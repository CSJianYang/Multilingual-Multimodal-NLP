[
    {
        "title": "Count Prefixes of a Given String",
        "question_content": "You are given a string array words and a string s, where words[i] and s comprise only of lowercase English letters.\nReturn the number of strings in words that are a prefix of s.\nA prefix of a string is a substring that occurs at the beginning of the string. A substring is a contiguous sequence of characters within a string.\n&nbsp;\nExample 1:\n\nInput: words = [\"a\",\"b\",\"c\",\"ab\",\"bc\",\"abc\"], s = \"abc\"\nOutput: 3\nExplanation:\nThe strings in words which are a prefix of s = \"abc\" are:\n\"a\", \"ab\", and \"abc\".\nThus the number of strings in words which are a prefix of s is 3.\nExample 2:\n\nInput: words = [\"a\",\"a\"], s = \"aa\"\nOutput: 2\nExplanation:\nBoth of the strings are a prefix of s. \nNote that the same string can occur multiple times in words, and it should be counted each time.\n&nbsp;\nConstraints:\n\n\t1 <= words.length <= 1000\n\t1 <= words[i].length, s.length <= 10\n\twords[i] and s consist of lowercase English letters only.",
        "solutions": [
            {
                "id": 1994777,
                "title": "java-c-python-starts-with",
                "content": "# **Explanation**\\nfor each word `w` in `words` list,\\ncheck if word `w` `startsWith` the string `s`\\n<br>\\n\\n# **Complexity**\\nTime `O(NS)`\\nSpace `O(1)`\\n<br>\\n\\n**Java**\\n```java\\n    public int countPrefixes(String[] words, String s) {\\n        int res = 0;\\n        for (String w : words)\\n            if (s.startsWith(w))\\n                res++;\\n        return res;\\n    }\\n```\\n\\n**C++**\\nTime O(NWS)\\n```cpp\\n    int countPrefixes(vector<string>& words, string s) {\\n        int res = 0;\\n        for (auto& w : words)\\n            res += s.find(w) < 1;\\n        return res; \\n    }\\n```\\n\\n**C++**\\nSuggested by @mzchen\\n```cpp\\n    int countPrefixes(vector<string>& words, string s) {\\n        int res = 0;\\n        for (auto& w : words)\\n            res += !s.compare(0, w.size(), w);\\n        return res;\\n    }\\n```\\n\\n**Python**\\n```py\\n    def countPrefixes(self, words, s):\\n        return sum(map(s.startswith, words))\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```java\\n    public int countPrefixes(String[] words, String s) {\\n        int res = 0;\\n        for (String w : words)\\n            if (s.startsWith(w))\\n                res++;\\n        return res;\\n    }\\n```\n```cpp\\n    int countPrefixes(vector<string>& words, string s) {\\n        int res = 0;\\n        for (auto& w : words)\\n            res += s.find(w) < 1;\\n        return res; \\n    }\\n```\n```cpp\\n    int countPrefixes(vector<string>& words, string s) {\\n        int res = 0;\\n        for (auto& w : words)\\n            res += !s.compare(0, w.size(), w);\\n        return res;\\n    }\\n```\n```py\\n    def countPrefixes(self, words, s):\\n        return sum(map(s.startswith, words))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1994746,
                "title": "c-easy-o-nxs-solution-string",
                "content": "```\\nclass Solution {\\npublic:\\n    //iterate over each words[i] and take the sub-string str from s of size equals to words[i].\\n    //and compare str with words[i] if both are equal increase count by 1.\\n    int countPrefixes(vector<string>& words, string s) \\n    {\\n        int count=0;\\n        for(auto it: words)\\n        {\\n            string str = s.substr(0, it.size());\\n            if(str == it) count++;            \\n        }\\n        return count;        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //iterate over each words[i] and take the sub-string str from s of size equals to words[i].\\n    //and compare str with words[i] if both are equal increase count by 1.\\n    int countPrefixes(vector<string>& words, string s) \\n    {\\n        int count=0;\\n        for(auto it: words)\\n        {\\n            string str = s.substr(0, it.size());\\n            if(str == it) count++;            \\n        }\\n        return count;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1997418,
                "title": "java-1-liner",
                "content": "```java\\npublic int countPrefixes(String[] words, String s) {\\n        return (int) Arrays.stream(words).filter(s::startsWith).count();\\n    }\\n```\\n\\nMy repositories with leetcode problems solving - [Java](https://github.com/FLlGHT/algorithms/tree/master/j-algorithms/src/main/java),  [C++](https://github.com/FLlGHT/algorithms/tree/master/c-algorithms/src/main/c%2B%2B)",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\npublic int countPrefixes(String[] words, String s) {\\n        return (int) Arrays.stream(words).filter(s::startsWith).count();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2076295,
                "title": "easy-python-solution",
                "content": "```\\nclass Solution:\\n    def countPrefixes(self, words: List[str], s: str) -> int:\\n        count=0\\n        for i in words:\\n            if (s[:len(i)]==i):\\n                count+=1\\n        return count\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countPrefixes(self, words: List[str], s: str) -> int:\\n        count=0\\n        for i in words:\\n            if (s[:len(i)]==i):\\n                count+=1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1994712,
                "title": "c-easy-to-understand-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) \\n    {\\n        int counter = 0;\\n        \\n        for(int i=0;i<words.size();i++)\\n        {\\n            if(words[i] == s.substr(0,words[i].size()))  \\n                counter++;\\n        }\\n\\n        return counter;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) \\n    {\\n        int counter = 0;\\n        \\n        for(int i=0;i<words.size();i++)\\n        {\\n            if(words[i] == s.substr(0,words[i].size()))  \\n                counter++;\\n        }\\n\\n        return counter;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1999377,
                "title": "count-if",
                "content": "**C++**\\n```cpp\\nint countPrefixes(vector<string>& words, string s) {\\n    return count_if(begin(words), end(words), [&](const auto &w){ return s.compare(0, w.size(), w) == 0; });\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint countPrefixes(vector<string>& words, string s) {\\n    return count_if(begin(words), end(words), [&](const auto &w){ return s.compare(0, w.size(), w) == 0; });\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1994767,
                "title": "2-lines-c-java",
                "content": "Apply **find()** in case of c++ and **indexof()** in case of java on every word and check if return position is 0.\\nReturn the count of such strings.\\n# C++\\n    int countPrefixes(vector<string>& words, string s, int cnt=0){\\n        for(auto i:words) if(s.find(i)==0) cnt++;\\n        return cnt;\\n    }\\n\\t\\n# Java\\n    public int countPrefixes(String[] words, String s) {\\n        int cnt=0;\\n        for(var i:words) if(s.indexOf(i)==0) cnt++;\\n        return cnt;\\n    }",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "Apply **find()** in case of c++ and **indexof()** in case of java on every word and check if return position is 0.\\nReturn the count of such strings.\\n# C++\\n    int countPrefixes(vector<string>& words, string s, int cnt=0){\\n        for(auto i:words) if(s.find(i)==0) cnt++;\\n        return cnt;\\n    }\\n\\t\\n# Java\\n    public int countPrefixes(String[] words, String s) {\\n        int cnt=0;\\n        for(var i:words) if(s.indexOf(i)==0) cnt++;\\n        return cnt;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1994720,
                "title": "c-basic-string-understanding",
                "content": "```\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) {\\n        int cnt = 0;\\n        int i, j;\\n        for(i=0; i<words.size(); i++){\\n            j = 0;\\n            while(j< words[i].size()){\\n                if(words[i][j] != s[j])\\n                    break;\\n                j++;\\n            }\\n            if(j == words[i].size())\\n                cnt++;\\n        }\\n        \\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) {\\n        int cnt = 0;\\n        int i, j;\\n        for(i=0; i<words.size(); i++){\\n            j = 0;\\n            while(j< words[i].size()){\\n                if(words[i][j] != s[j])\\n                    break;\\n                j++;\\n            }\\n            if(j == words[i].size())\\n                cnt++;\\n        }\\n        \\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3003590,
                "title": "python-simple-solution",
                "content": "# Approach\\nCheck for each word if is prefix of s.\\n\\n# Code\\n```\\nclass Solution:\\n    def countPrefixes(self, words: List[str], s: str) -> int:\\n        res = 0\\n\\n        for word in words:\\n            if s.startswith(word):\\n                res += 1\\n\\n        return res\\n```\\n\\nLike it? Please upvote!",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countPrefixes(self, words: List[str], s: str) -> int:\\n        res = 0\\n\\n        for word in words:\\n            if s.startswith(word):\\n                res += 1\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2726605,
                "title": "java-easy-to-understand-solution",
                "content": "```\\nclass Solution {\\n        public int countPrefixes(String[] words, String s) {\\n        \\n        int result = 0;\\n        for (int i=0; i<=s.length(); i++) {\\n            String x = s.substring(0, i);\\n            for (int j = 0; j<words.length; j++) {\\n                if (x.equals(words[j]))\\n                    result++;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n        public int countPrefixes(String[] words, String s) {\\n        \\n        int result = 0;\\n        for (int i=0; i<=s.length(); i++) {\\n            String x = s.substring(0, i);\\n            for (int j = 0; j<words.length; j++) {\\n                if (x.equals(words[j]))\\n                    result++;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2461131,
                "title": "3-different-fastest-approaches-with-javascript-including-one-liner",
                "content": "// approach 1 \\n\\n```\\nvar countPrefixes = function(words, s) {\\n     let counter = 0\\n     for (let i = 0; i < words.length; i++) {\\n         if (words[i]) === s.slice(0,words[i].length)) {\\n            counter++\\n        }\\n     }\\n    return counter\\n};\\n```\\n\\n// one liner approach - 2\\n\\n```\\nvar countPrefixes = function(words, s) {\\n    return words.filter((word) => word === s.slice(0,word.length)).length;\\n};\\n```\\n\\n// approach 3\\n\\n```\\nvar countPrefixes = function(words, s) {\\n    return words.filter(data=> s.indexOf(data) == 0).length;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar countPrefixes = function(words, s) {\\n     let counter = 0\\n     for (let i = 0; i < words.length; i++) {\\n         if (words[i]) === s.slice(0,words[i].length)) {\\n            counter++\\n        }\\n     }\\n    return counter\\n};\\n```\n```\\nvar countPrefixes = function(words, s) {\\n    return words.filter((word) => word === s.slice(0,word.length)).length;\\n};\\n```\n```\\nvar countPrefixes = function(words, s) {\\n    return words.filter(data=> s.indexOf(data) == 0).length;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2084421,
                "title": "straightforward-javascript-solution-faster-than-96-67",
                "content": "```\\nvar countPrefixes = function(words, s) {\\n    let count = 0;\\n    for (let word of words) {\\n        if (s.startsWith(word)) count++\\n    } return count;\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/9ebdaad0-0ac6-40e8-98da-26c37a70fab5_1653758537.70002.png)\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar countPrefixes = function(words, s) {\\n    let count = 0;\\n    for (let word of words) {\\n        if (s.startsWith(word)) count++\\n    } return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2008421,
                "title": "js-easiest-way",
                "content": "```\\nvar countPrefixes = function(words, s) {\\n  \\n    let cont = 0;\\n    \\n    for(i = 0; i < words.length; i++){\\n        for(j = 1; j <= s.length; j++){\\n            if(words[i] == s.slice(0, j)){\\n                cont++;\\n            }\\n        }        \\n    }\\n     return cont;\\n    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar countPrefixes = function(words, s) {\\n  \\n    let cont = 0;\\n    \\n    for(i = 0; i < words.length; i++){\\n        for(j = 1; j <= s.length; j++){\\n            if(words[i] == s.slice(0, j)){\\n                cont++;\\n            }\\n        }        \\n    }\\n     return cont;\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1994686,
                "title": "python-straightforward-with-startswith",
                "content": "```\\ndef countPrefixes(self, words: List[str], s: str) -> int:\\n\\n    c = 0\\n    for w in words:\\n        if s.startswith(w):\\n            c += 1\\n\\n    return c\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef countPrefixes(self, words: List[str], s: str) -> int:\\n\\n    c = 0\\n    for w in words:\\n        if s.startswith(w):\\n            c += 1\\n\\n    return c\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3955799,
                "title": "java-100-beats-2-solutions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:0(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:0(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countPrefixes(String[] words, String s) {\\n        int count = 0;\\n        for (String i : words)\\n            if (s.startsWith(i)) count++;\\n        return count;\\n\\n\\n//                          Another solution\\n\\n        // int count = 0;\\n        // int low = 0;\\n        // for(int i=1; i<=s.length(); i++){\\n        //    for(int j=0; j<words.length; j++){\\n        //        if(words[j].equals(s.substring(low,i))){\\n        //           count++;\\n        //        } \\n        //    }\\n        // }\\n        // return count;\\n    } \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "String Matching"
                ],
                "code": "```\\nclass Solution {\\n    public int countPrefixes(String[] words, String s) {\\n        int count = 0;\\n        for (String i : words)\\n            if (s.startsWith(i)) count++;\\n        return count;\\n\\n\\n//                          Another solution\\n\\n        // int count = 0;\\n        // int low = 0;\\n        // for(int i=1; i<=s.length(); i++){\\n        //    for(int j=0; j<words.length; j++){\\n        //        if(words[j].equals(s.substring(low,i))){\\n        //           count++;\\n        //        } \\n        //    }\\n        // }\\n        // return count;\\n    } \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1994877,
                "title": "c-simple-solution-using-substr",
                "content": "```\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) {\\n        int n = words.size();\\n        int cnt = 0;\\n        for(int i=0; i<n; i++) {\\n            string str = words[i];\\n            if(str == s.substr(0, str.size())) cnt++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) {\\n        int n = words.size();\\n        int cnt = 0;\\n        for(int i=0; i<n; i++) {\\n            string str = words[i];\\n            if(str == s.substr(0, str.size())) cnt++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1994683,
                "title": "java-easy-appraoch",
                "content": "```\\nclass Solution {\\n    public int countPrefixes(String[] words, String s) {\\n        int i = 0;\\n        int j = 0;\\n        int count = 0;\\n        for(int k = 0; k < words.length; k++){\\n            if(words[k].length() > s.length()){\\n                continue;\\n            }\\n            \\n            while(i < words[k].length() && words[k].charAt(i) == s.charAt(j)){\\n                i++;\\n                j++;\\n            }\\n            if(i == words[k].length()){\\n                count++;\\n            }\\n            i = 0;\\n            j = 0;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int countPrefixes(String[] words, String s) {\\n        int i = 0;\\n        int j = 0;\\n        int count = 0;\\n        for(int k = 0; k < words.length; k++){\\n            if(words[k].length() > s.length()){\\n                continue;\\n            }\\n            \\n            while(i < words[k].length() && words[k].charAt(i) == s.charAt(j)){\\n                i++;\\n                j++;\\n            }\\n            if(i == words[k].length()){\\n                count++;\\n            }\\n            i = 0;\\n            j = 0;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1994652,
                "title": "best-solution-using-set-easy-to-understand",
                "content": "Approach\\nStep 1 : Define a map and empty stirng\\nStep2 : insert prefixes in map\\nStep3 : check how many array of words element is present in map\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) {\\n        unordered_set<string> mp;\\n        string st = \"\";\\n        for(int i=0;i<s.length();i++){\\n            st += s[i];\\n            mp.insert(st);\\n        }\\n        int k=0;\\n        for(auto it:words){\\n            if(mp.count(it)){\\n                k++;\\n            }\\n        }\\n        return k;\\n    }\\n};\\n```\\n\\n# ****PLEASE UPVOTE",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) {\\n        unordered_set<string> mp;\\n        string st = \"\";\\n        for(int i=0;i<s.length();i++){\\n            st += s[i];\\n            mp.insert(st);\\n        }\\n        int k=0;\\n        for(auto it:words){\\n            if(mp.count(it)){\\n                k++;\\n            }\\n        }\\n        return k;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2864115,
                "title": "c-3-line-solution",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\t//time:O(n), space: O(1)\\n\\t\\tint countPrefixes(vector<string>& words, string s) {\\n\\t\\t\\tint count = 0;\\n\\t\\t\\tfor(auto wd : words)\\n\\t\\t\\t\\tif(s.find(wd) < 1) count++; //if first occurrence of sub-string is in the specified string\\n\\t\\t\\treturn count;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\t//time:O(n), space: O(1)\\n\\t\\tint countPrefixes(vector<string>& words, string s) {\\n\\t\\t\\tint count = 0;\\n\\t\\t\\tfor(auto wd : words)\\n\\t\\t\\t\\tif(s.find(wd) < 1) count++; //if first occurrence of sub-string is in the specified string\\n\\t\\t\\treturn count;\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 3583196,
                "title": "one-line-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def countPrefixes(self, words: List[str], s: str) -> int:\\n       return sum(1 for x in words if s.startswith(x))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countPrefixes(self, words: List[str], s: str) -> int:\\n       return sum(1 for x in words if s.startswith(x))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2965007,
                "title": "python3-code",
                "content": "# Code\\n```\\nclass Solution:\\n    def countPrefixes(self, words: List[str], s: str) -> int:\\n        return len([word for word in words if s.startswith(word)])\\n```\\n\\n![image.png](https://assets.leetcode.com/users/images/7ded423d-5651-41aa-8a7e-b8343efb856e_1672271463.1473987.png)\\n![image.png](https://assets.leetcode.com/users/images/65605e1b-564a-4ea3-8bf0-acad0d5862ea_1672271490.074425.png)",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countPrefixes(self, words: List[str], s: str) -> int:\\n        return len([word for word in words if s.startswith(word)])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2938964,
                "title": "easy-and-fast-c-solution",
                "content": "# Approach\\nUsing **s.find(words[i])** function which returns the index of words[i] if it is present in the string s , and to check whether words[i] occurs as a prefix use **s.find(words[i])==0**  ( since prefix always occurs at index 0).\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) {\\n\\n      int countPrefix = 0;\\n\\n      for(int i=0;i<words.size();++i){\\n          if(s.find(words[i])!=string::npos && s.find(words[i])==0){\\n              countPrefix++;\\n          }\\n      }  \\n      return countPrefix;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) {\\n\\n      int countPrefix = 0;\\n\\n      for(int i=0;i<words.size();++i){\\n          if(s.find(words[i])!=string::npos && s.find(words[i])==0){\\n              countPrefix++;\\n          }\\n      }  \\n      return countPrefix;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2768430,
                "title": "easy-o-n-maintain-a-set",
                "content": "We maintian a set called seen and add all the prefixes in the set and then simply check if the word in word list is present in the set or not\\n\\n***Leave an upvote if this helps!!!***\\n```\\nclass Solution:\\n    def countPrefixes(self, words: List[str], s: str) -> int:\\n        seen=set()\\n        count=0\\n        for i in range(1,len(s)+1):\\n            seen.add(s[:i])\\n        for i in words:\\n            if i in seen:\\n                count+=1\\n        return count\\n```",
                "solutionTags": [
                    "Python",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution:\\n    def countPrefixes(self, words: List[str], s: str) -> int:\\n        seen=set()\\n        count=0\\n        for i in range(1,len(s)+1):\\n            seen.add(s[:i])\\n        for i in words:\\n            if i in seen:\\n                count+=1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2048968,
                "title": "easy-python-solution",
                "content": "```\\ndef countPrefixes(self, words: List[str], s: str) -> int:\\n        c=0\\n        for i in words:\\n            l=len(i)\\n            if i==s[:l]:\\n                c+=1\\n        return c\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef countPrefixes(self, words: List[str], s: str) -> int:\\n        c=0\\n        for i in words:\\n            l=len(i)\\n            if i==s[:l]:\\n                c+=1\\n        return c\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1995252,
                "title": "c-online-with-std-count-if-and-string-rfind",
                "content": "This [stackover flow post](https://stackoverflow.com/questions/1878001/how-do-i-check-if-a-c-stdstring-starts-with-a-certain-string-and-convert-a) descrives how to you ```string::rfind``` to implement ```startsWith```, which leads to following over all code to solve to problem.\\n\\n```\\nint countPrefixes(const vector<string>& ws, const string& s) {\\n    return count_if(begin(ws), end(ws), [&](const string& w) { return s.rfind(w, 0) == 0; });\\n}\\n```\\n\\nOne might was well could use ```string::compare``` to solve the problem as well:\\n\\n```\\nint countPrefixes(const vector<string>& ws, const string& s) {\\n    return count_if(begin(ws), end(ws), [&](const string& w) {\\n        return s.compare(0, size(w), w) == 0;\\n    });\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```string::rfind```\n```startsWith```\n```\\nint countPrefixes(const vector<string>& ws, const string& s) {\\n    return count_if(begin(ws), end(ws), [&](const string& w) { return s.rfind(w, 0) == 0; });\\n}\\n```\n```string::compare```\n```\\nint countPrefixes(const vector<string>& ws, const string& s) {\\n    return count_if(begin(ws), end(ws), [&](const string& w) {\\n        return s.compare(0, size(w), w) == 0;\\n    });\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1995152,
                "title": "c-5-lines-code-very-easy-o-n-solution",
                "content": "```\\nint countPrefixes(vector<string>& words, string s) {\\n       int c=0;\\n       for(string str:words){\\n            int len=str.length();\\n           string subs=s.substr(0,len);\\n           if(str==subs){\\n                c++;\\n           }\\n       } \\n       return c;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String",
                    "Iterator"
                ],
                "code": "```\\nint countPrefixes(vector<string>& words, string s) {\\n       int c=0;\\n       for(string str:words){\\n            int len=str.length();\\n           string subs=s.substr(0,len);\\n           if(str==subs){\\n                c++;\\n           }\\n       } \\n       return c;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1994752,
                "title": "java",
                "content": "int ans=0;\\n        HashMap<String,Integer> l=new HashMap<>();\\n        for(String str:words)\\n            l.put(str,l.getOrDefault(str,0)+1);\\n        for(int i=0;i<=s.length();i++)\\n        {\\n            String st=s.substring(0,i);\\n            if(l.containsKey(st))\\n                ans=ans+l.get(st);\\n        }\\n        return ans;",
                "solutionTags": [
                    "Java"
                ],
                "code": "int ans=0;\\n        HashMap<String,Integer> l=new HashMap<>();\\n        for(String str:words)\\n            l.put(str,l.getOrDefault(str,0)+1);\\n        for(int i=0;i<=s.length();i++)\\n        {\\n            String st=s.substring(0,i);\\n            if(l.containsKey(st))\\n                ans=ans+l.get(st);\\n        }\\n        return ans;",
                "codeTag": "Unknown"
            },
            {
                "id": 3827383,
                "title": "python-one-line-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def countPrefixes(self, words: List[str], s: str) -> int:\\n        return len([i for i in words if s.startswith(i)])\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countPrefixes(self, words: List[str], s: str) -> int:\\n        return len([i for i in words if s.startswith(i)])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3534504,
                "title": "simple-easy-100-java-solution",
                "content": "\\n```\\nclass Solution {\\n    public int countPrefixes(String[] words, String s) {\\n        int count=0;\\n        for(String word: words){\\n            if(s.startsWith(word)) count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\n    public int countPrefixes(String[] words, String s) {\\n        int count=0;\\n        for(String word: words){\\n            if(s.startsWith(word)) count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3450978,
                "title": "easy-to-understand",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n        if it starts with element present in array count++;\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countPrefixes(String[] words, String s) {\\n        int count=0;\\n\\n        for(String word: words){\\n            if(s.startsWith(word)) count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countPrefixes(String[] words, String s) {\\n        int count=0;\\n\\n        for(String word: words){\\n            if(s.startsWith(word)) count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3443668,
                "title": "simple-using-substr-c",
                "content": "`Please Upvote If you Like the Solution !!!`\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) {\\n        int ans = 0;\\n        for(auto &w : words) {\\n            int n = w.size();\\n            if(s.substr(0,n) == w) ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) {\\n        int ans = 0;\\n        for(auto &w : words) {\\n            int n = w.size();\\n            if(s.substr(0,n) == w) ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3362962,
                "title": "simple-java-3-line-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countPrefixes(String[] words, String s) {\\n        int count = 0;\\n        for(int i =0; i<words.length; i++){\\n            if(s.startsWith(words[i])) count++;\\n        }\\n        return count;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countPrefixes(String[] words, String s) {\\n        int count = 0;\\n        for(int i =0; i<words.length; i++){\\n            if(s.startsWith(words[i])) count++;\\n        }\\n        return count;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3337621,
                "title": "esay-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countPrefixes(String[] words, String s) {\\n        int c=0;\\n        while(s.length()!=0){\\n        for(String y:words){\\n             if(y.equals(s))\\n             c++;\\n        }\\n        s=s.substring(0,s.length()-1); //Decreasing the length by 1\\n        }\\n        return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countPrefixes(String[] words, String s) {\\n        int c=0;\\n        while(s.length()!=0){\\n        for(String y:words){\\n             if(y.equals(s))\\n             c++;\\n        }\\n        s=s.substring(0,s.length()-1); //Decreasing the length by 1\\n        }\\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3278881,
                "title": "c-easy-simple",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) {\\n        int count = 0;\\n        for (string word : words)\\n        {\\n            if(s.find(word) == 0) \\n            { \\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) {\\n        int count = 0;\\n        for (string word : words)\\n        {\\n            if(s.find(word) == 0) \\n            { \\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3176731,
                "title": "simple-c-code-easy-beats-100",
                "content": "\\n\\nRuntime: Beats 100%\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) {\\n        int c=0;\\n        for(auto j:words){\\n            int b=1;\\n            for(int i=0;i<j.size();i++){\\n                if(j[i]!=s[i]){\\n                    b=0;\\n                    break;\\n                }\\n            }\\n            if(b==1){\\n                    c++;\\n                }\\n        }\\n        return c;\\n    }\\n};\\n```\\nHope you liked the implementation of the code, if you like it feel free to upvote \\uD83D\\uDC4D",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) {\\n        int c=0;\\n        for(auto j:words){\\n            int b=1;\\n            for(int i=0;i<j.size();i++){\\n                if(j[i]!=s[i]){\\n                    b=0;\\n                    break;\\n                }\\n            }\\n            if(b==1){\\n                    c++;\\n                }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3174986,
                "title": "c-o-n-simple-approach-using-string-s-find-func",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) {\\n\\n    int count = 0;\\n    for (int i = 0; i < words.size(); i++)\\n    {\\n        if (s.find(words[i])==0)\\n        {\\n            count++;\\n        }\\n    }\\n    return count;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) {\\n\\n    int count = 0;\\n    for (int i = 0; i < words.size(); i++)\\n    {\\n        if (s.find(words[i])==0)\\n        {\\n            count++;\\n        }\\n    }\\n    return count;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2868501,
                "title": "easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s)\\n    {\\n        string w = \"\" ;\\n        int count = 0 ;\\n        for(int i=0 ; i<words.size() ; i++)\\n        {\\n            w = words[i] ;\\n            int j ;\\n            for(j=0 ; j<w.size() ; j++)\\n            {\\n                if(w[j]!=s[j])\\n                {\\n                    break ;\\n                }\\n            }\\n            if(j==w.size())\\n            {\\n                count++ ;\\n            }\\n        }   \\n        return count ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s)\\n    {\\n        string w = \"\" ;\\n        int count = 0 ;\\n        for(int i=0 ; i<words.size() ; i++)\\n        {\\n            w = words[i] ;\\n            int j ;\\n            for(j=0 ; j<w.size() ; j++)\\n            {\\n                if(w[j]!=s[j])\\n                {\\n                    break ;\\n                }\\n            }\\n            if(j==w.size())\\n            {\\n                count++ ;\\n            }\\n        }   \\n        return count ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2701416,
                "title": "c-easy-approach-93-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) { \\n        int ans = 0;\\n        for(int i = 0 ; i<words.size() ; i++){\\n            string element = words[i];\\n            int len = element.length();\\n            \\n            for(int j = 0 ; j<len ; j++){\\n               \\n                if(element[j] != s[j]){\\n                    break;      \\n                }     \\n                if(j==len-1){\\n                    ans++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) { \\n        int ans = 0;\\n        for(int i = 0 ; i<words.size() ; i++){\\n            string element = words[i];\\n            int len = element.length();\\n            \\n            for(int j = 0 ; j<len ; j++){\\n               \\n                if(element[j] != s[j]){\\n                    break;      \\n                }     \\n                if(j==len-1){\\n                    ans++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2651729,
                "title": "startswith-in-java-java",
                "content": "```\\nif(you like)\\n\\tplease upvote;\\n```\\n![image.png](https://assets.leetcode.com/users/images/c46bfd5c-cd60-4a0f-a3af-d56e67ae236a_1664727810.0896583.png)\\n\\n# Java Code\\n```\\nclass Solution {\\n    public int countPrefixes(String[] words, String s) {\\n        int cnt = 0;\\n        for(String str:words)        \\n        {\\n            if(s.startsWith(str) == true)\\n                cnt++;\\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nif(you like)\\n\\tplease upvote;\\n```\n```\\nclass Solution {\\n    public int countPrefixes(String[] words, String s) {\\n        int cnt = 0;\\n        for(String str:words)        \\n        {\\n            if(s.startsWith(str) == true)\\n                cnt++;\\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2649512,
                "title": "python-solution",
                "content": "\\tclass Solution:\\n\\t\\tdef countPrefixes(self, words: List[str], s: str) -> int:\\n\\t\\t\\tres = 0\\n\\t\\t\\tfor word in words:\\n\\t\\t\\t\\tif s[:len(word)] == word: res += 1\\n\\t\\t\\treturn res",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef countPrefixes(self, words: List[str], s: str) -> int:\\n\\t\\t\\tres = 0\\n\\t\\t\\tfor word in words:\\n\\t\\t\\t\\tif s[:len(word)] == word: res += 1\\n\\t\\t\\treturn res",
                "codeTag": "Java"
            },
            {
                "id": 2566238,
                "title": "python-straight-forward-one-liner",
                "content": "Here is what I did:\\n\\n```python\\n    def countPrefixes(self, words: List[str], s: str) -> int:\\n        return sum(s.startswith(word) for word in words)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\n    def countPrefixes(self, words: List[str], s: str) -> int:\\n        return sum(s.startswith(word) for word in words)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2229509,
                "title": "javascript-straightforward-solution-simple-understandable-fast",
                "content": "**Runtime: 68 ms, faster than 91.85% of JavaScript online submissions for Count Prefixes of a Given String.\\nMemory Usage: 43 MB, less than 40.00% of JavaScript online submissions for Count Prefixes of a Given String.**\\n\\n```\\nvar countPrefixes = function(words, s) {\\n    let count = 0\\n    for (i of words) {\\n        if (s.startsWith(i)) {\\n            count++\\n        }\\n    } \\n    return count\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "String"
                ],
                "code": "```\\nvar countPrefixes = function(words, s) {\\n    let count = 0\\n    for (i of words) {\\n        if (s.startsWith(i)) {\\n            count++\\n        }\\n    } \\n    return count\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2007119,
                "title": "c-linq-one-line",
                "content": "```\\n\\tpublic int CountPrefixes(string[] words, string s) \\n        => words.Count(w => s.StartsWith(w));    \\n```",
                "solutionTags": [],
                "code": "```\\n\\tpublic int CountPrefixes(string[] words, string s) \\n        => words.Count(w => s.StartsWith(w));    \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1997642,
                "title": "rust-solutions",
                "content": "1. Simle use of `starts_with`:\\n```\\nimpl Solution {\\n    pub fn count_prefixes(words: Vec<String>, s: String) -> i32 {\\n        words.iter().filter(|w| s.starts_with(w.as_str())).count() as _\\n    }\\n}\\n```\\n2. Slice comparison\\n```\\nimpl Solution {\\n    pub fn count_prefixes(words: Vec<String>, s: String) -> i32 {\\n        words\\n            .iter()\\n            .filter(|w| w.len() <= s.len() && w.as_str() == &s[..w.len()])\\n            .count() as _\\n    }\\n}\\n```\\n3. Functional solution with `zip`:\\n```\\nimpl Solution {\\n    pub fn count_prefixes(words: Vec<String>, s: String) -> i32 {\\n        words\\n            .iter()\\n            .filter(|w| w.len() <= s.len() && w.chars().zip(s.chars()).all(|(a, b)| a == b))\\n            .count() as _\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn count_prefixes(words: Vec<String>, s: String) -> i32 {\\n        words.iter().filter(|w| s.starts_with(w.as_str())).count() as _\\n    }\\n}\\n```\n```\\nimpl Solution {\\n    pub fn count_prefixes(words: Vec<String>, s: String) -> i32 {\\n        words\\n            .iter()\\n            .filter(|w| w.len() <= s.len() && w.as_str() == &s[..w.len()])\\n            .count() as _\\n    }\\n}\\n```\n```\\nimpl Solution {\\n    pub fn count_prefixes(words: Vec<String>, s: String) -> i32 {\\n        words\\n            .iter()\\n            .filter(|w| w.len() <= s.len() && w.chars().zip(s.chars()).all(|(a, b)| a == b))\\n            .count() as _\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1995303,
                "title": "c-very-easy-to-understand-solution-using-unordered-set",
                "content": "```\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) {\\n        unordered_set<string> st;\\n        int size = s.size();\\n        for(int i = 0;i<size;i++){\\n            string temp = \"\";\\n            for(int j = 0;j<=i;j++){\\n                temp+=s[j];\\n            }\\n            st.insert(temp);\\n        }\\n        int ans = 0;\\n        for(int i = 0;i<words.size();i++){\\n            if(st.find(words[i])!=st.end())\\n                ans++;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) {\\n        unordered_set<string> st;\\n        int size = s.size();\\n        for(int i = 0;i<size;i++){\\n            string temp = \"\";\\n            for(int j = 0;j<=i;j++){\\n                temp+=s[j];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1994612,
                "title": "c-easy-to-understand-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) {\\n        int c=0;\\n        for(auto word:words)\\n        {\\n                string str=word;\\n                int l=word.size();\\n                string s2=s.substr(0,l);\\n                if(s2==word)\\n                    c++;\\n        }\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) {\\n        int c=0;\\n        for(auto word:words)\\n        {\\n                string str=word;\\n                int l=word.size();\\n                string s2=s.substr(0,l);\\n                if(s2==word)\\n                    c++;\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1994558,
                "title": "java-simple",
                "content": "```\\nclass Solution {\\n    public int countPrefixes(String[] words, String s) {\\n    \\n       int preFixCount=0;\\n       for(String curr:words){\\n           int i=0;\\n           \\n           if(curr.length()>s.length())     // if current  string length greater than s length invalid prefix\\n           continue; \\n           int j;\\n           for(j=0;j<curr.length();j++,i++){\\n               if(curr.charAt(j)==s.charAt(i))\\n               continue;\\n               else \\n               break;\\n                   \\n           }\\n           if(j==curr.length())             // if all character matches than mark valid \\n           preFixCount++;\\n       }\\n     return preFixCount;     \\n    }\\n   \\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int countPrefixes(String[] words, String s) {\\n    \\n       int preFixCount=0;\\n       for(String curr:words){\\n           int i=0;\\n           \\n           if(curr.length()>s.length())     // if current  string length greater than s length invalid prefix\\n           continue; \\n           int j;\\n           for(j=0;j<curr.length();j++,i++){\\n               if(curr.charAt(j)==s.charAt(i))\\n               continue;\\n               else \\n               break;\\n                   \\n           }",
                "codeTag": "Java"
            },
            {
                "id": 3972694,
                "title": "javascript-easy-one-line-solution",
                "content": "# Complexity\\n- Time complexity: O(n*m)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string[]} words\\n * @param {string} s\\n * @return {number}\\n */\\nvar countPrefixes = function (words, s) {\\n  return words.filter((item) => s.startsWith(item)).length\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} words\\n * @param {string} s\\n * @return {number}\\n */\\nvar countPrefixes = function (words, s) {\\n  return words.filter((item) => s.startsWith(item)).length\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3917786,
                "title": "go-easy",
                "content": "\\n\\n# Code\\n```\\nfunc countPrefixes(words []string, s string) int {\\n\\tvar count int\\n\\n\\tfor _, v := range words {\\n\\t\\tif strings.HasPrefix(s, v) {\\n\\t\\t\\tcount++\\n\\t\\t}\\n\\t}\\n\\n\\treturn count\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc countPrefixes(words []string, s string) int {\\n\\tvar count int\\n\\n\\tfor _, v := range words {\\n\\t\\tif strings.HasPrefix(s, v) {\\n\\t\\t\\tcount++\\n\\t\\t}\\n\\t}\\n\\n\\treturn count\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3297434,
                "title": "count-prefixes-of-a-given-string-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n*m)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) {\\n        int i, j, count=0;\\n        string str=\"\";\\n        for(i=0 ; i<s.length() ; i++)\\n        {\\n            str += s[i];\\n            for(j=0 ; j<words.size() ; j++)\\n            {\\n                if(str==words[j])\\n                {\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) {\\n        int i, j, count=0;\\n        string str=\"\";\\n        for(i=0 ; i<s.length() ; i++)\\n        {\\n            str += s[i];\\n            for(j=0 ; j<words.size() ; j++)\\n            {\\n                if(str==words[j])\\n                {\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3249714,
                "title": "pyhton3-oneliner-using-startswith",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def countPrefixes(self, words: List[str], s: str) -> int:\\n        count = 0\\n        for i in words:\\n            if s.startswith(i):\\n                count += 1\\n        return count\\n\\n        #One Liner\\n\\n        return sum(1 for i in words if s.startswith(i))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countPrefixes(self, words: List[str], s: str) -> int:\\n        count = 0\\n        for i in words:\\n            if s.startswith(i):\\n                count += 1\\n        return count\\n\\n        #One Liner\\n\\n        return sum(1 for i in words if s.startswith(i))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3149760,
                "title": "pooping-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nPoop the loop\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countPrefixes(self, words: List[str], s: str) -> int:\\n        c = 0\\n        for i in words:\\n            if i in s[:len(i)]:\\n                c+=1\\n        return c \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countPrefixes(self, words: List[str], s: str) -> int:\\n        c = 0\\n        for i in words:\\n            if i in s[:len(i)]:\\n                c+=1\\n        return c \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3114743,
                "title": "count-prefixes-of-a-given-string",
                "content": "```\\nint count=0;\\n        for(auto it:words){\\n            string str=s.substr(0,it.size());\\n            if(str==it)\\n            count++;\\n        }\\n        \\n        return count;\\n\\t\\t\\n```",
                "solutionTags": [
                    "C",
                    "Iterator"
                ],
                "code": "```\\nint count=0;\\n        for(auto it:words){\\n            string str=s.substr(0,it.size());\\n            if(str==it)\\n            count++;\\n        }\\n        \\n        return count;\\n\\t\\t\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2804300,
                "title": "count-prefixes-of-a-given-string-solution-java",
                "content": "class Solution {\\n  public int countPrefixes(String[] words, String s) {\\n    return (int) Arrays.stream(words).filter(word -> s.startsWith(word)).count();\\n  }\\n}\\n",
                "solutionTags": [
                    "Array",
                    "String"
                ],
                "code": "class Solution {\\n  public int countPrefixes(String[] words, String s) {\\n    return (int) Arrays.stream(words).filter(word -> s.startsWith(word)).count();\\n  }",
                "codeTag": "Java"
            },
            {
                "id": 2672445,
                "title": "java-solution-startswith-or-indexof",
                "content": "### Please Upvote :D\\n```\\nclass Solution {\\n    public int countPrefixes(String[] words, String s) {\\n        int count = 0;\\n        \\n        for (String str : words) {\\n            // if (s.indexOf(str) == 0) count++;\\n            if (s.startsWith(str)) count++;\\n        }\\n        \\n        return count;\\n    }\\n}\\n\\n// TC: O(n)\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countPrefixes(String[] words, String s) {\\n        int count = 0;\\n        \\n        for (String str : words) {\\n            // if (s.indexOf(str) == 0) count++;\\n            if (s.startsWith(str)) count++;\\n        }\\n        \\n        return count;\\n    }\\n}\\n\\n// TC: O(n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2651727,
                "title": "c-short-97-faster-than-all",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n     int countPrefixes(vector<string>& words, string s) {\\n        int count = 0;\\n        for(auto word:words){\\n            bool isPrefix = true;\\n            for(int i=0; i<word.length(); i++){\\n                if(word[i] != s[i]){\\n                    isPrefix = false;\\n                    break;\\n                }\\n            }\\n            if(isPrefix) count++;\\n        }\\n    return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n     int countPrefixes(vector<string>& words, string s) {\\n        int count = 0;\\n        for(auto word:words){\\n            bool isPrefix = true;\\n            for(int i=0; i<word.length(); i++){\\n                if(word[i] != s[i]){\\n                    isPrefix = false;\\n                    break;\\n                }\\n            }\\n            if(isPrefix) count++;\\n        }\\n    return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2626764,
                "title": "python-o-n",
                "content": "Time Complexcity O(N)\\nspace Complexcity O(1)\\n```\\nclass Solution:\\n    def countPrefixes(self, words: List[str], s: str) -> int:\\n        count=0\\n        for word in words:\\n            n=len(word)\\n            if s[0:n]==word:\\n                count+=1\\n        return count\\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def countPrefixes(self, words: List[str], s: str) -> int:\\n        count=0\\n        for word in words:\\n            n=len(word)\\n            if s[0:n]==word:\\n                count+=1\\n        return count\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2612849,
                "title": "java-soln",
                "content": "class Solution {\\n    public int countPrefixes(String[] words, String s) {\\n        \\n        int count =0;\\n        for(int i=0; i<words.length; i++){\\n         if(s.startsWith(words[i])){\\n             count++;\\n         }\\n        } \\n        return count;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int countPrefixes(String[] words, String s) {\\n        \\n        int count =0;\\n        for(int i=0; i<words.length; i++){\\n         if(s.startsWith(words[i])){\\n             count++;\\n         }",
                "codeTag": "Java"
            },
            {
                "id": 2601418,
                "title": "javascript-easy-solution",
                "content": "```\\n/**\\n * @param {string[]} words\\n * @param {string} s\\n * @return {number}\\n */\\nvar countPrefixes = function(words, s) {\\n    let count = 0;\\n    for(let i=0; i<words.length; i++) {\\n        if(words[i] === s.slice(0, words[i].length)) {\\n            count++;\\n        }\\n    }\\n    return count;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} words\\n * @param {string} s\\n * @return {number}\\n */\\nvar countPrefixes = function(words, s) {\\n    let count = 0;\\n    for(let i=0; i<words.length; i++) {\\n        if(words[i] === s.slice(0, words[i].length)) {\\n            count++;\\n        }\\n    }\\n    return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2561291,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) {\\n        int ct=0;\\n        for(string&word:words){\\n          bool flag=true;\\n          if(word.length()<=s.length()){\\n             for(int i=0; i<min(word.length(),s.length()); ++i){\\n                if(word[i]!=s[i]){\\n                   flag=false;\\n                   break;\\n                }\\n             }\\n            flag?ct++:ct+=0;\\n          }\\n        }\\n        return ct;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) {\\n        int ct=0;\\n        for(string&word:words){\\n          bool flag=true;\\n          if(word.length()<=s.length()){\\n             for(int i=0; i<min(word.length(),s.length()); ++i){\\n                if(word[i]!=s[i]){\\n                   flag=false;\\n                   break;\\n                }\\n             }\\n            flag?ct++:ct+=0;\\n          }\\n        }\\n        return ct;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2545761,
                "title": "count-prefixes-of-a-given-string",
                "content": "python3 sol\\n```\\nclass Solution:\\n    def countPrefixes(self, words: List[str], s: str) -> int:\\n        count= 0 \\n        for i in words:\\n            if i ==s:\\n                count+=1\\n            else:\\n                if i ==s[:len(i)]:\\n                    count+=1\\n        return count\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def countPrefixes(self, words: List[str], s: str) -> int:\\n        count= 0 \\n        for i in words:\\n            if i ==s:\\n                count+=1\\n            else:\\n                if i ==s[:len(i)]:\\n                    count+=1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2502759,
                "title": "easy-fast-short-solution",
                "content": "```\\nPLEASE UPVOTE IF YOU LIKE\\n```\\n```\\n        int count = 0;\\n        for(String temp: words)\\n            if (s.indexOf(temp) == 0)\\n                count++;\\n        return count;",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nPLEASE UPVOTE IF YOU LIKE\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2500078,
                "title": "c-solution-count-prefixes-of-a-given-string",
                "content": "```\\nclass Solution {\\nprivate:\\n    int linear_search(vector<string>& words , string prefix){\\n        int count = 0;\\n        for(int i = 0 ; i < words.size() ; i++){\\n            if(prefix == words[i])\\n                count++;\\n        }\\n        return count;\\n    }\\n    \\npublic:\\n    int countPrefixes(vector<string>& words, string s) {\\n        vector<string> prefix;\\n        int count = 0;\\n        \\n        for(int i = 1 ; i <= s.length() ; i++){\\n            prefix.push_back(s.substr(0,i));\\n        }\\n        \\n        \\n        for(int i = 0 ; i < prefix.size() ; i++){\\n            count = count + linear_search(words , prefix[i]);\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int linear_search(vector<string>& words , string prefix){\\n        int count = 0;\\n        for(int i = 0 ; i < words.size() ; i++){\\n            if(prefix == words[i])\\n                count++;\\n        }\\n        return count;\\n    }\\n    \\npublic:\\n    int countPrefixes(vector<string>& words, string s) {\\n        vector<string> prefix;\\n        int count = 0;\\n        \\n        for(int i = 1 ; i <= s.length() ; i++){\\n            prefix.push_back(s.substr(0,i));\\n        }\\n        \\n        \\n        for(int i = 0 ; i < prefix.size() ; i++){\\n            count = count + linear_search(words , prefix[i]);\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2498493,
                "title": "java-solution-easy-100",
                "content": "public static int prefixcount(String[] words, String s) {\\n        int out = 0;\\n\\n        for (int i = 0; i < words.length; i++) {\\n            if (s.startsWith(words[i])) {\\n                out++;\\n            }\\n        }\\n        return out;",
                "solutionTags": [],
                "code": "public static int prefixcount(String[] words, String s) {\\n        int out = 0;\\n\\n        for (int i = 0; i < words.length; i++) {\\n            if (s.startsWith(words[i])) {\\n                out++;\\n            }\\n        }\\n        return out;",
                "codeTag": "Unknown"
            },
            {
                "id": 2488556,
                "title": "runtime-22-ms-faster-than-18-45-of-c-online-submissions-for-count-prefixes-of-a-given-string",
                "content": "\\n    int count = 0;\\n    for (int i = 0; i < words.size(); i++)\\n    {\\n        if (s.find(words[i])==0)\\n        {\\n            count++;\\n        }\\n    }\\n    return count;\\n}\\n//   upvote if you like\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "\\n    int count = 0;\\n    for (int i = 0; i < words.size(); i++)\\n    {\\n        if (s.find(words[i])==0)\\n        {\\n            count++;\\n        }\\n    }\\n    return count;\\n}\\n//   upvote if you like\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2471556,
                "title": "java-solution-0ms-100-faster-easy-to-understand-linear-search-o-n",
                "content": "```\\nclass Solution {\\n    public int countPrefixes(String[] arr, String s) {\\n        int cnt = 0;\\n        for (String str : arr) {\\n            if (s.startsWith(str)) cnt++;\\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int countPrefixes(String[] arr, String s) {\\n        int cnt = 0;\\n        for (String str : arr) {\\n            if (s.startsWith(str)) cnt++;\\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2402405,
                "title": "easy-and-clear-solution-python3",
                "content": "```\\nclass Solution:\\n    def countPrefixes(self, words: List[str], s: str) -> int:\\n        count=0\\n        for word in words:\\n            if word == s[:len(word)]:\\n                count+=1\\n        return count\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countPrefixes(self, words: List[str], s: str) -> int:\\n        count=0\\n        for word in words:\\n            if word == s[:len(word)]:\\n                count+=1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2346554,
                "title": "c-brute-force-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) {\\n        string sk;\\n        bool istrue;\\n        int count=0;\\n        for(int i=0;i<words.size();i++){\\n            sk=words[i];\\n            for(int j=0;j<sk.length();j++){\\n                if(sk[j]!=s[j]){\\n                    istrue=false; \\n                    break;\\n                }\\n                else{\\n                     istrue=true;\\n                }\\n            }\\n            \\n            if(istrue==true){\\n                cout<<sk<<endl;\\n                count++;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) {\\n        string sk;\\n        bool istrue;\\n        int count=0;\\n        for(int i=0;i<words.size();i++){\\n            sk=words[i];\\n            for(int j=0;j<sk.length();j++){\\n                if(sk[j]!=s[j]){\\n                    istrue=false; \\n                    break;\\n                }\\n                else{\\n                     istrue=true;\\n                }\\n            }\\n            \\n            if(istrue==true){\\n                cout<<sk<<endl;\\n                count++;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2326109,
                "title": "one-liner-python",
                "content": "```\\nreturn sum([1 for word in words if s.startswith(word)])\\n```\\n**Please upvote if you want to see more one liners and simple solutions**",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nreturn sum([1 for word in words if s.startswith(word)])\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2308148,
                "title": "c-solution-easy-to-understand-one-line",
                "content": "```C#\\npublic class Solution {\\n    public int CountPrefixes(string[] words, string s) => words.Count(x => s.StartsWith(x));\\n}\\n```",
                "solutionTags": [],
                "code": "```C#\\npublic class Solution {\\n    public int CountPrefixes(string[] words, string s) => words.Count(x => s.StartsWith(x));\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2303504,
                "title": "cpp-trie-solution",
                "content": "```\\n class Trie{\\n        public:\\n        char c;\\n        Trie* ch[26];\\n        int we;\\n        Trie(char d){\\n            c=d;\\n            for(int i=0;i<26;i++) ch[i]=NULL;\\n            we=0;\\n        }\\n    };\\n    Trie* r=new Trie(\\'0\\');\\n    \\n    void add(string s){\\n        Trie* h=r;\\n        for(int i=0;i<s.size();i++){\\n            int ind=s[i]-\\'a\\';\\n            h->ch[ind]=new Trie(s[i]);\\n            h=h->ch[ind];\\n        }\\n        h->we=1;\\n    }\\n    \\n    bool check(string s){\\n        Trie* h=r;\\n        for(int i=0;i<s.size();i++){\\n            int ind=s[i]-\\'a\\';\\n            if(h->ch[ind]==NULL) return 0;\\n            h=h->ch[ind];\\n        }\\n        return 1;\\n    }\\n    int countPrefixes(vector<string>& words, string s) {\\n        add(s);\\n        int ans=0;\\n        for(int i=0;i<words.size();i++){\\n            if(check(words[i])){\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "String",
                    "Trie"
                ],
                "code": "```\\n class Trie{\\n        public:\\n        char c;\\n        Trie* ch[26];\\n        int we;\\n        Trie(char d){\\n            c=d;\\n            for(int i=0;i<26;i++) ch[i]=NULL;\\n            we=0;\\n        }\\n    };\\n    Trie* r=new Trie(\\'0\\');\\n    \\n    void add(string s){\\n        Trie* h=r;\\n        for(int i=0;i<s.size();i++){\\n            int ind=s[i]-\\'a\\';\\n            h->ch[ind]=new Trie(s[i]);\\n            h=h->ch[ind];\\n        }\\n        h->we=1;\\n    }\\n    \\n    bool check(string s){\\n        Trie* h=r;\\n        for(int i=0;i<s.size();i++){\\n            int ind=s[i]-\\'a\\';\\n            if(h->ch[ind]==NULL) return 0;\\n            h=h->ch[ind];\\n        }\\n        return 1;\\n    }\\n    int countPrefixes(vector<string>& words, string s) {\\n        add(s);\\n        int ans=0;\\n        for(int i=0;i<words.size();i++){\\n            if(check(words[i])){\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2200749,
                "title": "python-straightforward",
                "content": "```\\nclass Solution:\\n    def countPrefixes(self, words: List[str], s: str) -> int:\\n        countPrefixe = 0\\n        for word in words:\\n            if word in s and word == s[:len(word)]:\\n                countPrefixe += 1\\n        return countPrefixe\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def countPrefixes(self, words: List[str], s: str) -> int:\\n        countPrefixe = 0\\n        for word in words:\\n            if word in s and word == s[:len(word)]:\\n                countPrefixe += 1\\n        return countPrefixe\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2197461,
                "title": "javascript-solution-with-foreach",
                "content": "```\\nvar countPrefixes = function(words, s) {    \\n\\n    let count = 0; \\n\\t\\n    words.forEach((word) => {\\n        if( s.startsWith(word) ) \\n\\t\\t\\tcount++;\\n    });\\n    \\n    return count;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar countPrefixes = function(words, s) {    \\n\\n    let count = 0; \\n\\t\\n    words.forEach((word) => {\\n        if( s.startsWith(word) ) \\n\\t\\t\\tcount++;\\n    });\\n    \\n    return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2191967,
                "title": "my-easy-to-understand-2ms-java-code",
                "content": "```\\nclass Solution \\n{\\n    public int countPrefixes(String[] words, String s) \\n    {\\n        int c=0;\\n        for(String i:words)\\n        {\\n            if(s.startsWith(i))\\n            {\\n                c++;\\n            }\\n        }\\n        return c;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution \\n{\\n    public int countPrefixes(String[] words, String s) \\n    {\\n        int c=0;\\n        for(String i:words)\\n        {\\n            if(s.startsWith(i))\\n            {\\n                c++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2181067,
                "title": "python-trie-for-fast-queries",
                "content": "Prefix Tree aka Trie might be an overkill for this easy problem, but when you are not allowed to use startswith and need to reduce time complexity of multiple queries it\\'s a good option - linear scan of path to get sum of all words on the path.\\n\\n```\\nclass Node(object):\\n    def __init__(self):\\n        self.children = {}\\n        self.is_word = False\\n        self.count = 0\\n\\nclass Solution:\\n    def countPrefixes(self, words: List[str], s: str) -> int:\\n        root = Node()\\n        \\n        # build a trie\\n        for w in words:\\n            node = root\\n            for c in w:\\n                if c not in node.children:\\n                    node.children[c] = Node()\\n                node = node.children[c]\\n            node.count = 1 if not node.is_word else node.count + 1\\n            node.is_word = True\\n        \\n        # count prefix-words in s\\n        node = root\\n\\n        res = 0\\n        for c in s:\\n            if c in node.children:\\n                node = node.children[c]\\n                res += node.count if node.is_word else 0\\n            else:\\n                break\\n                \\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Trie"
                ],
                "code": "```\\nclass Node(object):\\n    def __init__(self):\\n        self.children = {}\\n        self.is_word = False\\n        self.count = 0\\n\\nclass Solution:\\n    def countPrefixes(self, words: List[str], s: str) -> int:\\n        root = Node()\\n        \\n        # build a trie\\n        for w in words:\\n            node = root\\n            for c in w:\\n                if c not in node.children:\\n                    node.children[c] = Node()\\n                node = node.children[c]\\n            node.count = 1 if not node.is_word else node.count + 1\\n            node.is_word = True\\n        \\n        # count prefix-words in s\\n        node = root\\n\\n        res = 0\\n        for c in s:\\n            if c in node.children:\\n                node = node.children[c]\\n                res += node.count if node.is_word else 0\\n            else:\\n                break\\n                \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2147734,
                "title": "c-simple-solution",
                "content": "class Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) {\\n        int ans=0;\\n        for(auto w : words)\\n        {\\n            int count=0;\\n            for(int i=0;i<w.length();i++)\\n            {\\n               if(w[i]==s[i])\\n                   count++; \\n            }\\n            if(count==w.length())\\n                ans++;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) {\\n        int ans=0;\\n        for(auto w : words)\\n        {\\n            int count=0;\\n            for(int i=0;i<w.length();i++)\\n            {\\n               if(w[i]==s[i])\\n                   count++; \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2143292,
                "title": "c-very-easy-solution-using-sets",
                "content": "```\\nint countPrefixes(vector<string>& words, string s) {\\n        int count = 0;\\n        set<string>ss;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            ss.insert(s.substr(0,i+1));\\n        }\\n        for(int i=0;i<words.size();i++)\\n        {\\n            if(ss.find(words[i])!=ss.end())\\n                count++;\\n        }\\n        return count;\\n    }",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nint countPrefixes(vector<string>& words, string s) {\\n        int count = 0;\\n        set<string>ss;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            ss.insert(s.substr(0,i+1));\\n        }\\n        for(int i=0;i<words.size();i++)\\n        {\\n            if(ss.find(words[i])!=ss.end())\\n                count++;\\n        }\\n        return count;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2140038,
                "title": "c-easy-traversal",
                "content": "```\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) {\\n       unordered_map<string,int>harsh;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            harsh[s.substr(0,i+1)]++;\\n        }\\n        int cnt=0;\\n        for(auto val:words)\\n        {\\n            if(harsh.find(val) != harsh.end())\\n            {\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) {\\n       unordered_map<string,int>harsh;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            harsh[s.substr(0,i+1)]++;\\n        }\\n        int cnt=0;\\n        for(auto val:words)\\n        {\\n            if(harsh.find(val) != harsh.end())\\n            {\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2132698,
                "title": "easy-java-solution-faster-100",
                "content": "```\\nclass Solution {\\n    public int countPrefixes(String[] words, String s) {\\n        int sum = 0;\\n        for(int i=0;i<words.length;i++){\\n            if(s.startsWith(words[i])){\\n                sum++;\\n            }\\n        }\\n        \\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int countPrefixes(String[] words, String s) {\\n        int sum = 0;\\n        for(int i=0;i<words.length;i++){\\n            if(s.startsWith(words[i])){\\n                sum++;\\n            }\\n        }\\n        \\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2098364,
                "title": "python-easy-beginer-friendly",
                "content": "```\\nclass Solution:\\n    def countPrefixes(self, a: List[str], s: str) -> int:\\n        r=0\\n        for i in a:\\n            if len(i)<=len(s) and i==s[:len(i)]:\\n                r+=1\\n        return r\\n```\\n![image](https://assets.leetcode.com/users/images/c570329e-69a5-4674-aff5-3562d8a29ea8_1654088247.904313.jpeg)\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def countPrefixes(self, a: List[str], s: str) -> int:\\n        r=0\\n        for i in a:\\n            if len(i)<=len(s) and i==s[:len(i)]:\\n                r+=1\\n        return r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2070262,
                "title": "fastest-java-solution-0ms",
                "content": "```\\nclass Solution {\\n    public int countPrefixes(String[] words, String s) {\\n        int c = 0;\\n        for(String word:words)\\n            if(s.startsWith(word))\\n                c++;\\n        return c;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int countPrefixes(String[] words, String s) {\\n        int c = 0;\\n        for(String word:words)\\n            if(s.startsWith(word))\\n                c++;\\n        return c;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2048287,
                "title": "python3-two-1-liners",
                "content": "class Solution:\\n    def countPrefixes(self, words: List[str], s: str) -> int:\\n        \\n        return sum(word == s[:len(word)] for word in words)\\n\\nclass Solution:\\n    def countPrefixes(self, words: List[str], s: str) -> int:\\n\\t\\n        return sum(s.find(word) == 0 for word in words)",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution:\\n    def countPrefixes(self, words: List[str], s: str) -> int:\\n        \\n        return sum(word == s[:len(word)] for word in words)\\n\\nclass Solution:\\n    def countPrefixes(self, words: List[str], s: str) -> int:\\n\\t\\n        return sum(s.find(word) == 0 for word in words)",
                "codeTag": "Java"
            },
            {
                "id": 2037971,
                "title": "c-easy-solution",
                "content": "class Solution {\\npublic:\\n    int countPrefixes(vector<string>& w, string s) {\\n        int res=0;\\n        for(int i=0;i<w.size();i++)\\n        {\\n            int flag=0;\\n            for(int j=0;j<w[i].size();j++)\\n            {\\n                if(w[i][j]!=s[j])\\n                    flag=1;\\n            }\\n            if (flag==0)\\n                res++;\\n        }\\n        return res;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int countPrefixes(vector<string>& w, string s) {\\n        int res=0;\\n        for(int i=0;i<w.size();i++)\\n        {\\n            int flag=0;\\n            for(int j=0;j<w[i].size();j++)\\n            {\\n                if(w[i][j]!=s[j])\\n                    flag=1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2022531,
                "title": "python3-one-line-solution",
                "content": "```\\nclass Solution:\\n    def countPrefixes(self, words: List[str], s: str) -> int:\\n        return sum([1 for w in words if w == s[:len(w)]])\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countPrefixes(self, words: List[str], s: str) -> int:\\n        return sum([1 for w in words if w == s[:len(w)]])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2014637,
                "title": "3ms-beats-95-c-submissions-easytounderstand",
                "content": "```\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& a, string s) {\\n        int ans=0;\\n        int n=s.size();\\n        for(auto it:a){\\n            int m=it.size();\\n            if(m<=n){\\n                int f=1;\\n                int k=0;\\n                for(auto i:it)\\n                    if(i!=s[k++])\\n                        {\\n                            f=0;\\n                            break;\\n                        }\\n                if(f)ans++;\\n            }\\n        }\\n     return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& a, string s) {\\n        int ans=0;\\n        int n=s.size();\\n        for(auto it:a){\\n            int m=it.size();\\n            if(m<=n){\\n                int f=1;\\n                int k=0;\\n                for(auto i:it)\\n                    if(i!=s[k++])\\n                        {\\n                            f=0;\\n                            break;\\n                        }\\n                if(f)ans++;\\n            }\\n        }\\n     return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2013095,
                "title": "runtime-12-ms-c-solution",
                "content": "class Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) {\\n        string str=\"\";\\n        int count=0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            str+=s[i];\\n            for(int j=0;j<words.size();j++)\\n            {\\n                if(words[j]==str)\\n                {\\n                    count++;\\n                }\\n                \\n            }\\n            \\n        }\\n        return count;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) {\\n        string str=\"\";\\n        int count=0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            str+=s[i];\\n            for(int j=0;j<words.size();j++)\\n            {\\n                if(words[j]==str)\\n                {\\n                    count++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2006744,
                "title": "c-efficient-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    bool contains(vector<string> vec, string & elem){\\n    bool result = false;\\n    if( find(vec.begin(), vec.end(), elem) != vec.end() )\\n    {\\n        result = true;\\n    }\\n    return result;\\n    }\\n    \\n    vector<string> vec;\\n    string temp=\"\";\\n    int c=0;\\n    int countPrefixes(vector<string>& words, string s) {\\n        for(int i=0;i<s.size();i++){\\n            temp+=s[i];\\n            vec.push_back(temp);\\n        }\\n        for(int i=0;i<words.size();i++){\\n            if(contains(vec,words[i])) c++;\\n        }\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool contains(vector<string> vec, string & elem){\\n    bool result = false;\\n    if( find(vec.begin(), vec.end(), elem) != vec.end() )\\n    {\\n        result = true;\\n    }\\n    return result;\\n    }\\n    \\n    vector<string> vec;\\n    string temp=\"\";\\n    int c=0;\\n    int countPrefixes(vector<string>& words, string s) {\\n        for(int i=0;i<s.size();i++){\\n            temp+=s[i];\\n            vec.push_back(temp);\\n        }\\n        for(int i=0;i<words.size();i++){\\n            if(contains(vec,words[i])) c++;\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1998165,
                "title": "python3",
                "content": "```\\nclass Solution:\\n    def countPrefixes(self, words: List[str], s: str) -> int:\\n        c=0\\n        for i in range(len(words)):\\n            if s.startswith(words[i]):\\n                    c+=1\\n        return c\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countPrefixes(self, words: List[str], s: str) -> int:\\n        c=0\\n        for i in range(len(words)):\\n            if s.startswith(words[i]):\\n                    c+=1\\n        return c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1997765,
                "title": "c-using-substr",
                "content": "```\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) {\\n        int ans1 = 0;\\n        for(int i=0;i<=s.size();i++){\\n            string h = s.substr(0,i);\\n            int x = count(words.begin(),words.end(),h);\\n            if(x>0)    ans1+=x;\\n        }\\n        return ans1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) {\\n        int ans1 = 0;\\n        for(int i=0;i<=s.size();i++){\\n            string h = s.substr(0,i);\\n            int x = count(words.begin(),words.end(),h);\\n            if(x>0)    ans1+=x;\\n        }\\n        return ans1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1995903,
                "title": "go-golang-solution",
                "content": "```go\\nfunc countPrefixes(words []string, s string) int {\\n    ans := 0\\n    for _, word := range words {\\n        n := len(word)\\n        if n > len(s) { continue }\\n        if word == s[:n] { ans++ }\\n    }\\n    return ans\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc countPrefixes(words []string, s string) int {\\n    ans := 0\\n    for _, word := range words {\\n        n := len(word)\\n        if n > len(s) { continue }\\n        if word == s[:n] { ans++ }\\n    }\\n    return ans\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1995794,
                "title": "easy-java-implementation",
                "content": "```\\nclass Solution {\\n    public int countPrefixes(String[] words, String s) {\\n        \\n        int count =0;\\n        \\n        for(String str : words){\\n \\xA0 \\xA0 \\xA0 \\xA0 if\\xA0(s.indexOf(str)==0) count++;\\n \\xA0 \\xA0 \\xA0 \\xA0}\\n \\xA0 \\xA0 \\xA0 \\xA0return count;\\n \\xA0 \\xA0}\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int countPrefixes(String[] words, String s) {\\n        \\n        int count =0;\\n        \\n        for(String str : words){\\n \\xA0 \\xA0 \\xA0 \\xA0 if\\xA0(s.indexOf(str)==0) count++;\\n \\xA0 \\xA0 \\xA0 \\xA0}\\n \\xA0 \\xA0 \\xA0 \\xA0return count;\\n \\xA0 \\xA0}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1995491,
                "title": "c-3-lines-no-substr-copy-or-global-find",
                "content": "Use `string::compare` to avoid substring copy and whole string scanning.\\n```\\nint countPrefixes(vector<string>& words, string s) {\\n    return count_if(words.begin(), words.end(), [&](string &w) {\\n        return !s.compare(0, w.size(), w);\\n    });\\n}\\n```\\n\\nEven better if LeetCode allows C++20 so that we could use the standard `string::starts_with`.",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint countPrefixes(vector<string>& words, string s) {\\n    return count_if(words.begin(), words.end(), [&](string &w) {\\n        return !s.compare(0, w.size(), w);\\n    });\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1995485,
                "title": "python-one-liner",
                "content": "```\\nclass Solution:\\n    def countPrefixes(self, words: List[str], s: str) -> int:\\n        return sum(w == s[:len(w)] for w in words)\\n```\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countPrefixes(self, words: List[str], s: str) -> int:\\n        return sum(w == s[:len(w)] for w in words)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1995010,
                "title": "ruby-solution",
                "content": "```\\n# @param {String[]} words\\n# @param {String} s\\n# @return {Integer}\\ndef count_prefixes(words, s)\\n    count = 0\\n    words.each {|word| count += 1 if word == s[0...word.length]}\\n    count\\nend\\n",
                "solutionTags": [],
                "code": "```\\n# @param {String[]} words\\n# @param {String} s\\n# @return {Integer}\\ndef count_prefixes(words, s)\\n    count = 0\\n    words.each {|word| count += 1 if word == s[0...word.length]}\\n    count\\nend\\n",
                "codeTag": "Python3"
            },
            {
                "id": 1994972,
                "title": "c",
                "content": "Just use substring to check is the same or not,\\nprefix must be a substring of string and length will be prefix self length.\\n[C# testcase](https://github.com/AhChao/OnceLeetCodePerDay/blob/main/OnceLeetCodePerDay/Contest/0430/Tests/L6051CountPrefixesOfAGivenStringTests.cs)\\n```\\npublic int CountPrefixes(string[] words, string s) {\\n\\tvar result = 0;\\n\\tforeach(var i in words)\\n\\t{\\n\\t\\tif(i.Length > s.Length) continue;\\n\\t\\tresult += s.Substring(0,i.Length) == i ? 1 : 0;\\n\\t}\\n\\treturn result;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int CountPrefixes(string[] words, string s) {\\n\\tvar result = 0;\\n\\tforeach(var i in words)\\n\\t{\\n\\t\\tif(i.Length > s.Length) continue;\\n\\t\\tresult += s.Substring(0,i.Length) == i ? 1 : 0;\\n\\t}\\n\\treturn result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1994856,
                "title": "python-hashset",
                "content": "```\\nclass Solution:\\n    def countPrefixes(self, words: List[str], s: str) -> int:\\n        \\n        c = 0 \\n        n = len(words)\\n        d = []\\n        for i in range(len(s)):\\n            d.append(s[:i+1])\\n        \\n        dd = set(d)\\n        \\n        for i in words:\\n            if i in dd:\\n                c += 1 \\n        return c\\n```\\n\\nDont miss to **Upvote** Coders, wish your very **great journey of coding**",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def countPrefixes(self, words: List[str], s: str) -> int:\\n        \\n        c = 0 \\n        n = len(words)\\n        d = []\\n        for i in range(len(s)):\\n            d.append(s[:i+1])\\n        \\n        dd = set(d)\\n        \\n        for i in words:\\n            if i in dd:\\n                c += 1 \\n        return c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1994706,
                "title": "easy-to-understand-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) {\\n        map<string, int> mpp;\\n        int ans = 0;\\n        string str;\\n        for(auto str : words) mpp[str]++;\\n        for(int i = 0; i < s.size(); i++){\\n                str += s[i];\\n                ans += mpp[str];\\n                cout << str << \" \";\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) {\\n        map<string, int> mpp;\\n        int ans = 0;\\n        string str;\\n        for(auto str : words) mpp[str]++;\\n        for(int i = 0; i < s.size(); i++){\\n                str += s[i];\\n                ans += mpp[str];\\n                cout << str << \" \";\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1994667,
                "title": "3-liner-easy-to-implement",
                "content": "```\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) {\\n        int count = 0;\\n        for(int i = 0 ; i < words.size() ; i++) if(words[i] == s.substr(0,words[i].size())) count++;\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) {\\n        int count = 0;\\n        for(int i = 0 ; i < words.size() ; i++) if(words[i] == s.substr(0,words[i].size())) count++;\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1994641,
                "title": "one-liner-easy-c-substr",
                "content": "```\\n    int countPrefixes(vector<string>& words, string s) {\\n        int count = 0;\\n        for(int i = 0; i < words.size(); i++)\\n            if(words[i].substr(0,words[i].size()) == s.substr(0,words[i].size()))\\n                count++;\\n        return count;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n    int countPrefixes(vector<string>& words, string s) {\\n        int count = 0;\\n        for(int i = 0; i < words.size(); i++)\\n            if(words[i].substr(0,words[i].size()) == s.substr(0,words[i].size()))\\n                count++;\\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1994629,
                "title": "very-easy-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) {\\n        int c = 0;\\n        unordered_map<string,int> hmp;\\n        int l = s.length();\\n        for(int i=0; i<words.size(); i++) {\\n            hmp[words[i]]++;\\n        }\\n        for(int i=1; i<=l; i++) {\\n            string str = s.substr(0,i);\\n            if(hmp.find(str)!=hmp.end())\\n                c += hmp[str];\\n        }\\n        return c;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) {\\n        int c = 0;\\n        unordered_map<string,int> hmp;\\n        int l = s.length();\\n        for(int i=0; i<words.size(); i++) {\\n            hmp[words[i]]++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1994607,
                "title": "simple-c-substring",
                "content": "class Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) {\\n        \\n        int num = 0;\\n        for(auto str:words){\\n            int len = str.size();\\n            string sub = s.substr(0,len);\\n            if(str == sub)\\n                num++;\\n        }\\n        \\n        return num;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) {\\n        \\n        int num = 0;\\n        for(auto str:words){\\n            int len = str.size();\\n            string sub = s.substr(0,len);\\n            if(str == sub)\\n                num++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1994580,
                "title": "java-startswith-easiest",
                "content": "```\\nclass Solution\\n{\\n    public int countPrefixes(String[] words, String s)\\n    {\\n        int count = 0;\\n        for(String word : words)\\n            if(s.startsWith(word))\\n                count++;\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution\\n{\\n    public int countPrefixes(String[] words, String s)\\n    {\\n        int count = 0;\\n        for(String word : words)\\n            if(s.startsWith(word))\\n                count++;\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1994576,
                "title": "c-3-lines-find-function",
                "content": "```\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) {\\n        int a=0;\\n        for(auto i:words)   a += s.find(i)==0;\\n        return a;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) {\\n        int a=0;\\n        for(auto i:words)   a += s.find(i)==0;\\n        return a;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1994564,
                "title": "c-4-lines-elegant-solution-using-std-mismatch",
                "content": "Built in C++ functions always comes handy in contests \\uD83D\\uDCAF\\n\\n```\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& a, string s) {\\n        int res = 0;\\n        for(auto i: a)\\n            if(mismatch(i.begin(), i.end(), s.begin(), s.end()).first == i.end()) res++;\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& a, string s) {\\n        int res = 0;\\n        for(auto i: a)\\n            if(mismatch(i.begin(), i.end(), s.begin(), s.end()).first == i.end()) res++;\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1994561,
                "title": "simple-elegant-4-line-cpp-code-faster-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& w, string s) {\\n        int ct=0;\\n        for(int i=0; i<w.size(); i++){\\n            if(s.substr(0,w[i].length())==w[i]) ct++;\\n        }\\n        return ct;\\n    }\\n};\\n```\\nTime Complexity: O(n)\\nSpace Complexity: O(1)\\n\\nLet me know if you\\'d like to add any point of if I have missed anything.\\nHappy Coding!",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& w, string s) {\\n        int ct=0;\\n        for(int i=0; i<w.size(); i++){\\n            if(s.substr(0,w[i].length())==w[i]) ct++;\\n        }\\n        return ct;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4093620,
                "title": "easy-one-liner-c",
                "content": "\\n# Approach\\nUsing Count and StartsWith\\n\\n# Code\\n```\\npublic class Solution {\\n    public int CountPrefixes(string[] words, string s) {\\n        return words.Count(i => s.StartsWith(i));\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int CountPrefixes(string[] words, string s) {\\n        return words.Count(i => s.StartsWith(i));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4088337,
                "title": "java-best-ever-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countPrefixes(String[] words, String s) {\\n        int c=0;\\n        for(int i=0;i<words.length;i++){\\n            if(s.startsWith(words[i])){\\n                c++;\\n            }\\n        }\\n        return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countPrefixes(String[] words, String s) {\\n        int c=0;\\n        for(int i=0;i<words.length;i++){\\n            if(s.startsWith(words[i])){\\n                c++;\\n            }\\n        }\\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4085650,
                "title": "easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) {\\n        int count = 0;\\n\\n        for(int i=0; i<words.size(); i++){\\n            if (s.rfind(words[i], 0) == 0) { \\n                count++;\\n            }\\n        }\\n\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) {\\n        int count = 0;\\n\\n        for(int i=0; i<words.size(); i++){\\n            if (s.rfind(words[i], 0) == 0) { \\n                count++;\\n            }\\n        }\\n\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4083046,
                "title": "detailed-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nwe have to find how many the elements in a words(list) can be prefixes to the string **S.**\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nwe have to take a variabe named counter.\\nstr\\n```python []\\ncount=0\\n\\n```\\nThen iterate through the loop to find whether the **elements in list  will match to the string S.** \\n```python []\\n    s[:len(i)]==i:\\n\\n```\\nthen increase the count value by 1\\n```python []\\ncount+=1\\n\\n```\\nFinally return the value of the count.\\n```python []\\nreturn count\\n\\n```\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countPrefixes(self, words: List[str], s: str) -> int:\\n        count=0\\n        for i in words:\\n            if s[:len(i)]==i:\\n                count+=1\\n        return count\\n```",
                "solutionTags": [
                    "Python3",
                    "String",
                    "String Matching"
                ],
                "code": "```python []\\ncount=0\\n\\n```\n```python []\\n    s[:len(i)]==i:\\n\\n```\n```python []\\ncount+=1\\n\\n```\n```python []\\nreturn count\\n\\n```\n```\\nclass Solution:\\n    def countPrefixes(self, words: List[str], s: str) -> int:\\n        count=0\\n        for i in words:\\n            if s[:len(i)]==i:\\n                count+=1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4081682,
                "title": "easy-to-understand-iterative",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIteratively check if each words is prefix or not\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Initialize the count.\\n2. Iterate through each word.\\n3. If the word is the prefix of s, increment count.\\n4. Return count.\\n\\n# Complexity\\n- Time complexity: O(n*m) , n=number of words, m=size of each word\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countPrefixes(self, words: List[str], s: str) -> int:\\n        \\n        count=0\\n        for w in words:\\n            n=len(w)\\n            if n<=len(s) and w==s[:n]:\\n                count+=1\\n        return count\\n```",
                "solutionTags": [
                    "Python3",
                    "Array"
                ],
                "code": "```\\nclass Solution:\\n    def countPrefixes(self, words: List[str], s: str) -> int:\\n        \\n        count=0\\n        for w in words:\\n            n=len(w)\\n            if n<=len(s) and w==s[:n]:\\n                count+=1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4079643,
                "title": "simple-java-solution-100-beats-4-lines-of-code-with-expanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n    Please Upvote.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countPrefixes(String[] words, String s) {\\n        // Variable to store the value of answer.\\n        int ans=0;\\n        // Iterate through all the strings of the array.\\n        for(String word:words){\\n            // If \\'s\\' starts with the current string then increse the answer count by one.\\n            if(s.startsWith(word)) ans++;\\n        }\\n        // Finaly return the answer.\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countPrefixes(String[] words, String s) {\\n        // Variable to store the value of answer.\\n        int ans=0;\\n        // Iterate through all the strings of the array.\\n        for(String word:words){\\n            // If \\'s\\' starts with the current string then increse the answer count by one.\\n            if(s.startsWith(word)) ans++;\\n        }\\n        // Finaly return the answer.\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4079160,
                "title": "c-100-faster-string",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) {\\n\\n    \\tint countOfPattern = 0;\\n\\n    \\tint inputSize = words.size();\\n\\n    \\tfor (int i = 0; i < inputSize; ++i)\\n    \\t{\\n    \\t\\tif(isPrefix(s,words[i])){\\n                countOfPattern++;\\n    \\t\\t}\\n    \\t}\\n\\n    \\treturn countOfPattern;\\n\\n    }\\n\\n\\tbool isPrefix(string str,string pattern){\\n\\n\\t\\tint size = pattern.size();\\n\\n\\t\\tfor (int i = 0; i < size; ++i)\\n\\t\\t{\\n\\t\\t\\tif(str[i] != pattern[i]){\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) {\\n\\n    \\tint countOfPattern = 0;\\n\\n    \\tint inputSize = words.size();\\n\\n    \\tfor (int i = 0; i < inputSize; ++i)\\n    \\t{\\n    \\t\\tif(isPrefix(s,words[i])){\\n                countOfPattern++;\\n    \\t\\t}\\n    \\t}\\n\\n    \\treturn countOfPattern;\\n\\n    }\\n\\n\\tbool isPrefix(string str,string pattern){\\n\\n\\t\\tint size = pattern.size();\\n\\n\\t\\tfor (int i = 0; i < size; ++i)\\n\\t\\t{\\n\\t\\t\\tif(str[i] != pattern[i]){\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4077227,
                "title": "beats-100-only-for-beginners",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countPrefixes(String[] words, String s) {\\n        int count = 0;\\n        for(int i=0;i<words.length;i++){\\n            if(s.startsWith(words[i])) count ++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countPrefixes(String[] words, String s) {\\n        int count = 0;\\n        for(int i=0;i<words.length;i++){\\n            if(s.startsWith(words[i])) count ++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4076286,
                "title": "one-line-solution",
                "content": "```\\nclass Solution:\\n    def countPrefixes(self, words: List[str], s: str) -> int:\\n        return sum(s.startswith(word) for word in words)       \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countPrefixes(self, words: List[str], s: str) -> int:\\n        return sum(s.startswith(word) for word in words)       \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4073928,
                "title": "beats-100-00-of-users-with-java",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int countPrefixes(String[] words, String s) {\\n         int count=0;\\n        for(String word: words)\\n        {\\n            if(s.indexOf(word)==0)\\n            {\\n                  count++;\\n            }\\n        }\\n        \\n    return count;}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countPrefixes(String[] words, String s) {\\n         int count=0;\\n        for(String word: words)\\n        {\\n            if(s.indexOf(word)==0)\\n            {\\n                  count++;\\n            }\\n        }\\n        \\n    return count;}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4071268,
                "title": "naive-method-96-beats-simple-solution-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countPrefixes(self, words: List[str], s: str) -> int:\\n        count=0\\n        for i in words:\\n            if len(i)<=len(s):\\n                c=0\\n                for j in range(len(i)):\\n                    if s[j]!=i[j]:\\n                        c=1\\n                        break\\n                if c==0:\\n                    count+=1\\n        return count\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countPrefixes(self, words: List[str], s: str) -> int:\\n        count=0\\n        for i in words:\\n            if len(i)<=len(s):\\n                c=0\\n                for j in range(len(i)):\\n                    if s[j]!=i[j]:\\n                        c=1\\n                        break\\n                if c==0:\\n                    count+=1\\n        return count\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4069485,
                "title": "easy-c-soln",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) {\\n        int n = words.size();\\n        int m = s.size();\\n        int count = 0;\\n        string str = \"\";\\n        for(int i=0; i<m; i++){\\n            str += s[i];\\n            for(int j=0; j<n; j++){\\n                if(words[j] == str){\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) {\\n        int n = words.size();\\n        int m = s.size();\\n        int count = 0;\\n        string str = \"\";\\n        for(int i=0; i<m; i++){\\n            str += s[i];\\n            for(int j=0; j<n; j++){\\n                if(words[j] == str){\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4067888,
                "title": "1-line-c-solution",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\npublic class Solution\\n{\\n    public int CountPrefixes(string[] words, string s)\\n    {\\n        return words.Count(s.StartsWith);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution\\n{\\n    public int CountPrefixes(string[] words, string s)\\n    {\\n        return words.Count(s.StartsWith);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4064105,
                "title": "1-line-of-code-beast-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n func countPrefixes(_ words: [String], _ s: String) -> Int {\\n    \\n    return words.filter {s.hasPrefix($0)}.count\\n}\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n func countPrefixes(_ words: [String], _ s: String) -> Int {\\n    \\n    return words.filter {s.hasPrefix($0)}.count\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4063523,
                "title": "c-solution-by-ajeet20-iit-kanpur",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) {\\n\\n        int count = 0;\\n        for(int i = 0; i < s.size(); i++)\\n        {\\n            string str = s.substr(0, i+1);\\n            for(int j = 0; j < words.size(); j++) {\\n                if(words[j] == str) count++;\\n            }\\n        }    \\n        return count;    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) {\\n\\n        int count = 0;\\n        for(int i = 0; i < s.size(); i++)\\n        {\\n            string str = s.substr(0, i+1);\\n            for(int j = 0; j < words.size(); j++) {\\n                if(words[j] == str) count++;\\n            }\\n        }    \\n        return count;    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4062738,
                "title": "hash-map-unordered-set-c-sol",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) {\\n        \\n        unordered_map<string,int> map;\\n        for(auto it :words)\\n        {\\n            map[it]++;\\n        }\\n        int ans  = 0;\\n        unordered_set<string> seti(words.begin(), words.end());\\n        for(int j = 1;j <= s.size();j++)\\n        {\\n            string temp = s.substr(0,j);\\n            if(seti.find(temp) != seti.end())\\n            {\\n                seti.erase(temp);\\n                ans += map[temp]++;\\n                map.erase(temp);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) {\\n        \\n        unordered_map<string,int> map;\\n        for(auto it :words)\\n        {\\n            map[it]++;\\n        }\\n        int ans  = 0;\\n        unordered_set<string> seti(words.begin(), words.end());\\n        for(int j = 1;j <= s.size();j++)\\n        {\\n            string temp = s.substr(0,j);\\n            if(seti.find(temp) != seti.end())\\n            {\\n                seti.erase(temp);\\n                ans += map[temp]++;\\n                map.erase(temp);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4061412,
                "title": "using-hashset-without-any-in-build-function",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countPrefixes(String[] words, String s) {\\n        int count = 0 ; \\n        Set<String> hs = new HashSet<>() ;\\n        for(int j=1;j<=s.length();j++) {\\n               hs.add(s.substring(0,j)) ; \\n            }\\n        for(int i = 0 ; i<words.length ; i++){\\n            if(words[i].length()>s.length())continue ; \\n            // for(int j=1;j<=s.length();j++) {\\n            //     if(words[i].equals(s.substring(0,j))) {count++ ; break ;}\\n            // }\\n            if(hs.contains(words[i]))count++ ; \\n        }\\n        return count ; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countPrefixes(String[] words, String s) {\\n        int count = 0 ; \\n        Set<String> hs = new HashSet<>() ;\\n        for(int j=1;j<=s.length();j++) {\\n               hs.add(s.substring(0,j)) ; \\n            }\\n        for(int i = 0 ; i<words.length ; i++){\\n            if(words[i].length()>s.length())continue ; \\n            // for(int j=1;j<=s.length();j++) {\\n            //     if(words[i].equals(s.substring(0,j))) {count++ ; break ;}\\n            // }\\n            if(hs.contains(words[i]))count++ ; \\n        }\\n        return count ; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4050484,
                "title": "js",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string[]} words\\n * @param {string} s\\n * @return {number}\\n */\\nvar countPrefixes = function(words, s) {\\n      return words.filter((item) => s.startsWith(item)).length\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} words\\n * @param {string} s\\n * @return {number}\\n */\\nvar countPrefixes = function(words, s) {\\n      return words.filter((item) => s.startsWith(item)).length\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4050311,
                "title": "simple-easy-solution",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {string[]} words\\n * @param {string} s\\n * @return {number}\\n */\\nvar countPrefixes = function(words, s) {\\n   let count = 0\\n    for(let i = 0; i<words.length; i++){\\n         if(s.startsWith(words[i])){\\n            count = count + 1\\n         }\\n    }\\n    return count\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} words\\n * @param {string} s\\n * @return {number}\\n */\\nvar countPrefixes = function(words, s) {\\n   let count = 0\\n    for(let i = 0; i<words.length; i++){\\n         if(s.startsWith(words[i])){\\n            count = count + 1\\n         }\\n    }\\n    return count\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4037732,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution \\n{\\n    public int countPrefixes(String[] words, String s) \\n    {\\n        int c = 0;\\n        for(int i = 1; i<=s.length(); i++)\\n        {\\n            String s1 = s.substring(0,i);\\n            for(int j = 0; j<words.length; j++)\\n            {\\n                if(words[j].equals(s1))\\n                c++;\\n            }\\n        }\\n        return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution \\n{\\n    public int countPrefixes(String[] words, String s) \\n    {\\n        int c = 0;\\n        for(int i = 1; i<=s.length(); i++)\\n        {\\n            String s1 = s.substring(0,i);\\n            for(int j = 0; j<words.length; j++)\\n            {\\n                if(words[j].equals(s1))\\n                c++;\\n            }\\n        }\\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4031001,
                "title": "100-beats-in-java",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countPrefixes(String[] words, String s) {\\n        int count = 0;\\n        for (String i : words)\\n            if (s.startsWith(i)) count++;\\n        return count;\\n\\n    } \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countPrefixes(String[] words, String s) {\\n        int count = 0;\\n        for (String i : words)\\n            if (s.startsWith(i)) count++;\\n        return count;\\n\\n    } \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4023312,
                "title": "begineers-must-see",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countPrefixes(String[] words, String s) {int a=0;\\n    for(int j=0;j<s.length();j++){\\n        for(int i=0;i<words.length;i++){\\n            if(words[i].equals (s.substring(0,j+1)))a++;\\n        }}\\n        return a;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countPrefixes(String[] words, String s) {int a=0;\\n    for(int j=0;j<s.length();j++){\\n        for(int i=0;i<words.length;i++){\\n            if(words[i].equals (s.substring(0,j+1)))a++;\\n        }}\\n        return a;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4014679,
                "title": "3lines-code-easy-code",
                "content": "# Code\\n```\\nclass Solution {\\n    public int countPrefixes(String[] words, String s) {\\n        int count=0;\\n        for(String str:words)\\n        {\\n            if(s.indexOf(str)==0)\\n            {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countPrefixes(String[] words, String s) {\\n        int count=0;\\n        for(String str:words)\\n        {\\n            if(s.indexOf(str)==0)\\n            {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4011936,
                "title": "direct-approach-using-java",
                "content": "\\n\\n# Java Code\\n```\\nclass Solution {\\n    public int countPrefixes(String[] words, String s) {\\n        int count = 0;\\n        String temp = \"\";\\n        for(int i =0;i<s.length();i++){\\n            temp+=Character.toString(s.charAt(i));\\n            for(String x:words)\\n                if(temp.equals(x))\\n                    count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int countPrefixes(String[] words, String s) {\\n        int count = 0;\\n        String temp = \"\";\\n        for(int i =0;i<s.length();i++){\\n            temp+=Character.toString(s.charAt(i));\\n            for(String x:words)\\n                if(temp.equals(x))\\n                    count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4011673,
                "title": "easy-python-linear-search-82-72-faster",
                "content": "faster than\\xA082.72%\\n\\n```\\nclass Solution:\\n    def countPrefixes(self, words: List[str], s: str) -> int:\\n        count = 0        \\n        # make s into tree.\\n        \\n        # traverse for each to see. If not, then not. \\n        for word in words:\\n            \\n            # word longer, cannot be prefix\\n            if len(word) > len(s):\\n                continue\\n                \\n            for i, ch in enumerate(word):\\n                \\n                if ch != s[i]:\\n                    break\\n                    \\n                if i == len(word) - 1:\\n                    count += 1\\n        \\n        return count\\n                \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def countPrefixes(self, words: List[str], s: str) -> int:\\n        count = 0        \\n        # make s into tree.\\n        \\n        # traverse for each to see. If not, then not. \\n        for word in words:\\n            \\n            # word longer, cannot be prefix\\n            if len(word) > len(s):\\n                continue\\n                \\n            for i, ch in enumerate(word):\\n                \\n                if ch != s[i]:\\n                    break\\n                    \\n                if i == len(word) - 1:\\n                    count += 1\\n        \\n        return count\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4007127,
                "title": "easy-java-solution-0-ms-beats-100-users",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countPrefixes(String[] words, String s) {\\n        int c=0;\\n        for(int i=0;i<words.length;i++){\\n            if(s.startsWith(words[i]))\\n                c++;\\n        }\\n        return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countPrefixes(String[] words, String s) {\\n        int c=0;\\n        for(int i=0;i<words.length;i++){\\n            if(s.startsWith(words[i]))\\n                c++;\\n        }\\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4005419,
                "title": "world-easy-solution-in-js",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string[]} words\\n * @param {string} s\\n * @return {number}\\n */\\nvar countPrefixes = function(words, s) {\\n    let number=0;\\n    for(let i = 0 ; i< words.length; i++){\\n        let a = checkme(words[i], s);\\n        if(a){\\n            number++;\\n        }\\n    }\\n    return number;\\n    \\n};\\nfunction checkme(word, s){\\n    // if(word.length>s.length){\\n        for(let i = 0 ; i< word.length; i++){\\n            if(word[i]!=s[i]){\\n                return false;\\n            }\\n        }\\n        return true;\\n    // }\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} words\\n * @param {string} s\\n * @return {number}\\n */\\nvar countPrefixes = function(words, s) {\\n    let number=0;\\n    for(let i = 0 ; i< words.length; i++){\\n        let a = checkme(words[i], s);\\n        if(a){\\n            number++;\\n        }\\n    }\\n    return number;\\n    \\n};\\nfunction checkme(word, s){\\n    // if(word.length>s.length){\\n        for(let i = 0 ; i< word.length; i++){\\n            if(word[i]!=s[i]){\\n                return false;\\n            }\\n        }\\n        return true;\\n    // }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4004148,
                "title": "easy-c-solution-using-find",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) {\\n        int cnt=0;\\n        for(int i=0;i<words.size();i++)\\n        {\\n            string str=words[i];\\n            if(s.find(str)==0)cnt++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) {\\n        int cnt=0;\\n        for(int i=0;i<words.size();i++)\\n        {\\n            string str=words[i];\\n            if(s.find(str)==0)cnt++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4000672,
                "title": "typescript-1-line-solution-o-n",
                "content": "# Complexity\\n- Time complexity: $O(n)$\\n- Space complexity: $O(1)$\\n\\n# Code\\n```\\nconst countPrefixes = (words: string[], s: string): number => words.reduce((a, w) => s.startsWith(w) ? a + 1 : a, 0)\\n```",
                "solutionTags": [
                    "TypeScript",
                    "Array",
                    "String"
                ],
                "code": "```\\nconst countPrefixes = (words: string[], s: string): number => words.reduce((a, w) => s.startsWith(w) ? a + 1 : a, 0)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3989630,
                "title": "dart-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n int countPrefixes(List<String> words, String s) {\\n  int result = 0;\\n\\n  for (int i = 0; i < words.length; i++) {\\n    if (s.startsWith(words[i])) {\\n      result++;\\n    }\\n  }\\n  return result;\\n}\\n}\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nclass Solution {\\n int countPrefixes(List<String> words, String s) {\\n  int result = 0;\\n\\n  for (int i = 0; i < words.length; i++) {\\n    if (s.startsWith(words[i])) {\\n      result++;\\n    }\\n  }\\n  return result;\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3986090,
                "title": "simple-java-solution-no-sms-nor-registration-required",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf a word is a prefix of the string s, it means the string s starts with that word. The Java String class provides a method startsWith() that can be used to determine if a string starts with a certain prefix. We can use this method to simplify our solution.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Initialize a Counter: Start by initializing a counter to zero. This will keep track of how many words from the array are prefixes of s.\\n\\n2. Iterate Over the Words: Go through each word in the words array.\\n\\n3. Check for Prefix: For each word, check if s starts with that word using the startsWith() method. If it does, increment the counter.\\n\\n4. Return the Counter: After checking all the words, return the counter.\\n\\n# Complexity\\n- Time complexity: O(n * m)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nwhere n is the number of words and m is the average length of a word. This is because the startsWith() method compares characters of the word with the string s and, in the worst case, this can be O(m).\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nas we are using only a fixed amount of extra space (the counter) regardless of the size of the input.\\n\\n# Code\\n```\\nclass Solution {\\n    public int countPrefixes(String[] words, String s) {\\n        int count = 0;\\n\\n        for (int i = 0; i < words.length; i++){\\n            if (s.startsWith(words[i])){\\n                count++;\\n            }\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countPrefixes(String[] words, String s) {\\n        int count = 0;\\n\\n        for (int i = 0; i < words.length; i++){\\n            if (s.startsWith(words[i])){\\n                count++;\\n            }\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3981590,
                "title": "easy-python-solution-slicing-string",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def countPrefixes(self, words: List[str], s: str) -> int:\\n        output = 0 \\n        for i in words :\\n            if i == s[:len(i)] :\\n                output += 1\\n        return output\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countPrefixes(self, words: List[str], s: str) -> int:\\n        output = 0 \\n        for i in words :\\n            if i == s[:len(i)] :\\n                output += 1\\n        return output\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3974113,
                "title": "check-prefix-java-o-n",
                "content": "\\tclass Solution {\\n\\t\\tpublic int countPrefixes(String[] words, String s) {\\n\\t\\t\\tint count=0;\\n\\t\\t\\tfor(String word: words){\\n\\t\\t\\t\\tint temp = word.length(); // substring length\\n\\t\\t\\t\\tif((s.length() >= temp) && word.equals(s.substring(0,temp))) count++;\\n\\t\\t\\t}\\n\\t\\t\\treturn count;\\n\\t\\t}\\n\\t}",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "class Solution {\\n\\t\\tpublic int countPrefixes(String[] words, String s) {\\n\\t\\t\\tint count=0;\\n\\t\\t\\tfor(String word: words){\\n\\t\\t\\t\\tint temp = word.length(); // substring length\\n\\t\\t\\t\\tif((s.length() >= temp) && word.equals(s.substring(0,temp))) count++;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 3971387,
                "title": "one-line-solution-using-list-comprehensions",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def countPrefixes(self, words: List[str], s: str) -> int:\\n        return sum([words.count(s[:i]) for i in range(1, len(s)+1)])\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countPrefixes(self, words: List[str], s: str) -> int:\\n        return sum([words.count(s[:i]) for i in range(1, len(s)+1)])\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3954226,
                "title": "easy",
                "content": "\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\nO(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def countPrefixes(self, words: List[str], s: str) -> int:\\n        count = 0\\n        for i in words:\\n            if i == s[0:len(i)]: \\n                count += 1\\n        return count\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countPrefixes(self, words: List[str], s: str) -> int:\\n        count = 0\\n        for i in words:\\n            if i == s[0:len(i)]: \\n                count += 1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3946446,
                "title": "easy-php-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    /**\\n     * @param String[] $words\\n     * @param String $s\\n     * @return Integer\\n     */\\n    function countPrefixes($words, $s) {\\n        $count = 0;\\n        $sLen = strlen($s);\\n        for($i=1; $i<=$sLen; $i++){\\n            $str = substr($s,0,$i);\\n            foreach($words as $word){\\n                if($word == $str){\\n                    $count++;\\n                }\\n            }\\n        }\\n\\n        return $count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "PHP"
                ],
                "code": "```\\nclass Solution {\\n\\n    /**\\n     * @param String[] $words\\n     * @param String $s\\n     * @return Integer\\n     */\\n    function countPrefixes($words, $s) {\\n        $count = 0;\\n        $sLen = strlen($s);\\n        for($i=1; $i<=$sLen; $i++){\\n            $str = substr($s,0,$i);\\n            foreach($words as $word){\\n                if($word == $str){\\n                    $count++;\\n                }\\n            }\\n        }\\n\\n        return $count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3941401,
                "title": "easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string[]} words\\n * @param {string} s\\n * @return {number}\\n */\\nvar countPrefixes = function(words, s) {\\n  const hasPrefix = words.filter( string => {\\n    return s.startsWith(string)\\n  })\\n\\n  return hasPrefix.length\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} words\\n * @param {string} s\\n * @return {number}\\n */\\nvar countPrefixes = function(words, s) {\\n  const hasPrefix = words.filter( string => {\\n    return s.startsWith(string)\\n  })\\n\\n  return hasPrefix.length\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3941261,
                "title": "dart-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  int countPrefixes(List<String> words, String s) {\\n      var c = 0;\\n      for (int i = 0; i < words.length; i++) {\\n          if (s.startsWith(words[i])) {\\n              c += 1;\\n          }\\n      }\\n\\n      return c;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nclass Solution {\\n  int countPrefixes(List<String> words, String s) {\\n      var c = 0;\\n      for (int i = 0; i < words.length; i++) {\\n          if (s.startsWith(words[i])) {\\n              c += 1;\\n          }\\n      }\\n\\n      return c;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3940064,
                "title": "javascript-single-line-functional-declarative-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string[]} words\\n * @param {string} s\\n * @return {number}\\n */\\nvar countPrefixes = function(words, s) {\\n    return words.filter(word => s.startsWith(word)).length\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} words\\n * @param {string} s\\n * @return {number}\\n */\\nvar countPrefixes = function(words, s) {\\n    return words.filter(word => s.startsWith(word)).length\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3937084,
                "title": "javascript-beats-32-51",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string[]} words\\n * @param {string} s\\n * @return {number}\\n */\\nvar countPrefixes = function(words, s) {\\n    let count=0;\\n   for (let index = 0; index < words.length; index++) if (s.startsWith(words[index])) count += 1;\\n   return count;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} words\\n * @param {string} s\\n * @return {number}\\n */\\nvar countPrefixes = function(words, s) {\\n    let count=0;\\n   for (let index = 0; index < words.length; index++) if (s.startsWith(words[index])) count += 1;\\n   return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3936190,
                "title": "python-easy-solution",
                "content": "\\n# Code\\n```\\nclass Solution(object):\\n    def countPrefixes(self, words, s):\\n        count = 0\\n        for i in range(len(words)):\\n            item = words[i]\\n            if s[0 : len(item)] == item:\\n                count += 1\\n        return count\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def countPrefixes(self, words, s):\\n        count = 0\\n        for i in range(len(words)):\\n            item = words[i]\\n            if s[0 : len(item)] == item:\\n                count += 1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3932521,
                "title": "simple-approach-runtime-60ms-beat-93-in-runtime-and-memory",
                "content": "# Intuition\\n=>check prefix of each string in word if equal then increment the count otherwise pass on\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n=>create count equal to zero and iterate a loop and check for each string in word if its string equal to starting elements of prefix string increment the count otherwise pass\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countPrefixes(self, words: List[str], s: str) -> int:\\n        cnt=0\\n        for i in words:\\n            if i==s[:len(i)]:\\n                cnt+=1\\n        return cnt\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countPrefixes(self, words: List[str], s: str) -> int:\\n        cnt=0\\n        for i in words:\\n            if i==s[:len(i)]:\\n                cnt+=1\\n        return cnt\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3931816,
                "title": "ez-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) {\\n        int sum=0;\\n        for(int i=0;i<words.size();i++){\\n            if(words[i].size()>s.size()){\\n                continue;\\n            }\\n            else {\\n                if(words[i]==s.substr(0,words[i].size())){\\n                    sum++;\\n                }\\n            }\\n        }\\n        return sum;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string s) {\\n        int sum=0;\\n        for(int i=0;i<words.size();i++){\\n            if(words[i].size()>s.size()){\\n                continue;\\n            }\\n            else {\\n                if(words[i]==s.substr(0,words[i].size())){\\n                    sum++;\\n                }\\n            }\\n        }\\n        return sum;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3923639,
                "title": "very-easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n# - Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countPrefixes(String[] words, String s) {\\n        int count=0;\\n\\n        for(String word: words){\\n            if(s.startsWith(word)) count++;\\n        }\\n        return count;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int countPrefixes(String[] words, String s) {\\n        int count=0;\\n\\n        for(String word: words){\\n            if(s.startsWith(word)) count++;\\n        }\\n        return count;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3923636,
                "title": "very-easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countPrefixes(String[] words, String s) {\\n        int count=0;\\n\\n        for(String word: words){\\n            if(s.startsWith(word)) count++;\\n        }\\n        return count;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int countPrefixes(String[] words, String s) {\\n        int count=0;\\n\\n        for(String word: words){\\n            if(s.startsWith(word)) count++;\\n        }\\n        return count;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1732909,
                "content": [
                    {
                        "username": "Nitish-Devarshi",
                        "content": "class Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string allowed) {\\n        int ans=0;\\n        for(int i=0;i<words.size();i++){\\n            string s=words[i];\\n            int z=s.size();\\n            for(int k=0;k<s.size();k++){\\n               if (s[k] == allowed[k]) {\\n                   z--;\\n               }\\n            }\\n            if(z==0){\\n                ans++;\\n            }\\n        }\\n        return ans; \\n    }\\n};"
                    },
                    {
                        "username": "DeepaSingh13",
                        "content": "word =[\"feh\",\"w\",\"w\",\"lwd\",\"c\",\"s\",\"vk\",\"zwlv\",\"n\",\"w\",\"sw\",\"qrd\",\"w\",\"w\",\"mqe\",\"w\",\"w\",\"w\",\"gb\",\"w\",\"qy\",\"xs\",\"br\",\"w\",\"rypg\",\"wh\",\"g\",\"w\",\"w\",\"fh\",\"w\",\"w\",\"sccy\"]\\nString s= \"w\";\\n\\nExpected output : 14 \\nMy output : 15\\nHow the expected o/p is coming as 14 if we count manually so it is 15\\n"
                    },
                    {
                        "username": "DhanushAM",
                        "content": " \\'wh\\' is not a prefix of \\'w\\'. A prefix is a sequence of characters that appears at the beginning of a longer string. In this case, \\'w\\' is a single character, and \\'wh\\' is two characters. \\'w\\' is not a longer string containing \\'wh\\' as a prefix, so \\'wh\\' cannot be considered a prefix of \\'w\\'."
                    },
                    {
                        "username": "manuatleet12195",
                        "content": "return sum([1 for i in words if s.startswith(i)])"
                    },
                    {
                        "username": "NarayanSharma",
                        "content": "Please check the test case No 122, in this case words have \"a\" also, so its output should be 135 \\n\\n`var countPrefixes = function(words, s) {\\n    let count = 0;\\n    for(let i = 0; i < words.length; i++){\\n        if((words[i][0] === s[0]) && s.includes(words[i])){\\n            count++\\n        }\\n    }\\n    return count\\n}; `"
                    },
                    {
                        "username": "nancychauhan99",
                        "content": "What is the time complexity for best and worst case? This question has come as google interview and an official solution from leetcode is missing, why? though its a easy one but approaches to handle and TC worth discussing, NO?"
                    },
                    {
                        "username": "brandonallen",
                        "content": "[vaguely] Every solution involves some form of iterating through words[], and comparing each word to s. So if n == length(words) and m == length(s), worst case is O(n*m); if every word is a prefix, and has a length proportional to m. Best case, if every word in words isn't a prefix, and the first character isn't shared between words[i] and s, then it's O(1) time to compare each word to s, so O(n) complexity. You still have to check every word, since they aren't sorted, so you could never beat O(n).\nIf you use a trie and store the number of occurrences of each distinct element in words, if seems like you could potentially optimize slightly. But I sampled the fastest submitted code, and the constraints (n and m) are small enough that it's faster to just brute force it."
                    }
                ]
            },
            {
                "id": 2039571,
                "content": [
                    {
                        "username": "Nitish-Devarshi",
                        "content": "class Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string allowed) {\\n        int ans=0;\\n        for(int i=0;i<words.size();i++){\\n            string s=words[i];\\n            int z=s.size();\\n            for(int k=0;k<s.size();k++){\\n               if (s[k] == allowed[k]) {\\n                   z--;\\n               }\\n            }\\n            if(z==0){\\n                ans++;\\n            }\\n        }\\n        return ans; \\n    }\\n};"
                    },
                    {
                        "username": "DeepaSingh13",
                        "content": "word =[\"feh\",\"w\",\"w\",\"lwd\",\"c\",\"s\",\"vk\",\"zwlv\",\"n\",\"w\",\"sw\",\"qrd\",\"w\",\"w\",\"mqe\",\"w\",\"w\",\"w\",\"gb\",\"w\",\"qy\",\"xs\",\"br\",\"w\",\"rypg\",\"wh\",\"g\",\"w\",\"w\",\"fh\",\"w\",\"w\",\"sccy\"]\\nString s= \"w\";\\n\\nExpected output : 14 \\nMy output : 15\\nHow the expected o/p is coming as 14 if we count manually so it is 15\\n"
                    },
                    {
                        "username": "DhanushAM",
                        "content": " \\'wh\\' is not a prefix of \\'w\\'. A prefix is a sequence of characters that appears at the beginning of a longer string. In this case, \\'w\\' is a single character, and \\'wh\\' is two characters. \\'w\\' is not a longer string containing \\'wh\\' as a prefix, so \\'wh\\' cannot be considered a prefix of \\'w\\'."
                    },
                    {
                        "username": "manuatleet12195",
                        "content": "return sum([1 for i in words if s.startswith(i)])"
                    },
                    {
                        "username": "NarayanSharma",
                        "content": "Please check the test case No 122, in this case words have \"a\" also, so its output should be 135 \\n\\n`var countPrefixes = function(words, s) {\\n    let count = 0;\\n    for(let i = 0; i < words.length; i++){\\n        if((words[i][0] === s[0]) && s.includes(words[i])){\\n            count++\\n        }\\n    }\\n    return count\\n}; `"
                    },
                    {
                        "username": "nancychauhan99",
                        "content": "What is the time complexity for best and worst case? This question has come as google interview and an official solution from leetcode is missing, why? though its a easy one but approaches to handle and TC worth discussing, NO?"
                    },
                    {
                        "username": "brandonallen",
                        "content": "[vaguely] Every solution involves some form of iterating through words[], and comparing each word to s. So if n == length(words) and m == length(s), worst case is O(n*m); if every word is a prefix, and has a length proportional to m. Best case, if every word in words isn't a prefix, and the first character isn't shared between words[i] and s, then it's O(1) time to compare each word to s, so O(n) complexity. You still have to check every word, since they aren't sorted, so you could never beat O(n).\nIf you use a trie and store the number of occurrences of each distinct element in words, if seems like you could potentially optimize slightly. But I sampled the fastest submitted code, and the constraints (n and m) are small enough that it's faster to just brute force it."
                    }
                ]
            },
            {
                "id": 1908446,
                "content": [
                    {
                        "username": "Nitish-Devarshi",
                        "content": "class Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string allowed) {\\n        int ans=0;\\n        for(int i=0;i<words.size();i++){\\n            string s=words[i];\\n            int z=s.size();\\n            for(int k=0;k<s.size();k++){\\n               if (s[k] == allowed[k]) {\\n                   z--;\\n               }\\n            }\\n            if(z==0){\\n                ans++;\\n            }\\n        }\\n        return ans; \\n    }\\n};"
                    },
                    {
                        "username": "DeepaSingh13",
                        "content": "word =[\"feh\",\"w\",\"w\",\"lwd\",\"c\",\"s\",\"vk\",\"zwlv\",\"n\",\"w\",\"sw\",\"qrd\",\"w\",\"w\",\"mqe\",\"w\",\"w\",\"w\",\"gb\",\"w\",\"qy\",\"xs\",\"br\",\"w\",\"rypg\",\"wh\",\"g\",\"w\",\"w\",\"fh\",\"w\",\"w\",\"sccy\"]\\nString s= \"w\";\\n\\nExpected output : 14 \\nMy output : 15\\nHow the expected o/p is coming as 14 if we count manually so it is 15\\n"
                    },
                    {
                        "username": "DhanushAM",
                        "content": " \\'wh\\' is not a prefix of \\'w\\'. A prefix is a sequence of characters that appears at the beginning of a longer string. In this case, \\'w\\' is a single character, and \\'wh\\' is two characters. \\'w\\' is not a longer string containing \\'wh\\' as a prefix, so \\'wh\\' cannot be considered a prefix of \\'w\\'."
                    },
                    {
                        "username": "manuatleet12195",
                        "content": "return sum([1 for i in words if s.startswith(i)])"
                    },
                    {
                        "username": "NarayanSharma",
                        "content": "Please check the test case No 122, in this case words have \"a\" also, so its output should be 135 \\n\\n`var countPrefixes = function(words, s) {\\n    let count = 0;\\n    for(let i = 0; i < words.length; i++){\\n        if((words[i][0] === s[0]) && s.includes(words[i])){\\n            count++\\n        }\\n    }\\n    return count\\n}; `"
                    },
                    {
                        "username": "nancychauhan99",
                        "content": "What is the time complexity for best and worst case? This question has come as google interview and an official solution from leetcode is missing, why? though its a easy one but approaches to handle and TC worth discussing, NO?"
                    },
                    {
                        "username": "brandonallen",
                        "content": "[vaguely] Every solution involves some form of iterating through words[], and comparing each word to s. So if n == length(words) and m == length(s), worst case is O(n*m); if every word is a prefix, and has a length proportional to m. Best case, if every word in words isn't a prefix, and the first character isn't shared between words[i] and s, then it's O(1) time to compare each word to s, so O(n) complexity. You still have to check every word, since they aren't sorted, so you could never beat O(n).\nIf you use a trie and store the number of occurrences of each distinct element in words, if seems like you could potentially optimize slightly. But I sampled the fastest submitted code, and the constraints (n and m) are small enough that it's faster to just brute force it."
                    }
                ]
            },
            {
                "id": 1875133,
                "content": [
                    {
                        "username": "Nitish-Devarshi",
                        "content": "class Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string allowed) {\\n        int ans=0;\\n        for(int i=0;i<words.size();i++){\\n            string s=words[i];\\n            int z=s.size();\\n            for(int k=0;k<s.size();k++){\\n               if (s[k] == allowed[k]) {\\n                   z--;\\n               }\\n            }\\n            if(z==0){\\n                ans++;\\n            }\\n        }\\n        return ans; \\n    }\\n};"
                    },
                    {
                        "username": "DeepaSingh13",
                        "content": "word =[\"feh\",\"w\",\"w\",\"lwd\",\"c\",\"s\",\"vk\",\"zwlv\",\"n\",\"w\",\"sw\",\"qrd\",\"w\",\"w\",\"mqe\",\"w\",\"w\",\"w\",\"gb\",\"w\",\"qy\",\"xs\",\"br\",\"w\",\"rypg\",\"wh\",\"g\",\"w\",\"w\",\"fh\",\"w\",\"w\",\"sccy\"]\\nString s= \"w\";\\n\\nExpected output : 14 \\nMy output : 15\\nHow the expected o/p is coming as 14 if we count manually so it is 15\\n"
                    },
                    {
                        "username": "DhanushAM",
                        "content": " \\'wh\\' is not a prefix of \\'w\\'. A prefix is a sequence of characters that appears at the beginning of a longer string. In this case, \\'w\\' is a single character, and \\'wh\\' is two characters. \\'w\\' is not a longer string containing \\'wh\\' as a prefix, so \\'wh\\' cannot be considered a prefix of \\'w\\'."
                    },
                    {
                        "username": "manuatleet12195",
                        "content": "return sum([1 for i in words if s.startswith(i)])"
                    },
                    {
                        "username": "NarayanSharma",
                        "content": "Please check the test case No 122, in this case words have \"a\" also, so its output should be 135 \\n\\n`var countPrefixes = function(words, s) {\\n    let count = 0;\\n    for(let i = 0; i < words.length; i++){\\n        if((words[i][0] === s[0]) && s.includes(words[i])){\\n            count++\\n        }\\n    }\\n    return count\\n}; `"
                    },
                    {
                        "username": "nancychauhan99",
                        "content": "What is the time complexity for best and worst case? This question has come as google interview and an official solution from leetcode is missing, why? though its a easy one but approaches to handle and TC worth discussing, NO?"
                    },
                    {
                        "username": "brandonallen",
                        "content": "[vaguely] Every solution involves some form of iterating through words[], and comparing each word to s. So if n == length(words) and m == length(s), worst case is O(n*m); if every word is a prefix, and has a length proportional to m. Best case, if every word in words isn't a prefix, and the first character isn't shared between words[i] and s, then it's O(1) time to compare each word to s, so O(n) complexity. You still have to check every word, since they aren't sorted, so you could never beat O(n).\nIf you use a trie and store the number of occurrences of each distinct element in words, if seems like you could potentially optimize slightly. But I sampled the fastest submitted code, and the constraints (n and m) are small enough that it's faster to just brute force it."
                    }
                ]
            },
            {
                "id": 1676289,
                "content": [
                    {
                        "username": "Nitish-Devarshi",
                        "content": "class Solution {\\npublic:\\n    int countPrefixes(vector<string>& words, string allowed) {\\n        int ans=0;\\n        for(int i=0;i<words.size();i++){\\n            string s=words[i];\\n            int z=s.size();\\n            for(int k=0;k<s.size();k++){\\n               if (s[k] == allowed[k]) {\\n                   z--;\\n               }\\n            }\\n            if(z==0){\\n                ans++;\\n            }\\n        }\\n        return ans; \\n    }\\n};"
                    },
                    {
                        "username": "DeepaSingh13",
                        "content": "word =[\"feh\",\"w\",\"w\",\"lwd\",\"c\",\"s\",\"vk\",\"zwlv\",\"n\",\"w\",\"sw\",\"qrd\",\"w\",\"w\",\"mqe\",\"w\",\"w\",\"w\",\"gb\",\"w\",\"qy\",\"xs\",\"br\",\"w\",\"rypg\",\"wh\",\"g\",\"w\",\"w\",\"fh\",\"w\",\"w\",\"sccy\"]\\nString s= \"w\";\\n\\nExpected output : 14 \\nMy output : 15\\nHow the expected o/p is coming as 14 if we count manually so it is 15\\n"
                    },
                    {
                        "username": "DhanushAM",
                        "content": " \\'wh\\' is not a prefix of \\'w\\'. A prefix is a sequence of characters that appears at the beginning of a longer string. In this case, \\'w\\' is a single character, and \\'wh\\' is two characters. \\'w\\' is not a longer string containing \\'wh\\' as a prefix, so \\'wh\\' cannot be considered a prefix of \\'w\\'."
                    },
                    {
                        "username": "manuatleet12195",
                        "content": "return sum([1 for i in words if s.startswith(i)])"
                    },
                    {
                        "username": "NarayanSharma",
                        "content": "Please check the test case No 122, in this case words have \"a\" also, so its output should be 135 \\n\\n`var countPrefixes = function(words, s) {\\n    let count = 0;\\n    for(let i = 0; i < words.length; i++){\\n        if((words[i][0] === s[0]) && s.includes(words[i])){\\n            count++\\n        }\\n    }\\n    return count\\n}; `"
                    },
                    {
                        "username": "nancychauhan99",
                        "content": "What is the time complexity for best and worst case? This question has come as google interview and an official solution from leetcode is missing, why? though its a easy one but approaches to handle and TC worth discussing, NO?"
                    },
                    {
                        "username": "brandonallen",
                        "content": "[vaguely] Every solution involves some form of iterating through words[], and comparing each word to s. So if n == length(words) and m == length(s), worst case is O(n*m); if every word is a prefix, and has a length proportional to m. Best case, if every word in words isn't a prefix, and the first character isn't shared between words[i] and s, then it's O(1) time to compare each word to s, so O(n) complexity. You still have to check every word, since they aren't sorted, so you could never beat O(n).\nIf you use a trie and store the number of occurrences of each distinct element in words, if seems like you could potentially optimize slightly. But I sampled the fastest submitted code, and the constraints (n and m) are small enough that it's faster to just brute force it."
                    }
                ]
            }
        ]
    },
    {
        "title": "Check if Number Has Equal Digit Count and Digit Value",
        "question_content": "<p>You are given a <strong>0-indexed</strong> string <code>num</code> of length <code>n</code> consisting of digits.</p>\n\n<p>Return <code>true</code> <em>if for <strong>every</strong> index </em><code>i</code><em> in the range </em><code>0 &lt;= i &lt; n</code><em>, the digit </em><code>i</code><em> occurs </em><code>num[i]</code><em> times in </em><code>num</code><em>, otherwise return </em><code>false</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> num = &quot;1210&quot;\n<strong>Output:</strong> true\n<strong>Explanation:</strong>\nnum[0] = &#39;1&#39;. The digit 0 occurs once in num.\nnum[1] = &#39;2&#39;. The digit 1 occurs twice in num.\nnum[2] = &#39;1&#39;. The digit 2 occurs once in num.\nnum[3] = &#39;0&#39;. The digit 3 occurs zero times in num.\nThe condition holds true for every index in &quot;1210&quot;, so return true.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> num = &quot;030&quot;\n<strong>Output:</strong> false\n<strong>Explanation:</strong>\nnum[0] = &#39;0&#39;. The digit 0 should occur zero times, but actually occurs twice in num.\nnum[1] = &#39;3&#39;. The digit 1 should occur three times, but actually occurs zero times in num.\nnum[2] = &#39;0&#39;. The digit 2 occurs zero times in num.\nThe indices 0 and 1 both violate the condition, so return false.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == num.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10</code></li>\n\t<li><code>num</code> consists of digits.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 2083839,
                "title": "brute-force-and-one-liner",
                "content": "I am sure some clever solution exists, but I did not want to spend too much time.\\n\\nYou can realize that the number of strings that match the criteria is very small - 7, to be exact (see the second solution below).\\n\\n#### Brute-Force\\n**C++**\\n```cpp\\nbool digitCount(string num) {\\n    int cnt[10] = {};\\n    for (auto n : num)\\n        ++cnt[n - \\'0\\'];\\n    for (int i = 0; i < num.size(); ++i)\\n        if (cnt[i] != num[i] - \\'0\\')\\n            return false;\\n    return true;\\n}\\n```\\n\\n#### One-Liner\\n```cpp\\nbool digitCount(string &num) {\\n    return unordered_set<string>{\"1210\", \"2020\" , \"21200\", \"3211000\", \"42101000\", \"521001000\", \"6210001000\"}.count(num);\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nbool digitCount(string num) {\\n    int cnt[10] = {};\\n    for (auto n : num)\\n        ++cnt[n - \\'0\\'];\\n    for (int i = 0; i < num.size(); ++i)\\n        if (cnt[i] != num[i] - \\'0\\')\\n            return false;\\n    return true;\\n}\\n```\n```cpp\\nbool digitCount(string &num) {\\n    return unordered_set<string>{\"1210\", \"2020\" , \"21200\", \"3211000\", \"42101000\", \"521001000\", \"6210001000\"}.count(num);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2084196,
                "title": "java-using-freq-array-easy-straightforward-solution",
                "content": "***UpVote if u find this Solution Useful***\\n\\n```\\nclass Solution {\\n    public boolean digitCount(String num) {\\n        int[] freqArr = new int[10];  // n = 10 given in constraints;\\n        \\n        \\n        for(char ch : num.toCharArray()){\\n            freqArr[ch-\\'0\\']++;\\n        }\\n        \\n        for(int i=0;i<num.length();i++){\\n            int freq = num.charAt(i)-\\'0\\';  //freq of each indexValue;\\n            freqArr[i] = freqArr[i] - freq; \\n        }\\n        for(int i=0;i<10;i++){\\n            if(freqArr[i]!=0){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean digitCount(String num) {\\n        int[] freqArr = new int[10];  // n = 10 given in constraints;\\n        \\n        \\n        for(char ch : num.toCharArray()){\\n            freqArr[ch-\\'0\\']++;\\n        }\\n        \\n        for(int i=0;i<num.length();i++){\\n            int freq = num.charAt(i)-\\'0\\';  //freq of each indexValue;\\n            freqArr[i] = freqArr[i] - freq; \\n        }\\n        for(int i=0;i<10;i++){\\n            if(freqArr[i]!=0){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2083864,
                "title": "java-python-3-simple-code",
                "content": "```java\\n    public boolean digitCount(String num) {\\n        int[] cnt = new int[11];\\n        char[] charArr = num.toCharArray();\\n        for (char d : charArr) {\\n            ++cnt[d - \\'0\\'];\\n        }\\n        for (int i = 0; i < charArr.length; ++i) {\\n            if (cnt[i] != charArr[i] - \\'0\\') {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n```\\n```python\\n    def digitCount(self, num: str) -> bool:\\n        c = Counter(map(int, num))\\n        return all(c[i] == int(d) for i, d in enumerate(num))\\n```",
                "solutionTags": [],
                "code": "```java\\n    public boolean digitCount(String num) {\\n        int[] cnt = new int[11];\\n        char[] charArr = num.toCharArray();\\n        for (char d : charArr) {\\n            ++cnt[d - \\'0\\'];\\n        }\\n        for (int i = 0; i < charArr.length; ++i) {\\n            if (cnt[i] != charArr[i] - \\'0\\') {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n```\n```python\\n    def digitCount(self, num: str) -> bool:\\n        c = Counter(map(int, num))\\n        return all(c[i] == int(d) for i, d in enumerate(num))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2083791,
                "title": "confusing-yet-simple-hashmap-solution-c",
                "content": "This question was really easy, but head scratching at the same time. I had to waste so much time only because of the confusion to chose number or character type hashmap.\\nSo, for simplicity we will maintain a int to int hashmap, which will store the frequency of a particular number.\\nThen for every index, **we have to check if the frequency of that index in hashmap is equal to the number at that index**.\\nHere is the solution too \\uD83D\\uDE0A\\n```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n        unordered_map<int,int> mpp;\\n        int n= num.length();\\n        for(auto it:num){\\n            int x = it - \\'0\\';\\n            mpp[x]++; // Store the frequency of the char as a number\\n        }\\n        for(int i=0;i<n;i++){\\n            int x = num[i] - \\'0\\'; // get the char as number\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0if(mpp[i] != x) // f the number is not equal to its frequency we return false\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n\\n```\\n\\n**Approach 2:**\\nWe just count the occurences of that index in the string. Thanks to @VisD566 for this approach.\\n\\n```\\nbool digitCount(string s) {\\n    for(int i=0; i<s.size(); i++){\\n        if(count(s.begin(), s.end(), i+\\'0\\') !=  s[i]-\\'0\\')\\n            return false;\\n    }\\n    return true;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n        unordered_map<int,int> mpp;\\n        int n= num.length();\\n        for(auto it:num){\\n            int x = it - \\'0\\';\\n            mpp[x]++; // Store the frequency of the char as a number\\n        }\\n        for(int i=0;i<n;i++){\\n            int x = num[i] - \\'0\\'; // get the char as number\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0if(mpp[i] != x) // f the number is not equal to its frequency we return false\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n\\n```\n```\\nbool digitCount(string s) {\\n    for(int i=0; i<s.size(); i++){\\n        if(count(s.begin(), s.end(), i+\\'0\\') !=  s[i]-\\'0\\')\\n            return false;\\n    }\\n    return true;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2083892,
                "title": "c-map-solution-o-n-easy-and-clean-code",
                "content": "```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n        unordered_map<char, int> mpp;\\n        \\n        for(int i=0; i<num.size(); i++)\\n            mpp[num[i]]++;\\n        \\n\\n        for(int i=0; i<num.size(); i++){\\n            char c =\\'0\\' + i;\\n            // cout<<c<<endl;\\n            if(num[i] != \\'0\\' + mpp[c]){\\n                // cout<<num[i]<<\" \"<<mpp[c]<<endl;\\n                return false;\\n            }\\n                \\n        }\\n        \\n        return true;\\n    }\\n};\\n```\\n\\n**Check out my youtube channel for related content\\nhttps://www.youtube.com/@ignition548/featured**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n        unordered_map<char, int> mpp;\\n        \\n        for(int i=0; i<num.size(); i++)\\n            mpp[num[i]]++;\\n        \\n\\n        for(int i=0; i<num.size(); i++){\\n            char c =\\'0\\' + i;\\n            // cout<<c<<endl;\\n            if(num[i] != \\'0\\' + mpp[c]){\\n                // cout<<num[i]<<\" \"<<mpp[c]<<endl;\\n                return false;\\n            }\\n                \\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3164855,
                "title": "easy-python3-solution-using-count",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def digitCount(self, num: str) -> bool:\\n        for i in range(len(num)):\\n            if int(num[i]) != num.count(str(i)):\\n                return False\\n        return True\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def digitCount(self, num: str) -> bool:\\n        for i in range(len(num)):\\n            if int(num[i]) != num.count(str(i)):\\n                return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2083889,
                "title": "straightforward",
                "content": "```\\nclass Solution {\\npublic:\\n    bool digitCount(string nums) {\\n        unordered_map<int,int> umap;\\n        for(int i=0;i<nums.length();i++)\\n        {\\n            string temp=\"\";\\n            temp+=nums[i];\\n            int n=stoi(temp);\\n            umap[n]++;\\n        }\\n        for(int i=0;i<nums.length();i++)\\n        {\\n            string temp=\"\";\\n            temp+=nums[i];\\n            int n=stoi(temp);\\n            \\n            //Number of times expected != Number of times occured \\n            if(n!=umap[i])\\n                return false;\\n                \\n        }\\n        return true;\\n    }\\n};\\n```\\n**Like it? Please Upvote ;-)**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool digitCount(string nums) {\\n        unordered_map<int,int> umap;\\n        for(int i=0;i<nums.length();i++)\\n        {\\n            string temp=\"\";\\n            temp+=nums[i];\\n            int n=stoi(temp);\\n            umap[n]++;\\n        }\\n        for(int i=0;i<nums.length();i++)\\n        {\\n            string temp=\"\";\\n            temp+=nums[i];\\n            int n=stoi(temp);\\n            \\n            //Number of times expected != Number of times occured \\n            if(n!=umap[i])\\n                return false;\\n                \\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2083808,
                "title": "java-simple",
                "content": "```\\nclass Solution {\\n    public boolean digitCount(String num) {\\n         \\n        int  indexCount[] = new int[10];\\n        \\n        for(char c:num.toCharArray()){\\n            indexCount[c-\\'0\\']++;\\n        }\\n        \\n        for(int i=0;i<num.length();i++){\\n            if(Character.getNumericValue(num.charAt(i)) != indexCount[i])\\n            return false;   \\n        }\\n            \\n        return true;\\n    }\\n}\\n   \\n\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public boolean digitCount(String num) {\\n         \\n        int  indexCount[] = new int[10];\\n        \\n        for(char c:num.toCharArray()){\\n            indexCount[c-\\'0\\']++;\\n        }\\n        \\n        for(int i=0;i<num.length();i++){\\n            if(Character.getNumericValue(num.charAt(i)) != indexCount[i])\\n            return false;   \\n        }\\n            \\n        return true;\\n    }\\n}\\n   \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2132635,
                "title": "simple-and-fast-javascript-typescript-solution",
                "content": "My simple and fast JS/TS solution:\\n```\\nfunction digitCount(num: string): boolean {\\n    const arr = Array(num.length).fill(0);\\n    for (const char of num) {\\n        arr[Number(char)]++;\\n    }\\n    return arr.join(\\'\\') === num;\\n};\\n```\\n\\nResult:\\nRuntime:\\xA073 ms, faster than\\xA097.44%\\xA0of\\xA0TypeScript\\xA0online submissions for\\xA0Check if Number Has Equal Digit Count and Digit Value.\\nMemory Usage:\\xA044.5 MB, less than\\xA053.85%\\xA0of\\xA0TypeScript\\xA0online submissions for\\xA0Check if Number Has Equal Digit Count and Digit Value.\\n",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nfunction digitCount(num: string): boolean {\\n    const arr = Array(num.length).fill(0);\\n    for (const char of num) {\\n        arr[Number(char)]++;\\n    }\\n    return arr.join(\\'\\') === num;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2083994,
                "title": "python-3-using-counter-fast-solution-one-liner",
                "content": "Approach: Create a dict storing frequency of each number and then just compare the index with frequency.\\n\\n```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def digitCount(self, num: str) -> bool:\\n        d = Counter(num)\\n        for i in range(len(num)):\\n            if int(num[i])!=d.get(str(i), 0):\\n                return False\\n        return True\\n```\\n\\nTwo-Liner:\\n\\n```\\n\\nclass Solution:\\n    def digitCount(self, num: str) -> bool:\\n        d = collections.Counter(num)\\n        return all([int(num[i])==d.get(str(i), 0) for i in range(len(num))])\\n```\\n\\nOne Liner (slight modification):\\n\\n```\\n\\nclass Solution:\\n    def digitCount(self, num: str) -> bool:\\n        return all([int(num[i])==Counter(num)[f\\'{i}\\'] for i in range(len(num))])\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def digitCount(self, num: str) -> bool:\\n        d = Counter(num)\\n        for i in range(len(num)):\\n            if int(num[i])!=d.get(str(i), 0):\\n                return False\\n        return True\\n```\n```\\n\\nclass Solution:\\n    def digitCount(self, num: str) -> bool:\\n        d = collections.Counter(num)\\n        return all([int(num[i])==d.get(str(i), 0) for i in range(len(num))])\\n```\n```\\n\\nclass Solution:\\n    def digitCount(self, num: str) -> bool:\\n        return all([int(num[i])==Counter(num)[f\\'{i}\\'] for i in range(len(num))])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2084001,
                "title": "brute-force-c-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n        unordered_map<char,int> mp;\\n        for(int i=0;i<num.length();i++)\\n        {\\n             mp[num[i]]++;\\n        }\\n        for(auto ele: mp)\\n        {\\n            \\n            if(ele.second!=num[ele.first-\\'0\\']-\\'0\\')\\n                return false;\\n        }\\n        return true;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n        unordered_map<char,int> mp;\\n        for(int i=0;i<num.length();i++)\\n        {\\n             mp[num[i]]++;\\n        }\\n        for(auto ele: mp)\\n        {\\n            \\n            if(ele.second!=num[ele.first-\\'0\\']-\\'0\\')\\n                return false;\\n        }\\n        return true;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2730033,
                "title": "c-easy-explained-map",
                "content": "1. create a map to calculate the frequency\\n2. iterate the string & check if frequncy is same with index+1 if not matched return false\\n3. else return true\\n\\n```\\nclass Solution {\\npublic:\\n    bool digitCount(string s) {\\n        unordered_map<char, int>mp;\\n        for(int i=0;i<s.size();i++)\\n            mp[s[i]]++;\\n        for(int i=0; i<s.size(); i++)\\n        {\\n            char c=i+\\'0\\';\\n            if(mp[c]!=s[i]-\\'0\\')\\n                return false;\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool digitCount(string s) {\\n        unordered_map<char, int>mp;\\n        for(int i=0;i<s.size();i++)\\n            mp[s[i]]++;\\n        for(int i=0; i<s.size(); i++)\\n        {\\n            char c=i+\\'0\\';\\n            if(mp[c]!=s[i]-\\'0\\')\\n                return false;\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2322016,
                "title": "easy-python-solution-using-hashmap",
                "content": "```\\nclass Solution:\\n    def digitCount(self, num: str) -> bool:\\n        \\n        h = {}\\n        n = len(num)\\n        \\n        for i in range(n):\\n            h[i] = num[i]\\n            \\n        for i in h:\\n            if(num.count(str(i))!=int(h[i])):\\n                return 0\\n        \\n        return 1\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def digitCount(self, num: str) -> bool:\\n        \\n        h = {}\\n        n = len(num)\\n        \\n        for i in range(n):\\n            h[i] = num[i]\\n            \\n        for i in h:\\n            if(num.count(str(i))!=int(h[i])):\\n                return 0\\n        \\n        return 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2100089,
                "title": "easy-python-solution",
                "content": "```\\ndef digitCount(self, num: str) -> bool:\\n        for i in range(len(num)):\\n            if num.count(str(i))!=int(num[i]):\\n                return False\\n        return True\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef digitCount(self, num: str) -> bool:\\n        for i in range(len(num)):\\n            if num.count(str(i))!=int(num[i]):\\n                return False\\n        return True\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2089906,
                "title": "o-n-solution",
                "content": "```\\nclass Solution {\\n    public boolean digitCount(String num) {\\n          HashMap<Integer,Integer> map = new HashMap<>();\\n//        First we are marking the frequency for the number. As we are given in the question, num.charAt(i) is the\\n//        frequency of the number i in the num String.\\n        for(int number = 0; number < num.length(); number++){\\n            int frequency = Character.getNumericValue(num.charAt(number));\\n            map.put(number,frequency);\\n        }\\n//        Now we are traversing through the string.\\n        for(int index = 0; index< num.length(); index++) {\\n//            If character at index i is less than num.length(), then only we need to know its frequency.\\n            if (Character.getNumericValue(num.charAt(index)) < num.length()) {\\n//                Get the frequency of the number and subtract 1 from it if it is present.\\n                int frequency = map.get(Character.getNumericValue(num.charAt(index))) - 1;\\n                map.put(Character.getNumericValue(num.charAt(index)), frequency);\\n            }\\n        }\\n//      If all the values are 0 , then only it is right otherwise , the frequency is either more or less than the\\n//        specified frequency, hence return false;\\n        for (int i = 0; i < num.length(); i++) {\\n            if(map.get(i) !=0){\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n```\\nIf you liked the solution or found the solution unique , please upvote :)\\nThank you",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean digitCount(String num) {\\n          HashMap<Integer,Integer> map = new HashMap<>();\\n//        First we are marking the frequency for the number. As we are given in the question, num.charAt(i) is the\\n//        frequency of the number i in the num String.\\n        for(int number = 0; number < num.length(); number++){\\n            int frequency = Character.getNumericValue(num.charAt(number));\\n            map.put(number,frequency);\\n        }\\n//        Now we are traversing through the string.\\n        for(int index = 0; index< num.length(); index++) {\\n//            If character at index i is less than num.length(), then only we need to know its frequency.\\n            if (Character.getNumericValue(num.charAt(index)) < num.length()) {\\n//                Get the frequency of the number and subtract 1 from it if it is present.\\n                int frequency = map.get(Character.getNumericValue(num.charAt(index))) - 1;\\n                map.put(Character.getNumericValue(num.charAt(index)), frequency);\\n            }\\n        }\\n//      If all the values are 0 , then only it is right otherwise , the frequency is either more or less than the\\n//        specified frequency, hence return false;\\n        for (int i = 0; i < num.length(); i++) {\\n            if(map.get(i) !=0){\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2084112,
                "title": "python-easy-solution",
                "content": "```\\nclass Solution:\\n    def digitCount(self, num: str) -> bool:\\n        counter=Counter(num)\\n        for i in range(len(num)):\\n            if counter[f\\'{i}\\'] != int(num[i]):\\n                return False\\n        return True\\n```\\n\\n**Time - O(n)\\nSpace - O(n)**\\n\\n---\\n\\n***Please upvote if you find it useful***",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def digitCount(self, num: str) -> bool:\\n        counter=Counter(num)\\n        for i in range(len(num)):\\n            if counter[f\\'{i}\\'] != int(num[i]):\\n                return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3363169,
                "title": "simple-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean digitCount(String num) {\\n        int[]arr = new int[10];\\n\\n      for(int i=0;i<num.length();i++){\\n          arr[num.charAt(i)-\\'0\\']+=1;\\n      }\\n      //System.out.println(Arrays.toString(arr));\\n   \\n\\n      for(int i=0;i<num.length();i++){\\n          if(arr[i]!=num.charAt(i)-\\'0\\'){\\n              return false;\\n          }\\n      }\\n     return true;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean digitCount(String num) {\\n        int[]arr = new int[10];\\n\\n      for(int i=0;i<num.length();i++){\\n          arr[num.charAt(i)-\\'0\\']+=1;\\n      }\\n      //System.out.println(Arrays.toString(arr));\\n   \\n\\n      for(int i=0;i<num.length();i++){\\n          if(arr[i]!=num.charAt(i)-\\'0\\'){\\n              return false;\\n          }\\n      }\\n     return true;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3282316,
                "title": "java-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n  public boolean digitCount(String num) {\\n    final char[] digit = num.toCharArray(); // convert string to char array\\n    final int n = digit.length; // length of char array\\n    int[] count = new int[10]; // count arr length 10 because constraint 1<=n<=10\\n    for (char c : digit) {\\n      count[c - \\'0\\']++; // count of digits \\n    }\\n    for (int i = 0; i < n; i++) {\\n      if (digit[i] - \\'0\\' != count[i]) { // check \\n        return false;\\n      }\\n    }\\n\\n    return true;\\n  }\\n}\\n\\n// DRY RUN TO CLEARLY UNDERSTAND THE WORKING OF CODE \\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n  public boolean digitCount(String num) {\\n    final char[] digit = num.toCharArray(); // convert string to char array\\n    final int n = digit.length; // length of char array\\n    int[] count = new int[10]; // count arr length 10 because constraint 1<=n<=10\\n    for (char c : digit) {\\n      count[c - \\'0\\']++; // count of digits \\n    }\\n    for (int i = 0; i < n; i++) {\\n      if (digit[i] - \\'0\\' != count[i]) { // check \\n        return false;\\n      }\\n    }\\n\\n    return true;\\n  }\\n}\\n\\n// DRY RUN TO CLEARLY UNDERSTAND THE WORKING OF CODE \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2600012,
                "title": "java-hashmap-string-straightforward-solution",
                "content": "```\\nclass Solution {\\n    public boolean digitCount(String num) {\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        for(int i=0;i<num.length();i++){\\n            int n = Character.getNumericValue(num.charAt(i));\\n            map.put(n,map.getOrDefault(n,0)+1);\\n        }\\n        for(int i=0;i<num.length();i++){\\n            if(map.containsKey(i)){\\n                int nn = map.get(i);\\n                if(nn!=Character.getNumericValue(num.charAt(i)))\\n                    return false;\\n            }\\n            else{\\n                if(Character.getNumericValue(num.charAt(i))>0)\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```\\nKindly upvote if you like the code.",
                "solutionTags": [
                    "Java",
                    "String",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\n    public boolean digitCount(String num) {\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        for(int i=0;i<num.length();i++){\\n            int n = Character.getNumericValue(num.charAt(i));\\n            map.put(n,map.getOrDefault(n,0)+1);\\n        }\\n        for(int i=0;i<num.length();i++){\\n            if(map.containsKey(i)){\\n                int nn = map.get(i);\\n                if(nn!=Character.getNumericValue(num.charAt(i)))\\n                    return false;\\n            }\\n            else{\\n                if(Character.getNumericValue(num.charAt(i))>0)\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2115384,
                "title": "python-fast-solution-faster-than-93",
                "content": "![image](https://assets.leetcode.com/users/images/2cc0a03a-545f-4144-a1be-d86804fc0d45_1654452047.1386557.png)\\n\\n```\\nclass Solution:\\n    def digitCount(self, num: str) -> bool:\\n        base = {}\\n        for i in range(len(num)):\\n            if base.get(num[i], None) is None:\\n                base[num[i]]=1\\n            else:\\n                base[num[i]]+=1\\n            if base.get(str(i), None) is None:\\n                base[str(i)]=0\\n                \\n        for i in range(len(num)):\\n            if str(base[str(i)])!=num[i]:\\n                return False\\n        return True\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def digitCount(self, num: str) -> bool:\\n        base = {}\\n        for i in range(len(num)):\\n            if base.get(num[i], None) is None:\\n                base[num[i]]=1\\n            else:\\n                base[num[i]]+=1\\n            if base.get(str(i), None) is None:\\n                base[str(i)]=0\\n                \\n        for i in range(len(num)):\\n            if str(base[str(i)])!=num[i]:\\n                return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2084818,
                "title": "c-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n        int n=num.length();\\n        map<int,int> mp;\\n        for(int i=0;i<n;i++){\\n            mp[num[i]-\\'0\\']++;\\n        }\\n        for(int i=0;i<n;i++){\\n            if(mp[i]!=num[i]-\\'0\\'){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n        int n=num.length();\\n        map<int,int> mp;\\n        for(int i=0;i<n;i++){\\n            mp[num[i]-\\'0\\']++;\\n        }\\n        for(int i=0;i<n;i++){\\n            if(mp[i]!=num[i]-\\'0\\'){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2084006,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public boolean digitCount(String num) {\\n        \\n        int[] result = new int[10];\\n        for(int i=0;i<num.length();i++)\\n        {\\n            result[num.charAt(i)-\\'0\\']++;\\n        }\\n      \\n       for(int i=0;i<num.length();i++)\\n       {\\n           if(num.charAt(i)-\\'0\\'!=result[i])\\n              return false;\\n       }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public boolean digitCount(String num) {\\n        \\n        int[] result = new int[10];\\n        for(int i=0;i<num.length();i++)\\n        {\\n            result[num.charAt(i)-\\'0\\']++;\\n        }\\n      \\n       for(int i=0;i<num.length();i++)\\n       {\\n           if(num.charAt(i)-\\'0\\'!=result[i])\\n              return false;\\n       }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2083852,
                "title": "javascript-map",
                "content": "```js\\n/**\\n * @param {string} num\\n * @return {boolean}\\n */\\nvar digitCount = function(num) {\\n    const numLength = num.length;\\n    const numArray = num.split(\\'\\').map(Number);\\n    let result = \"\";\\n    \\n    const numFreq = numArray.reduce((acc,item)=>acc.set(item,acc.get(item) + 1 || 1),new Map())\\n    \\n    for(let i=0;i<numLength;i++){\\n        result+=numFreq.get(i) || \"0\";        \\n    }\\n    \\n    return result === num\\n};\\n```",
                "solutionTags": [],
                "code": "```js\\n/**\\n * @param {string} num\\n * @return {boolean}\\n */\\nvar digitCount = function(num) {\\n    const numLength = num.length;\\n    const numArray = num.split(\\'\\').map(Number);\\n    let result = \"\";\\n    \\n    const numFreq = numArray.reduce((acc,item)=>acc.set(item,acc.get(item) + 1 || 1),new Map())\\n    \\n    for(let i=0;i<numLength;i++){\\n        result+=numFreq.get(i) || \"0\";        \\n    }\\n    \\n    return result === num\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3955024,
                "title": "java-100-beats-0-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:0(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:0(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean digitCount(String num) {\\n        char temp[] = new char[11];\\n        int temp1 = 0 , temp2 = 0;\\n        for(int i=0; i<num.length(); i++){\\n            char ch = num.charAt(i); temp1 = ch-\\'0\\';\\n            temp[temp1]++;\\n        }\\n        for(int i=0; i<num.length(); i++){\\n            char ch = num.charAt(i); temp2 = ch-\\'0\\';\\n            if(temp[i]!=temp2) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean digitCount(String num) {\\n        char temp[] = new char[11];\\n        int temp1 = 0 , temp2 = 0;\\n        for(int i=0; i<num.length(); i++){\\n            char ch = num.charAt(i); temp1 = ch-\\'0\\';\\n            temp[temp1]++;\\n        }\\n        for(int i=0; i<num.length(); i++){\\n            char ch = num.charAt(i); temp2 = ch-\\'0\\';\\n            if(temp[i]!=temp2) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3437755,
                "title": "easy-java-beats-99",
                "content": "# Intuition\\nconsidering {1210}\\n\\n    HASHMAP :\\n\\n    {\\n        0:1\\n        1:2\\n        2:3\\n    }\\n\\n    index : 0 1 2 3\\n    number: 1 2 1 0\\n\\n    according to the question,\\n\\n    num[i] should be equal to frequency of index i\\n\\n    let x = num.charAt(i)\\n    convert character to integer using -\\n    int a = x - \\'0\\';\\n\\n    thus, if(a != frequency of a) i.e if(a != map.get(i)) return false;\\n\\n\\n    but to avoid null pointer exception, we must check if the hashmap contains all indices or not, if it doesnt, then num[i] must be 0 as in this case,\\n\\nindex 3 is not in hashmap {\\n        0:1\\n        1:2\\n        2:3\\n    }\\n\\nso , if it doesnot contain in hashmap (! map.containsKey(i))\\n\\nthen check if num[i] must be 0, else return false;,\\nif it is 0, then continue\\n\\n# Time Complexity - O(n)\\n# Space Complexity - O(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean digitCount(String num) {\\n\\n        //creating an integer - integer hashmap\\n\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n\\n        for(int i = 0; i < num.length(); i++)\\n        {\\n            char x = num.charAt(i);\\n\\n            int a = x - \\'0\\'; // to create character to integer\\n\\n            if(map.containsKey(a))\\n                map.put(a,map.get(a)+1);\\n\\n            else\\n                map.put(a,1);\\n\\n        }\\n\\n        for(int i = 0; i<num.length(); i++)\\n        {\\n\\n            // to avoid nullPointerException\\n\\n            if(!map.containsKey(i))\\n            {\\n                if(num.charAt(i)!=\\'0\\') //it must be 0, else false\\n                    return false;\\n                else //if it is 0, then continue\\n                    continue;\\n            }\\n            char x = num.charAt(i); //let num[i] = x\\n            int a = x - \\'0\\'; //convert x to int\\n            if(a!=map.get(i)) //check if its equal to frequency\\n                return false;\\n\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public boolean digitCount(String num) {\\n\\n        //creating an integer - integer hashmap\\n\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n\\n        for(int i = 0; i < num.length(); i++)\\n        {\\n            char x = num.charAt(i);\\n\\n            int a = x - \\'0\\'; // to create character to integer\\n\\n            if(map.containsKey(a))\\n                map.put(a,map.get(a)+1);\\n\\n            else\\n                map.put(a,1);\\n\\n        }\\n\\n        for(int i = 0; i<num.length(); i++)\\n        {\\n\\n            // to avoid nullPointerException\\n\\n            if(!map.containsKey(i))\\n            {\\n                if(num.charAt(i)!=\\'0\\') //it must be 0, else false\\n                    return false;\\n                else //if it is 0, then continue\\n                    continue;\\n            }\\n            char x = num.charAt(i); //let num[i] = x\\n            int a = x - \\'0\\'; //convert x to int\\n            if(a!=map.get(i)) //check if its equal to frequency\\n                return false;\\n\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3359639,
                "title": "easy-beginner-friendly-solution-using-frequency-hashmap",
                "content": "# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nfrom collections import Counter\\nclass Solution:\\n    def digitCount(self, num: str) -> bool:\\n        dic=Counter(num)\\n        c=0\\n        for i in range(len(num)):\\n            if dic[str(i)]==int(num[i]):\\n                c+=1\\n                \\n        if c==len(num):\\n            return 1\\n        return 0\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table"
                ],
                "code": "```\\nfrom collections import Counter\\nclass Solution:\\n    def digitCount(self, num: str) -> bool:\\n        dic=Counter(num)\\n        c=0\\n        for i in range(len(num)):\\n            if dic[str(i)]==int(num[i]):\\n                c+=1\\n                \\n        if c==len(num):\\n            return 1\\n        return 0\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3312486,
                "title": "c-solution-brute-force-hash-table",
                "content": "# Approach : Brute Force\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n        \\n    vector<int> v(10,0);\\n    for (int i = 0; i < num.size(); i++)\\n        v[num[i] - \\'0\\']++;\\n\\n    for (int i = 0; i < num.size(); i++)\\n        if (num[i] - \\'0\\' != v[i])\\n           return false;\\n\\n    return true;\\n\\n    }\\n};\\n```\\n# Approach : Hash Table\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n        \\n    unordered_map<int, int> m;\\n    for (auto e : num)\\n        m[e - \\'0\\']++;\\n\\n    for (int i = 0; i < num.size(); i++)\\n        if (m[i] != num[i] - \\'0\\')\\n            return false;\\n    return true;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n        \\n    vector<int> v(10,0);\\n    for (int i = 0; i < num.size(); i++)\\n        v[num[i] - \\'0\\']++;\\n\\n    for (int i = 0; i < num.size(); i++)\\n        if (num[i] - \\'0\\' != v[i])\\n           return false;\\n\\n    return true;\\n\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n        \\n    unordered_map<int, int> m;\\n    for (auto e : num)\\n        m[e - \\'0\\']++;\\n\\n    for (int i = 0; i < num.size(); i++)\\n        if (m[i] != num[i] - \\'0\\')\\n            return false;\\n    return true;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3278845,
                "title": "c-easy-simple",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\no(k)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool digitCount(string nums) {\\n        unordered_map<int,int>mp;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            mp[nums[i]-\\'0\\']++;\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            if(mp[i]!=nums[i]-\\'0\\')\\n                return 0;\\n        }\\n        return 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool digitCount(string nums) {\\n        unordered_map<int,int>mp;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            mp[nums[i]-\\'0\\']++;\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            if(mp[i]!=nums[i]-\\'0\\')\\n                return 0;\\n        }\\n        return 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3237543,
                "title": "easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool digitCount(string nums) {\\n        unordered_map<int,int>mp;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            mp[nums[i]-\\'0\\']++;\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            if(mp[i]!=nums[i]-\\'0\\')\\n                return 0;\\n        }\\n        return 1;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool digitCount(string nums) {\\n        unordered_map<int,int>mp;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            mp[nums[i]-\\'0\\']++;\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            if(mp[i]!=nums[i]-\\'0\\')\\n                return 0;\\n        }\\n        return 1;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2852794,
                "title": "beats-99-easy-python-solution",
                "content": "```\\nclass Solution:\\n    def digitCount(self, num: str) -> bool:\\n        checked = set()\\n        i = 0\\n        while i < len(num):\\n            if num[i] not in checked:\\n                count = num.count(str(i))\\n                if int(num[i]) != count:\\n                    return False\\n                else:\\n                    checked.add(num[i])\\n                    i += 1\\n            else:\\n                i += 1\\n        \\n        return True\\n``",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def digitCount(self, num: str) -> bool:\\n        checked = set()\\n        i = 0\\n        while i < len(num):\\n            if num[i] not in checked:\\n                count = num.count(str(i))\\n                if int(num[i]) != count:\\n                    return False\\n                else:\\n                    checked.add(num[i])\\n                    i += 1\\n            else:\\n                i += 1\\n        \\n        return True\\n``",
                "codeTag": "Java"
            },
            {
                "id": 2561099,
                "title": "java-c-one-liner-100-00-0-ms-o-1",
                "content": "**UPVOTE PLEASE**\\n```\\ncpp:\\n\\n\\n    return unordered_set<string>{\"1210\", \"2020\" , \"21200\", \"3211000\", \"42101000\", \"521001000\", \"6210001000\"}.count(num);\\n\\t\\n\\tjava:\\n\\t\\n\\treturn new HashSet<String>(List.of(\"1210\", \"2020\" , \"21200\", \"3211000\", \"42101000\", \"521001000\", \"6210001000\")).contains(num); \\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "C"
                ],
                "code": "```\\ncpp:\\n\\n\\n    return unordered_set<string>{\"1210\", \"2020\" , \"21200\", \"3211000\", \"42101000\", \"521001000\", \"6210001000\"}.count(num);\\n\\t\\n\\tjava:\\n\\t\\n\\treturn new HashSet<String>(List.of(\"1210\", \"2020\" , \"21200\", \"3211000\", \"42101000\", \"521001000\", \"6210001000\")).contains(num); \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2530024,
                "title": "here-is-my-solution",
                "content": "*****plz upvote if you find my solution helpful*****\\n```\\nclass Solution:\\n    def digitCount(self, n: str) -> bool:\\n        l=len(n)\\n        for i in range(l):\\n            if n.count(str(i))!=int(n[i]):\\n                \\n                return False\\n        return True\\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def digitCount(self, n: str) -> bool:\\n        l=len(n)\\n        for i in range(l):\\n            if n.count(str(i))!=int(n[i]):\\n                \\n                return False\\n        return True\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2210762,
                "title": "java-easy-to-understand-2-hashmaps",
                "content": "```\\nclass Solution {\\n    public boolean digitCount(String num) {\\n        // Create a map for given frequencies\\n        HashMap<Character, Integer> givenFreqMap = new HashMap<>();\\n        \\n        // Create a map to count frequencies manually\\n        HashMap<Character, Integer> countFreqMap = new HashMap<>();\\n        \\n        // Loop through num\\n        for(int i = 0; i < num.length(); i++){\\n            \\n            // We only want to put in map if value at index is not equals to 0\\n            // because 0 means it\\'s not in the string so we do not need that\\n            if(num.charAt(i) != \\'0\\'){\\n                // Add to givenFreqMap convert the index to char and it\\'s value from char to int\\n                givenFreqMap.put((char)(i+\\'0\\'), num.charAt(i) - \\'0\\');\\n            }\\n        }\\n        \\n        // Loop through num     \\n        for(char c : num.toCharArray()){\\n            \\n            // Add to countFreqMap and count thier frequencies\\n            countFreqMap.put(c, countFreqMap.getOrDefault(c, 0) + 1);\\n        }\\n                 \\n        // If the characters and its frequencies are same in both map then return true, else false\\n        return givenFreqMap.equals(countFreqMap);\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean digitCount(String num) {\\n        // Create a map for given frequencies\\n        HashMap<Character, Integer> givenFreqMap = new HashMap<>();\\n        \\n        // Create a map to count frequencies manually\\n        HashMap<Character, Integer> countFreqMap = new HashMap<>();\\n        \\n        // Loop through num\\n        for(int i = 0; i < num.length(); i++){\\n            \\n            // We only want to put in map if value at index is not equals to 0\\n            // because 0 means it\\'s not in the string so we do not need that\\n            if(num.charAt(i) != \\'0\\'){\\n                // Add to givenFreqMap convert the index to char and it\\'s value from char to int\\n                givenFreqMap.put((char)(i+\\'0\\'), num.charAt(i) - \\'0\\');\\n            }\\n        }\\n        \\n        // Loop through num     \\n        for(char c : num.toCharArray()){\\n            \\n            // Add to countFreqMap and count thier frequencies\\n            countFreqMap.put(c, countFreqMap.getOrDefault(c, 0) + 1);\\n        }\\n                 \\n        // If the characters and its frequencies are same in both map then return true, else false\\n        return givenFreqMap.equals(countFreqMap);\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2194225,
                "title": "python-easy-2-liner-faster-than-93",
                "content": "```\\nclass Solution:\\n    def digitCount(self, num: str) -> bool:            \\n        for i in range(len(num)):\\n            if(num.count(str(i))!=int(num[i])): return False\\n        return True\\n```\\n***Pls upvote if you find it helpful***",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def digitCount(self, num: str) -> bool:            \\n        for i in range(len(num)):\\n            if(num.count(str(i))!=int(num[i])): return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2122515,
                "title": "easy-java-solution-using-hashmap",
                "content": "```\\nclass Solution {\\n    public boolean digitCount(String num) \\n    {\\n        HashMap<Integer,Integer> hmap = new HashMap<>();\\n        for(char ch:num.toCharArray())\\n            hmap.put(Character.getNumericValue(ch),hmap.getOrDefault(Character.getNumericValue(ch),0)+1);\\n        \\n        for(int i=0;i<num.length();i++)\\n        {\\n            if(hmap.get(i)!=null && hmap.get(i)!=Character.getNumericValue(num.charAt(i)))\\n                return false;\\n            else if(hmap.get(i)==null && Character.getNumericValue(num.charAt(i))!=0)\\n                return false;\\n        }\\n        return true;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public boolean digitCount(String num) \\n    {\\n        HashMap<Integer,Integer> hmap = new HashMap<>();\\n        for(char ch:num.toCharArray())\\n            hmap.put(Character.getNumericValue(ch),hmap.getOrDefault(Character.getNumericValue(ch),0)+1);\\n        \\n        for(int i=0;i<num.length();i++)\\n        {\\n            if(hmap.get(i)!=null && hmap.get(i)!=Character.getNumericValue(num.charAt(i)))\\n                return false;\\n            else if(hmap.get(i)==null && Character.getNumericValue(num.charAt(i))!=0)\\n                return false;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2087105,
                "title": "rust-solution",
                "content": "```\\nimpl Solution {\\n    pub fn digit_count(num: String) -> bool {\\n        let mut counter = [0; 10];\\n        let num_it = num.bytes().map(|b| (b - b\\'0\\') as usize);\\n        num_it.clone().for_each(|idx| counter[idx] += 1);\\n        num_it.enumerate().all(|(i, idx)| counter[i] == idx)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn digit_count(num: String) -> bool {\\n        let mut counter = [0; 10];\\n        let num_it = num.bytes().map(|b| (b - b\\'0\\') as usize);\\n        num_it.clone().for_each(|idx| counter[idx] += 1);\\n        num_it.enumerate().all(|(i, idx)| counter[i] == idx)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2085306,
                "title": "very-easy-c-solution-using-1-for-loop",
                "content": "```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n        for(int i=0;i<num.length();i++){\\n\\t\\t\\t// int to char\\n            char ch =  i + \\'0\\';\\n\\t\\t\\t\\n\\t\\t\\t// count no. of occurance\\n            int req = count(num.begin(),num.end(),ch);\\n\\t\\t\\t\\n\\t\\t\\t// check the given condtion\\n            if(req!=(num[i]-\\'0\\'))     return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n        for(int i=0;i<num.length();i++){\\n\\t\\t\\t// int to char\\n            char ch =  i + \\'0\\';\\n\\t\\t\\t\\n\\t\\t\\t// count no. of occurance\\n            int req = count(num.begin(),num.end(),ch);\\n\\t\\t\\t\\n\\t\\t\\t// check the given condtion\\n            if(req!=(num[i]-\\'0\\'))     return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2084641,
                "title": "python-easy-understanding-solution",
                "content": "```\\nclass Solution:\\n    def digitCount(self, num: str) -> bool:\\n        n=len(num)\\n        \\n        for i in range(n):\\n            if(num.count(str(i))!=int(num[i])):\\n                return False\\n            \\n        return True",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def digitCount(self, num: str) -> bool:\\n        n=len(num)\\n        \\n        for i in range(n):\\n            if(num.count(str(i))!=int(num[i])):\\n                return False\\n            \\n        return True",
                "codeTag": "Java"
            },
            {
                "id": 2084158,
                "title": "o-n-solution-using-map",
                "content": "```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n        map<int,int> m;\\n        int n=num.size();\\n        for(int i=0;i<n;i++){\\n            m[num[i]-\\'0\\']++;\\n        }\\n        for(int i=0;i<n;i++ ){\\n            if(num[i]==\\'0\\'&&m.find(i)==m.end())continue;\\n            if(m.find(i)!=m.end()&&m[i]==(num[i]-\\'0\\'))continue;\\n            return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n        map<int,int> m;\\n        int n=num.size();\\n        for(int i=0;i<n;i++){\\n            m[num[i]-\\'0\\']++;\\n        }\\n        for(int i=0;i<n;i++ ){\\n            if(num[i]==\\'0\\'&&m.find(i)==m.end())continue;\\n            if(m.find(i)!=m.end()&&m[i]==(num[i]-\\'0\\'))continue;\\n            return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2084130,
                "title": "javascript-counter-105ms",
                "content": "```\\nconst counter = (a_or_s) => { let m = new Map(); for (const x of a_or_s) m.set(x, m.get(x) + 1 || 1); return m; };\\n\\nconst digitCount = (a) => {\\n    let m = counter(a), n = a.length;\\n    for (let i = 0; i < n; i++) {\\n        let cnt = m.get(i + \\'\\') || 0\\n        if (a[i] != cnt) return false;\\n    }\\n    return true;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst counter = (a_or_s) => { let m = new Map(); for (const x of a_or_s) m.set(x, m.get(x) + 1 || 1); return m; };\\n\\nconst digitCount = (a) => {\\n    let m = counter(a), n = a.length;\\n    for (let i = 0; i < n; i++) {\\n        let cnt = m.get(i + \\'\\') || 0\\n        if (a[i] != cnt) return false;\\n    }\\n    return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2084121,
                "title": "python3-very-elegant-and-straightforward",
                "content": "\\n```\\n        c = Counter(num)\\n        for idx, x in enumerate(num):\\n            if c[str(idx)] != int(x):\\n                return False\\n        return True\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n        c = Counter(num)\\n        for idx, x in enumerate(num):\\n            if c[str(idx)] != int(x):\\n                return False\\n        return True\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2084061,
                "title": "brute-force-c-100",
                "content": "class Solution {\\npublic:\\n    bool digitCount(string num) {\\n        int count=0;\\n        bool ans=true;\\n        for(int i=0;i<num.size();i++){\\n            for(int j=0;j<num.size();j++){\\n                if((num[j]-\\'0\\')==i){\\n                    count=count+1;\\n                }\\n            }\\n            if((num[i]-\\'0\\')!=count){\\n                ans=false; \\n            }\\n            count=0;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "class Solution {\\npublic:\\n    bool digitCount(string num) {\\n        int count=0;\\n        bool ans=true;\\n        for(int i=0;i<num.size();i++){\\n            for(int j=0;j<num.size();j++){\\n                if((num[j]-\\'0\\')==i){\\n                    count=count+1;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2083804,
                "title": "2-liner-c",
                "content": "```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n        for(int i=0;i<num.size();i++) if(count(num.begin(),num.end(),(i+\\'0\\')) != num[i]-\\'0\\') return false;\\n        return true;\\n    }\\n};\\n```\\n\\n\\n\\n**With Using Extra space :** \\n```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n        unordered_map<char,int> mpp;\\n        for(auto c : num) mpp[c]++;\\n        for(int i=0;i<num.size();i++){\\n            char c = (char)i+\\'0\\';\\n            if(num[i]-\\'0\\' != mpp[c]) return false;\\n        }\\n         return true;\\n     \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n        for(int i=0;i<num.size();i++) if(count(num.begin(),num.end(),(i+\\'0\\')) != num[i]-\\'0\\') return false;\\n        return true;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n        unordered_map<char,int> mpp;\\n        for(auto c : num) mpp[c]++;\\n        for(int i=0;i<num.size();i++){\\n            char c = (char)i+\\'0\\';\\n            if(num[i]-\\'0\\' != mpp[c]) return false;\\n        }\\n         return true;\\n     \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3936222,
                "title": "python-beginner-friendly-explanation-beats-91",
                "content": "# Approach\\nSimple Compare the count of current index with value at corrent index\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def digitCount(self, num: str) -> bool:\\n        for i in range(len(num)):\\n            if num.count(str(i)) != int(num[i]):\\n                return False\\n        return True        \\n```",
                "solutionTags": [
                    "Python3",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def digitCount(self, num: str) -> bool:\\n        for i in range(len(num)):\\n            if num.count(str(i)) != int(num[i]):\\n                return False\\n        return True        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3904905,
                "title": "easy-approach-for-beginners-time-complexity-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def digitCount(self, num: str) -> bool:\\n        for i in range(len(num)):\\n            if num.count(str(i))!=int(num[i]):\\n                return False\\n        return True\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def digitCount(self, num: str) -> bool:\\n        for i in range(len(num)):\\n            if num.count(str(i))!=int(num[i]):\\n                return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3577641,
                "title": "java-simple-solution-hashmap-counting-100-faster",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    public boolean digitCount(String num) {\\n        Map<Integer, Integer> occurrence = new HashMap<>(num.length());\\n        for (int i = 0; i < num.length(); i++) {\\n            int currentDigit = num.charAt(i) - \\'0\\';\\n            occurrence.put(currentDigit, occurrence.getOrDefault(currentDigit, 0) + 1);\\n        }\\n\\n        for (int i = 0; i < num.length(); i++) {\\n            int currentDigit = num.charAt(i) - \\'0\\';\\n            int count = 0;\\n            if (occurrence.containsKey(i)) {\\n                count = occurrence.get(i);\\n            }\\n            if (count != currentDigit) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "String",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\n\\n    public boolean digitCount(String num) {\\n        Map<Integer, Integer> occurrence = new HashMap<>(num.length());\\n        for (int i = 0; i < num.length(); i++) {\\n            int currentDigit = num.charAt(i) - \\'0\\';\\n            occurrence.put(currentDigit, occurrence.getOrDefault(currentDigit, 0) + 1);\\n        }\\n\\n        for (int i = 0; i < num.length(); i++) {\\n            int currentDigit = num.charAt(i) - \\'0\\';\\n            int count = 0;\\n            if (occurrence.containsKey(i)) {\\n                count = occurrence.get(i);\\n            }\\n            if (count != currentDigit) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3573736,
                "title": "check-if-number-has-equal-digit-count-and-digit-value-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^2)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n        int i, j, count=0;\\n        for(i=0 ; i<num.length() ; i++)\\n        {\\n            count=0;\\n            for(j=0 ; j<num.length() ; j++)\\n            {\\n                if(i==(int)num[j]-48)\\n                {\\n                    count++;\\n                }\\n            }\\n            if((int)num[i]-48!=count)\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```\\n![upvote new.jpg](https://assets.leetcode.com/users/images/98f8d2dd-d2eb-4f98-991a-e52107e37b08_1685332542.106816.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n        int i, j, count=0;\\n        for(i=0 ; i<num.length() ; i++)\\n        {\\n            count=0;\\n            for(j=0 ; j<num.length() ; j++)\\n            {\\n                if(i==(int)num[j]-48)\\n                {\\n                    count++;\\n                }\\n            }\\n            if((int)num[i]-48!=count)\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3548379,
                "title": "simplest-efficient-c-code-time-o-n-2-space-o-1",
                "content": "# Intuition\\nThe code aims to compare the count of each digit in the string with the actual digit itself.\\n\\n# Approach\\nThe code iterates through each digit in the given string and compares its count with the actual digit itself. If any count doesn\\'t match, it returns false; otherwise, it returns true. \\n\\n# Complexity\\n- Time complexity: Let\\'s consider the length of the string num as n. The code uses two nested loops, with each loop iterating over the entire string. Therefore, the time complexity of the code is $O(n^2)$.\\n\\n- Space complexity: The code uses a constant amount of additional space to store variables l, i, j, and count. Hence, the space complexity is $O(1)$.\\n\\n# Code\\n```\\nbool digitCount(char * num)\\n{\\n    int l = strlen(num);\\n    for(int i=0;i<l;i++)\\n    {\\n        int count = 0;\\n        for(int j = 0;j<l;j++)\\n        {\\n            if(i==num[j]-\\'0\\')\\n            count++;\\n        }\\n        if(count != num[i]-\\'0\\')\\n        return false;\\n    }\\n    return true;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nbool digitCount(char * num)\\n{\\n    int l = strlen(num);\\n    for(int i=0;i<l;i++)\\n    {\\n        int count = 0;\\n        for(int j = 0;j<l;j++)\\n        {\\n            if(i==num[j]-\\'0\\')\\n            count++;\\n        }\\n        if(count != num[i]-\\'0\\')\\n        return false;\\n    }\\n    return true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3464006,
                "title": "easy-understanding-hash-java-99-85-beats-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean digitCount(String num) {\\n        HashMap<Integer,Integer> map=new HashMap<>();\\n\\n        for(int i=0;i<num.length();i++){\\n            int ch=num.charAt(i)-\\'0\\';\\n            map.put(ch,map.getOrDefault(ch,0)+1);\\n        }\\n        // StringBuilder sb=new StringBuilder();\\n        int count=0;\\n        for(int i=0;i<num.length();i++){\\n\\n            if(map.containsKey(i)){\\n                count=map.get(i);\\n            }\\n            else{\\n                count=0;\\n            }\\n          int x=num.charAt(i)-\\'0\\';\\n            if(x!=count){\\n                return false;\\n            }\\n        }\\n      return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean digitCount(String num) {\\n        HashMap<Integer,Integer> map=new HashMap<>();\\n\\n        for(int i=0;i<num.length();i++){\\n            int ch=num.charAt(i)-\\'0\\';\\n            map.put(ch,map.getOrDefault(ch,0)+1);\\n        }\\n        // StringBuilder sb=new StringBuilder();\\n        int count=0;\\n        for(int i=0;i<num.length();i++){\\n\\n            if(map.containsKey(i)){\\n                count=map.get(i);\\n            }\\n            else{\\n                count=0;\\n            }\\n          int x=num.charAt(i)-\\'0\\';\\n            if(x!=count){\\n                return false;\\n            }\\n        }\\n      return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3404476,
                "title": "easy-python-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def digitCount(self, num: str) -> bool:\\n        for i in range(len(num)):\\n            if num.count(str(i)) != int(num[i]):\\n                return False\\n        return True \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def digitCount(self, num: str) -> bool:\\n        for i in range(len(num)):\\n            if num.count(str(i)) != int(num[i]):\\n                return False\\n        return True \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3395513,
                "title": "easy-go-solution",
                "content": "```\\nfunc digitCount(num string) bool {\\n        var counters [10]int\\n\\n        for i := 0; i < len(num); i++ {\\n                val := num[i]\\n                counters[int(val-\\'0\\')]++\\n        }\\n\\n        isMatch := true\\n        for i := 0; i < len(num); i++ {\\n                val := num[i]\\n                if counters[i] != int(val-\\'0\\') {\\n                        isMatch = false\\n                        break\\n                }\\n        }\\n\\n        return isMatch\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc digitCount(num string) bool {\\n        var counters [10]int\\n\\n        for i := 0; i < len(num); i++ {\\n                val := num[i]\\n                counters[int(val-\\'0\\')]++\\n        }\\n\\n        isMatch := true\\n        for i := 0; i < len(num); i++ {\\n                val := num[i]\\n                if counters[i] != int(val-\\'0\\') {\\n                        isMatch = false\\n                        break\\n                }\\n        }\\n\\n        return isMatch\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3309058,
                "title": "java-hashmap-frequency-array-easy",
                "content": "## Solution 1: Using HashMap:\\n``` \\nclass Solution {\\n    public boolean digitCount(String num) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (char c : num.toCharArray()) {\\n            int n = c - \\'0\\';\\n            map.put(n, 1 + map.getOrDefault(n, 0));\\n        }\\n\\n        for (int i = 0; i < num.length(); i++) {\\n            int n = num.charAt(i) - \\'0\\';\\n            if (n != map.getOrDefault(i, 0)) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n```\\nSize will be at max $$10$$ so its very small.\\n\\n**Time complexity:** $$O(1)$$\\n**Space complexity:** $$O(1)$$\\n\\n---\\n## Solution 2: Using Frequency array:\\n```\\nclass Solution {\\n    public boolean digitCount(String num) {\\n        int[] freq = new int[10];\\n        for (char c : num.toCharArray()) {\\n            freq[c - \\'0\\']++;\\n        }\\n\\n        for (int i = 0; i < num.length(); i++) {\\n            int n = num.charAt(i) - \\'0\\';\\n            if (n != freq[i]) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n```\\n\\nSize will be at max $$10$$ so its very small.\\n\\n**Time complexity:** $$O(1)$$\\n**Space complexity:** $$O(1)$$\\n",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "String",
                    "Counting"
                ],
                "code": "``` \\nclass Solution {\\n    public boolean digitCount(String num) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (char c : num.toCharArray()) {\\n            int n = c - \\'0\\';\\n            map.put(n, 1 + map.getOrDefault(n, 0));\\n        }\\n\\n        for (int i = 0; i < num.length(); i++) {\\n            int n = num.charAt(i) - \\'0\\';\\n            if (n != map.getOrDefault(i, 0)) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public boolean digitCount(String num) {\\n        int[] freq = new int[10];\\n        for (char c : num.toCharArray()) {\\n            freq[c - \\'0\\']++;\\n        }\\n\\n        for (int i = 0; i < num.length(); i++) {\\n            int n = num.charAt(i) - \\'0\\';\\n            if (n != freq[i]) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3096491,
                "title": "python-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->First we have allocated a an empty string for storing the value. Now a loop upto length of the given string is generated and stored the value of that place (count of that place in num string) if the new formed string is equal to the given sting nums, return True else False.\\n# Code\\n```\\nclass Solution(object):\\n    def digitCount(self, num):\\n        \"\"\"\\n        :type num: str\\n        :rtype: bool\\n        \"\"\"\\n        s=\\'\\'\\n        for i in range(len(num)):\\n            s+=str(num.count(str(i)))\\n        if num==s:\\n            return True\\n        else:\\n            return False\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def digitCount(self, num):\\n        \"\"\"\\n        :type num: str\\n        :rtype: bool\\n        \"\"\"\\n        s=\\'\\'\\n        for i in range(len(num)):\\n            s+=str(num.count(str(i)))\\n        if num==s:\\n            return True\\n        else:\\n            return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2918316,
                "title": "c-hashing",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n        vector<int>v(10,0);   //to keep track of frequency of each digit\\n        int n=num.size();\\n\\n        for(int i=0;i<n;i++){\\n            int k=num[i]-\\'0\\';  //convert char to int\\n            v[k]++;   //hashing\\n        }\\n\\n        for(int i=0;i<n;i++){\\n            int k=num[i]-\\'0\\';\\n            if(v[i]!=k)return false;  //check if frequency of digit is equal to integer at that index\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n        vector<int>v(10,0);   //to keep track of frequency of each digit\\n        int n=num.size();\\n\\n        for(int i=0;i<n;i++){\\n            int k=num[i]-\\'0\\';  //convert char to int\\n            v[k]++;   //hashing\\n        }\\n\\n        for(int i=0;i<n;i++){\\n            int k=num[i]-\\'0\\';\\n            if(v[i]!=k)return false;  //check if frequency of digit is equal to integer at that index\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2833980,
                "title": "easy-js-solution-o-n",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nlet digitCount = function(num) {\\n    let map = new Map();\\n\\n    // Set Key:Value To Map\\n    for(let val of num) {\\n        // Covert string to number\\n        let n = Number(val)\\n        map.set(n, map.get(n) + 1 || 1);\\n    }\\n\\n    // Compare\\n    for(let i = 0; i < num.length; i++) {\\n        if(map.get(i) === Number(num[i])) {\\n            continue;\\n        } else if(!map.get(i) && Number(num[i]) === 0) {\\n            continue;\\n        }\\n        return false;\\n    }\\n    return true;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nlet digitCount = function(num) {\\n    let map = new Map();\\n\\n    // Set Key:Value To Map\\n    for(let val of num) {\\n        // Covert string to number\\n        let n = Number(val)\\n        map.set(n, map.get(n) + 1 || 1);\\n    }\\n\\n    // Compare\\n    for(let i = 0; i < num.length; i++) {\\n        if(map.get(i) === Number(num[i])) {\\n            continue;\\n        } else if(!map.get(i) && Number(num[i]) === 0) {\\n            continue;\\n        }\\n        return false;\\n    }\\n    return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2778905,
                "title": "simple-solution",
                "content": "simple solution in java using hash table\\n```\\nclass Solution {\\n    public boolean digitCount(String num) {\\n        int[] freq=new int[10];\\n        for(int i=0;i<num.length();i++)\\n        {\\n            int c=num.charAt(i)-\\'0\\';\\n            freq[c]++;\\n        }\\n        for(int i=0;i<num.length();i++){\\n            int a=num.charAt(i)-\\'0\\';\\n            if(a!=freq[i])\\n                return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public boolean digitCount(String num) {\\n        int[] freq=new int[10];\\n        for(int i=0;i<num.length();i++)\\n        {\\n            int c=num.charAt(i)-\\'0\\';\\n            freq[c]++;\\n        }\\n        for(int i=0;i<num.length();i++){\\n            int a=num.charAt(i)-\\'0\\';\\n            if(a!=freq[i])\\n                return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2778836,
                "title": "java-using-hash-maps",
                "content": "```\\nclass Solution {\\n    public boolean digitCount(String num) {\\n         Map<Integer,Integer> map=new HashMap<>();\\n        for(int i=0;i<num.length();i++){\\n            char a=num.charAt(i);\\n            if(map.containsKey(Integer.parseInt(String.valueOf(a))))\\n            {\\n                map.put(Integer.parseInt(String.valueOf(a)),map.get(Integer.parseInt(String.valueOf(a)))+1);\\n            }\\n            else{\\n                map.put(Integer.parseInt(String.valueOf(a)),1);\\n            }\\n        }\\n        \\n        for(int i=0;i<num.length();i++){\\n            if(map.containsKey(i)) {\\n                if (Integer.parseInt(String.valueOf(num.charAt(i))) != map.get(i)) {\\n                    return false;\\n                }\\n            }\\n            else{\\n                if(Integer.parseInt(String.valueOf(num.charAt(i)))!=0)\\n                    return false;\\n            }\\n        }\\n        return true; \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean digitCount(String num) {\\n         Map<Integer,Integer> map=new HashMap<>();\\n        for(int i=0;i<num.length();i++){\\n            char a=num.charAt(i);\\n            if(map.containsKey(Integer.parseInt(String.valueOf(a))))\\n            {\\n                map.put(Integer.parseInt(String.valueOf(a)),map.get(Integer.parseInt(String.valueOf(a)))+1);\\n            }\\n            else{\\n                map.put(Integer.parseInt(String.valueOf(a)),1);\\n            }\\n        }\\n        \\n        for(int i=0;i<num.length();i++){\\n            if(map.containsKey(i)) {\\n                if (Integer.parseInt(String.valueOf(num.charAt(i))) != map.get(i)) {\\n                    return false;\\n                }\\n            }\\n            else{\\n                if(Integer.parseInt(String.valueOf(num.charAt(i)))!=0)\\n                    return false;\\n            }\\n        }\\n        return true; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2760627,
                "title": "beats-98-60-in-time",
                "content": "#### Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- convert to char array using `toCharArray()`;\\n- to convert char to int -> `num[i]-\\'0\\'`\\n- can use the opp. approach,  *i.e* int to char -> `num[i]+\\'0\\'`\\n#### Approach\\n<!-- Describe your approach to solving the problem. -->\\nloop through the char array\\nanother loop to count the frequency of each char `num[j] == i`\\nif `num[i] == freq` return true\\nreturn false when loop finishes.\\n##### Code\\n```\\nclass Solution {\\n    public boolean digitCount(String num) {\\n        char[] numx = num.toCharArray();\\n        int freq = 0;\\n        for(int i=0; i<numx.length; i++){\\n            freq = 0;\\n            for(int j=0; j<numx.length; j++){\\n                if(i == (numx[j]-\\'0\\')){\\n                    freq++;\\n                }\\n            }\\n            if((numx[i]-\\'0\\') != freq) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean digitCount(String num) {\\n        char[] numx = num.toCharArray();\\n        int freq = 0;\\n        for(int i=0; i<numx.length; i++){\\n            freq = 0;\\n            for(int j=0; j<numx.length; j++){\\n                if(i == (numx[j]-\\'0\\')){\\n                    freq++;\\n                }\\n            }\\n            if((numx[i]-\\'0\\') != freq) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2710543,
                "title": "easty-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- wrost O(N^2)\\n- best O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def digitCount(self, s: str) -> bool:\\n        for i in range(len(s)):\\n            c=s.count(str(i))\\n            if c==int(s[i]):\\n                continue\\n            else:\\n                return False\\n        return True\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def digitCount(self, s: str) -> bool:\\n        for i in range(len(s)):\\n            c=s.count(str(i))\\n            if c==int(s[i]):\\n                continue\\n            else:\\n                return False\\n        return True\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2619170,
                "title": "super-easy-c-soln-hash-table",
                "content": "```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n        vector<int> v(10,0);\\n        for(auto it: num){\\n          v[it-\\'0\\']++;\\n        }\\n        for(int i=0;i<num.length();i++){\\n            if(v[i] != num[i]-\\'0\\') return false;\\n        }\\n        return true;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n        vector<int> v(10,0);\\n        for(auto it: num){\\n          v[it-\\'0\\']++;\\n        }\\n        for(int i=0;i<num.length();i++){\\n            if(v[i] != num[i]-\\'0\\') return false;\\n        }\\n        return true;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2571171,
                "title": "java-solution-for-beginners-without-hashmap",
                "content": "class Solution {\\n    public boolean digitCount(String num) {\\n        int[] count = new int[num.length()];\\n        for(int i = 0;i<num.length();i++){\\n            for(int j = 0;j<num.length();j++){\\n                if(i == num.charAt(j)-\\'0\\'){\\n                    count[i]++;\\n                }\\n            }\\n        }\\n        boolean bo = true;\\n        for(int i = 0;i<num.length();i++){\\n            if(count[i] == num.charAt(i)-\\'0\\'){\\n                bo = true;\\n            }\\n            else{\\n                bo = false;\\n                break;\\n            }\\n        }\\n        \\n        return bo;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public boolean digitCount(String num) {\\n        int[] count = new int[num.length()];\\n        for(int i = 0;i<num.length();i++){\\n            for(int j = 0;j<num.length();j++){\\n                if(i == num.charAt(j)-\\'0\\'){\\n                    count[i]++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2501744,
                "title": "62-ms-faster-than-99-15-easy-intuitive-js-solution",
                "content": "```\\nvar digitCount = function(num) {\\n    let map = new Map();\\n        \\n    for(let i = 0; i < num.length; i++) {\\n        map.has(num.charAt(i)) ? map.set(num.charAt(i), map.get(num.charAt(i))+1) : map.set(num.charAt(i), 1)\\n    }\\n\\n    let value;\\n    for(let i = 0; i < num.length; i++) {\\n        value = map.has(i.toString()) ? map.get(i.toString()) : 0;\\n        if(value != num.charAt(i)){\\n            return false\\n        }\\n    }\\n    \\n    return true;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar digitCount = function(num) {\\n    let map = new Map();\\n        \\n    for(let i = 0; i < num.length; i++) {\\n        map.has(num.charAt(i)) ? map.set(num.charAt(i), map.get(num.charAt(i))+1) : map.set(num.charAt(i), 1)\\n    }\\n\\n    let value;\\n    for(let i = 0; i < num.length; i++) {\\n        value = map.has(i.toString()) ? map.get(i.toString()) : 0;\\n        if(value != num.charAt(i)){\\n            return false\\n        }\\n    }\\n    \\n    return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2484276,
                "title": "c-0ms-unordered-map-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) \\n    {\\n        unordered_map<char,int>mp;\\n        for(int i=0;i<num.length();i++)\\n        {\\n            mp[num[i]]++;\\t\\n        }        \\n        for(int i=0;i<num.length();i++)\\n        {\\n            char currnum=i+\\'0\\';\\n            int freq=num[i]-\\'0\\';\\n\\n            if(mp[currnum]!=freq)\\n            {\\n               return false;    \\n            }\\n            \\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) \\n    {\\n        unordered_map<char,int>mp;\\n        for(int i=0;i<num.length();i++)\\n        {\\n            mp[num[i]]++;\\t\\n        }        \\n        for(int i=0;i<num.length();i++)\\n        {\\n            char currnum=i+\\'0\\';\\n            int freq=num[i]-\\'0\\';\\n\\n            if(mp[currnum]!=freq)\\n            {\\n               return false;    \\n            }\\n            \\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2332877,
                "title": "python3-o-n-o-n-runtime-47ms-62-83-memory-13-8mb-56-99",
                "content": "```\\nfrom collections import Counter as c\\nclass Solution:\\n#     O(n) || O(n)\\n# Runtime: 47ms 62.83% || Memory: 13.8mb 56.99%\\n    def digitCount(self, num: str) -> bool:\\n        if not num:\\n            return num\\n\\n        numFreq = c(num)\\n\\n        for idx, val in enumerate(num):\\n            if numFreq[f\\'{idx}\\'] != int(val):\\n                return False\\n        return True\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nfrom collections import Counter as c\\nclass Solution:\\n#     O(n) || O(n)\\n# Runtime: 47ms 62.83% || Memory: 13.8mb 56.99%\\n    def digitCount(self, num: str) -> bool:\\n        if not num:\\n            return num\\n\\n        numFreq = c(num)\\n\\n        for idx, val in enumerate(num):\\n            if numFreq[f\\'{idx}\\'] != int(val):\\n                return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2320976,
                "title": "java-runtime-1ms-time-o-n-space-n",
                "content": "```\\n/*\\nTo understand the code properly, dry run the code\\nin your notebook for the input:\\nnum = \"1210\"\\n*/\\n\\nclass Solution {\\n    public boolean digitCount(String num) {\\n        HashMap<Character, Integer> map = new HashMap<>() ;\\n        \\n        for (int i = 0; i < num.length(); i++) {\\n            map.put(num.charAt(i), map.getOrDefault(num.charAt(i), 0)+1) ;\\n        }\\n        \\n        for (int i = 0; i < num.length(); i++) {\\n            char ch = (char)(48+i) ;\\n            \\n            if (map.containsKey(ch)) {\\n                if ((int)(num.charAt(i))-48 != map.get(ch)) {\\n                    return false ;\\n                }\\n            }\\n            else if (num.charAt(i) != \\'0\\'){\\n                return false ;\\n            }\\n        }\\n        \\n        return true ;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\n/*\\nTo understand the code properly, dry run the code\\nin your notebook for the input:\\nnum = \"1210\"\\n*/\\n\\nclass Solution {\\n    public boolean digitCount(String num) {\\n        HashMap<Character, Integer> map = new HashMap<>() ;\\n        \\n        for (int i = 0; i < num.length(); i++) {\\n            map.put(num.charAt(i), map.getOrDefault(num.charAt(i), 0)+1) ;\\n        }\\n        \\n        for (int i = 0; i < num.length(); i++) {\\n            char ch = (char)(48+i) ;\\n            \\n            if (map.containsKey(ch)) {\\n                if ((int)(num.charAt(i))-48 != map.get(ch)) {\\n                    return false ;\\n                }\\n            }\\n            else if (num.charAt(i) != \\'0\\'){\\n                return false ;\\n            }\\n        }\\n        \\n        return true ;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2269284,
                "title": "simple-c-solution",
                "content": "```\\n        int n = num.length();\\n        vector<int> v(10,0);\\n        for(int i=0;i<n;i++)\\n        {\\n            v[num[i]-\\'0\\']++;\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            if((num[i]-\\'0\\') != v[i])\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n        int n = num.length();\\n        vector<int> v(10,0);\\n        for(int i=0;i<n;i++)\\n        {\\n            v[num[i]-\\'0\\']++;\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            if((num[i]-\\'0\\') != v[i])\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2246289,
                "title": "python-simple-solution-easy-2-liner-faster-than-93-easy-to-understand",
                "content": "```\\nst = \\'\\'\\nfor i in range(len(num)):\\n\\tst = st+str(num.count(str(i)))\\nreturn(st == num)\\n```\\n***Please Do Upvote, if you found my code helpful***",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nst = \\'\\'\\nfor i in range(len(num)):\\n\\tst = st+str(num.count(str(i)))\\nreturn(st == num)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2243800,
                "title": "java",
                "content": "```\\nimport java.util.*;\\n\\nclass Solution {\\n    public boolean digitCount(String num) {\\n        Hashtable<Integer, Integer> ht = new Hashtable<Integer, Integer>();\\n        for(int i = 0; i<num.length(); i++){\\n            ht.put(i, num.charAt(i)-\\'0\\'); \\n        }\\n        \\n        for(int i = 0; i<num.length(); i++){\\n            if(ht.get(num.charAt(i)-\\'0\\')== null){\\n                return false;\\n            }\\n            ht.replace(num.charAt(i)-\\'0\\', ht.get(num.charAt(i)-\\'0\\')-1);\\n        }\\n        for(int i = 0; i<num.length(); i++){\\n            if(ht.get(i)!=0){\\n                return false;\\n            }\\t\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.*;\\n\\nclass Solution {\\n    public boolean digitCount(String num) {\\n        Hashtable<Integer, Integer> ht = new Hashtable<Integer, Integer>();\\n        for(int i = 0; i<num.length(); i++){\\n            ht.put(i, num.charAt(i)-\\'0\\'); \\n        }\\n        \\n        for(int i = 0; i<num.length(); i++){\\n            if(ht.get(num.charAt(i)-\\'0\\')== null){\\n                return false;\\n            }\\n            ht.replace(num.charAt(i)-\\'0\\', ht.get(num.charAt(i)-\\'0\\')-1);\\n        }\\n        for(int i = 0; i<num.length(); i++){\\n            if(ht.get(i)!=0){\\n                return false;\\n            }\\t\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2218421,
                "title": "kotlin-1-line",
                "content": "```\\nfun digitCount(s: String) = s.withIndex().all { it.value - \\'0\\' == s.count { c -> c == \\'0\\' + it.index } }\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nfun digitCount(s: String) = s.withIndex().all { it.value - \\'0\\' == s.count { c -> c == \\'0\\' + it.index } }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2195712,
                "title": "java-easiest-solution-with-steps-explained",
                "content": "**STEPS**\\n\\n**Here we are using Frequency Array**\\n\\n**Step 1:** Initialising the Frequency Array with size 10 (**because 1 <= n <= 10 was given in the constraints**)\\n**Step 2:** Take each characters from the string and make it into character array\\n**Step 3:**  Store the frequency of characters in frequency Array.\\n**Step 4:** Now find frequency of each index value and update the frequency array.\\n**Step 5:** Now within a loop check upto constraint value check if frequency is zero or not .If zero then return false otherwise the function will return true.\\n\\n**Code**\\n\\n```\\nclass Solution {\\n    public boolean digitCount(String num) {\\n        int[] freqArray = new int[10];\\n        \\n        \\n        for(char ch : num.toCharArray()){\\n            freqArray[ch-\\'0\\']++;\\n        }\\n        \\n        for(int i=0;i<num.length();i++){\\n            int freq = num.charAt(i)-\\'0\\';\\n            freqArray[i] = freqArray[i] - freq; \\n        }\\n        for(int i=0;i<10;i++){\\n            if(freqArray[i]!=0){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean digitCount(String num) {\\n        int[] freqArray = new int[10];\\n        \\n        \\n        for(char ch : num.toCharArray()){\\n            freqArray[ch-\\'0\\']++;\\n        }\\n        \\n        for(int i=0;i<num.length();i++){\\n            int freq = num.charAt(i)-\\'0\\';\\n            freqArray[i] = freqArray[i] - freq; \\n        }\\n        for(int i=0;i<10;i++){\\n            if(freqArray[i]!=0){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2189195,
                "title": "javascript-using-regex",
                "content": "```\\nvar digitCount = function(num) {    \\n    const res = [...num].filter((element, index) => {\\n        const reg = new RegExp(index, \"g\");\\n        const count = (num.match(reg) || []).length;\\n        \\n        return Number(element) === count\\n    })\\n    \\n    return res.length === num.length    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar digitCount = function(num) {    \\n    const res = [...num].filter((element, index) => {\\n        const reg = new RegExp(index, \"g\");\\n        const count = (num.match(reg) || []).length;\\n        \\n        return Number(element) === count\\n    })\\n    \\n    return res.length === num.length    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2178551,
                "title": "easy-javascript-solution",
                "content": "```\\nvar digitCount = function(num) {\\n    let arr= Array(num.length).fill(0);\\n    for(const char of num){\\n        arr[Number(char)]++;\\n    }\\n    return arr.join(\\'\\') === num;\\n};\\n```\\n\\nRuntime: 113 ms, faster than 31.20% of JavaScript online submissions for Check if Number Has Equal Digit Count and Digit Value.\\nMemory Usage: 43.8 MB, less than 16.45% of JavaScript online submissions for Check if Number Has Equal Digit Count and Digit Value.",
                "solutionTags": [],
                "code": "```\\nvar digitCount = function(num) {\\n    let arr= Array(num.length).fill(0);\\n    for(const char of num){\\n        arr[Number(char)]++;\\n    }\\n    return arr.join(\\'\\') === num;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2171618,
                "title": "easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n        map<char,int>mp;\\n        for(int i=0;i<num.size();i++)\\n            mp[num[i]]++;\\n        int n=num.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            int temp=num[i]-\\'0\\';\\n           /// cout<<mp[(i+\\'0\\')]<<\" \"<<temp<<endl;\\n            if(mp[(i+\\'0\\')]!=temp)\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n        map<char,int>mp;\\n        for(int i=0;i<num.size();i++)\\n            mp[num[i]]++;\\n        int n=num.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            int temp=num[i]-\\'0\\';\\n           /// cout<<mp[(i+\\'0\\')]<<\" \"<<temp<<endl;\\n            if(mp[(i+\\'0\\')]!=temp)\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2124375,
                "title": "java-sol-using-counter-array",
                "content": "Java solution to use counter array because we will only have 10 digits\\n\\n```\\npublic boolean digitCount(String num) {\\n        int[] digit_counter = new int[10];\\n        \\n        for (int i = 0; i < num.length(); i++) {\\n            digit_counter[Character.getNumericValue(num.charAt(i))]++;\\n        }\\n        \\n        for (int i = 0; i < num.length(); i++) {\\n            if (digit_counter[i] != Character.getNumericValue(num.charAt(i)))\\n                return false;\\n        }\\n        \\n        return true;\\n        \\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "Java solution to use counter array because we will only have 10 digits\\n\\n```\\npublic boolean digitCount(String num) {\\n        int[] digit_counter = new int[10];\\n        \\n        for (int i = 0; i < num.length(); i++) {\\n            digit_counter[Character.getNumericValue(num.charAt(i))]++;\\n        }\\n        \\n        for (int i = 0; i < num.length(); i++) {\\n            if (digit_counter[i] != Character.getNumericValue(num.charAt(i)))\\n                return false;\\n        }\\n        \\n        return true;\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2112937,
                "title": "c-solution-without-using-vector-array-map-for-beginners",
                "content": "class Solution {\\npublic:\\n    bool digitCount(string num) {\\n        \\n        int count=0;\\n        int i=0;\\n        int a=0;\\n        for(int c=0;c<num.size();c++)\\n        {\\n            count=0;\\n            for(i=0;i<num.size();i++)\\n            {\\n                if(num[i]==char(c+48))\\n                {\\n                    count++;\\n                }\\n            }\\n            // cout<<count<<endl;\\n            if(count!=(int)num[a]-48)\\n            {\\n                return false;\\n            }\\n            a++;\\n        }\\n       \\n        \\n        return true;\\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    bool digitCount(string num) {\\n        \\n        int count=0;\\n        int i=0;\\n        int a=0;\\n        for(int c=0;c<num.size();c++)\\n        {\\n            count=0;\\n            for(i=0;i<num.size();i++)\\n            {\\n                if(num[i]==char(c+48))\\n                {\\n                    count++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2100275,
                "title": "kotlin-short-easy-solution-264ms-faster-than-50-00",
                "content": "just do what the problem says, along with 1 edge case\\n```\\nclass Solution {\\n    fun digitCount(num: String): Boolean {\\n        val map = num.groupingBy { it }.eachCount()\\n        return num.indices.all {\\n            val count = map[(\\'0\\'..\\'9\\').toList()[it]] ?: 0\\n            count == num[it].toString().toInt()\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun digitCount(num: String): Boolean {\\n        val map = num.groupingBy { it }.eachCount()\\n        return num.indices.all {\\n            val count = map[(\\'0\\'..\\'9\\').toList()[it]] ?: 0\\n            count == num[it].toString().toInt()\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2093748,
                "title": "python-count-and-check-with-explanation-45ms",
                "content": "```\\nclass Solution:\\n    def digitCount(self, num: str) -> bool:\\n        \\n        #Find the length\\n        LENGTH = len( num )\\n            \\n        #Count the occurences\\n        counter = Counter( num )\\n\\n        #Go through each number index\\n        for i in range( LENGTH ):\\n            #The index is the current digit\\n            current_digit = i\\n            \\n            #Cast it as a string for comparison\\n            str_current = str( i ) \\n            \\n            #Use the index to find the expected number in num\\n            expected_number = int ( num[ i ] )\\n            \\n            #Use the stringified number to find its occurences in counter\\n            if str_current in counter:\\n                digit_count = int( counter[ str_current ] )\\n                \\n            #If it is not found, the count is zero\\n            else:\\n                digit_count = 0\\n            \\n            #If we don\\'t find the expected number as the count, we return False\\n            if expected_number != digit_count:\\n                return False\\n            \\n        #Otherwise, all that are checked are valid\\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def digitCount(self, num: str) -> bool:\\n        \\n        #Find the length\\n        LENGTH = len( num )\\n            \\n        #Count the occurences\\n        counter = Counter( num )\\n\\n        #Go through each number index\\n        for i in range( LENGTH ):\\n            #The index is the current digit\\n            current_digit = i\\n            \\n            #Cast it as a string for comparison\\n            str_current = str( i ) \\n            \\n            #Use the index to find the expected number in num\\n            expected_number = int ( num[ i ] )\\n            \\n            #Use the stringified number to find its occurences in counter\\n            if str_current in counter:\\n                digit_count = int( counter[ str_current ] )\\n                \\n            #If it is not found, the count is zero\\n            else:\\n                digit_count = 0\\n            \\n            #If we don\\'t find the expected number as the count, we return False\\n            if expected_number != digit_count:\\n                return False\\n            \\n        #Otherwise, all that are checked are valid\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2092793,
                "title": "rust-hashmap-counter-o-n",
                "content": "```\\nuse std::collections::HashMap;\\n\\nimpl Solution {\\n    pub fn digit_count(num: String) -> bool {\\n        let mut dc = HashMap::new();\\n        for c in num.chars() {\\n            let d: usize = c.to_digit(10).unwrap_or(88) as usize;\\n            *dc.entry(d).or_insert(0) += 1;\\n        }\\n        \\n        for (i, c) in num.chars().enumerate() {\\n            let cnt: usize = c.to_digit(10).unwrap_or(99) as usize;\\n            if !dc.contains_key(&i) {\\n                if cnt == 0 {\\n                    continue\\n                } else {\\n                    return false;\\n                }\\n            } else if dc[&i] != cnt {\\n                return false;\\n            }\\n        }\\n        true\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::collections::HashMap;\\n\\nimpl Solution {\\n    pub fn digit_count(num: String) -> bool {\\n        let mut dc = HashMap::new();\\n        for c in num.chars() {\\n            let d: usize = c.to_digit(10).unwrap_or(88) as usize;\\n            *dc.entry(d).or_insert(0) += 1;\\n        }\\n        \\n        for (i, c) in num.chars().enumerate() {\\n            let cnt: usize = c.to_digit(10).unwrap_or(99) as usize;\\n            if !dc.contains_key(&i) {\\n                if cnt == 0 {\\n                    continue\\n                } else {\\n                    return false;\\n                }\\n            } else if dc[&i] != cnt {\\n                return false;\\n            }\\n        }\\n        true\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2087358,
                "title": "c-easy-0ms-100-beats-beginner-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n        unordered_map<char,int>ans;\\n        for(int i=0; i<num.size(); i++)\\n            ans[num[i]]++;\\n        for(int i=0; i<num.size(); i++){\\n            char c =\\'0\\' + i;\\n            if(num[i] != \\'0\\' + ans[c]){\\n                return false;\\n                \\n\\n            }\\n        }  \\n        return true;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    bool digitCount(string num) {\\n        unordered_map<char,int>ans;\\n        for(int i=0; i<num.size(); i++)\\n            ans[num[i]]++;\\n        for(int i=0; i<num.size(); i++){\\n            char c =\\'0\\' + i;\\n            if(num[i] != \\'0\\' + ans[c]){\\n                return false;\\n                \\n\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2086477,
                "title": "javascript-soln",
                "content": "```\\nvar digitCount = function(num) {\\n\\n    const numArray = num.split(\"\");\\n    for(let i=0;i<num.length;i++){\\n      if (!(num[i] == countFreq(numArray,`${i}`))) {\\n          return false;\\n      }\\n    }\\n    return true;\\n};\\n\\nconst countFreq = (arr,index) => {\\n   return( (arr.filter( (n) => {return n===index && n})).length );\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nvar digitCount = function(num) {\\n\\n    const numArray = num.split(\"\");\\n    for(let i=0;i<num.length;i++){\\n      if (!(num[i] == countFreq(numArray,`${i}`))) {\\n          return false;\\n      }\\n    }\\n    return true;\\n};\\n\\nconst countFreq = (arr,index) => {\\n   return( (arr.filter( (n) => {return n===index && n})).length );\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2086252,
                "title": "javascript-solution-using-replace",
                "content": "```\\n    for(let i = 0; i < num.length; i++) {\\n        const temp = num.replace(new RegExp(`${i}`, \"g\"), \"\");\\n        if (num.length - temp.length !== num.charAt(i) - \\'0\\') {\\n            return false;\\n        }\\n    }\\n    \\n    return true;\\n```",
                "solutionTags": [],
                "code": "```\\n    for(let i = 0; i < num.length; i++) {\\n        const temp = num.replace(new RegExp(`${i}`, \"g\"), \"\");\\n        if (num.length - temp.length !== num.charAt(i) - \\'0\\') {\\n            return false;\\n        }\\n    }\\n    \\n    return true;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2085920,
                "title": "cpp-hashmap",
                "content": "```\\nclass Solution {\\npublic:\\n    bool digitCount(string nums) {\\n        unordered_map<char,int>m;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            m[nums[i]]++;\\n        }\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            char t=nums[i];\\n            auto it=m.find(i+\\'0\\');\\n            if(it!=m.end())\\n            {\\n                if(it->second!=t-\\'0\\')\\n                {\\n                    return false;\\n                }\\n            }\\n            else if(it==m.end()&&(t)!=\\'0\\')\\n            {\\n                return false;\\n            }\\n            else\\n                continue;\\n            \\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool digitCount(string nums) {\\n        unordered_map<char,int>m;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            m[nums[i]]++;\\n        }\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            char t=nums[i];\\n            auto it=m.find(i+\\'0\\');\\n            if(it!=m.end())\\n            {\\n                if(it->second!=t-\\'0\\')\\n                {\\n                    return false;\\n                }\\n            }\\n            else if(it==m.end()&&(t)!=\\'0\\')\\n            {\\n                return false;\\n            }\\n            else\\n                continue;\\n            \\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2085579,
                "title": "cpp-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n        for(int i = 0  ; i < num.size() ; i++){\\n                int a = count(num.begin() , num.end() , i+\\'0\\'); // Make sure you actually convert those integers to characters by manipulating those ASCII values , here we count the occurances of the i th indice.\\n                if(a!=(num[i]-\\'0\\')) \\n                        return false;\\n        }\\n            return true;\\n    }\\n};\\n```\\n**Please upvote if you find this helpful**",
                "solutionTags": [
                    "Counting Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n        for(int i = 0  ; i < num.size() ; i++){\\n                int a = count(num.begin() , num.end() , i+\\'0\\'); // Make sure you actually convert those integers to characters by manipulating those ASCII values , here we count the occurances of the i th indice.\\n                if(a!=(num[i]-\\'0\\')) \\n                        return false;\\n        }\\n            return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2085435,
                "title": "0-ms-faster-hashmap-c",
                "content": "```\\nclass Solution {\\npublic:\\n    bool digitCount(string nums) {\\n        \\n        map<int,int>mp;\\n        \\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]!=\\'0\\') //if any number is occuring zero times then do not add that number into map\\n                mp[i] = nums[i] - \\'0\\';\\n        }\\n        \\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(mp.find(nums[i]-\\'0\\') == mp.end())\\n                return false;\\n            \\n            mp[nums[i]-\\'0\\']--;\\n            if(mp[nums[i]-\\'0\\']==0) //if value become zero then remove it from the map.\\n                mp.erase(nums[i]-\\'0\\');\\n        }\\n        if(mp.size()==0) // if map is empty then return true.\\n            return true;\\n        else\\n            return false;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool digitCount(string nums) {\\n        \\n        map<int,int>mp;\\n        \\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]!=\\'0\\') //if any number is occuring zero times then do not add that number into map\\n                mp[i] = nums[i] - \\'0\\';\\n        }\\n        \\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(mp.find(nums[i]-\\'0\\') == mp.end())\\n                return false;\\n            \\n            mp[nums[i]-\\'0\\']--;\\n            if(mp[nums[i]-\\'0\\']==0) //if value become zero then remove it from the map.\\n                mp.erase(nums[i]-\\'0\\');\\n        }\\n        if(mp.size()==0) // if map is empty then return true.\\n            return true;\\n        else\\n            return false;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2085302,
                "title": "go-golang-solution",
                "content": "```go\\nfunc digitCount(num string) bool {\\n    n := len(num)\\n    var a [10]int\\n    var b [10]int\\n    for i := 0; i < n; i++ {\\n        a[num[i] - \\'0\\']++\\n        b[i] = int(num[i] - \\'0\\')\\n    }\\n    return a == b\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc digitCount(num string) bool {\\n    n := len(num)\\n    var a [10]int\\n    var b [10]int\\n    for i := 0; i < n; i++ {\\n        a[num[i] - \\'0\\']++\\n        b[i] = int(num[i] - \\'0\\')\\n    }\\n    return a == b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2085072,
                "title": "hasmap-counting-c-sort-and-simple",
                "content": "```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n      map<int,int>mp;\\n        for(auto it:num){\\n            mp[it-\\'0\\']++;\\n        }\\n        for(int i=0;i<num.size();i++){\\n            if(mp[i]!=num[i]-\\'0\\'){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n      map<int,int>mp;\\n        for(auto it:num){\\n            mp[it-\\'0\\']++;\\n        }\\n        for(int i=0;i<num.size();i++){\\n            if(mp[i]!=num[i]-\\'0\\'){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2084831,
                "title": "c-array",
                "content": "```\\n    public bool DigitCount(string num)\\n    {\\n        int[] freq = new int[10];\\n        foreach (char n in num)\\n            freq[n - \\'0\\']++;\\n\\n        for (int i = 0; i < num.Length; i++)\\n            if (num[i] - \\'0\\' != freq[i])\\n                return false;\\n        return true;\\n    }\\n```",
                "solutionTags": [
                    "Array"
                ],
                "code": "```\\n    public bool DigitCount(string num)\\n    {\\n        int[] freq = new int[10];\\n        foreach (char n in num)\\n            freq[n - \\'0\\']++;\\n\\n        for (int i = 0; i < num.Length; i++)\\n            if (num[i] - \\'0\\' != freq[i])\\n                return false;\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2084695,
                "title": "c-solution",
                "content": "**Complexity**\\n- Time: O(n)\\n- Space: O(1)\\n\\n**Implementation**\\n```\\npublic class Solution {\\n    public bool DigitCount(string num) {\\n        \\n        if(string.IsNullOrEmpty(num))\\n            throw new ArgumentException(\"Invalid Input.\");\\n        \\n        int[] freq = new int[10];\\n        foreach(var c in num)\\n            freq[c - \\'0\\']++;\\n        \\n        for(int i = 0; i < num.Length; i++)\\n        {\\n            if(freq[i] != num[i] - \\'0\\')\\n                return false;\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public bool DigitCount(string num) {\\n        \\n        if(string.IsNullOrEmpty(num))\\n            throw new ArgumentException(\"Invalid Input.\");\\n        \\n        int[] freq = new int[10];\\n        foreach(var c in num)\\n            freq[c - \\'0\\']++;\\n        \\n        for(int i = 0; i < num.Length; i++)\\n        {\\n            if(freq[i] != num[i] - \\'0\\')\\n                return false;\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2084574,
                "title": "python-counter-solution",
                "content": "```\\nclass Solution:\\n    def digitCount(self, num: str) -> bool:\\n        counts = Counter(num)\\n        for i in range(len(num)):\\n            if counts[str(i)] != int(num[i]):\\n                return False\\n        return True \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def digitCount(self, num: str) -> bool:\\n        counts = Counter(num)\\n        for i in range(len(num)):\\n            if counts[str(i)] != int(num[i]):\\n                return False\\n        return True \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2084512,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Time Complexity : O(N * N)***\\n\\n* ***Space Complexity : O(N)***\\n\\n```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n        \\n        int n = num.size();\\n        \\n        unordered_map<int, int> mp;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            int count = 0;\\n            \\n            for(int j = 0; j < n; j++)\\n            {\\n                if(num[j] - \\'0\\' == i)\\n                {\\n                    count++;\\n                }\\n            }\\n            \\n            mp[i] = count;\\n        }\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            if(mp[i] != num[i] - \\'0\\')\\n            {\\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n        \\n        int n = num.size();\\n        \\n        unordered_map<int, int> mp;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            int count = 0;\\n            \\n            for(int j = 0; j < n; j++)\\n            {\\n                if(num[j] - \\'0\\' == i)\\n                {\\n                    count++;\\n                }\\n            }\\n            \\n            mp[i] = count;\\n        }\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            if(mp[i] != num[i] - \\'0\\')\\n            {\\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2084315,
                "title": "clean-python-code-using-counter",
                "content": "```\\nclass Solution:\\n    def digitCount(self, num: str) -> bool:\\n        d = Counter(num)\\n        for idx, val in enumerate(num):\\n            if int(val) != d[str(idx)]:\\n                return False\\n        return True\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def digitCount(self, num: str) -> bool:\\n        d = Counter(num)\\n        for idx, val in enumerate(num):\\n            if int(val) != d[str(idx)]:\\n                return False\\n        return True\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2084106,
                "title": "c-simple",
                "content": "\\n\\n    class Solution {\\n\\n    public:\\n    bool digitCount(string num) {\\n       vector<int>v(11,0);\\n        for(int i=0;i<num.size();i++){\\n          v[num[i]-\\'0\\']++;\\n            //cout<<v[num[i]-\\'0\\']<<\" \";\\n        }\\n        for(int i=0;i<num.size();i++){\\n            int x=num[i]-\\'0\\';\\n            if(v[i]!=x){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\n\\n    public:\\n    bool digitCount(string num) {\\n       vector<int>v(11,0);\\n        for(int i=0;i<num.size();i++){\\n          v[num[i]-\\'0\\']++;\\n            //cout<<v[num[i]-\\'0\\']<<\" \";\\n        }",
                "codeTag": "C++"
            },
            {
                "id": 2083968,
                "title": "simple-c-using-map-o-n-time",
                "content": "```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n        unordered_map<int,int> mp;\\n        for(auto x:num) mp[x-\\'0\\']++;\\n        for(int i=0;i<num.size();i++){\\n            if(num[i]-\\'0\\'!=mp[i]) return false;\\n        }\\n        return true;\\n    }\\n};\\n```\\n\\n**If you like this, Do Upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n        unordered_map<int,int> mp;\\n        for(auto x:num) mp[x-\\'0\\']++;\\n        for(int i=0;i<num.size();i++){\\n            if(num[i]-\\'0\\'!=mp[i]) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2083919,
                "title": "easy-short-efficient-solution",
                "content": "```\\nclass Solution {\\n#define ln ListNode\\n#define tn TreeNode\\n    typedef long long ll;\\n    typedef vector<ll> vi;\\n#define endl \\'\\\\n\\'\\n    const ll mod = 1e9;\\npublic:\\n    bool digitCount(string& s) {\\n        vi hash(10);\\n        for (char& ch : s)\\n            ++hash[ch - \\'0\\'];\\n        for (ll i = 0;i < s.length();++i)\\n            if (hash[i] != (s[i] - \\'0\\'))return false;\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n#define ln ListNode\\n#define tn TreeNode\\n    typedef long long ll;\\n    typedef vector<ll> vi;\\n#define endl \\'\\\\n\\'\\n    const ll mod = 1e9;\\npublic:\\n    bool digitCount(string& s) {\\n        vi hash(10);\\n        for (char& ch : s)\\n            ++hash[ch - \\'0\\'];\\n        for (ll i = 0;i < s.length();++i)\\n            if (hash[i] != (s[i] - \\'0\\'))return false;\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2083886,
                "title": "solution-using-hash-map-in-python",
                "content": "```\\nclass Solution:\\n    def digitCount(self, num: str) -> bool:\\n        leng = len(num)\\n        freq = {}\\n        \\n        for i in range(leng):\\n            freq[str(i)] = 0\\n            \\n        for i in range(leng):\\n            if num[i] in freq:\\n                freq[num[i]] += 1\\n        \\n        for i in range(leng):\\n            if num[i] == str(freq[str(i)]):\\n                continue\\n            else:\\n                return False\\n            \\n        return True\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def digitCount(self, num: str) -> bool:\\n        leng = len(num)\\n        freq = {}\\n        \\n        for i in range(leng):\\n            freq[str(i)] = 0\\n            \\n        for i in range(leng):\\n            if num[i] in freq:\\n                freq[num[i]] += 1\\n        \\n        for i in range(leng):\\n            if num[i] == str(freq[str(i)]):\\n                continue\\n            else:\\n                return False\\n            \\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2083855,
                "title": "c-easy-to-understand-simple-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n        map<int,int> mp1,mp2;\\n        int i=0;\\n        for(char ch:num)\\n        {\\n            if(ch!=\\'0\\')\\n            mp1[i]=ch-\\'0\\';\\n                i++;\\n        }\\n        for(char ch:num)\\n        {\\n            mp2[ch-\\'0\\']++;\\n        }\\n        return mp1==mp2;\\n    }\\n};\\n```\\n**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n        map<int,int> mp1,mp2;\\n        int i=0;\\n        for(char ch:num)\\n        {\\n            if(ch!=\\'0\\')\\n            mp1[i]=ch-\\'0\\';\\n                i++;\\n        }\\n        for(char ch:num)\\n        {\\n            mp2[ch-\\'0\\']++;\\n        }\\n        return mp1==mp2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2083835,
                "title": "c-easy-with-explanation",
                "content": "```\\n// Easy solution. We\\'ll first populate the array by string elements and then check if they \\n//are equal or not.\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n        int n = num.size();\\n        vector<int> arr(10,0);\\n        for(auto &it : num){\\n            arr[it-\\'0\\']++;\\n        }\\n        bool ans = 1;\\n        for(int i = 0;i<n;i++){\\n            if(arr[i] != num[i]-\\'0\\'){\\n                ans = 0;\\n                break;\\n            }\\n        }\\n        if(ans)\\n            return true;\\n        else return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n// Easy solution. We\\'ll first populate the array by string elements and then check if they \\n//are equal or not.\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n        int n = num.size();\\n        vector<int> arr(10,0);\\n        for(auto &it : num){\\n            arr[it-\\'0\\']++;\\n        }\\n        bool ans = 1;\\n        for(int i = 0;i<n;i++){\\n            if(arr[i] != num[i]-\\'0\\'){\\n                ans = 0;\\n                break;\\n            }\\n        }\\n        if(ans)\\n            return true;\\n        else return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2083824,
                "title": "java-do-as-they-ask",
                "content": "```\\nclass Solution {\\n    public boolean digitCount(String num) {\\n        int[] bucket = new int[10];\\n        for (char c : num.toCharArray()) {\\n            bucket[c - \\'0\\']++;\\n        }\\n        int i = 0;\\n        for (; i < num.length(); i++) {\\n            if (bucket[i] != num.charAt(i) - \\'0\\') return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean digitCount(String num) {\\n        int[] bucket = new int[10];\\n        for (char c : num.toCharArray()) {\\n            bucket[c - \\'0\\']++;\\n        }\\n        int i = 0;\\n        for (; i < num.length(); i++) {\\n            if (bucket[i] != num.charAt(i) - \\'0\\') return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2083772,
                "title": "c-using-10-size-vector",
                "content": "```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n        int arr[10] = {0};\\n        for(auto it : num){\\n            arr[it-\\'0\\']++;\\n        }\\n        for(int i=0;i<num.size();i++){\\n            if(arr[i]!=(num[i])-\\'0\\') return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n        int arr[10] = {0};\\n        for(auto it : num){\\n            arr[it-\\'0\\']++;\\n        }\\n        for(int i=0;i<num.size();i++){\\n            if(arr[i]!=(num[i])-\\'0\\') return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2083762,
                "title": "python-java-easy-to-understand",
                "content": "\\tclass Solution:\\n\\t\\tdef digitCount(self, num: str) -> bool:\\n\\t\\t\\tcnt = collections.Counter(num)\\n\\t\\t\\tfor i, digit in enumerate(num):\\n\\t\\t\\t\\tif cnt[str(i)] != int(digit):\\n\\t\\t\\t\\t\\treturn False\\n\\t\\t\\treturn True\\n\\n\\n\\tclass Solution {\\n\\t\\tpublic boolean digitCount(String num) {\\n\\t\\t\\tint[] cnt = new int[10];\\n\\t\\t\\tfor (char c: num.toCharArray()) {\\n\\t\\t\\t\\tcnt[c - \\'0\\'] += 1;\\n\\t\\t\\t}\\n\\t\\t\\tfor (int i = 0; i < num.length(); i ++) {\\n\\t\\t\\t\\tif (cnt[i] != num.charAt(i) - \\'0\\') {\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t}",
                "solutionTags": [],
                "code": "class Solution:\\n\\t\\tdef digitCount(self, num: str) -> bool:\\n\\t\\t\\tcnt = collections.Counter(num)\\n\\t\\t\\tfor i, digit in enumerate(num):\\n\\t\\t\\t\\tif cnt[str(i)] != int(digit):\\n\\t\\t\\t\\t\\treturn False\\n\\t\\t\\treturn True\\n\\n\\n\\tclass Solution {\\n\\t\\tpublic boolean digitCount(String num) {\\n\\t\\t\\tint[] cnt = new int[10];\\n\\t\\t\\tfor (char c: num.toCharArray()) {\\n\\t\\t\\t\\tcnt[c - \\'0\\'] += 1;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 4084293,
                "title": "check-if-number-has-equal-digit-count",
                "content": "# Approach\\n1. Split number into an array by converting it into a string and the split methods.\\n2. By default, set all numbers to be true. \\n3. Use a for loop to iterate through the array. \\n4. For each loop, get the length of the filtered array - count. \\n5. Filter the array to find if the string \\'x\\' is equal to stringified index \\'i\\'. \\n6. If count does not equal the value at arr[i], switch isValid to false and break the loop. \\n7. return isValid\\n\\n\\n```\\n/**\\n * @param {string} num\\n * @return {boolean}\\n */\\nvar digitCount = function(num) {\\n    const arr = num.toString().split(\\'\\');\\n    let isValid = true;\\n\\n    for (let i = 0; i < arr.length; i++) {\\n        const count = arr.filter((x) => x === i.toString()).length;\\n        if (count !== parseInt(arr[i])) {\\n            isValid = false;\\n            break;\\n        }\\n    }\\n\\n    return isValid;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} num\\n * @return {boolean}\\n */\\nvar digitCount = function(num) {\\n    const arr = num.toString().split(\\'\\');\\n    let isValid = true;\\n\\n    for (let i = 0; i < arr.length; i++) {\\n        const count = arr.filter((x) => x === i.toString()).length;\\n        if (count !== parseInt(arr[i])) {\\n            isValid = false;\\n            break;\\n        }\\n    }\\n\\n    return isValid;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4079858,
                "title": "python-dictionary-solution-beats-99-in-memory-70-in-runtime",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def digitCount(self, num: str) -> bool:\\n        d = {}\\n        n = list(map(int, num))\\n        for i in n:\\n            if i in d:\\n                d[i] += 1\\n            else:\\n                d[i] = 1\\n        res = True\\n        for i in range(len(n)):\\n            if i in d:\\n                if d[i] != n[i]:\\n                    res = False\\n                    break\\n            elif i not in d:\\n                if n[i] > 0:\\n                    res = False\\n                    break\\n\\n        return res\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def digitCount(self, num: str) -> bool:\\n        d = {}\\n        n = list(map(int, num))\\n        for i in n:\\n            if i in d:\\n                d[i] += 1\\n            else:\\n                d[i] = 1\\n        res = True\\n        for i in range(len(n)):\\n            if i in d:\\n                if d[i] != n[i]:\\n                    res = False\\n                    break\\n            elif i not in d:\\n                if n[i] > 0:\\n                    res = False\\n                    break\\n\\n        return res\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4079441,
                "title": "discuss",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean digitCount(String num) {\\n        int[] count = new int[10];\\n\\n        for (final char c : num.toCharArray())\\n        ++count[c - \\'0\\'];\\n\\n        for (int i = 0; i < num.length(); ++i)\\n        if (count[i] != num.charAt(i) - \\'0\\')\\n            return false;\\n\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean digitCount(String num) {\\n        int[] count = new int[10];\\n\\n        for (final char c : num.toCharArray())\\n        ++count[c - \\'0\\'];\\n\\n        for (int i = 0; i < num.length(); ++i)\\n        if (count[i] != num.charAt(i) - \\'0\\')\\n            return false;\\n\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4078817,
                "title": "c-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nObviously try to avoid n2\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nPutting the digits and their associated occurence in the map. You need to go through the num string again and decrease every time you see a digit. If the map holds digits for which the number of occurence left is not 0, than we have a problem.\\nCould be optmized.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1) Map has a maximum of 10 entries.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n        map<int,int> myMap;\\n\\n        for (int i=0; i<num.size(); i++) {\\n            myMap[i] = (int) num[i] -48; \\n        }\\n\\n        for (int i=0; i<num.size(); i++) { \\n            myMap[(int) num[i] -48]--;\\n        }\\n\\n        for (const auto & [key, value] : myMap)\\n            if (value != 0) return false;\\n\\n        return true;\\n    }\\n};\\n\\n// 0 apparait 1\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n        map<int,int> myMap;\\n\\n        for (int i=0; i<num.size(); i++) {\\n            myMap[i] = (int) num[i] -48; \\n        }\\n\\n        for (int i=0; i<num.size(); i++) { \\n            myMap[(int) num[i] -48]--;\\n        }\\n\\n        for (const auto & [key, value] : myMap)\\n            if (value != 0) return false;\\n\\n        return true;\\n    }\\n};\\n\\n// 0 apparait 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4078556,
                "title": "two-lines-solution",
                "content": "```\\nclass Solution:\\n    def digitCount(self, num: str) -> bool:\\n        cnt = Counter(map(int, num))\\n        return all(cnt[i] == int(n) for i, n in enumerate(num))      \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def digitCount(self, num: str) -> bool:\\n        cnt = Counter(map(int, num))\\n        return all(cnt[i] == int(n) for i, n in enumerate(num))      \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4071840,
                "title": "solution-in-java",
                "content": "```\\nclass Solution {\\n    public boolean digitCount(String num) {\\n        int[] freq = new int[10];\\n        for(int i=0;i<num.length();i++){\\n            freq[num.charAt(i)-\\'0\\']++;\\n        }\\n        for(int i=0;i<num.length();i++){\\n            if(num.charAt(i)-\\'0\\' != freq[i]) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean digitCount(String num) {\\n        int[] freq = new int[10];\\n        for(int i=0;i<num.length();i++){\\n            freq[num.charAt(i)-\\'0\\']++;\\n        }\\n        for(int i=0;i<num.length();i++){\\n            if(num.charAt(i)-\\'0\\' != freq[i]) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4071042,
                "title": "easy-c-solution",
                "content": "# Approach\\n- Build dictionary - cahr and number of occurencies of tthe char\\n- Check if ther condiction holds for each index\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\npublic class Solution\\n{\\n    public bool DigitCount(string num)\\n    {\\n        var dictionary = new Dictionary<char, int>();\\n        foreach (var c in num)\\n        {\\n            dictionary[c] = dictionary.GetValueOrDefault(c) + 1;\\n        }\\n\\n        return !num.Where((t, i) => dictionary.GetValueOrDefault((char) (\\'0\\' + i)) != t - \\'0\\').Any();\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution\\n{\\n    public bool DigitCount(string num)\\n    {\\n        var dictionary = new Dictionary<char, int>();\\n        foreach (var c in num)\\n        {\\n            dictionary[c] = dictionary.GetValueOrDefault(c) + 1;\\n        }\\n\\n        return !num.Where((t, i) => dictionary.GetValueOrDefault((char) (\\'0\\' + i)) != t - \\'0\\').Any();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4058408,
                "title": "c-100-faster-string",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(|hashTable|)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\tbool digitCount(string num) {\\n\\n\\t\\tint count[10] = {0};\\n\\n\\t\\tint inputSize = num.size();\\n\\n\\t\\tfor (int i = 0; i < inputSize; ++i)\\n\\t\\t{\\n\\t\\t\\tcount[num[i]-48]++;\\n\\t\\t}\\n\\n\\n\\t\\tfor (int i = 0; i < inputSize; ++i)\\n\\t\\t{\\n\\t\\t\\tif( (num[i]-48) !=  count[i]){\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn true;\\n\\n\\t}\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\tbool digitCount(string num) {\\n\\n\\t\\tint count[10] = {0};\\n\\n\\t\\tint inputSize = num.size();\\n\\n\\t\\tfor (int i = 0; i < inputSize; ++i)\\n\\t\\t{\\n\\t\\t\\tcount[num[i]-48]++;\\n\\t\\t}\\n\\n\\n\\t\\tfor (int i = 0; i < inputSize; ++i)\\n\\t\\t{\\n\\t\\t\\tif( (num[i]-48) !=  count[i]){\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn true;\\n\\n\\t}\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4047491,
                "title": "python-o-1-space-complexity-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def digitCount(self, num: str) -> bool:\\n\\n        for i in range(len(num)):\\n            if num.count(str(i)) != int(num[i]):\\n                return False\\n        \\n        return True\\n           \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def digitCount(self, num: str) -> bool:\\n\\n        for i in range(len(num)):\\n            if num.count(str(i)) != int(num[i]):\\n                return False\\n        \\n        return True\\n           \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4046356,
                "title": "easy-and-understandable-code-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n       \\n       vector<int>v;\\n       unordered_map<int,int>mp;\\n\\n       for(auto it:num)\\n       v.push_back(it-48);\\n\\n       for(auto it:v)\\n       mp[it]++;\\n\\n       for(int i=0;i<v.size();i++){\\n           if(mp[i]!=v[i])\\n            return false;\\n       }\\n       return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n       \\n       vector<int>v;\\n       unordered_map<int,int>mp;\\n\\n       for(auto it:num)\\n       v.push_back(it-48);\\n\\n       for(auto it:v)\\n       mp[it]++;\\n\\n       for(int i=0;i<v.size();i++){\\n           if(mp[i]!=v[i])\\n            return false;\\n       }\\n       return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4045126,
                "title": "2283-check-if-number-has-equal-digit-count-and-digit-value",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean digitCount(String num) {\\n\\n           HashMap<Integer,Integer> map = new HashMap<>();\\n        for(int number = 0; number < num.length(); number++){\\n            int frequency = Character.getNumericValue(num.charAt(number));\\n            map.put(number,frequency);\\n        }\\n\\n        for(int index = 0; index< num.length(); index++) {\\n\\n            if (Character.getNumericValue(num.charAt(index)) < num.length()) {\\n\\n                int frequency = map.get(Character.getNumericValue(num.charAt(index))) - 1;\\n                map.put(Character.getNumericValue(num.charAt(index)), frequency);\\n            }\\n        }\\n\\n        for (int i = 0; i < num.length(); i++) {\\n            if(map.get(i) !=0){\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean digitCount(String num) {\\n\\n           HashMap<Integer,Integer> map = new HashMap<>();\\n        for(int number = 0; number < num.length(); number++){\\n            int frequency = Character.getNumericValue(num.charAt(number));\\n            map.put(number,frequency);\\n        }\\n\\n        for(int index = 0; index< num.length(); index++) {\\n\\n            if (Character.getNumericValue(num.charAt(index)) < num.length()) {\\n\\n                int frequency = map.get(Character.getNumericValue(num.charAt(index))) - 1;\\n                map.put(Character.getNumericValue(num.charAt(index)), frequency);\\n            }\\n        }\\n\\n        for (int i = 0; i < num.length(); i++) {\\n            if(map.get(i) !=0){\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4042268,
                "title": "easiest-approach-beats-100-c-best-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n        unordered_map<char,int> san;\\n        for(auto &x:num)\\n            san[x]++;\\n        int k=0;\\n        int desh=num.size();\\n        while(desh--){\\n            if(san[(char)(k+48)]!=(num[k]-\\'0\\'))\\n                return false;\\n            k++;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n        unordered_map<char,int> san;\\n        for(auto &x:num)\\n            san[x]++;\\n        int k=0;\\n        int desh=num.size();\\n        while(desh--){\\n            if(san[(char)(k+48)]!=(num[k]-\\'0\\'))\\n                return false;\\n            k++;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4032741,
                "title": "simple-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe code aims to check if a given string num satisfies a specific condition where each digit i must occur exactly i times in the string. If this condition is met for every digit, the function returns true; otherwise, it returns false. The code uses a HashMap to count the occurrences of each digit in the string and compares the counts with the expected values.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Check if the first character of the string is \\'0\\'. If it is, return false because \\'0\\' cannot be the first character if every digit should occur at least once.\\n\\n2. Initialize a HashMap<Integer, Integer> called map to store the counts of each digit.\\n\\n3. Iterate through each character ch in the string num:\\n\\n4. Calculate the numeric value k of the current character by subtracting \\'0\\' from it.\\nUpdate the count of digit k in the map by using map.put(k, map.getOrDefault(k, 0) + 1).\\nIterate through the indices i from 0 to n-1, where n is the length of the string num:\\n\\n5. Calculate the numeric value m of the digit at index i in num.\\nCheck if m is equal to the count of digit i in the map using map.getOrDefault(i, 0).\\nIf m is not equal to the expected count, return false.\\nIf the code reaches this point without returning false, it means that the condition is satisfied for every digit, so return true.\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe code iterates through the string num twice, once to count the occurrences of each digit and once to check if the counts match the expected values. Therefore, the time complexity is O(2n), which simplifies to O(n), where n is the length of the input string num.\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe code uses a HashMap to store the counts of digits, which can have a maximum of 10 entries (0 to 9). Therefore, the space complexity is O(10), which simplifies to O(1) as it\\'s a constant space requirement.\\n# Code\\n```\\nclass Solution {\\n    public boolean digitCount(String num) {\\n        if (num.charAt(0) == \\'0\\') return false;\\n\\n        Map<Integer, Integer> map = new HashMap<>();\\n        int n = num.length();\\n\\n        for (char ch : num.toCharArray()){\\n            int k = ch - \\'0\\';\\n            map.put(k, map.getOrDefault(k, 0) + 1);\\n        }\\n\\n        for (int i = 0; i < n; i++){\\n            int m = num.charAt(i) - \\'0\\';\\n            if (m != map.getOrDefault(i, 0)){\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n```\\n![Frame 76.png](https://assets.leetcode.com/users/images/31fa458e-ca66-4725-8967-2f81fdd2ed8f_1694460428.0372012.png)\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean digitCount(String num) {\\n        if (num.charAt(0) == \\'0\\') return false;\\n\\n        Map<Integer, Integer> map = new HashMap<>();\\n        int n = num.length();\\n\\n        for (char ch : num.toCharArray()){\\n            int k = ch - \\'0\\';\\n            map.put(k, map.getOrDefault(k, 0) + 1);\\n        }\\n\\n        for (int i = 0; i < n; i++){\\n            int m = num.charAt(i) - \\'0\\';\\n            if (m != map.getOrDefault(i, 0)){\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4031271,
                "title": "python3-easy-2-liner-upvote-if-you-like",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def digitCount(self, num: str) -> bool:\\n        counter = Counter(num)\\n        return all(str(counter.get(str(index), 0)) == digit for index, digit in enumerate(num))\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def digitCount(self, num: str) -> bool:\\n        counter = Counter(num)\\n        return all(str(counter.get(str(index), 0)) == digit for index, digit in enumerate(num))\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4023967,
                "title": "100-beats-java-solution",
                "content": "# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean digitCount(String nums) {\\n\\n\\n        int[] flag = new int[10];\\n\\n\\n        for(int i = 0; i<nums.length(); i++){\\n            flag[nums.charAt(i)-\\'0\\']++;\\n        }\\n\\n\\n        for(int i = 0; i<nums.length(); i++){\\n            if(nums.charAt(i)-\\'0\\'!=flag[i]) return false;\\n        }\\n\\n        return true;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean digitCount(String nums) {\\n\\n\\n        int[] flag = new int[10];\\n\\n\\n        for(int i = 0; i<nums.length(); i++){\\n            flag[nums.charAt(i)-\\'0\\']++;\\n        }\\n\\n\\n        for(int i = 0; i<nums.length(); i++){\\n            if(nums.charAt(i)-\\'0\\'!=flag[i]) return false;\\n        }\\n\\n        return true;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4021280,
                "title": "check-if-number-has-equal-digit-count-and-digit-value-in-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean digitCount(String num) {\\n        for(int i=0;i<num.length();i++)\\n        {\\n            if(num.charAt(i)-\\'0\\' != Freq(num,(char)(i + \\'0\\')))\\n            return false;\\n        }\\n        return true;\\n    }\\n    public int Freq(String s , char ch)\\n    {\\n        int f=0;\\n        for(int i=0;i<s.length();i++)\\n        if(s.charAt(i)==ch)\\n        f++;\\n        return f;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean digitCount(String num) {\\n        for(int i=0;i<num.length();i++)\\n        {\\n            if(num.charAt(i)-\\'0\\' != Freq(num,(char)(i + \\'0\\')))\\n            return false;\\n        }\\n        return true;\\n    }\\n    public int Freq(String s , char ch)\\n    {\\n        int f=0;\\n        for(int i=0;i<s.length();i++)\\n        if(s.charAt(i)==ch)\\n        f++;\\n        return f;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4014663,
                "title": "1ms-java-code",
                "content": "# Code\\n```\\nclass Solution {\\n    public boolean digitCount(String num) {\\n        for (int i = 0; i < num.length(); i++) {\\n            int digit = num.charAt(i) - \\'0\\'; // Convert the character to an integer digit\\n            int count = 0;\\n\\n            for (int j = 0; j < num.length(); j++) {\\n                int currentDigit = num.charAt(j) - \\'0\\';\\n                if (currentDigit == i) {\\n                    count++;\\n                }\\n            }\\n            if (count != digit) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean digitCount(String num) {\\n        for (int i = 0; i < num.length(); i++) {\\n            int digit = num.charAt(i) - \\'0\\'; // Convert the character to an integer digit\\n            int count = 0;\\n\\n            for (int j = 0; j < num.length(); j++) {\\n                int currentDigit = num.charAt(j) - \\'0\\';\\n                if (currentDigit == i) {\\n                    count++;\\n                }\\n            }\\n            if (count != digit) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4014504,
                "title": "1ms-easy-code-java-string",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean digitCount(String num) {\\n        for (int i = 0; i < num.length(); i++) {\\n            int digit = num.charAt(i) - \\'0\\'; // Convert the character to an integer digit\\n            int count = 0;\\n\\n            for (int j = 0; j < num.length(); j++) {\\n                int currentDigit = num.charAt(j) - \\'0\\';\\n                if (currentDigit == i) {\\n                    count++;\\n                }\\n            }\\n\\n            if (count != digit) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean digitCount(String num) {\\n        for (int i = 0; i < num.length(); i++) {\\n            int digit = num.charAt(i) - \\'0\\'; // Convert the character to an integer digit\\n            int count = 0;\\n\\n            for (int j = 0; j < num.length(); j++) {\\n                int currentDigit = num.charAt(j) - \\'0\\';\\n                if (currentDigit == i) {\\n                    count++;\\n                }\\n            }\\n\\n            if (count != digit) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4012973,
                "title": "one-line-solution-using-list-comprehensions",
                "content": "# Code\\n```\\nclass Solution:\\n    def digitCount(self, num: str) -> bool:\\n        return len([x for i, x in enumerate(num) if int(x) == num.count(str(i))]) == len(num)\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def digitCount(self, num: str) -> bool:\\n        return len([x for i, x in enumerate(num) if int(x) == num.count(str(i))]) == len(num)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4009684,
                "title": "easy-cpp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n        \\n       int n = num.length();\\n        int count[10] = {0};\\n        for (int i = 0; i < n; i++) {\\n            count[num[i] - \\'0\\']++;\\n        }\\n        for (int i = 0; i < n; i++) {\\n            if (count[i] != num[i] - \\'0\\') {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n        \\n       int n = num.length();\\n        int count[10] = {0};\\n        for (int i = 0; i < n; i++) {\\n            count[num[i] - \\'0\\']++;\\n        }\\n        for (int i = 0; i < n; i++) {\\n            if (count[i] != num[i] - \\'0\\') {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4009618,
                "title": "simple-java-solution-0-ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean digitCount(String num) {\\n        int arr[]=new int[num.length()];\\n        int c=0;\\n        for(int i=0;i<num.length();i++)\\n            arr[i]=num.charAt(i)-\\'0\\';\\n        for(int i=0;i<arr.length;i++){\\n            int n=arr[i];\\n            for(int j=0;j<arr.length;j++){\\n                if(arr[j]==i)\\n                    c++;\\n            }\\n            if(c!=n)\\n                return false;\\n            c=0;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean digitCount(String num) {\\n        int arr[]=new int[num.length()];\\n        int c=0;\\n        for(int i=0;i<num.length();i++)\\n            arr[i]=num.charAt(i)-\\'0\\';\\n        for(int i=0;i<arr.length;i++){\\n            int n=arr[i];\\n            for(int j=0;j<arr.length;j++){\\n                if(arr[j]==i)\\n                    c++;\\n            }\\n            if(c!=n)\\n                return false;\\n            c=0;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4007228,
                "title": "beats-82-runtime-and-memory",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string} num\\n * @return {boolean}\\n */\\nvar digitCount = function(num) {\\n     let n = new Map();\\n    let numArray = num.split(\\'\\');\\n    for (i = 0; i < numArray.length; i++) {\\n        let val = 0;\\n        let index = Number(numArray[i]);\\n        n.get(index) ? val = n.get(index) + 1 : val = 1\\n        n.set(index, val);\\n    }\\n    for (i = 0; i < num.length; i++) {\\n        const a = Number(n.get(i)) || 0\\n        const b = Number(numArray[i])\\n        if (a !== b) {\\n            return false\\n        }\\n    }\\n    return true\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} num\\n * @return {boolean}\\n */\\nvar digitCount = function(num) {\\n     let n = new Map();\\n    let numArray = num.split(\\'\\');\\n    for (i = 0; i < numArray.length; i++) {\\n        let val = 0;\\n        let index = Number(numArray[i]);\\n        n.get(index) ? val = n.get(index) + 1 : val = 1\\n        n.set(index, val);\\n    }\\n    for (i = 0; i < num.length; i++) {\\n        const a = Number(n.get(i)) || 0\\n        const b = Number(numArray[i])\\n        if (a !== b) {\\n            return false\\n        }\\n    }\\n    return true\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4004424,
                "title": "java-easy-solution-hashing-100-beats",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public static boolean digitCount(String num) {\\n        int[] hash = new int[10];\\n        for(int n : num.toCharArray())\\n            hash[n-\\'0\\'-0]++;\\n        for(int i=0; i<num.length(); i++) \\n        \\tif(num.charAt(i)-\\'0\\'-0 != hash[i]) return false;\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "String",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\n    public static boolean digitCount(String num) {\\n        int[] hash = new int[10];\\n        for(int n : num.toCharArray())\\n            hash[n-\\'0\\'-0]++;\\n        for(int i=0; i<num.length(); i++) \\n        \\tif(num.charAt(i)-\\'0\\'-0 != hash[i]) return false;\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4001639,
                "title": "runtime-0ms-beats-100-00-of-users-with-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n        vector<int> v(10,0);\\n        for (int i=0;i<num.size();i++){\\n            v[num[i]-\\'0\\']++;\\n        }\\n        for (int j=0;j<num.size();j++){\\n            if (v[j]!=(int)num[j]-\\'0\\'){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n        vector<int> v(10,0);\\n        for (int i=0;i<num.size();i++){\\n            v[num[i]-\\'0\\']++;\\n        }\\n        for (int j=0;j<num.size();j++){\\n            if (v[j]!=(int)num[j]-\\'0\\'){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3999682,
                "title": "python3-just-count-and-compare",
                "content": "# Code\\n```\\nclass Solution:\\n    def digitCount(self, num: str) -> bool:\\n        N = len(num)\\n        cnts = [0]*10\\n        for n in num:\\n            cnts[int(n)]+=1\\n\\n        for i in range(N):\\n            if cnts[i] != int(num[i]):\\n                return False\\n\\n        return True            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def digitCount(self, num: str) -> bool:\\n        N = len(num)\\n        cnts = [0]*10\\n        for n in num:\\n            cnts[int(n)]+=1\\n\\n        for i in range(N):\\n            if cnts[i] != int(num[i]):\\n                return False\\n\\n        return True            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3994411,
                "title": "typescript-simple-solution-100-speed",
                "content": "![image.png](https://assets.leetcode.com/users/images/63c37f02-c7f7-477b-9b62-9d963e8f500a_1693692919.8918602.png)\\n\\n# Code (100% speed)\\n```ts\\nfunction digitCount(num: string): boolean {\\n    const map = new Map<number, number>() // number, count\\n    const numStr = num + \"\"\\n\\n    for (const each of numStr) {\\n        const eachNum = parseInt(each)\\n        const got = map.get(eachNum) || 0\\n        map.set(eachNum, got + 1)\\n    }\\n\\n    for (let i = 0; i < numStr.length; i++) {\\n        const count = parseInt(numStr[i])\\n        if ((map.get(i) || 0) !== count) return false\\n    }\\n    return true\\n};\\n```\\n\\n# Thank you\\nUpvote if you like \\u2B06\\uFE0F\\nIf you have any questions, please let me know in the comment section.",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```ts\\nfunction digitCount(num: string): boolean {\\n    const map = new Map<number, number>() // number, count\\n    const numStr = num + \"\"\\n\\n    for (const each of numStr) {\\n        const eachNum = parseInt(each)\\n        const got = map.get(eachNum) || 0\\n        map.set(eachNum, got + 1)\\n    }\\n\\n    for (let i = 0; i < numStr.length; i++) {\\n        const count = parseInt(numStr[i])\\n        if ((map.get(i) || 0) !== count) return false\\n    }\\n    return true\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3994410,
                "title": "typescript-simple-solution-100-speed",
                "content": "![image.png](https://assets.leetcode.com/users/images/63c37f02-c7f7-477b-9b62-9d963e8f500a_1693692919.8918602.png)\\n\\n# Code (100% speed)\\n```ts\\nfunction digitCount(num: string): boolean {\\n    const map = new Map<number, number>() // number, count\\n    const numStr = num + \"\"\\n\\n    for (const each of numStr) {\\n        const eachNum = parseInt(each)\\n        const got = map.get(eachNum) || 0\\n        map.set(eachNum, got + 1)\\n    }\\n\\n    for (let i = 0; i < numStr.length; i++) {\\n        const count = parseInt(numStr[i])\\n        if ((map.get(i) || 0) !== count) return false\\n    }\\n    return true\\n};\\n```\\n\\n# Thank you\\nUpvote if you like \\u2B06\\uFE0F\\nIf you have any questions, please let me know in the comment section.",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```ts\\nfunction digitCount(num: string): boolean {\\n    const map = new Map<number, number>() // number, count\\n    const numStr = num + \"\"\\n\\n    for (const each of numStr) {\\n        const eachNum = parseInt(each)\\n        const got = map.get(eachNum) || 0\\n        map.set(eachNum, got + 1)\\n    }\\n\\n    for (let i = 0; i < numStr.length; i++) {\\n        const count = parseInt(numStr[i])\\n        if ((map.get(i) || 0) !== count) return false\\n    }\\n    return true\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3991812,
                "title": "0-ms-beats-100-00-of-users-with-c",
                "content": "\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n        vector<int> ans; \\n        for(int i=0;i<num.size();i++)\\n        {\\n            int temp=num[i]-48;\\n            ans.push_back(temp);\\n        }\\n        int f=0;\\n        for(int i=0;i<ans.size();i++)\\n        {\\n            cout<<ans[i]<<\" \";\\n        }\\n        for(int i=0;i<ans.size();i++)\\n        {\\n            int c=count(ans.begin(),ans.end(),i);\\n            if(c==ans[i])\\n            {\\n                f=1;\\n            }\\n            else\\n            {\\n                f=0;\\n                break;\\n            }\\n        }\\n        if(f==1)\\n        {\\n            return true;\\n        }\\n        return false;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n        vector<int> ans; \\n        for(int i=0;i<num.size();i++)\\n        {\\n            int temp=num[i]-48;\\n            ans.push_back(temp);\\n        }\\n        int f=0;\\n        for(int i=0;i<ans.size();i++)\\n        {\\n            cout<<ans[i]<<\" \";\\n        }\\n        for(int i=0;i<ans.size();i++)\\n        {\\n            int c=count(ans.begin(),ans.end(),i);\\n            if(c==ans[i])\\n            {\\n                f=1;\\n            }\\n            else\\n            {\\n                f=0;\\n                break;\\n            }\\n        }\\n        if(f==1)\\n        {\\n            return true;\\n        }\\n        return false;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3981858,
                "title": "java-easy-solution-using-for-loop",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean digitCount(String num) {\\n        for(int i=0;i<num.length();i++){\\n            int m=Integer.parseInt(String.valueOf(num.charAt(i)));\\n            int c=0;\\n            for(int j=0;j<num.length();j++){\\n                int n=Integer.parseInt(String.valueOf(num.charAt(j)));\\n                if(n==i){\\n                    c++;\\n                }\\n            }\\n            if(c!=m){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean digitCount(String num) {\\n        for(int i=0;i<num.length();i++){\\n            int m=Integer.parseInt(String.valueOf(num.charAt(i)));\\n            int c=0;\\n            for(int j=0;j<num.length();j++){\\n                int n=Integer.parseInt(String.valueOf(num.charAt(j)));\\n                if(n==i){\\n                    c++;\\n                }\\n            }\\n            if(c!=m){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3970056,
                "title": "c-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n        vector<int> vec(10,0);\\n        char c;\\n        for(int i=0;i<num.size();i++)\\n        {\\n            c=num[i];\\n            vec[c-\\'0\\']++;\\n        }\\n\\n        for(int i=0;i<num.size();i++)\\n        {\\n            if(num[i]-\\'0\\'!=vec[i])\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n        vector<int> vec(10,0);\\n        char c;\\n        for(int i=0;i<num.size();i++)\\n        {\\n            c=num[i];\\n            vec[c-\\'0\\']++;\\n        }\\n\\n        for(int i=0;i<num.size();i++)\\n        {\\n            if(num[i]-\\'0\\'!=vec[i])\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3969137,
                "title": "c-using-map",
                "content": "```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n        \\n        map<int,int> vec;\\n        for(int i=0;i<num.size();i++)\\n        {\\n            vec[num[i]-\\'0\\']++;\\n        }\\n        for(int i=0;i<num.size();i++)\\n        {\\n            if(vec[i]!=num[i]-\\'0\\')\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n        \\n        map<int,int> vec;\\n        for(int i=0;i<num.size();i++)\\n        {\\n            vec[num[i]-\\'0\\']++;\\n        }\\n        for(int i=0;i<num.size();i++)\\n        {\\n            if(vec[i]!=num[i]-\\'0\\')\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3969134,
                "title": "c-using-map",
                "content": "```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n        \\n        map<int,int> vec;\\n        for(int i=0;i<num.size();i++)\\n        {\\n            vec[num[i]-\\'0\\']++;\\n        }\\n        for(int i=0;i<num.size();i++)\\n        {\\n            if(vec[i]!=num[i]-\\'0\\')\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n        \\n        map<int,int> vec;\\n        for(int i=0;i<num.size();i++)\\n        {\\n            vec[num[i]-\\'0\\']++;\\n        }\\n        for(int i=0;i<num.size();i++)\\n        {\\n            if(vec[i]!=num[i]-\\'0\\')\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3965992,
                "title": "beats-easy-beginner-friendly-solution-simple-and-easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean digitCount(String num) {\\n        int[] c= new int[10];\\n        for(int i=0;i<num.length();i++){\\n            int n=num.charAt(i)-\\'0\\';\\n            c[n]++;\\n        }\\n        for(int i=0;i<num.length();i++){\\n            int n=num.charAt(i)-\\'0\\';\\n            c[i]-=n;\\n        }\\n        for(int i=0;i<10;i++){\\n            if(c[i]!=0) return false;\\n        }\\n        return true;\\n    }\\n\\n\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean digitCount(String num) {\\n        int[] c= new int[10];\\n        for(int i=0;i<num.length();i++){\\n            int n=num.charAt(i)-\\'0\\';\\n            c[n]++;\\n        }\\n        for(int i=0;i<num.length();i++){\\n            int n=num.charAt(i)-\\'0\\';\\n            c[i]-=n;\\n        }\\n        for(int i=0;i<10;i++){\\n            if(c[i]!=0) return false;\\n        }\\n        return true;\\n    }\\n\\n\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3960239,
                "title": "easy-to-read-python-solution-with-explanation-in-comments",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def digitCount(self, num: str) -> bool:\\n\\n        #convert the num into a string\\n\\n        strNum = str(num)\\n\\n        #build a freq map of the digits in the num\\n\\n        digitCounter = Counter()\\n\\n        for digit in strNum:\\n            digitCounter[digit] += 1\\n        \\n        #now start parsing thru the number again\\n        # for each index, check if the frequency of the index\\n        # equal the digit at the index\\n\\n        for i in range(0, len(strNum)):\\n            indexStr = str(i) #converting the index into a str so we can look it up in the dict\\n            digitInt = int(strNum[i]) #converting the digit to an Int so we can compare it to indexStr\\'s frequency\\n            if digitCounter[indexStr] != digitInt:\\n                return False\\n        \\n        #if we come out of the loop, this means that all digits met the condition\\n        # so return true\\n\\n        return True\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def digitCount(self, num: str) -> bool:\\n\\n        #convert the num into a string\\n\\n        strNum = str(num)\\n\\n        #build a freq map of the digits in the num\\n\\n        digitCounter = Counter()\\n\\n        for digit in strNum:\\n            digitCounter[digit] += 1\\n        \\n        #now start parsing thru the number again\\n        # for each index, check if the frequency of the index\\n        # equal the digit at the index\\n\\n        for i in range(0, len(strNum)):\\n            indexStr = str(i) #converting the index into a str so we can look it up in the dict\\n            digitInt = int(strNum[i]) #converting the digit to an Int so we can compare it to indexStr\\'s frequency\\n            if digitCounter[indexStr] != digitInt:\\n                return False\\n        \\n        #if we come out of the loop, this means that all digits met the condition\\n        # so return true\\n\\n        return True\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3960089,
                "title": "easy-approach",
                "content": "\\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\nbool digitCount(String num) {\\n for (int i = 0; i < num.length; i++) {\\n    int count = 0;\\n\\n    for (int j = 0; j < num.length; j++) {\\n      if (int.parse(num[j]) == i) {\\n        count++;\\n      }\\n    }\\n\\n    if (count != int.parse(num[i])) {\\n      return false;\\n    }\\n  }\\n\\n  return true;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nclass Solution {\\nbool digitCount(String num) {\\n for (int i = 0; i < num.length; i++) {\\n    int count = 0;\\n\\n    for (int j = 0; j < num.length; j++) {\\n      if (int.parse(num[j]) == i) {\\n        count++;\\n      }\\n    }\\n\\n    if (count != int.parse(num[i])) {\\n      return false;\\n    }\\n  }\\n\\n  return true;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3947496,
                "title": "simple-solution-for-beginners-using-arraylist-java",
                "content": "# Intuition\\nBy understanding the problem one thing is clear that the first index is 0 and therefore for a single digit number input output will always be false as a single digit number has a frequency of one and index is 0. I found a way to separate the digit after checking for the above condition and after separating the digits i just checked remaining conditions.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAfter checking the single digit condition, I used logic of reversal of digit to separate the digits and stored the output in an ArrayList. After that I reversed the ArrayList as our digit was reversed it would have given wrong output if not reversed. Now we have the original number ... we will just use two for loops one for index digit and  another for traversing through the arraylist for the occurences. Then after counting the occurences I just compared it with the actual frequency we must have and after repeating this process if at some point occurrences and the given frequency is not equal we return false and breakout of the loop or return true as default value.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nit has a 2ms runtime and code is bit heavy but as a beginner it was easy for me ....I do admit the hashmap makes this stuff easies and char to int conversion methods can also be used but as I was solving i came up with this solution as a beginner.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean digitCount(String num) {\\n        Long k = Long.valueOf(num);\\n        return digitCount(k);\\n    }\\n    private boolean digitCount(long numb){\\n        ArrayList<Long> list1 = new ArrayList<Long>();\\n        boolean res = true;\\n        if(numb>=10){\\n        long temp = numb;\\n        while(temp>0){\\n            list1.add(temp%10);\\n            temp=temp/10;\\n        }\\n        Collections.reverse(list1);\\n        for(int i=0;i<list1.size();i++){\\n            int count = 0;\\n            for(int k=0;k<list1.size();k++)\\n            {\\n                if(i==list1.get(k))\\n                {\\n                    count++;\\n                }\\n            }\\n            if(count==list1.get(i))\\n            {\\n                res = true;\\n            }\\n            else\\n            {\\n                res = false;\\n                break;\\n            }\\n        }\\n        }\\n        else\\n        {\\n         res = false;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean digitCount(String num) {\\n        Long k = Long.valueOf(num);\\n        return digitCount(k);\\n    }\\n    private boolean digitCount(long numb){\\n        ArrayList<Long> list1 = new ArrayList<Long>();\\n        boolean res = true;\\n        if(numb>=10){\\n        long temp = numb;\\n        while(temp>0){\\n            list1.add(temp%10);\\n            temp=temp/10;\\n        }\\n        Collections.reverse(list1);\\n        for(int i=0;i<list1.size();i++){\\n            int count = 0;\\n            for(int k=0;k<list1.size();k++)\\n            {\\n                if(i==list1.get(k))\\n                {\\n                    count++;\\n                }\\n            }\\n            if(count==list1.get(i))\\n            {\\n                res = true;\\n            }\\n            else\\n            {\\n                res = false;\\n                break;\\n            }\\n        }\\n        }\\n        else\\n        {\\n         res = false;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3942507,
                "title": "python-2-lines",
                "content": "# Approach\\nNot the best option as we need to iterate over all **num** in all cases. Without 2 lines we can return False as soon as one condition is False.\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def digitCount(self, num: str) -> bool:\\n        d = Counter(num)\\n        return all(1 if str(d[str(i)]) == num[i] else 0 for i in range(len(num)))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def digitCount(self, num: str) -> bool:\\n        d = Counter(num)\\n        return all(1 if str(d[str(i)]) == num[i] else 0 for i in range(len(num)))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3942332,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean digitCount(String num) {\\n        int[] digit = new int[10];\\n        for(char c :num.toCharArray()){\\n            digit[c-\\'0\\']++;\\n        }\\n        for(int i=0;i<num.length();i++){\\n            int n = num.charAt(i) - \\'0\\';\\n            if(n!=digit[i]){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean digitCount(String num) {\\n        int[] digit = new int[10];\\n        for(char c :num.toCharArray()){\\n            digit[c-\\'0\\']++;\\n        }\\n        for(int i=0;i<num.length();i++){\\n            int n = num.charAt(i) - \\'0\\';\\n            if(n!=digit[i]){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3933004,
                "title": "beats-93-85-of-users-with-javascript-easy-javascript-solution-with-line-by-line-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string} num\\n * @return {boolean}\\n */\\nvar digitCount = function (num) {\\n\\n    // initialize function checkCount with parameter index\\n    function checkCount(index) {\\n\\n        // initialize count to zero\\n        let count = 0;\\n\\n        // loop through every character of string num\\n        for (let j = 0; j < num.length; j++) {\\n\\n            // if index is equal to every character of string num then increment count\\n            if (index == num[j]) {\\n\\n                count++;\\n            }\\n        }\\n\\n        // return count\\n        return count;\\n    }\\n\\n    // loop through every character of string num\\n    for (let i = 0; i < num.length; i++) {\\n\\n        // invoke the function checkCount with argument index i\\n        let digitCount = checkCount(i);\\n\\n        // if every character of num is not equal to digitCount then return false\\n        if (num[i] != digitCount) {\\n\\n            return false;\\n        }\\n    }\\n\\n    // return true\\n    return true;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} num\\n * @return {boolean}\\n */\\nvar digitCount = function (num) {\\n\\n    // initialize function checkCount with parameter index\\n    function checkCount(index) {\\n\\n        // initialize count to zero\\n        let count = 0;\\n\\n        // loop through every character of string num\\n        for (let j = 0; j < num.length; j++) {\\n\\n            // if index is equal to every character of string num then increment count\\n            if (index == num[j]) {\\n\\n                count++;\\n            }\\n        }\\n\\n        // return count\\n        return count;\\n    }\\n\\n    // loop through every character of string num\\n    for (let i = 0; i < num.length; i++) {\\n\\n        // invoke the function checkCount with argument index i\\n        let digitCount = checkCount(i);\\n\\n        // if every character of num is not equal to digitCount then return false\\n        if (num[i] != digitCount) {\\n\\n            return false;\\n        }\\n    }\\n\\n    // return true\\n    return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3932535,
                "title": "c-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n        map<char,int>m;\\n       for(int i=0;i<num.length();i++){\\n         m[num[i]]+=1;\\n       } \\n       for(auto i:m){\\n           \\n           if(num[i.first-\\'0\\']-\\'0\\' != i.second){\\n               return false;\\n           }\\n       }\\n       return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n        map<char,int>m;\\n       for(int i=0;i<num.length();i++){\\n         m[num[i]]+=1;\\n       } \\n       for(auto i:m){\\n           \\n           if(num[i.first-\\'0\\']-\\'0\\' != i.second){\\n               return false;\\n           }\\n       }\\n       return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3929865,
                "title": "python-easy-for-loop-solution",
                "content": "# Code\\n```\\nclass Solution(object):\\n    def strCount(self, num, i):\\n        return num.count(i)\\n\\n    def digitCount(self, num):\\n        output = \\'\\'\\n        for i in range(len(num)):\\n            total = self.strCount(num, str(i))\\n            output += str(total)\\n        return output == num\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def strCount(self, num, i):\\n        return num.count(i)\\n\\n    def digitCount(self, num):\\n        output = \\'\\'\\n        for i in range(len(num)):\\n            total = self.strCount(num, str(i))\\n            output += str(total)\\n        return output == num\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3924050,
                "title": "python3-solution-with-using-hashmap",
                "content": "# Code\\n```\\nclass Solution:\\n    def digitCount(self, num: str) -> bool:\\n        d = collections.defaultdict(int)\\n\\n        for char in num:\\n            d[int(char)] += 1\\n\\n        for i in range(len(num)):\\n            if d[i] != int(num[i]): return False\\n        \\n        return True\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def digitCount(self, num: str) -> bool:\\n        d = collections.defaultdict(int)\\n\\n        for char in num:\\n            d[int(char)] += 1\\n\\n        for i in range(len(num)):\\n            if d[i] != int(num[i]): return False\\n        \\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3923038,
                "title": "digit-count-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def digitCount(self, num: str) -> bool:\\n        for i in range(len(num)):\\n            if num.count(str(i))!=int(num[i]):\\n                return False\\n        return True\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def digitCount(self, num: str) -> bool:\\n        for i in range(len(num)):\\n            if num.count(str(i))!=int(num[i]):\\n                return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3914807,
                "title": "easy-solution-using-java",
                "content": "\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean digitCount(String num) {\\n        int[] arr = new int[10];\\n        for(char c:num.toCharArray()){\\n            arr[c - \\'0\\']++;\\n        }\\n        for(int i = 0; i < num.length(); i++){\\n            if(num.charAt(i) - \\'0\\' != arr[i]){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean digitCount(String num) {\\n        int[] arr = new int[10];\\n        for(char c:num.toCharArray()){\\n            arr[c - \\'0\\']++;\\n        }\\n        for(int i = 0; i < num.length(); i++){\\n            if(num.charAt(i) - \\'0\\' != arr[i]){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3911698,
                "title": "c-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n) ~ O(1) since n can be max 10\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n        \\n        int i,j,l=num.length();\\n        int a[10];\\n        memset(a,0,sizeof(a));\\n        bool b = true;\\n        for(i=0;i<l;++i)\\n        {\\n            int c=int(num[i])-48;\\n            a[c]+=1;\\n        }\\n        for(i=0;i<l;++i)\\n        {\\n            if(int(num[i]-48)!=(a[i]))\\n            b=0;\\n        }\\n        return b;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool digitCount(string num) {\\n        \\n        int i,j,l=num.length();\\n        int a[10];\\n        memset(a,0,sizeof(a));\\n        bool b = true;\\n        for(i=0;i<l;++i)\\n        {\\n            int c=int(num[i])-48;\\n            a[c]+=1;\\n        }\\n        for(i=0;i<l;++i)\\n        {\\n            if(int(num[i]-48)!=(a[i]))\\n            b=0;\\n        }\\n        return b;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3911306,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nlinear 2n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nbool digitCount(char * num){\\n\\n    int *fre = (int*)calloc(4, 10);\\n\\n    for(int i = 0; i < strlen(num); i++){\\n        fre[num[i] -\\'0\\']++;\\n    }\\n    for(int i = 0; i < strlen(num); i++){\\n        if(fre[i] !=num[i] - \\'0\\'){\\n            return false;\\n        }\\n    }\\n\\n    return true;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nbool digitCount(char * num){\\n\\n    int *fre = (int*)calloc(4, 10);\\n\\n    for(int i = 0; i < strlen(num); i++){\\n        fre[num[i] -\\'0\\']++;\\n    }\\n    for(int i = 0; i < strlen(num); i++){\\n        if(fre[i] !=num[i] - \\'0\\'){\\n            return false;\\n        }\\n    }\\n\\n    return true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3906374,
                "title": "easy-solution-5-lines",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def digitCount(self, num: str) -> bool:\\n        c = Counter(num)\\n        for i in range(len(num)):\\n            if int(num[i]) != c[str(i)]:\\n                return False\\n        return True\\n```\\n\\nPlease let me know if any improvements can be made.\\n\\nThanks",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def digitCount(self, num: str) -> bool:\\n        c = Counter(num)\\n        for i in range(len(num)):\\n            if int(num[i]) != c[str(i)]:\\n                return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3905020,
                "title": "easy-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def digitCount(self, num: str) -> bool:\\n        for i in range (len(num)):\\n            if num.count(str(i))!=int(num[i]):\\n                return False\\n        return True        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def digitCount(self, num: str) -> bool:\\n        for i in range (len(num)):\\n            if num.count(str(i))!=int(num[i]):\\n                return False\\n        return True        \\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1792237,
                "content": [
                    {
                        "username": "narasimhakamath",
                        "content": "Umm...what?"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "The framing of the problem statement makes it a little tricky which is otherwise an easy problem. "
                    },
                    {
                        "username": "eeveeouo",
                        "content": "For sure"
                    },
                    {
                        "username": "arindamsharma0123",
                        "content": "Make separate function to count char in the string and return it in int type. It will give you O(1) time complexity \\nint count(string num,int c){\\n        char ch;\\n        if(c == 0){\\n            ch = \\'0\\';\\n        }\\n        if(c == 1){\\n            ch = \\'1\\';\\n        }\\n        if(c == 2){\\n            ch = \\'2\\';\\n        }\\n        if(c == 3){\\n            ch = \\'3\\';\\n        }\\n        if(c == 4){\\n            ch = \\'4\\';\\n        }\\n        if(c == 5){\\n            ch = \\'5\\';\\n        }\\n        if(c == 6){\\n            ch = \\'6\\';\\n        }\\n        if(c == 7){\\n            ch = \\'7\\';\\n        }\\n        if(c == 8){\\n            ch = \\'8\\';\\n        }\\n        if(c == 9){\\n            ch = \\'9\\';\\n        }\\n        int ans = 0;\\n        for(int i = 0; num[i] != \\'\\\\0\\'; i++){\\n            if(num[i] == ch){\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }."
                    },
                    {
                        "username": "Amit17491",
                        "content": " I am facing issue while solve this question.\n\nnum = '0'\ni am printing my ans = 'false'\noutput = true\nexpected = false"
                    }
                ]
            },
            {
                "id": 1845321,
                "content": [
                    {
                        "username": "narasimhakamath",
                        "content": "Umm...what?"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "The framing of the problem statement makes it a little tricky which is otherwise an easy problem. "
                    },
                    {
                        "username": "eeveeouo",
                        "content": "For sure"
                    },
                    {
                        "username": "arindamsharma0123",
                        "content": "Make separate function to count char in the string and return it in int type. It will give you O(1) time complexity \\nint count(string num,int c){\\n        char ch;\\n        if(c == 0){\\n            ch = \\'0\\';\\n        }\\n        if(c == 1){\\n            ch = \\'1\\';\\n        }\\n        if(c == 2){\\n            ch = \\'2\\';\\n        }\\n        if(c == 3){\\n            ch = \\'3\\';\\n        }\\n        if(c == 4){\\n            ch = \\'4\\';\\n        }\\n        if(c == 5){\\n            ch = \\'5\\';\\n        }\\n        if(c == 6){\\n            ch = \\'6\\';\\n        }\\n        if(c == 7){\\n            ch = \\'7\\';\\n        }\\n        if(c == 8){\\n            ch = \\'8\\';\\n        }\\n        if(c == 9){\\n            ch = \\'9\\';\\n        }\\n        int ans = 0;\\n        for(int i = 0; num[i] != \\'\\\\0\\'; i++){\\n            if(num[i] == ch){\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }."
                    },
                    {
                        "username": "Amit17491",
                        "content": " I am facing issue while solve this question.\n\nnum = '0'\ni am printing my ans = 'false'\noutput = true\nexpected = false"
                    }
                ]
            },
            {
                "id": 2046477,
                "content": [
                    {
                        "username": "narasimhakamath",
                        "content": "Umm...what?"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "The framing of the problem statement makes it a little tricky which is otherwise an easy problem. "
                    },
                    {
                        "username": "eeveeouo",
                        "content": "For sure"
                    },
                    {
                        "username": "arindamsharma0123",
                        "content": "Make separate function to count char in the string and return it in int type. It will give you O(1) time complexity \\nint count(string num,int c){\\n        char ch;\\n        if(c == 0){\\n            ch = \\'0\\';\\n        }\\n        if(c == 1){\\n            ch = \\'1\\';\\n        }\\n        if(c == 2){\\n            ch = \\'2\\';\\n        }\\n        if(c == 3){\\n            ch = \\'3\\';\\n        }\\n        if(c == 4){\\n            ch = \\'4\\';\\n        }\\n        if(c == 5){\\n            ch = \\'5\\';\\n        }\\n        if(c == 6){\\n            ch = \\'6\\';\\n        }\\n        if(c == 7){\\n            ch = \\'7\\';\\n        }\\n        if(c == 8){\\n            ch = \\'8\\';\\n        }\\n        if(c == 9){\\n            ch = \\'9\\';\\n        }\\n        int ans = 0;\\n        for(int i = 0; num[i] != \\'\\\\0\\'; i++){\\n            if(num[i] == ch){\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }."
                    },
                    {
                        "username": "Amit17491",
                        "content": " I am facing issue while solve this question.\n\nnum = '0'\ni am printing my ans = 'false'\noutput = true\nexpected = false"
                    }
                ]
            },
            {
                "id": 2009175,
                "content": [
                    {
                        "username": "narasimhakamath",
                        "content": "Umm...what?"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "The framing of the problem statement makes it a little tricky which is otherwise an easy problem. "
                    },
                    {
                        "username": "eeveeouo",
                        "content": "For sure"
                    },
                    {
                        "username": "arindamsharma0123",
                        "content": "Make separate function to count char in the string and return it in int type. It will give you O(1) time complexity \\nint count(string num,int c){\\n        char ch;\\n        if(c == 0){\\n            ch = \\'0\\';\\n        }\\n        if(c == 1){\\n            ch = \\'1\\';\\n        }\\n        if(c == 2){\\n            ch = \\'2\\';\\n        }\\n        if(c == 3){\\n            ch = \\'3\\';\\n        }\\n        if(c == 4){\\n            ch = \\'4\\';\\n        }\\n        if(c == 5){\\n            ch = \\'5\\';\\n        }\\n        if(c == 6){\\n            ch = \\'6\\';\\n        }\\n        if(c == 7){\\n            ch = \\'7\\';\\n        }\\n        if(c == 8){\\n            ch = \\'8\\';\\n        }\\n        if(c == 9){\\n            ch = \\'9\\';\\n        }\\n        int ans = 0;\\n        for(int i = 0; num[i] != \\'\\\\0\\'; i++){\\n            if(num[i] == ch){\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }."
                    },
                    {
                        "username": "Amit17491",
                        "content": " I am facing issue while solve this question.\n\nnum = '0'\ni am printing my ans = 'false'\noutput = true\nexpected = false"
                    }
                ]
            }
        ]
    },
    {
        "title": "Successful Pairs of Spells and Potions",
        "question_content": "<p>You are given two positive integer arrays <code>spells</code> and <code>potions</code>, of length <code>n</code> and <code>m</code> respectively, where <code>spells[i]</code> represents the strength of the <code>i<sup>th</sup></code> spell and <code>potions[j]</code> represents the strength of the <code>j<sup>th</sup></code> potion.</p>\n\n<p>You are also given an integer <code>success</code>. A spell and potion pair is considered <strong>successful</strong> if the <strong>product</strong> of their strengths is <strong>at least</strong> <code>success</code>.</p>\n\n<p>Return <em>an integer array </em><code>pairs</code><em> of length </em><code>n</code><em> where </em><code>pairs[i]</code><em> is the number of <strong>potions</strong> that will form a successful pair with the </em><code>i<sup>th</sup></code><em> spell.</em></p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> spells = [5,1,3], potions = [1,2,3,4,5], success = 7\n<strong>Output:</strong> [4,0,3]\n<strong>Explanation:</strong>\n- 0<sup>th</sup> spell: 5 * [1,2,3,4,5] = [5,<u><strong>10</strong></u>,<u><strong>15</strong></u>,<u><strong>20</strong></u>,<u><strong>25</strong></u>]. 4 pairs are successful.\n- 1<sup>st</sup> spell: 1 * [1,2,3,4,5] = [1,2,3,4,5]. 0 pairs are successful.\n- 2<sup>nd</sup> spell: 3 * [1,2,3,4,5] = [3,6,<u><strong>9</strong></u>,<u><strong>12</strong></u>,<u><strong>15</strong></u>]. 3 pairs are successful.\nThus, [4,0,3] is returned.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> spells = [3,1,2], potions = [8,5,8], success = 16\n<strong>Output:</strong> [2,0,2]\n<strong>Explanation:</strong>\n- 0<sup>th</sup> spell: 3 * [8,5,8] = [<u><strong>24</strong></u>,15,<u><strong>24</strong></u>]. 2 pairs are successful.\n- 1<sup>st</sup> spell: 1 * [8,5,8] = [8,5,8]. 0 pairs are successful. \n- 2<sup>nd</sup> spell: 2 * [8,5,8] = [<strong><u>16</u></strong>,10,<u><strong>16</strong></u>]. 2 pairs are successful. \nThus, [2,0,2] is returned.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == spells.length</code></li>\n\t<li><code>m == potions.length</code></li>\n\t<li><code>1 &lt;= n, m &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= spells[i], potions[i] &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= success &lt;= 10<sup>10</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 3367914,
                "title": "easy-solutions-in-java-python-and-c-look-at-once-with-exaplanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFor each spell, we need to find the number of potions that can form a successful pair with it. A pair is successful if the product of their strengths is at least the given success value. To find the number of successful pairs for each spell, we can iterate through the potions array and check if the product of the spell strength and the potion strength is greater than or equal to the success value. If it is, we can increment a counter for that spell. We can then return the counters as an array.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. We start by initializing the output array `pairs` with all zeros, and sorting the `potions` array in ascending order.\\n \\n2. For each `spell` in `spells`, we perform a binary search on the `potions` array to find the number of `potions` that form a successful pair with the current `spell`. We maintain two pointers `left` and `right` that initially point to the first and last indices\\nof the `potions` array, respectively.\\n\\n3. We repeat the binary search until the `left` and `right` pointers meet or cross each other. In each iteration, we compute the product of the current `spell` and the middle `potion` using long integer multiplication to avoid integer overflow. If the product is greater than or equal to the `success` threshold, we move the `right` pointer to the left of the middle index. Otherwise, we move the `left` pointer to the right of the middle index.\\n\\n4. Once the binary search is complete, we set the corresponding element of `pairs` to the number of `potions` that come after the `left` pointer in the sorted `potions` array, which are guaranteed to form a successful pair with the current `spell`.\\n\\n5. Finally, we return the `pairs` array as the result.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of this solution is $$O(n log m)$$, where n is the length of `spells` and m is the length of `potions`, due to the binary search. The space complexity is O(1).\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity is $$O(1)$$, since we only use a constant amount of extra memory to store the `pairs` array and the binary search pointers.\\n\\n\\n![image.png](https://assets.leetcode.com/users/images/b427e686-2e5d-469a-8e7a-db5140022a6b_1677715904.0948765.png)\\n\\n\\n# Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\nPlease give my solution an upvote! \\uD83D\\uDC4D\\nIt\\'s a simple way to show your appreciation and\\nkeep me motivated. Thank you! \\uD83D\\uDE0A\\n```\\n\\n# Code\\n``` Java []\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        int n = spells.length;\\n        int m = potions.length;\\n        int[] pairs = new int[n];\\n        Arrays.sort(potions);\\n        for (int i = 0; i < n; i++) {\\n            int spell = spells[i];\\n            int left = 0;\\n            int right = m - 1;\\n            while (left <= right) {\\n                int mid = left + (right - left) / 2;\\n                long product = (long) spell * potions[mid];\\n                if (product >= success) {\\n                    right = mid - 1;\\n                } else {\\n                    left = mid + 1;\\n                }\\n            }\\n            pairs[i] = m - left;\\n        }\\n        return pairs;\\n    }\\n}\\n\\n```\\n``` Python []\\nclass Solution(object):\\n    def successfulPairs(self, spells, potions, success):\\n        n = len(spells)\\n        m = len(potions)\\n        pairs = [0] * n\\n        potions.sort()\\n        for i in range(n):\\n            spell = spells[i]\\n            left = 0\\n            right = m - 1\\n            while left <= right:\\n                mid = left + (right - left) // 2\\n                product = spell * potions[mid]\\n                if product >= success:\\n                    right = mid - 1\\n                else:\\n                    left = mid + 1\\n            pairs[i] = m - left\\n        return pairs\\n\\n```\\n``` C++ []\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        int n = spells.size();\\n        int m = potions.size();\\n        vector<int> pairs(n, 0);\\n        sort(potions.begin(), potions.end());\\n        for (int i = 0; i < n; i++) {\\n            int spell = spells[i];\\n            int left = 0;\\n            int right = m - 1;\\n            while (left <= right) {\\n                int mid = left + (right - left) / 2;\\n                long long product = (long long)spell * (long long)potions[mid];\\n                if (product >= success) {\\n                    right = mid - 1;\\n                } else {\\n                    left = mid + 1;\\n                }\\n            }\\n            pairs[i] = m - left;\\n        }\\n        return pairs;\\n    }\\n};\\n\\n```\\n# Please Comment\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\\nThanks for visiting my solution comment below if you like it.\\uD83D\\uDE0A\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\nPlease give my solution an upvote! \\uD83D\\uDC4D\\nIt\\'s a simple way to show your appreciation and\\nkeep me motivated. Thank you! \\uD83D\\uDE0A\\n```\n``` Java []\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        int n = spells.length;\\n        int m = potions.length;\\n        int[] pairs = new int[n];\\n        Arrays.sort(potions);\\n        for (int i = 0; i < n; i++) {\\n            int spell = spells[i];\\n            int left = 0;\\n            int right = m - 1;\\n            while (left <= right) {\\n                int mid = left + (right - left) / 2;\\n                long product = (long) spell * potions[mid];\\n                if (product >= success) {\\n                    right = mid - 1;\\n                } else {\\n                    left = mid + 1;\\n                }\\n            }\\n            pairs[i] = m - left;\\n        }\\n        return pairs;\\n    }\\n}\\n\\n```\n``` Python []\\nclass Solution(object):\\n    def successfulPairs(self, spells, potions, success):\\n        n = len(spells)\\n        m = len(potions)\\n        pairs = [0] * n\\n        potions.sort()\\n        for i in range(n):\\n            spell = spells[i]\\n            left = 0\\n            right = m - 1\\n            while left <= right:\\n                mid = left + (right - left) // 2\\n                product = spell * potions[mid]\\n                if product >= success:\\n                    right = mid - 1\\n                else:\\n                    left = mid + 1\\n            pairs[i] = m - left\\n        return pairs\\n\\n```\n``` C++ []\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        int n = spells.size();\\n        int m = potions.size();\\n        vector<int> pairs(n, 0);\\n        sort(potions.begin(), potions.end());\\n        for (int i = 0; i < n; i++) {\\n            int spell = spells[i];\\n            int left = 0;\\n            int right = m - 1;\\n            while (left <= right) {\\n                int mid = left + (right - left) / 2;\\n                long long product = (long long)spell * (long long)potions[mid];\\n                if (product >= success) {\\n                    right = mid - 1;\\n                } else {\\n                    left = mid + 1;\\n                }\\n            }\\n            pairs[i] = m - left;\\n        }\\n        return pairs;\\n    }\\n};\\n\\n```\n```\\nThanks for visiting my solution comment below if you like it.\\uD83D\\uDE0A\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2138875,
                "title": "javac-python-straignt-forward-with-explantion",
                "content": "# **Explanation**\\nFor each `spell`,\\nit needs ceil integer of `need = success * 1.0 / spell`.\\n\\nBinary search the `index` of first `potion >= need` in the sorted `potions`.\\nThe number of potions that are successful are `potions.length - index`\\n\\nAccumulate the result `res` and finally return it.\\n<br>\\n\\n# **Complexity**\\nTime `O(mlogm + nlogm)`\\nSpace `O(n)`\\n<br>\\n\\n**Java**\\n```java\\n\\tpublic int[] successfulPairs(int[] spells, int[] potions, long success) {\\n\\t\\tArrays.sort(potions);\\n\\t\\tTreeMap<Long, Integer> map = new TreeMap<>();\\n        map.put(Long.MAX_VALUE, potions.length);\\n\\t\\tfor (int i = potions.length - 1; i >= 0; i--) {\\n\\t\\t\\tmap.put((long) potions[i], i);\\n\\t\\t}\\n\\t\\tfor (int i = 0; i < spells.length; i++) {\\n            long need = (success + spells[i] - 1) / spells[i];\\n\\t\\t\\tspells[i] = potions.length - map.ceilingEntry(need).getValue();\\n\\t\\t}\\n\\t\\treturn spells;\\n\\t}\\n```\\n**C++**\\n```cpp\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        sort(potions.begin(), potions.end());\\n        vector<int> res;\\n        for (int a: spells) {\\n            long need = (success + a - 1) / a;\\n            auto it = lower_bound(potions.begin(), potions.end(), need);\\n            res.push_back(potions.end() - it);\\n        }\\n        return res;\\n    }\\n```\\n\\n**Python**\\n```py\\n    def successfulPairs(self, spells, potions, success):\\n        potions.sort()\\n        return [len(potions) - bisect_left(potions, (success + a - 1) // a) for a in spells]\\n```\\n<br>\\n\\n# Solution II: Two Sum\\nSort `spells`\\nSort `potions`\\nNow it\\'s basic two sum question, though it\\'s two mulplication.\\n\\nTime `O(nlogn + mlogm)`\\nSpace `O(n)`\\n\\n**Java**\\n```java\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        int[] spells0 = spells.clone();\\n        Arrays.sort(potions);\\n        Arrays.sort(spells);\\n        HashMap<Integer, Integer> count = new HashMap<>();\\n        int n = spells.length, m = potions.length, j = m - 1, res[] = new int[n];\\n        for (int i = 0; i < n; ++i) {\\n            while (j >= 0 && 1L * spells[i] * potions[j] >= success)\\n                j--;\\n            count.put(spells[i], m - j - 1);\\n        }\\n        for (int i = 0; i < n; ++i) {\\n            res[i] = count.get(spells0[i]);\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```java\\n\\tpublic int[] successfulPairs(int[] spells, int[] potions, long success) {\\n\\t\\tArrays.sort(potions);\\n\\t\\tTreeMap<Long, Integer> map = new TreeMap<>();\\n        map.put(Long.MAX_VALUE, potions.length);\\n\\t\\tfor (int i = potions.length - 1; i >= 0; i--) {\\n\\t\\t\\tmap.put((long) potions[i], i);\\n\\t\\t}\\n\\t\\tfor (int i = 0; i < spells.length; i++) {\\n            long need = (success + spells[i] - 1) / spells[i];\\n\\t\\t\\tspells[i] = potions.length - map.ceilingEntry(need).getValue();\\n\\t\\t}\\n\\t\\treturn spells;\\n\\t}\\n```\n```cpp\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        sort(potions.begin(), potions.end());\\n        vector<int> res;\\n        for (int a: spells) {\\n            long need = (success + a - 1) / a;\\n            auto it = lower_bound(potions.begin(), potions.end(), need);\\n            res.push_back(potions.end() - it);\\n        }\\n        return res;\\n    }\\n```\n```py\\n    def successfulPairs(self, spells, potions, success):\\n        potions.sort()\\n        return [len(potions) - bisect_left(potions, (success + a - 1) // a) for a in spells]\\n```\n```java\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        int[] spells0 = spells.clone();\\n        Arrays.sort(potions);\\n        Arrays.sort(spells);\\n        HashMap<Integer, Integer> count = new HashMap<>();\\n        int n = spells.length, m = potions.length, j = m - 1, res[] = new int[n];\\n        for (int i = 0; i < n; ++i) {\\n            while (j >= 0 && 1L * spells[i] * potions[j] >= success)\\n                j--;\\n            count.put(spells[i], m - j - 1);\\n        }\\n        for (int i = 0; i < n; ++i) {\\n            res[i] = count.get(spells0[i]);\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2139028,
                "title": "c-clean-easy",
                "content": "\\u2764 Please Upvote if you find helpful \\u2764\\n\\n**Explanation (Step by Step)**\\n\\n**Step 1.** \\nThe function starts by initializing the vector `v` with `zeros` and then `sorting` the vector `p` in `non-decreasing` order.\\n\\n**Step 2.** \\nFor each element `s[i]` in vector `s`, a `binary search` is performed on vector `p` to find the index of the `largest` element whose product with `s[i]` is `less than eqaul` to `suc`. The binary search is performed by maintaining two indices `l` and `h` representing the lower and upper bounds of the search range, respectively. The search continues until `l` is `less than equal` to `h`.\\n\\n**Step 3** \\nInside the loop, the middle index `mid` is computed as the average of `l` and `h`. If the product of `s[i]` and `p[mid]` is greater than or equal to suc, the upper bound `h` is adjusted to search the `left half` of the array, otherwise the lower bound `l` is adjusted to search the `right half` of the array.\\n\\n**Step 4**\\nAfter the binary search, the number of successful pairs for the element `s[i]` is calculated by `subtracting` the `index of the last element` found in the search from the `size of p`. This is because all elements in `p` starting from this index `satisfy` the condition for a successful pair.\\n\\n**Step 5**\\nFinally, the vector `v` is returned, containing the number of `successful pairs` for each element in `s`. \\n\\n**FAQ** : `Why binary search is used ?` \\n=> By using binary search, the code avoids the need to compare the current element in s with all elements in p, which would have a time complexity of $$O(n\\xB2)$$. Instead, the binary search algorithm efficiently reduces the search space by dividing it in half at each step, resulting in a much faster search time $$O(nlog(n))$$.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& s, vector<int>& p, long long suc) {\\n        \\n        vector<int> v(s.size(),0);\\n        sort(p.begin(),p.end());\\n        \\n        for(int i=0;i<s.size();i++)\\n        {\\n            int h=p.size()-1;\\n            int l=0;\\n            int mid;\\n            while(l<=h)\\n            {\\n                mid = l + (h-l)/2;\\n                \\n                if((long long int)s[i]*(long long int)p[mid] >= suc)\\n                    h = mid-1;\\n                \\n                else\\n                    l = mid+1;\\n            }\\n            \\n            v[i] = p.size()-1-h;\\n        }\\n        \\n        return v;\\n    }\\n};\\n```\\n![IMG_20230402_115743.jpg](https://assets.leetcode.com/users/images/4d144a01-19ce-4def-8200-2c2ca9987f29_1680416869.6585193.jpeg)\\n  \\u2227,,,\\u2227\\n(  \\u0333\\u2022 \\xB7 \\u2022 \\u0333)\\n/    \\u3065\\u2661\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& s, vector<int>& p, long long suc) {\\n        \\n        vector<int> v(s.size(),0);\\n        sort(p.begin(),p.end());\\n        \\n        for(int i=0;i<s.size();i++)\\n        {\\n            int h=p.size()-1;\\n            int l=0;\\n            int mid;\\n            while(l<=h)\\n            {\\n                mid = l + (h-l)/2;\\n                \\n                if((long long int)s[i]*(long long int)p[mid] >= suc)\\n                    h = mid-1;\\n                \\n                else\\n                    l = mid+1;\\n            }\\n            \\n            v[i] = p.size()-1-h;\\n        }\\n        \\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3367922,
                "title": "image-explanation-binary-search-with-without-inbuild-libraries-c-java-python",
                "content": "# Video Solution (`Aryan Mittal`) - Link in LeetCode Profile\\n`Successful Pairs of Spells and Potions` by `Aryan Mittal`\\n![thumb.png](https://assets.leetcode.com/users/images/5857de7f-4a28-4d73-80e0-117e42178bf3_1680402420.5635715.png)\\n\\n# Approach & Intution\\n![image.png](https://assets.leetcode.com/users/images/99a332e2-1f9b-42b1-9f38-d328ba555a0d_1680397450.5684943.png)\\n![image.png](https://assets.leetcode.com/users/images/95fd5621-491c-49ec-b02a-b7fb09792299_1680397462.2408035.png)\\n![image.png](https://assets.leetcode.com/users/images/5db5d26c-ddce-4df1-8bac-d09eba7231fa_1680397482.1739225.png)\\n![image.png](https://assets.leetcode.com/users/images/e0c85a7d-6300-4e09-99bc-7501984344ef_1680397494.6180933.png)\\n![image.png](https://assets.leetcode.com/users/images/f420160f-7384-4baf-991b-44f7a5b79dfc_1680397503.9567719.png)\\n![image.png](https://assets.leetcode.com/users/images/fb798d7d-2669-44d6-ac56-3af7fc5eec20_1680397511.739848.png)\\n![image.png](https://assets.leetcode.com/users/images/55723900-7dea-43b9-bbf5-8a183d663fd7_1680397521.3559468.png)\\n![image.png](https://assets.leetcode.com/users/images/39a8bc71-7920-4397-a37a-c6fa82d3b416_1680398553.798697.png)\\n\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        sort(potions.begin(), potions.end());\\n        vector<int> res;\\n        for (int spell: spells) {\\n            long potion_needed = (success + spell - 1) / spell;\\n            auto it = lower_bound(potions.begin(), potions.end(), potion_needed);\\n            res.push_back(potions.end() - it);\\n        }\\n        return res;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n\\t\\tArrays.sort(potions);\\n\\t\\tTreeMap<Long, Integer> map = new TreeMap<>();\\n        map.put(Long.MAX_VALUE, potions.length);\\n        \\n\\t\\tfor (int i = potions.length - 1; i >= 0; i--) {\\n\\t\\t\\tmap.put((long) potions[i], i);\\n\\t\\t}\\n\\t\\tfor (int i = 0; i < spells.length; i++) {\\n            long need = (success + spells[i] - 1) / spells[i];\\n\\t\\t\\tspells[i] = potions.length - map.ceilingEntry(need).getValue();\\n\\t\\t}\\n\\t\\treturn spells;\\n\\t}\\n}\\n```\\n```Python []\\nclass Solution:\\n    def successfulPairs(self, spells, potions, success):\\n        sorted_potions = sorted(potions)\\n        result = []\\n        for a in spells:\\n            count = len(sorted_potions) - bisect_left(sorted_potions, (success + a - 1) // a)\\n            result.append(count)\\n        return result\\n```\\n\\n\\n# Code Without Inbuild Libraries\\nExact same [Generalized Binary Search code](https://leetcode.com/problems/binary-search/solutions/3363888/image-explanation-most-generalized-binary-search-cjavapython/) discussed for C++/Java/Python.\\n```C++ []\\nclass Solution {\\npublic:\\n    int valid_pos(vector<int>& potions, long long success, int spell){\\n        long potion_needed = (success + spell - 1) / spell;\\n\\n        int l=0,r=potions.size();\\n        while(l<r){\\n            int mid = l + (r-l)/2;\\n            if(potions[mid] >= potion_needed)\\n                r = mid;\\n            else\\n                l = mid + 1;\\n        }\\n        return l;\\n    }\\n\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        sort(potions.begin(), potions.end());\\n        vector<int> res;\\n        for (int spell: spells) {\\n            res.push_back(potions.size()- valid_pos(potions, success, spell));\\n        }\\n        return res;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public int valid_pos(int[] potions, long success, int spell) {\\n        long potion_needed = (success + spell - 1) / spell;\\n        int l = 0, r = potions.length;\\n        while (l < r) {\\n            int mid = l + (r - l) / 2;\\n            if (potions[mid] >= potion_needed)\\n                r = mid;\\n            else\\n                l = mid + 1;\\n        }\\n        return l;\\n    }\\n\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        Arrays.sort(potions);\\n        int[] res = new int[spells.length];\\n        for (int i = 0; i < spells.length; i++) {\\n            res[i] = potions.length - valid_pos(potions, success, spells[i]);\\n        }\\n        return res;\\n    }\\n}\\n```\\n```Python []\\nclass Solution:\\n    def valid_pos(self, potions: List[int], success: int, spell: int) -> int:\\n        potion_needed = (success + spell - 1) // spell\\n        l, r = 0, len(potions)\\n        while l < r:\\n            mid = l + (r - l) // 2\\n            if potions[mid] >= potion_needed:\\n                r = mid\\n            else:\\n                l = mid + 1\\n        return l\\n\\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\\n        potions.sort()\\n        res = []\\n        for spell in spells:\\n            res.append(len(potions) - self.valid_pos(potions, success, spell))\\n        return res\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Binary Search"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        sort(potions.begin(), potions.end());\\n        vector<int> res;\\n        for (int spell: spells) {\\n            long potion_needed = (success + spell - 1) / spell;\\n            auto it = lower_bound(potions.begin(), potions.end(), potion_needed);\\n            res.push_back(potions.end() - it);\\n        }\\n        return res;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n\\t\\tArrays.sort(potions);\\n\\t\\tTreeMap<Long, Integer> map = new TreeMap<>();\\n        map.put(Long.MAX_VALUE, potions.length);\\n        \\n\\t\\tfor (int i = potions.length - 1; i >= 0; i--) {\\n\\t\\t\\tmap.put((long) potions[i], i);\\n\\t\\t}\\n\\t\\tfor (int i = 0; i < spells.length; i++) {\\n            long need = (success + spells[i] - 1) / spells[i];\\n\\t\\t\\tspells[i] = potions.length - map.ceilingEntry(need).getValue();\\n\\t\\t}\\n\\t\\treturn spells;\\n\\t}\\n}\\n```\n```Python []\\nclass Solution:\\n    def successfulPairs(self, spells, potions, success):\\n        sorted_potions = sorted(potions)\\n        result = []\\n        for a in spells:\\n            count = len(sorted_potions) - bisect_left(sorted_potions, (success + a - 1) // a)\\n            result.append(count)\\n        return result\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int valid_pos(vector<int>& potions, long long success, int spell){\\n        long potion_needed = (success + spell - 1) / spell;\\n\\n        int l=0,r=potions.size();\\n        while(l<r){\\n            int mid = l + (r-l)/2;\\n            if(potions[mid] >= potion_needed)\\n                r = mid;\\n            else\\n                l = mid + 1;\\n        }\\n        return l;\\n    }\\n\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        sort(potions.begin(), potions.end());\\n        vector<int> res;\\n        for (int spell: spells) {\\n            res.push_back(potions.size()- valid_pos(potions, success, spell));\\n        }\\n        return res;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public int valid_pos(int[] potions, long success, int spell) {\\n        long potion_needed = (success + spell - 1) / spell;\\n        int l = 0, r = potions.length;\\n        while (l < r) {\\n            int mid = l + (r - l) / 2;\\n            if (potions[mid] >= potion_needed)\\n                r = mid;\\n            else\\n                l = mid + 1;\\n        }\\n        return l;\\n    }\\n\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        Arrays.sort(potions);\\n        int[] res = new int[spells.length];\\n        for (int i = 0; i < spells.length; i++) {\\n            res[i] = potions.length - valid_pos(potions, success, spells[i]);\\n        }\\n        return res;\\n    }\\n}\\n```\n```Python []\\nclass Solution:\\n    def valid_pos(self, potions: List[int], success: int, spell: int) -> int:\\n        potion_needed = (success + spell - 1) // spell\\n        l, r = 0, len(potions)\\n        while l < r:\\n            mid = l + (r - l) // 2\\n            if potions[mid] >= potion_needed:\\n                r = mid\\n            else:\\n                l = mid + 1\\n        return l\\n\\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\\n        potions.sort()\\n        res = []\\n        for spell in spells:\\n            res.append(len(potions) - self.valid_pos(potions, success, spell))\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3367934,
                "title": "why-and-how-binary-search-intuition-explained",
                "content": "![image](https://assets.leetcode.com/users/images/4bde32d2-e235-415d-8602-368016c3acdb_1680397806.4855666.png)\\n![image](https://assets.leetcode.com/users/images/32b4d538-b79a-414b-b799-5195c4622a93_1680398342.075346.png)\\n\\n```\\nclass Solution {\\npublic:\\n    int getPairCount(vector<int>& potions, int& spell, long long& target)\\n    {\\n        int n = potions.size(), bestIdx = n;\\n        int low = 0, high = n - 1;\\n        //=============================================================\\n        while(low <= high)\\n        {\\n            int mid = low + (high - low) / 2;\\n            long long product = (long long)spell * potions[mid];\\n            \\n            if (product >= target)\\n            {\\n                bestIdx = mid;\\n                high = mid - 1;\\n            }\\n            else low = mid + 1;\\n        }\\n        //================================================================\\n        return (n - bestIdx);\\n    }\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success)\\n    {\\n        int n = spells.size();\\n        vector<int>ans(n);\\n        sort(potions.begin(), potions.end());\\n        for (int i = 0; i < n; i++) \\n            ans[i] = getPairCount(potions, spells[i], success);\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getPairCount(vector<int>& potions, int& spell, long long& target)\\n    {\\n        int n = potions.size(), bestIdx = n;\\n        int low = 0, high = n - 1;\\n        //=============================================================\\n        while(low <= high)\\n        {\\n            int mid = low + (high - low) / 2;\\n            long long product = (long long)spell * potions[mid];\\n            \\n            if (product >= target)\\n            {\\n                bestIdx = mid;\\n                high = mid - 1;\\n            }\\n            else low = mid + 1;\\n        }\\n        //================================================================\\n        return (n - bestIdx);\\n    }\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success)\\n    {\\n        int n = spells.size();\\n        vector<int>ans(n);\\n        sort(potions.begin(), potions.end());\\n        for (int i = 0; i < n; i++) \\n            ans[i] = getPairCount(potions, spells[i], success);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3368203,
                "title": "java-easy-solution-with-detailed-explaination-and-similar-problems-binary-search",
                "content": "# Intuition\\nQuestion reduces to finding no of potions for each spell which have \\n***product greater than success*** where product is (each spell * potions[i])\\n\\nNow decision is whether to keep the potions array sorted or not.\\n\\n- ***NON-SORTED*** Another is to traverse entire array of potions and count no of products(spell * potions[i]) greater than success. But this will take more time as for each spell we will need to traverse entire potions array.\\n\\n- ***SORTED*** Immediate thought to reduce time complexity of above case is to keep potions array sorted, then question reduces to finding the first occurrence of the product( each spell * potions[i]) which is greater than success, so we go with ***Binary search***\\n\\n---\\n\\n\\n# Approach\\n1) Sort potions array.\\n2) For every spell we will find min Index where the product( spell * potion[i]) is greater than success\\n3) Once we find such an index via binary search anser for that spell is \\npotions.length - minIndex\\n4) It is ***important*** how we choose left and right pointers of binary search\\n5) I intialised with left = 0, *right = potion.length and not potion.length-1*, since we can have a case where we donot find any minIndex in that case the minIndex will be potion.length and hence result[i] of such spell[i] = potion.length -minIndex = 0\\n\\n**Similar question[ LC 35 Search and Insert](https://leetcode.com/problems/search-insert-position/) to make you understand point 5 better and how to choose boundaries wisely depending on the question type.**\\n\\n***Generic binary search [understanding](https://leetcode.com/problems/binary-search/solutions/3364223/java-easy-solution-explained-why-leftright-left2-instead-of-leftright2/)***\\n\\n\\n---\\n- Time Complexity\\nO(nlogm): where m is the length of potions array and n of spells array\\n\\n***NOTE***: Reason why 1l is done in ***long product = (1l * spell) * potions[mid];*** because (spell * potions[i]) both being integer will overflow and will result in wrong product value. \\nI wasted a lot of time in this.\\n\\n---\\n\\nHope it is easy to understand.\\nLet me know if there is something unclear and i can fix it.\\n\\nOtherwise, please upvote if you like the solution, it would be encouraging\\n\\n![LCUpvote.png](https://assets.leetcode.com/users/images/0cb8949f-630b-4e16-b2c8-2f4e7d2007fb_1680404247.5368462.png)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        int [] result = new int[spells.length];\\n        int potionsLength = potions.length;\\n        Arrays.sort(potions);\\n\\n        for(int i=0; i<spells.length; i++){\\n            int minIndex = binarySearch(potions, success, spells[i]);\\n            result[i] = potionsLength - minIndex;\\n        }\\n        return result;\\n    }\\n\\n    private int binarySearch(int [] potions, long success, int spell){\\n        int left= 0;\\n        int right= potions.length;\\n        \\n        while(left<right){\\n            int mid = left + (right-left)/2;\\n            long product = (1l * spell) * potions[mid];\\n            if(product<success){\\n                left=mid+1;\\n            }else{\\n                right=mid;\\n            }\\n        }\\n\\n        return left;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        int [] result = new int[spells.length];\\n        int potionsLength = potions.length;\\n        Arrays.sort(potions);\\n\\n        for(int i=0; i<spells.length; i++){\\n            int minIndex = binarySearch(potions, success, spells[i]);\\n            result[i] = potionsLength - minIndex;\\n        }\\n        return result;\\n    }\\n\\n    private int binarySearch(int [] potions, long success, int spell){\\n        int left= 0;\\n        int right= potions.length;\\n        \\n        while(left<right){\\n            int mid = left + (right-left)/2;\\n            long product = (1l * spell) * potions[mid];\\n            if(product<success){\\n                left=mid+1;\\n            }else{\\n                right=mid;\\n            }\\n        }\\n\\n        return left;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3368209,
                "title": "prefix-postfix-sum-c-99-faster-in-time",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem asks us to find out the number of potion values that has product with a specific spell value which is greater than (or equal to) a threshold.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSince we have to find the amount of values that is greater than a value, the easiest way is to sort the whole array, then do binary search to find out the position that has the smallest element that satisfy the problem. However, since this approach takes `O(nlogn)` times, which might not be the best idea (in my opinion), for the input with size of 10^5, so I got another idea.\\n\\nMy idea was, couting occurences of all numbers, then add from the end, using postfix sum, so that, `postfix[n]` is the number of numbers that has value greater than or equal to value `n` in `potions`. Then, that would take `O(1)`, instead of `O(log n)` for each time do searching for each spell, and `O(n)` for counting, instead of `O(nlogn)` do sorting.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        int postfix[100001] = {0};\\n        for(auto potion: potions) postfix[potion]++;\\n        for(int i=99999; i>=0; --i) postfix[i] += postfix[i+1];\\n\\n        //No need extra space at all for storing final result\\n        for(int i=0; i<spells.size(); ++i){\\n            long long val = success / (long long) spells[i];\\n            if(success % (long long) spells[i] != 0) val++;\\n\\n            spells[i] = val <= 1e5 ? postfix[val] : 0;\\n        }\\n        return spells;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        int postfix[100001] = {0};\\n        for(auto potion: potions) postfix[potion]++;\\n        for(int i=99999; i>=0; --i) postfix[i] += postfix[i+1];\\n\\n        //No need extra space at all for storing final result\\n        for(int i=0; i<spells.size(); ++i){\\n            long long val = success / (long long) spells[i];\\n            if(success % (long long) spells[i] != 0) val++;\\n\\n            spells[i] = val <= 1e5 ? postfix[val] : 0;\\n        }\\n        return spells;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2138867,
                "title": "binary-search",
                "content": "\\n***If ith potion is successful then all the potions after will be successful.\\n    So find the first potion which is successful using Binary Search.***\\n```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        \\n        vector<int> res;\\n        int n(size(potions));\\n        sort(begin(potions), end(potions));\\n        \\n        for (auto& spell : spells) {\\n            int start(0), end(n);\\n            while (start < end) {\\n                int mid = start + (end-start)/2;\\n                ((long long)spell*potions[mid] >= success) ? end = mid : start = mid+1;\\n            }\\n            res.push_back(n-start);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        \\n        vector<int> res;\\n        int n(size(potions));\\n        sort(begin(potions), end(potions));\\n        \\n        for (auto& spell : spells) {\\n            int start(0), end(n);\\n            while (start < end) {\\n                int mid = start + (end-start)/2;\\n                ((long long)spell*potions[mid] >= success) ? end = mid : start = mid+1;\\n            }\\n            res.push_back(n-start);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3370925,
                "title": "python-simple-solution-easy-to-understand",
                "content": "# Please UPVOTE \\uD83D\\uDC4D\\n\\n**!! BIG ANNOUNCEMENT !!**\\nI am currently Giving away my premium content well-structured assignments and study materials to clear interviews at top companies related to computer science and data science to my current Subscribers this week. I planned to give for next 10,000 Subscribers as well. So **DON\\'T FORGET** to Subscribe\\n\\n**Search \\uD83D\\uDC49`Tech Wired leetcode` on YouTube to Subscribe**\\n# OR \\n**Click the Link in my Leetcode Profile to Subscribe**\\n\\n# Video Solution\\n**Search \\uD83D\\uDC49 `Successful Pairs of Spells and Potions by Tech Wired` on YouTube**\\n\\n![Yellow & Black Earn Money YouTube Thumbnail (7).png](https://assets.leetcode.com/users/images/a66c9634-0226-498d-b8b9-b69647afc108_1680441461.1699626.png)\\n\\n\\nHappy Learning, Cheers Guys \\uD83D\\uDE0A\\n\\n# Approach:\\n\\nThe approach for solving the problem is fairly straightforward. We start by sorting the potions list in non-decreasing order. Next, we loop through each spell strength a in the spells list. For each spell, we calculate the minimum strength required for a successful pair by using the formula (success + a - 1) // a. This formula ensures that the result is rounded up to the nearest integer. Once we have the minimum strength required, we use the bisect_left function to find the index of the first potion in the sorted potions list that has strength greater than or equal to the minimum strength required for a successful pair. Finally, we subtract this index from the length of potions to get the number of potions that can form a successful pair for the given spell strength. We repeat this process for each spell strength and store the counts in the result list. Finally, we return the result list.\\n\\n# Intuition:\\n\\nThe problem requires us to find the number of successful pairs of spells and potions. The key to finding a successful pair is to ensure that the strength of the potion is greater than or equal to the minimum strength required for a successful pair for the given spell strength. This minimum strength is calculated by using the formula (success + a - 1) // a, which ensures that the result is rounded up to the nearest integer. Sorting the potions list in non-decreasing order makes it easier to find the right potion for each spell. We use the bisect_left function to find the index of the first potion in the sorted potions list that has strength greater than or equal to the minimum strength required for a successful pair. The difference between the length of potions and this index gives the number of potions that can form a successful pair for the given spell strength. We repeat this process for each spell strength, and the counts are stored in the result list.\\n\\n```\\nclass Solution:\\n    def successfulPairs(self, spells, potions, success):\\n        sorted_potions = sorted(potions)\\n        result = []\\n        for a in spells:\\n            count = len(sorted_potions) - bisect_left(sorted_potions, (success + a - 1) // a)\\n            result.append(count)\\n        return result\\n\\n\\n```\\n![image.png](https://assets.leetcode.com/users/images/e2515d84-99cf-4499-80fb-fe458e1bbae2_1678932606.8004954.png)\\n\\n# Please UPVOTE \\uD83D\\uDC4D",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution:\\n    def successfulPairs(self, spells, potions, success):\\n        sorted_potions = sorted(potions)\\n        result = []\\n        for a in spells:\\n            count = len(sorted_potions) - bisect_left(sorted_potions, (success + a - 1) // a)\\n            result.append(count)\\n        return result\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2138921,
                "title": "java-python-3-sort-and-binary-search-w-brief-explanation-and-analysis",
                "content": "**Q & A**\\n\\nQ1: Why and how do we need to compute the factor?\\nA1: \\n1) We need a factor from `potions` to multiply with current `spells[i]` in order to get a product at least `success`. Therefore, computing before hand will obtain a key (the factor) for binary search.\\n2) `(success + s) // s = success / s + 1`, which is not ceiling of `success / s`; In contrast, `success / s <= (success + s - 1) // s < success / s + 1`, and therefore `(success + s - 1) // s` is the ceiling. \\n\\nQ2: Why in Python 3 code do we need to compute the ceiling `(success + s - 1) // s`, not `success / s`?\\nA2: For this problem we can use either. ~~~However, if `potions` is a float array then the ceiling way is a must. `success / s` is a float, which has a limited precision. In extreme case it may cause error; Use the ceiling, an int, will guarantee the correctness of the code.~~~\\n\\n~~~e.g., `success = 10, s = 3`, `potions[i] = 3.3333333333...33` (there are `k + 1` 3\\'s) is in `potions`.~~~\\n\\n~~~If we use float `factor = success / s = 10 / 3 = 3.3333333333...3` (there are `k` 3\\'s), then we will miss the correct `potions[i]` in binary search;~~~\\n~~~In contrast, `(success + s - 1) // s = (10 + 3 - 1) // 3 = 4` will guarantee to obtain correct result.~~~\\n\\n**End of Q & A**\\n\\n----\\n\\n1. Sort `potions` for binary search;\\n2. Traverse `spells`, for each element `s`, compute the ceiling of the quotient of `success / s`, `(success + s - 1) / s`;\\n3. Binary search the corresponding ceiling of each quotient in 2. to find out how many pairs with a product at least `success`.\\n\\n```java\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        Arrays.sort(potions);\\n        int[] pairs = new int[spells.length];\\n        for (int i = 0; i < spells.length; ++i) {\\n            if ((success + spells[i] - 1) / spells[i] > 100_000) { // boundary check to avoid int overflow.\\n                int s = spells[i], factor = (int)((success + s - 1) / s);\\n                pairs[i] = potions.length - binarySearch(potions, factor);\\n            } \\n        }\\n        return pairs;\\n    }\\n    private int binarySearch(int[] potions, int key) {\\n        int lo = 0, hi = potions.length; \\n        while (lo < hi) {\\n            int mid = lo + (hi - lo) / 2;\\n            if (potions[mid] < key) {\\n                lo = mid + 1;\\n            }else {\\n                hi = mid;\\n            } \\n        }\\n        return lo;\\n    }\\n```\\nWe can modify signature of `binarySearch(int[], int)` to `binarySearch(int[], long)` to avoid int overflow problem.\\n```java\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        Arrays.sort(potions);\\n        int[] pairs = new int[spells.length];\\n        for (int i = 0; i < spells.length; ++i) {\\n            long factor = (success + spells[i] - 1) / spells[i];\\n            pairs[i] = potions.length - binarySearch(potions, factor);\\n        }\\n        return pairs;\\n    }\\n    private int binarySearch(int[] potions, long key) {\\n        int lo = 0, hi = potions.length; \\n        while (lo < hi) {\\n            int mid = lo + (hi - lo) / 2;\\n            if (potions[mid] < key) {\\n                lo = mid + 1;\\n            }else {\\n                hi = mid;\\n            } \\n        }\\n        return lo;\\n    }\\n```\\n\\n```python\\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\\n        potions.sort()\\n        pairs = []\\n        for s in spells:\\n            factor = (success + s - 1) // s\\n            pairs.append(len(potions) - bisect.bisect_left(potions, factor))\\n        return pairs\\n```\\n\\nFor Python 3 code, we can use `success / s` as key for binary search:\\n\\n```python\\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\\n        potions.sort()\\n        return [len(potions) - bisect.bisect_left(potions, success / s) for s in spells]\\n```\\n\\n**Analysis:**\\n\\nTime: `O((m + n)logm)`, space: `O(n + m)` - including sorting space, where `n = spells.length, m = potions.length`.",
                "solutionTags": [
                    "Java",
                    "Python3",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```java\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        Arrays.sort(potions);\\n        int[] pairs = new int[spells.length];\\n        for (int i = 0; i < spells.length; ++i) {\\n            if ((success + spells[i] - 1) / spells[i] > 100_000) { // boundary check to avoid int overflow.\\n                int s = spells[i], factor = (int)((success + s - 1) / s);\\n                pairs[i] = potions.length - binarySearch(potions, factor);\\n            } \\n        }\\n        return pairs;\\n    }\\n    private int binarySearch(int[] potions, int key) {\\n        int lo = 0, hi = potions.length; \\n        while (lo < hi) {\\n            int mid = lo + (hi - lo) / 2;\\n            if (potions[mid] < key) {\\n                lo = mid + 1;\\n            }else {\\n                hi = mid;\\n            } \\n        }\\n        return lo;\\n    }\\n```\n```java\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        Arrays.sort(potions);\\n        int[] pairs = new int[spells.length];\\n        for (int i = 0; i < spells.length; ++i) {\\n            long factor = (success + spells[i] - 1) / spells[i];\\n            pairs[i] = potions.length - binarySearch(potions, factor);\\n        }\\n        return pairs;\\n    }\\n    private int binarySearch(int[] potions, long key) {\\n        int lo = 0, hi = potions.length; \\n        while (lo < hi) {\\n            int mid = lo + (hi - lo) / 2;\\n            if (potions[mid] < key) {\\n                lo = mid + 1;\\n            }else {\\n                hi = mid;\\n            } \\n        }\\n        return lo;\\n    }\\n```\n```python\\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\\n        potions.sort()\\n        pairs = []\\n        for s in spells:\\n            factor = (success + s - 1) // s\\n            pairs.append(len(potions) - bisect.bisect_left(potions, factor))\\n        return pairs\\n```\n```python\\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\\n        potions.sort()\\n        return [len(potions) - bisect.bisect_left(potions, success / s) for s in spells]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2139342,
                "title": "binary-search-vs-two-pointers",
                "content": "In the first approach, we sort `potions`, and use binary search to find the position of the weakest potion that produces a success. All potions to the right would work also.\\n\\nIn the second approach, we sort both `potions` and `spells` (we actually sort indexes `idx` to preserve the order of spells). Then, we use two pointers to track the weakest  `potions[j]` that works for `spells[i]`. Since we process spells from weakest to the strongest, pointer `j` is moved in one direction - from strongest to weakest.\\n\\n#### Binary Search\\n**C++**\\n```cpp\\nvector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n    sort(begin(potions), end(potions));\\n    for (int i = 0; i < spells.size(); ++i) {\\n        long long comp = (success + spells[i] - 1) / spells[i];\\n        spells[i] = potions.size() - (lower_bound(begin(potions), end(potions), comp) - begin(potions));\\n    }\\n    return spells;\\n}\\n```\\n#### Two Pointers\\n**C++**\\n```cpp\\nvector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n    vector<int> idx(spells.size());\\n    iota(begin(idx), end(idx), 0);\\n    sort(begin(potions), end(potions), greater<int>());\\n    sort(begin(idx), end(idx), [&](int i, int j){ return spells[i] < spells[j]; });\\n    for (int i = 0, j = 0; i < idx.size(); ++i) {\\n        while (j < potions.size() && (long long)potions[j] * spells[idx[i]] >= success)\\n            ++j;\\n        spells[idx[i]] = j;\\n    }\\n    return spells;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nvector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n    sort(begin(potions), end(potions));\\n    for (int i = 0; i < spells.size(); ++i) {\\n        long long comp = (success + spells[i] - 1) / spells[i];\\n        spells[i] = potions.size() - (lower_bound(begin(potions), end(potions), comp) - begin(potions));\\n    }\\n    return spells;\\n}\\n```\n```cpp\\nvector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n    vector<int> idx(spells.size());\\n    iota(begin(idx), end(idx), 0);\\n    sort(begin(potions), end(potions), greater<int>());\\n    sort(begin(idx), end(idx), [&](int i, int j){ return spells[i] < spells[j]; });\\n    for (int i = 0, j = 0; i < idx.size(); ++i) {\\n        while (j < potions.size() && (long long)potions[j] * spells[idx[i]] >= success)\\n            ++j;\\n        spells[idx[i]] = j;\\n    }\\n    return spells;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3369048,
                "title": "java-sorting-binary-search-approach",
                "content": "```\\n// Approach 2: Sorting  + Binary Search (Lower Bound)\\n\\n// Time complexity: O((m + n) log m)\\n// Space complexity: O(log m)\\n\\npublic int[] successfulPairs(int[] spells, int[] potions, long success) {\\n\\tint n = spells.length;\\n\\tint m = potions.length;\\n\\tint[] pairs = new int[n];\\n\\n\\tArrays.sort(potions); // m log m\\n\\n\\tfor (int i = 0; i < n; i++) { // n log m\\n\\t\\tint left = 0, right = m;\\n\\n\\t\\twhile (left < right) {\\n\\t\\t\\tint mid = left + (right - left) / 2;\\n\\n\\t\\t\\tif ((long) spells[i] * (long) potions[mid] >= success)\\n\\t\\t\\t\\tright = mid;\\n\\t\\t\\telse\\n\\t\\t\\t\\tleft = mid + 1;\\n\\t\\t}\\n\\n\\t\\tpairs[i] = m - left;\\n\\t}\\n\\n\\treturn pairs;\\n}\\n```\\n\\n**Please upvote if you find this solution useful. Happy Coding!**",
                "solutionTags": [
                    "Java",
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "```\\n// Approach 2: Sorting  + Binary Search (Lower Bound)\\n\\n// Time complexity: O((m + n) log m)\\n// Space complexity: O(log m)\\n\\npublic int[] successfulPairs(int[] spells, int[] potions, long success) {\\n\\tint n = spells.length;\\n\\tint m = potions.length;\\n\\tint[] pairs = new int[n];\\n\\n\\tArrays.sort(potions); // m log m\\n\\n\\tfor (int i = 0; i < n; i++) { // n log m\\n\\t\\tint left = 0, right = m;\\n\\n\\t\\twhile (left < right) {\\n\\t\\t\\tint mid = left + (right - left) / 2;\\n\\n\\t\\t\\tif ((long) spells[i] * (long) potions[mid] >= success)\\n\\t\\t\\t\\tright = mid;\\n\\t\\t\\telse\\n\\t\\t\\t\\tleft = mid + 1;\\n\\t\\t}\\n\\n\\t\\tpairs[i] = m - left;\\n\\t}\\n\\n\\treturn pairs;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3368113,
                "title": "c-beginner-friendly-explanation-brute-force-to-optimized-intuition",
                "content": "# Brute Force [Time Limit Exceeded]\\n\\n## Intuition\\nInitially, it sounds like we can just multiply each `spell` for each `potion`, but this is not fast enough.\\n\\n## Algorithm Design\\n- Loop for each `spell`\\n   - Loop for each `potion`\\n       - Increase count if the product is $$>=$$ `success`\\n\\n## Code\\n```cpp\\nclass Solution {\\npublic:\\n    // T:O(n*m), S:O(1)\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        vector<int> numPairs(spells.size(), 0);\\n\\n        // Loop through all spells\\n        for(int i = 0; i < spells.size(); i++) { // O(n)\\n            int spell = spells[i];\\n            int count = 0;\\n\\n            // Loop through all potions for each spell\\n            for(int potion: potions) { // O(m)\\n\\n                // Increment count if it exceeds success\\n                long long pair = (long long)potion * (long long)spell;\\n                if(pair >= success) count++;\\n            }\\n            numPairs[i] = count;\\n        }\\n\\n        return numPairs;\\n    }\\n};\\n```\\n\\n## Complexity\\nLet\\'s define `m` as the length of `spells` and `n` as the length of `potions`.\\n\\n- Time Complexity: $$O(n*m)$$\\n- Space Complexity: $$O(1)$$\\n  - The resulting array is not considered as space.\\n\\n# Binary Search [Accepted]\\n\\n## Intuition\\nTo reduce search time, we can almost always use binary search. However, the prequisite is sorting. Here, we only need to sort `potions` and find the minimum potion needed to be $$>=$$ `success`.\\n\\n## Algorithm Design\\n- Sort potions\\n- Loop for each `spell`\\n    - Find index of the minimum potion needed\\n    - Calculate the distance since every greater idx is $$>=$$ `success`\\n\\n## Code\\n```cpp\\nclass Solution {\\npublic:\\n    // T:O(m log m + n log m), S:O(log m)\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        vector<int> numPairs(spells.size(), 0);\\n\\n        // Sort potions\\n        sort(potions.begin(), potions.end()); // O(m log m)\\n\\n        // Loop through all spells\\n        for(int i = 0; i < spells.size(); i++) { // O(n)\\n            // Find the minimum potion needed for success\\n            long long potionNeeded = ceil(static_cast<double>(success) / spells[i]);\\n\\n            // Find the smallest idx position\\n            auto it = lower_bound(potions.begin(), potions.end(), potionNeeded); // O(log m)\\n            int idx = it - potions.begin();\\n\\n            // Calculate count based on the index\\n            int numPair = potions.size() - (it - potions.begin());\\n            numPairs[i] = max(0, numPair);\\n        }\\n\\n        return numPairs;\\n    }\\n};\\n```\\n\\n## Complexity\\nLet\\'s define `m` as the length of `spells` and `n` as the length of `potions`.\\n\\n- Time Complexity: $$O((m + n)log m)$$\\n- Space Complexity: $$O(log m)$$\\n    - Sorting in C++ takes $$O(log m)$$ space.\\n    - The resulting array is not considered as space.\\n    \\n# Two Pointers [Accepted]\\n\\n## Intuition\\nSince a larger number will always be able to form products $$>=$$ `success` compared to a smaller number, we can use a greedy two pointer approach. \\n\\n#### For example:\\nspells: [1,2,3]\\npotions: [1,2]\\nsuccess: 4\\n\\nIf we take the leftmost `spell` (1) and multiply with rightmost `potion` (2), we get a product of 2. This means any potion of a smaller index will not be possible. If we are able to form a product $$>=$$ `success`, that means any greater `spell` number can form it too.\\n\\n## Algorithm Design\\n- Remember the index of `spells` since we will be sorting\\n- Sort `potions` and `spells`\\n- Initialize two pointers:\\n    - Leftmost of `spells`\\n    - Rightmost of `potions`\\n- While we can form product $$>=$$ `success`, we should decrement `potion` pointer. \\n\\n## Code\\n```cpp\\nclass Solution {\\npublic:\\n    // T:O(n log n + m log m), S:O(n + log m)\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        unordered_map<int, pair<int, int>> pairsMap; // {spells[i], {idx, numPair}}\\n\\n        // Copy spells into numPairs\\n        vector<int> numPairs(spells); // O(n)\\n        \\n        // Add each number into the map\\n        for(int i = 0; i < spells.size(); i++) { // O(n)\\n            pairsMap[spells[i]] = {i, -1};\\n        }\\n\\n        // Sort both spells and potion\\n        sort(spells.begin(), spells.end()); // O(n log n)\\n        sort(potions.begin(), potions.end()); // O(m log m)\\n\\n        // Two pointer approach\\n        // Spell pointer starts from the left\\n        // Potion pointer starts from the right\\n        int potionPtr = potions.size() - 1;\\n        for(int i = 0; i < spells.size(); i++) { // O(m)\\n            int spell = spells[i];\\n            while(potionPtr >= 0 && (long long) spell * potions[potionPtr] >= success) {\\n                potionPtr--;\\n            }\\n            pairsMap[spell] = {pairsMap[spell].first, potions.size() - 1 - potionPtr};\\n        }\\n\\n        // Put data into vector\\n        int idx = 0;\\n        for(int spell: numPairs) { // O(n)\\n            numPairs[idx++] = pairsMap[spell].second;\\n        }\\n\\n        return numPairs;\\n    }\\n};\\n```\\n\\n## Complexity\\nLet\\'s define `m` as the length of `spells` and `n` as the length of `potions`.\\n\\n- Time Complexity: $$O(n log n + m log m)$$\\n- Space Complexity: $$O(n + log m)$$\\n    - Sorting in C++ takes $$O(log n)$$ space.\\n    - The resulting array is not considered as space.",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    // T:O(n*m), S:O(1)\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        vector<int> numPairs(spells.size(), 0);\\n\\n        // Loop through all spells\\n        for(int i = 0; i < spells.size(); i++) { // O(n)\\n            int spell = spells[i];\\n            int count = 0;\\n\\n            // Loop through all potions for each spell\\n            for(int potion: potions) { // O(m)\\n\\n                // Increment count if it exceeds success\\n                long long pair = (long long)potion * (long long)spell;\\n                if(pair >= success) count++;\\n            }\\n            numPairs[i] = count;\\n        }\\n\\n        return numPairs;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    // T:O(m log m + n log m), S:O(log m)\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        vector<int> numPairs(spells.size(), 0);\\n\\n        // Sort potions\\n        sort(potions.begin(), potions.end()); // O(m log m)\\n\\n        // Loop through all spells\\n        for(int i = 0; i < spells.size(); i++) { // O(n)\\n            // Find the minimum potion needed for success\\n            long long potionNeeded = ceil(static_cast<double>(success) / spells[i]);\\n\\n            // Find the smallest idx position\\n            auto it = lower_bound(potions.begin(), potions.end(), potionNeeded); // O(log m)\\n            int idx = it - potions.begin();\\n\\n            // Calculate count based on the index\\n            int numPair = potions.size() - (it - potions.begin());\\n            numPairs[i] = max(0, numPair);\\n        }\\n\\n        return numPairs;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    // T:O(n log n + m log m), S:O(n + log m)\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        unordered_map<int, pair<int, int>> pairsMap; // {spells[i], {idx, numPair}}\\n\\n        // Copy spells into numPairs\\n        vector<int> numPairs(spells); // O(n)\\n        \\n        // Add each number into the map\\n        for(int i = 0; i < spells.size(); i++) { // O(n)\\n            pairsMap[spells[i]] = {i, -1};\\n        }\\n\\n        // Sort both spells and potion\\n        sort(spells.begin(), spells.end()); // O(n log n)\\n        sort(potions.begin(), potions.end()); // O(m log m)\\n\\n        // Two pointer approach\\n        // Spell pointer starts from the left\\n        // Potion pointer starts from the right\\n        int potionPtr = potions.size() - 1;\\n        for(int i = 0; i < spells.size(); i++) { // O(m)\\n            int spell = spells[i];\\n            while(potionPtr >= 0 && (long long) spell * potions[potionPtr] >= success) {\\n                potionPtr--;\\n            }\\n            pairsMap[spell] = {pairsMap[spell].first, potions.size() - 1 - potionPtr};\\n        }\\n\\n        // Put data into vector\\n        int idx = 0;\\n        for(int spell: numPairs) { // O(n)\\n            numPairs[idx++] = pairsMap[spell].second;\\n        }\\n\\n        return numPairs;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3369016,
                "title": "linear-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Find maximum Spell power.\\n2. Create an array `counts` of length `max spell power` filled with zeros.\\n3. For each potion calculate minimum required spell. If required spell <= maximum spell power, increment counts of required Spell.\\n4. Update `counts` , so `counts[i] = sum(counts[0]...counts[i])`. So `counts` now contains total number of \"good\" potions.\\n5. Fill the results, so `results[i] = counts[spells[i]]`. To save some space, we can use spells as results.\\n\\n# Complexity\\n- Time complexity: O(n + m + k)\\n    spells.size() = n\\n    potions.size() = m\\n    max spells power = k\\n\\n    It can be optimized a little bit. `k` could be `max spells power` - `min spells power`\\n\\n- Space complexity: O(k)\\n  We only use additional space for `counts` array. If we consider `results` as additional space, then O(k+n).\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        int maxSpell = 0;\\n        for(int i=0; i<spells.size(); ++i){  //O(n)\\n            maxSpell = max(maxSpell, spells[i]);\\n        }\\n        vector<int> counts(maxSpell+1, 0);\\n\\n        for(int i=0; i<potions.size(); ++i){ //O(m)\\n            auto index = (success+potions[i]-1)/potions[i]; //minimum required spell power\\n            if(index<counts.size()) counts[index]++;\\n        }\\n\\n        for(int i=1; i<counts.size(); ++i){ //O(k)\\n            counts[i] +=counts[i-1];\\n        }\\n\\n        vector<int> result(spells.size(), 0);\\n        for(int i=0; i<spells.size(); ++i){ //O(n)\\n            result[i] = counts[spells[i]];\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        int maxSpell = 0;\\n        for(int i=0; i<spells.size(); ++i){  //O(n)\\n            maxSpell = max(maxSpell, spells[i]);\\n        }\\n        vector<int> counts(maxSpell+1, 0);\\n\\n        for(int i=0; i<potions.size(); ++i){ //O(m)\\n            auto index = (success+potions[i]-1)/potions[i]; //minimum required spell power\\n            if(index<counts.size()) counts[index]++;\\n        }\\n\\n        for(int i=1; i<counts.size(); ++i){ //O(k)\\n            counts[i] +=counts[i-1];\\n        }\\n\\n        vector<int> result(spells.size(), 0);\\n        for(int i=0; i<spells.size(); ++i){ //O(n)\\n            result[i] = counts[spells[i]];\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3367908,
                "title": "day-92-binary-search-easiest-beginner-friendly-sol",
                "content": "**NOTE - PLEASE READ INTUITION AND APPROACH FIRST THEN SEE THE CODE. YOU WILL DEFINITELY UNDERSTAND THE CODE LINE BY LINE AFTER SEEING THE APPROACH.**\\n \\n**NOTE 2 - I WILL HIGHLY RECOMMEND YOU GUYS BEFORE SOLVING THIS PROBLEM PLEASE SOLVE BINARY SEARCH PROBLEM.**\\n\\n**704. Binary Search Problem -** https://leetcode.com/problems/binary-search/\\n**704. Binary Search Solution -** https://leetcode.com/problems/binary-search/solutions/3364016/day-91-binary-search-o-logn-time-easiest-beginner-friendly-sol/\\n\\n# Intuition of this Problem :\\n*The problem is asking to find the number of successful pairings between the spells and potions arrays such that the product of their strengths is at least a given integer \"success\".*\\n\\n***To solve this problem, we can iterate through each spell and for each spell, we can find the index of the first potion whose strength is at least \"success\". This can be done using binary search since the potions array is sorted. Once we have the index, the number of successful pairings can be calculated by subtracting the index from the total number of potions. We can repeat this process for each spell and store the number of successful pairings in an array.***\\n\\n*Finally, we return the array containing the number of successful pairings for each spell.*\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach for this Problem :\\n1. Define a function binarySearch which takes the input integer spell, a vector of integers potions, and a long integer success and returns an integer value.\\n2. Initialize the integer startIndex to 0, lastIndex to potions.size() - 1, and ansIndex to -1.\\n3. Run a while loop until startIndex is less than or equal to lastIndex.\\n4. Within the loop, calculate the midIndex using (startIndex + (lastIndex - startIndex) / 2) to avoid integer overflow.\\n5. If the product of spell and the midIndex element of potions is greater than or equal to success, then set ansIndex to midIndex and update lastIndex to midIndex - 1.\\n6. Else, update startIndex to midIndex + 1.\\n7. Return ansIndex.\\n8. Initialize an integer m to the size of the potions vector and create an empty vector ans.\\n9. Sort the potions vector in ascending order using sort.\\n10. Iterate through each element spell in the spells vector.\\n11. Initialize an integer countPair to 0.\\n12. Call the binarySearch function with spell, potions, and success as arguments and store the result in the index variable.\\n13. If index is equal to -1, then add 0 to countPair, else add m - index to countPair.\\n14. Append countPair to ans.\\n15. Return ans.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Code :\\n```C++ []\\n//1st Approach\\n\\nclass Solution {\\npublic:\\n    int binarySearch(int spell, vector<int>& potions, long long success) {\\n        int startIndex = 0; \\n        int lastIndex = potions.size() - 1;\\n        int ansIndex = -1;\\n        while(startIndex <= lastIndex){\\n            //helps to prevent from out of bound\\n            int midIndex = (startIndex + (lastIndex - startIndex) / 2);\\n            if ((long long) spell * potions[midIndex] >= success){\\n                ansIndex = midIndex;\\n                lastIndex = midIndex - 1;\\n            }\\n            else{\\n                startIndex = midIndex + 1;\\n            }\\n        }\\n        return ansIndex;   \\n    }\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        sort(potions.begin(), potions.end());\\n        int m = potions.size();\\n        vector<int> ans;\\n        for (int spell : spells) {\\n            int countPair = 0;\\n            int index = binarySearch(spell, potions, success);\\n            if (index == -1) \\n                countPair += 0;\\n            else\\n                countPair += (m - index);\\n            ans.push_back(countPair);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n```C++ []\\n//2nd Approach\\n\\nclass Solution {\\npublic:\\n    int binarySearch(int spell, vector<int>& potions, long long success) {\\n        int startIndex = 0; \\n        int lastIndex = potions.size() - 1;\\n        while(startIndex <= lastIndex){\\n            //helps to prevent from out of bound\\n            int midIndex = (startIndex + (lastIndex - startIndex) / 2);\\n            if ((long long) spell * potions[midIndex] >= success){\\n                lastIndex = midIndex - 1;\\n            }\\n            else{\\n                startIndex = midIndex + 1;\\n            }\\n        }\\n        return lastIndex + 1;   \\n    }\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        sort(potions.begin(), potions.end());\\n        int m = potions.size();\\n        vector<int> ans;\\n        for (int spell : spells) {\\n            int index = binarySearch(spell, potions, success);\\n            ans.push_back(m - index);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public int binarySearch(int spell, int[] potions, long success) {\\n        int startIndex = 0; \\n        int lastIndex = potions.length - 1;\\n        int ansIndex = -1;\\n        while(startIndex <= lastIndex){\\n            int midIndex = (startIndex + (lastIndex - startIndex) / 2);\\n            if ((long) spell * potions[midIndex] >= success){\\n                ansIndex = midIndex;\\n                lastIndex = midIndex - 1;\\n            }\\n            else{\\n                startIndex = midIndex + 1;\\n            }\\n        }\\n        return ansIndex;   \\n    }\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        Arrays.sort(potions);\\n        int m = potions.length;\\n        int[] ans = new int[spells.length];\\n        for (int i = 0; i < spells.length; i++) {\\n            int countPair = 0;\\n            int index = binarySearch(spells[i], potions, success);\\n            if (index == -1) \\n                countPair += 0;\\n            else\\n                countPair += (m - index);\\n            ans[i] = countPair;\\n        }\\n        return ans;\\n    }\\n}\\n\\n```\\n```Python []\\nclass Solution:\\n    def binarySearch(self, spell: int, potions: List[int], success: int) -> int:\\n        startIndex = 0\\n        lastIndex = len(potions) - 1\\n        ansIndex = -1\\n        while startIndex <= lastIndex:\\n            midIndex = (startIndex + (lastIndex - startIndex) // 2)\\n            if spell * potions[midIndex] >= success:\\n                ansIndex = midIndex\\n                lastIndex = midIndex - 1\\n            else:\\n                startIndex = midIndex + 1\\n        return ansIndex\\n    \\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\\n        potions.sort()\\n        m = len(potions)\\n        ans = []\\n        for spell in spells:\\n            countPair = 0\\n            index = self.binarySearch(spell, potions, success)\\n            if index == -1:\\n                countPair += 0\\n            else:\\n                countPair += (m - index)\\n            ans.append(countPair)\\n        return ans\\n\\n```\\n\\n# Time Complexity and Space Complexity:\\n- **Time Complexity :** **O((n + m) log m)**, where n is the length of the spells vector and m is the length of the potions vector.\\n\\n*The sort function takes O(m log m) time where \\'m\\' is the size of the potions vector.\\nFor each spell, the binarySearch function is called which takes O(log m) time.\\nTherefore, the time complexity of the entire solution is O(n log m + m log m), where \\'n\\' is the size of the spells vector.*\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- **Space Complexity :** **O(m + n)**, since we need to store the result in the ans vector.\\n\\n*The space complexity of the solution is O(m) to store the sorted potions vector, and O(n) to store the output vector of size \\'n\\'.\\nTherefore, the total space complexity of the solution is O(m + n).*\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Array",
                    "Binary Search"
                ],
                "code": "```C++ []\\n//1st Approach\\n\\nclass Solution {\\npublic:\\n    int binarySearch(int spell, vector<int>& potions, long long success) {\\n        int startIndex = 0; \\n        int lastIndex = potions.size() - 1;\\n        int ansIndex = -1;\\n        while(startIndex <= lastIndex){\\n            //helps to prevent from out of bound\\n            int midIndex = (startIndex + (lastIndex - startIndex) / 2);\\n            if ((long long) spell * potions[midIndex] >= success){\\n                ansIndex = midIndex;\\n                lastIndex = midIndex - 1;\\n            }\\n            else{\\n                startIndex = midIndex + 1;\\n            }\\n        }\\n        return ansIndex;   \\n    }\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        sort(potions.begin(), potions.end());\\n        int m = potions.size();\\n        vector<int> ans;\\n        for (int spell : spells) {\\n            int countPair = 0;\\n            int index = binarySearch(spell, potions, success);\\n            if (index == -1) \\n                countPair += 0;\\n            else\\n                countPair += (m - index);\\n            ans.push_back(countPair);\\n        }\\n        return ans;\\n    }\\n};\\n```\n```C++ []\\n//2nd Approach\\n\\nclass Solution {\\npublic:\\n    int binarySearch(int spell, vector<int>& potions, long long success) {\\n        int startIndex = 0; \\n        int lastIndex = potions.size() - 1;\\n        while(startIndex <= lastIndex){\\n            //helps to prevent from out of bound\\n            int midIndex = (startIndex + (lastIndex - startIndex) / 2);\\n            if ((long long) spell * potions[midIndex] >= success){\\n                lastIndex = midIndex - 1;\\n            }\\n            else{\\n                startIndex = midIndex + 1;\\n            }\\n        }\\n        return lastIndex + 1;   \\n    }\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        sort(potions.begin(), potions.end());\\n        int m = potions.size();\\n        vector<int> ans;\\n        for (int spell : spells) {\\n            int index = binarySearch(spell, potions, success);\\n            ans.push_back(m - index);\\n        }\\n        return ans;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public int binarySearch(int spell, int[] potions, long success) {\\n        int startIndex = 0; \\n        int lastIndex = potions.length - 1;\\n        int ansIndex = -1;\\n        while(startIndex <= lastIndex){\\n            int midIndex = (startIndex + (lastIndex - startIndex) / 2);\\n            if ((long) spell * potions[midIndex] >= success){\\n                ansIndex = midIndex;\\n                lastIndex = midIndex - 1;\\n            }\\n            else{\\n                startIndex = midIndex + 1;\\n            }\\n        }\\n        return ansIndex;   \\n    }\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        Arrays.sort(potions);\\n        int m = potions.length;\\n        int[] ans = new int[spells.length];\\n        for (int i = 0; i < spells.length; i++) {\\n            int countPair = 0;\\n            int index = binarySearch(spells[i], potions, success);\\n            if (index == -1) \\n                countPair += 0;\\n            else\\n                countPair += (m - index);\\n            ans[i] = countPair;\\n        }\\n        return ans;\\n    }\\n}\\n\\n```\n```Python []\\nclass Solution:\\n    def binarySearch(self, spell: int, potions: List[int], success: int) -> int:\\n        startIndex = 0\\n        lastIndex = len(potions) - 1\\n        ansIndex = -1\\n        while startIndex <= lastIndex:\\n            midIndex = (startIndex + (lastIndex - startIndex) // 2)\\n            if spell * potions[midIndex] >= success:\\n                ansIndex = midIndex\\n                lastIndex = midIndex - 1\\n            else:\\n                startIndex = midIndex + 1\\n        return ansIndex\\n    \\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\\n        potions.sort()\\n        m = len(potions)\\n        ans = []\\n        for spell in spells:\\n            countPair = 0\\n            index = self.binarySearch(spell, potions, success)\\n            if index == -1:\\n                countPair += 0\\n            else:\\n                countPair += (m - index)\\n            ans.append(countPair)\\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3370613,
                "title": "simple-c-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n- the approach that is used here is `binary search`.\\n- So first we `sort` the potions.\\n- then we traverse through `every element in spell` and multiply it to the potions.\\n- and because our potions is `sorted` we can apply binary search now.\\n- so by doing that we can get the minimum element in `potions` which has multiplication `>=` to our success.\\n- when we get that element then every element from its right or is bigger than that element is gonna pass.\\n- so we push the `total size of potions - index of minimum success element`.\\n- after doing it for all the elements in `spells`, we return the answer\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: `O(nlog(n+m))` #correct me if i\\'m wrong cause not sure perfectly :)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n`Upvote ! It just takes 1 click :)`\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        vector<int> ans;\\n        int n= spells.size();\\n        int m = potions.size();\\n        sort(potions.begin(), potions.end());\\n        for (int i=0;i<n;i++){\\n            int spell = spells[i];\\n            int start = 0;\\n            int end = m-1;\\n            while(start<=end){\\n                int mid = start + (end-start)/2;\\n                long long product = (long) spell * potions[mid];\\n                if(product>=success){\\n                    end = mid-1;\\n                } \\n                else{\\n                    start = mid+1;\\n                }\\n            }\\n            ans.push_back(m-start);\\n            \\n        }\\n        return ans;\\n        \\n    }\\n};\\n```\\n![Upvote.jpeg](https://assets.leetcode.com/users/images/1b85f3f9-1fb4-466e-8a35-8dd5e22e1a9f_1680437696.0481274.jpeg)",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        vector<int> ans;\\n        int n= spells.size();\\n        int m = potions.size();\\n        sort(potions.begin(), potions.end());\\n        for (int i=0;i<n;i++){\\n            int spell = spells[i];\\n            int start = 0;\\n            int end = m-1;\\n            while(start<=end){\\n                int mid = start + (end-start)/2;\\n                long long product = (long) spell * potions[mid];\\n                if(product>=success){\\n                    end = mid-1;\\n                } \\n                else{\\n                    start = mid+1;\\n                }\\n            }\\n            ans.push_back(m-start);\\n            \\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2138901,
                "title": "binary-search",
                "content": "```\\npublic int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        Arrays.sort(potions);\\n        for(int i=0;i<spells.length;i++){\\n            int l=0,h=potions.length;\\n            while(l<h){\\n                int mid = (l+h)/2;\\n                if(1L*spells[i]*potions[mid]>=success){\\n                    h=mid;\\n                }else{\\n                    l=mid+1;\\n                }\\n            }\\n            spells[i]=potions.length-l;\\n        }\\n        return spells;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        Arrays.sort(potions);\\n        for(int i=0;i<spells.length;i++){\\n            int l=0,h=potions.length;\\n            while(l<h){\\n                int mid = (l+h)/2;\\n                if(1L*spells[i]*potions[mid]>=success){\\n                    h=mid;\\n                }else{\\n                    l=mid+1;\\n                }\\n            }\\n            spells[i]=potions.length-l;\\n        }\\n        return spells;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3369922,
                "title": "c-easy-binary-search",
                "content": "# Code\\n```\\nclass Solution {\\n    #define ll long long\\npublic:\\n    vector<int> successfulPairs(vector<int>& s, vector<int>& p, long long c) {\\n        sort(p.begin(),p.end());\\n        vector<int>an;\\n        for(int i=0;i<s.size();i++){\\n            int d=0;\\n            ll g=c/s[i];\\n            if(c%s[i])g++;\\n            int f=lower_bound(p.begin(),p.end(),g)-p.begin();\\n            d += p.size()-f;\\n            an.push_back(d);\\n        }\\n        return an;\\n    }\\n};\\n```\\n![upvote (3).jpg](https://assets.leetcode.com/users/images/c97c664a-5d0e-4880-8c56-ee876fe9d057_1680426069.3153875.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    #define ll long long\\npublic:\\n    vector<int> successfulPairs(vector<int>& s, vector<int>& p, long long c) {\\n        sort(p.begin(),p.end());\\n        vector<int>an;\\n        for(int i=0;i<s.size();i++){\\n            int d=0;\\n            ll g=c/s[i];\\n            if(c%s[i])g++;\\n            int f=lower_bound(p.begin(),p.end(),g)-p.begin();\\n            d += p.size()-f;\\n            an.push_back(d);\\n        }\\n        return an;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3369191,
                "title": "c-easy-explanation-beginner-friendly-without-bs",
                "content": "# Intuition\\nWE WILL SORT SPELLS IN DESCENDING ORDER AND POTIONS IN ASCENDING ORDER . SO THAT EVERY TIME I CHECK FOR A GIVEN SPELL ,I DON\\'T HAVE TO TRAVERSE FROM BEGINNING . It will start from some index k .\\n\\nAND ALSO.\\nIF ANY GREATER SPELL IS NOT ABLE TO MAKE SUCCESS FROM POTIONS ,THEN \\nNO SPELL AFTER THAT WILL GIVE ANY SUCCESS . THEREFORE \\n\\n```\\nif(flag==0)break;\\n```\\n\\n# Approach\\nSEE CODE WITH COMMENTS . YOU WILL SURELY GET IT .\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& ss, vector<int>& p, long long suc) {\\n        vector<int>s=ss;// TO MAKE USE OF ITS SORTED(DESCENDING) FORM .\\n        unordered_map<int,int>mpp;// TO STORE SPELL WITH THEIR SUCCESS.\\n        vector<int>ans; // FINAL RESULT WILL BE STORED .\\n\\n        sort(p.begin(),p.end());\\n\\n        sort(s.begin(),s.end(),greater<int>()); // SORTING IN DESCENDING .\\n\\n        int n=s.size();int n2=p.size();\\n // K IS USED FOR NEW INDEX FROM WHERE NEXT SPELL SHOULD CHECK IN POTION FOR THEIR SUCCESS .\\n        int k=0;\\n\\n        for(int i=0;i<n;i++){\\n\\n            bool flag=0;// for check if any spell is making success or not.\\n\\n            for(int j=k;j<n2;j++){\\n                // 1LL for avoiding overflow of int .\\n                if(1LL*s[i]*p[j]>=suc){\\n                    k=j; // storing new index for next spell to traverse.\\n                    flag=1;\\n                    mpp[s[i]]=n2-j;// storing success of current spell.\\n                    break;\\n                }\\n            }\\n            // if spell is not making success ,break;\\n            if(flag==0){  break; } \\n        }\\n\\n        for(int i=0;i<n;i++){\\n            // if spell was making any success .It had stored in mpp.\\n            if(mpp.count(ss[i]))ans.push_back(mpp[ss[i]]);\\n\\n            else ans.push_back(0);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```\\nCODE BY :) AMAN MAURYA \\nTHANK YOU \\n\\nUPVOTE IF YOU FOUND IT EASY OR DIFFERENT .\\n![UPVOTE.jpeg](https://assets.leetcode.com/users/images/920b2dc1-352a-4f35-a497-d3016f8a562a_1680415841.5855615.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nif(flag==0)break;\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& ss, vector<int>& p, long long suc) {\\n        vector<int>s=ss;// TO MAKE USE OF ITS SORTED(DESCENDING) FORM .\\n        unordered_map<int,int>mpp;// TO STORE SPELL WITH THEIR SUCCESS.\\n        vector<int>ans; // FINAL RESULT WILL BE STORED .\\n\\n        sort(p.begin(),p.end());\\n\\n        sort(s.begin(),s.end(),greater<int>()); // SORTING IN DESCENDING .\\n\\n        int n=s.size();int n2=p.size();\\n // K IS USED FOR NEW INDEX FROM WHERE NEXT SPELL SHOULD CHECK IN POTION FOR THEIR SUCCESS .\\n        int k=0;\\n\\n        for(int i=0;i<n;i++){\\n\\n            bool flag=0;// for check if any spell is making success or not.\\n\\n            for(int j=k;j<n2;j++){\\n                // 1LL for avoiding overflow of int .\\n                if(1LL*s[i]*p[j]>=suc){\\n                    k=j; // storing new index for next spell to traverse.\\n                    flag=1;\\n                    mpp[s[i]]=n2-j;// storing success of current spell.\\n                    break;\\n                }\\n            }\\n            // if spell is not making success ,break;\\n            if(flag==0){  break; } \\n        }\\n\\n        for(int i=0;i<n;i++){\\n            // if spell was making any success .It had stored in mpp.\\n            if(mpp.count(ss[i]))ans.push_back(mpp[ss[i]]);\\n\\n            else ans.push_back(0);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2147091,
                "title": "java-easy-solution-using-binary-search-o-n-logn",
                "content": "**O(n*log(n)) / O(1)**\\n```\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        Arrays.sort(potions);\\n        \\n        for(int i = 0; i < spells.length; i++) {\\n            int l = 0, r = potions.length;\\n            \\n            while(l < r) {\\n                int m = l + (r - l) / 2;\\n                \\n                if((long)spells[i]*potions[m]  >= success)\\n                    r = m;\\n                else\\n                    l = m + 1;\\n            }\\n            \\n            spells[i] = potions.length - l;\\n        }\\n        \\n        return spells;\\n    }\\n```\\n*Comment down, If you have any doubt.*\\n**Upvote^, If you liked it.**",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        Arrays.sort(potions);\\n        \\n        for(int i = 0; i < spells.length; i++) {\\n            int l = 0, r = potions.length;\\n            \\n            while(l < r) {\\n                int m = l + (r - l) / 2;\\n                \\n                if((long)spells[i]*potions[m]  >= success)\\n                    r = m;\\n                else\\n                    l = m + 1;\\n            }\\n            \\n            spells[i] = potions.length - l;\\n        }\\n        \\n        return spells;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2139570,
                "title": "python-solution-explained",
                "content": "\\'\\'\\'\\n\\n    def successfulPairs(self, spells: List[int], potions: List[int], s: int) -> List[int]:\\n        q=[]\\n        potions.sort()                                      #Sort the potion array\\n        a=len(potions)\\n        for i in spells:\\n            count=0\\n            l=0                                   #We have to find a value which is less than (success/i) in sorted array  \\n             r=len(potions)                # binary seach will give index of that point and onwards that index all are \\n            x=s/i                                #greater values \\n            while l<r:\\n                mid=l+(r-l)//2\\n                if potions[mid]>=x:\\n                    r=mid\\n                else:\\n                    l=mid+1\\n            \\n            count=(a-l)                                      #Last - index that came with binary search\\n            q.append(count)\\n        return q\\n\\'\\'\\'",
                "solutionTags": [
                    "Python",
                    "C",
                    "Binary Search",
                    "Tree"
                ],
                "code": "\\'\\'\\'\\n\\n    def successfulPairs(self, spells: List[int], potions: List[int], s: int) -> List[int]:\\n        q=[]\\n        potions.sort()                                      #Sort the potion array\\n        a=len(potions)\\n        for i in spells:\\n            count=0\\n            l=0                                   #We have to find a value which is less than (success/i) in sorted array  \\n             r=len(potions)                # binary seach will give index of that point and onwards that index all are \\n            x=s/i                                #greater values \\n            while l<r:\\n                mid=l+(r-l)//2\\n                if potions[mid]>=x:\\n                    r=mid\\n                else:\\n                    l=mid+1\\n            \\n            count=(a-l)                                      #Last - index that came with binary search\\n            q.append(count)\\n        return q\\n\\'\\'\\'",
                "codeTag": "Python3"
            },
            {
                "id": 3369205,
                "title": "binary-search-intuition-explained-with-example",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf we sort the potions array and find the minimum index where the product is greater than or equal to success, then we can be sure that the rest of the potions array will give product greater than or equal to success only.\\n\\nTo solve this kind of problem, we can use Binary Search. We can search in the range 0 to potions.size() and update the range according to whether the mid-value is enough or not.\\n\\n![image.png](https://assets.leetcode.com/users/images/9b20c1e9-0b07-4d87-9031-9d9a79afb50e_1680414955.5710003.png)\\n\\nThe condition would be:\\n``` \\nspell[i]*potions[j]>=success\\n=> potions[j]>=success/spell[i] (as success can be a large number)\\n```\\nNow we need to find the index where this condition is satisfied for the first time.\\n# Example\\nLet\\'s say we have the following inputs:\\n```\\nspells = [2, 3, 4]\\npotions = [1, 2, 3, 4, 5]\\nsuccess = 5\\n```\\n\\nAfter sorting potions, we have:\\n```\\npotions = [1, 2, 3, 4, 5]\\n```\\n\\nFor num = spell[0] = 2, we call binary search. \\n```\\nsuccess/num = 2.5 \\nThe index of the first element in potions that is >= 2.5 is 2.\\nTherefore, we append size-idx = 5-2 = 3 to the ans vector.\\n```\\nFor num = 3:\\n```\\nsuccess/num = 1.67\\nThe index of the first element in potions that is >= 1.67 is 1.\\nTherefore, we append n-idx = 5-1 = 4 to the ans vector.\\n```\\n\\nFor num = 4:\\n```\\nThe index of the first element in potions that is g>= 1.25 is 0.\\nTherefore, we append n-idx = 5-0 = 5 to the ans vector.\\n```\\nThe final ans vector:\\n```\\n[3, 4, 5]\\nindicating that there are 3 successful pairs for num = 2, \\n4 successful pairs for num = 3, \\nand 5 successful pairs for num = 4.\\n```\\n\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(mlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int binarySearch(int num, vector<int>& potions, long long success){\\n        int left=0, right=potions.size()-1;\\n        double curr=(double)success/num; \\n        while(left<right){\\n            int mid=left+(right-left)/2;\\n            if(potions[mid]>=curr){ \\n                right=mid;  // set right to mid to search for lower indices\\n            }\\n            else left=mid+1;  // else set left to mid+1 to search for higher indices\\n        }\\n        if(potions[right]>=curr) return right;  // if any element has product greater than or equal to success\\n        else return -1;  // else potion with success probability not fount\\n    }\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        vector<int>ans;\\n        int n=potions.size();\\n        sort(potions.begin(),potions.end()); \\n        for(int num:spells){\\n            int idx=binarySearch(num,potions,success);  // find index where condition is satisfied for the first time\\n            if(idx==-1) ans.push_back(0);  // if potion with success probability not found, add 0\\n            else  ans.push_back(n-idx);  // else, n-idx would be the number of pairs that satisfy the condition\\n        }\\n        return ans;  \\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "``` \\nspell[i]*potions[j]>=success\\n=> potions[j]>=success/spell[i] (as success can be a large number)\\n```\n```\\nspells = [2, 3, 4]\\npotions = [1, 2, 3, 4, 5]\\nsuccess = 5\\n```\n```\\npotions = [1, 2, 3, 4, 5]\\n```\n```\\nsuccess/num = 2.5 \\nThe index of the first element in potions that is >= 2.5 is 2.\\nTherefore, we append size-idx = 5-2 = 3 to the ans vector.\\n```\n```\\nsuccess/num = 1.67\\nThe index of the first element in potions that is >= 1.67 is 1.\\nTherefore, we append n-idx = 5-1 = 4 to the ans vector.\\n```\n```\\nThe index of the first element in potions that is g>= 1.25 is 0.\\nTherefore, we append n-idx = 5-0 = 5 to the ans vector.\\n```\n```\\n[3, 4, 5]\\nindicating that there are 3 successful pairs for num = 2, \\n4 successful pairs for num = 3, \\nand 5 successful pairs for num = 4.\\n```\n```\\nclass Solution {\\npublic:\\n    int binarySearch(int num, vector<int>& potions, long long success){\\n        int left=0, right=potions.size()-1;\\n        double curr=(double)success/num; \\n        while(left<right){\\n            int mid=left+(right-left)/2;\\n            if(potions[mid]>=curr){ \\n                right=mid;  // set right to mid to search for lower indices\\n            }\\n            else left=mid+1;  // else set left to mid+1 to search for higher indices\\n        }\\n        if(potions[right]>=curr) return right;  // if any element has product greater than or equal to success\\n        else return -1;  // else potion with success probability not fount\\n    }\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        vector<int>ans;\\n        int n=potions.size();\\n        sort(potions.begin(),potions.end()); \\n        for(int num:spells){\\n            int idx=binarySearch(num,potions,success);  // find index where condition is satisfied for the first time\\n            if(idx==-1) ans.push_back(0);  // if potion with success probability not found, add 0\\n            else  ans.push_back(n-idx);  // else, n-idx would be the number of pairs that satisfy the condition\\n        }\\n        return ans;  \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3367920,
                "title": "java-easy-solution-using-binary-search-beginner-friendly-using-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\nPLEASE UPVOTE IF YOU LIKE.\\n```\\nclass Solution {\\n    \\n    Map<Integer, int[]> duplicates;\\n\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        int[] pairs = new int[spells.length];\\n        Arrays.sort(potions);\\n        int ind = 0;\\n        duplicates = new HashMap<>();\\n        for (int i = 0; i < potions.length; i++) {\\n            if (duplicates.containsKey(potions[i])) {\\n                int[] idx = duplicates.get(potions[i]);\\n                duplicates.put(potions[i], new int[]{idx[0], i});\\n            } else duplicates.put(potions[i], new int[]{i});\\n        }\\n\\n        for (int s : spells) {\\n            int idx = bs(potions, (long) Math.ceil((double) success / s));\\n            if (idx >= 0) {\\n                pairs[ind++] = potions.length - idx;\\n            } else {\\n                pairs[ind++] = 0;\\n            }\\n        }\\n        return pairs;\\n    }\\n\\n    private int bs(int[] potions, long value) {\\n        int l = 0, h = potions.length - 1;\\n        while (l < h) {\\n            int mid = l + (h - l) / 2;\\n            if (value < potions[mid]) {\\n                h = mid;\\n            } else if (value > potions[mid]) {\\n                l = mid + 1;\\n            } else if (value == potions[mid]) {\\n                return duplicates.get(potions[mid])[0];\\n            }\\n        }\\n\\n        return potions[l] < value ? -1 : l;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    Map<Integer, int[]> duplicates;\\n\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        int[] pairs = new int[spells.length];\\n        Arrays.sort(potions);\\n        int ind = 0;\\n        duplicates = new HashMap<>();\\n        for (int i = 0; i < potions.length; i++) {\\n            if (duplicates.containsKey(potions[i])) {\\n                int[] idx = duplicates.get(potions[i]);\\n                duplicates.put(potions[i], new int[]{idx[0], i});\\n            } else duplicates.put(potions[i], new int[]{i});\\n        }\\n\\n        for (int s : spells) {\\n            int idx = bs(potions, (long) Math.ceil((double) success / s));\\n            if (idx >= 0) {\\n                pairs[ind++] = potions.length - idx;\\n            } else {\\n                pairs[ind++] = 0;\\n            }\\n        }\\n        return pairs;\\n    }\\n\\n    private int bs(int[] potions, long value) {\\n        int l = 0, h = potions.length - 1;\\n        while (l < h) {\\n            int mid = l + (h - l) / 2;\\n            if (value < potions[mid]) {\\n                h = mid;\\n            } else if (value > potions[mid]) {\\n                l = mid + 1;\\n            } else if (value == potions[mid]) {\\n                return duplicates.get(potions[mid])[0];\\n            }\\n        }\\n\\n        return potions[l] < value ? -1 : l;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2141703,
                "title": "c-use-binary-search-efficient-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) \\n    {\\n        int sn = spells.size();\\n        int pn = potions.size();\\n        vector<int> ans; //stores answer\\n        \\n        sort(potions.begin(), potions.end()); //sort potions for binary search\\n        \\n        for(auto it : spells)\\n        {\\n            int left=0, right=pn-1, mid; //define left, right and mid pointers\\n            \\n            while(left<=right) //iterate until right is lesser than left\\n            {\\n                mid = (left+right)>>1; \\n                \\n                if((long long)it*potions[mid] >= success) right=mid-1;\\n                \\n                else left=mid+1;\\n            }\\n            ans.push_back(pn-left);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```\\n\\n# Please upvote if you like this approach :)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search",
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) \\n    {\\n        int sn = spells.size();\\n        int pn = potions.size();\\n        vector<int> ans; //stores answer\\n        \\n        sort(potions.begin(), potions.end()); //sort potions for binary search\\n        \\n        for(auto it : spells)\\n        {\\n            int left=0, right=pn-1, mid; //define left, right and mid pointers\\n            \\n            while(left<=right) //iterate until right is lesser than left\\n            {\\n                mid = (left+right)>>1; \\n                \\n                if((long long)it*potions[mid] >= success) right=mid-1;\\n                \\n                else left=mid+1;\\n            }\\n            ans.push_back(pn-left);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2139547,
                "title": "python-3-math-binary-search-explanation",
                "content": "### Explanation\\n- The order of `potions` doesn\\'t matter, we just need to find out how many potion can form a *successful* pair with the current *spell*\\n\\t- Thus, we can sort `potions` to make a faster binary search\\n- We can\\'t use spell to multiply each potion, it takes a long time `O(mn)`; \\n\\t- Instead, we can use `success` to divided by the current *spell*, which is a `O(1)` operation\\n- If `success % spell == 0`, then we want to include `success // spell`\\n\\t- Thus, we will use a `bisect_left`\\n- Otherwise, we don\\'t want to include  `success // spell`\\n\\t- Thus, we will use a `bisect_right`\\n- `n - idx` is the number of *successful* potions with the current *spell*\\n- Time: `O(nlgm), n = len(spells), m = len(potions)`\\n### Implementation\\n```\\nclass Solution:\\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\\n        potions.sort()\\n        ans, n = [], len(potions)\\n        for spell in spells:\\n            val = success // spell\\n            if success % spell == 0:\\n                idx = bisect.bisect_left(potions, val)\\n            else:    \\n                idx = bisect.bisect_right(potions, val)\\n            ans.append(n - idx)\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution:\\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\\n        potions.sort()\\n        ans, n = [], len(potions)\\n        for spell in spells:\\n            val = success // spell\\n            if success % spell == 0:\\n                idx = bisect.bisect_left(potions, val)\\n            else:    \\n                idx = bisect.bisect_right(potions, val)\\n            ans.append(n - idx)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3375724,
                "title": "powerful-binary-search-approach",
                "content": "\\n# Time Complexity----->O(NLogN)\\n```\\nclass Solution:\\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\\n        list1=[]\\n        potions.sort()\\n        // some test cases are not sorted\\n        for s in spells:\\n            // binary search on left most value i.e greater than success\\n            left,right,index=0,len(potions)-1,len(potions)# index is len(potions) in worst case where no values matches with potions values\\n            while left<=right:\\n                mid=(left+right)//2\\n                if s*potions[mid]>=success:\\n                    right=mid-1\\n                    index=mid\\n                else:\\n                    left=mid+1\\n            // add all possible values by total length -index\\n            list1.append(len(potions)-index)\\n        return list1\\n        \\n```\\n# please upvote me it would encourage me alot\\n\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\\n        list1=[]\\n        potions.sort()\\n        // some test cases are not sorted\\n        for s in spells:\\n            // binary search on left most value i.e greater than success\\n            left,right,index=0,len(potions)-1,len(potions)# index is len(potions) in worst case where no values matches with potions values\\n            while left<=right:\\n                mid=(left+right)//2\\n                if s*potions[mid]>=success:\\n                    right=mid-1\\n                    index=mid\\n                else:\\n                    left=mid+1\\n            // add all possible values by total length -index\\n            list1.append(len(potions)-index)\\n        return list1\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3372355,
                "title": "python-two-pointers-solution-w-sorting-without-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe idea is to initially sort both the ```spells``` and ```potions``` array, and then initialize a variable called ```p``` at the last element of ```potions```. ```p``` will only move from right to left, while another pointer, ```s```, will iterate through ```spells``` from left to right. We will check if ``` spells[s]*potions[p] >= success ```. If so, keep on moving the ```p``` pointer to the left until that condition fails. Record the result once that condition fails for each iteration of ```spells```.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Since the order of our ```spells``` array is important in order to return the number of potions that will form a successful pair with each element in ```spell```, we will recreate the ```spells``` list as a nested list that stores each of its elements and its index.\\n```Ex. spells = [5,1,3] -> spells = [[5,0],[1,1],[3,2]]```\\n2. Sort both ```spells``` and ```potions```.\\n3. Initialize ```result``` and ```p``` to ```[0]*len(spells)``` and ```len(potions)-1```, respectively. The ```result``` array will be returned in the end.\\n4. Run a for-loop on ```spells``` and for each iteration, we run a while-loop that checks if ```spells[s][0]*potions[p] >= success```. If so, we decrement the ```p``` pointer until that condition fails. There\\'s no point in checking further since we already found the potion with the least strength that will form a successful pair for the ```spell[s]``` spell.\\n5. Once the while-loop breaks, we can compute the number of potions that will form a successful pair by doing ```len(potions)-p-1``` and replace the element\\'s value in ```result``` on the ```spells[s][1]``` index.\\n\\n# Complexity\\n- Time complexity: **O(nlog(n)+mlog(m)+n)** because we sorted both input lists and iterate through ```spells```\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(n)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\\n        spells = [[spells[i],i] for i in range(len(spells))]\\n        spells.sort()\\n        potions.sort()\\n\\n        result = [0]*len(spells)\\n        p = len(potions)-1\\n        for s in range(len(spells)):\\n            while p >= 0 and spells[s][0]*potions[p] >= success:\\n                p -= 1\\n            result[spells[s][1]] = len(potions)-p-1\\n\\n        return result\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Two Pointers",
                    "Sorting",
                    "Counting"
                ],
                "code": "```spells```\n```potions```\n```p```\n```potions```\n```p```\n```s```\n```spells```\n``` spells[s]*potions[p] >= success ```\n```p```\n```spells```\n```spells```\n```spell```\n```spells```\n```Ex. spells = [5,1,3] -> spells = [[5,0],[1,1],[3,2]]```\n```spells```\n```potions```\n```result```\n```p```\n```[0]*len(spells)```\n```len(potions)-1```\n```result```\n```spells```\n```spells[s][0]*potions[p] >= success```\n```p```\n```spell[s]```\n```len(potions)-p-1```\n```result```\n```spells[s][1]```\n```spells```\n```\\nclass Solution:\\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\\n        spells = [[spells[i],i] for i in range(len(spells))]\\n        spells.sort()\\n        potions.sort()\\n\\n        result = [0]*len(spells)\\n        p = len(potions)-1\\n        for s in range(len(spells)):\\n            while p >= 0 and spells[s][0]*potions[p] >= success:\\n                p -= 1\\n            result[spells[s][1]] = len(potions)-p-1\\n\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3372002,
                "title": "binary-search-for-success",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUsing Binary Search for suucess.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Sort the array.\\n- Binary Search to locate the dividing element.\\n- Dividing element is where the product is just started to get greater.\\n  For Ex.\\n  spell = 5,\\n  potions = [1,2,3,4,5]\\n  success = 16\\n  then, dividing element = 4 (index = 3);\\n- subtracting the index with the length.\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N*log(M) + MlogM)\\n*MlogM for Sorting.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n![leetcodeupvotetrick.png](https://assets.leetcode.com/users/images/8b7ef33d-9a39-409f-916e-353e6dd88607_1680463496.6290069.png)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] successfulPairs(int[] arr, int[] arr1, long suc) {\\n        int[] res = new int[arr.length];\\n        Arrays.sort(arr1);\\n        int l, r, mid;\\n        long t;\\n        for (int i = 0; i < arr.length; i++) {\\n            l = 0;\\n            r = arr1.length - 1;\\n            while (l <= r) {\\n                mid = (l + r) / 2;\\n                t = arr[i];\\n                if (arr1[mid] * t >= suc) {\\n                    r = mid - 1;\\n                    if(r==-1){\\n                        res[i] = arr1.length;\\n                    }\\n                } else if (arr1[mid] * t < suc) {\\n                    if (mid + 1 < arr1.length && arr1[mid + 1] * t >= suc) {\\n                        res[i] = arr1.length - (mid + 1);\\n                        break;\\n                    }\\n                    l = mid + 1;\\n                }\\n            }\\n        }\\n\\n        return res;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] successfulPairs(int[] arr, int[] arr1, long suc) {\\n        int[] res = new int[arr.length];\\n        Arrays.sort(arr1);\\n        int l, r, mid;\\n        long t;\\n        for (int i = 0; i < arr.length; i++) {\\n            l = 0;\\n            r = arr1.length - 1;\\n            while (l <= r) {\\n                mid = (l + r) / 2;\\n                t = arr[i];\\n                if (arr1[mid] * t >= suc) {\\n                    r = mid - 1;\\n                    if(r==-1){\\n                        res[i] = arr1.length;\\n                    }\\n                } else if (arr1[mid] * t < suc) {\\n                    if (mid + 1 < arr1.length && arr1[mid + 1] * t >= suc) {\\n                        res[i] = arr1.length - (mid + 1);\\n                        break;\\n                    }\\n                    l = mid + 1;\\n                }\\n            }\\n        }\\n\\n        return res;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3371631,
                "title": "javascript-php-beats-100-binary-search-faster-than-other-solutions",
                "content": "\\n# Approach\\nHere is my approach to solving the problem using a binary search:\\n\\n* First, we sort the potions array in ascending order. This ensures that the smallest potions are at the front of the\\n  array.\\n\\n* Then, we iterate over the spells array. For each spell, we perform _a binary search_ on the potions array to find the\\n  first potion that is greater than or equal to the _success_ value.\\n\\n* The number of potions that are greater than or equal to the spell\\'s power is the number of successful pairs that can\\n  be formed with that spell.\\n* We add this number to the pairs result array.\\n* We continue this process until we have iterated over all of the spells.\\n* Finally, we return the pairs array.\\n\\n# Complexity\\n\\nThe **time complexity** of the algorithm is O(n log m), where n is the number of potions, and m is the number of spells.\\nThis is because the algorithm sorts the potions array in O(n log n) time and performs a binary search on the potions\\narray for each spell, which takes O(n*log m) time. => O( (n+m) * log m) => O(n log m)\\n\\nThe **space complexity** of the algorithm is O(1), since the algorithm only requires a constant amount of space to store\\nthe\\npotions array, the spells array, the success value, and the pairs array.\\n\\n```javascript []\\n/**\\n * Binary search approach O((n+m)*log(m))\\n *\\n * @param {number[]} spells\\n * @param {number[]} potions\\n * @param {number} success\\n * @return {number[]}\\n */\\nvar successfulPairs = function (spells, potions, success) {\\n        const pairs = [];\\n        potions.sort((a, b) => a - b);\\n        const spellsLength = spells.length;\\n        const potionsLength = potions.length;\\n\\n        for (let i = 0; i < spellsLength; i++) {\\n            let count = 0;\\n            // binary search\\n            let left = 0;\\n            let right = potionsLength - 1;\\n            while (left <= right) {\\n                // const mid = Math.floor((left + right) / 2);\\n                const mid = (left + right) >> 1;\\n                if (spells[i] * potions[mid] >= success) {\\n                    right = mid - 1;\\n                } else {\\n                    left = mid + 1;\\n                }\\n            }\\n            count = potionsLength - left;\\n            pairs.push(count);\\n        }\\n        return pairs;\\n    };\\n```\\n\\n```php []\\nclass Solution\\n{\\n    /**\\n     * @param Integer[] $spells\\n     * @param Integer[] $potions\\n     * @param Integer $success\\n     * @return Integer[]\\n     */\\n    function successfulPairs(array $spells, array $potions, int $success): array {\\n        $pairsResult = [];\\n        $potionsCount = count($potions);\\n        $spellsCount = count($spells);\\n        sort($potions);\\n        // binary search\\n        for ($i = 0; $i < $spellsCount; $i++) {\\n            $left = 0;\\n            $right = $potionsCount - 1;\\n            while ($left <= $right) {\\n                $mid = ($left + $right) >> 1;\\n                if ($spells[$i] * $potions[$mid] >= $success) {\\n                    $right = $mid - 1;\\n                } else {\\n                    $left = $mid + 1;\\n                }\\n            }\\n            $pairsResult[$i] = $potionsCount - $left;\\n        }\\n        return $pairsResult;\\n    }\\n}\\n```\\n\\n```javascript []\\n/**\\n * Binary search approach with  with small optimization\\n *\\n * @param {number[]} spells\\n * @param {number[]} potions\\n * @param {number} success\\n * @return {number[]}\\n */\\nvar successfulPairs = function (spells, potions, success) {\\n        const pairs = [];\\n        potions.sort((a, b) => a - b);\\n        const spellsLength = spells.length;\\n        const potionsLength = potions.length;\\n\\n        let maxSpellValueWithZeroSuccess = 0; // Optimize -  max value of a spell that will never be successful\\n\\n        for (let i = 0; i < spellsLength; i++) {\\n            let count = 0;\\n            if (spells[i] > maxSpellValueWithZeroSuccess) {\\n                // binary search\\n                let left = 0;\\n                let right = potionsLength - 1;\\n                while (left <= right) {\\n                    const mid = (left + right) >> 1;\\n                    if (spells[i] * potions[mid] >= success) {\\n                        right = mid - 1;\\n                    } else {\\n                        left = mid + 1;\\n                    }\\n                }\\n                count = potionsLength - left;\\n                if (count == 0) maxSpellValueWithZeroSuccess = spells[i];\\n            }\\n            pairs.push(count);\\n        }\\n        return pairs;\\n    };\\n```\\n\\n##### Thanks for reading! If you have any questions or suggestions, please leave a comment below. I would love to hear your thoughts! \\uD83D\\uDE0A\\n### **Please upvote if you found this post helpful! \\uD83D\\uDE4F**",
                "solutionTags": [
                    "JavaScript",
                    "PHP",
                    "Binary Search"
                ],
                "code": "```javascript []\\n/**\\n * Binary search approach O((n+m)*log(m))\\n *\\n * @param {number[]} spells\\n * @param {number[]} potions\\n * @param {number} success\\n * @return {number[]}\\n */\\nvar successfulPairs = function (spells, potions, success) {\\n        const pairs = [];\\n        potions.sort((a, b) => a - b);\\n        const spellsLength = spells.length;\\n        const potionsLength = potions.length;\\n\\n        for (let i = 0; i < spellsLength; i++) {\\n            let count = 0;\\n            // binary search\\n            let left = 0;\\n            let right = potionsLength - 1;\\n            while (left <= right) {\\n                // const mid = Math.floor((left + right) / 2);\\n                const mid = (left + right) >> 1;\\n                if (spells[i] * potions[mid] >= success) {\\n                    right = mid - 1;\\n                } else {\\n                    left = mid + 1;\\n                }\\n            }\\n            count = potionsLength - left;\\n            pairs.push(count);\\n        }\\n        return pairs;\\n    };\\n```\n```php []\\nclass Solution\\n{\\n    /**\\n     * @param Integer[] $spells\\n     * @param Integer[] $potions\\n     * @param Integer $success\\n     * @return Integer[]\\n     */\\n    function successfulPairs(array $spells, array $potions, int $success): array {\\n        $pairsResult = [];\\n        $potionsCount = count($potions);\\n        $spellsCount = count($spells);\\n        sort($potions);\\n        // binary search\\n        for ($i = 0; $i < $spellsCount; $i++) {\\n            $left = 0;\\n            $right = $potionsCount - 1;\\n            while ($left <= $right) {\\n                $mid = ($left + $right) >> 1;\\n                if ($spells[$i] * $potions[$mid] >= $success) {\\n                    $right = $mid - 1;\\n                } else {\\n                    $left = $mid + 1;\\n                }\\n            }\\n            $pairsResult[$i] = $potionsCount - $left;\\n        }\\n        return $pairsResult;\\n    }\\n}\\n```\n```javascript []\\n/**\\n * Binary search approach with  with small optimization\\n *\\n * @param {number[]} spells\\n * @param {number[]} potions\\n * @param {number} success\\n * @return {number[]}\\n */\\nvar successfulPairs = function (spells, potions, success) {\\n        const pairs = [];\\n        potions.sort((a, b) => a - b);\\n        const spellsLength = spells.length;\\n        const potionsLength = potions.length;\\n\\n        let maxSpellValueWithZeroSuccess = 0; // Optimize -  max value of a spell that will never be successful\\n\\n        for (let i = 0; i < spellsLength; i++) {\\n            let count = 0;\\n            if (spells[i] > maxSpellValueWithZeroSuccess) {\\n                // binary search\\n                let left = 0;\\n                let right = potionsLength - 1;\\n                while (left <= right) {\\n                    const mid = (left + right) >> 1;\\n                    if (spells[i] * potions[mid] >= success) {\\n                        right = mid - 1;\\n                    } else {\\n                        left = mid + 1;\\n                    }\\n                }\\n                count = potionsLength - left;\\n                if (count == 0) maxSpellValueWithZeroSuccess = spells[i];\\n            }\\n            pairs.push(count);\\n        }\\n        return pairs;\\n    };\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3370088,
                "title": "c-prefix-sum-o-m-n-time-o-1-space",
                "content": "# Intuition\\nTo get to ```success``` we need to check if we can compensate potion power with our spell power. So we need to calculate ```neededSpellCost``` for each potion. As it is an integer division we need to add 1 when it can\\'t be divided to satisfy the requirement. After that we can see which spell can be used with which potion to make needed power.\\n\\n# Approach\\n```neededSpellCost``` can be quite big, such that we won\\'t have any possible spell at all, such cases just ignored.\\n\\nDuring the calculation of ```neededSpellCost``` we starting to build up our ```prefixSum```. After the loop on potions we will have ```prefixSum``` sloted with the number of each spell required.\\n\\nBut any ```k``` spell power can also be used to cover any less powerful spell. So we are going through ```prefixSum``` and accumulate it.\\n\\nLast run just goes through potions and sees how many each potion can cover.\\n\\n# Complexity\\n- Time complexity: ```O(m + n + 100000)``` => ```O(m + n)```\\n\\n- Space complexity: ```O(100000)``` => ```O(1)```\\n\\n# Code C#\\n```\\npublic class Solution {\\n    public int[] SuccessfulPairs(int[] spells, int[] potions, long success)\\n        {\\n            var limit = 100001;\\n            var prefixSum = new int[limit];\\n            for (var i = 0; i < potions.Length; i++)\\n            {\\n                var neededSpellCost = success % potions[i] == 0\\n                    ? success / potions[i]\\n                    : success / potions[i] + 1;\\n\\n                if (neededSpellCost < limit)\\n                    prefixSum[neededSpellCost]++;\\n            }\\n\\n            for (var i = 1; i < prefixSum.Length; i++)\\n                prefixSum[i] += prefixSum[i - 1];\\n\\n            var result = new int[spells.Length];\\n            for (var i = 0; i <  spells.Length; i++)\\n                result[i] = prefixSum[spells[i]];\\n\\n            return result;\\n        }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Prefix Sum"
                ],
                "code": "```success```\n```neededSpellCost```\n```neededSpellCost```\n```neededSpellCost```\n```prefixSum```\n```prefixSum```\n```k```\n```prefixSum```\n```O(m + n + 100000)```\n```O(m + n)```\n```O(100000)```\n```O(1)```\n```\\npublic class Solution {\\n    public int[] SuccessfulPairs(int[] spells, int[] potions, long success)\\n        {\\n            var limit = 100001;\\n            var prefixSum = new int[limit];\\n            for (var i = 0; i < potions.Length; i++)\\n            {\\n                var neededSpellCost = success % potions[i] == 0\\n                    ? success / potions[i]\\n                    : success / potions[i] + 1;\\n\\n                if (neededSpellCost < limit)\\n                    prefixSum[neededSpellCost]++;\\n            }\\n\\n            for (var i = 1; i < prefixSum.Length; i++)\\n                prefixSum[i] += prefixSum[i - 1];\\n\\n            var result = new int[spells.Length];\\n            for (var i = 0; i <  spells.Length; i++)\\n                result[i] = prefixSum[spells[i]];\\n\\n            return result;\\n        }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3368509,
                "title": "python3-solution",
                "content": "\\n```\\nclass Solution:\\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\\n        potions.sort()\\n        N=len(potions)\\n        ans=[]\\n        for s in spells:\\n            target=(success-1)//s\\n            index=bisect.bisect_right(potions,target)\\n            ans.append(N-index)\\n            \\n        return ans    \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\\n        potions.sort()\\n        N=len(potions)\\n        ans=[]\\n        for s in spells:\\n            target=(success-1)//s\\n            index=bisect.bisect_right(potions,target)\\n            ans.append(N-index)\\n            \\n        return ans    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3367853,
                "title": "daily-leetcoding-challenge-april-day-2",
                "content": "This problem is the Daily LeetCoding Challenge for April, Day 2.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/successful-pairs-of-spells-and-potions/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 0 approach in the official solution</summary>\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/successful-pairs-of-spells-and-potions/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 2140055,
                "title": "c-binary-search-explanation-with-comments",
                "content": "**Please Upvote If It Helps**\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) \\n    {\\n        // declare a vector of size spell that will store our ans\\n        int n = spells.size();\\n        int m = potions.size();\\n        vector<int> ans(n,0);\\n        \\n        // sort the potions fir applying the binary search\\n        sort(potions.begin(),potions.end());\\n        \\n        int i = 0;                    // it will help in storing the ans\\n        \\n        // start iterating over the spells\\n        for(auto& x : spells)\\n        {\\n            int l = 0;\\n            int r = m-1;\\n            int mid;\\n            \\n            // binary search\\n            while(l <= r)\\n            {\\n                mid = (l+r)>>1;\\n                \\n                // if it gives our need then reduce the window to the left side for cheking more \\n                if((long long)x*potions[mid] >= success)\\n                    r = mid-1;\\n                \\n                // if not then check to the right side\\n                else\\n                    l = mid+1;\\n            }\\n            ans[i] = m-l;            // storing the answer (total size - not needed size)\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) \\n    {\\n        // declare a vector of size spell that will store our ans\\n        int n = spells.size();\\n        int m = potions.size();\\n        vector<int> ans(n,0);\\n        \\n        // sort the potions fir applying the binary search\\n        sort(potions.begin(),potions.end());\\n        \\n        int i = 0;                    // it will help in storing the ans\\n        \\n        // start iterating over the spells\\n        for(auto& x : spells)\\n        {\\n            int l = 0;\\n            int r = m-1;\\n            int mid;\\n            \\n            // binary search\\n            while(l <= r)\\n            {\\n                mid = (l+r)>>1;\\n                \\n                // if it gives our need then reduce the window to the left side for cheking more \\n                if((long long)x*potions[mid] >= success)\\n                    r = mid-1;\\n                \\n                // if not then check to the right side\\n                else\\n                    l = mid+1;\\n            }\\n            ans[i] = m-l;            // storing the answer (total size - not needed size)\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2139528,
                "title": "c-binary-search-short-and-simple-logic",
                "content": "For each spell,\\n**need = success * 1.0 / spell**\\nBinary search the index of **first potion >= need** in the sorted potions.\\nThe number of potions that are successful are **potions.length - index**\\n```\\nvector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        sort(potions.begin(),potions.end());\\n        long long need;\\n        vector<int> ans;\\n        for(int spell:spells){\\n            need=ceil(success*1.0/spell);\\n            ans.push_back(potions.end()-lower_bound(potions.begin(),potions.end(),need));\\n        }\\n        return ans;\\n    }\\n```\\n*-----please upvote-----*",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nvector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        sort(potions.begin(),potions.end());\\n        long long need;\\n        vector<int> ans;\\n        for(int spell:spells){\\n            need=ceil(success*1.0/spell);\\n            ans.push_back(potions.end()-lower_bound(potions.begin(),potions.end(),need));\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3467543,
                "title": "python-simple-clean-solution-using-binary-search",
                "content": "# Code\\n```\\nclass Solution:\\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\\n        ans = []\\n        potions.sort()\\n\\n        n = len(potions)\\n        for s in spells:\\n            ind = bisect_left(potions, success / s)\\n            ans.append(n - ind)\\n        return ans\\n```\\n\\n## Binary Search\\n```\\nclass Solution:\\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\\n        ans = []\\n        potions.sort()\\n\\n        n = len(potions)\\n        for s in spells:\\n            l, r = 0, n - 1\\n            while l <= r:\\n                mid = (l + r) >> 1\\n                if potions[mid] * s >= success:\\n                    r = mid - 1\\n                else:\\n                    l = mid + 1\\n            ans.append(n - l)\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Two Pointers",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\\n        ans = []\\n        potions.sort()\\n\\n        n = len(potions)\\n        for s in spells:\\n            ind = bisect_left(potions, success / s)\\n            ans.append(n - ind)\\n        return ans\\n```\n```\\nclass Solution:\\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\\n        ans = []\\n        potions.sort()\\n\\n        n = len(potions)\\n        for s in spells:\\n            l, r = 0, n - 1\\n            while l <= r:\\n                mid = (l + r) >> 1\\n                if potions[mid] * s >= success:\\n                    r = mid - 1\\n                else:\\n                    l = mid + 1\\n            ans.append(n - l)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3372191,
                "title": "java-binary-search-spells-and-potions",
                "content": "\\n```\\nclass Solution {\\n    public int search(int[] nums, long target, long sel) {\\n        int start = 0;\\n        int finish = nums.length - 1;\\n        int med;\\n        if (target < nums[start] * sel) return start;\\n        if (target > nums[finish] * sel) return nums.length;\\n\\n        while (start < finish && nums[start] < nums[finish])\\n        {\\n            if (target == nums[start] * sel) return start;\\n            med = (start + finish) / 2;\\n            if (target > nums[med] * sel)\\n                start = med + 1;\\n            else\\n                finish = med;\\n\\n        }\\n        if (nums[start] * sel == target) return start;\\n        if (nums[start] * sel < target)\\n            return start + 1;\\n        else\\n            return start;\\n    }\\n\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        HashMap<Integer, Integer> dict = new HashMap<>();\\n        Arrays.sort(potions);\\n        int [] answ = new int[spells.length];\\n        for (int i = 0; i < spells.length; i++) {\\n            if (!dict.containsKey(spells[i]))\\n                dict.put(spells[i], potions.length - search(potions, success, spells[i]));\\n            answ[i] = dict.get(spells[i]);\\n        }\\n        return answ;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int search(int[] nums, long target, long sel) {\\n        int start = 0;\\n        int finish = nums.length - 1;\\n        int med;\\n        if (target < nums[start] * sel) return start;\\n        if (target > nums[finish] * sel) return nums.length;\\n\\n        while (start < finish && nums[start] < nums[finish])\\n        {\\n            if (target == nums[start] * sel) return start;\\n            med = (start + finish) / 2;\\n            if (target > nums[med] * sel)\\n                start = med + 1;\\n            else\\n                finish = med;\\n\\n        }\\n        if (nums[start] * sel == target) return start;\\n        if (nums[start] * sel < target)\\n            return start + 1;\\n        else\\n            return start;\\n    }\\n\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        HashMap<Integer, Integer> dict = new HashMap<>();\\n        Arrays.sort(potions);\\n        int [] answ = new int[spells.length];\\n        for (int i = 0; i < spells.length; i++) {\\n            if (!dict.containsKey(spells[i]))\\n                dict.put(spells[i], potions.length - search(potions, success, spells[i]));\\n            answ[i] = dict.get(spells[i]);\\n        }\\n        return answ;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3372160,
                "title": "c-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    Binary Search\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(N * log M)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        int n = potions.size();\\n        sort(potions.begin(), potions.end());\\n        vector<int> ans;\\n        for(auto x: spells) {\\n            int l = 0, r = n - 1;\\n            while(l <= r) {\\n                int mid = (l + r) / 2;\\n                if(1ll * potions[mid] * x < success) l = mid + 1;\\n                else r = mid - 1;\\n            }\\n            ans.push_back(n - l);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        int n = potions.size();\\n        sort(potions.begin(), potions.end());\\n        vector<int> ans;\\n        for(auto x: spells) {\\n            int l = 0, r = n - 1;\\n            while(l <= r) {\\n                int mid = (l + r) / 2;\\n                if(1ll * potions[mid] * x < success) l = mid + 1;\\n                else r = mid - 1;\\n            }\\n            ans.push_back(n - l);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3372059,
                "title": "java-binary-search-clean-code-beats-87",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O((m+n) * log(m))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(log(m))$$ used by the sort algorithm in Java\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n    var n = spells.length;\\n    var m = potions.length;\\n    var pairs = new int[n];\\n    \\n    Arrays.sort(potions);\\n\\n    for (var i=0; i<n; i++) {\\n      var minPotion = (int) Math.ceil((double) success / spells[i]);\\n\\n      if (minPotion > potions[m-1]) continue;\\n\\n      var l = 0;\\n      var r = m-1;\\n\\n      while (l < r) {\\n        var mid = l + (r-l) / 2;\\n\\n        if (potions[mid] < minPotion) l = mid+1;\\n        else r = mid;\\n      }\\n      pairs[i] = m-l;\\n    }\\n    return pairs;\\n  }\\n}\\n```\\nIf you like my solution, please upvote it!",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n  public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n    var n = spells.length;\\n    var m = potions.length;\\n    var pairs = new int[n];\\n    \\n    Arrays.sort(potions);\\n\\n    for (var i=0; i<n; i++) {\\n      var minPotion = (int) Math.ceil((double) success / spells[i]);\\n\\n      if (minPotion > potions[m-1]) continue;\\n\\n      var l = 0;\\n      var r = m-1;\\n\\n      while (l < r) {\\n        var mid = l + (r-l) / 2;\\n\\n        if (potions[mid] < minPotion) l = mid+1;\\n        else r = mid;\\n      }\\n      pairs[i] = m-l;\\n    }\\n    return pairs;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3371519,
                "title": "c-easy-lower-bound-2023-short-sol-must-watch",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& s, vector<int>& p, long long t) {\\n        sort(p.begin(),p.end());\\n        vector<int> ans; \\n        int x; long long y;\\n        for(auto &it:s) {\\n            y = t / it;\\n            x = p.end() - lower_bound(p.begin(),p.end(),y * it >= t ? y : y + 1);\\n            ans.push_back(x);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& s, vector<int>& p, long long t) {\\n        sort(p.begin(),p.end());\\n        vector<int> ans; \\n        int x; long long y;\\n        for(auto &it:s) {\\n            y = t / it;\\n            x = p.end() - lower_bound(p.begin(),p.end(),y * it >= t ? y : y + 1);\\n            ans.push_back(x);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3371258,
                "title": "python-3-7-lines-binary-search-t-m-97-70",
                "content": "```\\nclass Solution:\\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\\n\\n        n, ans = len(potions), []\\n        potions.sort()\\n        \\n        for s in spells:\\n            num = success//s + bool(success%s)\\n            idx = bisect_left(potions, num)\\n            ans.append(n-idx)\\n\\n        return ans\\n```\\n[https://leetcode.com/problems/successful-pairs-of-spells-and-potions/submissions/926254122/](http://)\\n\\nI could be wrong, but I think that time complexity is *O*(*N*log*N*) and space complexity is *O*(1).",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\\n\\n        n, ans = len(potions), []\\n        potions.sort()\\n        \\n        for s in spells:\\n            num = success//s + bool(success%s)\\n            idx = bisect_left(potions, num)\\n            ans.append(n-idx)\\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3370628,
                "title": "binary-search-c-please-upvote",
                "content": "# Intuition\\nCan be done in binary search.\\n\\n# Approach\\nStarting with the sorting of potions  , After that getting the element till which (spells[i]*potions[mid]) is greater than success and store those elements in pairs[i].\\nThe submission shall be taken care of for long long type casting.\\n\\n# Complexity\\n- Time complexity:\\nO(nlogm)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        int n=spells.size(),m=potions.size();\\n       \\n       \\n       sort(potions.begin(),potions.end());\\n       vector<int> pairs(n);\\n      for(int i=0;i<n;i++){\\n          int c=0,l=0,r=m-1;\\n        while(l<=r){\\n            \\n            int mid=l+(r-l)/2;\\n            if((long long)spells[i]*(long long)potions[mid]>=success){\\n                r=mid-1;\\n                \\n            }\\n            else{\\n                l=mid+1;\\n            }\\n        }\\n        pairs[i]=m-1-r;\\n        }\\n\\n        \\n        return pairs;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        int n=spells.size(),m=potions.size();\\n       \\n       \\n       sort(potions.begin(),potions.end());\\n       vector<int> pairs(n);\\n      for(int i=0;i<n;i++){\\n          int c=0,l=0,r=m-1;\\n        while(l<=r){\\n            \\n            int mid=l+(r-l)/2;\\n            if((long long)spells[i]*(long long)potions[mid]>=success){\\n                r=mid-1;\\n                \\n            }\\n            else{\\n                l=mid+1;\\n            }\\n        }\\n        pairs[i]=m-1-r;\\n        }\\n\\n        \\n        return pairs;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3370295,
                "title": "simple-14-lines-of-code-in-o-n-logn",
                "content": "# NOTE:\\n**Please go through the Intution and Approach before jumping to the code. You will definitely get it!**\\nSuggested to write things on notebook while reading.\\n\\n# Intuition & Approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIn the question, we can see a basic pattern that we have to search a value for every element in spell. If we do this searching linearly for all n elements of spell (m times).\\n\\nIt will give us complexity of `O(n*m)`. This complexity can be reduced to  `O(n * logm)`  by using binary search. But before that we have to sort the array potions.\\n```C++ []\\nsort(potions.begin(), potions.end());   // sorting array of potions\\n```\\n\\nNow, it is given in the question that we have to find the number of elements in potions that multiply with spell[i] to give value >= success.\\n\\nIn simple words: \\n$$spells[i] * potions[j]  >=  success$$\\n\\nTaking spells[i] on R.H.S. we get:\\n$$potions[j] >= success / spells[i]$$\\n\\nSo minimum possible value of potion for spells[i] is `success / spells[i]`. Now, it is clear that we have to find **$$lower bound$$** in our already sorted array of potions. And we know,  all the elements after this lower bound in the potions array will be greater (as the array is sorted in increasing order), so we will get the answer by doing m - lower bound.\\n```\\nans[i] = m - lower_bound_ind;\\n```\\nPlease check the code below.\\n\\n\\n\\n# Complexity\\n- Time complexity: O(n logm)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Please Upvote if it was helpfull.!\\uD83D\\uDE03\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        int n = spells.size(), m = potions.size();\\n        sort(potions.begin(), potions.end());\\n        vector<int> ans(n);\\n        for (int i{}; i<n; ++i){\\n            long long potion = ceil((double)success/spells[i]);\\n            int lower_bound_ind = lower_bound(potions.begin(), potions.end(), potion) - potions.begin();\\n            ans[i] = m-lower_bound_ind;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math",
                    "Binary Search",
                    "Sort"
                ],
                "code": "```C++ []\\nsort(potions.begin(), potions.end());   // sorting array of potions\\n```\n```\\nans[i] = m - lower_bound_ind;\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        int n = spells.size(), m = potions.size();\\n        sort(potions.begin(), potions.end());\\n        vector<int> ans(n);\\n        for (int i{}; i<n; ++i){\\n            long long potion = ceil((double)success/spells[i]);\\n            int lower_bound_ind = lower_bound(potions.begin(), potions.end(), potion) - potions.begin();\\n            ans[i] = m-lower_bound_ind;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3370276,
                "title": "easy-java-binary-search-beats-85",
                "content": "# Intuition\\nSolution using basic Binary Search\\n\\n# Approach\\n1. sort the potion array\\n2. now iterate for the spell array\\n3. binary search the index where the multiple of spell*potion>=success\\n4. now from that index onwards rest potions will be surely >=success because they are arranged in increasing order\\n# Complexity\\n- Time complexity:\\nO(NlogM)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] successfulPairs(int[] s, int[] p, long sus) {\\n        Arrays.sort(p);\\n        int n = s.length;\\n        int m = p.length;\\n        int[] ans = new int[n];\\n        for(int i=0;i<n;i++){\\n            ans[i] =m-search(p,sus,m,s[i]);\\n        }\\n        return ans;\\n    }\\n\\n    int search(int[] p ,long t ,int size, int given){\\n        int s =0;\\n        int e = size-1;\\n        while(s<=e){\\n            int mid = (s+e)/2;\\n            long mul = (long)given*p[mid];\\n            if(mul>=t){\\n                e = mid-1;\\n            }else{\\n                s = mid+1;\\n            }\\n\\n        }\\n        return s;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] successfulPairs(int[] s, int[] p, long sus) {\\n        Arrays.sort(p);\\n        int n = s.length;\\n        int m = p.length;\\n        int[] ans = new int[n];\\n        for(int i=0;i<n;i++){\\n            ans[i] =m-search(p,sus,m,s[i]);\\n        }\\n        return ans;\\n    }\\n\\n    int search(int[] p ,long t ,int size, int given){\\n        int s =0;\\n        int e = size-1;\\n        while(s<=e){\\n            int mid = (s+e)/2;\\n            long mul = (long)given*p[mid];\\n            if(mul>=t){\\n                e = mid-1;\\n            }else{\\n                s = mid+1;\\n            }\\n\\n        }\\n        return s;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3369698,
                "title": "binary-search-approach-java-solution",
                "content": "\\n# Java Code\\n```\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        int pairs[] = new int[spells.length];\\n\\n        Arrays.sort(potions);\\n\\n        for(int i = 0; i < spells.length; i++)\\n        {\\n            int start = 0, end = potions.length-1;\\n            while(start <= end)\\n            {\\n                int mid = start + (end - start)/2;\\n                if(potions[mid] * (long)spells[i] >= success)\\n                {\\n                    end = mid - 1;\\n                }\\n                else\\n                {\\n                    start = mid + 1;\\n                }\\n            }\\n            pairs[i] = potions.length - start;\\n        }\\n\\n        return pairs;\\n    }\\n}\\n```\\n\\n# PLEASE UPVOTE \\uD83D\\uDC4D",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        int pairs[] = new int[spells.length];\\n\\n        Arrays.sort(potions);\\n\\n        for(int i = 0; i < spells.length; i++)\\n        {\\n            int start = 0, end = potions.length-1;\\n            while(start <= end)\\n            {\\n                int mid = start + (end - start)/2;\\n                if(potions[mid] * (long)spells[i] >= success)\\n                {\\n                    end = mid - 1;\\n                }\\n                else\\n                {\\n                    start = mid + 1;\\n                }\\n            }\\n            pairs[i] = potions.length - start;\\n        }\\n\\n        return pairs;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3369619,
                "title": "easy-explanation-binary-search-approach",
                "content": "# Approach\\n1. Brute Force approach to solve this problem is to use a **nested loop**, where the outer loop iterates over the \"spells\" vector and the inner loop iterates over the \"potions\" vector. For each pair (s, p), the product s * p is checked against the target. If the product is greater than or equal to the target, then the pair is considered successful and the count is incremented.\\nHowever, this approach has a time complexity of **O(n^2)**, which is inefficient for large values of n.\\n2. A more efficient approach is to first sort the \"potions\" vector in non-decreasing order. This allows us to perform ***binary search*** on the sorted \"potions\" vector to ***find the index of the last element*** that satisfies the condition ***s * p >= target*** for a given s->element.\\n Then, for each element s in the \"spells\" vector, we can use binary search to find the number of elements in the \"potions\" vector that satisfy the condition s * p >= target. This can be done by finding the index of the last element in the \"potions\" vector that satisfies the condition using binary search, and subtracting this index from the total number of elements in the \"potions\" vector.\\n\\n# Complexity\\n- Time complexity:    O(n log n)\\n- Space Complexity:   O(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int getPairCount(vector<int>& potions, int& spell, long long& target)\\n    {\\n        int n = potions.size(), bestIdx = n;\\n        int low = 0, high = n - 1;\\n        \\n        while(low <= high)\\n        {\\n            int mid = low + (high - low) / 2;\\n            long long product = (long long)spell * potions[mid];\\n            \\n            if (product >= target)\\n            {\\n                bestIdx = mid;\\n                high = mid - 1;\\n            }\\n            else low = mid + 1;\\n        }\\n       \\n        return (n - bestIdx);\\n    }\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success)\\n    {\\n        int n = spells.size();\\n        vector<int>v(n);\\n        sort(potions.begin(), potions.end());\\n        for (int i = 0; i < n; i++) \\n            ans[i] = getPairCount(potions, spells[i], success);\\n        \\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getPairCount(vector<int>& potions, int& spell, long long& target)\\n    {\\n        int n = potions.size(), bestIdx = n;\\n        int low = 0, high = n - 1;\\n        \\n        while(low <= high)\\n        {\\n            int mid = low + (high - low) / 2;\\n            long long product = (long long)spell * potions[mid];\\n            \\n            if (product >= target)\\n            {\\n                bestIdx = mid;\\n                high = mid - 1;\\n            }\\n            else low = mid + 1;\\n        }\\n       \\n        return (n - bestIdx);\\n    }\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success)\\n    {\\n        int n = spells.size();\\n        vector<int>v(n);\\n        sort(potions.begin(), potions.end());\\n        for (int i = 0; i < n; i++) \\n            ans[i] = getPairCount(potions, spells[i], success);\\n        \\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3369587,
                "title": "python3-one-line-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\\n        return potions.sort() or [len(potions) - bisect_left(potions, -(-success // spell)) for spell in spells]\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\\n        return potions.sort() or [len(potions) - bisect_left(potions, -(-success // spell)) for spell in spells]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3369441,
                "title": "easy-and-fast-c-solution-with-full-explanation",
                "content": "# Intuition\\nsorting the potions array to reduce the number of operations to search(binary search) for the element whose product with ith spell is greater than or equal to the success.\\n\\n# Approach\\n1. sort `potions` array.\\n2. use `binary search` to search for the element whose product with that spell is equal or just greater than `success`.\\n3. count all the elements after that element *(including that element)* in `potions` array as all the elements after this element are greater than it and hence will result in greater product than `success`.\\n4. store that count in an `ans` vector.\\n5. return `ans`.\\n\\n# Complexity\\n- Time complexity:\\n`O(n*logm)`\\n\\n- Space complexity:\\n`O(n)`\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        int n = spells.size();\\n        int m = potions.size();\\n        sort(potions.begin(), potions.end());\\n        vector<int> ans;\\n        for(auto &i: spells){\\n            int j = 0;\\n            int k = m-1;\\n            while(j<=k){\\n                int mid = (j+k)/2;\\n                int long x = potions[mid];\\n                if(i*x<success){\\n                    j = mid + 1;\\n                }\\n                else{\\n                    k = mid - 1;\\n                }\\n            }\\n            ans.push_back(m-k-1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        int n = spells.size();\\n        int m = potions.size();\\n        sort(potions.begin(), potions.end());\\n        vector<int> ans;\\n        for(auto &i: spells){\\n            int j = 0;\\n            int k = m-1;\\n            while(j<=k){\\n                int mid = (j+k)/2;\\n                int long x = potions[mid];\\n                if(i*x<success){\\n                    j = mid + 1;\\n                }\\n                else{\\n                    k = mid - 1;\\n                }\\n            }\\n            ans.push_back(m-k-1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3368952,
                "title": "c-solution-with-explanation-let-s-code-it",
                "content": "# Upvote if you found this solution helpful\\uD83D\\uDD25\\n\\n# Approach\\nThe first approach which comes to mind after reading the question is to traverse the Potions array for each spell and count the number of pairs which satisfies the given condition, but this method leads to TLE because the time complexity for this will be O(n x m) where both n and m are of order 10^5.\\nSo, the optimized approach is to reduce the number of calculations we are doing for each spell.\\nIf we think for second we can deduce that by sorting the list of potions and using binary search to traverse the list we can reduce our calculations in a significant way.\\n\\nNOTE: Keep in mind to convert the product of spell and potion to LONG LONG before further moving with calculations\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int countPairs(int spell, vector<int> &potions, long long success){\\n        int n = potions.size();\\n        int index = n;\\n        int start = 0;\\n        int end = n-1;\\n\\n        while(start <= end){\\n            int mid = start + (end-start)/2;\\n\\n            //if the product of potion and spell satisfies the condition, move the end pointer to mid-1 because we need to find the first element for which the product of spell and potion is greater than success\\n            if((long long)potions[mid]*spell >= success){\\n                index = mid;\\n                end = mid-1;\\n            }\\n\\n            //if the product is less than the success value move to start pointer to mid+1\\n            if((long long)potions[mid]*spell < success)\\n                start = mid+1;\\n        }\\n\\n        return n-index;\\n    }\\n\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        vector<int> ans(spells.size());\\n\\n        //sorting the potions list\\n        sort(potions.begin(), potions.end());\\n\\n        //for each spell find the number of potions which can satisfy the condition\\n        for(int i=0; i<spells.size(); i++)\\n            ans[i] = countPairs(spells[i], potions, success);\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int countPairs(int spell, vector<int> &potions, long long success){\\n        int n = potions.size();\\n        int index = n;\\n        int start = 0;\\n        int end = n-1;\\n\\n        while(start <= end){\\n            int mid = start + (end-start)/2;\\n\\n            //if the product of potion and spell satisfies the condition, move the end pointer to mid-1 because we need to find the first element for which the product of spell and potion is greater than success\\n            if((long long)potions[mid]*spell >= success){\\n                index = mid;\\n                end = mid-1;\\n            }\\n\\n            //if the product is less than the success value move to start pointer to mid+1\\n            if((long long)potions[mid]*spell < success)\\n                start = mid+1;\\n        }\\n\\n        return n-index;\\n    }\\n\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        vector<int> ans(spells.size());\\n\\n        //sorting the potions list\\n        sort(potions.begin(), potions.end());\\n\\n        //for each spell find the number of potions which can satisfy the condition\\n        for(int i=0; i<spells.size(); i++)\\n            ans[i] = countPairs(spells[i], potions, success);\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3368830,
                "title": "python-short-and-clean-2-liner-functional-programming",
                "content": "# Approach\\n1. Sort `potions` into, say `s_potions`.\\n\\n2. For each `spells`, say `x`, binary-search for insertion index `i` in `s_potions`.\\n\\n3. Return `len(potions) - i`.\\n\\n# Complexity\\n- Time complexity: $$O((m + n) * log(n))$$\\n\\n- Space complexity: $$O(m + n)$$\\n\\nwhere,\\n`m is number of spells`,\\n`n is number of potions`.\\n\\n# Code\\nWIth currying (partial functions):\\n```python\\nclass Solution:\\n    def successfulPairs(self, spells: list[int], potions: list[int], success: int) -> list[int]:\\n        f = partial(bisect.bisect_left, sorted(potions))\\n        return (len(potions) - f(success / x) for x in spells)\\n\\n\\n```\\nWithout using currying (partial functions):\\n```python\\nclass Solution:\\n    def successfulPairs(self, spells: list[int], potions: list[int], success: int) -> list[int]:\\n        s_potions = sorted(potions)\\n        return (len(potions) - bisect.bisect_left(s_potions, success / x) for x in spells)\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```python\\nclass Solution:\\n    def successfulPairs(self, spells: list[int], potions: list[int], success: int) -> list[int]:\\n        f = partial(bisect.bisect_left, sorted(potions))\\n        return (len(potions) - f(success / x) for x in spells)\\n\\n\\n```\n```python\\nclass Solution:\\n    def successfulPairs(self, spells: list[int], potions: list[int], success: int) -> list[int]:\\n        s_potions = sorted(potions)\\n        return (len(potions) - bisect.bisect_left(s_potions, success / x) for x in spells)\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3368195,
                "title": "clear-c-binary-search-beats-95-4",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAfter sort potions, this problem becomes to: for each spells[i], find the first index in potions that spells[i] * potions[index] >= success. Then the pair that spells[i] can form is potions.Length - index\\n\\nFind the first index match a condition is a typical binary search question.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(mlogm + nlogm)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\npublic class Solution {\\n    public int[] SuccessfulPairs(int[] spells, int[] potions, long success) {\\n             Array.Sort(potions);\\n            int[] retval = new int[spells.Length];\\n            for(int i = 0; i < spells.Length; i++)\\n            {\\n                int l = 0, r = potions.Length - 1;\\n                int leftMostIdx = -1;\\n                while(l <= r)\\n                {\\n                    int m = (l + r) / 2;\\n                    if (((long)spells[i]) * potions[m] >= success)\\n                    {\\n                        leftMostIdx = m;\\n                        r = m - 1;\\n                    }\\n                    else l = m + 1;\\n                }\\n                retval[i] = leftMostIdx == -1 ? 0 : potions.Length - leftMostIdx;\\n            }\\n\\n            return retval;       \\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int[] SuccessfulPairs(int[] spells, int[] potions, long success) {\\n             Array.Sort(potions);\\n            int[] retval = new int[spells.Length];\\n            for(int i = 0; i < spells.Length; i++)\\n            {\\n                int l = 0, r = potions.Length - 1;\\n                int leftMostIdx = -1;\\n                while(l <= r)\\n                {\\n                    int m = (l + r) / 2;\\n                    if (((long)spells[i]) * potions[m] >= success)\\n                    {\\n                        leftMostIdx = m;\\n                        r = m - 1;\\n                    }\\n                    else l = m + 1;\\n                }\\n                retval[i] = leftMostIdx == -1 ? 0 : potions.Length - leftMostIdx;\\n            }\\n\\n            return retval;       \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3367859,
                "title": "c-sort-and-lower-bound",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& s, vector<int>& p, long long success) {\\n        int n = s.size(), m = p.size();\\n        sort(p.begin(), p.end());\\n        vector<int> res(n);\\n        for (int i = 0; i < n; i += 1) {\\n            long long x = (success + s[i] - 1) / s[i];\\n            if (x > p.back()) continue;\\n            auto it = lower_bound(p.begin(), p.end(), (int)x);\\n            res[i] = m - (it - p.begin());\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& s, vector<int>& p, long long success) {\\n        int n = s.size(), m = p.size();\\n        sort(p.begin(), p.end());\\n        vector<int> res(n);\\n        for (int i = 0; i < n; i += 1) {\\n            long long x = (success + s[i] - 1) / s[i];\\n            if (x > p.back()) continue;\\n            auto it = lower_bound(p.begin(), p.end(), (int)x);\\n            res[i] = m - (it - p.begin());\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2750229,
                "title": "easiest-best-solution-in-c-binarysearch",
                "content": "# Complexity\\n- Time complexity:\\nO(nlogm)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n**Please Upvote if u liked my Solution**\\uD83D\\uDE42\\n```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        int n=spells.size(),m=potions.size();\\n        vector<int> pairs;\\n        sort(potions.begin(),potions.end());\\n        for(int i=0;i<n;i++){\\n            if(spells[i]>=success){\\n                pairs.push_back(m);\\n                continue;\\n            }\\n            int ll=0,ul=m-1,mid;\\n            while(ll<=ul){\\n                mid =ll+(ul-ll)/2;\\n                long long product=(long long)potions[mid]*spells[i];\\n                if(product>=success)\\n                    ul=mid-1;\\n                else\\n                    ll=mid+1;\\n            }\\n            pairs.push_back(m-ll);\\n        }\\n        return pairs;\\n    }\\n};\\n```\\n**Happy LeetCoding\\uD83D\\uDCAF\\nPlease Upvote**",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        int n=spells.size(),m=potions.size();\\n        vector<int> pairs;\\n        sort(potions.begin(),potions.end());\\n        for(int i=0;i<n;i++){\\n            if(spells[i]>=success){\\n                pairs.push_back(m);\\n                continue;\\n            }\\n            int ll=0,ul=m-1,mid;\\n            while(ll<=ul){\\n                mid =ll+(ul-ll)/2;\\n                long long product=(long long)potions[mid]*spells[i];\\n                if(product>=success)\\n                    ul=mid-1;\\n                else\\n                    ll=mid+1;\\n            }\\n            pairs.push_back(m-ll);\\n        }\\n        return pairs;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2444760,
                "title": "js-binary-search-runtime-83-33",
                "content": "```\\nvar successfulPairs = function(spells, potions, success) {\\n\\tlet res = [];\\n\\tpotions.sort((a, b) => a - b);\\n\\tfor (let i = 0; i < spells.length; i++) {\\n\\t\\tlet h = potions.length-1, l = 0, mid;\\n\\t\\twhile (l <= h) {\\n\\t\\t\\tmid = ~~(l + (h-l)/2);\\n\\t\\t\\tif (spells[i] * potions[mid] >= success) h = mid-1;\\n\\t\\t\\telse l = mid+1;\\n\\t\\t}\\n\\t\\tres[i] = potions.length-1 - h;\\n\\t}\\n\\treturn res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Binary Tree"
                ],
                "code": "```\\nvar successfulPairs = function(spells, potions, success) {\\n\\tlet res = [];\\n\\tpotions.sort((a, b) => a - b);\\n\\tfor (let i = 0; i < spells.length; i++) {\\n\\t\\tlet h = potions.length-1, l = 0, mid;\\n\\t\\twhile (l <= h) {\\n\\t\\t\\tmid = ~~(l + (h-l)/2);\\n\\t\\t\\tif (spells[i] * potions[mid] >= success) h = mid-1;\\n\\t\\t\\telse l = mid+1;\\n\\t\\t}\\n\\t\\tres[i] = potions.length-1 - h;\\n\\t}\\n\\treturn res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2139975,
                "title": "o-n-m-approach-c-without-binary-search-and-sort-easy-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        int maxi = 0;\\n        unordered_map<int,int> dp;\\n        for(int i = 0 ; i<potions.size() ; i++){\\n            dp[potions[i]]++;\\n            maxi = max(potions[i],maxi);\\n        }\\n        \\n        vector<int> refer(maxi+1);\\n        \\n        refer[refer.size()-1] = dp[refer.size()-1];\\n        \\n        for(int i = refer.size()-2 ; i >= 0 ; i--){\\n            refer[i] = refer[i+1] + dp[i];\\n        }\\n        \\n        vector<int> result(spells.size());\\n        \\n        for(int i = 0 ; i < spells.size() ; i++){\\n            double t1 = success;\\n            double t2 = spells[i];\\n            long long temp = ceil(t1/t2);\\n            if(temp > maxi){\\n                result[i] = 0;\\n                continue;\\n            }\\n            result[i]= refer[temp];\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        int maxi = 0;\\n        unordered_map<int,int> dp;\\n        for(int i = 0 ; i<potions.size() ; i++){\\n            dp[potions[i]]++;\\n            maxi = max(potions[i],maxi);\\n        }\\n        \\n        vector<int> refer(maxi+1);\\n        \\n        refer[refer.size()-1] = dp[refer.size()-1];\\n        \\n        for(int i = refer.size()-2 ; i >= 0 ; i--){\\n            refer[i] = refer[i+1] + dp[i];\\n        }\\n        \\n        vector<int> result(spells.size());\\n        \\n        for(int i = 0 ; i < spells.size() ; i++){\\n            double t1 = success;\\n            double t2 = spells[i];\\n            long long temp = ceil(t1/t2);\\n            if(temp > maxi){\\n                result[i] = 0;\\n                continue;\\n            }\\n            result[i]= refer[temp];\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2139392,
                "title": "java-clean-code-binary-search",
                "content": "```\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        \\n        Arrays.sort(potions);\\n        int[] res=new int[spells.length];\\n        \\n        for(int i=0;i<spells.length;i++)\\n        {\\n            int count=binarySearch(spells[i],potions,success);\\n            res[i]=count;\\n        }\\n        \\n        return res;\\n    }\\n    \\n    public static int binarySearch(int spell, int[] potions, long success)\\n    {\\n        int i=0;\\n        int j=potions.length-1;\\n        int n=potions.length;\\n        \\n        int res=0;\\n        \\n        while(i<=j)\\n        {\\n            int mid=(i+j)/2;\\n            \\n            if((spell*1.0)*potions[mid]>=success)\\n            {\\n                res=n-mid;\\n                j=mid-1;\\n            }\\n            \\n            else\\n            {\\n                i=mid+1;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        \\n        Arrays.sort(potions);\\n        int[] res=new int[spells.length];\\n        \\n        for(int i=0;i<spells.length;i++)\\n        {\\n            int count=binarySearch(spells[i],potions,success);\\n            res[i]=count;\\n        }\\n        \\n        return res;\\n    }\\n    \\n    public static int binarySearch(int spell, int[] potions, long success)\\n    {\\n        int i=0;\\n        int j=potions.length-1;\\n        int n=potions.length;\\n        \\n        int res=0;\\n        \\n        while(i<=j)\\n        {\\n            int mid=(i+j)/2;\\n            \\n            if((spell*1.0)*potions[mid]>=success)\\n            {\\n                res=n-mid;\\n                j=mid-1;\\n            }\\n            \\n            else\\n            {\\n                i=mid+1;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2139292,
                "title": "python-binary-search-explanation",
                "content": "I Was Also One Of The Person Who Got TLE At The First Attempt\\n\\nThe Straight Forward Approach was to multiply each and every value of potion with the every value of spell and count the values which are greater than success and append to the answer array. This was one of the common solution which every one thinks of..\\n\\nThe Solution For Me Which Got Accepted Was After Using Binary Search With Sorting Array.\\n\\nLet Us See How It Worked For Me..\\n\\nSuppose spell = [5,1,3] potions = [1,2,3,4,5]  success = 7\\n\\nConsider First Element Of Spell - 5  the least number that makes 5 after multiplying results to greater than or equal to  7 that is obviously 2 - So the resultant value will be 4 \\n\\nConsider Second Element Of Spell -1 The Smallest Number That Makes Greater Than or equal to 7 is 7 but it is not in the array so the resultant value will be 0\\n\\nConsider Last Element Of Spell - 3 The Smallest Number That Makes 3 Greater Than Or Equal To 7 is 3 - So the Resultant Value will be 3\\n\\nSimilarly For Every Value in Spell If We Are Able To Find The Smaller Value Which After Multiplying Makes Greater Than Success Value And Then We Had To Find The Left Most Index Which Will Be Suitable For Placing The Obtained Value In The Potions Will Result Us Answer.\\n\\nThis is my following Code For The Problem..\\n\\n```\\nclass Solution:\\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\\n        result = self.function(spells,potions,success)\\n        return result\\n    \\n    def function(self,arr1,arr2,success):\\n        n2 = len(arr2)\\n        arr2.sort() #Sorting Enables Us To Do Binary Search\\n        ans = []\\n        for i in arr1:\\n            val = math.ceil(success/i) #Finding the Value Of Portion With Least Strength So That It Can Be Greater Than Success\\n            idx = bisect.bisect_left(arr2,val) #Finding The Left Most Index So That The Value Can Be Inserted\\n            res = n2-idx+1  #Calculating the remaining numbers after finding the suitable index\\n            ans.append(res-1)\\n        return ans\\n```\\n\\nPlease Upvote If You Like The Explanation..\\uD83D\\uDE0A\\n\\n\\nHappy LeetCoding!!!!",
                "solutionTags": [
                    "Python",
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\\n        result = self.function(spells,potions,success)\\n        return result\\n    \\n    def function(self,arr1,arr2,success):\\n        n2 = len(arr2)\\n        arr2.sort() #Sorting Enables Us To Do Binary Search\\n        ans = []\\n        for i in arr1:\\n            val = math.ceil(success/i) #Finding the Value Of Portion With Least Strength So That It Can Be Greater Than Success\\n            idx = bisect.bisect_left(arr2,val) #Finding The Left Most Index So That The Value Can Be Inserted\\n            res = n2-idx+1  #Calculating the remaining numbers after finding the suitable index\\n            ans.append(res-1)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2139016,
                "title": "binary-search-python-easy-to-understand",
                "content": "Idea:\\nThe pretty straightforward solution, sort potions and for each spell find an index of minimal potions that will make success and we know that everything greater will make a success too. \\n\\n\\n```\\nclass Solution:\\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\\n        potions.sort()\\n        ans = []\\n        for i in spells:\\n            cur = success/i\\n            ans.append(len(potions)-bisect.bisect_left(potions, cur))\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\\n        potions.sort()\\n        ans = []\\n        for i in spells:\\n            cur = success/i\\n            ans.append(len(potions)-bisect.bisect_left(potions, cur))\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2138968,
                "title": "priority-queue-c-max-heap-easy-understanding-simple",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        vector<int> ans;\\n        priority_queue<int> pq;\\n        unordered_map<int,int> mp;\\n        for(int i=0;i<potions.size();i++)\\n            pq.push(potions[i]);\\n        vector<int> spells1=spells;\\n        sort(spells.begin(),spells.end());\\n        int cnt=0;\\n        for(int i=0;i<=spells.size()-1;i++)\\n        {\\n            while(!pq.empty())\\n            {\\n                int x=pq.top();\\n                if((long long) x* (long long) spells[i]>=success) {cnt++; pq.pop();}\\n                else\\n                  break;\\n            }\\n            mp[spells[i]]=cnt;\\n        }\\n        for(int i=0;i<spells.size();i++)\\n        {\\n            ans.push_back(mp[spells1[i]]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        vector<int> ans;\\n        priority_queue<int> pq;\\n        unordered_map<int,int> mp;\\n        for(int i=0;i<potions.size();i++)\\n            pq.push(potions[i]);\\n        vector<int> spells1=spells;\\n        sort(spells.begin(),spells.end());\\n        int cnt=0;\\n        for(int i=0;i<=spells.size()-1;i++)\\n        {\\n            while(!pq.empty())\\n            {\\n                int x=pq.top();\\n                if((long long) x* (long long) spells[i]>=success) {cnt++; pq.pop();}\\n                else\\n                  break;\\n            }\\n            mp[spells[i]]=cnt;\\n        }\\n        for(int i=0;i<spells.size();i++)\\n        {\\n            ans.push_back(mp[spells1[i]]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2138935,
                "title": "sort-potions-and-apply-binary-search-c-sorting",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long k) {\\n        sort(potions.begin(),potions.end());\\n        int n = spells.size(), m = potions.size();\\n        int i = 0, j = 0;\\n        vector<int> res;\\n        for(int i=0;i<n;i++){\\n            int l = 0, h = m;\\n            long long c1 = spells[i];\\n            while(l<h){\\n                int mid = (l+h)/2;\\n                long long c2 = potions[mid];\\n                long long cur = c1*c2;\\n                if(cur<k) l = mid+1;\\n                else if(cur>=k) h = mid;\\n            }\\n            res.push_back(m-h);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long k) {\\n        sort(potions.begin(),potions.end());\\n        int n = spells.size(), m = potions.size();\\n        int i = 0, j = 0;\\n        vector<int> res;\\n        for(int i=0;i<n;i++){\\n            int l = 0, h = m;\\n            long long c1 = spells[i];\\n            while(l<h){\\n                int mid = (l+h)/2;\\n                long long c2 = potions[mid];\\n                long long cur = c1*c2;\\n                if(cur<k) l = mid+1;\\n                else if(cur>=k) h = mid;\\n            }\\n            res.push_back(m-h);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2138781,
                "title": "ceil-binary-search",
                "content": "\\ttypedef long long ll;\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tvector<int> successfulPairs(vector<int>& spells, vector<int>& portions, long long success) {\\n\\t\\t\\tsort(begin(portions),end(portions));\\n\\t\\t\\tvector<int>res;\\n\\t\\t\\tint m = portions.size();\\n\\t\\t\\tfor(auto num:spells){\\n\\t\\t\\t\\tif(success/num>=100001){\\n\\t\\t\\t\\t\\tres.push_back(0);\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tint n = success/num + (success%num!=0);\\n\\t\\t\\t\\tint i = lower_bound(begin(portions),end(portions),n)-begin(p);\\n\\t\\t\\t\\tres.push_back(m-i);\\n\\t\\t\\t}\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tvector<int> successfulPairs(vector<int>& spells, vector<int>& portions, long long success) {\\n\\t\\t\\tsort(begin(portions),end(portions));\\n\\t\\t\\tvector<int>res;\\n\\t\\t\\tint m = portions.size();\\n\\t\\t\\tfor(auto num:spells){\\n\\t\\t\\t\\tif(success/num>=100001){\\n\\t\\t\\t\\t\\tres.push_back(0);\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 4012507,
                "title": "successful-pairs-of-spells-and-potions-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        int n=potions.size();\\n        sort(potions.begin(), potions.end());\\n        vector<int> ans;\\n        for(long it: spells)\\n        {\\n            int start=0;\\n            int end=n-1;\\n            int count=0;\\n            \\n            while(start<=end)\\n            {\\n                int mid=(start+end)/2;\\n                if(it*potions[mid]>=success)\\n                {\\n                    count+=end-mid+1;\\n                    end=mid-1;\\n                }\\n                else\\n                    start=mid+1;\\n            }\\n            ans.push_back(count);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        int n=potions.size();\\n        sort(potions.begin(), potions.end());\\n        vector<int> ans;\\n        for(long it: spells)\\n        {\\n            int start=0;\\n            int end=n-1;\\n            int count=0;\\n            \\n            while(start<=end)\\n            {\\n                int mid=(start+end)/2;\\n                if(it*potions[mid]>=success)\\n                {\\n                    count+=end-mid+1;\\n                    end=mid-1;\\n                }\\n                else\\n                    start=mid+1;\\n            }\\n            ans.push_back(count);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3777754,
                "title": "c-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        int n=potions.size();\\n        sort(potions.begin(), potions.end());\\n        vector<int> ans;\\n        for(long it: spells)\\n        {\\n            int start=0;\\n            int end=n-1;\\n            int count=0;\\n            \\n            while(start<=end)\\n            {\\n                int mid=(start+end)/2;\\n                if(it*potions[mid]>=success)\\n                {\\n                    count+=end-mid+1;\\n                    end=mid-1;\\n                }\\n                else\\n                    start=mid+1;\\n            }\\n            ans.push_back(count);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        int n=potions.size();\\n        sort(potions.begin(), potions.end());\\n        vector<int> ans;\\n        for(long it: spells)\\n        {\\n            int start=0;\\n            int end=n-1;\\n            int count=0;\\n            \\n            while(start<=end)\\n            {\\n                int mid=(start+end)/2;\\n                if(it*potions[mid]>=success)\\n                {\\n                    count+=end-mid+1;\\n                    end=mid-1;\\n                }\\n                else\\n                    start=mid+1;\\n            }\\n            ans.push_back(count);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3374919,
                "title": "java-solution-binary-search-technique",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis code takes two arrays, spells and potions, and a success value as input. It then sorts the potions array and creates a new integer array pairs with the same length as the spells array.\\n\\nFor each element spells[i] in the spells array, the code performs a binary search on the potions array to find the largest index low such that the product of spells[i] and the potion at index low is less than success. This is done by comparing the product of spells[i] and the middle element of the remaining subarray with success, and narrowing the search space accordingly.\\n\\nOnce the binary search is completed, the code sets pairs[i] to the number of elements in the potions array that are greater than or equal to potions[low]. Since the potions array is sorted in ascending order, this value corresponds to the number of pairs of spells[i] and potions[j] such that their product is greater than or equal to success.\\n\\nThe pairs array is then returned as the result.\\n\\nIn summary, the code computes the number of successful pairs of spells and potions, where a pair is considered successful if the product of the two elements is greater than or equal to a given threshold success.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBinary Search\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public static int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        Arrays.sort(potions);\\n        int[] pairs = new int[spells.length];\\n        for (int i = 0; i < spells.length; i++) {\\n            int low = 0, high = potions.length - 1;\\n            while (low <= high) {\\n                int mid = (low + high) / 2;\\n                if ((long) spells[i] * potions[mid] >= success) {\\n                    high = mid - 1;\\n                } else {\\n                    low = mid + 1;\\n                }\\n            }\\n            pairs[i] = potions.length - low;\\n        }\\n        return pairs;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public static int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        Arrays.sort(potions);\\n        int[] pairs = new int[spells.length];\\n        for (int i = 0; i < spells.length; i++) {\\n            int low = 0, high = potions.length - 1;\\n            while (low <= high) {\\n                int mid = (low + high) / 2;\\n                if ((long) spells[i] * potions[mid] >= success) {\\n                    high = mid - 1;\\n                } else {\\n                    low = mid + 1;\\n                }\\n            }\\n            pairs[i] = potions.length - low;\\n        }\\n        return pairs;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3372258,
                "title": "using-binary-search-in-javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf you divide each element of potions from the success, you can get some information about how much the spell should be. Then by sorting the new array and using binary search you can find the number of element which is less than or equal to the spell\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n\\n# If you like, please upvote!\\n\\n# Code\\n```\\n/**\\n * @param {number[]} spells\\n * @param {number[]} potions\\n * @param {number} success\\n * @return {number[]}\\n */\\nvar successfulPairs = function(spells, potions, success) {\\n    let arr = [];\\n    for(let potion of potions) {\\n        arr.push(Math.ceil(success / potion));\\n    }\\n    arr.sort((a,b) => a-b);\\n    const n = arr.length;\\n    console.log(arr);\\n\\n    const res = [];\\n    for(let spell of spells) {\\n        let l=0, r=n-1, M=0;\\n        while(l<=r) {\\n            let m = Math.floor((l+r)/2);\\n            if(arr[m] <= spell) {\\n                l = m+1;\\n                M = l;\\n            } else {\\n                r = m-1;\\n            }\\n        }\\n        res.push(M);\\n    }  \\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} spells\\n * @param {number[]} potions\\n * @param {number} success\\n * @return {number[]}\\n */\\nvar successfulPairs = function(spells, potions, success) {\\n    let arr = [];\\n    for(let potion of potions) {\\n        arr.push(Math.ceil(success / potion));\\n    }\\n    arr.sort((a,b) => a-b);\\n    const n = arr.length;\\n    console.log(arr);\\n\\n    const res = [];\\n    for(let spell of spells) {\\n        let l=0, r=n-1, M=0;\\n        while(l<=r) {\\n            let m = Math.floor((l+r)/2);\\n            if(arr[m] <= spell) {\\n                l = m+1;\\n                M = l;\\n            } else {\\n                r = m-1;\\n            }\\n        }\\n        res.push(M);\\n    }  \\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3372158,
                "title": "easy-solutions-in-java-and-c-look-at-once-with-explanation",
                "content": "# Intuition\\nFor each spell, we need to find the number of potions that can form a succesfull pair with it means if we multiple the `spell[i]` with `potions[i]` and the value if `>=` success we can call it successful. We are iterating over all the spells and finding the particular potions from where all the upper potion can be successful and lower than that particular potion rest can\\'t make successful.\\nFor finding that particular point of potions vector we sort it and apply binary search as we can easily trim the search space in every turn.\\n\\n# Approach\\n1. Sort the `potions` in ascending order.\\n2. For each spell `s[i]`, calculate the maximum number of potions that can be paired with it such that their sum is less than or equal to success.\\n- I have created a maxNumber which hold the value of `(spell[i]/success)`, it tells us the minimum number which we should we multiply with `spell[i]` to get the success.\\n- if the `spell[i]` divides the success completely (for eg. 25 is success and we have `spell[i]` with a strength of 5 which mean we need minimum 5 to make success) that\\'s why i did `maxNumber - 1` in the case of `number % success == 0`\\n- else we simply take the ceil of `number / success`\\n- the `low` will has the the index of the number which is just greater than the required number so return `(potions.size() - low)` will gives the count of the number that are greater than it.\\n3. I have used binary search to find the number of potions in `potions` that have a value less than or equal to the maximum number of potions calculated in `step 2`.\\n4. Append the number of potions found in step 3 to the ans vector.\\n\\n# Complexity\\n- Time complexity:-\\nThe time complexity of the `successfulPairs` function is $$O(n log m)$$ where `n` is the length of the spells vector and `m` is the length of the potions vector. The time complexity of the `calculate` function is $$O(log m)$$ where `m` is the length of the potions \\n\\n- Space complexity:-\\nThe space complexity is $$O(1)$$ since they use constant extra space.\\n\\n# C++ Code\\n```\\nclass Solution {\\npublic:\\n\\n    int calculate(int number, vector<int>& potions, long long success){\\n    long long maxNumber;\\n    if (success % number == 0){\\n        maxNumber = (success/number)-1;\\n    }\\n    else{\\n        maxNumber = ceil(success/number);\\n    }\\n    int low = 0;\\n    int high = potions.size() - 1;\\n    while(low <= high){\\n        int mid = (high + low) >> 1;\\n        if (potions[mid] <= maxNumber) low = mid+1;\\n        else high = mid - 1;\\n    }\\n    high = potions.size();\\n    return (high - low);\\n    }\\n\\n\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        sort(potions.begin(), potions.end());\\n        vector<int> ans;\\n        for(int i=0; i<spells.size(); i++){\\n            int pair = calculate(spells[i], potions, success);\\n            ans.push_back(pair);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n# Java Code\\n```\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        int n = spells.length;\\n        int m = potions.length;\\n        int[] pairs = new int[n];\\n        Arrays.sort(potions);\\n        for (int i = 0; i < n; i++) {\\n            int spell = spells[i];\\n            int left = 0;\\n            int right = m - 1;\\n            while (left <= right) {\\n                int mid = left + (right - left) / 2;\\n                long product = (long) spell * potions[mid];\\n                if (product >= success) {\\n                    right = mid - 1;\\n                } else {\\n                    left = mid + 1;\\n                }\\n            }\\n            pairs[i] = m - left;\\n        }\\n        return pairs;\\n    }\\n}\\n```\\n### Read This \\uD83D\\uDC47\\n\\n**Hope it helps you \\uD83D\\uDE0A Keep Learning**\\n- If you didn\\'t understand anything ask in comment as no-one is perfect.\\n\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int calculate(int number, vector<int>& potions, long long success){\\n    long long maxNumber;\\n    if (success % number == 0){\\n        maxNumber = (success/number)-1;\\n    }\\n    else{\\n        maxNumber = ceil(success/number);\\n    }\\n    int low = 0;\\n    int high = potions.size() - 1;\\n    while(low <= high){\\n        int mid = (high + low) >> 1;\\n        if (potions[mid] <= maxNumber) low = mid+1;\\n        else high = mid - 1;\\n    }\\n    high = potions.size();\\n    return (high - low);\\n    }\\n\\n\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        sort(potions.begin(), potions.end());\\n        vector<int> ans;\\n        for(int i=0; i<spells.size(); i++){\\n            int pair = calculate(spells[i], potions, success);\\n            ans.push_back(pair);\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        int n = spells.length;\\n        int m = potions.length;\\n        int[] pairs = new int[n];\\n        Arrays.sort(potions);\\n        for (int i = 0; i < n; i++) {\\n            int spell = spells[i];\\n            int left = 0;\\n            int right = m - 1;\\n            while (left <= right) {\\n                int mid = left + (right - left) / 2;\\n                long product = (long) spell * potions[mid];\\n                if (product >= success) {\\n                    right = mid - 1;\\n                } else {\\n                    left = mid + 1;\\n                }\\n            }\\n            pairs[i] = m - left;\\n        }\\n        return pairs;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3372127,
                "title": "successful-pairs-of-spells-and-potions-python-solution",
                "content": "# Intuition\\n\\n\\n# Approach\\nBinary Search \\n\\n# Complexity\\n- Time complexity: O(logn)\\n\\n- Space complexity: O(1)\\n\\n\\n# Code\\n```\\nclass Solution(object):\\n    def successfulPairs(self, spells, potions, success):\\n        n = len(spells)\\n        m = len(potions)\\n        pairs = [None] * n\\n        potions.sort()\\n        for i in range(n):\\n            spell = spells[i]\\n            left = 0\\n            right = m - 1\\n            while left <= right:\\n                mid = left + (right - left) // 2\\n                product = spell * potions[mid]\\n                if product >= success:\\n                    right = mid - 1\\n                else:\\n                    left = mid + 1\\n            pairs[i] = m - left\\n        return pairs\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def successfulPairs(self, spells, potions, success):\\n        n = len(spells)\\n        m = len(potions)\\n        pairs = [None] * n\\n        potions.sort()\\n        for i in range(n):\\n            spell = spells[i]\\n            left = 0\\n            right = m - 1\\n            while left <= right:\\n                mid = left + (right - left) // 2\\n                product = spell * potions[mid]\\n                if product >= success:\\n                    right = mid - 1\\n                else:\\n                    left = mid + 1\\n            pairs[i] = m - left\\n        return pairs\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3371871,
                "title": "why-this-solution-is-not-accepted",
                "content": "Why This solution is not accepted, I see no TLE\\'s, \\nExactly want to know, why this TC is breaking the logic.\\n\\n\\nAlthough 48 passed out of 56 \\uD83E\\uDD72\\n\\n![Screenshot 2023-04-03 at 12.09.29 AM.png](https://assets.leetcode.com/users/images/caddea78-8146-444a-b0ea-a3215012d623_1680461180.6110756.png)\\n\\nRegards",
                "solutionTags": [
                    "Java"
                ],
                "code": "Why This solution is not accepted, I see no TLE\\'s, \\nExactly want to know, why this TC is breaking the logic.\\n\\n\\nAlthough 48 passed out of 56 \\uD83E\\uDD72\\n\\n![Screenshot 2023-04-03 at 12.09.29 AM.png](https://assets.leetcode.com/users/images/caddea78-8146-444a-b0ea-a3215012d623_1680461180.6110756.png)\\n\\nRegards",
                "codeTag": "Unknown"
            },
            {
                "id": 3371657,
                "title": "easy-cpp-solution-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(N LOG M)\\n\\n- Space complexity:\\n- O(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& arr, vector<int>& nums, long long success) {\\n        sort(nums.begin(),nums.end());\\n        vector<int> msxans;\\n        for(int i = 0;i<arr.size();i++){\\n            int s = 0;\\n            int e = nums.size()-1;\\n            int ans = -1;\\n            while(s<=e){\\n            int mid = s + (e - s)/2;\\n            long long value = (long)nums[mid]*arr[i] ; \\n                if(value >= success){\\n                    ans = mid;\\n                    e = mid - 1;\\n                }\\n                else s = mid + 1;\\n            }\\n            if(ans != -1) {\\n               msxans.push_back(nums.size()-ans);\\n            }\\n            else msxans.push_back(0);\\n        }\\n        return msxans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& arr, vector<int>& nums, long long success) {\\n        sort(nums.begin(),nums.end());\\n        vector<int> msxans;\\n        for(int i = 0;i<arr.size();i++){\\n            int s = 0;\\n            int e = nums.size()-1;\\n            int ans = -1;\\n            while(s<=e){\\n            int mid = s + (e - s)/2;\\n            long long value = (long)nums[mid]*arr[i] ; \\n                if(value >= success){\\n                    ans = mid;\\n                    e = mid - 1;\\n                }\\n                else s = mid + 1;\\n            }\\n            if(ans != -1) {\\n               msxans.push_back(nums.size()-ans);\\n            }\\n            else msxans.push_back(0);\\n        }\\n        return msxans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3370989,
                "title": "day92-binary-search-very-easy-solution",
                "content": "# Intuition and Approach\\nWe have implemented Binary Search to Solve the problem\\n\\nSo, Condition to use binary tree is that array must be sorted\\n\\nSo, we used the inbuilt sort function.\\n\\nNow to solve the problem many of you have already tried to do it in O(n^2) order (Code given below) but it is giving the TLE.\\n```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& s, vector<int>& po, long long success) {\\n        vector<int> v;\\n        int count=0;\\n\\n        for(int i=0;i<s.size();i++){\\n            for(int j=0;j<po.size();j++){\\n                if(s[i]*po[j] >= success){\\n                    count++;\\n                }\\n            }\\n            v.push_back(count);\\n            count=0;\\n        }\\n        return v;\\n    }\\n};\\n```\\n(In above approach we are simply calulating the product of two array and comparing it to Success)\\nSo, to overcome the TLE we have to think a way to minimize our search space and hence Binary Search came into play\\n\\nThere is an **Observation** for sorted array which is that if a current potion muliplied with current spell and if it greater than Success then all elements ahead of that position will be a satisfiable answer.\\n```\\ne.g. spells=[5,3,1] , potion=[1,2,3,4,5] , Success=7\\nAns: 5*1=5, 5*2=10, 5*3=15, 5*4=20, 5*5=25\\n              |\\n              |--from here, all ahead value will be greater than Success\\nSimilarly, 3*1=3, 3*2=6, 3*3=9...\\n                           |\\n                           |--from here, all value satisfy the Success\\n*Hence, we have to calculate or find the leftmost value which satisfies \\nthe relation.\\n```\\nSo, We are using binary search to find that value by using the condition you can check it in the code.\\n\\n**Upvote If you like.**\\n# Complexity\\n- Time complexity:O(n*log(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& s, vector<int>& po, long long success) {\\n        vector<int> v;\\n        //sorting the potion array\\n        sort(po.begin(),po.end());\\n\\n        for(int i=0;i<s.size();i++){\\n            int count=0;\\n            int l=0,r=po.size()-1;\\n            int mid=l + (r-l)/2;\\n            //Using Binary Search on potion array\\n            while(l<=r){\\n                if(s[i]*1ll*po[mid] >= success){//1LL is securely integer overflow\\n                    count=po.size()-mid;\\n                    r=mid-1;\\n                }\\n                else{\\n                    l=mid+1;\\n                }\\n                mid= l + (r-l)/2;\\n            }\\n            v.push_back(count);\\n        }\\n        \\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& s, vector<int>& po, long long success) {\\n        vector<int> v;\\n        int count=0;\\n\\n        for(int i=0;i<s.size();i++){\\n            for(int j=0;j<po.size();j++){\\n                if(s[i]*po[j] >= success){\\n                    count++;\\n                }\\n            }\\n            v.push_back(count);\\n            count=0;\\n        }\\n        return v;\\n    }\\n};\\n```\n```\\ne.g. spells=[5,3,1] , potion=[1,2,3,4,5] , Success=7\\nAns: 5*1=5, 5*2=10, 5*3=15, 5*4=20, 5*5=25\\n              |\\n              |--from here, all ahead value will be greater than Success\\nSimilarly, 3*1=3, 3*2=6, 3*3=9...\\n                           |\\n                           |--from here, all value satisfy the Success\\n*Hence, we have to calculate or find the leftmost value which satisfies \\nthe relation.\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& s, vector<int>& po, long long success) {\\n        vector<int> v;\\n        //sorting the potion array\\n        sort(po.begin(),po.end());\\n\\n        for(int i=0;i<s.size();i++){\\n            int count=0;\\n            int l=0,r=po.size()-1;\\n            int mid=l + (r-l)/2;\\n            //Using Binary Search on potion array\\n            while(l<=r){\\n                if(s[i]*1ll*po[mid] >= success){//1LL is securely integer overflow\\n                    count=po.size()-mid;\\n                    r=mid-1;\\n                }\\n                else{\\n                    l=mid+1;\\n                }\\n                mid= l + (r-l)/2;\\n            }\\n            v.push_back(count);\\n        }\\n        \\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3370506,
                "title": "binary-search-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& S, vector<int>& P, long long k) {\\n        int n = size(P);\\n        sort(begin(P),end(P));\\n        vector<int> ans;\\n        for(long long&&s: S){\\n            long long req = k%s ? k/s+1 : k/s;\\n            int idx = lower_bound(begin(P),end(P),req) - begin(P);\\n            if(idx < n) ans.push_back(n-idx);\\n            else ans.push_back(0);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& S, vector<int>& P, long long k) {\\n        int n = size(P);\\n        sort(begin(P),end(P));\\n        vector<int> ans;\\n        for(long long&&s: S){\\n            long long req = k%s ? k/s+1 : k/s;\\n            int idx = lower_bound(begin(P),end(P),req) - begin(P);\\n            if(idx < n) ans.push_back(n-idx);\\n            else ans.push_back(0);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3370172,
                "title": "simple-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem.\\n -->\\nOnce you figure it out that if you get the smallest potion value multiply by the spell is greater than equal to success in sorted potion array. Then no need to calculate potion[i]*spell[j] for every index. And you can directly calculate number of potion by potion.length - (index of smallest potion greater than or equal to success)\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Sort the potion array in ascending order\\n2. Iterate orver all the spells value.\\n3. Apply binary search on potion array and find the value of mid such that index of smallest potion greater than or equal to success.\\n4. Caluculate answer for each index as potion.length - l(lower index)\\n5. Store the value in result array and return\\n# Complexity\\n- Time complexity: O(nlogm + mlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n) depending upon sorting algorithm\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    public static int bs(int[] potions,int spell, long success){\\n        int l=0;\\n        int r=potions.length-1;\\n\\n        while(l<=r){\\n            int m = l - (l-r)/2;\\n            long mul =(long) potions[m]*spell;\\n            if(mul>=success){\\n                r=m-1;\\n            }\\n            else{\\n                l=m+1;\\n            }\\n        }\\n        return potions.length-l;\\n    }\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        int res[] = new int[spells.length];\\n        Arrays.sort(potions);\\n        for(int i=0;i<spells.length;i++){\\n            res[i] = bs(potions,spells[i],success);\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    public static int bs(int[] potions,int spell, long success){\\n        int l=0;\\n        int r=potions.length-1;\\n\\n        while(l<=r){\\n            int m = l - (l-r)/2;\\n            long mul =(long) potions[m]*spell;\\n            if(mul>=success){\\n                r=m-1;\\n            }\\n            else{\\n                l=m+1;\\n            }\\n        }\\n        return potions.length-l;\\n    }\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        int res[] = new int[spells.length];\\n        Arrays.sort(potions);\\n        for(int i=0;i<spells.length;i++){\\n            res[i] = bs(potions,spells[i],success);\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3370155,
                "title": "java-binary-search-explained",
                "content": "# Intuition:\\nA brute force would\\'ve been easy but the constraints don\\'t let us.\\n\\nWe just need the number of elements in `potions` which when multiplied by a particular number (from `spells`) gives the value greater than or equal to `success`.\\n\\nSo if we sort the array `potions`, we can apply a binary search to reach the starting index in `potions` from where onwards all the products yield value >= `success`.\\n\\nThe number of elements that yields product >= `success` is equal to:\\n`length of potions - starting index`\\n\\n---\\n\\n# Code:\\n```\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        int n = spells.length, m = potions.length;\\n        Arrays.sort(potions);\\n        int[] pairs = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            int startIdx = findStartIndex(spells[i], potions, success);\\n            pairs[i] = m - startIdx;\\n        }\\n        return pairs;\\n    }\\n\\n    private int findStartIndex(int spell, int[] potions, long success) {\\n        int m = potions.length;\\n        int lo = 0, hi = m - 1;\\n        // Initialise the start index as the length of potions array\\n        // because there might be a case when all the potion strengths\\n        // when multiplied by spell strength gave a less product value than success\\n        // so when we do potions.length - startIdx, it will automatically become 0\\n        // because start index will never get updated to a lesser value (mid)\\n        int startIdx = m;\\n        while (lo <= hi) {\\n            int mid = lo + (hi - lo) / 2;\\n            long prod = 1L * spell * potions[mid];\\n            // if product is >= success\\n            if (prod >= success) {\\n                // save this potential start index\\n                startIdx = mid;\\n                // look for a lesser potion strength\\n                hi = mid - 1;\\n            } else {\\n                // product was too less\\n                // go for a greater potion strength\\n                lo = mid + 1;\\n            }\\n        }\\n        return startIdx;\\n    }\\n}\\n```\\n---\\n### Clean solution:\\n```\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        int n = spells.length, m = potions.length;\\n        Arrays.sort(potions);\\n        int[] pairs = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            int startIdx = findStartIndex(spells[i], potions, success);\\n            pairs[i] = m - startIdx;\\n        }\\n        return pairs;\\n    }\\n\\n    private int findStartIndex(int spell, int[] potions, long success) {\\n        int m = potions.length;\\n        int lo = 0, hi = m - 1;\\n        int startIdx = m;\\n        while (lo <= hi) {\\n            int mid = lo + (hi - lo) / 2;\\n            long prod = 1L * spell * potions[mid];\\n            if (prod >= success) {\\n                startIdx = mid;\\n                hi = mid - 1;\\n            } else {\\n                lo = mid + 1;\\n            }\\n        }\\n        return startIdx;\\n    }\\n}\\n```\\n---\\n##### Time complexity: $$O(2.n.logm)$$\\n\\n##### Space complexity: $$O(n)$$",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        int n = spells.length, m = potions.length;\\n        Arrays.sort(potions);\\n        int[] pairs = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            int startIdx = findStartIndex(spells[i], potions, success);\\n            pairs[i] = m - startIdx;\\n        }\\n        return pairs;\\n    }\\n\\n    private int findStartIndex(int spell, int[] potions, long success) {\\n        int m = potions.length;\\n        int lo = 0, hi = m - 1;\\n        // Initialise the start index as the length of potions array\\n        // because there might be a case when all the potion strengths\\n        // when multiplied by spell strength gave a less product value than success\\n        // so when we do potions.length - startIdx, it will automatically become 0\\n        // because start index will never get updated to a lesser value (mid)\\n        int startIdx = m;\\n        while (lo <= hi) {\\n            int mid = lo + (hi - lo) / 2;\\n            long prod = 1L * spell * potions[mid];\\n            // if product is >= success\\n            if (prod >= success) {\\n                // save this potential start index\\n                startIdx = mid;\\n                // look for a lesser potion strength\\n                hi = mid - 1;\\n            } else {\\n                // product was too less\\n                // go for a greater potion strength\\n                lo = mid + 1;\\n            }\\n        }\\n        return startIdx;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        int n = spells.length, m = potions.length;\\n        Arrays.sort(potions);\\n        int[] pairs = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            int startIdx = findStartIndex(spells[i], potions, success);\\n            pairs[i] = m - startIdx;\\n        }\\n        return pairs;\\n    }\\n\\n    private int findStartIndex(int spell, int[] potions, long success) {\\n        int m = potions.length;\\n        int lo = 0, hi = m - 1;\\n        int startIdx = m;\\n        while (lo <= hi) {\\n            int mid = lo + (hi - lo) / 2;\\n            long prod = 1L * spell * potions[mid];\\n            if (prod >= success) {\\n                startIdx = mid;\\n                hi = mid - 1;\\n            } else {\\n                lo = mid + 1;\\n            }\\n        }\\n        return startIdx;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3370136,
                "title": "simple-solution-using-sorting-and-lower-bound-function",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAfter looking at the question the intuition that comes to my mind is to sort the potions vector and corresponding to every spell value will find the index of the minimum value in the potions vector whose value becomes equal to or greater than the success value given to us.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe have to find how many potions are there whose multiplication with that particular spell value is greater than or equal to the success value given to us. \\n\\nThe first thing that comes to mind is to sort that potions vector. Now try to find the index of that minimum value in the potions vector whose multiplication with the particular spell value becomes equal to or surpasses the success value given to us. (Ofcourse the values after that particular index will satisfy the criteria because we already sorted the vector in the first place.)\\n\\nWe will use lower_bound function here, which returns the iterator of that particular value if that particular value is present in the vector. And if that particular value is not present in the vector it will give us the iterator of the value which is greater than that value. We\\'ll then subtract this iterator from the base iterator(potions.begin()) to find the index. \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe for loop is running for n times where n = spells.size() and the lower bound function takes logN time where N - potions.size().\\n\\nSo the TOTAL TIME COMPLEXITY IS O(nlogN);\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nWe are using space to store the ans only. so the space complexity O(n) where n = spells.size()\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n\\n        vector<int> ans;\\n        sort(potions.begin(),potions.end());\\n\\n        \\n        for(int i=0; i<spells.size(); i++){\\n            long long value = ceil(success/(spells[i]*1.0));\\n            auto it = lower_bound(potions.begin(),potions.end(),value);\\n\\n            int res = 0;\\n\\n            if(it!=potions.end()){\\n                int ind = it-potions.begin();\\n                res += potions.size()-ind;\\n                ans.push_back(res);\\n            }\\n            else{\\n                ans.push_back(0);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n\\n        vector<int> ans;\\n        sort(potions.begin(),potions.end());\\n\\n        \\n        for(int i=0; i<spells.size(); i++){\\n            long long value = ceil(success/(spells[i]*1.0));\\n            auto it = lower_bound(potions.begin(),potions.end(),value);\\n\\n            int res = 0;\\n\\n            if(it!=potions.end()){\\n                int ind = it-potions.begin();\\n                res += potions.size()-ind;\\n                ans.push_back(res);\\n            }\\n            else{\\n                ans.push_back(0);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3370096,
                "title": "binary-search-beats100-runtime-and-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n# **Please upvote the solution if you like it.**\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe binSearch function is a recursive binary search algorithm that searches for a given element (the success variable) in a sorted array (the potions vector) based on a comparison between the product of the middle element of the array and a given integer (the pro variable) and the success variable. If the product is greater than or equal to success, the index variable is updated with the current index of the middle element and the algorithm continues the search on the left half of the array. If the product is less than success, the algorithm continues the search on the right half of the array. The function stops when the element is found or when the search range is empty.\\n\\nThe successfulPairs function takes in two vectors of integers, spells and potions, and a success variable of type long long. It first sorts the potions vector. Then, for each element in the spells vector, it calls the binSearch function to find the number of elements in the potions vector that form a successful pair with the current element in the spells vector, i.e., the number of elements in the potions vector whose product with the current element is greater than or equal to success. This number is then stored in the corresponding index of the spells vector. If no such elements exist, the corresponding index in the spells vector is set to 0. Finally, the spells vector is returned.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(mlogn)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    int index=-1;\\n    void binSearch(vector<int>& potions,int low,int high,long long success,int pro){\\n        if(low>high){\\n            return;\\n        }\\n        int mid = low+(high-low)/2;\\n        if((long long)potions[mid]*(long long)pro>=success){\\n            index=mid;\\n            binSearch(potions,low,mid-1,success,pro);\\n        }\\n        else{\\n            binSearch(potions,mid+1,high,success,pro);\\n        }\\n    }\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        ios_base::sync_with_stdio(false);\\n        sort(potions.begin(),potions.end());\\n        for(int i=0;i<spells.size();i++){\\n            binSearch(potions,0,potions.size()-1,success,spells[i]);\\n            if(index==-1){\\n                spells[i]=0;\\n            }\\n            else{\\n                spells[i]=potions.size()-index;\\n            }\\n            index=-1;\\n        }\\n        return spells;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int index=-1;\\n    void binSearch(vector<int>& potions,int low,int high,long long success,int pro){\\n        if(low>high){\\n            return;\\n        }\\n        int mid = low+(high-low)/2;\\n        if((long long)potions[mid]*(long long)pro>=success){\\n            index=mid;\\n            binSearch(potions,low,mid-1,success,pro);\\n        }\\n        else{\\n            binSearch(potions,mid+1,high,success,pro);\\n        }\\n    }\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        ios_base::sync_with_stdio(false);\\n        sort(potions.begin(),potions.end());\\n        for(int i=0;i<spells.size();i++){\\n            binSearch(potions,0,potions.size()-1,success,spells[i]);\\n            if(index==-1){\\n                spells[i]=0;\\n            }\\n            else{\\n                spells[i]=potions.size()-index;\\n            }\\n            index=-1;\\n        }\\n        return spells;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3370026,
                "title": "simple-commented-c-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        // Sort the potions array as we will use binary search here...\\n        sort(potions.begin(),potions.end());\\n        \\n        // Declaring the answer array...\\n        vector<int> ans(spells.size(),0);\\n        \\n        for(int i = 0; i < spells.size(); i++){\\n            long long n = spells[i];\\n            \\n            // the required element can be calculated as follows...\\n            long long int req = (success/n) + (success%n != 0);\\n            \\n            // if the required element is found then all the elements greater than \"req\" will satisfy the condition...\\n            int indx = lower_bound(potions.begin(),potions.end(),req) - potions.begin();\\n            \\n            // taking all elements greater than  and equal to \"req\"...\\n            ans[i] = potions.size() - indx;\\n            \\n        }\\n        \\n        return ans;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        // Sort the potions array as we will use binary search here...\\n        sort(potions.begin(),potions.end());\\n        \\n        // Declaring the answer array...\\n        vector<int> ans(spells.size(),0);\\n        \\n        for(int i = 0; i < spells.size(); i++){\\n            long long n = spells[i];\\n            \\n            // the required element can be calculated as follows...\\n            long long int req = (success/n) + (success%n != 0);\\n            \\n            // if the required element is found then all the elements greater than \"req\" will satisfy the condition...\\n            int indx = lower_bound(potions.begin(),potions.end(),req) - potions.begin();\\n            \\n            // taking all elements greater than  and equal to \"req\"...\\n            ans[i] = potions.size() - indx;\\n            \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3369972,
                "title": "easy-python-solution-using-bisect",
                "content": "# Code\\n```\\nclass Solution:\\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\\n        lst=[]\\n        potions.sort()\\n        ln=len(potions)\\n        for i in spells:\\n            t = bisect_left(potions, success/i)\\n            lst.append(ln-t)\\n        return lst\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Two Pointers",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution:\\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\\n        lst=[]\\n        potions.sort()\\n        ln=len(potions)\\n        for i in spells:\\n            t = bisect_left(potions, success/i)\\n            lst.append(ln-t)\\n        return lst\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3369558,
                "title": "java-solution-for-beginners-with-simple-explanation-and-some-additional-tips",
                "content": "# Intuition\\nBinary Search\\n\\n# Approach\\nStep 1 : Sort potions \\nStep 2 : get number of pair of successful potions and spells by using binary search. Try finding smallest element in potions which can give you successful pair by subtracting index of samllest element by length of potions.\\nStep 3 : store all the value in ans[] and return ans.\\n\\n\\n# Tips\\n1. In below code you can store ans[] values into spells[] which can help you reduce space complexity from O(n) to O(1). \\n\\n2. Instead of using function couSuc you can do binary search in for loop instead to save some more time. \\n\\n# Advantages\\n1. This approach gives you consistent result and it is favorable for very large array. \\n\\n2. This code can be done in space complexity of O(1) instead of O(n). which makes it space efficient. \\n\\n# Disadvantages\\n1. It is slower for small array. two Poiner method is favorable for smaler array\\n\\n# Complexity\\n- Time complexity:\\n O(n log n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        Arrays.sort(potions);\\n        int ans[] = new int[spells.length];\\n        for(int i=0;i<spells.length;i++){\\n            ans[i]=couSuc(spells[i],potions,success);\\n        }\\n        return ans;\\n    }\\n    private int couSuc(int a, int[] arr, long b){\\n        int start=0,end=arr.length;\\n        while(start<end){\\n            int mid=start+(end-start)/2;\\n            if((long)arr[mid]*a>=b){\\n                end=mid;\\n            }\\n            else{\\n                start=mid+1;\\n            }\\n        }\\n        return arr.length-start;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Binary Search",
                    "Sort"
                ],
                "code": "```\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        Arrays.sort(potions);\\n        int ans[] = new int[spells.length];\\n        for(int i=0;i<spells.length;i++){\\n            ans[i]=couSuc(spells[i],potions,success);\\n        }\\n        return ans;\\n    }\\n    private int couSuc(int a, int[] arr, long b){\\n        int start=0,end=arr.length;\\n        while(start<end){\\n            int mid=start+(end-start)/2;\\n            if((long)arr[mid]*a>=b){\\n                end=mid;\\n            }\\n            else{\\n                start=mid+1;\\n            }\\n        }\\n        return arr.length-start;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3369472,
                "title": "easy-approach-sorting-binary-search",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst Sort the potion array and then use the binary search in this array to find the first index whose product with the spells would be equal or grater than than the success.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(nlogm)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n# Code\\n```\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        Arrays.sort(potions);\\n        int[] ans = new int[spells.length];\\n        for(int i = 0 ; i < spells.length; i++){\\n            int left = 0;\\n            int right = potions.length-1;\\n            while(left <= right){\\n                int mid = (left+right)/2;\\n                if((long)spells[i]*potions[mid] < success){\\n                    left = mid+1;\\n                }\\n                else{\\n                    right = mid-1;\\n                }\\n            }\\n            ans[i] = potions.length-right-1;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        Arrays.sort(potions);\\n        int[] ans = new int[spells.length];\\n        for(int i = 0 ; i < spells.length; i++){\\n            int left = 0;\\n            int right = potions.length-1;\\n            while(left <= right){\\n                int mid = (left+right)/2;\\n                if((long)spells[i]*potions[mid] < success){\\n                    left = mid+1;\\n                }\\n                else{\\n                    right = mid-1;\\n                }\\n            }\\n            ans[i] = potions.length-right-1;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3369463,
                "title": "sorting-binary-search-explaination-easy-java-solution-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSort the potions array and then use binary search on potions array to get the that element whose elements of right part of the array will be greater than or equal to success given because if that particular element excceds success then all element from right will be also excceds.\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        int n = spells.length;\\n        int m = potions.length;\\n        int ans[] = new int[n];\\n        Arrays.sort(potions);\\n        for(int i = 0 ; i < n; i ++){\\n            int spell = spells[i];\\n            int low = 0;\\n            int high = m - 1;\\n            while(low <= high){\\n                int mid = (high - low)/2 + low;\\n                long product = (long)spell * (long)potions[mid];\\n                if(product >= success){\\n                    high = mid - 1;\\n                }else{\\n                    low = mid + 1;\\n                }\\n            }\\n            ans[i] = m - low;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        int n = spells.length;\\n        int m = potions.length;\\n        int ans[] = new int[n];\\n        Arrays.sort(potions);\\n        for(int i = 0 ; i < n; i ++){\\n            int spell = spells[i];\\n            int low = 0;\\n            int high = m - 1;\\n            while(low <= high){\\n                int mid = (high - low)/2 + low;\\n                long product = (long)spell * (long)potions[mid];\\n                if(product >= success){\\n                    high = mid - 1;\\n                }else{\\n                    low = mid + 1;\\n                }\\n            }\\n            ans[i] = m - low;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3369207,
                "title": "best-simple-approach-java-solution",
                "content": "# Intuition\\nSort the array. Then apply binary search.\\n\\n# Approach\\nSort the array. Then apply binary search.\\n\\n# Complexity\\n- Time complexity:O(nlogn)\\n\\n- Space complexity:O(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        //sorting array so that if once we find any value>= success then next values will be automatically >= success\\n        Arrays.sort(potions);\\n        int[] result = new int[spells.length];\\n        for(int i=0;i<spells.length;i++)\\n        {\\n            //we find first value for which multiplication value >= success by binary search for reducing time complexity\\n            //then we store the number of values by calculating length- minimum index for which it satisfies\\n            result[i] = binarySearch(spells,potions,0,potions.length-1,spells[i],success);\\n        }\\n        return result;\\n    }\\n\\n    //binary search function\\n    public  int binarySearch(int[] spells,int potions[], int si, int ei,int val,long target)\\n    {\\n        while(si<=ei)\\n        {\\n            int mid = si + (ei-si)/2;\\n            if((long)val*(long)potions[mid]>=target)\\n            {\\n                if(mid==0)\\n                {\\n                    return potions.length-mid;\\n                }\\n                else if((long)val*(long)potions[mid-1]<target)\\n                {\\n                     return potions.length-mid;\\n                }\\n                else\\n                {\\n                    ei= mid-1;\\n                }\\n            }\\n            else\\n            si= mid+1;\\n        }\\n        return 0;\\n         \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        //sorting array so that if once we find any value>= success then next values will be automatically >= success\\n        Arrays.sort(potions);\\n        int[] result = new int[spells.length];\\n        for(int i=0;i<spells.length;i++)\\n        {\\n            //we find first value for which multiplication value >= success by binary search for reducing time complexity\\n            //then we store the number of values by calculating length- minimum index for which it satisfies\\n            result[i] = binarySearch(spells,potions,0,potions.length-1,spells[i],success);\\n        }\\n        return result;\\n    }\\n\\n    //binary search function\\n    public  int binarySearch(int[] spells,int potions[], int si, int ei,int val,long target)\\n    {\\n        while(si<=ei)\\n        {\\n            int mid = si + (ei-si)/2;\\n            if((long)val*(long)potions[mid]>=target)\\n            {\\n                if(mid==0)\\n                {\\n                    return potions.length-mid;\\n                }\\n                else if((long)val*(long)potions[mid-1]<target)\\n                {\\n                     return potions.length-mid;\\n                }\\n                else\\n                {\\n                    ei= mid-1;\\n                }\\n            }\\n            else\\n            si= mid+1;\\n        }\\n        return 0;\\n         \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3369194,
                "title": "c-solution-nlogn",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMultiply each element of potions with each element of spells  and count number of number which is greater than or equal to success.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nNaive approach is using two for loop  that is in O(N*N).  but it will not run as test case is large.\\nso a better approach is using binary search (logN). Run a for loop for spells and apply binary search in potions.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(NlogN)\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        \\n        sort(potions.begin(),potions.end());\\n        int spells_size=spells.size();\\n        int potions_size=potions.size();\\n        vector<int>ans;\\n        for(int i=0;i<spells_size;i++)\\n        {\\n            int start=0;\\n            int end=potions_size-1;\\n            int max_number=0;\\n            while(start<=end)\\n            {\\n                int mid=(start+end)/2;\\n                if((long long)spells[i]*(long long )potions[mid]>=success)\\n                {\\n                    end=mid-1;\\n                    max_number=max(max_number,(potions_size-mid));\\n                }\\n                else if((long long)spells[i]*(long long )potions[mid]<success)\\n                {\\n                    start=mid+1;\\n                }\\n            }\\n            ans.push_back(max_number);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        \\n        sort(potions.begin(),potions.end());\\n        int spells_size=spells.size();\\n        int potions_size=potions.size();\\n        vector<int>ans;\\n        for(int i=0;i<spells_size;i++)\\n        {\\n            int start=0;\\n            int end=potions_size-1;\\n            int max_number=0;\\n            while(start<=end)\\n            {\\n                int mid=(start+end)/2;\\n                if((long long)spells[i]*(long long )potions[mid]>=success)\\n                {\\n                    end=mid-1;\\n                    max_number=max(max_number,(potions_size-mid));\\n                }\\n                else if((long long)spells[i]*(long long )potions[mid]<success)\\n                {\\n                    start=mid+1;\\n                }\\n            }\\n            ans.push_back(max_number);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3369022,
                "title": "using-binary-search-problem-of-the-day-april-2",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe have to find the minimum element from where the potions element * spell element will be greater than the succes and store the number that is greater than that.\\n \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe Naive approach will be using the two for loop which will eventually give the TLE because of contraint.\\n\\nSo the next approach will be the Binary search, firstly we have to sort the potions array for finding the minimumn potions element from where the spells[i]*potions[ele] >= success. Then by intialising an vector we will store the number of element that will be larger than that element i.e. [potions.size()-start]. Using this the Time Complexity will be: O(nlogn);\\n\\n# Complexity\\n- Time complexity:O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        int n = spells.size();\\n        vector<int> ans;\\n\\n        sort(potions.begin(),potions.end());\\n\\n        for(int ele: spells){\\n            // int ele = spells[i];\\n\\n            int start = 0;\\n            int end = potions.size();\\n\\n            while(start<end){\\n                int mid = (start + end) >> 1;\\n\\n                if(static_cast<long long>(ele) * potions[mid] >= success){\\n                    end = mid;\\n                }else{\\n                    start = mid+1;\\n                }\\n            }\\n\\n            ans.push_back(potions.size()-start);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        int n = spells.size();\\n        vector<int> ans;\\n\\n        sort(potions.begin(),potions.end());\\n\\n        for(int ele: spells){\\n            // int ele = spells[i];\\n\\n            int start = 0;\\n            int end = potions.size();\\n\\n            while(start<end){\\n                int mid = (start + end) >> 1;\\n\\n                if(static_cast<long long>(ele) * potions[mid] >= success){\\n                    end = mid;\\n                }else{\\n                    start = mid+1;\\n                }\\n            }\\n\\n            ans.push_back(potions.size()-start);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3368961,
                "title": "c-fully-commented-simple-intuitive",
                "content": "# Intuition\\nBinary Search\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach is explained with the code as comments\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        //firt sort the potions array\\n        sort(potions.begin(), potions.end());\\n        vector<int> ans;    //store the ans here\\n\\n        int n = potions.size();\\n        //iterate over the each spell\\n        for(int i = 0; i<spells.size(); i++){\\n            //check the minimum value for each spell. We are taking the ceil value. \\n            //Because as the question suggest we have to multiply that spell with potions \\n            //such that the multiplication should be greater than success.\\n            long long minLimit = success/spells[i];\\n            if(success%spells[i])\\n                minLimit++;\\n            //now find the starting position of minLimit and \\n            //add the total values larger than minLimit to your ans\\n            int cnt = lower_bound(potions.begin(), potions.end(), minLimit) - potions.begin();\\n            ans.push_back(n-cnt);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        //firt sort the potions array\\n        sort(potions.begin(), potions.end());\\n        vector<int> ans;    //store the ans here\\n\\n        int n = potions.size();\\n        //iterate over the each spell\\n        for(int i = 0; i<spells.size(); i++){\\n            //check the minimum value for each spell. We are taking the ceil value. \\n            //Because as the question suggest we have to multiply that spell with potions \\n            //such that the multiplication should be greater than success.\\n            long long minLimit = success/spells[i];\\n            if(success%spells[i])\\n                minLimit++;\\n            //now find the starting position of minLimit and \\n            //add the total values larger than minLimit to your ans\\n            int cnt = lower_bound(potions.begin(), potions.end(), minLimit) - potions.begin();\\n            ans.push_back(n-cnt);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3368926,
                "title": "javascript-java-c-and-python-solution-with-time-complexity-of-o-n-log-m",
                "content": "\\n\\n# Approach\\nSort the potions array in descending order.\\nCreate an empty hash map map to store the results.\\nFor each element in the spells array:\\na. If the element is not in the map, calculate the value of success / spells[i] and find the position of the first element in the sorted potions array that is greater than or equal to this value using a binary search. Store this position in len and add it to the res array. Also store len in the map against spells[i].\\nb. If the element is already in the map, retrieve the value of len from the map and add it to the res array.\\nReturn the res array.\\n\\n# Complexity\\n- Time complexity: O(n log m)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(m + n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# JavaCsript\\n```\\n/**\\n * @param {number[]} spells\\n * @param {number[]} potions\\n * @param {number} success\\n * @return {number[]}\\n */\\n var successfulPairs = function(spells, potions, success) {\\n    let res = [];\\n    potions.sort((a, b) => b-a);\\n    let map = new Map();\\n    \\n    for(let i=0; i<spells.length; i++){\\n        if(!map.has(spells[i])){\\n            let s = success / spells[i];\\n            let len = search(potions, s);\\n            res.push(len);\\n            map.set(spells[i], len);\\n        }else{\\n            let len = map.get(spells[i]);\\n            res.push(len);\\n        }\\n    }\\n    \\n    return res;\\n};\\n\\nfunction search(potions, target){\\n    let res = 0;\\n    let left = 0;\\n    let right = potions.length-1;\\n    while(left <= right){\\n        let mid = Math.floor((left + right) / 2);\\n        if(potions[mid] < target){\\n            right = mid - 1;\\n        }else{\\n            left = mid + 1;\\n            res = mid + 1;\\n        }\\n    }\\n\\n    return res;\\n}\\n```\\n# Java\\n```\\npublic class SuccessfulPairs {\\n    public static int[] successfulPairs(int[] spells, int[] potions, int success) {\\n        ArrayList<Integer> res = new ArrayList<>();\\n        int[] sortedPotions = potions.clone();\\n        Arrays.sort(sortedPotions);\\n        Map<Integer, Integer> map = new HashMap<>();\\n\\n        for(int i=0; i<spells.length; i++){\\n            if(!map.containsKey(spells[i])){\\n                int s = success / spells[i];\\n                int len = search(sortedPotions, s);\\n                res.add(len);\\n                map.put(spells[i], len);\\n            }else{\\n                int len = map.get(spells[i]);\\n                res.add(len);\\n            }\\n        }\\n\\n        int[] result = new int[res.size()];\\n        for(int i=0; i<res.size(); i++){\\n            result[i] = res.get(i);\\n        }\\n        return result;\\n    }\\n\\n    public static int search(int[] potions, int target){\\n        int res = 0;\\n        int left = 0;\\n        int right = potions.length-1;\\n        while(left <= right){\\n            int mid = (left + right) / 2;\\n            if(potions[mid] < target){\\n                right = mid - 1;\\n            }else{\\n                left = mid + 1;\\n                res = mid + 1;\\n            }\\n        }\\n\\n        return res;\\n    }\\n}\\n```\\n# C\\n```\\n\\n\\nint search(int* potions, int potionsSize, int target){\\n    int res = 0;\\n    int left = 0;\\n    int right = potionsSize-1;\\n    while(left <= right){\\n        int mid = (left + right) / 2;\\n        if(potions[mid] < target){\\n            right = mid - 1;\\n        }else{\\n            left = mid + 1;\\n            res = mid + 1;\\n        }\\n    }\\n\\n    return res;\\n}\\n\\nint* successfulPairs(int* spells, int spellsSize, int* potions, int potionsSize, int success, int* returnSize) {\\n    int* res = malloc(spellsSize * sizeof(int));\\n    int* sortedPotions = malloc(potionsSize * sizeof(int));\\n    memcpy(sortedPotions, potions, potionsSize * sizeof(int));\\n    qsort(sortedPotions, potionsSize, sizeof(int), (const void *)compare);\\n    int* map = calloc(spellsSize, sizeof(int));\\n\\n    for(int i=0; i<spellsSize; i++){\\n        if(map[spells[i]] == 0){\\n            int s = success / spells[i];\\n            int len = search(sortedPotions, potionsSize, s);\\n            res[i] = len;\\n            map[spells[i]] = len;\\n        }else{\\n            int len = map[spells[i]];\\n            res[i] = len;\\n        }\\n    }\\n    \\n    free(map);\\n    free(sortedPotions);\\n    *returnSize = spellsSize;\\n    return res;\\n}\\n\\nint compare(const void * a, const void * b) {\\n   return (*(int*)b - *(int*)a);\\n}\\n```\\n# Python\\n```\\nfrom typing import List\\nimport bisect\\n\\ndef successfulPairs(spells: List[int], potions: List[int], success: int) -> List[int]:\\n    res = []\\n    sortedPotions = sorted(potions, reverse=True)\\n    map = {}\\n\\n    for i in range(len(spells)):\\n        if spells[i] not in map:\\n            s = success / spells[i]\\n            len = bisect.bisect_left(sortedPotions, s)\\n            res.append(len)\\n            map[spells[i]] = len\\n        else:\\n            len = map[spells[i]]\\n            res.append(len)\\n\\n    return res\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} spells\\n * @param {number[]} potions\\n * @param {number} success\\n * @return {number[]}\\n */\\n var successfulPairs = function(spells, potions, success) {\\n    let res = [];\\n    potions.sort((a, b) => b-a);\\n    let map = new Map();\\n    \\n    for(let i=0; i<spells.length; i++){\\n        if(!map.has(spells[i])){\\n            let s = success / spells[i];\\n            let len = search(potions, s);\\n            res.push(len);\\n            map.set(spells[i], len);\\n        }else{\\n            let len = map.get(spells[i]);\\n            res.push(len);\\n        }\\n    }\\n    \\n    return res;\\n};\\n\\nfunction search(potions, target){\\n    let res = 0;\\n    let left = 0;\\n    let right = potions.length-1;\\n    while(left <= right){\\n        let mid = Math.floor((left + right) / 2);\\n        if(potions[mid] < target){\\n            right = mid - 1;\\n        }else{\\n            left = mid + 1;\\n            res = mid + 1;\\n        }\\n    }\\n\\n    return res;\\n}\\n```\n```\\npublic class SuccessfulPairs {\\n    public static int[] successfulPairs(int[] spells, int[] potions, int success) {\\n        ArrayList<Integer> res = new ArrayList<>();\\n        int[] sortedPotions = potions.clone();\\n        Arrays.sort(sortedPotions);\\n        Map<Integer, Integer> map = new HashMap<>();\\n\\n        for(int i=0; i<spells.length; i++){\\n            if(!map.containsKey(spells[i])){\\n                int s = success / spells[i];\\n                int len = search(sortedPotions, s);\\n                res.add(len);\\n                map.put(spells[i], len);\\n            }else{\\n                int len = map.get(spells[i]);\\n                res.add(len);\\n            }\\n        }\\n\\n        int[] result = new int[res.size()];\\n        for(int i=0; i<res.size(); i++){\\n            result[i] = res.get(i);\\n        }\\n        return result;\\n    }\\n\\n    public static int search(int[] potions, int target){\\n        int res = 0;\\n        int left = 0;\\n        int right = potions.length-1;\\n        while(left <= right){\\n            int mid = (left + right) / 2;\\n            if(potions[mid] < target){\\n                right = mid - 1;\\n            }else{\\n                left = mid + 1;\\n                res = mid + 1;\\n            }\\n        }\\n\\n        return res;\\n    }\\n}\\n```\n```\\n\\n\\nint search(int* potions, int potionsSize, int target){\\n    int res = 0;\\n    int left = 0;\\n    int right = potionsSize-1;\\n    while(left <= right){\\n        int mid = (left + right) / 2;\\n        if(potions[mid] < target){\\n            right = mid - 1;\\n        }else{\\n            left = mid + 1;\\n            res = mid + 1;\\n        }\\n    }\\n\\n    return res;\\n}\\n\\nint* successfulPairs(int* spells, int spellsSize, int* potions, int potionsSize, int success, int* returnSize) {\\n    int* res = malloc(spellsSize * sizeof(int));\\n    int* sortedPotions = malloc(potionsSize * sizeof(int));\\n    memcpy(sortedPotions, potions, potionsSize * sizeof(int));\\n    qsort(sortedPotions, potionsSize, sizeof(int), (const void *)compare);\\n    int* map = calloc(spellsSize, sizeof(int));\\n\\n    for(int i=0; i<spellsSize; i++){\\n        if(map[spells[i]] == 0){\\n            int s = success / spells[i];\\n            int len = search(sortedPotions, potionsSize, s);\\n            res[i] = len;\\n            map[spells[i]] = len;\\n        }else{\\n            int len = map[spells[i]];\\n            res[i] = len;\\n        }\\n    }\\n    \\n    free(map);\\n    free(sortedPotions);\\n    *returnSize = spellsSize;\\n    return res;\\n}\\n\\nint compare(const void * a, const void * b) {\\n   return (*(int*)b - *(int*)a);\\n}\\n```\n```\\nfrom typing import List\\nimport bisect\\n\\ndef successfulPairs(spells: List[int], potions: List[int], success: int) -> List[int]:\\n    res = []\\n    sortedPotions = sorted(potions, reverse=True)\\n    map = {}\\n\\n    for i in range(len(spells)):\\n        if spells[i] not in map:\\n            s = success / spells[i]\\n            len = bisect.bisect_left(sortedPotions, s)\\n            res.append(len)\\n            map[spells[i]] = len\\n        else:\\n            len = map[spells[i]]\\n            res.append(len)\\n\\n    return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3368832,
                "title": "easy-binary-search-using-constant-extra-space-java-solution-beats-99",
                "content": "# Intuition\\nWe can use binary search to find out which element is exactly greater than or equal to product of ```spells[i]``` and ```potions[i]```.\\n1) we just need to take care of long variable as product maybe go beyond int range.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1) Sort potions array ascending order. So that we can use binary search to find out minimum element that is less than success.\\n2) now we need to check for every element in spells, so let\\'s use a for loop and pass our binary Search.\\n```\\nfor(int i = 0; i < n; i++){\\n    arr[i] = bs(potions, spells[i], success, 0, m - 1);\\n}\\n```\\n3) In binary search if we found ```spells[i] * potions[mid] >= success``` it means there maybe other element in the left side that are maybe greater than or equal to success. So, we use ```end = mid - 1``` else ```start = mid + 1```.\\n4) Now for count all the numbers we just need to subtract ```potion.length - start```.\\n5) We can easily store these count in spells array as we don\\'t need previous values further. So we don\\'t need any extra space\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- $$O(n logn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        int n = spells.length, m = potions.length;\\n        Arrays.sort(potions);\\n        for(int i = 0; i < n; i++){\\n            spells[i] = bs(potions, spells[i], success, 0, m - 1);\\n        }\\n        return spells;\\n    }\\n    int bs(int[] nums, long t, long succ, int start, int end){\\n        while(start <= end){\\n            int mid = (start + end) >> 1;\\n            if((long)(t * nums[mid]) >= succ){\\n                end = mid - 1;\\n            }\\n            else{\\n                start = mid + 1;\\n            }\\n        }\\n        return nums.length - start;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```spells[i]```\n```potions[i]```\n```\\nfor(int i = 0; i < n; i++){\\n    arr[i] = bs(potions, spells[i], success, 0, m - 1);\\n}\\n```\n```spells[i] * potions[mid] >= success```\n```end = mid - 1```\n```start = mid + 1```\n```potion.length - start```\n```\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        int n = spells.length, m = potions.length;\\n        Arrays.sort(potions);\\n        for(int i = 0; i < n; i++){\\n            spells[i] = bs(potions, spells[i], success, 0, m - 1);\\n        }\\n        return spells;\\n    }\\n    int bs(int[] nums, long t, long succ, int start, int end){\\n        while(start <= end){\\n            int mid = (start + end) >> 1;\\n            if((long)(t * nums[mid]) >= succ){\\n                end = mid - 1;\\n            }\\n            else{\\n                start = mid + 1;\\n            }\\n        }\\n        return nums.length - start;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3368719,
                "title": "java-code-simple-explanation",
                "content": "## Brute Force\\n- you can solve this problem using brute force running two loops and get the `counter` and add it into the list or array and return for each element you can do same. \\n\\n## Using Sorting + Binary Search \\n- Idea behind it is simple once we get the min potion which can satisfy the success then all the greater of it will also form it \\n- so the task is to find the minimum potion. Now question is here how we gonna find that min right \\n- So to find that min we need to sort the array of potion why need to sort? - So that we can easily apply binary search and make this algo to `n` to `logn` \\n- once you sorted the array `spells = [5,1,3], potions = [1,2,3,4,5], success = 7` now see for 5 what is the min potion that is required to form success can you see it is 2 at index = 1 \\n- okay now what so can I get it by binary search how? you can do multi of it 1. if it get greater set the right pointer 2. else set the left pointer \\n- Now we get the index of it alright now what is the last or say size of it just substract this index with size and we get how much we can form to make it success. \\n- A case for 0 what is it? right the case for the 0 is simple like if we get the min potion and max postion suppose what will be the max potion the max potion will be the last one after the sorting this elements if we get required min potion greater than max potion.. simple mean we can\\'t make any just add 0 in it. \\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] successfulPairs(int[] S, int[] P, long suc) {\\n        int ans=0;\\n        List<Integer> ls = new ArrayList<>();\\n        Arrays.sort(P);\\n        int n = P.length;\\n        int maxpos = P[P.length-1];\\n        // finding first index whose satisfy the condition \\n        for(int i: S){\\n            long minpos = (long)Math.ceil((1.0*suc)/i);\\n            if(minpos>maxpos){\\n                ls.add(0);\\n            }else{\\n                int get = getI(i,P,suc);\\n                 get = n-get;\\n                ls.add(get);\\n            }\\n        }\\n        // converting to array \\n        int[] res = new int[ls.size()];\\n        for(int i=0; i<ls.size(); i++){\\n            res[i] = ls.get(i);\\n        }\\n        // returning the array\\n        return res; \\n    }\\n    public static int getI(int i, int[] P, long suc){\\n        int l = 0;\\n        int r = P.length-1;\\n        while(l<r){\\n            int mid = l+(r-l)/2;\\n            if((long)i*P[mid]>=suc){\\n                r = mid;\\n            }else{\\n                l = mid+1;\\n            }\\n        }\\n        return l;\\n    }\\n}\\n```\\n\\n# Complexity\\n- Time complexity: $$O(nlogn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n- you can remove list just simple array of `len(n)` will also work and because of return the Aux space will become $$O(1)$$ constant. \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] successfulPairs(int[] S, int[] P, long suc) {\\n        int ans=0;\\n        List<Integer> ls = new ArrayList<>();\\n        Arrays.sort(P);\\n        int n = P.length;\\n        int maxpos = P[P.length-1];\\n        // finding first index whose satisfy the condition \\n        for(int i: S){\\n            long minpos = (long)Math.ceil((1.0*suc)/i);\\n            if(minpos>maxpos){\\n                ls.add(0);\\n            }else{\\n                int get = getI(i,P,suc);\\n                 get = n-get;\\n                ls.add(get);\\n            }\\n        }\\n        // converting to array \\n        int[] res = new int[ls.size()];\\n        for(int i=0; i<ls.size(); i++){\\n            res[i] = ls.get(i);\\n        }\\n        // returning the array\\n        return res; \\n    }\\n    public static int getI(int i, int[] P, long suc){\\n        int l = 0;\\n        int r = P.length-1;\\n        while(l<r){\\n            int mid = l+(r-l)/2;\\n            if((long)i*P[mid]>=suc){\\n                r = mid;\\n            }else{\\n                l = mid+1;\\n            }\\n        }\\n        return l;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3368500,
                "title": "short-clean-and-optimal-solution-intuition-and-approach-explained",
                "content": "# Intuition\\nThe intuition behind the solution is to sort the potions array and then use binary search to find the index of the first potion whose strength multiplied by the spell\\'s strength is greater than or equal to the success threshold.\\n\\n# Approach\\nWe sort the potions array in non-decreasing order because we want to use binary search to find the index of the first potion that forms a successful pair with the current spell. Binary search can only be used on a sorted array.\\n\\nTo find the index of the first potion whose strength multiplied by the spell\\'s strength is greater than or equal to the success threshold, we divide the success threshold by the spell\\'s strength and round up to the nearest integer. This gives us the minimum potion strength required to form a successful pair with the spell.\\n\\nWe then use binary search to find the index of the first potion whose strength is greater than or equal to the minimum potion strength. All the potions from that index to the end of the array will form successful pairs with the spell.\\n\\nWe repeat this process for each spell in the spells array and add the number of successful pairs to the result vector.\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of this approach is O(n * log m), where n is the length of the spells array and m is the length of the potions array. Sorting the potions array takes O(m * log m) time, and the binary search for each spell takes O(log m) time.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        vector<int> result;\\n        sort(potions.begin(), potions.end());\\n        for (int i = 0; i < spells.size(); i++) {\\n            int index = lower_bound(potions.begin(), potions.end(), (success + spells[i] - 1) / spells[i]) - potions.begin();\\n            result.push_back(potions.size() - index);\\n        }\\n        return result;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Array",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        vector<int> result;\\n        sort(potions.begin(), potions.end());\\n        for (int i = 0; i < spells.size(); i++) {\\n            int index = lower_bound(potions.begin(), potions.end(), (success + spells[i] - 1) / spells[i]) - potions.begin();\\n            result.push_back(potions.size() - index);\\n        }\\n        return result;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3368333,
                "title": "sort-binary-search-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        int n = potions.size();\\n        vector<int> ans;\\n        sort(potions.begin(), potions.end());\\n\\n        for(int i : spells) {\\n            int pos = lower_bound(potions.begin(), potions.end(), ceil((double)success / i)) - potions.begin();\\n            ans.push_back(n - pos);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        int n = potions.size();\\n        vector<int> ans;\\n        sort(potions.begin(), potions.end());\\n\\n        for(int i : spells) {\\n            int pos = lower_bound(potions.begin(), potions.end(), ceil((double)success / i)) - potions.begin();\\n            ans.push_back(n - pos);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3368025,
                "title": "day-367-java-c-python-o-1-explained-3-3-ways-one-liner-dry-run",
                "content": "# Please Upvote as it really motivates me\\n# Intuition & Approach\\n##### \\u2022\\tThe problem requires to find the number of successful pairs between spells and potions, where a pair is considered successful if the product of the spell and potion is greater than or equal to a given value called success.\\n##### \\u2022\\tWe can start by finding the maximum value in the potions array, as this will help us in creating an array to count the number of potions available for each value.\\n##### \\u2022\\tWe create an array called potionsCount of size max+1, where max is the maximum value in the potions array. We initialize all elements of potionsCount to 0.\\n##### \\u2022\\tWe iterate through the potions array and increment the count of the corresponding value in potionsCount.\\n##### \\u2022\\tWe then iterate through the potionsCount array from right to left and update each element to the sum of itself and the next element. This gives us the number of potions available for each value and helps us in finding the number of successful pairs.\\n##### \\u2022\\tWe create an array called ret of size n, where n is the length of the spells array. We initialize all elements of ret to 0.\\n##### \\u2022\\tFor each spell, we calculate the minimum value of potion required to form a successful pair. We do this by dividing success by the spell and taking the floor of the result.\\n##### \\u2022\\tWe then iterate through the potionsCount array and find the number of potions available for the minimum value of potion required or any greater value. We store this value in the corresponding element of ret.\\n##### \\u2022\\tWe return the ret array containing the number of successful pairs for each spell.\\n##### \\u2022\\tTo handle the case where the minimum value of potion required is greater than the maximum value in the potions array, we skip the iteration for that spell.\\n##### \\u2022\\tTo handle the case where the product of the spell and the minimum value of potion required is less than success, we increment the minimum value of potion required until the product is greater than or equal to success. We do this only for values less than 100001, as this is the maximum value of success.\\n##### \\u2022\\tOverall, the solution has a time complexity of O(m + n log n), where m is the length of the potions array and n is the length of the spells array. The space complexity of the solution is O(max), where max is the maximum value in the potions array.\\n\\n\\n\\n```PYTHON []\\nclass Solution:\\n def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\\n        n = len(spells)\\n        m = len(potions)\\n\\n        # Find the maximum value in the potions array.\\n        max_val = max(potions)\\n\\n        # Create an array to count the number of potions available for each value.\\n        potions_count = [0] * (max_val + 1)\\n        for x in potions:\\n            potions_count[x] += 1\\n\\n        # Update the potions_count array to store the number of potions available for each value and any greater value.\\n        count = 0\\n        for i in range(max_val, -1, -1):\\n            count += potions_count[i]\\n            potions_count[i] = count\\n\\n        # Create an array to store the number of successful pairs for each spell.\\n        ret = [0] * n\\n\\n        # For each spell, find the minimum value of potion required to form a successful pair and count the number of available potions.\\n        for i in range(n):\\n            target = success // spells[i]\\n            if target > max_val:\\n                continue\\n\\n            # Increment the minimum value of potion required until the product is greater than or equal to success.\\n            while target < 100001 and target * spells[i] < success:\\n                target += 1\\n\\n            if target > max_val:\\n                continue\\n\\n            # Store the number of available potions for the minimum value of potion required or any greater value.\\n            ret[i] = potions_count[target]\\n\\n        return ret\\n```\\n```JAVA []\\nclass Solution{\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        int n = spells.length;\\n        int m = potions.length;\\n        \\n        int max = -1;\\n        for (int x : potions)\\n            max = max>x?max:x;\\n        \\n        int[] potionsCount = new int[max + 1];\\n        for (int x : potions)\\n            potionsCount[x]++;\\n        \\n        int count = 0;\\n        for (int i = max; i >= 0; i--) {\\n            count += potionsCount[i];\\n            potionsCount[i] = count;\\n        }\\n        \\n        \\n        int[] ret = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            long target = success / spells[i];\\n            if (target > max)\\n                continue;\\n            \\n            while (target < 100001 && target * spells[i] < success)\\n                target++;\\n            \\n            if (target > max)\\n                continue;\\n            \\n            ret[i] = potionsCount[(int)target];\\n        }\\n        \\n        return ret;\\n    }}\\n\\n```\\n\\n```C++ []\\nclass Solution {\\n:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        int n = spells.size();\\n        int m = potions.size();\\n\\n        int max = -1;\\n        for (int x : potions)\\n            max = max>x?max:x;\\n\\n        vector<int> potionsCount(max + 1, 0);\\n        for (int x : potions)\\n            potionsCount[x]++;\\n\\n        int count = 0;\\n        for (int i = max; i >= 0; i--) {\\n            count += potionsCount[i];\\n            potionsCount[i] = count;\\n        }\\n\\n        vector<int> ret(n, 0);\\n        for (int i = 0; i < n; i++) {\\n            long long target = success / spells[i];\\n            if (target > max)\\n                continue;\\n\\n            while (target < 100001 && target * spells[i] < success)\\n                target++;\\n\\n            if (target > max)\\n                continue;\\n\\n            ret[i] = potionsCount[target];\\n        }\\n\\n        return ret;\\n    }\\n};\\n```\\n# 2nd way \\n\\n<!-- Describe your approach to solving the problem. -->\\n##### \\u2022\\tThe problem requires us to find the number of successful pairs between spells and potions, where a pair is considered successful if the product of the spell and potion is greater than or equal to a given value called success.\\n##### \\u2022\\tWe can start by sorting the potions array in increasing order, as this will help us in finding the minimum potion required for a given spell.\\n##### \\u2022\\tFor each spell, we need to find the minimum value of potion whose product with the current spell will be at least success or more. We can calculate this value by dividing success by the spell and taking the ceiling of the result.\\n##### \\u2022\\tIf the minimum potion required is greater than the maximum potion available, then we cannot form any successful pairs for this spell. In this case, we can set the answer for this spell to 0 and move on to the next spell.\\n##### \\u2022\\tIf we have a potion that can be used with the current spell, we need to find the index of the first potion in the sorted array that is greater than or equal to the minimum potion required. We can use binary search to find this index.\\n##### \\u2022\\tOnce we have the index of the first potion that can be used, we can count the number of potions to the right of this index, as all these potions will be greater than or equal to the minimum potion required and can be used to form successful pairs with the current spell.\\n##### \\u2022\\tWe repeat steps 3 to 6 for all spells and return the answer array containing the number of successful pairs for each spell.\\n\\n# Code\\n```java []\\n class Solution {\\n    // Our implementation of lower bound method using binary search.\\n    private int lowerBound(int[] arr, int key) {\\n        int lo = 0;\\n        int hi = arr.length;\\n        while (lo < hi) {\\n            int mid = lo + (hi - lo) / 2;\\n            if (arr[mid] < key) {\\n                lo = mid + 1;\\n            } else {\\n                hi = mid;\\n            }\\n        }\\n        return lo;\\n    }\\n\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        // Sort the potions array in increasing order.\\n        Arrays.sort(potions);\\n        int[] answer = new int[spells.length];\\n        int m = potions.length;\\n        int maxPotion = potions[m - 1];\\n\\n        for (int i = 0; i < spells.length; i++) {\\n            int spell = spells[i];\\n            // Minimum value of potion whose product with current spell will be at least success or more.\\n            long minPotion = (long) Math.ceil((1.0 * success) / spell);\\n            // Check if we don\\'t have any potion which can be used.\\n            if (minPotion > maxPotion) {\\n                answer[i] = 0;\\n                continue;\\n            }\\n            // We can use the found potion, and all potion in its right (as the right potions are greater than the found potion).\\n            int index = lowerBound(potions, (int) minPotion);\\n            answer[i] = m - index;\\n        }\\n        return answer;\\n    }\\n}\\n```\\n```c++ []\\nclass Solution {\\npublic    // Our implementation of lower bound method using binary search.\\n    int lowerBound(vector<int>& arr, int key) {\\n        int lo = 0;\\n        int hi = arr.size();\\n        while (lo < hi) {\\n            int mid = lo + (hi - lo) / 2;\\n            if (arr[mid] < key) {\\n                lo = mid + 1;\\n            } else {\\n                hi = mid;\\n            }\\n        }\\n        return lo;\\n    }\\n\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        // Sort the potions array in increasing order.\\n        sort(potions.begin(), potions.end());\\n        vector<int> answer(spells.size());\\n        int m = potions.size();\\n        int maxPotion = potions[m - 1];\\n\\n        for (int i = 0; i < spells.size(); i++) {\\n            int spell = spells[i];\\n            // Minimum value of potion whose product with current spell will be at least success or more.\\n            long long minPotion = ceil((1.0 * success) / spell);\\n            // Check if we don\\'t have any potion which can be used.\\n            if (minPotion > maxPotion) {\\n                answer[i] = 0;\\n                continue;\\n            }\\n            // We can use the found potion, and all potion in its right (as the right potions are greater than the found potion).\\n            int index = lowerBound(potions, (int) minPotion);\\n            answer[i] = m - index;\\n        }\\n        return answer;\\n    }\\n};\\n```\\n```python []\\nclass Solution:\\n    # Our of lower bound method using binary search.\\n    def lowerBound(self, arr: List[int], key: int) -> int:\\n        lo = 0\\n        hi = len(arr)\\n        while lo < hi:\\n            mid = lo + (hi - lo) // 2\\n            if arr[mid] < key:\\n                lo = mid + 1\\n            else:\\n                hi = mid\\n        return lo\\n\\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\\n        # Sort the potions array in increasing order.\\n        potions.sort()\\n        answer = [0] * len(spells)\\n        m = len(potions)\\n        maxPotion = potions[m - 1]\\n\\n        for i in range(len(spells)):\\n            spell = spells[i]\\n            # Minimum value of potion whose product with current spell will be at least success or more.\\n            minPotion = math.ceil(success / spell)\\n            # Check if we don\\'t have any potion which can be used.\\n            if minPotion > maxPotion:\\n                answer[i] = 0\\n                continue\\n            # We can use the found potion, and all potion in its right (as the right potions are greater than the found potion).\\n            index = self.lowerBound(potions, minPotion)\\n            answer[i] = m - index\\n        return answer\\n```\\n\\n# in place sp 0(1)\\n```java []\\npublic int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        Arrays.sort(potions);\\n        int len = spells.length;\\n        int m= potions.length;\\n        int max=potions[m-1];\\n        for(int i=0;i<len;i++){\\n            int spell =spells[i];\\n            long min= (long)Math.ceil((1.0*success)/spell);\\n            if(min>max){\\n                spells[i]=0;\\n                continue;\\n            }\\n            int ind=lowerBound(potions,(int)min);\\n            spells[i]=m-ind;\\n        }return spells;\\n    }\\n    int lowerBound(int A[],int key){\\n        int lo=0,ri=A.length;\\n        while(lo<ri){\\n            int mid=lo+(ri-lo)/2;\\n            if(A[mid]<key){\\n                lo=mid+1;\\n            }else ri=mid;\\n        }return lo;\\n    }\\n```\\n\\n# Complexity\\n##### \\u2022\\tComplexity:\\n##### \\u2022\\tSorting the potions array takes O(m log m) time, where m is the length of the potions array.\\n##### \\u2022\\tFor each spell, we perform a binary search to find the index of the first potion that can be used. This takes O(log m) time.\\n##### \\u2022\\tTherefore, the total time complexity of the solution is O(n log m), where n is the length of the spells array.\\n##### \\u2022\\tSpace Complexity:\\n##### \\u2022\\tWe use a constant amount of extra space for variables and the answer array. Therefore, the space complexity of the solution is O(1).\\n##### \\u2022\\tOverall, the solution has a time complexity of O(n log m) and a space complexity of O(1).\\n\\n# dry run 1\\n##### \\u2022\\tlet\\'s dry run the given input:\\n##### \\u2022\\tspells = [51,3]\\n##### \\u2022\\tpotions = [1,2,3,4,5]\\n##### \\u2022\\tsuccess = 7\\n##### \\u2022\\tWe need to find the number of successful pairs between spells and potions, where a pair is considered successful if the product of the spell and potion is greater than or equal to 7.\\n##### \\u2022\\tThe maximum value in the potions array is 5.\\n##### \\u2022\\tWe create an array called potionsCount of size 6, where 6 is the maximum value in the potions array plus 1. We initialize all elements of potionsCount to 0.\\n##### \\u2022\\tWe iterate through the potions array and increment the count of the corresponding value in potionsCount. The updated potionsCount array is:\\n1.\\tpotionsCount = [1, 1, 1, 1, 1, 0]\\n##### \\u2022\\tWe then iterate through the potionsCount array from right to left and update each element to the sum of itself and the next element. This gives us the number of potions available for each value and helps us in finding the number of successful pairs. The updated potionsCount array is:\\n1.\\tpotionsCount = [5, 4, 3, 2, 1, 0]\\n##### \\u2022\\tWe create an array called ret of size 3, where 3 is the length of the spells array. We initialize all elements of ret to 0.\\n##### \\u2022\\tFor the first spell, 5, we calculate the minimum value of potion required to form a successful pair. We do this by dividing 7 by 5 and taking the floor of the result, which is 1.\\n##### \\u2022\\tWe then iterate through the potionsCount array and find the number of potions available for the minimum value of potion required or any greater value. We store this value in the corresponding element of ret. The number of available potions is 4.\\n##### \\u2022\\tFor the second spell, 1, the minimum value of potion required is 7. Since 7 is greater than the maximum value in the potions array, we skip the iteration for this spell.\\n##### \\u2022\\tFor the third spell, 3, we calculate the minimum value of potion required to form a successful pair. We do this by dividing 7 by 3 and taking the floor of the result, which is 2.\\n##### \\u2022\\tWe then iterate through the potionsCount array and find the number of potions available for the minimum value of potion required or any greater value. We store this value in the corresponding element of ret. The number of available potions is 3.\\n##### \\u2022\\tThe final ret array is [4, 0, 3], which represents the number of successful pairs for each spell.\\n##### \\u2022\\tTherefore, the output for the given input is [4, 0, 3].\\n\\n[MY POST LINK](https://leetcode.com/problems/successful-pairs-of-spells-and-potions/solutions/3368025/day-367-java-c-python-o-1-explained-3-3-ways-one-liner-dry-run/?orderBy=most_votes)\\n\\n# dry run 2\\n##### \\u2022\\tlet\\'s dry run the given input:\\n##### \\u2022\\tspells = [,1,2]\\n##### \\u2022\\tpot = [8,5,8]\\n##### \\u2022\\tsuccess = 16\\n##### \\u2022\\tWe need to find the number of successful pairs between spells and potions, where a pair is considered successful if the product of the spell and potion is greater than or equal to 16.\\n##### \\u2022\\tThe maximum value in the potions array is 8.\\n##### \\u2022\\tWe create an array called potionsCount of size 9, where 9 is the maximum value in the potions array plus 1. We initialize all elements of potionsCount to 0.\\n##### \\u2022\\tWe iterate through the potions array and increment the count of the corresponding value in potionsCount. The updated potionsCount array is:\\n1.\\tpotionsCount = [0, 0, 0, 0, 1, 1, 0, 0, 1]\\n##### \\u2022\\tWe then iterate through the potionsCount array from right to left and update each element to the sum of itself and the next element. This gives us the number of potions available for each value and helps us in finding the number of successful pairs. The updated potionsCount array is:\\n1.\\tpotionsCount = [2, 2, 2, 2, 2, 1, 1, 1, 1]\\n##### \\u2022\\tWe create an array called ret of size 3, where 3 is the length of the spells array. We initialize all elements of ret to 0.\\n##### \\u2022\\tFor the first spell, 3, we calculate the minimum value of potion required to form a successful pair. We do this by dividing 16 by 3 and taking the floor of the result, which is 5.\\n##### \\u2022\\tWe then iterate through the potionsCount array and find the number of potions available for the minimum value of potion required or any greater value. We store this value in the corresponding element of ret. The number of available potions is 2.\\n##### \\u2022\\tFor the second spell, 1, the minimum value of potion required is 16. Since 16 is greater than the maximum value in the potions array, we skip the iteration for this spell.\\n##### \\u2022\\tFor the third spell, 2, we calculate the minimum value of potion required to form a successful pair. We do this by dividing 16 by 2 and taking the floor of the result, which is 8.\\n##### \\u2022\\tWe then iterate through the potionsCount array and find the number of potions available for the minimum value of potion required or any greater value. We store this value in the corresponding element of ret. The number of available potions is 2.\\n##### \\u2022\\tThe final ret array is [2, 0, 2], which represents the number of successful pairs for each spell.\\n##### \\u2022\\tTherefore, the output for the given input is [2, 0, 2].\\n\\n# 3rd way one liner\\n```python []\\ndef successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\\npotions.sort()\\nreturn (len(potions) - bisect_left(potions, success, key=lambda p: p * s) for s in spells)\\n```\\n```java []\\npublic int[] successfulPairs(int spells, int[] potions, int success) {\\n    Arrays.sort(potions);\\n    int[] result = new int[spells.length];\\n    for (int i = 0; i < spells.length; i++) {\\n        int count = potions.length - Arrays.binarySearch(potions, success, (p) -> p * spells[i]);\\n        result[i] = count;\\n    }\\n    return result;\\n}\\n```\\n```c++ []\\nvector<int> successfulPairs(vector<int>& spells, vector<int>& potions, int success) {\\n    sort(potions.begin(), potions.end());\\n    vector<int> result;\\n    for (int s : spells) {\\n        int count = potions.size() - lower_bound(potions.begin(), potions.end(), success, [&](int p) { return p * s; });\\n        result.push_back(count);\\n    }\\n    return result;\\n}\\n```\\n\\n##### \\u2022\\tPlease Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\n##### \\u2022\\tThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\n##### \\u2022\\tPlease give my solution an upvote! \\uD83D\\uDC4D\\n##### \\u2022\\tIt\\'s a simple way to show your appreciation and\\n##### \\u2022\\tkeep me motivated. Thank you! \\uD83D\\uDE0A\\n\\n![BREUSELEE.webp](https://assets.leetcode.com/users/images/01e9d1d5-3462-485a-9534-d40a3e78a49a_1680408107.3861706.webp)\\n\\n![meme2.png](https://assets.leetcode.com/users/images/1dba63f5-3703-4778-995f-2561c0a08abb_1680408137.1317718.png)\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3"
                ],
                "code": "```PYTHON []\\nclass Solution:\\n def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\\n        n = len(spells)\\n        m = len(potions)\\n\\n        # Find the maximum value in the potions array.\\n        max_val = max(potions)\\n\\n        # Create an array to count the number of potions available for each value.\\n        potions_count = [0] * (max_val + 1)\\n        for x in potions:\\n            potions_count[x] += 1\\n\\n        # Update the potions_count array to store the number of potions available for each value and any greater value.\\n        count = 0\\n        for i in range(max_val, -1, -1):\\n            count += potions_count[i]\\n            potions_count[i] = count\\n\\n        # Create an array to store the number of successful pairs for each spell.\\n        ret = [0] * n\\n\\n        # For each spell, find the minimum value of potion required to form a successful pair and count the number of available potions.\\n        for i in range(n):\\n            target = success // spells[i]\\n            if target > max_val:\\n                continue\\n\\n            # Increment the minimum value of potion required until the product is greater than or equal to success.\\n            while target < 100001 and target * spells[i] < success:\\n                target += 1\\n\\n            if target > max_val:\\n                continue\\n\\n            # Store the number of available potions for the minimum value of potion required or any greater value.\\n            ret[i] = potions_count[target]\\n\\n        return ret\\n```\n```JAVA []\\nclass Solution{\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        int n = spells.length;\\n        int m = potions.length;\\n        \\n        int max = -1;\\n        for (int x : potions)\\n            max = max>x?max:x;\\n        \\n        int[] potionsCount = new int[max + 1];\\n        for (int x : potions)\\n            potionsCount[x]++;\\n        \\n        int count = 0;\\n        for (int i = max; i >= 0; i--) {\\n            count += potionsCount[i];\\n            potionsCount[i] = count;\\n        }\\n        \\n        \\n        int[] ret = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            long target = success / spells[i];\\n            if (target > max)\\n                continue;\\n            \\n            while (target < 100001 && target * spells[i] < success)\\n                target++;\\n            \\n            if (target > max)\\n                continue;\\n            \\n            ret[i] = potionsCount[(int)target];\\n        }\\n        \\n        return ret;\\n    }}\\n\\n```\n```C++ []\\nclass Solution {\\n:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        int n = spells.size();\\n        int m = potions.size();\\n\\n        int max = -1;\\n        for (int x : potions)\\n            max = max>x?max:x;\\n\\n        vector<int> potionsCount(max + 1, 0);\\n        for (int x : potions)\\n            potionsCount[x]++;\\n\\n        int count = 0;\\n        for (int i = max; i >= 0; i--) {\\n            count += potionsCount[i];\\n            potionsCount[i] = count;\\n        }\\n\\n        vector<int> ret(n, 0);\\n        for (int i = 0; i < n; i++) {\\n            long long target = success / spells[i];\\n            if (target > max)\\n                continue;\\n\\n            while (target < 100001 && target * spells[i] < success)\\n                target++;\\n\\n            if (target > max)\\n                continue;\\n\\n            ret[i] = potionsCount[target];\\n        }\\n\\n        return ret;\\n    }\\n};\\n```\n```java []\\n class Solution {\\n    // Our implementation of lower bound method using binary search.\\n    private int lowerBound(int[] arr, int key) {\\n        int lo = 0;\\n        int hi = arr.length;\\n        while (lo < hi) {\\n            int mid = lo + (hi - lo) / 2;\\n            if (arr[mid] < key) {\\n                lo = mid + 1;\\n            } else {\\n                hi = mid;\\n            }\\n        }\\n        return lo;\\n    }\\n\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        // Sort the potions array in increasing order.\\n        Arrays.sort(potions);\\n        int[] answer = new int[spells.length];\\n        int m = potions.length;\\n        int maxPotion = potions[m - 1];\\n\\n        for (int i = 0; i < spells.length; i++) {\\n            int spell = spells[i];\\n            // Minimum value of potion whose product with current spell will be at least success or more.\\n            long minPotion = (long) Math.ceil((1.0 * success) / spell);\\n            // Check if we don\\'t have any potion which can be used.\\n            if (minPotion > maxPotion) {\\n                answer[i] = 0;\\n                continue;\\n            }\\n            // We can use the found potion, and all potion in its right (as the right potions are greater than the found potion).\\n            int index = lowerBound(potions, (int) minPotion);\\n            answer[i] = m - index;\\n        }\\n        return answer;\\n    }\\n}\\n```\n```c++ []\\nclass Solution {\\npublic    // Our implementation of lower bound method using binary search.\\n    int lowerBound(vector<int>& arr, int key) {\\n        int lo = 0;\\n        int hi = arr.size();\\n        while (lo < hi) {\\n            int mid = lo + (hi - lo) / 2;\\n            if (arr[mid] < key) {\\n                lo = mid + 1;\\n            } else {\\n                hi = mid;\\n            }\\n        }\\n        return lo;\\n    }\\n\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        // Sort the potions array in increasing order.\\n        sort(potions.begin(), potions.end());\\n        vector<int> answer(spells.size());\\n        int m = potions.size();\\n        int maxPotion = potions[m - 1];\\n\\n        for (int i = 0; i < spells.size(); i++) {\\n            int spell = spells[i];\\n            // Minimum value of potion whose product with current spell will be at least success or more.\\n            long long minPotion = ceil((1.0 * success) / spell);\\n            // Check if we don\\'t have any potion which can be used.\\n            if (minPotion > maxPotion) {\\n                answer[i] = 0;\\n                continue;\\n            }\\n            // We can use the found potion, and all potion in its right (as the right potions are greater than the found potion).\\n            int index = lowerBound(potions, (int) minPotion);\\n            answer[i] = m - index;\\n        }\\n        return answer;\\n    }\\n};\\n```\n```python []\\nclass Solution:\\n    # Our of lower bound method using binary search.\\n    def lowerBound(self, arr: List[int], key: int) -> int:\\n        lo = 0\\n        hi = len(arr)\\n        while lo < hi:\\n            mid = lo + (hi - lo) // 2\\n            if arr[mid] < key:\\n                lo = mid + 1\\n            else:\\n                hi = mid\\n        return lo\\n\\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\\n        # Sort the potions array in increasing order.\\n        potions.sort()\\n        answer = [0] * len(spells)\\n        m = len(potions)\\n        maxPotion = potions[m - 1]\\n\\n        for i in range(len(spells)):\\n            spell = spells[i]\\n            # Minimum value of potion whose product with current spell will be at least success or more.\\n            minPotion = math.ceil(success / spell)\\n            # Check if we don\\'t have any potion which can be used.\\n            if minPotion > maxPotion:\\n                answer[i] = 0\\n                continue\\n            # We can use the found potion, and all potion in its right (as the right potions are greater than the found potion).\\n            index = self.lowerBound(potions, minPotion)\\n            answer[i] = m - index\\n        return answer\\n```\n```java []\\npublic int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        Arrays.sort(potions);\\n        int len = spells.length;\\n        int m= potions.length;\\n        int max=potions[m-1];\\n        for(int i=0;i<len;i++){\\n            int spell =spells[i];\\n            long min= (long)Math.ceil((1.0*success)/spell);\\n            if(min>max){\\n                spells[i]=0;\\n                continue;\\n            }\\n            int ind=lowerBound(potions,(int)min);\\n            spells[i]=m-ind;\\n        }return spells;\\n    }\\n    int lowerBound(int A[],int key){\\n        int lo=0,ri=A.length;\\n        while(lo<ri){\\n            int mid=lo+(ri-lo)/2;\\n            if(A[mid]<key){\\n                lo=mid+1;\\n            }else ri=mid;\\n        }return lo;\\n    }\\n```\n```python []\\ndef successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\\npotions.sort()\\nreturn (len(potions) - bisect_left(potions, success, key=lambda p: p * s) for s in spells)\\n```\n```java []\\npublic int[] successfulPairs(int spells, int[] potions, int success) {\\n    Arrays.sort(potions);\\n    int[] result = new int[spells.length];\\n    for (int i = 0; i < spells.length; i++) {\\n        int count = potions.length - Arrays.binarySearch(potions, success, (p) -> p * spells[i]);\\n        result[i] = count;\\n    }\\n    return result;\\n}\\n```\n```c++ []\\nvector<int> successfulPairs(vector<int>& spells, vector<int>& potions, int success) {\\n    sort(potions.begin(), potions.end());\\n    vector<int> result;\\n    for (int s : spells) {\\n        int count = potions.size() - lower_bound(potions.begin(), potions.end(), success, [&](int p) { return p * s; });\\n        result.push_back(count);\\n    }\\n    return result;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3367958,
                "title": "easy-solution-implemented-with-more-one-language",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# C++ Code\\n```\\nclass Solution {\\npublic:\\n    int BS(int t, vector<int>& p, long long success){\\n        long long l = 0, r = p.size()-1, mid = -1;\\n        while(l<=r){\\n            mid = (l+r)/2;\\n            if( (long long)t*p[mid] < success )\\n                l = mid+1;\\n            else\\n                r = mid-1;\\n        }\\n        return l;\\n    }\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        int n = spells.size(), p = potions.size(), temp;\\n        vector<int> ans(n, 0);\\n        sort(potions.begin(), potions.end());\\n        for(int i=0; i<n; ++i){\\n            temp = BS( spells[i] , potions, success );\\n            ans[i] = (temp == p) ? 0 : p-temp;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n# Java Code \\n```\\nclass Solution {\\n    public int BS(int t, int[] p, long success){\\n        int l = 0, r = p.length-1, mid;\\n        while(l<=r){\\n            mid = (l+r)/2;\\n            if( (long)t*p[mid] < success )\\n                l = mid+1;\\n            else\\n                r = mid-1;\\n        }\\n        return l;\\n    }\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        int n = spells.length, p = potions.length, temp;\\n        int[] ans = new int[n];\\n        Arrays.sort(potions);\\n        for(int i=0; i<n; ++i){\\n            temp = BS(spells[i], potions, success);\\n            ans[i] = (temp == p)? 0 : p - temp;\\n        }\\n        return ans;\\n    }\\n}\\n```\\n# JavaScript Code\\n```\\n/**\\n * @param {number[]} spells\\n * @param {number[]} potions\\n * @param {number} success\\n * @return {number[]}\\n */\\nconst BS = ( t, p, success)=>{\\n    let l = 0, r = p.length-1, mid;\\n    while(l<=r){\\n        mid = parseInt( (l+r)/2 );\\n        if( t*p[mid] < success ){\\n            l = mid+1;\\n        }else{\\n            r = mid-1;\\n        }\\n    }\\n    return l;\\n}\\n\\nvar successfulPairs = function(spells, potions, success) {\\n    let n = spells.length, p = potions.length, temp;\\n    let ans = new Array(n);\\n    potions.sort((a, b)=> a - b);\\n    for(let i=0; i<n; ++i){\\n        temp = BS( spells[i], potions, success);\\n        console.log(temp);\\n        ans[i] = (temp == p)? 0 : p-temp;\\n    }\\n    return ans;\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int BS(int t, vector<int>& p, long long success){\\n        long long l = 0, r = p.size()-1, mid = -1;\\n        while(l<=r){\\n            mid = (l+r)/2;\\n            if( (long long)t*p[mid] < success )\\n                l = mid+1;\\n            else\\n                r = mid-1;\\n        }\\n        return l;\\n    }\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        int n = spells.size(), p = potions.size(), temp;\\n        vector<int> ans(n, 0);\\n        sort(potions.begin(), potions.end());\\n        for(int i=0; i<n; ++i){\\n            temp = BS( spells[i] , potions, success );\\n            ans[i] = (temp == p) ? 0 : p-temp;\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int BS(int t, int[] p, long success){\\n        int l = 0, r = p.length-1, mid;\\n        while(l<=r){\\n            mid = (l+r)/2;\\n            if( (long)t*p[mid] < success )\\n                l = mid+1;\\n            else\\n                r = mid-1;\\n        }\\n        return l;\\n    }\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        int n = spells.length, p = potions.length, temp;\\n        int[] ans = new int[n];\\n        Arrays.sort(potions);\\n        for(int i=0; i<n; ++i){\\n            temp = BS(spells[i], potions, success);\\n            ans[i] = (temp == p)? 0 : p - temp;\\n        }\\n        return ans;\\n    }\\n}\\n```\n```\\n/**\\n * @param {number[]} spells\\n * @param {number[]} potions\\n * @param {number} success\\n * @return {number[]}\\n */\\nconst BS = ( t, p, success)=>{\\n    let l = 0, r = p.length-1, mid;\\n    while(l<=r){\\n        mid = parseInt( (l+r)/2 );\\n        if( t*p[mid] < success ){\\n            l = mid+1;\\n        }else{\\n            r = mid-1;\\n        }\\n    }\\n    return l;\\n}\\n\\nvar successfulPairs = function(spells, potions, success) {\\n    let n = spells.length, p = potions.length, temp;\\n    let ans = new Array(n);\\n    potions.sort((a, b)=> a - b);\\n    for(let i=0; i<n; ++i){\\n        temp = BS( spells[i], potions, success);\\n        console.log(temp);\\n        ans[i] = (temp == p)? 0 : p-temp;\\n    }\\n    return ans;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3367889,
                "title": "js-binary-search-with-comments",
                "content": "# Intuition\\nTo achieve we don\\'t have to calcualate every spell * potion. If we sort potions then have to find the firs potion which satisfies our conditions. All next potions will satisfy as well.\\n\\n# Approach\\n - Sort potions ascending order\\n - for each spell find that minimum number which would be bigger than success after multiplying on it\\n - find the index of the first potion which is equal or more than that number\\n\\n# Complexity\\n- Time complexity: O(n*log(n) + n*log(m))\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\n/**\\n * @param {number[]} spells\\n * @param {number[]} potions\\n * @param {number} success\\n * @return {number[]}\\n */\\nvar successfulPairs = function(spells, potions, success) {\\n    // Sort potions asc order for binary search\\n    potions.sort((a, b) => a - b);\\n    const ans = [];\\n    for (const spell of spells) {\\n        // this number will help us to find the index of the first potion which is equal or more than that number\\n        const rel = success / spell;\\n        let left = 0, right = potions.length - 1;\\n        // standard binary search\\n        while (left <= right) {\\n            const mid = Math.floor((left + right) / 2);\\n            if (potions[mid] < rel) {\\n                left = mid + 1;\\n            } else {\\n                right = mid - 1;\\n            }\\n        }\\n        // the answer for this number would be the difference between the potions leng and the index\\n        ans.push(potions.length - left);\\n    }\\n    return ans;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} spells\\n * @param {number[]} potions\\n * @param {number} success\\n * @return {number[]}\\n */\\nvar successfulPairs = function(spells, potions, success) {\\n    // Sort potions asc order for binary search\\n    potions.sort((a, b) => a - b);\\n    const ans = [];\\n    for (const spell of spells) {\\n        // this number will help us to find the index of the first potion which is equal or more than that number\\n        const rel = success / spell;\\n        let left = 0, right = potions.length - 1;\\n        // standard binary search\\n        while (left <= right) {\\n            const mid = Math.floor((left + right) / 2);\\n            if (potions[mid] < rel) {\\n                left = mid + 1;\\n            } else {\\n                right = mid - 1;\\n            }\\n        }\\n        // the answer for this number would be the difference between the potions leng and the index\\n        ans.push(potions.length - left);\\n    }\\n    return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2976823,
                "title": "ruby-solution-two-methods",
                "content": "### Method 1:  Brute Force (gives TLE)\\nTime Complexity O(m*n)\\n\\n```\\ndef successful_pairs(spells, potions, success)\\n    spells.map { |spell| potions.count { |potion| spell * potion >= success } }\\nend\\n```\\n\\n### Method 2: Binary Search\\nTime Complexity O(n*log(m))\\n\\nProcess:\\n* Sort `potions` so we can use bsearch \\n* Get 1st index in `potions` where: `potion*spell >= success` \\n\\t* or equivalently: `potion >= success/spell`\\n* Return the number of `potions` greater than the successful one found, or 0 if none were found\\n\\n```\\ndef successful_pairs(spells, potions, success)\\n    potions.sort! \\n    spells.map do |spell_str|\\n        min_pot_str = success.fdiv(spell_str)\\n        idx = potions.bsearch_index { |potion| potion >= min_pot_str }\\n        idx.nil? ? 0 : potions.size - idx\\n    end\\nend\\n```",
                "solutionTags": [
                    "Ruby",
                    "Binary Tree"
                ],
                "code": "```\\ndef successful_pairs(spells, potions, success)\\n    spells.map { |spell| potions.count { |potion| spell * potion >= success } }\\nend\\n```\n```\\ndef successful_pairs(spells, potions, success)\\n    potions.sort! \\n    spells.map do |spell_str|\\n        min_pot_str = success.fdiv(spell_str)\\n        idx = potions.bsearch_index { |potion| potion >= min_pot_str }\\n        idx.nil? ? 0 : potions.size - idx\\n    end\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2674578,
                "title": "java-binary-search",
                "content": "```\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        Arrays.sort(potions);\\n        int n=spells.length,m=potions.length;;\\n        int ans[]=new int[n];\\n       \\n        long prod=0;\\n        for(int i=0;i<n;i++){\\n            int idx=-1,j=0,k=m-1;\\n            while(j<=k){\\n                int mid=(j+k)/2;\\n                if((long)spells[i]*(long)potions[mid]>=success){\\n                    idx=mid;\\n                    k=mid-1;\\n                }\\n                else{\\n                    j=mid+1;\\n                }\\n            }\\n            ans[i]=idx==-1?0:m-idx;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        Arrays.sort(potions);\\n        int n=spells.length,m=potions.length;;\\n        int ans[]=new int[n];\\n       \\n        long prod=0;\\n        for(int i=0;i<n;i++){\\n            int idx=-1,j=0,k=m-1;\\n            while(j<=k){\\n                int mid=(j+k)/2;\\n                if((long)spells[i]*(long)potions[mid]>=success){\\n                    idx=mid;\\n                    k=mid-1;\\n                }\\n                else{\\n                    j=mid+1;\\n                }\\n            }\\n            ans[i]=idx==-1?0:m-idx;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2153478,
                "title": "c-lower-bound-easy-and-simple-code",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        vector<int>ans(spells.size());\\n        sort(potions.begin(), potions.end());\\n        \\n        for(int i = 0; i<spells.size(); i++){\\n            long long secondnumber = ceil(success/static_cast<double>(spells[i]));\\n            auto it = lower_bound(potions.begin(), potions.end(), secondnumber);\\n            int indexofit = it-potions.begin();\\n            ans[i] = potions.size()-indexofit;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        vector<int>ans(spells.size());\\n        sort(potions.begin(), potions.end());\\n        \\n        for(int i = 0; i<spells.size(); i++){\\n            long long secondnumber = ceil(success/static_cast<double>(spells[i]));\\n            auto it = lower_bound(potions.begin(), potions.end(), secondnumber);\\n            int indexofit = it-potions.begin();\\n            ans[i] = potions.size()-indexofit;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2143378,
                "title": "javascript-solution",
                "content": "```\\n/**\\n * @param {number[]} spells\\n * @param {number[]} potions\\n * @param {number} success\\n * @return {number[]}\\n */\\n var successfulPairs = function(spells, potions, success) {\\n    let res = [];\\n    potions.sort((a, b) => b-a);\\n    let map = new Map();\\n    \\n    for(let i=0; i<spells.length; i++){\\n        if(!map.has(spells[i])){\\n            let s = success / spells[i];\\n            let len = search(potions, s);\\n            res.push(len);\\n            map.set(spells[i], len);\\n        }else{\\n            let len = map.get(spells[i]);\\n            res.push(len);\\n        }\\n    }\\n    \\n    return res;\\n};\\n\\nfunction search(potions, target){\\n    let res = 0;\\n    let left = 0;\\n    let right = potions.length-1;\\n    while(left <= right){\\n        let mid = Math.floor((left + right) / 2);\\n        if(potions[mid] < target){\\n            right = mid - 1;\\n        }else{\\n            left = mid + 1;\\n            res = mid + 1;\\n        }\\n    }\\n\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Binary Search"
                ],
                "code": "```\\n/**\\n * @param {number[]} spells\\n * @param {number[]} potions\\n * @param {number} success\\n * @return {number[]}\\n */\\n var successfulPairs = function(spells, potions, success) {\\n    let res = [];\\n    potions.sort((a, b) => b-a);\\n    let map = new Map();\\n    \\n    for(let i=0; i<spells.length; i++){\\n        if(!map.has(spells[i])){\\n            let s = success / spells[i];\\n            let len = search(potions, s);\\n            res.push(len);\\n            map.set(spells[i], len);\\n        }else{\\n            let len = map.get(spells[i]);\\n            res.push(len);\\n        }\\n    }\\n    \\n    return res;\\n};\\n\\nfunction search(potions, target){\\n    let res = 0;\\n    let left = 0;\\n    let right = potions.length-1;\\n    while(left <= right){\\n        let mid = Math.floor((left + right) / 2);\\n        if(potions[mid] < target){\\n            right = mid - 1;\\n        }else{\\n            left = mid + 1;\\n            res = mid + 1;\\n        }\\n    }\\n\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2139988,
                "title": "c-solution-explanations-and-examples",
                "content": "**Main idea**\\nBrute force will lead to TLE, thus we may think: use binary search to make `O(N^2)` to `O(NlogN)`.\\nThe core code of a `binary search` is as follows, and for each element in `spells`, we run a binary search on `potions` array, to find the \"edge\\u201C element.\\n**Example**:\\n`spells   `: [5, 1, 3]\\n`potions`: [1, 2, 3, 4, 5]\\n`success`: 7\\n\\nFor `5` in `spells`, the \"edge\" element in `potions` is `2` - index is `1`. When the binary search stops, index `low` will be bigger than index \\'high\\', i.e., `low` = `1`, `high` = `0`. And for `5` in `spells`, the number of potions will be `potions.size() - high - 1 = potions.size() - low` = `4`.\\n\\nFor `3` in `spells`, when binary search finished, index `low` = `2`, `high` = `1`, the number of potions will be `potions.size - high - 1 = potions.size() - low` = `3`\\n* binary search code \"template\"\\n\\t```\\n\\t/* \\n\\t* binary search core code\\n\\t* vec    - array / vector - like \\n\\t* target - represents the target value or target expression\\n\\t*\\n\\t* requirement: vec must be sorted from small to large\\n\\t*/\\n\\n\\n\\t/* search range: [low, high] */\\n\\tint high = vec.size()-1;\\n\\tint low  = 0;\\n\\twhile(low<=high)  /* search range: [low, high] */\\n\\t{\\n\\t  int mid = low + (high-low)/2;  /* equals to (high + low)/2 */ \\n\\t  if(target == vec[mid])return mid;\\n\\t  else if(target < vec[mid])high = mid-1;\\n\\t  else low  = mid+1;\\n\\t}\\n\\n\\n\\t/* search range: [low, high) */\\n\\tint high = vec.size();\\n\\tint low  = 0;\\n\\twhile (low < high)  /* search range: [0, N) */\\n\\t{\\n\\t  int mid = low + (high-low)/2;  /* equals to (high + low)/2 */ \\n\\t  if (target == vec[mid])return mid;\\n\\t  else if (target < vec[mid])high = mid;\\n\\t  else low = mid+1;\\n\\t}\\n\\n\\n\\t/* difference */\\n\\t/*\\n\\t* int high = vec.size()   --   int high = vec.size()-1\\n\\t* while(low<high)         --   while(low<=high)\\n\\t* high = mid              --   high = mid-1\\n\\t*/\\n\\t```\\n* Solution\\n\\t```\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tvector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n\\n\\t\\t\\tint n = spells.size();\\n\\t\\t\\tint m = potions.size();\\n\\n\\t\\t\\tsort(potions.begin(), potions.end());  /* prepare for binary search */\\n\\n\\t\\t\\tvector<int> ans(n, 0);  /* answer */\\n\\n\\t\\t\\tfor(int i = 0; i < n; ++i)  /* loop through all spells */\\n\\t\\t\\t{                 \\n\\t\\t\\t\\t/* perform binary search on potions array */\\n\\t\\t\\t\\tint high = potions.size()-1;  \\n\\t\\t\\t\\tint low  = 0;\\n\\t\\t\\t\\twhile(low <= high)  /* search range: [low, high] */\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint mid = low + (high-low)/2;\\n\\t\\t\\t\\t\\tlong long p = potions[mid], s = spells[i];\\n\\t\\t\\t\\t\\tif(p * s < success)low = mid+1;\\n\\t\\t\\t\\t\\telse high = mid-1;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tans[i] = m - high - 1;  /* m - high - 1 because when quiting binary search, low > high, can be also written as m - low */\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};\\n\\t```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n\\t/* \\n\\t* binary search core code\\n\\t* vec    - array / vector - like \\n\\t* target - represents the target value or target expression\\n\\t*\\n\\t* requirement: vec must be sorted from small to large\\n\\t*/\\n\\n\\n\\t/* search range: [low, high] */\\n\\tint high = vec.size()-1;\\n\\tint low  = 0;\\n\\twhile(low<=high)  /* search range: [low, high] */\\n\\t{\\n\\t  int mid = low + (high-low)/2;  /* equals to (high + low)/2 */ \\n\\t  if(target == vec[mid])return mid;\\n\\t  else if(target < vec[mid])high = mid-1;\\n\\t  else low  = mid+1;\\n\\t}\\n\\n\\n\\t/* search range: [low, high) */\\n\\tint high = vec.size();\\n\\tint low  = 0;\\n\\twhile (low < high)  /* search range: [0, N) */\\n\\t{\\n\\t  int mid = low + (high-low)/2;  /* equals to (high + low)/2 */ \\n\\t  if (target == vec[mid])return mid;\\n\\t  else if (target < vec[mid])high = mid;\\n\\t  else low = mid+1;\\n\\t}\\n\\n\\n\\t/* difference */\\n\\t/*\\n\\t* int high = vec.size()   --   int high = vec.size()-1\\n\\t* while(low<high)         --   while(low<=high)\\n\\t* high = mid              --   high = mid-1\\n\\t*/\\n\\t```\n```\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tvector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n\\n\\t\\t\\tint n = spells.size();\\n\\t\\t\\tint m = potions.size();\\n\\n\\t\\t\\tsort(potions.begin(), potions.end());  /* prepare for binary search */\\n\\n\\t\\t\\tvector<int> ans(n, 0);  /* answer */\\n\\n\\t\\t\\tfor(int i = 0; i < n; ++i)  /* loop through all spells */\\n\\t\\t\\t{                 \\n\\t\\t\\t\\t/* perform binary search on potions array */\\n\\t\\t\\t\\tint high = potions.size()-1;  \\n\\t\\t\\t\\tint low  = 0;\\n\\t\\t\\t\\twhile(low <= high)  /* search range: [low, high] */\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint mid = low + (high-low)/2;\\n\\t\\t\\t\\t\\tlong long p = potions[mid], s = spells[i];\\n\\t\\t\\t\\t\\tif(p * s < success)low = mid+1;\\n\\t\\t\\t\\t\\telse high = mid-1;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tans[i] = m - high - 1;  /* m - high - 1 because when quiting binary search, low > high, can be also written as m - low */\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 2139864,
                "title": "python-simple-binary-search-with-explanation-easy-to-undestand",
                "content": "# Full Explained Solution**\\n```\\nimport math\\nclass Solution:\\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\\n        res = [0] * len(spells)\\n        N = len(potions)\\n\\t\\t# sorting potions so we can use binary search on it\\n        potions.sort()\\n        \\n        for i,x in enumerate(spells): # i = index, x = value of spells\\n\\t\\t# req is the minimun value of potion strength, for spell to be successful.\\n\\t\\t# math.ceil(7.1) is 8.    As potion contains only integer, we need celling\\n            req = math.ceil(success/x)\\n            index = N  # assuming last index contains value just bigger than\\n            start, end = 0, N-1 \\n\\t\\t\\t\\n\\t\\t\\t# B.Search left most index, where val of potions is >= to celling in sorted potions.\\n            while start <= end:\\n                mid = start + (end-start)//2\\n                if req <= potions[mid]:\\n\\t\\t\\t\\t# found an index, but tries to find the index in left of the index\\n                    index = mid\\n                    end = mid-1\\n                else:\\n                    start = mid+1\\n\\t\\t\\t# len(potions = N & index = ( \"N\" is nothing found in BS or \"index\" that is found)\\n\\t\\t\\t#  All the values in potions from (index -> N) satisfy \"Success Condition\". append them\\n            res[i] = N - index \\n        return res\\n                \\n```\\nThumbs Up are appericiated\\n\\n\\n# clean code**\\n```\\nimport math\\nclass Solution:\\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\\n        N = len(potions)\\n        res = [0] * len(spells)\\n        potions.sort()\\n        \\n        \\n        for i,x in enumerate(spells):\\n            req = math.ceil(success/x)\\n            index = N\\n            start, end = 0, N-1 \\n            while start <= end:\\n                mid = start + (end-start)//2\\n                if req <= potions[mid]:\\n                    index = mid\\n                    end = mid-1\\n                else:\\n                    start = mid+1\\n            res[i] = N - index \\n        return res\\n                \\n  ```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "```\\nimport math\\nclass Solution:\\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\\n        res = [0] * len(spells)\\n        N = len(potions)\\n\\t\\t# sorting potions so we can use binary search on it\\n        potions.sort()\\n        \\n        for i,x in enumerate(spells): # i = index, x = value of spells\\n\\t\\t# req is the minimun value of potion strength, for spell to be successful.\\n\\t\\t# math.ceil(7.1) is 8.    As potion contains only integer, we need celling\\n            req = math.ceil(success/x)\\n            index = N  # assuming last index contains value just bigger than\\n            start, end = 0, N-1 \\n\\t\\t\\t\\n\\t\\t\\t# B.Search left most index, where val of potions is >= to celling in sorted potions.\\n            while start <= end:\\n                mid = start + (end-start)//2\\n                if req <= potions[mid]:\\n\\t\\t\\t\\t# found an index, but tries to find the index in left of the index\\n                    index = mid\\n                    end = mid-1\\n                else:\\n                    start = mid+1\\n\\t\\t\\t# len(potions = N & index = ( \"N\" is nothing found in BS or \"index\" that is found)\\n\\t\\t\\t#  All the values in potions from (index -> N) satisfy \"Success Condition\". append them\\n            res[i] = N - index \\n        return res\\n                \\n```\n```\\nimport math\\nclass Solution:\\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\\n        N = len(potions)\\n        res = [0] * len(spells)\\n        potions.sort()\\n        \\n        \\n        for i,x in enumerate(spells):\\n            req = math.ceil(success/x)\\n            index = N\\n            start, end = 0, N-1 \\n            while start <= end:\\n                mid = start + (end-start)//2\\n                if req <= potions[mid]:\\n                    index = mid\\n                    end = mid-1\\n                else:\\n                    start = mid+1\\n            res[i] = N - index \\n        return res\\n                \\n  ```",
                "codeTag": "Java"
            },
            {
                "id": 2139661,
                "title": "c-using-binary-search",
                "content": "**Approach:** we can sort potions so that if we find a minimal point j in potions where we get success for a spell[i] then j and every greter value than j will give us success, so n-j will be total pairs. And to find this minimal point we will use Binary Search.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        \\n        vector<int> res;\\n        int n = potions.size();\\n        sort(potions.begin(), potions.end());\\n        \\n        for (auto& spell : spells) {\\n            int start = 0, end= n-1;\\n            int mid;\\n            while (start <= end) {\\n                mid = (start + end)>>1;\\n                if((long long)spell*potions[mid] >= success)\\n                    end = mid-1;\\n                else\\n                    start = mid+1;\\n            }\\n            \\n            res.push_back(n-start);\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n**Please do upvote if you like the solution:)**",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        \\n        vector<int> res;\\n        int n = potions.size();\\n        sort(potions.begin(), potions.end());\\n        \\n        for (auto& spell : spells) {\\n            int start = 0, end= n-1;\\n            int mid;\\n            while (start <= end) {\\n                mid = (start + end)>>1;\\n                if((long long)spell*potions[mid] >= success)\\n                    end = mid-1;\\n                else\\n                    start = mid+1;\\n            }\\n            \\n            res.push_back(n-start);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2139468,
                "title": "c-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        vector<int> ans(spells.size());\\n        \\n        sort(begin(potions),end(potions));\\n        \\n        for(int i=0;i<spells.size();i++)\\n        {\\n\\t\\t\\tlong long val = (success + spells[i] - 1)/(spells[i]*1ll);  //take ceil value during division\\n            \\n            int idx = lower_bound(begin(potions),end(potions),val) - begin(potions);\\n            \\n            ans[i] = max((int)potions.size() - idx,0);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        vector<int> ans(spells.size());\\n        \\n        sort(begin(potions),end(potions));\\n        \\n        for(int i=0;i<spells.size();i++)\\n        {\\n\\t\\t\\tlong long val = (success + spells[i] - 1)/(spells[i]*1ll);  //take ceil value during division\\n            \\n            int idx = lower_bound(begin(potions),end(potions),val) - begin(potions);\\n            \\n            ans[i] = max((int)potions.size() - idx,0);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2139411,
                "title": "rust-native-binary-search-solution",
                "content": "```rust\\nuse std::cmp::Ordering;\\n\\nimpl Solution {\\n    pub fn successful_pairs(spells: Vec<i32>, mut potions: Vec<i32>, success: i64) -> Vec<i32> {\\n        let num_potions = potions.len() as i32;\\n        potions.sort_unstable();\\n\\n        let mut result = vec![0; spells.len()];\\n\\n        for (i, spell) in spells.into_iter().enumerate() {\\n            let left = potions\\n                .binary_search_by(|&potion| match (potion as i64 * spell as i64).cmp(&success) {\\n                    Ordering::Less => Ordering::Less,\\n                    // treat equal element as greater so that the BS will always terminate with\\n                    // Error() containing the index of element that is greater or equal to one we\\n                    // searched for\\n                    Ordering::Equal => Ordering::Greater,\\n                    Ordering::Greater => Ordering::Greater,\\n                })\\n                .unwrap_err() as i32;\\n\\n            result[i] = (num_potions - left) as i32;\\n        }\\n\\n        result\\n    }\\n}\\n```\\n\\nBinary search example:\\n\\n```rust\\n#[test]\\nfn test6() {\\n\\t// 4 is missing\\n\\tlet sample = vec![1, 2, 3, 5, 6, 7, 7];\\n\\tlet left = sample\\n\\t\\t.binary_search_by(|&potion| match potion.cmp(&4) {\\n\\t\\t\\tOrdering::Less => Ordering::Less,\\n\\t\\t\\tOrdering::Equal => Ordering::Greater,\\n\\t\\t\\tOrdering::Greater => Ordering::Greater,\\n\\t\\t})\\n\\t\\t.unwrap_err();\\n\\tassert_eq!(sample[left], 5);\\n\\n\\tlet left = sample\\n\\t\\t.binary_search_by(|&potion| match potion.cmp(&3) {\\n\\t\\t\\tOrdering::Less => Ordering::Less,\\n\\t\\t\\tOrdering::Equal => Ordering::Greater,\\n\\t\\t\\tOrdering::Greater => Ordering::Greater,\\n\\t\\t})\\n\\t\\t.unwrap_err();\\n\\tassert_eq!(sample[left], 3);\\n}\\n```\\n\\nEquivalent for:\\n\\n```rust\\nimpl Solution {\\n    pub fn successful_pairs(spells: Vec<i32>, mut potions: Vec<i32>, success: i64) -> Vec<i32> {\\n        let num_potions = potions.len();\\n        potions.sort_unstable();\\n\\n        let mut result = vec![0; spells.len()];\\n\\n        for (i, spell) in spells.into_iter().enumerate() {\\n            let mut left = 0;\\n            let mut right = num_potions;\\n\\n            while left < right {\\n                let mid = left + (right - left) / 2;\\n                if spell as i64 * potions[mid] as i64 >= success {\\n                    right = mid;\\n                } else {\\n                    left = mid + 1;\\n                }\\n            }\\n\\n            result[i] = (num_potions - left) as i32;\\n        }\\n\\n        result\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Binary Tree"
                ],
                "code": "```rust\\nuse std::cmp::Ordering;\\n\\nimpl Solution {\\n    pub fn successful_pairs(spells: Vec<i32>, mut potions: Vec<i32>, success: i64) -> Vec<i32> {\\n        let num_potions = potions.len() as i32;\\n        potions.sort_unstable();\\n\\n        let mut result = vec![0; spells.len()];\\n\\n        for (i, spell) in spells.into_iter().enumerate() {\\n            let left = potions\\n                .binary_search_by(|&potion| match (potion as i64 * spell as i64).cmp(&success) {\\n                    Ordering::Less => Ordering::Less,\\n                    // treat equal element as greater so that the BS will always terminate with\\n                    // Error() containing the index of element that is greater or equal to one we\\n                    // searched for\\n                    Ordering::Equal => Ordering::Greater,\\n                    Ordering::Greater => Ordering::Greater,\\n                })\\n                .unwrap_err() as i32;\\n\\n            result[i] = (num_potions - left) as i32;\\n        }\\n\\n        result\\n    }\\n}\\n```\n```rust\\n#[test]\\nfn test6() {\\n\\t// 4 is missing\\n\\tlet sample = vec![1, 2, 3, 5, 6, 7, 7];\\n\\tlet left = sample\\n\\t\\t.binary_search_by(|&potion| match potion.cmp(&4) {\\n\\t\\t\\tOrdering::Less => Ordering::Less,\\n\\t\\t\\tOrdering::Equal => Ordering::Greater,\\n\\t\\t\\tOrdering::Greater => Ordering::Greater,\\n\\t\\t})\\n\\t\\t.unwrap_err();\\n\\tassert_eq!(sample[left], 5);\\n\\n\\tlet left = sample\\n\\t\\t.binary_search_by(|&potion| match potion.cmp(&3) {\\n\\t\\t\\tOrdering::Less => Ordering::Less,\\n\\t\\t\\tOrdering::Equal => Ordering::Greater,\\n\\t\\t\\tOrdering::Greater => Ordering::Greater,\\n\\t\\t})\\n\\t\\t.unwrap_err();\\n\\tassert_eq!(sample[left], 3);\\n}\\n```\n```rust\\nimpl Solution {\\n    pub fn successful_pairs(spells: Vec<i32>, mut potions: Vec<i32>, success: i64) -> Vec<i32> {\\n        let num_potions = potions.len();\\n        potions.sort_unstable();\\n\\n        let mut result = vec![0; spells.len()];\\n\\n        for (i, spell) in spells.into_iter().enumerate() {\\n            let mut left = 0;\\n            let mut right = num_potions;\\n\\n            while left < right {\\n                let mid = left + (right - left) / 2;\\n                if spell as i64 * potions[mid] as i64 >= success {\\n                    right = mid;\\n                } else {\\n                    left = mid + 1;\\n                }\\n            }\\n\\n            result[i] = (num_potions - left) as i32;\\n        }\\n\\n        result\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2139358,
                "title": "successful-pairs-of-spells-and-potions",
                "content": "**Easy approach Binary search --**\\n**Please Upvote**\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& s, vector<int>& p, long long ss) {\\n           sort(p.begin() , p.end());\\n          vector<long long> res(s.size());\\n          for(int i = 0 ; i< s.size() ; ++i){\\n              res[i] = (ss/s[i]);\\n          }\\n        \\n        vector<int> ans;\\n        for(int i = 0 ;  i < s.size() ; ++i){\\n            \\n            if(ss <= 1LL*res[i]*s[i] ){\\n                 int ind = lower_bound(p.begin() , p.end() , res[i])  - p.begin() ;   \\n                ans.push_back(p.size() - ind);\\n            }else{\\n                 int ind = upper_bound(p.begin() , p.end() , res[i])  - p.begin() ;\\n                      \\n                ans.push_back(p.size() - ind);\\n            }                   \\n           \\n        }\\n           \\n        return ans;\\n        \\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& s, vector<int>& p, long long ss) {\\n           sort(p.begin() , p.end());\\n          vector<long long> res(s.size());\\n          for(int i = 0 ; i< s.size() ; ++i){\\n              res[i] = (ss/s[i]);\\n          }\\n        \\n        vector<int> ans;\\n        for(int i = 0 ;  i < s.size() ; ++i){\\n            \\n            if(ss <= 1LL*res[i]*s[i] ){\\n                 int ind = lower_bound(p.begin() , p.end() , res[i])  - p.begin() ;   \\n                ans.push_back(p.size() - ind);\\n            }else{\\n                 int ind = upper_bound(p.begin() , p.end() , res[i])  - p.begin() ;\\n                      \\n                ans.push_back(p.size() - ind);\\n            }                   \\n           \\n        }\\n           \\n        return ans;\\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2139299,
                "title": "java-binary-search-sorting",
                "content": "First we sort the potions array, so ,for each spells[i] , we just have to find the smallest index of sorted potions array for which the product is greater than \\'success\\' ... then we can subtract this index from \\'potions\\' array length ... since all the indices after \\'this\\' ( we just found)  index will also provide product greater than success ( since the array is sorted )  \\n\\n\\n\\n\\n```\\n\\n\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        int[] potions1 = new int[potions.length];\\n        for(int i=0;i<potions.length;i++){\\n            potions1[i] = potions[i];\\n        }\\n        Arrays.sort(potions1);\\n        int[] arr = new int[spells.length];\\n        \\n        for(int i=0;i<spells.length;i++){\\n            int m = -1;\\n            int n = potions1.length;\\n            long count = 0;\\n            while(n>m+1){\\n                int mid = (m+n)/2;\\n                long mul = (long)spells[i]*(long)potions1[mid];\\n                if(mul >= success){\\n                    n = mid;\\n                }else{\\n                    m = mid;\\n                }\\n            }\\n            \\n            arr[i] = Math.max(arr[i] ,potions1.length - n);\\n            \\n            \\n        }\\n        return arr;\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "```\\n\\n\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        int[] potions1 = new int[potions.length];\\n        for(int i=0;i<potions.length;i++){\\n            potions1[i] = potions[i];\\n        }\\n        Arrays.sort(potions1);\\n        int[] arr = new int[spells.length];\\n        \\n        for(int i=0;i<spells.length;i++){\\n            int m = -1;\\n            int n = potions1.length;\\n            long count = 0;\\n            while(n>m+1){\\n                int mid = (m+n)/2;\\n                long mul = (long)spells[i]*(long)potions1[mid];\\n                if(mul >= success){\\n                    n = mid;\\n                }else{\\n                    m = mid;\\n                }\\n            }\\n            \\n            arr[i] = Math.max(arr[i] ,potions1.length - n);\\n            \\n            \\n        }\\n        return arr;\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2139262,
                "title": "easy-to-understand",
                "content": "```\\n public int[] successfulPairs(int[] spells, int[] positions, long suc) {\\n        Arrays.sort(positions);\\n        int []res = new int[spells.length];\\n         for(int i = 0; i<spells.length ;i++){\\n             \\n             int l = 0 , r = positions.length-1;\\n             int num = 0;\\n             while(l<= r){\\n                 \\n                 int m = (r+l)/2;\\n                 long prod = ((long)spells[i]*positions[m]);\\n                 if(prod >=suc){\\n                     r = m-1;\\n                     num = positions.length-m;\\n                 }else{\\n                     l = m+1;\\n                 }\\n             }\\n             res[i] = num;\\n         }\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\n public int[] successfulPairs(int[] spells, int[] positions, long suc) {\\n        Arrays.sort(positions);\\n        int []res = new int[spells.length];\\n         for(int i = 0; i<spells.length ;i++){\\n             \\n             int l = 0 , r = positions.length-1;\\n             int num = 0;\\n             while(l<= r){\\n                 \\n                 int m = (r+l)/2;\\n                 long prod = ((long)spells[i]*positions[m]);\\n                 if(prod >=suc){\\n                     r = m-1;\\n                     num = positions.length-m;\\n                 }else{\\n                     l = m+1;\\n                 }\\n             }\\n             res[i] = num;\\n         }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2139243,
                "title": "c-solution-using-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    int find(vector<int>&nums,long long val,long long max_val)\\n    {\\n        int l=0;\\n        int r=nums.size()-1;\\n        int ans=0;\\n        int n=nums.size();\\n        while(l<=r)\\n        {\\n            int mid=(l+r)/2;\\n            if((1ll)*nums[mid]*val>=max_val)\\n            {\\n                ans=n-mid;\\n                r=mid-1;\\n            }\\n            else\\n            {\\n                l=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n    vector<int> successfulPairs(vector<int>& s, vector<int>& nums, long long success) \\n    {\\n        int n=s.size();\\n        vector<int>ans;\\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<n;i++)\\n        {\\n            int val=find(nums,s[i],success);\\n            ans.push_back(val);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int find(vector<int>&nums,long long val,long long max_val)\\n    {\\n        int l=0;\\n        int r=nums.size()-1;\\n        int ans=0;\\n        int n=nums.size();\\n        while(l<=r)\\n        {\\n            int mid=(l+r)/2;\\n            if((1ll)*nums[mid]*val>=max_val)\\n            {\\n                ans=n-mid;\\n                r=mid-1;\\n            }\\n            else\\n            {\\n                l=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n    vector<int> successfulPairs(vector<int>& s, vector<int>& nums, long long success) \\n    {\\n        int n=s.size();\\n        vector<int>ans;\\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<n;i++)\\n        {\\n            int val=find(nums,s[i],success);\\n            ans.push_back(val);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2139108,
                "title": "c-simple-code-with-binary-search-o-n-logn",
                "content": "```\\nclass Solution {\\npublic:\\n    int solve(vector<int>& p, int i, long long success){\\n        long l = 0, h = p.size()-1;\\n        \\n        while(l <= h){\\n            long mid = l + (h-l)/2;\\n            \\n            if((long long)p[mid]*i >= success){\\n                h = mid-1;\\n            }\\n            else{\\n                l = mid+1;\\n            }\\n        }\\n        \\n        return p.size() - l;\\n    }\\n    \\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        sort(potions.begin(), potions.end());\\n        vector<int> ans;\\n        \\n        for(int i : spells){\\n            int count = solve(potions, i, success);\\n        \\n            if(count < 0)\\n                ans.push_back(0);\\n            else\\n                ans.push_back(count);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(vector<int>& p, int i, long long success){\\n        long l = 0, h = p.size()-1;\\n        \\n        while(l <= h){\\n            long mid = l + (h-l)/2;\\n            \\n            if((long long)p[mid]*i >= success){\\n                h = mid-1;\\n            }\\n            else{\\n                l = mid+1;\\n            }\\n        }\\n        \\n        return p.size() - l;\\n    }\\n    \\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        sort(potions.begin(), potions.end());\\n        vector<int> ans;\\n        \\n        for(int i : spells){\\n            int count = solve(potions, i, success);\\n        \\n            if(count < 0)\\n                ans.push_back(0);\\n            else\\n                ans.push_back(count);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2139038,
                "title": "c-o-n-log-m-using-sorting-and-binary-search-code-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    // Sorting and Binary Search\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        int n = spells.size(), m = potions.size();\\n        sort(potions.begin(), potions.end()); // Sorting potions so that we can binary search on it\\n        vector<int> ans;\\n        for(int i = 0; i < n; i++) { // For every spell, binary search on the number of potions that can be used such that spells[i] * potions[j] >= success\\n            int l = 0, r = m - 1, c = m;\\n            while(l <= r) {\\n                int mid = l + (r - l) / 2;\\n                if((((long long)potions[mid]) * ((long long)spells[i])) >= success) { // If this particular potion satisfies the condition, then we know that all the potions from potions[mid] to potions[m - 1] should satisfy the condition as well. Hence, we now store this index in \\'c\\' and proceed to find if any lower index in potions satisfy the condition or not\\n                    c = mid;\\n                    r = mid - 1;\\n                } else { // Condition is not satisfied. Hence, we proceed to a higher index to see if the condition is satisfied for any index\\n                    l = mid + 1;\\n                }\\n            }\\n            ans.push_back(m - c); // Since all potions from potions[c] to potions[m - 1] satisfy the condition, we have \\'m - c\\' pairs for this particular spell\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // Sorting and Binary Search\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        int n = spells.size(), m = potions.size();\\n        sort(potions.begin(), potions.end()); // Sorting potions so that we can binary search on it\\n        vector<int> ans;\\n        for(int i = 0; i < n; i++) { // For every spell, binary search on the number of potions that can be used such that spells[i] * potions[j] >= success\\n            int l = 0, r = m - 1, c = m;\\n            while(l <= r) {\\n                int mid = l + (r - l) / 2;\\n                if((((long long)potions[mid]) * ((long long)spells[i])) >= success) { // If this particular potion satisfies the condition, then we know that all the potions from potions[mid] to potions[m - 1] should satisfy the condition as well. Hence, we now store this index in \\'c\\' and proceed to find if any lower index in potions satisfy the condition or not\\n                    c = mid;\\n                    r = mid - 1;\\n                } else { // Condition is not satisfied. Hence, we proceed to a higher index to see if the condition is satisfied for any index\\n                    l = mid + 1;\\n                }\\n            }\\n            ans.push_back(m - c); // Since all potions from potions[c] to potions[m - 1] satisfy the condition, we have \\'m - c\\' pairs for this particular spell\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2139019,
                "title": "c-easy-to-understand-ultimate-binary-search-solution",
                "content": "```\\n#define ll long long int\\n#define ld long double\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& p, long long success) {\\n        sort(p.begin(),p.end());\\n        ll n=p.size();\\n\\n        vector<int> ans;\\n        for(int x:spells)\\n        {\\n            ll up=ceil((success)/(1.0*x));\\n            ll idx=lower_bound(p.begin(),p.end(),up)-p.begin();\\n            if(idx==n)\\n            {\\n                ans.push_back(0);\\n            }\\n            else\\n            ans.push_back(n-idx);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**",
                "solutionTags": [],
                "code": "```\\n#define ll long long int\\n#define ld long double\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& p, long long success) {\\n        sort(p.begin(),p.end());\\n        ll n=p.size();\\n\\n        vector<int> ans;\\n        for(int x:spells)\\n        {\\n            ll up=ceil((success)/(1.0*x));\\n            ll idx=lower_bound(p.begin(),p.end(),up)-p.begin();\\n            if(idx==n)\\n            {\\n                ans.push_back(0);\\n            }\\n            else\\n            ans.push_back(n-idx);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2138991,
                "title": "beginner-friendly-solution-with-explanation",
                "content": "we are sorting the array potion and performing binary search for each element of array spell and finding the highest index such that spell[i]*poition[i] < success. and storing answer in answer vector\\ntime complexity O(nlogm)\\n\\n```\\nclass Solution {\\npublic:\\n    int find(vector<int>&potions, long long num1, long long success){\\n        int l = 0, r = potions.size()-1;\\n        while(l <= r){\\n            int mid = l+(r-l)/2;\\n            long long num2 = potions[mid];\\n            if(num1*num2 < success){\\n                l = mid+1;\\n            }else{\\n                r = mid-1;\\n            }\\n        }\\n        return l;\\n    }\\n    \\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        sort(potions.begin(), potions.end());\\n        int n = spells.size();\\n        vector<int>ans;\\n        int m = potions.size();\\n        for(int i=0; i<n; i++){\\n            int idx=find(potions, spells[i], success);\\n            if(idx >= m){\\n                ans.push_back(0);\\n                continue;\\n            }\\n            ans.push_back(m-idx);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int find(vector<int>&potions, long long num1, long long success){\\n        int l = 0, r = potions.size()-1;\\n        while(l <= r){\\n            int mid = l+(r-l)/2;\\n            long long num2 = potions[mid];\\n            if(num1*num2 < success){\\n                l = mid+1;\\n            }else{\\n                r = mid-1;\\n            }\\n        }\\n        return l;\\n    }\\n    \\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        sort(potions.begin(), potions.end());\\n        int n = spells.size();\\n        vector<int>ans;\\n        int m = potions.size();\\n        for(int i=0; i<n; i++){\\n            int idx=find(potions, spells[i], success);\\n            if(idx >= m){\\n                ans.push_back(0);\\n                continue;\\n            }\\n            ans.push_back(m-idx);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2138908,
                "title": "binary-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        sort(potions.begin(),potions.end());\\n        vector<int> ans;\\n        int n=potions.size();\\n        for(int i=0;i<spells.size();i++){\\n            int l=0;\\n            int r=potions.size()-1;\\n            //Binary Search to track from where product is greater than success\\n            while(r>=l){\\n                int mid=l+(r-l)/2;\\n                long long temp = ((long long)(potions[mid])*spells[i]);\\n                if(temp>=success)\\n                    r=mid-1;\\n                else\\n                    l=mid+1;\\n            }\\n            \\n            ans.push_back(n-l);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        sort(potions.begin(),potions.end());\\n        vector<int> ans;\\n        int n=potions.size();\\n        for(int i=0;i<spells.size();i++){\\n            int l=0;\\n            int r=potions.size()-1;\\n            //Binary Search to track from where product is greater than success\\n            while(r>=l){\\n                int mid=l+(r-l)/2;\\n                long long temp = ((long long)(potions[mid])*spells[i]);\\n                if(temp>=success)\\n                    r=mid-1;\\n                else\\n                    l=mid+1;\\n            }\\n            \\n            ans.push_back(n-l);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2138904,
                "title": "binary-search-python",
                "content": "```\\nclass Solution:\\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\\n        ans = []\\n        potions.sort()\\n        m = len(potions)\\n        for s in spells:\\n            l, r = 0, m-1\\n            while l<r:\\n                mid = (r-l)//2+l\\n                if s*potions[mid]>=success:\\n                    r=mid\\n                else:\\n                    l =mid+1\\n            if l==m-1 and s*potions[l]<success:\\n                ans.append(0)\\n            else:\\n                ans.append(m-l)\\n        return ans\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\\n        ans = []\\n        potions.sort()\\n        m = len(potions)\\n        for s in spells:\\n            l, r = 0, m-1\\n            while l<r:\\n                mid = (r-l)//2+l\\n                if s*potions[mid]>=success:\\n                    r=mid\\n                else:\\n                    l =mid+1\\n            if l==m-1 and s*potions[l]<success:\\n                ans.append(0)\\n            else:\\n                ans.append(m-l)\\n        return ans\\n",
                "codeTag": "Java"
            },
            {
                "id": 2138871,
                "title": "easy-math-ratio-solution-binary-search-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        sort(potions.begin(),potions.end());\\n        int n = spells.size(),m = potions.size();\\n        vector<int> ans;\\n        for(int i = 0; i < n; i++){\\n            double ratio = (double)success / spells[i];\\n            long long mnfind = ceil(ratio);\\n            vector<int>::iterator lower = lower_bound(potions.begin(), potions.end(), mnfind);\\n            int x = lower - potions.begin();\\n            ans.push_back(m - x);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        sort(potions.begin(),potions.end());\\n        int n = spells.size(),m = potions.size();\\n        vector<int> ans;\\n        for(int i = 0; i < n; i++){\\n            double ratio = (double)success / spells[i];\\n            long long mnfind = ceil(ratio);\\n            vector<int>::iterator lower = lower_bound(potions.begin(), potions.end(), mnfind);\\n            int x = lower - potions.begin();\\n            ans.push_back(m - x);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2138844,
                "title": "binary-search-o-1-space-comment-s",
                "content": "```\\nclass Solution {\\npublic:\\n    // simple binary search\\n    int bs(vector<int> &num,int &x,long long &success){\\n        int l=0,r=num.size()-1;\\n        while(l<=r){\\n            int mid = l + (r-l)/2;\\n            long long m = (long long)x*num[mid];\\n            if(m>=success){\\n                r=mid-1;\\n            }else{\\n                l=mid+1;\\n            }\\n        }\\n        return l;\\n    }\\n    \\n    vector<int> successfulPairs(vector<int>& s, vector<int>& p, long long success) {\\n        // here we will not use any extra space just update answer to spell array\\n        // sort poision array\\n        sort(p.begin(),p.end());\\n        // iterate over spell array\\n        for(int i=0;i<s.size();i++){\\n            // pass poision vector , spell[i] and success to binary search\\n            // subtract it from poision size \\n            // because we will get number of small multiplication\\n            s[i] = p.size()-bs(p,s[i],success);\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // simple binary search\\n    int bs(vector<int> &num,int &x,long long &success){\\n        int l=0,r=num.size()-1;\\n        while(l<=r){\\n            int mid = l + (r-l)/2;\\n            long long m = (long long)x*num[mid];\\n            if(m>=success){\\n                r=mid-1;\\n            }else{\\n                l=mid+1;\\n            }\\n        }\\n        return l;\\n    }\\n    \\n    vector<int> successfulPairs(vector<int>& s, vector<int>& p, long long success) {\\n        // here we will not use any extra space just update answer to spell array\\n        // sort poision array\\n        sort(p.begin(),p.end());\\n        // iterate over spell array\\n        for(int i=0;i<s.size();i++){\\n            // pass poision vector , spell[i] and success to binary search\\n            // subtract it from poision size \\n            // because we will get number of small multiplication\\n            s[i] = p.size()-bs(p,s[i],success);\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3895036,
                "title": "easy-c-solution-beats-100-using-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nwe need to find the minimum possible element in potions which can be an answer all  the numbers greter to it will be a solution.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nfirst we will  sort the potions array. iterate through the spells array to find the answer for each spell. using binary search we find the minimum element which can be an answer. all the numbers inpotions greater than potions[mid] will also be an answer as will make the product bigger than befor. so we consider potions.size() - mid elements as our answer.\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long s) {\\n        sort(potions.begin(),potions.end());\\n        vector<int> ans;\\n        for(int i = 0; i < spells.size(); i++){\\n            int l = 0;\\n            int r = potions.size()-1;\\n            int temp = 0;\\n            while(l <= r){\\n                int mid = (l + r)/2;\\n                if((long long)spells[i] * (long long)potions[mid] < s){\\n                    l = mid + 1;\\n                }\\n                else{\\n                    temp = potions.size() - mid;\\n                    r = mid - 1;\\n                }\\n            }\\n            ans.push_back(temp);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long s) {\\n        sort(potions.begin(),potions.end());\\n        vector<int> ans;\\n        for(int i = 0; i < spells.size(); i++){\\n            int l = 0;\\n            int r = potions.size()-1;\\n            int temp = 0;\\n            while(l <= r){\\n                int mid = (l + r)/2;\\n                if((long long)spells[i] * (long long)potions[mid] < s){\\n                    l = mid + 1;\\n                }\\n                else{\\n                    temp = potions.size() - mid;\\n                    r = mid - 1;\\n                }\\n            }\\n            ans.push_back(temp);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3796607,
                "title": "python",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def successfulPairs(\\n        self, spells: List[int], potions: List[int], success: int\\n    ) -> List[int]:\\n        potions.sort()\\n        m = len(potions)\\n        return [m - bisect_left(potions, success / v) for v in spells]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def successfulPairs(\\n        self, spells: List[int], potions: List[int], success: int\\n    ) -> List[int]:\\n        potions.sort()\\n        m = len(potions)\\n        return [m - bisect_left(potions, success / v) for v in spells]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3738801,
                "title": "sorting-mlogm-and-traverse-binary-serach-nlogm-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        sort(potions.begin(),potions.end());\\n        int n=spells.size();\\n        vector<int>pairs(n,0);\\n        int m=potions.size();\\n        for(int i=0;i<n;i++){\\n            int l=0,r=m-1;\\n            while(l<=r){\\n                int mid=l+(r-l)/2;\\n                if(1LL*potions[mid]*spells[i]>=success){\\n                     r=mid-1;\\n\\n                }\\n                else{\\n                    l=mid+1;\\n                }\\n            }\\n            pairs[i]=m-l;\\n\\n        }\\n        return pairs;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        sort(potions.begin(),potions.end());\\n        int n=spells.size();\\n        vector<int>pairs(n,0);\\n        int m=potions.size();\\n        for(int i=0;i<n;i++){\\n            int l=0,r=m-1;\\n            while(l<=r){\\n                int mid=l+(r-l)/2;\\n                if(1LL*potions[mid]*spells[i]>=success){\\n                     r=mid-1;\\n\\n                }\\n                else{\\n                    l=mid+1;\\n                }\\n            }\\n            pairs[i]=m-l;\\n\\n        }\\n        return pairs;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3717671,
                "title": "easy-c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n\\n        int n = spells.size();\\n        int m = potions.size();\\n\\n        vector<int>ans;\\n\\n        sort(potions.begin(),potions.end());\\n        \\n        for(auto& x: spells){\\n            int s=0;\\n            int e = m-1;\\n            while(s<=e){\\n\\n                int mid = s+(e-s)/2;\\n                long long a = ceil((1.0 * success)/x);\\n                if(potions[mid]>=a){\\n                    e=mid-1;\\n                }\\n                else{\\n                    s=mid+1;\\n                }\\n            }\\n\\n            ans.push_back(m-s);\\n\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n\\n        int n = spells.size();\\n        int m = potions.size();\\n\\n        vector<int>ans;\\n\\n        sort(potions.begin(),potions.end());\\n        \\n        for(auto& x: spells){\\n            int s=0;\\n            int e = m-1;\\n            while(s<=e){\\n\\n                int mid = s+(e-s)/2;\\n                long long a = ceil((1.0 * success)/x);\\n                if(potions[mid]>=a){\\n                    e=mid-1;\\n                }\\n                else{\\n                    s=mid+1;\\n                }\\n            }\\n\\n            ans.push_back(m-s);\\n\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3626556,
                "title": "c-sorting-lower-bound-easy-solution",
                "content": "# Approach\\n- Sort the portions array in ascending order.\\n- Iterate over the spells array and for each spells[i], find the minimum required potion for it. \\n- Check for the index of potion in potions array using binary search to find the number of potions greter than required.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        vector<int> ans;\\n        int n=potions.size();\\n        sort(potions.begin(),potions.end());\\n        for(int i=0;i<spells.size();i++){\\n            long long req = ceil(1.0 * success/spells[i]);\\n            if(req>potions[potions.size()-1]){\\n                ans.push_back(0);\\n                continue;\\n            }\\n            auto idx= lower_bound(potions.begin(),potions.end(),req) - potions.begin();\\n            ans.push_back(n-idx);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**Please upvote if it helped. Happy Coding!**",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        vector<int> ans;\\n        int n=potions.size();\\n        sort(potions.begin(),potions.end());\\n        for(int i=0;i<spells.size();i++){\\n            long long req = ceil(1.0 * success/spells[i]);\\n            if(req>potions[potions.size()-1]){\\n                ans.push_back(0);\\n                continue;\\n            }\\n            auto idx= lower_bound(potions.begin(),potions.end(),req) - potions.begin();\\n            ans.push_back(n-idx);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3565630,
                "title": "99-90-beats-c-o-n-m-k-0ms",
                "content": "\\n# Complexity\\n- Time complexity: O(n+m+k)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(maxSpell)\\nwhere, maxSpell is the maximum value in the spells vector. The counts vector is created with a size of maxSpell+1, which contributes to the space complexity.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution \\n{\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) \\n    {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n\\n        int maxSpell = 0;\\n        for(int i=0; i<spells.size(); ++i){  //O(n)\\n            maxSpell = max(maxSpell, spells[i]);\\n        }\\n        vector<int> counts(maxSpell+1, 0);\\n\\n        for(int i=0; i<potions.size(); ++i){ //O(m)\\n            auto index = (success+potions[i]-1)/potions[i]; //minimum required spell power\\n            if(index<counts.size()) counts[index]++;\\n        }\\n\\n        for(int i=1; i<counts.size(); ++i){ //O(k)\\n            counts[i] +=counts[i-1];\\n        }\\n\\n        vector<int> result(spells.size(), 0);\\n        for(int i=0; i<spells.size(); ++i){ //O(n)\\n            result[i] = counts[spells[i]];\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) \\n    {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n\\n        int maxSpell = 0;\\n        for(int i=0; i<spells.size(); ++i){  //O(n)\\n            maxSpell = max(maxSpell, spells[i]);\\n        }\\n        vector<int> counts(maxSpell+1, 0);\\n\\n        for(int i=0; i<potions.size(); ++i){ //O(m)\\n            auto index = (success+potions[i]-1)/potions[i]; //minimum required spell power\\n            if(index<counts.size()) counts[index]++;\\n        }\\n\\n        for(int i=1; i<counts.size(); ++i){ //O(k)\\n            counts[i] +=counts[i-1];\\n        }\\n\\n        vector<int> result(spells.size(), 0);\\n        for(int i=0; i<spells.size(); ++i){ //O(n)\\n            result[i] = counts[spells[i]];\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3395355,
                "title": "python-simple-solution-easy-to-understand",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\\n\\n        potions.sort()\\n        n=len(potions)\\n        arr=[]\\n        for i in spells:\\n            if(i*potions[n-1]<success):\\n                arr.append(0)\\n            else:\\n                num=math.ceil(success/i)\\n                start=0\\n                end=n\\n                flag=0\\n                while(start<=end):\\n                    mid=(start+end)//2\\n                    if(mid<n and potions[mid]>=num and potions[mid-1]<num):\\n                        arr.append(n-mid)\\n                        flag=1\\n                        break\\n                    elif(mid<n and potions[mid]<num):\\n                        start=mid+1\\n                    else:\\n                        end=mid-1\\n                if(flag==0):\\n                    arr.append(n-mid)\\n        return arr\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Two Pointers",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\\n\\n        potions.sort()\\n        n=len(potions)\\n        arr=[]\\n        for i in spells:\\n            if(i*potions[n-1]<success):\\n                arr.append(0)\\n            else:\\n                num=math.ceil(success/i)\\n                start=0\\n                end=n\\n                flag=0\\n                while(start<=end):\\n                    mid=(start+end)//2\\n                    if(mid<n and potions[mid]>=num and potions[mid-1]<num):\\n                        arr.append(n-mid)\\n                        flag=1\\n                        break\\n                    elif(mid<n and potions[mid]<num):\\n                        start=mid+1\\n                    else:\\n                        end=mid-1\\n                if(flag==0):\\n                    arr.append(n-mid)\\n        return arr\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3376030,
                "title": "simple-solution",
                "content": "\\n\\n# Code\\n```\\npublic class Solution {\\n    public int[] SuccessfulPairs(int[] spells, int[] potions, long success) {\\n        \\n        Array.Sort(potions);\\n        List<int> res = new List<int>();\\n\\n        foreach (int spell in spells) {\\n            int l = 0;\\n            int r = potions.Length - 1;\\n            int index = potions.Length;\\n\\n            while (l <= r) {\\n                int m = (l + r) / 2;\\n\\n                if (((long)spell * potions[m]) >= success) {\\n                    r = m - 1;\\n                    index = m;\\n                } else {\\n                    l = m + 1;\\n                }\\n            }\\n\\n            res.Add(potions.Length - index);\\n        }\\n\\n        return res.ToArray();\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int[] SuccessfulPairs(int[] spells, int[] potions, long success) {\\n        \\n        Array.Sort(potions);\\n        List<int> res = new List<int>();\\n\\n        foreach (int spell in spells) {\\n            int l = 0;\\n            int r = potions.Length - 1;\\n            int index = potions.Length;\\n\\n            while (l <= r) {\\n                int m = (l + r) / 2;\\n\\n                if (((long)spell * potions[m]) >= success) {\\n                    r = m - 1;\\n                    index = m;\\n                } else {\\n                    l = m + 1;\\n                }\\n            }\\n\\n            res.Add(potions.Length - index);\\n        }\\n\\n        return res.ToArray();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3374581,
                "title": "simple-java-1ms-beats-100-easy-to-understand-look-at-once",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach: simple binary search approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n         Arrays.sort(potions);\\n        int[] count = new int[spells.length];\\n       \\n        for (int i = 0; i < spells.length; i++) {\\n            int spell = spells[i];\\n            int low = 0;\\n            int high = potions.length - 1;\\n            while (low <= high) {\\n                int mid = low + (high - low) / 2;\\n                long product = (long) spell * potions[mid];\\n                if (product >= success) {\\n                    high = mid - 1;\\n                } else {\\n                    low = mid + 1;\\n                }\\n            }\\n            count[i] = potions.length - low;\\n        }\\n        return count;\\n    }\\n}\\n```\\n# If this solution helped you, give it an up-vote to help others![download.jfif](https://assets.leetcode.com/users/images/3b0f35ff-0fad-47ea-809c-46a596b73c5f_1680525047.0606627.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n         Arrays.sort(potions);\\n        int[] count = new int[spells.length];\\n       \\n        for (int i = 0; i < spells.length; i++) {\\n            int spell = spells[i];\\n            int low = 0;\\n            int high = potions.length - 1;\\n            while (low <= high) {\\n                int mid = low + (high - low) / 2;\\n                long product = (long) spell * potions[mid];\\n                if (product >= success) {\\n                    high = mid - 1;\\n                } else {\\n                    low = mid + 1;\\n                }\\n            }\\n            count[i] = potions.length - low;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3373247,
                "title": "c-solution-easy-binary-search",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& s, vector<int>& p, long long success) {\\n        \\n        vector<int> pairs(s.size(),0);\\n        sort(p.begin(),p.end());\\n        \\n        for(int i=0;i<s.size();i++){\\n            int beg=0,end=p.size()-1;\\n            while(beg<=end){\\n                int mid = (beg + end) / 2;\\n                if( (long long int)s[i] * (long long int)p[mid] >= success){\\n                    end = mid - 1;\\n                }\\n                else{\\n                    beg = mid + 1;\\n                }\\n            }\\n            pairs[i] = p.size() - beg;\\n        }\\n\\n        return pairs;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& s, vector<int>& p, long long success) {\\n        \\n        vector<int> pairs(s.size(),0);\\n        sort(p.begin(),p.end());\\n        \\n        for(int i=0;i<s.size();i++){\\n            int beg=0,end=p.size()-1;\\n            while(beg<=end){\\n                int mid = (beg + end) / 2;\\n                if( (long long int)s[i] * (long long int)p[mid] >= success){\\n                    end = mid - 1;\\n                }\\n                else{\\n                    beg = mid + 1;\\n                }\\n            }\\n            pairs[i] = p.size() - beg;\\n        }\\n\\n        return pairs;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3372302,
                "title": "python-simple-binary-search-dictionary",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition and solution behind this problem is derived from 35.Search Insert position (easy). Check out my profile to view the solution of 35, and know why binary search on this , works.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Use same code from search insert position, with slight modifications. \\n- Use a hashtable to store first occurence of each index, and later refer it (for duplicates).\\n- Find the insert/position of ceil(success/spells[i])\\n\\n\\n# Complexity\\n- Time complexity: O(m * logn) + O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\\n        #Sort\\n        #Find lower bound for spell[i]\\n        #len-lowerBound =n\\n        #output[i]=n\\n        potions.sort()\\n        final=[]\\n        print(potions)\\n        d={}\\n        for i in range(len(potions)):\\n            try:\\n                d[potions[i]]=d[potions[i]]\\n            except:\\n                d[potions[i]]=i\\n        for i in spells:\\n            j=0\\n            target=ceil(success/i)\\n            #----------------Search insert position solution--------------------\\n            first=0\\n            last=len(potions)-1\\n            mid=(first+last)//2\\n            while(first<=last):\\n                mid=(first+last)//2\\n                if(potions[mid]==target):\\n                    break\\n                elif(potions[mid]<target):\\n                    first=mid+1\\n                else:\\n                    last=mid-1\\n            if(potions[mid]<target):\\n                mid+=1\\n            #---------------------------------------------------------------------\\n            if(mid>=0 and mid<len(potions)):\\n                mid=d[potions[mid]]\\n            n=len(potions)-mid\\n            final.append(n)\\n        return final\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\\n        #Sort\\n        #Find lower bound for spell[i]\\n        #len-lowerBound =n\\n        #output[i]=n\\n        potions.sort()\\n        final=[]\\n        print(potions)\\n        d={}\\n        for i in range(len(potions)):\\n            try:\\n                d[potions[i]]=d[potions[i]]\\n            except:\\n                d[potions[i]]=i\\n        for i in spells:\\n            j=0\\n            target=ceil(success/i)\\n            #----------------Search insert position solution--------------------\\n            first=0\\n            last=len(potions)-1\\n            mid=(first+last)//2\\n            while(first<=last):\\n                mid=(first+last)//2\\n                if(potions[mid]==target):\\n                    break\\n                elif(potions[mid]<target):\\n                    first=mid+1\\n                else:\\n                    last=mid-1\\n            if(potions[mid]<target):\\n                mid+=1\\n            #---------------------------------------------------------------------\\n            if(mid>=0 and mid<len(potions)):\\n                mid=d[potions[mid]]\\n            n=len(potions)-mid\\n            final.append(n)\\n        return final\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3372284,
                "title": "two-pointer-approach-leetcode-daily-c-explained-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    //T: O(m log m + n log n), S:O(n + log m)\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {   \\n        unordered_map<int, pair<int,int>> m; //{index,numpair}\\n        //Now creating a copy of spells vector\\n        vector<int> numspair(spells);\\n        //Now storing the spells and mapping its index onto the map\\n        for(int i=0;i<spells.size();i++){ // O(m)\\n            m[spells[i]]={i,-1};\\n        }\\n        //Now sorting both the vectors\\n        //Considering the length m of spells\\n        sort(spells.begin(),spells.end()); // O(m log m)\\n        //Considering the length n of potions\\n        sort(potions.begin(),potions.end());// O(n log n)\\n        \\n        int potionptr=potions.size()-1;\\n        \\n        // Two Pointer Approach\\n        //Starting spell pointer from left\\n        // And potion pointer from right\\n        for(int i=0;i<spells.size();i++){  //O(m)\\n            int spell=spells[i];\\n            while(potionptr>=0 && (long long) spell*potions[potionptr]>=success){\\n                potionptr--;\\n            }\\n            m[spell]={m[spell].first,potions.size()-1-potionptr};\\n           /*cout<<\"Value:\"<<spell<<\"-->\"<<\"Index:\"<<m[spell].first<<\"-->\"<<\"count:\"<<m[spell].second<<endl;------>this shows how count is being stored for every index and the index\\'s value*/\\n        }\\n        int index=0;\\n        for(int spell: numspair){ // O(m)\\n            numspair[index++]=m[spell].second;\\n        }\\n        return numspair;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    //T: O(m log m + n log n), S:O(n + log m)\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {   \\n        unordered_map<int, pair<int,int>> m; //{index,numpair}\\n        //Now creating a copy of spells vector\\n        vector<int> numspair(spells);\\n        //Now storing the spells and mapping its index onto the map\\n        for(int i=0;i<spells.size();i++){ // O(m)\\n            m[spells[i]]={i,-1};\\n        }\\n        //Now sorting both the vectors\\n        //Considering the length m of spells\\n        sort(spells.begin(),spells.end()); // O(m log m)\\n        //Considering the length n of potions\\n        sort(potions.begin(),potions.end());// O(n log n)\\n        \\n        int potionptr=potions.size()-1;\\n        \\n        // Two Pointer Approach\\n        //Starting spell pointer from left\\n        // And potion pointer from right\\n        for(int i=0;i<spells.size();i++){  //O(m)\\n            int spell=spells[i];\\n            while(potionptr>=0 && (long long) spell*potions[potionptr]>=success){\\n                potionptr--;\\n            }\\n            m[spell]={m[spell].first,potions.size()-1-potionptr};\\n           /*cout<<\"Value:\"<<spell<<\"-->\"<<\"Index:\"<<m[spell].first<<\"-->\"<<\"count:\"<<m[spell].second<<endl;------>this shows how count is being stored for every index and the index\\'s value*/\\n        }\\n        int index=0;\\n        for(int spell: numspair){ // O(m)\\n            numspair[index++]=m[spell].second;\\n        }\\n        return numspair;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3372205,
                "title": "2300-successful-pairs-of-spells-and-potions",
                "content": "\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& port, long long success) {\\n        \\nvector<int>res;\\n    sort(port.begin(),port.end());\\n\\n      for(auto spell:spells)\\n      {\\n\\n             long port_need = (success + spell -1 )/ spell;\\n\\n             auto it = lower_bound(port.begin(),port.end(),port_need); // store a number \\n             res.push_back(port.end()-it);\\n\\n      }\\n      return res;\\n\\n    }\\n};\\n\\n\\n```\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& port, long long success) {\\n        \\nvector<int>res;\\n    sort(port.begin(),port.end());\\n\\n      for(auto spell:spells)\\n      {\\n\\n             long port_need = (success + spell -1 )/ spell;\\n\\n             auto it = lower_bound(port.begin(),port.end(),port_need); // store a number \\n             res.push_back(port.end()-it);\\n\\n      }\\n      return res;\\n\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3372000,
                "title": "easiest-4-line-solution-c-95-memory-o-n-log-m",
                "content": "# Intuition\\nThe minimum potion strength required for each spell to succeed can be calculated as ceil((double)success/spells[i])\\n\\n# Approach\\nFirst, we sort the potions array in ascending order. Now we can apply binary search to search the index of the minimum potion strength required for each spell. This operation will take O(log(m)) time. Once we have the index, we can find the total number of potions that can succeed with that spell, since all the potions after the index can also be used with that spell to succeed (the strengths of potion after that index will always be greater than or equal to the potion strength at that index since potions array is sorted). Finally, we store the answer in spell array itself to save memory.\\n\\n# Complexity\\n- Time complexity:\\nO(n*log(m))\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nvector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n    sort (potions.begin(),potions.end());\\n    for (int i=0;i<spells.size();i++){\\n        spells[i]= potions.size() - (lower_bound(potions.begin(),potions.end(),ceil((double)success/spells[i]))-potions.begin());\\n    }\\n    return spells;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nvector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n    sort (potions.begin(),potions.end());\\n    for (int i=0;i<spells.size();i++){\\n        spells[i]= potions.size() - (lower_bound(potions.begin(),potions.end(),ceil((double)success/spells[i]))-potions.begin());\\n    }\\n    return spells;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3371999,
                "title": "simple-binary-search-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nsort the portion array since we only need a count from them \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& p, long long s) {\\n\\n\\n        vector<int>ans(spells.size(),0);\\n        int n=spells.size();\\n        int m=p.size();\\n        sort(p.begin(),p.end());\\n        for(int i=0;i<spells.size();i++){\\n        int low=0;\\n        int high=p.size()-1;\\n\\n            long long  cs=spells[i];\\n            int cr=-1;\\n            while(low<=high){\\n                int mid=low+(high-low)/2;\\n                if(cs*p[mid]<s){\\n                    low=mid+1;\\n                }else if(cs*p[mid]>=s){\\n                    high=mid-1;\\n                    cr=mid;\\n                }\\n            }\\n            if(cr!=-1){\\n                ans[i]=p.size()-cr;\\n            }\\n            \\n\\n\\n        }\\n           \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& p, long long s) {\\n\\n\\n        vector<int>ans(spells.size(),0);\\n        int n=spells.size();\\n        int m=p.size();\\n        sort(p.begin(),p.end());\\n        for(int i=0;i<spells.size();i++){\\n        int low=0;\\n        int high=p.size()-1;\\n\\n            long long  cs=spells[i];\\n            int cr=-1;\\n            while(low<=high){\\n                int mid=low+(high-low)/2;\\n                if(cs*p[mid]<s){\\n                    low=mid+1;\\n                }else if(cs*p[mid]>=s){\\n                    high=mid-1;\\n                    cr=mid;\\n                }\\n            }\\n            if(cr!=-1){\\n                ans[i]=p.size()-cr;\\n            }\\n            \\n\\n\\n        }\\n           \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3371980,
                "title": "java-self-explanatory",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        int[] arr = new int[spells.length];\\n        Arrays.sort(potions);\\n        for(int i=0;i<spells.length;i++){\\n            arr[i] = getPairs(spells[i],potions,success);\\n        }\\n        return arr;\\n    }\\n\\n    private int getPairs(int x, int[] potions,long success){\\n        int low = 0;\\n        int high = potions.length-1;\\n        while(low <= high){\\n            int mid = low +(high-low)/2;\\n            if((long)potions[mid]*x >= success){\\n                high = mid-1;\\n            }\\n            else\\n                low = mid+1;\\n        }\\n\\n        return potions.length - low;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        int[] arr = new int[spells.length];\\n        Arrays.sort(potions);\\n        for(int i=0;i<spells.length;i++){\\n            arr[i] = getPairs(spells[i],potions,success);\\n        }\\n        return arr;\\n    }\\n\\n    private int getPairs(int x, int[] potions,long success){\\n        int low = 0;\\n        int high = potions.length-1;\\n        while(low <= high){\\n            int mid = low +(high-low)/2;\\n            if((long)potions[mid]*x >= success){\\n                high = mid-1;\\n            }\\n            else\\n                low = mid+1;\\n        }\\n\\n        return potions.length - low;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3371966,
                "title": "binary-search-c-very-very-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n#define ll long long\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        vector<int>ans;\\n         sort(potions.begin(),potions.end());\\n       for(int i=0;i<spells.size();i++){\\n           int spell=spells[i];\\n           int low=0;\\n           int high=potions.size()-1;\\n           while(low<=high){\\n               int mid=low+(high-low)/2;\\n               long long pair_val=((ll)spell * (ll)potions[mid]);\\n               if(pair_val>=success){\\n                   high=mid-1;\\n               }\\n               else{\\n                     low=mid+1;\\n               }\\n           }\\n           ans.push_back(potions.size()-low);\\n       }\\n       return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n#define ll long long\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        vector<int>ans;\\n         sort(potions.begin(),potions.end());\\n       for(int i=0;i<spells.size();i++){\\n           int spell=spells[i];\\n           int low=0;\\n           int high=potions.size()-1;\\n           while(low<=high){\\n               int mid=low+(high-low)/2;\\n               long long pair_val=((ll)spell * (ll)potions[mid]);\\n               if(pair_val>=success){\\n                   high=mid-1;\\n               }\\n               else{\\n                     low=mid+1;\\n               }\\n           }\\n           ans.push_back(potions.size()-low);\\n       }\\n       return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3371958,
                "title": "easy-to-understand-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(nlogm)\\n\\n- Space complexity:O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        int n = spells.size();\\n        int m = potions.size();\\n        vector<int>pairs;\\n        sort(potions.begin(),potions.end());\\n        for(int i=0;i<n;i++){\\n           int low = 0;\\n           int high = m-1;\\n           int cnt =0;\\n           while(low<=high){\\n               long long mid = low+(high-low)/2;\\n               if((long)spells[i]*(long)potions[mid]>=success){\\n                    cnt += high-mid+1;\\n                    high = mid-1;\\n               }\\n               else if((long)spells[i]*(long)potions[mid]<success){\\n                   low = mid+1;\\n               }\\n           }\\n          pairs.push_back(cnt);\\n        }\\n        return pairs;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        int n = spells.size();\\n        int m = potions.size();\\n        vector<int>pairs;\\n        sort(potions.begin(),potions.end());\\n        for(int i=0;i<n;i++){\\n           int low = 0;\\n           int high = m-1;\\n           int cnt =0;\\n           while(low<=high){\\n               long long mid = low+(high-low)/2;\\n               if((long)spells[i]*(long)potions[mid]>=success){\\n                    cnt += high-mid+1;\\n                    high = mid-1;\\n               }\\n               else if((long)spells[i]*(long)potions[mid]<success){\\n                   low = mid+1;\\n               }\\n           }\\n          pairs.push_back(cnt);\\n        }\\n        return pairs;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3371863,
                "title": "simple-java-solution-with-detailed-steps-easy-to-understand-intuitive-solution-binary-search",
                "content": "# Intuition\\nFind the potion indices which on multiplication with spell result  atleast success.\\n\\n# Approach\\n**Brute Force Approach:** Iterate over spellls array and compare with each potion value if multiplication is more than or equals to success.\\n***Time complexity:*** As we are multiplying each potion with each spell, TC for this approach will be O(M*N).\\n***Space complexity:***: We are not using any additional space as part of our algorightm. We are creating an result array which is required as part of ans so we will consider it into our space complexity as its required for the answer.\\n\\n---\\n\\n**Optimized approach:** Let\\'s sort the potion array in ascending order. Now if somehow we can find the starting index which on multiplication with spell results into success then all the indices on it\\'s right will also results in success (potion array is sorted in ascending order). So we don\\'t need to check for each and every potion indices for success, we only need to find the starting index.\\nAs we have sorted the potion array, finding the starting index can be done using binary search. This will reduce our time complexity to find the starting index from O(N) to O(logN). \\nIf we have a valid starting index which means there are some potion values which will result into success so all the indices on it\\'s right will also results in success (So simply store the potion length - starting index as count for that spell). If didn\\'t find a valid potion which results into success then simply store 0 for that spell.\\n   \\n***Time complexity:***  Sorting the potion array will take O(N*logN). Iterating over spell array will result in O(M) TC and finding the starting index using binary search will take O(logN) so resultant Time Complexity will be O(Max(M, N) * logN)).\\n***Space complexity:***: We are not using any additional space as part of our algorightm. We are creating an result array which is required as part of ans so we will consider it into our space complexity as its required for the answer.\\n\\n# Kindly upvote if you liked the solution \\n![upvote.png](https://assets.leetcode.com/users/images/fc02b3ed-fbd5-4f2a-8065-67160bf2fe0e_1680460909.0296853.png)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        \\n        //Sort the array so that we can apply binary search on the array\\n        Arrays.sort(potions);\\n        int pLen = potions.length, startIndex = -1;\\n        int[] ans = new int[spells.length];\\n       \\n        //Iterate over spells and find starting potion index for each spell which will give success\\n        for(int s = 0; s < spells.length; s++){\\n            \\n            //using binary search find the starting index which results into success \\n            startIndex = getStartSuccessIndex(potions, spells[s], success);\\n\\n            //If a valid index is found then all the indices to it\\'s right will also result in success\\n            if(startIndex >= 0){\\n                ans[s] = pLen - startIndex;\\n            }else{\\n                //If no valid index is found then 0 results will be formed\\n                ans[s] = 0;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    private int getStartSuccessIndex(int[] potions, long spell, long success){\\n        int ans = -1, p = potions.length;\\n        int left = 0, right = p-1, mid = (right+left)/2;\\n        while(left <= right){\\n            mid = (left+right)/2;\\n            //If product of mid potion value with spll is >= success then this mighte be our ans so store it into ans variable and look for smaller index on the left side. \\n            if(potions[mid] * spell >= success){\\n                ans = mid;\\n                right = mid -1;\\n            }else {\\n                left = mid + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        \\n        //Sort the array so that we can apply binary search on the array\\n        Arrays.sort(potions);\\n        int pLen = potions.length, startIndex = -1;\\n        int[] ans = new int[spells.length];\\n       \\n        //Iterate over spells and find starting potion index for each spell which will give success\\n        for(int s = 0; s < spells.length; s++){\\n            \\n            //using binary search find the starting index which results into success \\n            startIndex = getStartSuccessIndex(potions, spells[s], success);\\n\\n            //If a valid index is found then all the indices to it\\'s right will also result in success\\n            if(startIndex >= 0){\\n                ans[s] = pLen - startIndex;\\n            }else{\\n                //If no valid index is found then 0 results will be formed\\n                ans[s] = 0;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    private int getStartSuccessIndex(int[] potions, long spell, long success){\\n        int ans = -1, p = potions.length;\\n        int left = 0, right = p-1, mid = (right+left)/2;\\n        while(left <= right){\\n            mid = (left+right)/2;\\n            //If product of mid potion value with spll is >= success then this mighte be our ans so store it into ans variable and look for smaller index on the left side. \\n            if(potions[mid] * spell >= success){\\n                ans = mid;\\n                right = mid -1;\\n            }else {\\n                left = mid + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3371825,
                "title": "binary-search-approach",
                "content": "# Intuition\\nTo find index of success value in sorted list if it is present in list else to find the insertion index of success value in sorted list.\\n\\n# Approach\\n\\nBinary Search\\n\\n# Complexity\\n- Time complexity:O(logn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\\n        potions.sort()\\n        s = []\\n        for i in spells:\\n            left = 0\\n            right = len(potions)\\n            while left < right:\\n                mid = (left + right) // 2\\n                if i * potions[mid] >= success:\\n                    right = mid\\n                else:\\n                    left = mid + 1\\n            s.append(len(potions) - left)\\n\\n        return s\\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution:\\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\\n        potions.sort()\\n        s = []\\n        for i in spells:\\n            left = 0\\n            right = len(potions)\\n            while left < right:\\n                mid = (left + right) // 2\\n                if i * potions[mid] >= success:\\n                    right = mid\\n                else:\\n                    left = mid + 1\\n            s.append(len(potions) - left)\\n\\n        return s\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3371813,
                "title": "c-soln-using-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n  n -> size of spells array and\\n  m -> size of potions array\\n\\n- Time complexity: O(nlog(m))\\n\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        sort(potions.begin(), potions.end());\\n        int m=potions.size(), n=spells.size();\\n        vector<int> ans;\\n\\n        for(int i=0; i<n; i++){\\n            int left=0, right=m-1;\\n            while(left<=right){\\n                int mid=(left+right)/2;\\n                long long temp = (long long)potions[mid]*spells[i];\\n                if(temp<success)\\n                  left=mid+1;\\n                else right=mid-1;\\n            }\\n            ans.push_back(m-left);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        sort(potions.begin(), potions.end());\\n        int m=potions.size(), n=spells.size();\\n        vector<int> ans;\\n\\n        for(int i=0; i<n; i++){\\n            int left=0, right=m-1;\\n            while(left<=right){\\n                int mid=(left+right)/2;\\n                long long temp = (long long)potions[mid]*spells[i];\\n                if(temp<success)\\n                  left=mid+1;\\n                else right=mid-1;\\n            }\\n            ans.push_back(m-left);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3371808,
                "title": "simple-binary-search-sorting-c",
                "content": "Sort both the arrays. Now for each spell find the min index in 2nd array such that it\\'s product with currect element of 1st array is greater than success value . Now all the elements after this index will surely have product greater than required success value.\\n\\nTime Complexity -> O(nlogn)\\n\\n```\\ntypedef long long int ll ;\\nstruct data {\\n    int index, count, a ;\\n};\\nbool comp(struct data A, struct data B){\\n    return A.a < B.a;\\n}\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        int n = spells.size(), m = potions.size();\\n        vector<struct data>v(n);\\n        for(int i = 0 ; i< n; i++){\\n            v[i].a = spells[i];\\n            v[i].index = i;\\n            v[i].count = 0 ;\\n        }\\n        sort(v.begin(), v.end(), comp);\\n        sort(potions.begin(), potions.end());\\n        for(int i = 0 ; i < n; i++){\\n            ll reqd = success/v[i].a ;\\n            if(success%v[i].a != 0)\\n                reqd ++ ;\\n            int ind = lower_bound(potions.begin(), potions.end(), reqd) - potions.begin();\\n            if(ind == m)\\n                v[i].count = 0 ;\\n            else\\n                v[i].count = m-ind;\\n        }\\n        vector<int>ans(n) ;\\n        for(auto it: v)\\n            ans[it.index] = it.count;\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "```\\ntypedef long long int ll ;\\nstruct data {\\n    int index, count, a ;\\n};\\nbool comp(struct data A, struct data B){\\n    return A.a < B.a;\\n}\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        int n = spells.size(), m = potions.size();\\n        vector<struct data>v(n);\\n        for(int i = 0 ; i< n; i++){\\n            v[i].a = spells[i];\\n            v[i].index = i;\\n            v[i].count = 0 ;\\n        }\\n        sort(v.begin(), v.end(), comp);\\n        sort(potions.begin(), potions.end());\\n        for(int i = 0 ; i < n; i++){\\n            ll reqd = success/v[i].a ;\\n            if(success%v[i].a != 0)\\n                reqd ++ ;\\n            int ind = lower_bound(potions.begin(), potions.end(), reqd) - potions.begin();\\n            if(ind == m)\\n                v[i].count = 0 ;\\n            else\\n                v[i].count = m-ind;\\n        }\\n        vector<int>ans(n) ;\\n        for(auto it: v)\\n            ans[it.index] = it.count;\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3371786,
                "title": "eeeee",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        int [] result = new int[spells.length];\\n        int potionsLength = potions.length;\\n        Arrays.sort(potions);\\n\\n        for(int i=0; i<spells.length; i++){\\n            int minIndex = binarySearch(potions, success, spells[i]);\\n            result[i] = potionsLength - minIndex;\\n        }\\n        return result;\\n    }\\n\\n    private int binarySearch(int [] potions, long success, int spell){\\n        int left= 0;\\n        int right= potions.length;\\n        while(left<right){\\n            int mid = left + (right-left)/2;\\n            long product = (1l * spell) * potions[mid];\\n                if(product<success)\\n                    left=mid+1;\\n                else\\n                    right=mid;\\n            }\\n        return left;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        int [] result = new int[spells.length];\\n        int potionsLength = potions.length;\\n        Arrays.sort(potions);\\n\\n        for(int i=0; i<spells.length; i++){\\n            int minIndex = binarySearch(potions, success, spells[i]);\\n            result[i] = potionsLength - minIndex;\\n        }\\n        return result;\\n    }\\n\\n    private int binarySearch(int [] potions, long success, int spell){\\n        int left= 0;\\n        int right= potions.length;\\n        while(left<right){\\n            int mid = left + (right-left)/2;\\n            long product = (1l * spell) * potions[mid];\\n                if(product<success)\\n                    left=mid+1;\\n                else\\n                    right=mid;\\n            }\\n        return left;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3371778,
                "title": "c-very-easy-solution-beginner-friendly-easy-to-understand-loaded-with-comments",
                "content": "# Intuition\\nLet us commence with the brute-force approach and progressively optimize it. Initially, we can write a brute-force algorithm using two loops: one for spells and another for potions. During each iteration, we will verify whether \"spells\\\\[i]\\\\*potions\\\\[i]>=success\". However, since the maximum size of m and n is 10e5 and this approach is quadratic, it will result in \"Time Limit Exceeded(TLE)\". This is due to the fact that in a second, the maximum operation which we can perform is approximately 1e8-1e9, whereas here it can be 1e10 at max.\\n\\nOptimization No:-1: Firstly, we will sort the potions vector. Since, as per the condition, we have to find the count satisfying \"spells\\\\[i]*potions\\\\[i]>=success\", using simple mathematics, we can convert it to \"potions\\\\[i]>=success/spells\\\\[i]\". However, there is a catch - in C++, if we divide without typecasting, it will round off to the nearest integer, but we want the answer to be calculated in floating-point, and then we will take the ceil of the number. Let me illustrate the problem we face without using typecasting and taking ceil of the result. Suppose success=16, spells\\\\[i]=3, then potions\\\\[i]>=16/3 in order to satisfy \"spells\\\\[i]*potions\\\\[i]>=success\". Therefore, 16/3 will be 5, and when we multiply 5 with 3, it comes out to be 15<16. So, to avoid this, if we typecast division, then (1.0*16)/3 would be 5.33..., and if we take ceil of that, we will end up getting 6, and that will satisfy our condition as 3*6=18>=16. Using the lower\\\\_bound function, we can calculate the index of the number >=potions\\\\[i] we have calculated just aforehead. So, the answer for that spells\\\\[i]=n-index. Here, n is the size of the potions vector.\\n\\n# Approach\\n\\n\\n# Complexity\\n- Time complexity:\\n- Brute Force: O(m*n);\\n- optimised Code:O(nlogn+mlogm);\\n-  Space complexity:\\n   - O(n)\\n\\n# Code\\n```\\n// BRUTE FORCE APPROACH and it will give TLE \\n//AS (N*M<=10e10 operations and that can\\'t pass within a second)\\n\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n      vector<int>v;\\n      for(int i=0;i<spells.size();i++){\\n          int count=0;\\n          int x =spells[i];\\n          for(int j=0;j<potions.size();j++){\\n              long long result= (1LL*x*potions[j]);\\n              if(result>=success){\\n                count++;\\n              } \\n          }\\n      v.push_back(count);\\n      }\\n      return v;\\n    }\\n};\\n\\n// Optimised no :1 Here we are using STL\\n\\n// Let\\'s write the optimised version\\n// Still here we are using the stl function to find lower_bound which internally implements binary search but interviewer in some case might not allow to use STL so in that case we will have to write lower_bound using bs internally by ourself.\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n    int m = spells.size();\\n    int n =potions.size();\\n    sort(begin(potions),end(potions));\\n    int maxPotionValue=potions[n-1];\\n    vector<int>ans;\\n    for(int i=0;i<m;i++){\\n        int spell=spells[i];\\n        // spell*potions[i]>=success \\n        long long minPotion=ceil((1.0*success)/spell);\\n        if(minPotion>maxPotionValue) {\\n            ans.emplace_back(0);\\n            continue;\\n        }\\n        int index=lower_bound(begin(potions),end(potions),minPotion)-begin(potions);\\n        int count=n-index;\\n        ans.emplace_back(count);\\n    } \\n    return ans ;  \\n    }\\n};\\n // Optimised Code :2 Here We are writing lower_bound by ourself\\n\\n// Let\\'s write the most optimised version\\nclass Solution {\\npublic:\\nint apnaLowerBound(int l , int r , int target,vector<int>& potions ){\\n    int ans=0;\\n    int mid=0;\\n    while(l<=r){\\n        mid=l+(r-l)/2;\\n        if(potions[mid]>=target){\\n            ans=mid;\\n            r=mid-1;\\n        }\\n        else{\\n            l=mid+1;\\n        }\\n    }\\n    return ans ;\\n}\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n    int m = spells.size();\\n    int n =potions.size();\\n    sort(begin(potions),end(potions));\\n    int maxPotionValue=potions[n-1];\\n    vector<int>ans;\\n    for(int i=0;i<m;i++){\\n        int spell=spells[i];\\n        // spell*potions[i]>=success \\n        long long minPotion=ceil((1.0*success)/spell);\\n        if(minPotion>maxPotionValue) {\\n            ans.emplace_back(0);\\n            continue;\\n        }\\n        // int index=lower_bound(begin(potions),end(potions),minPotion)-begin(potions);\\n        // We will calculate index now using our own function \\n        int index=apnaLowerBound(0,n-1,minPotion,potions);\\n        int count=n-index;\\n        ans.emplace_back(count);\\n    } \\n    return ans ;  \\n    }\\n};\\n\\n\\n\\n\\n\\n```\\nCAN I GET AN UPVOTE PLS , IT TOOK LOTS OF EFFORT TO PEN THIS DOWN \\uD83D\\uDE07\\uD83D\\uDE4F\\uD83D\\uDE4F",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\n// BRUTE FORCE APPROACH and it will give TLE \\n//AS (N*M<=10e10 operations and that can\\'t pass within a second)\\n\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n      vector<int>v;\\n      for(int i=0;i<spells.size();i++){\\n          int count=0;\\n          int x =spells[i];\\n          for(int j=0;j<potions.size();j++){\\n              long long result= (1LL*x*potions[j]);\\n              if(result>=success){\\n                count++;\\n              } \\n          }\\n      v.push_back(count);\\n      }\\n      return v;\\n    }\\n};\\n\\n// Optimised no :1 Here we are using STL\\n\\n// Let\\'s write the optimised version\\n// Still here we are using the stl function to find lower_bound which internally implements binary search but interviewer in some case might not allow to use STL so in that case we will have to write lower_bound using bs internally by ourself.\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n    int m = spells.size();\\n    int n =potions.size();\\n    sort(begin(potions),end(potions));\\n    int maxPotionValue=potions[n-1];\\n    vector<int>ans;\\n    for(int i=0;i<m;i++){\\n        int spell=spells[i];\\n        // spell*potions[i]>=success \\n        long long minPotion=ceil((1.0*success)/spell);\\n        if(minPotion>maxPotionValue) {\\n            ans.emplace_back(0);\\n            continue;\\n        }\\n        int index=lower_bound(begin(potions),end(potions),minPotion)-begin(potions);\\n        int count=n-index;\\n        ans.emplace_back(count);\\n    } \\n    return ans ;  \\n    }\\n};\\n // Optimised Code :2 Here We are writing lower_bound by ourself\\n\\n// Let\\'s write the most optimised version\\nclass Solution {\\npublic:\\nint apnaLowerBound(int l , int r , int target,vector<int>& potions ){\\n    int ans=0;\\n    int mid=0;\\n    while(l<=r){\\n        mid=l+(r-l)/2;\\n        if(potions[mid]>=target){\\n            ans=mid;\\n            r=mid-1;\\n        }\\n        else{\\n            l=mid+1;\\n        }\\n    }\\n    return ans ;\\n}\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n    int m = spells.size();\\n    int n =potions.size();\\n    sort(begin(potions),end(potions));\\n    int maxPotionValue=potions[n-1];\\n    vector<int>ans;\\n    for(int i=0;i<m;i++){\\n        int spell=spells[i];\\n        // spell*potions[i]>=success \\n        long long minPotion=ceil((1.0*success)/spell);\\n        if(minPotion>maxPotionValue) {\\n            ans.emplace_back(0);\\n            continue;\\n        }\\n        // int index=lower_bound(begin(potions),end(potions),minPotion)-begin(potions);\\n        // We will calculate index now using our own function \\n        int index=apnaLowerBound(0,n-1,minPotion,potions);\\n        int count=n-index;\\n        ans.emplace_back(count);\\n    } \\n    return ans ;  \\n    }\\n};\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3371574,
                "title": "c-binary-search-easiest-beginner-friendly-sol",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTo reduce the time complexity, you could sort the \"potions\" vector and use binary search to find the number of successful pairs for each spell. This would reduce the time complexity to O(n log n).\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        vector<int> pass;\\n        sort(potions.begin(), potions.end());\\n        for (int i = 0; i < spells.size(); i++)\\n        {\\n            int lo = 0, hi = potions.size() - 1;\\n            while (lo <= hi)\\n            {\\n                int mid = lo + (hi - lo) / 2;\\n                if ((long long)spells[i] * potions[mid] >= success)\\n                    hi = mid - 1;\\n                else\\n                    lo = mid + 1;\\n            }\\n            pass.push_back(potions.size() - lo);\\n        }\\n        return pass;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        vector<int> pass;\\n        sort(potions.begin(), potions.end());\\n        for (int i = 0; i < spells.size(); i++)\\n        {\\n            int lo = 0, hi = potions.size() - 1;\\n            while (lo <= hi)\\n            {\\n                int mid = lo + (hi - lo) / 2;\\n                if ((long long)spells[i] * potions[mid] >= success)\\n                    hi = mid - 1;\\n                else\\n                    lo = mid + 1;\\n            }\\n            pass.push_back(potions.size() - lo);\\n        }\\n        return pass;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3371475,
                "title": "simple-python-code-binary-search",
                "content": "# Approach: `Binary Search`\\n\\n# Complexity\\n- Time complexity: `O(N LogN)`\\n\\n- Space complexity: ` O(N) `\\n\\n# Code\\n```\\nclass Solution:\\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\\n        potions.sort()\\n        x = []\\n        for i in spells:\\n            l,r,ans = 0,len(potions)-1,0\\n            while l<=r:\\n                m = (l+r)//2\\n                if (potions[m]*i)>=success:\\n                    ans+=(r-m+1)\\n                    r=m-1\\n                else: l=m+1\\n            x.append(ans);\\n        return x\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\\n        potions.sort()\\n        x = []\\n        for i in spells:\\n            l,r,ans = 0,len(potions)-1,0\\n            while l<=r:\\n                m = (l+r)//2\\n                if (potions[m]*i)>=success:\\n                    ans+=(r-m+1)\\n                    r=m-1\\n                else: l=m+1\\n            x.append(ans);\\n        return x\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3371469,
                "title": "2-approach-easy-c-solution-brute-force-and-optimized-approach-binary-search",
                "content": "# Approach 1: Brute Force Approach\\n\\n# Complexity\\n- Time complexity: O(n*m)\\n\\n- Space complexity: O(1)\\n\\nwhere n == spells.length and m == potions.length\\n\\n# Code\\n```\\n// Brute Force Approach\\n// Time complexity -> O(n*m) and Space -> O(1)\\n// where n == spells.length and m == potions.length\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        vector<int> ans;\\n        for(int i=0;i<spells.size();i++)\\n        {\\n            int pairCount=0;\\n            for(int j=0;j<potions.size();j++)\\n            {\\n                long long check=(long long)(potions[j])*(long long)(spells[i]);\\n                if(check>=success)\\n                {\\n                    pairCount++;\\n                }\\n            }\\n            ans.push_back(pairCount);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nAbove code \\u274C give time limit Exceeded due to high complexity O(n*m)\\n\\n# Approach 2: Optimized Approach\\n\\n# Complexity\\n- Time complexity: O((n+m)log(m))\\n\\n- Space complexity: O(logm)\\n\\nwhere n == spells.length and m == potions.length\\n\\n# Code\\n```\\n// Optimized Approach [Binary Search]\\n// Time complexity -> O((n+m)log(m)) and Space -> O(logm)\\n// where n == spells.length and m == potions.length\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        int n=spells.size();\\n        int m=potions.size();\\n        sort(potions.begin(),potions.end());\\n        vector<int> ans;\\n        int maxPotionValue=potions[m-1];\\n        for(int i=0;i<n;i++)\\n        {\\n            int spell=spells[i];\\n            // minPotion*spell>=success\\n            long long minPotion=ceil((1.0*success)/spell);\\n            if(minPotion>maxPotionValue)\\n            {\\n                ans.push_back(0);\\n                continue;\\n            }\\n            int index=lower_bound(potions.begin(),potions.end(),minPotion)-potions.begin();\\n\\n            int count=m-index;\\n            ans.push_back(count);\\n        }\\n        return ans;\\n    }\\n};\\n\\n```\\n**OR**\\n\\n```\\nclass Solution {\\nprivate:\\n    int LowerBound(int l, int r,vector<int> &potions,int minPotion)\\n    {\\n        int possibleIndex=-1;\\n        while(l<=r)\\n        {\\n            int mid=l+(r-l)/2;\\n            if(potions[mid]>=minPotion)\\n            {\\n                possibleIndex=mid;\\n                r=mid-1;\\n            }\\n            else\\n            {\\n                l=mid+1;\\n            }\\n        }\\n        return possibleIndex;\\n    }\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        int n=spells.size();\\n        int m=potions.size();\\n        sort(potions.begin(),potions.end()); // O(mlogm)\\n        vector<int> ans;\\n        int maxPotionValue=potions[m-1];\\n        for(int i=0;i<n;i++) // O(n*logm)\\n        {\\n            int spell=spells[i];\\n            // minPotion*spell>=success\\n            long long minPotion=ceil((1.0*success)/spell);\\n            if(minPotion>maxPotionValue)\\n            {\\n                ans.push_back(0);\\n                continue;\\n            }\\n            int index=LowerBound(0,m-1,potions,minPotion);\\n            int count=m-index;\\n            ans.push_back(count);\\n        }\\n        return ans;\\n    }\\n};\\n\\n```\\n\\n**Explanation**\\n\\n![WhatsApp Image 2023-04-02 at 22.15.27.jpg](https://assets.leetcode.com/users/images/067ebdc3-350c-4847-866d-6bf25d838ec1_1680454005.8449535.jpeg)\\n\\n![WhatsApp Image 2023-04-02 at 22.15.28.jpg](https://assets.leetcode.com/users/images/5b991ac6-dca3-40e1-b392-ae6ea9056f73_1680454019.0853117.jpeg)\\n\\n![WhatsApp Image 2023-04-02 at 22.15.28.jpg](https://assets.leetcode.com/users/images/59d30d22-48ca-4928-b1ff-5d553d83d28f_1680454031.2301693.jpeg)\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\n// Brute Force Approach\\n// Time complexity -> O(n*m) and Space -> O(1)\\n// where n == spells.length and m == potions.length\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        vector<int> ans;\\n        for(int i=0;i<spells.size();i++)\\n        {\\n            int pairCount=0;\\n            for(int j=0;j<potions.size();j++)\\n            {\\n                long long check=(long long)(potions[j])*(long long)(spells[i]);\\n                if(check>=success)\\n                {\\n                    pairCount++;\\n                }\\n            }\\n            ans.push_back(pairCount);\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\n// Optimized Approach [Binary Search]\\n// Time complexity -> O((n+m)log(m)) and Space -> O(logm)\\n// where n == spells.length and m == potions.length\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        int n=spells.size();\\n        int m=potions.size();\\n        sort(potions.begin(),potions.end());\\n        vector<int> ans;\\n        int maxPotionValue=potions[m-1];\\n        for(int i=0;i<n;i++)\\n        {\\n            int spell=spells[i];\\n            // minPotion*spell>=success\\n            long long minPotion=ceil((1.0*success)/spell);\\n            if(minPotion>maxPotionValue)\\n            {\\n                ans.push_back(0);\\n                continue;\\n            }\\n            int index=lower_bound(potions.begin(),potions.end(),minPotion)-potions.begin();\\n\\n            int count=m-index;\\n            ans.push_back(count);\\n        }\\n        return ans;\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\nprivate:\\n    int LowerBound(int l, int r,vector<int> &potions,int minPotion)\\n    {\\n        int possibleIndex=-1;\\n        while(l<=r)\\n        {\\n            int mid=l+(r-l)/2;\\n            if(potions[mid]>=minPotion)\\n            {\\n                possibleIndex=mid;\\n                r=mid-1;\\n            }\\n            else\\n            {\\n                l=mid+1;\\n            }\\n        }\\n        return possibleIndex;\\n    }\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        int n=spells.size();\\n        int m=potions.size();\\n        sort(potions.begin(),potions.end()); // O(mlogm)\\n        vector<int> ans;\\n        int maxPotionValue=potions[m-1];\\n        for(int i=0;i<n;i++) // O(n*logm)\\n        {\\n            int spell=spells[i];\\n            // minPotion*spell>=success\\n            long long minPotion=ceil((1.0*success)/spell);\\n            if(minPotion>maxPotionValue)\\n            {\\n                ans.push_back(0);\\n                continue;\\n            }\\n            int index=LowerBound(0,m-1,potions,minPotion);\\n            int count=m-index;\\n            ans.push_back(count);\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3371463,
                "title": "accepted-time-complexity-o-n-log-n",
                "content": "# Complexity\\n- Time complexity:\\nO(nlog(n))\\n\\n# Code\\n```\\nclass Solution {\\n    func successfulPairs(_ spells: [Int], _ potions: [Int], _ success: Int) -> [Int] {\\n        var potions = potions\\n        potions.sort()\\n        var returnArr = [Int]()\\n\\n        for spell in spells {\\n            var i = 0 \\n            var j = potions.count-1\\n            if potions[j]*spell < success {\\n                returnArr.append(0)\\n                continue\\n            }\\n             if potions[0]*spell >= success {\\n                returnArr.append(potions.count)\\n                continue\\n            }\\n\\n            while i<=j {\\n                let mid = (i+j)/2\\n                if potions[mid]*spell >= success && potions[mid-1]*spell < success {\\n                    returnArr.append(potions.count-mid)\\n                    break\\n                } else if potions[mid]*spell >= success {\\n                    j = mid-1\\n                } else {\\n                    i = mid+1\\n                }\\n            }\\n        }\\n        return returnArr\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func successfulPairs(_ spells: [Int], _ potions: [Int], _ success: Int) -> [Int] {\\n        var potions = potions\\n        potions.sort()\\n        var returnArr = [Int]()\\n\\n        for spell in spells {\\n            var i = 0 \\n            var j = potions.count-1\\n            if potions[j]*spell < success {\\n                returnArr.append(0)\\n                continue\\n            }\\n             if potions[0]*spell >= success {\\n                returnArr.append(potions.count)\\n                continue\\n            }\\n\\n            while i<=j {\\n                let mid = (i+j)/2\\n                if potions[mid]*spell >= success && potions[mid-1]*spell < success {\\n                    returnArr.append(potions.count-mid)\\n                    break\\n                } else if potions[mid]*spell >= success {\\n                    j = mid-1\\n                } else {\\n                    i = mid+1\\n                }\\n            }\\n        }\\n        return returnArr\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3371458,
                "title": "c-accepted-time-complexity-o-n-log-n",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\nO(nlog(n))\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n         vector<int> ans;\\n         sort(potions.begin(),potions.end());\\n        for(int i=0;i<spells.size();i++){\\n            int count=0;\\n            int start=0;\\n            int end=potions.size();\\n            while(start<end){\\n\\n                int mid = (start+end)/2;\\n\\n                if(potions[mid]*1ll*spells[i]>=success){\\n                  end = mid;\\n                }\\n                else{\\n                   start=mid+1;\\n                }\\n                    \\n                \\n            }\\n            \\n           count+=potions.size()-end;\\n\\n\\n            ans.push_back(count);\\n        }\\n\\n      return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n         vector<int> ans;\\n         sort(potions.begin(),potions.end());\\n        for(int i=0;i<spells.size();i++){\\n            int count=0;\\n            int start=0;\\n            int end=potions.size();\\n            while(start<end){\\n\\n                int mid = (start+end)/2;\\n\\n                if(potions[mid]*1ll*spells[i]>=success){\\n                  end = mid;\\n                }\\n                else{\\n                   start=mid+1;\\n                }\\n                    \\n                \\n            }\\n            \\n           count+=potions.size()-end;\\n\\n\\n            ans.push_back(count);\\n        }\\n\\n      return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3371435,
                "title": "simplest-approach-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity  \\n- Time complexity: O(NlogN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:  O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spell, vector<int>& potion, long long success) {\\n      vector<int>v;\\n      sort(potion.begin(),potion.end());\\n      for(int i=0;i<spell.size();i++){\\n          int l=0;\\n          int h=potion.size()-1;\\n          int count=0;\\n          bool f=false;\\n          int mid;\\n          while(l<=h){\\n            mid=(l+h)/2;\\n          long long res=(long long)spell[i]*(long long)potion[mid];\\n          if(res>=success){\\n          count=mid;\\n          h=mid-1;\\n          f=true;\\n          }\\n          else\\n          l=mid+1;\\n      }\\n       if(f)\\n          v.push_back(potion.size()-count);  \\n       else \\n          v.push_back(0);\\n        }\\n        return v;       \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spell, vector<int>& potion, long long success) {\\n      vector<int>v;\\n      sort(potion.begin(),potion.end());\\n      for(int i=0;i<spell.size();i++){\\n          int l=0;\\n          int h=potion.size()-1;\\n          int count=0;\\n          bool f=false;\\n          int mid;\\n          while(l<=h){\\n            mid=(l+h)/2;\\n          long long res=(long long)spell[i]*(long long)potion[mid];\\n          if(res>=success){\\n          count=mid;\\n          h=mid-1;\\n          f=true;\\n          }\\n          else\\n          l=mid+1;\\n      }\\n       if(f)\\n          v.push_back(potion.size()-count);  \\n       else \\n          v.push_back(0);\\n        }\\n        return v;       \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3371395,
                "title": "c-binary-search-simple-easy-solution",
                "content": "# Complexity\\n- Time complexity:`O(n log n)`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:`O(1)`\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int getSuccess(int spell , vector<int>& potions , long long success){\\n\\n        int n = potions.size();\\n        int lo = 0 , hi = n -  1;\\n        int successfull_Pairs = 0;\\n\\n        while(lo <= hi){\\n\\n            int mid = lo + (hi - lo) / 2;\\n            long long product = (long long)spell * (long long)potions[mid];\\n\\n            if(product >= success){\\n                successfull_Pairs = n - mid;\\n                hi = mid - 1;\\n            }\\n            else{\\n                lo = mid + 1;\\n            }\\n\\n        }\\n\\n        return successfull_Pairs;\\n    }\\n\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        \\n        sort(potions.begin(),potions.end());\\n\\n        int n = spells.size();\\n        vector<int>result;\\n\\n        for(int i=0;i<n;i++){\\n\\n            int pairs = getSuccess(spells[i],potions,success);\\n            result.push_back(pairs);\\n\\n        }\\n\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int getSuccess(int spell , vector<int>& potions , long long success){\\n\\n        int n = potions.size();\\n        int lo = 0 , hi = n -  1;\\n        int successfull_Pairs = 0;\\n\\n        while(lo <= hi){\\n\\n            int mid = lo + (hi - lo) / 2;\\n            long long product = (long long)spell * (long long)potions[mid];\\n\\n            if(product >= success){\\n                successfull_Pairs = n - mid;\\n                hi = mid - 1;\\n            }\\n            else{\\n                lo = mid + 1;\\n            }\\n\\n        }\\n\\n        return successfull_Pairs;\\n    }\\n\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        \\n        sort(potions.begin(),potions.end());\\n\\n        int n = spells.size();\\n        vector<int>result;\\n\\n        for(int i=0;i<n;i++){\\n\\n            int pairs = getSuccess(spells[i],potions,success);\\n            result.push_back(pairs);\\n\\n        }\\n\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3371306,
                "title": "java-binary-search-solution",
                "content": "# Intuition \\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe brute force will result in O(n^2) time complexity so to minimise it we apply binary search within the outer loop to search for start of the element where the target or the success is achieved.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSort the array first to apply the binary search since we only need the count. And then search for the element idx for each spell where after which the success is achieved in the array. Now simply add the count in the ans array and return it.\\n\\n# Complexity\\n- Time complexity: O(NlogN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> \\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long target) {\\n        int[] ans = new int[spells.length];\\n        Arrays.sort(potions);\\n        for(int i = 0; i < spells.length; i++){\\n            int ele = spells[i];\\n            int st = 0;\\n            int end = potions.length-1;\\n            int idx = -1;\\n            while(st <= end){\\n                int mid = (st+end)/2;\\n                if((long)potions[mid]*ele > target){\\n                    end = mid-1;\\n                }else if((long)potions[mid]*ele < target){\\n                    st = mid+1;\\n                }else{\\n                    idx = mid;\\n                    end = mid-1;\\n                }\\n            }\\n            if(idx == -1){\\n                idx = st;\\n            }\\n            ans[i] = potions.length-idx;\\n        }\\n        return ans;\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long target) {\\n        int[] ans = new int[spells.length];\\n        Arrays.sort(potions);\\n        for(int i = 0; i < spells.length; i++){\\n            int ele = spells[i];\\n            int st = 0;\\n            int end = potions.length-1;\\n            int idx = -1;\\n            while(st <= end){\\n                int mid = (st+end)/2;\\n                if((long)potions[mid]*ele > target){\\n                    end = mid-1;\\n                }else if((long)potions[mid]*ele < target){\\n                    st = mid+1;\\n                }else{\\n                    idx = mid;\\n                    end = mid-1;\\n                }\\n            }\\n            if(idx == -1){\\n                idx = st;\\n            }\\n            ans[i] = potions.length-idx;\\n        }\\n        return ans;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3371267,
                "title": "2300-successful-pairs-of-spells-and-potions",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        int n = spells.length;\\n        int m = potions.length;\\n        int[] pairs = new int[n];\\n        Arrays.sort(potions);\\n        for (int i = 0; i < n; i++) {\\n            int spell = spells[i];\\n            int left = 0;\\n            int right = m - 1;\\n            while (left <= right) {\\n                int mid = left + (right - left) / 2;\\n                long product = (long) spell * potions[mid];\\n                if (product >= success) {\\n                    right = mid - 1;\\n                } else {\\n                    left = mid + 1;\\n                }\\n            }\\n            pairs[i] = m - left;\\n        }\\n        return pairs;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Two Pointers",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        int n = spells.length;\\n        int m = potions.length;\\n        int[] pairs = new int[n];\\n        Arrays.sort(potions);\\n        for (int i = 0; i < n; i++) {\\n            int spell = spells[i];\\n            int left = 0;\\n            int right = m - 1;\\n            while (left <= right) {\\n                int mid = left + (right - left) / 2;\\n                long product = (long) spell * potions[mid];\\n                if (product >= success) {\\n                    right = mid - 1;\\n                } else {\\n                    left = mid + 1;\\n                }\\n            }\\n            pairs[i] = m - left;\\n        }\\n        return pairs;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3371199,
                "title": "solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) \\n    {\\n        vector<int>ans;\\n        int m=spells.size();\\n        int n=potions.size();\\n        sort(potions.begin(),potions.end());\\n        for(int i=0;i<m;i++)\\n        {\\n            long long pro=spells[i];\\n            int l=0;\\n            int r=n-1;\\n            int count=0;\\n            while(l<=r){\\n                long long mid=l+(r-l)/2;\\n                if(success<=(pro*potions[mid]))\\n                {\\n                    count=n-mid;\\n                    r=mid-1;\\n                }\\n                else\\n                {\\n                    l=mid+1;\\n                }\\n            }\\n            ans.push_back(count);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) \\n    {\\n        vector<int>ans;\\n        int m=spells.size();\\n        int n=potions.size();\\n        sort(potions.begin(),potions.end());\\n        for(int i=0;i<m;i++)\\n        {\\n            long long pro=spells[i];\\n            int l=0;\\n            int r=n-1;\\n            int count=0;\\n            while(l<=r){\\n                long long mid=l+(r-l)/2;\\n                if(success<=(pro*potions[mid]))\\n                {\\n                    count=n-mid;\\n                    r=mid-1;\\n                }\\n                else\\n                {\\n                    l=mid+1;\\n                }\\n            }\\n            ans.push_back(count);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3371116,
                "title": "sort-binary-search-in-c-with-explanation",
                "content": "# Approach\\nSort and apply binary search on the potions\\n\\n# Complexity\\n- Time complexity:\\n$$O(mlogm) + O(nlogm)$$ mlogm is for sorting and nlogm is for binary search\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n\\n    int bsearch(vector<int>& arr, long long target, int mul) {\\n        int sz = arr.size();\\n        if( (arr[0]*1LL) *mul  > target)\\n            return 0;\\n        if( (arr[sz-1]*1LL) *mul  < target)\\n            return sz;\\n        int st = 0, ed = sz-1, idx = sz-1;\\n        while(st <= ed) {\\n            int mid = (st + ed)/2;\\n            if(target <= (arr[mid]*1LL) *mul) {\\n                idx = mid;\\n                ed = mid - 1;\\n            }\\n            else\\n                st = mid + 1;\\n        }\\n        return idx;\\n    }\\n\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        vector<int> ans;\\n        sort(potions.begin(),potions.end());\\n        int n = spells.size();\\n        int m = potions.size();\\n        for(int i=0;i<n;i++) {\\n            ans.push_back(m - bsearch(potions, success, spells[i]));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n\\n    int bsearch(vector<int>& arr, long long target, int mul) {\\n        int sz = arr.size();\\n        if( (arr[0]*1LL) *mul  > target)\\n            return 0;\\n        if( (arr[sz-1]*1LL) *mul  < target)\\n            return sz;\\n        int st = 0, ed = sz-1, idx = sz-1;\\n        while(st <= ed) {\\n            int mid = (st + ed)/2;\\n            if(target <= (arr[mid]*1LL) *mul) {\\n                idx = mid;\\n                ed = mid - 1;\\n            }\\n            else\\n                st = mid + 1;\\n        }\\n        return idx;\\n    }\\n\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        vector<int> ans;\\n        sort(potions.begin(),potions.end());\\n        int n = spells.size();\\n        int m = potions.size();\\n        for(int i=0;i<n;i++) {\\n            ans.push_back(m - bsearch(potions, success, spells[i]));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3371111,
                "title": "master-the-art-of-spell-and-potion-pairing-a-typescript-binary-search-approach-100-87-50",
                "content": "# Intuition\\nGiven two arrays representing the strengths of spells and potions, our task is to find the number of successful pairs for each spell. A pair is considered successful if the product of the strengths of the spell and the potion is at least equal to a given `success` value. To solve this problem efficiently, we can take advantage of a binary search algorithm on the sorted potions array for each spell.\\n\\n# Approach\\n1. **Sort the potions array:** First, we sort the potions array in ascending order. This enables us to perform binary search on the array later in the process. Sorting takes $$O(m * log(m))$$ time, where m is the length of the potions array.\\n2. **Define a binary search function:** We create a binary search function that takes an array and a target value as inputs. The function iterates over the array and finds the index where the target value should be inserted while maintaining the sorted order of the array. This function has a time complexity of $$O(log(m))$$ as it is applied to the sorted potions array.\\n3. **Iterate over spells:** For each spell in the spells array, we calculate the minimum potion strength required to form a successful pair. To do this, we divide the `success` value by the strength of the current spell and round up to the nearest integer. This gives us the minimum potion strength that, when multiplied by the current spell strength, will produce a product greater than or equal to the `success` value. We then use the binary search function to find the index where this minimum potion strength should be inserted in the sorted potions array.\\n4. **Calculate the number of successful pairs:** The number of successful pairs for a given spell is the difference between the length of the potions array and the index found using binary search. This is because all the potions at the index and to the right of it in the sorted array have a strength greater than or equal to the minimum potion strength required for a successful pair with the current spell.\\n5. **Return an array with the results:** Finally, we return an array with the number of successful pairs for each spell by mapping over the spells array and performing the above steps for each element. The returned array has the same length as the input spells array.\\n\\n# Complexity\\nTime complexity: $$O(n\\u2217log(m))$$, where n is the length of the spells array and m is the length of the potions array. This complexity is due to sorting the potions array in $$O(m * log(m))$$ time and performing binary search on the potions array for each spell in $$O(n * log(m))$$ time.\\nSpace complexity: $$O(1)$$, as we only use a constant amount of additional memory for temporary variables.\\n\\n# Code\\n```\\n/**\\n * Performs binary search on a sorted array to find the index where the target value should be inserted.\\n * \\n * @param arr - A sorted array of numbers.\\n * @param target - The target number to be searched for.\\n * @returns The index where the target value should be inserted to maintain the sorted order.\\n */\\nfunction binarySearch(arr: number[], target: number): number {\\n  let left = 0;\\n  let right = arr.length - 1;\\n\\n  // Iterate until the left and right pointers converge.\\n  while (left <= right) {\\n    const mid = left + Math.floor((right - left) / 2);\\n\\n    if (arr[mid] < target) {\\n      left = mid + 1;\\n    } else {\\n      right = mid - 1;\\n    }\\n  }\\n\\n  // Return the index where the target value should be inserted.\\n  return left;\\n}\\n\\n/**\\n * Calculates the number of successful pairs of spells and potions.\\n * A spell and potion pair is considered successful if the product of their strengths is at least `success`.\\n *\\n * @param spells - An array of integers representing the strengths of the spells.\\n * @param potions - An array of integers representing the strengths of the potions.\\n * @param success - An integer representing the minimum product of spell and potion strengths required for success.\\n * @returns An array of integers representing the number of potions that will form a successful pair with each spell.\\n */\\nfunction successfulPairs(spells: number[], potions: number[], success: number): number[] {\\n  // Sort the potions list in ascending order to allow for efficient binary search.\\n  potions.sort((a, b) => a - b);\\n\\n  // Iterate over each spell in the spells list and use binary search to find the index of the first potion\\n  // that forms a successful pair, then calculate the number of successful pairs for each spell.\\n  // The map function creates a new array with the results of calling the provided function on every element in the original spells array.\\n  return spells.map(\\n    // Calculate the minimum potion strength required to form a successful pair\\n    // with the current spell, and use binary search to find the index where the target value should be inserted.\\n    (spell) => potions.length - binarySearch(potions, Math.ceil(success / spell))\\n  );\\n}\\n```\\n![2300. Successful Pairs of Spells and Potions.PNG](https://assets.leetcode.com/users/images/e1438d97-4336-441e-bc1c-810381166d23_1680447034.2240133.png)\\n",
                "solutionTags": [
                    "TypeScript",
                    "Array",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\n/**\\n * Performs binary search on a sorted array to find the index where the target value should be inserted.\\n * \\n * @param arr - A sorted array of numbers.\\n * @param target - The target number to be searched for.\\n * @returns The index where the target value should be inserted to maintain the sorted order.\\n */\\nfunction binarySearch(arr: number[], target: number): number {\\n  let left = 0;\\n  let right = arr.length - 1;\\n\\n  // Iterate until the left and right pointers converge.\\n  while (left <= right) {\\n    const mid = left + Math.floor((right - left) / 2);\\n\\n    if (arr[mid] < target) {\\n      left = mid + 1;\\n    } else {\\n      right = mid - 1;\\n    }\\n  }\\n\\n  // Return the index where the target value should be inserted.\\n  return left;\\n}\\n\\n/**\\n * Calculates the number of successful pairs of spells and potions.\\n * A spell and potion pair is considered successful if the product of their strengths is at least `success`.\\n *\\n * @param spells - An array of integers representing the strengths of the spells.\\n * @param potions - An array of integers representing the strengths of the potions.\\n * @param success - An integer representing the minimum product of spell and potion strengths required for success.\\n * @returns An array of integers representing the number of potions that will form a successful pair with each spell.\\n */\\nfunction successfulPairs(spells: number[], potions: number[], success: number): number[] {\\n  // Sort the potions list in ascending order to allow for efficient binary search.\\n  potions.sort((a, b) => a - b);\\n\\n  // Iterate over each spell in the spells list and use binary search to find the index of the first potion\\n  // that forms a successful pair, then calculate the number of successful pairs for each spell.\\n  // The map function creates a new array with the results of calling the provided function on every element in the original spells array.\\n  return spells.map(\\n    // Calculate the minimum potion strength required to form a successful pair\\n    // with the current spell, and use binary search to find the index where the target value should be inserted.\\n    (spell) => potions.length - binarySearch(potions, Math.ceil(success / spell))\\n  );\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3371091,
                "title": "easy-c-approach-with-explanation",
                "content": "# Intuition\\nAs answer should follow the of spells so we can\\'t change that array.\\nbut if we read question properly then we can see that we only need to count values in potions by which if we product the spells index value which give product atleast success. \\n\\n# Approach\\nAs we have to find number of products which will give product with specific index atleast success.\\nSo if we see potion index we can easily see that we if we somehow sort that and find minimum value which gives product atleast success then rest falling ownwards will be greater. so which whill give result easily\\nSteps\\n1. sort potion array.\\n2. traverse spell array.\\n3. apply binary search to find minimum value giving product >= success.\\n4. add potion size - index to result.\\n\\n# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\nO(n) for result vector\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        sort(potions.begin(), potions.end());\\n        vector<int> result;\\n        for(auto x: spells)\\n        {\\n            int low = 0, high = potions.size() - 1;\\n            while(low <= high)\\n            {\\n                int mid = low + (high - low) / 2;\\n                long long pro = long(potions[mid]) * (long)(x);\\n                if(pro >= success)\\n                    high = mid - 1;\\n                else \\n                    low = mid +1;\\n            }\\n            result.push_back(potions.size() - low);\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        sort(potions.begin(), potions.end());\\n        vector<int> result;\\n        for(auto x: spells)\\n        {\\n            int low = 0, high = potions.size() - 1;\\n            while(low <= high)\\n            {\\n                int mid = low + (high - low) / 2;\\n                long long pro = long(potions[mid]) * (long)(x);\\n                if(pro >= success)\\n                    high = mid - 1;\\n                else \\n                    low = mid +1;\\n            }\\n            result.push_back(potions.size() - low);\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3371074,
                "title": "easy-java-solution-binary-search-memory-98-faster",
                "content": "# Code\\n```\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        Arrays.sort(potions);\\n        for(int i = 0; i < spells.length; i++){\\n            long target = (success + spells[i] - 1) / spells[i];\\n            int left = 0;\\n            int right = potions.length - 1;\\n\\n            while(left < right) {\\n                int mid = (right + left) / 2;\\n                if(potions[mid] < target) left = mid + 1;\\n                else right = mid;\\n            }\\n\\n            if(potions[left] < target) left++;\\n            spells[i] = potions.length - left;\\n        }\\n\\n        return spells;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        Arrays.sort(potions);\\n        for(int i = 0; i < spells.length; i++){\\n            long target = (success + spells[i] - 1) / spells[i];\\n            int left = 0;\\n            int right = potions.length - 1;\\n\\n            while(left < right) {\\n                int mid = (right + left) / 2;\\n                if(potions[mid] < target) left = mid + 1;\\n                else right = mid;\\n            }\\n\\n            if(potions[left] < target) left++;\\n            spells[i] = potions.length - left;\\n        }\\n\\n        return spells;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1850766,
                "content": [
                    {
                        "username": "AlecLC",
                        "content": "Which potion do I need to give the interviewer to hire me?"
                    },
                    {
                        "username": "santanusen",
                        "content": "```\\nvoid get_hired(vector<Company>& companies) {\\n    sort (companies.begin(), companies.end(), greater_preference());\\n    for (company : companies)\\n        if (interview(company) == hired)\\n            return;\\n\\n    get_hired(companies);\\n}\\n\\n```"
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "Potion of Butter \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Msey",
                        "content": "[@_Tan_A](/_Tan_A) You need to find a cat"
                    },
                    {
                        "username": "abhishek_2603",
                        "content": "[@Msey](/Msey)  what if I am a male."
                    },
                    {
                        "username": "nat1902",
                        "content": "[@Msey](/Msey) lol:)))))))))))))))"
                    },
                    {
                        "username": "Msey",
                        "content": "pussy juice"
                    },
                    {
                        "username": "Sudeepreddy537",
                        "content": "0(1) is it\\n"
                    },
                    {
                        "username": "pushprajsinghpawar7",
                        "content": ")1(O"
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "skill potion if u are not a female"
                    },
                    {
                        "username": "AMerrill",
                        "content": "[@gonestill](/gonestill) Paired with a disillusionment spell!"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "so if u go by NAIVE approach at 51th test case out of 56 u will get TLE"
                    },
                    {
                        "username": "hero080",
                        "content": "binary search is the *naive* approach here."
                    },
                    {
                        "username": "_srahul_",
                        "content": "The moment I see size as 10^5 in constraint, my mind automatically starts thinking of an approach that is `<= O(n*logn)  `.\\n\\nPerks of giving contests."
                    },
                    {
                        "username": "ibeastking",
                        "content": "[@amr_pk](/amr_pk)  So if the constraint was 10^4, then we could have used N^2 approach??"
                    },
                    {
                        "username": "amr_pk",
                        "content": "[@guptatanish145](/guptatanish145) 1 second ~= 10^8 operations. You should not exceed that. So you can write a solution that\\'s either N (10^5) or NlogN (10^6). That\\'s my mindset when I solve codeforces contests."
                    },
                    {
                        "username": "codeMonarch",
                        "content": "sumpott ++"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "how did you identify that ?"
                    },
                    {
                        "username": "pokaChika",
                        "content": "Reminds me of Severus Snape the Potions Master 😂 "
                    },
                    {
                        "username": "AMerrill",
                        "content": "This problem is a great follow up to yesterdays daily challenge. Let\\'s get the April streak going!\\n\\nThe question is: how can you implement a binary search in solving this problem? Try thinking about what variables you can change and how!"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Tip/Hint:- \n\n\nSort the potions array and then for each spell find the lower bound `idx `for\n\n `temp = (double) success/spell[i]`\n\nand push_back `length-idx` in the ans array."
                    },
                    {
                        "username": "chiragsanghvi18",
                        "content": "Doing the exact same thing but getting TLE not sure why."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@namandt](/namandt) yep exactly\\n"
                    },
                    {
                        "username": "Maang-io",
                        "content": "You can sort the array in descending order, and just push the index to result.\\nhttps://leetcode.com/problems/successful-pairs-of-spells-and-potions/solutions/3372013/interview-approach-journey-from-brute-force-to-better-brute-force-to-sorting-and-binary-search/"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@sarpalmadhav](/sarpalmadhav) Yeah, but I directly use the STL function lower_bound for this problem, there i needed to put a value to look for in the array,so I had only that option"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Shubham Raj](/Shubham_Raj22) In high precision problems, using double and dividing large numbers can be a risky bet. `spell[i]*potion[j] >= success` would be a better check"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@namandt](/namandt) It is that simple, lower bound means that in the sorted array we get the first occuring instance.. hence all other potions will be covered"
                    },
                    {
                        "username": "namandt",
                        "content": "Its not that simple.\\nNeed to handle duplicates in the potions"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "I guess Binary Search days are coming "
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "[@marwanmusa](/marwanmusa) my bad I\\'ve been training to look for hints and patterns from just the problem description and examples, not the optional hints some problems have haha"
                    },
                    {
                        "username": "marwanmusa",
                        "content": "[@disturbedbrown1](/disturbedbrown1) its in hint-3/3"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "the problem didnt give away any bs pattern/ hint though"
                    },
                    {
                        "username": "mickodjordjevic98",
                        "content": "Hints point to using binary search, but the best solution uses something similar to prefix sum which gives O(n) time instead of O(nlogn). Maybe this question need to have its conditions changed to make binary search most efficient option (since that is the point of the question I guess, to practice bs), maximum value of potions and spells should be big enough so that an array size of maxPotion or maxSpell exceeds memory capacity."
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "[@ashedcorpse](/ashedcorpse) A better problem to practice on is https://leetcode.com/problems/search-a-2d-matrix-ii/, as there are a few extra wrinkles in directly applying it to this problem that cloud the elegance of the strategy."
                    },
                    {
                        "username": "AlecLC",
                        "content": "[@ashedcorpse](/ashedcorpse) 2 pointer"
                    },
                    {
                        "username": "cswartzell",
                        "content": "I actually rather love that its NOT a binary search question, and may mislead people into thinking it is one. Its a good lesson to consider other, possibly simpler solutions. There are plenty of Binary Search questions on LC, we dont need to modify this to be a straight binary search. Its better as is to show why the tricky answer might actually be worse than the simple answer. "
                    },
                    {
                        "username": "ashedcorpse",
                        "content": "can you please share the approach of O(n)"
                    },
                    {
                        "username": "CodingMonkey101",
                        "content": "`Tip`\n***Just wanted to share my two favorite binary search templates to help with this problem as well as any similar ones:***\nTemplate 1: Find max value of x such that f(x) is true\n```\ndef binarySearchForMinVal()\n    l, r = lower_bound, upper_bound\n    while l < r:\n        mid = (l + r)//2 #round down\n        if feasible(mid):\n            r = mid #check for possible smaller values that work\n        else:\n            l = mid + 1 #values smaller than or equal to mid do not work. Reduce search space to values greater than mid.\n    return l\n```\nTemplate 2: Find min value of x such that f(x) is true\n```\ndef binarySearchForMaxVal()\n    l, r = lower_bound, upper_bound\n    while l < r:\n        mid = (l + r + 1)//2 #round up\n        if feasible(mid):\n            l = mid #check for possible greater values that work\n        else:\n            r = mid - 1 #values greater than or equal to mid do not work. Reduce search space to values smaller than mid.\n    return l\n\n```"
                    },
                    {
                        "username": "rajat_171",
                        "content": "Sometimes it is good, sometimes it is shit. (\\u25CF\\'\\u25E1\\'\\u25CF)"
                    },
                    {
                        "username": "EnzoPay",
                        "content": "For me bisearch is not the best way, brings to many troubles... :("
                    }
                ]
            },
            {
                "id": 1850841,
                "content": [
                    {
                        "username": "AlecLC",
                        "content": "Which potion do I need to give the interviewer to hire me?"
                    },
                    {
                        "username": "santanusen",
                        "content": "```\\nvoid get_hired(vector<Company>& companies) {\\n    sort (companies.begin(), companies.end(), greater_preference());\\n    for (company : companies)\\n        if (interview(company) == hired)\\n            return;\\n\\n    get_hired(companies);\\n}\\n\\n```"
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "Potion of Butter \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Msey",
                        "content": "[@_Tan_A](/_Tan_A) You need to find a cat"
                    },
                    {
                        "username": "abhishek_2603",
                        "content": "[@Msey](/Msey)  what if I am a male."
                    },
                    {
                        "username": "nat1902",
                        "content": "[@Msey](/Msey) lol:)))))))))))))))"
                    },
                    {
                        "username": "Msey",
                        "content": "pussy juice"
                    },
                    {
                        "username": "Sudeepreddy537",
                        "content": "0(1) is it\\n"
                    },
                    {
                        "username": "pushprajsinghpawar7",
                        "content": ")1(O"
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "skill potion if u are not a female"
                    },
                    {
                        "username": "AMerrill",
                        "content": "[@gonestill](/gonestill) Paired with a disillusionment spell!"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "so if u go by NAIVE approach at 51th test case out of 56 u will get TLE"
                    },
                    {
                        "username": "hero080",
                        "content": "binary search is the *naive* approach here."
                    },
                    {
                        "username": "_srahul_",
                        "content": "The moment I see size as 10^5 in constraint, my mind automatically starts thinking of an approach that is `<= O(n*logn)  `.\\n\\nPerks of giving contests."
                    },
                    {
                        "username": "ibeastking",
                        "content": "[@amr_pk](/amr_pk)  So if the constraint was 10^4, then we could have used N^2 approach??"
                    },
                    {
                        "username": "amr_pk",
                        "content": "[@guptatanish145](/guptatanish145) 1 second ~= 10^8 operations. You should not exceed that. So you can write a solution that\\'s either N (10^5) or NlogN (10^6). That\\'s my mindset when I solve codeforces contests."
                    },
                    {
                        "username": "codeMonarch",
                        "content": "sumpott ++"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "how did you identify that ?"
                    },
                    {
                        "username": "pokaChika",
                        "content": "Reminds me of Severus Snape the Potions Master 😂 "
                    },
                    {
                        "username": "AMerrill",
                        "content": "This problem is a great follow up to yesterdays daily challenge. Let\\'s get the April streak going!\\n\\nThe question is: how can you implement a binary search in solving this problem? Try thinking about what variables you can change and how!"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Tip/Hint:- \n\n\nSort the potions array and then for each spell find the lower bound `idx `for\n\n `temp = (double) success/spell[i]`\n\nand push_back `length-idx` in the ans array."
                    },
                    {
                        "username": "chiragsanghvi18",
                        "content": "Doing the exact same thing but getting TLE not sure why."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@namandt](/namandt) yep exactly\\n"
                    },
                    {
                        "username": "Maang-io",
                        "content": "You can sort the array in descending order, and just push the index to result.\\nhttps://leetcode.com/problems/successful-pairs-of-spells-and-potions/solutions/3372013/interview-approach-journey-from-brute-force-to-better-brute-force-to-sorting-and-binary-search/"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@sarpalmadhav](/sarpalmadhav) Yeah, but I directly use the STL function lower_bound for this problem, there i needed to put a value to look for in the array,so I had only that option"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Shubham Raj](/Shubham_Raj22) In high precision problems, using double and dividing large numbers can be a risky bet. `spell[i]*potion[j] >= success` would be a better check"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@namandt](/namandt) It is that simple, lower bound means that in the sorted array we get the first occuring instance.. hence all other potions will be covered"
                    },
                    {
                        "username": "namandt",
                        "content": "Its not that simple.\\nNeed to handle duplicates in the potions"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "I guess Binary Search days are coming "
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "[@marwanmusa](/marwanmusa) my bad I\\'ve been training to look for hints and patterns from just the problem description and examples, not the optional hints some problems have haha"
                    },
                    {
                        "username": "marwanmusa",
                        "content": "[@disturbedbrown1](/disturbedbrown1) its in hint-3/3"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "the problem didnt give away any bs pattern/ hint though"
                    },
                    {
                        "username": "mickodjordjevic98",
                        "content": "Hints point to using binary search, but the best solution uses something similar to prefix sum which gives O(n) time instead of O(nlogn). Maybe this question need to have its conditions changed to make binary search most efficient option (since that is the point of the question I guess, to practice bs), maximum value of potions and spells should be big enough so that an array size of maxPotion or maxSpell exceeds memory capacity."
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "[@ashedcorpse](/ashedcorpse) A better problem to practice on is https://leetcode.com/problems/search-a-2d-matrix-ii/, as there are a few extra wrinkles in directly applying it to this problem that cloud the elegance of the strategy."
                    },
                    {
                        "username": "AlecLC",
                        "content": "[@ashedcorpse](/ashedcorpse) 2 pointer"
                    },
                    {
                        "username": "cswartzell",
                        "content": "I actually rather love that its NOT a binary search question, and may mislead people into thinking it is one. Its a good lesson to consider other, possibly simpler solutions. There are plenty of Binary Search questions on LC, we dont need to modify this to be a straight binary search. Its better as is to show why the tricky answer might actually be worse than the simple answer. "
                    },
                    {
                        "username": "ashedcorpse",
                        "content": "can you please share the approach of O(n)"
                    },
                    {
                        "username": "CodingMonkey101",
                        "content": "`Tip`\n***Just wanted to share my two favorite binary search templates to help with this problem as well as any similar ones:***\nTemplate 1: Find max value of x such that f(x) is true\n```\ndef binarySearchForMinVal()\n    l, r = lower_bound, upper_bound\n    while l < r:\n        mid = (l + r)//2 #round down\n        if feasible(mid):\n            r = mid #check for possible smaller values that work\n        else:\n            l = mid + 1 #values smaller than or equal to mid do not work. Reduce search space to values greater than mid.\n    return l\n```\nTemplate 2: Find min value of x such that f(x) is true\n```\ndef binarySearchForMaxVal()\n    l, r = lower_bound, upper_bound\n    while l < r:\n        mid = (l + r + 1)//2 #round up\n        if feasible(mid):\n            l = mid #check for possible greater values that work\n        else:\n            r = mid - 1 #values greater than or equal to mid do not work. Reduce search space to values smaller than mid.\n    return l\n\n```"
                    },
                    {
                        "username": "rajat_171",
                        "content": "Sometimes it is good, sometimes it is shit. (\\u25CF\\'\\u25E1\\'\\u25CF)"
                    },
                    {
                        "username": "EnzoPay",
                        "content": "For me bisearch is not the best way, brings to many troubles... :("
                    }
                ]
            },
            {
                "id": 1851177,
                "content": [
                    {
                        "username": "AlecLC",
                        "content": "Which potion do I need to give the interviewer to hire me?"
                    },
                    {
                        "username": "santanusen",
                        "content": "```\\nvoid get_hired(vector<Company>& companies) {\\n    sort (companies.begin(), companies.end(), greater_preference());\\n    for (company : companies)\\n        if (interview(company) == hired)\\n            return;\\n\\n    get_hired(companies);\\n}\\n\\n```"
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "Potion of Butter \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Msey",
                        "content": "[@_Tan_A](/_Tan_A) You need to find a cat"
                    },
                    {
                        "username": "abhishek_2603",
                        "content": "[@Msey](/Msey)  what if I am a male."
                    },
                    {
                        "username": "nat1902",
                        "content": "[@Msey](/Msey) lol:)))))))))))))))"
                    },
                    {
                        "username": "Msey",
                        "content": "pussy juice"
                    },
                    {
                        "username": "Sudeepreddy537",
                        "content": "0(1) is it\\n"
                    },
                    {
                        "username": "pushprajsinghpawar7",
                        "content": ")1(O"
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "skill potion if u are not a female"
                    },
                    {
                        "username": "AMerrill",
                        "content": "[@gonestill](/gonestill) Paired with a disillusionment spell!"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "so if u go by NAIVE approach at 51th test case out of 56 u will get TLE"
                    },
                    {
                        "username": "hero080",
                        "content": "binary search is the *naive* approach here."
                    },
                    {
                        "username": "_srahul_",
                        "content": "The moment I see size as 10^5 in constraint, my mind automatically starts thinking of an approach that is `<= O(n*logn)  `.\\n\\nPerks of giving contests."
                    },
                    {
                        "username": "ibeastking",
                        "content": "[@amr_pk](/amr_pk)  So if the constraint was 10^4, then we could have used N^2 approach??"
                    },
                    {
                        "username": "amr_pk",
                        "content": "[@guptatanish145](/guptatanish145) 1 second ~= 10^8 operations. You should not exceed that. So you can write a solution that\\'s either N (10^5) or NlogN (10^6). That\\'s my mindset when I solve codeforces contests."
                    },
                    {
                        "username": "codeMonarch",
                        "content": "sumpott ++"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "how did you identify that ?"
                    },
                    {
                        "username": "pokaChika",
                        "content": "Reminds me of Severus Snape the Potions Master 😂 "
                    },
                    {
                        "username": "AMerrill",
                        "content": "This problem is a great follow up to yesterdays daily challenge. Let\\'s get the April streak going!\\n\\nThe question is: how can you implement a binary search in solving this problem? Try thinking about what variables you can change and how!"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Tip/Hint:- \n\n\nSort the potions array and then for each spell find the lower bound `idx `for\n\n `temp = (double) success/spell[i]`\n\nand push_back `length-idx` in the ans array."
                    },
                    {
                        "username": "chiragsanghvi18",
                        "content": "Doing the exact same thing but getting TLE not sure why."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@namandt](/namandt) yep exactly\\n"
                    },
                    {
                        "username": "Maang-io",
                        "content": "You can sort the array in descending order, and just push the index to result.\\nhttps://leetcode.com/problems/successful-pairs-of-spells-and-potions/solutions/3372013/interview-approach-journey-from-brute-force-to-better-brute-force-to-sorting-and-binary-search/"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@sarpalmadhav](/sarpalmadhav) Yeah, but I directly use the STL function lower_bound for this problem, there i needed to put a value to look for in the array,so I had only that option"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Shubham Raj](/Shubham_Raj22) In high precision problems, using double and dividing large numbers can be a risky bet. `spell[i]*potion[j] >= success` would be a better check"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@namandt](/namandt) It is that simple, lower bound means that in the sorted array we get the first occuring instance.. hence all other potions will be covered"
                    },
                    {
                        "username": "namandt",
                        "content": "Its not that simple.\\nNeed to handle duplicates in the potions"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "I guess Binary Search days are coming "
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "[@marwanmusa](/marwanmusa) my bad I\\'ve been training to look for hints and patterns from just the problem description and examples, not the optional hints some problems have haha"
                    },
                    {
                        "username": "marwanmusa",
                        "content": "[@disturbedbrown1](/disturbedbrown1) its in hint-3/3"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "the problem didnt give away any bs pattern/ hint though"
                    },
                    {
                        "username": "mickodjordjevic98",
                        "content": "Hints point to using binary search, but the best solution uses something similar to prefix sum which gives O(n) time instead of O(nlogn). Maybe this question need to have its conditions changed to make binary search most efficient option (since that is the point of the question I guess, to practice bs), maximum value of potions and spells should be big enough so that an array size of maxPotion or maxSpell exceeds memory capacity."
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "[@ashedcorpse](/ashedcorpse) A better problem to practice on is https://leetcode.com/problems/search-a-2d-matrix-ii/, as there are a few extra wrinkles in directly applying it to this problem that cloud the elegance of the strategy."
                    },
                    {
                        "username": "AlecLC",
                        "content": "[@ashedcorpse](/ashedcorpse) 2 pointer"
                    },
                    {
                        "username": "cswartzell",
                        "content": "I actually rather love that its NOT a binary search question, and may mislead people into thinking it is one. Its a good lesson to consider other, possibly simpler solutions. There are plenty of Binary Search questions on LC, we dont need to modify this to be a straight binary search. Its better as is to show why the tricky answer might actually be worse than the simple answer. "
                    },
                    {
                        "username": "ashedcorpse",
                        "content": "can you please share the approach of O(n)"
                    },
                    {
                        "username": "CodingMonkey101",
                        "content": "`Tip`\n***Just wanted to share my two favorite binary search templates to help with this problem as well as any similar ones:***\nTemplate 1: Find max value of x such that f(x) is true\n```\ndef binarySearchForMinVal()\n    l, r = lower_bound, upper_bound\n    while l < r:\n        mid = (l + r)//2 #round down\n        if feasible(mid):\n            r = mid #check for possible smaller values that work\n        else:\n            l = mid + 1 #values smaller than or equal to mid do not work. Reduce search space to values greater than mid.\n    return l\n```\nTemplate 2: Find min value of x such that f(x) is true\n```\ndef binarySearchForMaxVal()\n    l, r = lower_bound, upper_bound\n    while l < r:\n        mid = (l + r + 1)//2 #round up\n        if feasible(mid):\n            l = mid #check for possible greater values that work\n        else:\n            r = mid - 1 #values greater than or equal to mid do not work. Reduce search space to values smaller than mid.\n    return l\n\n```"
                    },
                    {
                        "username": "rajat_171",
                        "content": "Sometimes it is good, sometimes it is shit. (\\u25CF\\'\\u25E1\\'\\u25CF)"
                    },
                    {
                        "username": "EnzoPay",
                        "content": "For me bisearch is not the best way, brings to many troubles... :("
                    }
                ]
            },
            {
                "id": 1850860,
                "content": [
                    {
                        "username": "AlecLC",
                        "content": "Which potion do I need to give the interviewer to hire me?"
                    },
                    {
                        "username": "santanusen",
                        "content": "```\\nvoid get_hired(vector<Company>& companies) {\\n    sort (companies.begin(), companies.end(), greater_preference());\\n    for (company : companies)\\n        if (interview(company) == hired)\\n            return;\\n\\n    get_hired(companies);\\n}\\n\\n```"
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "Potion of Butter \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Msey",
                        "content": "[@_Tan_A](/_Tan_A) You need to find a cat"
                    },
                    {
                        "username": "abhishek_2603",
                        "content": "[@Msey](/Msey)  what if I am a male."
                    },
                    {
                        "username": "nat1902",
                        "content": "[@Msey](/Msey) lol:)))))))))))))))"
                    },
                    {
                        "username": "Msey",
                        "content": "pussy juice"
                    },
                    {
                        "username": "Sudeepreddy537",
                        "content": "0(1) is it\\n"
                    },
                    {
                        "username": "pushprajsinghpawar7",
                        "content": ")1(O"
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "skill potion if u are not a female"
                    },
                    {
                        "username": "AMerrill",
                        "content": "[@gonestill](/gonestill) Paired with a disillusionment spell!"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "so if u go by NAIVE approach at 51th test case out of 56 u will get TLE"
                    },
                    {
                        "username": "hero080",
                        "content": "binary search is the *naive* approach here."
                    },
                    {
                        "username": "_srahul_",
                        "content": "The moment I see size as 10^5 in constraint, my mind automatically starts thinking of an approach that is `<= O(n*logn)  `.\\n\\nPerks of giving contests."
                    },
                    {
                        "username": "ibeastking",
                        "content": "[@amr_pk](/amr_pk)  So if the constraint was 10^4, then we could have used N^2 approach??"
                    },
                    {
                        "username": "amr_pk",
                        "content": "[@guptatanish145](/guptatanish145) 1 second ~= 10^8 operations. You should not exceed that. So you can write a solution that\\'s either N (10^5) or NlogN (10^6). That\\'s my mindset when I solve codeforces contests."
                    },
                    {
                        "username": "codeMonarch",
                        "content": "sumpott ++"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "how did you identify that ?"
                    },
                    {
                        "username": "pokaChika",
                        "content": "Reminds me of Severus Snape the Potions Master 😂 "
                    },
                    {
                        "username": "AMerrill",
                        "content": "This problem is a great follow up to yesterdays daily challenge. Let\\'s get the April streak going!\\n\\nThe question is: how can you implement a binary search in solving this problem? Try thinking about what variables you can change and how!"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Tip/Hint:- \n\n\nSort the potions array and then for each spell find the lower bound `idx `for\n\n `temp = (double) success/spell[i]`\n\nand push_back `length-idx` in the ans array."
                    },
                    {
                        "username": "chiragsanghvi18",
                        "content": "Doing the exact same thing but getting TLE not sure why."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@namandt](/namandt) yep exactly\\n"
                    },
                    {
                        "username": "Maang-io",
                        "content": "You can sort the array in descending order, and just push the index to result.\\nhttps://leetcode.com/problems/successful-pairs-of-spells-and-potions/solutions/3372013/interview-approach-journey-from-brute-force-to-better-brute-force-to-sorting-and-binary-search/"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@sarpalmadhav](/sarpalmadhav) Yeah, but I directly use the STL function lower_bound for this problem, there i needed to put a value to look for in the array,so I had only that option"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Shubham Raj](/Shubham_Raj22) In high precision problems, using double and dividing large numbers can be a risky bet. `spell[i]*potion[j] >= success` would be a better check"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@namandt](/namandt) It is that simple, lower bound means that in the sorted array we get the first occuring instance.. hence all other potions will be covered"
                    },
                    {
                        "username": "namandt",
                        "content": "Its not that simple.\\nNeed to handle duplicates in the potions"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "I guess Binary Search days are coming "
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "[@marwanmusa](/marwanmusa) my bad I\\'ve been training to look for hints and patterns from just the problem description and examples, not the optional hints some problems have haha"
                    },
                    {
                        "username": "marwanmusa",
                        "content": "[@disturbedbrown1](/disturbedbrown1) its in hint-3/3"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "the problem didnt give away any bs pattern/ hint though"
                    },
                    {
                        "username": "mickodjordjevic98",
                        "content": "Hints point to using binary search, but the best solution uses something similar to prefix sum which gives O(n) time instead of O(nlogn). Maybe this question need to have its conditions changed to make binary search most efficient option (since that is the point of the question I guess, to practice bs), maximum value of potions and spells should be big enough so that an array size of maxPotion or maxSpell exceeds memory capacity."
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "[@ashedcorpse](/ashedcorpse) A better problem to practice on is https://leetcode.com/problems/search-a-2d-matrix-ii/, as there are a few extra wrinkles in directly applying it to this problem that cloud the elegance of the strategy."
                    },
                    {
                        "username": "AlecLC",
                        "content": "[@ashedcorpse](/ashedcorpse) 2 pointer"
                    },
                    {
                        "username": "cswartzell",
                        "content": "I actually rather love that its NOT a binary search question, and may mislead people into thinking it is one. Its a good lesson to consider other, possibly simpler solutions. There are plenty of Binary Search questions on LC, we dont need to modify this to be a straight binary search. Its better as is to show why the tricky answer might actually be worse than the simple answer. "
                    },
                    {
                        "username": "ashedcorpse",
                        "content": "can you please share the approach of O(n)"
                    },
                    {
                        "username": "CodingMonkey101",
                        "content": "`Tip`\n***Just wanted to share my two favorite binary search templates to help with this problem as well as any similar ones:***\nTemplate 1: Find max value of x such that f(x) is true\n```\ndef binarySearchForMinVal()\n    l, r = lower_bound, upper_bound\n    while l < r:\n        mid = (l + r)//2 #round down\n        if feasible(mid):\n            r = mid #check for possible smaller values that work\n        else:\n            l = mid + 1 #values smaller than or equal to mid do not work. Reduce search space to values greater than mid.\n    return l\n```\nTemplate 2: Find min value of x such that f(x) is true\n```\ndef binarySearchForMaxVal()\n    l, r = lower_bound, upper_bound\n    while l < r:\n        mid = (l + r + 1)//2 #round up\n        if feasible(mid):\n            l = mid #check for possible greater values that work\n        else:\n            r = mid - 1 #values greater than or equal to mid do not work. Reduce search space to values smaller than mid.\n    return l\n\n```"
                    },
                    {
                        "username": "rajat_171",
                        "content": "Sometimes it is good, sometimes it is shit. (\\u25CF\\'\\u25E1\\'\\u25CF)"
                    },
                    {
                        "username": "EnzoPay",
                        "content": "For me bisearch is not the best way, brings to many troubles... :("
                    }
                ]
            },
            {
                "id": 1850810,
                "content": [
                    {
                        "username": "AlecLC",
                        "content": "Which potion do I need to give the interviewer to hire me?"
                    },
                    {
                        "username": "santanusen",
                        "content": "```\\nvoid get_hired(vector<Company>& companies) {\\n    sort (companies.begin(), companies.end(), greater_preference());\\n    for (company : companies)\\n        if (interview(company) == hired)\\n            return;\\n\\n    get_hired(companies);\\n}\\n\\n```"
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "Potion of Butter \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Msey",
                        "content": "[@_Tan_A](/_Tan_A) You need to find a cat"
                    },
                    {
                        "username": "abhishek_2603",
                        "content": "[@Msey](/Msey)  what if I am a male."
                    },
                    {
                        "username": "nat1902",
                        "content": "[@Msey](/Msey) lol:)))))))))))))))"
                    },
                    {
                        "username": "Msey",
                        "content": "pussy juice"
                    },
                    {
                        "username": "Sudeepreddy537",
                        "content": "0(1) is it\\n"
                    },
                    {
                        "username": "pushprajsinghpawar7",
                        "content": ")1(O"
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "skill potion if u are not a female"
                    },
                    {
                        "username": "AMerrill",
                        "content": "[@gonestill](/gonestill) Paired with a disillusionment spell!"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "so if u go by NAIVE approach at 51th test case out of 56 u will get TLE"
                    },
                    {
                        "username": "hero080",
                        "content": "binary search is the *naive* approach here."
                    },
                    {
                        "username": "_srahul_",
                        "content": "The moment I see size as 10^5 in constraint, my mind automatically starts thinking of an approach that is `<= O(n*logn)  `.\\n\\nPerks of giving contests."
                    },
                    {
                        "username": "ibeastking",
                        "content": "[@amr_pk](/amr_pk)  So if the constraint was 10^4, then we could have used N^2 approach??"
                    },
                    {
                        "username": "amr_pk",
                        "content": "[@guptatanish145](/guptatanish145) 1 second ~= 10^8 operations. You should not exceed that. So you can write a solution that\\'s either N (10^5) or NlogN (10^6). That\\'s my mindset when I solve codeforces contests."
                    },
                    {
                        "username": "codeMonarch",
                        "content": "sumpott ++"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "how did you identify that ?"
                    },
                    {
                        "username": "pokaChika",
                        "content": "Reminds me of Severus Snape the Potions Master 😂 "
                    },
                    {
                        "username": "AMerrill",
                        "content": "This problem is a great follow up to yesterdays daily challenge. Let\\'s get the April streak going!\\n\\nThe question is: how can you implement a binary search in solving this problem? Try thinking about what variables you can change and how!"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Tip/Hint:- \n\n\nSort the potions array and then for each spell find the lower bound `idx `for\n\n `temp = (double) success/spell[i]`\n\nand push_back `length-idx` in the ans array."
                    },
                    {
                        "username": "chiragsanghvi18",
                        "content": "Doing the exact same thing but getting TLE not sure why."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@namandt](/namandt) yep exactly\\n"
                    },
                    {
                        "username": "Maang-io",
                        "content": "You can sort the array in descending order, and just push the index to result.\\nhttps://leetcode.com/problems/successful-pairs-of-spells-and-potions/solutions/3372013/interview-approach-journey-from-brute-force-to-better-brute-force-to-sorting-and-binary-search/"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@sarpalmadhav](/sarpalmadhav) Yeah, but I directly use the STL function lower_bound for this problem, there i needed to put a value to look for in the array,so I had only that option"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Shubham Raj](/Shubham_Raj22) In high precision problems, using double and dividing large numbers can be a risky bet. `spell[i]*potion[j] >= success` would be a better check"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@namandt](/namandt) It is that simple, lower bound means that in the sorted array we get the first occuring instance.. hence all other potions will be covered"
                    },
                    {
                        "username": "namandt",
                        "content": "Its not that simple.\\nNeed to handle duplicates in the potions"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "I guess Binary Search days are coming "
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "[@marwanmusa](/marwanmusa) my bad I\\'ve been training to look for hints and patterns from just the problem description and examples, not the optional hints some problems have haha"
                    },
                    {
                        "username": "marwanmusa",
                        "content": "[@disturbedbrown1](/disturbedbrown1) its in hint-3/3"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "the problem didnt give away any bs pattern/ hint though"
                    },
                    {
                        "username": "mickodjordjevic98",
                        "content": "Hints point to using binary search, but the best solution uses something similar to prefix sum which gives O(n) time instead of O(nlogn). Maybe this question need to have its conditions changed to make binary search most efficient option (since that is the point of the question I guess, to practice bs), maximum value of potions and spells should be big enough so that an array size of maxPotion or maxSpell exceeds memory capacity."
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "[@ashedcorpse](/ashedcorpse) A better problem to practice on is https://leetcode.com/problems/search-a-2d-matrix-ii/, as there are a few extra wrinkles in directly applying it to this problem that cloud the elegance of the strategy."
                    },
                    {
                        "username": "AlecLC",
                        "content": "[@ashedcorpse](/ashedcorpse) 2 pointer"
                    },
                    {
                        "username": "cswartzell",
                        "content": "I actually rather love that its NOT a binary search question, and may mislead people into thinking it is one. Its a good lesson to consider other, possibly simpler solutions. There are plenty of Binary Search questions on LC, we dont need to modify this to be a straight binary search. Its better as is to show why the tricky answer might actually be worse than the simple answer. "
                    },
                    {
                        "username": "ashedcorpse",
                        "content": "can you please share the approach of O(n)"
                    },
                    {
                        "username": "CodingMonkey101",
                        "content": "`Tip`\n***Just wanted to share my two favorite binary search templates to help with this problem as well as any similar ones:***\nTemplate 1: Find max value of x such that f(x) is true\n```\ndef binarySearchForMinVal()\n    l, r = lower_bound, upper_bound\n    while l < r:\n        mid = (l + r)//2 #round down\n        if feasible(mid):\n            r = mid #check for possible smaller values that work\n        else:\n            l = mid + 1 #values smaller than or equal to mid do not work. Reduce search space to values greater than mid.\n    return l\n```\nTemplate 2: Find min value of x such that f(x) is true\n```\ndef binarySearchForMaxVal()\n    l, r = lower_bound, upper_bound\n    while l < r:\n        mid = (l + r + 1)//2 #round up\n        if feasible(mid):\n            l = mid #check for possible greater values that work\n        else:\n            r = mid - 1 #values greater than or equal to mid do not work. Reduce search space to values smaller than mid.\n    return l\n\n```"
                    },
                    {
                        "username": "rajat_171",
                        "content": "Sometimes it is good, sometimes it is shit. (\\u25CF\\'\\u25E1\\'\\u25CF)"
                    },
                    {
                        "username": "EnzoPay",
                        "content": "For me bisearch is not the best way, brings to many troubles... :("
                    }
                ]
            },
            {
                "id": 1851027,
                "content": [
                    {
                        "username": "AlecLC",
                        "content": "Which potion do I need to give the interviewer to hire me?"
                    },
                    {
                        "username": "santanusen",
                        "content": "```\\nvoid get_hired(vector<Company>& companies) {\\n    sort (companies.begin(), companies.end(), greater_preference());\\n    for (company : companies)\\n        if (interview(company) == hired)\\n            return;\\n\\n    get_hired(companies);\\n}\\n\\n```"
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "Potion of Butter \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Msey",
                        "content": "[@_Tan_A](/_Tan_A) You need to find a cat"
                    },
                    {
                        "username": "abhishek_2603",
                        "content": "[@Msey](/Msey)  what if I am a male."
                    },
                    {
                        "username": "nat1902",
                        "content": "[@Msey](/Msey) lol:)))))))))))))))"
                    },
                    {
                        "username": "Msey",
                        "content": "pussy juice"
                    },
                    {
                        "username": "Sudeepreddy537",
                        "content": "0(1) is it\\n"
                    },
                    {
                        "username": "pushprajsinghpawar7",
                        "content": ")1(O"
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "skill potion if u are not a female"
                    },
                    {
                        "username": "AMerrill",
                        "content": "[@gonestill](/gonestill) Paired with a disillusionment spell!"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "so if u go by NAIVE approach at 51th test case out of 56 u will get TLE"
                    },
                    {
                        "username": "hero080",
                        "content": "binary search is the *naive* approach here."
                    },
                    {
                        "username": "_srahul_",
                        "content": "The moment I see size as 10^5 in constraint, my mind automatically starts thinking of an approach that is `<= O(n*logn)  `.\\n\\nPerks of giving contests."
                    },
                    {
                        "username": "ibeastking",
                        "content": "[@amr_pk](/amr_pk)  So if the constraint was 10^4, then we could have used N^2 approach??"
                    },
                    {
                        "username": "amr_pk",
                        "content": "[@guptatanish145](/guptatanish145) 1 second ~= 10^8 operations. You should not exceed that. So you can write a solution that\\'s either N (10^5) or NlogN (10^6). That\\'s my mindset when I solve codeforces contests."
                    },
                    {
                        "username": "codeMonarch",
                        "content": "sumpott ++"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "how did you identify that ?"
                    },
                    {
                        "username": "pokaChika",
                        "content": "Reminds me of Severus Snape the Potions Master 😂 "
                    },
                    {
                        "username": "AMerrill",
                        "content": "This problem is a great follow up to yesterdays daily challenge. Let\\'s get the April streak going!\\n\\nThe question is: how can you implement a binary search in solving this problem? Try thinking about what variables you can change and how!"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Tip/Hint:- \n\n\nSort the potions array and then for each spell find the lower bound `idx `for\n\n `temp = (double) success/spell[i]`\n\nand push_back `length-idx` in the ans array."
                    },
                    {
                        "username": "chiragsanghvi18",
                        "content": "Doing the exact same thing but getting TLE not sure why."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@namandt](/namandt) yep exactly\\n"
                    },
                    {
                        "username": "Maang-io",
                        "content": "You can sort the array in descending order, and just push the index to result.\\nhttps://leetcode.com/problems/successful-pairs-of-spells-and-potions/solutions/3372013/interview-approach-journey-from-brute-force-to-better-brute-force-to-sorting-and-binary-search/"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@sarpalmadhav](/sarpalmadhav) Yeah, but I directly use the STL function lower_bound for this problem, there i needed to put a value to look for in the array,so I had only that option"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Shubham Raj](/Shubham_Raj22) In high precision problems, using double and dividing large numbers can be a risky bet. `spell[i]*potion[j] >= success` would be a better check"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@namandt](/namandt) It is that simple, lower bound means that in the sorted array we get the first occuring instance.. hence all other potions will be covered"
                    },
                    {
                        "username": "namandt",
                        "content": "Its not that simple.\\nNeed to handle duplicates in the potions"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "I guess Binary Search days are coming "
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "[@marwanmusa](/marwanmusa) my bad I\\'ve been training to look for hints and patterns from just the problem description and examples, not the optional hints some problems have haha"
                    },
                    {
                        "username": "marwanmusa",
                        "content": "[@disturbedbrown1](/disturbedbrown1) its in hint-3/3"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "the problem didnt give away any bs pattern/ hint though"
                    },
                    {
                        "username": "mickodjordjevic98",
                        "content": "Hints point to using binary search, but the best solution uses something similar to prefix sum which gives O(n) time instead of O(nlogn). Maybe this question need to have its conditions changed to make binary search most efficient option (since that is the point of the question I guess, to practice bs), maximum value of potions and spells should be big enough so that an array size of maxPotion or maxSpell exceeds memory capacity."
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "[@ashedcorpse](/ashedcorpse) A better problem to practice on is https://leetcode.com/problems/search-a-2d-matrix-ii/, as there are a few extra wrinkles in directly applying it to this problem that cloud the elegance of the strategy."
                    },
                    {
                        "username": "AlecLC",
                        "content": "[@ashedcorpse](/ashedcorpse) 2 pointer"
                    },
                    {
                        "username": "cswartzell",
                        "content": "I actually rather love that its NOT a binary search question, and may mislead people into thinking it is one. Its a good lesson to consider other, possibly simpler solutions. There are plenty of Binary Search questions on LC, we dont need to modify this to be a straight binary search. Its better as is to show why the tricky answer might actually be worse than the simple answer. "
                    },
                    {
                        "username": "ashedcorpse",
                        "content": "can you please share the approach of O(n)"
                    },
                    {
                        "username": "CodingMonkey101",
                        "content": "`Tip`\n***Just wanted to share my two favorite binary search templates to help with this problem as well as any similar ones:***\nTemplate 1: Find max value of x such that f(x) is true\n```\ndef binarySearchForMinVal()\n    l, r = lower_bound, upper_bound\n    while l < r:\n        mid = (l + r)//2 #round down\n        if feasible(mid):\n            r = mid #check for possible smaller values that work\n        else:\n            l = mid + 1 #values smaller than or equal to mid do not work. Reduce search space to values greater than mid.\n    return l\n```\nTemplate 2: Find min value of x such that f(x) is true\n```\ndef binarySearchForMaxVal()\n    l, r = lower_bound, upper_bound\n    while l < r:\n        mid = (l + r + 1)//2 #round up\n        if feasible(mid):\n            l = mid #check for possible greater values that work\n        else:\n            r = mid - 1 #values greater than or equal to mid do not work. Reduce search space to values smaller than mid.\n    return l\n\n```"
                    },
                    {
                        "username": "rajat_171",
                        "content": "Sometimes it is good, sometimes it is shit. (\\u25CF\\'\\u25E1\\'\\u25CF)"
                    },
                    {
                        "username": "EnzoPay",
                        "content": "For me bisearch is not the best way, brings to many troubles... :("
                    }
                ]
            },
            {
                "id": 1851208,
                "content": [
                    {
                        "username": "AlecLC",
                        "content": "Which potion do I need to give the interviewer to hire me?"
                    },
                    {
                        "username": "santanusen",
                        "content": "```\\nvoid get_hired(vector<Company>& companies) {\\n    sort (companies.begin(), companies.end(), greater_preference());\\n    for (company : companies)\\n        if (interview(company) == hired)\\n            return;\\n\\n    get_hired(companies);\\n}\\n\\n```"
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "Potion of Butter \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Msey",
                        "content": "[@_Tan_A](/_Tan_A) You need to find a cat"
                    },
                    {
                        "username": "abhishek_2603",
                        "content": "[@Msey](/Msey)  what if I am a male."
                    },
                    {
                        "username": "nat1902",
                        "content": "[@Msey](/Msey) lol:)))))))))))))))"
                    },
                    {
                        "username": "Msey",
                        "content": "pussy juice"
                    },
                    {
                        "username": "Sudeepreddy537",
                        "content": "0(1) is it\\n"
                    },
                    {
                        "username": "pushprajsinghpawar7",
                        "content": ")1(O"
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "skill potion if u are not a female"
                    },
                    {
                        "username": "AMerrill",
                        "content": "[@gonestill](/gonestill) Paired with a disillusionment spell!"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "so if u go by NAIVE approach at 51th test case out of 56 u will get TLE"
                    },
                    {
                        "username": "hero080",
                        "content": "binary search is the *naive* approach here."
                    },
                    {
                        "username": "_srahul_",
                        "content": "The moment I see size as 10^5 in constraint, my mind automatically starts thinking of an approach that is `<= O(n*logn)  `.\\n\\nPerks of giving contests."
                    },
                    {
                        "username": "ibeastking",
                        "content": "[@amr_pk](/amr_pk)  So if the constraint was 10^4, then we could have used N^2 approach??"
                    },
                    {
                        "username": "amr_pk",
                        "content": "[@guptatanish145](/guptatanish145) 1 second ~= 10^8 operations. You should not exceed that. So you can write a solution that\\'s either N (10^5) or NlogN (10^6). That\\'s my mindset when I solve codeforces contests."
                    },
                    {
                        "username": "codeMonarch",
                        "content": "sumpott ++"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "how did you identify that ?"
                    },
                    {
                        "username": "pokaChika",
                        "content": "Reminds me of Severus Snape the Potions Master 😂 "
                    },
                    {
                        "username": "AMerrill",
                        "content": "This problem is a great follow up to yesterdays daily challenge. Let\\'s get the April streak going!\\n\\nThe question is: how can you implement a binary search in solving this problem? Try thinking about what variables you can change and how!"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Tip/Hint:- \n\n\nSort the potions array and then for each spell find the lower bound `idx `for\n\n `temp = (double) success/spell[i]`\n\nand push_back `length-idx` in the ans array."
                    },
                    {
                        "username": "chiragsanghvi18",
                        "content": "Doing the exact same thing but getting TLE not sure why."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@namandt](/namandt) yep exactly\\n"
                    },
                    {
                        "username": "Maang-io",
                        "content": "You can sort the array in descending order, and just push the index to result.\\nhttps://leetcode.com/problems/successful-pairs-of-spells-and-potions/solutions/3372013/interview-approach-journey-from-brute-force-to-better-brute-force-to-sorting-and-binary-search/"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@sarpalmadhav](/sarpalmadhav) Yeah, but I directly use the STL function lower_bound for this problem, there i needed to put a value to look for in the array,so I had only that option"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Shubham Raj](/Shubham_Raj22) In high precision problems, using double and dividing large numbers can be a risky bet. `spell[i]*potion[j] >= success` would be a better check"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@namandt](/namandt) It is that simple, lower bound means that in the sorted array we get the first occuring instance.. hence all other potions will be covered"
                    },
                    {
                        "username": "namandt",
                        "content": "Its not that simple.\\nNeed to handle duplicates in the potions"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "I guess Binary Search days are coming "
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "[@marwanmusa](/marwanmusa) my bad I\\'ve been training to look for hints and patterns from just the problem description and examples, not the optional hints some problems have haha"
                    },
                    {
                        "username": "marwanmusa",
                        "content": "[@disturbedbrown1](/disturbedbrown1) its in hint-3/3"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "the problem didnt give away any bs pattern/ hint though"
                    },
                    {
                        "username": "mickodjordjevic98",
                        "content": "Hints point to using binary search, but the best solution uses something similar to prefix sum which gives O(n) time instead of O(nlogn). Maybe this question need to have its conditions changed to make binary search most efficient option (since that is the point of the question I guess, to practice bs), maximum value of potions and spells should be big enough so that an array size of maxPotion or maxSpell exceeds memory capacity."
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "[@ashedcorpse](/ashedcorpse) A better problem to practice on is https://leetcode.com/problems/search-a-2d-matrix-ii/, as there are a few extra wrinkles in directly applying it to this problem that cloud the elegance of the strategy."
                    },
                    {
                        "username": "AlecLC",
                        "content": "[@ashedcorpse](/ashedcorpse) 2 pointer"
                    },
                    {
                        "username": "cswartzell",
                        "content": "I actually rather love that its NOT a binary search question, and may mislead people into thinking it is one. Its a good lesson to consider other, possibly simpler solutions. There are plenty of Binary Search questions on LC, we dont need to modify this to be a straight binary search. Its better as is to show why the tricky answer might actually be worse than the simple answer. "
                    },
                    {
                        "username": "ashedcorpse",
                        "content": "can you please share the approach of O(n)"
                    },
                    {
                        "username": "CodingMonkey101",
                        "content": "`Tip`\n***Just wanted to share my two favorite binary search templates to help with this problem as well as any similar ones:***\nTemplate 1: Find max value of x such that f(x) is true\n```\ndef binarySearchForMinVal()\n    l, r = lower_bound, upper_bound\n    while l < r:\n        mid = (l + r)//2 #round down\n        if feasible(mid):\n            r = mid #check for possible smaller values that work\n        else:\n            l = mid + 1 #values smaller than or equal to mid do not work. Reduce search space to values greater than mid.\n    return l\n```\nTemplate 2: Find min value of x such that f(x) is true\n```\ndef binarySearchForMaxVal()\n    l, r = lower_bound, upper_bound\n    while l < r:\n        mid = (l + r + 1)//2 #round up\n        if feasible(mid):\n            l = mid #check for possible greater values that work\n        else:\n            r = mid - 1 #values greater than or equal to mid do not work. Reduce search space to values smaller than mid.\n    return l\n\n```"
                    },
                    {
                        "username": "rajat_171",
                        "content": "Sometimes it is good, sometimes it is shit. (\\u25CF\\'\\u25E1\\'\\u25CF)"
                    },
                    {
                        "username": "EnzoPay",
                        "content": "For me bisearch is not the best way, brings to many troubles... :("
                    }
                ]
            },
            {
                "id": 1794344,
                "content": [
                    {
                        "username": "AlecLC",
                        "content": "Which potion do I need to give the interviewer to hire me?"
                    },
                    {
                        "username": "santanusen",
                        "content": "```\\nvoid get_hired(vector<Company>& companies) {\\n    sort (companies.begin(), companies.end(), greater_preference());\\n    for (company : companies)\\n        if (interview(company) == hired)\\n            return;\\n\\n    get_hired(companies);\\n}\\n\\n```"
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "Potion of Butter \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Msey",
                        "content": "[@_Tan_A](/_Tan_A) You need to find a cat"
                    },
                    {
                        "username": "abhishek_2603",
                        "content": "[@Msey](/Msey)  what if I am a male."
                    },
                    {
                        "username": "nat1902",
                        "content": "[@Msey](/Msey) lol:)))))))))))))))"
                    },
                    {
                        "username": "Msey",
                        "content": "pussy juice"
                    },
                    {
                        "username": "Sudeepreddy537",
                        "content": "0(1) is it\\n"
                    },
                    {
                        "username": "pushprajsinghpawar7",
                        "content": ")1(O"
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "skill potion if u are not a female"
                    },
                    {
                        "username": "AMerrill",
                        "content": "[@gonestill](/gonestill) Paired with a disillusionment spell!"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "so if u go by NAIVE approach at 51th test case out of 56 u will get TLE"
                    },
                    {
                        "username": "hero080",
                        "content": "binary search is the *naive* approach here."
                    },
                    {
                        "username": "_srahul_",
                        "content": "The moment I see size as 10^5 in constraint, my mind automatically starts thinking of an approach that is `<= O(n*logn)  `.\\n\\nPerks of giving contests."
                    },
                    {
                        "username": "ibeastking",
                        "content": "[@amr_pk](/amr_pk)  So if the constraint was 10^4, then we could have used N^2 approach??"
                    },
                    {
                        "username": "amr_pk",
                        "content": "[@guptatanish145](/guptatanish145) 1 second ~= 10^8 operations. You should not exceed that. So you can write a solution that\\'s either N (10^5) or NlogN (10^6). That\\'s my mindset when I solve codeforces contests."
                    },
                    {
                        "username": "codeMonarch",
                        "content": "sumpott ++"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "how did you identify that ?"
                    },
                    {
                        "username": "pokaChika",
                        "content": "Reminds me of Severus Snape the Potions Master 😂 "
                    },
                    {
                        "username": "AMerrill",
                        "content": "This problem is a great follow up to yesterdays daily challenge. Let\\'s get the April streak going!\\n\\nThe question is: how can you implement a binary search in solving this problem? Try thinking about what variables you can change and how!"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Tip/Hint:- \n\n\nSort the potions array and then for each spell find the lower bound `idx `for\n\n `temp = (double) success/spell[i]`\n\nand push_back `length-idx` in the ans array."
                    },
                    {
                        "username": "chiragsanghvi18",
                        "content": "Doing the exact same thing but getting TLE not sure why."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@namandt](/namandt) yep exactly\\n"
                    },
                    {
                        "username": "Maang-io",
                        "content": "You can sort the array in descending order, and just push the index to result.\\nhttps://leetcode.com/problems/successful-pairs-of-spells-and-potions/solutions/3372013/interview-approach-journey-from-brute-force-to-better-brute-force-to-sorting-and-binary-search/"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@sarpalmadhav](/sarpalmadhav) Yeah, but I directly use the STL function lower_bound for this problem, there i needed to put a value to look for in the array,so I had only that option"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Shubham Raj](/Shubham_Raj22) In high precision problems, using double and dividing large numbers can be a risky bet. `spell[i]*potion[j] >= success` would be a better check"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@namandt](/namandt) It is that simple, lower bound means that in the sorted array we get the first occuring instance.. hence all other potions will be covered"
                    },
                    {
                        "username": "namandt",
                        "content": "Its not that simple.\\nNeed to handle duplicates in the potions"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "I guess Binary Search days are coming "
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "[@marwanmusa](/marwanmusa) my bad I\\'ve been training to look for hints and patterns from just the problem description and examples, not the optional hints some problems have haha"
                    },
                    {
                        "username": "marwanmusa",
                        "content": "[@disturbedbrown1](/disturbedbrown1) its in hint-3/3"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "the problem didnt give away any bs pattern/ hint though"
                    },
                    {
                        "username": "mickodjordjevic98",
                        "content": "Hints point to using binary search, but the best solution uses something similar to prefix sum which gives O(n) time instead of O(nlogn). Maybe this question need to have its conditions changed to make binary search most efficient option (since that is the point of the question I guess, to practice bs), maximum value of potions and spells should be big enough so that an array size of maxPotion or maxSpell exceeds memory capacity."
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "[@ashedcorpse](/ashedcorpse) A better problem to practice on is https://leetcode.com/problems/search-a-2d-matrix-ii/, as there are a few extra wrinkles in directly applying it to this problem that cloud the elegance of the strategy."
                    },
                    {
                        "username": "AlecLC",
                        "content": "[@ashedcorpse](/ashedcorpse) 2 pointer"
                    },
                    {
                        "username": "cswartzell",
                        "content": "I actually rather love that its NOT a binary search question, and may mislead people into thinking it is one. Its a good lesson to consider other, possibly simpler solutions. There are plenty of Binary Search questions on LC, we dont need to modify this to be a straight binary search. Its better as is to show why the tricky answer might actually be worse than the simple answer. "
                    },
                    {
                        "username": "ashedcorpse",
                        "content": "can you please share the approach of O(n)"
                    },
                    {
                        "username": "CodingMonkey101",
                        "content": "`Tip`\n***Just wanted to share my two favorite binary search templates to help with this problem as well as any similar ones:***\nTemplate 1: Find max value of x such that f(x) is true\n```\ndef binarySearchForMinVal()\n    l, r = lower_bound, upper_bound\n    while l < r:\n        mid = (l + r)//2 #round down\n        if feasible(mid):\n            r = mid #check for possible smaller values that work\n        else:\n            l = mid + 1 #values smaller than or equal to mid do not work. Reduce search space to values greater than mid.\n    return l\n```\nTemplate 2: Find min value of x such that f(x) is true\n```\ndef binarySearchForMaxVal()\n    l, r = lower_bound, upper_bound\n    while l < r:\n        mid = (l + r + 1)//2 #round up\n        if feasible(mid):\n            l = mid #check for possible greater values that work\n        else:\n            r = mid - 1 #values greater than or equal to mid do not work. Reduce search space to values smaller than mid.\n    return l\n\n```"
                    },
                    {
                        "username": "rajat_171",
                        "content": "Sometimes it is good, sometimes it is shit. (\\u25CF\\'\\u25E1\\'\\u25CF)"
                    },
                    {
                        "username": "EnzoPay",
                        "content": "For me bisearch is not the best way, brings to many troubles... :("
                    }
                ]
            },
            {
                "id": 1851644,
                "content": [
                    {
                        "username": "AlecLC",
                        "content": "Which potion do I need to give the interviewer to hire me?"
                    },
                    {
                        "username": "santanusen",
                        "content": "```\\nvoid get_hired(vector<Company>& companies) {\\n    sort (companies.begin(), companies.end(), greater_preference());\\n    for (company : companies)\\n        if (interview(company) == hired)\\n            return;\\n\\n    get_hired(companies);\\n}\\n\\n```"
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "Potion of Butter \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Msey",
                        "content": "[@_Tan_A](/_Tan_A) You need to find a cat"
                    },
                    {
                        "username": "abhishek_2603",
                        "content": "[@Msey](/Msey)  what if I am a male."
                    },
                    {
                        "username": "nat1902",
                        "content": "[@Msey](/Msey) lol:)))))))))))))))"
                    },
                    {
                        "username": "Msey",
                        "content": "pussy juice"
                    },
                    {
                        "username": "Sudeepreddy537",
                        "content": "0(1) is it\\n"
                    },
                    {
                        "username": "pushprajsinghpawar7",
                        "content": ")1(O"
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "skill potion if u are not a female"
                    },
                    {
                        "username": "AMerrill",
                        "content": "[@gonestill](/gonestill) Paired with a disillusionment spell!"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "so if u go by NAIVE approach at 51th test case out of 56 u will get TLE"
                    },
                    {
                        "username": "hero080",
                        "content": "binary search is the *naive* approach here."
                    },
                    {
                        "username": "_srahul_",
                        "content": "The moment I see size as 10^5 in constraint, my mind automatically starts thinking of an approach that is `<= O(n*logn)  `.\\n\\nPerks of giving contests."
                    },
                    {
                        "username": "ibeastking",
                        "content": "[@amr_pk](/amr_pk)  So if the constraint was 10^4, then we could have used N^2 approach??"
                    },
                    {
                        "username": "amr_pk",
                        "content": "[@guptatanish145](/guptatanish145) 1 second ~= 10^8 operations. You should not exceed that. So you can write a solution that\\'s either N (10^5) or NlogN (10^6). That\\'s my mindset when I solve codeforces contests."
                    },
                    {
                        "username": "codeMonarch",
                        "content": "sumpott ++"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "how did you identify that ?"
                    },
                    {
                        "username": "pokaChika",
                        "content": "Reminds me of Severus Snape the Potions Master 😂 "
                    },
                    {
                        "username": "AMerrill",
                        "content": "This problem is a great follow up to yesterdays daily challenge. Let\\'s get the April streak going!\\n\\nThe question is: how can you implement a binary search in solving this problem? Try thinking about what variables you can change and how!"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Tip/Hint:- \n\n\nSort the potions array and then for each spell find the lower bound `idx `for\n\n `temp = (double) success/spell[i]`\n\nand push_back `length-idx` in the ans array."
                    },
                    {
                        "username": "chiragsanghvi18",
                        "content": "Doing the exact same thing but getting TLE not sure why."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@namandt](/namandt) yep exactly\\n"
                    },
                    {
                        "username": "Maang-io",
                        "content": "You can sort the array in descending order, and just push the index to result.\\nhttps://leetcode.com/problems/successful-pairs-of-spells-and-potions/solutions/3372013/interview-approach-journey-from-brute-force-to-better-brute-force-to-sorting-and-binary-search/"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@sarpalmadhav](/sarpalmadhav) Yeah, but I directly use the STL function lower_bound for this problem, there i needed to put a value to look for in the array,so I had only that option"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Shubham Raj](/Shubham_Raj22) In high precision problems, using double and dividing large numbers can be a risky bet. `spell[i]*potion[j] >= success` would be a better check"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@namandt](/namandt) It is that simple, lower bound means that in the sorted array we get the first occuring instance.. hence all other potions will be covered"
                    },
                    {
                        "username": "namandt",
                        "content": "Its not that simple.\\nNeed to handle duplicates in the potions"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "I guess Binary Search days are coming "
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "[@marwanmusa](/marwanmusa) my bad I\\'ve been training to look for hints and patterns from just the problem description and examples, not the optional hints some problems have haha"
                    },
                    {
                        "username": "marwanmusa",
                        "content": "[@disturbedbrown1](/disturbedbrown1) its in hint-3/3"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "the problem didnt give away any bs pattern/ hint though"
                    },
                    {
                        "username": "mickodjordjevic98",
                        "content": "Hints point to using binary search, but the best solution uses something similar to prefix sum which gives O(n) time instead of O(nlogn). Maybe this question need to have its conditions changed to make binary search most efficient option (since that is the point of the question I guess, to practice bs), maximum value of potions and spells should be big enough so that an array size of maxPotion or maxSpell exceeds memory capacity."
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "[@ashedcorpse](/ashedcorpse) A better problem to practice on is https://leetcode.com/problems/search-a-2d-matrix-ii/, as there are a few extra wrinkles in directly applying it to this problem that cloud the elegance of the strategy."
                    },
                    {
                        "username": "AlecLC",
                        "content": "[@ashedcorpse](/ashedcorpse) 2 pointer"
                    },
                    {
                        "username": "cswartzell",
                        "content": "I actually rather love that its NOT a binary search question, and may mislead people into thinking it is one. Its a good lesson to consider other, possibly simpler solutions. There are plenty of Binary Search questions on LC, we dont need to modify this to be a straight binary search. Its better as is to show why the tricky answer might actually be worse than the simple answer. "
                    },
                    {
                        "username": "ashedcorpse",
                        "content": "can you please share the approach of O(n)"
                    },
                    {
                        "username": "CodingMonkey101",
                        "content": "`Tip`\n***Just wanted to share my two favorite binary search templates to help with this problem as well as any similar ones:***\nTemplate 1: Find max value of x such that f(x) is true\n```\ndef binarySearchForMinVal()\n    l, r = lower_bound, upper_bound\n    while l < r:\n        mid = (l + r)//2 #round down\n        if feasible(mid):\n            r = mid #check for possible smaller values that work\n        else:\n            l = mid + 1 #values smaller than or equal to mid do not work. Reduce search space to values greater than mid.\n    return l\n```\nTemplate 2: Find min value of x such that f(x) is true\n```\ndef binarySearchForMaxVal()\n    l, r = lower_bound, upper_bound\n    while l < r:\n        mid = (l + r + 1)//2 #round up\n        if feasible(mid):\n            l = mid #check for possible greater values that work\n        else:\n            r = mid - 1 #values greater than or equal to mid do not work. Reduce search space to values smaller than mid.\n    return l\n\n```"
                    },
                    {
                        "username": "rajat_171",
                        "content": "Sometimes it is good, sometimes it is shit. (\\u25CF\\'\\u25E1\\'\\u25CF)"
                    },
                    {
                        "username": "EnzoPay",
                        "content": "For me bisearch is not the best way, brings to many troubles... :("
                    }
                ]
            },
            {
                "id": 1851426,
                "content": [
                    {
                        "username": "AlecLC",
                        "content": "Which potion do I need to give the interviewer to hire me?"
                    },
                    {
                        "username": "santanusen",
                        "content": "```\\nvoid get_hired(vector<Company>& companies) {\\n    sort (companies.begin(), companies.end(), greater_preference());\\n    for (company : companies)\\n        if (interview(company) == hired)\\n            return;\\n\\n    get_hired(companies);\\n}\\n\\n```"
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "Potion of Butter \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Msey",
                        "content": "[@_Tan_A](/_Tan_A) You need to find a cat"
                    },
                    {
                        "username": "abhishek_2603",
                        "content": "[@Msey](/Msey)  what if I am a male."
                    },
                    {
                        "username": "nat1902",
                        "content": "[@Msey](/Msey) lol:)))))))))))))))"
                    },
                    {
                        "username": "Msey",
                        "content": "pussy juice"
                    },
                    {
                        "username": "Sudeepreddy537",
                        "content": "0(1) is it\\n"
                    },
                    {
                        "username": "pushprajsinghpawar7",
                        "content": ")1(O"
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "skill potion if u are not a female"
                    },
                    {
                        "username": "AMerrill",
                        "content": "[@gonestill](/gonestill) Paired with a disillusionment spell!"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "so if u go by NAIVE approach at 51th test case out of 56 u will get TLE"
                    },
                    {
                        "username": "hero080",
                        "content": "binary search is the *naive* approach here."
                    },
                    {
                        "username": "_srahul_",
                        "content": "The moment I see size as 10^5 in constraint, my mind automatically starts thinking of an approach that is `<= O(n*logn)  `.\\n\\nPerks of giving contests."
                    },
                    {
                        "username": "ibeastking",
                        "content": "[@amr_pk](/amr_pk)  So if the constraint was 10^4, then we could have used N^2 approach??"
                    },
                    {
                        "username": "amr_pk",
                        "content": "[@guptatanish145](/guptatanish145) 1 second ~= 10^8 operations. You should not exceed that. So you can write a solution that\\'s either N (10^5) or NlogN (10^6). That\\'s my mindset when I solve codeforces contests."
                    },
                    {
                        "username": "codeMonarch",
                        "content": "sumpott ++"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "how did you identify that ?"
                    },
                    {
                        "username": "pokaChika",
                        "content": "Reminds me of Severus Snape the Potions Master 😂 "
                    },
                    {
                        "username": "AMerrill",
                        "content": "This problem is a great follow up to yesterdays daily challenge. Let\\'s get the April streak going!\\n\\nThe question is: how can you implement a binary search in solving this problem? Try thinking about what variables you can change and how!"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Tip/Hint:- \n\n\nSort the potions array and then for each spell find the lower bound `idx `for\n\n `temp = (double) success/spell[i]`\n\nand push_back `length-idx` in the ans array."
                    },
                    {
                        "username": "chiragsanghvi18",
                        "content": "Doing the exact same thing but getting TLE not sure why."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@namandt](/namandt) yep exactly\\n"
                    },
                    {
                        "username": "Maang-io",
                        "content": "You can sort the array in descending order, and just push the index to result.\\nhttps://leetcode.com/problems/successful-pairs-of-spells-and-potions/solutions/3372013/interview-approach-journey-from-brute-force-to-better-brute-force-to-sorting-and-binary-search/"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@sarpalmadhav](/sarpalmadhav) Yeah, but I directly use the STL function lower_bound for this problem, there i needed to put a value to look for in the array,so I had only that option"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Shubham Raj](/Shubham_Raj22) In high precision problems, using double and dividing large numbers can be a risky bet. `spell[i]*potion[j] >= success` would be a better check"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@namandt](/namandt) It is that simple, lower bound means that in the sorted array we get the first occuring instance.. hence all other potions will be covered"
                    },
                    {
                        "username": "namandt",
                        "content": "Its not that simple.\\nNeed to handle duplicates in the potions"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "I guess Binary Search days are coming "
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "[@marwanmusa](/marwanmusa) my bad I\\'ve been training to look for hints and patterns from just the problem description and examples, not the optional hints some problems have haha"
                    },
                    {
                        "username": "marwanmusa",
                        "content": "[@disturbedbrown1](/disturbedbrown1) its in hint-3/3"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "the problem didnt give away any bs pattern/ hint though"
                    },
                    {
                        "username": "mickodjordjevic98",
                        "content": "Hints point to using binary search, but the best solution uses something similar to prefix sum which gives O(n) time instead of O(nlogn). Maybe this question need to have its conditions changed to make binary search most efficient option (since that is the point of the question I guess, to practice bs), maximum value of potions and spells should be big enough so that an array size of maxPotion or maxSpell exceeds memory capacity."
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "[@ashedcorpse](/ashedcorpse) A better problem to practice on is https://leetcode.com/problems/search-a-2d-matrix-ii/, as there are a few extra wrinkles in directly applying it to this problem that cloud the elegance of the strategy."
                    },
                    {
                        "username": "AlecLC",
                        "content": "[@ashedcorpse](/ashedcorpse) 2 pointer"
                    },
                    {
                        "username": "cswartzell",
                        "content": "I actually rather love that its NOT a binary search question, and may mislead people into thinking it is one. Its a good lesson to consider other, possibly simpler solutions. There are plenty of Binary Search questions on LC, we dont need to modify this to be a straight binary search. Its better as is to show why the tricky answer might actually be worse than the simple answer. "
                    },
                    {
                        "username": "ashedcorpse",
                        "content": "can you please share the approach of O(n)"
                    },
                    {
                        "username": "CodingMonkey101",
                        "content": "`Tip`\n***Just wanted to share my two favorite binary search templates to help with this problem as well as any similar ones:***\nTemplate 1: Find max value of x such that f(x) is true\n```\ndef binarySearchForMinVal()\n    l, r = lower_bound, upper_bound\n    while l < r:\n        mid = (l + r)//2 #round down\n        if feasible(mid):\n            r = mid #check for possible smaller values that work\n        else:\n            l = mid + 1 #values smaller than or equal to mid do not work. Reduce search space to values greater than mid.\n    return l\n```\nTemplate 2: Find min value of x such that f(x) is true\n```\ndef binarySearchForMaxVal()\n    l, r = lower_bound, upper_bound\n    while l < r:\n        mid = (l + r + 1)//2 #round up\n        if feasible(mid):\n            l = mid #check for possible greater values that work\n        else:\n            r = mid - 1 #values greater than or equal to mid do not work. Reduce search space to values smaller than mid.\n    return l\n\n```"
                    },
                    {
                        "username": "rajat_171",
                        "content": "Sometimes it is good, sometimes it is shit. (\\u25CF\\'\\u25E1\\'\\u25CF)"
                    },
                    {
                        "username": "EnzoPay",
                        "content": "For me bisearch is not the best way, brings to many troubles... :("
                    }
                ]
            },
            {
                "id": 1850766,
                "content": [
                    {
                        "username": "AlecLC",
                        "content": "Which potion do I need to give the interviewer to hire me?"
                    },
                    {
                        "username": "santanusen",
                        "content": "```\\nvoid get_hired(vector<Company>& companies) {\\n    sort (companies.begin(), companies.end(), greater_preference());\\n    for (company : companies)\\n        if (interview(company) == hired)\\n            return;\\n\\n    get_hired(companies);\\n}\\n\\n```"
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "Potion of Butter \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Msey",
                        "content": "[@_Tan_A](/_Tan_A) You need to find a cat"
                    },
                    {
                        "username": "abhishek_2603",
                        "content": "[@Msey](/Msey)  what if I am a male."
                    },
                    {
                        "username": "nat1902",
                        "content": "[@Msey](/Msey) lol:)))))))))))))))"
                    },
                    {
                        "username": "Msey",
                        "content": "pussy juice"
                    },
                    {
                        "username": "Sudeepreddy537",
                        "content": "0(1) is it\\n"
                    },
                    {
                        "username": "pushprajsinghpawar7",
                        "content": ")1(O"
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "skill potion if u are not a female"
                    },
                    {
                        "username": "AMerrill",
                        "content": "[@gonestill](/gonestill) Paired with a disillusionment spell!"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "so if u go by NAIVE approach at 51th test case out of 56 u will get TLE"
                    },
                    {
                        "username": "hero080",
                        "content": "binary search is the *naive* approach here."
                    },
                    {
                        "username": "_srahul_",
                        "content": "The moment I see size as 10^5 in constraint, my mind automatically starts thinking of an approach that is `<= O(n*logn)  `.\\n\\nPerks of giving contests."
                    },
                    {
                        "username": "ibeastking",
                        "content": "[@amr_pk](/amr_pk)  So if the constraint was 10^4, then we could have used N^2 approach??"
                    },
                    {
                        "username": "amr_pk",
                        "content": "[@guptatanish145](/guptatanish145) 1 second ~= 10^8 operations. You should not exceed that. So you can write a solution that\\'s either N (10^5) or NlogN (10^6). That\\'s my mindset when I solve codeforces contests."
                    },
                    {
                        "username": "codeMonarch",
                        "content": "sumpott ++"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "how did you identify that ?"
                    },
                    {
                        "username": "pokaChika",
                        "content": "Reminds me of Severus Snape the Potions Master 😂 "
                    },
                    {
                        "username": "AMerrill",
                        "content": "This problem is a great follow up to yesterdays daily challenge. Let\\'s get the April streak going!\\n\\nThe question is: how can you implement a binary search in solving this problem? Try thinking about what variables you can change and how!"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Tip/Hint:- \n\n\nSort the potions array and then for each spell find the lower bound `idx `for\n\n `temp = (double) success/spell[i]`\n\nand push_back `length-idx` in the ans array."
                    },
                    {
                        "username": "chiragsanghvi18",
                        "content": "Doing the exact same thing but getting TLE not sure why."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@namandt](/namandt) yep exactly\\n"
                    },
                    {
                        "username": "Maang-io",
                        "content": "You can sort the array in descending order, and just push the index to result.\\nhttps://leetcode.com/problems/successful-pairs-of-spells-and-potions/solutions/3372013/interview-approach-journey-from-brute-force-to-better-brute-force-to-sorting-and-binary-search/"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@sarpalmadhav](/sarpalmadhav) Yeah, but I directly use the STL function lower_bound for this problem, there i needed to put a value to look for in the array,so I had only that option"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Shubham Raj](/Shubham_Raj22) In high precision problems, using double and dividing large numbers can be a risky bet. `spell[i]*potion[j] >= success` would be a better check"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@namandt](/namandt) It is that simple, lower bound means that in the sorted array we get the first occuring instance.. hence all other potions will be covered"
                    },
                    {
                        "username": "namandt",
                        "content": "Its not that simple.\\nNeed to handle duplicates in the potions"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "I guess Binary Search days are coming "
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "[@marwanmusa](/marwanmusa) my bad I\\'ve been training to look for hints and patterns from just the problem description and examples, not the optional hints some problems have haha"
                    },
                    {
                        "username": "marwanmusa",
                        "content": "[@disturbedbrown1](/disturbedbrown1) its in hint-3/3"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "the problem didnt give away any bs pattern/ hint though"
                    },
                    {
                        "username": "mickodjordjevic98",
                        "content": "Hints point to using binary search, but the best solution uses something similar to prefix sum which gives O(n) time instead of O(nlogn). Maybe this question need to have its conditions changed to make binary search most efficient option (since that is the point of the question I guess, to practice bs), maximum value of potions and spells should be big enough so that an array size of maxPotion or maxSpell exceeds memory capacity."
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "[@ashedcorpse](/ashedcorpse) A better problem to practice on is https://leetcode.com/problems/search-a-2d-matrix-ii/, as there are a few extra wrinkles in directly applying it to this problem that cloud the elegance of the strategy."
                    },
                    {
                        "username": "AlecLC",
                        "content": "[@ashedcorpse](/ashedcorpse) 2 pointer"
                    },
                    {
                        "username": "cswartzell",
                        "content": "I actually rather love that its NOT a binary search question, and may mislead people into thinking it is one. Its a good lesson to consider other, possibly simpler solutions. There are plenty of Binary Search questions on LC, we dont need to modify this to be a straight binary search. Its better as is to show why the tricky answer might actually be worse than the simple answer. "
                    },
                    {
                        "username": "ashedcorpse",
                        "content": "can you please share the approach of O(n)"
                    },
                    {
                        "username": "CodingMonkey101",
                        "content": "`Tip`\n***Just wanted to share my two favorite binary search templates to help with this problem as well as any similar ones:***\nTemplate 1: Find max value of x such that f(x) is true\n```\ndef binarySearchForMinVal()\n    l, r = lower_bound, upper_bound\n    while l < r:\n        mid = (l + r)//2 #round down\n        if feasible(mid):\n            r = mid #check for possible smaller values that work\n        else:\n            l = mid + 1 #values smaller than or equal to mid do not work. Reduce search space to values greater than mid.\n    return l\n```\nTemplate 2: Find min value of x such that f(x) is true\n```\ndef binarySearchForMaxVal()\n    l, r = lower_bound, upper_bound\n    while l < r:\n        mid = (l + r + 1)//2 #round up\n        if feasible(mid):\n            l = mid #check for possible greater values that work\n        else:\n            r = mid - 1 #values greater than or equal to mid do not work. Reduce search space to values smaller than mid.\n    return l\n\n```"
                    },
                    {
                        "username": "rajat_171",
                        "content": "Sometimes it is good, sometimes it is shit. (\\u25CF\\'\\u25E1\\'\\u25CF)"
                    },
                    {
                        "username": "EnzoPay",
                        "content": "For me bisearch is not the best way, brings to many troubles... :("
                    }
                ]
            },
            {
                "id": 1850841,
                "content": [
                    {
                        "username": "AlecLC",
                        "content": "Which potion do I need to give the interviewer to hire me?"
                    },
                    {
                        "username": "santanusen",
                        "content": "```\\nvoid get_hired(vector<Company>& companies) {\\n    sort (companies.begin(), companies.end(), greater_preference());\\n    for (company : companies)\\n        if (interview(company) == hired)\\n            return;\\n\\n    get_hired(companies);\\n}\\n\\n```"
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "Potion of Butter \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Msey",
                        "content": "[@_Tan_A](/_Tan_A) You need to find a cat"
                    },
                    {
                        "username": "abhishek_2603",
                        "content": "[@Msey](/Msey)  what if I am a male."
                    },
                    {
                        "username": "nat1902",
                        "content": "[@Msey](/Msey) lol:)))))))))))))))"
                    },
                    {
                        "username": "Msey",
                        "content": "pussy juice"
                    },
                    {
                        "username": "Sudeepreddy537",
                        "content": "0(1) is it\\n"
                    },
                    {
                        "username": "pushprajsinghpawar7",
                        "content": ")1(O"
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "skill potion if u are not a female"
                    },
                    {
                        "username": "AMerrill",
                        "content": "[@gonestill](/gonestill) Paired with a disillusionment spell!"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "so if u go by NAIVE approach at 51th test case out of 56 u will get TLE"
                    },
                    {
                        "username": "hero080",
                        "content": "binary search is the *naive* approach here."
                    },
                    {
                        "username": "_srahul_",
                        "content": "The moment I see size as 10^5 in constraint, my mind automatically starts thinking of an approach that is `<= O(n*logn)  `.\\n\\nPerks of giving contests."
                    },
                    {
                        "username": "ibeastking",
                        "content": "[@amr_pk](/amr_pk)  So if the constraint was 10^4, then we could have used N^2 approach??"
                    },
                    {
                        "username": "amr_pk",
                        "content": "[@guptatanish145](/guptatanish145) 1 second ~= 10^8 operations. You should not exceed that. So you can write a solution that\\'s either N (10^5) or NlogN (10^6). That\\'s my mindset when I solve codeforces contests."
                    },
                    {
                        "username": "codeMonarch",
                        "content": "sumpott ++"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "how did you identify that ?"
                    },
                    {
                        "username": "pokaChika",
                        "content": "Reminds me of Severus Snape the Potions Master 😂 "
                    },
                    {
                        "username": "AMerrill",
                        "content": "This problem is a great follow up to yesterdays daily challenge. Let\\'s get the April streak going!\\n\\nThe question is: how can you implement a binary search in solving this problem? Try thinking about what variables you can change and how!"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Tip/Hint:- \n\n\nSort the potions array and then for each spell find the lower bound `idx `for\n\n `temp = (double) success/spell[i]`\n\nand push_back `length-idx` in the ans array."
                    },
                    {
                        "username": "chiragsanghvi18",
                        "content": "Doing the exact same thing but getting TLE not sure why."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@namandt](/namandt) yep exactly\\n"
                    },
                    {
                        "username": "Maang-io",
                        "content": "You can sort the array in descending order, and just push the index to result.\\nhttps://leetcode.com/problems/successful-pairs-of-spells-and-potions/solutions/3372013/interview-approach-journey-from-brute-force-to-better-brute-force-to-sorting-and-binary-search/"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@sarpalmadhav](/sarpalmadhav) Yeah, but I directly use the STL function lower_bound for this problem, there i needed to put a value to look for in the array,so I had only that option"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Shubham Raj](/Shubham_Raj22) In high precision problems, using double and dividing large numbers can be a risky bet. `spell[i]*potion[j] >= success` would be a better check"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@namandt](/namandt) It is that simple, lower bound means that in the sorted array we get the first occuring instance.. hence all other potions will be covered"
                    },
                    {
                        "username": "namandt",
                        "content": "Its not that simple.\\nNeed to handle duplicates in the potions"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "I guess Binary Search days are coming "
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "[@marwanmusa](/marwanmusa) my bad I\\'ve been training to look for hints and patterns from just the problem description and examples, not the optional hints some problems have haha"
                    },
                    {
                        "username": "marwanmusa",
                        "content": "[@disturbedbrown1](/disturbedbrown1) its in hint-3/3"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "the problem didnt give away any bs pattern/ hint though"
                    },
                    {
                        "username": "mickodjordjevic98",
                        "content": "Hints point to using binary search, but the best solution uses something similar to prefix sum which gives O(n) time instead of O(nlogn). Maybe this question need to have its conditions changed to make binary search most efficient option (since that is the point of the question I guess, to practice bs), maximum value of potions and spells should be big enough so that an array size of maxPotion or maxSpell exceeds memory capacity."
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "[@ashedcorpse](/ashedcorpse) A better problem to practice on is https://leetcode.com/problems/search-a-2d-matrix-ii/, as there are a few extra wrinkles in directly applying it to this problem that cloud the elegance of the strategy."
                    },
                    {
                        "username": "AlecLC",
                        "content": "[@ashedcorpse](/ashedcorpse) 2 pointer"
                    },
                    {
                        "username": "cswartzell",
                        "content": "I actually rather love that its NOT a binary search question, and may mislead people into thinking it is one. Its a good lesson to consider other, possibly simpler solutions. There are plenty of Binary Search questions on LC, we dont need to modify this to be a straight binary search. Its better as is to show why the tricky answer might actually be worse than the simple answer. "
                    },
                    {
                        "username": "ashedcorpse",
                        "content": "can you please share the approach of O(n)"
                    },
                    {
                        "username": "CodingMonkey101",
                        "content": "`Tip`\n***Just wanted to share my two favorite binary search templates to help with this problem as well as any similar ones:***\nTemplate 1: Find max value of x such that f(x) is true\n```\ndef binarySearchForMinVal()\n    l, r = lower_bound, upper_bound\n    while l < r:\n        mid = (l + r)//2 #round down\n        if feasible(mid):\n            r = mid #check for possible smaller values that work\n        else:\n            l = mid + 1 #values smaller than or equal to mid do not work. Reduce search space to values greater than mid.\n    return l\n```\nTemplate 2: Find min value of x such that f(x) is true\n```\ndef binarySearchForMaxVal()\n    l, r = lower_bound, upper_bound\n    while l < r:\n        mid = (l + r + 1)//2 #round up\n        if feasible(mid):\n            l = mid #check for possible greater values that work\n        else:\n            r = mid - 1 #values greater than or equal to mid do not work. Reduce search space to values smaller than mid.\n    return l\n\n```"
                    },
                    {
                        "username": "rajat_171",
                        "content": "Sometimes it is good, sometimes it is shit. (\\u25CF\\'\\u25E1\\'\\u25CF)"
                    },
                    {
                        "username": "EnzoPay",
                        "content": "For me bisearch is not the best way, brings to many troubles... :("
                    }
                ]
            },
            {
                "id": 1851177,
                "content": [
                    {
                        "username": "AlecLC",
                        "content": "Which potion do I need to give the interviewer to hire me?"
                    },
                    {
                        "username": "santanusen",
                        "content": "```\\nvoid get_hired(vector<Company>& companies) {\\n    sort (companies.begin(), companies.end(), greater_preference());\\n    for (company : companies)\\n        if (interview(company) == hired)\\n            return;\\n\\n    get_hired(companies);\\n}\\n\\n```"
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "Potion of Butter \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Msey",
                        "content": "[@_Tan_A](/_Tan_A) You need to find a cat"
                    },
                    {
                        "username": "abhishek_2603",
                        "content": "[@Msey](/Msey)  what if I am a male."
                    },
                    {
                        "username": "nat1902",
                        "content": "[@Msey](/Msey) lol:)))))))))))))))"
                    },
                    {
                        "username": "Msey",
                        "content": "pussy juice"
                    },
                    {
                        "username": "Sudeepreddy537",
                        "content": "0(1) is it\\n"
                    },
                    {
                        "username": "pushprajsinghpawar7",
                        "content": ")1(O"
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "skill potion if u are not a female"
                    },
                    {
                        "username": "AMerrill",
                        "content": "[@gonestill](/gonestill) Paired with a disillusionment spell!"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "so if u go by NAIVE approach at 51th test case out of 56 u will get TLE"
                    },
                    {
                        "username": "hero080",
                        "content": "binary search is the *naive* approach here."
                    },
                    {
                        "username": "_srahul_",
                        "content": "The moment I see size as 10^5 in constraint, my mind automatically starts thinking of an approach that is `<= O(n*logn)  `.\\n\\nPerks of giving contests."
                    },
                    {
                        "username": "ibeastking",
                        "content": "[@amr_pk](/amr_pk)  So if the constraint was 10^4, then we could have used N^2 approach??"
                    },
                    {
                        "username": "amr_pk",
                        "content": "[@guptatanish145](/guptatanish145) 1 second ~= 10^8 operations. You should not exceed that. So you can write a solution that\\'s either N (10^5) or NlogN (10^6). That\\'s my mindset when I solve codeforces contests."
                    },
                    {
                        "username": "codeMonarch",
                        "content": "sumpott ++"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "how did you identify that ?"
                    },
                    {
                        "username": "pokaChika",
                        "content": "Reminds me of Severus Snape the Potions Master 😂 "
                    },
                    {
                        "username": "AMerrill",
                        "content": "This problem is a great follow up to yesterdays daily challenge. Let\\'s get the April streak going!\\n\\nThe question is: how can you implement a binary search in solving this problem? Try thinking about what variables you can change and how!"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Tip/Hint:- \n\n\nSort the potions array and then for each spell find the lower bound `idx `for\n\n `temp = (double) success/spell[i]`\n\nand push_back `length-idx` in the ans array."
                    },
                    {
                        "username": "chiragsanghvi18",
                        "content": "Doing the exact same thing but getting TLE not sure why."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@namandt](/namandt) yep exactly\\n"
                    },
                    {
                        "username": "Maang-io",
                        "content": "You can sort the array in descending order, and just push the index to result.\\nhttps://leetcode.com/problems/successful-pairs-of-spells-and-potions/solutions/3372013/interview-approach-journey-from-brute-force-to-better-brute-force-to-sorting-and-binary-search/"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@sarpalmadhav](/sarpalmadhav) Yeah, but I directly use the STL function lower_bound for this problem, there i needed to put a value to look for in the array,so I had only that option"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Shubham Raj](/Shubham_Raj22) In high precision problems, using double and dividing large numbers can be a risky bet. `spell[i]*potion[j] >= success` would be a better check"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@namandt](/namandt) It is that simple, lower bound means that in the sorted array we get the first occuring instance.. hence all other potions will be covered"
                    },
                    {
                        "username": "namandt",
                        "content": "Its not that simple.\\nNeed to handle duplicates in the potions"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "I guess Binary Search days are coming "
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "[@marwanmusa](/marwanmusa) my bad I\\'ve been training to look for hints and patterns from just the problem description and examples, not the optional hints some problems have haha"
                    },
                    {
                        "username": "marwanmusa",
                        "content": "[@disturbedbrown1](/disturbedbrown1) its in hint-3/3"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "the problem didnt give away any bs pattern/ hint though"
                    },
                    {
                        "username": "mickodjordjevic98",
                        "content": "Hints point to using binary search, but the best solution uses something similar to prefix sum which gives O(n) time instead of O(nlogn). Maybe this question need to have its conditions changed to make binary search most efficient option (since that is the point of the question I guess, to practice bs), maximum value of potions and spells should be big enough so that an array size of maxPotion or maxSpell exceeds memory capacity."
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "[@ashedcorpse](/ashedcorpse) A better problem to practice on is https://leetcode.com/problems/search-a-2d-matrix-ii/, as there are a few extra wrinkles in directly applying it to this problem that cloud the elegance of the strategy."
                    },
                    {
                        "username": "AlecLC",
                        "content": "[@ashedcorpse](/ashedcorpse) 2 pointer"
                    },
                    {
                        "username": "cswartzell",
                        "content": "I actually rather love that its NOT a binary search question, and may mislead people into thinking it is one. Its a good lesson to consider other, possibly simpler solutions. There are plenty of Binary Search questions on LC, we dont need to modify this to be a straight binary search. Its better as is to show why the tricky answer might actually be worse than the simple answer. "
                    },
                    {
                        "username": "ashedcorpse",
                        "content": "can you please share the approach of O(n)"
                    },
                    {
                        "username": "CodingMonkey101",
                        "content": "`Tip`\n***Just wanted to share my two favorite binary search templates to help with this problem as well as any similar ones:***\nTemplate 1: Find max value of x such that f(x) is true\n```\ndef binarySearchForMinVal()\n    l, r = lower_bound, upper_bound\n    while l < r:\n        mid = (l + r)//2 #round down\n        if feasible(mid):\n            r = mid #check for possible smaller values that work\n        else:\n            l = mid + 1 #values smaller than or equal to mid do not work. Reduce search space to values greater than mid.\n    return l\n```\nTemplate 2: Find min value of x such that f(x) is true\n```\ndef binarySearchForMaxVal()\n    l, r = lower_bound, upper_bound\n    while l < r:\n        mid = (l + r + 1)//2 #round up\n        if feasible(mid):\n            l = mid #check for possible greater values that work\n        else:\n            r = mid - 1 #values greater than or equal to mid do not work. Reduce search space to values smaller than mid.\n    return l\n\n```"
                    },
                    {
                        "username": "rajat_171",
                        "content": "Sometimes it is good, sometimes it is shit. (\\u25CF\\'\\u25E1\\'\\u25CF)"
                    },
                    {
                        "username": "EnzoPay",
                        "content": "For me bisearch is not the best way, brings to many troubles... :("
                    }
                ]
            },
            {
                "id": 1850860,
                "content": [
                    {
                        "username": "AlecLC",
                        "content": "Which potion do I need to give the interviewer to hire me?"
                    },
                    {
                        "username": "santanusen",
                        "content": "```\\nvoid get_hired(vector<Company>& companies) {\\n    sort (companies.begin(), companies.end(), greater_preference());\\n    for (company : companies)\\n        if (interview(company) == hired)\\n            return;\\n\\n    get_hired(companies);\\n}\\n\\n```"
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "Potion of Butter \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Msey",
                        "content": "[@_Tan_A](/_Tan_A) You need to find a cat"
                    },
                    {
                        "username": "abhishek_2603",
                        "content": "[@Msey](/Msey)  what if I am a male."
                    },
                    {
                        "username": "nat1902",
                        "content": "[@Msey](/Msey) lol:)))))))))))))))"
                    },
                    {
                        "username": "Msey",
                        "content": "pussy juice"
                    },
                    {
                        "username": "Sudeepreddy537",
                        "content": "0(1) is it\\n"
                    },
                    {
                        "username": "pushprajsinghpawar7",
                        "content": ")1(O"
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "skill potion if u are not a female"
                    },
                    {
                        "username": "AMerrill",
                        "content": "[@gonestill](/gonestill) Paired with a disillusionment spell!"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "so if u go by NAIVE approach at 51th test case out of 56 u will get TLE"
                    },
                    {
                        "username": "hero080",
                        "content": "binary search is the *naive* approach here."
                    },
                    {
                        "username": "_srahul_",
                        "content": "The moment I see size as 10^5 in constraint, my mind automatically starts thinking of an approach that is `<= O(n*logn)  `.\\n\\nPerks of giving contests."
                    },
                    {
                        "username": "ibeastking",
                        "content": "[@amr_pk](/amr_pk)  So if the constraint was 10^4, then we could have used N^2 approach??"
                    },
                    {
                        "username": "amr_pk",
                        "content": "[@guptatanish145](/guptatanish145) 1 second ~= 10^8 operations. You should not exceed that. So you can write a solution that\\'s either N (10^5) or NlogN (10^6). That\\'s my mindset when I solve codeforces contests."
                    },
                    {
                        "username": "codeMonarch",
                        "content": "sumpott ++"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "how did you identify that ?"
                    },
                    {
                        "username": "pokaChika",
                        "content": "Reminds me of Severus Snape the Potions Master 😂 "
                    },
                    {
                        "username": "AMerrill",
                        "content": "This problem is a great follow up to yesterdays daily challenge. Let\\'s get the April streak going!\\n\\nThe question is: how can you implement a binary search in solving this problem? Try thinking about what variables you can change and how!"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Tip/Hint:- \n\n\nSort the potions array and then for each spell find the lower bound `idx `for\n\n `temp = (double) success/spell[i]`\n\nand push_back `length-idx` in the ans array."
                    },
                    {
                        "username": "chiragsanghvi18",
                        "content": "Doing the exact same thing but getting TLE not sure why."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@namandt](/namandt) yep exactly\\n"
                    },
                    {
                        "username": "Maang-io",
                        "content": "You can sort the array in descending order, and just push the index to result.\\nhttps://leetcode.com/problems/successful-pairs-of-spells-and-potions/solutions/3372013/interview-approach-journey-from-brute-force-to-better-brute-force-to-sorting-and-binary-search/"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@sarpalmadhav](/sarpalmadhav) Yeah, but I directly use the STL function lower_bound for this problem, there i needed to put a value to look for in the array,so I had only that option"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Shubham Raj](/Shubham_Raj22) In high precision problems, using double and dividing large numbers can be a risky bet. `spell[i]*potion[j] >= success` would be a better check"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@namandt](/namandt) It is that simple, lower bound means that in the sorted array we get the first occuring instance.. hence all other potions will be covered"
                    },
                    {
                        "username": "namandt",
                        "content": "Its not that simple.\\nNeed to handle duplicates in the potions"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "I guess Binary Search days are coming "
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "[@marwanmusa](/marwanmusa) my bad I\\'ve been training to look for hints and patterns from just the problem description and examples, not the optional hints some problems have haha"
                    },
                    {
                        "username": "marwanmusa",
                        "content": "[@disturbedbrown1](/disturbedbrown1) its in hint-3/3"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "the problem didnt give away any bs pattern/ hint though"
                    },
                    {
                        "username": "mickodjordjevic98",
                        "content": "Hints point to using binary search, but the best solution uses something similar to prefix sum which gives O(n) time instead of O(nlogn). Maybe this question need to have its conditions changed to make binary search most efficient option (since that is the point of the question I guess, to practice bs), maximum value of potions and spells should be big enough so that an array size of maxPotion or maxSpell exceeds memory capacity."
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "[@ashedcorpse](/ashedcorpse) A better problem to practice on is https://leetcode.com/problems/search-a-2d-matrix-ii/, as there are a few extra wrinkles in directly applying it to this problem that cloud the elegance of the strategy."
                    },
                    {
                        "username": "AlecLC",
                        "content": "[@ashedcorpse](/ashedcorpse) 2 pointer"
                    },
                    {
                        "username": "cswartzell",
                        "content": "I actually rather love that its NOT a binary search question, and may mislead people into thinking it is one. Its a good lesson to consider other, possibly simpler solutions. There are plenty of Binary Search questions on LC, we dont need to modify this to be a straight binary search. Its better as is to show why the tricky answer might actually be worse than the simple answer. "
                    },
                    {
                        "username": "ashedcorpse",
                        "content": "can you please share the approach of O(n)"
                    },
                    {
                        "username": "CodingMonkey101",
                        "content": "`Tip`\n***Just wanted to share my two favorite binary search templates to help with this problem as well as any similar ones:***\nTemplate 1: Find max value of x such that f(x) is true\n```\ndef binarySearchForMinVal()\n    l, r = lower_bound, upper_bound\n    while l < r:\n        mid = (l + r)//2 #round down\n        if feasible(mid):\n            r = mid #check for possible smaller values that work\n        else:\n            l = mid + 1 #values smaller than or equal to mid do not work. Reduce search space to values greater than mid.\n    return l\n```\nTemplate 2: Find min value of x such that f(x) is true\n```\ndef binarySearchForMaxVal()\n    l, r = lower_bound, upper_bound\n    while l < r:\n        mid = (l + r + 1)//2 #round up\n        if feasible(mid):\n            l = mid #check for possible greater values that work\n        else:\n            r = mid - 1 #values greater than or equal to mid do not work. Reduce search space to values smaller than mid.\n    return l\n\n```"
                    },
                    {
                        "username": "rajat_171",
                        "content": "Sometimes it is good, sometimes it is shit. (\\u25CF\\'\\u25E1\\'\\u25CF)"
                    },
                    {
                        "username": "EnzoPay",
                        "content": "For me bisearch is not the best way, brings to many troubles... :("
                    }
                ]
            },
            {
                "id": 1850810,
                "content": [
                    {
                        "username": "AlecLC",
                        "content": "Which potion do I need to give the interviewer to hire me?"
                    },
                    {
                        "username": "santanusen",
                        "content": "```\\nvoid get_hired(vector<Company>& companies) {\\n    sort (companies.begin(), companies.end(), greater_preference());\\n    for (company : companies)\\n        if (interview(company) == hired)\\n            return;\\n\\n    get_hired(companies);\\n}\\n\\n```"
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "Potion of Butter \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Msey",
                        "content": "[@_Tan_A](/_Tan_A) You need to find a cat"
                    },
                    {
                        "username": "abhishek_2603",
                        "content": "[@Msey](/Msey)  what if I am a male."
                    },
                    {
                        "username": "nat1902",
                        "content": "[@Msey](/Msey) lol:)))))))))))))))"
                    },
                    {
                        "username": "Msey",
                        "content": "pussy juice"
                    },
                    {
                        "username": "Sudeepreddy537",
                        "content": "0(1) is it\\n"
                    },
                    {
                        "username": "pushprajsinghpawar7",
                        "content": ")1(O"
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "skill potion if u are not a female"
                    },
                    {
                        "username": "AMerrill",
                        "content": "[@gonestill](/gonestill) Paired with a disillusionment spell!"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "so if u go by NAIVE approach at 51th test case out of 56 u will get TLE"
                    },
                    {
                        "username": "hero080",
                        "content": "binary search is the *naive* approach here."
                    },
                    {
                        "username": "_srahul_",
                        "content": "The moment I see size as 10^5 in constraint, my mind automatically starts thinking of an approach that is `<= O(n*logn)  `.\\n\\nPerks of giving contests."
                    },
                    {
                        "username": "ibeastking",
                        "content": "[@amr_pk](/amr_pk)  So if the constraint was 10^4, then we could have used N^2 approach??"
                    },
                    {
                        "username": "amr_pk",
                        "content": "[@guptatanish145](/guptatanish145) 1 second ~= 10^8 operations. You should not exceed that. So you can write a solution that\\'s either N (10^5) or NlogN (10^6). That\\'s my mindset when I solve codeforces contests."
                    },
                    {
                        "username": "codeMonarch",
                        "content": "sumpott ++"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "how did you identify that ?"
                    },
                    {
                        "username": "pokaChika",
                        "content": "Reminds me of Severus Snape the Potions Master 😂 "
                    },
                    {
                        "username": "AMerrill",
                        "content": "This problem is a great follow up to yesterdays daily challenge. Let\\'s get the April streak going!\\n\\nThe question is: how can you implement a binary search in solving this problem? Try thinking about what variables you can change and how!"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Tip/Hint:- \n\n\nSort the potions array and then for each spell find the lower bound `idx `for\n\n `temp = (double) success/spell[i]`\n\nand push_back `length-idx` in the ans array."
                    },
                    {
                        "username": "chiragsanghvi18",
                        "content": "Doing the exact same thing but getting TLE not sure why."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@namandt](/namandt) yep exactly\\n"
                    },
                    {
                        "username": "Maang-io",
                        "content": "You can sort the array in descending order, and just push the index to result.\\nhttps://leetcode.com/problems/successful-pairs-of-spells-and-potions/solutions/3372013/interview-approach-journey-from-brute-force-to-better-brute-force-to-sorting-and-binary-search/"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@sarpalmadhav](/sarpalmadhav) Yeah, but I directly use the STL function lower_bound for this problem, there i needed to put a value to look for in the array,so I had only that option"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Shubham Raj](/Shubham_Raj22) In high precision problems, using double and dividing large numbers can be a risky bet. `spell[i]*potion[j] >= success` would be a better check"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@namandt](/namandt) It is that simple, lower bound means that in the sorted array we get the first occuring instance.. hence all other potions will be covered"
                    },
                    {
                        "username": "namandt",
                        "content": "Its not that simple.\\nNeed to handle duplicates in the potions"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "I guess Binary Search days are coming "
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "[@marwanmusa](/marwanmusa) my bad I\\'ve been training to look for hints and patterns from just the problem description and examples, not the optional hints some problems have haha"
                    },
                    {
                        "username": "marwanmusa",
                        "content": "[@disturbedbrown1](/disturbedbrown1) its in hint-3/3"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "the problem didnt give away any bs pattern/ hint though"
                    },
                    {
                        "username": "mickodjordjevic98",
                        "content": "Hints point to using binary search, but the best solution uses something similar to prefix sum which gives O(n) time instead of O(nlogn). Maybe this question need to have its conditions changed to make binary search most efficient option (since that is the point of the question I guess, to practice bs), maximum value of potions and spells should be big enough so that an array size of maxPotion or maxSpell exceeds memory capacity."
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "[@ashedcorpse](/ashedcorpse) A better problem to practice on is https://leetcode.com/problems/search-a-2d-matrix-ii/, as there are a few extra wrinkles in directly applying it to this problem that cloud the elegance of the strategy."
                    },
                    {
                        "username": "AlecLC",
                        "content": "[@ashedcorpse](/ashedcorpse) 2 pointer"
                    },
                    {
                        "username": "cswartzell",
                        "content": "I actually rather love that its NOT a binary search question, and may mislead people into thinking it is one. Its a good lesson to consider other, possibly simpler solutions. There are plenty of Binary Search questions on LC, we dont need to modify this to be a straight binary search. Its better as is to show why the tricky answer might actually be worse than the simple answer. "
                    },
                    {
                        "username": "ashedcorpse",
                        "content": "can you please share the approach of O(n)"
                    },
                    {
                        "username": "CodingMonkey101",
                        "content": "`Tip`\n***Just wanted to share my two favorite binary search templates to help with this problem as well as any similar ones:***\nTemplate 1: Find max value of x such that f(x) is true\n```\ndef binarySearchForMinVal()\n    l, r = lower_bound, upper_bound\n    while l < r:\n        mid = (l + r)//2 #round down\n        if feasible(mid):\n            r = mid #check for possible smaller values that work\n        else:\n            l = mid + 1 #values smaller than or equal to mid do not work. Reduce search space to values greater than mid.\n    return l\n```\nTemplate 2: Find min value of x such that f(x) is true\n```\ndef binarySearchForMaxVal()\n    l, r = lower_bound, upper_bound\n    while l < r:\n        mid = (l + r + 1)//2 #round up\n        if feasible(mid):\n            l = mid #check for possible greater values that work\n        else:\n            r = mid - 1 #values greater than or equal to mid do not work. Reduce search space to values smaller than mid.\n    return l\n\n```"
                    },
                    {
                        "username": "rajat_171",
                        "content": "Sometimes it is good, sometimes it is shit. (\\u25CF\\'\\u25E1\\'\\u25CF)"
                    },
                    {
                        "username": "EnzoPay",
                        "content": "For me bisearch is not the best way, brings to many troubles... :("
                    }
                ]
            },
            {
                "id": 1851027,
                "content": [
                    {
                        "username": "AlecLC",
                        "content": "Which potion do I need to give the interviewer to hire me?"
                    },
                    {
                        "username": "santanusen",
                        "content": "```\\nvoid get_hired(vector<Company>& companies) {\\n    sort (companies.begin(), companies.end(), greater_preference());\\n    for (company : companies)\\n        if (interview(company) == hired)\\n            return;\\n\\n    get_hired(companies);\\n}\\n\\n```"
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "Potion of Butter \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Msey",
                        "content": "[@_Tan_A](/_Tan_A) You need to find a cat"
                    },
                    {
                        "username": "abhishek_2603",
                        "content": "[@Msey](/Msey)  what if I am a male."
                    },
                    {
                        "username": "nat1902",
                        "content": "[@Msey](/Msey) lol:)))))))))))))))"
                    },
                    {
                        "username": "Msey",
                        "content": "pussy juice"
                    },
                    {
                        "username": "Sudeepreddy537",
                        "content": "0(1) is it\\n"
                    },
                    {
                        "username": "pushprajsinghpawar7",
                        "content": ")1(O"
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "skill potion if u are not a female"
                    },
                    {
                        "username": "AMerrill",
                        "content": "[@gonestill](/gonestill) Paired with a disillusionment spell!"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "so if u go by NAIVE approach at 51th test case out of 56 u will get TLE"
                    },
                    {
                        "username": "hero080",
                        "content": "binary search is the *naive* approach here."
                    },
                    {
                        "username": "_srahul_",
                        "content": "The moment I see size as 10^5 in constraint, my mind automatically starts thinking of an approach that is `<= O(n*logn)  `.\\n\\nPerks of giving contests."
                    },
                    {
                        "username": "ibeastking",
                        "content": "[@amr_pk](/amr_pk)  So if the constraint was 10^4, then we could have used N^2 approach??"
                    },
                    {
                        "username": "amr_pk",
                        "content": "[@guptatanish145](/guptatanish145) 1 second ~= 10^8 operations. You should not exceed that. So you can write a solution that\\'s either N (10^5) or NlogN (10^6). That\\'s my mindset when I solve codeforces contests."
                    },
                    {
                        "username": "codeMonarch",
                        "content": "sumpott ++"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "how did you identify that ?"
                    },
                    {
                        "username": "pokaChika",
                        "content": "Reminds me of Severus Snape the Potions Master 😂 "
                    },
                    {
                        "username": "AMerrill",
                        "content": "This problem is a great follow up to yesterdays daily challenge. Let\\'s get the April streak going!\\n\\nThe question is: how can you implement a binary search in solving this problem? Try thinking about what variables you can change and how!"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Tip/Hint:- \n\n\nSort the potions array and then for each spell find the lower bound `idx `for\n\n `temp = (double) success/spell[i]`\n\nand push_back `length-idx` in the ans array."
                    },
                    {
                        "username": "chiragsanghvi18",
                        "content": "Doing the exact same thing but getting TLE not sure why."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@namandt](/namandt) yep exactly\\n"
                    },
                    {
                        "username": "Maang-io",
                        "content": "You can sort the array in descending order, and just push the index to result.\\nhttps://leetcode.com/problems/successful-pairs-of-spells-and-potions/solutions/3372013/interview-approach-journey-from-brute-force-to-better-brute-force-to-sorting-and-binary-search/"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@sarpalmadhav](/sarpalmadhav) Yeah, but I directly use the STL function lower_bound for this problem, there i needed to put a value to look for in the array,so I had only that option"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Shubham Raj](/Shubham_Raj22) In high precision problems, using double and dividing large numbers can be a risky bet. `spell[i]*potion[j] >= success` would be a better check"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@namandt](/namandt) It is that simple, lower bound means that in the sorted array we get the first occuring instance.. hence all other potions will be covered"
                    },
                    {
                        "username": "namandt",
                        "content": "Its not that simple.\\nNeed to handle duplicates in the potions"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "I guess Binary Search days are coming "
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "[@marwanmusa](/marwanmusa) my bad I\\'ve been training to look for hints and patterns from just the problem description and examples, not the optional hints some problems have haha"
                    },
                    {
                        "username": "marwanmusa",
                        "content": "[@disturbedbrown1](/disturbedbrown1) its in hint-3/3"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "the problem didnt give away any bs pattern/ hint though"
                    },
                    {
                        "username": "mickodjordjevic98",
                        "content": "Hints point to using binary search, but the best solution uses something similar to prefix sum which gives O(n) time instead of O(nlogn). Maybe this question need to have its conditions changed to make binary search most efficient option (since that is the point of the question I guess, to practice bs), maximum value of potions and spells should be big enough so that an array size of maxPotion or maxSpell exceeds memory capacity."
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "[@ashedcorpse](/ashedcorpse) A better problem to practice on is https://leetcode.com/problems/search-a-2d-matrix-ii/, as there are a few extra wrinkles in directly applying it to this problem that cloud the elegance of the strategy."
                    },
                    {
                        "username": "AlecLC",
                        "content": "[@ashedcorpse](/ashedcorpse) 2 pointer"
                    },
                    {
                        "username": "cswartzell",
                        "content": "I actually rather love that its NOT a binary search question, and may mislead people into thinking it is one. Its a good lesson to consider other, possibly simpler solutions. There are plenty of Binary Search questions on LC, we dont need to modify this to be a straight binary search. Its better as is to show why the tricky answer might actually be worse than the simple answer. "
                    },
                    {
                        "username": "ashedcorpse",
                        "content": "can you please share the approach of O(n)"
                    },
                    {
                        "username": "CodingMonkey101",
                        "content": "`Tip`\n***Just wanted to share my two favorite binary search templates to help with this problem as well as any similar ones:***\nTemplate 1: Find max value of x such that f(x) is true\n```\ndef binarySearchForMinVal()\n    l, r = lower_bound, upper_bound\n    while l < r:\n        mid = (l + r)//2 #round down\n        if feasible(mid):\n            r = mid #check for possible smaller values that work\n        else:\n            l = mid + 1 #values smaller than or equal to mid do not work. Reduce search space to values greater than mid.\n    return l\n```\nTemplate 2: Find min value of x such that f(x) is true\n```\ndef binarySearchForMaxVal()\n    l, r = lower_bound, upper_bound\n    while l < r:\n        mid = (l + r + 1)//2 #round up\n        if feasible(mid):\n            l = mid #check for possible greater values that work\n        else:\n            r = mid - 1 #values greater than or equal to mid do not work. Reduce search space to values smaller than mid.\n    return l\n\n```"
                    },
                    {
                        "username": "rajat_171",
                        "content": "Sometimes it is good, sometimes it is shit. (\\u25CF\\'\\u25E1\\'\\u25CF)"
                    },
                    {
                        "username": "EnzoPay",
                        "content": "For me bisearch is not the best way, brings to many troubles... :("
                    }
                ]
            },
            {
                "id": 1851208,
                "content": [
                    {
                        "username": "AlecLC",
                        "content": "Which potion do I need to give the interviewer to hire me?"
                    },
                    {
                        "username": "santanusen",
                        "content": "```\\nvoid get_hired(vector<Company>& companies) {\\n    sort (companies.begin(), companies.end(), greater_preference());\\n    for (company : companies)\\n        if (interview(company) == hired)\\n            return;\\n\\n    get_hired(companies);\\n}\\n\\n```"
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "Potion of Butter \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Msey",
                        "content": "[@_Tan_A](/_Tan_A) You need to find a cat"
                    },
                    {
                        "username": "abhishek_2603",
                        "content": "[@Msey](/Msey)  what if I am a male."
                    },
                    {
                        "username": "nat1902",
                        "content": "[@Msey](/Msey) lol:)))))))))))))))"
                    },
                    {
                        "username": "Msey",
                        "content": "pussy juice"
                    },
                    {
                        "username": "Sudeepreddy537",
                        "content": "0(1) is it\\n"
                    },
                    {
                        "username": "pushprajsinghpawar7",
                        "content": ")1(O"
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "skill potion if u are not a female"
                    },
                    {
                        "username": "AMerrill",
                        "content": "[@gonestill](/gonestill) Paired with a disillusionment spell!"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "so if u go by NAIVE approach at 51th test case out of 56 u will get TLE"
                    },
                    {
                        "username": "hero080",
                        "content": "binary search is the *naive* approach here."
                    },
                    {
                        "username": "_srahul_",
                        "content": "The moment I see size as 10^5 in constraint, my mind automatically starts thinking of an approach that is `<= O(n*logn)  `.\\n\\nPerks of giving contests."
                    },
                    {
                        "username": "ibeastking",
                        "content": "[@amr_pk](/amr_pk)  So if the constraint was 10^4, then we could have used N^2 approach??"
                    },
                    {
                        "username": "amr_pk",
                        "content": "[@guptatanish145](/guptatanish145) 1 second ~= 10^8 operations. You should not exceed that. So you can write a solution that\\'s either N (10^5) or NlogN (10^6). That\\'s my mindset when I solve codeforces contests."
                    },
                    {
                        "username": "codeMonarch",
                        "content": "sumpott ++"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "how did you identify that ?"
                    },
                    {
                        "username": "pokaChika",
                        "content": "Reminds me of Severus Snape the Potions Master 😂 "
                    },
                    {
                        "username": "AMerrill",
                        "content": "This problem is a great follow up to yesterdays daily challenge. Let\\'s get the April streak going!\\n\\nThe question is: how can you implement a binary search in solving this problem? Try thinking about what variables you can change and how!"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Tip/Hint:- \n\n\nSort the potions array and then for each spell find the lower bound `idx `for\n\n `temp = (double) success/spell[i]`\n\nand push_back `length-idx` in the ans array."
                    },
                    {
                        "username": "chiragsanghvi18",
                        "content": "Doing the exact same thing but getting TLE not sure why."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@namandt](/namandt) yep exactly\\n"
                    },
                    {
                        "username": "Maang-io",
                        "content": "You can sort the array in descending order, and just push the index to result.\\nhttps://leetcode.com/problems/successful-pairs-of-spells-and-potions/solutions/3372013/interview-approach-journey-from-brute-force-to-better-brute-force-to-sorting-and-binary-search/"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@sarpalmadhav](/sarpalmadhav) Yeah, but I directly use the STL function lower_bound for this problem, there i needed to put a value to look for in the array,so I had only that option"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Shubham Raj](/Shubham_Raj22) In high precision problems, using double and dividing large numbers can be a risky bet. `spell[i]*potion[j] >= success` would be a better check"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@namandt](/namandt) It is that simple, lower bound means that in the sorted array we get the first occuring instance.. hence all other potions will be covered"
                    },
                    {
                        "username": "namandt",
                        "content": "Its not that simple.\\nNeed to handle duplicates in the potions"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "I guess Binary Search days are coming "
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "[@marwanmusa](/marwanmusa) my bad I\\'ve been training to look for hints and patterns from just the problem description and examples, not the optional hints some problems have haha"
                    },
                    {
                        "username": "marwanmusa",
                        "content": "[@disturbedbrown1](/disturbedbrown1) its in hint-3/3"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "the problem didnt give away any bs pattern/ hint though"
                    },
                    {
                        "username": "mickodjordjevic98",
                        "content": "Hints point to using binary search, but the best solution uses something similar to prefix sum which gives O(n) time instead of O(nlogn). Maybe this question need to have its conditions changed to make binary search most efficient option (since that is the point of the question I guess, to practice bs), maximum value of potions and spells should be big enough so that an array size of maxPotion or maxSpell exceeds memory capacity."
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "[@ashedcorpse](/ashedcorpse) A better problem to practice on is https://leetcode.com/problems/search-a-2d-matrix-ii/, as there are a few extra wrinkles in directly applying it to this problem that cloud the elegance of the strategy."
                    },
                    {
                        "username": "AlecLC",
                        "content": "[@ashedcorpse](/ashedcorpse) 2 pointer"
                    },
                    {
                        "username": "cswartzell",
                        "content": "I actually rather love that its NOT a binary search question, and may mislead people into thinking it is one. Its a good lesson to consider other, possibly simpler solutions. There are plenty of Binary Search questions on LC, we dont need to modify this to be a straight binary search. Its better as is to show why the tricky answer might actually be worse than the simple answer. "
                    },
                    {
                        "username": "ashedcorpse",
                        "content": "can you please share the approach of O(n)"
                    },
                    {
                        "username": "CodingMonkey101",
                        "content": "`Tip`\n***Just wanted to share my two favorite binary search templates to help with this problem as well as any similar ones:***\nTemplate 1: Find max value of x such that f(x) is true\n```\ndef binarySearchForMinVal()\n    l, r = lower_bound, upper_bound\n    while l < r:\n        mid = (l + r)//2 #round down\n        if feasible(mid):\n            r = mid #check for possible smaller values that work\n        else:\n            l = mid + 1 #values smaller than or equal to mid do not work. Reduce search space to values greater than mid.\n    return l\n```\nTemplate 2: Find min value of x such that f(x) is true\n```\ndef binarySearchForMaxVal()\n    l, r = lower_bound, upper_bound\n    while l < r:\n        mid = (l + r + 1)//2 #round up\n        if feasible(mid):\n            l = mid #check for possible greater values that work\n        else:\n            r = mid - 1 #values greater than or equal to mid do not work. Reduce search space to values smaller than mid.\n    return l\n\n```"
                    },
                    {
                        "username": "rajat_171",
                        "content": "Sometimes it is good, sometimes it is shit. (\\u25CF\\'\\u25E1\\'\\u25CF)"
                    },
                    {
                        "username": "EnzoPay",
                        "content": "For me bisearch is not the best way, brings to many troubles... :("
                    }
                ]
            },
            {
                "id": 1794344,
                "content": [
                    {
                        "username": "AlecLC",
                        "content": "Which potion do I need to give the interviewer to hire me?"
                    },
                    {
                        "username": "santanusen",
                        "content": "```\\nvoid get_hired(vector<Company>& companies) {\\n    sort (companies.begin(), companies.end(), greater_preference());\\n    for (company : companies)\\n        if (interview(company) == hired)\\n            return;\\n\\n    get_hired(companies);\\n}\\n\\n```"
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "Potion of Butter \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Msey",
                        "content": "[@_Tan_A](/_Tan_A) You need to find a cat"
                    },
                    {
                        "username": "abhishek_2603",
                        "content": "[@Msey](/Msey)  what if I am a male."
                    },
                    {
                        "username": "nat1902",
                        "content": "[@Msey](/Msey) lol:)))))))))))))))"
                    },
                    {
                        "username": "Msey",
                        "content": "pussy juice"
                    },
                    {
                        "username": "Sudeepreddy537",
                        "content": "0(1) is it\\n"
                    },
                    {
                        "username": "pushprajsinghpawar7",
                        "content": ")1(O"
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "skill potion if u are not a female"
                    },
                    {
                        "username": "AMerrill",
                        "content": "[@gonestill](/gonestill) Paired with a disillusionment spell!"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "so if u go by NAIVE approach at 51th test case out of 56 u will get TLE"
                    },
                    {
                        "username": "hero080",
                        "content": "binary search is the *naive* approach here."
                    },
                    {
                        "username": "_srahul_",
                        "content": "The moment I see size as 10^5 in constraint, my mind automatically starts thinking of an approach that is `<= O(n*logn)  `.\\n\\nPerks of giving contests."
                    },
                    {
                        "username": "ibeastking",
                        "content": "[@amr_pk](/amr_pk)  So if the constraint was 10^4, then we could have used N^2 approach??"
                    },
                    {
                        "username": "amr_pk",
                        "content": "[@guptatanish145](/guptatanish145) 1 second ~= 10^8 operations. You should not exceed that. So you can write a solution that\\'s either N (10^5) or NlogN (10^6). That\\'s my mindset when I solve codeforces contests."
                    },
                    {
                        "username": "codeMonarch",
                        "content": "sumpott ++"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "how did you identify that ?"
                    },
                    {
                        "username": "pokaChika",
                        "content": "Reminds me of Severus Snape the Potions Master 😂 "
                    },
                    {
                        "username": "AMerrill",
                        "content": "This problem is a great follow up to yesterdays daily challenge. Let\\'s get the April streak going!\\n\\nThe question is: how can you implement a binary search in solving this problem? Try thinking about what variables you can change and how!"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Tip/Hint:- \n\n\nSort the potions array and then for each spell find the lower bound `idx `for\n\n `temp = (double) success/spell[i]`\n\nand push_back `length-idx` in the ans array."
                    },
                    {
                        "username": "chiragsanghvi18",
                        "content": "Doing the exact same thing but getting TLE not sure why."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@namandt](/namandt) yep exactly\\n"
                    },
                    {
                        "username": "Maang-io",
                        "content": "You can sort the array in descending order, and just push the index to result.\\nhttps://leetcode.com/problems/successful-pairs-of-spells-and-potions/solutions/3372013/interview-approach-journey-from-brute-force-to-better-brute-force-to-sorting-and-binary-search/"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@sarpalmadhav](/sarpalmadhav) Yeah, but I directly use the STL function lower_bound for this problem, there i needed to put a value to look for in the array,so I had only that option"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Shubham Raj](/Shubham_Raj22) In high precision problems, using double and dividing large numbers can be a risky bet. `spell[i]*potion[j] >= success` would be a better check"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@namandt](/namandt) It is that simple, lower bound means that in the sorted array we get the first occuring instance.. hence all other potions will be covered"
                    },
                    {
                        "username": "namandt",
                        "content": "Its not that simple.\\nNeed to handle duplicates in the potions"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "I guess Binary Search days are coming "
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "[@marwanmusa](/marwanmusa) my bad I\\'ve been training to look for hints and patterns from just the problem description and examples, not the optional hints some problems have haha"
                    },
                    {
                        "username": "marwanmusa",
                        "content": "[@disturbedbrown1](/disturbedbrown1) its in hint-3/3"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "the problem didnt give away any bs pattern/ hint though"
                    },
                    {
                        "username": "mickodjordjevic98",
                        "content": "Hints point to using binary search, but the best solution uses something similar to prefix sum which gives O(n) time instead of O(nlogn). Maybe this question need to have its conditions changed to make binary search most efficient option (since that is the point of the question I guess, to practice bs), maximum value of potions and spells should be big enough so that an array size of maxPotion or maxSpell exceeds memory capacity."
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "[@ashedcorpse](/ashedcorpse) A better problem to practice on is https://leetcode.com/problems/search-a-2d-matrix-ii/, as there are a few extra wrinkles in directly applying it to this problem that cloud the elegance of the strategy."
                    },
                    {
                        "username": "AlecLC",
                        "content": "[@ashedcorpse](/ashedcorpse) 2 pointer"
                    },
                    {
                        "username": "cswartzell",
                        "content": "I actually rather love that its NOT a binary search question, and may mislead people into thinking it is one. Its a good lesson to consider other, possibly simpler solutions. There are plenty of Binary Search questions on LC, we dont need to modify this to be a straight binary search. Its better as is to show why the tricky answer might actually be worse than the simple answer. "
                    },
                    {
                        "username": "ashedcorpse",
                        "content": "can you please share the approach of O(n)"
                    },
                    {
                        "username": "CodingMonkey101",
                        "content": "`Tip`\n***Just wanted to share my two favorite binary search templates to help with this problem as well as any similar ones:***\nTemplate 1: Find max value of x such that f(x) is true\n```\ndef binarySearchForMinVal()\n    l, r = lower_bound, upper_bound\n    while l < r:\n        mid = (l + r)//2 #round down\n        if feasible(mid):\n            r = mid #check for possible smaller values that work\n        else:\n            l = mid + 1 #values smaller than or equal to mid do not work. Reduce search space to values greater than mid.\n    return l\n```\nTemplate 2: Find min value of x such that f(x) is true\n```\ndef binarySearchForMaxVal()\n    l, r = lower_bound, upper_bound\n    while l < r:\n        mid = (l + r + 1)//2 #round up\n        if feasible(mid):\n            l = mid #check for possible greater values that work\n        else:\n            r = mid - 1 #values greater than or equal to mid do not work. Reduce search space to values smaller than mid.\n    return l\n\n```"
                    },
                    {
                        "username": "rajat_171",
                        "content": "Sometimes it is good, sometimes it is shit. (\\u25CF\\'\\u25E1\\'\\u25CF)"
                    },
                    {
                        "username": "EnzoPay",
                        "content": "For me bisearch is not the best way, brings to many troubles... :("
                    }
                ]
            },
            {
                "id": 1851644,
                "content": [
                    {
                        "username": "AlecLC",
                        "content": "Which potion do I need to give the interviewer to hire me?"
                    },
                    {
                        "username": "santanusen",
                        "content": "```\\nvoid get_hired(vector<Company>& companies) {\\n    sort (companies.begin(), companies.end(), greater_preference());\\n    for (company : companies)\\n        if (interview(company) == hired)\\n            return;\\n\\n    get_hired(companies);\\n}\\n\\n```"
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "Potion of Butter \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Msey",
                        "content": "[@_Tan_A](/_Tan_A) You need to find a cat"
                    },
                    {
                        "username": "abhishek_2603",
                        "content": "[@Msey](/Msey)  what if I am a male."
                    },
                    {
                        "username": "nat1902",
                        "content": "[@Msey](/Msey) lol:)))))))))))))))"
                    },
                    {
                        "username": "Msey",
                        "content": "pussy juice"
                    },
                    {
                        "username": "Sudeepreddy537",
                        "content": "0(1) is it\\n"
                    },
                    {
                        "username": "pushprajsinghpawar7",
                        "content": ")1(O"
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "skill potion if u are not a female"
                    },
                    {
                        "username": "AMerrill",
                        "content": "[@gonestill](/gonestill) Paired with a disillusionment spell!"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "so if u go by NAIVE approach at 51th test case out of 56 u will get TLE"
                    },
                    {
                        "username": "hero080",
                        "content": "binary search is the *naive* approach here."
                    },
                    {
                        "username": "_srahul_",
                        "content": "The moment I see size as 10^5 in constraint, my mind automatically starts thinking of an approach that is `<= O(n*logn)  `.\\n\\nPerks of giving contests."
                    },
                    {
                        "username": "ibeastking",
                        "content": "[@amr_pk](/amr_pk)  So if the constraint was 10^4, then we could have used N^2 approach??"
                    },
                    {
                        "username": "amr_pk",
                        "content": "[@guptatanish145](/guptatanish145) 1 second ~= 10^8 operations. You should not exceed that. So you can write a solution that\\'s either N (10^5) or NlogN (10^6). That\\'s my mindset when I solve codeforces contests."
                    },
                    {
                        "username": "codeMonarch",
                        "content": "sumpott ++"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "how did you identify that ?"
                    },
                    {
                        "username": "pokaChika",
                        "content": "Reminds me of Severus Snape the Potions Master 😂 "
                    },
                    {
                        "username": "AMerrill",
                        "content": "This problem is a great follow up to yesterdays daily challenge. Let\\'s get the April streak going!\\n\\nThe question is: how can you implement a binary search in solving this problem? Try thinking about what variables you can change and how!"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Tip/Hint:- \n\n\nSort the potions array and then for each spell find the lower bound `idx `for\n\n `temp = (double) success/spell[i]`\n\nand push_back `length-idx` in the ans array."
                    },
                    {
                        "username": "chiragsanghvi18",
                        "content": "Doing the exact same thing but getting TLE not sure why."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@namandt](/namandt) yep exactly\\n"
                    },
                    {
                        "username": "Maang-io",
                        "content": "You can sort the array in descending order, and just push the index to result.\\nhttps://leetcode.com/problems/successful-pairs-of-spells-and-potions/solutions/3372013/interview-approach-journey-from-brute-force-to-better-brute-force-to-sorting-and-binary-search/"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@sarpalmadhav](/sarpalmadhav) Yeah, but I directly use the STL function lower_bound for this problem, there i needed to put a value to look for in the array,so I had only that option"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Shubham Raj](/Shubham_Raj22) In high precision problems, using double and dividing large numbers can be a risky bet. `spell[i]*potion[j] >= success` would be a better check"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@namandt](/namandt) It is that simple, lower bound means that in the sorted array we get the first occuring instance.. hence all other potions will be covered"
                    },
                    {
                        "username": "namandt",
                        "content": "Its not that simple.\\nNeed to handle duplicates in the potions"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "I guess Binary Search days are coming "
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "[@marwanmusa](/marwanmusa) my bad I\\'ve been training to look for hints and patterns from just the problem description and examples, not the optional hints some problems have haha"
                    },
                    {
                        "username": "marwanmusa",
                        "content": "[@disturbedbrown1](/disturbedbrown1) its in hint-3/3"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "the problem didnt give away any bs pattern/ hint though"
                    },
                    {
                        "username": "mickodjordjevic98",
                        "content": "Hints point to using binary search, but the best solution uses something similar to prefix sum which gives O(n) time instead of O(nlogn). Maybe this question need to have its conditions changed to make binary search most efficient option (since that is the point of the question I guess, to practice bs), maximum value of potions and spells should be big enough so that an array size of maxPotion or maxSpell exceeds memory capacity."
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "[@ashedcorpse](/ashedcorpse) A better problem to practice on is https://leetcode.com/problems/search-a-2d-matrix-ii/, as there are a few extra wrinkles in directly applying it to this problem that cloud the elegance of the strategy."
                    },
                    {
                        "username": "AlecLC",
                        "content": "[@ashedcorpse](/ashedcorpse) 2 pointer"
                    },
                    {
                        "username": "cswartzell",
                        "content": "I actually rather love that its NOT a binary search question, and may mislead people into thinking it is one. Its a good lesson to consider other, possibly simpler solutions. There are plenty of Binary Search questions on LC, we dont need to modify this to be a straight binary search. Its better as is to show why the tricky answer might actually be worse than the simple answer. "
                    },
                    {
                        "username": "ashedcorpse",
                        "content": "can you please share the approach of O(n)"
                    },
                    {
                        "username": "CodingMonkey101",
                        "content": "`Tip`\n***Just wanted to share my two favorite binary search templates to help with this problem as well as any similar ones:***\nTemplate 1: Find max value of x such that f(x) is true\n```\ndef binarySearchForMinVal()\n    l, r = lower_bound, upper_bound\n    while l < r:\n        mid = (l + r)//2 #round down\n        if feasible(mid):\n            r = mid #check for possible smaller values that work\n        else:\n            l = mid + 1 #values smaller than or equal to mid do not work. Reduce search space to values greater than mid.\n    return l\n```\nTemplate 2: Find min value of x such that f(x) is true\n```\ndef binarySearchForMaxVal()\n    l, r = lower_bound, upper_bound\n    while l < r:\n        mid = (l + r + 1)//2 #round up\n        if feasible(mid):\n            l = mid #check for possible greater values that work\n        else:\n            r = mid - 1 #values greater than or equal to mid do not work. Reduce search space to values smaller than mid.\n    return l\n\n```"
                    },
                    {
                        "username": "rajat_171",
                        "content": "Sometimes it is good, sometimes it is shit. (\\u25CF\\'\\u25E1\\'\\u25CF)"
                    },
                    {
                        "username": "EnzoPay",
                        "content": "For me bisearch is not the best way, brings to many troubles... :("
                    }
                ]
            },
            {
                "id": 1851426,
                "content": [
                    {
                        "username": "AlecLC",
                        "content": "Which potion do I need to give the interviewer to hire me?"
                    },
                    {
                        "username": "santanusen",
                        "content": "```\\nvoid get_hired(vector<Company>& companies) {\\n    sort (companies.begin(), companies.end(), greater_preference());\\n    for (company : companies)\\n        if (interview(company) == hired)\\n            return;\\n\\n    get_hired(companies);\\n}\\n\\n```"
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "Potion of Butter \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Msey",
                        "content": "[@_Tan_A](/_Tan_A) You need to find a cat"
                    },
                    {
                        "username": "abhishek_2603",
                        "content": "[@Msey](/Msey)  what if I am a male."
                    },
                    {
                        "username": "nat1902",
                        "content": "[@Msey](/Msey) lol:)))))))))))))))"
                    },
                    {
                        "username": "Msey",
                        "content": "pussy juice"
                    },
                    {
                        "username": "Sudeepreddy537",
                        "content": "0(1) is it\\n"
                    },
                    {
                        "username": "pushprajsinghpawar7",
                        "content": ")1(O"
                    },
                    {
                        "username": "SatyamBindroo",
                        "content": "skill potion if u are not a female"
                    },
                    {
                        "username": "AMerrill",
                        "content": "[@gonestill](/gonestill) Paired with a disillusionment spell!"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "so if u go by NAIVE approach at 51th test case out of 56 u will get TLE"
                    },
                    {
                        "username": "hero080",
                        "content": "binary search is the *naive* approach here."
                    },
                    {
                        "username": "_srahul_",
                        "content": "The moment I see size as 10^5 in constraint, my mind automatically starts thinking of an approach that is `<= O(n*logn)  `.\\n\\nPerks of giving contests."
                    },
                    {
                        "username": "ibeastking",
                        "content": "[@amr_pk](/amr_pk)  So if the constraint was 10^4, then we could have used N^2 approach??"
                    },
                    {
                        "username": "amr_pk",
                        "content": "[@guptatanish145](/guptatanish145) 1 second ~= 10^8 operations. You should not exceed that. So you can write a solution that\\'s either N (10^5) or NlogN (10^6). That\\'s my mindset when I solve codeforces contests."
                    },
                    {
                        "username": "codeMonarch",
                        "content": "sumpott ++"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "how did you identify that ?"
                    },
                    {
                        "username": "pokaChika",
                        "content": "Reminds me of Severus Snape the Potions Master 😂 "
                    },
                    {
                        "username": "AMerrill",
                        "content": "This problem is a great follow up to yesterdays daily challenge. Let\\'s get the April streak going!\\n\\nThe question is: how can you implement a binary search in solving this problem? Try thinking about what variables you can change and how!"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Tip/Hint:- \n\n\nSort the potions array and then for each spell find the lower bound `idx `for\n\n `temp = (double) success/spell[i]`\n\nand push_back `length-idx` in the ans array."
                    },
                    {
                        "username": "chiragsanghvi18",
                        "content": "Doing the exact same thing but getting TLE not sure why."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@namandt](/namandt) yep exactly\\n"
                    },
                    {
                        "username": "Maang-io",
                        "content": "You can sort the array in descending order, and just push the index to result.\\nhttps://leetcode.com/problems/successful-pairs-of-spells-and-potions/solutions/3372013/interview-approach-journey-from-brute-force-to-better-brute-force-to-sorting-and-binary-search/"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@sarpalmadhav](/sarpalmadhav) Yeah, but I directly use the STL function lower_bound for this problem, there i needed to put a value to look for in the array,so I had only that option"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Shubham Raj](/Shubham_Raj22) In high precision problems, using double and dividing large numbers can be a risky bet. `spell[i]*potion[j] >= success` would be a better check"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@namandt](/namandt) It is that simple, lower bound means that in the sorted array we get the first occuring instance.. hence all other potions will be covered"
                    },
                    {
                        "username": "namandt",
                        "content": "Its not that simple.\\nNeed to handle duplicates in the potions"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "I guess Binary Search days are coming "
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "[@marwanmusa](/marwanmusa) my bad I\\'ve been training to look for hints and patterns from just the problem description and examples, not the optional hints some problems have haha"
                    },
                    {
                        "username": "marwanmusa",
                        "content": "[@disturbedbrown1](/disturbedbrown1) its in hint-3/3"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "the problem didnt give away any bs pattern/ hint though"
                    },
                    {
                        "username": "mickodjordjevic98",
                        "content": "Hints point to using binary search, but the best solution uses something similar to prefix sum which gives O(n) time instead of O(nlogn). Maybe this question need to have its conditions changed to make binary search most efficient option (since that is the point of the question I guess, to practice bs), maximum value of potions and spells should be big enough so that an array size of maxPotion or maxSpell exceeds memory capacity."
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "[@ashedcorpse](/ashedcorpse) A better problem to practice on is https://leetcode.com/problems/search-a-2d-matrix-ii/, as there are a few extra wrinkles in directly applying it to this problem that cloud the elegance of the strategy."
                    },
                    {
                        "username": "AlecLC",
                        "content": "[@ashedcorpse](/ashedcorpse) 2 pointer"
                    },
                    {
                        "username": "cswartzell",
                        "content": "I actually rather love that its NOT a binary search question, and may mislead people into thinking it is one. Its a good lesson to consider other, possibly simpler solutions. There are plenty of Binary Search questions on LC, we dont need to modify this to be a straight binary search. Its better as is to show why the tricky answer might actually be worse than the simple answer. "
                    },
                    {
                        "username": "ashedcorpse",
                        "content": "can you please share the approach of O(n)"
                    },
                    {
                        "username": "CodingMonkey101",
                        "content": "`Tip`\n***Just wanted to share my two favorite binary search templates to help with this problem as well as any similar ones:***\nTemplate 1: Find max value of x such that f(x) is true\n```\ndef binarySearchForMinVal()\n    l, r = lower_bound, upper_bound\n    while l < r:\n        mid = (l + r)//2 #round down\n        if feasible(mid):\n            r = mid #check for possible smaller values that work\n        else:\n            l = mid + 1 #values smaller than or equal to mid do not work. Reduce search space to values greater than mid.\n    return l\n```\nTemplate 2: Find min value of x such that f(x) is true\n```\ndef binarySearchForMaxVal()\n    l, r = lower_bound, upper_bound\n    while l < r:\n        mid = (l + r + 1)//2 #round up\n        if feasible(mid):\n            l = mid #check for possible greater values that work\n        else:\n            r = mid - 1 #values greater than or equal to mid do not work. Reduce search space to values smaller than mid.\n    return l\n\n```"
                    },
                    {
                        "username": "rajat_171",
                        "content": "Sometimes it is good, sometimes it is shit. (\\u25CF\\'\\u25E1\\'\\u25CF)"
                    },
                    {
                        "username": "EnzoPay",
                        "content": "For me bisearch is not the best way, brings to many troubles... :("
                    }
                ]
            },
            {
                "id": 1851643,
                "content": [
                    {
                        "username": "AshutoshPatel028",
                        "content": "I Know Binary Search but I don\\'t How to twist and use it according to problem!! \\uD83D\\uDE05\\uD83D\\uDE05"
                    },
                    {
                        "username": "iamshub07",
                        "content": "If your  code is failing for large test cases...\\ntry\\n`long x = (long)spell*arr[mid];`\\ni.e cast spell in long as by default it is int."
                    },
                    {
                        "username": "anurag_code_r",
                        "content": "One strange thing happened to me. When I build a function for binary search it shows memory limit exceeded but when I do it in the main function itself it runs???\\n"
                    },
                    {
                        "username": "mennaabdelrahman6",
                        "content": "I have an interview in 5 min, I don\\'t know why the hack I am doing in this section"
                    },
                    {
                        "username": "DevyDhanish",
                        "content": "DO not do the double \"for loop\" method you will get TLE at 51 \\uD83D\\uDE2D"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "If a spell's strength is greater than or equal to success, potions of any strength will do."
                    },
                    {
                        "username": "trpaslik",
                        "content": "If you wonder how to do ceil(x/y) faster using only int division:\\n`ceil(x/y) = (x + y - 1) // y`\\nIn python, it is indeed much faster."
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "A shorter alternative is -(-x//y) if you are in a language (like Python) that always truncates down instead of truncating towards  zero."
                    },
                    {
                        "username": "MohitAhlawat",
                        "content": "use binary search same as lower bound but have to modified according to mid according to spells without modifing whole array"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "Solve\\n35. Search insert position to get a better understanding at this!"
                    },
                    {
                        "username": "adityadixit7054",
                        "content": "sort the potions arrray for reducing the time complexity otherwise use two for loops "
                    },
                    {
                        "username": "user5400vw",
                        "content": "if test suite allowed for O(N^2) solutions, the problem would warrant an easy tag ."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "two for loops -> TLE"
                    }
                ]
            },
            {
                "id": 1851600,
                "content": [
                    {
                        "username": "AshutoshPatel028",
                        "content": "I Know Binary Search but I don\\'t How to twist and use it according to problem!! \\uD83D\\uDE05\\uD83D\\uDE05"
                    },
                    {
                        "username": "iamshub07",
                        "content": "If your  code is failing for large test cases...\\ntry\\n`long x = (long)spell*arr[mid];`\\ni.e cast spell in long as by default it is int."
                    },
                    {
                        "username": "anurag_code_r",
                        "content": "One strange thing happened to me. When I build a function for binary search it shows memory limit exceeded but when I do it in the main function itself it runs???\\n"
                    },
                    {
                        "username": "mennaabdelrahman6",
                        "content": "I have an interview in 5 min, I don\\'t know why the hack I am doing in this section"
                    },
                    {
                        "username": "DevyDhanish",
                        "content": "DO not do the double \"for loop\" method you will get TLE at 51 \\uD83D\\uDE2D"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "If a spell's strength is greater than or equal to success, potions of any strength will do."
                    },
                    {
                        "username": "trpaslik",
                        "content": "If you wonder how to do ceil(x/y) faster using only int division:\\n`ceil(x/y) = (x + y - 1) // y`\\nIn python, it is indeed much faster."
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "A shorter alternative is -(-x//y) if you are in a language (like Python) that always truncates down instead of truncating towards  zero."
                    },
                    {
                        "username": "MohitAhlawat",
                        "content": "use binary search same as lower bound but have to modified according to mid according to spells without modifing whole array"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "Solve\\n35. Search insert position to get a better understanding at this!"
                    },
                    {
                        "username": "adityadixit7054",
                        "content": "sort the potions arrray for reducing the time complexity otherwise use two for loops "
                    },
                    {
                        "username": "user5400vw",
                        "content": "if test suite allowed for O(N^2) solutions, the problem would warrant an easy tag ."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "two for loops -> TLE"
                    }
                ]
            },
            {
                "id": 1936167,
                "content": [
                    {
                        "username": "AshutoshPatel028",
                        "content": "I Know Binary Search but I don\\'t How to twist and use it according to problem!! \\uD83D\\uDE05\\uD83D\\uDE05"
                    },
                    {
                        "username": "iamshub07",
                        "content": "If your  code is failing for large test cases...\\ntry\\n`long x = (long)spell*arr[mid];`\\ni.e cast spell in long as by default it is int."
                    },
                    {
                        "username": "anurag_code_r",
                        "content": "One strange thing happened to me. When I build a function for binary search it shows memory limit exceeded but when I do it in the main function itself it runs???\\n"
                    },
                    {
                        "username": "mennaabdelrahman6",
                        "content": "I have an interview in 5 min, I don\\'t know why the hack I am doing in this section"
                    },
                    {
                        "username": "DevyDhanish",
                        "content": "DO not do the double \"for loop\" method you will get TLE at 51 \\uD83D\\uDE2D"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "If a spell's strength is greater than or equal to success, potions of any strength will do."
                    },
                    {
                        "username": "trpaslik",
                        "content": "If you wonder how to do ceil(x/y) faster using only int division:\\n`ceil(x/y) = (x + y - 1) // y`\\nIn python, it is indeed much faster."
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "A shorter alternative is -(-x//y) if you are in a language (like Python) that always truncates down instead of truncating towards  zero."
                    },
                    {
                        "username": "MohitAhlawat",
                        "content": "use binary search same as lower bound but have to modified according to mid according to spells without modifing whole array"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "Solve\\n35. Search insert position to get a better understanding at this!"
                    },
                    {
                        "username": "adityadixit7054",
                        "content": "sort the potions arrray for reducing the time complexity otherwise use two for loops "
                    },
                    {
                        "username": "user5400vw",
                        "content": "if test suite allowed for O(N^2) solutions, the problem would warrant an easy tag ."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "two for loops -> TLE"
                    }
                ]
            },
            {
                "id": 1905055,
                "content": [
                    {
                        "username": "AshutoshPatel028",
                        "content": "I Know Binary Search but I don\\'t How to twist and use it according to problem!! \\uD83D\\uDE05\\uD83D\\uDE05"
                    },
                    {
                        "username": "iamshub07",
                        "content": "If your  code is failing for large test cases...\\ntry\\n`long x = (long)spell*arr[mid];`\\ni.e cast spell in long as by default it is int."
                    },
                    {
                        "username": "anurag_code_r",
                        "content": "One strange thing happened to me. When I build a function for binary search it shows memory limit exceeded but when I do it in the main function itself it runs???\\n"
                    },
                    {
                        "username": "mennaabdelrahman6",
                        "content": "I have an interview in 5 min, I don\\'t know why the hack I am doing in this section"
                    },
                    {
                        "username": "DevyDhanish",
                        "content": "DO not do the double \"for loop\" method you will get TLE at 51 \\uD83D\\uDE2D"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "If a spell's strength is greater than or equal to success, potions of any strength will do."
                    },
                    {
                        "username": "trpaslik",
                        "content": "If you wonder how to do ceil(x/y) faster using only int division:\\n`ceil(x/y) = (x + y - 1) // y`\\nIn python, it is indeed much faster."
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "A shorter alternative is -(-x//y) if you are in a language (like Python) that always truncates down instead of truncating towards  zero."
                    },
                    {
                        "username": "MohitAhlawat",
                        "content": "use binary search same as lower bound but have to modified according to mid according to spells without modifing whole array"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "Solve\\n35. Search insert position to get a better understanding at this!"
                    },
                    {
                        "username": "adityadixit7054",
                        "content": "sort the potions arrray for reducing the time complexity otherwise use two for loops "
                    },
                    {
                        "username": "user5400vw",
                        "content": "if test suite allowed for O(N^2) solutions, the problem would warrant an easy tag ."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "two for loops -> TLE"
                    }
                ]
            },
            {
                "id": 1859454,
                "content": [
                    {
                        "username": "AshutoshPatel028",
                        "content": "I Know Binary Search but I don\\'t How to twist and use it according to problem!! \\uD83D\\uDE05\\uD83D\\uDE05"
                    },
                    {
                        "username": "iamshub07",
                        "content": "If your  code is failing for large test cases...\\ntry\\n`long x = (long)spell*arr[mid];`\\ni.e cast spell in long as by default it is int."
                    },
                    {
                        "username": "anurag_code_r",
                        "content": "One strange thing happened to me. When I build a function for binary search it shows memory limit exceeded but when I do it in the main function itself it runs???\\n"
                    },
                    {
                        "username": "mennaabdelrahman6",
                        "content": "I have an interview in 5 min, I don\\'t know why the hack I am doing in this section"
                    },
                    {
                        "username": "DevyDhanish",
                        "content": "DO not do the double \"for loop\" method you will get TLE at 51 \\uD83D\\uDE2D"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "If a spell's strength is greater than or equal to success, potions of any strength will do."
                    },
                    {
                        "username": "trpaslik",
                        "content": "If you wonder how to do ceil(x/y) faster using only int division:\\n`ceil(x/y) = (x + y - 1) // y`\\nIn python, it is indeed much faster."
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "A shorter alternative is -(-x//y) if you are in a language (like Python) that always truncates down instead of truncating towards  zero."
                    },
                    {
                        "username": "MohitAhlawat",
                        "content": "use binary search same as lower bound but have to modified according to mid according to spells without modifing whole array"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "Solve\\n35. Search insert position to get a better understanding at this!"
                    },
                    {
                        "username": "adityadixit7054",
                        "content": "sort the potions arrray for reducing the time complexity otherwise use two for loops "
                    },
                    {
                        "username": "user5400vw",
                        "content": "if test suite allowed for O(N^2) solutions, the problem would warrant an easy tag ."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "two for loops -> TLE"
                    }
                ]
            },
            {
                "id": 1851734,
                "content": [
                    {
                        "username": "AshutoshPatel028",
                        "content": "I Know Binary Search but I don\\'t How to twist and use it according to problem!! \\uD83D\\uDE05\\uD83D\\uDE05"
                    },
                    {
                        "username": "iamshub07",
                        "content": "If your  code is failing for large test cases...\\ntry\\n`long x = (long)spell*arr[mid];`\\ni.e cast spell in long as by default it is int."
                    },
                    {
                        "username": "anurag_code_r",
                        "content": "One strange thing happened to me. When I build a function for binary search it shows memory limit exceeded but when I do it in the main function itself it runs???\\n"
                    },
                    {
                        "username": "mennaabdelrahman6",
                        "content": "I have an interview in 5 min, I don\\'t know why the hack I am doing in this section"
                    },
                    {
                        "username": "DevyDhanish",
                        "content": "DO not do the double \"for loop\" method you will get TLE at 51 \\uD83D\\uDE2D"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "If a spell's strength is greater than or equal to success, potions of any strength will do."
                    },
                    {
                        "username": "trpaslik",
                        "content": "If you wonder how to do ceil(x/y) faster using only int division:\\n`ceil(x/y) = (x + y - 1) // y`\\nIn python, it is indeed much faster."
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "A shorter alternative is -(-x//y) if you are in a language (like Python) that always truncates down instead of truncating towards  zero."
                    },
                    {
                        "username": "MohitAhlawat",
                        "content": "use binary search same as lower bound but have to modified according to mid according to spells without modifing whole array"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "Solve\\n35. Search insert position to get a better understanding at this!"
                    },
                    {
                        "username": "adityadixit7054",
                        "content": "sort the potions arrray for reducing the time complexity otherwise use two for loops "
                    },
                    {
                        "username": "user5400vw",
                        "content": "if test suite allowed for O(N^2) solutions, the problem would warrant an easy tag ."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "two for loops -> TLE"
                    }
                ]
            },
            {
                "id": 1851456,
                "content": [
                    {
                        "username": "AshutoshPatel028",
                        "content": "I Know Binary Search but I don\\'t How to twist and use it according to problem!! \\uD83D\\uDE05\\uD83D\\uDE05"
                    },
                    {
                        "username": "iamshub07",
                        "content": "If your  code is failing for large test cases...\\ntry\\n`long x = (long)spell*arr[mid];`\\ni.e cast spell in long as by default it is int."
                    },
                    {
                        "username": "anurag_code_r",
                        "content": "One strange thing happened to me. When I build a function for binary search it shows memory limit exceeded but when I do it in the main function itself it runs???\\n"
                    },
                    {
                        "username": "mennaabdelrahman6",
                        "content": "I have an interview in 5 min, I don\\'t know why the hack I am doing in this section"
                    },
                    {
                        "username": "DevyDhanish",
                        "content": "DO not do the double \"for loop\" method you will get TLE at 51 \\uD83D\\uDE2D"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "If a spell's strength is greater than or equal to success, potions of any strength will do."
                    },
                    {
                        "username": "trpaslik",
                        "content": "If you wonder how to do ceil(x/y) faster using only int division:\\n`ceil(x/y) = (x + y - 1) // y`\\nIn python, it is indeed much faster."
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "A shorter alternative is -(-x//y) if you are in a language (like Python) that always truncates down instead of truncating towards  zero."
                    },
                    {
                        "username": "MohitAhlawat",
                        "content": "use binary search same as lower bound but have to modified according to mid according to spells without modifing whole array"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "Solve\\n35. Search insert position to get a better understanding at this!"
                    },
                    {
                        "username": "adityadixit7054",
                        "content": "sort the potions arrray for reducing the time complexity otherwise use two for loops "
                    },
                    {
                        "username": "user5400vw",
                        "content": "if test suite allowed for O(N^2) solutions, the problem would warrant an easy tag ."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "two for loops -> TLE"
                    }
                ]
            },
            {
                "id": 1851401,
                "content": [
                    {
                        "username": "AshutoshPatel028",
                        "content": "I Know Binary Search but I don\\'t How to twist and use it according to problem!! \\uD83D\\uDE05\\uD83D\\uDE05"
                    },
                    {
                        "username": "iamshub07",
                        "content": "If your  code is failing for large test cases...\\ntry\\n`long x = (long)spell*arr[mid];`\\ni.e cast spell in long as by default it is int."
                    },
                    {
                        "username": "anurag_code_r",
                        "content": "One strange thing happened to me. When I build a function for binary search it shows memory limit exceeded but when I do it in the main function itself it runs???\\n"
                    },
                    {
                        "username": "mennaabdelrahman6",
                        "content": "I have an interview in 5 min, I don\\'t know why the hack I am doing in this section"
                    },
                    {
                        "username": "DevyDhanish",
                        "content": "DO not do the double \"for loop\" method you will get TLE at 51 \\uD83D\\uDE2D"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "If a spell's strength is greater than or equal to success, potions of any strength will do."
                    },
                    {
                        "username": "trpaslik",
                        "content": "If you wonder how to do ceil(x/y) faster using only int division:\\n`ceil(x/y) = (x + y - 1) // y`\\nIn python, it is indeed much faster."
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "A shorter alternative is -(-x//y) if you are in a language (like Python) that always truncates down instead of truncating towards  zero."
                    },
                    {
                        "username": "MohitAhlawat",
                        "content": "use binary search same as lower bound but have to modified according to mid according to spells without modifing whole array"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "Solve\\n35. Search insert position to get a better understanding at this!"
                    },
                    {
                        "username": "adityadixit7054",
                        "content": "sort the potions arrray for reducing the time complexity otherwise use two for loops "
                    },
                    {
                        "username": "user5400vw",
                        "content": "if test suite allowed for O(N^2) solutions, the problem would warrant an easy tag ."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "two for loops -> TLE"
                    }
                ]
            },
            {
                "id": 1851396,
                "content": [
                    {
                        "username": "AshutoshPatel028",
                        "content": "I Know Binary Search but I don\\'t How to twist and use it according to problem!! \\uD83D\\uDE05\\uD83D\\uDE05"
                    },
                    {
                        "username": "iamshub07",
                        "content": "If your  code is failing for large test cases...\\ntry\\n`long x = (long)spell*arr[mid];`\\ni.e cast spell in long as by default it is int."
                    },
                    {
                        "username": "anurag_code_r",
                        "content": "One strange thing happened to me. When I build a function for binary search it shows memory limit exceeded but when I do it in the main function itself it runs???\\n"
                    },
                    {
                        "username": "mennaabdelrahman6",
                        "content": "I have an interview in 5 min, I don\\'t know why the hack I am doing in this section"
                    },
                    {
                        "username": "DevyDhanish",
                        "content": "DO not do the double \"for loop\" method you will get TLE at 51 \\uD83D\\uDE2D"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "If a spell's strength is greater than or equal to success, potions of any strength will do."
                    },
                    {
                        "username": "trpaslik",
                        "content": "If you wonder how to do ceil(x/y) faster using only int division:\\n`ceil(x/y) = (x + y - 1) // y`\\nIn python, it is indeed much faster."
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "A shorter alternative is -(-x//y) if you are in a language (like Python) that always truncates down instead of truncating towards  zero."
                    },
                    {
                        "username": "MohitAhlawat",
                        "content": "use binary search same as lower bound but have to modified according to mid according to spells without modifing whole array"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "Solve\\n35. Search insert position to get a better understanding at this!"
                    },
                    {
                        "username": "adityadixit7054",
                        "content": "sort the potions arrray for reducing the time complexity otherwise use two for loops "
                    },
                    {
                        "username": "user5400vw",
                        "content": "if test suite allowed for O(N^2) solutions, the problem would warrant an easy tag ."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "two for loops -> TLE"
                    }
                ]
            },
            {
                "id": 1851357,
                "content": [
                    {
                        "username": "AshutoshPatel028",
                        "content": "I Know Binary Search but I don\\'t How to twist and use it according to problem!! \\uD83D\\uDE05\\uD83D\\uDE05"
                    },
                    {
                        "username": "iamshub07",
                        "content": "If your  code is failing for large test cases...\\ntry\\n`long x = (long)spell*arr[mid];`\\ni.e cast spell in long as by default it is int."
                    },
                    {
                        "username": "anurag_code_r",
                        "content": "One strange thing happened to me. When I build a function for binary search it shows memory limit exceeded but when I do it in the main function itself it runs???\\n"
                    },
                    {
                        "username": "mennaabdelrahman6",
                        "content": "I have an interview in 5 min, I don\\'t know why the hack I am doing in this section"
                    },
                    {
                        "username": "DevyDhanish",
                        "content": "DO not do the double \"for loop\" method you will get TLE at 51 \\uD83D\\uDE2D"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "If a spell's strength is greater than or equal to success, potions of any strength will do."
                    },
                    {
                        "username": "trpaslik",
                        "content": "If you wonder how to do ceil(x/y) faster using only int division:\\n`ceil(x/y) = (x + y - 1) // y`\\nIn python, it is indeed much faster."
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "A shorter alternative is -(-x//y) if you are in a language (like Python) that always truncates down instead of truncating towards  zero."
                    },
                    {
                        "username": "MohitAhlawat",
                        "content": "use binary search same as lower bound but have to modified according to mid according to spells without modifing whole array"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "Solve\\n35. Search insert position to get a better understanding at this!"
                    },
                    {
                        "username": "adityadixit7054",
                        "content": "sort the potions arrray for reducing the time complexity otherwise use two for loops "
                    },
                    {
                        "username": "user5400vw",
                        "content": "if test suite allowed for O(N^2) solutions, the problem would warrant an easy tag ."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "two for loops -> TLE"
                    }
                ]
            },
            {
                "id": 1850771,
                "content": [
                    {
                        "username": "Code_With_Gurnoor_Chhabra",
                        "content": "\\ncan anyone explain why my recursive son got TLE and iterative passed all test cases (recursion uses stack space of log n but what\\'s role in time complexity?)\\nclass Solution {\\npublic:\\n/* int bin_search(vector<int>p,int l,int r,int i,long long s)\\n{\\n    if(l>r)\\n    {\\n        return 0;\\n    }\\n    long long int mid = l+(r-l)/2;\\n    long long cmp = (long long)p[mid]*i;\\n    int ct=0;\\n    if(cmp<s)\\n    {\\n        ct+=bin_search(p,mid+1,r,i,s);\\n    }\\n    else\\n    {\\n        ct+=r-mid+1+bin_search(p,l,mid-1,i,s);\\n    }\\n    return ct;\\n}\\n*/\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        sort(potions.begin(),potions.end());\\n        vector<int> ans;\\n        int l=0;\\n        int r=potions.size()-1;\\n        for(int i=0;i<spells.size();i++)\\n        {\\n            int ct=0;\\n            int l=0;\\n            int r=potions.size()-1;\\n            while(l<=r)\\n            {\\n              long long int mid = l+(r-l)/2;\\n              long long cmp = (long long)potions[mid]*spells[i];\\n              if(cmp<success)\\n              {\\n                  l=mid+1;\\n              }\\n              else\\n              {\\n                  ct+=r-mid+1;\\n                  r=mid-1;\\n              }\\n            }\\n            ans.push_back(ct);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "anish_patro",
                        "content": "55/56 passed\\ncan someone please explain this ?\\n\\n\\nclass Solution {\\npublic:   \\nint mod=1e9+7; \\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        vector<int> v;\\n        int sn=spells.size();\\n        int pn=potions.size();\\n       for(int i=0;i<pn;++i){\\n           if(success%potions[i]!=0)\\n           potions[i]=success/potions[i] +1;\\n           else\\n           potions[i]=success/potions[i];\\n       }\\n       sort(potions.begin(),potions.end());\\n        for(int i=0;i<sn;++i){\\n             long long low=0;\\n             long long high=pn-1;\\n           int ans=-1;\\n            while(low<=high){\\n            int mid=(low+(high-low)/2)%mod;\\n            if(potions[mid]<=spells[i])\\n           { ans=mid%mod;\\n            low=mid+1;}\\n            else\\n            high=mid-1;   \\n        }\\n        v.push_back(ans+1);\\n        }\\n       return v;\\n    }\\n};"
                    },
                    {
                        "username": "llamasheep",
                        "content": "[@shivansh961](/shivansh961) The above code assumes that success/potions[i] fits in int, but it could overflow. I also made a similar mistake"
                    },
                    {
                        "username": "shivansh961",
                        "content": "I made the same mistake, used lower bound instead.\\nDon\\'t know what\\'s the mistake.\\nIf you understood, the please do tell"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Hint</span>\n![](https://leetcode.com/problems/successful-pairs-of-spells-and-potions/Figures/2300/Slide1.PNG)\n![](https://leetcode.com/problems/successful-pairs-of-spells-and-potions/Figures/2300/Slide3.PNG)\n![](https://leetcode.com/problems/successful-pairs-of-spells-and-potions/Figures/2300/Slide4.PNG)"
                    },
                    {
                        "username": "waiyankyaw961999",
                        "content": "[@namandt](/namandt) By sorting the array, I think we can just scan the specific portion instead of validating all the elements. So, saving the amount of time."
                    },
                    {
                        "username": "x-ider",
                        "content": "[@namandt](/namandt) it\\'s an alternative solution without binary search"
                    },
                    {
                        "username": "namandt",
                        "content": "why do we need to sort the spells array?"
                    },
                    {
                        "username": "piyush_mehta22",
                        "content": "bs giving tle at 49th/56 tc.\\uD83E\\uDD28"
                    },
                    {
                        "username": "Applethal",
                        "content": "`class Solution:\\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\\n        return [sum(1 for potion in potions if spell * potion >= success) for spell in spells]`\\n\\nMade it to 51/56"
                    },
                    {
                        "username": "vamshikiranm",
                        "content": "Learning of > 1ll\nTo prevent overflow, you can use the ll suffix to explicitly specify that you want the literals to be treated as long long:\n\n\n ` long long k = spells[i]*1ll*potions[mid];`"
                    },
                    {
                        "username": "reactdevsourav",
                        "content": "Hi everyone I have solved the problem but I have once question:- \\nHere is my current solution which works\\n```\\nvar successfulPairs = function (spells = [], potions = [], success = 0) {\\n  let ans = [];\\n  potions.sort((a, b) => a - b);\\n  for (let i = 0; i < spells.length; i++) {\\n    let left = 0;\\n    let right = potions.length - 1;\\n    let mid;\\n    let validMid = null;\\n    while (left <= right) {\\n      mid = Math.floor((left + right) / 2);\\n     if (potions[mid] * spells[i] >= success) {\\n        validMid = mid;\\n        right = mid - 1;\\n      } else {\\n        left = mid + 1;\\n      }\\n    }\\n    if (validMid !== null) {\\n      ans.push(potions.length - validMid);\\n    } else {\\n      ans.push(0);\\n    }\\n  }\\n\\n  return ans;\\n};\\n```\\nBut  my this solution gives me wrong answer, could anybody explain why?\\n```\\nvar successfulPairs = function (spells = [], potions = [], success = 0) {\\n  let ans = [];\\n  potions.sort((a, b) => a - b);\\n  for (let i = 0; i < spells.length; i++) {\\n    let left = 0;\\n    let right = potions.length - 1;\\n    let mid;\\n    let validMid = null;\\n    while (left <= right) {\\n      mid = Math.floor((left + right) / 2);\\n      if (potions[mid] * spells[i] === success) {\\n        validMid = mid;\\n        break;\\n      } else if (potions[mid] * spells[i] > success) {\\n        validMid = mid;\\n        right = mid - 1;\\n      } else {\\n        left = mid + 1;\\n      }\\n    }\\n    if (validMid !== null) {\\n      ans.push(potions.length - validMid);\\n    } else {\\n      ans.push(0);\\n    }\\n  }\\n\\n  return ans;\\n};\\n\\n```"
                    },
                    {
                        "username": "pyush98",
                        "content": "you\\'re on the right track if you think you have to do X amount of binary searches\\n\\nU can also sort the arrays since the runtime of sorting and X binary searches is the same\\n\\nNow decide whether or not both arrays should be sorted or just one.\\n\\nOnce you answer that question, ask yourself if the weakest position is success...doesn\\'t that mean all the potions stronger than it is also success\\n\\ngood luck "
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Some edge cases in binary search are frustrating."
                    },
                    {
                        "username": "7_aditi",
                        "content": "I am getting this error: \\nLine 15: Char 46: runtime error: signed integer overflow: 2 * -1094795586 cannot be represented in type \\'int\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:24:46\\n\\nmy code was:\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        sort(potions.begin(),potions.end());\\n        int n=spells.size(), m=potions.size();\\n        vector<int> pair;\\n        int count=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            int left=0,right=m;\\n            int  mid;\\n            while(left<=right)\\n            {\\n               mid=(left+right)/2;\\n               long long prod = spells[i]*potions[mid];\\n               if(prod<success)\\n               left=mid+1;\\n               else\\n               right=mid-1; \\n            }\\n            long long prod = spells[i]*potions[mid];\\n            if(prod<success)\\n            mid=mid+1;\\n            if(mid<m)\\n            pair.push_back(m-mid);\\n            else\\n            pair.push_back(0);\\n        }\\n        return pair;\\n    }\\n};\\n\\nplease can anyone tell me how to resolve it and why m I getting this error?"
                    }
                ]
            },
            {
                "id": 1834821,
                "content": [
                    {
                        "username": "Code_With_Gurnoor_Chhabra",
                        "content": "\\ncan anyone explain why my recursive son got TLE and iterative passed all test cases (recursion uses stack space of log n but what\\'s role in time complexity?)\\nclass Solution {\\npublic:\\n/* int bin_search(vector<int>p,int l,int r,int i,long long s)\\n{\\n    if(l>r)\\n    {\\n        return 0;\\n    }\\n    long long int mid = l+(r-l)/2;\\n    long long cmp = (long long)p[mid]*i;\\n    int ct=0;\\n    if(cmp<s)\\n    {\\n        ct+=bin_search(p,mid+1,r,i,s);\\n    }\\n    else\\n    {\\n        ct+=r-mid+1+bin_search(p,l,mid-1,i,s);\\n    }\\n    return ct;\\n}\\n*/\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        sort(potions.begin(),potions.end());\\n        vector<int> ans;\\n        int l=0;\\n        int r=potions.size()-1;\\n        for(int i=0;i<spells.size();i++)\\n        {\\n            int ct=0;\\n            int l=0;\\n            int r=potions.size()-1;\\n            while(l<=r)\\n            {\\n              long long int mid = l+(r-l)/2;\\n              long long cmp = (long long)potions[mid]*spells[i];\\n              if(cmp<success)\\n              {\\n                  l=mid+1;\\n              }\\n              else\\n              {\\n                  ct+=r-mid+1;\\n                  r=mid-1;\\n              }\\n            }\\n            ans.push_back(ct);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "anish_patro",
                        "content": "55/56 passed\\ncan someone please explain this ?\\n\\n\\nclass Solution {\\npublic:   \\nint mod=1e9+7; \\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        vector<int> v;\\n        int sn=spells.size();\\n        int pn=potions.size();\\n       for(int i=0;i<pn;++i){\\n           if(success%potions[i]!=0)\\n           potions[i]=success/potions[i] +1;\\n           else\\n           potions[i]=success/potions[i];\\n       }\\n       sort(potions.begin(),potions.end());\\n        for(int i=0;i<sn;++i){\\n             long long low=0;\\n             long long high=pn-1;\\n           int ans=-1;\\n            while(low<=high){\\n            int mid=(low+(high-low)/2)%mod;\\n            if(potions[mid]<=spells[i])\\n           { ans=mid%mod;\\n            low=mid+1;}\\n            else\\n            high=mid-1;   \\n        }\\n        v.push_back(ans+1);\\n        }\\n       return v;\\n    }\\n};"
                    },
                    {
                        "username": "llamasheep",
                        "content": "[@shivansh961](/shivansh961) The above code assumes that success/potions[i] fits in int, but it could overflow. I also made a similar mistake"
                    },
                    {
                        "username": "shivansh961",
                        "content": "I made the same mistake, used lower bound instead.\\nDon\\'t know what\\'s the mistake.\\nIf you understood, the please do tell"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Hint</span>\n![](https://leetcode.com/problems/successful-pairs-of-spells-and-potions/Figures/2300/Slide1.PNG)\n![](https://leetcode.com/problems/successful-pairs-of-spells-and-potions/Figures/2300/Slide3.PNG)\n![](https://leetcode.com/problems/successful-pairs-of-spells-and-potions/Figures/2300/Slide4.PNG)"
                    },
                    {
                        "username": "waiyankyaw961999",
                        "content": "[@namandt](/namandt) By sorting the array, I think we can just scan the specific portion instead of validating all the elements. So, saving the amount of time."
                    },
                    {
                        "username": "x-ider",
                        "content": "[@namandt](/namandt) it\\'s an alternative solution without binary search"
                    },
                    {
                        "username": "namandt",
                        "content": "why do we need to sort the spells array?"
                    },
                    {
                        "username": "piyush_mehta22",
                        "content": "bs giving tle at 49th/56 tc.\\uD83E\\uDD28"
                    },
                    {
                        "username": "Applethal",
                        "content": "`class Solution:\\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\\n        return [sum(1 for potion in potions if spell * potion >= success) for spell in spells]`\\n\\nMade it to 51/56"
                    },
                    {
                        "username": "vamshikiranm",
                        "content": "Learning of > 1ll\nTo prevent overflow, you can use the ll suffix to explicitly specify that you want the literals to be treated as long long:\n\n\n ` long long k = spells[i]*1ll*potions[mid];`"
                    },
                    {
                        "username": "reactdevsourav",
                        "content": "Hi everyone I have solved the problem but I have once question:- \\nHere is my current solution which works\\n```\\nvar successfulPairs = function (spells = [], potions = [], success = 0) {\\n  let ans = [];\\n  potions.sort((a, b) => a - b);\\n  for (let i = 0; i < spells.length; i++) {\\n    let left = 0;\\n    let right = potions.length - 1;\\n    let mid;\\n    let validMid = null;\\n    while (left <= right) {\\n      mid = Math.floor((left + right) / 2);\\n     if (potions[mid] * spells[i] >= success) {\\n        validMid = mid;\\n        right = mid - 1;\\n      } else {\\n        left = mid + 1;\\n      }\\n    }\\n    if (validMid !== null) {\\n      ans.push(potions.length - validMid);\\n    } else {\\n      ans.push(0);\\n    }\\n  }\\n\\n  return ans;\\n};\\n```\\nBut  my this solution gives me wrong answer, could anybody explain why?\\n```\\nvar successfulPairs = function (spells = [], potions = [], success = 0) {\\n  let ans = [];\\n  potions.sort((a, b) => a - b);\\n  for (let i = 0; i < spells.length; i++) {\\n    let left = 0;\\n    let right = potions.length - 1;\\n    let mid;\\n    let validMid = null;\\n    while (left <= right) {\\n      mid = Math.floor((left + right) / 2);\\n      if (potions[mid] * spells[i] === success) {\\n        validMid = mid;\\n        break;\\n      } else if (potions[mid] * spells[i] > success) {\\n        validMid = mid;\\n        right = mid - 1;\\n      } else {\\n        left = mid + 1;\\n      }\\n    }\\n    if (validMid !== null) {\\n      ans.push(potions.length - validMid);\\n    } else {\\n      ans.push(0);\\n    }\\n  }\\n\\n  return ans;\\n};\\n\\n```"
                    },
                    {
                        "username": "pyush98",
                        "content": "you\\'re on the right track if you think you have to do X amount of binary searches\\n\\nU can also sort the arrays since the runtime of sorting and X binary searches is the same\\n\\nNow decide whether or not both arrays should be sorted or just one.\\n\\nOnce you answer that question, ask yourself if the weakest position is success...doesn\\'t that mean all the potions stronger than it is also success\\n\\ngood luck "
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Some edge cases in binary search are frustrating."
                    },
                    {
                        "username": "7_aditi",
                        "content": "I am getting this error: \\nLine 15: Char 46: runtime error: signed integer overflow: 2 * -1094795586 cannot be represented in type \\'int\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:24:46\\n\\nmy code was:\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        sort(potions.begin(),potions.end());\\n        int n=spells.size(), m=potions.size();\\n        vector<int> pair;\\n        int count=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            int left=0,right=m;\\n            int  mid;\\n            while(left<=right)\\n            {\\n               mid=(left+right)/2;\\n               long long prod = spells[i]*potions[mid];\\n               if(prod<success)\\n               left=mid+1;\\n               else\\n               right=mid-1; \\n            }\\n            long long prod = spells[i]*potions[mid];\\n            if(prod<success)\\n            mid=mid+1;\\n            if(mid<m)\\n            pair.push_back(m-mid);\\n            else\\n            pair.push_back(0);\\n        }\\n        return pair;\\n    }\\n};\\n\\nplease can anyone tell me how to resolve it and why m I getting this error?"
                    }
                ]
            },
            {
                "id": 1850764,
                "content": [
                    {
                        "username": "Code_With_Gurnoor_Chhabra",
                        "content": "\\ncan anyone explain why my recursive son got TLE and iterative passed all test cases (recursion uses stack space of log n but what\\'s role in time complexity?)\\nclass Solution {\\npublic:\\n/* int bin_search(vector<int>p,int l,int r,int i,long long s)\\n{\\n    if(l>r)\\n    {\\n        return 0;\\n    }\\n    long long int mid = l+(r-l)/2;\\n    long long cmp = (long long)p[mid]*i;\\n    int ct=0;\\n    if(cmp<s)\\n    {\\n        ct+=bin_search(p,mid+1,r,i,s);\\n    }\\n    else\\n    {\\n        ct+=r-mid+1+bin_search(p,l,mid-1,i,s);\\n    }\\n    return ct;\\n}\\n*/\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        sort(potions.begin(),potions.end());\\n        vector<int> ans;\\n        int l=0;\\n        int r=potions.size()-1;\\n        for(int i=0;i<spells.size();i++)\\n        {\\n            int ct=0;\\n            int l=0;\\n            int r=potions.size()-1;\\n            while(l<=r)\\n            {\\n              long long int mid = l+(r-l)/2;\\n              long long cmp = (long long)potions[mid]*spells[i];\\n              if(cmp<success)\\n              {\\n                  l=mid+1;\\n              }\\n              else\\n              {\\n                  ct+=r-mid+1;\\n                  r=mid-1;\\n              }\\n            }\\n            ans.push_back(ct);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "anish_patro",
                        "content": "55/56 passed\\ncan someone please explain this ?\\n\\n\\nclass Solution {\\npublic:   \\nint mod=1e9+7; \\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        vector<int> v;\\n        int sn=spells.size();\\n        int pn=potions.size();\\n       for(int i=0;i<pn;++i){\\n           if(success%potions[i]!=0)\\n           potions[i]=success/potions[i] +1;\\n           else\\n           potions[i]=success/potions[i];\\n       }\\n       sort(potions.begin(),potions.end());\\n        for(int i=0;i<sn;++i){\\n             long long low=0;\\n             long long high=pn-1;\\n           int ans=-1;\\n            while(low<=high){\\n            int mid=(low+(high-low)/2)%mod;\\n            if(potions[mid]<=spells[i])\\n           { ans=mid%mod;\\n            low=mid+1;}\\n            else\\n            high=mid-1;   \\n        }\\n        v.push_back(ans+1);\\n        }\\n       return v;\\n    }\\n};"
                    },
                    {
                        "username": "llamasheep",
                        "content": "[@shivansh961](/shivansh961) The above code assumes that success/potions[i] fits in int, but it could overflow. I also made a similar mistake"
                    },
                    {
                        "username": "shivansh961",
                        "content": "I made the same mistake, used lower bound instead.\\nDon\\'t know what\\'s the mistake.\\nIf you understood, the please do tell"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Hint</span>\n![](https://leetcode.com/problems/successful-pairs-of-spells-and-potions/Figures/2300/Slide1.PNG)\n![](https://leetcode.com/problems/successful-pairs-of-spells-and-potions/Figures/2300/Slide3.PNG)\n![](https://leetcode.com/problems/successful-pairs-of-spells-and-potions/Figures/2300/Slide4.PNG)"
                    },
                    {
                        "username": "waiyankyaw961999",
                        "content": "[@namandt](/namandt) By sorting the array, I think we can just scan the specific portion instead of validating all the elements. So, saving the amount of time."
                    },
                    {
                        "username": "x-ider",
                        "content": "[@namandt](/namandt) it\\'s an alternative solution without binary search"
                    },
                    {
                        "username": "namandt",
                        "content": "why do we need to sort the spells array?"
                    },
                    {
                        "username": "piyush_mehta22",
                        "content": "bs giving tle at 49th/56 tc.\\uD83E\\uDD28"
                    },
                    {
                        "username": "Applethal",
                        "content": "`class Solution:\\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\\n        return [sum(1 for potion in potions if spell * potion >= success) for spell in spells]`\\n\\nMade it to 51/56"
                    },
                    {
                        "username": "vamshikiranm",
                        "content": "Learning of > 1ll\nTo prevent overflow, you can use the ll suffix to explicitly specify that you want the literals to be treated as long long:\n\n\n ` long long k = spells[i]*1ll*potions[mid];`"
                    },
                    {
                        "username": "reactdevsourav",
                        "content": "Hi everyone I have solved the problem but I have once question:- \\nHere is my current solution which works\\n```\\nvar successfulPairs = function (spells = [], potions = [], success = 0) {\\n  let ans = [];\\n  potions.sort((a, b) => a - b);\\n  for (let i = 0; i < spells.length; i++) {\\n    let left = 0;\\n    let right = potions.length - 1;\\n    let mid;\\n    let validMid = null;\\n    while (left <= right) {\\n      mid = Math.floor((left + right) / 2);\\n     if (potions[mid] * spells[i] >= success) {\\n        validMid = mid;\\n        right = mid - 1;\\n      } else {\\n        left = mid + 1;\\n      }\\n    }\\n    if (validMid !== null) {\\n      ans.push(potions.length - validMid);\\n    } else {\\n      ans.push(0);\\n    }\\n  }\\n\\n  return ans;\\n};\\n```\\nBut  my this solution gives me wrong answer, could anybody explain why?\\n```\\nvar successfulPairs = function (spells = [], potions = [], success = 0) {\\n  let ans = [];\\n  potions.sort((a, b) => a - b);\\n  for (let i = 0; i < spells.length; i++) {\\n    let left = 0;\\n    let right = potions.length - 1;\\n    let mid;\\n    let validMid = null;\\n    while (left <= right) {\\n      mid = Math.floor((left + right) / 2);\\n      if (potions[mid] * spells[i] === success) {\\n        validMid = mid;\\n        break;\\n      } else if (potions[mid] * spells[i] > success) {\\n        validMid = mid;\\n        right = mid - 1;\\n      } else {\\n        left = mid + 1;\\n      }\\n    }\\n    if (validMid !== null) {\\n      ans.push(potions.length - validMid);\\n    } else {\\n      ans.push(0);\\n    }\\n  }\\n\\n  return ans;\\n};\\n\\n```"
                    },
                    {
                        "username": "pyush98",
                        "content": "you\\'re on the right track if you think you have to do X amount of binary searches\\n\\nU can also sort the arrays since the runtime of sorting and X binary searches is the same\\n\\nNow decide whether or not both arrays should be sorted or just one.\\n\\nOnce you answer that question, ask yourself if the weakest position is success...doesn\\'t that mean all the potions stronger than it is also success\\n\\ngood luck "
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Some edge cases in binary search are frustrating."
                    },
                    {
                        "username": "7_aditi",
                        "content": "I am getting this error: \\nLine 15: Char 46: runtime error: signed integer overflow: 2 * -1094795586 cannot be represented in type \\'int\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:24:46\\n\\nmy code was:\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        sort(potions.begin(),potions.end());\\n        int n=spells.size(), m=potions.size();\\n        vector<int> pair;\\n        int count=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            int left=0,right=m;\\n            int  mid;\\n            while(left<=right)\\n            {\\n               mid=(left+right)/2;\\n               long long prod = spells[i]*potions[mid];\\n               if(prod<success)\\n               left=mid+1;\\n               else\\n               right=mid-1; \\n            }\\n            long long prod = spells[i]*potions[mid];\\n            if(prod<success)\\n            mid=mid+1;\\n            if(mid<m)\\n            pair.push_back(m-mid);\\n            else\\n            pair.push_back(0);\\n        }\\n        return pair;\\n    }\\n};\\n\\nplease can anyone tell me how to resolve it and why m I getting this error?"
                    }
                ]
            },
            {
                "id": 2062725,
                "content": [
                    {
                        "username": "Code_With_Gurnoor_Chhabra",
                        "content": "\\ncan anyone explain why my recursive son got TLE and iterative passed all test cases (recursion uses stack space of log n but what\\'s role in time complexity?)\\nclass Solution {\\npublic:\\n/* int bin_search(vector<int>p,int l,int r,int i,long long s)\\n{\\n    if(l>r)\\n    {\\n        return 0;\\n    }\\n    long long int mid = l+(r-l)/2;\\n    long long cmp = (long long)p[mid]*i;\\n    int ct=0;\\n    if(cmp<s)\\n    {\\n        ct+=bin_search(p,mid+1,r,i,s);\\n    }\\n    else\\n    {\\n        ct+=r-mid+1+bin_search(p,l,mid-1,i,s);\\n    }\\n    return ct;\\n}\\n*/\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        sort(potions.begin(),potions.end());\\n        vector<int> ans;\\n        int l=0;\\n        int r=potions.size()-1;\\n        for(int i=0;i<spells.size();i++)\\n        {\\n            int ct=0;\\n            int l=0;\\n            int r=potions.size()-1;\\n            while(l<=r)\\n            {\\n              long long int mid = l+(r-l)/2;\\n              long long cmp = (long long)potions[mid]*spells[i];\\n              if(cmp<success)\\n              {\\n                  l=mid+1;\\n              }\\n              else\\n              {\\n                  ct+=r-mid+1;\\n                  r=mid-1;\\n              }\\n            }\\n            ans.push_back(ct);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "anish_patro",
                        "content": "55/56 passed\\ncan someone please explain this ?\\n\\n\\nclass Solution {\\npublic:   \\nint mod=1e9+7; \\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        vector<int> v;\\n        int sn=spells.size();\\n        int pn=potions.size();\\n       for(int i=0;i<pn;++i){\\n           if(success%potions[i]!=0)\\n           potions[i]=success/potions[i] +1;\\n           else\\n           potions[i]=success/potions[i];\\n       }\\n       sort(potions.begin(),potions.end());\\n        for(int i=0;i<sn;++i){\\n             long long low=0;\\n             long long high=pn-1;\\n           int ans=-1;\\n            while(low<=high){\\n            int mid=(low+(high-low)/2)%mod;\\n            if(potions[mid]<=spells[i])\\n           { ans=mid%mod;\\n            low=mid+1;}\\n            else\\n            high=mid-1;   \\n        }\\n        v.push_back(ans+1);\\n        }\\n       return v;\\n    }\\n};"
                    },
                    {
                        "username": "llamasheep",
                        "content": "[@shivansh961](/shivansh961) The above code assumes that success/potions[i] fits in int, but it could overflow. I also made a similar mistake"
                    },
                    {
                        "username": "shivansh961",
                        "content": "I made the same mistake, used lower bound instead.\\nDon\\'t know what\\'s the mistake.\\nIf you understood, the please do tell"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Hint</span>\n![](https://leetcode.com/problems/successful-pairs-of-spells-and-potions/Figures/2300/Slide1.PNG)\n![](https://leetcode.com/problems/successful-pairs-of-spells-and-potions/Figures/2300/Slide3.PNG)\n![](https://leetcode.com/problems/successful-pairs-of-spells-and-potions/Figures/2300/Slide4.PNG)"
                    },
                    {
                        "username": "waiyankyaw961999",
                        "content": "[@namandt](/namandt) By sorting the array, I think we can just scan the specific portion instead of validating all the elements. So, saving the amount of time."
                    },
                    {
                        "username": "x-ider",
                        "content": "[@namandt](/namandt) it\\'s an alternative solution without binary search"
                    },
                    {
                        "username": "namandt",
                        "content": "why do we need to sort the spells array?"
                    },
                    {
                        "username": "piyush_mehta22",
                        "content": "bs giving tle at 49th/56 tc.\\uD83E\\uDD28"
                    },
                    {
                        "username": "Applethal",
                        "content": "`class Solution:\\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\\n        return [sum(1 for potion in potions if spell * potion >= success) for spell in spells]`\\n\\nMade it to 51/56"
                    },
                    {
                        "username": "vamshikiranm",
                        "content": "Learning of > 1ll\nTo prevent overflow, you can use the ll suffix to explicitly specify that you want the literals to be treated as long long:\n\n\n ` long long k = spells[i]*1ll*potions[mid];`"
                    },
                    {
                        "username": "reactdevsourav",
                        "content": "Hi everyone I have solved the problem but I have once question:- \\nHere is my current solution which works\\n```\\nvar successfulPairs = function (spells = [], potions = [], success = 0) {\\n  let ans = [];\\n  potions.sort((a, b) => a - b);\\n  for (let i = 0; i < spells.length; i++) {\\n    let left = 0;\\n    let right = potions.length - 1;\\n    let mid;\\n    let validMid = null;\\n    while (left <= right) {\\n      mid = Math.floor((left + right) / 2);\\n     if (potions[mid] * spells[i] >= success) {\\n        validMid = mid;\\n        right = mid - 1;\\n      } else {\\n        left = mid + 1;\\n      }\\n    }\\n    if (validMid !== null) {\\n      ans.push(potions.length - validMid);\\n    } else {\\n      ans.push(0);\\n    }\\n  }\\n\\n  return ans;\\n};\\n```\\nBut  my this solution gives me wrong answer, could anybody explain why?\\n```\\nvar successfulPairs = function (spells = [], potions = [], success = 0) {\\n  let ans = [];\\n  potions.sort((a, b) => a - b);\\n  for (let i = 0; i < spells.length; i++) {\\n    let left = 0;\\n    let right = potions.length - 1;\\n    let mid;\\n    let validMid = null;\\n    while (left <= right) {\\n      mid = Math.floor((left + right) / 2);\\n      if (potions[mid] * spells[i] === success) {\\n        validMid = mid;\\n        break;\\n      } else if (potions[mid] * spells[i] > success) {\\n        validMid = mid;\\n        right = mid - 1;\\n      } else {\\n        left = mid + 1;\\n      }\\n    }\\n    if (validMid !== null) {\\n      ans.push(potions.length - validMid);\\n    } else {\\n      ans.push(0);\\n    }\\n  }\\n\\n  return ans;\\n};\\n\\n```"
                    },
                    {
                        "username": "pyush98",
                        "content": "you\\'re on the right track if you think you have to do X amount of binary searches\\n\\nU can also sort the arrays since the runtime of sorting and X binary searches is the same\\n\\nNow decide whether or not both arrays should be sorted or just one.\\n\\nOnce you answer that question, ask yourself if the weakest position is success...doesn\\'t that mean all the potions stronger than it is also success\\n\\ngood luck "
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Some edge cases in binary search are frustrating."
                    },
                    {
                        "username": "7_aditi",
                        "content": "I am getting this error: \\nLine 15: Char 46: runtime error: signed integer overflow: 2 * -1094795586 cannot be represented in type \\'int\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:24:46\\n\\nmy code was:\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        sort(potions.begin(),potions.end());\\n        int n=spells.size(), m=potions.size();\\n        vector<int> pair;\\n        int count=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            int left=0,right=m;\\n            int  mid;\\n            while(left<=right)\\n            {\\n               mid=(left+right)/2;\\n               long long prod = spells[i]*potions[mid];\\n               if(prod<success)\\n               left=mid+1;\\n               else\\n               right=mid-1; \\n            }\\n            long long prod = spells[i]*potions[mid];\\n            if(prod<success)\\n            mid=mid+1;\\n            if(mid<m)\\n            pair.push_back(m-mid);\\n            else\\n            pair.push_back(0);\\n        }\\n        return pair;\\n    }\\n};\\n\\nplease can anyone tell me how to resolve it and why m I getting this error?"
                    }
                ]
            },
            {
                "id": 2053397,
                "content": [
                    {
                        "username": "Code_With_Gurnoor_Chhabra",
                        "content": "\\ncan anyone explain why my recursive son got TLE and iterative passed all test cases (recursion uses stack space of log n but what\\'s role in time complexity?)\\nclass Solution {\\npublic:\\n/* int bin_search(vector<int>p,int l,int r,int i,long long s)\\n{\\n    if(l>r)\\n    {\\n        return 0;\\n    }\\n    long long int mid = l+(r-l)/2;\\n    long long cmp = (long long)p[mid]*i;\\n    int ct=0;\\n    if(cmp<s)\\n    {\\n        ct+=bin_search(p,mid+1,r,i,s);\\n    }\\n    else\\n    {\\n        ct+=r-mid+1+bin_search(p,l,mid-1,i,s);\\n    }\\n    return ct;\\n}\\n*/\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        sort(potions.begin(),potions.end());\\n        vector<int> ans;\\n        int l=0;\\n        int r=potions.size()-1;\\n        for(int i=0;i<spells.size();i++)\\n        {\\n            int ct=0;\\n            int l=0;\\n            int r=potions.size()-1;\\n            while(l<=r)\\n            {\\n              long long int mid = l+(r-l)/2;\\n              long long cmp = (long long)potions[mid]*spells[i];\\n              if(cmp<success)\\n              {\\n                  l=mid+1;\\n              }\\n              else\\n              {\\n                  ct+=r-mid+1;\\n                  r=mid-1;\\n              }\\n            }\\n            ans.push_back(ct);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "anish_patro",
                        "content": "55/56 passed\\ncan someone please explain this ?\\n\\n\\nclass Solution {\\npublic:   \\nint mod=1e9+7; \\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        vector<int> v;\\n        int sn=spells.size();\\n        int pn=potions.size();\\n       for(int i=0;i<pn;++i){\\n           if(success%potions[i]!=0)\\n           potions[i]=success/potions[i] +1;\\n           else\\n           potions[i]=success/potions[i];\\n       }\\n       sort(potions.begin(),potions.end());\\n        for(int i=0;i<sn;++i){\\n             long long low=0;\\n             long long high=pn-1;\\n           int ans=-1;\\n            while(low<=high){\\n            int mid=(low+(high-low)/2)%mod;\\n            if(potions[mid]<=spells[i])\\n           { ans=mid%mod;\\n            low=mid+1;}\\n            else\\n            high=mid-1;   \\n        }\\n        v.push_back(ans+1);\\n        }\\n       return v;\\n    }\\n};"
                    },
                    {
                        "username": "llamasheep",
                        "content": "[@shivansh961](/shivansh961) The above code assumes that success/potions[i] fits in int, but it could overflow. I also made a similar mistake"
                    },
                    {
                        "username": "shivansh961",
                        "content": "I made the same mistake, used lower bound instead.\\nDon\\'t know what\\'s the mistake.\\nIf you understood, the please do tell"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Hint</span>\n![](https://leetcode.com/problems/successful-pairs-of-spells-and-potions/Figures/2300/Slide1.PNG)\n![](https://leetcode.com/problems/successful-pairs-of-spells-and-potions/Figures/2300/Slide3.PNG)\n![](https://leetcode.com/problems/successful-pairs-of-spells-and-potions/Figures/2300/Slide4.PNG)"
                    },
                    {
                        "username": "waiyankyaw961999",
                        "content": "[@namandt](/namandt) By sorting the array, I think we can just scan the specific portion instead of validating all the elements. So, saving the amount of time."
                    },
                    {
                        "username": "x-ider",
                        "content": "[@namandt](/namandt) it\\'s an alternative solution without binary search"
                    },
                    {
                        "username": "namandt",
                        "content": "why do we need to sort the spells array?"
                    },
                    {
                        "username": "piyush_mehta22",
                        "content": "bs giving tle at 49th/56 tc.\\uD83E\\uDD28"
                    },
                    {
                        "username": "Applethal",
                        "content": "`class Solution:\\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\\n        return [sum(1 for potion in potions if spell * potion >= success) for spell in spells]`\\n\\nMade it to 51/56"
                    },
                    {
                        "username": "vamshikiranm",
                        "content": "Learning of > 1ll\nTo prevent overflow, you can use the ll suffix to explicitly specify that you want the literals to be treated as long long:\n\n\n ` long long k = spells[i]*1ll*potions[mid];`"
                    },
                    {
                        "username": "reactdevsourav",
                        "content": "Hi everyone I have solved the problem but I have once question:- \\nHere is my current solution which works\\n```\\nvar successfulPairs = function (spells = [], potions = [], success = 0) {\\n  let ans = [];\\n  potions.sort((a, b) => a - b);\\n  for (let i = 0; i < spells.length; i++) {\\n    let left = 0;\\n    let right = potions.length - 1;\\n    let mid;\\n    let validMid = null;\\n    while (left <= right) {\\n      mid = Math.floor((left + right) / 2);\\n     if (potions[mid] * spells[i] >= success) {\\n        validMid = mid;\\n        right = mid - 1;\\n      } else {\\n        left = mid + 1;\\n      }\\n    }\\n    if (validMid !== null) {\\n      ans.push(potions.length - validMid);\\n    } else {\\n      ans.push(0);\\n    }\\n  }\\n\\n  return ans;\\n};\\n```\\nBut  my this solution gives me wrong answer, could anybody explain why?\\n```\\nvar successfulPairs = function (spells = [], potions = [], success = 0) {\\n  let ans = [];\\n  potions.sort((a, b) => a - b);\\n  for (let i = 0; i < spells.length; i++) {\\n    let left = 0;\\n    let right = potions.length - 1;\\n    let mid;\\n    let validMid = null;\\n    while (left <= right) {\\n      mid = Math.floor((left + right) / 2);\\n      if (potions[mid] * spells[i] === success) {\\n        validMid = mid;\\n        break;\\n      } else if (potions[mid] * spells[i] > success) {\\n        validMid = mid;\\n        right = mid - 1;\\n      } else {\\n        left = mid + 1;\\n      }\\n    }\\n    if (validMid !== null) {\\n      ans.push(potions.length - validMid);\\n    } else {\\n      ans.push(0);\\n    }\\n  }\\n\\n  return ans;\\n};\\n\\n```"
                    },
                    {
                        "username": "pyush98",
                        "content": "you\\'re on the right track if you think you have to do X amount of binary searches\\n\\nU can also sort the arrays since the runtime of sorting and X binary searches is the same\\n\\nNow decide whether or not both arrays should be sorted or just one.\\n\\nOnce you answer that question, ask yourself if the weakest position is success...doesn\\'t that mean all the potions stronger than it is also success\\n\\ngood luck "
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Some edge cases in binary search are frustrating."
                    },
                    {
                        "username": "7_aditi",
                        "content": "I am getting this error: \\nLine 15: Char 46: runtime error: signed integer overflow: 2 * -1094795586 cannot be represented in type \\'int\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:24:46\\n\\nmy code was:\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        sort(potions.begin(),potions.end());\\n        int n=spells.size(), m=potions.size();\\n        vector<int> pair;\\n        int count=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            int left=0,right=m;\\n            int  mid;\\n            while(left<=right)\\n            {\\n               mid=(left+right)/2;\\n               long long prod = spells[i]*potions[mid];\\n               if(prod<success)\\n               left=mid+1;\\n               else\\n               right=mid-1; \\n            }\\n            long long prod = spells[i]*potions[mid];\\n            if(prod<success)\\n            mid=mid+1;\\n            if(mid<m)\\n            pair.push_back(m-mid);\\n            else\\n            pair.push_back(0);\\n        }\\n        return pair;\\n    }\\n};\\n\\nplease can anyone tell me how to resolve it and why m I getting this error?"
                    }
                ]
            },
            {
                "id": 2036657,
                "content": [
                    {
                        "username": "Code_With_Gurnoor_Chhabra",
                        "content": "\\ncan anyone explain why my recursive son got TLE and iterative passed all test cases (recursion uses stack space of log n but what\\'s role in time complexity?)\\nclass Solution {\\npublic:\\n/* int bin_search(vector<int>p,int l,int r,int i,long long s)\\n{\\n    if(l>r)\\n    {\\n        return 0;\\n    }\\n    long long int mid = l+(r-l)/2;\\n    long long cmp = (long long)p[mid]*i;\\n    int ct=0;\\n    if(cmp<s)\\n    {\\n        ct+=bin_search(p,mid+1,r,i,s);\\n    }\\n    else\\n    {\\n        ct+=r-mid+1+bin_search(p,l,mid-1,i,s);\\n    }\\n    return ct;\\n}\\n*/\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        sort(potions.begin(),potions.end());\\n        vector<int> ans;\\n        int l=0;\\n        int r=potions.size()-1;\\n        for(int i=0;i<spells.size();i++)\\n        {\\n            int ct=0;\\n            int l=0;\\n            int r=potions.size()-1;\\n            while(l<=r)\\n            {\\n              long long int mid = l+(r-l)/2;\\n              long long cmp = (long long)potions[mid]*spells[i];\\n              if(cmp<success)\\n              {\\n                  l=mid+1;\\n              }\\n              else\\n              {\\n                  ct+=r-mid+1;\\n                  r=mid-1;\\n              }\\n            }\\n            ans.push_back(ct);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "anish_patro",
                        "content": "55/56 passed\\ncan someone please explain this ?\\n\\n\\nclass Solution {\\npublic:   \\nint mod=1e9+7; \\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        vector<int> v;\\n        int sn=spells.size();\\n        int pn=potions.size();\\n       for(int i=0;i<pn;++i){\\n           if(success%potions[i]!=0)\\n           potions[i]=success/potions[i] +1;\\n           else\\n           potions[i]=success/potions[i];\\n       }\\n       sort(potions.begin(),potions.end());\\n        for(int i=0;i<sn;++i){\\n             long long low=0;\\n             long long high=pn-1;\\n           int ans=-1;\\n            while(low<=high){\\n            int mid=(low+(high-low)/2)%mod;\\n            if(potions[mid]<=spells[i])\\n           { ans=mid%mod;\\n            low=mid+1;}\\n            else\\n            high=mid-1;   \\n        }\\n        v.push_back(ans+1);\\n        }\\n       return v;\\n    }\\n};"
                    },
                    {
                        "username": "llamasheep",
                        "content": "[@shivansh961](/shivansh961) The above code assumes that success/potions[i] fits in int, but it could overflow. I also made a similar mistake"
                    },
                    {
                        "username": "shivansh961",
                        "content": "I made the same mistake, used lower bound instead.\\nDon\\'t know what\\'s the mistake.\\nIf you understood, the please do tell"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Hint</span>\n![](https://leetcode.com/problems/successful-pairs-of-spells-and-potions/Figures/2300/Slide1.PNG)\n![](https://leetcode.com/problems/successful-pairs-of-spells-and-potions/Figures/2300/Slide3.PNG)\n![](https://leetcode.com/problems/successful-pairs-of-spells-and-potions/Figures/2300/Slide4.PNG)"
                    },
                    {
                        "username": "waiyankyaw961999",
                        "content": "[@namandt](/namandt) By sorting the array, I think we can just scan the specific portion instead of validating all the elements. So, saving the amount of time."
                    },
                    {
                        "username": "x-ider",
                        "content": "[@namandt](/namandt) it\\'s an alternative solution without binary search"
                    },
                    {
                        "username": "namandt",
                        "content": "why do we need to sort the spells array?"
                    },
                    {
                        "username": "piyush_mehta22",
                        "content": "bs giving tle at 49th/56 tc.\\uD83E\\uDD28"
                    },
                    {
                        "username": "Applethal",
                        "content": "`class Solution:\\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\\n        return [sum(1 for potion in potions if spell * potion >= success) for spell in spells]`\\n\\nMade it to 51/56"
                    },
                    {
                        "username": "vamshikiranm",
                        "content": "Learning of > 1ll\nTo prevent overflow, you can use the ll suffix to explicitly specify that you want the literals to be treated as long long:\n\n\n ` long long k = spells[i]*1ll*potions[mid];`"
                    },
                    {
                        "username": "reactdevsourav",
                        "content": "Hi everyone I have solved the problem but I have once question:- \\nHere is my current solution which works\\n```\\nvar successfulPairs = function (spells = [], potions = [], success = 0) {\\n  let ans = [];\\n  potions.sort((a, b) => a - b);\\n  for (let i = 0; i < spells.length; i++) {\\n    let left = 0;\\n    let right = potions.length - 1;\\n    let mid;\\n    let validMid = null;\\n    while (left <= right) {\\n      mid = Math.floor((left + right) / 2);\\n     if (potions[mid] * spells[i] >= success) {\\n        validMid = mid;\\n        right = mid - 1;\\n      } else {\\n        left = mid + 1;\\n      }\\n    }\\n    if (validMid !== null) {\\n      ans.push(potions.length - validMid);\\n    } else {\\n      ans.push(0);\\n    }\\n  }\\n\\n  return ans;\\n};\\n```\\nBut  my this solution gives me wrong answer, could anybody explain why?\\n```\\nvar successfulPairs = function (spells = [], potions = [], success = 0) {\\n  let ans = [];\\n  potions.sort((a, b) => a - b);\\n  for (let i = 0; i < spells.length; i++) {\\n    let left = 0;\\n    let right = potions.length - 1;\\n    let mid;\\n    let validMid = null;\\n    while (left <= right) {\\n      mid = Math.floor((left + right) / 2);\\n      if (potions[mid] * spells[i] === success) {\\n        validMid = mid;\\n        break;\\n      } else if (potions[mid] * spells[i] > success) {\\n        validMid = mid;\\n        right = mid - 1;\\n      } else {\\n        left = mid + 1;\\n      }\\n    }\\n    if (validMid !== null) {\\n      ans.push(potions.length - validMid);\\n    } else {\\n      ans.push(0);\\n    }\\n  }\\n\\n  return ans;\\n};\\n\\n```"
                    },
                    {
                        "username": "pyush98",
                        "content": "you\\'re on the right track if you think you have to do X amount of binary searches\\n\\nU can also sort the arrays since the runtime of sorting and X binary searches is the same\\n\\nNow decide whether or not both arrays should be sorted or just one.\\n\\nOnce you answer that question, ask yourself if the weakest position is success...doesn\\'t that mean all the potions stronger than it is also success\\n\\ngood luck "
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Some edge cases in binary search are frustrating."
                    },
                    {
                        "username": "7_aditi",
                        "content": "I am getting this error: \\nLine 15: Char 46: runtime error: signed integer overflow: 2 * -1094795586 cannot be represented in type \\'int\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:24:46\\n\\nmy code was:\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        sort(potions.begin(),potions.end());\\n        int n=spells.size(), m=potions.size();\\n        vector<int> pair;\\n        int count=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            int left=0,right=m;\\n            int  mid;\\n            while(left<=right)\\n            {\\n               mid=(left+right)/2;\\n               long long prod = spells[i]*potions[mid];\\n               if(prod<success)\\n               left=mid+1;\\n               else\\n               right=mid-1; \\n            }\\n            long long prod = spells[i]*potions[mid];\\n            if(prod<success)\\n            mid=mid+1;\\n            if(mid<m)\\n            pair.push_back(m-mid);\\n            else\\n            pair.push_back(0);\\n        }\\n        return pair;\\n    }\\n};\\n\\nplease can anyone tell me how to resolve it and why m I getting this error?"
                    }
                ]
            },
            {
                "id": 2024872,
                "content": [
                    {
                        "username": "Code_With_Gurnoor_Chhabra",
                        "content": "\\ncan anyone explain why my recursive son got TLE and iterative passed all test cases (recursion uses stack space of log n but what\\'s role in time complexity?)\\nclass Solution {\\npublic:\\n/* int bin_search(vector<int>p,int l,int r,int i,long long s)\\n{\\n    if(l>r)\\n    {\\n        return 0;\\n    }\\n    long long int mid = l+(r-l)/2;\\n    long long cmp = (long long)p[mid]*i;\\n    int ct=0;\\n    if(cmp<s)\\n    {\\n        ct+=bin_search(p,mid+1,r,i,s);\\n    }\\n    else\\n    {\\n        ct+=r-mid+1+bin_search(p,l,mid-1,i,s);\\n    }\\n    return ct;\\n}\\n*/\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        sort(potions.begin(),potions.end());\\n        vector<int> ans;\\n        int l=0;\\n        int r=potions.size()-1;\\n        for(int i=0;i<spells.size();i++)\\n        {\\n            int ct=0;\\n            int l=0;\\n            int r=potions.size()-1;\\n            while(l<=r)\\n            {\\n              long long int mid = l+(r-l)/2;\\n              long long cmp = (long long)potions[mid]*spells[i];\\n              if(cmp<success)\\n              {\\n                  l=mid+1;\\n              }\\n              else\\n              {\\n                  ct+=r-mid+1;\\n                  r=mid-1;\\n              }\\n            }\\n            ans.push_back(ct);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "anish_patro",
                        "content": "55/56 passed\\ncan someone please explain this ?\\n\\n\\nclass Solution {\\npublic:   \\nint mod=1e9+7; \\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        vector<int> v;\\n        int sn=spells.size();\\n        int pn=potions.size();\\n       for(int i=0;i<pn;++i){\\n           if(success%potions[i]!=0)\\n           potions[i]=success/potions[i] +1;\\n           else\\n           potions[i]=success/potions[i];\\n       }\\n       sort(potions.begin(),potions.end());\\n        for(int i=0;i<sn;++i){\\n             long long low=0;\\n             long long high=pn-1;\\n           int ans=-1;\\n            while(low<=high){\\n            int mid=(low+(high-low)/2)%mod;\\n            if(potions[mid]<=spells[i])\\n           { ans=mid%mod;\\n            low=mid+1;}\\n            else\\n            high=mid-1;   \\n        }\\n        v.push_back(ans+1);\\n        }\\n       return v;\\n    }\\n};"
                    },
                    {
                        "username": "llamasheep",
                        "content": "[@shivansh961](/shivansh961) The above code assumes that success/potions[i] fits in int, but it could overflow. I also made a similar mistake"
                    },
                    {
                        "username": "shivansh961",
                        "content": "I made the same mistake, used lower bound instead.\\nDon\\'t know what\\'s the mistake.\\nIf you understood, the please do tell"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Hint</span>\n![](https://leetcode.com/problems/successful-pairs-of-spells-and-potions/Figures/2300/Slide1.PNG)\n![](https://leetcode.com/problems/successful-pairs-of-spells-and-potions/Figures/2300/Slide3.PNG)\n![](https://leetcode.com/problems/successful-pairs-of-spells-and-potions/Figures/2300/Slide4.PNG)"
                    },
                    {
                        "username": "waiyankyaw961999",
                        "content": "[@namandt](/namandt) By sorting the array, I think we can just scan the specific portion instead of validating all the elements. So, saving the amount of time."
                    },
                    {
                        "username": "x-ider",
                        "content": "[@namandt](/namandt) it\\'s an alternative solution without binary search"
                    },
                    {
                        "username": "namandt",
                        "content": "why do we need to sort the spells array?"
                    },
                    {
                        "username": "piyush_mehta22",
                        "content": "bs giving tle at 49th/56 tc.\\uD83E\\uDD28"
                    },
                    {
                        "username": "Applethal",
                        "content": "`class Solution:\\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\\n        return [sum(1 for potion in potions if spell * potion >= success) for spell in spells]`\\n\\nMade it to 51/56"
                    },
                    {
                        "username": "vamshikiranm",
                        "content": "Learning of > 1ll\nTo prevent overflow, you can use the ll suffix to explicitly specify that you want the literals to be treated as long long:\n\n\n ` long long k = spells[i]*1ll*potions[mid];`"
                    },
                    {
                        "username": "reactdevsourav",
                        "content": "Hi everyone I have solved the problem but I have once question:- \\nHere is my current solution which works\\n```\\nvar successfulPairs = function (spells = [], potions = [], success = 0) {\\n  let ans = [];\\n  potions.sort((a, b) => a - b);\\n  for (let i = 0; i < spells.length; i++) {\\n    let left = 0;\\n    let right = potions.length - 1;\\n    let mid;\\n    let validMid = null;\\n    while (left <= right) {\\n      mid = Math.floor((left + right) / 2);\\n     if (potions[mid] * spells[i] >= success) {\\n        validMid = mid;\\n        right = mid - 1;\\n      } else {\\n        left = mid + 1;\\n      }\\n    }\\n    if (validMid !== null) {\\n      ans.push(potions.length - validMid);\\n    } else {\\n      ans.push(0);\\n    }\\n  }\\n\\n  return ans;\\n};\\n```\\nBut  my this solution gives me wrong answer, could anybody explain why?\\n```\\nvar successfulPairs = function (spells = [], potions = [], success = 0) {\\n  let ans = [];\\n  potions.sort((a, b) => a - b);\\n  for (let i = 0; i < spells.length; i++) {\\n    let left = 0;\\n    let right = potions.length - 1;\\n    let mid;\\n    let validMid = null;\\n    while (left <= right) {\\n      mid = Math.floor((left + right) / 2);\\n      if (potions[mid] * spells[i] === success) {\\n        validMid = mid;\\n        break;\\n      } else if (potions[mid] * spells[i] > success) {\\n        validMid = mid;\\n        right = mid - 1;\\n      } else {\\n        left = mid + 1;\\n      }\\n    }\\n    if (validMid !== null) {\\n      ans.push(potions.length - validMid);\\n    } else {\\n      ans.push(0);\\n    }\\n  }\\n\\n  return ans;\\n};\\n\\n```"
                    },
                    {
                        "username": "pyush98",
                        "content": "you\\'re on the right track if you think you have to do X amount of binary searches\\n\\nU can also sort the arrays since the runtime of sorting and X binary searches is the same\\n\\nNow decide whether or not both arrays should be sorted or just one.\\n\\nOnce you answer that question, ask yourself if the weakest position is success...doesn\\'t that mean all the potions stronger than it is also success\\n\\ngood luck "
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Some edge cases in binary search are frustrating."
                    },
                    {
                        "username": "7_aditi",
                        "content": "I am getting this error: \\nLine 15: Char 46: runtime error: signed integer overflow: 2 * -1094795586 cannot be represented in type \\'int\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:24:46\\n\\nmy code was:\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        sort(potions.begin(),potions.end());\\n        int n=spells.size(), m=potions.size();\\n        vector<int> pair;\\n        int count=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            int left=0,right=m;\\n            int  mid;\\n            while(left<=right)\\n            {\\n               mid=(left+right)/2;\\n               long long prod = spells[i]*potions[mid];\\n               if(prod<success)\\n               left=mid+1;\\n               else\\n               right=mid-1; \\n            }\\n            long long prod = spells[i]*potions[mid];\\n            if(prod<success)\\n            mid=mid+1;\\n            if(mid<m)\\n            pair.push_back(m-mid);\\n            else\\n            pair.push_back(0);\\n        }\\n        return pair;\\n    }\\n};\\n\\nplease can anyone tell me how to resolve it and why m I getting this error?"
                    }
                ]
            },
            {
                "id": 1943749,
                "content": [
                    {
                        "username": "Code_With_Gurnoor_Chhabra",
                        "content": "\\ncan anyone explain why my recursive son got TLE and iterative passed all test cases (recursion uses stack space of log n but what\\'s role in time complexity?)\\nclass Solution {\\npublic:\\n/* int bin_search(vector<int>p,int l,int r,int i,long long s)\\n{\\n    if(l>r)\\n    {\\n        return 0;\\n    }\\n    long long int mid = l+(r-l)/2;\\n    long long cmp = (long long)p[mid]*i;\\n    int ct=0;\\n    if(cmp<s)\\n    {\\n        ct+=bin_search(p,mid+1,r,i,s);\\n    }\\n    else\\n    {\\n        ct+=r-mid+1+bin_search(p,l,mid-1,i,s);\\n    }\\n    return ct;\\n}\\n*/\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        sort(potions.begin(),potions.end());\\n        vector<int> ans;\\n        int l=0;\\n        int r=potions.size()-1;\\n        for(int i=0;i<spells.size();i++)\\n        {\\n            int ct=0;\\n            int l=0;\\n            int r=potions.size()-1;\\n            while(l<=r)\\n            {\\n              long long int mid = l+(r-l)/2;\\n              long long cmp = (long long)potions[mid]*spells[i];\\n              if(cmp<success)\\n              {\\n                  l=mid+1;\\n              }\\n              else\\n              {\\n                  ct+=r-mid+1;\\n                  r=mid-1;\\n              }\\n            }\\n            ans.push_back(ct);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "anish_patro",
                        "content": "55/56 passed\\ncan someone please explain this ?\\n\\n\\nclass Solution {\\npublic:   \\nint mod=1e9+7; \\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        vector<int> v;\\n        int sn=spells.size();\\n        int pn=potions.size();\\n       for(int i=0;i<pn;++i){\\n           if(success%potions[i]!=0)\\n           potions[i]=success/potions[i] +1;\\n           else\\n           potions[i]=success/potions[i];\\n       }\\n       sort(potions.begin(),potions.end());\\n        for(int i=0;i<sn;++i){\\n             long long low=0;\\n             long long high=pn-1;\\n           int ans=-1;\\n            while(low<=high){\\n            int mid=(low+(high-low)/2)%mod;\\n            if(potions[mid]<=spells[i])\\n           { ans=mid%mod;\\n            low=mid+1;}\\n            else\\n            high=mid-1;   \\n        }\\n        v.push_back(ans+1);\\n        }\\n       return v;\\n    }\\n};"
                    },
                    {
                        "username": "llamasheep",
                        "content": "[@shivansh961](/shivansh961) The above code assumes that success/potions[i] fits in int, but it could overflow. I also made a similar mistake"
                    },
                    {
                        "username": "shivansh961",
                        "content": "I made the same mistake, used lower bound instead.\\nDon\\'t know what\\'s the mistake.\\nIf you understood, the please do tell"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Hint</span>\n![](https://leetcode.com/problems/successful-pairs-of-spells-and-potions/Figures/2300/Slide1.PNG)\n![](https://leetcode.com/problems/successful-pairs-of-spells-and-potions/Figures/2300/Slide3.PNG)\n![](https://leetcode.com/problems/successful-pairs-of-spells-and-potions/Figures/2300/Slide4.PNG)"
                    },
                    {
                        "username": "waiyankyaw961999",
                        "content": "[@namandt](/namandt) By sorting the array, I think we can just scan the specific portion instead of validating all the elements. So, saving the amount of time."
                    },
                    {
                        "username": "x-ider",
                        "content": "[@namandt](/namandt) it\\'s an alternative solution without binary search"
                    },
                    {
                        "username": "namandt",
                        "content": "why do we need to sort the spells array?"
                    },
                    {
                        "username": "piyush_mehta22",
                        "content": "bs giving tle at 49th/56 tc.\\uD83E\\uDD28"
                    },
                    {
                        "username": "Applethal",
                        "content": "`class Solution:\\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\\n        return [sum(1 for potion in potions if spell * potion >= success) for spell in spells]`\\n\\nMade it to 51/56"
                    },
                    {
                        "username": "vamshikiranm",
                        "content": "Learning of > 1ll\nTo prevent overflow, you can use the ll suffix to explicitly specify that you want the literals to be treated as long long:\n\n\n ` long long k = spells[i]*1ll*potions[mid];`"
                    },
                    {
                        "username": "reactdevsourav",
                        "content": "Hi everyone I have solved the problem but I have once question:- \\nHere is my current solution which works\\n```\\nvar successfulPairs = function (spells = [], potions = [], success = 0) {\\n  let ans = [];\\n  potions.sort((a, b) => a - b);\\n  for (let i = 0; i < spells.length; i++) {\\n    let left = 0;\\n    let right = potions.length - 1;\\n    let mid;\\n    let validMid = null;\\n    while (left <= right) {\\n      mid = Math.floor((left + right) / 2);\\n     if (potions[mid] * spells[i] >= success) {\\n        validMid = mid;\\n        right = mid - 1;\\n      } else {\\n        left = mid + 1;\\n      }\\n    }\\n    if (validMid !== null) {\\n      ans.push(potions.length - validMid);\\n    } else {\\n      ans.push(0);\\n    }\\n  }\\n\\n  return ans;\\n};\\n```\\nBut  my this solution gives me wrong answer, could anybody explain why?\\n```\\nvar successfulPairs = function (spells = [], potions = [], success = 0) {\\n  let ans = [];\\n  potions.sort((a, b) => a - b);\\n  for (let i = 0; i < spells.length; i++) {\\n    let left = 0;\\n    let right = potions.length - 1;\\n    let mid;\\n    let validMid = null;\\n    while (left <= right) {\\n      mid = Math.floor((left + right) / 2);\\n      if (potions[mid] * spells[i] === success) {\\n        validMid = mid;\\n        break;\\n      } else if (potions[mid] * spells[i] > success) {\\n        validMid = mid;\\n        right = mid - 1;\\n      } else {\\n        left = mid + 1;\\n      }\\n    }\\n    if (validMid !== null) {\\n      ans.push(potions.length - validMid);\\n    } else {\\n      ans.push(0);\\n    }\\n  }\\n\\n  return ans;\\n};\\n\\n```"
                    },
                    {
                        "username": "pyush98",
                        "content": "you\\'re on the right track if you think you have to do X amount of binary searches\\n\\nU can also sort the arrays since the runtime of sorting and X binary searches is the same\\n\\nNow decide whether or not both arrays should be sorted or just one.\\n\\nOnce you answer that question, ask yourself if the weakest position is success...doesn\\'t that mean all the potions stronger than it is also success\\n\\ngood luck "
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Some edge cases in binary search are frustrating."
                    },
                    {
                        "username": "7_aditi",
                        "content": "I am getting this error: \\nLine 15: Char 46: runtime error: signed integer overflow: 2 * -1094795586 cannot be represented in type \\'int\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:24:46\\n\\nmy code was:\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        sort(potions.begin(),potions.end());\\n        int n=spells.size(), m=potions.size();\\n        vector<int> pair;\\n        int count=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            int left=0,right=m;\\n            int  mid;\\n            while(left<=right)\\n            {\\n               mid=(left+right)/2;\\n               long long prod = spells[i]*potions[mid];\\n               if(prod<success)\\n               left=mid+1;\\n               else\\n               right=mid-1; \\n            }\\n            long long prod = spells[i]*potions[mid];\\n            if(prod<success)\\n            mid=mid+1;\\n            if(mid<m)\\n            pair.push_back(m-mid);\\n            else\\n            pair.push_back(0);\\n        }\\n        return pair;\\n    }\\n};\\n\\nplease can anyone tell me how to resolve it and why m I getting this error?"
                    }
                ]
            },
            {
                "id": 1862876,
                "content": [
                    {
                        "username": "Code_With_Gurnoor_Chhabra",
                        "content": "\\ncan anyone explain why my recursive son got TLE and iterative passed all test cases (recursion uses stack space of log n but what\\'s role in time complexity?)\\nclass Solution {\\npublic:\\n/* int bin_search(vector<int>p,int l,int r,int i,long long s)\\n{\\n    if(l>r)\\n    {\\n        return 0;\\n    }\\n    long long int mid = l+(r-l)/2;\\n    long long cmp = (long long)p[mid]*i;\\n    int ct=0;\\n    if(cmp<s)\\n    {\\n        ct+=bin_search(p,mid+1,r,i,s);\\n    }\\n    else\\n    {\\n        ct+=r-mid+1+bin_search(p,l,mid-1,i,s);\\n    }\\n    return ct;\\n}\\n*/\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        sort(potions.begin(),potions.end());\\n        vector<int> ans;\\n        int l=0;\\n        int r=potions.size()-1;\\n        for(int i=0;i<spells.size();i++)\\n        {\\n            int ct=0;\\n            int l=0;\\n            int r=potions.size()-1;\\n            while(l<=r)\\n            {\\n              long long int mid = l+(r-l)/2;\\n              long long cmp = (long long)potions[mid]*spells[i];\\n              if(cmp<success)\\n              {\\n                  l=mid+1;\\n              }\\n              else\\n              {\\n                  ct+=r-mid+1;\\n                  r=mid-1;\\n              }\\n            }\\n            ans.push_back(ct);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "anish_patro",
                        "content": "55/56 passed\\ncan someone please explain this ?\\n\\n\\nclass Solution {\\npublic:   \\nint mod=1e9+7; \\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        vector<int> v;\\n        int sn=spells.size();\\n        int pn=potions.size();\\n       for(int i=0;i<pn;++i){\\n           if(success%potions[i]!=0)\\n           potions[i]=success/potions[i] +1;\\n           else\\n           potions[i]=success/potions[i];\\n       }\\n       sort(potions.begin(),potions.end());\\n        for(int i=0;i<sn;++i){\\n             long long low=0;\\n             long long high=pn-1;\\n           int ans=-1;\\n            while(low<=high){\\n            int mid=(low+(high-low)/2)%mod;\\n            if(potions[mid]<=spells[i])\\n           { ans=mid%mod;\\n            low=mid+1;}\\n            else\\n            high=mid-1;   \\n        }\\n        v.push_back(ans+1);\\n        }\\n       return v;\\n    }\\n};"
                    },
                    {
                        "username": "llamasheep",
                        "content": "[@shivansh961](/shivansh961) The above code assumes that success/potions[i] fits in int, but it could overflow. I also made a similar mistake"
                    },
                    {
                        "username": "shivansh961",
                        "content": "I made the same mistake, used lower bound instead.\\nDon\\'t know what\\'s the mistake.\\nIf you understood, the please do tell"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Hint</span>\n![](https://leetcode.com/problems/successful-pairs-of-spells-and-potions/Figures/2300/Slide1.PNG)\n![](https://leetcode.com/problems/successful-pairs-of-spells-and-potions/Figures/2300/Slide3.PNG)\n![](https://leetcode.com/problems/successful-pairs-of-spells-and-potions/Figures/2300/Slide4.PNG)"
                    },
                    {
                        "username": "waiyankyaw961999",
                        "content": "[@namandt](/namandt) By sorting the array, I think we can just scan the specific portion instead of validating all the elements. So, saving the amount of time."
                    },
                    {
                        "username": "x-ider",
                        "content": "[@namandt](/namandt) it\\'s an alternative solution without binary search"
                    },
                    {
                        "username": "namandt",
                        "content": "why do we need to sort the spells array?"
                    },
                    {
                        "username": "piyush_mehta22",
                        "content": "bs giving tle at 49th/56 tc.\\uD83E\\uDD28"
                    },
                    {
                        "username": "Applethal",
                        "content": "`class Solution:\\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\\n        return [sum(1 for potion in potions if spell * potion >= success) for spell in spells]`\\n\\nMade it to 51/56"
                    },
                    {
                        "username": "vamshikiranm",
                        "content": "Learning of > 1ll\nTo prevent overflow, you can use the ll suffix to explicitly specify that you want the literals to be treated as long long:\n\n\n ` long long k = spells[i]*1ll*potions[mid];`"
                    },
                    {
                        "username": "reactdevsourav",
                        "content": "Hi everyone I have solved the problem but I have once question:- \\nHere is my current solution which works\\n```\\nvar successfulPairs = function (spells = [], potions = [], success = 0) {\\n  let ans = [];\\n  potions.sort((a, b) => a - b);\\n  for (let i = 0; i < spells.length; i++) {\\n    let left = 0;\\n    let right = potions.length - 1;\\n    let mid;\\n    let validMid = null;\\n    while (left <= right) {\\n      mid = Math.floor((left + right) / 2);\\n     if (potions[mid] * spells[i] >= success) {\\n        validMid = mid;\\n        right = mid - 1;\\n      } else {\\n        left = mid + 1;\\n      }\\n    }\\n    if (validMid !== null) {\\n      ans.push(potions.length - validMid);\\n    } else {\\n      ans.push(0);\\n    }\\n  }\\n\\n  return ans;\\n};\\n```\\nBut  my this solution gives me wrong answer, could anybody explain why?\\n```\\nvar successfulPairs = function (spells = [], potions = [], success = 0) {\\n  let ans = [];\\n  potions.sort((a, b) => a - b);\\n  for (let i = 0; i < spells.length; i++) {\\n    let left = 0;\\n    let right = potions.length - 1;\\n    let mid;\\n    let validMid = null;\\n    while (left <= right) {\\n      mid = Math.floor((left + right) / 2);\\n      if (potions[mid] * spells[i] === success) {\\n        validMid = mid;\\n        break;\\n      } else if (potions[mid] * spells[i] > success) {\\n        validMid = mid;\\n        right = mid - 1;\\n      } else {\\n        left = mid + 1;\\n      }\\n    }\\n    if (validMid !== null) {\\n      ans.push(potions.length - validMid);\\n    } else {\\n      ans.push(0);\\n    }\\n  }\\n\\n  return ans;\\n};\\n\\n```"
                    },
                    {
                        "username": "pyush98",
                        "content": "you\\'re on the right track if you think you have to do X amount of binary searches\\n\\nU can also sort the arrays since the runtime of sorting and X binary searches is the same\\n\\nNow decide whether or not both arrays should be sorted or just one.\\n\\nOnce you answer that question, ask yourself if the weakest position is success...doesn\\'t that mean all the potions stronger than it is also success\\n\\ngood luck "
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Some edge cases in binary search are frustrating."
                    },
                    {
                        "username": "7_aditi",
                        "content": "I am getting this error: \\nLine 15: Char 46: runtime error: signed integer overflow: 2 * -1094795586 cannot be represented in type \\'int\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:24:46\\n\\nmy code was:\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        sort(potions.begin(),potions.end());\\n        int n=spells.size(), m=potions.size();\\n        vector<int> pair;\\n        int count=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            int left=0,right=m;\\n            int  mid;\\n            while(left<=right)\\n            {\\n               mid=(left+right)/2;\\n               long long prod = spells[i]*potions[mid];\\n               if(prod<success)\\n               left=mid+1;\\n               else\\n               right=mid-1; \\n            }\\n            long long prod = spells[i]*potions[mid];\\n            if(prod<success)\\n            mid=mid+1;\\n            if(mid<m)\\n            pair.push_back(m-mid);\\n            else\\n            pair.push_back(0);\\n        }\\n        return pair;\\n    }\\n};\\n\\nplease can anyone tell me how to resolve it and why m I getting this error?"
                    }
                ]
            },
            {
                "id": 1859621,
                "content": [
                    {
                        "username": "Code_With_Gurnoor_Chhabra",
                        "content": "\\ncan anyone explain why my recursive son got TLE and iterative passed all test cases (recursion uses stack space of log n but what\\'s role in time complexity?)\\nclass Solution {\\npublic:\\n/* int bin_search(vector<int>p,int l,int r,int i,long long s)\\n{\\n    if(l>r)\\n    {\\n        return 0;\\n    }\\n    long long int mid = l+(r-l)/2;\\n    long long cmp = (long long)p[mid]*i;\\n    int ct=0;\\n    if(cmp<s)\\n    {\\n        ct+=bin_search(p,mid+1,r,i,s);\\n    }\\n    else\\n    {\\n        ct+=r-mid+1+bin_search(p,l,mid-1,i,s);\\n    }\\n    return ct;\\n}\\n*/\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        sort(potions.begin(),potions.end());\\n        vector<int> ans;\\n        int l=0;\\n        int r=potions.size()-1;\\n        for(int i=0;i<spells.size();i++)\\n        {\\n            int ct=0;\\n            int l=0;\\n            int r=potions.size()-1;\\n            while(l<=r)\\n            {\\n              long long int mid = l+(r-l)/2;\\n              long long cmp = (long long)potions[mid]*spells[i];\\n              if(cmp<success)\\n              {\\n                  l=mid+1;\\n              }\\n              else\\n              {\\n                  ct+=r-mid+1;\\n                  r=mid-1;\\n              }\\n            }\\n            ans.push_back(ct);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "anish_patro",
                        "content": "55/56 passed\\ncan someone please explain this ?\\n\\n\\nclass Solution {\\npublic:   \\nint mod=1e9+7; \\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        vector<int> v;\\n        int sn=spells.size();\\n        int pn=potions.size();\\n       for(int i=0;i<pn;++i){\\n           if(success%potions[i]!=0)\\n           potions[i]=success/potions[i] +1;\\n           else\\n           potions[i]=success/potions[i];\\n       }\\n       sort(potions.begin(),potions.end());\\n        for(int i=0;i<sn;++i){\\n             long long low=0;\\n             long long high=pn-1;\\n           int ans=-1;\\n            while(low<=high){\\n            int mid=(low+(high-low)/2)%mod;\\n            if(potions[mid]<=spells[i])\\n           { ans=mid%mod;\\n            low=mid+1;}\\n            else\\n            high=mid-1;   \\n        }\\n        v.push_back(ans+1);\\n        }\\n       return v;\\n    }\\n};"
                    },
                    {
                        "username": "llamasheep",
                        "content": "[@shivansh961](/shivansh961) The above code assumes that success/potions[i] fits in int, but it could overflow. I also made a similar mistake"
                    },
                    {
                        "username": "shivansh961",
                        "content": "I made the same mistake, used lower bound instead.\\nDon\\'t know what\\'s the mistake.\\nIf you understood, the please do tell"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Hint</span>\n![](https://leetcode.com/problems/successful-pairs-of-spells-and-potions/Figures/2300/Slide1.PNG)\n![](https://leetcode.com/problems/successful-pairs-of-spells-and-potions/Figures/2300/Slide3.PNG)\n![](https://leetcode.com/problems/successful-pairs-of-spells-and-potions/Figures/2300/Slide4.PNG)"
                    },
                    {
                        "username": "waiyankyaw961999",
                        "content": "[@namandt](/namandt) By sorting the array, I think we can just scan the specific portion instead of validating all the elements. So, saving the amount of time."
                    },
                    {
                        "username": "x-ider",
                        "content": "[@namandt](/namandt) it\\'s an alternative solution without binary search"
                    },
                    {
                        "username": "namandt",
                        "content": "why do we need to sort the spells array?"
                    },
                    {
                        "username": "piyush_mehta22",
                        "content": "bs giving tle at 49th/56 tc.\\uD83E\\uDD28"
                    },
                    {
                        "username": "Applethal",
                        "content": "`class Solution:\\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\\n        return [sum(1 for potion in potions if spell * potion >= success) for spell in spells]`\\n\\nMade it to 51/56"
                    },
                    {
                        "username": "vamshikiranm",
                        "content": "Learning of > 1ll\nTo prevent overflow, you can use the ll suffix to explicitly specify that you want the literals to be treated as long long:\n\n\n ` long long k = spells[i]*1ll*potions[mid];`"
                    },
                    {
                        "username": "reactdevsourav",
                        "content": "Hi everyone I have solved the problem but I have once question:- \\nHere is my current solution which works\\n```\\nvar successfulPairs = function (spells = [], potions = [], success = 0) {\\n  let ans = [];\\n  potions.sort((a, b) => a - b);\\n  for (let i = 0; i < spells.length; i++) {\\n    let left = 0;\\n    let right = potions.length - 1;\\n    let mid;\\n    let validMid = null;\\n    while (left <= right) {\\n      mid = Math.floor((left + right) / 2);\\n     if (potions[mid] * spells[i] >= success) {\\n        validMid = mid;\\n        right = mid - 1;\\n      } else {\\n        left = mid + 1;\\n      }\\n    }\\n    if (validMid !== null) {\\n      ans.push(potions.length - validMid);\\n    } else {\\n      ans.push(0);\\n    }\\n  }\\n\\n  return ans;\\n};\\n```\\nBut  my this solution gives me wrong answer, could anybody explain why?\\n```\\nvar successfulPairs = function (spells = [], potions = [], success = 0) {\\n  let ans = [];\\n  potions.sort((a, b) => a - b);\\n  for (let i = 0; i < spells.length; i++) {\\n    let left = 0;\\n    let right = potions.length - 1;\\n    let mid;\\n    let validMid = null;\\n    while (left <= right) {\\n      mid = Math.floor((left + right) / 2);\\n      if (potions[mid] * spells[i] === success) {\\n        validMid = mid;\\n        break;\\n      } else if (potions[mid] * spells[i] > success) {\\n        validMid = mid;\\n        right = mid - 1;\\n      } else {\\n        left = mid + 1;\\n      }\\n    }\\n    if (validMid !== null) {\\n      ans.push(potions.length - validMid);\\n    } else {\\n      ans.push(0);\\n    }\\n  }\\n\\n  return ans;\\n};\\n\\n```"
                    },
                    {
                        "username": "pyush98",
                        "content": "you\\'re on the right track if you think you have to do X amount of binary searches\\n\\nU can also sort the arrays since the runtime of sorting and X binary searches is the same\\n\\nNow decide whether or not both arrays should be sorted or just one.\\n\\nOnce you answer that question, ask yourself if the weakest position is success...doesn\\'t that mean all the potions stronger than it is also success\\n\\ngood luck "
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Some edge cases in binary search are frustrating."
                    },
                    {
                        "username": "7_aditi",
                        "content": "I am getting this error: \\nLine 15: Char 46: runtime error: signed integer overflow: 2 * -1094795586 cannot be represented in type \\'int\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:24:46\\n\\nmy code was:\\nclass Solution {\\npublic:\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        sort(potions.begin(),potions.end());\\n        int n=spells.size(), m=potions.size();\\n        vector<int> pair;\\n        int count=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            int left=0,right=m;\\n            int  mid;\\n            while(left<=right)\\n            {\\n               mid=(left+right)/2;\\n               long long prod = spells[i]*potions[mid];\\n               if(prod<success)\\n               left=mid+1;\\n               else\\n               right=mid-1; \\n            }\\n            long long prod = spells[i]*potions[mid];\\n            if(prod<success)\\n            mid=mid+1;\\n            if(mid<m)\\n            pair.push_back(m-mid);\\n            else\\n            pair.push_back(0);\\n        }\\n        return pair;\\n    }\\n};\\n\\nplease can anyone tell me how to resolve it and why m I getting this error?"
                    }
                ]
            },
            {
                "id": 1857730,
                "content": [
                    {
                        "username": "WarrenSanchez",
                        "content": "I think the last case is broken"
                    },
                    {
                        "username": "Elora24",
                        "content": "I\\'m getting error at 54th test case. Couldn\\'t figure this out but assuming success/spells[i] be the reason though this won\\'t cross the limit of integer. Can anyone pls explain what\\'s wrong with it?\\n \\nCode :\\nvector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        sort(potions.begin() , potions.end());\\n\\n        int n = spells.size();\\n        int m = potions.size();\\n        vector<int> result;\\n        for(int i=0 ; i<n ; i++)\\n        {\\n            int keep = success/spells[i];\\n            if(success%spells[i])\\n                ++keep;\\n\\n\\n            int l=0 ,r=m-1 , mid;\\n            while(l<=r)\\n            {\\n                mid = l+((r-l)/2);\\n                if(potions[mid]>=keep)\\n                    r=mid-1;\\n                else\\n                    l=mid+1;\\n            }\\n\\n            result.push_back(m-l);\\n        }\\n\\n        return result;\\n    }"
                    },
                    {
                        "username": "Poopiboi",
                        "content": "These test cases are give me aneurism"
                    },
                    {
                        "username": "ramansehgal174",
                        "content": "Can anyone help me with my code, Test Case-51 is passing when provided input but i get TLE when running the solution ? Time Complexity -O(nlogn)\\n `\\n#define pb push_back\\n#define ll long long\\nclass Solution {\\npublic:\\n    int ceil(vector<int> arr, ll t){\\n        int M=arr.size();\\n        int ans = M;\\n        int low,mid,high;\\n        low = 0;\\n        high = arr.size() - 1;\\n        while(low <= high){\\n            mid = (low + high)/2;\\n            if(arr[mid] >= t){\\n                ans = mid;\\n                high = mid-1;\\n            }\\n            else\\n                low = mid + 1;\\n        }\\n        return M - ans;\\n    }\\n    int getCeil(vector<int> arr, ll t){\\n        int M = arr.size();\\n        if(arr[0] >= t)\\n            return M;\\n        if(arr[M-1] < t)\\n            return 0;\\n        return ceil(arr,t);\\n    }\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        \\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n\\n        int i;\\n        int N=spells.size();\\n        vector<int> pair;\\n        sort(potions.begin(),potions.end()); \\n        for(i=0;i<N;i++){\\n            ll target = success/spells[i] + (success%spells[i]?1:0);\\n            //cout << success << \" \" << spells[i] << \" = \" << target << endl;\\n            int ele = getCeil(potions,target);\\n            //cout << i << \" \" << target << \" \" << ele << endl;\\n            pair.pb(ele);\\n        }\\n        return pair;\\n    }\\n};\\n\\n`"
                    },
                    {
                        "username": "sunny8080",
                        "content": "Uhhh ! This problem is just same as yesterdays\\' Binary Search Problem.\\uD83D\\uDE0E "
                    },
                    {
                        "username": "Maang-io",
                        "content": "Sort the array in descending order, for easy work"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "I\\'ve got this working after giving up of a recursive binary search. Just a casual while loop with left/middle/right indexing made me complete the worst case scenario without hitting RTL."
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "Please tell me what is the mistake in my code?\nIt's not working from 49th testcase.\nExplaination:\n        1. Sorted the potion array\n        2. Find the minimum potion that is successful from potion array.\n        3. And answer is length of potion array - the minimum potion that is successful (i.e. step 2 ).\nCode: \npublic int[] successfulPairs(int[] spells, int[] potions, long success) {\n        Arrays.sort(potions);\n        int[] arr = new int[spells.length];\n        for (int i = 0; i < spells.length; i++)\n        {\n            int s = 0, e = potions.length-1;\n            while (s < e) {\n                int mid = (s+e)/2;\n                if ((potions[mid] * spells[i]) >= success) {\n                    e = mid;\n                }\n                else if ((potions[mid] * spells[i]) < success) {\n                    s = mid+1;\n                }\n            }\n            if (e == -1) {\n                arr[i] = potions.length;\n            }\n            else if ((spells[i] * potions[e]) < success) {\n                arr[i] = (potions.length - e) - 1;\n            }\n            else {\n                arr[i] = potions.length - e;\n            }\n        }\n        return arr;\n    }"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "did you take care of duplicates in potions? eg in <14 14 14 14 14> binary search ends up with mid 14 rather than the first 14"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "Leetcode, plis dont gib me hope \\uD83E\\uDD7A"
                    },
                    {
                        "username": "josh10187",
                        "content": "What is algorithm used here?"
                    }
                ]
            },
            {
                "id": 1857050,
                "content": [
                    {
                        "username": "WarrenSanchez",
                        "content": "I think the last case is broken"
                    },
                    {
                        "username": "Elora24",
                        "content": "I\\'m getting error at 54th test case. Couldn\\'t figure this out but assuming success/spells[i] be the reason though this won\\'t cross the limit of integer. Can anyone pls explain what\\'s wrong with it?\\n \\nCode :\\nvector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        sort(potions.begin() , potions.end());\\n\\n        int n = spells.size();\\n        int m = potions.size();\\n        vector<int> result;\\n        for(int i=0 ; i<n ; i++)\\n        {\\n            int keep = success/spells[i];\\n            if(success%spells[i])\\n                ++keep;\\n\\n\\n            int l=0 ,r=m-1 , mid;\\n            while(l<=r)\\n            {\\n                mid = l+((r-l)/2);\\n                if(potions[mid]>=keep)\\n                    r=mid-1;\\n                else\\n                    l=mid+1;\\n            }\\n\\n            result.push_back(m-l);\\n        }\\n\\n        return result;\\n    }"
                    },
                    {
                        "username": "Poopiboi",
                        "content": "These test cases are give me aneurism"
                    },
                    {
                        "username": "ramansehgal174",
                        "content": "Can anyone help me with my code, Test Case-51 is passing when provided input but i get TLE when running the solution ? Time Complexity -O(nlogn)\\n `\\n#define pb push_back\\n#define ll long long\\nclass Solution {\\npublic:\\n    int ceil(vector<int> arr, ll t){\\n        int M=arr.size();\\n        int ans = M;\\n        int low,mid,high;\\n        low = 0;\\n        high = arr.size() - 1;\\n        while(low <= high){\\n            mid = (low + high)/2;\\n            if(arr[mid] >= t){\\n                ans = mid;\\n                high = mid-1;\\n            }\\n            else\\n                low = mid + 1;\\n        }\\n        return M - ans;\\n    }\\n    int getCeil(vector<int> arr, ll t){\\n        int M = arr.size();\\n        if(arr[0] >= t)\\n            return M;\\n        if(arr[M-1] < t)\\n            return 0;\\n        return ceil(arr,t);\\n    }\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        \\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n\\n        int i;\\n        int N=spells.size();\\n        vector<int> pair;\\n        sort(potions.begin(),potions.end()); \\n        for(i=0;i<N;i++){\\n            ll target = success/spells[i] + (success%spells[i]?1:0);\\n            //cout << success << \" \" << spells[i] << \" = \" << target << endl;\\n            int ele = getCeil(potions,target);\\n            //cout << i << \" \" << target << \" \" << ele << endl;\\n            pair.pb(ele);\\n        }\\n        return pair;\\n    }\\n};\\n\\n`"
                    },
                    {
                        "username": "sunny8080",
                        "content": "Uhhh ! This problem is just same as yesterdays\\' Binary Search Problem.\\uD83D\\uDE0E "
                    },
                    {
                        "username": "Maang-io",
                        "content": "Sort the array in descending order, for easy work"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "I\\'ve got this working after giving up of a recursive binary search. Just a casual while loop with left/middle/right indexing made me complete the worst case scenario without hitting RTL."
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "Please tell me what is the mistake in my code?\nIt's not working from 49th testcase.\nExplaination:\n        1. Sorted the potion array\n        2. Find the minimum potion that is successful from potion array.\n        3. And answer is length of potion array - the minimum potion that is successful (i.e. step 2 ).\nCode: \npublic int[] successfulPairs(int[] spells, int[] potions, long success) {\n        Arrays.sort(potions);\n        int[] arr = new int[spells.length];\n        for (int i = 0; i < spells.length; i++)\n        {\n            int s = 0, e = potions.length-1;\n            while (s < e) {\n                int mid = (s+e)/2;\n                if ((potions[mid] * spells[i]) >= success) {\n                    e = mid;\n                }\n                else if ((potions[mid] * spells[i]) < success) {\n                    s = mid+1;\n                }\n            }\n            if (e == -1) {\n                arr[i] = potions.length;\n            }\n            else if ((spells[i] * potions[e]) < success) {\n                arr[i] = (potions.length - e) - 1;\n            }\n            else {\n                arr[i] = potions.length - e;\n            }\n        }\n        return arr;\n    }"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "did you take care of duplicates in potions? eg in <14 14 14 14 14> binary search ends up with mid 14 rather than the first 14"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "Leetcode, plis dont gib me hope \\uD83E\\uDD7A"
                    },
                    {
                        "username": "josh10187",
                        "content": "What is algorithm used here?"
                    }
                ]
            },
            {
                "id": 1853506,
                "content": [
                    {
                        "username": "WarrenSanchez",
                        "content": "I think the last case is broken"
                    },
                    {
                        "username": "Elora24",
                        "content": "I\\'m getting error at 54th test case. Couldn\\'t figure this out but assuming success/spells[i] be the reason though this won\\'t cross the limit of integer. Can anyone pls explain what\\'s wrong with it?\\n \\nCode :\\nvector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        sort(potions.begin() , potions.end());\\n\\n        int n = spells.size();\\n        int m = potions.size();\\n        vector<int> result;\\n        for(int i=0 ; i<n ; i++)\\n        {\\n            int keep = success/spells[i];\\n            if(success%spells[i])\\n                ++keep;\\n\\n\\n            int l=0 ,r=m-1 , mid;\\n            while(l<=r)\\n            {\\n                mid = l+((r-l)/2);\\n                if(potions[mid]>=keep)\\n                    r=mid-1;\\n                else\\n                    l=mid+1;\\n            }\\n\\n            result.push_back(m-l);\\n        }\\n\\n        return result;\\n    }"
                    },
                    {
                        "username": "Poopiboi",
                        "content": "These test cases are give me aneurism"
                    },
                    {
                        "username": "ramansehgal174",
                        "content": "Can anyone help me with my code, Test Case-51 is passing when provided input but i get TLE when running the solution ? Time Complexity -O(nlogn)\\n `\\n#define pb push_back\\n#define ll long long\\nclass Solution {\\npublic:\\n    int ceil(vector<int> arr, ll t){\\n        int M=arr.size();\\n        int ans = M;\\n        int low,mid,high;\\n        low = 0;\\n        high = arr.size() - 1;\\n        while(low <= high){\\n            mid = (low + high)/2;\\n            if(arr[mid] >= t){\\n                ans = mid;\\n                high = mid-1;\\n            }\\n            else\\n                low = mid + 1;\\n        }\\n        return M - ans;\\n    }\\n    int getCeil(vector<int> arr, ll t){\\n        int M = arr.size();\\n        if(arr[0] >= t)\\n            return M;\\n        if(arr[M-1] < t)\\n            return 0;\\n        return ceil(arr,t);\\n    }\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        \\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n\\n        int i;\\n        int N=spells.size();\\n        vector<int> pair;\\n        sort(potions.begin(),potions.end()); \\n        for(i=0;i<N;i++){\\n            ll target = success/spells[i] + (success%spells[i]?1:0);\\n            //cout << success << \" \" << spells[i] << \" = \" << target << endl;\\n            int ele = getCeil(potions,target);\\n            //cout << i << \" \" << target << \" \" << ele << endl;\\n            pair.pb(ele);\\n        }\\n        return pair;\\n    }\\n};\\n\\n`"
                    },
                    {
                        "username": "sunny8080",
                        "content": "Uhhh ! This problem is just same as yesterdays\\' Binary Search Problem.\\uD83D\\uDE0E "
                    },
                    {
                        "username": "Maang-io",
                        "content": "Sort the array in descending order, for easy work"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "I\\'ve got this working after giving up of a recursive binary search. Just a casual while loop with left/middle/right indexing made me complete the worst case scenario without hitting RTL."
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "Please tell me what is the mistake in my code?\nIt's not working from 49th testcase.\nExplaination:\n        1. Sorted the potion array\n        2. Find the minimum potion that is successful from potion array.\n        3. And answer is length of potion array - the minimum potion that is successful (i.e. step 2 ).\nCode: \npublic int[] successfulPairs(int[] spells, int[] potions, long success) {\n        Arrays.sort(potions);\n        int[] arr = new int[spells.length];\n        for (int i = 0; i < spells.length; i++)\n        {\n            int s = 0, e = potions.length-1;\n            while (s < e) {\n                int mid = (s+e)/2;\n                if ((potions[mid] * spells[i]) >= success) {\n                    e = mid;\n                }\n                else if ((potions[mid] * spells[i]) < success) {\n                    s = mid+1;\n                }\n            }\n            if (e == -1) {\n                arr[i] = potions.length;\n            }\n            else if ((spells[i] * potions[e]) < success) {\n                arr[i] = (potions.length - e) - 1;\n            }\n            else {\n                arr[i] = potions.length - e;\n            }\n        }\n        return arr;\n    }"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "did you take care of duplicates in potions? eg in <14 14 14 14 14> binary search ends up with mid 14 rather than the first 14"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "Leetcode, plis dont gib me hope \\uD83E\\uDD7A"
                    },
                    {
                        "username": "josh10187",
                        "content": "What is algorithm used here?"
                    }
                ]
            },
            {
                "id": 1852403,
                "content": [
                    {
                        "username": "WarrenSanchez",
                        "content": "I think the last case is broken"
                    },
                    {
                        "username": "Elora24",
                        "content": "I\\'m getting error at 54th test case. Couldn\\'t figure this out but assuming success/spells[i] be the reason though this won\\'t cross the limit of integer. Can anyone pls explain what\\'s wrong with it?\\n \\nCode :\\nvector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        sort(potions.begin() , potions.end());\\n\\n        int n = spells.size();\\n        int m = potions.size();\\n        vector<int> result;\\n        for(int i=0 ; i<n ; i++)\\n        {\\n            int keep = success/spells[i];\\n            if(success%spells[i])\\n                ++keep;\\n\\n\\n            int l=0 ,r=m-1 , mid;\\n            while(l<=r)\\n            {\\n                mid = l+((r-l)/2);\\n                if(potions[mid]>=keep)\\n                    r=mid-1;\\n                else\\n                    l=mid+1;\\n            }\\n\\n            result.push_back(m-l);\\n        }\\n\\n        return result;\\n    }"
                    },
                    {
                        "username": "Poopiboi",
                        "content": "These test cases are give me aneurism"
                    },
                    {
                        "username": "ramansehgal174",
                        "content": "Can anyone help me with my code, Test Case-51 is passing when provided input but i get TLE when running the solution ? Time Complexity -O(nlogn)\\n `\\n#define pb push_back\\n#define ll long long\\nclass Solution {\\npublic:\\n    int ceil(vector<int> arr, ll t){\\n        int M=arr.size();\\n        int ans = M;\\n        int low,mid,high;\\n        low = 0;\\n        high = arr.size() - 1;\\n        while(low <= high){\\n            mid = (low + high)/2;\\n            if(arr[mid] >= t){\\n                ans = mid;\\n                high = mid-1;\\n            }\\n            else\\n                low = mid + 1;\\n        }\\n        return M - ans;\\n    }\\n    int getCeil(vector<int> arr, ll t){\\n        int M = arr.size();\\n        if(arr[0] >= t)\\n            return M;\\n        if(arr[M-1] < t)\\n            return 0;\\n        return ceil(arr,t);\\n    }\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        \\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n\\n        int i;\\n        int N=spells.size();\\n        vector<int> pair;\\n        sort(potions.begin(),potions.end()); \\n        for(i=0;i<N;i++){\\n            ll target = success/spells[i] + (success%spells[i]?1:0);\\n            //cout << success << \" \" << spells[i] << \" = \" << target << endl;\\n            int ele = getCeil(potions,target);\\n            //cout << i << \" \" << target << \" \" << ele << endl;\\n            pair.pb(ele);\\n        }\\n        return pair;\\n    }\\n};\\n\\n`"
                    },
                    {
                        "username": "sunny8080",
                        "content": "Uhhh ! This problem is just same as yesterdays\\' Binary Search Problem.\\uD83D\\uDE0E "
                    },
                    {
                        "username": "Maang-io",
                        "content": "Sort the array in descending order, for easy work"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "I\\'ve got this working after giving up of a recursive binary search. Just a casual while loop with left/middle/right indexing made me complete the worst case scenario without hitting RTL."
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "Please tell me what is the mistake in my code?\nIt's not working from 49th testcase.\nExplaination:\n        1. Sorted the potion array\n        2. Find the minimum potion that is successful from potion array.\n        3. And answer is length of potion array - the minimum potion that is successful (i.e. step 2 ).\nCode: \npublic int[] successfulPairs(int[] spells, int[] potions, long success) {\n        Arrays.sort(potions);\n        int[] arr = new int[spells.length];\n        for (int i = 0; i < spells.length; i++)\n        {\n            int s = 0, e = potions.length-1;\n            while (s < e) {\n                int mid = (s+e)/2;\n                if ((potions[mid] * spells[i]) >= success) {\n                    e = mid;\n                }\n                else if ((potions[mid] * spells[i]) < success) {\n                    s = mid+1;\n                }\n            }\n            if (e == -1) {\n                arr[i] = potions.length;\n            }\n            else if ((spells[i] * potions[e]) < success) {\n                arr[i] = (potions.length - e) - 1;\n            }\n            else {\n                arr[i] = potions.length - e;\n            }\n        }\n        return arr;\n    }"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "did you take care of duplicates in potions? eg in <14 14 14 14 14> binary search ends up with mid 14 rather than the first 14"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "Leetcode, plis dont gib me hope \\uD83E\\uDD7A"
                    },
                    {
                        "username": "josh10187",
                        "content": "What is algorithm used here?"
                    }
                ]
            },
            {
                "id": 1851983,
                "content": [
                    {
                        "username": "WarrenSanchez",
                        "content": "I think the last case is broken"
                    },
                    {
                        "username": "Elora24",
                        "content": "I\\'m getting error at 54th test case. Couldn\\'t figure this out but assuming success/spells[i] be the reason though this won\\'t cross the limit of integer. Can anyone pls explain what\\'s wrong with it?\\n \\nCode :\\nvector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        sort(potions.begin() , potions.end());\\n\\n        int n = spells.size();\\n        int m = potions.size();\\n        vector<int> result;\\n        for(int i=0 ; i<n ; i++)\\n        {\\n            int keep = success/spells[i];\\n            if(success%spells[i])\\n                ++keep;\\n\\n\\n            int l=0 ,r=m-1 , mid;\\n            while(l<=r)\\n            {\\n                mid = l+((r-l)/2);\\n                if(potions[mid]>=keep)\\n                    r=mid-1;\\n                else\\n                    l=mid+1;\\n            }\\n\\n            result.push_back(m-l);\\n        }\\n\\n        return result;\\n    }"
                    },
                    {
                        "username": "Poopiboi",
                        "content": "These test cases are give me aneurism"
                    },
                    {
                        "username": "ramansehgal174",
                        "content": "Can anyone help me with my code, Test Case-51 is passing when provided input but i get TLE when running the solution ? Time Complexity -O(nlogn)\\n `\\n#define pb push_back\\n#define ll long long\\nclass Solution {\\npublic:\\n    int ceil(vector<int> arr, ll t){\\n        int M=arr.size();\\n        int ans = M;\\n        int low,mid,high;\\n        low = 0;\\n        high = arr.size() - 1;\\n        while(low <= high){\\n            mid = (low + high)/2;\\n            if(arr[mid] >= t){\\n                ans = mid;\\n                high = mid-1;\\n            }\\n            else\\n                low = mid + 1;\\n        }\\n        return M - ans;\\n    }\\n    int getCeil(vector<int> arr, ll t){\\n        int M = arr.size();\\n        if(arr[0] >= t)\\n            return M;\\n        if(arr[M-1] < t)\\n            return 0;\\n        return ceil(arr,t);\\n    }\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        \\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n\\n        int i;\\n        int N=spells.size();\\n        vector<int> pair;\\n        sort(potions.begin(),potions.end()); \\n        for(i=0;i<N;i++){\\n            ll target = success/spells[i] + (success%spells[i]?1:0);\\n            //cout << success << \" \" << spells[i] << \" = \" << target << endl;\\n            int ele = getCeil(potions,target);\\n            //cout << i << \" \" << target << \" \" << ele << endl;\\n            pair.pb(ele);\\n        }\\n        return pair;\\n    }\\n};\\n\\n`"
                    },
                    {
                        "username": "sunny8080",
                        "content": "Uhhh ! This problem is just same as yesterdays\\' Binary Search Problem.\\uD83D\\uDE0E "
                    },
                    {
                        "username": "Maang-io",
                        "content": "Sort the array in descending order, for easy work"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "I\\'ve got this working after giving up of a recursive binary search. Just a casual while loop with left/middle/right indexing made me complete the worst case scenario without hitting RTL."
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "Please tell me what is the mistake in my code?\nIt's not working from 49th testcase.\nExplaination:\n        1. Sorted the potion array\n        2. Find the minimum potion that is successful from potion array.\n        3. And answer is length of potion array - the minimum potion that is successful (i.e. step 2 ).\nCode: \npublic int[] successfulPairs(int[] spells, int[] potions, long success) {\n        Arrays.sort(potions);\n        int[] arr = new int[spells.length];\n        for (int i = 0; i < spells.length; i++)\n        {\n            int s = 0, e = potions.length-1;\n            while (s < e) {\n                int mid = (s+e)/2;\n                if ((potions[mid] * spells[i]) >= success) {\n                    e = mid;\n                }\n                else if ((potions[mid] * spells[i]) < success) {\n                    s = mid+1;\n                }\n            }\n            if (e == -1) {\n                arr[i] = potions.length;\n            }\n            else if ((spells[i] * potions[e]) < success) {\n                arr[i] = (potions.length - e) - 1;\n            }\n            else {\n                arr[i] = potions.length - e;\n            }\n        }\n        return arr;\n    }"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "did you take care of duplicates in potions? eg in <14 14 14 14 14> binary search ends up with mid 14 rather than the first 14"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "Leetcode, plis dont gib me hope \\uD83E\\uDD7A"
                    },
                    {
                        "username": "josh10187",
                        "content": "What is algorithm used here?"
                    }
                ]
            },
            {
                "id": 1851950,
                "content": [
                    {
                        "username": "WarrenSanchez",
                        "content": "I think the last case is broken"
                    },
                    {
                        "username": "Elora24",
                        "content": "I\\'m getting error at 54th test case. Couldn\\'t figure this out but assuming success/spells[i] be the reason though this won\\'t cross the limit of integer. Can anyone pls explain what\\'s wrong with it?\\n \\nCode :\\nvector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        sort(potions.begin() , potions.end());\\n\\n        int n = spells.size();\\n        int m = potions.size();\\n        vector<int> result;\\n        for(int i=0 ; i<n ; i++)\\n        {\\n            int keep = success/spells[i];\\n            if(success%spells[i])\\n                ++keep;\\n\\n\\n            int l=0 ,r=m-1 , mid;\\n            while(l<=r)\\n            {\\n                mid = l+((r-l)/2);\\n                if(potions[mid]>=keep)\\n                    r=mid-1;\\n                else\\n                    l=mid+1;\\n            }\\n\\n            result.push_back(m-l);\\n        }\\n\\n        return result;\\n    }"
                    },
                    {
                        "username": "Poopiboi",
                        "content": "These test cases are give me aneurism"
                    },
                    {
                        "username": "ramansehgal174",
                        "content": "Can anyone help me with my code, Test Case-51 is passing when provided input but i get TLE when running the solution ? Time Complexity -O(nlogn)\\n `\\n#define pb push_back\\n#define ll long long\\nclass Solution {\\npublic:\\n    int ceil(vector<int> arr, ll t){\\n        int M=arr.size();\\n        int ans = M;\\n        int low,mid,high;\\n        low = 0;\\n        high = arr.size() - 1;\\n        while(low <= high){\\n            mid = (low + high)/2;\\n            if(arr[mid] >= t){\\n                ans = mid;\\n                high = mid-1;\\n            }\\n            else\\n                low = mid + 1;\\n        }\\n        return M - ans;\\n    }\\n    int getCeil(vector<int> arr, ll t){\\n        int M = arr.size();\\n        if(arr[0] >= t)\\n            return M;\\n        if(arr[M-1] < t)\\n            return 0;\\n        return ceil(arr,t);\\n    }\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        \\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n\\n        int i;\\n        int N=spells.size();\\n        vector<int> pair;\\n        sort(potions.begin(),potions.end()); \\n        for(i=0;i<N;i++){\\n            ll target = success/spells[i] + (success%spells[i]?1:0);\\n            //cout << success << \" \" << spells[i] << \" = \" << target << endl;\\n            int ele = getCeil(potions,target);\\n            //cout << i << \" \" << target << \" \" << ele << endl;\\n            pair.pb(ele);\\n        }\\n        return pair;\\n    }\\n};\\n\\n`"
                    },
                    {
                        "username": "sunny8080",
                        "content": "Uhhh ! This problem is just same as yesterdays\\' Binary Search Problem.\\uD83D\\uDE0E "
                    },
                    {
                        "username": "Maang-io",
                        "content": "Sort the array in descending order, for easy work"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "I\\'ve got this working after giving up of a recursive binary search. Just a casual while loop with left/middle/right indexing made me complete the worst case scenario without hitting RTL."
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "Please tell me what is the mistake in my code?\nIt's not working from 49th testcase.\nExplaination:\n        1. Sorted the potion array\n        2. Find the minimum potion that is successful from potion array.\n        3. And answer is length of potion array - the minimum potion that is successful (i.e. step 2 ).\nCode: \npublic int[] successfulPairs(int[] spells, int[] potions, long success) {\n        Arrays.sort(potions);\n        int[] arr = new int[spells.length];\n        for (int i = 0; i < spells.length; i++)\n        {\n            int s = 0, e = potions.length-1;\n            while (s < e) {\n                int mid = (s+e)/2;\n                if ((potions[mid] * spells[i]) >= success) {\n                    e = mid;\n                }\n                else if ((potions[mid] * spells[i]) < success) {\n                    s = mid+1;\n                }\n            }\n            if (e == -1) {\n                arr[i] = potions.length;\n            }\n            else if ((spells[i] * potions[e]) < success) {\n                arr[i] = (potions.length - e) - 1;\n            }\n            else {\n                arr[i] = potions.length - e;\n            }\n        }\n        return arr;\n    }"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "did you take care of duplicates in potions? eg in <14 14 14 14 14> binary search ends up with mid 14 rather than the first 14"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "Leetcode, plis dont gib me hope \\uD83E\\uDD7A"
                    },
                    {
                        "username": "josh10187",
                        "content": "What is algorithm used here?"
                    }
                ]
            },
            {
                "id": 1851905,
                "content": [
                    {
                        "username": "WarrenSanchez",
                        "content": "I think the last case is broken"
                    },
                    {
                        "username": "Elora24",
                        "content": "I\\'m getting error at 54th test case. Couldn\\'t figure this out but assuming success/spells[i] be the reason though this won\\'t cross the limit of integer. Can anyone pls explain what\\'s wrong with it?\\n \\nCode :\\nvector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        sort(potions.begin() , potions.end());\\n\\n        int n = spells.size();\\n        int m = potions.size();\\n        vector<int> result;\\n        for(int i=0 ; i<n ; i++)\\n        {\\n            int keep = success/spells[i];\\n            if(success%spells[i])\\n                ++keep;\\n\\n\\n            int l=0 ,r=m-1 , mid;\\n            while(l<=r)\\n            {\\n                mid = l+((r-l)/2);\\n                if(potions[mid]>=keep)\\n                    r=mid-1;\\n                else\\n                    l=mid+1;\\n            }\\n\\n            result.push_back(m-l);\\n        }\\n\\n        return result;\\n    }"
                    },
                    {
                        "username": "Poopiboi",
                        "content": "These test cases are give me aneurism"
                    },
                    {
                        "username": "ramansehgal174",
                        "content": "Can anyone help me with my code, Test Case-51 is passing when provided input but i get TLE when running the solution ? Time Complexity -O(nlogn)\\n `\\n#define pb push_back\\n#define ll long long\\nclass Solution {\\npublic:\\n    int ceil(vector<int> arr, ll t){\\n        int M=arr.size();\\n        int ans = M;\\n        int low,mid,high;\\n        low = 0;\\n        high = arr.size() - 1;\\n        while(low <= high){\\n            mid = (low + high)/2;\\n            if(arr[mid] >= t){\\n                ans = mid;\\n                high = mid-1;\\n            }\\n            else\\n                low = mid + 1;\\n        }\\n        return M - ans;\\n    }\\n    int getCeil(vector<int> arr, ll t){\\n        int M = arr.size();\\n        if(arr[0] >= t)\\n            return M;\\n        if(arr[M-1] < t)\\n            return 0;\\n        return ceil(arr,t);\\n    }\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        \\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n\\n        int i;\\n        int N=spells.size();\\n        vector<int> pair;\\n        sort(potions.begin(),potions.end()); \\n        for(i=0;i<N;i++){\\n            ll target = success/spells[i] + (success%spells[i]?1:0);\\n            //cout << success << \" \" << spells[i] << \" = \" << target << endl;\\n            int ele = getCeil(potions,target);\\n            //cout << i << \" \" << target << \" \" << ele << endl;\\n            pair.pb(ele);\\n        }\\n        return pair;\\n    }\\n};\\n\\n`"
                    },
                    {
                        "username": "sunny8080",
                        "content": "Uhhh ! This problem is just same as yesterdays\\' Binary Search Problem.\\uD83D\\uDE0E "
                    },
                    {
                        "username": "Maang-io",
                        "content": "Sort the array in descending order, for easy work"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "I\\'ve got this working after giving up of a recursive binary search. Just a casual while loop with left/middle/right indexing made me complete the worst case scenario without hitting RTL."
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "Please tell me what is the mistake in my code?\nIt's not working from 49th testcase.\nExplaination:\n        1. Sorted the potion array\n        2. Find the minimum potion that is successful from potion array.\n        3. And answer is length of potion array - the minimum potion that is successful (i.e. step 2 ).\nCode: \npublic int[] successfulPairs(int[] spells, int[] potions, long success) {\n        Arrays.sort(potions);\n        int[] arr = new int[spells.length];\n        for (int i = 0; i < spells.length; i++)\n        {\n            int s = 0, e = potions.length-1;\n            while (s < e) {\n                int mid = (s+e)/2;\n                if ((potions[mid] * spells[i]) >= success) {\n                    e = mid;\n                }\n                else if ((potions[mid] * spells[i]) < success) {\n                    s = mid+1;\n                }\n            }\n            if (e == -1) {\n                arr[i] = potions.length;\n            }\n            else if ((spells[i] * potions[e]) < success) {\n                arr[i] = (potions.length - e) - 1;\n            }\n            else {\n                arr[i] = potions.length - e;\n            }\n        }\n        return arr;\n    }"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "did you take care of duplicates in potions? eg in <14 14 14 14 14> binary search ends up with mid 14 rather than the first 14"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "Leetcode, plis dont gib me hope \\uD83E\\uDD7A"
                    },
                    {
                        "username": "josh10187",
                        "content": "What is algorithm used here?"
                    }
                ]
            },
            {
                "id": 1851803,
                "content": [
                    {
                        "username": "WarrenSanchez",
                        "content": "I think the last case is broken"
                    },
                    {
                        "username": "Elora24",
                        "content": "I\\'m getting error at 54th test case. Couldn\\'t figure this out but assuming success/spells[i] be the reason though this won\\'t cross the limit of integer. Can anyone pls explain what\\'s wrong with it?\\n \\nCode :\\nvector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        sort(potions.begin() , potions.end());\\n\\n        int n = spells.size();\\n        int m = potions.size();\\n        vector<int> result;\\n        for(int i=0 ; i<n ; i++)\\n        {\\n            int keep = success/spells[i];\\n            if(success%spells[i])\\n                ++keep;\\n\\n\\n            int l=0 ,r=m-1 , mid;\\n            while(l<=r)\\n            {\\n                mid = l+((r-l)/2);\\n                if(potions[mid]>=keep)\\n                    r=mid-1;\\n                else\\n                    l=mid+1;\\n            }\\n\\n            result.push_back(m-l);\\n        }\\n\\n        return result;\\n    }"
                    },
                    {
                        "username": "Poopiboi",
                        "content": "These test cases are give me aneurism"
                    },
                    {
                        "username": "ramansehgal174",
                        "content": "Can anyone help me with my code, Test Case-51 is passing when provided input but i get TLE when running the solution ? Time Complexity -O(nlogn)\\n `\\n#define pb push_back\\n#define ll long long\\nclass Solution {\\npublic:\\n    int ceil(vector<int> arr, ll t){\\n        int M=arr.size();\\n        int ans = M;\\n        int low,mid,high;\\n        low = 0;\\n        high = arr.size() - 1;\\n        while(low <= high){\\n            mid = (low + high)/2;\\n            if(arr[mid] >= t){\\n                ans = mid;\\n                high = mid-1;\\n            }\\n            else\\n                low = mid + 1;\\n        }\\n        return M - ans;\\n    }\\n    int getCeil(vector<int> arr, ll t){\\n        int M = arr.size();\\n        if(arr[0] >= t)\\n            return M;\\n        if(arr[M-1] < t)\\n            return 0;\\n        return ceil(arr,t);\\n    }\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        \\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n\\n        int i;\\n        int N=spells.size();\\n        vector<int> pair;\\n        sort(potions.begin(),potions.end()); \\n        for(i=0;i<N;i++){\\n            ll target = success/spells[i] + (success%spells[i]?1:0);\\n            //cout << success << \" \" << spells[i] << \" = \" << target << endl;\\n            int ele = getCeil(potions,target);\\n            //cout << i << \" \" << target << \" \" << ele << endl;\\n            pair.pb(ele);\\n        }\\n        return pair;\\n    }\\n};\\n\\n`"
                    },
                    {
                        "username": "sunny8080",
                        "content": "Uhhh ! This problem is just same as yesterdays\\' Binary Search Problem.\\uD83D\\uDE0E "
                    },
                    {
                        "username": "Maang-io",
                        "content": "Sort the array in descending order, for easy work"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "I\\'ve got this working after giving up of a recursive binary search. Just a casual while loop with left/middle/right indexing made me complete the worst case scenario without hitting RTL."
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "Please tell me what is the mistake in my code?\nIt's not working from 49th testcase.\nExplaination:\n        1. Sorted the potion array\n        2. Find the minimum potion that is successful from potion array.\n        3. And answer is length of potion array - the minimum potion that is successful (i.e. step 2 ).\nCode: \npublic int[] successfulPairs(int[] spells, int[] potions, long success) {\n        Arrays.sort(potions);\n        int[] arr = new int[spells.length];\n        for (int i = 0; i < spells.length; i++)\n        {\n            int s = 0, e = potions.length-1;\n            while (s < e) {\n                int mid = (s+e)/2;\n                if ((potions[mid] * spells[i]) >= success) {\n                    e = mid;\n                }\n                else if ((potions[mid] * spells[i]) < success) {\n                    s = mid+1;\n                }\n            }\n            if (e == -1) {\n                arr[i] = potions.length;\n            }\n            else if ((spells[i] * potions[e]) < success) {\n                arr[i] = (potions.length - e) - 1;\n            }\n            else {\n                arr[i] = potions.length - e;\n            }\n        }\n        return arr;\n    }"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "did you take care of duplicates in potions? eg in <14 14 14 14 14> binary search ends up with mid 14 rather than the first 14"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "Leetcode, plis dont gib me hope \\uD83E\\uDD7A"
                    },
                    {
                        "username": "josh10187",
                        "content": "What is algorithm used here?"
                    }
                ]
            },
            {
                "id": 1851800,
                "content": [
                    {
                        "username": "WarrenSanchez",
                        "content": "I think the last case is broken"
                    },
                    {
                        "username": "Elora24",
                        "content": "I\\'m getting error at 54th test case. Couldn\\'t figure this out but assuming success/spells[i] be the reason though this won\\'t cross the limit of integer. Can anyone pls explain what\\'s wrong with it?\\n \\nCode :\\nvector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        sort(potions.begin() , potions.end());\\n\\n        int n = spells.size();\\n        int m = potions.size();\\n        vector<int> result;\\n        for(int i=0 ; i<n ; i++)\\n        {\\n            int keep = success/spells[i];\\n            if(success%spells[i])\\n                ++keep;\\n\\n\\n            int l=0 ,r=m-1 , mid;\\n            while(l<=r)\\n            {\\n                mid = l+((r-l)/2);\\n                if(potions[mid]>=keep)\\n                    r=mid-1;\\n                else\\n                    l=mid+1;\\n            }\\n\\n            result.push_back(m-l);\\n        }\\n\\n        return result;\\n    }"
                    },
                    {
                        "username": "Poopiboi",
                        "content": "These test cases are give me aneurism"
                    },
                    {
                        "username": "ramansehgal174",
                        "content": "Can anyone help me with my code, Test Case-51 is passing when provided input but i get TLE when running the solution ? Time Complexity -O(nlogn)\\n `\\n#define pb push_back\\n#define ll long long\\nclass Solution {\\npublic:\\n    int ceil(vector<int> arr, ll t){\\n        int M=arr.size();\\n        int ans = M;\\n        int low,mid,high;\\n        low = 0;\\n        high = arr.size() - 1;\\n        while(low <= high){\\n            mid = (low + high)/2;\\n            if(arr[mid] >= t){\\n                ans = mid;\\n                high = mid-1;\\n            }\\n            else\\n                low = mid + 1;\\n        }\\n        return M - ans;\\n    }\\n    int getCeil(vector<int> arr, ll t){\\n        int M = arr.size();\\n        if(arr[0] >= t)\\n            return M;\\n        if(arr[M-1] < t)\\n            return 0;\\n        return ceil(arr,t);\\n    }\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        \\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n\\n        int i;\\n        int N=spells.size();\\n        vector<int> pair;\\n        sort(potions.begin(),potions.end()); \\n        for(i=0;i<N;i++){\\n            ll target = success/spells[i] + (success%spells[i]?1:0);\\n            //cout << success << \" \" << spells[i] << \" = \" << target << endl;\\n            int ele = getCeil(potions,target);\\n            //cout << i << \" \" << target << \" \" << ele << endl;\\n            pair.pb(ele);\\n        }\\n        return pair;\\n    }\\n};\\n\\n`"
                    },
                    {
                        "username": "sunny8080",
                        "content": "Uhhh ! This problem is just same as yesterdays\\' Binary Search Problem.\\uD83D\\uDE0E "
                    },
                    {
                        "username": "Maang-io",
                        "content": "Sort the array in descending order, for easy work"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "I\\'ve got this working after giving up of a recursive binary search. Just a casual while loop with left/middle/right indexing made me complete the worst case scenario without hitting RTL."
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "Please tell me what is the mistake in my code?\nIt's not working from 49th testcase.\nExplaination:\n        1. Sorted the potion array\n        2. Find the minimum potion that is successful from potion array.\n        3. And answer is length of potion array - the minimum potion that is successful (i.e. step 2 ).\nCode: \npublic int[] successfulPairs(int[] spells, int[] potions, long success) {\n        Arrays.sort(potions);\n        int[] arr = new int[spells.length];\n        for (int i = 0; i < spells.length; i++)\n        {\n            int s = 0, e = potions.length-1;\n            while (s < e) {\n                int mid = (s+e)/2;\n                if ((potions[mid] * spells[i]) >= success) {\n                    e = mid;\n                }\n                else if ((potions[mid] * spells[i]) < success) {\n                    s = mid+1;\n                }\n            }\n            if (e == -1) {\n                arr[i] = potions.length;\n            }\n            else if ((spells[i] * potions[e]) < success) {\n                arr[i] = (potions.length - e) - 1;\n            }\n            else {\n                arr[i] = potions.length - e;\n            }\n        }\n        return arr;\n    }"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "did you take care of duplicates in potions? eg in <14 14 14 14 14> binary search ends up with mid 14 rather than the first 14"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "Leetcode, plis dont gib me hope \\uD83E\\uDD7A"
                    },
                    {
                        "username": "josh10187",
                        "content": "What is algorithm used here?"
                    }
                ]
            },
            {
                "id": 1851796,
                "content": [
                    {
                        "username": "WarrenSanchez",
                        "content": "I think the last case is broken"
                    },
                    {
                        "username": "Elora24",
                        "content": "I\\'m getting error at 54th test case. Couldn\\'t figure this out but assuming success/spells[i] be the reason though this won\\'t cross the limit of integer. Can anyone pls explain what\\'s wrong with it?\\n \\nCode :\\nvector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        sort(potions.begin() , potions.end());\\n\\n        int n = spells.size();\\n        int m = potions.size();\\n        vector<int> result;\\n        for(int i=0 ; i<n ; i++)\\n        {\\n            int keep = success/spells[i];\\n            if(success%spells[i])\\n                ++keep;\\n\\n\\n            int l=0 ,r=m-1 , mid;\\n            while(l<=r)\\n            {\\n                mid = l+((r-l)/2);\\n                if(potions[mid]>=keep)\\n                    r=mid-1;\\n                else\\n                    l=mid+1;\\n            }\\n\\n            result.push_back(m-l);\\n        }\\n\\n        return result;\\n    }"
                    },
                    {
                        "username": "Poopiboi",
                        "content": "These test cases are give me aneurism"
                    },
                    {
                        "username": "ramansehgal174",
                        "content": "Can anyone help me with my code, Test Case-51 is passing when provided input but i get TLE when running the solution ? Time Complexity -O(nlogn)\\n `\\n#define pb push_back\\n#define ll long long\\nclass Solution {\\npublic:\\n    int ceil(vector<int> arr, ll t){\\n        int M=arr.size();\\n        int ans = M;\\n        int low,mid,high;\\n        low = 0;\\n        high = arr.size() - 1;\\n        while(low <= high){\\n            mid = (low + high)/2;\\n            if(arr[mid] >= t){\\n                ans = mid;\\n                high = mid-1;\\n            }\\n            else\\n                low = mid + 1;\\n        }\\n        return M - ans;\\n    }\\n    int getCeil(vector<int> arr, ll t){\\n        int M = arr.size();\\n        if(arr[0] >= t)\\n            return M;\\n        if(arr[M-1] < t)\\n            return 0;\\n        return ceil(arr,t);\\n    }\\n    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {\\n        \\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n\\n        int i;\\n        int N=spells.size();\\n        vector<int> pair;\\n        sort(potions.begin(),potions.end()); \\n        for(i=0;i<N;i++){\\n            ll target = success/spells[i] + (success%spells[i]?1:0);\\n            //cout << success << \" \" << spells[i] << \" = \" << target << endl;\\n            int ele = getCeil(potions,target);\\n            //cout << i << \" \" << target << \" \" << ele << endl;\\n            pair.pb(ele);\\n        }\\n        return pair;\\n    }\\n};\\n\\n`"
                    },
                    {
                        "username": "sunny8080",
                        "content": "Uhhh ! This problem is just same as yesterdays\\' Binary Search Problem.\\uD83D\\uDE0E "
                    },
                    {
                        "username": "Maang-io",
                        "content": "Sort the array in descending order, for easy work"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "I\\'ve got this working after giving up of a recursive binary search. Just a casual while loop with left/middle/right indexing made me complete the worst case scenario without hitting RTL."
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "Please tell me what is the mistake in my code?\nIt's not working from 49th testcase.\nExplaination:\n        1. Sorted the potion array\n        2. Find the minimum potion that is successful from potion array.\n        3. And answer is length of potion array - the minimum potion that is successful (i.e. step 2 ).\nCode: \npublic int[] successfulPairs(int[] spells, int[] potions, long success) {\n        Arrays.sort(potions);\n        int[] arr = new int[spells.length];\n        for (int i = 0; i < spells.length; i++)\n        {\n            int s = 0, e = potions.length-1;\n            while (s < e) {\n                int mid = (s+e)/2;\n                if ((potions[mid] * spells[i]) >= success) {\n                    e = mid;\n                }\n                else if ((potions[mid] * spells[i]) < success) {\n                    s = mid+1;\n                }\n            }\n            if (e == -1) {\n                arr[i] = potions.length;\n            }\n            else if ((spells[i] * potions[e]) < success) {\n                arr[i] = (potions.length - e) - 1;\n            }\n            else {\n                arr[i] = potions.length - e;\n            }\n        }\n        return arr;\n    }"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "did you take care of duplicates in potions? eg in <14 14 14 14 14> binary search ends up with mid 14 rather than the first 14"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "Leetcode, plis dont gib me hope \\uD83E\\uDD7A"
                    },
                    {
                        "username": "josh10187",
                        "content": "What is algorithm used here?"
                    }
                ]
            },
            {
                "id": 1851763,
                "content": [
                    {
                        "username": "dashingboy110035",
                        "content": "`for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                temp = (long)spells[i]*potions[j];\\n                if(temp >= success){\\n                    cnt++;\\n                }\\n                temp=0;\\n            }\\n            ans.push_back(cnt);\\n            cnt=0;\\n        }\\n        return ans;`\\n\\n51/56 demn constraints."
                    },
                    {
                        "username": "samsondanielcaps",
                        "content": "Passed 54/56 and got time limit exceeded is there any way i can improve the code:\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        Arrays.sort(potions);\\n        // Arrays.sort(spells);\\n        for(int i=0;i<spells.length;i++)\\n        {\\n            int c=0;\\n            for(int j=potions.length-1;j>=0;j--)\\n            {\\n                long n=(long)spells[i]*potions[j];\\n                if(n<success)\\n                {\\n                    break;\\n                }\\n                else{\\n                    c++;\\n                }\\n            }\\n            spells[i]=c;\\n        }    \\n        return spells;\\n    }\\n}"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "Try to write in code format or use proper indents, very hard to read\\n"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "55 / 56 testcases passed\\n\\uD83D\\uDE29"
                    },
                    {
                        "username": "HumbleFool22",
                        "content": "I\\'m solving this problem in brute froce approach plzz tell me what I did wrong here in this question .\\n\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        int arr2[]= new int[spells.length];\\n        for(int i = 0 ;i<spells.length;i++)\\n        {\\n            int arr1[]= Multiplication(spells[i],potions);\\n            arr2[i] = counting(arr1, success);\\n        }        \\n        return arr2;\\n\\n    }\\n    public static int counting (int arr[],long success)\\n    {\\n        int count =0;\\n        for(int i=0;i<arr.length;i++)\\n        {\\n            if(arr[i]>=success)\\n            {\\n                count++;\\n            }\\n        }\\n        return count ;\\n    } \\n    public static int[] Multiplication(int a , int potions[])\\n    {\\n        int arr[]= new int[potions.length];\\n        for(int i=0;i<potions.length;i++)\\n        {\\n            arr[i]= a*potions[i];\\n        }\\n\\n        return arr;\\n    } \\n}"
                    },
                    {
                        "username": "HumbleFool22",
                        "content": "my solution fail in 48th test case \\n"
                    },
                    {
                        "username": "crysqrlkys",
                        "content": "shadow wizard money gang\\nwe love casting spells"
                    },
                    {
                        "username": "jemuel90880",
                        "content": "Did somebody solve this is C lang? man I cant seem to past the 48/56 testcases. help..."
                    },
                    {
                        "username": "user2871e",
                        "content": "faced similar issue in java, solved it with by multiplying 1L (1 long) with potions[mid]*spells[i]"
                    },
                    {
                        "username": "user1160Ov",
                        "content": "I went through 2 arrays (spells and potions) using for loops. Gave a if condition to check if the product(spells[i]*potions[j]) can be greater then success and had a counter for every pair. basically the na\\xEFve approach. But it didn\\'t work for a certain test case(48th one). help me\\n\\nclass Solution {\\n\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n\\n        int n = spells.length;\\n        int m = potions.length;\\n\\n        int pairs[] = new int[n];\\n\\n        for(int i = 0; i<n; i++) {\\n            int successful = 0;\\n            for(int j = 0; j<m; j++) {\\n                int prod = spells[i]*potions[j];\\n                if(prod >= (int)success) {\\n                    successful++;\\n                }\\n            }\\n            pairs[i] = successful;\\n        }\\n\\n    return pairs;\\n\\n    }\\n}"
                    },
                    {
                        "username": "waiyankyaw961999",
                        "content": "Yes, if you approach that way, you will definitely get Time Limit Exceeded Error. Use binary search algorithms or sort the two arrays and scan only the specific portions."
                    },
                    {
                        "username": "TheCodeVenturer",
                        "content": "why ceil function misbehaved in c++\\ni tried \\n\\n```\\nlong div =ceil ((float)success/(float)i);\\n```\\nbut for a testcase it failed for a single value\\n```\\nlong div = success/i;\\n            if(success%i) div++;\\n```\\nbut this passed why?\\n"
                    },
                    {
                        "username": "vetor",
                        "content": "Dont use ```Long.valueOf(potions[mid] * spell) < success``` instead use \\n\\n```1L * potions[mid] * spell``` for elevation of int The 1L literal promotes the result of potions[mid] * spell to a long primitive before the multiplication is performed, ensuring that the result is a long primitive with the correct value and precision. \\n\\nhope this may help"
                    },
                    {
                        "username": "devildecoder",
                        "content": "This ques  is quiet easy but due to the integer overflow, runtime  error occurs so keep in this mind..."
                    }
                ]
            },
            {
                "id": 1851756,
                "content": [
                    {
                        "username": "dashingboy110035",
                        "content": "`for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                temp = (long)spells[i]*potions[j];\\n                if(temp >= success){\\n                    cnt++;\\n                }\\n                temp=0;\\n            }\\n            ans.push_back(cnt);\\n            cnt=0;\\n        }\\n        return ans;`\\n\\n51/56 demn constraints."
                    },
                    {
                        "username": "samsondanielcaps",
                        "content": "Passed 54/56 and got time limit exceeded is there any way i can improve the code:\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        Arrays.sort(potions);\\n        // Arrays.sort(spells);\\n        for(int i=0;i<spells.length;i++)\\n        {\\n            int c=0;\\n            for(int j=potions.length-1;j>=0;j--)\\n            {\\n                long n=(long)spells[i]*potions[j];\\n                if(n<success)\\n                {\\n                    break;\\n                }\\n                else{\\n                    c++;\\n                }\\n            }\\n            spells[i]=c;\\n        }    \\n        return spells;\\n    }\\n}"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "Try to write in code format or use proper indents, very hard to read\\n"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "55 / 56 testcases passed\\n\\uD83D\\uDE29"
                    },
                    {
                        "username": "HumbleFool22",
                        "content": "I\\'m solving this problem in brute froce approach plzz tell me what I did wrong here in this question .\\n\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        int arr2[]= new int[spells.length];\\n        for(int i = 0 ;i<spells.length;i++)\\n        {\\n            int arr1[]= Multiplication(spells[i],potions);\\n            arr2[i] = counting(arr1, success);\\n        }        \\n        return arr2;\\n\\n    }\\n    public static int counting (int arr[],long success)\\n    {\\n        int count =0;\\n        for(int i=0;i<arr.length;i++)\\n        {\\n            if(arr[i]>=success)\\n            {\\n                count++;\\n            }\\n        }\\n        return count ;\\n    } \\n    public static int[] Multiplication(int a , int potions[])\\n    {\\n        int arr[]= new int[potions.length];\\n        for(int i=0;i<potions.length;i++)\\n        {\\n            arr[i]= a*potions[i];\\n        }\\n\\n        return arr;\\n    } \\n}"
                    },
                    {
                        "username": "HumbleFool22",
                        "content": "my solution fail in 48th test case \\n"
                    },
                    {
                        "username": "crysqrlkys",
                        "content": "shadow wizard money gang\\nwe love casting spells"
                    },
                    {
                        "username": "jemuel90880",
                        "content": "Did somebody solve this is C lang? man I cant seem to past the 48/56 testcases. help..."
                    },
                    {
                        "username": "user2871e",
                        "content": "faced similar issue in java, solved it with by multiplying 1L (1 long) with potions[mid]*spells[i]"
                    },
                    {
                        "username": "user1160Ov",
                        "content": "I went through 2 arrays (spells and potions) using for loops. Gave a if condition to check if the product(spells[i]*potions[j]) can be greater then success and had a counter for every pair. basically the na\\xEFve approach. But it didn\\'t work for a certain test case(48th one). help me\\n\\nclass Solution {\\n\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n\\n        int n = spells.length;\\n        int m = potions.length;\\n\\n        int pairs[] = new int[n];\\n\\n        for(int i = 0; i<n; i++) {\\n            int successful = 0;\\n            for(int j = 0; j<m; j++) {\\n                int prod = spells[i]*potions[j];\\n                if(prod >= (int)success) {\\n                    successful++;\\n                }\\n            }\\n            pairs[i] = successful;\\n        }\\n\\n    return pairs;\\n\\n    }\\n}"
                    },
                    {
                        "username": "waiyankyaw961999",
                        "content": "Yes, if you approach that way, you will definitely get Time Limit Exceeded Error. Use binary search algorithms or sort the two arrays and scan only the specific portions."
                    },
                    {
                        "username": "TheCodeVenturer",
                        "content": "why ceil function misbehaved in c++\\ni tried \\n\\n```\\nlong div =ceil ((float)success/(float)i);\\n```\\nbut for a testcase it failed for a single value\\n```\\nlong div = success/i;\\n            if(success%i) div++;\\n```\\nbut this passed why?\\n"
                    },
                    {
                        "username": "vetor",
                        "content": "Dont use ```Long.valueOf(potions[mid] * spell) < success``` instead use \\n\\n```1L * potions[mid] * spell``` for elevation of int The 1L literal promotes the result of potions[mid] * spell to a long primitive before the multiplication is performed, ensuring that the result is a long primitive with the correct value and precision. \\n\\nhope this may help"
                    },
                    {
                        "username": "devildecoder",
                        "content": "This ques  is quiet easy but due to the integer overflow, runtime  error occurs so keep in this mind..."
                    }
                ]
            },
            {
                "id": 1851749,
                "content": [
                    {
                        "username": "dashingboy110035",
                        "content": "`for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                temp = (long)spells[i]*potions[j];\\n                if(temp >= success){\\n                    cnt++;\\n                }\\n                temp=0;\\n            }\\n            ans.push_back(cnt);\\n            cnt=0;\\n        }\\n        return ans;`\\n\\n51/56 demn constraints."
                    },
                    {
                        "username": "samsondanielcaps",
                        "content": "Passed 54/56 and got time limit exceeded is there any way i can improve the code:\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        Arrays.sort(potions);\\n        // Arrays.sort(spells);\\n        for(int i=0;i<spells.length;i++)\\n        {\\n            int c=0;\\n            for(int j=potions.length-1;j>=0;j--)\\n            {\\n                long n=(long)spells[i]*potions[j];\\n                if(n<success)\\n                {\\n                    break;\\n                }\\n                else{\\n                    c++;\\n                }\\n            }\\n            spells[i]=c;\\n        }    \\n        return spells;\\n    }\\n}"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "Try to write in code format or use proper indents, very hard to read\\n"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "55 / 56 testcases passed\\n\\uD83D\\uDE29"
                    },
                    {
                        "username": "HumbleFool22",
                        "content": "I\\'m solving this problem in brute froce approach plzz tell me what I did wrong here in this question .\\n\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        int arr2[]= new int[spells.length];\\n        for(int i = 0 ;i<spells.length;i++)\\n        {\\n            int arr1[]= Multiplication(spells[i],potions);\\n            arr2[i] = counting(arr1, success);\\n        }        \\n        return arr2;\\n\\n    }\\n    public static int counting (int arr[],long success)\\n    {\\n        int count =0;\\n        for(int i=0;i<arr.length;i++)\\n        {\\n            if(arr[i]>=success)\\n            {\\n                count++;\\n            }\\n        }\\n        return count ;\\n    } \\n    public static int[] Multiplication(int a , int potions[])\\n    {\\n        int arr[]= new int[potions.length];\\n        for(int i=0;i<potions.length;i++)\\n        {\\n            arr[i]= a*potions[i];\\n        }\\n\\n        return arr;\\n    } \\n}"
                    },
                    {
                        "username": "HumbleFool22",
                        "content": "my solution fail in 48th test case \\n"
                    },
                    {
                        "username": "crysqrlkys",
                        "content": "shadow wizard money gang\\nwe love casting spells"
                    },
                    {
                        "username": "jemuel90880",
                        "content": "Did somebody solve this is C lang? man I cant seem to past the 48/56 testcases. help..."
                    },
                    {
                        "username": "user2871e",
                        "content": "faced similar issue in java, solved it with by multiplying 1L (1 long) with potions[mid]*spells[i]"
                    },
                    {
                        "username": "user1160Ov",
                        "content": "I went through 2 arrays (spells and potions) using for loops. Gave a if condition to check if the product(spells[i]*potions[j]) can be greater then success and had a counter for every pair. basically the na\\xEFve approach. But it didn\\'t work for a certain test case(48th one). help me\\n\\nclass Solution {\\n\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n\\n        int n = spells.length;\\n        int m = potions.length;\\n\\n        int pairs[] = new int[n];\\n\\n        for(int i = 0; i<n; i++) {\\n            int successful = 0;\\n            for(int j = 0; j<m; j++) {\\n                int prod = spells[i]*potions[j];\\n                if(prod >= (int)success) {\\n                    successful++;\\n                }\\n            }\\n            pairs[i] = successful;\\n        }\\n\\n    return pairs;\\n\\n    }\\n}"
                    },
                    {
                        "username": "waiyankyaw961999",
                        "content": "Yes, if you approach that way, you will definitely get Time Limit Exceeded Error. Use binary search algorithms or sort the two arrays and scan only the specific portions."
                    },
                    {
                        "username": "TheCodeVenturer",
                        "content": "why ceil function misbehaved in c++\\ni tried \\n\\n```\\nlong div =ceil ((float)success/(float)i);\\n```\\nbut for a testcase it failed for a single value\\n```\\nlong div = success/i;\\n            if(success%i) div++;\\n```\\nbut this passed why?\\n"
                    },
                    {
                        "username": "vetor",
                        "content": "Dont use ```Long.valueOf(potions[mid] * spell) < success``` instead use \\n\\n```1L * potions[mid] * spell``` for elevation of int The 1L literal promotes the result of potions[mid] * spell to a long primitive before the multiplication is performed, ensuring that the result is a long primitive with the correct value and precision. \\n\\nhope this may help"
                    },
                    {
                        "username": "devildecoder",
                        "content": "This ques  is quiet easy but due to the integer overflow, runtime  error occurs so keep in this mind..."
                    }
                ]
            },
            {
                "id": 1851718,
                "content": [
                    {
                        "username": "dashingboy110035",
                        "content": "`for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                temp = (long)spells[i]*potions[j];\\n                if(temp >= success){\\n                    cnt++;\\n                }\\n                temp=0;\\n            }\\n            ans.push_back(cnt);\\n            cnt=0;\\n        }\\n        return ans;`\\n\\n51/56 demn constraints."
                    },
                    {
                        "username": "samsondanielcaps",
                        "content": "Passed 54/56 and got time limit exceeded is there any way i can improve the code:\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        Arrays.sort(potions);\\n        // Arrays.sort(spells);\\n        for(int i=0;i<spells.length;i++)\\n        {\\n            int c=0;\\n            for(int j=potions.length-1;j>=0;j--)\\n            {\\n                long n=(long)spells[i]*potions[j];\\n                if(n<success)\\n                {\\n                    break;\\n                }\\n                else{\\n                    c++;\\n                }\\n            }\\n            spells[i]=c;\\n        }    \\n        return spells;\\n    }\\n}"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "Try to write in code format or use proper indents, very hard to read\\n"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "55 / 56 testcases passed\\n\\uD83D\\uDE29"
                    },
                    {
                        "username": "HumbleFool22",
                        "content": "I\\'m solving this problem in brute froce approach plzz tell me what I did wrong here in this question .\\n\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        int arr2[]= new int[spells.length];\\n        for(int i = 0 ;i<spells.length;i++)\\n        {\\n            int arr1[]= Multiplication(spells[i],potions);\\n            arr2[i] = counting(arr1, success);\\n        }        \\n        return arr2;\\n\\n    }\\n    public static int counting (int arr[],long success)\\n    {\\n        int count =0;\\n        for(int i=0;i<arr.length;i++)\\n        {\\n            if(arr[i]>=success)\\n            {\\n                count++;\\n            }\\n        }\\n        return count ;\\n    } \\n    public static int[] Multiplication(int a , int potions[])\\n    {\\n        int arr[]= new int[potions.length];\\n        for(int i=0;i<potions.length;i++)\\n        {\\n            arr[i]= a*potions[i];\\n        }\\n\\n        return arr;\\n    } \\n}"
                    },
                    {
                        "username": "HumbleFool22",
                        "content": "my solution fail in 48th test case \\n"
                    },
                    {
                        "username": "crysqrlkys",
                        "content": "shadow wizard money gang\\nwe love casting spells"
                    },
                    {
                        "username": "jemuel90880",
                        "content": "Did somebody solve this is C lang? man I cant seem to past the 48/56 testcases. help..."
                    },
                    {
                        "username": "user2871e",
                        "content": "faced similar issue in java, solved it with by multiplying 1L (1 long) with potions[mid]*spells[i]"
                    },
                    {
                        "username": "user1160Ov",
                        "content": "I went through 2 arrays (spells and potions) using for loops. Gave a if condition to check if the product(spells[i]*potions[j]) can be greater then success and had a counter for every pair. basically the na\\xEFve approach. But it didn\\'t work for a certain test case(48th one). help me\\n\\nclass Solution {\\n\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n\\n        int n = spells.length;\\n        int m = potions.length;\\n\\n        int pairs[] = new int[n];\\n\\n        for(int i = 0; i<n; i++) {\\n            int successful = 0;\\n            for(int j = 0; j<m; j++) {\\n                int prod = spells[i]*potions[j];\\n                if(prod >= (int)success) {\\n                    successful++;\\n                }\\n            }\\n            pairs[i] = successful;\\n        }\\n\\n    return pairs;\\n\\n    }\\n}"
                    },
                    {
                        "username": "waiyankyaw961999",
                        "content": "Yes, if you approach that way, you will definitely get Time Limit Exceeded Error. Use binary search algorithms or sort the two arrays and scan only the specific portions."
                    },
                    {
                        "username": "TheCodeVenturer",
                        "content": "why ceil function misbehaved in c++\\ni tried \\n\\n```\\nlong div =ceil ((float)success/(float)i);\\n```\\nbut for a testcase it failed for a single value\\n```\\nlong div = success/i;\\n            if(success%i) div++;\\n```\\nbut this passed why?\\n"
                    },
                    {
                        "username": "vetor",
                        "content": "Dont use ```Long.valueOf(potions[mid] * spell) < success``` instead use \\n\\n```1L * potions[mid] * spell``` for elevation of int The 1L literal promotes the result of potions[mid] * spell to a long primitive before the multiplication is performed, ensuring that the result is a long primitive with the correct value and precision. \\n\\nhope this may help"
                    },
                    {
                        "username": "devildecoder",
                        "content": "This ques  is quiet easy but due to the integer overflow, runtime  error occurs so keep in this mind..."
                    }
                ]
            },
            {
                "id": 1851549,
                "content": [
                    {
                        "username": "dashingboy110035",
                        "content": "`for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                temp = (long)spells[i]*potions[j];\\n                if(temp >= success){\\n                    cnt++;\\n                }\\n                temp=0;\\n            }\\n            ans.push_back(cnt);\\n            cnt=0;\\n        }\\n        return ans;`\\n\\n51/56 demn constraints."
                    },
                    {
                        "username": "samsondanielcaps",
                        "content": "Passed 54/56 and got time limit exceeded is there any way i can improve the code:\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        Arrays.sort(potions);\\n        // Arrays.sort(spells);\\n        for(int i=0;i<spells.length;i++)\\n        {\\n            int c=0;\\n            for(int j=potions.length-1;j>=0;j--)\\n            {\\n                long n=(long)spells[i]*potions[j];\\n                if(n<success)\\n                {\\n                    break;\\n                }\\n                else{\\n                    c++;\\n                }\\n            }\\n            spells[i]=c;\\n        }    \\n        return spells;\\n    }\\n}"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "Try to write in code format or use proper indents, very hard to read\\n"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "55 / 56 testcases passed\\n\\uD83D\\uDE29"
                    },
                    {
                        "username": "HumbleFool22",
                        "content": "I\\'m solving this problem in brute froce approach plzz tell me what I did wrong here in this question .\\n\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        int arr2[]= new int[spells.length];\\n        for(int i = 0 ;i<spells.length;i++)\\n        {\\n            int arr1[]= Multiplication(spells[i],potions);\\n            arr2[i] = counting(arr1, success);\\n        }        \\n        return arr2;\\n\\n    }\\n    public static int counting (int arr[],long success)\\n    {\\n        int count =0;\\n        for(int i=0;i<arr.length;i++)\\n        {\\n            if(arr[i]>=success)\\n            {\\n                count++;\\n            }\\n        }\\n        return count ;\\n    } \\n    public static int[] Multiplication(int a , int potions[])\\n    {\\n        int arr[]= new int[potions.length];\\n        for(int i=0;i<potions.length;i++)\\n        {\\n            arr[i]= a*potions[i];\\n        }\\n\\n        return arr;\\n    } \\n}"
                    },
                    {
                        "username": "HumbleFool22",
                        "content": "my solution fail in 48th test case \\n"
                    },
                    {
                        "username": "crysqrlkys",
                        "content": "shadow wizard money gang\\nwe love casting spells"
                    },
                    {
                        "username": "jemuel90880",
                        "content": "Did somebody solve this is C lang? man I cant seem to past the 48/56 testcases. help..."
                    },
                    {
                        "username": "user2871e",
                        "content": "faced similar issue in java, solved it with by multiplying 1L (1 long) with potions[mid]*spells[i]"
                    },
                    {
                        "username": "user1160Ov",
                        "content": "I went through 2 arrays (spells and potions) using for loops. Gave a if condition to check if the product(spells[i]*potions[j]) can be greater then success and had a counter for every pair. basically the na\\xEFve approach. But it didn\\'t work for a certain test case(48th one). help me\\n\\nclass Solution {\\n\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n\\n        int n = spells.length;\\n        int m = potions.length;\\n\\n        int pairs[] = new int[n];\\n\\n        for(int i = 0; i<n; i++) {\\n            int successful = 0;\\n            for(int j = 0; j<m; j++) {\\n                int prod = spells[i]*potions[j];\\n                if(prod >= (int)success) {\\n                    successful++;\\n                }\\n            }\\n            pairs[i] = successful;\\n        }\\n\\n    return pairs;\\n\\n    }\\n}"
                    },
                    {
                        "username": "waiyankyaw961999",
                        "content": "Yes, if you approach that way, you will definitely get Time Limit Exceeded Error. Use binary search algorithms or sort the two arrays and scan only the specific portions."
                    },
                    {
                        "username": "TheCodeVenturer",
                        "content": "why ceil function misbehaved in c++\\ni tried \\n\\n```\\nlong div =ceil ((float)success/(float)i);\\n```\\nbut for a testcase it failed for a single value\\n```\\nlong div = success/i;\\n            if(success%i) div++;\\n```\\nbut this passed why?\\n"
                    },
                    {
                        "username": "vetor",
                        "content": "Dont use ```Long.valueOf(potions[mid] * spell) < success``` instead use \\n\\n```1L * potions[mid] * spell``` for elevation of int The 1L literal promotes the result of potions[mid] * spell to a long primitive before the multiplication is performed, ensuring that the result is a long primitive with the correct value and precision. \\n\\nhope this may help"
                    },
                    {
                        "username": "devildecoder",
                        "content": "This ques  is quiet easy but due to the integer overflow, runtime  error occurs so keep in this mind..."
                    }
                ]
            },
            {
                "id": 1851535,
                "content": [
                    {
                        "username": "dashingboy110035",
                        "content": "`for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                temp = (long)spells[i]*potions[j];\\n                if(temp >= success){\\n                    cnt++;\\n                }\\n                temp=0;\\n            }\\n            ans.push_back(cnt);\\n            cnt=0;\\n        }\\n        return ans;`\\n\\n51/56 demn constraints."
                    },
                    {
                        "username": "samsondanielcaps",
                        "content": "Passed 54/56 and got time limit exceeded is there any way i can improve the code:\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        Arrays.sort(potions);\\n        // Arrays.sort(spells);\\n        for(int i=0;i<spells.length;i++)\\n        {\\n            int c=0;\\n            for(int j=potions.length-1;j>=0;j--)\\n            {\\n                long n=(long)spells[i]*potions[j];\\n                if(n<success)\\n                {\\n                    break;\\n                }\\n                else{\\n                    c++;\\n                }\\n            }\\n            spells[i]=c;\\n        }    \\n        return spells;\\n    }\\n}"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "Try to write in code format or use proper indents, very hard to read\\n"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "55 / 56 testcases passed\\n\\uD83D\\uDE29"
                    },
                    {
                        "username": "HumbleFool22",
                        "content": "I\\'m solving this problem in brute froce approach plzz tell me what I did wrong here in this question .\\n\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        int arr2[]= new int[spells.length];\\n        for(int i = 0 ;i<spells.length;i++)\\n        {\\n            int arr1[]= Multiplication(spells[i],potions);\\n            arr2[i] = counting(arr1, success);\\n        }        \\n        return arr2;\\n\\n    }\\n    public static int counting (int arr[],long success)\\n    {\\n        int count =0;\\n        for(int i=0;i<arr.length;i++)\\n        {\\n            if(arr[i]>=success)\\n            {\\n                count++;\\n            }\\n        }\\n        return count ;\\n    } \\n    public static int[] Multiplication(int a , int potions[])\\n    {\\n        int arr[]= new int[potions.length];\\n        for(int i=0;i<potions.length;i++)\\n        {\\n            arr[i]= a*potions[i];\\n        }\\n\\n        return arr;\\n    } \\n}"
                    },
                    {
                        "username": "HumbleFool22",
                        "content": "my solution fail in 48th test case \\n"
                    },
                    {
                        "username": "crysqrlkys",
                        "content": "shadow wizard money gang\\nwe love casting spells"
                    },
                    {
                        "username": "jemuel90880",
                        "content": "Did somebody solve this is C lang? man I cant seem to past the 48/56 testcases. help..."
                    },
                    {
                        "username": "user2871e",
                        "content": "faced similar issue in java, solved it with by multiplying 1L (1 long) with potions[mid]*spells[i]"
                    },
                    {
                        "username": "user1160Ov",
                        "content": "I went through 2 arrays (spells and potions) using for loops. Gave a if condition to check if the product(spells[i]*potions[j]) can be greater then success and had a counter for every pair. basically the na\\xEFve approach. But it didn\\'t work for a certain test case(48th one). help me\\n\\nclass Solution {\\n\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n\\n        int n = spells.length;\\n        int m = potions.length;\\n\\n        int pairs[] = new int[n];\\n\\n        for(int i = 0; i<n; i++) {\\n            int successful = 0;\\n            for(int j = 0; j<m; j++) {\\n                int prod = spells[i]*potions[j];\\n                if(prod >= (int)success) {\\n                    successful++;\\n                }\\n            }\\n            pairs[i] = successful;\\n        }\\n\\n    return pairs;\\n\\n    }\\n}"
                    },
                    {
                        "username": "waiyankyaw961999",
                        "content": "Yes, if you approach that way, you will definitely get Time Limit Exceeded Error. Use binary search algorithms or sort the two arrays and scan only the specific portions."
                    },
                    {
                        "username": "TheCodeVenturer",
                        "content": "why ceil function misbehaved in c++\\ni tried \\n\\n```\\nlong div =ceil ((float)success/(float)i);\\n```\\nbut for a testcase it failed for a single value\\n```\\nlong div = success/i;\\n            if(success%i) div++;\\n```\\nbut this passed why?\\n"
                    },
                    {
                        "username": "vetor",
                        "content": "Dont use ```Long.valueOf(potions[mid] * spell) < success``` instead use \\n\\n```1L * potions[mid] * spell``` for elevation of int The 1L literal promotes the result of potions[mid] * spell to a long primitive before the multiplication is performed, ensuring that the result is a long primitive with the correct value and precision. \\n\\nhope this may help"
                    },
                    {
                        "username": "devildecoder",
                        "content": "This ques  is quiet easy but due to the integer overflow, runtime  error occurs so keep in this mind..."
                    }
                ]
            },
            {
                "id": 1851496,
                "content": [
                    {
                        "username": "dashingboy110035",
                        "content": "`for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                temp = (long)spells[i]*potions[j];\\n                if(temp >= success){\\n                    cnt++;\\n                }\\n                temp=0;\\n            }\\n            ans.push_back(cnt);\\n            cnt=0;\\n        }\\n        return ans;`\\n\\n51/56 demn constraints."
                    },
                    {
                        "username": "samsondanielcaps",
                        "content": "Passed 54/56 and got time limit exceeded is there any way i can improve the code:\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        Arrays.sort(potions);\\n        // Arrays.sort(spells);\\n        for(int i=0;i<spells.length;i++)\\n        {\\n            int c=0;\\n            for(int j=potions.length-1;j>=0;j--)\\n            {\\n                long n=(long)spells[i]*potions[j];\\n                if(n<success)\\n                {\\n                    break;\\n                }\\n                else{\\n                    c++;\\n                }\\n            }\\n            spells[i]=c;\\n        }    \\n        return spells;\\n    }\\n}"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "Try to write in code format or use proper indents, very hard to read\\n"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "55 / 56 testcases passed\\n\\uD83D\\uDE29"
                    },
                    {
                        "username": "HumbleFool22",
                        "content": "I\\'m solving this problem in brute froce approach plzz tell me what I did wrong here in this question .\\n\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        int arr2[]= new int[spells.length];\\n        for(int i = 0 ;i<spells.length;i++)\\n        {\\n            int arr1[]= Multiplication(spells[i],potions);\\n            arr2[i] = counting(arr1, success);\\n        }        \\n        return arr2;\\n\\n    }\\n    public static int counting (int arr[],long success)\\n    {\\n        int count =0;\\n        for(int i=0;i<arr.length;i++)\\n        {\\n            if(arr[i]>=success)\\n            {\\n                count++;\\n            }\\n        }\\n        return count ;\\n    } \\n    public static int[] Multiplication(int a , int potions[])\\n    {\\n        int arr[]= new int[potions.length];\\n        for(int i=0;i<potions.length;i++)\\n        {\\n            arr[i]= a*potions[i];\\n        }\\n\\n        return arr;\\n    } \\n}"
                    },
                    {
                        "username": "HumbleFool22",
                        "content": "my solution fail in 48th test case \\n"
                    },
                    {
                        "username": "crysqrlkys",
                        "content": "shadow wizard money gang\\nwe love casting spells"
                    },
                    {
                        "username": "jemuel90880",
                        "content": "Did somebody solve this is C lang? man I cant seem to past the 48/56 testcases. help..."
                    },
                    {
                        "username": "user2871e",
                        "content": "faced similar issue in java, solved it with by multiplying 1L (1 long) with potions[mid]*spells[i]"
                    },
                    {
                        "username": "user1160Ov",
                        "content": "I went through 2 arrays (spells and potions) using for loops. Gave a if condition to check if the product(spells[i]*potions[j]) can be greater then success and had a counter for every pair. basically the na\\xEFve approach. But it didn\\'t work for a certain test case(48th one). help me\\n\\nclass Solution {\\n\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n\\n        int n = spells.length;\\n        int m = potions.length;\\n\\n        int pairs[] = new int[n];\\n\\n        for(int i = 0; i<n; i++) {\\n            int successful = 0;\\n            for(int j = 0; j<m; j++) {\\n                int prod = spells[i]*potions[j];\\n                if(prod >= (int)success) {\\n                    successful++;\\n                }\\n            }\\n            pairs[i] = successful;\\n        }\\n\\n    return pairs;\\n\\n    }\\n}"
                    },
                    {
                        "username": "waiyankyaw961999",
                        "content": "Yes, if you approach that way, you will definitely get Time Limit Exceeded Error. Use binary search algorithms or sort the two arrays and scan only the specific portions."
                    },
                    {
                        "username": "TheCodeVenturer",
                        "content": "why ceil function misbehaved in c++\\ni tried \\n\\n```\\nlong div =ceil ((float)success/(float)i);\\n```\\nbut for a testcase it failed for a single value\\n```\\nlong div = success/i;\\n            if(success%i) div++;\\n```\\nbut this passed why?\\n"
                    },
                    {
                        "username": "vetor",
                        "content": "Dont use ```Long.valueOf(potions[mid] * spell) < success``` instead use \\n\\n```1L * potions[mid] * spell``` for elevation of int The 1L literal promotes the result of potions[mid] * spell to a long primitive before the multiplication is performed, ensuring that the result is a long primitive with the correct value and precision. \\n\\nhope this may help"
                    },
                    {
                        "username": "devildecoder",
                        "content": "This ques  is quiet easy but due to the integer overflow, runtime  error occurs so keep in this mind..."
                    }
                ]
            },
            {
                "id": 1851491,
                "content": [
                    {
                        "username": "dashingboy110035",
                        "content": "`for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                temp = (long)spells[i]*potions[j];\\n                if(temp >= success){\\n                    cnt++;\\n                }\\n                temp=0;\\n            }\\n            ans.push_back(cnt);\\n            cnt=0;\\n        }\\n        return ans;`\\n\\n51/56 demn constraints."
                    },
                    {
                        "username": "samsondanielcaps",
                        "content": "Passed 54/56 and got time limit exceeded is there any way i can improve the code:\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        Arrays.sort(potions);\\n        // Arrays.sort(spells);\\n        for(int i=0;i<spells.length;i++)\\n        {\\n            int c=0;\\n            for(int j=potions.length-1;j>=0;j--)\\n            {\\n                long n=(long)spells[i]*potions[j];\\n                if(n<success)\\n                {\\n                    break;\\n                }\\n                else{\\n                    c++;\\n                }\\n            }\\n            spells[i]=c;\\n        }    \\n        return spells;\\n    }\\n}"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "Try to write in code format or use proper indents, very hard to read\\n"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "55 / 56 testcases passed\\n\\uD83D\\uDE29"
                    },
                    {
                        "username": "HumbleFool22",
                        "content": "I\\'m solving this problem in brute froce approach plzz tell me what I did wrong here in this question .\\n\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        int arr2[]= new int[spells.length];\\n        for(int i = 0 ;i<spells.length;i++)\\n        {\\n            int arr1[]= Multiplication(spells[i],potions);\\n            arr2[i] = counting(arr1, success);\\n        }        \\n        return arr2;\\n\\n    }\\n    public static int counting (int arr[],long success)\\n    {\\n        int count =0;\\n        for(int i=0;i<arr.length;i++)\\n        {\\n            if(arr[i]>=success)\\n            {\\n                count++;\\n            }\\n        }\\n        return count ;\\n    } \\n    public static int[] Multiplication(int a , int potions[])\\n    {\\n        int arr[]= new int[potions.length];\\n        for(int i=0;i<potions.length;i++)\\n        {\\n            arr[i]= a*potions[i];\\n        }\\n\\n        return arr;\\n    } \\n}"
                    },
                    {
                        "username": "HumbleFool22",
                        "content": "my solution fail in 48th test case \\n"
                    },
                    {
                        "username": "crysqrlkys",
                        "content": "shadow wizard money gang\\nwe love casting spells"
                    },
                    {
                        "username": "jemuel90880",
                        "content": "Did somebody solve this is C lang? man I cant seem to past the 48/56 testcases. help..."
                    },
                    {
                        "username": "user2871e",
                        "content": "faced similar issue in java, solved it with by multiplying 1L (1 long) with potions[mid]*spells[i]"
                    },
                    {
                        "username": "user1160Ov",
                        "content": "I went through 2 arrays (spells and potions) using for loops. Gave a if condition to check if the product(spells[i]*potions[j]) can be greater then success and had a counter for every pair. basically the na\\xEFve approach. But it didn\\'t work for a certain test case(48th one). help me\\n\\nclass Solution {\\n\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n\\n        int n = spells.length;\\n        int m = potions.length;\\n\\n        int pairs[] = new int[n];\\n\\n        for(int i = 0; i<n; i++) {\\n            int successful = 0;\\n            for(int j = 0; j<m; j++) {\\n                int prod = spells[i]*potions[j];\\n                if(prod >= (int)success) {\\n                    successful++;\\n                }\\n            }\\n            pairs[i] = successful;\\n        }\\n\\n    return pairs;\\n\\n    }\\n}"
                    },
                    {
                        "username": "waiyankyaw961999",
                        "content": "Yes, if you approach that way, you will definitely get Time Limit Exceeded Error. Use binary search algorithms or sort the two arrays and scan only the specific portions."
                    },
                    {
                        "username": "TheCodeVenturer",
                        "content": "why ceil function misbehaved in c++\\ni tried \\n\\n```\\nlong div =ceil ((float)success/(float)i);\\n```\\nbut for a testcase it failed for a single value\\n```\\nlong div = success/i;\\n            if(success%i) div++;\\n```\\nbut this passed why?\\n"
                    },
                    {
                        "username": "vetor",
                        "content": "Dont use ```Long.valueOf(potions[mid] * spell) < success``` instead use \\n\\n```1L * potions[mid] * spell``` for elevation of int The 1L literal promotes the result of potions[mid] * spell to a long primitive before the multiplication is performed, ensuring that the result is a long primitive with the correct value and precision. \\n\\nhope this may help"
                    },
                    {
                        "username": "devildecoder",
                        "content": "This ques  is quiet easy but due to the integer overflow, runtime  error occurs so keep in this mind..."
                    }
                ]
            },
            {
                "id": 1851478,
                "content": [
                    {
                        "username": "dashingboy110035",
                        "content": "`for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                temp = (long)spells[i]*potions[j];\\n                if(temp >= success){\\n                    cnt++;\\n                }\\n                temp=0;\\n            }\\n            ans.push_back(cnt);\\n            cnt=0;\\n        }\\n        return ans;`\\n\\n51/56 demn constraints."
                    },
                    {
                        "username": "samsondanielcaps",
                        "content": "Passed 54/56 and got time limit exceeded is there any way i can improve the code:\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        Arrays.sort(potions);\\n        // Arrays.sort(spells);\\n        for(int i=0;i<spells.length;i++)\\n        {\\n            int c=0;\\n            for(int j=potions.length-1;j>=0;j--)\\n            {\\n                long n=(long)spells[i]*potions[j];\\n                if(n<success)\\n                {\\n                    break;\\n                }\\n                else{\\n                    c++;\\n                }\\n            }\\n            spells[i]=c;\\n        }    \\n        return spells;\\n    }\\n}"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "Try to write in code format or use proper indents, very hard to read\\n"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "55 / 56 testcases passed\\n\\uD83D\\uDE29"
                    },
                    {
                        "username": "HumbleFool22",
                        "content": "I\\'m solving this problem in brute froce approach plzz tell me what I did wrong here in this question .\\n\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        int arr2[]= new int[spells.length];\\n        for(int i = 0 ;i<spells.length;i++)\\n        {\\n            int arr1[]= Multiplication(spells[i],potions);\\n            arr2[i] = counting(arr1, success);\\n        }        \\n        return arr2;\\n\\n    }\\n    public static int counting (int arr[],long success)\\n    {\\n        int count =0;\\n        for(int i=0;i<arr.length;i++)\\n        {\\n            if(arr[i]>=success)\\n            {\\n                count++;\\n            }\\n        }\\n        return count ;\\n    } \\n    public static int[] Multiplication(int a , int potions[])\\n    {\\n        int arr[]= new int[potions.length];\\n        for(int i=0;i<potions.length;i++)\\n        {\\n            arr[i]= a*potions[i];\\n        }\\n\\n        return arr;\\n    } \\n}"
                    },
                    {
                        "username": "HumbleFool22",
                        "content": "my solution fail in 48th test case \\n"
                    },
                    {
                        "username": "crysqrlkys",
                        "content": "shadow wizard money gang\\nwe love casting spells"
                    },
                    {
                        "username": "jemuel90880",
                        "content": "Did somebody solve this is C lang? man I cant seem to past the 48/56 testcases. help..."
                    },
                    {
                        "username": "user2871e",
                        "content": "faced similar issue in java, solved it with by multiplying 1L (1 long) with potions[mid]*spells[i]"
                    },
                    {
                        "username": "user1160Ov",
                        "content": "I went through 2 arrays (spells and potions) using for loops. Gave a if condition to check if the product(spells[i]*potions[j]) can be greater then success and had a counter for every pair. basically the na\\xEFve approach. But it didn\\'t work for a certain test case(48th one). help me\\n\\nclass Solution {\\n\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n\\n        int n = spells.length;\\n        int m = potions.length;\\n\\n        int pairs[] = new int[n];\\n\\n        for(int i = 0; i<n; i++) {\\n            int successful = 0;\\n            for(int j = 0; j<m; j++) {\\n                int prod = spells[i]*potions[j];\\n                if(prod >= (int)success) {\\n                    successful++;\\n                }\\n            }\\n            pairs[i] = successful;\\n        }\\n\\n    return pairs;\\n\\n    }\\n}"
                    },
                    {
                        "username": "waiyankyaw961999",
                        "content": "Yes, if you approach that way, you will definitely get Time Limit Exceeded Error. Use binary search algorithms or sort the two arrays and scan only the specific portions."
                    },
                    {
                        "username": "TheCodeVenturer",
                        "content": "why ceil function misbehaved in c++\\ni tried \\n\\n```\\nlong div =ceil ((float)success/(float)i);\\n```\\nbut for a testcase it failed for a single value\\n```\\nlong div = success/i;\\n            if(success%i) div++;\\n```\\nbut this passed why?\\n"
                    },
                    {
                        "username": "vetor",
                        "content": "Dont use ```Long.valueOf(potions[mid] * spell) < success``` instead use \\n\\n```1L * potions[mid] * spell``` for elevation of int The 1L literal promotes the result of potions[mid] * spell to a long primitive before the multiplication is performed, ensuring that the result is a long primitive with the correct value and precision. \\n\\nhope this may help"
                    },
                    {
                        "username": "devildecoder",
                        "content": "This ques  is quiet easy but due to the integer overflow, runtime  error occurs so keep in this mind..."
                    }
                ]
            },
            {
                "id": 1851457,
                "content": [
                    {
                        "username": "dashingboy110035",
                        "content": "`for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                temp = (long)spells[i]*potions[j];\\n                if(temp >= success){\\n                    cnt++;\\n                }\\n                temp=0;\\n            }\\n            ans.push_back(cnt);\\n            cnt=0;\\n        }\\n        return ans;`\\n\\n51/56 demn constraints."
                    },
                    {
                        "username": "samsondanielcaps",
                        "content": "Passed 54/56 and got time limit exceeded is there any way i can improve the code:\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        Arrays.sort(potions);\\n        // Arrays.sort(spells);\\n        for(int i=0;i<spells.length;i++)\\n        {\\n            int c=0;\\n            for(int j=potions.length-1;j>=0;j--)\\n            {\\n                long n=(long)spells[i]*potions[j];\\n                if(n<success)\\n                {\\n                    break;\\n                }\\n                else{\\n                    c++;\\n                }\\n            }\\n            spells[i]=c;\\n        }    \\n        return spells;\\n    }\\n}"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "Try to write in code format or use proper indents, very hard to read\\n"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "55 / 56 testcases passed\\n\\uD83D\\uDE29"
                    },
                    {
                        "username": "HumbleFool22",
                        "content": "I\\'m solving this problem in brute froce approach plzz tell me what I did wrong here in this question .\\n\\nclass Solution {\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n        int arr2[]= new int[spells.length];\\n        for(int i = 0 ;i<spells.length;i++)\\n        {\\n            int arr1[]= Multiplication(spells[i],potions);\\n            arr2[i] = counting(arr1, success);\\n        }        \\n        return arr2;\\n\\n    }\\n    public static int counting (int arr[],long success)\\n    {\\n        int count =0;\\n        for(int i=0;i<arr.length;i++)\\n        {\\n            if(arr[i]>=success)\\n            {\\n                count++;\\n            }\\n        }\\n        return count ;\\n    } \\n    public static int[] Multiplication(int a , int potions[])\\n    {\\n        int arr[]= new int[potions.length];\\n        for(int i=0;i<potions.length;i++)\\n        {\\n            arr[i]= a*potions[i];\\n        }\\n\\n        return arr;\\n    } \\n}"
                    },
                    {
                        "username": "HumbleFool22",
                        "content": "my solution fail in 48th test case \\n"
                    },
                    {
                        "username": "crysqrlkys",
                        "content": "shadow wizard money gang\\nwe love casting spells"
                    },
                    {
                        "username": "jemuel90880",
                        "content": "Did somebody solve this is C lang? man I cant seem to past the 48/56 testcases. help..."
                    },
                    {
                        "username": "user2871e",
                        "content": "faced similar issue in java, solved it with by multiplying 1L (1 long) with potions[mid]*spells[i]"
                    },
                    {
                        "username": "user1160Ov",
                        "content": "I went through 2 arrays (spells and potions) using for loops. Gave a if condition to check if the product(spells[i]*potions[j]) can be greater then success and had a counter for every pair. basically the na\\xEFve approach. But it didn\\'t work for a certain test case(48th one). help me\\n\\nclass Solution {\\n\\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\\n\\n        int n = spells.length;\\n        int m = potions.length;\\n\\n        int pairs[] = new int[n];\\n\\n        for(int i = 0; i<n; i++) {\\n            int successful = 0;\\n            for(int j = 0; j<m; j++) {\\n                int prod = spells[i]*potions[j];\\n                if(prod >= (int)success) {\\n                    successful++;\\n                }\\n            }\\n            pairs[i] = successful;\\n        }\\n\\n    return pairs;\\n\\n    }\\n}"
                    },
                    {
                        "username": "waiyankyaw961999",
                        "content": "Yes, if you approach that way, you will definitely get Time Limit Exceeded Error. Use binary search algorithms or sort the two arrays and scan only the specific portions."
                    },
                    {
                        "username": "TheCodeVenturer",
                        "content": "why ceil function misbehaved in c++\\ni tried \\n\\n```\\nlong div =ceil ((float)success/(float)i);\\n```\\nbut for a testcase it failed for a single value\\n```\\nlong div = success/i;\\n            if(success%i) div++;\\n```\\nbut this passed why?\\n"
                    },
                    {
                        "username": "vetor",
                        "content": "Dont use ```Long.valueOf(potions[mid] * spell) < success``` instead use \\n\\n```1L * potions[mid] * spell``` for elevation of int The 1L literal promotes the result of potions[mid] * spell to a long primitive before the multiplication is performed, ensuring that the result is a long primitive with the correct value and precision. \\n\\nhope this may help"
                    },
                    {
                        "username": "devildecoder",
                        "content": "This ques  is quiet easy but due to the integer overflow, runtime  error occurs so keep in this mind..."
                    }
                ]
            }
        ]
    },
    {
        "title": "Selling Pieces of Wood",
        "question_content": "<p>You are given two integers <code>m</code> and <code>n</code> that represent the height and width of a rectangular piece of wood. You are also given a 2D integer array <code>prices</code>, where <code>prices[i] = [h<sub>i</sub>, w<sub>i</sub>, price<sub>i</sub>]</code> indicates you can sell a rectangular piece of wood of height <code>h<sub>i</sub></code> and width <code>w<sub>i</sub></code> for <code>price<sub>i</sub></code> dollars.</p>\n\n<p>To cut a piece of wood, you must make a vertical or horizontal cut across the <strong>entire</strong> height or width of the piece to split it into two smaller pieces. After cutting a piece of wood into some number of smaller pieces, you can sell pieces according to <code>prices</code>. You may sell multiple pieces of the same shape, and you do not have to sell all the shapes. The grain of the wood makes a difference, so you <strong>cannot</strong> rotate a piece to swap its height and width.</p>\n\n<p>Return <em>the <strong>maximum</strong> money you can earn after cutting an </em><code>m x n</code><em> piece of wood</em>.</p>\n\n<p>Note that you can cut the piece of wood as many times as you want.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/04/27/ex1.png\" style=\"width: 239px; height: 150px;\" />\n<pre>\n<strong>Input:</strong> m = 3, n = 5, prices = [[1,4,2],[2,2,7],[2,1,3]]\n<strong>Output:</strong> 19\n<strong>Explanation:</strong> The diagram above shows a possible scenario. It consists of:\n- 2 pieces of wood shaped 2 x 2, selling for a price of 2 * 7 = 14.\n- 1 piece of wood shaped 2 x 1, selling for a price of 1 * 3 = 3.\n- 1 piece of wood shaped 1 x 4, selling for a price of 1 * 2 = 2.\nThis obtains a total of 14 + 3 + 2 = 19 money earned.\nIt can be shown that 19 is the maximum amount of money that can be earned.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/04/27/ex2new.png\" style=\"width: 250px; height: 175px;\" />\n<pre>\n<strong>Input:</strong> m = 4, n = 6, prices = [[3,2,10],[1,4,2],[4,1,3]]\n<strong>Output:</strong> 32\n<strong>Explanation:</strong> The diagram above shows a possible scenario. It consists of:\n- 3 pieces of wood shaped 3 x 2, selling for a price of 3 * 10 = 30.\n- 1 piece of wood shaped 1 x 4, selling for a price of 1 * 2 = 2.\nThis obtains a total of 30 + 2 = 32 money earned.\nIt can be shown that 32 is the maximum amount of money that can be earned.\nNotice that we cannot rotate the 1 x 4 piece of wood to obtain a 4 x 1 piece of wood.</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= m, n &lt;= 200</code></li>\n\t<li><code>1 &lt;= prices.length &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>prices[i].length == 3</code></li>\n\t<li><code>1 &lt;= h<sub>i</sub> &lt;= m</code></li>\n\t<li><code>1 &lt;= w<sub>i</sub> &lt;= n</code></li>\n\t<li><code>1 &lt;= price<sub>i</sub> &lt;= 10<sup>6</sup></code></li>\n\t<li>All the shapes of wood <code>(h<sub>i</sub>, w<sub>i</sub>)</code> are pairwise <strong>distinct</strong>.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 2168148,
                "title": "java-c-python-bottom-up-dp",
                "content": "# **Intuition**\\nMust cut across the **entire** height or width of the piece,\\nthis leads up to the dp soluition.\\n<br>\\n\\n# **Explanation**\\nFor a piece of `w * h`,\\n\\nwe can make a vertical cut to split it into `a * h` and `(w - a) * h`\\nSo we can update `dp[w][h] = max(dp[w][h], dp[a][h] + dp[w - a][h])`.\\n\\nwe can make a horizontal cut to split it into  `w * a` and `w * (h - a)`\\nSo we can update `dp[w][h] = max(dp[w][h], dp[w][a] + dp[w][h - a])`.\\n<br>\\n\\n# **Complexity**\\nTime `O(mmn + mnn)`\\nSpace `O(mn)`\\n<br>\\n\\n**Java**\\n```java\\n    public long sellingWood(int m, int n, int[][] prices) {\\n        long[][] dp = new long[m + 1][n + 1];\\n        for (int[] p : prices)\\n            dp[p[0]][p[1]] = p[2];\\n        for (int w = 1; w <= m; ++w) {\\n            for (int h = 1; h <= n; ++h) {\\n                for (int a = 1; a <= w / 2; ++a)\\n                    dp[w][h] = Math.max(dp[w][h], dp[a][h] + dp[w - a][h]);\\n                for (int a = 1; a <= h / 2; ++a)\\n                    dp[w][h] = Math.max(dp[w][h], dp[w][a] + dp[w][h - a]);\\n            }\\n        }\\n        return dp[m][n];\\n    }\\n```\\n\\n**C++**\\n```cpp\\n    long long sellingWood(int m, int n, vector<vector<int>>& prices) {\\n        long long dp[201][201] = {};\\n        for (auto& p: prices)\\n            dp[p[0]][p[1]] = p[2];\\n        for (int w = 1; w <= m; ++w) {\\n            for (int h = 1; h <= n; ++h) {\\n                for (int a = 1; a <= w / 2; ++a)\\n                    dp[w][h] = max(dp[w][h], dp[a][h] + dp[w - a][h]);\\n                for (int a = 1; a <= h / 2; ++a)\\n                    dp[w][h] = max(dp[w][h], dp[w][a] + dp[w][h - a]);\\n            }\\n        }\\n        return dp[m][n];\\n    }\\n```\\n\\n**Python**\\n```py\\n    def sellingWood(self, m, n, prices):\\n        dp = [[0] * (n + 1) for i in range(m+1)]\\n        for w, h, p in prices:\\n            dp[w][h] = p\\n        for w in range(1, m + 1):\\n            for h in range(1, n + 1):\\n                for a in range(1, w // 2 + 1):\\n                    dp[w][h] = max(dp[w][h], dp[a][h] + dp[w - a][h])\\n                for a in range(1, h // 2 + 1):\\n                    dp[w][h] = max(dp[w][h], dp[w][a] + dp[w][h - a])\\n        return dp[m][n]\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```java\\n    public long sellingWood(int m, int n, int[][] prices) {\\n        long[][] dp = new long[m + 1][n + 1];\\n        for (int[] p : prices)\\n            dp[p[0]][p[1]] = p[2];\\n        for (int w = 1; w <= m; ++w) {\\n            for (int h = 1; h <= n; ++h) {\\n                for (int a = 1; a <= w / 2; ++a)\\n                    dp[w][h] = Math.max(dp[w][h], dp[a][h] + dp[w - a][h]);\\n                for (int a = 1; a <= h / 2; ++a)\\n                    dp[w][h] = Math.max(dp[w][h], dp[w][a] + dp[w][h - a]);\\n            }\\n        }\\n        return dp[m][n];\\n    }\\n```\n```cpp\\n    long long sellingWood(int m, int n, vector<vector<int>>& prices) {\\n        long long dp[201][201] = {};\\n        for (auto& p: prices)\\n            dp[p[0]][p[1]] = p[2];\\n        for (int w = 1; w <= m; ++w) {\\n            for (int h = 1; h <= n; ++h) {\\n                for (int a = 1; a <= w / 2; ++a)\\n                    dp[w][h] = max(dp[w][h], dp[a][h] + dp[w - a][h]);\\n                for (int a = 1; a <= h / 2; ++a)\\n                    dp[w][h] = max(dp[w][h], dp[w][a] + dp[w][h - a]);\\n            }\\n        }\\n        return dp[m][n];\\n    }\\n```\n```py\\n    def sellingWood(self, m, n, prices):\\n        dp = [[0] * (n + 1) for i in range(m+1)]\\n        for w, h, p in prices:\\n            dp[w][h] = p\\n        for w in range(1, m + 1):\\n            for h in range(1, n + 1):\\n                for a in range(1, w // 2 + 1):\\n                    dp[w][h] = max(dp[w][h], dp[a][h] + dp[w - a][h])\\n                for a in range(1, h // 2 + 1):\\n                    dp[w][h] = max(dp[w][h], dp[w][a] + dp[w][h - a])\\n        return dp[m][n]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2170082,
                "title": "partition-dp-recursion-memoization-tabulation-space-optimization",
                "content": "#####  **Let\\'s Start The Journey of Solving This Beautiful Problem** \\uD83D\\uDE09\\n\\n\\n**Step - 1** **(*Understanding what the problem states*)**\\n\\nWe have to `explore all possible ways `\\n(i.e cut the wood in all possible ways both row wise and column wise)\\nand `return` the case in which we can earn `maximum money`.\\n\\n****\\n\\t\\n**Step - 2** **(*How to approach the problem*)**\\n\\nAccording to step - 1, we have `explore all possible` ways \\nin which wood can be cut both row-wise and column-wise. \\nSo, we have to `use Recursion`.\\n\\t\\n****\\n\\n**Step - 3** **(*Writing Recursion / Top-Down Approach*)**\\t\\n\\n**Obervation :** \\nIt is difficult to work with the `Prices` matrix given. So, we have to store the prices into a data structure (like `HashMap`, `2D Vector` etc.) according to the `height` and `width` of the wood. Here, I will use HashMap.\\n\\n**How To Write Recursion ? :**\\n1. To Explore all possible ways, we can cut the Rectangular wood both row-wise and column-wise `independently`.\\n[**Why independently? :** \\nAccording to the question; `To cut a piece of wood, you must make a vertical or horizontal cut across the entire height or width of the piece to split it into two smaller pieces`. This is why we can consider vertical and horizontal cuts independently.] \\n\\t\\n\\tI.  If length of `row` is `m`, then we can do partition at `1,2,3,....,m-1`.\\n\\n\\tII.  If length of `column` is `n`, then we can do partition at `1,2,3,....,n-1`.\\n\\n2.  `Return` the `maximum` of all cases.\\n\\n3. ***Base case -*** The `partitions` for which `price is not given`, we have to `return 0`.\\n\\n**Code :** \\n\\n\\tclass Solution {\\n\\tprivate:\\n\\t\\tlong long f(int row, int col, map<pair<int,int>,long long> &mp){\\n\\n\\t\\t\\t//Base case is tackled in this line\\n\\t\\t\\tlong long ans = mp[{row,col}]; \\n\\n\\t\\t\\tfor(int i = 1;i < row;i++) //Partitions Row-wise\\n\\t\\t\\t\\tans = max(ans,f(i,col,mp) + f(row-i,col,mp));\\n\\n\\t\\t\\tfor(int j = 1;j < col;j++) //Partitions Column-wise\\n\\t\\t\\t\\tans = max(ans,f(row, j, mp) + f(row, col-j, mp));\\n\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\tpublic:\\n\\t\\tlong long sellingWood(int m, int n, vector<vector<int>>& prices) {\\n\\t\\t\\t//Declaring the HashMap\\n\\t\\t\\tmap<pair<int,int>,long long> mp;\\n\\n\\t\\t\\t//Storing Prices in HashMap where {height,width} of wood is key and {Price} is value\\n\\t\\t\\tfor(int i = 0;i < prices.size();i++)\\n\\t\\t\\t\\tmp[{prices[i][0],prices[i][1]}] = prices[i][2];\\n\\n\\t\\t\\treturn f(m,n,mp);\\n\\t\\t}\\n\\t};\\n\\n\\n**Time complexity -** *Exponential*\\n**Space complexity -** *O(k) + O(m + n)* [ Recursion stack space], k = `Size` of `Prices` Array Given\\n\\n**Result :** *Time Limit Exceded*\\n\\n****\\n\\n**Step - 4** **(*Optimizing Recursion / Top-Down Approach*)**\\t\\n\\n**Obervation :** \\nDue to symmetry, If we do partitions till (row/2) and (col/2), we will be able to explore all possible ways.\\n***Example -***\\nFor `i = 3 & row = 7`; \\nwe will call `f(3,col,mp) + f(7-3,col,mp)` i.e `f(3,col,mp) + f(4,col,mp)`.\\nNo point to call it again for `i = 4 & row = 7` i.e `f(4,col,mp) + f(3,col,mp)`\\n\\n**Code :**\\n\\n\\tclass Solution {\\n\\tprivate:\\n\\t\\tlong long f(int row, int col, map<pair<int,int>,long long> &mp){\\n\\n\\t\\t\\t//Base case is tackled in this line\\n\\t\\t\\tlong long ans = mp[{row,col}]; \\n\\n\\t\\t\\tfor(int i = 1;i <= row/2;i++) //Partitions Row-wise\\n\\t\\t\\t\\tans = max(ans,f(i,col,mp) + f(row-i,col,mp));\\n\\n\\t\\t\\tfor(int j = 1;j <= col/2;j++) //Partitions Column-wise\\n\\t\\t\\t\\tans = max(ans,f(row, j, mp) + f(row, col-j, mp));\\n\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\tpublic:\\n\\t\\tlong long sellingWood(int m, int n, vector<vector<int>>& prices) {\\n\\t\\t\\t//Declaring the HashMap\\n\\t\\t\\tmap<pair<int,int>,long long> mp;\\n\\n\\t\\t\\t//Storing Prices in HashMap where {height,width} of wood is key and {Price} is value\\n\\t\\t\\tfor(int i = 0;i < prices.size();i++)\\n\\t\\t\\t\\tmp[{prices[i][0],prices[i][1]}] = prices[i][2];\\n\\n\\t\\t\\treturn f(m,n,mp);\\n\\t\\t}\\n\\t};\\n\\t\\n**Time complexity -** *Exponential*\\n**Space complexity -** *O(k) + O(m + n)* [ Recursion stack space], k = `Size` of `Prices` Array Given\\n\\n**Result :** *Time Limit Exceded*\\n\\n****\\n\\n**Step - 5** **(*Writing Memoization*)**\\n\\n**Obervation :** \\nIf you `draw Recursion Tree`, You will `observe` there will be lots of `Overlapping Sub-Problems`.\\nSo, we have to `use Memoization`.\\n\\n**How To Write Memoization ? :**\\n\\n1.  See the `range` of `row` and `col` variable.\\n\\t I. `row` - `[1,m]`\\n\\t II. `col` - `[1,n]`\\n2. Declare a 2D Vector (say, `dp`)\\tOf length `[max(row)+1][max(col)+1]` and `Intialised` with a value not in the constraints (like `-1` here) i.e v`ector<vector<long long>> dp(m+1,vector<long long>(n+1,-1));`\\n3. Now before going into recursion call check (i.e `if(dp[row][col] != -1)`) if the value is already computed or not. If computed return it (i.e `return dp[row][col]`), no need to compute it again.\\n4. Every time returning the value of recursion call store it in `dp[row][col]` so that we can use it again.\\n\\n**Code :**\\n\\n\\tclass Solution {\\n\\tprivate:\\n\\t\\tlong long f(int row, int col, map<pair<int,int>,long long> &mp,vector<vector<long long>> &dp){\\n\\t\\t\\t//Check pre-computed previously or not\\n\\t\\t\\tif(dp[row][col] != -1) return dp[row][col];\\n\\n\\t\\t\\t//Base Case is tackled under this\\n\\t\\t\\tlong long ans = mp[{row,col}]; \\n\\n\\t\\t\\tfor(int i = 1;i <= row/2;i++) //Partitions Row-wise\\n\\t\\t\\t\\tans = max(ans,f(i,col,mp,dp) + f(row-i,col,mp,dp));\\n\\n\\t\\t\\tfor(int j = 1;j <= col/2;j++) //Partitions Column-wise\\n\\t\\t\\t\\tans = max(ans,f(row, j, mp,dp) + f(row, col-j, mp,dp));\\n\\n\\t\\t\\t//store ans in dp array before returning so that we can use it again.\\n\\t\\t\\treturn dp[row][col] = ans; \\n\\t\\t}\\n\\tpublic:\\n\\t\\tlong long sellingWood(int m, int n, vector<vector<int>>& prices) {\\n\\t\\t\\t//Declaring the HashMap\\n\\t\\t\\tmap<pair<int,int>,long long> mp;\\n\\n\\t\\t\\t//Storing Prices in HashMap where {height,width} of wood is key and {Price} is value\\n\\t\\t\\tfor(int i = 0;i < prices.size();i++)\\n\\t\\t\\t\\tmp[{prices[i][0],prices[i][1]}] = prices[i][2];\\n\\n\\t\\t\\tvector<vector<long long>> dp(m+1,vector<long long>(n+1,-1));\\n\\t\\t\\treturn f(m,n,mp,dp);\\n\\t\\t}\\n\\t};\\n\\n**Time complexity -** *O(mn(m+n))*\\n**Space complexity -** *O(mn) + O(k) + O(m + n)* [ Recursion stack space], k = `Size` of `Prices` Array Given\\n\\n**Result :** *Accepted*\\n\\n****\\n\\n**Step - 6** **(*Writing Tabulation / Bottom-Up Approach*)**\\t\\n\\n**Why To Do Tabulation ? :**\\nTo remove the `Recursion stack Space` (i.e `O(m + n)`) we are using.\\n\\n**How To Write Tabulation? :**\\n\\n1. `Tabulation` is `Bottom-up` approach i.e `opposite` of `Top-Down / Recursion`. So, here we will run loop in `opposite order` i.e `row - 1,2,3,4....m` and `column - 1,2,3,....n.`\\n2. `Copy & Paste` the `recursion` inside the loop `i.e`\\n\\t\\t\\n\\t\\t//Base Case is tackled under this\\n\\t\\tlong long ans = mp[{row,col}]; \\n\\n\\t\\tfor(int i = 1;i <= row/2;i++) //Partitions Row-wise\\n\\t\\t\\tans = max(ans,f(i,col,mp,dp) + f(row-i,col,mp,dp));\\n\\n\\t\\tfor(int j = 1;j <= col/2;j++) //Partitions Column-wise\\n\\t\\t\\tans = max(ans,f(row, j, mp,dp) + f(row, col-j, mp,dp));\\n\\n\\t\\t//store ans in dp array before returning so that we can use it again.\\n\\t\\treturn dp[row][col] = ans;\\n\\tand `change function to dp array` ( like `f(i,col,mp,dp)` to `dp[i][col]`).\\n3. `Remove return` from `return dp[row][col] = ans;`\\n4. Atlast change return statement `return f(m,n,mp,dp)` to `return dp[m][n]`.\\n\\n\\n**Code :**\\n\\t \\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tlong long sellingWood(int m, int n, vector<vector<int>>& prices) {\\n\\t\\t\\t//Declaring the HashMap\\n\\t\\t\\tmap<pair<int,int>,long long> mp;\\n\\n\\t\\t\\t//Storing Prices in HashMap where {height,width} of wood is key and {Price} is value\\n\\t\\t\\tfor(int i = 0;i < prices.size();i++)\\n\\t\\t\\t\\tmp[{prices[i][0],prices[i][1]}] = prices[i][2];\\n\\n\\t\\t\\tvector<vector<long long>> dp(m+1,vector<long long>(n+1,-1));\\n\\n\\t\\t\\tfor(int row = 1;row <= m;row++){ //loop reversed\\n\\t\\t\\t\\tfor(int col = 1;col <= n;col++){ //loop reversed\\n\\n\\t\\t\\t\\t\\t//Base Case is tackled under this\\n\\t\\t\\t\\t\\tlong long ans = mp[{row,col}]; \\n\\n\\t\\t\\t\\t\\tfor(int i = 1;i <= row/2;i++) //Partitions Row-wise\\n\\t\\t\\t\\t\\t\\tans = max(ans,dp[i][col] + dp[row-i][col]);\\n\\n\\t\\t\\t\\t\\tfor(int j = 1;j <= col/2;j++) //Partitions Column-wise\\n\\t\\t\\t\\t\\t\\tans = max(ans,dp[row][j] + dp[row][col-j]);\\n\\n\\t\\t\\t\\t\\t//store ans in dp array before returning so that we can use it again.\\n\\t\\t\\t\\t\\tdp[row][col] = ans;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn dp[m][n];\\n\\t\\t}\\n\\t};\\n\\n\\n**Time complexity -** *O(mn(m+n))*\\n**Space complexity -** *O(mn) + O(k)*, k = `Size` of `Prices` Array Given\\n\\n**Result :** *Accepted*\\n\\n****\\n\\n**Step - 7** **(*Writing Space Optimization*)**\\n\\n**Obervation :** \\n1. If you can `fill the dp array`,then you will see, we `donot need HashMap` to `store prices`. `We can directly store prices in dp array`.\\n2. `Previously`, we are `tackling base case` in `long long ans = mp[{row,col}]; ` .` Now`, if we  `initialized dp array by 0`,then base case will be tackled.\\n\\n\\n**Code :**\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tlong long sellingWood(int m, int n, vector<vector<int>>& prices) {     \\n\\t\\t\\t//Base case is tackled in this declaration as we initialized the dp array with 0.\\n\\t\\t\\tvector<vector<long long>> dp(m+1,vector<long long>(n+1,0)); \\n\\n\\t\\t\\t//Storing Prices in dp array itself\\n\\t\\t\\tfor(int i = 0;i < prices.size();i++)\\n\\t\\t\\t\\tdp[prices[i][0]][prices[i][1]] = prices[i][2];\\n\\n\\t\\t\\tfor(int row = 1;row <= m;row++){ //loop reversed\\n\\t\\t\\t\\tfor(int col = 1;col <= n;col++){ //loop reversed\\n\\n\\t\\t\\t\\t\\t//Base Case is tackled under this\\n\\t\\t\\t\\t\\tlong long ans = dp[row][col]; \\n\\n\\t\\t\\t\\t\\tfor(int i = 1;i <= row/2;i++)  //Partitions Row-wise\\n\\t\\t\\t\\t\\t\\tans = max(ans,dp[i][col] + dp[row-i][col]);\\n\\n\\t\\t\\t\\t\\tfor(int j = 1;j <= col/2;j++) //Partitions Column-wise\\n\\t\\t\\t\\t\\t\\tans = max(ans,dp[row][j] + dp[row][col-j]);\\n\\n\\t\\t\\t\\t\\t//store ans in dp array before returning so that we can use it again.\\n\\t\\t\\t\\t\\tdp[row][col] = ans;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn dp[m][n];\\n\\t\\t}\\n\\t};\\n\\n\\n**Time complexity -** *O(mn(m+n))*\\n**Space complexity -** *O(mn)*\\n\\n**Result :** *Accepted*\\n\\n****\\n\\n**JOURNEY ENDS HERE\\uD83D\\uDE42**\\n\\n**My Other Articles :**\\n\\n1. [Number of Distinct Roll Sequences](https://leetcode.com/problems/number-of-distinct-roll-sequences/discuss/2197300/3D-DP-Recursion-greaterMemoization-greaterTabulation-greaterSpace-Optimization) [ 3D DP Pattern ]\\n\\n**If You Like It, Please Upvote.**\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution {\\n\\tprivate:\\n\\t\\tlong long f(int row, int col, map<pair<int,int>,long long> &mp){\\n\\n\\t\\t\\t//Base case is tackled in this line\\n\\t\\t\\tlong long ans = mp[{row,col}",
                "codeTag": "Java"
            },
            {
                "id": 2168135,
                "title": "python-explanation-with-pictures-dp",
                "content": "*To cut a piece of wood, you must make a vertical or horizontal cut across the **entire** height or width of the piece to split it into two smaller pieces.* \\n\\nI was lost in plans with twisted cutting edges before I noticed this line above, then the logic became quite clear:\\n\\nFor a piece of wood of size `r*c`, forget about the final states and the many smaller pieces it might turn into, let\\'s just focus on the **first cut**.  \\n\\nSince we must cut accross the entire height or weight, thus every possible first cut makes the original piece into two smaller piece of the **same length** or **same height**. Given a piece of size `4*6`, all the possible cutting plans are listed below.\\n\\n![image](https://assets.leetcode.com/users/images/2dbc0ad3-5693-4aa7-9945-da7263073033_1655611245.4847548.png)\\n\\nOriginally every cell of `dp` is 0 since we have no idea what the best price is. We are also given a list of selling plans `A`, `[r, c, p]` in `A` means that if we have a a piece of wood with size of `r*c`, we can sell it directly without further cutting, put these prices in the corresponding cells in `dp`.\\n\\n![image](https://assets.leetcode.com/users/images/2c318a64-130f-4c13-bbe2-a5127dd27b46_1655611253.4621947.png)\\n\\nLet\\'s see how we update `dp`, start by `row = 1` and `row = 1`:\\n- `dp[1][1] = 1`\\n- For `dp[1][2]` (size of `1*2`), we can either sell it directly, or cut it into two `1*1`. Put the higher price in `dp[1][2]`.\\n- For `dp[1][3]` (size of `1*3`), we can either sell it directly, or cut it into `1*1` and `1*2`. Put the higher price in `dp[1][3]`.\\n\\n![image](https://assets.leetcode.com/users/images/7f6af3b9-2dd1-4e89-8192-619af3364082_1655611260.840119.png)\\n\\n- For `dp[1][4]` (size of `1*4`), we can either:\\n\\t-  sell it directly.\\n\\t-  cut it into `1*1` and `1*3`. \\n\\t-  cut it into `1*2` and `1*2`. \\n\\nNotice that even though we can sell `1*4` directly, we make more profit by cutting it into two `1*2`s, Thus we update the price on `dp[1][4]` as `4`.\\n\\n![image](https://assets.leetcode.com/users/images/a6847329-d740-43f3-9118-d7d29d384a3f_1655611264.9172854.png)\\n\\n\\nThe example above only shows the vertical first cut, in general we should check for both vertical cuts and the horizontal cuts before updating the best price for each cell.\\n\\nFinally return `dp[m][n]` as the best price for this whole piece of wood.\\n\\n**python**\\n\\n```\\ndef sellingWood(self, m: int, n: int, P: List[List[int]]) -> int:\\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\\n        for r, c, p in P:\\n            dp[r][c] = p\\n            \\n        for r in range(1, m + 1):\\n            for c in range(1, n + 1):\\n                # Find all the possible first cut:\\n                for nc in range(1, c // 2 + 1): \\n                    dp[r][c] = max(dp[r][c], dp[r][nc] + dp[r][c - nc])\\n                for nr in range(1, r // 2 + 1):\\n                    dp[r][c] = max(dp[r][c], dp[nr][c] + dp[r - nr][c])\\n                    \\n        return dp[m][n]\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\ndef sellingWood(self, m: int, n: int, P: List[List[int]]) -> int:\\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\\n        for r, c, p in P:\\n            dp[r][c] = p\\n            \\n        for r in range(1, m + 1):\\n            for c in range(1, n + 1):\\n                # Find all the possible first cut:\\n                for nc in range(1, c // 2 + 1): \\n                    dp[r][c] = max(dp[r][c], dp[r][nc] + dp[r][c - nc])\\n                for nr in range(1, r // 2 + 1):\\n                    dp[r][c] = max(dp[r][c], dp[nr][c] + dp[r - nr][c])\\n                    \\n        return dp[m][n]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2168403,
                "title": "3d-dp",
                "content": "Loved this problem. First, we need to figure out how to handle prices. \\n\\nSince we are going to be using DP array anyway, we can just set the initial price for `[h_i, w_i]` pieces to `price_i`.\\n\\nAnother trick is to do it in 3D, not 4D. For each piece `[i, j]`, we do not need to check all combinations of vertical and horizontal cuts (i * j options). We can just try all horizontal cuts, and all vertical cuts independently (i + j options).\\n\\nFinally, we only need to try `i / 2` and `j / 2` cuts because of the symmetry, as suggested by [rexue70](https://leetcode.com/rexue70/).\\n\\n**Java**\\n```java\\npublic long sellingWood(int m, int n, int[][] prices) {\\n    long[][] dp = new long[m + 1][n + 1];\\n    for (var p : prices)\\n        dp[p[0]][p[1]] = p[2];\\n    for (int i = 1; i <= m; ++i)\\n        for (int j = 1; j <= n; ++j) {\\n            for (int h = 1; h <= i / 2; ++h)\\n                dp[i][j] = Math.max(dp[i][j], dp[h][j] + dp[i - h][j]);\\n            for (int v = 1; v <= j / 2; ++v)\\n                dp[i][j] = Math.max(dp[i][j], dp[i][v] + dp[i][j - v]);\\n        }    \\n    return dp[m][n];\\n}\\n```\\n**C++**\\n```cpp\\nlong long sellingWood(int m, int n, vector<vector<int>>& prices) {\\n    long long dp[201][201] = {};\\n    for (auto &p : prices)\\n        dp[p[0]][p[1]] = p[2];\\n    for (int i = 1; i <= m; ++i)\\n        for (int j = 1; j <= n; ++j) {\\n            for (int h = 1; h <= i / 2; ++h)\\n                dp[i][j] = max(dp[i][j], dp[h][j] + dp[i - h][j]);\\n            for (int v = 1; v <= j / 2; ++v)\\n                dp[i][j] = max(dp[i][j], dp[i][v] + dp[i][j - v]);\\n        }\\n    return dp[m][n];\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```java\\npublic long sellingWood(int m, int n, int[][] prices) {\\n    long[][] dp = new long[m + 1][n + 1];\\n    for (var p : prices)\\n        dp[p[0]][p[1]] = p[2];\\n    for (int i = 1; i <= m; ++i)\\n        for (int j = 1; j <= n; ++j) {\\n            for (int h = 1; h <= i / 2; ++h)\\n                dp[i][j] = Math.max(dp[i][j], dp[h][j] + dp[i - h][j]);\\n            for (int v = 1; v <= j / 2; ++v)\\n                dp[i][j] = Math.max(dp[i][j], dp[i][v] + dp[i][j - v]);\\n        }    \\n    return dp[m][n];\\n}\\n```\n```cpp\\nlong long sellingWood(int m, int n, vector<vector<int>>& prices) {\\n    long long dp[201][201] = {};\\n    for (auto &p : prices)\\n        dp[p[0]][p[1]] = p[2];\\n    for (int i = 1; i <= m; ++i)\\n        for (int j = 1; j <= n; ++j) {\\n            for (int h = 1; h <= i / 2; ++h)\\n                dp[i][j] = max(dp[i][j], dp[h][j] + dp[i - h][j]);\\n            for (int v = 1; v <= j / 2; ++v)\\n                dp[i][j] = max(dp[i][j], dp[i][v] + dp[i][j - v]);\\n        }\\n    return dp[m][n];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2168249,
                "title": "easy-to-understand-and-intuitive-rec-memo",
                "content": "DP[h][v] is the maximum profit we can get after we cut a sheet with height h and width v\\nAlso if a particular DP[h][v] is already initialised then not calling the function to evaluate again recurcively to reduce the call stack overhead.\\n```\\nclass Solution {\\n    map<pair<int, int>, long> price;\\n    vector<vector<long>> DP;\\n\\n    long solve(int h, int v) {\\n        if (DP[h][v] != -1)\\n            return DP[h][v];\\n\\t\\t\\t\\n        // Check if we have a price for this sheet with height h and width v\\n        long ans = price.find(make_pair(h, v)) == price.end()? 0: price[make_pair(h, v)];\\n        \\n        for (int i = 1; i < 1 + h / 2; i++)\\n            ans = max(ans, \\n\\t\\t\\t\\t\\t\\t\\t(DP[i][v] != -1? DP[i][v]: solve(i, v)) +\\n\\t\\t\\t\\t\\t\\t\\t(DP[h - i][v] != -1? DP[h - i][v]: solve(h - i, v))\\n\\t\\t\\t\\t\\t); // Cut the sheet horizontally and take the maximum\\n        \\n        for (int j = 1; j < 1 + v / 2; j++)\\n            ans = max(ans, \\n\\t\\t\\t\\t\\t\\t\\t(DP[h][j] != -1? DP[h][j]: solve(h, j)) + \\n\\t\\t\\t\\t\\t\\t\\t(DP[h][v - j] != -1? DP[h][v - j]: solve(h, v - j))\\n\\t\\t\\t\\t\\t); // Cut the sheet vertically and take the maximum\\n        \\n        return DP[h][v] = ans;\\n    }\\npublic:\\n    long long sellingWood(int m, int n, vector<vector<int>>& prices) {\\n        price = map<pair<int, int>, long>();\\n        for (vector<int> &dimension_price: prices) price[make_pair(dimension_price[0], dimension_price[1])] = dimension_price[2];\\n        DP = vector<vector<long>>(m + 1, vector<long>(n + 1, -1));\\n        \\n        return solve(m, n);\\n    }\\n};\\n```\\n\\nPython 3 solution with the same concept though its pretty slow for a python code.\\n\\n```\\nclass Solution:\\n    def sellingWood(self, m: int, n: int, prices: List[List[int]]) -> int:\\n        price = {(dimension_price[0], dimension_price[1]): dimension_price[2] for dimension_price in prices}\\n        DP = [[-1 for _ in range(n + 1)] for _ in range(m + 1)]\\n        \\n        def solve(h: int, v: int) -> int:\\n            if DP[h][v] != -1:\\n                return DP[i][j]\\n            \\n            ans = price.get((h, v), 0)\\n            \\n            for i in range(1, 1 + h // 2):\\n                ans = max(ans, (DP[i][v] if DP[i][v] != -1 else solve(i, v)) + (DP[h - i][v] if DP[h - i][v] != -1 else solve(h - i, v)))\\n            \\n            for j in range(1, 1 + v // 2):\\n                ans = max(ans, (DP[h][j] if DP[h][j] != -1 else solve(h, j)) + (DP[h][v - j] if DP[h][v - j] != -1 else solve(h, v - j)))\\n            \\n            DP[h][v] = ans\\n            \\n            return ans\\n        \\n        return solve(m, n)\\n```",
                "solutionTags": [
                    "Python",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    map<pair<int, int>, long> price;\\n    vector<vector<long>> DP;\\n\\n    long solve(int h, int v) {\\n        if (DP[h][v] != -1)\\n            return DP[h][v];\\n\\t\\t\\t\\n        // Check if we have a price for this sheet with height h and width v\\n        long ans = price.find(make_pair(h, v)) == price.end()? 0: price[make_pair(h, v)];\\n        \\n        for (int i = 1; i < 1 + h / 2; i++)\\n            ans = max(ans, \\n\\t\\t\\t\\t\\t\\t\\t(DP[i][v] != -1? DP[i][v]: solve(i, v)) +\\n\\t\\t\\t\\t\\t\\t\\t(DP[h - i][v] != -1? DP[h - i][v]: solve(h - i, v))\\n\\t\\t\\t\\t\\t); // Cut the sheet horizontally and take the maximum\\n        \\n        for (int j = 1; j < 1 + v / 2; j++)\\n            ans = max(ans, \\n\\t\\t\\t\\t\\t\\t\\t(DP[h][j] != -1? DP[h][j]: solve(h, j)) + \\n\\t\\t\\t\\t\\t\\t\\t(DP[h][v - j] != -1? DP[h][v - j]: solve(h, v - j))\\n\\t\\t\\t\\t\\t); // Cut the sheet vertically and take the maximum\\n        \\n        return DP[h][v] = ans;\\n    }\\npublic:\\n    long long sellingWood(int m, int n, vector<vector<int>>& prices) {\\n        price = map<pair<int, int>, long>();\\n        for (vector<int> &dimension_price: prices) price[make_pair(dimension_price[0], dimension_price[1])] = dimension_price[2];\\n        DP = vector<vector<long>>(m + 1, vector<long>(n + 1, -1));\\n        \\n        return solve(m, n);\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def sellingWood(self, m: int, n: int, prices: List[List[int]]) -> int:\\n        price = {(dimension_price[0], dimension_price[1]): dimension_price[2] for dimension_price in prices}\\n        DP = [[-1 for _ in range(n + 1)] for _ in range(m + 1)]\\n        \\n        def solve(h: int, v: int) -> int:\\n            if DP[h][v] != -1:\\n                return DP[i][j]\\n            \\n            ans = price.get((h, v), 0)\\n            \\n            for i in range(1, 1 + h // 2):\\n                ans = max(ans, (DP[i][v] if DP[i][v] != -1 else solve(i, v)) + (DP[h - i][v] if DP[h - i][v] != -1 else solve(h - i, v)))\\n            \\n            for j in range(1, 1 + v // 2):\\n                ans = max(ans, (DP[h][j] if DP[h][j] != -1 else solve(h, j)) + (DP[h][v - j] if DP[h][v - j] != -1 else solve(h, v - j)))\\n            \\n            DP[h][v] = ans\\n            \\n            return ans\\n        \\n        return solve(m, n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2168109,
                "title": "c-java-python3-top-down-dp",
                "content": "**Explanation**:\\n* `p[i][j]` represents the price to get a cut of height `i` and width `j`\\n* For a piece of type `i * j` we can cut it to have the 2 pieces of types `ii * j` and `(i - ii) * j` or `i * jj` and `i * (j - jj)`\\n* `dp[i][j]` is the maximum profit we can get after we cut a sheet with height i and width j\\n* We run for loop from `1 to i // 2` so that we don\\'t repeat the same calculations again\\n\\n**Python3**:\\n   ```\\ndef sellingWood(self, m: int, n: int, prices: List[List[int]]) -> int:\\n        p = [[0] * (n + 1) for _ in range(m + 1)]\\n        for x, y, z in prices: p[x][y] = z\\n        @cache\\n        def f(i, j):\\n            if i == 0 or j == 0: return 0\\n            ans = p[i][j]\\n            for ii in range(1, i // 2 + 1):\\n                ans = max(ans, f(ii, j) + f(i - ii, j))\\n            for jj in range(1, j // 2 + 1):\\n                ans = max(ans, f(i, jj) + f(i, j - jj))\\n            return ans\\n        return f(m, n)\\n```\\n\\n**C++**:\\n```\\nlong long sellingWood(int m, int n, vector<vector<int>>& prices) {\\n\\tvector<vector<int>> p(m + 1, vector<int>(n + 1, 0));\\n\\tvector<vector<long long>> memo(m + 1, vector<long long>(n + 1, -1));\\n\\tfor (auto &pri: prices) p[pri[0]][pri[1]] = pri[2];\\n\\treturn dp(m, n, memo, p);\\n}\\nlong long dp(int i, int j, vector<vector<long long>> &memo, vector<vector<int>> &p) {\\n\\tif (i == 0 || j == 0) return 0;\\n\\tif (memo[i][j] > -1) return memo[i][j];\\n\\tlong long ans = p[i][j];\\n\\tfor (int ii = 1; ii <= i / 2; ii++) \\n\\t\\tans = max(ans, dp(ii, j, memo, p) + dp(i - ii, j, memo, p));\\n\\tfor (int jj = 1; jj <= j / 2; jj++) \\n\\t\\tans = max(ans, dp(i, jj, memo, p) + dp(i, j - jj, memo, p));\\n\\treturn memo[i][j] = ans;\\n}\\n```\\n\\n**Java**:\\n```\\npublic long sellingWood(int m, int n, int[][] prices) {\\n    int p[][] = new int[m + 1][n + 1];\\n    long memo[][] = new long[m + 1][n + 1];\\n    for (int i = 0; i <= m; i++) Arrays.fill(memo[i], -1);\\n    for (int pri[]: prices) p[pri[0]][pri[1]] = pri[2];\\n    return dp(m, n, memo, p);\\n}\\nprivate long dp(int i, int j, long memo[][], int p[][]) {\\n    if (i == 0 || j == 0) return 0;\\n    if (memo[i][j] > -1) return memo[i][j];\\n    long ans = p[i][j];\\n    for (int ii = 1; ii <= i / 2; ii++) \\n        ans = Math.max(ans, dp(ii, j, memo, p) + dp(i - ii, j, memo, p));\\n    for (int jj = 1; jj <= j / 2; jj++) \\n        ans = Math.max(ans, dp(i, jj, memo, p) + dp(i, j - jj, memo, p));\\n    return memo[i][j] = ans;\\n}\\n```",
                "solutionTags": [
                    "Python",
                    "C"
                ],
                "code": "```\\ndef sellingWood(self, m: int, n: int, prices: List[List[int]]) -> int:\\n        p = [[0] * (n + 1) for _ in range(m + 1)]\\n        for x, y, z in prices: p[x][y] = z\\n        @cache\\n        def f(i, j):\\n            if i == 0 or j == 0: return 0\\n            ans = p[i][j]\\n            for ii in range(1, i // 2 + 1):\\n                ans = max(ans, f(ii, j) + f(i - ii, j))\\n            for jj in range(1, j // 2 + 1):\\n                ans = max(ans, f(i, jj) + f(i, j - jj))\\n            return ans\\n        return f(m, n)\\n```\n```\\nlong long sellingWood(int m, int n, vector<vector<int>>& prices) {\\n\\tvector<vector<int>> p(m + 1, vector<int>(n + 1, 0));\\n\\tvector<vector<long long>> memo(m + 1, vector<long long>(n + 1, -1));\\n\\tfor (auto &pri: prices) p[pri[0]][pri[1]] = pri[2];\\n\\treturn dp(m, n, memo, p);\\n}\\nlong long dp(int i, int j, vector<vector<long long>> &memo, vector<vector<int>> &p) {\\n\\tif (i == 0 || j == 0) return 0;\\n\\tif (memo[i][j] > -1) return memo[i][j];\\n\\tlong long ans = p[i][j];\\n\\tfor (int ii = 1; ii <= i / 2; ii++) \\n\\t\\tans = max(ans, dp(ii, j, memo, p) + dp(i - ii, j, memo, p));\\n\\tfor (int jj = 1; jj <= j / 2; jj++) \\n\\t\\tans = max(ans, dp(i, jj, memo, p) + dp(i, j - jj, memo, p));\\n\\treturn memo[i][j] = ans;\\n}\\n```\n```\\npublic long sellingWood(int m, int n, int[][] prices) {\\n    int p[][] = new int[m + 1][n + 1];\\n    long memo[][] = new long[m + 1][n + 1];\\n    for (int i = 0; i <= m; i++) Arrays.fill(memo[i], -1);\\n    for (int pri[]: prices) p[pri[0]][pri[1]] = pri[2];\\n    return dp(m, n, memo, p);\\n}\\nprivate long dp(int i, int j, long memo[][], int p[][]) {\\n    if (i == 0 || j == 0) return 0;\\n    if (memo[i][j] > -1) return memo[i][j];\\n    long ans = p[i][j];\\n    for (int ii = 1; ii <= i / 2; ii++) \\n        ans = Math.max(ans, dp(ii, j, memo, p) + dp(i - ii, j, memo, p));\\n    for (int jj = 1; jj <= j / 2; jj++) \\n        ans = Math.max(ans, dp(i, jj, memo, p) + dp(i, j - jj, memo, p));\\n    return memo[i][j] = ans;\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2168182,
                "title": "c-dynamic-programming-fast-lookup-for-a-price",
                "content": "Dynamic programming pattern - 3 options:\\n1. just take a price for the whole piece of wood\\n2. make 1 horizontal cut - and take 2 prices for 2 smaller horizontal pieces\\n3. make 1 vertical cut - and take 2 prices...\\n\\nTo make a fast lookup for the whole piece price - pre-fill a 2-dimensional array `(m+1) * (n+1)` which gives the price for the piece in O(1). The price can be `0` or not optimal (smaller pieces can have higher price) - in this case optimal price will be found using options 2 and 3 - with cutting the piece.\\n\\nTo not repeat calculations for repetitive arguments - use memoization\\n\\nTime complexity: single recursive call takes `O(M + N)`, result for the given parameters is calculated only once, DP space is `M * N`.\\n`maxPrice` precalculation takes `O(P)` to iterate on `prices`. Total:  `O(P + M * N * (M + N))` : \\nSpace complexity: `O(M * N)` - for memo and pre-filled maxPrice array\\n\\n```\\nclass Solution {\\npublic:\\n    long long getResult(int m, int n, const vector<vector<int>>& maxPrice, vector<vector<long long>>& memo) {\\n        if (memo[m][n] != -1) return memo[m][n];\\n        \\n        // option 1: just take the price for the whole piece\\n        long long price = maxPrice[m][n];\\n        \\n        for (int h = 1; h < m; ++h) {\\n            // option 2: make 1 horizontal cut, take 2 prices for the smaller pieces\\n            price = max(price, getResult(m-h, n, maxPrice, memo) + getResult(h, n, maxPrice, memo));\\n        }\\n        \\n        for (int w = 1; w < n; ++w) {\\n            // option 3: make 1 vertical cut, take 2 prices\\n            price = max(price, getResult(m, n - w, maxPrice, memo) + getResult(m, w, maxPrice, memo));\\n        }\\n        \\n        return memo[m][n] = price;\\n    }\\n    \\n    long long sellingWood(int m, int n, vector<vector<int>>& prices) {\\n        // pre-calculate array for fast lookup of \"price for piece of size h*w\"\\n        vector<vector<int>> maxPrice(m+1, vector<int>(n+1, 0));\\n        for (const vector<int>& p : prices) {\\n            int h = p[0];\\n            int w = p[1];\\n            maxPrice[h][w] = p[2];\\n        }\\n        \\n        vector<vector<long long>> memo(m+1, vector<long long>(n+1, -1));\\n        return getResult(m, n, maxPrice, memo);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long getResult(int m, int n, const vector<vector<int>>& maxPrice, vector<vector<long long>>& memo) {\\n        if (memo[m][n] != -1) return memo[m][n];\\n        \\n        // option 1: just take the price for the whole piece\\n        long long price = maxPrice[m][n];\\n        \\n        for (int h = 1; h < m; ++h) {\\n            // option 2: make 1 horizontal cut, take 2 prices for the smaller pieces\\n            price = max(price, getResult(m-h, n, maxPrice, memo) + getResult(h, n, maxPrice, memo));\\n        }\\n        \\n        for (int w = 1; w < n; ++w) {\\n            // option 3: make 1 vertical cut, take 2 prices\\n            price = max(price, getResult(m, n - w, maxPrice, memo) + getResult(m, w, maxPrice, memo));\\n        }\\n        \\n        return memo[m][n] = price;\\n    }\\n    \\n    long long sellingWood(int m, int n, vector<vector<int>>& prices) {\\n        // pre-calculate array for fast lookup of \"price for piece of size h*w\"\\n        vector<vector<int>> maxPrice(m+1, vector<int>(n+1, 0));\\n        for (const vector<int>& p : prices) {\\n            int h = p[0];\\n            int w = p[1];\\n            maxPrice[h][w] = p[2];\\n        }\\n        \\n        vector<vector<long long>> memo(m+1, vector<long long>(n+1, -1));\\n        return getResult(m, n, maxPrice, memo);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2169003,
                "title": "c-with-explanation-easy-to-understand-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    long dp[201][201], p[201][201];\\n    long long sellingWood(int m, int n, vector<vector<int>>& prices) {\\n        memset(dp,-1,sizeof(dp));\\n        memset(p,0,sizeof(p));\\n        for(auto & i:prices)\\n            p[i[0]][i[1]]=i[2];\\n        return helper(m,n); \\n    }\\n  long helper(int height,int width){\\n        if(dp[height][width]!=-1)\\n            return dp[height][width];\\n      // sell this whole piece  and get money\\n        long maxAmnt=p[height][width];\\n      // or cut into pieces and then sell\\n      // cut till half of height and width because of symmetry\\n      // cut along height\\n        for(int lowerHeight=1;lowerHeight<=height/2;lowerHeight++){\\n            int upperHeight=height-lowerHeight;\\n            long temp=helper(upperHeight,width) + helper(lowerHeight,width);\\n            maxAmnt=max(maxAmnt,temp);\\n        }\\n      \\n      //cut along width\\n        for(int leftWidth=1;leftWidth<=width/2;leftWidth++){\\n            int rightWidth=width-leftWidth;\\n            long temp=helper(height,rightWidth)+helper(height,leftWidth);\\n            maxAmnt=max(maxAmnt,temp);\\n        }   \\n        dp[height][width]=maxAmnt;\\n        return maxAmnt;\\n    }\\n};\\n```\\nDo **UPVOTE** if it helps :)",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long dp[201][201], p[201][201];\\n    long long sellingWood(int m, int n, vector<vector<int>>& prices) {\\n        memset(dp,-1,sizeof(dp));\\n        memset(p,0,sizeof(p));\\n        for(auto & i:prices)\\n            p[i[0]][i[1]]=i[2];\\n        return helper(m,n); \\n    }\\n  long helper(int height,int width){\\n        if(dp[height][width]!=-1)\\n            return dp[height][width];\\n      // sell this whole piece  and get money\\n        long maxAmnt=p[height][width];\\n      // or cut into pieces and then sell\\n      // cut till half of height and width because of symmetry\\n      // cut along height\\n        for(int lowerHeight=1;lowerHeight<=height/2;lowerHeight++){\\n            int upperHeight=height-lowerHeight;\\n            long temp=helper(upperHeight,width) + helper(lowerHeight,width);\\n            maxAmnt=max(maxAmnt,temp);\\n        }\\n      \\n      //cut along width\\n        for(int leftWidth=1;leftWidth<=width/2;leftWidth++){\\n            int rightWidth=width-leftWidth;\\n            long temp=helper(height,rightWidth)+helper(height,leftWidth);\\n            maxAmnt=max(maxAmnt,temp);\\n        }   \\n        dp[height][width]=maxAmnt;\\n        return maxAmnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2168973,
                "title": "bottom-up-with-explanation-o-n-3",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tlong long sellingWood(int m, int n, vector<vector<int>>& prices) {\\n\\t\\t\\t// try cutting horizonally  and again vertically , take the maximum...\\n\\t\\t\\t// after half length of cut .. values are repeating..  \\n\\t\\t\\t// n^3\\n\\t\\t\\t// WxH   cut from i of width   WxH, ixH, (W-i)xH  take maximum of these three... \\n\\t\\t\\t// base cases are the prices given...\\n\\n\\t\\t\\t// mxn wood  hxw \\n\\n\\t\\t\\tvector<vector<long long>> dp(m+1, vector<long long> (n+1, 0));\\n\\n\\t\\t\\tfor(vector<int> p: prices)\\n\\t\\t\\t\\tdp[p[0]][p[1]] = p[2];\\n\\n\\t\\t\\tfor(int h= 1; h<= m ; h++){\\n\\t\\t\\t\\tfor(int w = 1; w<=n; w++){\\n\\t\\t\\t\\t\\t// try every horizontal cut for wood hxw\\n\\t\\t\\t\\t\\tfor(int i = 1; i<= h/2; i++)\\n\\t\\t\\t\\t\\t\\tdp[h][w] = max(dp[h][w], dp[i][w]+dp[h-i][w]);\\n\\n\\t\\t\\t\\t\\t// now try every vertical cut for wood hxw\\n\\t\\t\\t\\t\\tfor(int j= 1; j<= w/2; j++)\\n\\t\\t\\t\\t\\t\\tdp[h][w] = max(dp[h][w], dp[h][j]+ dp[h][w-j]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn dp[m][n];    \\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tlong long sellingWood(int m, int n, vector<vector<int>>& prices) {\\n\\t\\t\\t// try cutting horizonally  and again vertically , take the maximum...\\n\\t\\t\\t// after half length of cut .. values are repeating..  \\n\\t\\t\\t// n^3\\n\\t\\t\\t// WxH   cut from i of width   WxH, ixH, (W-i)xH  take maximum of these three... \\n\\t\\t\\t// base cases are the prices given...\\n\\n\\t\\t\\t// mxn wood  hxw \\n\\n\\t\\t\\tvector<vector<long long>> dp(m+1, vector<long long> (n+1, 0));\\n\\n\\t\\t\\tfor(vector<int> p: prices)\\n\\t\\t\\t\\tdp[p[0]][p[1]] = p[2];\\n\\n\\t\\t\\tfor(int h= 1; h<= m ; h++){\\n\\t\\t\\t\\tfor(int w = 1; w<=n; w++){\\n\\t\\t\\t\\t\\t// try every horizontal cut for wood hxw\\n\\t\\t\\t\\t\\tfor(int i = 1; i<= h/2; i++)\\n\\t\\t\\t\\t\\t\\tdp[h][w] = max(dp[h][w], dp[i][w]+dp[h-i][w]);\\n\\n\\t\\t\\t\\t\\t// now try every vertical cut for wood hxw\\n\\t\\t\\t\\t\\tfor(int j= 1; j<= w/2; j++)\\n\\t\\t\\t\\t\\t\\tdp[h][w] = max(dp[h][w], dp[h][j]+ dp[h][w-j]);\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2168899,
                "title": "python3-recursion-with-cache",
                "content": "Here is my recusrive solution with @cache-ing. The time complexity is O(m * n * max(m, n) + len(prices)) and we use O(m * n) memory\\nLet me know if you have questions!\\n\\n```\\nclass Solution:\\n    def sellingWood(self, m: int, n: int, prices: List[List[int]]) -> int:\\n        # Keep track of all prices available in a dict\\n        pr = {}\\n        for i in range(m + 1):\\n            for j in range(n + 1):\\n                pr[(i, j)] = 0\\n        for h, w, p in prices:\\n            if pr[(h, w)] < p:\\n                pr[(h, w)] = p\\n        \\n        @cache\\n        def helper(x, y):\\n            if x * y == 0:\\n                return 0\\n            t = pr[(x, y)]\\n            # cut horizontally\\n            for i in range(1, x // 2 + 1):\\n                t = max(t, helper(i, y) + helper(x - i, y))\\n            # cut vertically\\n            for j in range(1, y // 2 + 1):\\n                t = max(t, helper(x, j) + helper(x, y - j))\\n            return t\\n            \\n        return helper(m, n)\\n```",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def sellingWood(self, m: int, n: int, prices: List[List[int]]) -> int:\\n        # Keep track of all prices available in a dict\\n        pr = {}\\n        for i in range(m + 1):\\n            for j in range(n + 1):\\n                pr[(i, j)] = 0\\n        for h, w, p in prices:\\n            if pr[(h, w)] < p:\\n                pr[(h, w)] = p\\n        \\n        @cache\\n        def helper(x, y):\\n            if x * y == 0:\\n                return 0\\n            t = pr[(x, y)]\\n            # cut horizontally\\n            for i in range(1, x // 2 + 1):\\n                t = max(t, helper(i, y) + helper(x - i, y))\\n            # cut vertically\\n            for j in range(1, y // 2 + 1):\\n                t = max(t, helper(x, j) + helper(x, y - j))\\n            return t\\n            \\n        return helper(m, n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3362382,
                "title": "c-dp-memorization-tabulation-beats-90",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    // long long dp[201][201],price[201][201];\\n    // long long solve(int m, int n){\\n    //     if(dp[m][n]!=-1){\\n    //         return dp[m][n];\\n    //     }\\n\\n    //     long long ans=0,tans1,tans2;\\n    //     if(price[m][n]!=-1){\\n    //         ans=price[m][n];\\n    //     }\\n    //     for(int x=1;x<m;x++){\\n    //         tans1=solve(x,n)+solve(m-x,n);\\n    //         ans=max(ans,tans1);\\n    //     }\\n\\n    //     for(int x=1;x<n;x++){\\n    //         tans1=solve(m,x)+solve(m,n-x);\\n    //         ans=max(ans,tans1);\\n    //     }\\n\\n    //     return dp[m][n]=ans;\\n    // }\\n\\n    long long sellingWood(int m, int n, vector<vector<int>>& prices) {\\n        long long int dp[m+1][n+1];\\n        memset(dp,0,sizeof(dp));\\n        // memset(dp,-1,sizeof(dp));\\n        // memset(price,-1,sizeof(price));\\n\\n        for(int x=0;x<prices.size();x++){\\n            // price[prices[x][0]][prices[x][1]]=prices[x][2];\\n            dp[prices[x][0]][prices[x][1]]=prices[x][2];\\n        }\\n\\n        for(int x=1;x<=m;x++){\\n            for(int y=1;y<=n;y++){\\n                for(int z=1;z<=x/2;z++){\\n                    dp[x][y]=max(dp[x][y],(dp[z][y]+dp[x-z][y]));\\n                }\\n                for(int z=1;z<=y/2;z++){\\n                    dp[x][y]=max(dp[x][y],(dp[x][z]+dp[x][y-z]));\\n                }\\n            }\\n        }\\n\\n        return dp[m][n];\\n        // return solve(m,n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // long long dp[201][201],price[201][201];\\n    // long long solve(int m, int n){\\n    //     if(dp[m][n]!=-1){\\n    //         return dp[m][n];\\n    //     }\\n\\n    //     long long ans=0,tans1,tans2;\\n    //     if(price[m][n]!=-1){\\n    //         ans=price[m][n];\\n    //     }\\n    //     for(int x=1;x<m;x++){\\n    //         tans1=solve(x,n)+solve(m-x,n);\\n    //         ans=max(ans,tans1);\\n    //     }\\n\\n    //     for(int x=1;x<n;x++){\\n    //         tans1=solve(m,x)+solve(m,n-x);\\n    //         ans=max(ans,tans1);\\n    //     }\\n\\n    //     return dp[m][n]=ans;\\n    // }\\n\\n    long long sellingWood(int m, int n, vector<vector<int>>& prices) {\\n        long long int dp[m+1][n+1];\\n        memset(dp,0,sizeof(dp));\\n        // memset(dp,-1,sizeof(dp));\\n        // memset(price,-1,sizeof(price));\\n\\n        for(int x=0;x<prices.size();x++){\\n            // price[prices[x][0]][prices[x][1]]=prices[x][2];\\n            dp[prices[x][0]][prices[x][1]]=prices[x][2];\\n        }\\n\\n        for(int x=1;x<=m;x++){\\n            for(int y=1;y<=n;y++){\\n                for(int z=1;z<=x/2;z++){\\n                    dp[x][y]=max(dp[x][y],(dp[z][y]+dp[x-z][y]));\\n                }\\n                for(int z=1;z<=y/2;z++){\\n                    dp[x][y]=max(dp[x][y],(dp[x][z]+dp[x][y-z]));\\n                }\\n            }\\n        }\\n\\n        return dp[m][n];\\n        // return solve(m,n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2194125,
                "title": "python-fastest-soln-beats-98-in-time-97-in-space-dp",
                "content": "![image](https://assets.leetcode.com/users/images/015a1c04-eb75-41ce-aa7d-35c0971daa9c_1656140006.801418.png)\\n\\n```\\nclass Solution:\\n    def sellingWood(self, m: int, n: int, prices: List[List[int]]) -> int:\\n        price = [[0 for _ in range(n+1)] for _ in range(m+1)] \\n        for r, c, p in prices: price[r][c] = p\\n        dp = [[0 for _ in range(n+1)] for _ in range(m+1)] \\n        for r in range(1, m+1):\\n            for c in range(1, n+1):\\n                result = price[r][c] \\n                for i in range(1, r//2+1): result = max(result, dp[r-i][c]+dp[i][c])\\n                for i in range(1, c//2+1): result = max(result, dp[r][c-i]+dp[r][i])\\n                dp[r][c] = result \\n        return dp[m][n]\\n```\\n***Pls upvote if you find it helpful***",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def sellingWood(self, m: int, n: int, prices: List[List[int]]) -> int:\\n        price = [[0 for _ in range(n+1)] for _ in range(m+1)] \\n        for r, c, p in prices: price[r][c] = p\\n        dp = [[0 for _ in range(n+1)] for _ in range(m+1)] \\n        for r in range(1, m+1):\\n            for c in range(1, n+1):\\n                result = price[r][c] \\n                for i in range(1, r//2+1): result = max(result, dp[r-i][c]+dp[i][c])\\n                for i in range(1, c//2+1): result = max(result, dp[r][c-i]+dp[r][i])\\n                dp[r][c] = result \\n        return dp[m][n]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2184119,
                "title": "c-dynamic-programming-recursive",
                "content": "class Solution {\\npublic:\\n    \\n    // state is the row and column\\n    long long dp[201][201];\\n    map <pair<int,int>,long long> mp;\\n    \\n    // n rows and m columns (in question its m rows and n columns)\\n    long long rec(int n,int m){\\n        \\n        // checking if already computed\\n        if(dp[n][m] != -1) return dp[n][m];\\n        \\n        long long ans = 0;\\n        // if there is a price for rectangle nxm initialize ans with it\\n        if(mp.find({n,m}) != mp.end()) ans = mp[{n,m}];\\n        \\n        // trying to cut horizontally\\n        for(int mid = 0;mid<n-1;mid++){\\n        ans = max(ans,1LL*rec(mid+1,m) + 1LL*rec(n-mid-1,m));\\n        }\\n        \\n        // trying to cut vertically\\n        for(int mid = 0;mid<m-1;mid++){\\n        ans = max(ans,1LL*rec(n,mid+1)+1LL*rec(n,m-mid-1));\\n        }\\n        return dp[n][m] = ans;\\n    }\\n    \\n    long long sellingWood(int m, int n, vector<vector<int>>& prices) {\\n        // storing prices in a map\\n        for(auto v:prices){\\n            mp[{v[0],v[1]}] = v[2];\\n        }\\n        memset(dp,-1,sizeof(dp));\\n        return rec(m,n);\\n    }\\n};``",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    // state is the row and column\\n    long long dp[201][201];\\n    map <pair<int,int>,long long> mp;\\n    \\n    // n rows and m columns (in question its m rows and n columns)\\n    long long rec(int n,int m){\\n        \\n        // checking if already computed\\n        if(dp[n][m] != -1) return dp[n][m];\\n        \\n        long long ans = 0;\\n        // if there is a price for rectangle nxm initialize ans with it\\n        if(mp.find({n,m}",
                "codeTag": "Java"
            },
            {
                "id": 2172971,
                "title": "python-go-dp-w-backtracking-o-mn-m-n",
                "content": "*Python* solution\\n\\n```python\\ndef sellingWood(self, m, n, prices):\\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\\n    for h, w, x in prices:\\n        dp[h][w] = x\\n    for i in range(m + 1):\\n        for j in range(n + 1):\\n            for h in range(i // 2 + 1):                           # help reduce TC to 1/2 w/ optimization\\n                                                                  # otherwise vulnerable to TLE\\n                dp[i][j] = max(dp[i][j], dp[h][j] + dp[i - h][j])\\n            for w in range(j // 2 + 1):                           # complement to above\\n                dp[i][j] = max(dp[i][j], dp[i][w] + dp[i][j - w])\\n    return dp[m][n]\\n```\\n\\n*Go* solution in 67ms\\n\\n```go\\nfunc max(x, y int64) int64 {\\n\\tif x > y {\\n\\t\\treturn x\\n\\t}\\n\\treturn y\\n}\\n\\nfunc sellingWood(m int, n int, prices [][]int) int64 {\\n\\tdp := make([][]int64, m+1)\\n\\tfor i := range dp {\\n\\t\\tdp[i] = make([]int64, n+1)\\n\\t}\\n\\tfor _, p := range prices {\\n\\t\\tdp[p[0]][p[1]] = int64(p[2])\\n\\t}\\n\\tfor i := 0; i <= m; i++ {\\n\\t\\tfor j := 0; j <= n; j++ {\\n\\t\\t\\tfor h := 0; h <= i/2; h++ {\\n\\t\\t\\t\\tdp[i][j] = max(dp[i][j], dp[h][j]+dp[i-h][j])\\n\\t\\t\\t}\\n\\t\\t\\tfor w := 0; w <= j/2; w++ {\\n\\t\\t\\t\\tdp[i][j] = max(dp[i][j], dp[i][w]+dp[i][j-w])\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn dp[m][n]\\n}\\n```",
                "solutionTags": [],
                "code": "```python\\ndef sellingWood(self, m, n, prices):\\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\\n    for h, w, x in prices:\\n        dp[h][w] = x\\n    for i in range(m + 1):\\n        for j in range(n + 1):\\n            for h in range(i // 2 + 1):                           # help reduce TC to 1/2 w/ optimization\\n                                                                  # otherwise vulnerable to TLE\\n                dp[i][j] = max(dp[i][j], dp[h][j] + dp[i - h][j])\\n            for w in range(j // 2 + 1):                           # complement to above\\n                dp[i][j] = max(dp[i][j], dp[i][w] + dp[i][j - w])\\n    return dp[m][n]\\n```\n```go\\nfunc max(x, y int64) int64 {\\n\\tif x > y {\\n\\t\\treturn x\\n\\t}\\n\\treturn y\\n}\\n\\nfunc sellingWood(m int, n int, prices [][]int) int64 {\\n\\tdp := make([][]int64, m+1)\\n\\tfor i := range dp {\\n\\t\\tdp[i] = make([]int64, n+1)\\n\\t}\\n\\tfor _, p := range prices {\\n\\t\\tdp[p[0]][p[1]] = int64(p[2])\\n\\t}\\n\\tfor i := 0; i <= m; i++ {\\n\\t\\tfor j := 0; j <= n; j++ {\\n\\t\\t\\tfor h := 0; h <= i/2; h++ {\\n\\t\\t\\t\\tdp[i][j] = max(dp[i][j], dp[h][j]+dp[i-h][j])\\n\\t\\t\\t}\\n\\t\\t\\tfor w := 0; w <= j/2; w++ {\\n\\t\\t\\t\\tdp[i][j] = max(dp[i][j], dp[i][w]+dp[i][j-w])\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn dp[m][n]\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2172032,
                "title": "python-top-down-dp",
                "content": "```\\nclass Solution:\\n    def sellingWood(self, m: int, n: int, prices: List[List[int]]) -> int:        \\n        @cache\\n        def dfs(h, w):\\n            return max(woods[h, w],\\n                       max(dfs(i, w) + dfs(h - i, w) for i in range(1, h // 2 + 1)) if h > 1 else 0,\\n                       max(dfs(h, i) + dfs(h, w - i) for i in range(1, w // 2 + 1)) if w > 1 else 0)\\n        \\n        woods = collections.defaultdict(int, {(h, w): p for h, w, p in prices})\\n\\n        return dfs(m, n)\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def sellingWood(self, m: int, n: int, prices: List[List[int]]) -> int:        \\n        @cache\\n        def dfs(h, w):\\n            return max(woods[h, w],\\n                       max(dfs(i, w) + dfs(h - i, w) for i in range(1, h // 2 + 1)) if h > 1 else 0,\\n                       max(dfs(h, i) + dfs(h, w - i) for i in range(1, w // 2 + 1)) if w > 1 else 0)\\n        \\n        woods = collections.defaultdict(int, {(h, w): p for h, w, p in prices})\\n\\n        return dfs(m, n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2169922,
                "title": "c-easy-understanding-clean-code-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    map<pair<int,int>,int>mp;\\n    long long dp[205][205];\\n    long long fun(int row,int col){\\n        if(row <=0 or col<=0) return 0;\\n        if(dp[row][col]!=-1) return dp[row][col];\\n        long long ans=mp[{row,col}];\\n        //horizontal cut\\n        for(int i=1;i<row;i++){\\n            ans=max(ans,fun(i,col)+fun(row-i,col));\\n        }\\n        //vertical cut\\n        for(int i=1;i<col;i++){\\n            ans=max(ans,fun(row,i)+fun(row,col-i));\\n        }\\n        dp[row][col]=ans;\\n        return ans;\\n    }\\n    long long sellingWood(int m, int n, vector<vector<int>>& prices) {\\n        for(auto it:prices){\\n            mp[{it[0],it[1]}]=it[2];\\n        }\\n        memset(dp,-1,sizeof(dp));\\n        //dp[i][j] = maximum profit of i row and j col\\n        return fun(m,n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    map<pair<int,int>,int>mp;\\n    long long dp[205][205];\\n    long long fun(int row,int col){\\n        if(row <=0 or col<=0) return 0;\\n        if(dp[row][col]!=-1) return dp[row][col];\\n        long long ans=mp[{row,col}];\\n        //horizontal cut\\n        for(int i=1;i<row;i++){\\n            ans=max(ans,fun(i,col)+fun(row-i,col));\\n        }\\n        //vertical cut\\n        for(int i=1;i<col;i++){\\n            ans=max(ans,fun(row,i)+fun(row,col-i));\\n        }\\n        dp[row][col]=ans;\\n        return ans;\\n    }\\n    long long sellingWood(int m, int n, vector<vector<int>>& prices) {\\n        for(auto it:prices){\\n            mp[{it[0],it[1]}]=it[2];\\n        }\\n        memset(dp,-1,sizeof(dp));\\n        //dp[i][j] = maximum profit of i row and j col\\n        return fun(m,n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2168258,
                "title": "java-dynamic-programming-explained",
                "content": "This is a standard dynamic programming question.\\n\\nUse max[m, n] where max[m, n] is the maximum money you can earn from cutting an m x n piece of wood.\\n\\n**Base cases** in this question are found in prices array.\\n\\nFor the **recurrence relation**, we check all horizontal/vertical cut for each piece, m x n. Then we pick the largest price from the optimal subpieces. We use bottom-up dp to ensure that subpiecess are optimal before moving on to the larger pieces.\\n\\nmax[m, n] = **Maximum of**:\\n\\t\\t**horizontal**: { max[i][n] + max[m-i][n] } for all 1 <= i < m\\n\\t    **vertical**:   { max[m][j] + max[m][n-j] } for all 1 <= j < m\\n\\t   \\nEdge cases. It is possible that a single 2x2 might cost less than four 1x1 pieces.\\nTherefore, you should check each and every piece from 1x1. \\n\\n```\\nclass Solution {\\n    public long sellingWood(int m, int n, int[][] prices) {\\n        long[][] dp = new long[m+1][n+1];\\n        for (int[] price : prices) {\\n            dp[price[0]][price[1]] = price[2];\\n        }\\n        for (int i = 1; i < m+1; i++) {\\n            for (int j = 1; j < n+1; j++) {\\n                // all horizontal\\n                for (int k = 1; k <= i/2; k++) {\\n                    dp[i][j] = Math.max(dp[i][j], dp[i-k][j] + dp[k][j]);\\n                }\\n                // all vertical\\n                for (int k = 1; k <= j/2; k++) {\\n                    dp[i][j] = Math.max(dp[i][j], dp[i][j-k] + dp[i][k]);\\n                }\\n            }\\n        }\\n        \\n        return dp[m][n];\\n    }\\n}\\n```\\n**Time complexity** = O(mn(m+n))\\nCheck for each piece = O(mn)\\nFor each piece, check all cuts = O(m+n)\\n\\n**Space Complexity** = O(mn)",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public long sellingWood(int m, int n, int[][] prices) {\\n        long[][] dp = new long[m+1][n+1];\\n        for (int[] price : prices) {\\n            dp[price[0]][price[1]] = price[2];\\n        }\\n        for (int i = 1; i < m+1; i++) {\\n            for (int j = 1; j < n+1; j++) {\\n                // all horizontal\\n                for (int k = 1; k <= i/2; k++) {\\n                    dp[i][j] = Math.max(dp[i][j], dp[i-k][j] + dp[k][j]);\\n                }\\n                // all vertical\\n                for (int k = 1; k <= j/2; k++) {\\n                    dp[i][j] = Math.max(dp[i][j], dp[i][j-k] + dp[i][k]);\\n                }\\n            }\\n        }\\n        \\n        return dp[m][n];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3200861,
                "title": "crisp-n-clear-o-n-javascript-memory-33-meaningful-vars",
                "content": "Time Complexity: O(N)\\nSpace Complexity: O(N)\\n```\\nvar sellingWood = function(row, colum, prices) {\\n\\tconst dynamicProgramming = (function() {\\n\\t\\tconst config = {};\\n\\t\\tfor (const iterator of prices) {\\n\\t\\t\\tconst key = `${iterator[0]}_${iterator[1]}`;\\n\\t\\t\\tconfig[key] = iterator[2];\\n\\t\\t}\\n\\t\\treturn config;\\n\\t})();\\n\\tfor (let rowIndex = 1; rowIndex <= row; rowIndex++) {\\n\\t\\tfor (let columnIndex = 1; columnIndex <= colum; columnIndex++) {\\n\\t\\t\\tconst key = `${rowIndex}_${columnIndex}`;\\n\\t\\t\\tfor (let horizontalIndex = 1; horizontalIndex <= columnIndex; horizontalIndex++) {\\n\\t\\t\\t\\tconst key1 = `${rowIndex}_${horizontalIndex}`;\\n\\t\\t\\t\\tconst key2 = `${rowIndex}_${columnIndex - horizontalIndex}`;\\n\\t\\t\\t\\tdynamicProgramming[key] = Math.max(\\n\\t\\t\\t\\t\\tdynamicProgramming[key] || 0,\\n\\t\\t\\t\\t\\t(dynamicProgramming[key1] || 0) + (dynamicProgramming[key2] || 0)\\n\\t\\t\\t\\t);\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor (let verticalIndex = 1; verticalIndex <= rowIndex; verticalIndex++) {\\n\\t\\t\\t\\tconst key1 = `${verticalIndex}_${columnIndex}`;\\n\\t\\t\\t\\tconst key2 = `${rowIndex - verticalIndex}_${columnIndex}`;\\n\\t\\t\\t\\tdynamicProgramming[key] = Math.max(\\n\\t\\t\\t\\t\\tdynamicProgramming[key] || 0,\\n\\t\\t\\t\\t\\t(dynamicProgramming[key1] || 0) + (dynamicProgramming[key2] || 0)\\n\\t\\t\\t\\t);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tconst key = `${row}_${colum}`;\\n\\treturn dynamicProgramming[key];\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar sellingWood = function(row, colum, prices) {\\n\\tconst dynamicProgramming = (function() {\\n\\t\\tconst config = {};\\n\\t\\tfor (const iterator of prices) {\\n\\t\\t\\tconst key = `${iterator[0]}_${iterator[1]}`;\\n\\t\\t\\tconfig[key] = iterator[2];\\n\\t\\t}\\n\\t\\treturn config;\\n\\t})();\\n\\tfor (let rowIndex = 1; rowIndex <= row; rowIndex++) {\\n\\t\\tfor (let columnIndex = 1; columnIndex <= colum; columnIndex++) {\\n\\t\\t\\tconst key = `${rowIndex}_${columnIndex}`;\\n\\t\\t\\tfor (let horizontalIndex = 1; horizontalIndex <= columnIndex; horizontalIndex++) {\\n\\t\\t\\t\\tconst key1 = `${rowIndex}_${horizontalIndex}`;\\n\\t\\t\\t\\tconst key2 = `${rowIndex}_${columnIndex - horizontalIndex}`;\\n\\t\\t\\t\\tdynamicProgramming[key] = Math.max(\\n\\t\\t\\t\\t\\tdynamicProgramming[key] || 0,\\n\\t\\t\\t\\t\\t(dynamicProgramming[key1] || 0) + (dynamicProgramming[key2] || 0)\\n\\t\\t\\t\\t);\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor (let verticalIndex = 1; verticalIndex <= rowIndex; verticalIndex++) {\\n\\t\\t\\t\\tconst key1 = `${verticalIndex}_${columnIndex}`;\\n\\t\\t\\t\\tconst key2 = `${rowIndex - verticalIndex}_${columnIndex}`;\\n\\t\\t\\t\\tdynamicProgramming[key] = Math.max(\\n\\t\\t\\t\\t\\tdynamicProgramming[key] || 0,\\n\\t\\t\\t\\t\\t(dynamicProgramming[key1] || 0) + (dynamicProgramming[key2] || 0)\\n\\t\\t\\t\\t);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tconst key = `${row}_${colum}`;\\n\\treturn dynamicProgramming[key];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3036060,
                "title": "simple-python-solution-with-explanation",
                "content": "# Approach\\n\\n* Price Map -> \\n\\n    Since prices is a list, it is costly to fetch the price of a specific height `h` and width `w`. \\n    Lets convert it to a map: `priceMap` where the first order key is height and second order key is width.\\n\\n    ```\\n    height: h1\\n    width: w1\\n    price: priceMap[h1][w1]\\n    ```\\n\\n* Recursive approach ->\\n\\n    Lets say we have a rectangle of height `h` and width `w`, \\n\\n    * first, lets check if there is any price in our `priceMap` for this rectangle configuration (or initialise it to zero)\\n    * now lets say we make a horizontal cut, so that it divides the rectangle in two rectangles:\\n    Rectangle 1: height: `h1`, width: `w`\\n    Rectangle 2: height: `h-h1`, width: `w`\\n\\n    \\n    * lets check where can we make a cut so that we get the maximum price, `h1` can be anywhere between `[1, h-1]` (inclusive)\\n      we will recursively check for each of this rectangle, and maximise the amount\\n        ```\\n        money = max(\\n            money,  \\n            rec(h1, w) + rec(h-h1, w)\\n        )\\n        ```\\n\\n    do the same vertically\\n\\n\\n# Complexity\\n- Time complexity:\\n$$O(m * n)$$\\n\\n- Space complexity:\\n$$O(m * n)$$  -> memoization and priceMap\\n\\n# Code\\n```\\nclass Solution:\\n    def sellingWood(self, m: int, n: int, prices: List[List[int]]) -> int:\\n\\n        priceMap = {}\\n        for p in prices:\\n            if p[0] in priceMap:\\n                priceMap[p[0]][p[1]] = p[2]\\n            else:\\n                priceMap[p[0]] = {p[1]: p[2]}\\n\\n        def getPrice(h, w):\\n            if h in priceMap and w in priceMap[h]:\\n                return priceMap[h][w]\\n            return 0\\n\\n        @cache\\n        def rec(h, w):\\n            money = getPrice(h, w)\\n\\n            # cut horizontal\\n            for i in range(1, h):\\n                money = max(money, rec(i, w) + rec(h - i, w))\\n\\n            # cut vertical\\n            for i in range(1, w):\\n                money = max(money, rec(h, i) + rec(h, w - i))\\n\\n            return money\\n\\n        return rec(m, n)\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n    height: h1\\n    width: w1\\n    price: priceMap[h1][w1]\\n    ```\n```\\n        money = max(\\n            money,  \\n            rec(h1, w) + rec(h-h1, w)\\n        )\\n        ```\n```\\nclass Solution:\\n    def sellingWood(self, m: int, n: int, prices: List[List[int]]) -> int:\\n\\n        priceMap = {}\\n        for p in prices:\\n            if p[0] in priceMap:\\n                priceMap[p[0]][p[1]] = p[2]\\n            else:\\n                priceMap[p[0]] = {p[1]: p[2]}\\n\\n        def getPrice(h, w):\\n            if h in priceMap and w in priceMap[h]:\\n                return priceMap[h][w]\\n            return 0\\n\\n        @cache\\n        def rec(h, w):\\n            money = getPrice(h, w)\\n\\n            # cut horizontal\\n            for i in range(1, h):\\n                money = max(money, rec(i, w) + rec(h - i, w))\\n\\n            # cut vertical\\n            for i in range(1, w):\\n                money = max(money, rec(h, i) + rec(h, w - i))\\n\\n            return money\\n\\n        return rec(m, n)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2609208,
                "title": "dp",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tlong long f(int m,int n,vector<vector<long long>>& maxPrice,vector<vector<long long>>&dp)\\n\\t\\t{\\n\\t\\t\\tif(dp[m][n]!=-1)\\n\\t\\t\\t\\treturn dp[m][n];\\n\\t\\t\\tlong long money=maxPrice[m][n];\\n\\t\\t\\t//horizontal cut\\n\\t\\t\\tfor(int h=1;h<m;h++)\\n\\t\\t\\t\\tmoney=max(money,f(m-h,n,maxPrice,dp)+f(h,n,maxPrice,dp));\\n\\n\\t\\t\\t//vertical\\n\\t\\t\\tfor(int v=1;v<n;v++)\\n\\t\\t\\t\\tmoney=max(money,f(m,n-v,maxPrice,dp)+f(m,v,maxPrice,dp));\\n\\n\\t\\t\\treturn dp[m][n]=money;\\n\\t\\t}\\n\\t\\tlong long sellingWood(int m, int n, vector<vector<int>>& prices) \\n\\t\\t{\\n\\t\\t\\tvector<vector<long long>> maxPrice(m+1, vector<long long>(n+1, 0));\\n\\t\\t\\tfor (auto p : prices) {\\n\\t\\t\\t\\tint h = p[0];\\n\\t\\t\\t\\tint w = p[1];\\n\\t\\t\\t\\tmaxPrice[h][w] = p[2];\\n\\t\\t\\t}\\n\\n\\t\\t\\tvector<vector<long long>> dp(m+1, vector<long long>(n+1, -1));\\n\\t\\t\\treturn f(m,n,maxPrice,dp);\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tlong long f(int m,int n,vector<vector<long long>>& maxPrice,vector<vector<long long>>&dp)\\n\\t\\t{\\n\\t\\t\\tif(dp[m][n]!=-1)\\n\\t\\t\\t\\treturn dp[m][n];\\n\\t\\t\\tlong long money=maxPrice[m][n];\\n\\t\\t\\t//horizontal cut\\n\\t\\t\\tfor(int h=1;h<m;h++)\\n\\t\\t\\t\\tmoney=max(money,f(m-h,n,maxPrice,dp)+f(h,n,maxPrice,dp));\\n\\n\\t\\t\\t//vertical\\n\\t\\t\\tfor(int v=1;v<n;v++)\\n\\t\\t\\t\\tmoney=max(money,f(m,n-v,maxPrice,dp)+f(m,v,maxPrice,dp));\\n\\n\\t\\t\\treturn dp[m][n]=money;\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2402901,
                "title": "c-dp-memoization",
                "content": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    ll dp[201][201];\\n\\t\\n    ll solve(int m, int n, unordered_map<string,ll> &price){\\n        if(m<=0 || n<=0) return 0;\\n        if(dp[m][n] != -1) return dp[m][n];\\n        \\n        string key = to_string(m)+\"#\"+to_string(n);\\n        \\n        ll ans = 0;\\n        if(price.find(key) != price.end()) ans = price[key];\\n   \\n        for(int i=1; i<=m/2; ++i){\\n            ans = max(ans, solve(i,n,price) + solve(m-i,n,price));\\n        }\\n        \\n        for(int j=1; j<=n/2; ++j){\\n            ans = max(ans, solve(m,n-j,price) + solve(m,j,price));\\n        }\\n        \\n        return dp[m][n] = ans;\\n    }\\n    \\n    \\n    long long sellingWood(int m, int n, vector<vector<int>>& prices) {\\n\\n        memset(dp,-1,sizeof(dp));\\n        ll sz = prices.size();\\n        unordered_map<string,ll> price;\\n        \\n        for(int i=0; i<sz; ++i){\\n            string key = to_string(prices[i][0])+\"#\"+to_string(prices[i][1]);\\n            price[key] = prices[i][2];\\n        }\\n        \\n        return solve(m,n,price);\\n    }\\n};\\n```\\nplease **UPVOTE**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    ll dp[201][201];\\n\\t\\n    ll solve(int m, int n, unordered_map<string,ll> &price){\\n        if(m<=0 || n<=0) return 0;\\n        if(dp[m][n] != -1) return dp[m][n];\\n        \\n        string key = to_string(m)+\"#\"+to_string(n);\\n        \\n        ll ans = 0;\\n        if(price.find(key) != price.end()) ans = price[key];\\n   \\n        for(int i=1; i<=m/2; ++i){\\n            ans = max(ans, solve(i,n,price) + solve(m-i,n,price));\\n        }\\n        \\n        for(int j=1; j<=n/2; ++j){\\n            ans = max(ans, solve(m,n-j,price) + solve(m,j,price));\\n        }\\n        \\n        return dp[m][n] = ans;\\n    }\\n    \\n    \\n    long long sellingWood(int m, int n, vector<vector<int>>& prices) {\\n\\n        memset(dp,-1,sizeof(dp));\\n        ll sz = prices.size();\\n        unordered_map<string,ll> price;\\n        \\n        for(int i=0; i<sz; ++i){\\n            string key = to_string(prices[i][0])+\"#\"+to_string(prices[i][1]);\\n            price[key] = prices[i][2];\\n        }\\n        \\n        return solve(m,n,price);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2194345,
                "title": "python-bottom-up-dp-faster-than-99",
                "content": "```\\nclass Solution:\\n    def sellingWood(self, m: int, n: int, prices: List[List[int]]) -> int:\\n        dp = [[0]*(n+1) for _ in range(m+1)]\\n        for h, w, p in prices:\\n            dp[h][w] = p\\n        for i in range(1, m+1):\\n            for j in range(1, n+1):\\n                v = max(dp[k][j] + dp[i - k][j] for k in range(1, i // 2 + 1)) if i > 1 else 0\\n                h = max(dp[i][k] + dp[i][j - k] for k in range(1, j // 2 + 1)) if j > 1 else 0\\n                dp[i][j] = max(dp[i][j], v, h)\\n        return dp[m][n]",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def sellingWood(self, m: int, n: int, prices: List[List[int]]) -> int:\\n        dp = [[0]*(n+1) for _ in range(m+1)]\\n        for h, w, p in prices:\\n            dp[h][w] = p\\n        for i in range(1, m+1):\\n            for j in range(1, n+1):\\n                v = max(dp[k][j] + dp[i - k][j] for k in range(1, i // 2 + 1)) if i > 1 else 0\\n                h = max(dp[i][k] + dp[i][j - k] for k in range(1, j // 2 + 1)) if j > 1 else 0\\n                dp[i][j] = max(dp[i][j], v, h)\\n        return dp[m][n]",
                "codeTag": "Java"
            },
            {
                "id": 2193598,
                "title": "c-dp-easy-understanding",
                "content": "```\\ntypedef long long ll;\\nclass Solution {\\n    \\npublic:\\n    ll dp[201][201];\\n    \\n    ll mxprice(int rows,int columns,vector<vector<ll>>&price){\\n        if(dp[rows][columns]!=-1)\\n            return dp[rows][columns];\\n        \\n        if(rows==1 && columns==1){\\n            dp[rows][columns] = price[1][1];\\n            return price[1][1];\\n        }\\n        \\n        \\n        \\n        ll ans = price[rows][columns];\\n        for(int i=1;i<=rows/2;i++)\\n            ans = max(ans,mxprice(i,columns,price)+mxprice(rows-i,columns,price));\\n        \\n        for(int i=1;i<=columns/2;i++)\\n            ans = max(ans,mxprice(rows,i,price)+mxprice(rows,columns-i,price));\\n        dp[rows][columns] = ans;\\n        return ans;\\n    }\\n    \\n    \\n    long long sellingWood(int m, int n, vector<vector<int>>& prices) {\\n        memset(dp,-1,sizeof(dp));\\n        \\n        vector<vector<ll>>price(m+1,vector<ll>(n+1,0));\\n        \\n        for(auto it:prices)\\n            price[it[0]][it[1]] = it[2];\\n        \\n        return mxprice(m,n,price);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\ntypedef long long ll;\\nclass Solution {\\n    \\npublic:\\n    ll dp[201][201];\\n    \\n    ll mxprice(int rows,int columns,vector<vector<ll>>&price){\\n        if(dp[rows][columns]!=-1)\\n            return dp[rows][columns];\\n        \\n        if(rows==1 && columns==1){\\n            dp[rows][columns] = price[1][1];\\n            return price[1][1];\\n        }\\n        \\n        \\n        \\n        ll ans = price[rows][columns];\\n        for(int i=1;i<=rows/2;i++)\\n            ans = max(ans,mxprice(i,columns,price)+mxprice(rows-i,columns,price));\\n        \\n        for(int i=1;i<=columns/2;i++)\\n            ans = max(ans,mxprice(rows,i,price)+mxprice(rows,columns-i,price));\\n        dp[rows][columns] = ans;\\n        return ans;\\n    }\\n    \\n    \\n    long long sellingWood(int m, int n, vector<vector<int>>& prices) {\\n        memset(dp,-1,sizeof(dp));\\n        \\n        vector<vector<ll>>price(m+1,vector<ll>(n+1,0));\\n        \\n        for(auto it:prices)\\n            price[it[0]][it[1]] = it[2];\\n        \\n        return mxprice(m,n,price);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2173616,
                "title": "c-recursion-memorization-matrix-chain-multiplication-mcm-approach-100-faster",
                "content": "**Intuition :**\\nAs 1 <= m, n <= 200 and (1<= hi<=m , 1<=wi<=n)\\nTraversing and checking each possible horizontal cut from (1 to m-1) and each vertical cut (1 to n-1) takes O(m+n) time for each dp position. In worst case, we need to calculate it for every cell O(m*n)\\nTotal Time: **O(mn(m+n))**\\nTotal Space:  **O(m * n)**\\n\\nUsing memorization: We can further reduce the time by avoiding this calculation for already computer sizes to avoid repeated calculation. \\n\\n```\\nclass Solution {\\npublic:\\n    map<pair<int,int>,int> profit;\\n    vector<vector<long long>> dp;\\n    long long max(long long a,long long b){\\n        return a>b?a:b;\\n    }\\n    long long solve(int m,int n,vector<vector<int>>& prices){\\n        if(m<0||n<0)return 0;\\n        if(dp[m][n]>-1)return dp[m][n];\\n        dp[m][n]=profit[{m,n}];\\n        //checking each possible horizontal cut\\n        for(int h=1;h<m;h++){\\n            dp[m][n]=max(dp[m][n],solve(h,n,prices)+solve(m-h,n,prices));\\n        }\\n\\t\\t//checking each possible vertical cut\\n        for(int v=1;v<n;v++){\\n            dp[m][n]=max(dp[m][n],solve(m,v,prices)+solve(m,n-v,prices));\\n        }\\n        \\n        return dp[m][n];\\n    }\\n    long long sellingWood(int m, int n, vector<vector<int>>& prices) {\\n        if(m==0&&n==0)return 0;\\n        dp.resize(m+1,vector<long long>(n+1,-1));\\n        for(int i=0;i<=m;i++)dp[i][0]=0;\\n        for(int i=0;i<=n;i++)dp[0][i]=0;\\n        for(auto t:prices){\\n            profit[make_pair(t[0],t[1])]=t[2];\\n        }\\n        return solve(m,n,prices);\\n    }\\n};\\n```\\n**Note** :\\nDividing m size height into [1,m-1] cuts =[m-1,1] cuts\\nSo we can further optimize above code by looping in for only (1 to m/2) and (1 to n/2)\\n\\n**Runtime**: 747 ms, **faster than 100.00%** of C++ online submissions for Selling Pieces of Wood.\\n**Memory Usage**: 41 MB, **less than 100.00%** of C++ online submissions for Selling Pieces of Wood.\\n```\\nclass Solution {\\npublic:\\n    map<pair<int,int>,int> profit;\\n    vector<vector<long long>> dp;\\n    long long max(long long a,long long b){\\n        return a>b?a:b;\\n    }\\n    long long solve(int m,int n,vector<vector<int>>& prices){\\n        if(m<0||n<0)return 0;\\n        if(dp[m][n]>-1)return dp[m][n];\\n        dp[m][n]=profit[{m,n}];\\n        //checking each possible horizontal cut\\n        for(int h=1;h<=m/2;h++){\\n            dp[m][n]=max(dp[m][n],solve(h,n,prices)+solve(m-h,n,prices));\\n        }\\n\\t\\t//checking each possible vertical cut\\n        for(int v=1;v<=n/2;v++){\\n            dp[m][n]=max(dp[m][n],solve(m,v,prices)+solve(m,n-v,prices));\\n        }\\n        \\n        return dp[m][n];\\n    }\\n    long long sellingWood(int m, int n, vector<vector<int>>& prices) {\\n        if(m==0&&n==0)return 0;\\n        dp.resize(m+1,vector<long long>(n+1,-1));\\n        for(int i=0;i<=m;i++)dp[i][0]=0;\\n        for(int i=0;i<=n;i++)dp[0][i]=0;\\n        for(auto t:prices){\\n            profit[make_pair(t[0],t[1])]=t[2];\\n        }\\n        return solve(m,n,prices);\\n    }\\n};\\n```\\n\\n***Please upvote if you like the solution.***",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    map<pair<int,int>,int> profit;\\n    vector<vector<long long>> dp;\\n    long long max(long long a,long long b){\\n        return a>b?a:b;\\n    }\\n    long long solve(int m,int n,vector<vector<int>>& prices){\\n        if(m<0||n<0)return 0;\\n        if(dp[m][n]>-1)return dp[m][n];\\n        dp[m][n]=profit[{m,n}];\\n        //checking each possible horizontal cut\\n        for(int h=1;h<m;h++){\\n            dp[m][n]=max(dp[m][n],solve(h,n,prices)+solve(m-h,n,prices));\\n        }\\n\\t\\t//checking each possible vertical cut\\n        for(int v=1;v<n;v++){\\n            dp[m][n]=max(dp[m][n],solve(m,v,prices)+solve(m,n-v,prices));\\n        }\\n        \\n        return dp[m][n];\\n    }\\n    long long sellingWood(int m, int n, vector<vector<int>>& prices) {\\n        if(m==0&&n==0)return 0;\\n        dp.resize(m+1,vector<long long>(n+1,-1));\\n        for(int i=0;i<=m;i++)dp[i][0]=0;\\n        for(int i=0;i<=n;i++)dp[0][i]=0;\\n        for(auto t:prices){\\n            profit[make_pair(t[0],t[1])]=t[2];\\n        }\\n        return solve(m,n,prices);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    map<pair<int,int>,int> profit;\\n    vector<vector<long long>> dp;\\n    long long max(long long a,long long b){\\n        return a>b?a:b;\\n    }\\n    long long solve(int m,int n,vector<vector<int>>& prices){\\n        if(m<0||n<0)return 0;\\n        if(dp[m][n]>-1)return dp[m][n];\\n        dp[m][n]=profit[{m,n}];\\n        //checking each possible horizontal cut\\n        for(int h=1;h<=m/2;h++){\\n            dp[m][n]=max(dp[m][n],solve(h,n,prices)+solve(m-h,n,prices));\\n        }\\n\\t\\t//checking each possible vertical cut\\n        for(int v=1;v<=n/2;v++){\\n            dp[m][n]=max(dp[m][n],solve(m,v,prices)+solve(m,n-v,prices));\\n        }\\n        \\n        return dp[m][n];\\n    }\\n    long long sellingWood(int m, int n, vector<vector<int>>& prices) {\\n        if(m==0&&n==0)return 0;\\n        dp.resize(m+1,vector<long long>(n+1,-1));\\n        for(int i=0;i<=m;i++)dp[i][0]=0;\\n        for(int i=0;i<=n;i++)dp[0][i]=0;\\n        for(auto t:prices){\\n            profit[make_pair(t[0],t[1])]=t[2];\\n        }\\n        return solve(m,n,prices);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2169159,
                "title": "javascript-dp-w-memoization",
                "content": "**Solution: DP w/ Memoization**\\n\\nFirst, change prices so that we can look up the price in `O(1)` time.\\nMemoize the result of each `(width, height)`, take the maximum earnings from a piece of wood with those measurements.\\n\\nGiven the width and height of a piece of wood, we can make horizontal or vetical cuts.\\n  Try each of the different sized horizontal and vertical cuts.\\n  Take the maximum price out of all the different ways of cutting.\\n\\nTime Complexity: `O(m * n * (m + n))` 810ms\\nSpace Complexity: `O(mn)` 63.6MB\\n```\\nvar sellingWood = function(m, n, prices) {\\n  let price = Array(n + 1).fill(0).map(() => Array(m + 1).fill(0));\\n  for (let [height, width, woodPrice] of prices) {\\n    price[width][height] = woodPrice;\\n  }\\n  let memo = Array(n + 1).fill(0).map(() => Array(m + 1).fill(-1));\\n  return dfs(n, m);\\n\\n  function dfs(width, height) {\\n    if (width === 0 || height === 0) return 0;\\n    if (memo[width][height] !== -1) return memo[width][height];\\n\\n    let ans = price[width][height];\\n    for (let h = 1; h <= Math.floor(height / 2); h++) {\\n      ans = Math.max(ans, dfs(width, h) + dfs(width, height - h));\\n    }\\n    for (let w = 1; w <= Math.floor(width / 2); w++) {\\n      ans = Math.max(ans, dfs(w, height) + dfs(width - w, height));\\n    }\\n    return memo[width][height] = ans;\\n  }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar sellingWood = function(m, n, prices) {\\n  let price = Array(n + 1).fill(0).map(() => Array(m + 1).fill(0));\\n  for (let [height, width, woodPrice] of prices) {\\n    price[width][height] = woodPrice;\\n  }\\n  let memo = Array(n + 1).fill(0).map(() => Array(m + 1).fill(-1));\\n  return dfs(n, m);\\n\\n  function dfs(width, height) {\\n    if (width === 0 || height === 0) return 0;\\n    if (memo[width][height] !== -1) return memo[width][height];\\n\\n    let ans = price[width][height];\\n    for (let h = 1; h <= Math.floor(height / 2); h++) {\\n      ans = Math.max(ans, dfs(width, h) + dfs(width, height - h));\\n    }\\n    for (let w = 1; w <= Math.floor(width / 2); w++) {\\n      ans = Math.max(ans, dfs(w, height) + dfs(width - w, height));\\n    }\\n    return memo[width][height] = ans;\\n  }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2168786,
                "title": "c-bottom-up-dynamic-programming-100-faster-100-mem-efficient",
                "content": "Most Important Observation -\\nIf we cut the wood into pieces we MUST cut entire height or width\\nEg: 2X3 --> 2X2 + 2X1 Entire height or width must be cut\\nLogic-\\nwe cut piece of i X j into smaller pieces -\\n\\tfor(int k=0;k<=j;++k){\\n                    dp[i][j] = max(dp[i][j],dp[i][k]+dp[i][j-k]);//--->[2X4] = [2X1] + [2X3]\\n                }\\n\\t for(int k=0;k<=i;++k){\\n                    dp[i][j] = max(dp[i][j],dp[k][j]+dp[i-k][j]);//--->[3X4] = [1X4] + [2X4]\\n                }\\n \\n\\n```\\nclass Solution {\\npublic:\\n    long long sellingWood(int r, int c, vector<vector<int>>& prices) {\\n        long long dp[r+1][c+1];\\n        memset(dp,0,sizeof(dp));\\n        for(auto i:prices){\\n            dp[i[0]][i[1]] = i[2];\\n        }\\n        \\n        for(int i=1;i<=r;++i){\\n            for(int j=1;j<=c;++j){\\n                for(int k=0;k<=j;++k){\\n                    dp[i][j] = max(dp[i][j],dp[i][k]+dp[i][j-k]);\\n                }\\n                for(int k=0;k<=i;++k){\\n                    dp[i][j] = max(dp[i][j],dp[k][j]+dp[i-k][j]);\\n                }\\n            }\\n        }\\n        return dp[r][c];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long sellingWood(int r, int c, vector<vector<int>>& prices) {\\n        long long dp[r+1][c+1];\\n        memset(dp,0,sizeof(dp));\\n        for(auto i:prices){\\n            dp[i[0]][i[1]] = i[2];\\n        }\\n        \\n        for(int i=1;i<=r;++i){\\n            for(int j=1;j<=c;++j){\\n                for(int k=0;k<=j;++k){\\n                    dp[i][j] = max(dp[i][j],dp[i][k]+dp[i][j-k]);\\n                }\\n                for(int k=0;k<=i;++k){\\n                    dp[i][j] = max(dp[i][j],dp[k][j]+dp[i-k][j]);\\n                }\\n            }\\n        }\\n        return dp[r][c];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2168669,
                "title": "c-recursion-with-memoization",
                "content": "```\\n#define ll long long int\\nclass Solution {\\npublic:\\n    vector<vector<ll>>mp;\\n    ll dp[205][205];\\n    ll rec(int m,int n)\\n    {\\n        if(m==1&&n==1)\\n        {\\n            return mp[m][n];\\n        }\\n        if(dp[m][n]!=-1)\\n            return dp[m][n];\\n        ll ans=0;\\n        for(int i=1;i<m;i++)\\n        {\\n            int sum=0;\\n            \\n            ans=max(ans,max(mp[i][n],rec(i,n))+max(mp[m-i][n],rec(m-i,n)));\\n        }\\n        for(int i=1;i<n;i++)\\n        {\\n            int sum=0;\\n            ans=max(ans,max(mp[m][i],rec(m,i))+max(mp[m][n-i],rec(m,n-i)));\\n        }\\n        \\n        return dp[m][n]=ans;\\n    }\\n    long long sellingWood(int m, int n, vector<vector<int>>& prices) {\\n        memset(dp,-1,sizeof(dp));\\n        mp.clear();\\n        for(int i=0;i<=m+2;i++)\\n        {\\n            vector<ll>temp;\\n            for(int j=0;j<=n+2;j++)\\n                temp.push_back(0);\\n            mp.push_back(temp);\\n        }\\n        for(auto x : prices)\\n            mp[x[0]][x[1]]=x[2];\\n        \\n        ll ans=max(rec(m,n),mp[m][n]);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Memoization"
                ],
                "code": "```\\n#define ll long long int\\nclass Solution {\\npublic:\\n    vector<vector<ll>>mp;\\n    ll dp[205][205];\\n    ll rec(int m,int n)\\n    {\\n        if(m==1&&n==1)\\n        {\\n            return mp[m][n];\\n        }\\n        if(dp[m][n]!=-1)\\n            return dp[m][n];\\n        ll ans=0;\\n        for(int i=1;i<m;i++)\\n        {\\n            int sum=0;\\n            \\n            ans=max(ans,max(mp[i][n],rec(i,n))+max(mp[m-i][n],rec(m-i,n)));\\n        }\\n        for(int i=1;i<n;i++)\\n        {\\n            int sum=0;\\n            ans=max(ans,max(mp[m][i],rec(m,i))+max(mp[m][n-i],rec(m,n-i)));\\n        }\\n        \\n        return dp[m][n]=ans;\\n    }\\n    long long sellingWood(int m, int n, vector<vector<int>>& prices) {\\n        memset(dp,-1,sizeof(dp));\\n        mp.clear();\\n        for(int i=0;i<=m+2;i++)\\n        {\\n            vector<ll>temp;\\n            for(int j=0;j<=n+2;j++)\\n                temp.push_back(0);\\n            mp.push_back(temp);\\n        }\\n        for(auto x : prices)\\n            mp[x[0]][x[1]]=x[2];\\n        \\n        ll ans=max(rec(m,n),mp[m][n]);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2168536,
                "title": "c-tabulation-bottom-up-optimized-approach-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    long long sellingWood(int m, int n, vector<vector<int>>& prices) {\\n           long long dp[201][201] = {};\\n        for (auto& p: prices)\\n            dp[p[0]][p[1]] = p[2];\\n        for (int w = 1; w <= m; ++w) {\\n            for (int h = 1; h <= n; ++h) {\\n                for (int a = 1; a <= w / 2; ++a)\\n                    dp[w][h] = max(dp[w][h], dp[a][h] + dp[w - a][h]);\\n                for (int a = 1; a <= h / 2; ++a)\\n                    dp[w][h] = max(dp[w][h], dp[w][a] + dp[w][h - a]);\\n            }\\n        }\\n        return dp[m][n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long sellingWood(int m, int n, vector<vector<int>>& prices) {\\n           long long dp[201][201] = {};\\n        for (auto& p: prices)\\n            dp[p[0]][p[1]] = p[2];\\n        for (int w = 1; w <= m; ++w) {\\n            for (int h = 1; h <= n; ++h) {\\n                for (int a = 1; a <= w / 2; ++a)\\n                    dp[w][h] = max(dp[w][h], dp[a][h] + dp[w - a][h]);\\n                for (int a = 1; a <= h / 2; ++a)\\n                    dp[w][h] = max(dp[w][h], dp[w][a] + dp[w][h - a]);\\n            }\\n        }\\n        return dp[m][n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2168389,
                "title": "rust-memoization",
                "content": "### This is what I have written during the contest, will impove later \\n\\n```rust\\nuse std::{\\n    cell::RefCell,\\n    cmp::Ordering,\\n    collections::{BTreeMap, BinaryHeap, HashMap, HashSet, VecDeque},\\n    rc::Rc,\\n    vec,\\n};\\n\\n\\n\\nimpl Solution {\\n    pub fn selling_wood(m: i32, n: i32, prices: Vec<Vec<i32>>) -> i64 {\\n        let mut p: HashMap<(i32, i32), (i128, bool)> = HashMap::new();\\n\\n        p.insert((0, 0), (0, true));\\n        p.insert((1, 0), (0, true));\\n        p.insert((0, 1), (0, true));\\n        p.insert((1, 1), (0, true));\\n\\n        for price in &prices {\\n            let l = price[0];\\n            let h = price[1];\\n            let v = price[2] as i128;\\n            p.insert((l, h), (v, false));\\n        }\\n\\n        let mut prices = p;\\n\\n        // println!(\"{:?}\", prices);\\n\\n\\n        fn helper(\\n            m: i32,\\n            n: i32,\\n            prices: &mut HashMap<(i32, i32), (i128, bool)>,\\n        ) -> i128 {\\n            // println!(\"HELPER CALL m {} n {}\", m, n);\\n\\n            let mut res = 0;\\n            if let Some((r, finalized)) = prices.get(&(m, n)) {\\n                if *finalized {\\n                    return *r;\\n                }\\n                res = *r;\\n            }\\n\\n            // split m\\n            for i in 1..=(m - 1) {\\n                let sub_0 = helper(i, n, prices);\\n                let sub_1 = helper(m - i, n, prices);\\n                res = std::cmp::max(res, sub_0 + sub_1);\\n            }\\n\\n            // split n\\n            for i in 1..=(n - 1) {\\n                let sub_0 = helper(m, i, prices);\\n                let sub_1 = helper(m, n - i, prices);\\n                res = std::cmp::max(res, sub_0 + sub_1);\\n            }\\n\\n            // println!(\"HEPER m {} n {} res {} price {:?}\", m, n, res, &prices);\\n\\n            prices.insert((m, n), (res, true));\\n            res\\n        }\\n\\n        // println!(\"{:?}\", &prices);\\n\\n        helper(m, n, &mut prices) as i64\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```rust\\nuse std::{\\n    cell::RefCell,\\n    cmp::Ordering,\\n    collections::{BTreeMap, BinaryHeap, HashMap, HashSet, VecDeque},\\n    rc::Rc,\\n    vec,\\n};\\n\\n\\n\\nimpl Solution {\\n    pub fn selling_wood(m: i32, n: i32, prices: Vec<Vec<i32>>) -> i64 {\\n        let mut p: HashMap<(i32, i32), (i128, bool)> = HashMap::new();\\n\\n        p.insert((0, 0), (0, true));\\n        p.insert((1, 0), (0, true));\\n        p.insert((0, 1), (0, true));\\n        p.insert((1, 1), (0, true));\\n\\n        for price in &prices {\\n            let l = price[0];\\n            let h = price[1];\\n            let v = price[2] as i128;\\n            p.insert((l, h), (v, false));\\n        }\\n\\n        let mut prices = p;\\n\\n        // println!(\"{:?}\", prices);\\n\\n\\n        fn helper(\\n            m: i32,\\n            n: i32,\\n            prices: &mut HashMap<(i32, i32), (i128, bool)>,\\n        ) -> i128 {\\n            // println!(\"HELPER CALL m {} n {}\", m, n);\\n\\n            let mut res = 0;\\n            if let Some((r, finalized)) = prices.get(&(m, n)) {\\n                if *finalized {\\n                    return *r;\\n                }\\n                res = *r;\\n            }\\n\\n            // split m\\n            for i in 1..=(m - 1) {\\n                let sub_0 = helper(i, n, prices);\\n                let sub_1 = helper(m - i, n, prices);\\n                res = std::cmp::max(res, sub_0 + sub_1);\\n            }\\n\\n            // split n\\n            for i in 1..=(n - 1) {\\n                let sub_0 = helper(m, i, prices);\\n                let sub_1 = helper(m, n - i, prices);\\n                res = std::cmp::max(res, sub_0 + sub_1);\\n            }\\n\\n            // println!(\"HEPER m {} n {} res {} price {:?}\", m, n, res, &prices);\\n\\n            prices.insert((m, n), (res, true));\\n            res\\n        }\\n\\n        // println!(\"{:?}\", &prices);\\n\\n        helper(m, n, &mut prices) as i64\\n    }\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2168311,
                "title": "c-topdown-bottom-dp",
                "content": "\\nThis is a pretty good question that bottom up DP is better than top down DP.\\nReason is that some piece of wood that already has a price in prices array, may have better price if we cut it into smaller pieces.  \\nIf we use topdown approach, we need another 2d array to store the prices (or map).\\nIf we use bottom up , it is more natural.\\nTo cut a piece of wood, you must make a vertical or horizontal cut across the\\xA0entire\\xA0height or width of the piece, this simply the question, the calculation of status is limited to O( max(n , m))\\nSo total time O(n * m * max(n , m)), space (n * m)\\n\\n\\nTopdown \\n==================================\\n```\\nclass Solution {\\npublic:\\n    vector<vector<long long>> dp;\\n    vector<vector<long long>> dp1;\\n    long long dfs(int x, int y) {\\n        if (dp1[x][y] != -1) return dp1[x][y];\\n        long long cur = dp[x][y];\\n        for (int i = 1; i <= x - i; i++) cur = max(cur, dfs(i, y) + dfs(x - i, y));      \\n        for (int j = 1; j <= y - j; j++) cur = max(cur, dfs(x, j) + dfs(x, y - j));\\n        dp1[x][y] = cur;\\n        return cur;\\n    }\\n    long long sellingWood(int n, int m, vector<vector<int>>& prices) {\\n        dp = vector<vector<long long>>(n + 1, vector<long long>(m + 1, 0));\\n        dp1 = vector<vector<long long>>(n + 1, vector<long long>(m + 1, -1));\\n        for (auto& p : prices) dp[p[0]][p[1]] = p[2];\\n        return dfs(n, m);\\n    }\\n};\\n```\\n\\n\\nBottom up\\n=================================================================\\n```\\nclass Solution {\\npublic:\\n    int n;\\n    int m;\\n    vector<vector<long long>> dp;\\n    long long dfs(int x, int y) {\\n        if (dp[x][y] != -1) return dp[x][y];\\n        long long cur = 0;\\n        for (int i = 1; i <= x - i; i++) {\\n            long long a =  dfs(i, y);\\n            long long b = dfs(x - i, y);\\n            cur = max(cur, a + b);\\n        }\\n        \\n        for (int j = 1; j <= y - j; j++) {\\n            long long a = dfs(x, j);\\n            long long b = dfs(x, y - j);\\n            cur = max(cur, a + b);\\n        }\\n        dp[x][y] = cur;\\n        return cur;\\n    }\\n    long long sellingWood(int n1, int m1, vector<vector<int>>& prices) {\\n        n = n1;\\n        m = m1;\\n        dp = vector<vector<long long>>(n + 1, vector<long long>(m + 1, -1));\\n        for (auto& p : prices) dp[p[0]][p[1]] = p[2];\\n        for (int i = 0; i < n; i++) dp[i][0] = 0;\\n        for (int j = 0; j < m; j++) dp[0][j] = 0;\\n        if (dp[1][1] == -1) dp[1][1] = 0;\\n        \\n        for (int x = 1; x <= n; x++) {\\n            for (int y = 1; y <= m; y++) {\\n                long long cur = dp[x][y];\\n                dp[x][y] = -1;\\n                long long b = dfs(x, y);\\n                dp[x][y] = max(cur, b);\\n            }\\n        }\\n        return dp[n][m];\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<long long>> dp;\\n    vector<vector<long long>> dp1;\\n    long long dfs(int x, int y) {\\n        if (dp1[x][y] != -1) return dp1[x][y];\\n        long long cur = dp[x][y];\\n        for (int i = 1; i <= x - i; i++) cur = max(cur, dfs(i, y) + dfs(x - i, y));      \\n        for (int j = 1; j <= y - j; j++) cur = max(cur, dfs(x, j) + dfs(x, y - j));\\n        dp1[x][y] = cur;\\n        return cur;\\n    }\\n    long long sellingWood(int n, int m, vector<vector<int>>& prices) {\\n        dp = vector<vector<long long>>(n + 1, vector<long long>(m + 1, 0));\\n        dp1 = vector<vector<long long>>(n + 1, vector<long long>(m + 1, -1));\\n        for (auto& p : prices) dp[p[0]][p[1]] = p[2];\\n        return dfs(n, m);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int n;\\n    int m;\\n    vector<vector<long long>> dp;\\n    long long dfs(int x, int y) {\\n        if (dp[x][y] != -1) return dp[x][y];\\n        long long cur = 0;\\n        for (int i = 1; i <= x - i; i++) {\\n            long long a =  dfs(i, y);\\n            long long b = dfs(x - i, y);\\n            cur = max(cur, a + b);\\n        }\\n        \\n        for (int j = 1; j <= y - j; j++) {\\n            long long a = dfs(x, j);\\n            long long b = dfs(x, y - j);\\n            cur = max(cur, a + b);\\n        }\\n        dp[x][y] = cur;\\n        return cur;\\n    }\\n    long long sellingWood(int n1, int m1, vector<vector<int>>& prices) {\\n        n = n1;\\n        m = m1;\\n        dp = vector<vector<long long>>(n + 1, vector<long long>(m + 1, -1));\\n        for (auto& p : prices) dp[p[0]][p[1]] = p[2];\\n        for (int i = 0; i < n; i++) dp[i][0] = 0;\\n        for (int j = 0; j < m; j++) dp[0][j] = 0;\\n        if (dp[1][1] == -1) dp[1][1] = 0;\\n        \\n        for (int x = 1; x <= n; x++) {\\n            for (int y = 1; y <= m; y++) {\\n                long long cur = dp[x][y];\\n                dp[x][y] = -1;\\n                long long b = dfs(x, y);\\n                dp[x][y] = max(cur, b);\\n            }\\n        }\\n        return dp[n][m];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2168137,
                "title": "knapsack-dp",
                "content": "```\\nimport java.util.*;\\n\\nclass Solution {\\n\\n    public long helper(long[][] max, int m, int n, Long[][] ddp) {\\n        if (ddp[m][n] != null) return ddp[m][n];\\n        ddp[m][n] = max[m][n];\\n        for (int i = 1; i < m; i++) {\\n            ddp[m][n] = Math.max(ddp[m][n], helper(max, i, n, ddp) + helper(max, m-i, n, ddp));\\n        }\\n        for (int i = 1; i < n; i++) {\\n            ddp[m][n] = Math.max(ddp[m][n], helper(max, m, i, ddp) + helper(max, m, n-i, ddp));\\n        }\\n        return ddp[m][n];\\n    }\\n\\n    public long sellingWood(int m, int n, int[][] prices) {\\n        long[][] max = new long[m+3][n+1];\\n        Arrays.sort(prices, (a,b)->(a[0]-b[0]));\\n        long[] dp = new long[n+1];\\n        int k = 0;\\n        for (int i = 1; i <= m; i++) {\\n            while (k < prices.length && prices[k][0] <= i) {\\n                for (int p = prices[k][1]; p <= n; p++) {\\n                    dp[p] = Math.max(dp[p], dp[p-prices[k][1]]+prices[k][2]);\\n                }\\n                k++;\\n            }\\n            for (int j = 0; j <= n; j++) max[i][j] = dp[j];\\n        }\\n         \\n        Long[][] ddp = new Long[m+3][n+1];\\n\\n        return helper(max, m, n, ddp);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nimport java.util.*;\\n\\nclass Solution {\\n\\n    public long helper(long[][] max, int m, int n, Long[][] ddp) {\\n        if (ddp[m][n] != null) return ddp[m][n];\\n        ddp[m][n] = max[m][n];\\n        for (int i = 1; i < m; i++) {\\n            ddp[m][n] = Math.max(ddp[m][n], helper(max, i, n, ddp) + helper(max, m-i, n, ddp));\\n        }\\n        for (int i = 1; i < n; i++) {\\n            ddp[m][n] = Math.max(ddp[m][n], helper(max, m, i, ddp) + helper(max, m, n-i, ddp));\\n        }\\n        return ddp[m][n];\\n    }\\n\\n    public long sellingWood(int m, int n, int[][] prices) {\\n        long[][] max = new long[m+3][n+1];\\n        Arrays.sort(prices, (a,b)->(a[0]-b[0]));\\n        long[] dp = new long[n+1];\\n        int k = 0;\\n        for (int i = 1; i <= m; i++) {\\n            while (k < prices.length && prices[k][0] <= i) {\\n                for (int p = prices[k][1]; p <= n; p++) {\\n                    dp[p] = Math.max(dp[p], dp[p-prices[k][1]]+prices[k][2]);\\n                }\\n                k++;\\n            }\\n            for (int j = 0; j <= n; j++) max[i][j] = dp[j];\\n        }\\n         \\n        Long[][] ddp = new Long[m+3][n+1];\\n\\n        return helper(max, m, n, ddp);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2168129,
                "title": "java-dynamic-programming",
                "content": "```\\nclass Solution {\\n    public long sellingWood(int m, int n, int[][] prices) {\\n        Long[][] dp = new Long[m + 1][n + 1];\\n        dp[0][0] = 0L;\\n        HashMap<Integer, HashMap<Integer, Long>> heightToWidthToPrice = new HashMap<Integer, HashMap<Integer, Long>>();\\n        for(int[] price : prices) {\\n            HashMap<Integer, Long> widthToPrice = heightToWidthToPrice.get(price[0]);\\n            if(widthToPrice == null) {\\n                widthToPrice = new HashMap<>();\\n                heightToWidthToPrice.put(price[0], widthToPrice);\\n            }\\n            \\n            widthToPrice.put(price[1], (long)price[2]);\\n        }\\n        \\n        return dfs(dp, m, n, heightToWidthToPrice);\\n    }\\n    \\n    private long dfs(Long[][] dp, int m, int n, HashMap<Integer, HashMap<Integer, Long>> heightToWidthToPrice) {\\n        if(dp[m][n] != null) {\\n            return dp[m][n];\\n        }\\n        \\n        dp[m][n] = 0L;\\n        HashMap<Integer, Long> widthToPrice = heightToWidthToPrice.get(m);\\n        if(widthToPrice != null) {\\n            dp[m][n] = widthToPrice.getOrDefault(n, 0L);\\n        }\\n        \\n        long candidate  = 0;\\n        for(int i = 1; i <m; ++i) {\\n            candidate = dfs(dp, i, n, heightToWidthToPrice) + \\n                dfs(dp, m-i, n, heightToWidthToPrice);\\n            dp[m][n] = Math.max(dp[m][n], candidate);\\n        }\\n        \\n        for(int j = 1; j < n; ++j) {\\n            candidate = dfs(dp, m, j, heightToWidthToPrice) + \\n                dfs(dp, m, n-j, heightToWidthToPrice);\\n            dp[m][n] = Math.max(dp[m][n], candidate);\\n        }\\n        \\n        return dp[m][n];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public long sellingWood(int m, int n, int[][] prices) {\\n        Long[][] dp = new Long[m + 1][n + 1];\\n        dp[0][0] = 0L;\\n        HashMap<Integer, HashMap<Integer, Long>> heightToWidthToPrice = new HashMap<Integer, HashMap<Integer, Long>>();\\n        for(int[] price : prices) {\\n            HashMap<Integer, Long> widthToPrice = heightToWidthToPrice.get(price[0]);\\n            if(widthToPrice == null) {\\n                widthToPrice = new HashMap<>();\\n                heightToWidthToPrice.put(price[0], widthToPrice);\\n            }\\n            \\n            widthToPrice.put(price[1], (long)price[2]);\\n        }\\n        \\n        return dfs(dp, m, n, heightToWidthToPrice);\\n    }\\n    \\n    private long dfs(Long[][] dp, int m, int n, HashMap<Integer, HashMap<Integer, Long>> heightToWidthToPrice) {\\n        if(dp[m][n] != null) {\\n            return dp[m][n];\\n        }\\n        \\n        dp[m][n] = 0L;\\n        HashMap<Integer, Long> widthToPrice = heightToWidthToPrice.get(m);\\n        if(widthToPrice != null) {\\n            dp[m][n] = widthToPrice.getOrDefault(n, 0L);\\n        }\\n        \\n        long candidate  = 0;\\n        for(int i = 1; i <m; ++i) {\\n            candidate = dfs(dp, i, n, heightToWidthToPrice) + \\n                dfs(dp, m-i, n, heightToWidthToPrice);\\n            dp[m][n] = Math.max(dp[m][n], candidate);\\n        }\\n        \\n        for(int j = 1; j < n; ++j) {\\n            candidate = dfs(dp, m, j, heightToWidthToPrice) + \\n                dfs(dp, m, n-j, heightToWidthToPrice);\\n            dp[m][n] = Math.max(dp[m][n], candidate);\\n        }\\n        \\n        return dp[m][n];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2168110,
                "title": "easy-dynamic-programming-solution-c",
                "content": "```C++\\nclass Solution {\\n    long long dp[202][202];\\n    long long c[202][202];\\n\\n    long long helper(int n, int m) {\\n        if(dp[n][m] != -1) return dp[n][m];\\n        long long& res = dp[n][m] = c[n][m];\\n        for(int i = 1; i < n; i++) { // divide with row\\n            res = max(res, helper(i,m) + helper(n-i, m));\\n        }\\n        for(int i = 1; i < m; i++) { // divide with col\\n            res = max(res, helper(n,i) + helper(n,m-i));\\n        }\\n        return res;\\n    }\\npublic:\\n    long long sellingWood(int n, int m, vector<vector<int>>& prices) {\\n        memset(dp, -1, sizeof dp);\\n        memset(c, 0, sizeof c);\\n        for(auto& p : prices) {\\n            long long y = p[0], x = p[1], w = p[2];\\n            c[y][x] = max(c[y][x], w);\\n        }\\n\\n        return helper(n,m);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```C++\\nclass Solution {\\n    long long dp[202][202];\\n    long long c[202][202];\\n\\n    long long helper(int n, int m) {\\n        if(dp[n][m] != -1) return dp[n][m];\\n        long long& res = dp[n][m] = c[n][m];\\n        for(int i = 1; i < n; i++) { // divide with row\\n            res = max(res, helper(i,m) + helper(n-i, m));\\n        }\\n        for(int i = 1; i < m; i++) { // divide with col\\n            res = max(res, helper(n,i) + helper(n,m-i));\\n        }\\n        return res;\\n    }\\npublic:\\n    long long sellingWood(int n, int m, vector<vector<int>>& prices) {\\n        memset(dp, -1, sizeof dp);\\n        memset(c, 0, sizeof c);\\n        for(auto& p : prices) {\\n            long long y = p[0], x = p[1], w = p[2];\\n            c[y][x] = max(c[y][x], w);\\n        }\\n\\n        return helper(n,m);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4086460,
                "title": "dart",
                "content": "# Code\\n```\\nimport \\'dart:math\\';\\n\\nclass Solution {\\n  int sellingWood(final int M, final int N, List<List<int>> prices) {\\n    final memo = List.generate(M + 1, (_) => List.filled(N + 1, 0));\\n    for (final price in prices) {\\n      final int h = price[0], w = price[1], profit = price[2];\\n      memo[h][w] = profit;\\n    }\\n    \\n    final vis = List.generate(M + 1, (_) => List.filled(N + 1, false));\\n\\n    int dfs(final int height, final int width) {\\n      if (height == 0 || width == 0) return 0;\\n      if (vis[height][width]) return memo[height][width];\\n      vis[height][width] = true;\\n      \\n      var tmp = memo[height][width];\\n      for (int left = 1; left < height; left++)\\n        tmp = max(tmp, dfs(left, width) + dfs(height - left, width));\\n      \\n      for (int left = 1; left < width; left++)\\n        tmp = max(tmp, dfs(height, left) + dfs(height, width - left));\\n\\n      memo[height][width] = tmp;\\n      return memo[height][width];\\n    }\\n\\n    return dfs(M, N);\\n  }\\n}\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nimport \\'dart:math\\';\\n\\nclass Solution {\\n  int sellingWood(final int M, final int N, List<List<int>> prices) {\\n    final memo = List.generate(M + 1, (_) => List.filled(N + 1, 0));\\n    for (final price in prices) {\\n      final int h = price[0], w = price[1], profit = price[2];\\n      memo[h][w] = profit;\\n    }\\n    \\n    final vis = List.generate(M + 1, (_) => List.filled(N + 1, false));\\n\\n    int dfs(final int height, final int width) {\\n      if (height == 0 || width == 0) return 0;\\n      if (vis[height][width]) return memo[height][width];\\n      vis[height][width] = true;\\n      \\n      var tmp = memo[height][width];\\n      for (int left = 1; left < height; left++)\\n        tmp = max(tmp, dfs(left, width) + dfs(height - left, width));\\n      \\n      for (int left = 1; left < width; left++)\\n        tmp = max(tmp, dfs(height, left) + dfs(height, width - left));\\n\\n      memo[height][width] = tmp;\\n      return memo[height][width];\\n    }\\n\\n    return dfs(M, N);\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3947002,
                "title": "mcm-bottom-up-dp-2d-matrix-tc-o-m-n-n-sc-o-m-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMCM -VARIATION IN DP\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n![upvote me please.png](https://assets.leetcode.com/users/images/72f77fbd-e160-495e-93fc-8f0d1a1d23a1_1692728697.3980412.png)\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:  \\n    long long sellingWood(int m, int n, vector<vector<int>>& p) {\\n        long long  dp[201][201];\\n        memset(dp,0,sizeof(dp));\\n        for(int i=0;i<p.size();++i)\\n        {\\n           for(int j=0;j<2;++j)\\n           {\\n               dp[p[i][0]][p[i][1]]=p[i][2];\\n           }\\n        }\\n        \\n         for(int i=1;i<=m;++i)\\n         {\\n             for(int j=1;j<=n;++j)\\n             {\\n                for(int k=0;k<=i;k++)\\n                {\\n                  dp[i][j]=max(dp[i][j],dp[k][j]+dp[i-k][j]);\\n                }\\n                for(int l=0; l<=j;++l)\\n                {\\n                     dp[i][j]=max(dp[i][j],dp[i][l]+dp[i][j-l]);\\n                     \\n                }\\n                \\n                \\n             }\\n         }\\n        \\n          \\n         return dp[m][n];\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:  \\n    long long sellingWood(int m, int n, vector<vector<int>>& p) {\\n        long long  dp[201][201];\\n        memset(dp,0,sizeof(dp));\\n        for(int i=0;i<p.size();++i)\\n        {\\n           for(int j=0;j<2;++j)\\n           {\\n               dp[p[i][0]][p[i][1]]=p[i][2];\\n           }\\n        }\\n        \\n         for(int i=1;i<=m;++i)\\n         {\\n             for(int j=1;j<=n;++j)\\n             {\\n                for(int k=0;k<=i;k++)\\n                {\\n                  dp[i][j]=max(dp[i][j],dp[k][j]+dp[i-k][j]);\\n                }\\n                for(int l=0; l<=j;++l)\\n                {\\n                     dp[i][j]=max(dp[i][j],dp[i][l]+dp[i][j-l]);\\n                     \\n                }\\n                \\n                \\n             }\\n         }\\n        \\n          \\n         return dp[m][n];\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3933299,
                "title": "dp-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long solve(int m,int n,vector<vector<int>>&p,vector<vector<long long>>&dp){\\n        if(dp[m][n]!=-1) return dp[m][n];\\n        long long price=p[m][n];\\n        for(int i=1;i<m;i++) price=max(price,solve(m-i,n,p,dp)+solve(i,n,p,dp));\\n        for(int i=1;i<n;i++) price=max(price,solve(m,n-i,p,dp)+solve(m,i,p,dp));\\n        return dp[m][n]=price;\\n    }\\n    long long sellingWood(int m, int n, vector<vector<int>>& prices) {\\n        vector<vector<int>>p(m+1,vector<int>(n+1,0));\\n        for(int i=0;i<prices.size();i++) p[prices[i][0]][prices[i][1]]=prices[i][2];\\n        vector<vector<long long>>dp(m+1,vector<long long>(n+1,-1));\\n        return solve(m,n,p,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long solve(int m,int n,vector<vector<int>>&p,vector<vector<long long>>&dp){\\n        if(dp[m][n]!=-1) return dp[m][n];\\n        long long price=p[m][n];\\n        for(int i=1;i<m;i++) price=max(price,solve(m-i,n,p,dp)+solve(i,n,p,dp));\\n        for(int i=1;i<n;i++) price=max(price,solve(m,n-i,p,dp)+solve(m,i,p,dp));\\n        return dp[m][n]=price;\\n    }\\n    long long sellingWood(int m, int n, vector<vector<int>>& prices) {\\n        vector<vector<int>>p(m+1,vector<int>(n+1,0));\\n        for(int i=0;i<prices.size();i++) p[prices[i][0]][prices[i][1]]=prices[i][2];\\n        vector<vector<long long>>dp(m+1,vector<long long>(n+1,-1));\\n        return solve(m,n,p,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3918801,
                "title": "bottom-up-dp-go",
                "content": "# Complexity\\n- Time complexity:\\nO(m\\\\*n\\\\*max(m,n))\\n\\n- Space complexity:\\nO(m\\\\*n)\\n\\n# Code\\n```\\n\\nfunc sellingWood(m int, n int, prices [][]int) int64 {\\n\\td := make([][]int64, m+1)\\n\\n\\tfor i := 0; i <= m; i++ {\\n\\t\\td[i] = make([]int64, n+1)\\n\\t}\\n\\n\\tfor _, price := range prices {\\n\\t\\ti := price[0]\\n\\t\\tj := price[1]\\n\\t\\tcost := int64(price[2])\\n\\t\\tif i <= m && j <= n {\\n\\t\\t\\td[i][j] = max(d[i][j], cost)\\n\\t\\t}\\n\\t}\\n\\n\\tfor i := 1; i <= m; i++ {\\n\\t\\tfor j := 1; j <= n; j++ {\\n\\t\\t\\tfor k := 1; k < j; k++ {\\n\\t\\t\\t\\td[i][j] = max(d[i][j], d[i][k]+d[i][j-k])\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor k := 1; k < i; k++ {\\n\\t\\t\\t\\td[i][j] = max(d[i][j], d[k][j]+d[i-k][j])\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn d[m][n]\\n}\\n\\nfunc max(a, b int64) int64 {\\n\\tif a > b {\\n\\t\\treturn a\\n\\t}\\n\\n\\treturn b\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\n\\nfunc sellingWood(m int, n int, prices [][]int) int64 {\\n\\td := make([][]int64, m+1)\\n\\n\\tfor i := 0; i <= m; i++ {\\n\\t\\td[i] = make([]int64, n+1)\\n\\t}\\n\\n\\tfor _, price := range prices {\\n\\t\\ti := price[0]\\n\\t\\tj := price[1]\\n\\t\\tcost := int64(price[2])\\n\\t\\tif i <= m && j <= n {\\n\\t\\t\\td[i][j] = max(d[i][j], cost)\\n\\t\\t}\\n\\t}\\n\\n\\tfor i := 1; i <= m; i++ {\\n\\t\\tfor j := 1; j <= n; j++ {\\n\\t\\t\\tfor k := 1; k < j; k++ {\\n\\t\\t\\t\\td[i][j] = max(d[i][j], d[i][k]+d[i][j-k])\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor k := 1; k < i; k++ {\\n\\t\\t\\t\\td[i][j] = max(d[i][j], d[k][j]+d[i-k][j])\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn d[m][n]\\n}\\n\\nfunc max(a, b int64) int64 {\\n\\tif a > b {\\n\\t\\treturn a\\n\\t}\\n\\n\\treturn b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3896537,
                "title": "simple-2d-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long sellingWood(int m, int n, vector<vector<int>>& prices) {\\n        \\n        \\n        int row = m;\\n        int col = n;\\n\\n        int price_size = prices.size();\\n\\n\\n        long long cost[row][col];\\n\\n        for(int i = 0; i < row; i++) {\\n            for(int j = 0; j < col; j++) {\\n                cost[i][j] = 0;\\n            }\\n        }\\n\\n        for(int i = 0; i < price_size; i++) {\\n            \\n            int h = prices[i][0];\\n            int w = prices[i][1];\\n            int price = prices[i][2];\\n\\n\\n            cost[h - 1][w - 1] = price;\\n        \\n        }\\n\\n        long long dp[row][col];\\n\\n        for(int i = 0; i < row; i++) {\\n            for(int j = 0; j < col; j++) {\\n                dp[i][j] = 0;\\n            }\\n        }\\n\\n\\n        for(int i = 0; i < row; i++) {\\n            for(int j = 0; j < col; j++) {\\n\\n                int left_col = 0;\\n                int right_col = j - 1;\\n\\n                while(left_col <= right_col) {\\n                    dp[i][j] = max(dp[i][j], dp[i][left_col] + dp[i][right_col]);\\n                    left_col++;\\n                    right_col--;\\n                }\\n\\n                int top_row = 0;\\n                int bottom_row = i - 1;\\n\\n\\n                while(top_row <= bottom_row) {\\n                    dp[i][j] = max(dp[i][j], dp[top_row][j] + dp[bottom_row][j]);\\n                    top_row++;\\n                    bottom_row--;\\n                }\\n\\n\\n                dp[i][j] = max(dp[i][j], cost[i][j]);\\n            }\\n        }\\n\\n\\n\\n        return dp[row - 1][col - 1];\\n\\n\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long sellingWood(int m, int n, vector<vector<int>>& prices) {\\n        \\n        \\n        int row = m;\\n        int col = n;\\n\\n        int price_size = prices.size();\\n\\n\\n        long long cost[row][col];\\n\\n        for(int i = 0; i < row; i++) {\\n            for(int j = 0; j < col; j++) {\\n                cost[i][j] = 0;\\n            }\\n        }\\n\\n        for(int i = 0; i < price_size; i++) {\\n            \\n            int h = prices[i][0];\\n            int w = prices[i][1];\\n            int price = prices[i][2];\\n\\n\\n            cost[h - 1][w - 1] = price;\\n        \\n        }\\n\\n        long long dp[row][col];\\n\\n        for(int i = 0; i < row; i++) {\\n            for(int j = 0; j < col; j++) {\\n                dp[i][j] = 0;\\n            }\\n        }\\n\\n\\n        for(int i = 0; i < row; i++) {\\n            for(int j = 0; j < col; j++) {\\n\\n                int left_col = 0;\\n                int right_col = j - 1;\\n\\n                while(left_col <= right_col) {\\n                    dp[i][j] = max(dp[i][j], dp[i][left_col] + dp[i][right_col]);\\n                    left_col++;\\n                    right_col--;\\n                }\\n\\n                int top_row = 0;\\n                int bottom_row = i - 1;\\n\\n\\n                while(top_row <= bottom_row) {\\n                    dp[i][j] = max(dp[i][j], dp[top_row][j] + dp[bottom_row][j]);\\n                    top_row++;\\n                    bottom_row--;\\n                }\\n\\n\\n                dp[i][j] = max(dp[i][j], cost[i][j]);\\n            }\\n        }\\n\\n\\n\\n        return dp[row - 1][col - 1];\\n\\n\\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3837327,
                "title": "rust-top-down-dp-binary-search",
                "content": "# Intuition\\n\\nSplit this problem into smaller sub-problems. For a piece of wood, we can\\n\\n1. Sell it as-is (if possible).\\n2. Cut it horizontally and sell two pieces separately.\\n3. Cut it vertically and sell two pieces separately.\\n\\nThe maximum money we can gain is the maximum value between the above 3.\\n\\n# Approach\\n\\nThe reality is a bit more complicated. How much should we cut? Turned out it doesn\\'t make any sense to cut out pieces that are *too small to sell*. It makes more sense to cut with width/height that fits given dimensions. If we can only sell in sizes of `[5, 5]` or `[7, 7]`, it only makes sense to cut with length `5` or `7`.\\n\\nTo check if a piece of wood can be sold as-is, we can use a hash... We can sort, and do binary search on the given array!!\\n\\n# Code\\n```\\npub struct DP {\\n    vec: Vec<([usize; 2], usize)>,\\n    m_max: usize, n_max: usize,\\n\\n    map_0: Vec<usize>,\\n    map_1: Vec<usize>,\\n\\n    memo: Vec<Vec<Option<usize>>>,\\n}\\n\\nimpl DP {\\n    pub fn new(vec: Vec<([usize; 2], usize)>, m_max: usize, n_max: usize) -> Self {\\n        let mut map_0 = vec.iter()\\n            .map(|&([v0, v1], w)| v0)\\n            .collect::<Vec<_>>();\\n        map_0.sort_unstable();\\n        map_0.dedup();\\n\\n        let mut map_1 = vec.iter()\\n            .map(|&([v0, v1], w)| v1)\\n            .collect::<Vec<_>>();\\n        map_1.sort_unstable();\\n        map_1.dedup();\\n\\n        let memo = vec![vec![None; n_max + 1]; m_max + 1];\\n\\n        Self {\\n            vec,\\n            m_max, n_max,\\n            map_0, map_1,\\n            memo\\n        }\\n    }\\n}\\n\\nimpl DP {\\n    pub fn solve(&mut self, m: usize, n: usize) -> usize {\\n        if m > self.m_max { return usize::MIN; }\\n        if n > self.n_max { return usize::MIN; }\\n\\n        if let Some(ret) = self.memo[m][n] {\\n            return ret; // cached\\n        }\\n\\n        let ret = self.solve_inner(m, n);\\n        self.memo[m][n] = Some(ret);\\n        ret\\n    }\\n\\n    fn solve_inner(&mut self, m: usize, n: usize) -> usize {\\n        if m < 1 { return usize::MIN; }\\n        if n < 1 { return usize::MIN; } // nothing to cut\\n\\n        let mut ret = usize::MIN;\\n\\n        if let Some(ptr) = self.vec.binary_search_by_key(\\n            &[m, n], |&(v, _)| v\\n        ).ok() { // sell as-is\\n            ret = ret.max(self.vec[ptr].1);\\n        }\\n\\n        let ptr_0 = self.map_0.partition_point(|&e| e < m);\\n        for ptr in (0..ptr_0).rev() {\\n            let mut _ret = usize::MIN;\\n\\n            let m_next = self.map_0[ptr];\\n            _ret += self.solve(m_next, n);\\n            _ret += self.solve(m - m_next, n);\\n\\n            ret = ret.max(_ret);\\n        } // cut height-wise\\n\\n        let ptr_1 = self.map_1.partition_point(|&e| e < n);\\n        for ptr in (0..ptr_1).rev() {\\n            let mut _ret = usize::MIN;\\n\\n            let n_next = self.map_1[ptr];\\n            _ret += self.solve(m, n_next);\\n            _ret += self.solve(m, n - n_next);\\n\\n            ret = ret.max(_ret);\\n        } // cut width-wise\\n\\n        ret\\n    }\\n}\\n\\nimpl Solution {\\n    pub fn selling_wood(m: i32, n: i32, vec: Vec<Vec<i32>>) -> i64 {\\n        let (m, n) = (m as usize, n as usize);\\n\\n        let mut vec = vec.into_iter()\\n            .map(|v| ([v[0] as usize, v[1] as usize], v[2] as usize))\\n            .collect::<Vec<_>>();\\n        vec.sort_unstable();\\n\\n        let mut dp = DP::new(vec, m, n);\\n        dp.solve(m, n) as i64\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Binary Search",
                    "Dynamic Programming"
                ],
                "code": "```\\npub struct DP {\\n    vec: Vec<([usize; 2], usize)>,\\n    m_max: usize, n_max: usize,\\n\\n    map_0: Vec<usize>,\\n    map_1: Vec<usize>,\\n\\n    memo: Vec<Vec<Option<usize>>>,\\n}\\n\\nimpl DP {\\n    pub fn new(vec: Vec<([usize; 2], usize)>, m_max: usize, n_max: usize) -> Self {\\n        let mut map_0 = vec.iter()\\n            .map(|&([v0, v1], w)| v0)\\n            .collect::<Vec<_>>();\\n        map_0.sort_unstable();\\n        map_0.dedup();\\n\\n        let mut map_1 = vec.iter()\\n            .map(|&([v0, v1], w)| v1)\\n            .collect::<Vec<_>>();\\n        map_1.sort_unstable();\\n        map_1.dedup();\\n\\n        let memo = vec![vec![None; n_max + 1]; m_max + 1];\\n\\n        Self {\\n            vec,\\n            m_max, n_max,\\n            map_0, map_1,\\n            memo\\n        }\\n    }\\n}\\n\\nimpl DP {\\n    pub fn solve(&mut self, m: usize, n: usize) -> usize {\\n        if m > self.m_max { return usize::MIN; }\\n        if n > self.n_max { return usize::MIN; }\\n\\n        if let Some(ret) = self.memo[m][n] {\\n            return ret; // cached\\n        }\\n\\n        let ret = self.solve_inner(m, n);\\n        self.memo[m][n] = Some(ret);\\n        ret\\n    }\\n\\n    fn solve_inner(&mut self, m: usize, n: usize) -> usize {\\n        if m < 1 { return usize::MIN; }\\n        if n < 1 { return usize::MIN; } // nothing to cut\\n\\n        let mut ret = usize::MIN;\\n\\n        if let Some(ptr) = self.vec.binary_search_by_key(\\n            &[m, n], |&(v, _)| v\\n        ).ok() { // sell as-is\\n            ret = ret.max(self.vec[ptr].1);\\n        }\\n\\n        let ptr_0 = self.map_0.partition_point(|&e| e < m);\\n        for ptr in (0..ptr_0).rev() {\\n            let mut _ret = usize::MIN;\\n\\n            let m_next = self.map_0[ptr];\\n            _ret += self.solve(m_next, n);\\n            _ret += self.solve(m - m_next, n);\\n\\n            ret = ret.max(_ret);\\n        } // cut height-wise\\n\\n        let ptr_1 = self.map_1.partition_point(|&e| e < n);\\n        for ptr in (0..ptr_1).rev() {\\n            let mut _ret = usize::MIN;\\n\\n            let n_next = self.map_1[ptr];\\n            _ret += self.solve(m, n_next);\\n            _ret += self.solve(m, n - n_next);\\n\\n            ret = ret.max(_ret);\\n        } // cut width-wise\\n\\n        ret\\n    }\\n}\\n\\nimpl Solution {\\n    pub fn selling_wood(m: i32, n: i32, vec: Vec<Vec<i32>>) -> i64 {\\n        let (m, n) = (m as usize, n as usize);\\n\\n        let mut vec = vec.into_iter()\\n            .map(|v| ([v[0] as usize, v[1] as usize], v[2] as usize))\\n            .collect::<Vec<_>>();\\n        vec.sort_unstable();\\n\\n        let mut dp = DP::new(vec, m, n);\\n        dp.solve(m, n) as i64\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3754490,
                "title": "c-python-dynamic-programming-solution-with-picture-explanation",
                "content": "![image](https://assets.leetcode.com/users/images/8cb3602b-7564-403e-9d3e-1f4ef5ecd743_1689158545.3771586.png)\\n\\n```dfs(r, c)``` is max profit of a wood whose size is ```(r, c)```.\\nFirst, we can use ```(m+1) * (n+1)``` matrix to store price of a wood whose size is (r, c).\\ntc of check the price of a wood is O(1). \\n\\nenumerating all the ways we can cut a wood,\\nfind the price of two small woods.\\ntc of enumerating all the ways is r + c.\\n\\nTotal tc is O(m * n (m + n)), sc is O(m* n).\\n### python\\n\\n```python\\nclass Solution:\\n    def sellingWood(self, m: int, n: int, prices: List[List[int]]) -> int:\\n\\t\\t\\n\\t\\t# price matrix\\n        pr_mat = [[0] * (m+1) for _ in range(n+1)]\\n        for r, c, p in prices:\\n            pr_mat[r][c] = p\\n        \\n        @cache\\n        def dfs(r, c):\\n\\t\\t\\n\\t\\t\\t# price of current wood\\n            sub = pr_mat[r][c] \\n            \\n\\t\\t\\t# enumerate all ways to cut horizontally\\n\\t\\t\\t# size of one of a woods > 0 (r >= 1)\\n            for i in range(1, r//2 + 1):\\n                t = dfs(i, c) + dfs(r-i, c)\\n                if t > sub: sub = t\\n\\t\\t\\t\\t\\n            # enumerate all ways to cut vertically\\n\\t\\t\\t# size of two woods > 0 (c >= 1)\\n            for j in range(1, c//2 + 1):\\n                t = dfs(r, j) + dfs(r, c-j)\\n                if t > sub: sub = t\\n            \\n            return sub\\n        \\n        return dfs(m, n)\\n```\\n### c++\\n```cpp\\nclass Solution {\\npublic:\\n    long long sellingWood(int m, int n, vector<vector<int>>& prices) {\\n        \\n        vector<vector<long long>> dp (m+1, vector<long long> (n+1, -1));\\n        vector<vector<int>> pr_mat (m+1, vector<int> (n+1, 0));\\n        \\n        for (auto& p: prices)\\n            pr_mat[p[0]][p[1]] = p[2];\\n        \\n        \\n        function<long long(int, int)> dfs = [&] (int r, int c) {\\n            if (dp[r][c] != -1) return dp[r][c];\\n            long long sub = pr_mat[r][c];\\n            for (int i = 1; i <= r / 2; i+=1)\\n                sub = max(sub, dfs(i, c) + dfs(r-i, c));\\n            \\n            for (int j = 1; j <= c / 2; j+=1)\\n                sub = max(sub, dfs(r, j) + dfs(r, c-j));\\n            \\n            dp[r][c] = sub;\\n            return sub; \\n        };\\n        \\n        return dfs(m, n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Python",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```dfs(r, c)```\n```(r, c)```\n```(m+1) * (n+1)```\n```python\\nclass Solution:\\n    def sellingWood(self, m: int, n: int, prices: List[List[int]]) -> int:\\n\\t\\t\\n\\t\\t# price matrix\\n        pr_mat = [[0] * (m+1) for _ in range(n+1)]\\n        for r, c, p in prices:\\n            pr_mat[r][c] = p\\n        \\n        @cache\\n        def dfs(r, c):\\n\\t\\t\\n\\t\\t\\t# price of current wood\\n            sub = pr_mat[r][c] \\n            \\n\\t\\t\\t# enumerate all ways to cut horizontally\\n\\t\\t\\t# size of one of a woods > 0 (r >= 1)\\n            for i in range(1, r//2 + 1):\\n                t = dfs(i, c) + dfs(r-i, c)\\n                if t > sub: sub = t\\n\\t\\t\\t\\t\\n            # enumerate all ways to cut vertically\\n\\t\\t\\t# size of two woods > 0 (c >= 1)\\n            for j in range(1, c//2 + 1):\\n                t = dfs(r, j) + dfs(r, c-j)\\n                if t > sub: sub = t\\n            \\n            return sub\\n        \\n        return dfs(m, n)\\n```\n```cpp\\nclass Solution {\\npublic:\\n    long long sellingWood(int m, int n, vector<vector<int>>& prices) {\\n        \\n        vector<vector<long long>> dp (m+1, vector<long long> (n+1, -1));\\n        vector<vector<int>> pr_mat (m+1, vector<int> (n+1, 0));\\n        \\n        for (auto& p: prices)\\n            pr_mat[p[0]][p[1]] = p[2];\\n        \\n        \\n        function<long long(int, int)> dfs = [&] (int r, int c) {\\n            if (dp[r][c] != -1) return dp[r][c];\\n            long long sub = pr_mat[r][c];\\n            for (int i = 1; i <= r / 2; i+=1)\\n                sub = max(sub, dfs(i, c) + dfs(r-i, c));\\n            \\n            for (int j = 1; j <= c / 2; j+=1)\\n                sub = max(sub, dfs(r, j) + dfs(r, c-j));\\n            \\n            dp[r][c] = sub;\\n            return sub; \\n        };\\n        \\n        return dfs(m, n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3751699,
                "title": "python-90-time-and-57-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def sellingWood(self, m: int, n: int, prices: List[List[int]]) -> int:\\n\\n\\n        P=[[0 for i in range(n+1)]for j in range(m+1)]\\n\\n        for i in prices:\\n            P[i[0]][i[1]]=i[2]\\n        dp=[[False for i in range(n+1)]for j in range(m+1)]\\n        def sol(x,y):\\n            if dp[x][y] is not False:\\n                return dp[x][y]\\n            ret=P[x][y]\\n            for k in range(x//2):\\n                a=sol(k+1,y)+sol(x-(k+1),y)\\n                ret=max(ret,a)\\n            for k in range(y//2):\\n                a=sol(x,k+1)+sol(x,y-(k+1))\\n                ret=max(ret,a)\\n            dp[x][y]=ret\\n            return ret\\n        final=sol(m,n)\\n        return final\\n\\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def sellingWood(self, m: int, n: int, prices: List[List[int]]) -> int:\\n\\n\\n        P=[[0 for i in range(n+1)]for j in range(m+1)]\\n\\n        for i in prices:\\n            P[i[0]][i[1]]=i[2]\\n        dp=[[False for i in range(n+1)]for j in range(m+1)]\\n        def sol(x,y):\\n            if dp[x][y] is not False:\\n                return dp[x][y]\\n            ret=P[x][y]\\n            for k in range(x//2):\\n                a=sol(k+1,y)+sol(x-(k+1),y)\\n                ret=max(ret,a)\\n            for k in range(y//2):\\n                a=sol(x,k+1)+sol(x,y-(k+1))\\n                ret=max(ret,a)\\n            dp[x][y]=ret\\n            return ret\\n        final=sol(m,n)\\n        return final\\n\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3690874,
                "title": "dp-split-into-horizontal-and-vertical-halves",
                "content": "```\\nclass Solution:\\n    def sellingWood(self, m: int, n: int, prices: List[List[int]]) -> int:\\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\\n        for h, w, p in prices:\\n            dp[h][w] = p\\n        for h in range(m + 1):\\n            for w in range(n + 1):\\n                for hh in range(1, h):\\n                    dp[h][w] = max(dp[h][w], dp[hh][w] + dp[h - hh][w])\\n                for ww in range(1, w):\\n                    dp[h][w] = max(dp[h][w], dp[h][ww] + dp[h][w - ww])\\n        return dp[m][n]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def sellingWood(self, m: int, n: int, prices: List[List[int]]) -> int:\\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\\n        for h, w, p in prices:\\n            dp[h][w] = p\\n        for h in range(m + 1):\\n            for w in range(n + 1):\\n                for hh in range(1, h):\\n                    dp[h][w] = max(dp[h][w], dp[hh][w] + dp[h - hh][w])\\n                for ww in range(1, w):\\n                    dp[h][w] = max(dp[h][w], dp[h][ww] + dp[h][w - ww])\\n        return dp[m][n]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3589771,
                "title": "c-dp-commented-and-easy-to-understand-solution",
                "content": "```\\nclass Solution {\\npublic:\\n#define int2 long long\\n#define pp pair<int,int>\\n    int2 solve(int m,int n ,map<pp,int>&mp,vector<vector<int2>>&dp){\\n        if(m ==1 && n == 1){\\n            return mp[{m,n}];\\n        }\\n        // first try to sell the whole block..\\n        if(dp[m][n] != -1)return dp[m][n];\\n        int2 ans = mp[{m,n}]; // you could find in 0(1)\\n        // cut it into skinny pieces vertically...\\n        for(int i = 1;i<m;i++){\\n            ans = max(ans,solve(i,n,mp,dp)+solve(m-i,n,mp,dp));\\n        }\\n        //  cut it into skinny pieces horizonally...\\n        for(int j = 1;j<n;j++){\\n            ans = max(ans,solve(m,j,mp,dp)+solve(m,n-j,mp,dp));\\n        }\\n        return dp[m][n] = ans;\\n    }\\n    long long sellingWood(int m, int n, vector<vector<int>>& prices) {\\n        map<pp,int>mp;\\n        for(auto it: prices){\\n            mp[{it[0],it[1]}] = it[2];\\n        }\\n        vector<vector<int2>>dp(m+1,vector<int2>(n+1,-1));\\n        int2 ans = solve(m,n,mp,dp);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n#define int2 long long\\n#define pp pair<int,int>\\n    int2 solve(int m,int n ,map<pp,int>&mp,vector<vector<int2>>&dp){\\n        if(m ==1 && n == 1){\\n            return mp[{m,n}];\\n        }\\n        // first try to sell the whole block..\\n        if(dp[m][n] != -1)return dp[m][n];\\n        int2 ans = mp[{m,n}]; // you could find in 0(1)\\n        // cut it into skinny pieces vertically...\\n        for(int i = 1;i<m;i++){\\n            ans = max(ans,solve(i,n,mp,dp)+solve(m-i,n,mp,dp));\\n        }\\n        //  cut it into skinny pieces horizonally...\\n        for(int j = 1;j<n;j++){\\n            ans = max(ans,solve(m,j,mp,dp)+solve(m,n-j,mp,dp));\\n        }\\n        return dp[m][n] = ans;\\n    }\\n    long long sellingWood(int m, int n, vector<vector<int>>& prices) {\\n        map<pp,int>mp;\\n        for(auto it: prices){\\n            mp[{it[0],it[1]}] = it[2];\\n        }\\n        vector<vector<int2>>dp(m+1,vector<int2>(n+1,-1));\\n        int2 ans = solve(m,n,mp,dp);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3507227,
                "title": "java-easy-to-understand",
                "content": "```\\nclass Solution {\\n    Long[][] dp;\\n    record Pair(int x, int y) { }\\n    Map<Pair, Integer> map;\\n    private long solve(int n, int m){\\n        if(n == 0 || m == 0) return 0;\\n        if(dp[n][m] != null) return dp[n][m];\\n        long res = map.getOrDefault(new Pair(n, m), 0);\\n        for(int i = 1; i < n; i++)\\n            res = Math.max(res, solve(i, m) + solve(n - i, m));\\n        for(int i = 1; i < m; i++)\\n            res = Math.max(res, solve(n, i) + solve(n, m - i));\\n        dp[n][m] = res;\\n        return res;\\n    }\\n    public long sellingWood(int m, int n, int[][] prices) {\\n        dp = new Long[m + 1][n + 1];\\n        map = new HashMap<>();\\n        for(int[] p: prices) map.put(new Pair(p[0], p[1]), p[2]);\\n        return solve(m, n);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    Long[][] dp;\\n    record Pair(int x, int y) { }\\n    Map<Pair, Integer> map;\\n    private long solve(int n, int m){\\n        if(n == 0 || m == 0) return 0;\\n        if(dp[n][m] != null) return dp[n][m];\\n        long res = map.getOrDefault(new Pair(n, m), 0);\\n        for(int i = 1; i < n; i++)\\n            res = Math.max(res, solve(i, m) + solve(n - i, m));\\n        for(int i = 1; i < m; i++)\\n            res = Math.max(res, solve(n, i) + solve(n, m - i));\\n        dp[n][m] = res;\\n        return res;\\n    }\\n    public long sellingWood(int m, int n, int[][] prices) {\\n        dp = new Long[m + 1][n + 1];\\n        map = new HashMap<>();\\n        for(int[] p: prices) map.put(new Pair(p[0], p[1]), p[2]);\\n        return solve(m, n);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3448131,
                "title": "python-short-and-clean-memo-dp",
                "content": "# Intuition\\nMain observation: we always cut <b>straight whole line</b> which splits rectangle into two. It gives fuel to DP solution over $m,n$: what is the maximal price we can get out of $$m*n$$ rectangle? We just try exact match in prices, each vertical and horizontal cut, and choose maximum option.\\nDP formula: $f(m,n)=max(f(m,x)+f(m,n-x)_{1<=x<n},f(x,n)+f(m-x,n)_{1<=x<m},price(m,n))$\\n\\n# Approach\\nImplement DP formula + use memoization via `@cache`. \\n\\n# Complexity\\n- Time complexity: `O(m*n*(m+n))`\\n- Space complexity: `O(m*n)`\\n\\n# Code\\n```\\nclass Solution:\\n    def sellingWood(self, m: int, n: int, prices: List[List[int]]) -> int:\\n        prices=defaultdict(int)|{(h,w):p for h,w,p in prices}\\n        @cache\\n        def f(m,n):            \\n            hor = max((f(x,n)+f(m-x,n) for x in range(1,1+m//2)), default=0)\\n            ver = max((f(m,x)+f(m,n-x) for x in range(1,1+n//2)), default=0)\\n            return max(hor,ver, prices[m,n])\\n        return f(m,n)\\n            \\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def sellingWood(self, m: int, n: int, prices: List[List[int]]) -> int:\\n        prices=defaultdict(int)|{(h,w):p for h,w,p in prices}\\n        @cache\\n        def f(m,n):            \\n            hor = max((f(x,n)+f(m-x,n) for x in range(1,1+m//2)), default=0)\\n            ver = max((f(m,x)+f(m,n-x) for x in range(1,1+n//2)), default=0)\\n            return max(hor,ver, prices[m,n])\\n        return f(m,n)\\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3397344,
                "title": "js-javascript-solution",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {number} m\\n * @param {number} n\\n * @param {number[][]} prices\\n * @return {number}\\n */\\nvar sellingWood = function(m, n, prices) {\\n    let prObj = {}\\n    let checked = {}\\n    \\n    for (let i = 0; i < prices.length; i++){\\n        prObj[\"\" + prices[i][0] + \"/\" + prices[i][1]] = prices[i][2]\\n    }\\n\\n    return iter(m,n)\\n\\n    function iter(row, col){\\n        if (checked[\"\" + row + \"/\" + col] !== undefined) return checked[\"\" + row + \"/\" + col]\\n        let p = 0 // max price of current piece.\\n        if (prObj[\"\" + row + \"/\" + col] !== undefined) p = prObj[\"\" + row + \"/\" + col]\\n    \\n        for (let i = 1; i <= Math.floor(row / 2); i++){\\n            p = Math.max(p, iter(i, col) + iter(row - i, col))\\n        }\\n        \\n        for (let i = 1; i <= Math.floor(col / 2); i++){\\n            p = Math.max(p, iter(row, i) + iter(row, col - i))\\n        }\\n        checked[\"\" + row + \"/\" + col] = p\\n        return p\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} m\\n * @param {number} n\\n * @param {number[][]} prices\\n * @return {number}\\n */\\nvar sellingWood = function(m, n, prices) {\\n    let prObj = {}\\n    let checked = {}\\n    \\n    for (let i = 0; i < prices.length; i++){\\n        prObj[\"\" + prices[i][0] + \"/\" + prices[i][1]] = prices[i][2]\\n    }\\n\\n    return iter(m,n)\\n\\n    function iter(row, col){\\n        if (checked[\"\" + row + \"/\" + col] !== undefined) return checked[\"\" + row + \"/\" + col]\\n        let p = 0 // max price of current piece.\\n        if (prObj[\"\" + row + \"/\" + col] !== undefined) p = prObj[\"\" + row + \"/\" + col]\\n    \\n        for (let i = 1; i <= Math.floor(row / 2); i++){\\n            p = Math.max(p, iter(i, col) + iter(row - i, col))\\n        }\\n        \\n        for (let i = 1; i <= Math.floor(col / 2); i++){\\n            p = Math.max(p, iter(row, i) + iter(row, col - i))\\n        }\\n        checked[\"\" + row + \"/\" + col] = p\\n        return p\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3266913,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn selling_wood(m: i32, n: i32, prices: Vec<Vec<i32>>) -> i64 {\\n        use std::collections::HashMap;\\n        fn dfs(high: i32, wid: i32, part_price: &HashMap<(i32, i32), i64>, f: &mut HashMap<(i32, i32), i64>) -> i64 {\\n            let mut ans: i64 = 0;\\n            if f.contains_key(&(high, wid)) {\\n                return f[&(high, wid)];\\n            }\\n            if part_price.contains_key(&(high, wid)) {\\n                ans = part_price[&(high, wid)];\\n            }\\n            let half_high = high / 2 + 1;\\n            let half_wid = wid / 2 + 1;\\n            for h in 1..half_high {\\n                let up = dfs(h, wid, part_price, f);\\n                let down = dfs(high - h, wid, part_price, f);\\n                ans = ans.max(up + down);\\n            }\\n            for w in 1..half_wid {\\n                let left = dfs(high, w, part_price, f);\\n                let right = dfs(high, wid - w, part_price, f);\\n                ans = ans.max(left + right);\\n            }\\n            f.insert((high, wid), ans);\\n            ans\\n        }\\n\\n        let part_price: HashMap<(i32, i32), i64> = prices.iter().map(|x| ((x[0], x[1]), x[2] as i64)).collect();\\n        let mut f: HashMap<(i32, i32), i64> = HashMap::new();\\n        dfs(m, n, &part_price, &mut f)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn selling_wood(m: i32, n: i32, prices: Vec<Vec<i32>>) -> i64 {\\n        use std::collections::HashMap;\\n        fn dfs(high: i32, wid: i32, part_price: &HashMap<(i32, i32), i64>, f: &mut HashMap<(i32, i32), i64>) -> i64 {\\n            let mut ans: i64 = 0;\\n            if f.contains_key(&(high, wid)) {\\n                return f[&(high, wid)];\\n            }\\n            if part_price.contains_key(&(high, wid)) {\\n                ans = part_price[&(high, wid)];\\n            }\\n            let half_high = high / 2 + 1;\\n            let half_wid = wid / 2 + 1;\\n            for h in 1..half_high {\\n                let up = dfs(h, wid, part_price, f);\\n                let down = dfs(high - h, wid, part_price, f);\\n                ans = ans.max(up + down);\\n            }\\n            for w in 1..half_wid {\\n                let left = dfs(high, w, part_price, f);\\n                let right = dfs(high, wid - w, part_price, f);\\n                ans = ans.max(left + right);\\n            }\\n            f.insert((high, wid), ans);\\n            ans\\n        }\\n\\n        let part_price: HashMap<(i32, i32), i64> = prices.iter().map(|x| ((x[0], x[1]), x[2] as i64)).collect();\\n        let mut f: HashMap<(i32, i32), i64> = HashMap::new();\\n        dfs(m, n, &part_price, &mut f)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3228648,
                "title": "python-simple-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def sellingWood(self, m, n, prices):\\n        dict1 = collections.defaultdict(int)\\n\\n        for i,j,k in prices:\\n            dict1[(i,j)] = k\\n\\n        @lru_cache(None)\\n        def dfs(h,w):\\n            if h == 0 or w == 0: return 0\\n\\n            max_val = dict1[(h,w)]\\n\\n            for i in range(1,h//2+1):\\n                max_val = max(max_val,dfs(i,w) + dfs(h-i,w))\\n\\n            for j in range(1,w//2+1):\\n                max_val = max(max_val,dfs(h,j) + dfs(h,w-j))\\n\\n            return max_val \\n\\n        return dfs(m,n)\\n\\n\\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def sellingWood(self, m, n, prices):\\n        dict1 = collections.defaultdict(int)\\n\\n        for i,j,k in prices:\\n            dict1[(i,j)] = k\\n\\n        @lru_cache(None)\\n        def dfs(h,w):\\n            if h == 0 or w == 0: return 0\\n\\n            max_val = dict1[(h,w)]\\n\\n            for i in range(1,h//2+1):\\n                max_val = max(max_val,dfs(i,w) + dfs(h-i,w))\\n\\n            for j in range(1,w//2+1):\\n                max_val = max(max_val,dfs(h,j) + dfs(h,w-j))\\n\\n            return max_val \\n\\n        return dfs(m,n)\\n\\n\\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2962438,
                "title": "c-dp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    using ll = long long;\\n    ll memo[201][201]{}, mp[201][201]{};\\n    ll sellingWood(int m, int n, vector<vector<int>>& P) {\\n        for(auto &p : P) mp[p[0]][p[1]] = p[2];\\n        return help(m, n);\\n    }\\n\\n    ll help(int m, int n) {\\n        ll res = memo[m][n];\\n        if(res) return res-1;\\n        if(mp[m][n]) res = mp[m][n];\\n        for(int i = 1; i <= m/2; i++) res = max(res, help(i, n)+help(m-i, n));\\n        for(int i = 1; i <= n/2; i++) res = max(res, help(m, i)+help(m, n-i));\\n        memo[m][n] = res+1;\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    using ll = long long;\\n    ll memo[201][201]{}, mp[201][201]{};\\n    ll sellingWood(int m, int n, vector<vector<int>>& P) {\\n        for(auto &p : P) mp[p[0]][p[1]] = p[2];\\n        return help(m, n);\\n    }\\n\\n    ll help(int m, int n) {\\n        ll res = memo[m][n];\\n        if(res) return res-1;\\n        if(mp[m][n]) res = mp[m][n];\\n        for(int i = 1; i <= m/2; i++) res = max(res, help(i, n)+help(m-i, n));\\n        for(int i = 1; i <= n/2; i++) res = max(res, help(m, i)+help(m, n-i));\\n        memo[m][n] = res+1;\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2954276,
                "title": "recursion-c",
                "content": "# Approach\\n1. We need to check for possibility so it means we can think of recursion here.\\n2. firstly I will cut the current rectangle into two rectangles\\n3. there are two ways to cut it i.e. row wise and column wise\\n4. So, firstly cut it through row state will be dp(cut, col) + dp(row - cut, col) and similarly for column\\n5. and my base case will be when I reach row length = 1 and column length also 1 then we return price[1][1].\\n6. Check the code for more clearity.\\n# Complexity\\n- Time complexity:\\nO(n * m * (n + m))\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long cache[205][205];\\n    long long price[205][205];\\n    long long dp(int rl, int cl) {\\n        if(rl == 1 && cl == 1) {\\n            return price[cl][rl];\\n        }\\n        long long& ans = cache[rl][cl];\\n        if(ans != -1) {\\n            return ans;\\n        }\\n        ans = 0;\\n        ans = max(ans, price[rl][cl]);\\n        for(int cut = 1; cut < rl; cut++) {\\n            ans = max(ans, dp(cut, cl) + dp(rl - cut, cl));\\n        }\\n        for(int cut = 1; cut < cl; cut++) {\\n            ans = max(ans, dp(rl, cut) + dp(rl, cl - cut));\\n        }\\n        return ans;\\n    }\\n    long long sellingWood(int n, int m, vector<vector<int>>& prices) {\\n        for(auto p : prices) {\\n            int i = p[0];\\n            int j = p[1];\\n            int c = p[2];\\n            price[i][j] = c;\\n        }\\n        memset(cache, -1, sizeof(cache));\\n        return dp(n, m);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long cache[205][205];\\n    long long price[205][205];\\n    long long dp(int rl, int cl) {\\n        if(rl == 1 && cl == 1) {\\n            return price[cl][rl];\\n        }\\n        long long& ans = cache[rl][cl];\\n        if(ans != -1) {\\n            return ans;\\n        }\\n        ans = 0;\\n        ans = max(ans, price[rl][cl]);\\n        for(int cut = 1; cut < rl; cut++) {\\n            ans = max(ans, dp(cut, cl) + dp(rl - cut, cl));\\n        }\\n        for(int cut = 1; cut < cl; cut++) {\\n            ans = max(ans, dp(rl, cut) + dp(rl, cl - cut));\\n        }\\n        return ans;\\n    }\\n    long long sellingWood(int n, int m, vector<vector<int>>& prices) {\\n        for(auto p : prices) {\\n            int i = p[0];\\n            int j = p[1];\\n            int c = p[2];\\n            price[i][j] = c;\\n        }\\n        memset(cache, -1, sizeof(cache));\\n        return dp(n, m);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2919010,
                "title": "python-easy-to-read-and-understand-bottom-up",
                "content": "```\\nclass Solution:\\n    def sellingWood(self, m: int, n: int, prices: List[List[int]]) -> int:\\n        t = [[0 for _ in range(n+1)] for _ in range(m+1)]\\n        \\n        for r, c, p in prices:\\n            t[r][c] = p\\n        \\n        for i in range(1, m+1):\\n            for j in range(1, n+1):\\n                for c in range(j//2 + 1):\\n                    t[i][j] = max(t[i][j], t[i][c] + t[i][j-c])\\n                for r in range(i//2 + 1):\\n                    t[i][j] = max(t[i][j], t[r][j] + t[i-r][j])\\n        \\n        return t[m][n]",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def sellingWood(self, m: int, n: int, prices: List[List[int]]) -> int:\\n        t = [[0 for _ in range(n+1)] for _ in range(m+1)]\\n        \\n        for r, c, p in prices:\\n            t[r][c] = p\\n        \\n        for i in range(1, m+1):\\n            for j in range(1, n+1):\\n                for c in range(j//2 + 1):\\n                    t[i][j] = max(t[i][j], t[i][c] + t[i][j-c])\\n                for r in range(i//2 + 1):\\n                    t[i][j] = max(t[i][j], t[r][j] + t[i-r][j])\\n        \\n        return t[m][n]",
                "codeTag": "Java"
            },
            {
                "id": 2891944,
                "title": "c-very-easy-to-understand-dp-memoization",
                "content": "SC: O(m * n)\\n```\\n#define ll long long\\nclass Solution {\\npublic:\\n    ll priceList[201][201];\\n    ll dp[201][201];\\n    ll solve(int height,int width){\\n        //base case\\n        if(height==0 || width==0)\\n            return 0;\\n        \\n        //check the cache\\n        if(dp[height][width]!=-1)\\n            return dp[height][width];\\n        \\n        ll maxProfit=0;\\n        \\n        // when sell entire plank\\n        maxProfit = priceList[height][width];\\n        \\n        //when cut height wise\\n        for(int i=1;i<height;i++){\\n            ll curr = solve(i,width) + solve(height-i,width);\\n            maxProfit=max(maxProfit,curr);\\n        }\\n        \\n        //when cut width wise\\n        for(int i=1;i<width;i++){\\n            ll curr = solve(height,i) + solve(height,width-i);\\n            maxProfit=max(maxProfit,curr);\\n        }\\n        \\n        return dp[height][width] = maxProfit;\\n    }\\n    long long sellingWood(int m, int n, vector<vector<int>>& prices) {\\n        \\n        //creating a pricelist array to access in O(1) time\\n        for(auto &it:prices){\\n            priceList[it[0]][it[1]]=it[2];\\n        }\\n        memset(dp,-1,sizeof(dp));\\n        // return max profit when having plank of size m*n\\n        return solve(m,n); \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    ll priceList[201][201];\\n    ll dp[201][201];\\n    ll solve(int height,int width){\\n        //base case\\n        if(height==0 || width==0)\\n            return 0;\\n        \\n        //check the cache\\n        if(dp[height][width]!=-1)\\n            return dp[height][width];\\n        \\n        ll maxProfit=0;\\n        \\n        // when sell entire plank\\n        maxProfit = priceList[height][width];\\n        \\n        //when cut height wise\\n        for(int i=1;i<height;i++){\\n            ll curr = solve(i,width) + solve(height-i,width);\\n            maxProfit=max(maxProfit,curr);\\n        }\\n        \\n        //when cut width wise\\n        for(int i=1;i<width;i++){\\n            ll curr = solve(height,i) + solve(height,width-i);\\n            maxProfit=max(maxProfit,curr);\\n        }\\n        \\n        return dp[height][width] = maxProfit;\\n    }\\n    long long sellingWood(int m, int n, vector<vector<int>>& prices) {\\n        \\n        //creating a pricelist array to access in O(1) time\\n        for(auto &it:prices){\\n            priceList[it[0]][it[1]]=it[2];\\n        }\\n        memset(dp,-1,sizeof(dp));\\n        // return max profit when having plank of size m*n\\n        return solve(m,n); \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2798600,
                "title": "hashmap-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    HashMap<Pair<Integer,Integer>,Long> hm;\\n    long dp[][];\\n    public long sellingWood(int m, int n, int[][] prices) {\\n        hm=new HashMap<>();\\n        dp=new long[m+1][n+1];\\n        for(int i=0;i<=m;i++){\\n            Arrays.fill(dp[i],-1);\\n        }\\n        for(int i=0;i<prices.length;i++){\\n            hm.put(new Pair(prices[i][0],prices[i][1]),new Long(prices[i][2]));\\n        }\\n        return solve(m,n,prices);\\n    }\\n    public long solve(int m,int n,int [][]prices){\\n        if(dp[m][n]!=-1){\\n            return dp[m][n];\\n        }\\n        long ans=0;\\n        long val=hm.containsKey(new Pair(m,n))?hm.get(new Pair(m,n)):0;\\n        ans=val;\\n        for(int i=1;i<=m/2;i++){\\n            ans=Math.max(ans,solve(i,n,prices)+solve(m-i,n,prices));\\n        }\\n        for(int j=1;j<=n/2;j++){\\n            ans=Math.max(ans,solve(m,j,prices)+solve(m,n-j,prices));\\n        }\\n        return dp[m][n]=ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    HashMap<Pair<Integer,Integer>,Long> hm;\\n    long dp[][];\\n    public long sellingWood(int m, int n, int[][] prices) {\\n        hm=new HashMap<>();\\n        dp=new long[m+1][n+1];\\n        for(int i=0;i<=m;i++){\\n            Arrays.fill(dp[i],-1);\\n        }\\n        for(int i=0;i<prices.length;i++){\\n            hm.put(new Pair(prices[i][0],prices[i][1]),new Long(prices[i][2]));\\n        }\\n        return solve(m,n,prices);\\n    }\\n    public long solve(int m,int n,int [][]prices){\\n        if(dp[m][n]!=-1){\\n            return dp[m][n];\\n        }\\n        long ans=0;\\n        long val=hm.containsKey(new Pair(m,n))?hm.get(new Pair(m,n)):0;\\n        ans=val;\\n        for(int i=1;i<=m/2;i++){\\n            ans=Math.max(ans,solve(i,n,prices)+solve(m-i,n,prices));\\n        }\\n        for(int j=1;j<=n/2;j++){\\n            ans=Math.max(ans,solve(m,j,prices)+solve(m,n-j,prices));\\n        }\\n        return dp[m][n]=ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2744716,
                "title": "javascript-bottom-up-dp-83-time-100-space",
                "content": "```\\n/**\\n * @param {number} m\\n * @param {number} n\\n * @param {number[][]} prices\\n * @return {number}\\n */\\nvar sellingWood = function(m, n, prices) {\\n    const dp = Array(m + 1).fill().map(() => Array(n + 1).fill(0))\\n    \\n    for (let [h, w, p] of prices) dp[h][w] = p\\n    \\n    for (let row = 1; row <= m; row++) {\\n        for (let col = 1; col <= n; col++) {\\n            for (let r = 0; r <= row; r++) {\\n                dp[row][col] = Math.max(dp[row][col], dp[r][col] + dp[row - r][col])\\n            }\\n            for (let c = 0; c <= col; c++) {\\n                dp[row][col] = Math.max(dp[row][col], dp[row][c] + dp[row][col - c])\\n            }\\n        }\\n    }\\n    \\n    return dp[m][n]\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} m\\n * @param {number} n\\n * @param {number[][]} prices\\n * @return {number}\\n */\\nvar sellingWood = function(m, n, prices) {\\n    const dp = Array(m + 1).fill().map(() => Array(n + 1).fill(0))\\n    \\n    for (let [h, w, p] of prices) dp[h][w] = p\\n    \\n    for (let row = 1; row <= m; row++) {\\n        for (let col = 1; col <= n; col++) {\\n            for (let r = 0; r <= row; r++) {\\n                dp[row][col] = Math.max(dp[row][col], dp[r][col] + dp[row - r][col])\\n            }\\n            for (let c = 0; c <= col; c++) {\\n                dp[row][col] = Math.max(dp[row][col], dp[row][c] + dp[row][col - c])\\n            }\\n        }\\n    }\\n    \\n    return dp[m][n]\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 2711310,
                "title": "python3-dp",
                "content": "class Solution:\\n\\n    def sellingWood(self, m: int, n: int, prices: List[List[int]]) -> int:\\n        M,N = m+1,n+1\\n        dp = [[0]*N for _ in range(M)]\\n        for x,y,price in prices:\\n            dp[x][y] = price\\n        \\n        for i in range(1,M):\\n            I = i//2+1\\n            for j in range(1,N):\\n                J = j//2+1\\n                #Vertical division\\n                for k in range(1,I):\\n                    dp[i][j] = max(dp[i][j],dp[i-k][j]+dp[k][j])\\n                #Horizontal division    \\n                for k in range(1,J):\\n                    dp[i][j] = max(dp[i][j],dp[i][j-k]+dp[i][k])\\n        \\n        return dp[-1][-1]",
                "solutionTags": [],
                "code": "class Solution:\\n\\n    def sellingWood(self, m: int, n: int, prices: List[List[int]]) -> int:\\n        M,N = m+1,n+1\\n        dp = [[0]*N for _ in range(M)]\\n        for x,y,price in prices:\\n            dp[x][y] = price\\n        \\n        for i in range(1,M):\\n            I = i//2+1\\n            for j in range(1,N):\\n                J = j//2+1\\n                #Vertical division\\n                for k in range(1,I):\\n                    dp[i][j] = max(dp[i][j],dp[i-k][j]+dp[k][j])\\n                #Horizontal division    \\n                for k in range(1,J):\\n                    dp[i][j] = max(dp[i][j],dp[i][j-k]+dp[i][k])\\n        \\n        return dp[-1][-1]",
                "codeTag": "Java"
            },
            {
                "id": 2698169,
                "title": "java-solution-tc-o-n-m-n-m",
                "content": "**please up-vote:)**\\n```\\nclass Solution {\\n        \\n    Long[][] memo;\\n    Integer[][] withoutCuts;\\n\\t\\n    public long sellingWood(int m, int n, int[][] prices) {\\n        memo = new Long[m+1][n+1];\\n        withoutCuts = new Integer[m+1][n+1];\\n        for(int[] price : prices)\\n            withoutCuts[price[0]][price[1]] = price[2];\\n\\t\\t\\t\\n        return cutToPieces(m, n);\\n    }\\n\\n    private long cutToPieces(int m, int n){\\n        if(memo[m][n] != null)\\n            return memo[m][n];\\n       \\n\\t    if(m == 0 || n == 0)\\n\\t\\t\\treturn memo[m][n] = 0l;\\n\\t\\t\\t\\n        long max = 0;\\n        if(withoutCuts[m][n] != null) // if the size fits one piece\\n            max = withoutCuts[m][n];\\n  \\n        for(int i = 1; i <= m/2; i++)   //horizontal cut\\n            max = Math.max(max, cutToPieces(i, n) + cutToPieces(m-i, n));\\n        \\n        for(int i = 1; i <= n/2; i++)   //vertical cut\\n            max = Math.max(max, cutToPieces(m, i) + cutToPieces(m, n-i));\\n        \\n        return memo[m][n] = max;\\n    }\\n}\\n```\\n\\n**TC** = o(n*m*(n+m))\\nbecause we fill a matrix of **n*m** cells, and for each cell we do **n+m** work.\\n\\n**SC** = o(n*m)",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n        \\n    Long[][] memo;\\n    Integer[][] withoutCuts;\\n\\t\\n    public long sellingWood(int m, int n, int[][] prices) {\\n        memo = new Long[m+1][n+1];\\n        withoutCuts = new Integer[m+1][n+1];\\n        for(int[] price : prices)\\n            withoutCuts[price[0]][price[1]] = price[2];\\n\\t\\t\\t\\n        return cutToPieces(m, n);\\n    }\\n\\n    private long cutToPieces(int m, int n){\\n        if(memo[m][n] != null)\\n            return memo[m][n];\\n       \\n\\t    if(m == 0 || n == 0)\\n\\t\\t\\treturn memo[m][n] = 0l;\\n\\t\\t\\t\\n        long max = 0;\\n        if(withoutCuts[m][n] != null) // if the size fits one piece\\n            max = withoutCuts[m][n];\\n  \\n        for(int i = 1; i <= m/2; i++)   //horizontal cut\\n            max = Math.max(max, cutToPieces(i, n) + cutToPieces(m-i, n));\\n        \\n        for(int i = 1; i <= n/2; i++)   //vertical cut\\n            max = Math.max(max, cutToPieces(m, i) + cutToPieces(m, n-i));\\n        \\n        return memo[m][n] = max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2685208,
                "title": "diagrammatically-explained-python3-top-down-and-bottom-up-dp",
                "content": "First convert the prices array into an dictionary so that we can query the price given the dimensions of the plank in O(1) time.\\n\\nNext lets write a function` f(m,n)` where` f(m,n)` is the money made using a wooden plank of dim mxn.\\n\\nIt is given that the wooden plank can be cut horizontally or vertically which will change its dimension.\\nWhen making a cut, the cut has to be made across entire wooden plank ie complete cut has to be made vertically or horizontally.\\n\\nWhen cut row wise, the plank gets broken into:` ixn` and `(m-i)xn` dimensional plank\\nwhile when cut column wise, it cut split into `mxj` and `mx(n-j)` dimensional plank as shown in the figure below.\\n\\n![image](https://assets.leetcode.com/users/images/aca7ecef-24a8-4462-87cc-74138506a3ad_1665391934.9728634.png)\\n\\nThen we find which of these cuts yields us the maximum profit by solving for these dimensions recursively\\n\\nAlso in the figure we notice that the 5th option and 4th option are same due to symmetry,.\\nHence it suffices to go till `m//2 `and `n//2` of the plank and prevent repetitive calculations.\\n\\nThe memoized code is shown below:\\n```\\nclass Solution:\\n    def sellingWood(self, m: int, n: int, prices: List[List[int]]) -> int:\\n        #dimension to price mapping\\n        price = defaultdict(int)\\n        \\n        for l,b,p in prices:\\n            price[(l,b)] = p\\n        \\n        @cache\\n        def solve(m,n):\\n            dim = (m,n)\\n            \\n            #money gained without cutting the plank\\n            money = price[dim]\\n            \\n            #money gained after cutting the plank vertically\\n            for i in range(1,(m//2)+1):\\n                money = max(\\n                    money,\\n                    solve(i,n)+solve(m-i,n)\\n                )\\n            \\n            #money gained after cutting the plank horizontally\\n            for j in range(1,(n//2)+1):\\n                money = max(\\n                    money,\\n                    solve(m,j)+solve(m,n-j)\\n                )\\n            \\n            return money\\n        \\n        return solve(m,n)\\n```\\n\\nIn bottom up, we start with the money earned by selling the smallest plank size of 0x0 and then move our way up to solve larger plank size problems using the answers saved from the smaller plank size problems.\\n\\n`dp[i][j]` will store the money earned by selling a plank of size` ixj`.\\nWe initialize it with the money earned by selling the entire plank without cutting it up.\\nThen we generate all possible plank size from 0x0 to mxn and calculate the maximum profit made.\\n\\n```\\nclass Solution:\\n    def sellingWood(self, m: int, n: int, prices: List[List[int]]) -> int:\\n        \\n        #dimension to price mapping\\n        price = {}\\n        \\n        for l,b,p in prices:\\n            price[(l,b)] = p\\n        \\n        #dp[i][j] = money earned by selling ixj dim plank\\n        dp = [[price[(i,j)] if (i,j) in price else 0 for j in range(n+1)]\\\\\\n              for i in range(m+1)] \\n       \\n        #generate empty plank to mxn plank\\n        for i in range(1,m+1):\\n            for j in range(1,n+1):\\n                                \\n                #cut it horizontally\\n                for r in range(1,(i//2)+1):\\n                    dp[i][j] = max(\\n                        dp[i][j],\\n                        dp[r][j]+dp[i-r][j]\\n                    )\\n                    \\n                #cut vertically\\n                for c in range(1,(j//2)+1):\\n                    dp[i][j] = max(\\n                        dp[i][j],\\n                        dp[i][c]+dp[i][j-c]\\n                    )\\n                \\n        return dp[m][n]\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def sellingWood(self, m: int, n: int, prices: List[List[int]]) -> int:\\n        #dimension to price mapping\\n        price = defaultdict(int)\\n        \\n        for l,b,p in prices:\\n            price[(l,b)] = p\\n        \\n        @cache\\n        def solve(m,n):\\n            dim = (m,n)\\n            \\n            #money gained without cutting the plank\\n            money = price[dim]\\n            \\n            #money gained after cutting the plank vertically\\n            for i in range(1,(m//2)+1):\\n                money = max(\\n                    money,\\n                    solve(i,n)+solve(m-i,n)\\n                )\\n            \\n            #money gained after cutting the plank horizontally\\n            for j in range(1,(n//2)+1):\\n                money = max(\\n                    money,\\n                    solve(m,j)+solve(m,n-j)\\n                )\\n            \\n            return money\\n        \\n        return solve(m,n)\\n```\n```\\nclass Solution:\\n    def sellingWood(self, m: int, n: int, prices: List[List[int]]) -> int:\\n        \\n        #dimension to price mapping\\n        price = {}\\n        \\n        for l,b,p in prices:\\n            price[(l,b)] = p\\n        \\n        #dp[i][j] = money earned by selling ixj dim plank\\n        dp = [[price[(i,j)] if (i,j) in price else 0 for j in range(n+1)]\\\\\\n              for i in range(m+1)] \\n       \\n        #generate empty plank to mxn plank\\n        for i in range(1,m+1):\\n            for j in range(1,n+1):\\n                                \\n                #cut it horizontally\\n                for r in range(1,(i//2)+1):\\n                    dp[i][j] = max(\\n                        dp[i][j],\\n                        dp[r][j]+dp[i-r][j]\\n                    )\\n                    \\n                #cut vertically\\n                for c in range(1,(j//2)+1):\\n                    dp[i][j] = max(\\n                        dp[i][j],\\n                        dp[i][c]+dp[i][j-c]\\n                    )\\n                \\n        return dp[m][n]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2669699,
                "title": "c",
                "content": "(```) class Solution {\\npublic:\\n    long long sellingWood(int m, int n, vector<vector<int>>& prices) \\n    {\\n     \\n        vector<vector<long long>> dp(m+1,vector<long long>(n+1, 0));\\n        \\n        for(auto &x: prices)\\n        {\\n            dp[x[0]][x[1]] = x[2];\\n        }\\n        \\n        for(int h=1; h<=m; h++)\\n        {\\n            for(int w=1; w<=n; w++)\\n            {\\n                for(int a=1; a<=h/2; a++)\\n                {\\n                    dp[h][w] = max(dp[h][w], dp[a][w] + dp[h-a][w]);\\n                }\\n            \\n                for(int a=1; a<=w/2; a++)\\n                {\\n                    dp[h][w] = max(dp[h][w], dp[h][a] + dp[h][w-a]);\\n                }  \\n                \\n            }\\n        }\\n        \\n        return dp[m][n];\\n            \\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    long long sellingWood(int m, int n, vector<vector<int>>& prices) \\n    {\\n     \\n        vector<vector<long long>> dp(m+1,vector<long long>(n+1, 0));\\n        \\n        for(auto &x: prices)\\n        {\\n            dp[x[0]][x[1]] = x[2];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2647191,
                "title": "python-solution",
                "content": "\\tclass Solution:\\n\\t\\tdef sellingWood(self, m: int, n: int, P: List[List[int]]) -> int:\\n\\t\\t\\tdp = [[0] * (n + 1) for _ in range(m + 1)]\\n\\t\\t\\tfor r, c, p in P:\\n\\t\\t\\t\\tdp[r][c] = p\\n\\n\\t\\t\\tfor r in range(1, m + 1):\\n\\t\\t\\t\\tfor c in range(1, n + 1):\\n\\t\\t\\t\\t\\t# Find all the possible first cut:\\n\\t\\t\\t\\t\\tfor nc in range(1, c // 2 + 1): \\n\\t\\t\\t\\t\\t\\tdp[r][c] = max(dp[r][c], dp[r][nc] + dp[r][c - nc])\\n\\t\\t\\t\\t\\tfor nr in range(1, r // 2 + 1):\\n\\t\\t\\t\\t\\t\\tdp[r][c] = max(dp[r][c], dp[nr][c] + dp[r - nr][c])\\n\\n\\t\\t\\treturn dp[m][n]",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef sellingWood(self, m: int, n: int, P: List[List[int]]) -> int:\\n\\t\\t\\tdp = [[0] * (n + 1) for _ in range(m + 1)]\\n\\t\\t\\tfor r, c, p in P:\\n\\t\\t\\t\\tdp[r][c] = p\\n\\n\\t\\t\\tfor r in range(1, m + 1):\\n\\t\\t\\t\\tfor c in range(1, n + 1):\\n\\t\\t\\t\\t\\t# Find all the possible first cut:\\n\\t\\t\\t\\t\\tfor nc in range(1, c // 2 + 1): \\n\\t\\t\\t\\t\\t\\tdp[r][c] = max(dp[r][c], dp[r][nc] + dp[r][c - nc])\\n\\t\\t\\t\\t\\tfor nr in range(1, r // 2 + 1):\\n\\t\\t\\t\\t\\t\\tdp[r][c] = max(dp[r][c], dp[nr][c] + dp[r - nr][c])\\n\\n\\t\\t\\treturn dp[m][n]",
                "codeTag": "Java"
            },
            {
                "id": 2577762,
                "title": "c-dp-solution-easy-explanation",
                "content": "\\tclass Solution {\\n\\tpublic:\\n    long long solve(int n,int m,vector<vector<long long>>& prices,vector<vector<long long>>& dp)\\n    {\\n        // cache\\n        if(dp[n][m]!=-1)\\n        {\\n            return dp[n][m];\\n        }\\n        \\n        // taking the price for current height and width\\n        long long price = prices[n][m];\\n        \\n        for(int i = 1; i < n; i++)\\n        {\\n            // dealing with two conditions, price for cut on height and then for rest\\n            price = max(price,solve(n-i,m,prices,dp) + solve(i,m,prices,dp));\\n        }\\n        for(int i = 1; i < m; i++)\\n        {\\n            // dealing with two conditions, price for cut on width and then for rest\\n            price = max(price,solve(n,m-i,prices,dp) + solve(n,i,prices,dp));\\n        }\\n        return dp[n][m] = price;\\n    }\\n    long long sellingWood(int n, int m, vector<vector<int>>& prices) {\\n        // creating 2-d price vector\\n        vector<vector<long long>> v(n+1,vector<long long>(m+1,0));\\n        for(auto &it : prices)\\n        {\\n            v[it[0]][it[1]] = it[2];\\n        }\\n        \\n        // dp initialization\\n        vector<vector<long long>> dp(n+1,vector<long long>(m+1,-1));\\n        return solve(n,m,v,dp);\\n    }\\n\\t};\\n\\t# upvote if this help u :)",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution {\\n\\tpublic:\\n    long long solve(int n,int m,vector<vector<long long>>& prices,vector<vector<long long>>& dp)\\n    {\\n        // cache\\n        if(dp[n][m]!=-1)\\n        {\\n            return dp[n][m];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2522017,
                "title": "c-easy-dfs-memo",
                "content": "```\\nclass Solution {\\npublic:\\n    map<pair<int,int>,int> prices;\\n    vector<vector<long long>> dp;\\n    long long maxPro(int l,int w){\\n        if(dp[l][w]!=-1) return dp[l][w];\\n        long long ans=0;\\n        if(prices.count({l,w})) ans=prices[{l,w}];\\n        \\n        for(int i=1;i<=l-1;i++){\\n            ans=max(ans,maxPro(i,w)+maxPro(l-i,w));\\n        }\\n        for(int i=1;i<=w-1;i++){\\n            ans=max(ans,maxPro(l,i)+maxPro(l,w-i));\\n        }\\n        \\n        return dp[l][w]= ans;\\n    }\\n    \\n    long long sellingWood(int m, int n, vector<vector<int>>& price) {\\n        dp.assign(m+1,vector<long long>(n+1,-1));\\n        for(auto &v:price){\\n            prices[{v[0],v[1]}]=v[2];\\n        }\\n        \\n        return maxPro(m,n);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    map<pair<int,int>,int> prices;\\n    vector<vector<long long>> dp;\\n    long long maxPro(int l,int w){\\n        if(dp[l][w]!=-1) return dp[l][w];\\n        long long ans=0;\\n        if(prices.count({l,w})) ans=prices[{l,w}];\\n        \\n        for(int i=1;i<=l-1;i++){\\n            ans=max(ans,maxPro(i,w)+maxPro(l-i,w));\\n        }\\n        for(int i=1;i<=w-1;i++){\\n            ans=max(ans,maxPro(l,i)+maxPro(l,w-i));\\n        }\\n        \\n        return dp[l][w]= ans;\\n    }\\n    \\n    long long sellingWood(int m, int n, vector<vector<int>>& price) {\\n        dp.assign(m+1,vector<long long>(n+1,-1));\\n        for(auto &v:price){\\n            prices[{v[0],v[1]}]=v[2];\\n        }\\n        \\n        return maxPro(m,n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2521051,
                "title": "clean-c-tabulation-dp",
                "content": "``` \\nclass Solution {\\npublic:\\n    long long sellingWood(int m, int n, vector<vector<int>>& prices) {\\n        \\n        int val[201][201];\\n        memset(val,0,sizeof val);\\n        \\n        for(auto a:prices){\\n            val[a[0]][a[1]] = a[2];\\n        }\\n        \\n        \\n        long long int dp[m+1][n+1];\\n        \\n        memset(dp,0,sizeof dp);\\n        for(int i=1;i<=m;i++){\\n            for(int j=1;j<=n;j++){\\n               \\n                dp[i][j] = val[i][j];\\n                \\n                for(int k=0;k<=i;k++){\\n                    dp[i][j] = max(dp[k][j]+dp[i-k][j],dp[i][j]);\\n                }\\n                for(int k=0;k<=j;k++){\\n                    dp[i][j] = max(dp[i][k]+dp[i][j-k],dp[i][j]);\\n                }\\n            }\\n        }\\n        \\n        return dp[m][n];\\n   \\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "``` \\nclass Solution {\\npublic:\\n    long long sellingWood(int m, int n, vector<vector<int>>& prices) {\\n        \\n        int val[201][201];\\n        memset(val,0,sizeof val);\\n        \\n        for(auto a:prices){\\n            val[a[0]][a[1]] = a[2];\\n        }\\n        \\n        \\n        long long int dp[m+1][n+1];\\n        \\n        memset(dp,0,sizeof dp);\\n        for(int i=1;i<=m;i++){\\n            for(int j=1;j<=n;j++){\\n               \\n                dp[i][j] = val[i][j];\\n                \\n                for(int k=0;k<=i;k++){\\n                    dp[i][j] = max(dp[k][j]+dp[i-k][j],dp[i][j]);\\n                }\\n                for(int k=0;k<=j;k++){\\n                    dp[i][j] = max(dp[i][k]+dp[i][j-k],dp[i][j]);\\n                }\\n            }\\n        }\\n        \\n        return dp[m][n];\\n   \\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2435937,
                "title": "c-top-down-dp-and-bottom-up-dp-with-comments-o-m-n-m-n",
                "content": "# [C++] Top-Down DP and Bottom-Up DP, O(m*n*(m+n))\\n\\n##### Top-Down DP\\n* for a board of size (m, n), we can choose the best result from 3 options:\\n\\t* the price of (m,n) if it\\'s sellable directly\\n\\t* the profit of cutting it along the rows\\n\\t* the profit of cutting it along the columns.\\n* We find the min & max heights and widths of the sellable boards, and use them to make the search space sparser.\\n\\n```\\nclass Solution {  // TopDownDP\\n    unordered_map<int, int> _priceMap;\\n    // the max height and width of wood pieces.\\n    int _maxH = 0; // cut along row, at 1 ... _maxH\\n    int _maxW = 0; // cut along col, at 1 ... _maxW\\n    int _minH = INT_MAX;\\n    int _minW = INT_MAX;\\n    // memo[H][W] = the max of:\\n    // 1) the price of wood board of size (H,W), if it\\'s sellable; otherwise 0.\\n    // 2) max(memo[c][W] + memo[H-c][W]) for c from minH to maxH and c < H, ie cut along the row\\n    // 3) max(memo[H][c] + memo[H][W-c]) for c from minW to maxW and c < W, ie cut along the row\\n    long long _memo[201][201] = {};\\n\\npublic:\\n    long long sellingWood(int m, int n, vector<vector<int>>& prices) {\\n        //\\n        processPrices(prices);\\n        // because 0 is a legitimate price, we initialize the dp memo entries to -1.\\n        memset(_memo, -1, sizeof(_memo));\\n\\n        return dfs(m, n);\\n    }\\n\\nprivate:\\n    long long dfs(int m, int n) {\\n        if (_memo[m][n] != -1) {\\n            return _memo[m][n];\\n        }\\n        // this is the baseline profit.\\n        // sometimes we can make more profit by cutting the lumber further.\\n        // therefore, even if (m,n) has a positive price, we should continue search.\\n        long long profit = getPrice(m, n);\\n        // cut along the row, at _minH ... _maxH\\n        // note that: if h >= m, we won\\'t cut it along the row again.\\n        for (int h = _minH; h <= _maxH && h < m; ++h) {\\n            profit = max(profit, dfs(h, n) + dfs(m - h, n));\\n        }\\n        // cut along the colum, at _minW ... _maxW\\n        // note that: if w >= n, we won\\'t cut it along the col again.\\n        for (int w = _minW; w <= _maxW && w < n; ++w) {\\n            profit = max(profit, dfs(m, w) + dfs(m, n - w));\\n        }\\n\\n        return _memo[m][n] = profit;\\n    }\\n\\n    void processPrices(const vector<vector<int>>& prices) {\\n        _priceMap.clear();\\n        _maxH = 0;\\n        _maxW = 0;\\n        _minH = INT_MAX;\\n        _minW = INT_MAX;\\n\\n        for (auto& p : prices) {\\n            int h = p[0], w = p[1], price = p[2];\\n            int key = (h << 16) | w;\\n            _priceMap[key] = price;\\n            _maxH = max(_maxH, h);\\n            _maxW = max(_maxW, w);\\n            _minH = min(_minH, h);\\n            _minW = min(_minW, w);\\n        }\\n    }\\n\\n    int getPrice(int h, int w) const {\\n        int key = (h << 16) | w;\\n        if (auto iter = _priceMap.find(key); iter != _priceMap.end()) {\\n            return iter->second;\\n        }\\n        return 0;\\n    }\\n};\\n```\\n\\n-------------\\n==============\\n\\n##### Bottom-Up DP\\n* We should process the entries in a dense fashion, to make sure  that `dp[m][n]` is properly filled.\\n\\n\\n```\\n// dp[H][W] = the max of:\\n// 1) the price of wood board of size (H,W), if it\\'s sellable; otherwise 0.\\n// 2) max(dp[c][W] + dp[H-c][W]) for c from minH to maxH and c < H, ie cut along the row\\n// 3) max(dp[H][c] + dp[H][W-c]) for c from minW to maxW and c < W, ie cut along the col\\nclass Solution {\\npublic:\\n    long long sellingWood(int m, int n, vector<vector<int>>& prices) {\\n        // for bottom-up dp, we may set the dp entries to 0.\\n        long long dp[201][201] = {};\\n        // process the prices\\n        for (auto& p : prices) {\\n            const int h = p[0], w = p[1], price = p[2];\\n            dp[h][w] = price;\\n        }\\n\\n        //\\n        for (int h = 1; h <= m; ++h) {\\n            for (int w = 1; w <= n; ++w) {\\n                // cut (h,w) by the rows\\n                for (int c = 1; c <= h / 2; ++c) {\\n                    // no worries: because c <= h-1, and h-c <= h-1,\\n                    // dp[c][w] and dp[h - c][w] contains good results.\\n                    dp[h][w] = max(dp[h][w], dp[c][w] + dp[h - c][w]);\\n                }\\n                // cut (h,w) by the columns\\n                for (int c = 1; c <= w / 2; ++c) {\\n                    // same reasoning:\\n                    // because c <= w-1 and w-c <= w-1,\\n                    // dp[h][c] and dp[h][w - c] contains good results.\\n                    dp[h][w] = max(dp[h][w], dp[h][c] + dp[h][w - c]);\\n                }\\n            }\\n        }\\n\\n        return dp[m][n];\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {  // TopDownDP\\n    unordered_map<int, int> _priceMap;\\n    // the max height and width of wood pieces.\\n    int _maxH = 0; // cut along row, at 1 ... _maxH\\n    int _maxW = 0; // cut along col, at 1 ... _maxW\\n    int _minH = INT_MAX;\\n    int _minW = INT_MAX;\\n    // memo[H][W] = the max of:\\n    // 1) the price of wood board of size (H,W), if it\\'s sellable; otherwise 0.\\n    // 2) max(memo[c][W] + memo[H-c][W]) for c from minH to maxH and c < H, ie cut along the row\\n    // 3) max(memo[H][c] + memo[H][W-c]) for c from minW to maxW and c < W, ie cut along the row\\n    long long _memo[201][201] = {};\\n\\npublic:\\n    long long sellingWood(int m, int n, vector<vector<int>>& prices) {\\n        //\\n        processPrices(prices);\\n        // because 0 is a legitimate price, we initialize the dp memo entries to -1.\\n        memset(_memo, -1, sizeof(_memo));\\n\\n        return dfs(m, n);\\n    }\\n\\nprivate:\\n    long long dfs(int m, int n) {\\n        if (_memo[m][n] != -1) {\\n            return _memo[m][n];\\n        }\\n        // this is the baseline profit.\\n        // sometimes we can make more profit by cutting the lumber further.\\n        // therefore, even if (m,n) has a positive price, we should continue search.\\n        long long profit = getPrice(m, n);\\n        // cut along the row, at _minH ... _maxH\\n        // note that: if h >= m, we won\\'t cut it along the row again.\\n        for (int h = _minH; h <= _maxH && h < m; ++h) {\\n            profit = max(profit, dfs(h, n) + dfs(m - h, n));\\n        }\\n        // cut along the colum, at _minW ... _maxW\\n        // note that: if w >= n, we won\\'t cut it along the col again.\\n        for (int w = _minW; w <= _maxW && w < n; ++w) {\\n            profit = max(profit, dfs(m, w) + dfs(m, n - w));\\n        }\\n\\n        return _memo[m][n] = profit;\\n    }\\n\\n    void processPrices(const vector<vector<int>>& prices) {\\n        _priceMap.clear();\\n        _maxH = 0;\\n        _maxW = 0;\\n        _minH = INT_MAX;\\n        _minW = INT_MAX;\\n\\n        for (auto& p : prices) {\\n            int h = p[0], w = p[1], price = p[2];\\n            int key = (h << 16) | w;\\n            _priceMap[key] = price;\\n            _maxH = max(_maxH, h);\\n            _maxW = max(_maxW, w);\\n            _minH = min(_minH, h);\\n            _minW = min(_minW, w);\\n        }\\n    }\\n\\n    int getPrice(int h, int w) const {\\n        int key = (h << 16) | w;\\n        if (auto iter = _priceMap.find(key); iter != _priceMap.end()) {\\n            return iter->second;\\n        }\\n        return 0;\\n    }\\n};\\n```\n```\\n// dp[H][W] = the max of:\\n// 1) the price of wood board of size (H,W), if it\\'s sellable; otherwise 0.\\n// 2) max(dp[c][W] + dp[H-c][W]) for c from minH to maxH and c < H, ie cut along the row\\n// 3) max(dp[H][c] + dp[H][W-c]) for c from minW to maxW and c < W, ie cut along the col\\nclass Solution {\\npublic:\\n    long long sellingWood(int m, int n, vector<vector<int>>& prices) {\\n        // for bottom-up dp, we may set the dp entries to 0.\\n        long long dp[201][201] = {};\\n        // process the prices\\n        for (auto& p : prices) {\\n            const int h = p[0], w = p[1], price = p[2];\\n            dp[h][w] = price;\\n        }\\n\\n        //\\n        for (int h = 1; h <= m; ++h) {\\n            for (int w = 1; w <= n; ++w) {\\n                // cut (h,w) by the rows\\n                for (int c = 1; c <= h / 2; ++c) {\\n                    // no worries: because c <= h-1, and h-c <= h-1,\\n                    // dp[c][w] and dp[h - c][w] contains good results.\\n                    dp[h][w] = max(dp[h][w], dp[c][w] + dp[h - c][w]);\\n                }\\n                // cut (h,w) by the columns\\n                for (int c = 1; c <= w / 2; ++c) {\\n                    // same reasoning:\\n                    // because c <= w-1 and w-c <= w-1,\\n                    // dp[h][c] and dp[h][w - c] contains good results.\\n                    dp[h][w] = max(dp[h][w], dp[h][c] + dp[h][w - c]);\\n                }\\n            }\\n        }\\n\\n        return dp[m][n];\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2415460,
                "title": "python-dp-recusrion-memo",
                "content": "```class Solution:\\n    def sellingWood(self, m: int, n: int, prices: List[List[int]]) -> int:\\n        \\n        # @cache\\n        def f(m,n):\\n            if dp[m][n] != -1:\\n                return dp[m][n]\\n            if not ((m,n) in h):\\n                h[(m,n)] = 0\\n            ans = h[(m,n)]\\n            for i in range(1,m//2+1):\\n                ans = max(ans,f(i,n)+f(m-i,n))\\n            for i in range(1,n//2+1):\\n                ans = max(ans,f(m,i)+f(m,n-i))\\n            dp[m][n] = ans\\n            return ans\\n            \\n        h = defaultdict(int)\\n        for i,j,k in prices:\\n            h[(i,j)] = k\\n        dp = [[-1 for _ in range(n+1)] for _ in range(m+1)]\\n        return f(m,n)\\n",
                "solutionTags": [
                    "Recursion",
                    "Memoization"
                ],
                "code": "```class Solution:\\n    def sellingWood(self, m: int, n: int, prices: List[List[int]]) -> int:\\n        \\n        # @cache\\n        def f(m,n):\\n            if dp[m][n] != -1:\\n                return dp[m][n]\\n            if not ((m,n) in h):\\n                h[(m,n)] = 0\\n            ans = h[(m,n)]\\n            for i in range(1,m//2+1):\\n                ans = max(ans,f(i,n)+f(m-i,n))\\n            for i in range(1,n//2+1):\\n                ans = max(ans,f(m,i)+f(m,n-i))\\n            dp[m][n] = ans\\n            return ans\\n            \\n        h = defaultdict(int)\\n        for i,j,k in prices:\\n            h[(i,j)] = k\\n        dp = [[-1 for _ in range(n+1)] for _ in range(m+1)]\\n        return f(m,n)\\n",
                "codeTag": "Java"
            },
            {
                "id": 2338239,
                "title": "python-3-standard-dp",
                "content": "we can make either horizontalcut or vertical cut so we look for everything and because of symmetry we just check till curr_height//2 or curr_width//2\\n\\n\\tclass Solution:\\n\\t\\t\\tdef sellingWood(self, m: int, n: int, prices: List[List[int]]) -> int:\\n\\t\\t\\t\\tdp=[[0]*(n+1) for _ in range(m+1)]\\n\\t\\t\\t\\tfor i,j,cost in prices:\\n\\t\\t\\t\\t\\tdp[i][j]=cost\\n\\t\\t\\t\\tfor i in range(1,m+1):\\n\\t\\t\\t\\t\\tfor j in range(1,n+1):\\n\\t\\t\\t\\t\\t\\tfor h in range(1,i//2+1):\\n\\t\\t\\t\\t\\t\\t\\tdp[i][j]=max(dp[i][j],dp[i-h][j]+dp[h][j])\\n\\t\\t\\t\\t\\t\\tfor w in range(1,j//2+1):\\n\\t\\t\\t\\t\\t\\t\\tdp[i][j]=max(dp[i][j],dp[i][j-w]+dp[i][w])\\n\\t\\t\\t\\treturn dp[m][n]",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "we can make either horizontalcut or vertical cut so we look for everything and because of symmetry we just check till curr_height//2 or curr_width//2\\n\\n\\tclass Solution:\\n\\t\\t\\tdef sellingWood(self, m: int, n: int, prices: List[List[int]]) -> int:\\n\\t\\t\\t\\tdp=[[0]*(n+1) for _ in range(m+1)]\\n\\t\\t\\t\\tfor i,j,cost in prices:\\n\\t\\t\\t\\t\\tdp[i][j]=cost\\n\\t\\t\\t\\tfor i in range(1,m+1):\\n\\t\\t\\t\\t\\tfor j in range(1,n+1):\\n\\t\\t\\t\\t\\t\\tfor h in range(1,i//2+1):\\n\\t\\t\\t\\t\\t\\t\\tdp[i][j]=max(dp[i][j],dp[i-h][j]+dp[h][j])\\n\\t\\t\\t\\t\\t\\tfor w in range(1,j//2+1):\\n\\t\\t\\t\\t\\t\\t\\tdp[i][j]=max(dp[i][j],dp[i][j-w]+dp[i][w])\\n\\t\\t\\t\\treturn dp[m][n]",
                "codeTag": "Java"
            },
            {
                "id": 2263530,
                "title": "java-simple-dp-soln",
                "content": "```\\nclass Solution {\\n    public long sellingWood(int m, int n, int[][] prices) {\\n        long[][] dp = new long[m+1][n+1];\\n        \\n        Map<String, Integer> cost = new HashMap<>();\\n        \\n        for (int[] price : prices) {\\n            cost.put(price[0] + \":\" + price[1], price[2]);\\n        }\\n        \\n        for (int i = 1; i <= m; i++) {\\n            for (int j = 1; j <= n; j++) {\\n                // vertical cut\\n                for (int v = 1; v <= j/2; v++) {\\n                    dp[i][j] = Math.max(dp[i][j], dp[i][v] + dp[i][j-v]);\\n                }\\n                // horizontal cut\\n                for (int h = 1; h <= i/2; h++) {\\n                    dp[i][j] = Math.max(dp[i][j], dp[h][j] + dp[i-h][j]);\\n                }\\n                // Cost already given\\n                dp[i][j] = Math.max(dp[i][j], cost.getOrDefault(i + \":\" + j, 0));\\n            }\\n        }\\n        return dp[m][n];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public long sellingWood(int m, int n, int[][] prices) {\\n        long[][] dp = new long[m+1][n+1];\\n        \\n        Map<String, Integer> cost = new HashMap<>();\\n        \\n        for (int[] price : prices) {\\n            cost.put(price[0] + \":\" + price[1], price[2]);\\n        }\\n        \\n        for (int i = 1; i <= m; i++) {\\n            for (int j = 1; j <= n; j++) {\\n                // vertical cut\\n                for (int v = 1; v <= j/2; v++) {\\n                    dp[i][j] = Math.max(dp[i][j], dp[i][v] + dp[i][j-v]);\\n                }\\n                // horizontal cut\\n                for (int h = 1; h <= i/2; h++) {\\n                    dp[i][j] = Math.max(dp[i][j], dp[h][j] + dp[i-h][j]);\\n                }\\n                // Cost already given\\n                dp[i][j] = Math.max(dp[i][j], cost.getOrDefault(i + \":\" + j, 0));\\n            }\\n        }\\n        return dp[m][n];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2210198,
                "title": "python-lru-cache-and-recursion",
                "content": "```\\nclass Solution:\\n    def sellingWood(self, m: int, n: int, prices: List[List[int]]) -> int:\\n        @lru_cache(None)\\n        def f(m,n):\\n            if m==0 or n==0:return 0\\n            ans=0\\n            if (m,n) in x:\\n                ans=x[m,n]\\n            for j in range(1,m//2+1):\\n                ans=max(ans,f(j,n)+f(m-j,n))\\n            for j in range(1,n//2+1):\\n                ans=max(ans,f(m,j)+f(m,n-j))\\n            return ans\\n        x={}\\n        for a,b,c in prices:\\n            x[a,b]=c\\n        return f(m,n)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def sellingWood(self, m: int, n: int, prices: List[List[int]]) -> int:\\n        @lru_cache(None)\\n        def f(m,n):\\n            if m==0 or n==0:return 0\\n            ans=0\\n            if (m,n) in x:\\n                ans=x[m,n]\\n            for j in range(1,m//2+1):\\n                ans=max(ans,f(j,n)+f(m-j,n))\\n            for j in range(1,n//2+1):\\n                ans=max(ans,f(m,j)+f(m,n-j))\\n            return ans\\n        x={}\\n        for a,b,c in prices:\\n            x[a,b]=c\\n        return f(m,n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2194726,
                "title": "java-simple-recursion-solution-with-memoization",
                "content": "```\\nclass Solution {\\n    Long[][] dp;\\n    Integer[][] store;\\n    int MIN = -1*((int)1e8 + 5);\\n    long helper(int w, int h, int[][] prices){\\n        if(w == 0 || h == 0) return 0;\\n        \\n        if(dp[w][h] != null) return dp[w][h];\\n        // if(store[w][h] != null) return store[w][h];\\n\\n        long max = (store[w][h] != null) ? store[w][h] : 0;\\n        // making vertical cut...\\n        for(int i = 1; i < w; i++){\\n            long a = helper(w - i, h, prices) + helper(i, h, prices);\\n            max = Math.max(max, a);\\n        }\\n        \\n        // making horizontal cut\\n        for(int i = 1; i < h; i++){\\n            long a = helper(w, h - i, prices) + helper(w, i, prices);\\n            max = Math.max(max, a);\\n        }\\n        \\n        return dp[w][h] = max;\\n        // System.out.println(\" --> \" + max);\\n        // return max;\\n    }\\n    public long sellingWood(int m, int n, int[][] prices) {\\n        \\n        dp = new Long[n+1][m+1];\\n        store = new Integer[n+1][m+1];\\n        \\n        for(int i = 0; i < prices.length; i++){\\n            int h = prices[i][0];\\n            int w = prices[i][1];\\n            int p = prices[i][2];\\n            store[w][h] = p;\\n        }\\n        \\n        // n = w , m = h\\n        long max = helper(n, m, prices);\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    Long[][] dp;\\n    Integer[][] store;\\n    int MIN = -1*((int)1e8 + 5);\\n    long helper(int w, int h, int[][] prices){\\n        if(w == 0 || h == 0) return 0;\\n        \\n        if(dp[w][h] != null) return dp[w][h];\\n        // if(store[w][h] != null) return store[w][h];\\n\\n        long max = (store[w][h] != null) ? store[w][h] : 0;\\n        // making vertical cut...\\n        for(int i = 1; i < w; i++){\\n            long a = helper(w - i, h, prices) + helper(i, h, prices);\\n            max = Math.max(max, a);\\n        }\\n        \\n        // making horizontal cut\\n        for(int i = 1; i < h; i++){\\n            long a = helper(w, h - i, prices) + helper(w, i, prices);\\n            max = Math.max(max, a);\\n        }\\n        \\n        return dp[w][h] = max;\\n        // System.out.println(\" --> \" + max);\\n        // return max;\\n    }\\n    public long sellingWood(int m, int n, int[][] prices) {\\n        \\n        dp = new Long[n+1][m+1];\\n        store = new Integer[n+1][m+1];\\n        \\n        for(int i = 0; i < prices.length; i++){\\n            int h = prices[i][0];\\n            int w = prices[i][1];\\n            int p = prices[i][2];\\n            store[w][h] = p;\\n        }\\n        \\n        // n = w , m = h\\n        long max = helper(n, m, prices);\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2192871,
                "title": "easy-dp-solution-c",
                "content": "```\\nclass Solution {\\npublic:\\n    long long dp[201][201];\\n    long long sellingWood(int m, int n, vector<vector<int>>& prices) {\\n          for(int i=0; i<prices.size(); i++) dp[prices[i][0]][prices[i][1]]=prices[i][2];\\n          for(int i=1; i<=m; i++) {\\n              for(int j=1; j<=n; j++) {\\n                   for(int area=1; area<=i/2; area++) dp[i][j]=max(dp[i][j],dp[area][j]+dp[i-area][j]);\\n                   for(int area=1; area<=j/2; area++) dp[i][j]=max(dp[i][j],dp[i][area]+dp[i][j-area]);\\n              }\\n          }\\n        return dp[m][n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long dp[201][201];\\n    long long sellingWood(int m, int n, vector<vector<int>>& prices) {\\n          for(int i=0; i<prices.size(); i++) dp[prices[i][0]][prices[i][1]]=prices[i][2];\\n          for(int i=1; i<=m; i++) {\\n              for(int j=1; j<=n; j++) {\\n                   for(int area=1; area<=i/2; area++) dp[i][j]=max(dp[i][j],dp[area][j]+dp[i-area][j]);\\n                   for(int area=1; area<=j/2; area++) dp[i][j]=max(dp[i][j],dp[i][area]+dp[i][j-area]);\\n              }\\n          }\\n        return dp[m][n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2191716,
                "title": "javascript-easy-simple-solution",
                "content": "```\\n/**\\n * @param {number} m\\n * @param {number} n\\n * @param {number[][]} prices\\n * @return {number}\\n */\\nvar sellingWood = function(m, n, prices) {\\n    let map={},cache={};\\n    for(let i=0;i<prices.length;i++){\\n        let r=prices[i][0];\\n        let c=prices[i][1];\\n        map[r+\"_\"+c]=prices[i][2];\\n    }\\n    let ans = backtrack(m,n);\\n    return ans;\\n    function backtrack(rows,cols){\\n        let key = rows+\"_\"+cols;\\n        if(cache[key]!==undefined){\\n            return cache[key];\\n        }\\n        \\n        let p0=0,p1=0,p2=0;\\n        if(map[key]!==undefined){//Check if there is a price for the entire wood board\\n            p0 = map[key];\\n        }\\n        if(rows>1){//Check by cutting rows\\n            for(let i=1;i<=Math.floor(rows/2);i++){//Note: for rows=5 we just need to check 1,4 and 2,3 only as rest of 3,2 and 4,1 will give the same results. So we are runing from i=1 till i<=Math.floor(rows/2)\\n                let r = backtrack(rows-i,cols)+backtrack(i,cols);\\n                p1 = Math.max(r,p1);\\n            }\\n        }\\n        if(cols>1){//Check by cutting cols\\n            for(let i=1;i<=Math.floor(cols/2);i++){\\n                let r = backtrack(rows,cols-i)+backtrack(rows,i);\\n                p2 = Math.max(r,p2);\\n            }\\n        }\\n        let res = Math.max(p0,p1,p2);\\n        cache[key] = res;\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} m\\n * @param {number} n\\n * @param {number[][]} prices\\n * @return {number}\\n */\\nvar sellingWood = function(m, n, prices) {\\n    let map={},cache={};\\n    for(let i=0;i<prices.length;i++){\\n        let r=prices[i][0];\\n        let c=prices[i][1];\\n        map[r+\"_\"+c]=prices[i][2];\\n    }\\n    let ans = backtrack(m,n);\\n    return ans;\\n    function backtrack(rows,cols){\\n        let key = rows+\"_\"+cols;\\n        if(cache[key]!==undefined){\\n            return cache[key];\\n        }\\n        \\n        let p0=0,p1=0,p2=0;\\n        if(map[key]!==undefined){//Check if there is a price for the entire wood board\\n            p0 = map[key];\\n        }\\n        if(rows>1){//Check by cutting rows\\n            for(let i=1;i<=Math.floor(rows/2);i++){//Note: for rows=5 we just need to check 1,4 and 2,3 only as rest of 3,2 and 4,1 will give the same results. So we are runing from i=1 till i<=Math.floor(rows/2)\\n                let r = backtrack(rows-i,cols)+backtrack(i,cols);\\n                p1 = Math.max(r,p1);\\n            }\\n        }\\n        if(cols>1){//Check by cutting cols\\n            for(let i=1;i<=Math.floor(cols/2);i++){\\n                let r = backtrack(rows,cols-i)+backtrack(rows,i);\\n                p2 = Math.max(r,p2);\\n            }\\n        }\\n        let res = Math.max(p0,p1,p2);\\n        cache[key] = res;\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2186853,
                "title": "go-search-with-memoization",
                "content": "```\\nfunc sellingWood(m int, n int, prices [][]int) int64 {\\n    maxp, memo, dictp := make([][]int, m + 1), make([][]int, m + 1), make([][]int, m + 1)\\n    for i := 0; i < m + 1; i++ {\\n        maxp[i] = make([]int, n + 1)\\n        memo[i] = make([]int, n + 1)\\n        dictp[i] = make([]int, n + 1)\\n        for j := 0; j < n + 1; j++ {\\n            memo[i][j] = -1\\n        }\\n    }\\n    \\n    for _, p := range prices {\\n        dictp[p[0]][p[1]] = max(dictp[p[0]][p[1]], p[2])\\n    }\\n    \\n    get_maxp(m, n, maxp, dictp)\\n    \\n    return int64(dfs(m, n, maxp, memo))\\n}\\n\\nfunc get_maxp(m int, n int, maxp [][]int, dictp [][]int) {\\n    for i := 1; i <= m; i++ {\\n        for j := 1; j <= n; j++ {\\n            maxp[i][j] = max(maxp[i - 1][j], maxp[i][j - 1])\\n            maxp[i][j] = max(maxp[i][j], dictp[i][j])\\n        }\\n    }\\n}\\n\\nfunc dfs(m int, n int, maxp [][]int, memo [][]int) int {    \\n    if memo[m][n] != -1 {\\n        return memo[m][n]\\n    }\\n    \\n    res := maxp[m][n]\\n    \\n    for i := 1; i <= m / 2; i++ {\\n        res = max(res, dfs(i, n, maxp, memo) + dfs(m - i, n, maxp, memo))\\n    }\\n    \\n    for i := 1; i <= n / 2; i++ {\\n        res = max(res, dfs(m, i, maxp, memo) + dfs(m, n - i, maxp, memo))\\n    }\\n\\n    memo[m][n] = res\\n    return res\\n}\\n\\nfunc max(a int, b int) int {\\n    if a > b {\\n        return a\\n    }\\n    return b\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc sellingWood(m int, n int, prices [][]int) int64 {\\n    maxp, memo, dictp := make([][]int, m + 1), make([][]int, m + 1), make([][]int, m + 1)\\n    for i := 0; i < m + 1; i++ {\\n        maxp[i] = make([]int, n + 1)\\n        memo[i] = make([]int, n + 1)\\n        dictp[i] = make([]int, n + 1)\\n        for j := 0; j < n + 1; j++ {\\n            memo[i][j] = -1\\n        }\\n    }\\n    \\n    for _, p := range prices {\\n        dictp[p[0]][p[1]] = max(dictp[p[0]][p[1]], p[2])\\n    }\\n    \\n    get_maxp(m, n, maxp, dictp)\\n    \\n    return int64(dfs(m, n, maxp, memo))\\n}\\n\\nfunc get_maxp(m int, n int, maxp [][]int, dictp [][]int) {\\n    for i := 1; i <= m; i++ {\\n        for j := 1; j <= n; j++ {\\n            maxp[i][j] = max(maxp[i - 1][j], maxp[i][j - 1])\\n            maxp[i][j] = max(maxp[i][j], dictp[i][j])\\n        }\\n    }\\n}\\n\\nfunc dfs(m int, n int, maxp [][]int, memo [][]int) int {    \\n    if memo[m][n] != -1 {\\n        return memo[m][n]\\n    }\\n    \\n    res := maxp[m][n]\\n    \\n    for i := 1; i <= m / 2; i++ {\\n        res = max(res, dfs(i, n, maxp, memo) + dfs(m - i, n, maxp, memo))\\n    }\\n    \\n    for i := 1; i <= n / 2; i++ {\\n        res = max(res, dfs(m, i, maxp, memo) + dfs(m, n - i, maxp, memo))\\n    }\\n\\n    memo[m][n] = res\\n    return res\\n}\\n\\nfunc max(a int, b int) int {\\n    if a > b {\\n        return a\\n    }\\n    return b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2186309,
                "title": "matrix-chain-multiplication",
                "content": "```\\nlong long sellingWood(int m, int n, vector<vector<int>>& prices) {\\n\\n\\tunordered_map<int, unordered_map<int,ll>> mp;\\n\\tfor(auto& p : prices) mp[p[0]][p[1]] = p[2];\\n\\n\\tvector<vector<ll>> dp(m+1, vector<ll>(n+1));\\n\\n\\tfor(int h=1;h <= m; h++){\\n\\t\\tfor(int w = 1; w <= n; w++){\\n\\n\\t\\t\\tll maxProfit = (mp[h].count(w) ? mp[h][w] : 0);\\n\\n\\t\\t\\t// Horizontal Cuts\\n\\t\\t\\tfor(int i=1;i<h;i++){\\n\\n\\t\\t\\t\\tll maxProfitUp = dp[i][w];\\n\\t\\t\\t\\tll maxProfitDown = dp[h-i][w];\\n\\n\\t\\t\\t\\tll totProfit = maxProfitUp + maxProfitDown;\\n\\n\\t\\t\\t\\tmaxProfit = max(maxProfit, totProfit);\\n\\t\\t\\t}\\n\\n\\n\\t\\t\\t//Vertical Cuts\\n\\t\\t\\tfor(int j=1;j<w;j++){\\n\\n\\t\\t\\t\\tll maxProfitLeft = dp[h][j];\\n\\t\\t\\t\\tll maxProfitRight = dp[h][w-j];\\n\\n\\t\\t\\t\\tll totProfit = maxProfitLeft + maxProfitRight;\\n\\n\\t\\t\\t\\tmaxProfit = max(maxProfit, totProfit);\\n\\t\\t\\t}\\n\\n\\t\\t\\tdp[h][w] = maxProfit;\\n\\t\\t}\\n\\t}\\n\\n\\n\\treturn dp[m][n];\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nlong long sellingWood(int m, int n, vector<vector<int>>& prices) {\\n\\n\\tunordered_map<int, unordered_map<int,ll>> mp;\\n\\tfor(auto& p : prices) mp[p[0]][p[1]] = p[2];\\n\\n\\tvector<vector<ll>> dp(m+1, vector<ll>(n+1));\\n\\n\\tfor(int h=1;h <= m; h++){\\n\\t\\tfor(int w = 1; w <= n; w++){\\n\\n\\t\\t\\tll maxProfit = (mp[h].count(w) ? mp[h][w] : 0);\\n\\n\\t\\t\\t// Horizontal Cuts\\n\\t\\t\\tfor(int i=1;i<h;i++){\\n\\n\\t\\t\\t\\tll maxProfitUp = dp[i][w];\\n\\t\\t\\t\\tll maxProfitDown = dp[h-i][w];\\n\\n\\t\\t\\t\\tll totProfit = maxProfitUp + maxProfitDown;\\n\\n\\t\\t\\t\\tmaxProfit = max(maxProfit, totProfit);\\n\\t\\t\\t}\\n\\n\\n\\t\\t\\t//Vertical Cuts\\n\\t\\t\\tfor(int j=1;j<w;j++){\\n\\n\\t\\t\\t\\tll maxProfitLeft = dp[h][j];\\n\\t\\t\\t\\tll maxProfitRight = dp[h][w-j];\\n\\n\\t\\t\\t\\tll totProfit = maxProfitLeft + maxProfitRight;\\n\\n\\t\\t\\t\\tmaxProfit = max(maxProfit, totProfit);\\n\\t\\t\\t}\\n\\n\\t\\t\\tdp[h][w] = maxProfit;\\n\\t\\t}\\n\\t}\\n\\n\\n\\treturn dp[m][n];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2182791,
                "title": "scala-functional-top-down-dp",
                "content": "```\\n  def sellingWood(height: Int, width: Int, prices: Array[Array[Int]]): Long = {\\n    val priceMap = prices.map { case Array(h, w, p) => (h, w) -> p.toLong }.toMap\\n    val mem      = scala.collection.mutable.Map.empty[(Int, Int), Long]\\n\\n    def dfs(height: Int, width: Int): Long = mem.getOrElseUpdate((height, width), {\\n      val verticalCuts   = (1 to width / 2).map(col => dfs(height, col) + dfs(height, width - col))\\n      val horizontalCuts = (1 to height / 2).map(row => dfs(row, width) + dfs(height - row, width))\\n      (horizontalCuts ++ verticalCuts ++ priceMap.get((height, width))).maxOption.getOrElse(0L)\\n    })\\n\\n    dfs(height, width)\\n  }\\n```",
                "solutionTags": [],
                "code": "```\\n  def sellingWood(height: Int, width: Int, prices: Array[Array[Int]]): Long = {\\n    val priceMap = prices.map { case Array(h, w, p) => (h, w) -> p.toLong }.toMap\\n    val mem      = scala.collection.mutable.Map.empty[(Int, Int), Long]\\n\\n    def dfs(height: Int, width: Int): Long = mem.getOrElseUpdate((height, width), {\\n      val verticalCuts   = (1 to width / 2).map(col => dfs(height, col) + dfs(height, width - col))\\n      val horizontalCuts = (1 to height / 2).map(row => dfs(row, width) + dfs(height - row, width))\\n      (horizontalCuts ++ verticalCuts ++ priceMap.get((height, width))).maxOption.getOrElse(0L)\\n    })\\n\\n    dfs(height, width)\\n  }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2180808,
                "title": "c-dp-solution-beat-77-54",
                "content": "```\\nclass Solution {\\nprivate:\\n    vector<vector<long long>> dp;\\n    unordered_map<int, int> mp;\\n    \\n    void findMax(vector<vector<int>>& prices, int i, int j){\\n        long long money = mp.count(i * 1000 + j) ? mp[i * 1000 + j] : 0;\\n        if(i >= 2) for(int cut = 1; cut <= i / 2; cut++)\\n            money = max(money, dp[cut][j] + dp[i - cut][j]);\\n        if(j >= 2) for(int cut = 1; cut <= j / 2; cut++)\\n            money = max(money, dp[i][cut] + dp[i][j - cut]);\\n        dp[i][j] = money;\\n    }\\n    \\npublic:\\n    long long sellingWood(int m, int n, vector<vector<int>>& prices) {\\n        dp.resize(m + 1, vector<long long>(n + 1, 0));\\n        for(auto price : prices) mp[price[0] * 1000 + price[1]] = price[2];\\n        for(int i = 1; i <= m; i++) \\n            for(int j = 1; j <= n; j++)\\n                findMax(prices, i, j);\\n        return dp[m][n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    vector<vector<long long>> dp;\\n    unordered_map<int, int> mp;\\n    \\n    void findMax(vector<vector<int>>& prices, int i, int j){\\n        long long money = mp.count(i * 1000 + j) ? mp[i * 1000 + j] : 0;\\n        if(i >= 2) for(int cut = 1; cut <= i / 2; cut++)\\n            money = max(money, dp[cut][j] + dp[i - cut][j]);\\n        if(j >= 2) for(int cut = 1; cut <= j / 2; cut++)\\n            money = max(money, dp[i][cut] + dp[i][j - cut]);\\n        dp[i][j] = money;\\n    }\\n    \\npublic:\\n    long long sellingWood(int m, int n, vector<vector<int>>& prices) {\\n        dp.resize(m + 1, vector<long long>(n + 1, 0));\\n        for(auto price : prices) mp[price[0] * 1000 + price[1]] = price[2];\\n        for(int i = 1; i <= m; i++) \\n            for(int j = 1; j <= n; j++)\\n                findMax(prices, i, j);\\n        return dp[m][n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2178781,
                "title": "c-bottom-up-dp-easy-solution",
                "content": "```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    long long sellingWood(int m, int n, vector<vector<int>>& prices) \\n    {\\n        vector<vector<ll>>f(m+1,vector<ll>(n+1,0));\\n        vector<vector<ll>>record(m+1,vector<ll>(n+1,0));\\n        for(auto &x:prices)record[x[0]][x[1]]=x[2];\\n        for(int i=1;i<=m;i++)\\n            for(int j=1;j<=n;j++)\\n            {\\n                f[i][j]=max(f[i][j],record[i][j]);\\n                for(int k=1;k<i;k++)\\n                    f[i][j]=max(f[i][j],f[k][j]+f[i-k][j]);\\n                for(int k=1;k<j;k++)\\n                    f[i][j]=max(f[i][j],f[i][k]+f[i][j-k]);\\n            }\\n        return f[m][n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    long long sellingWood(int m, int n, vector<vector<int>>& prices) \\n    {\\n        vector<vector<ll>>f(m+1,vector<ll>(n+1,0));\\n        vector<vector<ll>>record(m+1,vector<ll>(n+1,0));\\n        for(auto &x:prices)record[x[0]][x[1]]=x[2];\\n        for(int i=1;i<=m;i++)\\n            for(int j=1;j<=n;j++)\\n            {\\n                f[i][j]=max(f[i][j],record[i][j]);\\n                for(int k=1;k<i;k++)\\n                    f[i][j]=max(f[i][j],f[k][j]+f[i-k][j]);\\n                for(int k=1;k<j;k++)\\n                    f[i][j]=max(f[i][j],f[i][k]+f[i][j-k]);\\n            }\\n        return f[m][n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2177426,
                "title": "java-dp-recursion-memo",
                "content": "```\\n        //TC = O(mn), SC = O(mn)\\n       /*\\n        The idea is to make horizontal cuts ie, if i make a cut of {i,j} I can further convert it into pieces of (ii, j) and (i-ii, j) and get the max ans\\n        Repeat above steps for vertical cut\\n        return max result.\\n        */\\n    public long sellingWood(int m, int n, int[][] prices) {\\n        long[][] memo = new long[m + 1][n + 1];\\n        for (int i = 0; i <= m; i++) Arrays.fill(memo[i], -1);\\n        long[][] p = new long[m + 1][n + 1]; // prices of cut of dimention {i*j}\\n\\n        for (int[] pri : prices) p[pri[0]][pri[1]] = pri[2];\\n        return dp(m, n, p, memo);\\n    }\\n\\n    private long dp(int i, int j, long[][] p, long[][] memo) {\\n        // base case\\n        if (i == 0 || j == 0) return 0;\\n\\n        if (memo[i][j] != -1) return memo[i][j];\\n        long ans = p[i][j];\\n\\n        for (int ii = 1; ii <= i / 2; ii++) {\\n            ans = Math.max(ans, dp(ii, j, p, memo) + dp(i - ii, j, p, memo));\\n        }\\n\\n        for (int jj = 1; jj <= j / 2; jj++) {\\n            ans = Math.max(ans, dp(i, jj, p, memo) + dp(i, j - jj, p, memo));\\n        }\\n        return memo[i][j] = ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n        //TC = O(mn), SC = O(mn)\\n       /*\\n        The idea is to make horizontal cuts ie, if i make a cut of {i,j} I can further convert it into pieces of (ii, j) and (i-ii, j) and get the max ans\\n        Repeat above steps for vertical cut\\n        return max result.\\n        */\\n    public long sellingWood(int m, int n, int[][] prices) {\\n        long[][] memo = new long[m + 1][n + 1];\\n        for (int i = 0; i <= m; i++) Arrays.fill(memo[i], -1);\\n        long[][] p = new long[m + 1][n + 1]; // prices of cut of dimention {i*j}\\n\\n        for (int[] pri : prices) p[pri[0]][pri[1]] = pri[2];\\n        return dp(m, n, p, memo);\\n    }\\n\\n    private long dp(int i, int j, long[][] p, long[][] memo) {\\n        // base case\\n        if (i == 0 || j == 0) return 0;\\n\\n        if (memo[i][j] != -1) return memo[i][j];\\n        long ans = p[i][j];\\n\\n        for (int ii = 1; ii <= i / 2; ii++) {\\n            ans = Math.max(ans, dp(ii, j, p, memo) + dp(i - ii, j, p, memo));\\n        }\\n\\n        for (int jj = 1; jj <= j / 2; jj++) {\\n            ans = Math.max(ans, dp(i, jj, p, memo) + dp(i, j - jj, p, memo));\\n        }\\n        return memo[i][j] = ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2176995,
                "title": "rust-divide-and-merge-dfs-memo-o-m-n-m-n",
                "content": "```\\nuse std::cmp::max;\\nuse std::collections::HashMap;\\nimpl Solution {\\n    pub fn selling_wood(m: i32, n: i32, prices: Vec<Vec<i32>>) -> i64 {\\n        let mut part_price: HashMap<(i32, i32), i64> = prices.iter()\\n            .map(|x|((x[0], x[1]), x[2] as i64))\\n            .collect();\\n\\n        // let mut part_price: HashMap<(i32, i32), i64> = HashMap::new();\\n        // for p in prices {\\n        //     part_price.insert((p[0], p[1]), p[2] as i64);\\n        // }\\n        let mut f: HashMap<(i32, i32), i64> = HashMap::new();\\n        let ans = dfs(m, n, &part_price, &mut f);\\n        ans\\n    }\\n}\\n\\nfn dfs(high: i32, wid: i32, part_price: &HashMap<(i32, i32), i64>, f: &mut HashMap<(i32, i32), i64>) -> i64 {\\n    let mut ans: i64 = 0;\\n    if f.contains_key(&(high, wid)) {\\n        return f[&(high, wid)];\\n    }\\n    if part_price.contains_key(&(high, wid)) {\\n        ans = part_price[&(high, wid)];\\n    }\\n    let half_high = high/2 + 1;\\n    let half_wid = wid/2 + 1;\\n    for h in 1..half_high {\\n        let up = dfs(h, wid, part_price, f);\\n        let down = dfs(high - h, wid, part_price, f);\\n        ans = max(ans, up + down);\\n    }\\n    for w in 1..half_wid {\\n        let left = dfs(high, w, part_price, f);\\n        let right = dfs(high, wid - w, part_price, f);\\n        ans = max(ans, left + right);\\n    }\\n    f.insert((high, wid), ans);\\n    ans\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::cmp::max;\\nuse std::collections::HashMap;\\nimpl Solution {\\n    pub fn selling_wood(m: i32, n: i32, prices: Vec<Vec<i32>>) -> i64 {\\n        let mut part_price: HashMap<(i32, i32), i64> = prices.iter()\\n            .map(|x|((x[0], x[1]), x[2] as i64))\\n            .collect();\\n\\n        // let mut part_price: HashMap<(i32, i32), i64> = HashMap::new();\\n        // for p in prices {\\n        //     part_price.insert((p[0], p[1]), p[2] as i64);\\n        // }\\n        let mut f: HashMap<(i32, i32), i64> = HashMap::new();\\n        let ans = dfs(m, n, &part_price, &mut f);\\n        ans\\n    }\\n}\\n\\nfn dfs(high: i32, wid: i32, part_price: &HashMap<(i32, i32), i64>, f: &mut HashMap<(i32, i32), i64>) -> i64 {\\n    let mut ans: i64 = 0;\\n    if f.contains_key(&(high, wid)) {\\n        return f[&(high, wid)];\\n    }\\n    if part_price.contains_key(&(high, wid)) {\\n        ans = part_price[&(high, wid)];\\n    }\\n    let half_high = high/2 + 1;\\n    let half_wid = wid/2 + 1;\\n    for h in 1..half_high {\\n        let up = dfs(h, wid, part_price, f);\\n        let down = dfs(high - h, wid, part_price, f);\\n        ans = max(ans, up + down);\\n    }\\n    for w in 1..half_wid {\\n        let left = dfs(high, w, part_price, f);\\n        let right = dfs(high, wid - w, part_price, f);\\n        ans = max(ans, left + right);\\n    }\\n    f.insert((high, wid), ans);\\n    ans\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2176729,
                "title": "python3-dp-with-explanation",
                "content": "```\\ndef sellingWood(self, m: int, n: int, prices: List[List[int]]) -> int:\\n        # use a dictionary to save size and prices\\n        price_dict = {}\\n        for pi, pj, price in prices:\\n            price_dict[(pi, pj)] = price\\n        \\n        # use dp to calculate the max sale price\\n\\t\\t# dp[1][1] represents [1,1,price] in prices\\n\\t\\t# therefore, we need (m+1)*(n+1) to represent the shapes since dp[i][0] and dp[0][j] are not valid shapes\\n        dp = [[0]*(n+1) for i in range(m+1)]\\n        for i in range(1,m+1):\\n            for j in range(1,n+1):\\n                if (i,j) in price_dict:\\n                    dp[i][j] = price_dict[(i, j)]\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t# dp[i][j] is the max of all sub shapes\\n                for ii in range(1,i//2+1):\\n                    x = dp[ii][j]+dp[i-ii][j]\\n                    if x>dp[i][j]:\\n                        dp[i][j] = x \\n                for jj in range(1,j//2+1):\\n                    x = dp[i][jj]+dp[i][j-jj]\\n                    if x>dp[i][j]:\\n                        dp[i][j] = x\\n        \\n        \\n        return dp[m][n]\\n",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\ndef sellingWood(self, m: int, n: int, prices: List[List[int]]) -> int:\\n        # use a dictionary to save size and prices\\n        price_dict = {}\\n        for pi, pj, price in prices:\\n            price_dict[(pi, pj)] = price\\n        \\n        # use dp to calculate the max sale price\\n\\t\\t# dp[1][1] represents [1,1,price] in prices\\n\\t\\t# therefore, we need (m+1)*(n+1) to represent the shapes since dp[i][0] and dp[0][j] are not valid shapes\\n        dp = [[0]*(n+1) for i in range(m+1)]\\n        for i in range(1,m+1):\\n            for j in range(1,n+1):\\n                if (i,j) in price_dict:\\n                    dp[i][j] = price_dict[(i, j)]\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t# dp[i][j] is the max of all sub shapes\\n                for ii in range(1,i//2+1):\\n                    x = dp[ii][j]+dp[i-ii][j]\\n                    if x>dp[i][j]:\\n                        dp[i][j] = x \\n                for jj in range(1,j//2+1):\\n                    x = dp[i][jj]+dp[i][j-jj]\\n                    if x>dp[i][j]:\\n                        dp[i][j] = x\\n        \\n        \\n        return dp[m][n]\\n",
                "codeTag": "Python3"
            },
            {
                "id": 2176350,
                "title": "python3-dp",
                "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/3f890a1a0d9001fdd4440b921ddce7ba11a42ef3) for solutions of weekly 298. \\n\\n```\\nclass Solution:\\n    def sellingWood(self, m: int, n: int, prices: List[List[int]]) -> int:\\n        mp = {(h, w) : p for h, w, p in prices}\\n        \\n        @cache\\n        def fn(m, n): \\n            \"\"\"Return max money of a mxn piece of wood.\"\"\"\\n            if m == 0 or n == 0: return 0\\n            ans = 0 \\n            if (m, n) in mp: ans = mp[m, n]\\n            if m > 1: ans = max(ans, max(fn(i, n) + fn(m-i, n) for i in range(1, m//2+1)))\\n            if n > 1: ans = max(ans, max(fn(m, j) + fn(m, n-j) for j in range(1, n//2+1)))\\n            return ans \\n        \\n        return fn(m, n)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def sellingWood(self, m: int, n: int, prices: List[List[int]]) -> int:\\n        mp = {(h, w) : p for h, w, p in prices}\\n        \\n        @cache\\n        def fn(m, n): \\n            \"\"\"Return max money of a mxn piece of wood.\"\"\"\\n            if m == 0 or n == 0: return 0\\n            ans = 0 \\n            if (m, n) in mp: ans = mp[m, n]\\n            if m > 1: ans = max(ans, max(fn(i, n) + fn(m-i, n) for i in range(1, m//2+1)))\\n            if n > 1: ans = max(ans, max(fn(m, j) + fn(m, n-j) for j in range(1, n//2+1)))\\n            return ans \\n        \\n        return fn(m, n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2176294,
                "title": "scala",
                "content": "```\\nobject Solution {\\n  def sellingWood(m: Int, n: Int, prices: Array[Array[Int]]): Long = {\\n    val dp = Array.fill(m + 1, n + 1)(0L)\\n    for (Array(height, width, price) <- prices) {\\n      dp(height)(width) = price\\n    }\\n    \\n    for {\\n      height <- 1 to m\\n      width <- 1 to n\\n    } {\\n      dp(height)(width) = Iterator(dp(height)(width))\\n        .concat((1 to height / 2).iterator.map(h => dp(h)(width) + dp(height - h)(width)))\\n        .concat((1 to width / 2).iterator.map(w => dp(height)(w) + dp(height)(width - w)))\\n        .max\\n    }\\n    \\n    dp(m)(n)\\n  }\\n}\\n```",
                "solutionTags": [
                    "Scala",
                    "Dynamic Programming"
                ],
                "code": "```\\nobject Solution {\\n  def sellingWood(m: Int, n: Int, prices: Array[Array[Int]]): Long = {\\n    val dp = Array.fill(m + 1, n + 1)(0L)\\n    for (Array(height, width, price) <- prices) {\\n      dp(height)(width) = price\\n    }\\n    \\n    for {\\n      height <- 1 to m\\n      width <- 1 to n\\n    } {\\n      dp(height)(width) = Iterator(dp(height)(width))\\n        .concat((1 to height / 2).iterator.map(h => dp(h)(width) + dp(height - h)(width)))\\n        .concat((1 to width / 2).iterator.map(w => dp(height)(w) + dp(height)(width - w)))\\n        .max\\n    }\\n    \\n    dp(m)(n)\\n  }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2176064,
                "title": "c-15-lines-top-down-dp-o-m-n-m-n-time-o-m-n-space",
                "content": "```\\npublic class Solution \\n{\\n    public long SellingWood(int m, int n, int[][] prices) \\n    {\\n        var pricesDict = prices.ToDictionary(price => (price[0], price[1]), price => price[2]);\\n        Dictionary<(int, int), long> dp = new();\\n        \\n        return Work(m, n);\\n        \\n        long Work(int x, int y) \\n        {\\n            if (x == 0 || y == 0) return 0;\\n            \\n            if (!dp.ContainsKey((x, y))) \\n            {\\n                long ans = pricesDict.ContainsKey((x, y)) ? pricesDict[(x, y)] : 0;\\n                \\n                for (int i = 1; i <= x / 2; ++i) ans = Math.Max(ans, Work(i, y) + Work(x - i, y));\\n                for (int i = 1; i <= y / 2; ++i) ans = Math.Max(ans, Work(x, i) + Work(x, y - i));\\n                \\n                dp[(x, y)] = ans;\\n            }  \\n                \\n            return dp[(x, y)];\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\npublic class Solution \\n{\\n    public long SellingWood(int m, int n, int[][] prices) \\n    {\\n        var pricesDict = prices.ToDictionary(price => (price[0], price[1]), price => price[2]);\\n        Dictionary<(int, int), long> dp = new();\\n        \\n        return Work(m, n);\\n        \\n        long Work(int x, int y) \\n        {\\n            if (x == 0 || y == 0) return 0;\\n            \\n            if (!dp.ContainsKey((x, y))) \\n            {\\n                long ans = pricesDict.ContainsKey((x, y)) ? pricesDict[(x, y)] : 0;\\n                \\n                for (int i = 1; i <= x / 2; ++i) ans = Math.Max(ans, Work(i, y) + Work(x - i, y));\\n                for (int i = 1; i <= y / 2; ++i) ans = Math.Max(ans, Work(x, i) + Work(x, y - i));\\n                \\n                dp[(x, y)] = ans;\\n            }  \\n                \\n            return dp[(x, y)];\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2175888,
                "title": "c-fastest-100-and-100",
                "content": "```\\nclass Solution {\\npublic:\\n    static bool comp(vector<int> a, vector<int> b)\\n    {\\n        return a[2]>b[2];\\n    }\\n\\t\\n    vector<vector<int>> mem;\\n    vector<vector<int>> vis;\\n\\t\\n    long long rec(int m, int n)\\n    {\\n        if(m==0 || n==0 || mem[m][n]==0)\\n            return 0;\\n        if(vis[m][n])\\n            return mem[m][n];\\n        vis[m][n]=1;\\n        long long sum=mem[m][n];\\n        for(int i=1; i<m; i++)\\n            sum=max(sum, rec(i, n)+rec(m-i, n));\\n        for(int i=1; i<n; i++)\\n            sum=max(sum, rec(m, i)+rec(m, n-i));\\n        mem[m][n]=sum;\\n        return sum;\\n    }\\n\\t\\n    long long sellingWood(int m, int n, vector<vector<int>>& prices) {\\n        mem.assign(m+1, vector<int>(n+1, 0));\\n        vis.assign(m+1, vector<int>(n+1, 0));\\n        sort(prices.begin(), prices.end(), comp);\\n        for(int k=0; k<prices.size(); k++)\\n        {\\n            if(mem[prices[k][0]][prices[k][1]])\\n                continue;\\n            for(int i=prices[k][0]; i<=m; i++)\\n                for(int j=prices[k][1]; j<=n; j++)\\n                {\\n                    if(mem[i][j])\\n                        break;\\n                    mem[i][j]=prices[k][2];\\n                }\\n        }\\n        return rec(m, n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static bool comp(vector<int> a, vector<int> b)\\n    {\\n        return a[2]>b[2];\\n    }\\n\\t\\n    vector<vector<int>> mem;\\n    vector<vector<int>> vis;\\n\\t\\n    long long rec(int m, int n)\\n    {\\n        if(m==0 || n==0 || mem[m][n]==0)\\n            return 0;\\n        if(vis[m][n])\\n            return mem[m][n];\\n        vis[m][n]=1;\\n        long long sum=mem[m][n];\\n        for(int i=1; i<m; i++)\\n            sum=max(sum, rec(i, n)+rec(m-i, n));\\n        for(int i=1; i<n; i++)\\n            sum=max(sum, rec(m, i)+rec(m, n-i));\\n        mem[m][n]=sum;\\n        return sum;\\n    }\\n\\t\\n    long long sellingWood(int m, int n, vector<vector<int>>& prices) {\\n        mem.assign(m+1, vector<int>(n+1, 0));\\n        vis.assign(m+1, vector<int>(n+1, 0));\\n        sort(prices.begin(), prices.end(), comp);\\n        for(int k=0; k<prices.size(); k++)\\n        {\\n            if(mem[prices[k][0]][prices[k][1]])\\n                continue;\\n            for(int i=prices[k][0]; i<=m; i++)\\n                for(int j=prices[k][1]; j<=n; j++)\\n                {\\n                    if(mem[i][j])\\n                        break;\\n                    mem[i][j]=prices[k][2];\\n                }\\n        }\\n        return rec(m, n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2174960,
                "title": "c-my-solution-recursion-and-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    long long dfs (int h, int w, vector<vector<long long>> & lk, vector<vector<long long>> & init){\\n                \\n        if(h == 1 && w == 1){\\n            // end case.\\n            if(lk[h][w] > LLONG_MIN) return lk[h][w];\\n            lk[h][w] = init[h][w] > LLONG_MIN? init[h][w] : 0;            \\n            return lk[h][w];\\n        }\\n        \\n        // check cache\\n        if(lk[h][w] > LLONG_MIN) return lk[h][w];\\n        \\n        long long maxx = LLONG_MIN;\\n        if(init[h][w] > LLONG_MIN) maxx = init[h][w];\\n        // split left\\n        for(int i = 1; i < h ; i++){\\n            long long top = dfs(i, w , lk, init);\\n            long long bottom = dfs(h-i, w, lk, init);\\n            maxx = max(maxx, top+bottom);\\n        }\\n        // split top\\n        for(int i = 1; i < w ; i++){\\n            long long left = dfs(h, i, lk, init);\\n            long long right = dfs(h, w-i, lk, init);\\n            maxx = max(maxx, left+right);\\n        }\\n        lk[h][w] = maxx;\\n        \\n        return lk[h][w];\\n    }\\n    \\n    long long sellingWood(int m, int n, vector<vector<int>>& prices) {\\n        \\n        vector<vector<long long>> lk(m+1, vector<long long>(n+1 , LLONG_MIN));\\n        vector<vector<long long>> init(m+1, vector<long long>(n+1 , LLONG_MIN));\\n        // load init\\n        for(auto price: prices){\\n            int h = price[0];\\n            int w = price[1];\\n            int p = price[2];\\n            init[h][w] = p;\\n        }\\n        \\n        return dfs(m, n , lk, init);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    long long dfs (int h, int w, vector<vector<long long>> & lk, vector<vector<long long>> & init){\\n                \\n        if(h == 1 && w == 1){\\n            // end case.\\n            if(lk[h][w] > LLONG_MIN) return lk[h][w];\\n            lk[h][w] = init[h][w] > LLONG_MIN? init[h][w] : 0;            \\n            return lk[h][w];\\n        }\\n        \\n        // check cache\\n        if(lk[h][w] > LLONG_MIN) return lk[h][w];\\n        \\n        long long maxx = LLONG_MIN;\\n        if(init[h][w] > LLONG_MIN) maxx = init[h][w];\\n        // split left\\n        for(int i = 1; i < h ; i++){\\n            long long top = dfs(i, w , lk, init);\\n            long long bottom = dfs(h-i, w, lk, init);\\n            maxx = max(maxx, top+bottom);\\n        }\\n        // split top\\n        for(int i = 1; i < w ; i++){\\n            long long left = dfs(h, i, lk, init);\\n            long long right = dfs(h, w-i, lk, init);\\n            maxx = max(maxx, left+right);\\n        }\\n        lk[h][w] = maxx;\\n        \\n        return lk[h][w];\\n    }\\n    \\n    long long sellingWood(int m, int n, vector<vector<int>>& prices) {\\n        \\n        vector<vector<long long>> lk(m+1, vector<long long>(n+1 , LLONG_MIN));\\n        vector<vector<long long>> init(m+1, vector<long long>(n+1 , LLONG_MIN));\\n        // load init\\n        for(auto price: prices){\\n            int h = price[0];\\n            int w = price[1];\\n            int p = price[2];\\n            init[h][w] = p;\\n        }\\n        \\n        return dfs(m, n , lk, init);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2174303,
                "title": "python3-top-down-dp",
                "content": "```\\nclass Solution:\\n    def sellingWood(self, m, n, prices):\\n        height = defaultdict(set)\\n        width = defaultdict(set)\\n        for h, w, p in prices:\\n            height[h].add((w, p))\\n            width[w].add((h, p))\\n        \\n        @lru_cache(None)\\n        def dp(h, w):\\n            return max(\\n                max((p*(w//ww) for ww,p in height[h]), default=0),\\n                max((p*(h//hh) for hh,p in width[w]), default=0),\\n                max((dp(hh,w)+dp(h-hh,w) for hh in range(1, h//2+1) if hh in height), default=0),\\n                max((dp(h,ww)+dp(h,w-ww) for ww in range(1,w//2+1)), default=0)\\n            )\\n            \\n        return dp(m,n)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def sellingWood(self, m, n, prices):\\n        height = defaultdict(set)\\n        width = defaultdict(set)\\n        for h, w, p in prices:\\n            height[h].add((w, p))\\n            width[w].add((h, p))\\n        \\n        @lru_cache(None)\\n        def dp(h, w):\\n            return max(\\n                max((p*(w//ww) for ww,p in height[h]), default=0),\\n                max((p*(h//hh) for hh,p in width[w]), default=0),\\n                max((dp(hh,w)+dp(h-hh,w) for hh in range(1, h//2+1) if hh in height), default=0),\\n                max((dp(h,ww)+dp(h,w-ww) for ww in range(1,w//2+1)), default=0)\\n            )\\n            \\n        return dp(m,n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2173708,
                "title": "c-dp-solution",
                "content": "```\\n    public long SellingWood(int m, int n, int[][] prices)\\n    {\\n        long[][] dp = new long[m + 1][];\\n        for (int i = 0; i <= m; i++)\\n        {\\n            dp[i] = new long[n + 1];\\n        }\\n        for (int i = 0; i < prices.Length; ++i)\\n        {\\n            dp[prices[i][0]][prices[i][1]] = prices[i][2];\\n        }\\n        for (int i = 1; i < dp.Length; ++i)\\n        {\\n            for (int j = 1; j < dp[i].Length; ++j)\\n            {\\n                int limit = j / 2 + 1;\\n                for (int z = 1; z < limit; z++)\\n                {\\n                    dp[i][j] = Math.Max(dp[i][j], dp[i][z] + dp[i][j - z]);\\n                }\\n                limit = i / 2 + 1;\\n                for (int z = 1; z < limit; z++)\\n                {\\n                    dp[i][j] = Math.Max(dp[i][j], dp[z][j] + dp[i - z][j]);\\n                }\\n            }\\n        }\\n        return dp[m][n];\\n    }\\n```\\nCan stop the loop when j / 2 or i /2 because: \" z + (j -z) = j \" and \" a + b \" equals \" b + a \"\\nBtw, it\\'s so sad to see \"Sorry. We do not have enough accepted submissions to show distribution chart.\" after submitting C# Solution... haha",
                "solutionTags": [
                    "C#",
                    "Dynamic Programming"
                ],
                "code": "```\\n    public long SellingWood(int m, int n, int[][] prices)\\n    {\\n        long[][] dp = new long[m + 1][];\\n        for (int i = 0; i <= m; i++)\\n        {\\n            dp[i] = new long[n + 1];\\n        }\\n        for (int i = 0; i < prices.Length; ++i)\\n        {\\n            dp[prices[i][0]][prices[i][1]] = prices[i][2];\\n        }\\n        for (int i = 1; i < dp.Length; ++i)\\n        {\\n            for (int j = 1; j < dp[i].Length; ++j)\\n            {\\n                int limit = j / 2 + 1;\\n                for (int z = 1; z < limit; z++)\\n                {\\n                    dp[i][j] = Math.Max(dp[i][j], dp[i][z] + dp[i][j - z]);\\n                }\\n                limit = i / 2 + 1;\\n                for (int z = 1; z < limit; z++)\\n                {\\n                    dp[i][j] = Math.Max(dp[i][j], dp[z][j] + dp[i - z][j]);\\n                }\\n            }\\n        }\\n        return dp[m][n];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2173349,
                "title": "c-solution",
                "content": "```\\nlong long M_best_cut(long long** list, int M, int now){\\n    long long max = 0;\\n    int helf = now / 2;\\n    for (int l = 1 ; l <= helf ; l++){\\n        if (max < list[M][l] + list[M][now-l]){\\n            max = list[M][l] + list[M][now-l];\\n        }\\n    }\\n    return max;\\n}\\n\\nlong long N_best_cut(long long** list, int N, int now){\\n    long long max = 0;\\n    int helf = now / 2;\\n    for (int l = 1 ; l <= helf ; l++){\\n        if (max < list[l][N] + list[now-l][N]){\\n            max = list[l][N] + list[now-l][N];\\n        }\\n    }\\n    return max;\\n}\\n\\nlong long best(long long a, long long b, long long c){\\n    if (a < b){\\n        a = b;\\n    }\\n    if (a < c){\\n        return c;\\n    }\\n    return a;\\n}\\n\\nlong long sellingWood(int m, int n, int** prices, int pricesSize, int* pricesColSize){\\n    long long** list = malloc(sizeof(long long*)*(m+1));\\n    \\n    for (int i = 0 ; i <= m ; i++){\\n        list[i] = calloc((n+1),sizeof(long long));\\n    }\\n    \\n    for (int i = 0 ; i < pricesSize ; i++){\\n        list[prices[i][0]][prices[i][1]] = prices[i][2];\\n    }\\n    \\n    long long cut_M, cut_N;\\n    \\n    for (int i = 1 ; i <= m ; i++){\\n        for (int j = 1 ; j <= n ; j++){\\n            cut_M = M_best_cut(list, i, j);\\n            cut_N = N_best_cut(list, j, i);\\n            list[i][j] = best(cut_M,cut_N,list[i][j]);\\n        }\\n    }\\n\\n    long long ans = list[m][n];\\n    for (int i = 0 ; i <= m ; i++){\\n        free(list[i]);\\n    }\\n    free(list);\\n    return ans;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nlong long M_best_cut(long long** list, int M, int now){\\n    long long max = 0;\\n    int helf = now / 2;\\n    for (int l = 1 ; l <= helf ; l++){\\n        if (max < list[M][l] + list[M][now-l]){\\n            max = list[M][l] + list[M][now-l];\\n        }\\n    }\\n    return max;\\n}\\n\\nlong long N_best_cut(long long** list, int N, int now){\\n    long long max = 0;\\n    int helf = now / 2;\\n    for (int l = 1 ; l <= helf ; l++){\\n        if (max < list[l][N] + list[now-l][N]){\\n            max = list[l][N] + list[now-l][N];\\n        }\\n    }\\n    return max;\\n}\\n\\nlong long best(long long a, long long b, long long c){\\n    if (a < b){\\n        a = b;\\n    }\\n    if (a < c){\\n        return c;\\n    }\\n    return a;\\n}\\n\\nlong long sellingWood(int m, int n, int** prices, int pricesSize, int* pricesColSize){\\n    long long** list = malloc(sizeof(long long*)*(m+1));\\n    \\n    for (int i = 0 ; i <= m ; i++){\\n        list[i] = calloc((n+1),sizeof(long long));\\n    }\\n    \\n    for (int i = 0 ; i < pricesSize ; i++){\\n        list[prices[i][0]][prices[i][1]] = prices[i][2];\\n    }\\n    \\n    long long cut_M, cut_N;\\n    \\n    for (int i = 1 ; i <= m ; i++){\\n        for (int j = 1 ; j <= n ; j++){\\n            cut_M = M_best_cut(list, i, j);\\n            cut_N = N_best_cut(list, j, i);\\n            list[i][j] = best(cut_M,cut_N,list[i][j]);\\n        }\\n    }\\n\\n    long long ans = list[m][n];\\n    for (int i = 0 ; i <= m ; i++){\\n        free(list[i]);\\n    }\\n    free(list);\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2172670,
                "title": "python-top-down-dp-o-n-3",
                "content": "```\\n    def sellingWood(self, m: int, n: int, prices: List[List[int]]) -> int:\\n        dt = {}\\n        for h, w, p in prices:\\n            dt[(h,w)] = p\\n        @cache\\n        def dfs(h, w):\\n            if h == 0 or w == 0: return 0\\n            res = dt[(h,w)] if (h,w) in dt else 0\\n            for a in range(1, h//2+1):\\n                res = max(res, dfs(a, w) + dfs(h-a, w))\\n            for a in range(1, w//2+1):\\n                res = max(res, dfs(h, a) + dfs(h, w-a))\\n            return res\\n        return dfs(m, n)",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\n    def sellingWood(self, m: int, n: int, prices: List[List[int]]) -> int:\\n        dt = {}\\n        for h, w, p in prices:\\n            dt[(h,w)] = p\\n        @cache\\n        def dfs(h, w):\\n            if h == 0 or w == 0: return 0\\n            res = dt[(h,w)] if (h,w) in dt else 0\\n            for a in range(1, h//2+1):\\n                res = max(res, dfs(a, w) + dfs(h-a, w))\\n            for a in range(1, w//2+1):\\n                res = max(res, dfs(h, a) + dfs(h, w-a))\\n            return res\\n        return dfs(m, n)",
                "codeTag": "Python3"
            },
            {
                "id": 2172411,
                "title": "2d-dp-top-down-approach-o-m-n-m-n-beats-100-time-space",
                "content": "```\\nclass Solution {\\npublic:\\n    long long sellingWood(int m, int n, vector<vector<int>>& prices) {\\n        \\n        long long i, j;\\n        \\n        vector<vector<long long>>dp(m + 1, vector<long long>(n + 1, -1));\\n        \\n        vector<vector<long long>>p(m + 1, vector<long long>(n + 1, LLONG_MIN));\\n        \\n        \\n        for (i = 0; i < prices.size(); i++) {\\n            p[prices[i][0]][prices[i][1]] = prices[i][2];\\n        }\\n        \\n        \\n        return solve(m, n, dp, p);\\n    }\\n    \\n    long long solve(long long m, long n, vector<vector<long long>>& dp, vector<vector<long long>>& p) {\\n        \\n        long long ans = 0;\\n        \\n        if (m == 1 && n == 1) {\\n\\t\\t// can\\'t cut further\\n            return max(0LL, p[m][n]);\\n        }\\n        \\n        if (dp[m][n] != -1) {\\n            return dp[m][n];\\n        }\\n        \\n        ans = p[m][n];\\n        \\n        long long i, j, k;\\n        \\n\\t\\t// cut horizontally\\n        for (i = 1; i < m; i++) {\\n            ans = max(ans, solve(i, n, dp, p) + solve(m - i, n, dp, p));\\n        }\\n        \\n\\t\\t// cut vertically\\n        for (i = 1; i < n; i++) {\\n            ans = max(ans, solve(m, i, dp, p) + solve(m, n - i, dp, p));\\n        }\\n        \\n        return dp[m][n] = ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long sellingWood(int m, int n, vector<vector<int>>& prices) {\\n        \\n        long long i, j;\\n        \\n        vector<vector<long long>>dp(m + 1, vector<long long>(n + 1, -1));\\n        \\n        vector<vector<long long>>p(m + 1, vector<long long>(n + 1, LLONG_MIN));\\n        \\n        \\n        for (i = 0; i < prices.size(); i++) {\\n            p[prices[i][0]][prices[i][1]] = prices[i][2];\\n        }\\n        \\n        \\n        return solve(m, n, dp, p);\\n    }\\n    \\n    long long solve(long long m, long n, vector<vector<long long>>& dp, vector<vector<long long>>& p) {\\n        \\n        long long ans = 0;\\n        \\n        if (m == 1 && n == 1) {\\n\\t\\t// can\\'t cut further\\n            return max(0LL, p[m][n]);\\n        }\\n        \\n        if (dp[m][n] != -1) {\\n            return dp[m][n];\\n        }\\n        \\n        ans = p[m][n];\\n        \\n        long long i, j, k;\\n        \\n\\t\\t// cut horizontally\\n        for (i = 1; i < m; i++) {\\n            ans = max(ans, solve(i, n, dp, p) + solve(m - i, n, dp, p));\\n        }\\n        \\n\\t\\t// cut vertically\\n        for (i = 1; i < n; i++) {\\n            ans = max(ans, solve(m, i, dp, p) + solve(m, n - i, dp, p));\\n        }\\n        \\n        return dp[m][n] = ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2172149,
                "title": "my-school-homework-exactly-the-same",
                "content": "This is one of my school homework problems from my algo class 6 months ago lol ...\\n\\nThe idea is simple actually - create a lookup table (dp) and perform 1 cut per round.\\nWe can either cut it vertically or horizontally, and it becomes two smallers grid which we had computed before. \\n\\n```Java\\nclass Solution {\\n    public long sellingWood(int m, int n, int[][] prices) {\\n        long[][] dp = new long[m+1][n+1];\\n        for (int[] p : prices){\\n            dp[p[0]][p[1]]=p[2];\\n        }\\n        for (int i = 1; i <= m; i++){ // height\\n            for (int j = 1; j <= n; j++){ // width\\n                for (int k = 1; k <= i; k++){ // cut height (horizontally)\\n                    dp[i][j]=Math.max(dp[i][j], dp[i-k][j]+dp[k][j]);\\n                }\\n                for (int k = 1; k <= j; k++){ // cut width (vertically)\\n                    dp[i][j]=Math.max(dp[i][j], dp[i][j-k]+dp[i][k]);\\n                }\\n            }\\n        }\\n        return dp[m][n];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```Java\\nclass Solution {\\n    public long sellingWood(int m, int n, int[][] prices) {\\n        long[][] dp = new long[m+1][n+1];\\n        for (int[] p : prices){\\n            dp[p[0]][p[1]]=p[2];\\n        }\\n        for (int i = 1; i <= m; i++){ // height\\n            for (int j = 1; j <= n; j++){ // width\\n                for (int k = 1; k <= i; k++){ // cut height (horizontally)\\n                    dp[i][j]=Math.max(dp[i][j], dp[i-k][j]+dp[k][j]);\\n                }\\n                for (int k = 1; k <= j; k++){ // cut width (vertically)\\n                    dp[i][j]=Math.max(dp[i][j], dp[i][j-k]+dp[i][k]);\\n                }\\n            }\\n        }\\n        return dp[m][n];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2172007,
                "title": "fastest-and-simplest-c-solution",
                "content": "```\\n#define ll long long\\n\\nclass Solution {\\npublic:\\n    \\n\\t// storing given {i, j} ans in map to fetch it out quickly\\n    ll solve(int n, int m, map<pair<int, int>, ll> &hsh, vector<vector<ll>> &dp){\\n        if(dp[n][m] != -1) return dp[n][m];\\n        ll ans = hsh.find({n, m}) == hsh.end() ? 0 : hsh[{n, m}];\\n        // Why taking individual rows and cols?\\n        // Becuase in each and every individual call for particular i we get all col combination in it\\'s function call in next for loop of column. So by this we get each combination of i and j\\n        for(ll i = 1; i < n; i++){\\n            ans = max(ans, solve(i, m, hsh, dp) + solve(n - i, m, hsh, dp));\\n        }\\n        for(ll j = 1; j < m; j++){\\n            ans = max(ans, solve(n, j, hsh, dp) + solve(n, m - j, hsh, dp));\\n        }\\n        return dp[n][m] = ans;\\n    }\\n    \\n    long long sellingWood(int m, int n, vector<vector<int>>& prices) {\\n        map<pair<int, int>, ll> hsh;\\n        vector<vector<ll>> dp(m + 1, vector<ll>(n + 1, -1));\\n        for(auto i : prices) hsh[{i[0], i[1]}] = i[2];\\n        return solve(m, n, hsh, dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\n#define ll long long\\n\\nclass Solution {\\npublic:\\n    \\n\\t// storing given {i, j} ans in map to fetch it out quickly\\n    ll solve(int n, int m, map<pair<int, int>, ll> &hsh, vector<vector<ll>> &dp){\\n        if(dp[n][m] != -1) return dp[n][m];\\n        ll ans = hsh.find({n, m}) == hsh.end() ? 0 : hsh[{n, m}];\\n        // Why taking individual rows and cols?\\n        // Becuase in each and every individual call for particular i we get all col combination in it\\'s function call in next for loop of column. So by this we get each combination of i and j\\n        for(ll i = 1; i < n; i++){\\n            ans = max(ans, solve(i, m, hsh, dp) + solve(n - i, m, hsh, dp));\\n        }\\n        for(ll j = 1; j < m; j++){\\n            ans = max(ans, solve(n, j, hsh, dp) + solve(n, m - j, hsh, dp));\\n        }\\n        return dp[n][m] = ans;\\n    }\\n    \\n    long long sellingWood(int m, int n, vector<vector<int>>& prices) {\\n        map<pair<int, int>, ll> hsh;\\n        vector<vector<ll>> dp(m + 1, vector<ll>(n + 1, -1));\\n        for(auto i : prices) hsh[{i[0], i[1]}] = i[2];\\n        return solve(m, n, hsh, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2171704,
                "title": "java-bottom-up-dp",
                "content": "```\\nclass Solution {\\n    public long sellingWood(int m, int n, int[][] prices) {\\n\\t\\t// dp[i][j] = Maximum profit selling wood of size i*j\\n        long[][] dp = new long[m][n];\\n        for(int[] price : prices) {\\n            dp[price[0]-1][price[1]-1] = Math.max(dp[price[0]-1][price[1]-1], price[2]);\\n        }\\n        for(int i = 0; i < m; i++) {\\n            for(int j = 0; j < n; j++) {\\n                // Cut Vertically\\n                for(int k = 0; k < j; k++) {\\n                    dp[i][j] = Math.max(dp[i][j], dp[i][k] + dp[i][j-k-1]);\\n                }\\n                // Cut Horizontally\\n                for(int k = 0; k < i; k++) {\\n                    dp[i][j] = Math.max(dp[i][j], dp[k][j] + dp[i-k-1][j]);\\n                }\\n            }\\n        }\\n        return dp[m-1][n-1];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public long sellingWood(int m, int n, int[][] prices) {\\n\\t\\t// dp[i][j] = Maximum profit selling wood of size i*j\\n        long[][] dp = new long[m][n];\\n        for(int[] price : prices) {\\n            dp[price[0]-1][price[1]-1] = Math.max(dp[price[0]-1][price[1]-1], price[2]);\\n        }\\n        for(int i = 0; i < m; i++) {\\n            for(int j = 0; j < n; j++) {\\n                // Cut Vertically\\n                for(int k = 0; k < j; k++) {\\n                    dp[i][j] = Math.max(dp[i][j], dp[i][k] + dp[i][j-k-1]);\\n                }\\n                // Cut Horizontally\\n                for(int k = 0; k < i; k++) {\\n                    dp[i][j] = Math.max(dp[i][j], dp[k][j] + dp[i-k-1][j]);\\n                }\\n            }\\n        }\\n        return dp[m-1][n-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2171641,
                "title": "java-dp-memo",
                "content": "```\\nclass Solution {\\n    long ans=0;\\n    int[][]temp;\\n    long[][]dp;\\n    public long sellingWood(int m, int n, int[][] prices) {\\n        temp=new int[m+1][n+1];\\n        dp=new long[m+1][n+1];\\n        for(long[]t:dp){\\n            Arrays.fill(t,-1);\\n        }\\n        for(int[]t:prices){\\n            temp[t[0]][t[1]]=t[2];\\n        }\\n        return solve(m,n);\\n        \\n    }\\n    \\n    long solve(int m,int n){\\n        \\n        //base case\\n        if(m==1 && n==1){\\n            return temp[m][n];\\n        }\\n        if(dp[m][n]!=-1){\\n            return dp[m][n];\\n        }\\n        long ans=temp[m][n];\\n\\t\\t\\n\\t\\t// split by rows\\n        for(int rows=0;rows<m/2;rows++){\\n            ans=Math.max(ans,solve(rows+1,n)+solve(m-rows-1,n));\\n        }\\n\\t\\t\\n\\t\\t//split by cols\\n        for(int cols=0;cols<n/2;cols++){\\n            ans=Math.max(ans,solve(m,cols+1)+solve(m,n-cols-1));\\n        }\\n        return dp[m][n]=ans;\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    long ans=0;\\n    int[][]temp;\\n    long[][]dp;\\n    public long sellingWood(int m, int n, int[][] prices) {\\n        temp=new int[m+1][n+1];\\n        dp=new long[m+1][n+1];\\n        for(long[]t:dp){\\n            Arrays.fill(t,-1);\\n        }\\n        for(int[]t:prices){\\n            temp[t[0]][t[1]]=t[2];\\n        }\\n        return solve(m,n);\\n        \\n    }\\n    \\n    long solve(int m,int n){\\n        \\n        //base case\\n        if(m==1 && n==1){\\n            return temp[m][n];\\n        }\\n        if(dp[m][n]!=-1){\\n            return dp[m][n];\\n        }\\n        long ans=temp[m][n];\\n\\t\\t\\n\\t\\t// split by rows\\n        for(int rows=0;rows<m/2;rows++){\\n            ans=Math.max(ans,solve(rows+1,n)+solve(m-rows-1,n));\\n        }\\n\\t\\t\\n\\t\\t//split by cols\\n        for(int cols=0;cols<n/2;cols++){\\n            ans=Math.max(ans,solve(m,cols+1)+solve(m,n-cols-1));\\n        }\\n        return dp[m][n]=ans;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2171460,
                "title": "help-python-memoization-getting-timeout-tle",
                "content": "Can someone say why this solution is getting timeout ?\\n```\\nclass Solution(object):\\n    def sellingWood(self, m, n, prices):\\n        \"\"\"\\n        :type m: int\\n        :type n: int\\n        :type prices: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        memo = {}\\n        ma = {}\\n        for x,y,p in prices:\\n            ma[x,y] = p\\n        \\n        def dpMemo(x, y):\\n            val = 0\\n            if (x,y) in memo:\\n                return memo[x,y]\\n            \\n            for i in range(1, x/2 + 1):\\n                l = memo[i, y] if (i, y) in memo else dpMemo(i, y)\\n                r = memo[x-i, y] if (x-i, y) in memo else dpMemo(x-i, y)\\n                val=max(val,l+r)\\n            \\n            for j in range(1, y/2 + 1):\\n                l = memo[x, j] if (x, j) in memo else dpMemo(x, j)\\n                r = memo[x, y-j] if (x, y-j) in memo else dpMemo(x, y-j)\\n                val=max(val , l + dpMemo(x, y-j))\\n            \\n            if (x,y) in ma:\\n                val = max(val, ma[x,y])\\n            memo[x,y] = val\\n            return val\\n        r = dpMemo(m, n)\\n        return r\\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def sellingWood(self, m, n, prices):\\n        \"\"\"\\n        :type m: int\\n        :type n: int\\n        :type prices: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        memo = {}\\n        ma = {}\\n        for x,y,p in prices:\\n            ma[x,y] = p\\n        \\n        def dpMemo(x, y):\\n            val = 0\\n            if (x,y) in memo:\\n                return memo[x,y]\\n            \\n            for i in range(1, x/2 + 1):\\n                l = memo[i, y] if (i, y) in memo else dpMemo(i, y)\\n                r = memo[x-i, y] if (x-i, y) in memo else dpMemo(x-i, y)\\n                val=max(val,l+r)\\n            \\n            for j in range(1, y/2 + 1):\\n                l = memo[x, j] if (x, j) in memo else dpMemo(x, j)\\n                r = memo[x, y-j] if (x, y-j) in memo else dpMemo(x, y-j)\\n                val=max(val , l + dpMemo(x, y-j))\\n            \\n            if (x,y) in ma:\\n                val = max(val, ma[x,y])\\n            memo[x,y] = val\\n            return val\\n        r = dpMemo(m, n)\\n        return r\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2171435,
                "title": "fase-go-beats-100",
                "content": "```\\nfunc dp(h, w int, memo, p [][]int64) int64 {\\n    if h == 0 || w == 0 {\\n        return 0\\n    }\\n    \\n    if memo[h][w] >= 0 {\\n        return memo[h][w]\\n    }\\n    \\n    memo[h][w] = 0\\n    r := int64(0)\\n    if p[h][w] != -1 {\\n        r = p[h][w]\\n    }\\n    \\n    for i := 1; i < h; i++ {\\n        x := dp(i, w, memo, p) + dp(h - i, w, memo, p)\\n        if x > r {\\n            r = x\\n        }        \\n    }\\n    \\n    for j := 1; j < w; j++ {\\n        x := dp(h, j, memo, p) + dp(h, w - j, memo, p)\\n        if x > r {\\n            r = x\\n        }\\n    }\\n    \\n    memo[h][w] = r\\n    return r    \\n}\\n\\nfunc sellingWood(m int, n int, prices [][]int) int64 {\\n    memo := make([][]int64, m + 1)\\n    p := make([][]int64, m + 1)\\n    for i := 0; i <= m; i++ {\\n        memo[i] = make([]int64, n + 1)\\n        p[i] = make([]int64, n + 1)\\n        for j := 0; j <= n; j++ {\\n            memo[i][j] = -1\\n            p[i][j] = -1\\n        }\\n    }\\n    \\n    for _, x := range prices {\\n        p[x[0]][x[1]] = int64(x[2])\\n    }\\n            \\n    return dp(m, n, memo, p)\\n}",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc dp(h, w int, memo, p [][]int64) int64 {\\n    if h == 0 || w == 0 {\\n        return 0\\n    }\\n    \\n    if memo[h][w] >= 0 {\\n        return memo[h][w]\\n    }\\n    \\n    memo[h][w] = 0\\n    r := int64(0)\\n    if p[h][w] != -1 {\\n        r = p[h][w]\\n    }\\n    \\n    for i := 1; i < h; i++ {\\n        x := dp(i, w, memo, p) + dp(h - i, w, memo, p)\\n        if x > r {\\n            r = x\\n        }        \\n    }\\n    \\n    for j := 1; j < w; j++ {\\n        x := dp(h, j, memo, p) + dp(h, w - j, memo, p)\\n        if x > r {\\n            r = x\\n        }\\n    }\\n    \\n    memo[h][w] = r\\n    return r    \\n}\\n\\nfunc sellingWood(m int, n int, prices [][]int) int64 {\\n    memo := make([][]int64, m + 1)\\n    p := make([][]int64, m + 1)\\n    for i := 0; i <= m; i++ {\\n        memo[i] = make([]int64, n + 1)\\n        p[i] = make([]int64, n + 1)\\n        for j := 0; j <= n; j++ {\\n            memo[i][j] = -1\\n            p[i][j] = -1\\n        }\\n    }\\n    \\n    for _, x := range prices {\\n        p[x[0]][x[1]] = int64(x[2])\\n    }\\n            \\n    return dp(m, n, memo, p)\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 2171119,
                "title": "c-memo-100-time-100-space-sol",
                "content": "![image](https://assets.leetcode.com/users/images/e48a3002-05ba-4434-b3a6-1a9a97b884d2_1655655212.4242225.png)\\n\\ntime: O(mn*(m+n))\\nspace: O(mn+len(prices))\\n```\\nclass Solution {\\npublic:\\n    long long sellingWood(int m, int n, vector<vector<int>>& prices) {\\n        unordered_map<string, int> hm;\\n        for (auto& price: prices)\\n        {\\n            hm[to_string(price[0])+\\'_\\'+to_string(price[1])] = price[2];\\n        }\\n        vector<vector<long long>> memo(m+1, vector<long long>(n+1, -1));\\n        return helper(m, n, hm, memo);\\n    }\\nprivate:\\n    long long helper(int m, int n, unordered_map<string, int>& hm, vector<vector<long long>>& memo)\\n    {\\n        if (m <= 0 || n <= 0) return 0;\\n        if (memo[m][n] != -1) return memo[m][n];\\n        string shape = to_string(m)+\\'_\\'+to_string(n);\\n        long long res = 0;\\n        if (hm.find(shape) != hm.end()) res = static_cast<long long>(hm[shape]);\\n        // horizontal cut\\n        for (int i=1; i<m; i++)\\n        {\\n            res = max(res, helper(i, n, hm, memo)+helper(m-i, n, hm, memo));\\n        }\\n        // vertical cut\\n        for (int i=1; i<n; i++)\\n        {\\n            res = max(res, helper(m, i, hm, memo)+helper(m, n-i, hm, memo));\\n        }\\n        return memo[m][n] = res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long sellingWood(int m, int n, vector<vector<int>>& prices) {\\n        unordered_map<string, int> hm;\\n        for (auto& price: prices)\\n        {\\n            hm[to_string(price[0])+\\'_\\'+to_string(price[1])] = price[2];\\n        }\\n        vector<vector<long long>> memo(m+1, vector<long long>(n+1, -1));\\n        return helper(m, n, hm, memo);\\n    }\\nprivate:\\n    long long helper(int m, int n, unordered_map<string, int>& hm, vector<vector<long long>>& memo)\\n    {\\n        if (m <= 0 || n <= 0) return 0;\\n        if (memo[m][n] != -1) return memo[m][n];\\n        string shape = to_string(m)+\\'_\\'+to_string(n);\\n        long long res = 0;\\n        if (hm.find(shape) != hm.end()) res = static_cast<long long>(hm[shape]);\\n        // horizontal cut\\n        for (int i=1; i<m; i++)\\n        {\\n            res = max(res, helper(i, n, hm, memo)+helper(m-i, n, hm, memo));\\n        }\\n        // vertical cut\\n        for (int i=1; i<n; i++)\\n        {\\n            res = max(res, helper(m, i, hm, memo)+helper(m, n-i, hm, memo));\\n        }\\n        return memo[m][n] = res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2171001,
                "title": "c-top-down-dp",
                "content": "```\\npublic class Solution\\n{\\n  public long SellingWood(int m, int n, int[][] prices)\\n  {\\n    var pricesMap = prices.ToDictionary(x => (x[0], x[1]), x => x[2]);\\n\\n    // DP\\n    // recursive + memo\\n    var memo = new Dictionary<(int h, int w), long>();\\n    var ans = Calculate(m, n, pricesMap, memo);\\n    \\n    return ans;\\n  }\\n\\n  private long Calculate(int m, int n, \\n                         Dictionary<(int, int), int> prices, Dictionary<(int h, int w), long> memo)\\n  {\\n    if (memo.ContainsKey((m, n)))\\n    {\\n      return memo[(m, n)];\\n    }\\n\\n    var ans = 0L;\\n\\n    // walk thru all horizontal cuts\\n    for (var i = 1; i < m; i++)\\n    {\\n      ans = Math.Max(ans, \\n        Calculate(i, n, prices, memo) + Calculate(m - i, n, prices, memo));\\n    }\\n\\n    // walk thru all vertical cuts\\n    for (var i = 1; i < n; i++)\\n    {\\n      ans = Math.Max(ans, \\n        Calculate(m, i, prices, memo) + Calculate(m, n - i, prices, memo));\\n    }\\n\\n    // check exact piece size\\n    if (prices.ContainsKey((m, n)))\\n    {\\n      ans = Math.Max(ans, prices[(m, n)]);\\n    }\\n\\n    memo[(m, n)] = ans;\\n    return ans;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\npublic class Solution\\n{\\n  public long SellingWood(int m, int n, int[][] prices)\\n  {\\n    var pricesMap = prices.ToDictionary(x => (x[0], x[1]), x => x[2]);\\n\\n    // DP\\n    // recursive + memo\\n    var memo = new Dictionary<(int h, int w), long>();\\n    var ans = Calculate(m, n, pricesMap, memo);\\n    \\n    return ans;\\n  }\\n\\n  private long Calculate(int m, int n, \\n                         Dictionary<(int, int), int> prices, Dictionary<(int h, int w), long> memo)\\n  {\\n    if (memo.ContainsKey((m, n)))\\n    {\\n      return memo[(m, n)];\\n    }\\n\\n    var ans = 0L;\\n\\n    // walk thru all horizontal cuts\\n    for (var i = 1; i < m; i++)\\n    {\\n      ans = Math.Max(ans, \\n        Calculate(i, n, prices, memo) + Calculate(m - i, n, prices, memo));\\n    }\\n\\n    // walk thru all vertical cuts\\n    for (var i = 1; i < n; i++)\\n    {\\n      ans = Math.Max(ans, \\n        Calculate(m, i, prices, memo) + Calculate(m, n - i, prices, memo));\\n    }\\n\\n    // check exact piece size\\n    if (prices.ContainsKey((m, n)))\\n    {\\n      ans = Math.Max(ans, prices[(m, n)]);\\n    }\\n\\n    memo[(m, n)] = ans;\\n    return ans;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2170576,
                "title": "swift-memo-dfs",
                "content": "```swift\\nhttps://leetcode.com/problems/selling-pieces-of-wood/\\nclass Solution {\\n    func sellingWood(_ height: Int, _ width: Int, _ _prices: [[Int]]) -> Int {\\n        var memo = [[Int]](repeating: [Int](repeating: -1, count: width + 5), count: height + 5)\\n\\n        var prices = [[Int]](repeating: [Int](repeating: 0, count: width + 5), count: height + 5)\\n        _prices.forEach { p in\\n            prices[p[0]][p[1]] = p[2]\\n        }\\n\\n\\n\\n        func dfs(_ curHeight: Int, _ curWidth: Int) -> Int {\\n\\n            guard -1 == memo[curHeight][curWidth] else {\\n                return memo[curHeight][curWidth]\\n            }\\n\\n            var ans = prices[curHeight][curWidth]\\n            //horizon\\n            for firstPartHeight in 1..<curHeight {\\n                ans = max(ans, dfs(firstPartHeight, curWidth) + dfs(curHeight - firstPartHeight, curWidth))\\n            }\\n            //vertical\\n            for firstPartWidth in 1..<curWidth {\\n                ans = max(ans, dfs(curHeight, firstPartWidth) + dfs(curHeight, curWidth - firstPartWidth))\\n            }\\n            memo[curHeight][curWidth] = ans\\n            return ans\\n        }\\n\\n        return dfs(height, width)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```swift\\nhttps://leetcode.com/problems/selling-pieces-of-wood/\\nclass Solution {\\n    func sellingWood(_ height: Int, _ width: Int, _ _prices: [[Int]]) -> Int {\\n        var memo = [[Int]](repeating: [Int](repeating: -1, count: width + 5), count: height + 5)\\n\\n        var prices = [[Int]](repeating: [Int](repeating: 0, count: width + 5), count: height + 5)\\n        _prices.forEach { p in\\n            prices[p[0]][p[1]] = p[2]\\n        }\\n\\n\\n\\n        func dfs(_ curHeight: Int, _ curWidth: Int) -> Int {\\n\\n            guard -1 == memo[curHeight][curWidth] else {\\n                return memo[curHeight][curWidth]\\n            }\\n\\n            var ans = prices[curHeight][curWidth]\\n            //horizon\\n            for firstPartHeight in 1..<curHeight {\\n                ans = max(ans, dfs(firstPartHeight, curWidth) + dfs(curHeight - firstPartHeight, curWidth))\\n            }\\n            //vertical\\n            for firstPartWidth in 1..<curWidth {\\n                ans = max(ans, dfs(curHeight, firstPartWidth) + dfs(curHeight, curWidth - firstPartWidth))\\n            }\\n            memo[curHeight][curWidth] = ans\\n            return ans\\n        }\\n\\n        return dfs(height, width)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2170523,
                "title": "iterative-and-recursive-solution-recursive-giving-tle",
                "content": "```\\nclass Solution:\\n    def sellingWood(self, m: int, n: int, prices: List[List[int]]) -> int:\\n        \\n        pricelist={}\\n\\n        dp=[[0 for i in range(n+1)] for  j in range(m+1)]\\n        for i,j,p in prices:\\n            pricelist[(i,j)]=p\\n            dp[i][j]=p\\n        for i in range(1,m+1):\\n            for j in range(1,n+1):\\n                    for a in range(1,j//2+1):\\n                        dp[i][j]=max(dp[i][j],dp[i][a]+dp[i][j-a])\\n                    for b  in range(1,i//2+1):\\n                        dp[i][j]=max(dp[i][j],dp[b][j]+dp[i-b][j])\\n                    if (i,j) in pricelist:\\n                        dp[i][j]=max(pricelist[(i,j)],dp[i][j])\\n        return dp[m][n]\\n  \\n  \\n```\\nRecursive:\\n```\\nclass Solution:\\n    def sellingWood(self, m: int, n: int, prices: List[List[int]]) -> int:\\n\\n        dp={}\\n        def cost(m,n):\\n            if (m,n) in dp:\\n                return dp[(m,n)]\\n            if m==0 or n==0:\\n                return 0\\n            ans=0\\n            for i in range(1,n//2+1):\\n                ans=max(ans,cost(m,i)+cost(m,n-i))\\n            for j in range(1,m//2+1):\\n                ans=max(ans,cost(j,n)+cost(m-j,n))\\n            if (m,n) in pricelist:\\n                dp[(m,n)]=max(pricelist[(m,n)],ans)\\n                return max(pricelist[(m,n)],ans)\\n            else:\\n                dp[(m,n)]=ans\\n                return ans\\n        return cost(m,n)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def sellingWood(self, m: int, n: int, prices: List[List[int]]) -> int:\\n        \\n        pricelist={}\\n\\n        dp=[[0 for i in range(n+1)] for  j in range(m+1)]\\n        for i,j,p in prices:\\n            pricelist[(i,j)]=p\\n            dp[i][j]=p\\n        for i in range(1,m+1):\\n            for j in range(1,n+1):\\n                    for a in range(1,j//2+1):\\n                        dp[i][j]=max(dp[i][j],dp[i][a]+dp[i][j-a])\\n                    for b  in range(1,i//2+1):\\n                        dp[i][j]=max(dp[i][j],dp[b][j]+dp[i-b][j])\\n                    if (i,j) in pricelist:\\n                        dp[i][j]=max(pricelist[(i,j)],dp[i][j])\\n        return dp[m][n]\\n  \\n  \\n```\n```\\nclass Solution:\\n    def sellingWood(self, m: int, n: int, prices: List[List[int]]) -> int:\\n\\n        dp={}\\n        def cost(m,n):\\n            if (m,n) in dp:\\n                return dp[(m,n)]\\n            if m==0 or n==0:\\n                return 0\\n            ans=0\\n            for i in range(1,n//2+1):\\n                ans=max(ans,cost(m,i)+cost(m,n-i))\\n            for j in range(1,m//2+1):\\n                ans=max(ans,cost(j,n)+cost(m-j,n))\\n            if (m,n) in pricelist:\\n                dp[(m,n)]=max(pricelist[(m,n)],ans)\\n                return max(pricelist[(m,n)],ans)\\n            else:\\n                dp[(m,n)]=ans\\n                return ans\\n        return cost(m,n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2170517,
                "title": "c-dp-recursion-memo-trying-all-cuts",
                "content": "```\\nclass Solution {\\nprivate:\\n    long long dp[201][201];\\n    long long profit[201][201];\\n    long long fun(int m, int n){\\n        if(m == 0 || n == 0) return 0;\\n        if(dp[m][n]!=-1) return dp[m][n];\\n        long long ans = profit[m][n];\\n        for(int i = 1; i <= m/2; i++) ans = max(ans, fun(i, n) + fun(m-i, n));\\n        for(int j = 1; j <= n/2; j++) ans = max(ans, fun(m, j) + fun(m, n-j));\\n        return dp[m][n] = ans;\\n    }\\npublic:\\n    long long sellingWood(int m, int n, vector<vector<int>>& prices) {\\n        memset(profit, 0, sizeof profit);\\n        memset(dp, -1, sizeof dp);\\n        for(auto &i: prices){\\n            profit[i[0]][i[1]] = i[2];\\n        }\\n        return fun(m, n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    long long dp[201][201];\\n    long long profit[201][201];\\n    long long fun(int m, int n){\\n        if(m == 0 || n == 0) return 0;\\n        if(dp[m][n]!=-1) return dp[m][n];\\n        long long ans = profit[m][n];\\n        for(int i = 1; i <= m/2; i++) ans = max(ans, fun(i, n) + fun(m-i, n));\\n        for(int j = 1; j <= n/2; j++) ans = max(ans, fun(m, j) + fun(m, n-j));\\n        return dp[m][n] = ans;\\n    }\\npublic:\\n    long long sellingWood(int m, int n, vector<vector<int>>& prices) {\\n        memset(profit, 0, sizeof profit);\\n        memset(dp, -1, sizeof dp);\\n        for(auto &i: prices){\\n            profit[i[0]][i[1]] = i[2];\\n        }\\n        return fun(m, n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2170477,
                "title": "easy-solution-100-faster-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    long long sellingWood(int m, int n, vector<vector<int>>& prices) {\\n        long long dp[m+1][n+1];\\n        memset(dp,0,sizeof(dp));\\n        int size=prices.size();\\n        for(int i=0;i<size;i++) dp[prices[i][0]][prices[i][1]]=prices[i][2];\\n        for(int i=1;i<=m;i++){\\n            for(int j=1;j<=n;j++){\\n                for(int k=0;k<=max(i,j);k++){\\n                    if(k<=j) dp[i][j]=max(dp[i][j],dp[i][k]+dp[i][j-k]);\\n                    if(k<=i) dp[i][j]=max(dp[i][j],dp[k][j]+dp[i-k][j]);\\n                }\\n            }\\n        }\\n        return dp[m][n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long sellingWood(int m, int n, vector<vector<int>>& prices) {\\n        long long dp[m+1][n+1];\\n        memset(dp,0,sizeof(dp));\\n        int size=prices.size();\\n        for(int i=0;i<size;i++) dp[prices[i][0]][prices[i][1]]=prices[i][2];\\n        for(int i=1;i<=m;i++){\\n            for(int j=1;j<=n;j++){\\n                for(int k=0;k<=max(i,j);k++){\\n                    if(k<=j) dp[i][j]=max(dp[i][j],dp[i][k]+dp[i][j-k]);\\n                    if(k<=i) dp[i][j]=max(dp[i][j],dp[k][j]+dp[i-k][j]);\\n                }\\n            }\\n        }\\n        return dp[m][n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2170423,
                "title": "c-dp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    long long sellingWood(int m, int n, vector<vector<int>>& prices) {\\n        vector<vector<long long>> dp(m + 1, vector<long long> (n + 1));\\n        \\n        int i, j, k;\\n        \\n        for(i = 0; i < prices.size(); i++){\\n            int row = prices[i][0];\\n            int col = prices[i][1];\\n            int price = prices[i][2];\\n            \\n            dp[row][col] = price;\\n        }\\n        \\n        for(i = 1; i <= m; i++){\\n            for(j = 1; j <= n; j++){\\n                for(k = 1; k <= i; k++){\\n                    dp[i][j] = max(dp[i][j], dp[k][j] + dp[i - k][j]);\\n                }\\n                for(k = 1; k <= j; k++){\\n                    dp[i][j] = max(dp[i][j], dp[i][k] + dp[i][j - k]);\\n                }\\n            }\\n        }\\n        \\n        return dp[m][n];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long sellingWood(int m, int n, vector<vector<int>>& prices) {\\n        vector<vector<long long>> dp(m + 1, vector<long long> (n + 1));\\n        \\n        int i, j, k;\\n        \\n        for(i = 0; i < prices.size(); i++){\\n            int row = prices[i][0];\\n            int col = prices[i][1];\\n            int price = prices[i][2];\\n            \\n            dp[row][col] = price;\\n        }\\n        \\n        for(i = 1; i <= m; i++){\\n            for(j = 1; j <= n; j++){\\n                for(k = 1; k <= i; k++){\\n                    dp[i][j] = max(dp[i][j], dp[k][j] + dp[i - k][j]);\\n                }\\n                for(k = 1; k <= j; k++){\\n                    dp[i][j] = max(dp[i][j], dp[i][k] + dp[i][j - k]);\\n                }\\n            }\\n        }\\n        \\n        return dp[m][n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2170135,
                "title": "recursion-approach-not-working",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<long long>>dp;\\n    void solve(int m, int n){\\n        for(int i=1;i<=m/2;i++){\\n            solve(i,n);\\n            solve(m-i,n);\\n            dp[m][n]=max(dp[m][n],dp[i][n]+dp[m-i][n]);\\n        }\\n        for(int i=1;i<=n/2;i++){\\n            solve(m,i);\\n            solve(m,n-i);\\n            dp[m][n]=max(dp[m][n],dp[m][i]+dp[m][n-i]);\\n        }\\n    }\\n    long long sellingWood(int m, int n, vector<vector<int>>& prices) {\\n        dp = vector<vector<long long>>(m+1,vector<long long>(n+1,0));\\n        for(auto it:prices){\\n            dp[it[0]][it[1]]=it[2];\\n        }\\n        solve(m,n);\\n        return dp[m][n];\\n    }\\n};\\n```\\nwhy this thing showing tle ??\\n",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<long long>>dp;\\n    void solve(int m, int n){\\n        for(int i=1;i<=m/2;i++){\\n            solve(i,n);\\n            solve(m-i,n);\\n            dp[m][n]=max(dp[m][n],dp[i][n]+dp[m-i][n]);\\n        }\\n        for(int i=1;i<=n/2;i++){\\n            solve(m,i);\\n            solve(m,n-i);\\n            dp[m][n]=max(dp[m][n],dp[m][i]+dp[m][n-i]);\\n        }\\n    }\\n    long long sellingWood(int m, int n, vector<vector<int>>& prices) {\\n        dp = vector<vector<long long>>(m+1,vector<long long>(n+1,0));\\n        for(auto it:prices){\\n            dp[it[0]][it[1]]=it[2];\\n        }\\n        solve(m,n);\\n        return dp[m][n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2169909,
                "title": "javascript-bottom-up-dp-faster-than-100-309ms",
                "content": "```\\nvar sellingWood = function (m, n, prices) {\\n  const dp = Array(m + 1).fill(null).map(_ => Array(n + 1).fill(0));\\n  for (let p of prices)\\n    dp[p[0]][p[1]] = p[2];\\n  for (let w = 1; w <= m; ++w) {\\n    for (let h = 1; h <= n; ++h) {\\n      for (let a = 1; a <= Math.floor(w / 2); ++a)\\n        dp[w][h] = Math.max(dp[w][h], dp[a][h] + dp[w - a][h]);\\n      for (let a = 1; a <= Math.floor(h / 2); ++a)\\n        dp[w][h] = Math.max(dp[w][h], dp[w][a] + dp[w][h - a]);\\n    }\\n  }\\n  return dp[m][n];\\n};\\n```\\n\\nFor more detail see: [3D DP](https://leetcode.com/problems/selling-pieces-of-wood/discuss/2168403/3D-DP)",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\nvar sellingWood = function (m, n, prices) {\\n  const dp = Array(m + 1).fill(null).map(_ => Array(n + 1).fill(0));\\n  for (let p of prices)\\n    dp[p[0]][p[1]] = p[2];\\n  for (let w = 1; w <= m; ++w) {\\n    for (let h = 1; h <= n; ++h) {\\n      for (let a = 1; a <= Math.floor(w / 2); ++a)\\n        dp[w][h] = Math.max(dp[w][h], dp[a][h] + dp[w - a][h]);\\n      for (let a = 1; a <= Math.floor(h / 2); ++a)\\n        dp[w][h] = Math.max(dp[w][h], dp[w][a] + dp[w][h - a]);\\n    }\\n  }\\n  return dp[m][n];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2169792,
                "title": "c-100-faster-solution",
                "content": "```\\n#define in long long int\\n\\nbool cmp(pair<int, int>&a, pair<int, int>&b){\\n    return (long double)a.second/(long double)a.first < (long double)b.second/(long double)b.first;\\n}\\n\\nclass Solution {\\npublic:\\n    vector<pair<int, int>> x[201];\\n    long long int dp[201][201];\\n    vector<vector<int>> p;\\n    \\n    in find(int m, int n){\\n        if(dp[m][n] != -1) return dp[m][n];\\n        if(m == 0 || n == 0) return dp[m][n] = 0;\\n        in ans = 0;\\n        for(int i=m;i>=1;i--){\\n            int ind = x[i].size()-1;\\n            while(ind >= 0){\\n                if(x[i][ind].first > n){\\n                    ind--;\\n                    continue;\\n                }\\n                in before = ans;\\n                ans = max({\\n                    ans,\\n                    x[i][ind].second*1ll + find(i, n-x[i][ind].first) + find(m - i, n),\\n                    x[i][ind].second*1ll + find(m-i, x[i][ind].first) + find(m, n - x[i][ind].first)\\n                });\\n                if(ans == before) break;\\n                ind--;\\n            }\\n        }\\n        \\n        return dp[m][n] = ans;\\n    }\\n    \\n    long long sellingWood(int m, int n, vector<vector<int>>& prices) {\\n        memset(dp, -1, sizeof(dp));\\n        for(vector<int>&pp : prices){\\n            x[pp[0]].push_back({pp[1], pp[2]});\\n        }\\n        for(int i=0;i<201;i++){\\n            sort(x[i].begin(), x[i].end(), cmp);\\n        }\\n        return find(m, n);    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n#define in long long int\\n\\nbool cmp(pair<int, int>&a, pair<int, int>&b){\\n    return (long double)a.second/(long double)a.first < (long double)b.second/(long double)b.first;\\n}\\n\\nclass Solution {\\npublic:\\n    vector<pair<int, int>> x[201];\\n    long long int dp[201][201];\\n    vector<vector<int>> p;\\n    \\n    in find(int m, int n){\\n        if(dp[m][n] != -1) return dp[m][n];\\n        if(m == 0 || n == 0) return dp[m][n] = 0;\\n        in ans = 0;\\n        for(int i=m;i>=1;i--){\\n            int ind = x[i].size()-1;\\n            while(ind >= 0){\\n                if(x[i][ind].first > n){\\n                    ind--;\\n                    continue;\\n                }\\n                in before = ans;\\n                ans = max({\\n                    ans,\\n                    x[i][ind].second*1ll + find(i, n-x[i][ind].first) + find(m - i, n),\\n                    x[i][ind].second*1ll + find(m-i, x[i][ind].first) + find(m, n - x[i][ind].first)\\n                });\\n                if(ans == before) break;\\n                ind--;\\n            }\\n        }\\n        \\n        return dp[m][n] = ans;\\n    }\\n    \\n    long long sellingWood(int m, int n, vector<vector<int>>& prices) {\\n        memset(dp, -1, sizeof(dp));\\n        for(vector<int>&pp : prices){\\n            x[pp[0]].push_back({pp[1], pp[2]});\\n        }\\n        for(int i=0;i<201;i++){\\n            sort(x[i].begin(), x[i].end(), cmp);\\n        }\\n        return find(m, n);    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2169743,
                "title": "my-solution",
                "content": "```\\n/**\\n * Time Complexity: O(m * n * max(m, n))\\n * Space Complexity: O(m * n)\\n */\\nclass Solution {\\n public:\\n  long long sellingWood(const int m, const int n, const vector<vector<int>>& prices) {\\n    int profit[m + 1][n + 1];\\n    memset(profit, 0, sizeof(profit));\\n    for (const vector<int> &price : prices) {\\n      profit[price[0]][price[1]] = price[2];\\n    }\\n    \\n    long long dp[m + 1][n + 1];\\n    memset(dp, 0, sizeof(dp));\\n    for (int rows = 1; rows < m + 1; ++rows) {\\n      for (int cols = 1; cols < n + 1; ++cols) {\\n        dp[rows][cols] = profit[rows][cols];\\n        for (int top = 1; top < rows; ++top) {\\n          dp[rows][cols] = max(dp[rows][cols], dp[top][cols] + dp[rows - top][cols]);\\n        }\\n        for (int left = 1; left < cols; ++left) {\\n          dp[rows][cols] = max(dp[rows][cols], dp[rows][left] + dp[rows][cols - left]);\\n        }\\n      }\\n    }\\n    return dp[m][n];\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Time Complexity: O(m * n * max(m, n))\\n * Space Complexity: O(m * n)\\n */\\nclass Solution {\\n public:\\n  long long sellingWood(const int m, const int n, const vector<vector<int>>& prices) {\\n    int profit[m + 1][n + 1];\\n    memset(profit, 0, sizeof(profit));\\n    for (const vector<int> &price : prices) {\\n      profit[price[0]][price[1]] = price[2];\\n    }\\n    \\n    long long dp[m + 1][n + 1];\\n    memset(dp, 0, sizeof(dp));\\n    for (int rows = 1; rows < m + 1; ++rows) {\\n      for (int cols = 1; cols < n + 1; ++cols) {\\n        dp[rows][cols] = profit[rows][cols];\\n        for (int top = 1; top < rows; ++top) {\\n          dp[rows][cols] = max(dp[rows][cols], dp[top][cols] + dp[rows - top][cols]);\\n        }\\n        for (int left = 1; left < cols; ++left) {\\n          dp[rows][cols] = max(dp[rows][cols], dp[rows][left] + dp[rows][cols - left]);\\n        }\\n      }\\n    }\\n    return dp[m][n];\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2169498,
                "title": "python-solution-bottom-up-dp",
                "content": "I wasn\\'t paying enough attention during the contest that you cannot cut one small piece out. \\nAnyway, this problem is still standard DP.\\nI tried top-down first (standard DFS + memo), but too slow and got TLEed. I guess because the question is inherently 2D and bottom-up 2D DP is more appropriate and less prone to missing edge cases. The run time wasn\\'t great, welcome for suggestions to make it faster\\n```\\nclass Solution:\\n    # Try bottom-up DP\\n    # given a m X n board,\\n    # if we cut at i = p: dp[m][n] = dp[p][n] + dp[m-p][n] \\n    # if we cut at j = q: dp[m][n] = dp[m][q] + dp[m][n-q]\\n    # Therefore this is at least N^3 algorithm\\n    # as (k, i-k-1) are symmetric, no need to go through to i. choose the mid point which (i-1) //2 is fine\\n    def sellingWood(self, m: int, n: int, prices: List[List[int]]) -> int:\\n        dp = [[0 for j in range(n)] for i in range(m)]\\n        # First add the price of each little board to the dp matrix\\n        for price in prices:\\n            dp[price[0]-1][price[1]-1] = price[2]\\n        for i in range(m):\\n            for j in range(n):\\n                for k in range(0,(i-1)//2+1):\\n                    dp[i][j] = max(dp[i][j], dp[k][j] + dp[i-k-1][j])\\n                for k in range(0,(j-1)//2+1):\\n                    dp[i][j] = max(dp[i][j], dp[i][k] + dp[i][j-k-1])\\n        return dp[m-1][n-1]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    # Try bottom-up DP\\n    # given a m X n board,\\n    # if we cut at i = p: dp[m][n] = dp[p][n] + dp[m-p][n] \\n    # if we cut at j = q: dp[m][n] = dp[m][q] + dp[m][n-q]\\n    # Therefore this is at least N^3 algorithm\\n    # as (k, i-k-1) are symmetric, no need to go through to i. choose the mid point which (i-1) //2 is fine\\n    def sellingWood(self, m: int, n: int, prices: List[List[int]]) -> int:\\n        dp = [[0 for j in range(n)] for i in range(m)]\\n        # First add the price of each little board to the dp matrix\\n        for price in prices:\\n            dp[price[0]-1][price[1]-1] = price[2]\\n        for i in range(m):\\n            for j in range(n):\\n                for k in range(0,(i-1)//2+1):\\n                    dp[i][j] = max(dp[i][j], dp[k][j] + dp[i-k-1][j])\\n                for k in range(0,(j-1)//2+1):\\n                    dp[i][j] = max(dp[i][j], dp[i][k] + dp[i][j-k-1])\\n        return dp[m-1][n-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2169434,
                "title": "c-dp-top-down-approach",
                "content": "```\\ntypedef long long ll;\\n\\nclass Solution {\\npublic:\\n    \\n    map<pair<ll, ll>, ll> mp;\\n    vector<vector<ll> > dp;\\n    \\n    ll util(ll rows, ll cols){\\n        if(rows==0 || cols==0){\\n            return 0;\\n        }\\n        if(dp[rows][cols]!=-1){\\n            return dp[rows][cols];\\n        }\\n        ll ans=0;\\n        if(mp.count({rows, cols})){\\n            ans=mp[{rows, cols}];\\n        }\\n        for(ll j=1; j<cols; j++){\\n            ans=max(ans, util(rows, j)+util(rows, cols-j));\\n        }\\n        for(ll i=1; i<rows; i++){\\n            ans=max(ans, util(i, cols)+util(rows-i, cols));\\n        }\\n        return dp[rows][cols]=ans;\\n    }\\n    \\n    long long sellingWood(int n, int m, vector<vector<int>>& prices) {\\n        for(auto& itr: prices){\\n            mp[{itr[0], itr[1]}]=itr[2];\\n        }\\n        dp=vector<vector<ll> >(n+1, vector<ll>(m+1, -1));\\n        return util(n, m);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\ntypedef long long ll;\\n\\nclass Solution {\\npublic:\\n    \\n    map<pair<ll, ll>, ll> mp;\\n    vector<vector<ll> > dp;\\n    \\n    ll util(ll rows, ll cols){\\n        if(rows==0 || cols==0){\\n            return 0;\\n        }\\n        if(dp[rows][cols]!=-1){\\n            return dp[rows][cols];\\n        }\\n        ll ans=0;\\n        if(mp.count({rows, cols})){\\n            ans=mp[{rows, cols}];\\n        }\\n        for(ll j=1; j<cols; j++){\\n            ans=max(ans, util(rows, j)+util(rows, cols-j));\\n        }\\n        for(ll i=1; i<rows; i++){\\n            ans=max(ans, util(i, cols)+util(rows-i, cols));\\n        }\\n        return dp[rows][cols]=ans;\\n    }\\n    \\n    long long sellingWood(int n, int m, vector<vector<int>>& prices) {\\n        for(auto& itr: prices){\\n            mp[{itr[0], itr[1]}]=itr[2];\\n        }\\n        dp=vector<vector<ll> >(n+1, vector<ll>(m+1, -1));\\n        return util(n, m);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2168881,
                "title": "video-explanation",
                "content": "[Video Link](https://www.youtube.com/watch?v=-fLTdo1ANkE)\\n\\n",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "[Video Link](https://www.youtube.com/watch?v=-fLTdo1ANkE)\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2168878,
                "title": "python-dp",
                "content": "```\\nclass Solution:\\n  def sellingWood(self, m: int, n: int, prices: List[List[int]]) -> int:\\n    dp = [[0 for w in range(n + 1)] for h in range(m + 1)]\\n    for price in prices:\\n      dp[price[0]][price[1]] = price[2]\\n    for h in range(1, m + 1):  \\n      for w in range(1, n + 1):\\n        max_cost = dp[h][w]\\n        for h_ in range(1, h):\\n          max_cost = max(max_cost, dp[h_][w] + dp[h - h_][w])\\n        for w_ in range(1, w):\\n          max_cost = max(max_cost, dp[h][w_] + dp[h][w - w_])\\n        dp[h][w] = max_cost  \\n    return dp[m][n]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n  def sellingWood(self, m: int, n: int, prices: List[List[int]]) -> int:\\n    dp = [[0 for w in range(n + 1)] for h in range(m + 1)]\\n    for price in prices:\\n      dp[price[0]][price[1]] = price[2]\\n    for h in range(1, m + 1):  \\n      for w in range(1, n + 1):\\n        max_cost = dp[h][w]\\n        for h_ in range(1, h):\\n          max_cost = max(max_cost, dp[h_][w] + dp[h - h_][w])\\n        for w_ in range(1, w):\\n          max_cost = max(max_cost, dp[h][w_] + dp[h][w - w_])\\n        dp[h][w] = max_cost  \\n    return dp[m][n]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2168872,
                "title": "java-bottom-up",
                "content": "dp[i, j] signifies is the max amount you can earn from cutting an i x j piece of wood.\\n\\nFor every (i, j) pair we cut the piece of wood in the following ways:\\n1. from height = 1 to i , with width as j\\n2. from width = 1 to j, with height as i\\n\\n\\n\\ndp[i, j] = Maximum of:\\nwidth cuts: { dp[i][x] + dp[i][x-j] } for all 1 <= x < j\\nheight cuts: { dp[x][j] + dp[i-x][j] } for all 1 <= x < i\\n\\nEdge cases. It is possible that a single 2x2 might cost less than four 1x1 pieces.\\nTherefore, you should check each and every piece from 1x1.\\n\\nThe hashmap makes it faster to lookup prices for base cases where each piece of wood can be directly sold as one unit.\\n```\\nclass Solution {\\n        public long sellingWood(int m, int n, int[][] prices) {\\n        HashMap<Integer, Integer> hm = new HashMap<>();\\n        for(int[] p : prices) {\\n            hm.put(1000*p[0] + p[1], p[2]);\\n        }\\n\\n        long[][] dp = new long[m+1][n+1];\\n\\n        for(int i = 1; i<= m; i++) {\\n            for(int j = 1; j<=n; j++) {\\n                dp[i][j] = hm.get(1000*i + j)==null?0:hm.get(1000*i + j);\\n\\n                for(int x = 1; x<=i; x++) {\\n                    dp[i][j] = Math.max(dp[i][j], dp[x][j] + dp[i-x][j]);\\n                }\\n\\n                for(int x = 1; x<=j; x++) {\\n                    dp[i][j] = Math.max(dp[i][j], dp[i][x] + dp[i][j-x]);\\n                }\\n            }\\n        }\\n\\n\\n        return dp[m][n];\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n        public long sellingWood(int m, int n, int[][] prices) {\\n        HashMap<Integer, Integer> hm = new HashMap<>();\\n        for(int[] p : prices) {\\n            hm.put(1000*p[0] + p[1], p[2]);\\n        }\\n\\n        long[][] dp = new long[m+1][n+1];\\n\\n        for(int i = 1; i<= m; i++) {\\n            for(int j = 1; j<=n; j++) {\\n                dp[i][j] = hm.get(1000*i + j)==null?0:hm.get(1000*i + j);\\n\\n                for(int x = 1; x<=i; x++) {\\n                    dp[i][j] = Math.max(dp[i][j], dp[x][j] + dp[i-x][j]);\\n                }\\n\\n                for(int x = 1; x<=j; x++) {\\n                    dp[i][j] = Math.max(dp[i][j], dp[i][x] + dp[i][j-x]);\\n                }\\n            }\\n        }\\n\\n\\n        return dp[m][n];\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2168762,
                "title": "easy-to-understand-solution-dp",
                "content": "```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    long long sellingWood(int n, int m, vector<vector<int>>& prices) {\\n        ll dp[n+1][m+1];\\n        //dp[i][j] -> best ans for matrix of size i*j\\n        map<pair<int,int>,int> mp;\\n        for(auto vec:prices){\\n            mp[{vec[0],vec[1]}] = vec[2];\\n        }\\n        \\n        for(int i=0;i<=n;i++){\\n            for(int j=0;j<=m;j++){\\n                dp[i][j]=0;\\n            }\\n        }        \\n        \\n        for(int i=1;i<=n;i++){\\n            for(int j=1;j<=m;j++){\\n                if(mp.find({i,j}) != mp.end()) dp[i][j] = mp[{i,j}];\\n                //moving along vertical side\\n                for(int k=0;k<=j;k++){\\n                    dp[i][j] = max(dp[i][j] , dp[i][k]+dp[i][j-k]);\\n                }\\n                //moving along horizantal side\\n                for(int k=0;k<=i;k++){\\n                    dp[i][j] = max(dp[i][j] , dp[k][j]+dp[i-k][j]);\\n                }                \\n            }\\n        }\\n        return dp[n][m];\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    long long sellingWood(int n, int m, vector<vector<int>>& prices) {\\n        ll dp[n+1][m+1];\\n        //dp[i][j] -> best ans for matrix of size i*j\\n        map<pair<int,int>,int> mp;\\n        for(auto vec:prices){\\n            mp[{vec[0],vec[1]}] = vec[2];\\n        }\\n        \\n        for(int i=0;i<=n;i++){\\n            for(int j=0;j<=m;j++){\\n                dp[i][j]=0;\\n            }\\n        }        \\n        \\n        for(int i=1;i<=n;i++){\\n            for(int j=1;j<=m;j++){\\n                if(mp.find({i,j}) != mp.end()) dp[i][j] = mp[{i,j}];\\n                //moving along vertical side\\n                for(int k=0;k<=j;k++){\\n                    dp[i][j] = max(dp[i][j] , dp[i][k]+dp[i][j-k]);\\n                }\\n                //moving along horizantal side\\n                for(int k=0;k<=i;k++){\\n                    dp[i][j] = max(dp[i][j] , dp[k][j]+dp[i-k][j]);\\n                }                \\n            }\\n        }\\n        return dp[n][m];\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2168658,
                "title": "simple-c-memomization-dp-code-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int p[201][201];\\n    long long memo[201][201];\\n    long long helper(int m, int n){\\n        if(m==0 || n==0) return 0;\\n        if(memo[m][n]!=-1) return memo[m][n]; \\n        long long curr = 0;\\n        if(p[m][n]!=-1) curr = p[m][n];\\n        for(int i=1; i<m; i++) curr = max(curr, helper(i, n) + helper(m-i, n));\\n        for(int j=1; j<n; j++) curr = max(curr, helper(m, j) + helper(m, n-j));\\n        return memo[m][n] = curr;\\n    }\\n    \\n    long long sellingWood(int m, int n, vector<vector<int>>& prices) {\\n        for(int i=0; i<=m; i++){\\n            for(int j=0; j<=n; j++) p[i][j] = -1, memo[i][j]=-1;\\n        }\\n        for(vector<int> &i: prices){\\n            p[i[0]][i[1]] = i[2];\\n        }\\n        return helper(m, n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int p[201][201];\\n    long long memo[201][201];\\n    long long helper(int m, int n){\\n        if(m==0 || n==0) return 0;\\n        if(memo[m][n]!=-1) return memo[m][n]; \\n        long long curr = 0;\\n        if(p[m][n]!=-1) curr = p[m][n];\\n        for(int i=1; i<m; i++) curr = max(curr, helper(i, n) + helper(m-i, n));\\n        for(int j=1; j<n; j++) curr = max(curr, helper(m, j) + helper(m, n-j));\\n        return memo[m][n] = curr;\\n    }\\n    \\n    long long sellingWood(int m, int n, vector<vector<int>>& prices) {\\n        for(int i=0; i<=m; i++){\\n            for(int j=0; j<=n; j++) p[i][j] = -1, memo[i][j]=-1;\\n        }\\n        for(vector<int> &i: prices){\\n            p[i[0]][i[1]] = i[2];\\n        }\\n        return helper(m, n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2168587,
                "title": "java-dfs-memo-dp",
                "content": "Time O(mn(m+n))\\nSpace O(mn)\\n```\\nclass Solution {\\n    public long sellingWood(int m, int n, int[][] prices) {\\n        Long[][] cache = new Long[m+1][n+1];\\n        // maxPriceNoCut is best price if no cut for size m * n\\n        int[][] maxPriceNoCut = getMaxPriceNoCut(m, n, prices);\\t\\n        return helper(m, n, maxPriceNoCut, cache);\\n    }\\n\\t// Time O(mn (m+n))\\n    private long helper(int m, int n, int[][] maxPriceNoCut, Long[][] cache){\\n        if(cache[m][n] != null){\\n            return cache[m][n];\\n        }\\n        // Max price if not cut\\n        long max = maxPriceNoCut[m][n]; \\n        // Try horizontal cut\\n        for(int i=1;i<m;i++){\\n            long piece1 = helper(i, n, maxPriceNoCut, cache);\\n            long piece2 = helper(m-i, n, maxPriceNoCut, cache);\\n            max = Math.max(max, piece1 + piece2);\\n        }\\n        // Try vertical  cut\\n        for(int i=1;i<n;i++){\\n            long piece1 = helper(m, i, maxPriceNoCut, cache);\\n            long piece2 = helper(m, n-i, maxPriceNoCut, cache);\\n            max = Math.max(max, piece1 + piece2);\\n        }\\n        return cache[m][n] = max;\\n    }\\n\\t// Time O(mn)\\n    private int[][] getMaxPriceNoCut(int m, int n, int[][] prices){\\n        int[][] maxPriceNoCut = new int[m+1][n+1];\\n        for(int[] p : prices){\\n            maxPriceNoCut[p[0]][p[1]] = p[2];\\n        }\\n        for(int i=1;i<=m;i++){\\n            for(int j=1;j<=n;j++){\\n                maxPriceNoCut[i][j] = Math.max(maxPriceNoCut[i][j], maxPriceNoCut[i-1][j]);\\n                maxPriceNoCut[i][j] = Math.max(maxPriceNoCut[i][j], maxPriceNoCut[i][j-1]);\\n            }\\n        }\\n        return maxPriceNoCut;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public long sellingWood(int m, int n, int[][] prices) {\\n        Long[][] cache = new Long[m+1][n+1];\\n        // maxPriceNoCut is best price if no cut for size m * n\\n        int[][] maxPriceNoCut = getMaxPriceNoCut(m, n, prices);\\t\\n        return helper(m, n, maxPriceNoCut, cache);\\n    }\\n\\t// Time O(mn (m+n))\\n    private long helper(int m, int n, int[][] maxPriceNoCut, Long[][] cache){\\n        if(cache[m][n] != null){\\n            return cache[m][n];\\n        }\\n        // Max price if not cut\\n        long max = maxPriceNoCut[m][n]; \\n        // Try horizontal cut\\n        for(int i=1;i<m;i++){\\n            long piece1 = helper(i, n, maxPriceNoCut, cache);\\n            long piece2 = helper(m-i, n, maxPriceNoCut, cache);\\n            max = Math.max(max, piece1 + piece2);\\n        }\\n        // Try vertical  cut\\n        for(int i=1;i<n;i++){\\n            long piece1 = helper(m, i, maxPriceNoCut, cache);\\n            long piece2 = helper(m, n-i, maxPriceNoCut, cache);\\n            max = Math.max(max, piece1 + piece2);\\n        }\\n        return cache[m][n] = max;\\n    }\\n\\t// Time O(mn)\\n    private int[][] getMaxPriceNoCut(int m, int n, int[][] prices){\\n        int[][] maxPriceNoCut = new int[m+1][n+1];\\n        for(int[] p : prices){\\n            maxPriceNoCut[p[0]][p[1]] = p[2];\\n        }\\n        for(int i=1;i<=m;i++){\\n            for(int j=1;j<=n;j++){\\n                maxPriceNoCut[i][j] = Math.max(maxPriceNoCut[i][j], maxPriceNoCut[i-1][j]);\\n                maxPriceNoCut[i][j] = Math.max(maxPriceNoCut[i][j], maxPriceNoCut[i][j-1]);\\n            }\\n        }\\n        return maxPriceNoCut;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2168543,
                "title": "java-recursive-dp-solution",
                "content": "Why it is giving TLE\\n\\n```\\n\\nclass Solution {\\n    public long sellingWood(int m, int n, int[][] prices) {\\n        long dp[][]=new long[m+1][n+1];\\n        return sol(m,n,prices,dp);\\n    }\\n    long sol(int height,int width,int [][]price,long dp[][]){\\n        if(height<=0 || width<=0){\\n            return 0l;\\n        }\\n        if( dp[height][width] !=0){\\n            return  dp[height][width] ;\\n        }\\n        long max =0;\\n        for(int i=0;i<price.length;i++){\\n            \\n            int hth = price[i][0];\\n            int wth = price[i][1];\\n            int cost = price[i][2];\\n            \\n            long max_cost = 0;\\n            if(height>=hth &&  width>=wth){\\n                 max_cost = cost+ Math.max(sol(height-hth,width,price,dp) + sol(hth,width-wth,price,dp), sol(height-hth,wth,price,dp)+sol(height,width-wth,price,dp));\\n            }\\n           \\n            max =Math.max(max_cost,max);\\n           \\n        }\\n        dp[height][width] = max;\\n        return max;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\n\\nclass Solution {\\n    public long sellingWood(int m, int n, int[][] prices) {\\n        long dp[][]=new long[m+1][n+1];\\n        return sol(m,n,prices,dp);\\n    }\\n    long sol(int height,int width,int [][]price,long dp[][]){\\n        if(height<=0 || width<=0){\\n            return 0l;\\n        }\\n        if( dp[height][width] !=0){\\n            return  dp[height][width] ;\\n        }\\n        long max =0;\\n        for(int i=0;i<price.length;i++){\\n            \\n            int hth = price[i][0];\\n            int wth = price[i][1];\\n            int cost = price[i][2];\\n            \\n            long max_cost = 0;\\n            if(height>=hth &&  width>=wth){\\n                 max_cost = cost+ Math.max(sol(height-hth,width,price,dp) + sol(hth,width-wth,price,dp), sol(height-hth,wth,price,dp)+sol(height,width-wth,price,dp));\\n            }\\n           \\n            max =Math.max(max_cost,max);\\n           \\n        }\\n        dp[height][width] = max;\\n        return max;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2168509,
                "title": "bottom-up-dp-easy-understanding-with-comments-upvote-if-helpful",
                "content": "Please Upvote if Helpful !!!\\n```\\nclass Solution {\\n    long long board[201][201];\\n    \\npublic:\\n    long long sellingWood(int m, int n, vector<vector<int>>& prices) \\n    {\\n        for (auto &p : prices)\\n        {\\n            int r = p[0];\\n            int c = p[1];\\n            int cost = p[2];\\n            board[r][c] = cost;\\n        }\\n        for (int i = 1; i <= m; i++)\\n        {\\n            for (int j = 1; j <= n; j++) \\n            {\\n                // 2 Options: \\n                \\n                // Split the i * j board at row i - k to give 2 boards k * j, (i - k) * j\\n                for (int k = 1; k < i; k++)\\n                    board[i][j] = max(board[i][j], board[k][j] + board[i - k][j]);\\n                \\n                // Split the i * j board at col j - k to give 2 boards i * k, i * (j - k)\\n                for (int k = 1; k < j; k++)\\n                    board[i][j] = max(board[i][j], board[i][k] + board[i][j - k]);\\n            }\\n        }\\n        return board[m][n];\\n    }\\n};\\n```\\nMemoization Method:\\n```\\n/* \\n    Time: O(m*n*max(m,n)+k), k is length of prices\\n    Space: O(m*n+k)\\n    Tag: DP, Memoization, Hashing\\n    Difficulty: M\\n*/\\n\\ntypedef long long ll;\\n\\nclass Solution {\\n    unordered_map<ll, ll> piece;\\n    vector<vector<ll>> t;\\n\\n    ll solve(int m, int n) {\\n        if (m <= 0 || n <= 0) return 0;\\n        if (t[m][n] != -1) return t[m][n];\\n\\n        ll res = 0;\\n\\n        auto it = piece.find(m * 1000001ll + n);\\n        if (it != piece.end()) res = it->second;\\n\\n        for (int i = 1; i < m; i++) {\\n            res = max(res, solve(i, n) + solve(m - i, n));\\n        }\\n        for (int i = 1; i < n; i++) {\\n            res = max(res, solve(m, i) + solve(m, n - i));\\n        }\\n\\n        t[m][n] = res;\\n        return t[m][n];\\n    }\\n\\npublic:\\n    long long sellingWood(int m, int n, vector<vector<int>> &prices) {\\n        for (auto &v : prices) {\\n            piece[v[0] * 1000001ll + v[1]] = v[2];\\n        }\\n        t.resize(m + 1, vector<ll>(n + 1, -1));\\n        return solve(m, n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    long long board[201][201];\\n    \\npublic:\\n    long long sellingWood(int m, int n, vector<vector<int>>& prices) \\n    {\\n        for (auto &p : prices)\\n        {\\n            int r = p[0];\\n            int c = p[1];\\n            int cost = p[2];\\n            board[r][c] = cost;\\n        }\\n        for (int i = 1; i <= m; i++)\\n        {\\n            for (int j = 1; j <= n; j++) \\n            {\\n                // 2 Options: \\n                \\n                // Split the i * j board at row i - k to give 2 boards k * j, (i - k) * j\\n                for (int k = 1; k < i; k++)\\n                    board[i][j] = max(board[i][j], board[k][j] + board[i - k][j]);\\n                \\n                // Split the i * j board at col j - k to give 2 boards i * k, i * (j - k)\\n                for (int k = 1; k < j; k++)\\n                    board[i][j] = max(board[i][j], board[i][k] + board[i][j - k]);\\n            }\\n        }\\n        return board[m][n];\\n    }\\n};\\n```\n```\\n/* \\n    Time: O(m*n*max(m,n)+k), k is length of prices\\n    Space: O(m*n+k)\\n    Tag: DP, Memoization, Hashing\\n    Difficulty: M\\n*/\\n\\ntypedef long long ll;\\n\\nclass Solution {\\n    unordered_map<ll, ll> piece;\\n    vector<vector<ll>> t;\\n\\n    ll solve(int m, int n) {\\n        if (m <= 0 || n <= 0) return 0;\\n        if (t[m][n] != -1) return t[m][n];\\n\\n        ll res = 0;\\n\\n        auto it = piece.find(m * 1000001ll + n);\\n        if (it != piece.end()) res = it->second;\\n\\n        for (int i = 1; i < m; i++) {\\n            res = max(res, solve(i, n) + solve(m - i, n));\\n        }\\n        for (int i = 1; i < n; i++) {\\n            res = max(res, solve(m, i) + solve(m, n - i));\\n        }\\n\\n        t[m][n] = res;\\n        return t[m][n];\\n    }\\n\\npublic:\\n    long long sellingWood(int m, int n, vector<vector<int>> &prices) {\\n        for (auto &v : prices) {\\n            piece[v[0] * 1000001ll + v[1]] = v[2];\\n        }\\n        t.resize(m + 1, vector<ll>(n + 1, -1));\\n        return solve(m, n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2168427,
                "title": "c-just-generate-all-possible-dimensions-and-memoize-it",
                "content": "```\\n/* \\n    Time: O(m*n*(m+n)+k), k is length of prices\\n    Space: O(m*n+k)\\n    Tag: DP, Memoization, Hashing\\n    Difficulty: M\\n*/\\n\\ntypedef long long ll;\\n\\nclass Solution {\\n    unordered_map<ll, ll> piece;\\n    vector<vector<ll>> t;\\n\\n    ll solve(int m, int n) {\\n        if (m <= 0 || n <= 0) return 0;\\n        if (t[m][n] != -1) return t[m][n];\\n\\n        ll res = 0;\\n\\n        auto it = piece.find(m * 1000001ll + n);\\n        if (it != piece.end()) res = it->second;\\n\\n        for (int i = 1; i < m; i++) {\\n            res = max(res, solve(i, n) + solve(m - i, n));\\n        }\\n        for (int i = 1; i < n; i++) {\\n            res = max(res, solve(m, i) + solve(m, n - i));\\n        }\\n\\n        t[m][n] = res;\\n        return t[m][n];\\n    }\\n\\npublic:\\n    long long sellingWood(int m, int n, vector<vector<int>> &prices) {\\n        for (auto &v : prices) {\\n            piece[v[0] * 1000001ll + v[1]] = v[2];\\n        }\\n        t.resize(m + 1, vector<ll>(n + 1, -1));\\n        return solve(m, n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\n/* \\n    Time: O(m*n*(m+n)+k), k is length of prices\\n    Space: O(m*n+k)\\n    Tag: DP, Memoization, Hashing\\n    Difficulty: M\\n*/\\n\\ntypedef long long ll;\\n\\nclass Solution {\\n    unordered_map<ll, ll> piece;\\n    vector<vector<ll>> t;\\n\\n    ll solve(int m, int n) {\\n        if (m <= 0 || n <= 0) return 0;\\n        if (t[m][n] != -1) return t[m][n];\\n\\n        ll res = 0;\\n\\n        auto it = piece.find(m * 1000001ll + n);\\n        if (it != piece.end()) res = it->second;\\n\\n        for (int i = 1; i < m; i++) {\\n            res = max(res, solve(i, n) + solve(m - i, n));\\n        }\\n        for (int i = 1; i < n; i++) {\\n            res = max(res, solve(m, i) + solve(m, n - i));\\n        }\\n\\n        t[m][n] = res;\\n        return t[m][n];\\n    }\\n\\npublic:\\n    long long sellingWood(int m, int n, vector<vector<int>> &prices) {\\n        for (auto &v : prices) {\\n            piece[v[0] * 1000001ll + v[1]] = v[2];\\n        }\\n        t.resize(m + 1, vector<ll>(n + 1, -1));\\n        return solve(m, n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2168406,
                "title": "python-dp",
                "content": "```\\nclass Solution:\\n    def sellingWood(self, m: int, n: int, prices: List[List[int]]) -> int:\\n        pDict = {}\\n        for h,w,p in prices:\\n            pDict[(h,w)] = p\\n        \\n        @lru_cache(None)\\n        def dp(H,W):\\n            ans = 0\\n            if (H,W) in pDict:\\n                ans = pDict[(H,W)]\\n            for i in range(1,H):\\n                ans = max(ans, dp(H-i,W) + dp(i,W))\\n            for j in range(1,W):\\n                ans = max(ans, dp(H,W-j)+dp(H,j))\\n            return ans\\n        return dp(m,n)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def sellingWood(self, m: int, n: int, prices: List[List[int]]) -> int:\\n        pDict = {}\\n        for h,w,p in prices:\\n            pDict[(h,w)] = p\\n        \\n        @lru_cache(None)\\n        def dp(H,W):\\n            ans = 0\\n            if (H,W) in pDict:\\n                ans = pDict[(H,W)]\\n            for i in range(1,H):\\n                ans = max(ans, dp(H-i,W) + dp(i,W))\\n            for j in range(1,W):\\n                ans = max(ans, dp(H,W-j)+dp(H,j))\\n            return ans\\n        return dp(m,n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2168354,
                "title": "passable-but-probably-not-the-intended-solution",
                "content": "Worst time complexity is `O(mn*len(prices))` so it doesn\\'t pass without the `if dp[h][w] < price:` condition, but in practice this clocks at 1128 ms.\\n```\\n# Simplified\\nclass Solution:\\n    def sellingWood(self, m: int, n: int, prices: List[List[int]]) -> int:\\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\\n        prices.sort()\\n        for h, w, price in prices:\\n            if dp[h][w] < price:\\n                for i in range(h, m + 1):\\n                    for j in range(w, n + 1):\\n                        dp[i][j] = max(dp[i][j], price + dp[i - h][j] + dp[h][j - w], price + dp[i][j - w] + dp[i - h][w])\\n        return dp[-1][-1]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n# Simplified\\nclass Solution:\\n    def sellingWood(self, m: int, n: int, prices: List[List[int]]) -> int:\\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\\n        prices.sort()\\n        for h, w, price in prices:\\n            if dp[h][w] < price:\\n                for i in range(h, m + 1):\\n                    for j in range(w, n + 1):\\n                        dp[i][j] = max(dp[i][j], price + dp[i - h][j] + dp[h][j - w], price + dp[i][j - w] + dp[i - h][w])\\n        return dp[-1][-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2168278,
                "title": "simple-dp-solution",
                "content": "Let n = Number of rows and m = Number of columns.\\n\\n\\nStore prices in a matrix of (n * m) where cost[row][col] is maximum price of board with dimension as (row*col) as given in prices array for faster look-up.\\n\\n\\nProblem can now be reduced as \\n\\nT(n, m) = max[cost[n][m] ,  max(T(r, m) + T(n - r, m)), max(T(n, c) + T(n, m-c))]\\n\\nwhere r in [1, n-1] and c in [1, m-1] \\n\\nComplexity :\\n\\nTime : O(n* m* (n+m))\\nSpace : O(n* m)\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    vector<vector<int> > cost;\\n    vector<vector<long long> > dp;\\n    \\n    long long sellingWood(int n, int m, vector<vector<int>>& prices) {\\n        \\n        cost.assign(n+1, vector<int> (m+1, -1));\\n        for(int i=0;i<prices.size();i++) {\\n            cost[prices[i][0]][prices[i][1]] = max(cost[prices[i][0]][prices[i][1]], prices[i][2]);            \\n        }\\n        \\n        dp.assign(n+1, vector<long long> (m+1, -1));\\n                \\n        long long ans = getans(n, m);\\n        return ans;\\n    }\\n    \\n    long long getans(int row, int col) {\\n        if(row == 1 && col == 1) {\\n            if(cost[1][1] != -1)\\n                return cost[1][1];\\n            return 0;\\n        }\\n        \\n        if(dp[row][col] != -1)\\n            return dp[row][col];\\n        \\n        \\n        long long ans = cost[row][col] == -1 ? 0 : cost[row][col];\\n        \\n        for(int i = 1; i < row; i++) {\\n            long long curr = getans(i, col) + getans(row - i, col);\\n            ans = max(ans, curr);\\n        }\\n        \\n        for(int i = 1; i < col; i++) {\\n            long long curr = getans(row, i) + getans(row, col - i);\\n            ans = max(ans, curr);\\n        }\\n        \\n        dp[row][col] = ans;\\n        return ans;\\n    }\\n};\\n\\n```\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    vector<vector<int> > cost;\\n    vector<vector<long long> > dp;\\n    \\n    long long sellingWood(int n, int m, vector<vector<int>>& prices) {\\n        \\n        cost.assign(n+1, vector<int> (m+1, -1));\\n        for(int i=0;i<prices.size();i++) {\\n            cost[prices[i][0]][prices[i][1]] = max(cost[prices[i][0]][prices[i][1]], prices[i][2]);            \\n        }\\n        \\n        dp.assign(n+1, vector<long long> (m+1, -1));\\n                \\n        long long ans = getans(n, m);\\n        return ans;\\n    }\\n    \\n    long long getans(int row, int col) {\\n        if(row == 1 && col == 1) {\\n            if(cost[1][1] != -1)\\n                return cost[1][1];\\n            return 0;\\n        }\\n        \\n        if(dp[row][col] != -1)\\n            return dp[row][col];\\n        \\n        \\n        long long ans = cost[row][col] == -1 ? 0 : cost[row][col];\\n        \\n        for(int i = 1; i < row; i++) {\\n            long long curr = getans(i, col) + getans(row - i, col);\\n            ans = max(ans, curr);\\n        }\\n        \\n        for(int i = 1; i < col; i++) {\\n            long long curr = getans(row, i) + getans(row, col - i);\\n            ans = max(ans, curr);\\n        }\\n        \\n        dp[row][col] = ans;\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2168217,
                "title": "c-bottom-up-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    using ll = long long;\\n    long long sellingWood(int m, int n, vector<vector<int>>& prices) {\\n        unordered_map<int, vector<int>> dict_row;//key: row, value: price idx\\n        unordered_map<int, vector<int>> dict_col;//key: col, value: price idx\\n        for(int i=0;i<prices.size();++i){\\n            const auto& p = prices.at(i);\\n            int h = p[0];\\n            int w = p[1];\\n            dict_row[h].push_back(i);\\n            dict_col[w].push_back(i);\\n        }\\n        vector<vector<ll>> dp(m + 1, vector<ll>(n + 1, 0));\\n        for(int i=0;i<m;++i){\\n            dp[i][0] = 0;\\n        }\\n        for(int j=0;j<n;++j){\\n            dp[0][j] = 0;\\n        }\\n        for(int i=0;i+1<=m;++i){\\n            for(int j=0;j+1<=n;++j){\\n                // dp[i+1][j]\\n                for(int k=1;k<=(i+1)/2;++k){\\n                    dp[i+1][j] = max(dp[i+1][j], dp[k][j] + dp[i+1-k][j]);\\n                }\\n                if(dict_row.count(i + 1) > 0){\\n                    for(auto idx : dict_row[i+1]){\\n                        ll h = i + 1;\\n                        ll w = prices[idx][1];\\n                        ll cash = prices[idx][2];\\n                        for(ll k=1;k * w <= j;++k){\\n                            dp[i+1][j] = max(dp[i+1][j], cash * k + dp[i+1][j - k * w]);\\n                        }\\n                    }\\n                }\\n                \\n                //dp[i][j+1]\\n                for(int k=1;k<=(j+1)/2;++k){\\n                    dp[i][j+1] = max(dp[i][j+1], dp[i][k] + dp[i][j+1-k]);\\n                }\\n                if(dict_col.count(j + 1) > 0){\\n                    for(auto idx : dict_col[j+1]){\\n                        ll h = prices[idx][0];\\n                        ll w = j + 1;\\n                        ll cash = prices[idx][2];\\n                        for(ll k=1;k * h <= i;++k){\\n                            dp[i][j+1] = max(dp[i][j+1], cash * k + dp[i - k * h][j+1]);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        //dp[m][n]\\n        for(int k=1;k<=m/2;++k){\\n            dp[m][n] = max(dp[m][n], dp[k][n] + dp[m-k][n]);\\n        }\\n          if(dict_row.count(m) > 0){\\n                for(auto idx : dict_row[m]){\\n                    ll h = m;\\n                    ll w = prices[idx][1];\\n                    ll cash = prices[idx][2];\\n                    for(ll k=1;k * w <= n;++k){\\n                        dp[m][n] = max(dp[m][n], cash * k + dp[m][n - k * w]);\\n                    }\\n                }\\n            }\\n        \\n        for(int k=1;k<=n/2;++k){\\n            dp[m][n] = max(dp[m][n], dp[m][k] + dp[m][n-k]);\\n        }\\n        if(dict_col.count(n) > 0){\\n            for(auto idx : dict_col[n]){\\n                ll h = prices[idx][0];\\n                ll w = n;\\n                ll cash = prices[idx][2];\\n                for(ll k=1;k * h <= m;++k){\\n                    dp[m][n] = max(dp[m][n], cash * k + dp[m - k * h][n]);\\n                }\\n            }\\n        }\\n        \\n        return dp[m][n];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    using ll = long long;\\n    long long sellingWood(int m, int n, vector<vector<int>>& prices) {\\n        unordered_map<int, vector<int>> dict_row;//key: row, value: price idx\\n        unordered_map<int, vector<int>> dict_col;//key: col, value: price idx\\n        for(int i=0;i<prices.size();++i){\\n            const auto& p = prices.at(i);\\n            int h = p[0];\\n            int w = p[1];\\n            dict_row[h].push_back(i);\\n            dict_col[w].push_back(i);\\n        }\\n        vector<vector<ll>> dp(m + 1, vector<ll>(n + 1, 0));\\n        for(int i=0;i<m;++i){\\n            dp[i][0] = 0;\\n        }\\n        for(int j=0;j<n;++j){\\n            dp[0][j] = 0;\\n        }\\n        for(int i=0;i+1<=m;++i){\\n            for(int j=0;j+1<=n;++j){\\n                // dp[i+1][j]\\n                for(int k=1;k<=(i+1)/2;++k){\\n                    dp[i+1][j] = max(dp[i+1][j], dp[k][j] + dp[i+1-k][j]);\\n                }\\n                if(dict_row.count(i + 1) > 0){\\n                    for(auto idx : dict_row[i+1]){\\n                        ll h = i + 1;\\n                        ll w = prices[idx][1];\\n                        ll cash = prices[idx][2];\\n                        for(ll k=1;k * w <= j;++k){\\n                            dp[i+1][j] = max(dp[i+1][j], cash * k + dp[i+1][j - k * w]);\\n                        }\\n                    }\\n                }\\n                \\n                //dp[i][j+1]\\n                for(int k=1;k<=(j+1)/2;++k){\\n                    dp[i][j+1] = max(dp[i][j+1], dp[i][k] + dp[i][j+1-k]);\\n                }\\n                if(dict_col.count(j + 1) > 0){\\n                    for(auto idx : dict_col[j+1]){\\n                        ll h = prices[idx][0];\\n                        ll w = j + 1;\\n                        ll cash = prices[idx][2];\\n                        for(ll k=1;k * h <= i;++k){\\n                            dp[i][j+1] = max(dp[i][j+1], cash * k + dp[i - k * h][j+1]);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        //dp[m][n]\\n        for(int k=1;k<=m/2;++k){\\n            dp[m][n] = max(dp[m][n], dp[k][n] + dp[m-k][n]);\\n        }\\n          if(dict_row.count(m) > 0){\\n                for(auto idx : dict_row[m]){\\n                    ll h = m;\\n                    ll w = prices[idx][1];\\n                    ll cash = prices[idx][2];\\n                    for(ll k=1;k * w <= n;++k){\\n                        dp[m][n] = max(dp[m][n], cash * k + dp[m][n - k * w]);\\n                    }\\n                }\\n            }\\n        \\n        for(int k=1;k<=n/2;++k){\\n            dp[m][n] = max(dp[m][n], dp[m][k] + dp[m][n-k]);\\n        }\\n        if(dict_col.count(n) > 0){\\n            for(auto idx : dict_col[n]){\\n                ll h = prices[idx][0];\\n                ll w = n;\\n                ll cash = prices[idx][2];\\n                for(ll k=1;k * h <= m;++k){\\n                    dp[m][n] = max(dp[m][n], cash * k + dp[m - k * h][n]);\\n                }\\n            }\\n        }\\n        \\n        return dp[m][n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1864570,
                "content": [
                    {
                        "username": "worsecoder",
                        "content": "The critical step to avoid TLE is to avoid symmetric split. In other words, if you have already calculated the price of splitting a wood (h, w) into (h, w1) and (h, w - w1), you should not calculate it splitting into (h, w - w1) and (h, w1) again. By avoiding this the total cost is halved."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "was able to do this question , felt so good !!"
                    },
                    {
                        "username": "Finesse",
                        "content": "Initially I tried to cut out every possible `prices` size from the given wood slab, get 2 smaller pieces after the cut and solve the problem recursively for the smaller pieces. My solution exceeded the time limit, because the number of `prices` is very high.\n\nA simple idea helped me to improve the performance.  Don't check each `prices` size, check each possible horizontal and vertical cut, there are only 200 of them for the biggest piece of wood. "
                    },
                    {
                        "username": "Finesse",
                        "content": "It\\'s a 2D 0\\u2013\\u221E knapsack problem. Extra hard to solve, but the solution is extra satisfying."
                    }
                ]
            },
            {
                "id": 1856574,
                "content": [
                    {
                        "username": "worsecoder",
                        "content": "The critical step to avoid TLE is to avoid symmetric split. In other words, if you have already calculated the price of splitting a wood (h, w) into (h, w1) and (h, w - w1), you should not calculate it splitting into (h, w - w1) and (h, w1) again. By avoiding this the total cost is halved."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "was able to do this question , felt so good !!"
                    },
                    {
                        "username": "Finesse",
                        "content": "Initially I tried to cut out every possible `prices` size from the given wood slab, get 2 smaller pieces after the cut and solve the problem recursively for the smaller pieces. My solution exceeded the time limit, because the number of `prices` is very high.\n\nA simple idea helped me to improve the performance.  Don't check each `prices` size, check each possible horizontal and vertical cut, there are only 200 of them for the biggest piece of wood. "
                    },
                    {
                        "username": "Finesse",
                        "content": "It\\'s a 2D 0\\u2013\\u221E knapsack problem. Extra hard to solve, but the solution is extra satisfying."
                    }
                ]
            },
            {
                "id": 1787167,
                "content": [
                    {
                        "username": "worsecoder",
                        "content": "The critical step to avoid TLE is to avoid symmetric split. In other words, if you have already calculated the price of splitting a wood (h, w) into (h, w1) and (h, w - w1), you should not calculate it splitting into (h, w - w1) and (h, w1) again. By avoiding this the total cost is halved."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "was able to do this question , felt so good !!"
                    },
                    {
                        "username": "Finesse",
                        "content": "Initially I tried to cut out every possible `prices` size from the given wood slab, get 2 smaller pieces after the cut and solve the problem recursively for the smaller pieces. My solution exceeded the time limit, because the number of `prices` is very high.\n\nA simple idea helped me to improve the performance.  Don't check each `prices` size, check each possible horizontal and vertical cut, there are only 200 of them for the biggest piece of wood. "
                    },
                    {
                        "username": "Finesse",
                        "content": "It\\'s a 2D 0\\u2013\\u221E knapsack problem. Extra hard to solve, but the solution is extra satisfying."
                    }
                ]
            },
            {
                "id": 1787175,
                "content": [
                    {
                        "username": "worsecoder",
                        "content": "The critical step to avoid TLE is to avoid symmetric split. In other words, if you have already calculated the price of splitting a wood (h, w) into (h, w1) and (h, w - w1), you should not calculate it splitting into (h, w - w1) and (h, w1) again. By avoiding this the total cost is halved."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "was able to do this question , felt so good !!"
                    },
                    {
                        "username": "Finesse",
                        "content": "Initially I tried to cut out every possible `prices` size from the given wood slab, get 2 smaller pieces after the cut and solve the problem recursively for the smaller pieces. My solution exceeded the time limit, because the number of `prices` is very high.\n\nA simple idea helped me to improve the performance.  Don't check each `prices` size, check each possible horizontal and vertical cut, there are only 200 of them for the biggest piece of wood. "
                    },
                    {
                        "username": "Finesse",
                        "content": "It\\'s a 2D 0\\u2013\\u221E knapsack problem. Extra hard to solve, but the solution is extra satisfying."
                    }
                ]
            }
        ]
    },
    {
        "title": "Spiral Matrix IV",
        "question_content": "<p>You are given two integers <code>m</code> and <code>n</code>, which represent the dimensions of a matrix.</p>\n\n<p>You are also given the <code>head</code> of a linked list of integers.</p>\n\n<p>Generate an <code>m x n</code> matrix that contains the integers in the linked list presented in <strong>spiral</strong> order <strong>(clockwise)</strong>, starting from the <strong>top-left</strong> of the matrix. If there are remaining empty spaces, fill them with <code>-1</code>.</p>\n\n<p>Return <em>the generated matrix</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/05/09/ex1new.jpg\" style=\"width: 240px; height: 150px;\" />\n<pre>\n<strong>Input:</strong> m = 3, n = 5, head = [3,0,2,6,8,1,7,9,4,2,5,5,0]\n<strong>Output:</strong> [[3,0,2,6,8],[5,0,-1,-1,1],[5,2,4,9,7]]\n<strong>Explanation:</strong> The diagram above shows how the values are printed in the matrix.\nNote that the remaining spaces in the matrix are filled with -1.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/05/11/ex2.jpg\" style=\"width: 221px; height: 60px;\" />\n<pre>\n<strong>Input:</strong> m = 1, n = 4, head = [0,1,2]\n<strong>Output:</strong> [[0,1,2,-1]]\n<strong>Explanation:</strong> The diagram above shows how the values are printed from left to right in the matrix.\nThe last space in the matrix is set to -1.</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= m, n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= m * n &lt;= 10<sup>5</sup></code></li>\n\t<li>The number of nodes in the list is in the range <code>[1, m * n]</code>.</li>\n\t<li><code>0 &lt;= Node.val &lt;= 1000</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 2229856,
                "title": "roomba",
                "content": "We use directions (`d`) to right->down->left->up and then repeat. When we bump into an edge - we change the direction.\\n\\nNote that an edge is also a cell that we\\'ve already filled (not equal to `-1`). This makes it a bit easier, otherwise we could use an offset, incrementing it after each full turn.\\n\\n**C++**\\n```cpp    \\nvector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n    int i = 0, j = 0, cur_d = 0, d[5] = {0, 1, 0, -1, 0};\\n    vector<vector<int>> res(m, vector<int>(n, -1));\\n    for (; head != nullptr; head = head->next) {\\n        res[i][j] = head->val;\\n        int ni = i + d[cur_d], nj = j + d[cur_d + 1];\\n        if (min(ni, nj) < 0 || ni >= m || nj >= n || res[ni][nj] != -1)\\n            cur_d = (cur_d + 1) % 4;\\n        i += d[cur_d];\\n        j += d[cur_d + 1];\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp    \\nvector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n    int i = 0, j = 0, cur_d = 0, d[5] = {0, 1, 0, -1, 0};\\n    vector<vector<int>> res(m, vector<int>(n, -1));\\n    for (; head != nullptr; head = head->next) {\\n        res[i][j] = head->val;\\n        int ni = i + d[cur_d], nj = j + d[cur_d + 1];\\n        if (min(ni, nj) < 0 || ni >= m || nj >= n || res[ni][nj] != -1)\\n            cur_d = (cur_d + 1) % 4;\\n        i += d[cur_d];\\n        j += d[cur_d + 1];\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2230122,
                "title": "c-easy-understanding-o-n-solution",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int n, int m, ListNode* head) \\n    {\\n\\t\\t// Create a matrix of n x m with values filled with -1.\\n        vector<vector<int>> spiral(n, vector<int>(m, -1));\\n        int i = 0, j = 0;\\n\\t\\t// Traverse the matrix in spiral form, and update with the values present in the head list.\\n\\t\\t// If head reacher NULL pointer break out from the loop, and return the spiral matrix.\\n        while (head != NULL)\\n        {\\n            if (j < m)\\n            {\\n                while (head != NULL && j < m && spiral[i][j] == -1)\\n                {\\n                    spiral[i][j] = head->val;\\n                    head = head->next;\\n                    j++;\\n                }\\n                if (head == NULL)\\n                    break;\\n                i++;\\n                j--;\\n            }\\n            if (i < n)\\n            {\\n                while (head != NULL && i < n && spiral[i][j] == -1)\\n                {\\n                    spiral[i][j] = head->val;\\n                    head = head->next;\\n                    i++;\\n                }\\n                i--;\\n                j--;\\n            }\\n            if (j >= 0)\\n            {\\n                while (head != NULL && j >= 0 && spiral[i][j] == -1)\\n                {\\n                    spiral[i][j] = head->val;\\n                    head = head->next;\\n                    j--;\\n                }\\n                j++;\\n                i--;\\n            }\\n            if (i >= 0)\\n            {\\n                while (head != NULL && i >= 0 && spiral[i][j] == -1)\\n                {\\n                    spiral[i][j] = head->val;\\n                    head = head->next;\\n                    i--;\\n                }\\n                i++;\\n                j++;\\n            }\\n            n--;\\n            m++;\\n        }\\n\\t\\t// Rest values are itself -1.\\n        return spiral;\\n    }\\n};\\n```\\nHope you like it.",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List",
                    "Matrix"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int n, int m, ListNode* head) \\n    {\\n\\t\\t// Create a matrix of n x m with values filled with -1.\\n        vector<vector<int>> spiral(n, vector<int>(m, -1));\\n        int i = 0, j = 0;\\n\\t\\t// Traverse the matrix in spiral form, and update with the values present in the head list.\\n\\t\\t// If head reacher NULL pointer break out from the loop, and return the spiral matrix.\\n        while (head != NULL)\\n        {\\n            if (j < m)\\n            {\\n                while (head != NULL && j < m && spiral[i][j] == -1)\\n                {\\n                    spiral[i][j] = head->val;\\n                    head = head->next;\\n                    j++;\\n                }\\n                if (head == NULL)\\n                    break;\\n                i++;\\n                j--;\\n            }\\n            if (i < n)\\n            {\\n                while (head != NULL && i < n && spiral[i][j] == -1)\\n                {\\n                    spiral[i][j] = head->val;\\n                    head = head->next;\\n                    i++;\\n                }\\n                i--;\\n                j--;\\n            }\\n            if (j >= 0)\\n            {\\n                while (head != NULL && j >= 0 && spiral[i][j] == -1)\\n                {\\n                    spiral[i][j] = head->val;\\n                    head = head->next;\\n                    j--;\\n                }\\n                j++;\\n                i--;\\n            }\\n            if (i >= 0)\\n            {\\n                while (head != NULL && i >= 0 && spiral[i][j] == -1)\\n                {\\n                    spiral[i][j] = head->val;\\n                    head = head->next;\\n                    i--;\\n                }\\n                i++;\\n                j++;\\n            }\\n            n--;\\n            m++;\\n        }\\n\\t\\t// Rest values are itself -1.\\n        return spiral;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2229918,
                "title": "python-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def spiralMatrix(self, m: int, n: int, head: Optional[ListNode]) -> List[List[int]]:\\n        num = m * n\\n        res = [[-1 for j in range(n)] for i in range(m)]\\n        x, y = 0, 0\\n        dx, dy = 1, 0\\n        while head:\\n            res[y][x] = head.val\\n            if x + dx < 0 or x + dx >= n or y + dy < 0 or y + dy >= m or res[y+dy][x+dx] != -1:\\n                dx, dy = -dy, dx\\n            x = x + dx\\n            y = y + dy\\n            head = head.next\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def spiralMatrix(self, m: int, n: int, head: Optional[ListNode]) -> List[List[int]]:\\n        num = m * n\\n        res = [[-1 for j in range(n)] for i in range(m)]\\n        x, y = 0, 0\\n        dx, dy = 1, 0\\n        while head:\\n            res[y][x] = head.val\\n            if x + dx < 0 or x + dx >= n or y + dy < 0 or y + dy >= m or res[y+dy][x+dx] != -1:\\n                dx, dy = -dy, dx\\n            x = x + dx\\n            y = y + dy\\n            head = head.next\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2231052,
                "title": "python-concise-code-easy-to-understand",
                "content": "The idea to take from this, is how to rotate the direction in a concise way.\\n\\nInitially we start by adding 1 to the column, and 0 to the row (going right)\\n\\nIf we hit a wall/edge, we must swap the direction. The trick is to swap with: \\n\\n`xr, xc = xc, -xr`\\n\\nLet `xr` be the term we add to our `r` row in every move.\\nLet `xc` be the term we add to our `c` column in every move.\\n\\n```\\nclass Solution:\\n    def spiralMatrix(self, m: int, n: int, head: Optional[ListNode]) -> List[List[int]]:\\n        r, c = 0, 0\\n        xr, xc = 0, 1\\n        \\n        matrix = [[-1 for _ in range(n)] for _ in range(m)]\\n        while head:\\n            matrix[r][c] = head.val\\n            \\n            # Conditions to swap the direction\\n            if r + xr < 0 or r + xr >= m or c + xc < 0 or c + xc >= n or matrix[r+xr][c+xc] != -1:\\n                xr, xc = xc, -xr\\n            \\n            r += xr\\n            c += xc\\n            head = head.next\\n        \\n        return matrix\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def spiralMatrix(self, m: int, n: int, head: Optional[ListNode]) -> List[List[int]]:\\n        r, c = 0, 0\\n        xr, xc = 0, 1\\n        \\n        matrix = [[-1 for _ in range(n)] for _ in range(m)]\\n        while head:\\n            matrix[r][c] = head.val\\n            \\n            # Conditions to swap the direction\\n            if r + xr < 0 or r + xr >= m or c + xc < 0 or c + xc >= n or matrix[r+xr][c+xc] != -1:\\n                xr, xc = xc, -xr\\n            \\n            r += xr\\n            c += xc\\n            head = head.next\\n        \\n        return matrix\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3205664,
                "title": "spiral-matrix-i-ii-iii-iv-solutions",
                "content": "# Explaination\\n- This is a very simple and easy to understand solution. I have traversed RIGHT and incremented TOP, then traverse DOWN and decrement RIGHT, then I traverse LEFT and decrement BOTTOM, and finally I have traversed UP and increment LEFT.\\n\\n- The only tricky part is that when I traverse left or up I have to check whether the row or col still exists to prevent duplicates. \\nAny comments greatly appreciated.\\n\\n# Complexity\\n- Time Complexity: O(m*n)\\n- Space Complexity: O(1)\\n\\n# Spiral Matrix I\\n```\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        vector<int> v;\\n        if (matrix.size() == 0) \\n            return v;\\n        \\n        int left = 0, right = matrix[0].size() - 1, top = 0, bottom = matrix.size()- 1;\\n        \\n        while (left <= right && top <= bottom) {\\n            for (int i = left; i <= right; i++) {\\n                v.push_back(matrix[top][i]);\\n            }\\n            top++;\\n            \\n            for (int i = top; i <= bottom; i++) {\\n                v.push_back(matrix[i][right]);\\n            }\\n            right--;\\n            \\n            for (int i = right; top <= bottom && i >= left; i--) {\\n                v.push_back(matrix[bottom][i]);\\n            }\\n            bottom--;\\n            \\n            for (int i = bottom; left <= right && i >= top; i--) {\\n                v.push_back(matrix[i][left]);\\n            }\\n            left++;\\n        }\\n        return v;\\n    }\\n};\\n```\\n# Spiral Matrix II\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> matrix(n, vector<int> (n, 0));\\n        \\n        int left = 0, right = matrix[0].size() - 1, top = 0, bottom = matrix.size()- 1;\\n        int count = 1;\\n        while (left <= right && top <= bottom) {\\n            for (int i = left; i <= right; i++) {\\n                matrix[top][i] = count;\\n                count++;\\n            }\\n            top++;\\n            \\n            for (int i = top; i <= bottom; i++) {\\n                matrix[i][right] = count;\\n                count++;\\n            }\\n            right--;\\n            \\n            for (int i = right; top <= bottom && i >= left; i--) {\\n                matrix[bottom][i] = count;\\n                count++;\\n            }\\n            bottom--;\\n            \\n            for (int i = bottom; left <= right && i >= top; i--) {\\n                matrix[i][left] = count;\\n                count++;\\n            }\\n            left++;\\n        }\\n        return matrix;\\n    }\\n};\\n```\\n# Spiral Matrix III\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        vector<vector<int>> matrix;\\n        int count = 0, step = 1;\\n        \\n        while(count < rows*cols){\\n\\n            for (int i=0; i<step; i++){\\n                if(rStart >= 0 and rStart < rows and cStart >= 0 and cStart < cols){\\n                    matrix.push_back({rStart, cStart});\\n                    count++;\\n                }\\n                cStart++;\\n            }\\n\\n            for (int i=0; i<step; i++){\\n                if(rStart >= 0 and rStart < rows and cStart >= 0 and cStart < cols){\\n                    matrix.push_back({rStart, cStart});\\n                    count++;\\n                }\\n                rStart++;\\n            }\\n            step++;\\n\\n            for (int i=0; i<step; i++){\\n                if(rStart >= 0 and rStart < rows and cStart >= 0 and cStart < cols){\\n                    matrix.push_back({rStart, cStart});\\n                    count++;\\n                }\\n                cStart--;\\n            }\\n\\n            for (int i=0; i<step; i++){\\n                if(rStart >= 0 and rStart < rows and cStart >= 0 and cStart < cols){\\n                    matrix.push_back({rStart, cStart});\\n                    count++;\\n                }\\n                rStart--;\\n            }\\n            step++;\\n        }\\n        return matrix;\\n    }\\n};\\n```\\n# Sprial Matrix IV\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        vector<vector<int>> matrix(m, vector<int> (n, -1));\\n        int left = 0, right = n-1, top = 0, bottom = m-1;\\n        while(left<=right and top<=bottom){\\n            for(int i = left; i<=right; i++){\\n                if(head){\\n                    matrix[top][i] = head->val;\\n                    head = head->next;\\n                }\\n            }\\n            top++;\\n            for(int i = top; i<=bottom; i++){\\n                if(head){\\n                    matrix[i][right] = head->val;\\n                    head = head->next;\\n                }\\n            }\\n            right--;\\n            for(int i = right; top<=bottom && i>=left; i--){ \\n                if(head){\\n                    matrix[bottom][i] = head->val;\\n                    head = head->next;\\n                }\\n            }   \\n            bottom--;\\n            for(int i = bottom; left<=right && i>=top; i--){\\n                if(head){\\n                    matrix[i][left] = head->val;\\n                    head = head->next;\\n                }\\n            }\\n            left++;\\n        }\\n        return matrix;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        vector<int> v;\\n        if (matrix.size() == 0) \\n            return v;\\n        \\n        int left = 0, right = matrix[0].size() - 1, top = 0, bottom = matrix.size()- 1;\\n        \\n        while (left <= right && top <= bottom) {\\n            for (int i = left; i <= right; i++) {\\n                v.push_back(matrix[top][i]);\\n            }\\n            top++;\\n            \\n            for (int i = top; i <= bottom; i++) {\\n                v.push_back(matrix[i][right]);\\n            }\\n            right--;\\n            \\n            for (int i = right; top <= bottom && i >= left; i--) {\\n                v.push_back(matrix[bottom][i]);\\n            }\\n            bottom--;\\n            \\n            for (int i = bottom; left <= right && i >= top; i--) {\\n                v.push_back(matrix[i][left]);\\n            }\\n            left++;\\n        }\\n        return v;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> matrix(n, vector<int> (n, 0));\\n        \\n        int left = 0, right = matrix[0].size() - 1, top = 0, bottom = matrix.size()- 1;\\n        int count = 1;\\n        while (left <= right && top <= bottom) {\\n            for (int i = left; i <= right; i++) {\\n                matrix[top][i] = count;\\n                count++;\\n            }\\n            top++;\\n            \\n            for (int i = top; i <= bottom; i++) {\\n                matrix[i][right] = count;\\n                count++;\\n            }\\n            right--;\\n            \\n            for (int i = right; top <= bottom && i >= left; i--) {\\n                matrix[bottom][i] = count;\\n                count++;\\n            }\\n            bottom--;\\n            \\n            for (int i = bottom; left <= right && i >= top; i--) {\\n                matrix[i][left] = count;\\n                count++;\\n            }\\n            left++;\\n        }\\n        return matrix;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        vector<vector<int>> matrix;\\n        int count = 0, step = 1;\\n        \\n        while(count < rows*cols){\\n\\n            for (int i=0; i<step; i++){\\n                if(rStart >= 0 and rStart < rows and cStart >= 0 and cStart < cols){\\n                    matrix.push_back({rStart, cStart});\\n                    count++;\\n                }\\n                cStart++;\\n            }\\n\\n            for (int i=0; i<step; i++){\\n                if(rStart >= 0 and rStart < rows and cStart >= 0 and cStart < cols){\\n                    matrix.push_back({rStart, cStart});\\n                    count++;\\n                }\\n                rStart++;\\n            }\\n            step++;\\n\\n            for (int i=0; i<step; i++){\\n                if(rStart >= 0 and rStart < rows and cStart >= 0 and cStart < cols){\\n                    matrix.push_back({rStart, cStart});\\n                    count++;\\n                }\\n                cStart--;\\n            }\\n\\n            for (int i=0; i<step; i++){\\n                if(rStart >= 0 and rStart < rows and cStart >= 0 and cStart < cols){\\n                    matrix.push_back({rStart, cStart});\\n                    count++;\\n                }\\n                rStart--;\\n            }\\n            step++;\\n        }\\n        return matrix;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        vector<vector<int>> matrix(m, vector<int> (n, -1));\\n        int left = 0, right = n-1, top = 0, bottom = m-1;\\n        while(left<=right and top<=bottom){\\n            for(int i = left; i<=right; i++){\\n                if(head){\\n                    matrix[top][i] = head->val;\\n                    head = head->next;\\n                }\\n            }\\n            top++;\\n            for(int i = top; i<=bottom; i++){\\n                if(head){\\n                    matrix[i][right] = head->val;\\n                    head = head->next;\\n                }\\n            }\\n            right--;\\n            for(int i = right; top<=bottom && i>=left; i--){ \\n                if(head){\\n                    matrix[bottom][i] = head->val;\\n                    head = head->next;\\n                }\\n            }   \\n            bottom--;\\n            for(int i = bottom; left<=right && i>=top; i--){\\n                if(head){\\n                    matrix[i][left] = head->val;\\n                    head = head->next;\\n                }\\n            }\\n            left++;\\n        }\\n        return matrix;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2309660,
                "title": "java-solution-runtime-8-ms-faster-than-96-36-of-java-online-submissions-for-spiral-matrix-iv",
                "content": "```\\nclass Solution {\\n    public int[][] spiralMatrix(int m, int n, ListNode head) {\\n        int[][] ans=new int[m][n];\\n        for(int[] arr:ans){\\n            Arrays.fill(arr,-1);\\n        }\\n        \\n        int rowBegin=0;\\n        int rowEnd=m-1;\\n        int columnBegin=0;\\n        int columnEnd=n-1;\\n        ListNode cur=head;\\n        \\n      \\n        while(rowBegin<=rowEnd && columnBegin<=columnEnd && cur!=null){\\n            \\n            for(int i=columnBegin;i<=columnEnd && cur!=null;i++){\\n                if(cur!=null){\\n                    ans[rowBegin][i]=cur.val;\\n                }\\n               \\n                    cur=cur.next;\\n                \\n                \\n            }\\n            rowBegin++;\\n            for(int i=rowBegin;i<=rowEnd && cur!=null;i++){\\n               if(cur!=null){\\n                ans[i][columnEnd]=cur.val;\\n               }\\n                \\n                    cur=cur.next;\\n                \\n\\n            }\\n            columnEnd--;\\n            if(rowBegin<=rowEnd){\\n                for(int i=columnEnd;i>=columnBegin && cur!=null;i--){\\n                if(cur!=null){\\n                ans[rowEnd][i]=cur.val;\\n                }\\n                 \\n                    cur=cur.next;\\n                \\n\\n            }\\n           \\n            }\\n             rowEnd--;\\n            if(columnBegin<=columnEnd){\\n                for(int i=rowEnd;i>=rowBegin && cur!=null;i--){\\n                  if(cur!=null){\\n                ans[i][columnBegin]=cur.val;\\n                  }\\n                 \\n                    cur=cur.next;\\n                \\n\\n            }\\n            \\n            }\\n            columnBegin++;\\n           \\n        }\\n        return ans;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] spiralMatrix(int m, int n, ListNode head) {\\n        int[][] ans=new int[m][n];\\n        for(int[] arr:ans){\\n            Arrays.fill(arr,-1);\\n        }\\n        \\n        int rowBegin=0;\\n        int rowEnd=m-1;\\n        int columnBegin=0;\\n        int columnEnd=n-1;\\n        ListNode cur=head;\\n        \\n      \\n        while(rowBegin<=rowEnd && columnBegin<=columnEnd && cur!=null){\\n            \\n            for(int i=columnBegin;i<=columnEnd && cur!=null;i++){\\n                if(cur!=null){\\n                    ans[rowBegin][i]=cur.val;\\n                }\\n               \\n                    cur=cur.next;\\n                \\n                \\n            }\\n            rowBegin++;\\n            for(int i=rowBegin;i<=rowEnd && cur!=null;i++){\\n               if(cur!=null){\\n                ans[i][columnEnd]=cur.val;\\n               }\\n                \\n                    cur=cur.next;\\n                \\n\\n            }\\n            columnEnd--;\\n            if(rowBegin<=rowEnd){\\n                for(int i=columnEnd;i>=columnBegin && cur!=null;i--){\\n                if(cur!=null){\\n                ans[rowEnd][i]=cur.val;\\n                }\\n                 \\n                    cur=cur.next;\\n                \\n\\n            }\\n           \\n            }\\n             rowEnd--;\\n            if(columnBegin<=columnEnd){\\n                for(int i=rowEnd;i>=rowBegin && cur!=null;i--){\\n                  if(cur!=null){\\n                ans[i][columnBegin]=cur.val;\\n                  }\\n                 \\n                    cur=cur.next;\\n                \\n\\n            }\\n            \\n            }\\n            columnBegin++;\\n           \\n        }\\n        return ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2230062,
                "title": "c-easy-to-uderstand-solution-simple-concept",
                "content": "![image](https://assets.leetcode.com/users/images/3fddd4d2-8830-49bb-847e-da22c49a2992_1656821239.6477444.png)\\n\\n**T->O(m * n) && S->O(m * n)**\\n\\n\\tclass Solution {\\n\\t\\tpublic:\\n\\t\\t\\tvector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n\\t\\t\\t\\tvector<vector<int>> mat(m,vector<int>(n,-1));\\n\\t\\t\\t\\tListNode* curr=head;\\n\\t\\t\\t\\tint minr=0;\\n\\t\\t\\t\\tint minc=0;\\n\\t\\t\\t\\tint maxr=m-1;\\n\\t\\t\\t\\tint maxc=n-1;\\n\\t\\t\\t\\twhile(curr!=NULL){\\n\\t\\t\\t\\t\\tfor(int j=minc;j<=maxc && curr!=NULL;j++){\\n\\t\\t\\t\\t\\t\\tint i=minr;\\n\\t\\t\\t\\t\\t\\tmat[i][j]=curr->val;\\n\\t\\t\\t\\t\\t\\tcurr=curr->next;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tminr++;\\n\\t\\t\\t\\t\\tfor(int i=minr;i<=maxr && curr!=NULL;i++){\\n\\t\\t\\t\\t\\t\\tint j=maxc;\\n\\t\\t\\t\\t\\t\\tmat[i][j]=curr->val;\\n\\t\\t\\t\\t\\t\\tcurr=curr->next;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tmaxc--;\\n\\t\\t\\t\\t\\tfor(int j=maxc;j>=minc && curr!=NULL;j--){\\n\\t\\t\\t\\t\\t\\tint i=maxr;\\n\\t\\t\\t\\t\\t\\tmat[i][j]=curr->val;\\n\\t\\t\\t\\t\\t\\tcurr=curr->next;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tmaxr--;\\n\\t\\t\\t\\t\\tfor(int i=maxr;i>=minr && curr!=NULL;i--){\\n\\t\\t\\t\\t\\t\\tint j=minc;\\n\\t\\t\\t\\t\\t\\tmat[i][j]=curr->val;\\n\\t\\t\\t\\t\\t\\tcurr=curr->next;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tminc++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn mat;\\n\\t\\t\\t}\\n\\t\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List",
                    "Matrix"
                ],
                "code": "class Solution {\\n\\t\\tpublic:\\n\\t\\t\\tvector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n\\t\\t\\t\\tvector<vector<int>> mat(m,vector<int>(n,-1));\\n\\t\\t\\t\\tListNode* curr=head;\\n\\t\\t\\t\\tint minr=0;\\n\\t\\t\\t\\tint minc=0;\\n\\t\\t\\t\\tint maxr=m-1;\\n\\t\\t\\t\\tint maxc=n-1;\\n\\t\\t\\t\\twhile(curr!=NULL){\\n\\t\\t\\t\\t\\tfor(int j=minc;j<=maxc && curr!=NULL;j++){\\n\\t\\t\\t\\t\\t\\tint i=minr;\\n\\t\\t\\t\\t\\t\\tmat[i][j]=curr->val;\\n\\t\\t\\t\\t\\t\\tcurr=curr->next;\\n\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2232024,
                "title": "java-iterative",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public int[][] spiralMatrix(int m, int n, ListNode head) {\\n        int res[][] = new int[m][n];\\n        for(int x[] : res) Arrays.fill(x,-1);\\n        ListNode temp=head;\\n        int startrow=0;\\n        int startcol=0;\\n        int endrow=m-1;\\n        int endcol=n-1;\\n        while(temp!=null){\\n            \\n            for(int i=startcol;i<=endcol;i++){\\n                if(temp==null) break;\\n                res[startrow][i]=temp.val;\\n                temp=temp.next;\\n            }\\n            \\n             for(int i=startrow+1;i<=endrow;i++){\\n                 if(temp==null) break;\\n                res[i][endcol]=temp.val;\\n                temp=temp.next;\\n            }\\n            \\n             for(int i=endcol-1;i>=startcol;i--){\\n                 if(temp==null) break;\\n                res[endrow][i]=temp.val;\\n                temp=temp.next;\\n            }\\n            \\n             for(int i=endrow-1;i>startrow;i--){\\n                 if(temp==null) break;\\n                res[i][startcol]=temp.val;\\n                temp=temp.next;\\n            }\\n            startrow++;\\n            startcol++;\\n            endrow--;\\n            endcol--;\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public int[][] spiralMatrix(int m, int n, ListNode head) {\\n        int res[][] = new int[m][n];\\n        for(int x[] : res) Arrays.fill(x,-1);\\n        ListNode temp=head;\\n        int startrow=0;\\n        int startcol=0;\\n        int endrow=m-1;\\n        int endcol=n-1;\\n        while(temp!=null){\\n            \\n            for(int i=startcol;i<=endcol;i++){\\n                if(temp==null) break;\\n                res[startrow][i]=temp.val;\\n                temp=temp.next;\\n            }\\n            \\n             for(int i=startrow+1;i<=endrow;i++){\\n                 if(temp==null) break;\\n                res[i][endcol]=temp.val;\\n                temp=temp.next;\\n            }\\n            \\n             for(int i=endcol-1;i>=startcol;i--){\\n                 if(temp==null) break;\\n                res[endrow][i]=temp.val;\\n                temp=temp.next;\\n            }\\n            \\n             for(int i=endrow-1;i>startrow;i--){\\n                 if(temp==null) break;\\n                res[i][startcol]=temp.val;\\n                temp=temp.next;\\n            }\\n            startrow++;\\n            startcol++;\\n            endrow--;\\n            endcol--;\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2229981,
                "title": "c-simulation",
                "content": "**Algorithm**\\nProgressively fill the matrix. The key is clockwise rotation (di, dj) = (dj, -di). \\n\\n**Complexity**\\n* O(M*N) time \\n* O(M*N) space \\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        ListNode* node = head; \\n        vector<vector<int>> ans(m, vector<int>(n, -1)); \\n        for (int i = 0, j = 0, di = 0, dj = 1; node; node = node->next, i+=di, j+=dj) {\\n            ans[i][j] = node->val; \\n            if (i+di < 0 || i+di == m || j+dj < 0 || j+dj == n || ans[i+di][j+dj] != -1) \\n                tie(di, dj) = make_tuple(dj, -di); \\n        }\\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        ListNode* node = head; \\n        vector<vector<int>> ans(m, vector<int>(n, -1)); \\n        for (int i = 0, j = 0, di = 0, dj = 1; node; node = node->next, i+=di, j+=dj) {\\n            ans[i][j] = node->val; \\n            if (i+di < 0 || i+di == m || j+dj < 0 || j+dj == n || ans[i+di][j+dj] != -1) \\n                tie(di, dj) = make_tuple(dj, -di); \\n        }\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2240061,
                "title": "java-o-m-n-11ms",
                "content": "only move to valid points\\n>Runtime: 11 ms, faster than 91.80% of Java online submissions for Spiral Matrix IV.\\nMemory Usage: 60.2 MB, less than 98.42% of Java online submissions for Spiral Matrix IV.\\n```java\\npublic int[][] spiralMatrix(int m, int n, ListNode head) {\\n        int[][] answer = new int[m][n];\\n        for (int[] ints : answer) {\\n            Arrays.fill(ints, -1);\\n        }\\n\\n        int y = 0;\\n        int x = 0;\\n        int[][] dirs = new int[][]{{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\\n        int curDir = 0;\\n        int cnt = 0;\\n        while (head != null) {\\n            answer[y][x] = head.val;\\n\\n            if (++cnt == m * n) {\\n                return answer;\\n            }\\n\\n            int[] dir = dirs[curDir];\\n            int nextY = y + dir[0];\\n            int nextX = x + dir[1];\\n            if (nextY < 0 || nextY >= m || nextX < 0 || nextX >= n || answer[nextY][nextX] != -1) {\\n                curDir = (curDir + 1) % 4;\\n                nextY = y + dirs[curDir][0];\\n                nextX = x + dirs[curDir][1];\\n            }\\n            y = nextY;\\n            x = nextX;\\n            head = head.next;\\n        }\\n        return answer;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\npublic int[][] spiralMatrix(int m, int n, ListNode head) {\\n        int[][] answer = new int[m][n];\\n        for (int[] ints : answer) {\\n            Arrays.fill(ints, -1);\\n        }\\n\\n        int y = 0;\\n        int x = 0;\\n        int[][] dirs = new int[][]{{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\\n        int curDir = 0;\\n        int cnt = 0;\\n        while (head != null) {\\n            answer[y][x] = head.val;\\n\\n            if (++cnt == m * n) {\\n                return answer;\\n            }\\n\\n            int[] dir = dirs[curDir];\\n            int nextY = y + dir[0];\\n            int nextX = x + dir[1];\\n            if (nextY < 0 || nextY >= m || nextX < 0 || nextX >= n || answer[nextY][nextX] != -1) {\\n                curDir = (curDir + 1) % 4;\\n                nextY = y + dirs[curDir][0];\\n                nextX = x + dirs[curDir][1];\\n            }\\n            y = nextY;\\n            x = nextX;\\n            head = head.next;\\n        }\\n        return answer;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2230747,
                "title": "c-explained",
                "content": "**UPVOTE IF HELPFuuL**\\n\\nA long question but just implementation.\\n\\n* Firstly create a **2-D** array with all values initialised to```-1``` so if linked list is incomplete, we will not update remaining index of array as they will already be ```-1```.\\n\\n* With a while loop put the value from linked list at index ```[x][y]``` -> ```res[x][y] = head -> val;```\\n\\n**HOW TO UPDATE VALUES OF X,Y**\\nVariables:\\n* **r1** -> represents TOPMOST row that has been filled\\n* **r2** -> represents BOTTOM row that has been filled\\n* **c1** -> represents LEFTMOST column that has been filled\\n* **c2** -> represents RIGHTMOST column that has been filled\\n\\n* **left** -> true if we are moving in LEFT direction.\\n* **right** ->true if we are moving in RIGHT direction.\\n* **down** -> true if we are moving in DOWN direction.\\n* If all three are **false** we are moing in upward direction.\\n![image](https://assets.leetcode.com/users/images/a5639faf-ea4a-416f-925f-1ab9120b55ee_1656828246.234272.png)\\n\\n* While moving right -> keep increasing **Y** -> when at last point, increase **r1**.\\n* While moving down -> keep increasing **X** -> when at last point . decrease **c2**.\\n* While moving left -> keep decreasing **Y** -> when at last point, decrease **r2**.\\n* While moving upward -> keep decreasing **X** -> when at last point, increase **c1**.\\n\\nALSO REMEMBER TO CHANGE ```bool left, right, down``` accordingly while reaching last point in any direction.\\n\\n\\n**UPVOTE IF HELPFuuL**\\n```\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        \\n        vector<vector<int>> res;\\n        for (int i=0; i<m; i++){\\n            vector<int> k;\\n            for (int j=0; j<n; j++){\\n                k.push_back(-1);\\n            }\\n            res.push_back(k);\\n        }\\n        int r1=-1, r2=m, c1=-1, c2=n;\\n        int x=0, y=0;\\n        bool right=true, down=false, left=false;\\n        \\n        while (head){\\n            \\n            res[x][y] = head -> val;\\n            head = head -> next;\\n            \\n            if (right){\\n                if (y+1 == c2){\\n                    x++;\\n                    right = false;\\n                    down = true;\\n                    r1++;\\n                }else{\\n                    y++;\\n                }\\n            }\\n            else if(down){\\n                if (x+1==r2){\\n                    y--;\\n                    down = false;\\n                    left = true;\\n                    c2--;\\n                }else{\\n                    x++;\\n                }\\n            }\\n            else if(left){\\n                if (y-1==c1){\\n                    x--;\\n                    left = false;\\n                    r2--;\\n                }else{\\n                    y--;\\n                }\\n            }\\n            else{\\n                if (x-1==r1){\\n                    y++;\\n                    right = true;\\n                    c1++;\\n                }else{\\n                    x--;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/ec5c3001-558f-46ef-8319-b4897070a294_1656827865.452618.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List",
                    "Interactive"
                ],
                "code": "```-1```\n```-1```\n```[x][y]```\n```res[x][y] = head -> val;```\n```bool left, right, down```\n```\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        \\n        vector<vector<int>> res;\\n        for (int i=0; i<m; i++){\\n            vector<int> k;\\n            for (int j=0; j<n; j++){\\n                k.push_back(-1);\\n            }\\n            res.push_back(k);\\n        }\\n        int r1=-1, r2=m, c1=-1, c2=n;\\n        int x=0, y=0;\\n        bool right=true, down=false, left=false;\\n        \\n        while (head){\\n            \\n            res[x][y] = head -> val;\\n            head = head -> next;\\n            \\n            if (right){\\n                if (y+1 == c2){\\n                    x++;\\n                    right = false;\\n                    down = true;\\n                    r1++;\\n                }else{\\n                    y++;\\n                }\\n            }\\n            else if(down){\\n                if (x+1==r2){\\n                    y--;\\n                    down = false;\\n                    left = true;\\n                    c2--;\\n                }else{\\n                    x++;\\n                }\\n            }\\n            else if(left){\\n                if (y-1==c1){\\n                    x--;\\n                    left = false;\\n                    r2--;\\n                }else{\\n                    y--;\\n                }\\n            }\\n            else{\\n                if (x-1==r1){\\n                    y++;\\n                    right = true;\\n                    c1++;\\n                }else{\\n                    x--;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2229969,
                "title": "c-optimal-solution",
                "content": "``` /**\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        ListNode *current=head;\\n        vector <vector <int> > ans (m , vector <int> (n,-1)); \\n        vector <vector <bool >> seen (m, vector <bool> (n ,false));\\n        vector <int> dr ={0,1,0,-1};\\n        vector <int> dc ={1,0,-1,0};\\n        int x=0;\\n        int y=0;\\n        int di=0;\\n        int i=0;\\n        for(i=0 ; i < m*n; i++ ){\\n            if(current !=NULL){\\n            ans[x][y]=current->val;\\n            seen[x][y]=true;\\n            int newX=x+dr[di];\\n            int newY=y+dc[di];\\n            if( 0 <= newX && newX < m  && 0 <=newY && newY < n && !seen[newX][newY]){\\n                x=newX;\\n                y=newY;\\n            }\\n            else{\\n                di=(di+1)%4;\\n                x+=dr[di];\\n                y+=dc[di];\\n            }\\n                current=current->next;\\n            }\\n            else{\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Array",
                    "Linked List",
                    "Matrix"
                ],
                "code": "class Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        ListNode *current=head;\\n        vector <vector <int> > ans (m , vector <int> (n,-1)); \\n        vector <vector <bool >> seen (m, vector <bool> (n ,false));\\n        vector <int> dr ={0,1,0,-1}",
                "codeTag": "Java"
            },
            {
                "id": 2229879,
                "title": "python-100-explainted-simple-direction-change-use-this-template-for-matrix-chain-1-2-3-4",
                "content": "Step 1 : Fill the matrix with -1\\nStep 2 : Take x=0 and y=0 (start coordinate)\\nStep 3 : Take dx=1 and dy=0 (two more variables for changing x and y)...as we are moving in east initially that\\'s why dx=1 and dy=0.\\nStep 4 : When ever index overflow or value in grid already filled change the direction that is , dx=-dy and dy = dx.\\n\\n\\n**Note: you can use this template in every spiral matrix question**\\n\\n\\tdef spiralMatrix(self, m: int, n: int, head: Optional[ListNode]) -> List[List[int]]: \\n\\t\\n\\t\\t\\tmat=[[-1 for i in range(n)] for j in range(m)] # Initilize the Grid\\n\\t\\t\\tdx,dy,x,y=1,0,0,0 # change in x , change in y , Initilize X , Initilize Y\\n\\t\\t\\tfor i in range(n*m):\\n\\t\\t\\t\\tif x+dx<0 or x+dx>n-1 or y+dy>m-1 or y+dy<0 or mat[y+dy][x+dx]!=-1:  # Boundary Condition\\n\\t\\t\\t\\t\\tdx,dy=-dy,dx  # Change direction\\n\\t\\t\\t\\t# write the code for adding value to grid (This part will change according to question)\\n\\t\\t\\t\\tx,y=x+dx,y+dy # move Forward\\n\\n\\t\\t\\treturn mat\\n\\t\\t\\t\\n## CODE : \\n\\n\\tdef spiralMatrix(self, m: int, n: int, head: Optional[ListNode]) -> List[List[int]]:\\n\\t\\t\\tmat=[[-1 for i in range(n)] for j in range(m)]\\n\\t\\t\\tdx,dy,x,y=1,0,0,0\\n\\t\\t\\tfor i in range(n*m):\\n\\t\\t\\t\\tif x+dx<0 or x+dx>n-1 or y+dy>m-1 or y+dy<0 or mat[y+dy][x+dx]!=-1:\\n\\t\\t\\t\\t\\tdx,dy=-dy,dx  \\n\\t\\t\\t\\tmat[y][x]=head.val\\n\\t\\t\\t\\tif head.next==None:\\n\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\thead=head.next\\n\\t\\t\\t\\tx,y=x+dx,y+dy\\n\\n\\t\\t\\treturn mat\\n\\t\\t\\t\\n\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "Step 1 : Fill the matrix with -1\\nStep 2 : Take x=0 and y=0 (start coordinate)\\nStep 3 : Take dx=1 and dy=0 (two more variables for changing x and y)...as we are moving in east initially that\\'s why dx=1 and dy=0.\\nStep 4 : When ever index overflow or value in grid already filled change the direction that is , dx=-dy and dy = dx.\\n\\n\\n**Note: you can use this template in every spiral matrix question**\\n\\n\\tdef spiralMatrix(self, m: int, n: int, head: Optional[ListNode]) -> List[List[int]]: \\n\\t\\n\\t\\t\\tmat=[[-1 for i in range(n)] for j in range(m)] # Initilize the Grid\\n\\t\\t\\tdx,dy,x,y=1,0,0,0 # change in x , change in y , Initilize X , Initilize Y\\n\\t\\t\\tfor i in range(n*m):\\n\\t\\t\\t\\tif x+dx<0 or x+dx>n-1 or y+dy>m-1 or y+dy<0 or mat[y+dy][x+dx]!=-1:  # Boundary Condition\\n\\t\\t\\t\\t\\tdx,dy=-dy,dx  # Change direction\\n\\t\\t\\t\\t# write the code for adding value to grid (This part will change according to question)\\n\\t\\t\\t\\tx,y=x+dx,y+dy # move Forward\\n\\n\\t\\t\\treturn mat\\n\\t\\t\\t\\n## CODE : \\n\\n\\tdef spiralMatrix(self, m: int, n: int, head: Optional[ListNode]) -> List[List[int]]:\\n\\t\\t\\tmat=[[-1 for i in range(n)] for j in range(m)]\\n\\t\\t\\tdx,dy,x,y=1,0,0,0\\n\\t\\t\\tfor i in range(n*m):\\n\\t\\t\\t\\tif x+dx<0 or x+dx>n-1 or y+dy>m-1 or y+dy<0 or mat[y+dy][x+dx]!=-1:\\n\\t\\t\\t\\t\\tdx,dy=-dy,dx  \\n\\t\\t\\t\\tmat[y][x]=head.val\\n\\t\\t\\t\\tif head.next==None:\\n\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\thead=head.next\\n\\t\\t\\t\\tx,y=x+dx,y+dy\\n\\n\\t\\t\\treturn mat\\n\\t\\t\\t\\n\\n",
                "codeTag": "Python3"
            },
            {
                "id": 2230153,
                "title": "c-easy-understanding",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int n, int m, ListNode* head) {\\n        vector<vector<int>> ans(n, vector<int> (m, -1));\\n        ListNode* tmp = head;\\n        int t = 0, s = 0;\\n        int b = n-1, a = m-1;\\n        while(1)\\n        {\\n            for(int i=s;i<=a;i++)\\n            {\\n                ans[t][i] = tmp->val;\\n                tmp = tmp->next;\\n                if(tmp == NULL)\\n                    break;\\n            }\\n            t++;\\n            if(tmp == NULL)\\n                break;\\n            \\n            for(int i = t;i<=b;i++)\\n            {\\n                ans[i][a] = tmp->val;\\n                tmp = tmp->next;\\n                if(tmp == NULL)\\n                    break;\\n            }\\n            a--;\\n            if(tmp == NULL)\\n                break;\\n            \\n            for(int i = a;i>=s;i--)\\n            {\\n                ans[b][i] = tmp->val;\\n                tmp = tmp->next;\\n                if(tmp == NULL)\\n                    break;\\n            }\\n            b--;\\n            if(tmp == NULL)\\n                break;\\n            \\n            for(int i = b;i>=t;i--)\\n            {\\n                ans[i][s] = tmp->val;\\n                tmp = tmp->next;\\n                if(tmp == NULL)\\n                    break;\\n            }\\n            s++;\\n            if(tmp == NULL)\\n                break;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int n, int m, ListNode* head) {\\n        vector<vector<int>> ans(n, vector<int> (m, -1));\\n        ListNode* tmp = head;\\n        int t = 0, s = 0;\\n        int b = n-1, a = m-1;\\n        while(1)\\n        {\\n            for(int i=s;i<=a;i++)\\n            {\\n                ans[t][i] = tmp->val;\\n                tmp = tmp->next;\\n                if(tmp == NULL)\\n                    break;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2252226,
                "title": "python-10-lines-linear-algebra-t-m-88-89",
                "content": "```\\nclass Solution:\\n    def spiralMatrix(self, m: int, n: int, head: ListNode) -> List[List[int]]:\\n\\n                        # The plan here is to start at cell (0,0) and move in the direction\\n                        # of <0,1>. At each step, we first peek whether we are still in the grid\\n                        # and whether the cell is unvisited (that is, still -1):\\n                        #\\n                        #      \\u2022 If so, we mark the cell with head.val, move head to the next node,\\n                        #        and then peek ahead in the same direction to another cell\\n                        #\\n                        #      \\u2022 If not, we turn right\\n                        #\\n                        # We continue with this process until we hit the end of the linked list.\\n                        # \\n                        # Because we always turn right, we don\\'t need a tuple of directions. From\\n                        # linear algebra, we know that turning right from a current direction\\n                        # <a,b> gives the new direction <b,-a>.\\n        \\n        \\n        ans = [[-1] * n for _ in range(m)]                          # initialize stuff\\n        ans[0][0], head = head.val, head.next\\n        r, c, dr, dc, R, C = 0, 0, 0, 1, range(m), range(n)\\n\\n        while head:\\n            if r+dr in R and c+dc in C and ans[r+dr][c+dc] == -1:   # check whether in grid and whether unvisited\\n                r+= dr ;  c+= dc                                        # if so, assign val and keep going\\n                ans[r][c], head = head.val, head.next\\n            else:                                                       # else, turn right\\n                dr, dc = dc, -dr\\n                \\n        return ans",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def spiralMatrix(self, m: int, n: int, head: ListNode) -> List[List[int]]:\\n\\n                        # The plan here is to start at cell (0,0) and move in the direction\\n                        # of <0,1>. At each step, we first peek whether we are still in the grid\\n                        # and whether the cell is unvisited (that is, still -1):\\n                        #\\n                        #      \\u2022 If so, we mark the cell with head.val, move head to the next node,\\n                        #        and then peek ahead in the same direction to another cell\\n                        #\\n                        #      \\u2022 If not, we turn right\\n                        #\\n                        # We continue with this process until we hit the end of the linked list.\\n                        # \\n                        # Because we always turn right, we don\\'t need a tuple of directions. From\\n                        # linear algebra, we know that turning right from a current direction\\n                        # <a,b> gives the new direction <b,-a>.\\n        \\n        \\n        ans = [[-1] * n for _ in range(m)]                          # initialize stuff\\n        ans[0][0], head = head.val, head.next\\n        r, c, dr, dc, R, C = 0, 0, 0, 1, range(m), range(n)\\n\\n        while head:\\n            if r+dr in R and c+dc in C and ans[r+dr][c+dc] == -1:   # check whether in grid and whether unvisited\\n                r+= dr ;  c+= dc                                        # if so, assign val and keep going\\n                ans[r][c], head = head.val, head.next\\n            else:                                                       # else, turn right\\n                dr, dc = dc, -dr\\n                \\n        return ans",
                "codeTag": "Java"
            },
            {
                "id": 2230428,
                "title": "c-best-approach-easy-tc-o-m-n-sc-o-1",
                "content": "\\'\\'\\'\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        vector<vector<int>>ans(m,vector<int>(n,-1));\\n        \\n        int top=0,down=m-1;\\n        int left=0,right=n-1;\\n        int dir=0,i;\\n        \\n        while(top<=down &&  left<=right && head!=NULL){\\n            if(dir==0){\\n                i=left;\\n                while(head!=NULL && i<=right){\\n                    ans[top][i]=head->val;\\n                    head=head->next;\\n                    i++;\\n                }\\n                top++;\\n            }\\n            else if(dir==1){\\n                i=top;\\n                while(head!=NULL && i<=down){\\n                    ans[i][right]=head->val;\\n                    head=head->next;\\n                    i++;\\n                }\\n                right--;\\n            }\\n            else if(dir==2){\\n                i=right;\\n                while(head!=NULL && i>=left){\\n                    ans[down][i]=head->val;\\n                    head=head->next;\\n                    i--;\\n                }\\n                down--;\\n            }\\n            else if(dir==3){\\n                i=down;\\n                while(head!=NULL && i>=top){\\n                    ans[i][left]=head->val;\\n                    head=head->next;\\n                    i--;\\n                }\\n                left++;\\n            }\\n            dir=(dir+1)%4;\\n        }\\n        return ans;\\n    }\\n};\\n\\'\\'\\'",
                "solutionTags": [
                    "C",
                    "Matrix"
                ],
                "code": "class Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        vector<vector<int>>ans(m,vector<int>(n,-1));\\n        \\n        int top=0,down=m-1;\\n        int left=0,right=n-1;\\n        int dir=0,i;\\n        \\n        while(top<=down &&  left<=right && head!=NULL){\\n            if(dir==0){\\n                i=left;\\n                while(head!=NULL && i<=right){\\n                    ans[top][i]=head->val;\\n                    head=head->next;\\n                    i++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2229846,
                "title": "easy-to-understand-cpp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        vector<vector<int>> ans(m,vector<int>(n,-1));\\n        int i = 0, j = 0;\\n\\t    bool flag=false;\\n        while(i <= (m-1)/2 && j <= (n-1)/2) {\\n            for(int y=j; y<n-j; y++){\\n                if(head==NULL){\\n                    flag=true;\\n                    break;\\n                }\\n                ans[i][y]=head->val;\\n                head=head->next;\\n            }\\n                \\n\\n            for(int x=i+1; x<m-i; x++){\\n                if(head==NULL){\\n                    flag=true;\\n                    break;\\n                }\\n                ans[x][n-1-j]=head->val;\\n                head=head->next;\\n            }\\n                \\n\\n            for(int y=n-1-j-1; y>=j && i!=m-1-i; y--){\\n                if(head==NULL){\\n                    flag=true;\\n                    break;\\n                }\\n                ans[m-1-i][y]=head->val;\\n                head=head->next;\\n                \\n            }\\n                \\n\\n            for(int x=m-1-i-1; x>i && j!=n-1-j; x--){\\n                if(head==NULL){\\n                    flag=true;\\n                    break;\\n                }\\n                ans[x][j]=head->val;\\n                head=head->next;\\n            }\\n                \\n            if(flag)\\n                break;\\n            i++;\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Interactive"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        vector<vector<int>> ans(m,vector<int>(n,-1));\\n        int i = 0, j = 0;\\n\\t    bool flag=false;\\n        while(i <= (m-1)/2 && j <= (n-1)/2) {\\n            for(int y=j; y<n-j; y++){\\n                if(head==NULL){\\n                    flag=true;\\n                    break;\\n                }\\n                ans[i][y]=head->val;\\n                head=head->next;\\n            }\\n                \\n\\n            for(int x=i+1; x<m-i; x++){\\n                if(head==NULL){\\n                    flag=true;\\n                    break;\\n                }\\n                ans[x][n-1-j]=head->val;\\n                head=head->next;\\n            }\\n                \\n\\n            for(int y=n-1-j-1; y>=j && i!=m-1-i; y--){\\n                if(head==NULL){\\n                    flag=true;\\n                    break;\\n                }\\n                ans[m-1-i][y]=head->val;\\n                head=head->next;\\n                \\n            }\\n                \\n\\n            for(int x=m-1-i-1; x>i && j!=n-1-j; x--){\\n                if(head==NULL){\\n                    flag=true;\\n                    break;\\n                }\\n                ans[x][j]=head->val;\\n                head=head->next;\\n            }\\n                \\n            if(flag)\\n                break;\\n            i++;\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2238487,
                "title": "javascript-very-easy-to-understand-o-n-solution",
                "content": "```\\n\\n var spiralMatrix = function(m, n, head) {\\n    var matrix = new Array(m).fill().map(()=> new Array(n).fill(-1))\\n    var row=0, col=0;\\n    var direction=\"right\";\\n    while(head)\\n        {\\n            matrix[row][col]=head.val;\\n            if(direction==\"right\")\\n                {\\n                    if(col+1 == n || matrix[row][col+1] != -1)\\n                        {\\n                            direction=\"down\"\\n                            row++;\\n                        }\\n                    else\\n                        col++\\n                }\\n            else if(direction==\"down\")\\n                {\\n                    if(row+1 == m || matrix[row+1][col] != -1)\\n                        {\\n                            direction=\"left\"\\n                            col--;\\n                        }\\n                    else\\n                        row++\\n                }\\n            else if(direction==\"left\")\\n                {\\n                    if(col == 0 || matrix[row][col-1] != -1)\\n                        {\\n                            direction=\"up\"\\n                            row--;\\n                        }\\n                    else\\n                        col--\\n                }\\n            else if(direction==\"up\")\\n                {\\n                    if(row == 0 || matrix[row-1][col] != -1)\\n                        {\\n                            direction=\"right\"\\n                            col++;\\n                        }\\n                    else\\n                        row--\\n                }\\n            head = head.next;\\n        }\\n    return matrix;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\n var spiralMatrix = function(m, n, head) {\\n    var matrix = new Array(m).fill().map(()=> new Array(n).fill(-1))\\n    var row=0, col=0;\\n    var direction=\"right\";\\n    while(head)\\n        {\\n            matrix[row][col]=head.val;\\n            if(direction==\"right\")\\n                {\\n                    if(col+1 == n || matrix[row][col+1] != -1)\\n                        {\\n                            direction=\"down\"\\n                            row++;\\n                        }\\n                    else\\n                        col++\\n                }\\n            else if(direction==\"down\")\\n                {\\n                    if(row+1 == m || matrix[row+1][col] != -1)\\n                        {\\n                            direction=\"left\"\\n                            col--;\\n                        }\\n                    else\\n                        row++\\n                }\\n            else if(direction==\"left\")\\n                {\\n                    if(col == 0 || matrix[row][col-1] != -1)\\n                        {\\n                            direction=\"up\"\\n                            row--;\\n                        }\\n                    else\\n                        col--\\n                }\\n            else if(direction==\"up\")\\n                {\\n                    if(row == 0 || matrix[row-1][col] != -1)\\n                        {\\n                            direction=\"right\"\\n                            col++;\\n                        }\\n                    else\\n                        row--\\n                }\\n            head = head.next;\\n        }\\n    return matrix;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2230791,
                "title": "java-simple-solution-o-m-n",
                "content": "```\\n\\nclass Solution {\\n    public int[][] spiralMatrix(int m, int n, ListNode head) {\\n        int[][] result = new int[m][n];\\n        int top =0;\\n        int bottom = m-1;\\n        int left =0; \\n        int right = n-1;\\n        int len = m*n;\\n        int count =0;\\n        int val=0;\\n        while(count<len){\\n            //Top\\n            for(int i = left; i<=right && count<len; i++){\\n                if(head !=null) {\\n                    val = head.val;\\n                    head=head.next;\\n                } else val=-1;\\n                result[top][i] = val;\\n                count++;\\n            }\\n            top++;\\n            // right\\n            for(int i = top; i<=bottom && count<len; i++){\\n                if(head !=null) {\\n                    val = head.val;\\n                    head=head.next;\\n                } else val=-1;\\n                result[i][right] = val;\\n                count++;\\n            }\\n            right--;\\n            // bottom\\n            for(int i = right; i>=left && count<len; i--){\\n                if(head !=null) {\\n                    val = head.val;\\n                    head=head.next;\\n                } else val=-1;\\n                result[bottom][i] = val;\\n                count++;\\n            }\\n            bottom--;\\n           // left\\n            for(int i = bottom; i>=top && count<len; i--){\\n                if(head !=null) {\\n                    val = head.val;\\n                    head=head.next;\\n                } else val=-1;\\n                result[i][left] = val;\\n                count++;\\n            }\\n            left++;            \\n        }\\n        \\n        return result;\\n    }\\n```\\n",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\n    public int[][] spiralMatrix(int m, int n, ListNode head) {\\n        int[][] result = new int[m][n];\\n        int top =0;\\n        int bottom = m-1;\\n        int left =0; \\n        int right = n-1;\\n        int len = m*n;\\n        int count =0;\\n        int val=0;\\n        while(count<len){\\n            //Top\\n            for(int i = left; i<=right && count<len; i++){\\n                if(head !=null) {\\n                    val = head.val;\\n                    head=head.next;\\n                } else val=-1;\\n                result[top][i] = val;\\n                count++;\\n            }\\n            top++;\\n            // right\\n            for(int i = top; i<=bottom && count<len; i++){\\n                if(head !=null) {\\n                    val = head.val;\\n                    head=head.next;\\n                } else val=-1;\\n                result[i][right] = val;\\n                count++;\\n            }\\n            right--;\\n            // bottom\\n            for(int i = right; i>=left && count<len; i--){\\n                if(head !=null) {\\n                    val = head.val;\\n                    head=head.next;\\n                } else val=-1;\\n                result[bottom][i] = val;\\n                count++;\\n            }\\n            bottom--;\\n           // left\\n            for(int i = bottom; i>=top && count<len; i--){\\n                if(head !=null) {\\n                    val = head.val;\\n                    head=head.next;\\n                } else val=-1;\\n                result[i][left] = val;\\n                count++;\\n            }\\n            left++;            \\n        }\\n        \\n        return result;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2230456,
                "title": "easy-java-solution-well-commented",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public int[][] spiralMatrix(int m, int n, ListNode head) \\n    {\\n        int[][] matrix = new int[m][n];\\n        \\n        //Initialize the matrix with -1\\n        //After linked list is completed, rest matrix cells will be -1\\n        for(int[] row : matrix)\\n            Arrays.fill(row , -1);\\n        \\n        //Base/Edge case\\n        if(head == null)\\n            return matrix;\\n        \\n        \\n        int rowBegin = 0;\\n        int rowEnd = matrix.length-1;\\n        int colBegin = 0;\\n        int colEnd = matrix[0].length - 1;\\n        \\n        ListNode current = head;\\n        \\n        while (rowBegin <= rowEnd && colBegin <= colEnd) {\\n            \\n            // Traverse Right\\n            for (int j = colBegin; j <= colEnd; j ++) {\\n                //If we have linked list node values, then only fill it in matrix cell else do nothing\\n                if(current != null){                            \\n                    matrix[rowBegin][j] = current.val;\\n                    current = current.next;\\n                }\\n            }\\n            rowBegin++;\\n            \\n            // Traverse Down\\n            for (int j = rowBegin; j <= rowEnd; j ++) {\\n                if(current != null){\\n                    matrix[j][colEnd] = current.val;\\n                    current = current.next;\\n                }\\n            }\\n            colEnd--;\\n            \\n            if (rowBegin <= rowEnd) {\\n                // Traverse Left\\n                for (int j = colEnd; j >= colBegin; j --) {\\n                    if(current != null){\\n                        matrix[rowEnd][j] = current.val;\\n                        current = current.next;\\n                    }\\n                }\\n            }\\n            rowEnd--;\\n            \\n            if (colBegin <= colEnd) {\\n                // Traver Up\\n                for (int j = rowEnd; j >= rowBegin; j --) {\\n                    if(current != null){\\n                        matrix[j][colBegin] = current.val;\\n                        current = current.next;\\n                    }\\n                }\\n            }\\n            colBegin ++;\\n        }\\n        return matrix;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List",
                    "Matrix"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public int[][] spiralMatrix(int m, int n, ListNode head) \\n    {\\n        int[][] matrix = new int[m][n];\\n        \\n        //Initialize the matrix with -1\\n        //After linked list is completed, rest matrix cells will be -1\\n        for(int[] row : matrix)\\n            Arrays.fill(row , -1);\\n        \\n        //Base/Edge case\\n        if(head == null)\\n            return matrix;\\n        \\n        \\n        int rowBegin = 0;\\n        int rowEnd = matrix.length-1;\\n        int colBegin = 0;\\n        int colEnd = matrix[0].length - 1;\\n        \\n        ListNode current = head;\\n        \\n        while (rowBegin <= rowEnd && colBegin <= colEnd) {\\n            \\n            // Traverse Right\\n            for (int j = colBegin; j <= colEnd; j ++) {\\n                //If we have linked list node values, then only fill it in matrix cell else do nothing\\n                if(current != null){                            \\n                    matrix[rowBegin][j] = current.val;\\n                    current = current.next;\\n                }\\n            }\\n            rowBegin++;\\n            \\n            // Traverse Down\\n            for (int j = rowBegin; j <= rowEnd; j ++) {\\n                if(current != null){\\n                    matrix[j][colEnd] = current.val;\\n                    current = current.next;\\n                }\\n            }\\n            colEnd--;\\n            \\n            if (rowBegin <= rowEnd) {\\n                // Traverse Left\\n                for (int j = colEnd; j >= colBegin; j --) {\\n                    if(current != null){\\n                        matrix[rowEnd][j] = current.val;\\n                        current = current.next;\\n                    }\\n                }\\n            }\\n            rowEnd--;\\n            \\n            if (colBegin <= colEnd) {\\n                // Traver Up\\n                for (int j = rowEnd; j >= rowBegin; j --) {\\n                    if(current != null){\\n                        matrix[j][colBegin] = current.val;\\n                        current = current.next;\\n                    }\\n                }\\n            }\\n            colBegin ++;\\n        }\\n        return matrix;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2230251,
                "title": "python-easy-solution-using-direction-variable",
                "content": "```\\nclass Solution:\\n    def spiralMatrix(self, m: int, n: int, head: Optional[ListNode]) -> List[List[int]]:\\n        \\n        matrix = [[-1]*n for i in range(m)]\\n        \\n        current = head\\n        direction = 1\\n        i, j = 0, -1\\n        \\n        while current:\\n            for _ in range(n):\\n                if current:\\n                    j += direction\\n                    matrix[i][j] = current.val\\n                    current = current.next\\n                    \\n            m -= 1\\n            \\n            for _ in range(m):\\n                if current:\\n                    i += direction\\n                    matrix[i][j] = current.val\\n                    current = current.next\\n            n -= 1\\n            \\n            direction *= -1\\n        \\n        return matrix",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def spiralMatrix(self, m: int, n: int, head: Optional[ListNode]) -> List[List[int]]:\\n        \\n        matrix = [[-1]*n for i in range(m)]\\n        \\n        current = head\\n        direction = 1\\n        i, j = 0, -1\\n        \\n        while current:\\n            for _ in range(n):\\n                if current:\\n                    j += direction\\n                    matrix[i][j] = current.val\\n                    current = current.next\\n                    \\n            m -= 1\\n            \\n            for _ in range(m):\\n                if current:\\n                    i += direction\\n                    matrix[i][j] = current.val\\n                    current = current.next\\n            n -= 1\\n            \\n            direction *= -1\\n        \\n        return matrix",
                "codeTag": "Java"
            },
            {
                "id": 2229907,
                "title": "c-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        vector<vector<int>>v(m,vector<int>(n,-1));\\n         int row = 0,col = 0;\\n        int rf = m-1, cf = n-1;\\n         while(head && row<=rf && col<=cf)\\n        {\\n            if(row<=rf)\\n            {\\n                for(int i = col;i<=cf && head;i++)\\n                {\\n                 \\n                    v[row][i] = head->val;\\n                    head = head->next;\\n                    \\n                }\\n                row++;\\n            }\\n            if(col<=cf)\\n            {\\n                for(int i = row;i<=rf && head;i++)\\n                {\\n                   \\n                    v[i][cf] = head->val;\\n                    head = head->next;\\n                }\\n                cf--;\\n            }\\n            if(row<=rf)\\n            {\\n                for(int i = cf;i>=col && head;i--)\\n                {\\n                    \\n                    v[rf][i] = head->val;\\n                    head = head->next;\\n                    \\n                }\\n                rf--;\\n            }\\n            if(col<=cf)\\n            {\\n                for(int i = rf;i>=row && head;i--)\\n                {\\n                   \\n                    v[i][col] = head->val;\\n                    head = head->next;\\n                }\\n                col++;\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Linked List",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        vector<vector<int>>v(m,vector<int>(n,-1));\\n         int row = 0,col = 0;\\n        int rf = m-1, cf = n-1;\\n         while(head && row<=rf && col<=cf)\\n        {\\n            if(row<=rf)\\n            {\\n                for(int i = col;i<=cf && head;i++)\\n                {\\n                 \\n                    v[row][i] = head->val;\\n                    head = head->next;\\n                    \\n                }\\n                row++;\\n            }\\n            if(col<=cf)\\n            {\\n                for(int i = row;i<=rf && head;i++)\\n                {\\n                   \\n                    v[i][cf] = head->val;\\n                    head = head->next;\\n                }\\n                cf--;\\n            }\\n            if(row<=rf)\\n            {\\n                for(int i = cf;i>=col && head;i--)\\n                {\\n                    \\n                    v[rf][i] = head->val;\\n                    head = head->next;\\n                    \\n                }\\n                rf--;\\n            }\\n            if(col<=cf)\\n            {\\n                for(int i = rf;i>=row && head;i--)\\n                {\\n                   \\n                    v[i][col] = head->val;\\n                    head = head->next;\\n                }\\n                col++;\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2229892,
                "title": "c-easy-to-understand-simple-solution",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        vector<int> val;\\n        int len=0;\\n        while(head!=NULL)\\n        {\\n            val.push_back(head->val);\\n            head=head->next;\\n            len++;\\n        }\\n        int left=m*n-len;\\n        while(left--)\\n        {\\n            val.push_back(-1);\\n        }\\n        vector<vector<int>> mat(m,vector<int>(n,0));\\n        int z=val.size();\\n        \\n        int uprow=0,downrow=m-1;\\n        int leftcol=0,rightcol=n-1;\\n        int c=0;\\n        while(c!=z)\\n        {\\n            \\n            for(int i=leftcol;i<=rightcol;i++)\\n            {\\n                if(c==z)\\n                {\\n                    break;\\n                }\\n                mat[uprow][i]=val[c++];\\n            }\\n            uprow++;\\n            for(int j=uprow;j<=downrow;j++)\\n            {\\n                if(c==z)\\n                {\\n                    break;\\n                }\\n                mat[j][rightcol]=val[c++];\\n            }\\n            rightcol--;\\n            for(int i=rightcol;i>=leftcol;i--)\\n            {\\n                if(c==z)\\n                {\\n                    break;\\n                }\\n                mat[downrow][i]=val[c++];\\n            }\\n            downrow--;\\n            for(int i=downrow;i>=uprow;i--)\\n            {\\n                if(c==z)\\n                {\\n                    break;\\n                }\\n                mat[i][leftcol]=val[c++];\\n            }\\n            leftcol++;\\n            if(c==z)\\n                {\\n                    break;\\n                }\\n        }\\n        return mat;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        vector<int> val;\\n        int len=0;\\n        while(head!=NULL)\\n        {\\n            val.push_back(head->val);\\n            head=head->next;\\n            len++;\\n        }\\n        int left=m*n-len;\\n        while(left--)\\n        {\\n            val.push_back(-1);\\n        }\\n        vector<vector<int>> mat(m,vector<int>(n,0));\\n        int z=val.size();\\n        \\n        int uprow=0,downrow=m-1;\\n        int leftcol=0,rightcol=n-1;\\n        int c=0;\\n        while(c!=z)\\n        {\\n            \\n            for(int i=leftcol;i<=rightcol;i++)\\n            {\\n                if(c==z)\\n                {\\n                    break;\\n                }\\n                mat[uprow][i]=val[c++];\\n            }\\n            uprow++;\\n            for(int j=uprow;j<=downrow;j++)\\n            {\\n                if(c==z)\\n                {\\n                    break;\\n                }\\n                mat[j][rightcol]=val[c++];\\n            }\\n            rightcol--;\\n            for(int i=rightcol;i>=leftcol;i--)\\n            {\\n                if(c==z)\\n                {\\n                    break;\\n                }\\n                mat[downrow][i]=val[c++];\\n            }\\n            downrow--;\\n            for(int i=downrow;i>=uprow;i--)\\n            {\\n                if(c==z)\\n                {\\n                    break;\\n                }\\n                mat[i][leftcol]=val[c++];\\n            }\\n            leftcol++;\\n            if(c==z)\\n                {\\n                    break;\\n                }\\n        }\\n        return mat;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3762430,
                "title": "two-approaches-easy-to-understand-simple",
                "content": "\\n\\n# ***FIRST APPROACH***\\n\\n  \\n    class Solution {\\n    public:\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        vector<vector<int>>vect(m,vector<int>(n,-1));\\n        int cnt=0,tot=m*n;\\n        int rs=0,re=m-1,cs=0,ce=n-1;\\n        while(head!=NULL and cnt<tot){\\n            for(int i=cs;cnt<tot and head!=NULL and i<=ce;i++){\\n                vect[rs][i]=head->val;\\n                head=head->next;\\n                cnt++;\\n            }\\n            rs++;\\n            for(int i=rs;cnt<tot and head!=NULL and i<=re;i++){\\n                vect[i][ce]=head->val;\\n                head=head->next;\\n                cnt++;\\n            }\\n            ce--;\\n            for(int i=ce;cnt<tot and head!=NULL and i>=cs;i--){\\n                vect[re][i]=head->val;\\n                head=head->next;\\n                cnt++;\\n            }\\n            re--;\\n            for(int i=re;cnt<tot and head!=NULL and i>=rs;i--){\\n                vect[i][cs]=head->val;\\n                head=head->next;\\n                cnt++;\\n            }\\n            cs++;\\n        }\\n        return vect;\\n       }\\n    };\\n\\t\\n\\t\\n# ***SECOND APPROACH***\\n\\n    class Solution {\\n    public:\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        ListNode* y=head;\\n        //y->next=head;\\n        int cnt=0;\\n        while(y){\\n            y=y->next;\\n            cnt++;\\n        }\\n        vector<vector<int>>matrix(m,vector<int>(n,-1));\\n        int k=1;\\n        int rwst=0,rwed=m-1,clst=0,cled=n-1;\\n        int count=0,total=m*n;\\n        while(count<cnt){\\n            for(int i=clst;count<cnt && i<=cled;i++){\\n                matrix[rwst][i]=head->val;\\n                head=head->next;\\n                count++;\\n            }\\n            rwst++;\\n            for(int i=rwst;count<cnt && i<=rwed;i++){\\n                matrix[i][cled]=head->val;\\n                head=head->next;\\n                count++;\\n            }\\n            cled--;\\n            for(int i=cled;count<cnt && i>=clst;i--){\\n                matrix[rwed][i]=head->val;\\n                head=head->next;\\n                count++;\\n            }\\n            rwed--;\\n            for(int i=rwed;count<cnt && i>=rwst;i--){\\n                matrix[i][clst]=head->val;\\n                head=head->next;\\n                count++;\\n            }\\n            clst++;\\n        }\\n        return matrix;\\n      }\\n    };",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "class Solution {\\n    public:\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        vector<vector<int>>vect(m,vector<int>(n,-1));\\n        int cnt=0,tot=m*n;\\n        int rs=0,re=m-1,cs=0,ce=n-1;\\n        while(head!=NULL and cnt<tot){\\n            for(int i=cs;cnt<tot and head!=NULL and i<=ce;i++){\\n                vect[rs][i]=head->val;\\n                head=head->next;\\n                cnt++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3684885,
                "title": "easy-solution-with-full-approach-explanation",
                "content": "# Intuition\\nwe need to know how to iterate vector and iteration of linked list at a time .\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nwe need to go in this order\\n right->down->left->up\\nuntill you reach to end of linked list you need to traverse\\nright:\\n -> first start at 0,0 index go through the ith and when your j value is greater than n  or your v[i][j]!=-1 stop iterating that row \\n->increament i by one and decrement j by 1\\ndown:\\n    ->start at previous indices of i and j, whne your i>=m or v[i][j]!=-1   stop iterating that colomn \\n-> decreament i and j by 1\\n\\nleft:\\n    ->start i and j th indices , iterate untill your j<0 or v[i][j]!=-1\\n-> decrement i by 1 to move upper row\\n->  increament j by 1 to move back colomn\\n\\nup:\\n-> iterate untill your i<0 or v[i][j]!=-1\\n->increase i by one to get lower row and increase j by 1 to get front column \\n\\nthis loop iterates untill you reach to end of linked list\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(size of list)\\n\\n- Space complexity:\\n- m x n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        vector<vector<int>> v(m,vector<int>(n,-1));\\n        int i=0,j=0;\\n\\tint l=0,r=0,d=0,u=0;\\n\\tListNode *t=head;\\n\\twhile(t!=NULL){\\n\\t\\tif(t!=NULL){\\n\\t\\t\\twhile(t and j<n and i<m and i>=0 and j>=0){\\n\\t\\t\\t\\tif(v[i][j]!=-1)\\n                    break;\\n\\t\\t\\t\\tv[i][j++]=t->val;\\n                t=t->next;\\n\\t\\t\\t}\\n\\t\\t\\tj--;\\n            i++;\\n\\t\\t}\\n        if(t){\\n            while(t and j<n and i<m and i>=0 and j>=0){\\n\\t\\t\\t\\tif(v[i][j]!=-1)\\n                    break;\\n\\t\\t\\t\\tv[i++][j]=t->val;\\n                t=t->next;\\n\\t\\t\\t}\\n\\t\\t\\ti--;\\n            j--;\\n        }\\n        if(t){\\n            while(t and j<n and i<m and i>=0 and j>=0){\\n\\t\\t\\t\\tif(v[i][j]!=-1)\\n                    break;\\n\\t\\t\\t\\tv[i][j--]=t->val;\\n                t=t->next;\\n\\t\\t\\t}\\n\\t\\t\\tj++;\\n            i--;\\n        }\\n        if(t){\\n            while(t and j<n and i<m and i>=0 and j>=0){\\n\\t\\t\\t\\tif(v[i][j]!=-1)\\n                    break;\\n\\t\\t\\t\\tv[i--][j]=t->val;\\n                t=t->next;\\n\\t\\t\\t}\\n\\t\\t\\tj++;\\n            i++;\\n        }\\n\\t}\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "# Intuition\\nwe need to know how to iterate vector and iteration of linked list at a time .\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nwe need to go in this order\\n right->down->left->up\\nuntill you reach to end of linked list you need to traverse\\nright:\\n -> first start at 0,0 index go through the ith and when your j value is greater than n  or your v[i][j]!=-1 stop iterating that row \\n->increament i by one and decrement j by 1\\ndown:\\n    ->start at previous indices of i and j, whne your i>=m or v[i][j]!=-1   stop iterating that colomn \\n-> decreament i and j by 1\\n\\nleft:\\n    ->start i and j th indices , iterate untill your j<0 or v[i][j]!=-1\\n-> decrement i by 1 to move upper row\\n->  increament j by 1 to move back colomn\\n\\nup:\\n-> iterate untill your i<0 or v[i][j]!=-1\\n->increase i by one to get lower row and increase j by 1 to get front column \\n\\nthis loop iterates untill you reach to end of linked list\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(size of list)\\n\\n- Space complexity:\\n- m x n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        vector<vector<int>> v(m,vector<int>(n,-1));\\n        int i=0,j=0;\\n\\tint l=0,r=0,d=0,u=0;\\n\\tListNode *t=head;\\n\\twhile(t!=NULL){\\n\\t\\tif(t!=NULL){\\n\\t\\t\\twhile(t and j<n and i<m and i>=0 and j>=0){\\n\\t\\t\\t\\tif(v[i][j]!=-1)\\n                    break;\\n\\t\\t\\t\\tv[i][j++]=t->val;\\n                t=t->next;\\n\\t\\t\\t}\\n\\t\\t\\tj--;\\n            i++;\\n\\t\\t}\\n        if(t){\\n            while(t and j<n and i<m and i>=0 and j>=0){\\n\\t\\t\\t\\tif(v[i][j]!=-1)\\n                    break;\\n\\t\\t\\t\\tv[i++][j]=t->val;\\n                t=t->next;\\n\\t\\t\\t}\\n\\t\\t\\ti--;\\n            j--;\\n        }\\n        if(t){\\n            while(t and j<n and i<m and i>=0 and j>=0){\\n\\t\\t\\t\\tif(v[i][j]!=-1)\\n                    break;\\n\\t\\t\\t\\tv[i][j--]=t->val;\\n                t=t->next;\\n\\t\\t\\t}\\n\\t\\t\\tj++;\\n            i--;\\n        }\\n        if(t){\\n            while(t and j<n and i<m and i>=0 and j>=0){\\n\\t\\t\\t\\tif(v[i][j]!=-1)\\n                    break;\\n\\t\\t\\t\\tv[i--][j]=t->val;\\n                t=t->next;\\n\\t\\t\\t}\\n\\t\\t\\tj++;\\n            i++;\\n        }\\n\\t}\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3505952,
                "title": "java-easy-solution-beats-98-solution-easy-to-understand",
                "content": "\\n# Approach\\n* Fill the required array with -1.\\n* Now Traverse the linkedlist and fill the required array in spiral order.\\n\\n# Complexity\\n- Time complexity:\\nO(m*n)\\nwhere m=number of rows\\n      n=number of columns\\n\\n- Space complexity:\\nO(m*n)\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public int[][] spiralMatrix(int m, int n, ListNode head) {\\n\\n        int row=0;\\n        int nrow=m-1;\\n        int col=0;\\n        int ncol=n-1;\\n        int size=n*m;\\n        int c=0;\\n\\n        int[][] arr=new int[m][n];\\n\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n                arr[i][j]=-1;\\n        }\\n\\n        while(head != null){\\n\\n            for(int i=row;head != null && i<=ncol;i++)\\n            {\\n                arr[row][i]=head.val;\\n                c+=1;\\n                head=head.next;\\n            }\\n            row+=1;\\n\\n            for(int i=row;head != null && i<=nrow;i++)\\n            {\\n                arr[i][ncol]=head.val;\\n                c+=1;\\n                head=head.next;\\n            }\\n            ncol-=1;\\n\\n            for(int i=ncol;head != null && i>=col;i--){\\n                arr[nrow][i]=head.val;\\n                c+=1;\\n                head=head.next;\\n            }\\n            nrow-=1;\\n\\n            for(int i=nrow;head != null && i>=row;i--){\\n                arr[i][col]=head.val;\\n                c+=1;\\n                head=head.next;\\n            }\\n            col+=1;\\n\\n        }\\n\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List",
                    "Simulation"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public int[][] spiralMatrix(int m, int n, ListNode head) {\\n\\n        int row=0;\\n        int nrow=m-1;\\n        int col=0;\\n        int ncol=n-1;\\n        int size=n*m;\\n        int c=0;\\n\\n        int[][] arr=new int[m][n];\\n\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n                arr[i][j]=-1;\\n        }\\n\\n        while(head != null){\\n\\n            for(int i=row;head != null && i<=ncol;i++)\\n            {\\n                arr[row][i]=head.val;\\n                c+=1;\\n                head=head.next;\\n            }\\n            row+=1;\\n\\n            for(int i=row;head != null && i<=nrow;i++)\\n            {\\n                arr[i][ncol]=head.val;\\n                c+=1;\\n                head=head.next;\\n            }\\n            ncol-=1;\\n\\n            for(int i=ncol;head != null && i>=col;i--){\\n                arr[nrow][i]=head.val;\\n                c+=1;\\n                head=head.next;\\n            }\\n            nrow-=1;\\n\\n            for(int i=nrow;head != null && i>=row;i--){\\n                arr[i][col]=head.val;\\n                c+=1;\\n                head=head.next;\\n            }\\n            col+=1;\\n\\n        }\\n\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3481154,
                "title": "c-easy-simple",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        vector<vector<int>> ans(m , vector<int> (n,-1));\\n\\n        int t = 0, d = m-1, l = 0 , r = n-1;\\n\\n        while(head != NULL && t <= d && l <= r){\\n            // cout << t << \" \" << d << \" \" << l << \" \" << r << endl;\\n            for(int i=l;i<=r && head != NULL;i++){\\n                ans[t][i] = head -> val;\\n                // cout << ans[t][i] << endl;\\n                head = head -> next;\\n            }\\n            \\n            t++;\\n            for(int i=t;i<=d && head != NULL;i++){\\n                ans[i][r] = head -> val;\\n                // cout <<  ans[i][r] << endl;\\n\\n                head = head -> next;\\n            }\\n            r--;\\n            for(int i=r;i>=l && head != NULL;i--){\\n                ans[d][i] = head -> val;\\n                // cout <<   ans[d][i] << endl;\\n\\n                head = head -> next;\\n            }\\n            d--;\\n            for(int i=d;i>=t && head != NULL;i--){\\n                ans[i][l] = head -> val;\\n                // cout <<  ans[i][l] << endl;\\n                head = head -> next;\\n            }\\n            l++;\\n            // cout << head -> val << endl;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        vector<vector<int>> ans(m , vector<int> (n,-1));\\n\\n        int t = 0, d = m-1, l = 0 , r = n-1;\\n\\n        while(head != NULL && t <= d && l <= r){\\n            // cout << t << \" \" << d << \" \" << l << \" \" << r << endl;\\n            for(int i=l;i<=r && head != NULL;i++){\\n                ans[t][i] = head -> val;\\n                // cout << ans[t][i] << endl;\\n                head = head -> next;\\n            }\\n            \\n            t++;\\n            for(int i=t;i<=d && head != NULL;i++){\\n                ans[i][r] = head -> val;\\n                // cout <<  ans[i][r] << endl;\\n\\n                head = head -> next;\\n            }\\n            r--;\\n            for(int i=r;i>=l && head != NULL;i--){\\n                ans[d][i] = head -> val;\\n                // cout <<   ans[d][i] << endl;\\n\\n                head = head -> next;\\n            }\\n            d--;\\n            for(int i=d;i>=t && head != NULL;i--){\\n                ans[i][l] = head -> val;\\n                // cout <<  ans[i][l] << endl;\\n                head = head -> next;\\n            }\\n            l++;\\n            // cout << head -> val << endl;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3390439,
                "title": "easy-clean-o-m-n-java-solution",
                "content": "\\n```java []\\n\\nclass Solution {\\n    public int[][] spiralMatrix(int m, int n, ListNode head) {\\n        int[][] arr = new int[m][n];\\n        for(int[] row: arr)   Arrays.fill(row,-1);\\n        int top = 0, left = 0, right = n-1, bottom = m-1;\\n        while(head != null){\\n            for(int i=left; i<=right && head != null; i++){\\n                arr[top][i] = head.val;\\n                head = head.next;\\n            }\\n            top++;\\n            for(int i=top; i<=bottom && head != null; i++){\\n                arr[i][right] = head.val;\\n                head = head.next;\\n            }\\n            right--;\\n            for(int i=right; i>=left && head != null; i--){\\n                arr[bottom][i] = head.val;\\n                head = head.next;\\n            }\\n            bottom--;\\n            for(int i=bottom; i>=top && head != null; i--){\\n                arr[i][left] = head.val;\\n                head = head.next;\\n            }\\n            left++;\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java []\\n\\nclass Solution {\\n    public int[][] spiralMatrix(int m, int n, ListNode head) {\\n        int[][] arr = new int[m][n];\\n        for(int[] row: arr)   Arrays.fill(row,-1);\\n        int top = 0, left = 0, right = n-1, bottom = m-1;\\n        while(head != null){\\n            for(int i=left; i<=right && head != null; i++){\\n                arr[top][i] = head.val;\\n                head = head.next;\\n            }\\n            top++;\\n            for(int i=top; i<=bottom && head != null; i++){\\n                arr[i][right] = head.val;\\n                head = head.next;\\n            }\\n            right--;\\n            for(int i=right; i>=left && head != null; i--){\\n                arr[bottom][i] = head.val;\\n                head = head.next;\\n            }\\n            bottom--;\\n            for(int i=bottom; i>=top && head != null; i--){\\n                arr[i][left] = head.val;\\n                head = head.next;\\n            }\\n            left++;\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3354902,
                "title": "one-way-approach-using-spiral-matrix-traversal-technique",
                "content": "\\n# Approach\\nFirst of all i created a 2-D matrix of size n*m . Then use spiral Matrix Traversal technique and assign the cur head value at each cell.\\n\\n\\n# Complexity\\n- Time complexity:\\nO(N*M)\\n\\n- Space complexity:\\nO(N*M)\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def spiralMatrix(self, m: int, n: int, head: Optional[ListNode]) -> List[List[int]]:\\n        matrix=[[-1 for _ in range(n)]for _ in range(m)]\\n        top,left=0,0\\n        down,right=len(matrix)-1,len(matrix[0])-1\\n        direction=0\\n        cur=head\\n        while top<=down and left<=right:\\n            if direction==0:\\n                for i in range(left,right+1):\\n                    if cur :\\n                        matrix[top][i]=cur.val\\n                        cur=cur.next\\n                       \\n                top+=1\\n            elif direction==1:\\n                \\n                for i in range(top,down+1):\\n                    if cur:\\n                        matrix[i][right]=cur.val\\n                        cur=cur.next\\n                       \\n                right-=1\\n            elif direction==2:\\n               \\n                for i in range(right,left-1,-1):\\n                    if cur:\\n                        matrix[down][i]=cur.val\\n                        cur=cur.next\\n                        \\n                down-=1\\n            elif direction==3:\\n                \\n                for i in range(down,top-1,-1):\\n                    if cur:\\n                        matrix[i][left]=cur.val\\n                        cur=cur.next\\n                        \\n                left+=1\\n            direction=(direction+1)%4\\n        return matrix\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def spiralMatrix(self, m: int, n: int, head: Optional[ListNode]) -> List[List[int]]:\\n        matrix=[[-1 for _ in range(n)]for _ in range(m)]\\n        top,left=0,0\\n        down,right=len(matrix)-1,len(matrix[0])-1\\n        direction=0\\n        cur=head\\n        while top<=down and left<=right:\\n            if direction==0:\\n                for i in range(left,right+1):\\n                    if cur :\\n                        matrix[top][i]=cur.val\\n                        cur=cur.next\\n                       \\n                top+=1\\n            elif direction==1:\\n                \\n                for i in range(top,down+1):\\n                    if cur:\\n                        matrix[i][right]=cur.val\\n                        cur=cur.next\\n                       \\n                right-=1\\n            elif direction==2:\\n               \\n                for i in range(right,left-1,-1):\\n                    if cur:\\n                        matrix[down][i]=cur.val\\n                        cur=cur.next\\n                        \\n                down-=1\\n            elif direction==3:\\n                \\n                for i in range(down,top-1,-1):\\n                    if cur:\\n                        matrix[i][left]=cur.val\\n                        cur=cur.next\\n                        \\n                left+=1\\n            direction=(direction+1)%4\\n        return matrix\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3308924,
                "title": "copy-paste-spiral-matrix-2-solution-easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public int[][] spiralMatrix(int m, int n, ListNode head) {\\n        ListNode curr = head;\\n        int startRow = 0;\\n        int endRow = m - 1;\\n        int startCol = 0;\\n        int endCol = n - 1;\\n        int [][] arr = new int[m][n];\\n        while(startCol <= endCol && startRow <= endRow){\\n            //top\\n            for(int i = startCol; i <= endCol; i++){\\n                if(curr == null)\\n                    arr[startRow][i] = -1;\\n                else{\\n                    arr[startRow][i] = curr.val;\\n                    curr = curr.next;\\n                }\\n            }\\n            //right\\n            for(int i = startRow + 1; i <= endRow; i++){\\n                if(curr == null)\\n                    arr[i][endCol] = -1;\\n                else{\\n                    arr[i][endCol] = curr.val;\\n                    curr = curr.next;\\n                }\\n            }\\n            //bottom\\n            for(int i = endCol - 1; i >= startCol; i--){\\n                if(startRow == endRow)\\n                    break;\\n                if(curr == null)\\n                    arr[endRow][i] = -1;\\n                else{\\n                    arr[endRow][i] = curr.val;\\n                    curr = curr.next;\\n                }\\n            }\\n            //left\\n            for(int i = endRow - 1; i >= startCol + 1; i--){\\n                if(startCol == endCol)\\n                    break;\\n                if(curr == null)\\n                    arr[i][startCol] = -1;\\n                else{\\n                    arr[i][startCol] = curr.val;\\n                    curr = curr.next;\\n                }\\n            }\\n            startCol++;\\n            startRow++;\\n            endCol--;\\n            endRow--;\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public int[][] spiralMatrix(int m, int n, ListNode head) {\\n        ListNode curr = head;\\n        int startRow = 0;\\n        int endRow = m - 1;\\n        int startCol = 0;\\n        int endCol = n - 1;\\n        int [][] arr = new int[m][n];\\n        while(startCol <= endCol && startRow <= endRow){\\n            //top\\n            for(int i = startCol; i <= endCol; i++){\\n                if(curr == null)\\n                    arr[startRow][i] = -1;\\n                else{\\n                    arr[startRow][i] = curr.val;\\n                    curr = curr.next;\\n                }\\n            }\\n            //right\\n            for(int i = startRow + 1; i <= endRow; i++){\\n                if(curr == null)\\n                    arr[i][endCol] = -1;\\n                else{\\n                    arr[i][endCol] = curr.val;\\n                    curr = curr.next;\\n                }\\n            }\\n            //bottom\\n            for(int i = endCol - 1; i >= startCol; i--){\\n                if(startRow == endRow)\\n                    break;\\n                if(curr == null)\\n                    arr[endRow][i] = -1;\\n                else{\\n                    arr[endRow][i] = curr.val;\\n                    curr = curr.next;\\n                }\\n            }\\n            //left\\n            for(int i = endRow - 1; i >= startCol + 1; i--){\\n                if(startCol == endCol)\\n                    break;\\n                if(curr == null)\\n                    arr[i][startCol] = -1;\\n                else{\\n                    arr[i][startCol] = curr.val;\\n                    curr = curr.next;\\n                }\\n            }\\n            startCol++;\\n            startRow++;\\n            endCol--;\\n            endRow--;\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3164917,
                "title": "beginner-friendly-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nfollow up direction : right -> down -> left -> up\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ncreating a matrix m*n fillup with -1 and traverse throgh list and make update directions according to current directions and values of before cells\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n     O(N) (no of Nodes in linkedlist)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(N+M)\\n\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def spiralMatrix(self, m: int, n: int, head: Optional[ListNode]) -> List[List[int]]:\\n        mat=[[-1 for i in range(n)] for i in range(m)]\\n        temp=head\\n        d=1\\n        rowi,colj=0,0\\n        while temp!=None:\\n            mat[rowi][colj]=temp.val\\n            if d==1:\\n                if colj+1<n and mat[rowi][colj+1]==-1:\\n                    colj+=1\\n                    d=1\\n                elif rowi+1<m and mat[rowi+1][colj]==-1:\\n                    rowi+=1\\n                    d=2\\n            elif d==2:\\n                if rowi+1<m and mat[rowi+1][colj]==-1:\\n                    rowi+=1\\n                    d=2\\n                elif colj-1>=0 and mat[rowi][colj-1]==-1:\\n                    colj-=1\\n                    d=3\\n            elif d==3:\\n                if colj-1>=0 and mat[rowi][colj-1]==-1:\\n                    colj-=1\\n                    d=3\\n                elif rowi-1>=0 and mat[rowi-1][colj]==-1:\\n                    rowi-=1\\n                    d=4\\n            elif d==4:\\n                if rowi-1>=0 and mat[rowi-1][colj]==-1:\\n                    rowi-=1\\n                    d=4\\n                elif colj+1<n and mat[rowi][colj+1]==-1:\\n                    colj+=1\\n                    d=1\\n            temp=temp.next\\n        return mat\\n\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Linked List",
                    "Matrix"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def spiralMatrix(self, m: int, n: int, head: Optional[ListNode]) -> List[List[int]]:\\n        mat=[[-1 for i in range(n)] for i in range(m)]\\n        temp=head\\n        d=1\\n        rowi,colj=0,0\\n        while temp!=None:\\n            mat[rowi][colj]=temp.val\\n            if d==1:\\n                if colj+1<n and mat[rowi][colj+1]==-1:\\n                    colj+=1\\n                    d=1\\n                elif rowi+1<m and mat[rowi+1][colj]==-1:\\n                    rowi+=1\\n                    d=2\\n            elif d==2:\\n                if rowi+1<m and mat[rowi+1][colj]==-1:\\n                    rowi+=1\\n                    d=2\\n                elif colj-1>=0 and mat[rowi][colj-1]==-1:\\n                    colj-=1\\n                    d=3\\n            elif d==3:\\n                if colj-1>=0 and mat[rowi][colj-1]==-1:\\n                    colj-=1\\n                    d=3\\n                elif rowi-1>=0 and mat[rowi-1][colj]==-1:\\n                    rowi-=1\\n                    d=4\\n            elif d==4:\\n                if rowi-1>=0 and mat[rowi-1][colj]==-1:\\n                    rowi-=1\\n                    d=4\\n                elif colj+1<n and mat[rowi][colj+1]==-1:\\n                    colj+=1\\n                    d=1\\n            temp=temp.next\\n        return mat\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3077044,
                "title": "easy-approach-o-length-time-beats-others",
                "content": "\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        vector<vector<int>>mat(m,vector<int>(n,-1));\\n        ListNode*curr=head;\\n        int top=0,right=n-1,bottom=m-1,left=0;\\n        while(top<=bottom && left<=right && curr){\\n            for(int i=left;i<=right;i++){\\n                if(curr){\\n                    mat[top][i]=curr->val;\\n                    curr=curr->next;\\n                }else{\\n                    break;\\n                }\\n            }\\n            top++;\\n            for(int i=top;i<=bottom;i++){\\n                if(curr){\\n                    mat[i][right]=curr->val;\\n                    curr=curr->next;\\n                }else{\\n                    break;\\n                }\\n            }\\n            right--;\\n            if(top<=bottom){\\n                for(int i=right;i>=left;i--){\\n                    if(curr){\\n                        mat[bottom][i]=curr->val;\\n                        curr=curr->next;\\n                    }else{\\n                        break;\\n                    }\\n                }\\n                bottom--;\\n            }\\n            if(left<=right){\\n                for(int i=bottom;i>=top;i--){\\n                    if(curr){\\n                        mat[i][left]=curr->val;\\n                        curr=curr->next;\\n                    }else{\\n                        break;\\n                    }\\n                }\\n                left++;\\n            }\\n        }\\n        return mat;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        vector<vector<int>>mat(m,vector<int>(n,-1));\\n        ListNode*curr=head;\\n        int top=0,right=n-1,bottom=m-1,left=0;\\n        while(top<=bottom && left<=right && curr){\\n            for(int i=left;i<=right;i++){\\n                if(curr){\\n                    mat[top][i]=curr->val;\\n                    curr=curr->next;\\n                }else{\\n                    break;\\n                }\\n            }\\n            top++;\\n            for(int i=top;i<=bottom;i++){\\n                if(curr){\\n                    mat[i][right]=curr->val;\\n                    curr=curr->next;\\n                }else{\\n                    break;\\n                }\\n            }\\n            right--;\\n            if(top<=bottom){\\n                for(int i=right;i>=left;i--){\\n                    if(curr){\\n                        mat[bottom][i]=curr->val;\\n                        curr=curr->next;\\n                    }else{\\n                        break;\\n                    }\\n                }\\n                bottom--;\\n            }\\n            if(left<=right){\\n                for(int i=bottom;i>=top;i--){\\n                    if(curr){\\n                        mat[i][left]=curr->val;\\n                        curr=curr->next;\\n                    }else{\\n                        break;\\n                    }\\n                }\\n                left++;\\n            }\\n        }\\n        return mat;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3029531,
                "title": "c-beginner-friendly-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        int top = 0, left = 0, right = n - 1, down = m - 1;\\n        int dir = 0;\\n        vector<vector<int>> answer(m, vector<int>(n, -1));\\n        while(top <= down && left <= right && head) {\\n            if(dir == 0) {\\n                for(int col = top; col <= right; col++) {\\n                    if(!head) return answer;\\n                    int val = head -> val;\\n                    answer[top][col] = val;\\n                    head = head -> next;\\n                }\\n                top++;\\n            }else if(dir == 1) {\\n                for(int row = top; row <= down; row++) {\\n                    if(!head) return answer;\\n                    int val = head -> val;\\n                    answer[row][right] = val;\\n                    head = head -> next;\\n                }\\n                right--;\\n            }else if(dir == 2) {\\n                for(int col = right; col >= left; col--) {\\n                    if(!head) return answer;\\n                    int val = head -> val;\\n                    answer[down][col] = val;\\n                    head = head -> next;\\n                }\\n                down--;\\n            }else {\\n                for(int row = down; row >= top; row--) {\\n                    if(!head) return answer;\\n                    int val = head -> val;\\n                    answer[row][left] = val;\\n                    head = head -> next;\\n                }\\n                left++;\\n            }\\n            dir = (++dir) % 4;\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        int top = 0, left = 0, right = n - 1, down = m - 1;\\n        int dir = 0;\\n        vector<vector<int>> answer(m, vector<int>(n, -1));\\n        while(top <= down && left <= right && head) {\\n            if(dir == 0) {\\n                for(int col = top; col <= right; col++) {\\n                    if(!head) return answer;\\n                    int val = head -> val;\\n                    answer[top][col] = val;\\n                    head = head -> next;\\n                }\\n                top++;\\n            }else if(dir == 1) {\\n                for(int row = top; row <= down; row++) {\\n                    if(!head) return answer;\\n                    int val = head -> val;\\n                    answer[row][right] = val;\\n                    head = head -> next;\\n                }\\n                right--;\\n            }else if(dir == 2) {\\n                for(int col = right; col >= left; col--) {\\n                    if(!head) return answer;\\n                    int val = head -> val;\\n                    answer[down][col] = val;\\n                    head = head -> next;\\n                }\\n                down--;\\n            }else {\\n                for(int row = down; row >= top; row--) {\\n                    if(!head) return answer;\\n                    int val = head -> val;\\n                    answer[row][left] = val;\\n                    head = head -> next;\\n                }\\n                left++;\\n            }\\n            dir = (++dir) % 4;\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2872005,
                "title": "elegant-cpp-solution-with-no-if-statements",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nnum_x, num_y denote the total numbers that can be filled while moving horizontally or vertically in a given row or column.\\n\\n# Complexity\\n- Time complexity: O(N) where N = mn;\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N) for creating the spiral matrix;\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        vector<vector<int>> mat(m, vector<int>(n, -1));\\n        int i=0, j=-1, num_x=m, num_y=n, counter;\\n\\n        while(head){\\n            //left\\n            counter=num_y;\\n            while(head && counter--){\\n                mat[i][++j]=head->val;\\n                head = head->next;\\n            }\\n            num_x--;\\n\\n            //down\\n            counter=num_x;\\n            while(head && counter--){\\n                mat[++i][j]=head->val;\\n                head = head->next;\\n            }\\n            num_y--;\\n\\n            //right\\n            counter=num_y;\\n            while(head && counter--){\\n                mat[i][--j]=head->val;\\n                head = head->next;\\n            }\\n            num_x--;\\n\\n            //up\\n            counter=num_x;\\n            while(head && counter--){\\n                mat[--i][j]=head->val;\\n                head = head->next;\\n            }\\n            num_y--;\\n        }\\n        return mat;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        vector<vector<int>> mat(m, vector<int>(n, -1));\\n        int i=0, j=-1, num_x=m, num_y=n, counter;\\n\\n        while(head){\\n            //left\\n            counter=num_y;\\n            while(head && counter--){\\n                mat[i][++j]=head->val;\\n                head = head->next;\\n            }\\n            num_x--;\\n\\n            //down\\n            counter=num_x;\\n            while(head && counter--){\\n                mat[++i][j]=head->val;\\n                head = head->next;\\n            }\\n            num_y--;\\n\\n            //right\\n            counter=num_y;\\n            while(head && counter--){\\n                mat[i][--j]=head->val;\\n                head = head->next;\\n            }\\n            num_x--;\\n\\n            //up\\n            counter=num_x;\\n            while(head && counter--){\\n                mat[--i][j]=head->val;\\n                head = head->next;\\n            }\\n            num_y--;\\n        }\\n        return mat;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2545816,
                "title": "java-easy-understanding-7ms-99-7-faster-solution",
                "content": "```\\nclass Solution {\\n    public int[][] spiralMatrix(int m, int n, ListNode head) {\\n        \\n        int[][] res =new int[m][n];\\n        for(int[] i:res){\\n            Arrays.fill(i,-1);\\n        }\\n\\n        int top=0;\\n        int right =res[0].length -1;\\n        int bottom =res.length-1;\\n        int left =0;\\n        ListNode curr=head;\\n        \\n        while(curr!=null){\\n            //top= left to right\\n            for(int i=left;i<=right && curr!=null;i++){\\n                res[top][i]=curr.val;\\n                curr=curr.next;\\n            }\\n            top++;\\n            //right= top to bottom\\n            for(int i=top;i<=bottom && curr!=null;i++){\\n                res[i][right]=curr.val;\\n                curr=curr.next;\\n            }\\n            right--;\\n            //bottom= right to left \\n            for(int i=right;i>=left && curr!=null;i--){\\n                res[bottom][i]=curr.val;\\n                curr=curr.next;\\n            }\\n            bottom--;\\n            //left=bottom to top\\n            for(int i=bottom;i>=top && curr!=null;i--){\\n                res[i][left]=curr.val;\\n                curr=curr.next;\\n            }\\n            left++;\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] spiralMatrix(int m, int n, ListNode head) {\\n        \\n        int[][] res =new int[m][n];\\n        for(int[] i:res){\\n            Arrays.fill(i,-1);\\n        }\\n\\n        int top=0;\\n        int right =res[0].length -1;\\n        int bottom =res.length-1;\\n        int left =0;\\n        ListNode curr=head;\\n        \\n        while(curr!=null){\\n            //top= left to right\\n            for(int i=left;i<=right && curr!=null;i++){\\n                res[top][i]=curr.val;\\n                curr=curr.next;\\n            }\\n            top++;\\n            //right= top to bottom\\n            for(int i=top;i<=bottom && curr!=null;i++){\\n                res[i][right]=curr.val;\\n                curr=curr.next;\\n            }\\n            right--;\\n            //bottom= right to left \\n            for(int i=right;i>=left && curr!=null;i--){\\n                res[bottom][i]=curr.val;\\n                curr=curr.next;\\n            }\\n            bottom--;\\n            //left=bottom to top\\n            for(int i=bottom;i>=top && curr!=null;i--){\\n                res[i][left]=curr.val;\\n                curr=curr.next;\\n            }\\n            left++;\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2482290,
                "title": "c-easy-to-understand-solution-100-faster",
                "content": "Create four index pointers top, bottom, left, right and traverse the matrix accordingly by changing the index pointers.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n\\t\\n        vector<vector<int>>res(m,vector<int>(n,-1));\\n        int left=0,right=n-1,top=0,bottom=m-1;\\n        while(left<=right&&top<=bottom&&head)\\n        {\\n            for(int i=left;i<=right;i++)\\n            {\\n                res[top][i]=head->val;\\n                head=head->next;\\n                if(!head)return res;\\n            }\\n            top++; \\n            for(int i=top;i<=bottom;i++)\\n            {\\n                res[i][right]=head->val;\\n                head=head->next;\\n                if(!head)return res;\\n            }\\n            right--;\\n            for(int i=right;i>=left;i--)\\n            {\\n                 res[bottom][i]=head->val;\\n                head=head->next;\\n                if(!head)return res;\\n            }\\n            bottom--;\\n            for(int i=bottom;i>=top;i--)\\n            {\\n                res[i][left]=head->val;\\n                head=head->next;\\n                if(!head)return res;\\n            }\\n            left++;      \\n        }\\n        return res;\\n    }\\n};\\n```\\nDo Upvote!",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n\\t\\n        vector<vector<int>>res(m,vector<int>(n,-1));\\n        int left=0,right=n-1,top=0,bottom=m-1;\\n        while(left<=right&&top<=bottom&&head)\\n        {\\n            for(int i=left;i<=right;i++)\\n            {\\n                res[top][i]=head->val;\\n                head=head->next;\\n                if(!head)return res;\\n            }\\n            top++; \\n            for(int i=top;i<=bottom;i++)\\n            {\\n                res[i][right]=head->val;\\n                head=head->next;\\n                if(!head)return res;\\n            }\\n            right--;\\n            for(int i=right;i>=left;i--)\\n            {\\n                 res[bottom][i]=head->val;\\n                head=head->next;\\n                if(!head)return res;\\n            }\\n            bottom--;\\n            for(int i=bottom;i>=top;i--)\\n            {\\n                res[i][left]=head->val;\\n                head=head->next;\\n                if(!head)return res;\\n            }\\n            left++;      \\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2455288,
                "title": "simple-simulation-very-clear-and-easy-to-understand",
                "content": "```\\n\\nclass Solution:\\n    def spiralMatrix(self, m: int, n: int, head: Optional[ListNode]) -> List[List[int]]:\\n        result = [ [-1] * n for _ in range(m) ]\\n        node = head\\n        \\n        \\n        \\n        UP = 2\\n        DOWN = 3\\n        LEFT = 1\\n        RIGHT = 0\\n        \\n        directions = ( (0,1), (0,-1), (-1,0), (1,0))\\n        direction = RIGHT\\n        \\n        uB, dB, lB, rB = 0, m-1, 0, n-1\\n        row, col = 0, 0\\n\\n        while node:\\n            result[row][col] = node.val \\n            node = node.next \\n\\n            if direction == RIGHT and col == rB and row != dB:\\n                direction = DOWN\\n                uB += 1\\n            \\n\\n            if direction == DOWN and col == rB and row == dB:\\n                direction = LEFT\\n                rB -= 1\\n                \\n            if direction == LEFT and col == lB and row != uB:\\n                direction = UP\\n                dB -= 1\\n                \\n            if direction == UP and col == lB and row == uB:\\n                direction = RIGHT\\n                lB += 1\\n            \\n            dr,dc = directions[direction]\\n            row,col = row+dr, col+dc\\n\\n        return result\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Simulation"
                ],
                "code": "```\\n\\nclass Solution:\\n    def spiralMatrix(self, m: int, n: int, head: Optional[ListNode]) -> List[List[int]]:\\n        result = [ [-1] * n for _ in range(m) ]\\n        node = head\\n        \\n        \\n        \\n        UP = 2\\n        DOWN = 3\\n        LEFT = 1\\n        RIGHT = 0\\n        \\n        directions = ( (0,1), (0,-1), (-1,0), (1,0))\\n        direction = RIGHT\\n        \\n        uB, dB, lB, rB = 0, m-1, 0, n-1\\n        row, col = 0, 0\\n\\n        while node:\\n            result[row][col] = node.val \\n            node = node.next \\n\\n            if direction == RIGHT and col == rB and row != dB:\\n                direction = DOWN\\n                uB += 1\\n            \\n\\n            if direction == DOWN and col == rB and row == dB:\\n                direction = LEFT\\n                rB -= 1\\n                \\n            if direction == LEFT and col == lB and row != uB:\\n                direction = UP\\n                dB -= 1\\n                \\n            if direction == UP and col == lB and row == uB:\\n                direction = RIGHT\\n                lB += 1\\n            \\n            dr,dc = directions[direction]\\n            row,col = row+dr, col+dc\\n\\n        return result\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2263648,
                "title": "time-o-n-m-space-o-n-m",
                "content": "/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        // TIME- O(N*M)  SPACE - O(N*M)\\n        vector<vector<int>> ans(m,vector<int>(n,-1));\\n        int left=0,right=n-1,up=0,down=m-1;\\n        while(left<=right && up<=down && head)\\n        {\\n\\n            for(int col=left;col<=right;col++)\\n            {\\n                if(head)\\n                {\\n                    ans[up][col]=head->val;\\n                    head=head->next;\\n                }\\n                else break;\\n            }\\n            up++;\\n            \\n            for(int row=up;row<=down;row++)\\n            {\\n                if(head)\\n                {\\n                    ans[row][right]=head->val;\\n                    head=head->next;\\n                }\\n                else break;\\n            }\\n        \\n        right--;\\n            \\n            \\n            for(int col=right;col>=left;col--)\\n            {\\n                if(head)\\n                {\\n                    ans[down][col]=head->val;\\n                    head=head->next;\\n                }\\n                else break;\\n                \\n            }\\n            down--;\\n            \\n            for(int row=down;row>=up;row--)\\n            {\\n                 if(head)\\n                {\\n                    ans[row][left]=head->val;\\n                    head=head->next;\\n                }\\n                else break;\\n            }\\n            left++;\\n        \\n        \\n        \\n        \\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "Linked List",
                    "Matrix"
                ],
                "code": "class Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        // TIME- O(N*M)  SPACE - O(N*M)\\n        vector<vector<int>> ans(m,vector<int>(n,-1));\\n        int left=0,right=n-1,up=0,down=m-1;\\n        while(left<=right && up<=down && head)\\n        {\\n\\n            for(int col=left;col<=right;col++)\\n            {\\n                if(head)\\n                {\\n                    ans[up][col]=head->val;\\n                    head=head->next;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2233775,
                "title": "javascript-simple-easy-to-understand-matrix",
                "content": "```\\nvar spiralMatrix = function(m, n, head) {\\n    let matrix = []\\n    for (let i = 0; i < m; i++) {\\n        let arr = [];\\n        for (let j = 0; j < n; j++) arr.push(-1)\\n        matrix.push(arr)\\n    }\\n    let list = []\\n    let li = head\\n    while (li != null) {\\n        list.push(li.val)\\n        li = li.next;\\n    }\\n    let index = 0\\n    let rowBoundaries = 0\\n    let colBoundaries = 0\\n    let row = 0\\n    let col = -1\\n    while (true) {\\n        while (col<matrix[0].length-colBoundaries-1 && index<list.length) {\\n            col++\\n            matrix[row][col] = list[index]\\n            index++\\n        }\\n        while (row<matrix.length-rowBoundaries-1 && index<list.length) {\\n            row++\\n            matrix[row][col] = list[index]\\n            index++\\n        }\\n        while (col>colBoundaries && index<list.length) {\\n            col--\\n            matrix[row][col] = list[index]\\n            index++\\n        }\\n        rowBoundaries++\\n        colBoundaries++\\n        while (row>rowBoundaries && index<list.length) {\\n            row--\\n            matrix[row][col] = list[index]\\n            index++\\n        }\\n        if (index>=list.length) break\\n    }\\n    return matrix\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Linked List",
                    "Matrix"
                ],
                "code": "```\\nvar spiralMatrix = function(m, n, head) {\\n    let matrix = []\\n    for (let i = 0; i < m; i++) {\\n        let arr = [];\\n        for (let j = 0; j < n; j++) arr.push(-1)\\n        matrix.push(arr)\\n    }\\n    let list = []\\n    let li = head\\n    while (li != null) {\\n        list.push(li.val)\\n        li = li.next;\\n    }\\n    let index = 0\\n    let rowBoundaries = 0\\n    let colBoundaries = 0\\n    let row = 0\\n    let col = -1\\n    while (true) {\\n        while (col<matrix[0].length-colBoundaries-1 && index<list.length) {\\n            col++\\n            matrix[row][col] = list[index]\\n            index++\\n        }\\n        while (row<matrix.length-rowBoundaries-1 && index<list.length) {\\n            row++\\n            matrix[row][col] = list[index]\\n            index++\\n        }\\n        while (col>colBoundaries && index<list.length) {\\n            col--\\n            matrix[row][col] = list[index]\\n            index++\\n        }\\n        rowBoundaries++\\n        colBoundaries++\\n        while (row>rowBoundaries && index<list.length) {\\n            row--\\n            matrix[row][col] = list[index]\\n            index++\\n        }\\n        if (index>=list.length) break\\n    }\\n    return matrix\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2231059,
                "title": "c-easy-code-simple-to-under-stand",
                "content": "\\n       \\n        \\n\\tclass Solution {\\n\\tpublic:\\n\\t\\t\\t\\tvector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n\\t\\t\\t\\tListNode* my = head;\\n\\t\\t\\t\\tvector<vector<int>> map;\\n\\t\\t\\t\\tmap.assign(m, vector<int>(n, -1));\\n\\n\\t\\t\\t\\tint ox[4]= {1, 0, -1, 0};     // for direction change \\n\\t\\t\\t\\tint oy[4]= {0, 1, 0, -1};    //  [right -> down -> left -> up]  is repeated\\n\\n\\t\\t\\t\\tint w = 0; int h =0;\\n\\t\\t\\t\\tmap[h][w] = my->val; // add first \\n\\t\\t\\t\\tint cur=1;  // add first,  so cur is 1 \\n\\t\\t\\t\\tint i=0;    // check direction \\n\\t\\t\\t\\tint num=0;  \\n\\n\\t\\t\\t\\twhile(m*n !=cur) {    // do this while m*n \\n\\n\\t\\t\\t\\t\\t// step1.  check can use next number?, if not  use  -1 \\n\\t\\t\\t\\t\\tif(my->next != NULL){\\n\\t\\t\\t\\t\\t\\tmy = my->next;\\n\\t\\t\\t\\t\\t\\tnum = my->val;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\tnum = -1; \\n\\n\\n\\t\\t\\t\\t   // 0 0 0 1\\n\\t\\t\\t\\t   // 3 4 4 1 \\n\\t\\t\\t\\t   // 3 2 2 2\\n\\n\\t\\t\\t\\t\\t// step2. check  can access and  is not visited   => keep current direction\\n\\t\\t\\t\\t\\t// if not? => change direction\\n\\t\\t\\t\\t\\tif( (h+oy[i] >= 0 && h+oy[i]< m && w+ox[i] >=0 && w+ox[i] < n) && map[h+oy[i]][w+ox[i]] == -1)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\th+=oy[i];\\n\\t\\t\\t\\t\\t\\tw+=ox[i];                \\n\\n\\t\\t\\t\\t\\t}else{\\n\\t\\t\\t\\t\\t\\ti=(i+1)%4;\\n\\t\\t\\t\\t\\t\\th+=oy[i];\\n\\t\\t\\t\\t\\t\\tw+=ox[i];              \\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tmap[h][w] = num;\\n\\t\\t\\t\\t\\tcur++;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn map;\\n\\n\\t\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\t\\t\\tvector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n\\t\\t\\t\\tListNode* my = head;\\n\\t\\t\\t\\tvector<vector<int>> map;\\n\\t\\t\\t\\tmap.assign(m, vector<int>(n, -1));\\n\\n\\t\\t\\t\\tint ox[4]= {1, 0, -1, 0}",
                "codeTag": "Java"
            },
            {
                "id": 2230824,
                "title": "simple-c-solution-o-m-n",
                "content": "```\\nclass Solution {\\n    \\npublic:\\n    \\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        \\n        vector<vector<int>>mat(m,vector<int>(n,-1)) ;\\n\\n        int dir = 1 ;\\n        \\n        /*\\n        1 = left to right\\n        2 = up to down\\n        3 = right to left\\n        4 = down to up\\n        */\\n        int left=0 , right=n-1 , up=0 , down=m-1 ;\\n        int count = 1 ;\\n        \\n        while( head != NULL && left <= right && up <= down )\\n        {\\n            \\n                if(dir == 1)\\n                {\\n                    for(int i=left;i<=right;i++)\\n                    {\\n                        if(head==NULL)break;\\n                        mat[up][i]=head->val ;\\n                        head=head->next ;\\n                    }\\n                    \\n                    up++;\\n                    dir++;\\n                }\\n                else if(dir == 2)\\n                {\\n                    for(int i=up;i<=down;i++)\\n                    {\\n                        if(head==NULL)break;\\n                        mat[i][right]=head->val ;\\n                        head=head->next ;\\n                    }\\n                    right--;\\n                    dir++;\\n                }\\n                else if(dir == 3)\\n                {\\n                    for(int i=right;i>=left;i--)\\n                    {\\n                        if(head==NULL)break;\\n                        mat[down][i]=head->val ;\\n                        head=head->next ;\\n                    }\\n                    down--;\\n                    dir++;\\n                }\\n                else\\n                {\\n                    for(int i=down;i>=up;i--)\\n                    {\\n                        if(head==NULL)break;\\n                        mat[i][left]=head->val ;\\n                        head=head->next ;\\n                    }\\n                    left++;\\n                    dir = 1;\\n                }\\n            \\n        }\\n        return mat;\\n \\n    }\\n    \\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    \\npublic:\\n    \\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        \\n        vector<vector<int>>mat(m,vector<int>(n,-1)) ;\\n\\n        int dir = 1 ;\\n        \\n        /*\\n        1 = left to right\\n        2 = up to down\\n        3 = right to left\\n        4 = down to up\\n        */\\n        int left=0 , right=n-1 , up=0 , down=m-1 ;\\n        int count = 1 ;\\n        \\n        while( head != NULL && left <= right && up <= down )\\n        {\\n            \\n                if(dir == 1)\\n                {\\n                    for(int i=left;i<=right;i++)\\n                    {\\n                        if(head==NULL)break;\\n                        mat[up][i]=head->val ;\\n                        head=head->next ;\\n                    }\\n                    \\n                    up++;\\n                    dir++;\\n                }\\n                else if(dir == 2)\\n                {\\n                    for(int i=up;i<=down;i++)\\n                    {\\n                        if(head==NULL)break;\\n                        mat[i][right]=head->val ;\\n                        head=head->next ;\\n                    }\\n                    right--;\\n                    dir++;\\n                }\\n                else if(dir == 3)\\n                {\\n                    for(int i=right;i>=left;i--)\\n                    {\\n                        if(head==NULL)break;\\n                        mat[down][i]=head->val ;\\n                        head=head->next ;\\n                    }\\n                    down--;\\n                    dir++;\\n                }\\n                else\\n                {\\n                    for(int i=down;i>=up;i--)\\n                    {\\n                        if(head==NULL)break;\\n                        mat[i][left]=head->val ;\\n                        head=head->next ;\\n                    }\\n                    left++;\\n                    dir = 1;\\n                }\\n            \\n        }\\n        return mat;\\n \\n    }\\n    \\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2230508,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Time Complexity :- O(N * M)***\\n\\n* ***Space Complexity :- O(1)***\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int n, int m, ListNode* head) {\\n        \\n        ListNode* curr = head;\\n        \\n        vector<vector<int>> res(n, vector<int> (m, -1));\\n        \\n        int top = 0;\\n        \\n        int bottom = n - 1;\\n        \\n        int left = 0;\\n        \\n        int right = m - 1;\\n        \\n        while(top <= bottom && left <= right)\\n        {\\n            // fill the top row\\n            \\n            if(top <= bottom)\\n            {\\n                for(int i = left; i <= right && curr; i++)\\n                {\\n                    res[top][i] = curr -> val;\\n                    \\n                    curr = curr -> next;\\n                }\\n                \\n                top++;\\n            }\\n            \\n            // fill the right col\\n            \\n            if(left <= right)\\n            {\\n                for(int i = top; i <= bottom && curr; i++)\\n                {\\n                    res[i][right] = curr -> val;\\n                    \\n                    curr = curr -> next;\\n                }\\n                \\n                right--;\\n            }\\n            \\n            // fill the bottom row\\n            \\n            if(top <= bottom)\\n            {\\n                for(int i = right; i >= left && curr; i--)\\n                {\\n                    res[bottom][i] = curr -> val;\\n                    \\n                    curr = curr -> next;\\n                }\\n                \\n                bottom--;\\n            }\\n            \\n            // fill the left col\\n            \\n            if(left <= right)\\n            {\\n                for(int i = bottom; i >= top && curr; i--)\\n                {\\n                    res[i][left] = curr -> val;\\n                    \\n                    curr = curr -> next;\\n                }\\n                \\n                left++;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int n, int m, ListNode* head) {\\n        \\n        ListNode* curr = head;\\n        \\n        vector<vector<int>> res(n, vector<int> (m, -1));\\n        \\n        int top = 0;\\n        \\n        int bottom = n - 1;\\n        \\n        int left = 0;\\n        \\n        int right = m - 1;\\n        \\n        while(top <= bottom && left <= right)\\n        {\\n            // fill the top row\\n            \\n            if(top <= bottom)\\n            {\\n                for(int i = left; i <= right && curr; i++)\\n                {\\n                    res[top][i] = curr -> val;\\n                    \\n                    curr = curr -> next;\\n                }\\n                \\n                top++;\\n            }\\n            \\n            // fill the right col\\n            \\n            if(left <= right)\\n            {\\n                for(int i = top; i <= bottom && curr; i++)\\n                {\\n                    res[i][right] = curr -> val;\\n                    \\n                    curr = curr -> next;\\n                }\\n                \\n                right--;\\n            }\\n            \\n            // fill the bottom row\\n            \\n            if(top <= bottom)\\n            {\\n                for(int i = right; i >= left && curr; i--)\\n                {\\n                    res[bottom][i] = curr -> val;\\n                    \\n                    curr = curr -> next;\\n                }\\n                \\n                bottom--;\\n            }\\n            \\n            // fill the left col\\n            \\n            if(left <= right)\\n            {\\n                for(int i = bottom; i >= top && curr; i--)\\n                {\\n                    res[i][left] = curr -> val;\\n                    \\n                    curr = curr -> next;\\n                }\\n                \\n                left++;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2230352,
                "title": "simple-solution-in-c",
                "content": "```/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        vector<vector<int>> ans(m,vector<int>(n,-1));\\n        int r1=0,r2=m-1,c1=0,c2=n-1;\\n        \\n        while( (r1<=r2 && c1<=c2) && head){\\n            \\n            for(int i=c1;i<=c2 && head;i++){\\n                ans[r1][i]=head->val;\\n                head=head->next;\\n            }\\n            r1++;\\n            for(int i=r1;i<=r2 && head;i++){\\n                ans[i][c2]=head->val;\\n                head=head->next;\\n            }\\n            c2--;\\n            for(int i=c2;i>=c1 && head;i--){\\n                ans[r2][i]=head->val;\\n                head=head->next;\\n            }\\n            r2--;\\n            \\n            for(int i=r2;i>=r1 && head;i--){\\n                ans[i][c1]=head->val;\\n                head=head->next;\\n            }\\n            c1++;\\n            \\n            \\n        }\\n        return ans;\\n    }\\n};```",
                "solutionTags": [],
                "code": "```/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        vector<vector<int>> ans(m,vector<int>(n,-1));\\n        int r1=0,r2=m-1,c1=0,c2=n-1;\\n        \\n        while( (r1<=r2 && c1<=c2) && head){\\n            \\n            for(int i=c1;i<=c2 && head;i++){\\n                ans[r1][i]=head->val;\\n                head=head->next;\\n            }\\n            r1++;\\n            for(int i=r1;i<=r2 && head;i++){\\n                ans[i][c2]=head->val;\\n                head=head->next;\\n            }\\n            c2--;\\n            for(int i=c2;i>=c1 && head;i--){\\n                ans[r2][i]=head->val;\\n                head=head->next;\\n            }\\n            r2--;\\n            \\n            for(int i=r2;i>=r1 && head;i--){\\n                ans[i][c1]=head->val;\\n                head=head->next;\\n            }\\n            c1++;\\n            \\n            \\n        }\\n        return ans;\\n    }\\n};```",
                "codeTag": "Java"
            },
            {
                "id": 2230108,
                "title": "c",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        \\n        vector<vector<int>> ans(m, vector<int> (n,-1));\\n        \\n        int top=0,bottom=m-1,left=0,right=n-1;\\n        \\n        while(top<=bottom && left <= right)\\n        {\\n            for(int i=left;i<=right&&head;i++)\\n            {\\n                ans[top][i] = head->val;\\n                head = head->next;\\n                if(!head)\\n                    break;\\n            }\\n            top++;\\n            \\n            for(int i=top;i<=bottom&&head;i++)\\n            {\\n                ans[i][right] = head->val;\\n                head = head->next;\\n                if(!head)\\n                    break;\\n            }\\n            \\n            right--;\\n            \\n            for(int i=right;i>=left&&head;i--)\\n            {\\n                ans[bottom][i]  = head->val;\\n                head=head->next;\\n                if(!head)\\n                    break;\\n            }\\n            \\n            bottom--;\\n            \\n            for(int i=bottom;i>=top&&head;i--)\\n            {\\n                ans[i][left] = head->val;\\n                head=head->next;\\n                if(!head)\\n                    break;\\n            }\\n            \\n            left++;\\n            \\n        }\\n        \\n        return ans;\\n        \\n     }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        \\n        vector<vector<int>> ans(m, vector<int> (n,-1));\\n        \\n        int top=0,bottom=m-1,left=0,right=n-1;\\n        \\n        while(top<=bottom && left <= right)\\n        {\\n            for(int i=left;i<=right&&head;i++)\\n            {\\n                ans[top][i] = head->val;\\n                head = head->next;\\n                if(!head)\\n                    break;\\n            }\\n            top++;\\n            \\n            for(int i=top;i<=bottom&&head;i++)\\n            {\\n                ans[i][right] = head->val;\\n                head = head->next;\\n                if(!head)\\n                    break;\\n            }\\n            \\n            right--;\\n            \\n            for(int i=right;i>=left&&head;i--)\\n            {\\n                ans[bottom][i]  = head->val;\\n                head=head->next;\\n                if(!head)\\n                    break;\\n            }\\n            \\n            bottom--;\\n            \\n            for(int i=bottom;i>=top&&head;i--)\\n            {\\n                ans[i][left] = head->val;\\n                head=head->next;\\n                if(!head)\\n                    break;\\n            }\\n            \\n            left++;\\n            \\n        }\\n        \\n        return ans;\\n        \\n     }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2229922,
                "title": "c-spiral-matrix-1",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        vector<vector<int>>ans(m,vector<int>(n,-1));\\n        int minrow = 0;\\n        int mincol = 0;\\n        int maxrow = m-1;\\n        int maxcol = n-1;\\n        int x = 1;\\n        while(x<=m*n){\\n            //right\\n            for(int i=mincol;i<=maxcol;i++){\\n                if(!head){\\n                    ans[minrow][i] = -1;\\n                    x++;\\n                }else{\\n                    ans[minrow][i] = head->val;\\n                    head = head->next;\\n                    x++;\\n                }\\n            }\\n            \\n            minrow++;\\n            //down\\n            if(x<=m*n){\\n            for(int i=minrow;i<=maxrow;i++){\\n                if(!head){\\n                    ans[i][maxcol] = -1;\\n                    x++;\\n                }else{\\n                    ans[i][maxcol] = head->val;\\n                    head = head->next;\\n                    x++;\\n                }\\n            }\\n            \\n            maxcol--;\\n            }\\n            //left\\n            if(x<=m*n){\\n            for(int i=maxcol;i>=mincol;i--){\\n                if(!head){\\n                    ans[maxrow][i] = -1;\\n                    x++;\\n                }else{\\n                    ans[maxrow][i] = head->val;\\n                    head = head->next;\\n                    x++;\\n                }\\n            }\\n            \\n            maxrow--;\\n            }\\n            //up\\n            if(x<=m*n){\\n            for(int i=maxrow;i>=minrow;i--){\\n                if(!head){\\n                    ans[i][mincol] = -1;\\n                    x++;\\n                }else{\\n                    ans[i][mincol] = head->val;\\n                    head = head->next;\\n                    x++;\\n                }\\n            }\\n            mincol++;\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        vector<vector<int>>ans(m,vector<int>(n,-1));\\n        int minrow = 0;\\n        int mincol = 0;\\n        int maxrow = m-1;\\n        int maxcol = n-1;\\n        int x = 1;\\n        while(x<=m*n){\\n            //right\\n            for(int i=mincol;i<=maxcol;i++){\\n                if(!head){\\n                    ans[minrow][i] = -1;\\n                    x++;\\n                }else{\\n                    ans[minrow][i] = head->val;\\n                    head = head->next;\\n                    x++;\\n                }\\n            }\\n            \\n            minrow++;\\n            //down\\n            if(x<=m*n){\\n            for(int i=minrow;i<=maxrow;i++){\\n                if(!head){\\n                    ans[i][maxcol] = -1;\\n                    x++;\\n                }else{\\n                    ans[i][maxcol] = head->val;\\n                    head = head->next;\\n                    x++;\\n                }\\n            }\\n            \\n            maxcol--;\\n            }\\n            //left\\n            if(x<=m*n){\\n            for(int i=maxcol;i>=mincol;i--){\\n                if(!head){\\n                    ans[maxrow][i] = -1;\\n                    x++;\\n                }else{\\n                    ans[maxrow][i] = head->val;\\n                    head = head->next;\\n                    x++;\\n                }\\n            }\\n            \\n            maxrow--;\\n            }\\n            //up\\n            if(x<=m*n){\\n            for(int i=maxrow;i>=minrow;i--){\\n                if(!head){\\n                    ans[i][mincol] = -1;\\n                    x++;\\n                }else{\\n                    ans[i][mincol] = head->val;\\n                    head = head->next;\\n                    x++;\\n                }\\n            }\\n            mincol++;\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3509623,
                "title": "beats-98-6-only-loops-python-3-explained",
                "content": "# Intuition\\nThe code is very similar to the SPIRAL MATRIX I / II but here you need to check if we reach at the end of head i.e head.next = None;\\nif it is None return ans as we reached end and all other matrix coloumn will be -1 (ans matrix is prefilled with -1)\\nIts a pretty long code and shorter codes are also available but its a good practice to know how loops work! ;)\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def spiralMatrix(self, m: int, n: int, head: Optional[ListNode]) -> List[List[int]]:\\n        ans = [[-1]*(n) for _ in range(m)]\\n        first_row = 0\\n        first_col = 0\\n        last_row = m - 1\\n        last_col = n - 1\\n        while first_row < last_row and first_col < last_col:\\n            for j in range(first_col, last_col):\\n                ans[first_row][j] = head.val\\n                head = head.next\\n                if head == None:\\n                    return ans\\n                \\n            for i in range(first_row, last_row):\\n                ans[i][last_col] = head.val\\n                head = head.next\\n                if head == None:\\n                    return ans\\n            for j in range(last_col, first_col, -1):\\n                ans[last_row][j] = head.val\\n                head = head.next\\n                if head == None:\\n                    return ans\\n            for i in range(last_row, first_row, -1):\\n                ans[i][first_col] = head.val\\n                head = head.next\\n                if head == None:\\n                    return ans\\n            first_row += 1\\n            first_col += 1\\n            last_row -= 1\\n            last_col -= 1\\n       \\n        if head != None:\\n            for i in range(first_row, last_row + 1):\\n                for j in range(first_col, last_col + 1):\\n                    ans[i][j] = head.val\\n                    head = head.next \\n                    if head == None:\\n                        return ans \\n        return(ans)\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Linked List",
                    "Matrix",
                    "Simulation"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def spiralMatrix(self, m: int, n: int, head: Optional[ListNode]) -> List[List[int]]:\\n        ans = [[-1]*(n) for _ in range(m)]\\n        first_row = 0\\n        first_col = 0\\n        last_row = m - 1\\n        last_col = n - 1\\n        while first_row < last_row and first_col < last_col:\\n            for j in range(first_col, last_col):\\n                ans[first_row][j] = head.val\\n                head = head.next\\n                if head == None:\\n                    return ans\\n                \\n            for i in range(first_row, last_row):\\n                ans[i][last_col] = head.val\\n                head = head.next\\n                if head == None:\\n                    return ans\\n            for j in range(last_col, first_col, -1):\\n                ans[last_row][j] = head.val\\n                head = head.next\\n                if head == None:\\n                    return ans\\n            for i in range(last_row, first_row, -1):\\n                ans[i][first_col] = head.val\\n                head = head.next\\n                if head == None:\\n                    return ans\\n            first_row += 1\\n            first_col += 1\\n            last_row -= 1\\n            last_col -= 1\\n       \\n        if head != None:\\n            for i in range(first_row, last_row + 1):\\n                for j in range(first_col, last_col + 1):\\n                    ans[i][j] = head.val\\n                    head = head.next \\n                    if head == None:\\n                        return ans \\n        return(ans)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3401508,
                "title": "simple-c-solution",
                "content": "# Intuition\\nSpiral traversal means we will have to maintain four pointers right, down, left and up. In each iteration we will update these values until the number of values in matrix becomes = no. of rows * no.of columns.\\n\\n# Approach\\nInitialize a 2d vector of size m*n containing -10 or any other number.\\nInitialize current i and current j pointers to be initially 0 and -1. \\nInitialize pointers right = n (travel n distance right), then down = m-1 (travel m-1 distance down) then left = n-1 (travel n-1 distance left) and finally travel up = m-2 distance upwards to complete one rotation. Now, for next rotation, update distances right, left, down and up. \\nIf you carefully draw a spiral matrix on paper and trace the spiral rotations, you will notice that right should be updated as left-1, down updates as up-1, left updates as right-1 and up updates as down-1.\\n\\nNow, if head of linked list is pointing to null, then we will set\\nans[current i][current j] = -1 or else ans[current i][current j] = head -> val and make head = head -> next.\\n\\nNow in each step we will have to update the no. of values in the linkedlist that we visited. For right travseral we will increase the values variable by \\'right\\' and so on for others. Then, in between traversing to the next direction i.e. from right to down, from down to left, from left to up we will check if values variable is equal to m*n or not and if so break and return the answer vector.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        vector<vector<int>> ans(vector<vector<int>>(m,vector<int>(n,-10)));\\n        int cur_i = 0, cur_j = -1, values = 0;\\n        int right = n, down = m-1, left = n-1, up = m-2;\\n        while(values <= m*n) {\\n            for(int i=1;i<=right;i++) {\\n                cur_j++;\\n                if(head==NULL) {\\n                    ans[cur_i][cur_j] = -1;\\n                    // cout<<-1<<endl;\\n                }\\n                else{\\n                    ans[cur_i][cur_j] = head -> val;\\n                    // cout<<head->val<<endl;\\n                    head = head -> next;\\n                }\\n            }\\n\\n            values += right;\\n\\n            if(values >= m*n) break;\\n\\n            if(cur_j > n-1) {\\n                cur_j--;\\n            }\\n\\n            for(int i=1;i<=down;i++) {\\n                cur_i++;\\n                if(head==NULL) {\\n                    ans[cur_i][cur_j] = -1;\\n                    // cout<<-1<<endl;\\n                }\\n                else{\\n                    ans[cur_i][cur_j] = head -> val;\\n                    // cout<<head->val<<endl;\\n                    head = head -> next;\\n                }\\n            }\\n\\n            values += down;\\n\\n            if(values >= m*n) break;\\n\\n            if(cur_i > m-1) {\\n                cur_i--;\\n            }\\n\\n            for(int i=1;i<=left;i++) {\\n                cur_j--;\\n                if(head == NULL) {\\n                    ans[cur_i][cur_j] = -1;\\n                }\\n                else{\\n                    ans[cur_i][cur_j] = head -> val;\\n                    head = head -> next;\\n                }\\n            }\\n\\n            values += left;\\n\\n            if(values >= m*n) break;\\n\\n            if(cur_j < 0) {\\n                cur_j++;\\n            }\\n\\n            for(int i=1;i<=up;i++) {\\n                cur_i--;\\n                if(head == NULL) {\\n                    ans[cur_i][cur_j] = -1;\\n                }\\n                else{\\n                    ans[cur_i][cur_j] = head -> val;\\n                    head = head -> next;\\n                }\\n            }\\n\\n            values += up;\\n\\n            if(values >= m*n) break;\\n\\n            if(cur_i < 0) {\\n                cur_i++;\\n            }\\n\\n            right=left-1;\\n            down = up-1;\\n            left = right-1;\\n            up = down-1;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        vector<vector<int>> ans(vector<vector<int>>(m,vector<int>(n,-10)));\\n        int cur_i = 0, cur_j = -1, values = 0;\\n        int right = n, down = m-1, left = n-1, up = m-2;\\n        while(values <= m*n) {\\n            for(int i=1;i<=right;i++) {\\n                cur_j++;\\n                if(head==NULL) {\\n                    ans[cur_i][cur_j] = -1;\\n                    // cout<<-1<<endl;\\n                }\\n                else{\\n                    ans[cur_i][cur_j] = head -> val;\\n                    // cout<<head->val<<endl;\\n                    head = head -> next;\\n                }\\n            }\\n\\n            values += right;\\n\\n            if(values >= m*n) break;\\n\\n            if(cur_j > n-1) {\\n                cur_j--;\\n            }\\n\\n            for(int i=1;i<=down;i++) {\\n                cur_i++;\\n                if(head==NULL) {\\n                    ans[cur_i][cur_j] = -1;\\n                    // cout<<-1<<endl;\\n                }\\n                else{\\n                    ans[cur_i][cur_j] = head -> val;\\n                    // cout<<head->val<<endl;\\n                    head = head -> next;\\n                }\\n            }\\n\\n            values += down;\\n\\n            if(values >= m*n) break;\\n\\n            if(cur_i > m-1) {\\n                cur_i--;\\n            }\\n\\n            for(int i=1;i<=left;i++) {\\n                cur_j--;\\n                if(head == NULL) {\\n                    ans[cur_i][cur_j] = -1;\\n                }\\n                else{\\n                    ans[cur_i][cur_j] = head -> val;\\n                    head = head -> next;\\n                }\\n            }\\n\\n            values += left;\\n\\n            if(values >= m*n) break;\\n\\n            if(cur_j < 0) {\\n                cur_j++;\\n            }\\n\\n            for(int i=1;i<=up;i++) {\\n                cur_i--;\\n                if(head == NULL) {\\n                    ans[cur_i][cur_j] = -1;\\n                }\\n                else{\\n                    ans[cur_i][cur_j] = head -> val;\\n                    head = head -> next;\\n                }\\n            }\\n\\n            values += up;\\n\\n            if(values >= m*n) break;\\n\\n            if(cur_i < 0) {\\n                cur_i++;\\n            }\\n\\n            right=left-1;\\n            down = up-1;\\n            left = right-1;\\n            up = down-1;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3354861,
                "title": "beats-90-46-easy-basic-solution",
                "content": "\\n# Approach\\n\\n---\\n\\nFill Matrix By traverssing Linked List\\n\\n# Complexity\\n\\n- Space complexity:\\nO(N^2)\\n\\n# Code\\n\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n\\n---\\n\\n    def spiralMatrix(self, m: int, n: int, head: Optional[ListNode]) -> List[List[int]]:\\n        mat=[[-1 for i in range(n)]for j in range(m)]\\n        colbegin=0\\n        rowbegin=0\\n        colend=n\\n        rowend=m\\n        while rowbegin<rowend and colbegin<colend and head!=None:\\n            for i in range(colbegin,colend):\\n                if head!=None:\\n                    mat[rowbegin][i]=head.val\\n                    head=head.next\\n            for j in range(rowbegin+1,rowend-1):\\n                if head!=None:\\n                    mat[j][colend-1]=head.val\\n                    head=head.next\\n            if rowbegin!=rowend-1:\\n                for i in range(colend-1,colbegin-1,-1):\\n                    if head!=None:\\n                        mat[rowend-1][i]=head.val\\n                        head=head.next\\n            if colbegin!=colend-1:\\n                for j in range(rowend-2,rowbegin,-1):\\n                    if head!=None:\\n                        mat[j][colbegin]=head.val\\n                        head=head.next\\n            colbegin+=1\\n            colend-=1\\n            rowbegin+=1\\n            rowend-=1\\n        return mat",
                "solutionTags": [
                    "Python3"
                ],
                "code": "\\n# Approach\\n\\n---\\n\\nFill Matrix By traverssing Linked List\\n\\n# Complexity\\n\\n- Space complexity:\\nO(N^2)\\n\\n# Code\\n\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n\\n---\\n\\n    def spiralMatrix(self, m: int, n: int, head: Optional[ListNode]) -> List[List[int]]:\\n        mat=[[-1 for i in range(n)]for j in range(m)]\\n        colbegin=0\\n        rowbegin=0\\n        colend=n\\n        rowend=m\\n        while rowbegin<rowend and colbegin<colend and head!=None:\\n            for i in range(colbegin,colend):\\n                if head!=None:\\n                    mat[rowbegin][i]=head.val\\n                    head=head.next\\n            for j in range(rowbegin+1,rowend-1):\\n                if head!=None:\\n                    mat[j][colend-1]=head.val\\n                    head=head.next\\n            if rowbegin!=rowend-1:\\n                for i in range(colend-1,colbegin-1,-1):\\n                    if head!=None:\\n                        mat[rowend-1][i]=head.val\\n                        head=head.next\\n            if colbegin!=colend-1:\\n                for j in range(rowend-2,rowbegin,-1):\\n                    if head!=None:\\n                        mat[j][colbegin]=head.val\\n                        head=head.next\\n            colbegin+=1\\n            colend-=1\\n            rowbegin+=1\\n            rowend-=1\\n        return mat",
                "codeTag": "Java"
            },
            {
                "id": 3317158,
                "title": "easy-to-understand-clean-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] spiralMatrix(int m, int n, ListNode head) {\\n        int[][] ans = new int[m][n];\\n        int rowStart = 0;\\n        int rowEnd = m - 1;\\n        int colStart = 0;\\n        int colEnd = n - 1;\\n        ListNode temp = head;\\n\\n        while(rowStart <= rowEnd && colStart <= colEnd) {\\n            // top -->\\n            for(int j = colStart; j <= colEnd; j++) {\\n                if(temp == null) {\\n                    ans[rowStart][j] = -1;\\n                } else {\\n                    ans[rowStart][j] = temp.val;\\n                    temp = temp.next;\\n                }\\n            }\\n\\n            // Right -->\\n            for(int i = rowStart + 1; i <= rowEnd; i++) {\\n                if(temp == null) {\\n                    ans[i][colEnd] = -1;\\n                } else {\\n                    ans[i][colEnd] = temp.val;\\n                    temp = temp.next;\\n                }\\n            }\\n\\n            //Bottom -->\\n            for(int j = colEnd - 1; j >= colStart; j--) {\\n                if(rowStart == rowEnd) break; // V.V.I (base condition)\\n                if(temp == null) {\\n                    ans[rowEnd][j] = -1;\\n                } else {\\n                    ans[rowEnd][j] = temp.val;\\n                    temp = temp.next;\\n                }\\n            }\\n\\n            // Left -->\\n            for(int i = rowEnd - 1; i >= rowStart + 1; i--) {\\n                if(colStart == colEnd) break; // V.V.I (base condition)\\n                if(temp == null) {\\n                    ans[i][colStart] = -1;\\n                } else {\\n                    ans[i][colStart] = temp.val;\\n                    temp = temp.next;\\n                }\\n            }\\n\\n            rowStart++;\\n            rowEnd--;\\n            colStart++;\\n            colEnd--;\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Linked List",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] spiralMatrix(int m, int n, ListNode head) {\\n        int[][] ans = new int[m][n];\\n        int rowStart = 0;\\n        int rowEnd = m - 1;\\n        int colStart = 0;\\n        int colEnd = n - 1;\\n        ListNode temp = head;\\n\\n        while(rowStart <= rowEnd && colStart <= colEnd) {\\n            // top -->\\n            for(int j = colStart; j <= colEnd; j++) {\\n                if(temp == null) {\\n                    ans[rowStart][j] = -1;\\n                } else {\\n                    ans[rowStart][j] = temp.val;\\n                    temp = temp.next;\\n                }\\n            }\\n\\n            // Right -->\\n            for(int i = rowStart + 1; i <= rowEnd; i++) {\\n                if(temp == null) {\\n                    ans[i][colEnd] = -1;\\n                } else {\\n                    ans[i][colEnd] = temp.val;\\n                    temp = temp.next;\\n                }\\n            }\\n\\n            //Bottom -->\\n            for(int j = colEnd - 1; j >= colStart; j--) {\\n                if(rowStart == rowEnd) break; // V.V.I (base condition)\\n                if(temp == null) {\\n                    ans[rowEnd][j] = -1;\\n                } else {\\n                    ans[rowEnd][j] = temp.val;\\n                    temp = temp.next;\\n                }\\n            }\\n\\n            // Left -->\\n            for(int i = rowEnd - 1; i >= rowStart + 1; i--) {\\n                if(colStart == colEnd) break; // V.V.I (base condition)\\n                if(temp == null) {\\n                    ans[i][colStart] = -1;\\n                } else {\\n                    ans[i][colStart] = temp.val;\\n                    temp = temp.next;\\n                }\\n            }\\n\\n            rowStart++;\\n            rowEnd--;\\n            colStart++;\\n            colEnd--;\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3095576,
                "title": "c-very-simple-and-easy-spiral-logic",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int n, int m, ListNode* head) {\\n        vector<vector<int>> res(n,vector<int>(m,-1));\\n        int i = 0, j =0;\\n        while(head!=NULL)\\n        {\\n            if(j<m)\\n            {\\n                while(head!= NULL and j<m and res[i][j]== -1)\\n                {\\n                    res[i][j] = head->val;\\n                    head = head->next;\\n                    j++;\\n                }\\n                i++;\\n                j--;\\n            }\\n            if(i<n)\\n            {\\n                while(head!= NULL and i<n and res[i][j]== -1)\\n                {\\n                    res[i][j] = head->val;\\n                    head = head->next;\\n                    i++;\\n                }\\n                i--;\\n                j--;\\n            }\\n            if(j>=0)\\n            {\\n                while(head!= NULL and j>=0 and res[i][j]== -1)\\n                {\\n                    res[i][j] = head->val;\\n                    head = head->next;\\n                    j--;\\n                }\\n                i--;\\n                j++;\\n            }\\n            if(i>=0)\\n            {\\n                while(head!= NULL and i>=0 and res[i][j]== -1)\\n                {\\n                    res[i][j] = head->val;\\n                    head = head->next;\\n                    i--;\\n                }\\n                i++;\\n                j++;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int n, int m, ListNode* head) {\\n        vector<vector<int>> res(n,vector<int>(m,-1));\\n        int i = 0, j =0;\\n        while(head!=NULL)\\n        {\\n            if(j<m)\\n            {\\n                while(head!= NULL and j<m and res[i][j]== -1)\\n                {\\n                    res[i][j] = head->val;\\n                    head = head->next;\\n                    j++;\\n                }\\n                i++;\\n                j--;\\n            }\\n            if(i<n)\\n            {\\n                while(head!= NULL and i<n and res[i][j]== -1)\\n                {\\n                    res[i][j] = head->val;\\n                    head = head->next;\\n                    i++;\\n                }\\n                i--;\\n                j--;\\n            }\\n            if(j>=0)\\n            {\\n                while(head!= NULL and j>=0 and res[i][j]== -1)\\n                {\\n                    res[i][j] = head->val;\\n                    head = head->next;\\n                    j--;\\n                }\\n                i--;\\n                j++;\\n            }\\n            if(i>=0)\\n            {\\n                while(head!= NULL and i>=0 and res[i][j]== -1)\\n                {\\n                    res[i][j] = head->val;\\n                    head = head->next;\\n                    i--;\\n                }\\n                i++;\\n                j++;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2697172,
                "title": "java-simple-solution-beginner-friendly",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public int[][] spiralMatrix(int m, int n, ListNode head) {\\n        //arr to store the  answer\\n        int[][] arr = new int[m][n];\\n        //Fill every row of the array with -1\\n        for(int[] x : arr) {\\n             Arrays.fill(x,-1);\\n        }\\n        //We have to traverse spirally to get the required matrix\\n        //top-left to right\\n        //top-right to bottom\\n        //bottom-right to left\\n        //bottom-left to top\\n        //We have to traverse according to above mentioned paths from head of the linkedlist\\n        int top = 0, bottom = m-1;\\n        int left = 0, right = n-1;\\n        //traverse the list until your head didn\\'t face the null\\n        while(head!=null){\\n            //This for-loop stores elements from top.left-right\\n            for(int i = top;i<=right && head!=null ;i++){\\n                arr[top][i] = head.val;\\n                head = head.next;\\n            }\\n            //Increment the top value to avoid duplicates\\n            top++;\\n            //This for-loop stores values from top.right to bottom\\n            for(int i = top;i<=bottom && head!=null;i++){\\n                arr[i][right] = head.val;\\n                head = head.next;\\n            }\\n            //Decrement the right value to avoid duplicates\\n            right--;\\n            //This for-loop stores elements from bottom.right to left\\n            for(int i = right;i>=left && head!=null;i--){\\n                arr[bottom][i] = head.val;\\n                head = head.next;\\n            }\\n            //Decrement the bottom value to avoid duplicates\\n            bottom--;\\n            //This for-loop stores elements from bottom.left to top\\n            for(int i = bottom;i>=top && head!=null;i--){\\n                arr[i][left] = head.val;\\n                head = head.next;\\n            }\\n            //Increment the left value to avoid duplicates\\n            left++;\\n            \\n        }\\n        return arr;\\n    }\\n}\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Iterator"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public int[][] spiralMatrix(int m, int n, ListNode head) {\\n        //arr to store the  answer\\n        int[][] arr = new int[m][n];\\n        //Fill every row of the array with -1\\n        for(int[] x : arr) {\\n             Arrays.fill(x,-1);\\n        }\\n        //We have to traverse spirally to get the required matrix\\n        //top-left to right\\n        //top-right to bottom\\n        //bottom-right to left\\n        //bottom-left to top\\n        //We have to traverse according to above mentioned paths from head of the linkedlist\\n        int top = 0, bottom = m-1;\\n        int left = 0, right = n-1;\\n        //traverse the list until your head didn\\'t face the null\\n        while(head!=null){\\n            //This for-loop stores elements from top.left-right\\n            for(int i = top;i<=right && head!=null ;i++){\\n                arr[top][i] = head.val;\\n                head = head.next;\\n            }\\n            //Increment the top value to avoid duplicates\\n            top++;\\n            //This for-loop stores values from top.right to bottom\\n            for(int i = top;i<=bottom && head!=null;i++){\\n                arr[i][right] = head.val;\\n                head = head.next;\\n            }\\n            //Decrement the right value to avoid duplicates\\n            right--;\\n            //This for-loop stores elements from bottom.right to left\\n            for(int i = right;i>=left && head!=null;i--){\\n                arr[bottom][i] = head.val;\\n                head = head.next;\\n            }\\n            //Decrement the bottom value to avoid duplicates\\n            bottom--;\\n            //This for-loop stores elements from bottom.left to top\\n            for(int i = bottom;i>=top && head!=null;i--){\\n                arr[i][left] = head.val;\\n                head = head.next;\\n            }\\n            //Increment the left value to avoid duplicates\\n            left++;\\n            \\n        }\\n        return arr;\\n    }\\n}\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2673591,
                "title": "faster-than-100-easy-to-understand-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n    vector<vector<int>> ans (m,vector<int>(n,-1));\\n    int sr=0,er=m-1,sc=0,ec=n-1;\\n        \\n    while(head!=NULL){\\n       for(int i=sc;i<=ec && head!=NULL;i++){\\n           ans[sr][i]=head->val;\\n           head=head->next;\\n       }\\n      sr++;\\n      for(int i=sr;i<=er && head!=NULL;i++){\\n           ans[i][ec]=head->val;\\n           head=head->next;\\n       }\\n      ec--;\\n      for(int i=ec;i>=sc && head!=NULL;i--){\\n            ans[er][i]=head->val;\\n            head=head->next;\\n       }\\n       er--;\\n       for(int i=er;i>=sr && head!=NULL;i--){\\n           ans[i][sc]=head->val;\\n           head=head->next;\\n       }\\n    sc++;    \\n    }\\n    return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n    vector<vector<int>> ans (m,vector<int>(n,-1));\\n    int sr=0,er=m-1,sc=0,ec=n-1;\\n        \\n    while(head!=NULL){\\n       for(int i=sc;i<=ec && head!=NULL;i++){\\n           ans[sr][i]=head->val;\\n           head=head->next;\\n       }\\n      sr++;\\n      for(int i=sr;i<=er && head!=NULL;i++){\\n           ans[i][ec]=head->val;\\n           head=head->next;\\n       }\\n      ec--;\\n      for(int i=ec;i>=sc && head!=NULL;i--){\\n            ans[er][i]=head->val;\\n            head=head->next;\\n       }\\n       er--;\\n       for(int i=er;i>=sr && head!=NULL;i--){\\n           ans[i][sc]=head->val;\\n           head=head->next;\\n       }\\n    sc++;    \\n    }\\n    return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2673498,
                "title": "easy-c-solution-logic-building",
                "content": "**Please Upvote If this Helps U :)**\\n```\\nclass Solution {\\npublic:\\n    int len(ListNode* head){\\n        int ctr=0;\\n        ListNode* temp = head;\\n        while(temp!=nullptr){\\n            ctr++;\\n            temp = temp->next;\\n        }\\n        return ctr;\\n    }\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        vector<vector<int>> v(m,vector<int>(n,-1));\\n        if(head == nullptr){\\n            return v;\\n        }\\n        ListNode* temp = head;\\n        int t = len(head);\\n        int strrow = 0;\\n        int strcol = 0;\\n        int endrow = m-1;\\n        int endcol = n-1;\\n        int count = 0;\\n        while(count<t)\\n        {\\n            for(int i=strrow;count<t&&i<=endcol;i++){\\n                v[strrow][i] = temp->val;\\n                temp = temp->next;\\n                count++;\\n            }\\n            strrow++;\\n            for(int i=strrow;count<t && i<=endrow;i++){\\n                v[i][endcol] = temp->val;\\n                temp = temp->next;\\n                count++;\\n            }\\n            endcol--;\\n            for(int i=endcol;count<t &&i>=strcol;i--){\\n                \\n                v[endrow][i] = temp->val;\\n                temp = temp->next;\\n                count++;\\n            }\\n            endrow--;\\n            for(int i=endrow;count<t && i>=strrow;i--){\\n                v[i][strcol] = temp->val;\\n                temp = temp->next;\\n                count++;\\n            }\\n            strcol++;\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int len(ListNode* head){\\n        int ctr=0;\\n        ListNode* temp = head;\\n        while(temp!=nullptr){\\n            ctr++;\\n            temp = temp->next;\\n        }\\n        return ctr;\\n    }\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        vector<vector<int>> v(m,vector<int>(n,-1));\\n        if(head == nullptr){\\n            return v;\\n        }\\n        ListNode* temp = head;\\n        int t = len(head);\\n        int strrow = 0;\\n        int strcol = 0;\\n        int endrow = m-1;\\n        int endcol = n-1;\\n        int count = 0;\\n        while(count<t)\\n        {\\n            for(int i=strrow;count<t&&i<=endcol;i++){\\n                v[strrow][i] = temp->val;\\n                temp = temp->next;\\n                count++;\\n            }\\n            strrow++;\\n            for(int i=strrow;count<t && i<=endrow;i++){\\n                v[i][endcol] = temp->val;\\n                temp = temp->next;\\n                count++;\\n            }\\n            endcol--;\\n            for(int i=endcol;count<t &&i>=strcol;i--){\\n                \\n                v[endrow][i] = temp->val;\\n                temp = temp->next;\\n                count++;\\n            }\\n            endrow--;\\n            for(int i=endrow;count<t && i>=strrow;i--){\\n                v[i][strcol] = temp->val;\\n                temp = temp->next;\\n                count++;\\n            }\\n            strcol++;\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2661492,
                "title": "python-easy-understand-solution",
                "content": "```\\n# 2022.10.04\\n# The logic for this problem is the same as spiral matrix II, the only difference is we need to consider the linked list. So everytime when we update the value in the matrix, we want to make sure the head of the linked list is not pointed to null. If the linked list has been thoroughly iterated, we assign the next value to -1. \\nclass Solution:\\n    def spiralMatrix(self, m: int, n: int, head: Optional[ListNode]) -> List[List[int]]:\\n        matrix = [[0 for i in range(n)] for j in range(m)]\\n        left, right = 0, n\\n        top, bottom = 0, m \\n        while left < right and top < bottom :\\n            for i in range(left, right):\\n                if not head:\\n                    matrix[top][i] = -1\\n                else:\\n                    matrix[top][i] = head.val\\n                    head = head.next\\n            top += 1\\n            \\n            for i in range(top, bottom):\\n                if not head:\\n                    matrix[i][right-1] = -1\\n                else:\\n                    matrix[i][right-1] = head.val\\n                    head = head.next\\n            right -= 1\\n            \\n            if not (left < right and top < bottom):\\n                break\\n            \\n            for i in range(right-1, left-1, -1):\\n                if not head:\\n                    matrix[bottom-1][i] = -1\\n                else:\\n                    matrix[bottom-1][i] = head.val\\n                    head = head.next \\n            bottom -= 1\\n            \\n            for i in range(bottom-1, top-1, -1):\\n                if not head:\\n                    matrix[i][left] = - 1\\n                else:\\n                    matrix[i][left] = head.val\\n                    head = head.next\\n            left += 1\\n        return matrix \\n            \\n            \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n# 2022.10.04\\n# The logic for this problem is the same as spiral matrix II, the only difference is we need to consider the linked list. So everytime when we update the value in the matrix, we want to make sure the head of the linked list is not pointed to null. If the linked list has been thoroughly iterated, we assign the next value to -1. \\nclass Solution:\\n    def spiralMatrix(self, m: int, n: int, head: Optional[ListNode]) -> List[List[int]]:\\n        matrix = [[0 for i in range(n)] for j in range(m)]\\n        left, right = 0, n\\n        top, bottom = 0, m \\n        while left < right and top < bottom :\\n            for i in range(left, right):\\n                if not head:\\n                    matrix[top][i] = -1\\n                else:\\n                    matrix[top][i] = head.val\\n                    head = head.next\\n            top += 1\\n            \\n            for i in range(top, bottom):\\n                if not head:\\n                    matrix[i][right-1] = -1\\n                else:\\n                    matrix[i][right-1] = head.val\\n                    head = head.next\\n            right -= 1\\n            \\n            if not (left < right and top < bottom):\\n                break\\n            \\n            for i in range(right-1, left-1, -1):\\n                if not head:\\n                    matrix[bottom-1][i] = -1\\n                else:\\n                    matrix[bottom-1][i] = head.val\\n                    head = head.next \\n            bottom -= 1\\n            \\n            for i in range(bottom-1, top-1, -1):\\n                if not head:\\n                    matrix[i][left] = - 1\\n                else:\\n                    matrix[i][left] = head.val\\n                    head = head.next\\n            left += 1\\n        return matrix \\n            \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2561849,
                "title": "java",
                "content": "\\n```\\nclass Solution {\\n    static boolean[][] visited;\\n    public int[][] spiralMatrix(int m, int n, ListNode head) {\\n        int[][] res = new int[m][n];\\n        visited = new boolean[m][n];\\n        int[] coordinates = new int[]{0, 0};\\n        \\n        placeNext(head.val, res, coordinates);\\n        head = head.next;\\n        visited[0][0] = true;\\n        int direction = 0;\\n        int mult = m * n - 1;\\n        \\n        for (int i = 0; i < mult; i++) {\\n            int[] coordTemp = findNextCoord(coordinates, direction);\\n            if (!cellExists(coordTemp[0], coordTemp[1], res)) {\\n                direction++;\\n                direction %= 4;\\n                coordinates = findNextCoord(coordinates, direction);\\n            } else {\\n                coordinates = coordTemp;\\n            }\\n            if (head != null) {\\n                placeNext(head.val, res, coordinates);\\n                head = head.next;\\n            } else {\\n                placeNext(-1, res, coordinates);\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    private int[] findNextCoord(int[] coordinates, int direction) {\\n        int y = coordinates[0], x = coordinates[1];\\n        if (direction == 0) {\\n            x++;\\n        } else if (direction == 1) {\\n            y++;\\n        } else if (direction == 2) {\\n            x--;\\n        } else {\\n            y--;\\n        }\\n        return new int[]{y, x};\\n    }\\n    \\n    private void placeNext(int num, int[][] res, int[] coordinates) {\\n        res[coordinates[0]][coordinates[1]] = num;\\n        visited[coordinates[0]][coordinates[1]] = true;\\n    }\\n\\n    private boolean cellExists(int row, int col, int[][] array) {\\n        return (row <= array.length - 1 && row >= 0) && (col <= array[0].length - 1 && col >= 0) && !visited[row][col];\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    static boolean[][] visited;\\n    public int[][] spiralMatrix(int m, int n, ListNode head) {\\n        int[][] res = new int[m][n];\\n        visited = new boolean[m][n];\\n        int[] coordinates = new int[]{0, 0}",
                "codeTag": "Java"
            },
            {
                "id": 2513672,
                "title": "c-easy-understanding-o-n-solution-100-faster",
                "content": "```\\nvector<vector<int>> spiralMatrix(int n, int m, ListNode* head) {\\n\\tvector<vector<int>> res(n, vector<int> (m, -1));\\n\\tbool right = true, down = false, left = false, up = false;\\n\\n\\tint rs = 0, re = n-1;\\n\\tint cs = 0, ce = m-1;\\n\\n\\twhile(head!=NULL) {\\n\\t\\tif(right) {\\n\\t\\t\\tfor(int i=cs; i<=ce&&head!=NULL; i++) {\\n\\t\\t\\t\\tres[rs][i] = head->val;\\n\\t\\t\\t\\thead = head->next;\\n\\t\\t\\t}\\n\\t\\t\\tdown = true;\\n\\t\\t\\tright = false;\\n\\t\\t\\trs += 1;\\n\\t\\t} else if(down) {\\n\\t\\t\\tfor(int i=rs; i<=re&&head!=NULL; i++) {\\n\\t\\t\\t\\tres[i][ce] = head->val;\\n\\t\\t\\t\\thead = head->next;\\n\\t\\t\\t}\\n\\t\\t\\tleft = true;\\n\\t\\t\\tdown = false;\\n\\t\\t\\tce -= 1;\\n\\t\\t} else if(left) {\\n\\t\\t\\tfor(int i=ce; i>=cs&&head!=NULL; i--) {\\n\\t\\t\\t\\tres[re][i] = head->val;\\n\\t\\t\\t\\thead = head->next;\\n\\t\\t\\t}\\n\\t\\t\\tup = true;\\n\\t\\t\\tleft = false;\\n\\t\\t\\tre -= 1;\\n\\t\\t} else {\\n\\t\\t\\tfor(int i=re; i>=rs&&head!=NULL; i--) {\\n\\t\\t\\t\\tres[i][cs] = head->val;\\n\\t\\t\\t\\thead = head->next;\\n\\t\\t\\t}\\n\\t\\t\\tright = true;\\n\\t\\t\\tup = false;\\n\\t\\t\\tcs += 1;\\n\\t\\t}\\n\\t}\\n\\n\\treturn res;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nvector<vector<int>> spiralMatrix(int n, int m, ListNode* head) {\\n\\tvector<vector<int>> res(n, vector<int> (m, -1));\\n\\tbool right = true, down = false, left = false, up = false;\\n\\n\\tint rs = 0, re = n-1;\\n\\tint cs = 0, ce = m-1;\\n\\n\\twhile(head!=NULL) {\\n\\t\\tif(right) {\\n\\t\\t\\tfor(int i=cs; i<=ce&&head!=NULL; i++) {\\n\\t\\t\\t\\tres[rs][i] = head->val;\\n\\t\\t\\t\\thead = head->next;\\n\\t\\t\\t}\\n\\t\\t\\tdown = true;\\n\\t\\t\\tright = false;\\n\\t\\t\\trs += 1;\\n\\t\\t} else if(down) {\\n\\t\\t\\tfor(int i=rs; i<=re&&head!=NULL; i++) {\\n\\t\\t\\t\\tres[i][ce] = head->val;\\n\\t\\t\\t\\thead = head->next;\\n\\t\\t\\t}\\n\\t\\t\\tleft = true;\\n\\t\\t\\tdown = false;\\n\\t\\t\\tce -= 1;\\n\\t\\t} else if(left) {\\n\\t\\t\\tfor(int i=ce; i>=cs&&head!=NULL; i--) {\\n\\t\\t\\t\\tres[re][i] = head->val;\\n\\t\\t\\t\\thead = head->next;\\n\\t\\t\\t}\\n\\t\\t\\tup = true;\\n\\t\\t\\tleft = false;\\n\\t\\t\\tre -= 1;\\n\\t\\t} else {\\n\\t\\t\\tfor(int i=re; i>=rs&&head!=NULL; i--) {\\n\\t\\t\\t\\tres[i][cs] = head->val;\\n\\t\\t\\t\\thead = head->next;\\n\\t\\t\\t}\\n\\t\\t\\tright = true;\\n\\t\\t\\tup = false;\\n\\t\\t\\tcs += 1;\\n\\t\\t}\\n\\t}\\n\\n\\treturn res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2500516,
                "title": "c-simple-simulation-cleanest-code-4-while-loops",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        vector<vector<int>>matrix(m, vector<int>(n,-1));\\n        int i = 0, j = 0;\\n        matrix[i][j] = head->val;\\n        head = head->next;\\n        while(head){\\n            while(head and i<m and j+1<n and matrix[i][j+1]==-1){\\n                matrix[i][j+1] = head->val;\\n                head = head->next;\\n                j++;\\n            }\\n            \\n            while(head and i+1<m and j<n and matrix[i+1][j]==-1){\\n                matrix[i+1][j] = head->val;\\n                head = head->next;\\n                i++;\\n            }\\n            \\n            while(head and i<m and j-1>=0 and matrix[i][j-1]==-1){\\n                matrix[i][j-1] = head->val;\\n                head = head->next;\\n                j--;\\n            }\\n            \\n            while(head and i-1>=0 and j<n and matrix[i-1][j]==-1){\\n                matrix[i-1][j] = head->val;\\n                head = head->next;\\n                i--;\\n            }\\n        }\\n        \\n        return matrix;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        vector<vector<int>>matrix(m, vector<int>(n,-1));\\n        int i = 0, j = 0;\\n        matrix[i][j] = head->val;\\n        head = head->next;\\n        while(head){\\n            while(head and i<m and j+1<n and matrix[i][j+1]==-1){\\n                matrix[i][j+1] = head->val;\\n                head = head->next;\\n                j++;\\n            }\\n            \\n            while(head and i+1<m and j<n and matrix[i+1][j]==-1){\\n                matrix[i+1][j] = head->val;\\n                head = head->next;\\n                i++;\\n            }\\n            \\n            while(head and i<m and j-1>=0 and matrix[i][j-1]==-1){\\n                matrix[i][j-1] = head->val;\\n                head = head->next;\\n                j--;\\n            }\\n            \\n            while(head and i-1>=0 and j<n and matrix[i-1][j]==-1){\\n                matrix[i-1][j] = head->val;\\n                head = head->next;\\n                i--;\\n            }\\n        }\\n        \\n        return matrix;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2443665,
                "title": "c-simple-o-n-solution-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    // curr: direction 0=right, 1=down, 2=left, 3=top\\n    // if going in a direction and encounter end of matrix or matrix[next_i][next_j]!=-1\\n    // then switch the direction, and move to new matrix[next_i][next_j] according to the given direction\\n    // if this element is also not -1, then end the traversal\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        vector<vector<int>>ans(m,vector<int>(n,-1));\\n        int curr=0,i=0,j=0; \\n        while(head){\\n            ans[i][j]=head->val;\\n            bool check=false;\\n            switch(curr){\\n                case 0:{\\n                    if(j+1>=n || ans[i][j+1]!=-1){\\n                        curr++;\\n                        i++;\\n                    }else j++;\\n                    break;\\n                }\\n                case 1:{\\n                    if(i+1>=m || ans[i+1][j]!=-1){\\n                        curr++;\\n                        j--;\\n                    }else i++;\\n                    break;\\n                }\\n                case 2:{\\n                    if(j-1<0 || ans[i][j-1]!=-1){\\n                        curr++;\\n                        i--;\\n                    }else j--;\\n                    break;\\n                }\\n                case 3:{\\n                    if(i-1<0 || ans[i-1][j]!=-1){\\n                        curr=0;\\n                        j++;\\n                    }else i--;\\n                    break;\\n                }\\n            }\\n            if(i<0 || i>=m || j<0 || j>=n || ans[i][j]!=-1)\\n                break;\\n            head=head->next;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // curr: direction 0=right, 1=down, 2=left, 3=top\\n    // if going in a direction and encounter end of matrix or matrix[next_i][next_j]!=-1\\n    // then switch the direction, and move to new matrix[next_i][next_j] according to the given direction\\n    // if this element is also not -1, then end the traversal\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        vector<vector<int>>ans(m,vector<int>(n,-1));\\n        int curr=0,i=0,j=0; \\n        while(head){\\n            ans[i][j]=head->val;\\n            bool check=false;\\n            switch(curr){\\n                case 0:{\\n                    if(j+1>=n || ans[i][j+1]!=-1){\\n                        curr++;\\n                        i++;\\n                    }else j++;\\n                    break;\\n                }\\n                case 1:{\\n                    if(i+1>=m || ans[i+1][j]!=-1){\\n                        curr++;\\n                        j--;\\n                    }else i++;\\n                    break;\\n                }\\n                case 2:{\\n                    if(j-1<0 || ans[i][j-1]!=-1){\\n                        curr++;\\n                        i--;\\n                    }else j--;\\n                    break;\\n                }\\n                case 3:{\\n                    if(i-1<0 || ans[i-1][j]!=-1){\\n                        curr=0;\\n                        j++;\\n                    }else i--;\\n                    break;\\n                }\\n            }\\n            if(i<0 || i>=m || j<0 || j>=n || ans[i][j]!=-1)\\n                break;\\n            head=head->next;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2442580,
                "title": "c-99-86-faster-clean-and-easy-code",
                "content": "```\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        vector<vector<int>> ans(m,vector<int>(n,-1));\\n        int dir=0,top=0,down=m-1,left=0,right=n-1;\\n        while(top<=down  && left<=right && head)\\n        {\\n            if(dir==0)\\n            {\\n                for(int i=left;i<=right;i++) \\n                {\\n                    if(!head) return ans;\\n                    ans[top][i]= head->val;\\n                    head=head->next;\\n                }\\n                top++;\\n            }\\n            else if(dir==1)\\n            {\\n                 for(int i=top;i<=down;i++) \\n                {\\n                    if(!head) return ans;\\n                    ans[i][right]= head->val;\\n                    head=head->next;\\n                }\\n                right--;\\n            }\\n            else if(dir==2)\\n            {\\n                 for(int i=right;i>=left;i--) \\n                {\\n                    if(!head) return ans;\\n                    ans[down][i]= head->val;\\n                    head=head->next;\\n                }\\n                down--;\\n            }\\n            else   \\n            {\\n               for(int i=down;i>=top;i--) \\n                {\\n                    if(!head) return ans;\\n                    ans[i][left]= head->val;\\n                    head=head->next;\\n                }\\n                left++;  \\n            }\\n            dir=(dir+1)%4;\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        vector<vector<int>> ans(m,vector<int>(n,-1));\\n        int dir=0,top=0,down=m-1,left=0,right=n-1;\\n        while(top<=down  && left<=right && head)\\n        {\\n            if(dir==0)\\n            {\\n                for(int i=left;i<=right;i++) \\n                {\\n                    if(!head) return ans;\\n                    ans[top][i]= head->val;\\n                    head=head->next;\\n                }\\n                top++;\\n            }\\n            else if(dir==1)\\n            {\\n                 for(int i=top;i<=down;i++) \\n                {\\n                    if(!head) return ans;\\n                    ans[i][right]= head->val;\\n                    head=head->next;\\n                }\\n                right--;\\n            }\\n            else if(dir==2)\\n            {\\n                 for(int i=right;i>=left;i--) \\n                {\\n                    if(!head) return ans;\\n                    ans[down][i]= head->val;\\n                    head=head->next;\\n                }\\n                down--;\\n            }\\n            else   \\n            {\\n               for(int i=down;i>=top;i--) \\n                {\\n                    if(!head) return ans;\\n                    ans[i][left]= head->val;\\n                    head=head->next;\\n                }\\n                left++;  \\n            }\\n            dir=(dir+1)%4;\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2437275,
                "title": "c-easy-linked-list-traversal-and-2d-spiral-traversal",
                "content": "\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tvector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n\\n\\t\\t\\tvector<vector<int>> ans(m,vector<int>(n,-1));\\n\\t\\t\\tauto [sr,sc,er,ec] = make_tuple(0,0,m-1,n-1);\\n\\n\\t\\t\\twhile(head){\\n\\t\\t\\t\\tfor(int i=sc;i<=ec && head; i++){\\n\\t\\t\\t\\t\\tans[sr][i] = head->val;\\n\\t\\t\\t\\t\\thead = head->next;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tsr++;\\n\\t\\t\\t\\tfor(int i=sr; i<=er and head; i++){\\n\\t\\t\\t\\t\\tans[i][ec] = head->val;;\\n\\t\\t\\t\\t\\thead = head->next;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tec--;\\n\\t\\t\\t\\tfor(int i=ec;i>=sc && head; i--){\\n\\t\\t\\t\\t\\tans[er][i] = head->val;;\\n\\t\\t\\t\\t\\thead = head->next;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\ter--;\\n\\t\\t\\t\\tfor(int i=er;i>=sr && head; i--){\\n\\t\\t\\t\\t\\tans[i][sc] = head->val;;\\n\\t\\t\\t\\t\\thead = head->next;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tsc++;\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tvector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n\\n\\t\\t\\tvector<vector<int>> ans(m,vector<int>(n,-1));\\n\\t\\t\\tauto [sr,sc,er,ec] = make_tuple(0,0,m-1,n-1);\\n\\n\\t\\t\\twhile(head){\\n\\t\\t\\t\\tfor(int i=sc;i<=ec && head; i++){\\n\\t\\t\\t\\t\\tans[sr][i] = head->val;\\n\\t\\t\\t\\t\\thead = head->next;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2417327,
                "title": "c-easy-approach",
                "content": "```\\nclass Solution {\\npublic:\\n   vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n    vector<vector<int>>vec(m,vector<int>(n));\\n    int s =0;\\n    int left =0;\\n    int right = n-1;\\n    int top = 0;\\n    int bottom = m-1;\\n    ListNode *cursor = head;\\n    while (s < m*n){\\n        for(int i = left; i<=right && s<m*n; i++){\\n            if(cursor == nullptr) {\\n                vec[top][i] = -1;\\n                s++;\\n            }else{\\n                vec[top][i] = cursor->val;\\n                cursor = cursor->next;\\n                s++;\\n            }\\n        }\\n        top++;\\n        for(int i = top; i<= bottom&& s<m*n; i++){\\n            if(cursor == nullptr) {\\n                vec[i][right] = -1;\\n                s++;\\n            }else{\\n                vec[i][right] = cursor->val;\\n                cursor = cursor->next;\\n                s++;\\n            }\\n        }\\n        right--;\\n        for (int i = right; i >=left && s<m*n; i--) {\\n            if(cursor == nullptr) {\\n                vec[bottom][i] = -1;\\n                s++;\\n            }else{\\n                vec[bottom][i] = cursor->val;\\n                cursor = cursor->next;\\n                s++;\\n            }\\n        }\\n        bottom--;\\n        for(int i = bottom; i>= top&& s<m*n; i--){\\n            if(cursor== nullptr) {\\n                vec[i][left] = -1;\\n                s++;\\n            }else{\\n                vec[i][left] = cursor->val;\\n                cursor = cursor->next;\\n                s++;\\n            }\\n        }\\n        left++;\\n    }\\n    return vec;\\n}\\n};",
                "solutionTags": [
                    "C",
                    "Linked List",
                    "Matrix"
                ],
                "code": "class Solution {\\npublic:\\n   vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n    vector<vector<int>>vec(m,vector<int>(n));\\n    int s =0;\\n    int left =0;\\n    int right = n-1;\\n    int top = 0;\\n    int bottom = m-1;\\n    ListNode *cursor = head;\\n    while (s < m*n){\\n        for(int i = left; i<=right && s<m*n; i++){\\n            if(cursor == nullptr) {\\n                vec[top][i] = -1;\\n                s++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2384923,
                "title": "java-counting-round-and-predefined-border",
                "content": "Simulate each step and count total round of four directions\\n\\n```\\nclass Solution {\\n    public int[][] spiralMatrix(int m, int n, ListNode head) {\\n        int[][] res = new int[m][n];\\n        int r = 0, c = 0, d = 0, x = 0, y = 0;\\n        int[] dx = new int[] {0, 1, 0, -1};        \\n        int[] dy = new int[] {1, 0, -1, 0};\\n        int[] border = new int[] {n - 1, m - 1, 0, 1};\\n        while (c < m * n) {\\n            if (head == null) {\\n                res[x][y] = -1;\\n            } else {\\n                res[x][y] = head.val;\\n                head = head.next;\\n            }\\n            \\n            if (d == 0 && y == border[d] - r) {\\n                d++;\\n            } else if (d == 1 && x == border[d] - r) {\\n                d++;\\n            } else if (d == 2 && y == border[d] + r) {\\n                d++;\\n            } else if (d == 3 && x == border[d] + r) {\\n                d = 0;\\n                r++;\\n            }\\n            \\n            x = x + dx[d];\\n            y = y + dy[d];\\n            \\n            c++;\\n        }\\n        \\n        return res;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[][] spiralMatrix(int m, int n, ListNode head) {\\n        int[][] res = new int[m][n];\\n        int r = 0, c = 0, d = 0, x = 0, y = 0;\\n        int[] dx = new int[] {0, 1, 0, -1};        \\n        int[] dy = new int[] {1, 0, -1, 0};\\n        int[] border = new int[] {n - 1, m - 1, 0, 1};\\n        while (c < m * n) {\\n            if (head == null) {\\n                res[x][y] = -1;\\n            } else {\\n                res[x][y] = head.val;\\n                head = head.next;\\n            }\\n            \\n            if (d == 0 && y == border[d] - r) {\\n                d++;\\n            } else if (d == 1 && x == border[d] - r) {\\n                d++;\\n            } else if (d == 2 && y == border[d] + r) {\\n                d++;\\n            } else if (d == 3 && x == border[d] + r) {\\n                d = 0;\\n                r++;\\n            }\\n            \\n            x = x + dx[d];\\n            y = y + dy[d];\\n            \\n            c++;\\n        }\\n        \\n        return res;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2381911,
                "title": "java-easy-optimize-solution",
                "content": "```\\nclass Solution {\\n    public int[][] spiralMatrix(int m, int n, ListNode head) {\\n        int[][] ans=new int[m][n];\\n        for(int[] arr:ans){\\n            Arrays.fill(arr,-1);\\n        }\\n        \\n        int rowBegin=0;\\n        int rowEnd=m-1;\\n        int columnBegin=0;\\n        int columnEnd=n-1;\\n        ListNode cur=head;\\n        \\n      \\n        while(rowBegin<=rowEnd && columnBegin<=columnEnd && cur!=null){\\n            \\n            for(int i=columnBegin;i<=columnEnd && cur!=null;i++){\\n                if(cur!=null){\\n                    ans[rowBegin][i]=cur.val;\\n                }\\n               \\n                    cur=cur.next;\\n                \\n                \\n            }\\n            rowBegin++;\\n            for(int i=rowBegin;i<=rowEnd && cur!=null;i++){\\n               if(cur!=null){\\n                ans[i][columnEnd]=cur.val;\\n               }\\n                \\n                    cur=cur.next;\\n                \\n\\n            }\\n            columnEnd--;\\n            if(rowBegin<=rowEnd){\\n                for(int i=columnEnd;i>=columnBegin && cur!=null;i--){\\n                if(cur!=null){\\n                ans[rowEnd][i]=cur.val;\\n                }\\n                 \\n                    cur=cur.next;\\n                \\n\\n            }\\n           \\n            }\\n             rowEnd--;\\n            if(columnBegin<=columnEnd){\\n                for(int i=rowEnd;i>=rowBegin && cur!=null;i--){\\n                  if(cur!=null){\\n                ans[i][columnBegin]=cur.val;\\n                  }\\n                 \\n                    cur=cur.next;\\n                \\n\\n            }\\n            \\n            }\\n            columnBegin++;\\n           \\n        }\\n        return ans;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] spiralMatrix(int m, int n, ListNode head) {\\n        int[][] ans=new int[m][n];\\n        for(int[] arr:ans){\\n            Arrays.fill(arr,-1);\\n        }\\n        \\n        int rowBegin=0;\\n        int rowEnd=m-1;\\n        int columnBegin=0;\\n        int columnEnd=n-1;\\n        ListNode cur=head;\\n        \\n      \\n        while(rowBegin<=rowEnd && columnBegin<=columnEnd && cur!=null){\\n            \\n            for(int i=columnBegin;i<=columnEnd && cur!=null;i++){\\n                if(cur!=null){\\n                    ans[rowBegin][i]=cur.val;\\n                }\\n               \\n                    cur=cur.next;\\n                \\n                \\n            }\\n            rowBegin++;\\n            for(int i=rowBegin;i<=rowEnd && cur!=null;i++){\\n               if(cur!=null){\\n                ans[i][columnEnd]=cur.val;\\n               }\\n                \\n                    cur=cur.next;\\n                \\n\\n            }\\n            columnEnd--;\\n            if(rowBegin<=rowEnd){\\n                for(int i=columnEnd;i>=columnBegin && cur!=null;i--){\\n                if(cur!=null){\\n                ans[rowEnd][i]=cur.val;\\n                }\\n                 \\n                    cur=cur.next;\\n                \\n\\n            }\\n           \\n            }\\n             rowEnd--;\\n            if(columnBegin<=columnEnd){\\n                for(int i=rowEnd;i>=rowBegin && cur!=null;i--){\\n                  if(cur!=null){\\n                ans[i][columnBegin]=cur.val;\\n                  }\\n                 \\n                    cur=cur.next;\\n                \\n\\n            }\\n            \\n            }\\n            columnBegin++;\\n           \\n        }\\n        return ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2374292,
                "title": "python-simple-explained-using-layers-fast",
                "content": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def spiralMatrix(self, m: int, n: int, head: Optional[ListNode]) -> List[List[int]]:\\n        # Initialize matrix with -1\\n        matrix = [[-1 for _ in range(n)] for _ in range(m)] \\n        \\n        # Number of layers (times we need to move in spiral)\\n        layers = (min(m,n)+1)//2\\n        \\n        for layer in range(layers):\\n                 \\n            #Right\\n            \\n            for i in range(layer,n-layer):\\n                if head:\\n                    matrix[layer][i] = head.val\\n                    #print(\"Matrix : \", matrix)\\n                    head = head.next\\n                else: \\n                    break\\n                \\n            # Down\\n            \\n            for i in range(layer+1,m-layer):\\n                if head:\\n                    matrix[i][n-layer-1] = head.val\\n                    #print(\"Matrix : \", matrix)\\n                    head = head.next\\n                else: \\n                    break\\n                \\n            # Left\\n            \\n            for i in range(n-layer-2,layer-1,-1):\\n                if head:\\n                    matrix[m-layer-1][i] = head.val\\n                    #print(\"Matrix : \", matrix)\\n                    head = head.next\\n                else: \\n                    break\\n                    \\n            # Up\\n            \\n            for i in range(m-layer-2,layer,-1):\\n                if head:\\n                    matrix[i][layer] = head.val\\n                    #print(\"Matrix : \", matrix)\\n                    head = head.next\\n                else: \\n                    break\\n                    \\n        return matrix\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def spiralMatrix(self, m: int, n: int, head: Optional[ListNode]) -> List[List[int]]:\\n        # Initialize matrix with -1\\n        matrix = [[-1 for _ in range(n)] for _ in range(m)] \\n        \\n        # Number of layers (times we need to move in spiral)\\n        layers = (min(m,n)+1)//2\\n        \\n        for layer in range(layers):\\n                 \\n            #Right\\n            \\n            for i in range(layer,n-layer):\\n                if head:\\n                    matrix[layer][i] = head.val\\n                    #print(\"Matrix : \", matrix)\\n                    head = head.next\\n                else: \\n                    break\\n                \\n            # Down\\n            \\n            for i in range(layer+1,m-layer):\\n                if head:\\n                    matrix[i][n-layer-1] = head.val\\n                    #print(\"Matrix : \", matrix)\\n                    head = head.next\\n                else: \\n                    break\\n                \\n            # Left\\n            \\n            for i in range(n-layer-2,layer-1,-1):\\n                if head:\\n                    matrix[m-layer-1][i] = head.val\\n                    #print(\"Matrix : \", matrix)\\n                    head = head.next\\n                else: \\n                    break\\n                    \\n            # Up\\n            \\n            for i in range(m-layer-2,layer,-1):\\n                if head:\\n                    matrix[i][layer] = head.val\\n                    #print(\"Matrix : \", matrix)\\n                    head = head.next\\n                else: \\n                    break\\n                    \\n        return matrix\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2363867,
                "title": "c-most-intuitive-and-simple-to-understand-spiral-traversal-of-mtarix-ii",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    // very easy simple \\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        \\n        // spiral order clockwise mai fill kardo marix ko uske baad direct row by row print kardo matrix, ya direct\\n        // return kardo spiral order mai filling karke\\n        vector<vector<int>>v(m, vector<int>(n,-1));\\n        int startrow=0, endrow=m-1, startcol=0, endcol=n-1;\\n        \\n        while(startrow<=endrow and startcol<=endcol and head)\\n        {\\n            // first row\\n            for(int i=startcol;i<=endcol and head;i++){\\n                v[startrow][i] = head->val;\\n                head=head->next;\\n            }\\n            startrow++;\\n            \\n            for(int i=startrow;i<=endrow and head;i++){\\n                v[i][endcol] = head->val;\\n                head=head->next;\\n            }\\n            endcol--;\\n            \\n            for(int i=endcol;i>=startcol and head;i--){\\n                v[endrow][i] = head->val;\\n                head=head->next;\\n            }\\n            endrow--;\\n            \\n            for(int i=endrow;i>=startrow and head;i--){\\n                v[i][startcol] = head->val;\\n                head=head->next;\\n            }\\n            startcol++;\\n        }\\n        return v;\\n    }\\n};\\n```\\n***Thanks for Upvoting !***\\n\\uD83D\\uDE42",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    // very easy simple \\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        \\n        // spiral order clockwise mai fill kardo marix ko uske baad direct row by row print kardo matrix, ya direct\\n        // return kardo spiral order mai filling karke\\n        vector<vector<int>>v(m, vector<int>(n,-1));\\n        int startrow=0, endrow=m-1, startcol=0, endcol=n-1;\\n        \\n        while(startrow<=endrow and startcol<=endcol and head)\\n        {\\n            // first row\\n            for(int i=startcol;i<=endcol and head;i++){\\n                v[startrow][i] = head->val;\\n                head=head->next;\\n            }\\n            startrow++;\\n            \\n            for(int i=startrow;i<=endrow and head;i++){\\n                v[i][endcol] = head->val;\\n                head=head->next;\\n            }\\n            endcol--;\\n            \\n            for(int i=endcol;i>=startcol and head;i--){\\n                v[endrow][i] = head->val;\\n                head=head->next;\\n            }\\n            endrow--;\\n            \\n            for(int i=endrow;i>=startrow and head;i--){\\n                v[i][startcol] = head->val;\\n                head=head->next;\\n            }\\n            startcol++;\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2363802,
                "title": "java-solution",
                "content": "\\n```\\nclass Solution {\\n    public int[][] spiralMatrix(int m, int n, ListNode head) {\\n        int[][] res = new int[m][n];\\n      \\n        //fill array with -1 (so no need to fill -1, so we can straightaway return matrix after finish traversing linked list\\n        for (int[] row: res){\\n            Arrays.fill(row, -1);\\n        }\\n      \\n        //this keep track of current starting and ending point for both row and column (will be updated in the loop)\\n        int rowStart = 0, rowEnd = m-1;\\n        int colStart = 0, colEnd = n-1;\\n        \\n        //row and col keep track of current coordinate to be filled\\n        int row = 0, col = 0;\\n      \\n        while(head != null){\\n          \\n            //to check whether to start from left or right, col equals colStart means the direction is from left to right and vice versa (else condition: right to left)\\n            if(col == colStart || row == rowStart){\\n              \\n                //fill up column from colStart until colEnd while traversing the list, incrementing col)\\n                while(col <= colEnd && head != null){\\n                    res[row][col] = head.val;\\n                    head = head.next;\\n                    col++;\\n                }\\n                //reset col to colEnd (because we might have incremented col by extra 1 in while loop)\\n                //cannot simply use col-- because we might not even enter while loop\\n                col = colEnd;\\n              \\n                //once we have filled up one column, means starting row had been incremented by 1, and we set row to be rowStart\\n                rowStart++;\\n                row = rowStart;\\n                \\n                //fill up row from rowStart until rowEnd, increment row\\n                while(row <= rowEnd && head != null){\\n                    res[row][col] = head.val;\\n                    head = head.next;\\n                    row++;\\n                }\\n                //similar explanation to above;\\n                row = rowEnd;\\n              \\n                //once we have filled up one row means colEnd had decreased\\n                colEnd--;\\n                col = colEnd;\\n            } else{\\n              \\n                //similar explanation, just different direction (refer to comments above)\\n                //filling up column\\n                while(col >= colStart && head != null){\\n                    res[row][col] = head.val;\\n                    col--;\\n                    head = head.next;\\n                }\\n                rowEnd--;\\n                row = rowEnd;\\n                col = colStart;\\n                \\n                //filling up rows\\n                while(row >= rowStart && head != null){\\n                    res[row][col] = head.val;\\n                    row--;\\n                    head = head.next;\\n                }\\n                colStart++; \\n                row = rowStart;\\n                col = colStart;            \\n            }\\n        } \\n        return res;\\n    }\\n}\\n\\n//Runtime: 12 ms, faster than 85.35% of Java online submissions for Spiral Matrix IV.\\n//Memory Usage: 244.6 MB, less than 54.47% of Java online submissions for Spiral Matrix IV.",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int[][] spiralMatrix(int m, int n, ListNode head) {\\n        int[][] res = new int[m][n];\\n      \\n        //fill array with -1 (so no need to fill -1, so we can straightaway return matrix after finish traversing linked list\\n        for (int[] row: res){\\n            Arrays.fill(row, -1);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2340039,
                "title": "python-easiest-way-to-understand-simple-clean",
                "content": "```\\nclass Solution:\\n    def spiralMatrix(self, m: int, n: int, head: Optional[ListNode]) -> List[List[int]]:\\n        matrix=[[0 for i in range(n)] for j in range(m)]\\n        topRow=0\\n        bottomRow=m-1\\n        leftCol=0\\n        rightCol=n-1\\n        curr=head\\n      \\n        while(leftCol<rightCol+1 and topRow<bottomRow+1):\\n            #topRow\\n            for j in range(leftCol,rightCol+1):\\n                if curr:\\n                    matrix[topRow][j]=curr.val\\n                    curr=curr.next\\n                else:\\n                    matrix[topRow][j]=-1\\n            topRow+=1\\n          \\n            #RightCol\\n            for i in range(topRow,bottomRow+1):\\n                if curr:\\n                    matrix[i][rightCol]=curr.val\\n                    curr=curr.next\\n                else:\\n                    matrix[i][rightCol]=-1\\n            rightCol-=1\\n            \\n            #bottomRow\\n            if topRow<bottomRow:\\n                for j in range(rightCol,leftCol-1,-1):\\n                    if curr:\\n                        matrix[bottomRow][j]=curr.val\\n                        curr=curr.next\\n                    else:\\n                        matrix[bottomRow][j]=-1\\n                bottomRow-=1\\n                \\n            #leftCol    \\n            if leftCol<rightCol:\\n                for i in range(bottomRow,topRow-1,-1):\\n                    if curr:\\n                        matrix[i][leftCol]=curr.val\\n                        curr=curr.next\\n                    else:\\n                        matrix[i][leftCol]=-1\\n                leftCol+=1\\n            \\n        return matrix\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def spiralMatrix(self, m: int, n: int, head: Optional[ListNode]) -> List[List[int]]:\\n        matrix=[[0 for i in range(n)] for j in range(m)]\\n        topRow=0\\n        bottomRow=m-1\\n        leftCol=0\\n        rightCol=n-1\\n        curr=head\\n      \\n        while(leftCol<rightCol+1 and topRow<bottomRow+1):\\n            #topRow\\n            for j in range(leftCol,rightCol+1):\\n                if curr:\\n                    matrix[topRow][j]=curr.val\\n                    curr=curr.next\\n                else:\\n                    matrix[topRow][j]=-1\\n            topRow+=1\\n          \\n            #RightCol\\n            for i in range(topRow,bottomRow+1):\\n                if curr:\\n                    matrix[i][rightCol]=curr.val\\n                    curr=curr.next\\n                else:\\n                    matrix[i][rightCol]=-1\\n            rightCol-=1\\n            \\n            #bottomRow\\n            if topRow<bottomRow:\\n                for j in range(rightCol,leftCol-1,-1):\\n                    if curr:\\n                        matrix[bottomRow][j]=curr.val\\n                        curr=curr.next\\n                    else:\\n                        matrix[bottomRow][j]=-1\\n                bottomRow-=1\\n                \\n            #leftCol    \\n            if leftCol<rightCol:\\n                for i in range(bottomRow,topRow-1,-1):\\n                    if curr:\\n                        matrix[i][leftCol]=curr.val\\n                        curr=curr.next\\n                    else:\\n                        matrix[i][leftCol]=-1\\n                leftCol+=1\\n            \\n        return matrix\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2332849,
                "title": "simple-java-solution",
                "content": "class Solution {\\n    public int[][] spiralMatrix(int m, int n, ListNode head) {\\n        \\n        int[][] res = new int[m][n];\\n        ListNode temp = head;\\n        \\n        for(int[] row: res)\\n            Arrays.fill(row, -1);\\n        \\n        int rowBegin=0, rowEnd=m-1;\\n        int colBegin=0, colEnd=n-1;\\n        \\n        while(rowBegin<=rowEnd && colBegin<=colEnd && temp!=null){\\n            \\n            for(int i=colBegin; i<=colEnd && temp!=null; i++){\\n                res[rowBegin][i]=temp.val;\\n                temp=temp.next;\\n            }\\n            \\n            rowBegin++;\\n            \\n            for(int i=rowBegin; i<=rowEnd && temp!=null; i++){\\n                res[i][colEnd]=temp.val;\\n                temp=temp.next;\\n            }\\n            \\n            colEnd--;\\n            \\n            if(rowBegin<=rowEnd){\\n                for(int i=colEnd; i>=colBegin && temp!=null; i--){\\n                    res[rowEnd][i]=temp.val;\\n                    temp=temp.next;\\n                }\\n            }\\n            \\n            rowEnd--;\\n            \\n            if(colBegin<=colEnd){\\n                for(int i=rowEnd; i>=rowBegin && temp!=null; i--){\\n                    res[i][colBegin]=temp.val;\\n                    temp=temp.next;\\n                }\\n            }\\n            \\n            colBegin++;\\n            \\n        }\\n        \\n        return res;\\n        \\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int[][] spiralMatrix(int m, int n, ListNode head) {\\n        \\n        int[][] res = new int[m][n];\\n        ListNode temp = head;\\n        \\n        for(int[] row: res)\\n            Arrays.fill(row, -1);\\n        \\n        int rowBegin=0, rowEnd=m-1;\\n        int colBegin=0, colEnd=n-1;\\n        \\n        while(rowBegin<=rowEnd && colBegin<=colEnd && temp!=null){\\n            \\n            for(int i=colBegin; i<=colEnd && temp!=null; i++){\\n                res[rowBegin][i]=temp.val;\\n                temp=temp.next;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2300228,
                "title": "java-faster-than-99-97-less-space-than-91-38-easy-to-understand",
                "content": "![image](https://assets.leetcode.com/users/images/1b365162-af2e-4f40-ba51-08ffdd2dd744_1658161936.9575908.png)\\n\\n\\n```\\n// Time complexity = O(n*m)\\n// Space complexity = O(n*m) or O(1) if we ignore the results array\\n\\nclass Solution {\\n    public int[][] spiralMatrix(int m, int n, ListNode head) {\\n        int[][] result = new int[m][n];\\n        ListNode curr = head;\\n        int top = 0, right = n-1, down = m-1, left = 0;\\n        \\n        while(top <= down && left <= right) {\\n            //left to right\\n            for(int i = left; i <= right; i++) {\\n                if(curr == null) {\\n                    result[top][i] = -1;\\n                }\\n                else {\\n                    result[top][i] = curr.val;\\n                    curr = curr.next;\\n                }\\n            }\\n            \\n            //right to bottom\\n            for(int i = top + 1; i <= down; i++) {\\n                if(curr == null) {\\n                    result[i][right] = -1;\\n                }\\n                else {\\n                    result[i][right] = curr.val;\\n                    curr = curr.next;\\n                }\\n            }\\n            \\n            //bottom to left\\n            //We check first if top < down, because if they are equal then this will \\n            //overwrite the \"left to right\" step above\\n            if(top < down) {\\n                for(int i = right - 1; i >= left; i--) {\\n                    if(curr == null) {\\n                        result[down][i] = -1;\\n                    }\\n                    else {\\n                        result[down][i] = curr.val;\\n                        curr = curr.next;\\n                    }\\n                }\\n            }\\n            \\n            //left to top\\n            //We check first if left < right, because if they are equal then this will\\n            //overwrite the \"right to bottom\" step above\\n            if(left < right) {\\n                for(int i = down - 1; i > top; i--) {\\n                    if(curr == null) {\\n                        result[i][left] = -1;\\n                    }\\n                    else {\\n                        result[i][left] = curr.val;\\n                        curr = curr.next;\\n                    }\\n                }\\n            }\\n            \\n            top++; left++; right--; down--;\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n// Time complexity = O(n*m)\\n// Space complexity = O(n*m) or O(1) if we ignore the results array\\n\\nclass Solution {\\n    public int[][] spiralMatrix(int m, int n, ListNode head) {\\n        int[][] result = new int[m][n];\\n        ListNode curr = head;\\n        int top = 0, right = n-1, down = m-1, left = 0;\\n        \\n        while(top <= down && left <= right) {\\n            //left to right\\n            for(int i = left; i <= right; i++) {\\n                if(curr == null) {\\n                    result[top][i] = -1;\\n                }\\n                else {\\n                    result[top][i] = curr.val;\\n                    curr = curr.next;\\n                }\\n            }\\n            \\n            //right to bottom\\n            for(int i = top + 1; i <= down; i++) {\\n                if(curr == null) {\\n                    result[i][right] = -1;\\n                }\\n                else {\\n                    result[i][right] = curr.val;\\n                    curr = curr.next;\\n                }\\n            }\\n            \\n            //bottom to left\\n            //We check first if top < down, because if they are equal then this will \\n            //overwrite the \"left to right\" step above\\n            if(top < down) {\\n                for(int i = right - 1; i >= left; i--) {\\n                    if(curr == null) {\\n                        result[down][i] = -1;\\n                    }\\n                    else {\\n                        result[down][i] = curr.val;\\n                        curr = curr.next;\\n                    }\\n                }\\n            }\\n            \\n            //left to top\\n            //We check first if left < right, because if they are equal then this will\\n            //overwrite the \"right to bottom\" step above\\n            if(left < right) {\\n                for(int i = down - 1; i > top; i--) {\\n                    if(curr == null) {\\n                        result[i][left] = -1;\\n                    }\\n                    else {\\n                        result[i][left] = curr.val;\\n                        curr = curr.next;\\n                    }\\n                }\\n            }\\n            \\n            top++; left++; right--; down--;\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2267956,
                "title": "c-easy-to-understand-iterative",
                "content": "vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        \\n        int row=m;\\n        int col=n;\\n       \\n        ListNode* temp=head;\\n        \\n        vector<vector<int>> result(m,vector<int>(n,-1));\\n        \\n        int top=0,left=0;\\n        int bottom=row-1,right=col-1;\\n        \\n        while(left <= right && top <= bottom){\\n            \\n            \\n            //PROCESS ROW\\n            for(int i=left;i<=right;i++){                \\n                         \\n                if(temp!=NULL){\\n                    result[top][i]=temp->val;                   \\n                    temp=temp->next;\\n                }\\n                \\n            }\\n            top++;\\n            \\n            // PROCESS COLUMN\\n            for(int i=top;i<=bottom;i++){\\n                \\n               if(temp!=NULL){\\n                    result[i][right]=temp->val;                    \\n                    temp=temp->next;\\n                }\\n             \\n                \\n            }\\n            right--;\\n            \\n            //PROCESS ROW\\n            for(int i=right;i>=left;i--){\\n                \\n                if(temp!=NULL){\\n                    result[bottom][i]=temp->val;                   \\n                    temp=temp->next;\\n                }\\n                \\n               \\n            }\\n            bottom--;\\n            \\n            // PROCESS COLUMN\\n            \\n            for(int i=bottom;i>=top;i--){\\n                \\n               if(temp!=NULL){\\n                    result[i][left]=temp->val;                   \\n                    temp=temp->next;\\n                }  \\n                \\n            }\\n            left++;\\n            \\n            \\n            \\n            \\n        }\\n        \\n        return result;\\n        \\n        \\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        \\n        int row=m;\\n        int col=n;\\n       \\n        ListNode* temp=head;\\n        \\n        vector<vector<int>> result(m,vector<int>(n,-1));\\n        \\n        int top=0,left=0;\\n        int bottom=row-1,right=col-1;\\n        \\n        while(left <= right && top <= bottom){\\n            \\n            \\n            //PROCESS ROW\\n            for(int i=left;i<=right;i++){                \\n                         \\n                if(temp!=NULL){\\n                    result[top][i]=temp->val;                   \\n                    temp=temp->next;\\n                }\\n                \\n            }\\n            top++;\\n            \\n            // PROCESS COLUMN\\n            for(int i=top;i<=bottom;i++){\\n                \\n               if(temp!=NULL){\\n                    result[i][right]=temp->val;                    \\n                    temp=temp->next;\\n                }\\n             \\n                \\n            }\\n            right--;\\n            \\n            //PROCESS ROW\\n            for(int i=right;i>=left;i--){\\n                \\n                if(temp!=NULL){\\n                    result[bottom][i]=temp->val;                   \\n                    temp=temp->next;\\n                }\\n                \\n               \\n            }\\n            bottom--;\\n            \\n            // PROCESS COLUMN\\n            \\n            for(int i=bottom;i>=top;i--){\\n                \\n               if(temp!=NULL){\\n                    result[i][left]=temp->val;                   \\n                    temp=temp->next;\\n                }  \\n                \\n            }\\n            left++;\\n            \\n            \\n            \\n            \\n        }\\n        \\n        return result;\\n        \\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2264949,
                "title": "c-simplest-solution-with-comments-single-loop-traversal",
                "content": "\\n ```\\n class Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) \\n    {\\n          int r = m;//rows\\n          int c = n;//columns\\n\\t\\t  \\n          int i ; // for traversal\\n\\t      int rowindex = 0, colindex = 0; // starting positions of row and colom\\n          vector<vector<int>> matrix(r,vector<int> (c)); // matrix with r rows and c columns\\n\\t\\t  \\n          int l;\\n    \\n          while(rowindex<r and colindex<c)\\n          { \\n                  //left to right traversal\\n                  for(i=colindex;i<c;i++)\\n                  {   \\n                        if(head!=NULL)\\n                        {\\n                            l = head->val;\\n                            head = head->next;\\n                        }\\n                        else l = -1;\\n                      \\n                        matrix[rowindex][i] = l;\\n                   }\\n        \\n                  rowindex++; // first row printed\\n        \\n                 //top to bottom traversal\\n                for(i=rowindex;i<r;i++)\\n                {   \\n                     if(head!=NULL)\\n                     {\\n                         l = head->val;\\n                         head = head->next;\\n                     }\\n                     else l = -1;\\n                    \\n                     matrix[i][c-1] = l;\\n                }\\n        \\n                c--; // last column printed\\n        \\n                //right to left traversal\\n                if(rowindex<r)\\n                {\\n                   for(i = c-1; i>=colindex; i--)\\n                   {   \\n                        if(head!=NULL)\\n                        {\\n                             l = head->val;\\n                             head = head->next;\\n                        }\\n                        else l = -1;\\n                       \\n                        matrix[r-1][i] = l;\\n                    }\\n            \\n                  r--; // last row printed\\n               }\\n         \\n               //bottom to top traversal\\n              if(colindex<c)\\n              {\\n                    for(i = r-1; i >= rowindex; i--)\\n                    {   \\n                         if(head!=NULL)\\n                         {\\n                            l = head->val;\\n                           head = head->next;\\n                          }\\n                         else l = -1;\\n                         matrix[i][colindex] = l;\\n                    }\\n           \\n                   colindex++; // first column printed\\n              }\\n        \\n             }//end of while loop\\n    \\n           return matrix;\\n    }\\n};\\n\\nPlease do consider upvoting if it helped you.",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List"
                ],
                "code": "class Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) \\n    {\\n          int r = m;//rows\\n          int c = n;//columns\\n\\t\\t  \\n          int i ; // for traversal\\n\\t      int rowindex = 0, colindex = 0; // starting positions of row and colom\\n          vector<vector<int>> matrix(r,vector<int> (c)); // matrix with r rows and c columns\\n\\t\\t  \\n          int l;\\n    \\n          while(rowindex<r and colindex<c)\\n          { \\n                  //left to right traversal\\n                  for(i=colindex;i<c;i++)\\n                  {   \\n                        if(head!=NULL)\\n                        {\\n                            l = head->val;\\n                            head = head->next;\\n                        }",
                "codeTag": "Java"
            },
            {
                "id": 2260503,
                "title": "c-14-lines-o-n-easy-to-understand-code",
                "content": "1. Every time x and y go out of bounds, change direction. \\n2. when next cell is filled (not equal to -1), change direction immediately. \\n3. Direction index: curPos = (curPos + 1) % 4\\n```\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        vector<vector<int>> res(m, vector<int> (n, -1));\\n        vector<pair<int, int>> dirs = {{0, 1},  {1, 0}, {0, -1}, {-1, 0}};\\n        int curPos = 0, x = 0, y = 0;\\n        while(head) {\\n            if(x == m || y == n || x < 0 || y < 0 || res[x][y] != -1) {\\n                x -= dirs[curPos].first, y -= dirs[curPos].second;\\n                curPos = (curPos + 1) % 4;\\n                x += dirs[curPos].first, y += dirs[curPos].second;\\n            }\\n            res[x][y] = head->val;\\n            head = head->next;\\n            x += dirs[curPos].first, y += dirs[curPos].second;\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        vector<vector<int>> res(m, vector<int> (n, -1));\\n        vector<pair<int, int>> dirs = {{0, 1},  {1, 0}, {0, -1}, {-1, 0}};\\n        int curPos = 0, x = 0, y = 0;\\n        while(head) {\\n            if(x == m || y == n || x < 0 || y < 0 || res[x][y] != -1) {\\n                x -= dirs[curPos].first, y -= dirs[curPos].second;\\n                curPos = (curPos + 1) % 4;\\n                x += dirs[curPos].first, y += dirs[curPos].second;\\n            }\\n            res[x][y] = head->val;\\n            head = head->next;\\n            x += dirs[curPos].first, y += dirs[curPos].second;\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2257399,
                "title": "easy-to-understand-recursive-solution",
                "content": "class Solution {\\npublic:\\n    void print(vector<vector<int>> &arr, int i, int j, int m, int n,ListNode *k)\\n{\\n    // If i or j lies outside the matrix\\n    if (i >= m or j >= n)\\n        return;\\n  \\n    // Print First Row\\n    for (int p = j; p < n; p++)\\n    {\\n        if(k!=nullptr)\\n        {\\n            arr[i][p]=k->val;\\n            k=k->next;\\n        }\\n        else\\n        {\\n            arr[i][p]=-1;\\n        }\\n    }\\n       // cout << arr[i][p] << \" \";\\n  \\n    // Print Last Column\\n    for (int p = i + 1; p < m; p++)\\n    {\\n           if(k!=nullptr)\\n        {\\n            arr[p][n-1]=k->val;\\n            k=k->next;\\n        }\\n        else\\n        {\\n            arr[p][n-1]=-1;\\n        }\\n    }\\n      //  cout << arr[p][n - 1] << \" \";\\n  \\n    // Print Last Row, if Last and\\n    // First Row are not same\\n    if ((m - 1) != i){\\n        for (int p = n - 2; p >= j; p--)\\n        {\\n               if(k!=nullptr)\\n        {\\n            arr[m-1][p]=k->val;\\n            k=k->next;\\n        }\\n        else\\n        {\\n            arr[m-1][p]=-1;\\n        } \\n        }\\n           // cout << arr[m - 1][p] << \" \";\\n    }\\n  \\n    // Print First Column,  if Last and\\n    // First Column are not same\\n    if ((n - 1) != j){\\n        for (int p = m - 2; p > i; p--){\\n                if(k!=nullptr)\\n        {\\n            arr[p][j]=k->val;\\n            k=k->next;\\n        }\\n        else\\n        {\\n            arr[p][j]=-1;\\n        }\\n           // cout << arr[p][j] << \" \";\\n        }\\n    }\\n    print(arr, i + 1, j + 1, m - 1, n - 1,k);\\n}\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        vector<vector<int> > arr(m, vector<int>(n,-1)); \\n      \\n        print(arr,0,0,m,n,head);\\n        return arr;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Linked List",
                    "Recursion",
                    "Matrix"
                ],
                "code": "class Solution {\\npublic:\\n    void print(vector<vector<int>> &arr, int i, int j, int m, int n,ListNode *k)\\n{\\n    // If i or j lies outside the matrix\\n    if (i >= m or j >= n)\\n        return;\\n  \\n    // Print First Row\\n    for (int p = j; p < n; p++)\\n    {\\n        if(k!=nullptr)\\n        {\\n            arr[i][p]=k->val;\\n            k=k->next;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2252723,
                "title": "faster-than-86-java",
                "content": "```\\nclass Solution {\\n    public int[][] spiralMatrix(int m, int n, ListNode head) {\\n        int[][] arr = new int[m][n];\\n        int orientation = 0;\\n        int lasti = 0;\\n        int lastj = 0;\\n        int[][] visited = new int[m][n];\\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                arr[i][j] = -1;\\n            }\\n        }\\n        l1:while(true){\\n            if(orientation == 0){\\n                for(;;){\\n                    if(lastj == n || visited[lasti][lastj] == 1){\\n                        orientation = (orientation + 1) % 4;\\n                        lastj--;\\n                        lasti++;\\n                        continue l1;\\n                    } \\n                    visited[lasti][lastj] = 1;\\n                    arr[lasti][lastj++] = head.val;\\n                    head = head.next;\\n                    if(head == null){\\n                        break l1;\\n                    }\\n                }\\n            }\\n             if(orientation == 1){\\n                for(;;){\\n                    if(lasti == m || visited[lasti][lastj] == 1){\\n                        orientation = (orientation + 1) % 4;\\n                        lasti--;\\n                        lastj--;\\n                        continue l1;\\n                    } \\n                      visited[lasti][lastj] = 1;\\n                    arr[lasti++][lastj] = head.val;\\n                    head = head.next;\\n                      if(head == null){\\n                        break l1;\\n                    }\\n                }\\n            }\\n             if(orientation == 2){\\n                for(;;){\\n                    if(lastj < 0 || visited[lasti][lastj] == 1){\\n                        orientation = (orientation + 1) % 4;\\n                        lastj++;\\n                        lasti--;\\n                        continue l1;\\n                    } \\n                      visited[lasti][lastj] = 1;\\n                    arr[lasti][lastj--] = head.val;\\n                    head = head.next;\\n                      if(head == null){\\n                        break l1;\\n                    }\\n                }\\n            }\\n             if(orientation == 3){\\n                for(;;){\\n                    if(lasti < 0 || visited[lasti][lastj] == 1){\\n                        orientation = (orientation + 1) % 4;\\n                        lasti++;\\n                        lastj++;\\n                        continue l1;\\n                    } \\n                      visited[lasti][lastj] = 1;\\n                    arr[lasti--][lastj] = head.val;\\n                    head = head.next;\\n                      if(head == null){\\n                        break l1;\\n                    }\\n                }\\n            }\\n        }\\n        return arr;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int[][] spiralMatrix(int m, int n, ListNode head) {\\n        int[][] arr = new int[m][n];\\n        int orientation = 0;\\n        int lasti = 0;\\n        int lastj = 0;\\n        int[][] visited = new int[m][n];\\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                arr[i][j] = -1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2247181,
                "title": "simple-c-code",
                "content": "# **If you like the implementation then Please help me by increasing my reputation. By clicking the up arrow on the left of my image.**\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\n    bool CheckMove(vector<vector<int>> &matrix, char &ch, int i, int j, int m, int n)\\n    {\\n        if(ch == \\'R\\' && j+1 < n && matrix[i][j+1] == -1)\\n            return true;\\n        if(ch == \\'D\\' && i+1 < m && matrix[i+1][j] == -1)\\n            return true;\\n        if(ch == \\'L\\' && j-1 >= 0 && matrix[i][j-1] == -1)\\n            return true;\\n        if(ch == \\'U\\' && i-1 >= 0 && matrix[i-1][j] == -1)\\n            return true;\\n        return false;\\n    }\\n    pair<char, pair<int, int>> NextMove(char &ch, int i, int j, int m, int n)\\n    {\\n        if(ch == \\'R\\')\\n            return {\\'D\\',{i+1,j}};\\n        else if(ch == \\'D\\')\\n            return {\\'L\\',{i,j-1}};\\n        else if(ch == \\'U\\')\\n            return {\\'R\\', {i, j+1}};\\n        else\\n            return {\\'U\\',{i-1, j}};\\n    }\\n    void dfs(vector<vector<int>> &matrix, int i, int j, int m, int n, ListNode* head, char &ch)\\n    {\\n        if(!head) return;\\n        matrix[i][j] = head->val;\\n        if(CheckMove(matrix, ch, i, j, m, n))\\n        {\\n            if(ch == \\'R\\')\\n                dfs(matrix, i, j+1, m, n, head->next, ch);\\n            else if(ch == \\'D\\')\\n                dfs(matrix, i+1, j, m, n, head->next, ch);\\n            else if(ch == \\'U\\')\\n                dfs(matrix, i-1, j, m, n, head->next, ch);\\n            else if(ch == \\'L\\')\\n                dfs(matrix, i, j-1, m, n, head->next, ch);\\n        }\\n        else\\n        {\\n            pair<char,pair<int,int>> t = NextMove(ch, i, j, m, n);\\n            dfs(matrix, t.second.first, t.second.second, m, n, head->next, t.first);\\n        }\\n        return;\\n    }\\npublic:\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        vector<vector<int>> matrix(m, vector<int> (n, -1));\\n        char ch = \\'R\\';\\n        dfs(matrix, 0, 0, m, n, head, ch);\\n        return matrix;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\n    bool CheckMove(vector<vector<int>> &matrix, char &ch, int i, int j, int m, int n)\\n    {\\n        if(ch == \\'R\\' && j+1 < n && matrix[i][j+1] == -1)\\n            return true;\\n        if(ch == \\'D\\' && i+1 < m && matrix[i+1][j] == -1)\\n            return true;\\n        if(ch == \\'L\\' && j-1 >= 0 && matrix[i][j-1] == -1)\\n            return true;\\n        if(ch == \\'U\\' && i-1 >= 0 && matrix[i-1][j] == -1)\\n            return true;\\n        return false;\\n    }\\n    pair<char, pair<int, int>> NextMove(char &ch, int i, int j, int m, int n)\\n    {\\n        if(ch == \\'R\\')\\n            return {\\'D\\',{i+1,j}};\\n        else if(ch == \\'D\\')\\n            return {\\'L\\',{i,j-1}};\\n        else if(ch == \\'U\\')\\n            return {\\'R\\', {i, j+1}};\\n        else\\n            return {\\'U\\',{i-1, j}};\\n    }\\n    void dfs(vector<vector<int>> &matrix, int i, int j, int m, int n, ListNode* head, char &ch)\\n    {\\n        if(!head) return;\\n        matrix[i][j] = head->val;\\n        if(CheckMove(matrix, ch, i, j, m, n))\\n        {\\n            if(ch == \\'R\\')\\n                dfs(matrix, i, j+1, m, n, head->next, ch);\\n            else if(ch == \\'D\\')\\n                dfs(matrix, i+1, j, m, n, head->next, ch);\\n            else if(ch == \\'U\\')\\n                dfs(matrix, i-1, j, m, n, head->next, ch);\\n            else if(ch == \\'L\\')\\n                dfs(matrix, i, j-1, m, n, head->next, ch);\\n        }\\n        else\\n        {\\n            pair<char,pair<int,int>> t = NextMove(ch, i, j, m, n);\\n            dfs(matrix, t.second.first, t.second.second, m, n, head->next, t.first);\\n        }\\n        return;\\n    }\\npublic:\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        vector<vector<int>> matrix(m, vector<int> (n, -1));\\n        char ch = \\'R\\';\\n        dfs(matrix, 0, 0, m, n, head, ch);\\n        return matrix;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2235342,
                "title": "mine-is-much-simpler-python3",
                "content": "**Like it ? Please Upvote !**\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def spiralMatrix(self, m: int, n: int, head: Optional[ListNode]) -> List[List[int]]:\\n        \\n        result = [[-1]*n for i in range(m)]\\n        \\n        top,bottom,left,right=0,m-1,0,n-1\\n        \\n        direction = 0\\n        \\n        while head and left<=right and top<=bottom:\\n            \\n            if direction==0:\\n                for i in range(left,right+1):\\n                    if head:\\n                        result[top][i] = head.val\\n                        head = head.next\\n                    else:\\n                        return result\\n                top += 1\\n            \\n            elif direction==1:\\n                for i in range(top,bottom+1):\\n                    if head:\\n                        result[i][right] = head.val\\n                        head = head.next\\n                    else:\\n                        return result\\n                right -= 1\\n            \\n            elif direction==2:\\n                for i in range(right,left-1,-1):\\n                    if head:\\n                        result[bottom][i] = head.val\\n                        head = head.next\\n                    else:\\n                        return result\\n                bottom -= 1\\n                \\n            else:\\n                for i in range(bottom,top-1,-1):\\n                    if head:\\n                        result[i][left] = head.val\\n                        head = head.next\\n                    else:\\n                        return result\\n                left += 1\\n                \\n            direction = (direction + 1)%4\\n            \\n        return result\\n```",
                "solutionTags": [
                    "Linked List",
                    "Matrix"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def spiralMatrix(self, m: int, n: int, head: Optional[ListNode]) -> List[List[int]]:\\n        \\n        result = [[-1]*n for i in range(m)]\\n        \\n        top,bottom,left,right=0,m-1,0,n-1\\n        \\n        direction = 0\\n        \\n        while head and left<=right and top<=bottom:\\n            \\n            if direction==0:\\n                for i in range(left,right+1):\\n                    if head:\\n                        result[top][i] = head.val\\n                        head = head.next\\n                    else:\\n                        return result\\n                top += 1\\n            \\n            elif direction==1:\\n                for i in range(top,bottom+1):\\n                    if head:\\n                        result[i][right] = head.val\\n                        head = head.next\\n                    else:\\n                        return result\\n                right -= 1\\n            \\n            elif direction==2:\\n                for i in range(right,left-1,-1):\\n                    if head:\\n                        result[bottom][i] = head.val\\n                        head = head.next\\n                    else:\\n                        return result\\n                bottom -= 1\\n                \\n            else:\\n                for i in range(bottom,top-1,-1):\\n                    if head:\\n                        result[i][left] = head.val\\n                        head = head.next\\n                    else:\\n                        return result\\n                left += 1\\n                \\n            direction = (direction + 1)%4\\n            \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2234240,
                "title": "c-implementation-based-on-spiral-matrix-ii-o-n-solution",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\nvector<vector<int>> spiralMatrix(int n, int m, ListNode *head)\\n{\\n    vector<vector<int>> ans(n, vector<int>(m,-1));\\n    int top = 0, bottom = n - 1, left = 0, right = m - 1;\\n    int count = 1, dir = 0;\\n    while (head!=NULL)\\n    {\\n        // Top Wall\\n        for (int i = left; i <= right && head!=NULL; i++)\\n        {\\n            ans[top][i] = head->val;\\n            head = head->next;\\n            count++;\\n        }\\n        top++;\\n        // Right Wall\\n        for (int i = top; i <= bottom && head!=NULL; i++)\\n        {\\n            ans[i][right] = head->val;\\n            head = head->next;\\n            count++;\\n        }\\n        right--;\\n\\n        // Bottom Wall\\n        for (int i = right; i >= left && head!=NULL; i--)\\n        {\\n            ans[bottom][i] = head->val;\\n            head = head->next;\\n            count++;\\n        }\\n        bottom--;\\n\\n        // Left Wall\\n        for (int i = bottom; i >= top && head!=NULL; i--)\\n        {\\n            ans[i][left] = head->val;\\n            head = head->next;\\n            count++;\\n        }\\n        left++;\\n    }\\n    return ans;\\n}\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\nvector<vector<int>> spiralMatrix(int n, int m, ListNode *head)\\n{\\n    vector<vector<int>> ans(n, vector<int>(m,-1));\\n    int top = 0, bottom = n - 1, left = 0, right = m - 1;\\n    int count = 1, dir = 0;\\n    while (head!=NULL)\\n    {\\n        // Top Wall\\n        for (int i = left; i <= right && head!=NULL; i++)\\n        {\\n            ans[top][i] = head->val;\\n            head = head->next;\\n            count++;\\n        }\\n        top++;\\n        // Right Wall\\n        for (int i = top; i <= bottom && head!=NULL; i++)\\n        {\\n            ans[i][right] = head->val;\\n            head = head->next;\\n            count++;\\n        }\\n        right--;\\n\\n        // Bottom Wall\\n        for (int i = right; i >= left && head!=NULL; i--)\\n        {\\n            ans[bottom][i] = head->val;\\n            head = head->next;\\n            count++;\\n        }\\n        bottom--;\\n\\n        // Left Wall\\n        for (int i = bottom; i >= top && head!=NULL; i--)\\n        {\\n            ans[i][left] = head->val;\\n            head = head->next;\\n            count++;\\n        }\\n        left++;\\n    }\\n    return ans;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2234131,
                "title": "rust-solution-using-direction-vector",
                "content": "~~~\\n       // direction vector: going right->down->left->up cycle \\n        let dirs: [[i32; 2]; 4] = [[0, 1], [1, 0], [0, -1], [-1, 0]];\\n\\t\\t\\n        let (m, n, mut i, mut j) = (m as usize, n as usize, 0 as usize, 0 as usize);\\n        let mut curr = &head;\\n        let mut ret = vec![vec![-1; n]; m];\\n        let mut d: usize = 0;\\n        \\n        while curr.is_some() {\\n            if let Some(ref node) = curr {\\n                ret[i][j] = node.val;\\n                curr = &node.next;\\n            }\\n            \\n            let x: i32 = i as i32 + dirs[d][0];\\n            let y: i32 = j as i32 + dirs[d][1];\\n            \\n\\t\\t\\t// need to change direction?\\n            if x < 0 || x == m as i32 || y < 0 || y == n as i32 || ret[x as usize][y as usize] != -1 {\\n                d = (d + 1) % 4;\\n            }\\n            \\n            i = (i as i32 + dirs[d][0]) as usize;\\n            j = (j as i32 + dirs[d][1]) as usize;\\n        }\\n        \\n        ret\\n~~~",
                "solutionTags": [],
                "code": "~~~\\n       // direction vector: going right->down->left->up cycle \\n        let dirs: [[i32; 2]; 4] = [[0, 1], [1, 0], [0, -1], [-1, 0]];\\n\\t\\t\\n        let (m, n, mut i, mut j) = (m as usize, n as usize, 0 as usize, 0 as usize);\\n        let mut curr = &head;\\n        let mut ret = vec![vec![-1; n]; m];\\n        let mut d: usize = 0;\\n        \\n        while curr.is_some() {\\n            if let Some(ref node) = curr {\\n                ret[i][j] = node.val;\\n                curr = &node.next;\\n            }\\n            \\n            let x: i32 = i as i32 + dirs[d][0];\\n            let y: i32 = j as i32 + dirs[d][1];\\n            \\n\\t\\t\\t// need to change direction?\\n            if x < 0 || x == m as i32 || y < 0 || y == n as i32 || ret[x as usize][y as usize] != -1 {\\n                d = (d + 1) % 4;\\n            }\\n            \\n            i = (i as i32 + dirs[d][0]) as usize;\\n            j = (j as i32 + dirs[d][1]) as usize;\\n        }\\n        \\n        ret\\n~~~",
                "codeTag": "Unknown"
            },
            {
                "id": 2233467,
                "title": "c-easy-solution-little-modification-in-spiral-matrix",
                "content": "```\\n vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n         vector<vector<int>>ans(m,vector<int>(n,-1));\\n        ListNode *cur=head;\\n        int row=m;\\n        int col=n;\\n        int r=0,c=0;\\n        while(r<row && c<col && cur)\\n        {\\n          // for row from begining\\n          for(int i=c;i<col && cur!=NULL;i++)\\n          {\\n            ans[r][i]=cur->val;\\n            cur=cur->next;\\n          }\\n          r++;\\n          // for col from end\\n          for(int i=r;i<row && cur!=NULL;i++)\\n          {\\n            ans[i][col-1]=cur->val;\\n             cur=cur->next;\\n          }\\n          col--;\\n          if(r<row)\\n          {   \\n            // for row from end;\\n            for(int i=col-1;i>=c && cur!=NULL;i--)\\n          {\\n            ans[row-1][i]=cur->val;\\n               cur=cur->next;\\n          }\\n            row--;\\n          }\\n          \\n          if(c<col)\\n          {  // for col from start\\n            for(int i=row-1;i>=r && cur!=NULL;i--)\\n                {\\n                    ans[i][c]=cur->val;\\n                      cur=cur->next;\\n                }\\n                c++;\\n          }\\n          \\n        }\\n      return ans;\\n    }\\n```\\t",
                "solutionTags": [],
                "code": "```\\n vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n         vector<vector<int>>ans(m,vector<int>(n,-1));\\n        ListNode *cur=head;\\n        int row=m;\\n        int col=n;\\n        int r=0,c=0;\\n        while(r<row && c<col && cur)\\n        {\\n          // for row from begining\\n          for(int i=c;i<col && cur!=NULL;i++)\\n          {\\n            ans[r][i]=cur->val;\\n            cur=cur->next;\\n          }\\n          r++;\\n          // for col from end\\n          for(int i=r;i<row && cur!=NULL;i++)\\n          {\\n            ans[i][col-1]=cur->val;\\n             cur=cur->next;\\n          }\\n          col--;\\n          if(r<row)\\n          {   \\n            // for row from end;\\n            for(int i=col-1;i>=c && cur!=NULL;i--)\\n          {\\n            ans[row-1][i]=cur->val;\\n               cur=cur->next;\\n          }\\n            row--;\\n          }\\n          \\n          if(c<col)\\n          {  // for col from start\\n            for(int i=row-1;i>=r && cur!=NULL;i--)\\n                {\\n                    ans[i][c]=cur->val;\\n                      cur=cur->next;\\n                }\\n                c++;\\n          }\\n          \\n        }\\n      return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2233140,
                "title": "c-easy-to-understand-iterative-spiral-beginners-friendly",
                "content": "```\\nvector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        ListNode* curr=head;\\n        vector<vector<int>>ans(m,vector<int>(n,-1));\\n        int top=0,right=n-1,down=m-1,left=0;\\n        int t=0;\\n        while(curr!=NULL && t<=m*n){\\n            for(int i=left;i<=right &&curr!=NULL;i++){\\n                ans[top][i]=curr->val;\\n                curr=curr->next;\\n                t++;\\n            }\\n            top++;\\n            for(int i=top;i<=down && curr!=NULL;i++){\\n                ans[i][right]=curr->val;\\n                curr=curr->next;\\n                t++;\\n            }\\n            right--;\\n            if(top<=down){\\n            for(int i=right;i>=left &&curr!=NULL;i--){\\n                ans[down][i]=curr->val;\\n                curr=curr->next;\\n                t++;\\n                }\\n            }\\n            down--;\\n            if(left<=right){\\n            for(int i=down;i>=top &&curr!=NULL;i--){\\n                ans[i][left]=curr->val;\\n                curr=curr->next;\\n                t++;\\n                }\\n            }\\n            left++;\\n        }\\n        \\n        return ans;\\n        \\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List",
                    "Matrix"
                ],
                "code": "```\\nvector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        ListNode* curr=head;\\n        vector<vector<int>>ans(m,vector<int>(n,-1));\\n        int top=0,right=n-1,down=m-1,left=0;\\n        int t=0;\\n        while(curr!=NULL && t<=m*n){\\n            for(int i=left;i<=right &&curr!=NULL;i++){\\n                ans[top][i]=curr->val;\\n                curr=curr->next;\\n                t++;\\n            }\\n            top++;\\n            for(int i=top;i<=down && curr!=NULL;i++){\\n                ans[i][right]=curr->val;\\n                curr=curr->next;\\n                t++;\\n            }\\n            right--;\\n            if(top<=down){\\n            for(int i=right;i>=left &&curr!=NULL;i--){\\n                ans[down][i]=curr->val;\\n                curr=curr->next;\\n                t++;\\n                }\\n            }\\n            down--;\\n            if(left<=right){\\n            for(int i=down;i>=top &&curr!=NULL;i--){\\n                ans[i][left]=curr->val;\\n                curr=curr->next;\\n                t++;\\n                }\\n            }\\n            left++;\\n        }\\n        \\n        return ans;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2232094,
                "title": "c-easy-recursive",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    int m,n;\\n    int xs=0;\\n    int ys=0;\\n    vector<vector<int>>ret;\\n    vector<vector<int>> spiralMatrix(int M, int N, ListNode* head) {\\n        m=M;\\n        n=N;\\n        //vector<vector<int>>ret(m,vector<int>(n,-1));\\n        ret.resize(m,vector<int>(n,-1));\\n        recur(head);\\n        return ret;\\n    }\\n    void recur(ListNode*head){\\n        if(!head)\\n            return;\\n        if(xs>n||ys>m)\\n            return;\\n        int i,j;\\n        i=xs;\\n        j=ys;\\n        for(;i<n&&head;i++){\\n            ret[j][i]=head->val;\\n            head=head->next;\\n        }\\n        ++ys;\\n        i-=1;\\n        j+=1;\\n        for(;j<m&&head;j++){\\n            ret[j][i]=head->val;\\n            head=head->next;\\n        }\\n        --n;\\n        j-=1;\\n        i-=1;\\n        for(;i>=xs&&head;i--){\\n            ret[j][i]=head->val;\\n            head=head->next;\\n        }\\n        --m;\\n        i+=1;\\n        j-=1;\\n        for(;j>=ys&&head;j--){\\n            ret[j][i]=head->val;\\n            head=head->next;\\n        }\\n        ++xs;\\n        recur(head);\\n        \\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int m,n;\\n    int xs=0;\\n    int ys=0;\\n    vector<vector<int>>ret;\\n    vector<vector<int>> spiralMatrix(int M, int N, ListNode* head) {\\n        m=M;\\n        n=N;\\n        //vector<vector<int>>ret(m,vector<int>(n,-1));\\n        ret.resize(m,vector<int>(n,-1));\\n        recur(head);\\n        return ret;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2231666,
                "title": "java-100-faster-solution",
                "content": "The idea is to iterate the matrix in spiral form and fill the value from list if LinkedList node exists else with -1.\\nIn Spiral iteration we follow the below directions till we reach the boundaries :\\n1) Go right\\n2) Go down\\n3) Go left\\n4) Go up\\n\\n# psudo code:\\n```\\n\\tDefine variables: rowStart=0, rowEnd=m-1, colStart=0 and colEnd=n-1\\n\\tIterate the loop within valid boundaries of above variables\\n\\t//Right\\n\\tIn rowStart row Fill all the column values(from list or -1) starting from colStart to colEnd\\n\\tincrement the rowStart\\n\\t\\n\\t//Down\\n\\tIn colEnd column fill all the values(from list or -1) starting from rowStart to rowEnd\\n\\tdecrement the colEnd\\n\\t\\n\\t//Left\\n\\tThis is a conditional Iteration\\n\\tIf rowStart <= rowEnd then only fill all the column values(from list or -1) from colEnd to colStart in rowEnd row.\\n\\tdecrement rowEnd\\n\\t\\n\\t//Up\\n\\tThis is a conditional Iteration\\n\\tIf colStart <= colEnd then only fill all the values(from list or -1) from rowEnd to rowStart in colStart column\\n\\tincrement colStart\\n```\\n\\t\\n# Here is the working solution:\\n```\\npublic int[][] spiralMatrix(int m, int n, ListNode head) {\\n        int[][] mat = new int[m][n];\\n        int rowStart = 0;\\n        int rowEnd = m-1;\\n        int colStart = 0;\\n        int colEnd = n-1;\\n        while(rowStart<=rowEnd && colStart<=colEnd) {\\n            //right\\n            for(int i=colStart; i<=colEnd; i++) {\\n                if(head == null) {\\n                    mat[rowStart][i] = -1;\\n                } else {\\n                    mat[rowStart][i] = head.val;\\n                    head = head.next;\\n                }\\n            }\\n            rowStart++;\\n            //down\\n            for(int i=rowStart; i<=rowEnd; i++) {\\n                if(head == null) {\\n                    mat[i][colEnd] = -1;\\n                } else {\\n                    mat[i][colEnd] = head.val;\\n                    head = head.next;\\n                }\\n            }\\n            colEnd--;\\n            //left\\n            if(rowStart <= rowEnd) {\\n                for(int i=colEnd; i>=colStart; i--) {\\n                    if(head == null) {\\n                        mat[rowEnd][i] = -1;\\n                    } else {\\n                        mat[rowEnd][i] = head.val;\\n                        head = head.next;\\n                    }\\n                }\\n            }\\n            rowEnd--;\\n            //up\\n            if(colStart <= colEnd) {\\n                for(int i=rowEnd; i>=rowStart; i--) {\\n                    if(head == null) {\\n                        mat[i][colStart] = -1;\\n                    } else {\\n                        mat[i][colStart] = head.val;\\n                        head = head.next;\\n                    }\\n                }\\n            }\\n            colStart++;\\n        }\\n        return mat;\\n    }\\n```\\n\\n\\t",
                "solutionTags": [
                    "Java",
                    "Matrix"
                ],
                "code": "```\\n\\tDefine variables: rowStart=0, rowEnd=m-1, colStart=0 and colEnd=n-1\\n\\tIterate the loop within valid boundaries of above variables\\n\\t//Right\\n\\tIn rowStart row Fill all the column values(from list or -1) starting from colStart to colEnd\\n\\tincrement the rowStart\\n\\t\\n\\t//Down\\n\\tIn colEnd column fill all the values(from list or -1) starting from rowStart to rowEnd\\n\\tdecrement the colEnd\\n\\t\\n\\t//Left\\n\\tThis is a conditional Iteration\\n\\tIf rowStart <= rowEnd then only fill all the column values(from list or -1) from colEnd to colStart in rowEnd row.\\n\\tdecrement rowEnd\\n\\t\\n\\t//Up\\n\\tThis is a conditional Iteration\\n\\tIf colStart <= colEnd then only fill all the values(from list or -1) from rowEnd to rowStart in colStart column\\n\\tincrement colStart\\n```\n```\\npublic int[][] spiralMatrix(int m, int n, ListNode head) {\\n        int[][] mat = new int[m][n];\\n        int rowStart = 0;\\n        int rowEnd = m-1;\\n        int colStart = 0;\\n        int colEnd = n-1;\\n        while(rowStart<=rowEnd && colStart<=colEnd) {\\n            //right\\n            for(int i=colStart; i<=colEnd; i++) {\\n                if(head == null) {\\n                    mat[rowStart][i] = -1;\\n                } else {\\n                    mat[rowStart][i] = head.val;\\n                    head = head.next;\\n                }\\n            }\\n            rowStart++;\\n            //down\\n            for(int i=rowStart; i<=rowEnd; i++) {\\n                if(head == null) {\\n                    mat[i][colEnd] = -1;\\n                } else {\\n                    mat[i][colEnd] = head.val;\\n                    head = head.next;\\n                }\\n            }\\n            colEnd--;\\n            //left\\n            if(rowStart <= rowEnd) {\\n                for(int i=colEnd; i>=colStart; i--) {\\n                    if(head == null) {\\n                        mat[rowEnd][i] = -1;\\n                    } else {\\n                        mat[rowEnd][i] = head.val;\\n                        head = head.next;\\n                    }\\n                }\\n            }\\n            rowEnd--;\\n            //up\\n            if(colStart <= colEnd) {\\n                for(int i=rowEnd; i>=rowStart; i--) {\\n                    if(head == null) {\\n                        mat[i][colStart] = -1;\\n                    } else {\\n                        mat[i][colStart] = head.val;\\n                        head = head.next;\\n                    }\\n                }\\n            }\\n            colStart++;\\n        }\\n        return mat;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2231334,
                "title": "c-similar-to-other-spiral-matrix-questions-beginner-friendly",
                "content": "# **C++ EASY TO UNDERSATAND Simple looping traversal**\\n```\\nvector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        vector<vector<int>> ans(m,vector<int>(n,-1));\\n        int r=0,c=0,re=m-1,ce=n-1;\\n        while(c<=ce&&r<=re){\\n            \\n            for(int i=c;i<=ce&&head;i++){\\n                ans[r][i]=head->val;\\n                head=head->next;\\n            }\\n            r++;\\n            for(int i=r;i<=re&&head;i++){\\n                ans[i][ce]=head->val;\\n                head=head->next;\\n            }\\n            ce--;\\n            for(int i=ce;i>=c&&head;i--){\\n                ans[re][i]=head->val;\\n                head=head->next;\\n            }\\n            re--;\\n            for(int i=re;i>=r&&head;i--){\\n                ans[i][c]=head->val;\\n                head=head->next;\\n            }\\n            c++;\\n            \\n        }\\n        return ans;\\n    }\\n```\\n*hope u like it*",
                "solutionTags": [
                    "C",
                    "Matrix"
                ],
                "code": "```\\nvector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        vector<vector<int>> ans(m,vector<int>(n,-1));\\n        int r=0,c=0,re=m-1,ce=n-1;\\n        while(c<=ce&&r<=re){\\n            \\n            for(int i=c;i<=ce&&head;i++){\\n                ans[r][i]=head->val;\\n                head=head->next;\\n            }\\n            r++;\\n            for(int i=r;i<=re&&head;i++){\\n                ans[i][ce]=head->val;\\n                head=head->next;\\n            }\\n            ce--;\\n            for(int i=ce;i>=c&&head;i--){\\n                ans[re][i]=head->val;\\n                head=head->next;\\n            }\\n            re--;\\n            for(int i=re;i>=r&&head;i--){\\n                ans[i][c]=head->val;\\n                head=head->next;\\n            }\\n            c++;\\n            \\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2230698,
                "title": "c-industrial-level-modular-code-understandable-o-m-n",
                "content": "Hey folks, \\nI guess I\\'m late to the party but I\\'ve bought something new and delicious to the table. Presenting an industrial level modular code for the problem with the simplest explanation ever. \\n\\n**EXPLANATION :** (i & j are the matrix iterators and m&n are the dimensions of the matrix) \\n\\nSo the simple idea is that we need to traverse the matrix in a spiral form. Upon obesrvation we can see that the spiral is clockwise, hence every time it\\'s taking a right turn while spiralling inwards. So in general while traversing the spiral, there is always two constant actions that we\\'re taking : \\n1.  Going straight in the current direction of motion \\n2.  Taking a right turn\\n\\nUnderstanding this we can make two separate methods to implement these:\\n1. `isValid()` returns a boolean informing whether the current matrix iterators are valid or not. Validity is based on two factors: \\n\\t* \\tIt is inside the matrix (i<m, j<n, i>=0 and j>=0)\\n\\t* \\tThe value in the matrix cell is not prefilled. (in which case we\\'ll have to take a right turn)\\n2.  `goingStraight()` returns a boolean value which increments the current matrix iterators if gonig straight is possible, else returns false. \\n3.  `takeRight()` takes a `char direction` as parameter and returns the new direction after taking a right turn. \\n\\t* **Note** :  Directions taken are North as \\'n\\', South as \\'s\\', East as \\'e\\' and West as \\'w\\'.\\n\\n**Algorithm** : \\n1. Traverse the matrix for *mn* times and in each iteration : \\n\\t* \\t*if head is null*: \\n\\t\\t* \\tupdate current matrix cell with value -1\\n\\t* \\t*else* \\n\\t\\t* \\tupdate value with the head of the linked list \\n\\t\\t* \\tmove head to the next element \\n\\t*  check if it\\'s possible to go straight: \\n\\t\\t*  *if yes,* \\n\\t\\t\\t*  increment iterators and go to next iteration \\n\\t\\t* *else* \\n\\t\\t\\t* take a right turn and then go straight \\n\\n**C++ Code :** \\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    typedef vector<vector<int>> vvi ;\\n    bool isValid(vvi& spiralMatrix, int i, int j){\\n        int m = spiralMatrix.size();\\n        int n = spiralMatrix[0].size();\\n        if(i<m && j<n && i>=0 && j>=0){\\n            if(spiralMatrix[i][j] == -2){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    bool goStraight(vvi &spiralMatrix, char dir, int &i, int &j){\\n        int x = i ;\\n        int y = j;\\n        if(dir == \\'n\\')\\n            x--;\\n        \\n        else if (dir ==\\'s\\')\\n            x++;\\n        else if (dir == \\'e\\')\\n            y++;\\n        else \\n            y--;\\n        if(isValid(spiralMatrix,x,y)){\\n            i = x;\\n            j = y;\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    char takeRight(char dir){\\n        if(dir ==\\'n\\')\\n            return \\'e\\';\\n        else if (dir ==\\'s\\')\\n            return \\'w\\';\\n        else if (dir == \\'e\\')\\n            return \\'s\\';\\n        else \\n            return \\'n\\';\\n    }\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        vector<vector<int>> spiralMatrix (m, vector<int> (n,-2));\\n        if(m==1 && n==1){\\n            if(!head){\\n                spiralMatrix[0][0] = -1;\\n                return spiralMatrix;\\n            }\\n            spiralMatrix[0][0] = head->val;\\n            return spiralMatrix;\\n            \\n        }\\n        \\n        int matLength = m*n;\\n        int i=0,j=0;\\n        int l = 0;\\n        ListNode* tempHead = head;\\n        char direction = \\'e\\';\\n        while(matLength--){\\n            if(tempHead){\\n                spiralMatrix[i][j] = tempHead->val;\\n                tempHead = tempHead->next;\\n            }\\n            else{\\n                spiralMatrix[i][j] = -1;\\n            }\\n            \\n            bool canGoStraight = goStraight(spiralMatrix,direction,i,j);\\n            if(canGoStraight)\\n                continue;\\n            \\n            direction = takeRight(direction);\\n            goStraight(spiralMatrix,direction,i,j);             \\n        }\\n        return spiralMatrix;\\n        \\n    }\\n};\\n```\\n**Note :** \\nNotice the nomenclature of variables in the code. It is understandable if you\\'re using short names during the contest/ competitive coding but always keep in mind to use proper variable names and indentations during coding interviews to make your code more readable and easy to understand. \\n\\nThat\\'s it for now from my end :D \\nHope you had a good read and a good day ahead. \\n\\n~shav",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    typedef vector<vector<int>> vvi ;\\n    bool isValid(vvi& spiralMatrix, int i, int j){\\n        int m = spiralMatrix.size();\\n        int n = spiralMatrix[0].size();\\n        if(i<m && j<n && i>=0 && j>=0){\\n            if(spiralMatrix[i][j] == -2){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    bool goStraight(vvi &spiralMatrix, char dir, int &i, int &j){\\n        int x = i ;\\n        int y = j;\\n        if(dir == \\'n\\')\\n            x--;\\n        \\n        else if (dir ==\\'s\\')\\n            x++;\\n        else if (dir == \\'e\\')\\n            y++;\\n        else \\n            y--;\\n        if(isValid(spiralMatrix,x,y)){\\n            i = x;\\n            j = y;\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    char takeRight(char dir){\\n        if(dir ==\\'n\\')\\n            return \\'e\\';\\n        else if (dir ==\\'s\\')\\n            return \\'w\\';\\n        else if (dir == \\'e\\')\\n            return \\'s\\';\\n        else \\n            return \\'n\\';\\n    }\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        vector<vector<int>> spiralMatrix (m, vector<int> (n,-2));\\n        if(m==1 && n==1){\\n            if(!head){\\n                spiralMatrix[0][0] = -1;\\n                return spiralMatrix;\\n            }\\n            spiralMatrix[0][0] = head->val;\\n            return spiralMatrix;\\n            \\n        }\\n        \\n        int matLength = m*n;\\n        int i=0,j=0;\\n        int l = 0;\\n        ListNode* tempHead = head;\\n        char direction = \\'e\\';\\n        while(matLength--){\\n            if(tempHead){\\n                spiralMatrix[i][j] = tempHead->val;\\n                tempHead = tempHead->next;\\n            }\\n            else{\\n                spiralMatrix[i][j] = -1;\\n            }\\n            \\n            bool canGoStraight = goStraight(spiralMatrix,direction,i,j);\\n            if(canGoStraight)\\n                continue;\\n            \\n            direction = takeRight(direction);\\n            goStraight(spiralMatrix,direction,i,j);             \\n        }\\n        return spiralMatrix;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2230543,
                "title": "easy-solution-cpp",
                "content": "At start 0(row),n-1(col) ,m-1(row) ,0(col). Now after every iteration, increase 0, row and 0 col, and decrease the remaining by 1.\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        \\n        vector<vector<int>> res(m,vector<int>(n,-1));\\n        \\n        ListNode* temp=head;\\n        int rs=0,re=m-1;\\n        int cs=0,ce=n-1;\\n        while(temp!=NULL)\\n        {\\n            for(int i=cs;i<=ce;i++)\\n            {\\n                if(temp!=NULL)\\n                {\\n                    res[rs][i] = temp->val;\\n                    temp=temp->next;\\n                }\\n                else\\n                {\\n                    break;\\n                }\\n            }\\n            rs++;\\n            for(int i=rs;i<=re;i++)\\n            {\\n                if(temp!=NULL)\\n                {\\n                    res[i][ce] = temp->val;\\n                    temp=temp->next;\\n                }\\n                else\\n                {\\n                    break;\\n                }\\n            }\\n            ce--;\\n            //cout<<temp->val<<endl;\\n            for(int i=ce;i>=cs;i--)\\n            {\\n                if(temp!=NULL)\\n                {\\n                    //cout<<re<<\" \"<<i<<\" hell0 \"<<endl;\\n                    res[re][i] = temp->val;\\n                    temp=temp->next;\\n                }\\n                else\\n                {\\n                    break;\\n                }\\n            }\\n            re--;\\n            for(int i=re;i>=rs;i--)\\n            {\\n                if(temp!=NULL)\\n                {\\n                    res[i][cs] = temp->val;\\n                    temp=temp->next;\\n                }\\n                else\\n                {\\n                    break;\\n                }              \\n            }\\n            cs++;\\n\\n            \\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        \\n        vector<vector<int>> res(m,vector<int>(n,-1));\\n        \\n        ListNode* temp=head;\\n        int rs=0,re=m-1;\\n        int cs=0,ce=n-1;\\n        while(temp!=NULL)\\n        {\\n            for(int i=cs;i<=ce;i++)\\n            {\\n                if(temp!=NULL)\\n                {\\n                    res[rs][i] = temp->val;\\n                    temp=temp->next;\\n                }\\n                else\\n                {\\n                    break;\\n                }\\n            }\\n            rs++;\\n            for(int i=rs;i<=re;i++)\\n            {\\n                if(temp!=NULL)\\n                {\\n                    res[i][ce] = temp->val;\\n                    temp=temp->next;\\n                }\\n                else\\n                {\\n                    break;\\n                }\\n            }\\n            ce--;\\n            //cout<<temp->val<<endl;\\n            for(int i=ce;i>=cs;i--)\\n            {\\n                if(temp!=NULL)\\n                {\\n                    //cout<<re<<\" \"<<i<<\" hell0 \"<<endl;\\n                    res[re][i] = temp->val;\\n                    temp=temp->next;\\n                }\\n                else\\n                {\\n                    break;\\n                }\\n            }\\n            re--;\\n            for(int i=re;i>=rs;i--)\\n            {\\n                if(temp!=NULL)\\n                {\\n                    res[i][cs] = temp->val;\\n                    temp=temp->next;\\n                }\\n                else\\n                {\\n                    break;\\n                }              \\n            }\\n            cs++;\\n\\n            \\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2230511,
                "title": "simple-c",
                "content": "```\\n  vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        vector<int> ll;\\n        \\n        while(head != NULL){\\n            ll.push_back(head->val);\\n            head = head->next;\\n        }\\n        \\n        vector<vector<int>> arr(m, vector<int>(n, -1));\\n        \\n        int r1 = 0, r2 = m-1;\\n        int c1 = 0, c2 = n-1;\\n        \\n        int i = 0;\\n        \\n        while(r1 <= r2 and c1 <= c2){\\n            if(i == ll.size()) break;\\n            //left to right\\n            for(int c=c1; c<=c2; c++) {\\n                if(i == ll.size()) break;\\n                arr[r1][c] = ll[i++];\\n            }\\n            \\n            //move down\\n            for(int r=r1+1; r<=r2; r++) {\\n                if(i == ll.size()) break;\\n                arr[r][c2] = ll[i++];\\n            }\\n            \\n            //right to left and move up\\n            if(r1 < r2 and c1 < c2){\\n                if(i == ll.size()) break;\\n                //right to left\\n                \\n                for(int c=c2-1; c>c1; c--) {\\n                    if(i == ll.size()) break;\\n                    arr[r2][c] = ll[i++];\\n                }\\n                \\n                //up\\n                for(int r=r2; r>r1; r--) {\\n                    if(i == ll.size()) break;\\n                    arr[r][c1] = ll[i++];\\n                }\\n            }\\n            r1++;\\n            r2--;\\n            c1++;\\n            c2--;\\n        }\\n        return arr;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n  vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        vector<int> ll;\\n        \\n        while(head != NULL){\\n            ll.push_back(head->val);\\n            head = head->next;\\n        }\\n        \\n        vector<vector<int>> arr(m, vector<int>(n, -1));\\n        \\n        int r1 = 0, r2 = m-1;\\n        int c1 = 0, c2 = n-1;\\n        \\n        int i = 0;\\n        \\n        while(r1 <= r2 and c1 <= c2){\\n            if(i == ll.size()) break;\\n            //left to right\\n            for(int c=c1; c<=c2; c++) {\\n                if(i == ll.size()) break;\\n                arr[r1][c] = ll[i++];\\n            }\\n            \\n            //move down\\n            for(int r=r1+1; r<=r2; r++) {\\n                if(i == ll.size()) break;\\n                arr[r][c2] = ll[i++];\\n            }\\n            \\n            //right to left and move up\\n            if(r1 < r2 and c1 < c2){\\n                if(i == ll.size()) break;\\n                //right to left\\n                \\n                for(int c=c2-1; c>c1; c--) {\\n                    if(i == ll.size()) break;\\n                    arr[r2][c] = ll[i++];\\n                }\\n                \\n                //up\\n                for(int r=r2; r>r1; r--) {\\n                    if(i == ll.size()) break;\\n                    arr[r][c1] = ll[i++];\\n                }\\n            }\\n            r1++;\\n            r2--;\\n            c1++;\\n            c2--;\\n        }\\n        return arr;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2230393,
                "title": "c-small-variation-in-spiral-matrix-problem-easy-understanding",
                "content": "**C++**\\n  Just made small change in SPIRAL MATRIX code ,the comments are of spiral matrix(problem 54) earlier code\\n  in place of those just written the traversal of HEAD(i.e Linked List) till it become NULL.\\n       \\n                                  \\n    \\n\\t\\n\\t\\n\\t   vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        ListNode* t=head;\\n\\t\\t vector<vector<int>> ans(m,vector<int>(n,-1));\\n       // int row=matrix.size(),col=matrix[0].size();\\n\\tint sr=0,er=m-1,sc=0,ec=n-1;\\n\\twhile(sr<=er && sc<=ec){\\n        for(int i=sc;i<=ec;i++){\\n            // ans.push_back(matrix[sr][i]);\\n            ans[sr][i]=t->val;\\n            t=t->next;\\n            if(t==NULL)\\n                break;\\n                   }\\n               sr++;\\n        if(t==NULL)\\n                break;\\n              for(int i=sr;i<=er;i++){\\n               //ans.push_back(matrix[i][ec]);\\n                    ans[i][ec]=t->val;\\n            t=t->next;\\n            if(t==NULL)\\n                break;\\n              }\\n                 ec--;\\n        if(t==NULL)\\n                break;\\n        \\n        if(sr<=er){\\n         for(int i=ec;i>=sc;i--){\\n             //  ans.push_back(matrix[er][i]);\\n               ans[er][i]=t->val;\\n            t=t->next;\\n            if(t==NULL)\\n                break;\\n              }}\\n                   er--;\\n        if(t==NULL)\\n                break;\\n        \\n        if(sc<=ec){\\n      for(int i=er;i>=sr;i--){\\n              // ans.push_back(matrix[i][sc]);\\n            ans[i][sc]=t->val;\\n            t=t->next;\\n            if(t==NULL)\\n                break;\\n              }}\\n                                                          sc++;\\n        if(t==NULL)\\n                break;\\n                                                          \\n    }                       \\n             return ans;                                             \\n                                                   \\n    }",
                "solutionTags": [
                    "C",
                    "Linked List",
                    "Matrix"
                ],
                "code": "**C++**\\n  Just made small change in SPIRAL MATRIX code ,the comments are of spiral matrix(problem 54) earlier code\\n  in place of those just written the traversal of HEAD(i.e Linked List) till it become NULL.\\n       \\n                                  \\n    \\n\\t\\n\\t\\n\\t   vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        ListNode* t=head;\\n\\t\\t vector<vector<int>> ans(m,vector<int>(n,-1));\\n       // int row=matrix.size(),col=matrix[0].size();\\n\\tint sr=0,er=m-1,sc=0,ec=n-1;\\n\\twhile(sr<=er && sc<=ec){\\n        for(int i=sc;i<=ec;i++){\\n            // ans.push_back(matrix[sr][i]);\\n            ans[sr][i]=t->val;\\n            t=t->next;\\n            if(t==NULL)\\n                break;\\n                   }\\n               sr++;\\n        if(t==NULL)\\n                break;\\n              for(int i=sr;i<=er;i++){\\n               //ans.push_back(matrix[i][ec]);\\n                    ans[i][ec]=t->val;\\n            t=t->next;\\n            if(t==NULL)\\n                break;\\n              }\\n                 ec--;\\n        if(t==NULL)\\n                break;\\n        \\n        if(sr<=er){\\n         for(int i=ec;i>=sc;i--){\\n             //  ans.push_back(matrix[er][i]);\\n               ans[er][i]=t->val;\\n            t=t->next;\\n            if(t==NULL)\\n                break;\\n              }}\\n                   er--;\\n        if(t==NULL)\\n                break;\\n        \\n        if(sc<=ec){\\n      for(int i=er;i>=sr;i--){\\n              // ans.push_back(matrix[i][sc]);\\n            ans[i][sc]=t->val;\\n            t=t->next;\\n            if(t==NULL)\\n                break;\\n              }}\\n                                                          sc++;\\n        if(t==NULL)\\n                break;\\n                                                          \\n    }                       \\n             return ans;                                             \\n                                                   \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2230316,
                "title": "c-easy-and-concise-code-o-n-solution-similar-to-54-spiral-matrix",
                "content": "``` \\nvector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        vector<vector<int>> ans(m, vector<int>(n, -1));\\n        int sr = 0, sc = 0, er = m  - 1, ec = n-1;\\n        while(head != NULL){\\n            \\n            for(int i = sr, j = sc; j <= ec && head != NULL; j++){\\n                ans[i][j] = head->val;\\n                head = head->next;\\n            }\\n            sr++;\\n            \\n            for(int i = sr, j = ec; i <= er && head != NULL; i++){\\n                ans[i][j] = head->val;\\n                head = head->next;\\n            }\\n            ec--;\\n            \\n            for(int i = er, j = ec; j >= sc && head != NULL; j--){\\n                ans[i][j] = head->val;\\n                head = head->next;\\n            }\\n            er--;\\n            \\n            for(int i = er, j = sc; i >= sr && head != NULL; i--){\\n                ans[i][j] = head->val;\\n                head = head->next;\\n            }\\n            sc++;\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "``` \\nvector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        vector<vector<int>> ans(m, vector<int>(n, -1));\\n        int sr = 0, sc = 0, er = m  - 1, ec = n-1;\\n        while(head != NULL){\\n            \\n            for(int i = sr, j = sc; j <= ec && head != NULL; j++){\\n                ans[i][j] = head->val;\\n                head = head->next;\\n            }\\n            sr++;\\n            \\n            for(int i = sr, j = ec; i <= er && head != NULL; i++){\\n                ans[i][j] = head->val;\\n                head = head->next;\\n            }\\n            ec--;\\n            \\n            for(int i = er, j = ec; j >= sc && head != NULL; j--){\\n                ans[i][j] = head->val;\\n                head = head->next;\\n            }\\n            er--;\\n            \\n            for(int i = er, j = sc; i >= sr && head != NULL; i--){\\n                ans[i][j] = head->val;\\n                head = head->next;\\n            }\\n            sc++;\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2230298,
                "title": "c-easy-understanding-o-n-time",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    \\n    // Simple solution.\\n    // Same as Spiral Matrix I. Using temp to iterate over the linked list.\\n    \\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        swap(n, m);\\n        ListNode* temp = head; // \\n        vector<vector<int>> ans(n, vector<int> (m, -1));\\n        int r=0, c=0;\\n        while(r<n and c<m and temp) {\\n            for(int i=c;i<m;i++) {\\n                if(temp) {\\n                    ans[r][i] = temp->val;        \\n                    temp = temp->next;\\n                }\\n            }\\n            r++;\\n            for(int i=r;i<n;i++) {\\n                if(temp) {\\n                    ans[i][m-1] = temp->val;\\n                    temp = temp->next;\\n                }\\n            }\\n            m--;\\n            if(r < n) {\\n                for(int i=m-1;i>=c;i--){\\n                    if(temp) {\\n                        ans[n-1][i] = temp->val;\\n                        temp = temp->next;\\n                    }\\n                }\\n                n--;\\n            }\\n            if(c < m) {\\n                for(int i=n-1;i>=r;i--){\\n                    if(temp) {\\n                        ans[i][c] = temp->val;\\n                        temp = temp->next;\\n                    }\\n                }\\n                c++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Linked List",
                    "Matrix"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    \\n    // Simple solution.\\n    // Same as Spiral Matrix I. Using temp to iterate over the linked list.\\n    \\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        swap(n, m);\\n        ListNode* temp = head; // \\n        vector<vector<int>> ans(n, vector<int> (m, -1));\\n        int r=0, c=0;\\n        while(r<n and c<m and temp) {\\n            for(int i=c;i<m;i++) {\\n                if(temp) {\\n                    ans[r][i] = temp->val;        \\n                    temp = temp->next;\\n                }\\n            }\\n            r++;\\n            for(int i=r;i<n;i++) {\\n                if(temp) {\\n                    ans[i][m-1] = temp->val;\\n                    temp = temp->next;\\n                }\\n            }\\n            m--;\\n            if(r < n) {\\n                for(int i=m-1;i>=c;i--){\\n                    if(temp) {\\n                        ans[n-1][i] = temp->val;\\n                        temp = temp->next;\\n                    }\\n                }\\n                n--;\\n            }\\n            if(c < m) {\\n                for(int i=n-1;i>=r;i--){\\n                    if(temp) {\\n                        ans[i][c] = temp->val;\\n                        temp = temp->next;\\n                    }\\n                }\\n                c++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2230266,
                "title": "c-easy-solution",
                "content": "```\\npublic class Solution\\n{\\n    public int[][] SpiralMatrix(int m, int n, ListNode head)\\n    {\\n        var matrix = new int[m][];\\n        for (var i = 0; i < m; i++)\\n        {\\n            var arr = new int[n];\\n            Array.Fill(arr, -1);\\n            matrix[i] = arr;\\n        }\\n\\n        if (n == 0 || m == 0) return matrix;\\n\\n        var rowStart = 0;\\n        var rowEnd = m - 1;\\n        var colStart = 0;\\n        var colEnd = n - 1;\\n        var ln = head;\\n\\n        while (rowStart <= rowEnd && colStart <= colEnd)\\n        {\\n            for (var i = colStart; i <= colEnd; i++)\\n            {\\n                if(ln == null)\\n                    return matrix;\\n                \\n                matrix[rowStart][i] = ln.val;\\n                ln = ln.next;\\n            }\\n\\n            rowStart++;\\n\\n            for (var i = rowStart; i <= rowEnd; i++)\\n            {\\n                if(ln == null)\\n                    return matrix;\\n                \\n                matrix[i][colEnd] = ln.val;\\n                ln = ln.next;\\n            }\\n\\n            colEnd--;\\n\\n            for (var i = colEnd; i >= colStart; i--)\\n                if (rowStart <= rowEnd)\\n                {\\n                    if(ln == null)\\n                        return matrix;\\n                    \\n                    matrix[rowEnd][i] = ln.val;\\n                    ln = ln.next;\\n                }\\n\\n            rowEnd--;\\n\\n            for (var i = rowEnd; i >= rowStart; i--)\\n                if (colStart <= colEnd)\\n                {\\n                    if(ln == null)\\n                        return matrix;\\n                    \\n                    matrix[i][colStart] = ln.val;\\n                    ln = ln.next;\\n                }\\n\\n            colStart++;\\n        }\\n\\n        return matrix;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution\\n{\\n    public int[][] SpiralMatrix(int m, int n, ListNode head)\\n    {\\n        var matrix = new int[m][];\\n        for (var i = 0; i < m; i++)\\n        {\\n            var arr = new int[n];\\n            Array.Fill(arr, -1);\\n            matrix[i] = arr;\\n        }\\n\\n        if (n == 0 || m == 0) return matrix;\\n\\n        var rowStart = 0;\\n        var rowEnd = m - 1;\\n        var colStart = 0;\\n        var colEnd = n - 1;\\n        var ln = head;\\n\\n        while (rowStart <= rowEnd && colStart <= colEnd)\\n        {\\n            for (var i = colStart; i <= colEnd; i++)\\n            {\\n                if(ln == null)\\n                    return matrix;\\n                \\n                matrix[rowStart][i] = ln.val;\\n                ln = ln.next;\\n            }\\n\\n            rowStart++;\\n\\n            for (var i = rowStart; i <= rowEnd; i++)\\n            {\\n                if(ln == null)\\n                    return matrix;\\n                \\n                matrix[i][colEnd] = ln.val;\\n                ln = ln.next;\\n            }\\n\\n            colEnd--;\\n\\n            for (var i = colEnd; i >= colStart; i--)\\n                if (rowStart <= rowEnd)\\n                {\\n                    if(ln == null)\\n                        return matrix;\\n                    \\n                    matrix[rowEnd][i] = ln.val;\\n                    ln = ln.next;\\n                }\\n\\n            rowEnd--;\\n\\n            for (var i = rowEnd; i >= rowStart; i--)\\n                if (colStart <= colEnd)\\n                {\\n                    if(ln == null)\\n                        return matrix;\\n                    \\n                    matrix[i][colStart] = ln.val;\\n                    ln = ln.next;\\n                }\\n\\n            colStart++;\\n        }\\n\\n        return matrix;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2230238,
                "title": "easiest-java-solution-beginner-friendly",
                "content": "```\\nclass Solution {\\n    public int[][] spiralMatrix(int m, int n, ListNode head) {\\n        int[][] matrix = new int[m][n];\\n        for(int[] row : matrix){\\n            Arrays.fill(row, -1);\\n        }\\n        int sr = 0 , sc = 0, dr = m-1, dc = n-1;\\n        while(head != null){\\n            for(int i=sr, j = sc ; j <= dc && head != null; j++){\\n                matrix[i][j] = head.val;\\n                head = head.next;\\n            }\\n            sr++;\\n            for(int i=sr, j = dc ; i <= dr && head != null; i++){\\n                matrix[i][j] = head.val;\\n                head = head.next;\\n            }\\n            dc--;\\n            for(int i=dr, j = dc ; j >= sc && head != null; j--){\\n                matrix[i][j] = head.val;\\n                head = head.next;;\\n            }\\n            dr--;\\n            for(int i=dr, j = sc ; i >= sr && head != null; i--){\\n                matrix[i][j] = head.val;\\n                head = head.next;\\n            }\\n            sc++;\\n        }\\n        return matrix;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] spiralMatrix(int m, int n, ListNode head) {\\n        int[][] matrix = new int[m][n];\\n        for(int[] row : matrix){\\n            Arrays.fill(row, -1);\\n        }\\n        int sr = 0 , sc = 0, dr = m-1, dc = n-1;\\n        while(head != null){\\n            for(int i=sr, j = sc ; j <= dc && head != null; j++){\\n                matrix[i][j] = head.val;\\n                head = head.next;\\n            }\\n            sr++;\\n            for(int i=sr, j = dc ; i <= dr && head != null; i++){\\n                matrix[i][j] = head.val;\\n                head = head.next;\\n            }\\n            dc--;\\n            for(int i=dr, j = dc ; j >= sc && head != null; j--){\\n                matrix[i][j] = head.val;\\n                head = head.next;;\\n            }\\n            dr--;\\n            for(int i=dr, j = sc ; i >= sr && head != null; i--){\\n                matrix[i][j] = head.val;\\n                head = head.next;\\n            }\\n            sc++;\\n        }\\n        return matrix;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2230235,
                "title": "c-solution-easy-to-understand-spiral-matrix-iv",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        vector<vector<int>> ans(m, vector<int>(n,-1));\\n        int top = 0,down = m-1,left =0,right = n-1; \\n        int dir = 0;    \\n        while(top<=down && left<=right){\\n            if(dir==0){\\n                for(int i = left;i<=right;i++){\\n                    if(head->next!=NULL){\\n                    ans[top][i] = head->val;\\n                    head = head->next;\\n                    }else{\\n                        ans[top][i] = head->val;\\n                        return ans;\\n                        exit(1);\\n                    }\\n                }\\n                top++;\\n            }\\n            \\n          else if(dir==1){\\n              for(int i=top;i<=down;i++){\\n                  if(head->next!=NULL){\\n                      ans[i][right] = head->val;\\n                      head = head->next;\\n                  }else{\\n                      ans[i][right] = head->val;\\n                      return ans;\\n                      exit(1);\\n                  }\\n              }\\n              right--;\\n          }\\n        else if(dir == 2){\\n            for(int i=right;i>=left;i--){\\n                if(head->next!=NULL){\\n                    ans[down][i] = head->val;\\n                    head = head->next;\\n                }else{\\n                    ans[down][i] = head->val;\\n                    return ans;\\n                    exit(1);\\n                }\\n            }\\n            down--;\\n        }\\n        else if(dir == 3){\\n            for(int i=down;i>=top;i--){\\n                if(head->next!=NULL){\\n                    ans[i][left] = head->val;\\n                    head = head->next;\\n                }else{\\n                    ans[i][left] = head->val;\\n                    return ans;\\n                    exit(1);\\n                }\\n            }\\n            left++;\\n        }\\n            dir = (dir + 1)%4;\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        vector<vector<int>> ans(m, vector<int>(n,-1));\\n        int top = 0,down = m-1,left =0,right = n-1; \\n        int dir = 0;    \\n        while(top<=down && left<=right){\\n            if(dir==0){\\n                for(int i = left;i<=right;i++){\\n                    if(head->next!=NULL){\\n                    ans[top][i] = head->val;\\n                    head = head->next;\\n                    }else{\\n                        ans[top][i] = head->val;\\n                        return ans;\\n                        exit(1);\\n                    }\\n                }\\n                top++;\\n            }\\n            \\n          else if(dir==1){\\n              for(int i=top;i<=down;i++){\\n                  if(head->next!=NULL){\\n                      ans[i][right] = head->val;\\n                      head = head->next;\\n                  }else{\\n                      ans[i][right] = head->val;\\n                      return ans;\\n                      exit(1);\\n                  }\\n              }\\n              right--;\\n          }\\n        else if(dir == 2){\\n            for(int i=right;i>=left;i--){\\n                if(head->next!=NULL){\\n                    ans[down][i] = head->val;\\n                    head = head->next;\\n                }else{\\n                    ans[down][i] = head->val;\\n                    return ans;\\n                    exit(1);\\n                }\\n            }\\n            down--;\\n        }\\n        else if(dir == 3){\\n            for(int i=down;i>=top;i--){\\n                if(head->next!=NULL){\\n                    ans[i][left] = head->val;\\n                    head = head->next;\\n                }else{\\n                    ans[i][left] = head->val;\\n                    return ans;\\n                    exit(1);\\n                }\\n            }\\n            left++;\\n        }\\n            dir = (dir + 1)%4;\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2230163,
                "title": "java-simple-easy-read-4min-read",
                "content": "```\\npublic int[][] spiralMatrix(int n, int m, ListNode head) {\\n        int[][]ans=new int[n][m];\\n        for(int[]i:ans)Arrays.fill(i,-1);\\n        int top=0,left=0,right=m-1,bottom=n-1;\\n        int dir=0;\\n        Deque<Integer> q=new ArrayDeque<>();\\n        while(head!=null){\\n            q.offerLast(head.val);\\n            head=head.next;\\n        }\\n        while(!q.isEmpty()&&top<=bottom&&left<=right){\\n            if(dir==0){\\n                for(int i=left;i<=right&&!q.isEmpty();i++){\\n                    ans[top][i]=q.pollFirst();\\n                }\\n                top++;\\n            }else if(dir==1){\\n                for(int i=top;i<=bottom&&!q.isEmpty();i++){\\n                    ans[i][right]=q.pollFirst();\\n                }\\n                right--;\\n            }else if(dir==2){\\n                for(int i=right;i>=left&&!q.isEmpty();i--){\\n                    ans[bottom][i]=q.pollFirst();\\n                }\\n                bottom--;\\n            }else{\\n                for(int i=bottom;i>=top&&!q.isEmpty();i--){\\n                    ans[i][left]=q.pollFirst();\\n                }\\n                left++;\\n            }\\n            dir=(dir+1)%4;\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Matrix"
                ],
                "code": "```\\npublic int[][] spiralMatrix(int n, int m, ListNode head) {\\n        int[][]ans=new int[n][m];\\n        for(int[]i:ans)Arrays.fill(i,-1);\\n        int top=0,left=0,right=m-1,bottom=n-1;\\n        int dir=0;\\n        Deque<Integer> q=new ArrayDeque<>();\\n        while(head!=null){\\n            q.offerLast(head.val);\\n            head=head.next;\\n        }\\n        while(!q.isEmpty()&&top<=bottom&&left<=right){\\n            if(dir==0){\\n                for(int i=left;i<=right&&!q.isEmpty();i++){\\n                    ans[top][i]=q.pollFirst();\\n                }\\n                top++;\\n            }else if(dir==1){\\n                for(int i=top;i<=bottom&&!q.isEmpty();i++){\\n                    ans[i][right]=q.pollFirst();\\n                }\\n                right--;\\n            }else if(dir==2){\\n                for(int i=right;i>=left&&!q.isEmpty();i--){\\n                    ans[bottom][i]=q.pollFirst();\\n                }\\n                bottom--;\\n            }else{\\n                for(int i=bottom;i>=top&&!q.isEmpty();i--){\\n                    ans[i][left]=q.pollFirst();\\n                }\\n                left++;\\n            }\\n            dir=(dir+1)%4;\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2230130,
                "title": "linear-time-solution-java-easy",
                "content": "```\\nclass Solution {\\n    public int[][] spiralMatrix(int m, int n, ListNode head) {\\n        ListNode p=head;\\n        int i=0,j=0,arr[][]=new int[m][n],flag=1;//1-right, 2-down,3-left ,4-up\\n        int left=-1,up=0,loop=0,mn=m*n;\\n        while(flag>0 && loop<mn){\\n            int val=(p==null)?-1:p.val;\\n            switch(flag){\\n                case 1:\\n                    if(j+1==n){\\n                        flag++;\\n                        n--;\\n                        break;\\n                    }\\n                    arr[i][j]=val;\\n                    j++;\\n                    loop++;\\n                    if(p!=null)p=p.next;\\n                    break;\\n                case 2:\\n                    if(i+1==m){\\n                        flag++;\\n                        m--;\\n                        break;\\n                    }\\n                    arr[i][j]=val;\\n                    i++;\\n                    loop++;\\n                    if(p!=null)p=p.next;\\n                    break;\\n                case 3:\\n                    if(j-1==left){\\n                        flag++;\\n                        left++;\\n                        break;\\n                    }\\n                    arr[i][j]=val;\\n                    j--;\\n                    loop++;\\n                    if(p!=null)p=p.next;\\n                    break;\\n                case 4:\\n                    if(i-1==up){\\n                        flag=1;\\n                        up++;\\n                        break;\\n                    }\\n                    arr[i][j]=val;\\n                    i--;\\n                    loop++;\\n                    if(p!=null)p=p.next;\\n                    break;\\n            }\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] spiralMatrix(int m, int n, ListNode head) {\\n        ListNode p=head;\\n        int i=0,j=0,arr[][]=new int[m][n],flag=1;//1-right, 2-down,3-left ,4-up\\n        int left=-1,up=0,loop=0,mn=m*n;\\n        while(flag>0 && loop<mn){\\n            int val=(p==null)?-1:p.val;\\n            switch(flag){\\n                case 1:\\n                    if(j+1==n){\\n                        flag++;\\n                        n--;\\n                        break;\\n                    }\\n                    arr[i][j]=val;\\n                    j++;\\n                    loop++;\\n                    if(p!=null)p=p.next;\\n                    break;\\n                case 2:\\n                    if(i+1==m){\\n                        flag++;\\n                        m--;\\n                        break;\\n                    }\\n                    arr[i][j]=val;\\n                    i++;\\n                    loop++;\\n                    if(p!=null)p=p.next;\\n                    break;\\n                case 3:\\n                    if(j-1==left){\\n                        flag++;\\n                        left++;\\n                        break;\\n                    }\\n                    arr[i][j]=val;\\n                    j--;\\n                    loop++;\\n                    if(p!=null)p=p.next;\\n                    break;\\n                case 4:\\n                    if(i-1==up){\\n                        flag=1;\\n                        up++;\\n                        break;\\n                    }\\n                    arr[i][j]=val;\\n                    i--;\\n                    loop++;\\n                    if(p!=null)p=p.next;\\n                    break;\\n            }\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2230100,
                "title": "python-solution",
                "content": "```\\nclass Solution:\\n    def spiralMatrix(self, m: int, n: int, head: Optional[ListNode]) -> List[List[int]]:\\n        matrix= [[-1 for j in range(n)] for i in range(m)]\\n       \\n        left = 0\\n        right = n-1\\n        top = 0\\n        bottom = m-1\\n       \\n        if not head:\\n            return matrix\\n       \\n        while(left < right and top < bottom):\\n            for i in range(left,right):\\n                matrix[top][i] = head.val\\n                if(head.next==None):\\n                    return matrix\\n                head = head.next\\n               \\n            for i in range(top,bottom):\\n                matrix[i][right] = head.val\\n                if(head.next==None):\\n                    return matrix\\n                head = head.next\\n               \\n            for i in range(right,left,-1):\\n                matrix[bottom][i] = head.val\\n                if(head.next==None):\\n                    return matrix\\n                head = head.next\\n               \\n            for i in range(bottom,top,-1):\\n                matrix[i][left] = head.val\\n                if(head.next==None):\\n                    return matrix\\n                head = head.next\\n               \\n            left += 1\\n            right -=1\\n            top +=1\\n            bottom -=1\\n           \\n        if(left == right and top == bottom):\\n            matrix[left][right] = head.val\\n            if(head.next==None):\\n                    return matrix\\n            head = head.next\\n       \\n        elif(left == right):\\n            for i in range(top,bottom + 1):\\n                matrix[i][left] = head.val\\n                if(head.next==None):\\n                    return matrix\\n                head = head.next\\n               \\n        elif(top == bottom):\\n            for i in range(left,right +1):\\n                matrix[top][i] = head.val\\n                if(head.next==None):\\n                    return matrix\\n                head = head.next\\n           \\n        return matrix\\n```",
                "solutionTags": [
                    "Python",
                    "Linked List",
                    "Matrix"
                ],
                "code": "```\\nclass Solution:\\n    def spiralMatrix(self, m: int, n: int, head: Optional[ListNode]) -> List[List[int]]:\\n        matrix= [[-1 for j in range(n)] for i in range(m)]\\n       \\n        left = 0\\n        right = n-1\\n        top = 0\\n        bottom = m-1\\n       \\n        if not head:\\n            return matrix\\n       \\n        while(left < right and top < bottom):\\n            for i in range(left,right):\\n                matrix[top][i] = head.val\\n                if(head.next==None):\\n                    return matrix\\n                head = head.next\\n               \\n            for i in range(top,bottom):\\n                matrix[i][right] = head.val\\n                if(head.next==None):\\n                    return matrix\\n                head = head.next\\n               \\n            for i in range(right,left,-1):\\n                matrix[bottom][i] = head.val\\n                if(head.next==None):\\n                    return matrix\\n                head = head.next\\n               \\n            for i in range(bottom,top,-1):\\n                matrix[i][left] = head.val\\n                if(head.next==None):\\n                    return matrix\\n                head = head.next\\n               \\n            left += 1\\n            right -=1\\n            top +=1\\n            bottom -=1\\n           \\n        if(left == right and top == bottom):\\n            matrix[left][right] = head.val\\n            if(head.next==None):\\n                    return matrix\\n            head = head.next\\n       \\n        elif(left == right):\\n            for i in range(top,bottom + 1):\\n                matrix[i][left] = head.val\\n                if(head.next==None):\\n                    return matrix\\n                head = head.next\\n               \\n        elif(top == bottom):\\n            for i in range(left,right +1):\\n                matrix[top][i] = head.val\\n                if(head.next==None):\\n                    return matrix\\n                head = head.next\\n           \\n        return matrix\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2230084,
                "title": "spiral-traversal-explanation-in-comments-c-o-m-n",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int n, int m, ListNode* head) {\\n        vector<vector<int>> matrix(n,vector<int> (m,-1));\\n        \\n        int left =0, right = m-1, top =0, bottom = n-1;\\n        \\n        int i;\\n        ListNode *temp = head;\\n        \\n        while(left <= right and top <= bottom and temp!=NULL) {\\n            \\n            // left to right in the top row\\n            for(i = left; i <= right; i++) {\\n                if(temp) {matrix[top][i] = temp->val;\\n                temp = temp ->next;}\\n            }\\n            // now that top row is done,decrement the top pointer\\n            top++;\\n            \\n            if(left > right || top > bottom || temp == NULL) break;\\n            \\n            //top to bottom in the rightmost column\\n            for(i = top; i <= bottom; i++) {\\n               \\n                 if(temp) { matrix[i][right] = temp->val;\\n                temp = temp ->next;}\\n            }\\n            right--;\\n            \\n            if(left > right || top > bottom || temp == NULL) break;\\n            \\n            //right to left in the bottom row\\n            for(i = right; i >= left; i--) {\\n              \\n                if(temp) {matrix[bottom][i] = temp->val;\\n                temp = temp ->next;}\\n            }\\n            bottom--;\\n            \\n            if(left > right || top > bottom || temp == NULL) break;\\n            \\n            //bottom to top in the left most column\\n            for(i=bottom; i >= top; i--) {\\n                \\n                if(temp) {matrix[i][left] = temp->val;\\n                temp = temp->next;}\\n                \\n            }\\n            left++;\\n            \\n            if(left > right || top > bottom || temp == NULL) break;\\n        }\\n        \\n        return matrix;\\n        \\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Matrix",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int n, int m, ListNode* head) {\\n        vector<vector<int>> matrix(n,vector<int> (m,-1));\\n        \\n        int left =0, right = m-1, top =0, bottom = n-1;\\n        \\n        int i;\\n        ListNode *temp = head;\\n        \\n        while(left <= right and top <= bottom and temp!=NULL) {\\n            \\n            // left to right in the top row\\n            for(i = left; i <= right; i++) {\\n                if(temp) {matrix[top][i] = temp->val;\\n                temp = temp ->next;}\\n            }\\n            // now that top row is done,decrement the top pointer\\n            top++;\\n            \\n            if(left > right || top > bottom || temp == NULL) break;\\n            \\n            //top to bottom in the rightmost column\\n            for(i = top; i <= bottom; i++) {\\n               \\n                 if(temp) { matrix[i][right] = temp->val;\\n                temp = temp ->next;}\\n            }\\n            right--;\\n            \\n            if(left > right || top > bottom || temp == NULL) break;\\n            \\n            //right to left in the bottom row\\n            for(i = right; i >= left; i--) {\\n              \\n                if(temp) {matrix[bottom][i] = temp->val;\\n                temp = temp ->next;}\\n            }\\n            bottom--;\\n            \\n            if(left > right || top > bottom || temp == NULL) break;\\n            \\n            //bottom to top in the left most column\\n            for(i=bottom; i >= top; i--) {\\n                \\n                if(temp) {matrix[i][left] = temp->val;\\n                temp = temp->next;}\\n                \\n            }\\n            left++;\\n            \\n            if(left > right || top > bottom || temp == NULL) break;\\n        }\\n        \\n        return matrix;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2230071,
                "title": "easy-python-solution",
                "content": "Kindly upvote\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def spiralMatrix(self, m: int, n: int, head: Optional[ListNode]) -> List[List[int]]:\\n        matrix= [[-1 for j in range(n)] for i in range(m)]\\n        \\n        l=0     #left\\n        r= n-1    #right\\n        t=0  #top\\n        b= m-1   #bottom\\n        \\n        if(head==None):\\n            return matrix\\n        \\n        while(l<r and t<b):\\n\\t\\t\\t# iterate top row from left to right\\n            for i in range(l,r):\\n                matrix[t][i] = head.val\\n                if(head.next==None):       # check if head becomes NULL\\n                    return matrix\\n                head = head.next\\n             \\n\\t\\t\\t#iterate right column from top to bottom\\n            for i in range(t,b):\\n                matrix[i][r] = head.val\\n                if(head.next==None):\\n                    return matrix\\n                head = head.next\\n            \\n\\t\\t\\t#iterate bottom row from right to left\\n            for i in range(r,l,-1):\\n                matrix[b][i] = head.val\\n                if(head.next==None):\\n                    return matrix\\n                head = head.next\\n            \\n\\t\\t\\t#iterate left column from bottom to top\\n            for i in range(b,t,-1):\\n                matrix[i][l] = head.val\\n                if(head.next==None):\\n                    return matrix\\n                head = head.next\\n                \\n            l+=1\\n            r-=1\\n            t+=1\\n            b-=1\\n            \\n\\t\\t# if single remaining middle element\\n        if(l==r and t==b):\\n            matrix[l][r] = head.val\\n            if(head.next==None):\\n                    return matrix\\n            head = head.next\\n        \\n\\t\\t# if remaining vertical elements\\n        elif(l==r):\\n            for i in range(t,b+1):\\n                matrix[i][l] = head.val\\n                if(head.next==None):\\n                    return matrix\\n                head = head.next\\n                \\n\\t\\t# if remaining horizontal elements\\n        elif(t==b):\\n            for i in range(l,r+1):\\n                matrix[t][i] = head.val\\n                if(head.next==None):\\n                    return matrix\\n                head = head.next\\n            \\n        return matrix\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def spiralMatrix(self, m: int, n: int, head: Optional[ListNode]) -> List[List[int]]:\\n        matrix= [[-1 for j in range(n)] for i in range(m)]\\n        \\n        l=0     #left\\n        r= n-1    #right\\n        t=0  #top\\n        b= m-1   #bottom\\n        \\n        if(head==None):\\n            return matrix\\n        \\n        while(l<r and t<b):\\n\\t\\t\\t# iterate top row from left to right\\n            for i in range(l,r):\\n                matrix[t][i] = head.val\\n                if(head.next==None):       # check if head becomes NULL\\n                    return matrix\\n                head = head.next\\n             \\n\\t\\t\\t#iterate right column from top to bottom\\n            for i in range(t,b):\\n                matrix[i][r] = head.val\\n                if(head.next==None):\\n                    return matrix\\n                head = head.next\\n            \\n\\t\\t\\t#iterate bottom row from right to left\\n            for i in range(r,l,-1):\\n                matrix[b][i] = head.val\\n                if(head.next==None):\\n                    return matrix\\n                head = head.next\\n            \\n\\t\\t\\t#iterate left column from bottom to top\\n            for i in range(b,t,-1):\\n                matrix[i][l] = head.val\\n                if(head.next==None):\\n                    return matrix\\n                head = head.next\\n                \\n            l+=1\\n            r-=1\\n            t+=1\\n            b-=1\\n            \\n\\t\\t# if single remaining middle element\\n        if(l==r and t==b):\\n            matrix[l][r] = head.val\\n            if(head.next==None):\\n                    return matrix\\n            head = head.next\\n        \\n\\t\\t# if remaining vertical elements\\n        elif(l==r):\\n            for i in range(t,b+1):\\n                matrix[i][l] = head.val\\n                if(head.next==None):\\n                    return matrix\\n                head = head.next\\n                \\n\\t\\t# if remaining horizontal elements\\n        elif(t==b):\\n            for i in range(l,r+1):\\n                matrix[t][i] = head.val\\n                if(head.next==None):\\n                    return matrix\\n                head = head.next\\n            \\n        return matrix\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2230064,
                "title": "c-9-lines",
                "content": "```\\npublic class Solution \\n{\\n    public int[][] SpiralMatrix(int m, int n, ListNode head) \\n    {\\n        int[][] res = Enumerable.Range(0, m).Select(i => Enumerable.Repeat(-1, n).ToArray()).ToArray();\\n        \\n        for (int i = 0, j = 0, di = 0, dj = +1; head is not null; (i, j) = (i + di, j + dj)) \\n        {\\n            res[i][j] = head.val;\\n            head = head.next;\\n            \\n            if (!isOK(i + di, j + dj)) (di, dj) = (dj, -di);\\n                \\n            bool isOK(int x, int y) => x >= 0 && x < m && y >= 0 && y < n && res[x][y] == -1; \\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution \\n{\\n    public int[][] SpiralMatrix(int m, int n, ListNode head) \\n    {\\n        int[][] res = Enumerable.Range(0, m).Select(i => Enumerable.Repeat(-1, n).ToArray()).ToArray();\\n        \\n        for (int i = 0, j = 0, di = 0, dj = +1; head is not null; (i, j) = (i + di, j + dj)) \\n        {\\n            res[i][j] = head.val;\\n            head = head.next;\\n            \\n            if (!isOK(i + di, j + dj)) (di, dj) = (dj, -di);\\n                \\n            bool isOK(int x, int y) => x >= 0 && x < m && y >= 0 && y < n && res[x][y] == -1; \\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2230054,
                "title": "simple-constructive-solution",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        int fRow = 0, fCol= 0, lRow = m-1, lCol = n-1;\\n        int count = 0;\\n        vector<vector<int>> mat(m, vector<int> (n, -1));\\n        while(count<n*m){\\n            for(int j=fCol; j<=lCol; j++){\\n                mat[fRow][j] = head->val;\\n                head = head->next;\\n                if(++count==m*n || head == NULL)    return mat;\\n            }\\n            if(count==m*n || head == NULL)  return mat;\\n            fRow++;\\n            for(int i=fRow; i<=lRow; i++){\\n                mat[i][lCol] = head->val;\\n                head = head->next;\\n                if(++count==m*n || head == NULL)    return mat;\\n            }\\n            if(count==m*n || head == NULL)  return mat;\\n            lCol--;\\n            for(int j=lCol; j>=fCol; j--){\\n                mat[lRow][j] = head->val;\\n                head = head->next;\\n                if(++count==m*n || head == NULL)    return mat;\\n            }\\n            if(count==m*n || head == NULL)  return mat;\\n            lRow--;\\n            for(int i=lRow; i>=fRow; i--){\\n                mat[i][fCol] = head->val;\\n                head = head->next;\\n                if(++count==m*n || head == NULL)    return mat;\\n            }\\n            if(count==m*n || head == NULL)  return mat;\\n            fCol++;\\n        }\\n        return mat;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Linked List",
                    "Matrix"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        int fRow = 0, fCol= 0, lRow = m-1, lCol = n-1;\\n        int count = 0;\\n        vector<vector<int>> mat(m, vector<int> (n, -1));\\n        while(count<n*m){\\n            for(int j=fCol; j<=lCol; j++){\\n                mat[fRow][j] = head->val;\\n                head = head->next;\\n                if(++count==m*n || head == NULL)    return mat;\\n            }\\n            if(count==m*n || head == NULL)  return mat;\\n            fRow++;\\n            for(int i=fRow; i<=lRow; i++){\\n                mat[i][lCol] = head->val;\\n                head = head->next;\\n                if(++count==m*n || head == NULL)    return mat;\\n            }\\n            if(count==m*n || head == NULL)  return mat;\\n            lCol--;\\n            for(int j=lCol; j>=fCol; j--){\\n                mat[lRow][j] = head->val;\\n                head = head->next;\\n                if(++count==m*n || head == NULL)    return mat;\\n            }\\n            if(count==m*n || head == NULL)  return mat;\\n            lRow--;\\n            for(int i=lRow; i>=fRow; i--){\\n                mat[i][fCol] = head->val;\\n                head = head->next;\\n                if(++count==m*n || head == NULL)    return mat;\\n            }\\n            if(count==m*n || head == NULL)  return mat;\\n            fCol++;\\n        }\\n        return mat;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2230043,
                "title": "simple-efficient-solution",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\ntypedef int ll;\\ntypedef long double ld;\\ntypedef pair<ll, ll> pi;\\n#define vi(x) vector<x>\\n#define li(x) list<x>\\n#define pb push_back\\n#define ln ListNode\\nconst ll mod = 1e9 + 7;\\nconst char nl = \\'\\\\n\\';\\nvector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n    ll p = -1, cnt = 0;\\n    vi(vi(ll))res(m, vi(ll)(n, -1));\\n    while (cnt < (m * n)) {\\n        ++p;\\n        for (ll i = 0;i < n - (2 * p);++i) {\\n            if (!head)\\n                return res;\\n            res[p][p + i] = head->val;\\n            head = head->next;\\n            ++cnt;\\n        }\\n        for (ll i = 1;i < m - 2 * p;++i) {\\n            if (!head)\\n                return res;\\n            res[p + i][n - 1 - p] = head->val;\\n            head = head->next;\\n            ++cnt;\\n        }\\n        for (ll i = n - p - 2;i >= p;--i) {\\n            if (!head)\\n                return res;\\n            res[m - 1 - p][i] = head->val;\\n            head = head->next;\\n            ++cnt;\\n        }\\n        for (ll i = m - p - 2;i >= p + 1;--i) {\\n            if (!head)\\n                return res;\\n            res[i][p] = head->val;\\n            head = head->next;\\n            ++cnt;\\n        }\\n    }\\n    return res;\\n}\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\ntypedef int ll;\\ntypedef long double ld;\\ntypedef pair<ll, ll> pi;\\n#define vi(x) vector<x>\\n#define li(x) list<x>\\n#define pb push_back\\n#define ln ListNode\\nconst ll mod = 1e9 + 7;\\nconst char nl = \\'\\\\n\\';\\nvector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n    ll p = -1, cnt = 0;\\n    vi(vi(ll))res(m, vi(ll)(n, -1));\\n    while (cnt < (m * n)) {\\n        ++p;\\n        for (ll i = 0;i < n - (2 * p);++i) {\\n            if (!head)\\n                return res;\\n            res[p][p + i] = head->val;\\n            head = head->next;\\n            ++cnt;\\n        }\\n        for (ll i = 1;i < m - 2 * p;++i) {\\n            if (!head)\\n                return res;\\n            res[p + i][n - 1 - p] = head->val;\\n            head = head->next;\\n            ++cnt;\\n        }\\n        for (ll i = n - p - 2;i >= p;--i) {\\n            if (!head)\\n                return res;\\n            res[m - 1 - p][i] = head->val;\\n            head = head->next;\\n            ++cnt;\\n        }\\n        for (ll i = m - p - 2;i >= p + 1;--i) {\\n            if (!head)\\n                return res;\\n            res[i][p] = head->val;\\n            head = head->next;\\n            ++cnt;\\n        }\\n    }\\n    return res;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2230030,
                "title": "simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        vector<vector<int>> mat(m,vector<int>(n));\\n\\n        int left=0 , right=n-1; // column pointers\\n        int top=0 , bottom=m-1; // row pointers\\n        int dir = 0;\\n        while(left<=right && top<=bottom) {\\n            if(dir == 0) {\\n                for(int i=left ; i<=right ; i++) {\\n                    mat[top][i] = (head) ? head->val : -1;\\n                    if(head) head = head->next;\\n                }\\n                top++;\\n            }\\n\\n            if(dir == 1) {\\n                for(int i=top ; i<=bottom ; i++) {\\n                    mat[i][right] = (head) ? head->val : -1;\\n                    if(head) head = head->next;\\n                }\\n                right--;\\n            }\\n\\n            if(dir == 2) {\\n                for(int i=right ; i>=left ; i--) {\\n                    mat[bottom][i] = (head) ? head->val : -1;\\n                    if(head) head = head->next;\\n                }\\n                bottom--;\\n            }\\n\\n            if(dir == 3) {\\n                for(int i=bottom ; i>=top ; i--) {\\n                    mat[i][left] = (head) ? head->val : -1;\\n                    if(head) head = head->next;\\n                }\\n                left++;\\n            }\\n\\n            dir = (dir+1)%4;\\n        }\\n        return mat;\\n    }\\n};\\n```\\n\\nCheck all the Spiral Matrix Problems (1 to 4) here -\\nSpiral Matrix 1 - https://leetcode.com/problems/spiral-matrix/solutions/3747955/easy-traversal/\\nSpiral Matrix 2 - https://leetcode.com/problems/spiral-matrix-ii/solutions/3747970/same-as-spiral-matrix-i/\\nSpiral Matrix 3 - https://leetcode.com/problems/spiral-matrix-iii/solutions/3750377/solution-made-easy/\\nSpiral Matrix 4 - https://leetcode.com/problems/spiral-matrix-iv/solutions/2230030/simple-solution/",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        vector<vector<int>> mat(m,vector<int>(n));\\n\\n        int left=0 , right=n-1; // column pointers\\n        int top=0 , bottom=m-1; // row pointers\\n        int dir = 0;\\n        while(left<=right && top<=bottom) {\\n            if(dir == 0) {\\n                for(int i=left ; i<=right ; i++) {\\n                    mat[top][i] = (head) ? head->val : -1;\\n                    if(head) head = head->next;\\n                }\\n                top++;\\n            }\\n\\n            if(dir == 1) {\\n                for(int i=top ; i<=bottom ; i++) {\\n                    mat[i][right] = (head) ? head->val : -1;\\n                    if(head) head = head->next;\\n                }\\n                right--;\\n            }\\n\\n            if(dir == 2) {\\n                for(int i=right ; i>=left ; i--) {\\n                    mat[bottom][i] = (head) ? head->val : -1;\\n                    if(head) head = head->next;\\n                }\\n                bottom--;\\n            }\\n\\n            if(dir == 3) {\\n                for(int i=bottom ; i>=top ; i--) {\\n                    mat[i][left] = (head) ? head->val : -1;\\n                    if(head) head = head->next;\\n                }\\n                left++;\\n            }\\n\\n            dir = (dir+1)%4;\\n        }\\n        return mat;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2230018,
                "title": "python-easy-solution-using-for-loops",
                "content": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def spiralMatrix(self, m: int, n: int, head: Optional[ListNode]) -> List[List[int]]:\\n        ans = [[-1]*n for i in range(m)]\\n        j = 0\\n        while True:\\n            for k in range(j,n-j):\\n                #print(j,k)\\n                ans[j][k] = head.val\\n                head = head.next\\n                if not head:\\n                    return ans\\n            for k in range(j+1,m-j):\\n                #print(k,n-j,m-j)\\n                ans[k][n-j-1] = head.val\\n                head = head.next\\n                if not head:\\n                    return ans\\n            for k in reversed(range(j,n-j-1)):\\n                #print(m-j-1,k)\\n                ans[m-j-1][k] =head.val\\n                head = head.next\\n                if not head:\\n                    return ans\\n            for k in reversed(range(j+1,m-j-1)):\\n                #print(k,j)\\n                ans[k][j] = head.val\\n                head = head.next\\n                if not head:\\n                    return ans\\n            j += 1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def spiralMatrix(self, m: int, n: int, head: Optional[ListNode]) -> List[List[int]]:\\n        ans = [[-1]*n for i in range(m)]\\n        j = 0\\n        while True:\\n            for k in range(j,n-j):\\n                #print(j,k)\\n                ans[j][k] = head.val\\n                head = head.next\\n                if not head:\\n                    return ans\\n            for k in range(j+1,m-j):\\n                #print(k,n-j,m-j)\\n                ans[k][n-j-1] = head.val\\n                head = head.next\\n                if not head:\\n                    return ans\\n            for k in reversed(range(j,n-j-1)):\\n                #print(m-j-1,k)\\n                ans[m-j-1][k] =head.val\\n                head = head.next\\n                if not head:\\n                    return ans\\n            for k in reversed(range(j+1,m-j-1)):\\n                #print(k,j)\\n                ans[k][j] = head.val\\n                head = head.next\\n                if not head:\\n                    return ans\\n            j += 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2230014,
                "title": "spiral-matrix-c-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        vector<vector<int>> res(m, vector<int> (n, -1));\\n        \\n        int rowStart = 0, rowEnd = m - 1;\\n        int colStart = 0, colEnd = n - 1;\\n        \\n        while(rowStart <= rowEnd && colStart <= colEnd and head){\\n            for(int i = colStart; i <= colEnd; i++){\\n                res[rowStart][i] = (head->val);\\n                head = head->next;\\n                if(!head) return res;\\n            }\\n            for(int i = rowStart + 1; i <= rowEnd; i++){\\n                res[i][colEnd] = (head->val);\\n                head = head->next;\\n                if(!head) return res;\\n            }\\n            if(rowStart < rowEnd && colStart < colEnd){\\n                for(int i = colEnd - 1; i > colStart; i--){\\n                    res[rowEnd][i] = (head->val);\\n                    head = head->next;\\n                    if(!head) return res;\\n                }\\n                for(int i = rowEnd; i > rowStart; i--){\\n                    res[i][colStart] = (head->val);\\n                    head = head->next;\\n                    if(!head) return res;\\n                }\\n            }\\n            rowStart++; colStart++;\\n            colEnd--; rowEnd--;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        vector<vector<int>> res(m, vector<int> (n, -1));\\n        \\n        int rowStart = 0, rowEnd = m - 1;\\n        int colStart = 0, colEnd = n - 1;\\n        \\n        while(rowStart <= rowEnd && colStart <= colEnd and head){\\n            for(int i = colStart; i <= colEnd; i++){\\n                res[rowStart][i] = (head->val);\\n                head = head->next;\\n                if(!head) return res;\\n            }\\n            for(int i = rowStart + 1; i <= rowEnd; i++){\\n                res[i][colEnd] = (head->val);\\n                head = head->next;\\n                if(!head) return res;\\n            }\\n            if(rowStart < rowEnd && colStart < colEnd){\\n                for(int i = colEnd - 1; i > colStart; i--){\\n                    res[rowEnd][i] = (head->val);\\n                    head = head->next;\\n                    if(!head) return res;\\n                }\\n                for(int i = rowEnd; i > rowStart; i--){\\n                    res[i][colStart] = (head->val);\\n                    head = head->next;\\n                    if(!head) return res;\\n                }\\n            }\\n            rowStart++; colStart++;\\n            colEnd--; rowEnd--;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2229927,
                "title": "very-simple-java-solution",
                "content": "**Intution**\\nCreate a matrix and iterate over it in a spiral manner and use the linked list to fill it.\\n \\n```\\nclass Solution {\\n    public int[][] spiralMatrix(int m, int n, ListNode head) {\\n        \\n        int[][] mat = new int[m][n];\\n        int cnt = 0;\\n        \\n        // boundaies\\n        // Left and right\\n        int lb = 0, rb = n-1;\\n        // ceil and floor\\n        int c = 0, f = m-1;\\n        \\n        while(cnt < (m*n)){\\n            \\n            // Fill L to R\\n            for(int i = lb; i <= rb ; i++){\\n                \\n                cnt++;\\n                if(head != null){   \\n                    mat[c][i] = head.val;\\n                    head = head.next;\\n                }else{\\n                    mat[c][i] = -1;\\n                }\\n            }\\n            \\n            // Fill C to F\\n            for(int j = c+1; j <= f ; j++){\\n                \\n                cnt++;\\n                if(head != null){   \\n                    mat[j][rb] = head.val;\\n                    head = head.next;\\n                }else{\\n                    mat[j][rb] = -1;\\n                }\\n            }\\n            \\n            // Fill R to L\\n            if(f != c){\\n                for(int i = rb-1; i >= lb ; i--){\\n                    \\n                    cnt++;\\n                    if(head != null){   \\n                        mat[f][i] = head.val;\\n                        head = head.next;\\n                    }else{\\n                        mat[f][i] = -1;\\n                    }\\n                }\\n            }\\n            \\n            // Fill F to C\\n            if(lb != rb){\\n                for(int j = f-1; j > c ; j--){\\n\\n                    cnt++;\\n                    if(head != null){   \\n                        mat[j][lb] = head.val;\\n                        head = head.next;\\n                    }else{\\n                        mat[j][lb] = -1;\\n                    }\\n                }\\n            }\\n            \\n            // Increment\\n            lb++;\\n            rb--;\\n            c++;\\n            f--;\\n        }\\n        \\n        return mat;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] spiralMatrix(int m, int n, ListNode head) {\\n        \\n        int[][] mat = new int[m][n];\\n        int cnt = 0;\\n        \\n        // boundaies\\n        // Left and right\\n        int lb = 0, rb = n-1;\\n        // ceil and floor\\n        int c = 0, f = m-1;\\n        \\n        while(cnt < (m*n)){\\n            \\n            // Fill L to R\\n            for(int i = lb; i <= rb ; i++){\\n                \\n                cnt++;\\n                if(head != null){   \\n                    mat[c][i] = head.val;\\n                    head = head.next;\\n                }else{\\n                    mat[c][i] = -1;\\n                }\\n            }\\n            \\n            // Fill C to F\\n            for(int j = c+1; j <= f ; j++){\\n                \\n                cnt++;\\n                if(head != null){   \\n                    mat[j][rb] = head.val;\\n                    head = head.next;\\n                }else{\\n                    mat[j][rb] = -1;\\n                }\\n            }\\n            \\n            // Fill R to L\\n            if(f != c){\\n                for(int i = rb-1; i >= lb ; i--){\\n                    \\n                    cnt++;\\n                    if(head != null){   \\n                        mat[f][i] = head.val;\\n                        head = head.next;\\n                    }else{\\n                        mat[f][i] = -1;\\n                    }\\n                }\\n            }\\n            \\n            // Fill F to C\\n            if(lb != rb){\\n                for(int j = f-1; j > c ; j--){\\n\\n                    cnt++;\\n                    if(head != null){   \\n                        mat[j][lb] = head.val;\\n                        head = head.next;\\n                    }else{\\n                        mat[j][lb] = -1;\\n                    }\\n                }\\n            }\\n            \\n            // Increment\\n            lb++;\\n            rb--;\\n            c++;\\n            f--;\\n        }\\n        \\n        return mat;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2229888,
                "title": "c-simulation",
                "content": "\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tvector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n\\t\\t\\tvector<vector<int>>res(m,vector<int>(n,-1));\\n\\t\\t\\tint row = 0, col = 0,drow = m-1,dcol = n-1,dir = 1,val = 1;\\n\\t\\t\\twhile(row<=drow and col<=dcol and head){\\n\\t\\t\\t\\tfor(int i = col;i<=dcol and head;i++, head = head->next) res[row][i] = head->val;\\n\\t\\t\\t\\trow++;\\n\\t\\t\\t\\tif(!head) break;\\n\\t\\t\\t\\tfor(int i = row;i<=drow and head;i++,head = head->next) res[i][dcol] = head->val;\\n\\t\\t\\t\\tdcol--;\\n\\t\\t\\t\\tif(!head) break;\\n\\t\\t\\t\\tfor(int i = dcol;i>=col and head;i--,head = head->next) res[drow][i] = head->val;\\n\\t\\t\\t\\tdrow--;\\n\\t\\t\\t\\tif(!head) break;\\n\\t\\t\\t\\tfor(int i = drow;i>=row and head;i--,head = head->next) res[i][col] = head->val;\\n\\t\\t\\t\\tcol++;\\n\\t\\t\\t\\tif(!head) break;\\n\\t\\t\\t}\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tvector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n\\t\\t\\tvector<vector<int>>res(m,vector<int>(n,-1));\\n\\t\\t\\tint row = 0, col = 0,drow = m-1,dcol = n-1,dir = 1,val = 1;\\n\\t\\t\\twhile(row<=drow and col<=dcol and head){\\n\\t\\t\\t\\tfor(int i = col;i<=dcol and head;i++, head = head->next) res[row][i] = head->val;\\n\\t\\t\\t\\trow++;\\n\\t\\t\\t\\tif(!head) break;\\n\\t\\t\\t\\tfor(int i = row;i<=drow and head;i++,head = head->next) res[i][dcol] = head->val;\\n\\t\\t\\t\\tdcol--;\\n\\t\\t\\t\\tif(!head) break;\\n\\t\\t\\t\\tfor(int i = dcol;i>=col and head;i--,head = head->next) res[drow][i] = head->val;\\n\\t\\t\\t\\tdrow--;\\n\\t\\t\\t\\tif(!head) break;\\n\\t\\t\\t\\tfor(int i = drow;i>=row and head;i--,head = head->next) res[i][col] = head->val;\\n\\t\\t\\t\\tcol++;\\n\\t\\t\\t\\tif(!head) break;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2229874,
                "title": "c-easy-solution-similar-to-spiral-matrix-ii",
                "content": "It is exactly similar to the spiral matrix 1 , \\nwe initialize the whole vector by -1 and using the condition temp!=NULL, we traverse the linkedlist\\n```\\nvector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        vector<vector<int>> v( m, vector<int> (n, -1));\\n        \\n        int srow =0;\\n        int scol =0;\\n        int erow = m-1;\\n        int ecol = n-1;\\n        \\n        if( head == NULL) return v;\\n        ListNode* temp = head;\\n        while(temp!= NULL){\\n            for( int index = scol; temp!= NULL && index<=ecol; index++){\\n                v[srow][index]= temp->val;\\n                temp= temp->next;\\n            }\\n            srow++;\\n            for( int index = srow;temp!= NULL && index<=erow; index++){\\n                v[index][ecol]= temp->val;\\n                temp= temp->next;\\n            }\\n            ecol--;\\n            for( int index = ecol; temp!= NULL &&index>=scol; index--){\\n                v[erow][index]= temp->val;\\n                temp= temp->next;\\n            }\\n            erow--;\\n            \\n            for( int index = erow; temp!= NULL && index>=srow; index--){\\n                v[index][scol]= temp->val;\\n                temp= temp->next;\\n            }\\n            scol++;\\n        }\\n        return v;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List",
                    "Matrix"
                ],
                "code": "```\\nvector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        vector<vector<int>> v( m, vector<int> (n, -1));\\n        \\n        int srow =0;\\n        int scol =0;\\n        int erow = m-1;\\n        int ecol = n-1;\\n        \\n        if( head == NULL) return v;\\n        ListNode* temp = head;\\n        while(temp!= NULL){\\n            for( int index = scol; temp!= NULL && index<=ecol; index++){\\n                v[srow][index]= temp->val;\\n                temp= temp->next;\\n            }\\n            srow++;\\n            for( int index = srow;temp!= NULL && index<=erow; index++){\\n                v[index][ecol]= temp->val;\\n                temp= temp->next;\\n            }\\n            ecol--;\\n            for( int index = ecol; temp!= NULL &&index>=scol; index--){\\n                v[erow][index]= temp->val;\\n                temp= temp->next;\\n            }\\n            erow--;\\n            \\n            for( int index = erow; temp!= NULL && index>=srow; index--){\\n                v[index][scol]= temp->val;\\n                temp= temp->next;\\n            }\\n            scol++;\\n        }\\n        return v;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2229851,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int[][] spiralMatrix(int m, int n, ListNode head) {                \\n        int[][] result = new int[m][n];\\n        int rowBegin = 0;\\n        int rowEnd = result.length - 1;\\n        int colBegin = 0;\\n        int colEnd = result[0].length - 1;\\n        int index = 0;\\n        while (rowBegin <= rowEnd && colBegin <= colEnd) {\\n            for (int i = colBegin; i <= colEnd; i++) {\\n                if (head == null) {\\n                    result[rowBegin][i] = -1;\\n                    continue;\\n                }\\n                result[rowBegin][i] = head.val;\\n                head = head.next;\\n            }\\n            rowBegin++;\\n            for (int i = rowBegin; i <= rowEnd; i++) {\\n                if (head == null) {\\n                    result[i][colEnd] = -1;\\n                    continue;\\n                }\\n                result[i][colEnd] = head.val;\\n                head = head.next;\\n            }\\n            colEnd--;\\n            if (rowBegin <= rowEnd) {\\n                for (int i = colEnd; i >= colBegin; i--) {\\n                    if (head == null) {\\n                        result[rowEnd][i] = -1;\\n                        continue;\\n                    }\\n                    result[rowEnd][i] = head.val;\\n                    head = head.next;\\n                }\\n            }\\n            rowEnd--;\\n            if (colBegin <= colEnd) {\\n                for (int i = rowEnd; i >= rowBegin; i--) {\\n                    if (head == null) {\\n                        result[i][colBegin] = -1;\\n                        continue;\\n                    }\\n                    result[i][colBegin] = head.val;\\n                    head = head.next;\\n                }\\n            }\\n            colBegin++;\\n        }\\n        return result;        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] spiralMatrix(int m, int n, ListNode head) {                \\n        int[][] result = new int[m][n];\\n        int rowBegin = 0;\\n        int rowEnd = result.length - 1;\\n        int colBegin = 0;\\n        int colEnd = result[0].length - 1;\\n        int index = 0;\\n        while (rowBegin <= rowEnd && colBegin <= colEnd) {\\n            for (int i = colBegin; i <= colEnd; i++) {\\n                if (head == null) {\\n                    result[rowBegin][i] = -1;\\n                    continue;\\n                }\\n                result[rowBegin][i] = head.val;\\n                head = head.next;\\n            }\\n            rowBegin++;\\n            for (int i = rowBegin; i <= rowEnd; i++) {\\n                if (head == null) {\\n                    result[i][colEnd] = -1;\\n                    continue;\\n                }\\n                result[i][colEnd] = head.val;\\n                head = head.next;\\n            }\\n            colEnd--;\\n            if (rowBegin <= rowEnd) {\\n                for (int i = colEnd; i >= colBegin; i--) {\\n                    if (head == null) {\\n                        result[rowEnd][i] = -1;\\n                        continue;\\n                    }\\n                    result[rowEnd][i] = head.val;\\n                    head = head.next;\\n                }\\n            }\\n            rowEnd--;\\n            if (colBegin <= colEnd) {\\n                for (int i = rowEnd; i >= rowBegin; i--) {\\n                    if (head == null) {\\n                        result[i][colBegin] = -1;\\n                        continue;\\n                    }\\n                    result[i][colBegin] = head.val;\\n                    head = head.next;\\n                }\\n            }\\n            colBegin++;\\n        }\\n        return result;        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2229845,
                "title": "python3-solution-copy-from-spiral-matrix-ii",
                "content": "```\\nclass Solution:\\n    def spiralMatrix(self, m: int, n: int, head: Optional[ListNode]) -> List[List[int]]:\\n        lst = []\\n        while head:\\n            lst.append(head.val)\\n            head = head.next\\n        matrix = [[-1 for _ in range(n)] for _ in range(m)]\\n\\n        x, y, dx, dy = 0, 0, 1, 0\\n        for i in range(len(matrix) * len(matrix[0])):\\n            if i > len(lst) - 1:\\n                break\\n            matrix[y][x] = lst[i]\\n\\n            if not 0 <= x + dx < n:\\n                dx, dy = -dy, dx\\n            elif not 0 <= y + dy < m:\\n                dx, dy = -dy, dx\\n            elif matrix[y + dy][x + dx] != -1:\\n                dx, dy = -dy, dx\\n\\n            x, y = x + dx, y + dy\\n        return matrix\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def spiralMatrix(self, m: int, n: int, head: Optional[ListNode]) -> List[List[int]]:\\n        lst = []\\n        while head:\\n            lst.append(head.val)\\n            head = head.next\\n        matrix = [[-1 for _ in range(n)] for _ in range(m)]\\n\\n        x, y, dx, dy = 0, 0, 1, 0\\n        for i in range(len(matrix) * len(matrix[0])):\\n            if i > len(lst) - 1:\\n                break\\n            matrix[y][x] = lst[i]\\n\\n            if not 0 <= x + dx < n:\\n                dx, dy = -dy, dx\\n            elif not 0 <= y + dy < m:\\n                dx, dy = -dy, dx\\n            elif matrix[y + dy][x + dx] != -1:\\n                dx, dy = -dy, dx\\n\\n            x, y = x + dx, y + dy\\n        return matrix\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2229843,
                "title": "c-simple-grid-traversal",
                "content": "**Explanation**: In the below code these variable stands for\\nrs - starting of row\\nre - ending of row\\ncs - starting of column\\nce - ending of column\\n\\nors - original starting of row\\nore - original ending of row\\nocs - original starting of column\\noce - original ending of column\\n\\n**C++ Code:**\\n\\n```cpp\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        vector<vector<int>> mat(m, vector<int>(n, -1));\\n        \\n        int rs = 0, cs = 0, re = m - 1, ce = n-1;\\n        while(rs <= re)\\n        {\\n            if(head == NULL) break;\\n            int ors =rs, ore = re, ocs = cs, oce = ce;\\n            while(cs <= ce)\\n            {\\n                if(head == NULL) break;\\n                mat[rs][cs] = head->val;\\n                head = head->next;\\n                cs++;\\n            }\\n            cs = ocs;\\n            rs++;\\n            while(rs <= re)\\n            {\\n                if(head == NULL) break;\\n                mat[rs][ce] = head->val;\\n                head = head->next;\\n                rs++;\\n            }\\n            rs = ors;\\n            ce--;\\n            while(cs <= ce)\\n            {\\n                if(head == NULL) break;\\n                mat[re][ce] = head->val;\\n                head = head->next;\\n                ce--;\\n            }\\n            ce = oce;\\n            re--;\\n            while(rs < re)\\n            {\\n                if(head == NULL) break;\\n                mat[re][cs] = head->val;\\n                head = head->next;\\n                re--;\\n            }\\n            \\n            rs = ors, re = ore, cs = ocs, ce = oce;\\n            rs++; re--;\\n            cs++; ce--;\\n        }\\n        \\n        return mat;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Linked List",
                    "Matrix"
                ],
                "code": "```cpp\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        vector<vector<int>> mat(m, vector<int>(n, -1));\\n        \\n        int rs = 0, cs = 0, re = m - 1, ce = n-1;\\n        while(rs <= re)\\n        {\\n            if(head == NULL) break;\\n            int ors =rs, ore = re, ocs = cs, oce = ce;\\n            while(cs <= ce)\\n            {\\n                if(head == NULL) break;\\n                mat[rs][cs] = head->val;\\n                head = head->next;\\n                cs++;\\n            }\\n            cs = ocs;\\n            rs++;\\n            while(rs <= re)\\n            {\\n                if(head == NULL) break;\\n                mat[rs][ce] = head->val;\\n                head = head->next;\\n                rs++;\\n            }\\n            rs = ors;\\n            ce--;\\n            while(cs <= ce)\\n            {\\n                if(head == NULL) break;\\n                mat[re][ce] = head->val;\\n                head = head->next;\\n                ce--;\\n            }\\n            ce = oce;\\n            re--;\\n            while(rs < re)\\n            {\\n                if(head == NULL) break;\\n                mat[re][cs] = head->val;\\n                head = head->next;\\n                re--;\\n            }\\n            \\n            rs = ors, re = ore, cs = ocs, ce = oce;\\n            rs++; re--;\\n            cs++; ce--;\\n        }\\n        \\n        return mat;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4086964,
                "title": "optimized-spiral-walk",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Example:\\n * var li = ListNode(5)\\n * var v = li.`val`\\n * Definition for singly-linked list.\\n * class ListNode(var `val`: Int) {\\n *     var next: ListNode? = null\\n * }\\n */\\nclass Solution {\\n    fun spiralMatrix(m: Int, n: Int, head: ListNode?): Array<IntArray> {\\n        var matrix = Array<IntArray>(m){IntArray(n){-1}}\\n        head ?: return matrix\\n        var R = arrayOf(0,1,0,-1)\\n        var C = arrayOf(1,0,-1,0)\\n        var (row,col,dr,dc,i) = listOf(0,0,0,0,1)\\n        var size = m*n\\n        var curr = head \\n        while(i++ <= size){\\n            matrix[row][col] = curr!!.`val`\\n            curr = curr?.next\\n            if(curr == null) break\\n            var r = Math.floorMod(row+R[dr],m)\\n            var c = Math.floorMod(col+C[dc],n)\\n            if(matrix[r][c] != -1){\\n                dr = (dr+1) % 4\\n                dc = (dc+1) % 4\\n            }\\n            row += R[dr]\\n            col += C[dc]\\n        }\\n        return matrix\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\n/**\\n * Example:\\n * var li = ListNode(5)\\n * var v = li.`val`\\n * Definition for singly-linked list.\\n * class ListNode(var `val`: Int) {\\n *     var next: ListNode? = null\\n * }\\n */\\nclass Solution {\\n    fun spiralMatrix(m: Int, n: Int, head: ListNode?): Array<IntArray> {\\n        var matrix = Array<IntArray>(m){IntArray(n){-1}}\\n        head ?: return matrix\\n        var R = arrayOf(0,1,0,-1)\\n        var C = arrayOf(1,0,-1,0)\\n        var (row,col,dr,dc,i) = listOf(0,0,0,0,1)\\n        var size = m*n\\n        var curr = head \\n        while(i++ <= size){\\n            matrix[row][col] = curr!!.`val`\\n            curr = curr?.next\\n            if(curr == null) break\\n            var r = Math.floorMod(row+R[dr],m)\\n            var c = Math.floorMod(col+C[dc],n)\\n            if(matrix[r][c] != -1){\\n                dr = (dr+1) % 4\\n                dc = (dc+1) % 4\\n            }\\n            row += R[dr]\\n            col += C[dc]\\n        }\\n        return matrix\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4086956,
                "title": "cleanest-spiral-walk",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Example:\\n * var li = ListNode(5)\\n * var v = li.`val`\\n * Definition for singly-linked list.\\n * class ListNode(var `val`: Int) {\\n *     var next: ListNode? = null\\n * }\\n */\\nclass Solution {\\n    fun spiralMatrix(m: Int, n: Int, head: ListNode?): Array<IntArray> {\\n        var matrix = Array<IntArray>(m){IntArray(n){-1}}\\n        head ?: return matrix\\n        var R = arrayOf(0,1,0,-1)\\n        var C = arrayOf(1,0,-1,0)\\n        var (row,col,dr,dc,i) = listOf(0,0,0,0,1)\\n        var size = m*n\\n        var visited = Array<BooleanArray>(m){BooleanArray(n)}\\n        var curr = head \\n        while(i++ <= size){\\n            matrix[row][col] = curr!!.`val`\\n            curr = curr?.next\\n            if(curr == null) break\\n            visited[row][col] = true\\n            var r = Math.floorMod(row+R[dr],m)\\n            var c = Math.floorMod(col+C[dc],n)\\n            if(visited[r][c]){\\n                dr = (dr+1) % 4\\n                dc = (dc+1) % 4\\n            }\\n            row += R[dr]\\n            col += C[dc]\\n        }\\n        return matrix\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\n/**\\n * Example:\\n * var li = ListNode(5)\\n * var v = li.`val`\\n * Definition for singly-linked list.\\n * class ListNode(var `val`: Int) {\\n *     var next: ListNode? = null\\n * }\\n */\\nclass Solution {\\n    fun spiralMatrix(m: Int, n: Int, head: ListNode?): Array<IntArray> {\\n        var matrix = Array<IntArray>(m){IntArray(n){-1}}\\n        head ?: return matrix\\n        var R = arrayOf(0,1,0,-1)\\n        var C = arrayOf(1,0,-1,0)\\n        var (row,col,dr,dc,i) = listOf(0,0,0,0,1)\\n        var size = m*n\\n        var visited = Array<BooleanArray>(m){BooleanArray(n)}\\n        var curr = head \\n        while(i++ <= size){\\n            matrix[row][col] = curr!!.`val`\\n            curr = curr?.next\\n            if(curr == null) break\\n            visited[row][col] = true\\n            var r = Math.floorMod(row+R[dr],m)\\n            var c = Math.floorMod(col+C[dc],n)\\n            if(visited[r][c]){\\n                dr = (dr+1) % 4\\n                dc = (dc+1) % 4\\n            }\\n            row += R[dr]\\n            col += C[dc]\\n        }\\n        return matrix\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4076929,
                "title": "java-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public int[][] spiralMatrix(int m, int n, ListNode head) {\\n        int [][]arr=new int[m][n];\\n        int startrow=0;\\n        int endrow=m-1;\\n        int startcol=0;\\n        int endcol=n-1;\\n        while(startrow<=endrow && startcol<=endcol)\\n        {\\n            // for top\\n            for(int i=startcol;i<=endcol;i++)\\n            {\\n                if(head!=null)\\n                {\\n                    arr[startrow][i]=head.val;\\n                    head=head.next;\\n                }\\n                else\\n                {\\n                    arr[startrow][i]=-1;\\n                }\\n            }\\n            // for right\\n            for(int i=startrow+1;i<=endrow;i++)\\n            {\\n                if(head!=null)\\n                {\\n                    arr[i][endcol]=head.val;\\n                    head=head.next;\\n                }\\n                else\\n                {\\n                    arr[i][endcol]=-1;\\n                }\\n            }\\n            // for bottom\\n            for(int i=endcol-1;i>=startcol;i--)\\n            {\\n                if(startrow==endrow)\\n                {\\n                    break;\\n                }\\n                if(head!=null)\\n                {\\n                    arr[endrow][i]=head.val;\\n                    head=head.next;\\n                }\\n                else\\n                {\\n                    arr[endrow][i]=-1;\\n                }\\n                \\n            }\\n            // for left\\n            for(int i=endrow-1;i>=startrow+1;i--)\\n            {\\n                if(startcol==endcol)\\n                {\\n                    break;\\n                }\\n                if(head!=null)\\n                {\\n                    arr[i][startcol]=head.val;\\n                    head=head.next;\\n                }\\n                else\\n                {\\n                    arr[i][startcol]=-1;\\n                }\\n                \\n            }\\n            startrow++;\\n            startcol++;\\n            endrow--;\\n            endcol--;\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public int[][] spiralMatrix(int m, int n, ListNode head) {\\n        int [][]arr=new int[m][n];\\n        int startrow=0;\\n        int endrow=m-1;\\n        int startcol=0;\\n        int endcol=n-1;\\n        while(startrow<=endrow && startcol<=endcol)\\n        {\\n            // for top\\n            for(int i=startcol;i<=endcol;i++)\\n            {\\n                if(head!=null)\\n                {\\n                    arr[startrow][i]=head.val;\\n                    head=head.next;\\n                }\\n                else\\n                {\\n                    arr[startrow][i]=-1;\\n                }\\n            }\\n            // for right\\n            for(int i=startrow+1;i<=endrow;i++)\\n            {\\n                if(head!=null)\\n                {\\n                    arr[i][endcol]=head.val;\\n                    head=head.next;\\n                }\\n                else\\n                {\\n                    arr[i][endcol]=-1;\\n                }\\n            }\\n            // for bottom\\n            for(int i=endcol-1;i>=startcol;i--)\\n            {\\n                if(startrow==endrow)\\n                {\\n                    break;\\n                }\\n                if(head!=null)\\n                {\\n                    arr[endrow][i]=head.val;\\n                    head=head.next;\\n                }\\n                else\\n                {\\n                    arr[endrow][i]=-1;\\n                }\\n                \\n            }\\n            // for left\\n            for(int i=endrow-1;i>=startrow+1;i--)\\n            {\\n                if(startcol==endcol)\\n                {\\n                    break;\\n                }\\n                if(head!=null)\\n                {\\n                    arr[i][startcol]=head.val;\\n                    head=head.next;\\n                }\\n                else\\n                {\\n                    arr[i][startcol]=-1;\\n                }\\n                \\n            }\\n            startrow++;\\n            startcol++;\\n            endrow--;\\n            endcol--;\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4076173,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public int[][] spiralMatrix(int m, int n, ListNode head) {\\n        int [][] arr=new int [m][n];ListNode temp=head;\\n       \\n       int top=0,left=0,right=n-1,bottom=m-1;\\n          int arr1[]=new int[m*n];\\n        for(int in=0;in<arr1.length;in++){\\n            arr1[in]=-1;\\n        }\\n       int in=0;\\n        while(head!=null){\\n            arr1[in]=head.val;\\n            in++;\\n            head=head.next;\\n        }\\nint c=0;\\n       while(left<=right && bottom >=top){\\n\\n        for(int i=left;i<=right;i++){\\n           arr[top][i]=arr1[c];\\n           c++;\\n       }\\n       top++;\\n       for(int i=top;i<=bottom;i++){\\n           arr[i][right]=arr1[c];\\n           c++;\\n       }\\n       right--;\\n       if(top<=bottom){\\n       for(int i=right;i>=left;i--){\\n           arr[bottom][i]=arr1[c];\\n          c++;\\n       }\\n       bottom--;}\\n       if(left<=right){\\n       for(int i=bottom;i>=top;i--){\\n           arr[i][left]=arr1[c];\\n           c++;\\n       }\\n       left++;\\n       }}\\n\\n       \\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public int[][] spiralMatrix(int m, int n, ListNode head) {\\n        int [][] arr=new int [m][n];ListNode temp=head;\\n       \\n       int top=0,left=0,right=n-1,bottom=m-1;\\n          int arr1[]=new int[m*n];\\n        for(int in=0;in<arr1.length;in++){\\n            arr1[in]=-1;\\n        }\\n       int in=0;\\n        while(head!=null){\\n            arr1[in]=head.val;\\n            in++;\\n            head=head.next;\\n        }\\nint c=0;\\n       while(left<=right && bottom >=top){\\n\\n        for(int i=left;i<=right;i++){\\n           arr[top][i]=arr1[c];\\n           c++;\\n       }\\n       top++;\\n       for(int i=top;i<=bottom;i++){\\n           arr[i][right]=arr1[c];\\n           c++;\\n       }\\n       right--;\\n       if(top<=bottom){\\n       for(int i=right;i>=left;i--){\\n           arr[bottom][i]=arr1[c];\\n          c++;\\n       }\\n       bottom--;}\\n       if(left<=right){\\n       for(int i=bottom;i>=top;i--){\\n           arr[i][left]=arr1[c];\\n           c++;\\n       }\\n       left++;\\n       }}\\n\\n       \\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4056465,
                "title": "c-solution",
                "content": "\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        vector<vector<int>>ans(m,vector<int>(n,-1));\\n        ListNode* temp=head;\\n        int rowstart=0;\\n        int rowend=m-1;\\n        int colstart=0;\\n        int colend=n-1;\\n\\n        while(temp){\\n            for(int col=colstart;col<=colend && temp;col++){\\n                ans[rowstart][col]=temp->val;\\n                temp=temp->next;\\n            }\\n            rowstart++;\\n            for(int row=rowstart;row<=rowend && temp;row++){\\n                ans[row][colend]=temp->val;\\n                temp=temp->next;\\n            }\\n            colend--;\\n            for(int col=colend;col>=colstart && temp;col--){\\n                ans[rowend][col]=temp->val;\\n                temp=temp->next;\\n            }\\n            rowend--;\\n            for(int row=rowend;row>=rowstart && temp;row--){\\n                ans[row][colstart]=temp->val;\\n                temp=temp->next;\\n            }\\n            colstart++;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        vector<vector<int>>ans(m,vector<int>(n,-1));\\n        ListNode* temp=head;\\n        int rowstart=0;\\n        int rowend=m-1;\\n        int colstart=0;\\n        int colend=n-1;\\n\\n        while(temp){\\n            for(int col=colstart;col<=colend && temp;col++){\\n                ans[rowstart][col]=temp->val;\\n                temp=temp->next;\\n            }\\n            rowstart++;\\n            for(int row=rowstart;row<=rowend && temp;row++){\\n                ans[row][colend]=temp->val;\\n                temp=temp->next;\\n            }\\n            colend--;\\n            for(int col=colend;col>=colstart && temp;col--){\\n                ans[rowend][col]=temp->val;\\n                temp=temp->next;\\n            }\\n            rowend--;\\n            for(int row=rowend;row>=rowstart && temp;row--){\\n                ans[row][colstart]=temp->val;\\n                temp=temp->next;\\n            }\\n            colstart++;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4032264,
                "title": "c-easy-to-understand-solution-similar-to-spiral-matrix-1-and-2",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        vector<vector<int> >ans(m,vector<int>(n,-1));\\n        int lowr=0,lowc=0;\\n        int highr=m-1;\\n        int highc=n-1;\\n        ListNode*temp=head;\\n        while(lowr<=highr && lowc<=highc){\\n            for(int j=lowc;j<=highc;j++){\\n                if(temp==nullptr) return ans;\\n                ans[lowr][j]=temp->val;\\n                temp=temp->next;\\n            }\\n            lowr++;\\n            for(int i=lowr;i<=highr;i++){\\n                if(temp==nullptr) return ans;\\n                ans[i][highc]=temp->val;\\n                temp=temp->next;\\n            }\\n            highc--;\\n            for(int j=highc;j>=lowc;j--){\\n                if(temp==nullptr) return ans;\\n                ans[highr][j]=temp->val;\\n                temp=temp->next;\\n            }\\n            highr--;\\n            for(int i=highr;i>=lowr;i--){\\n                if(temp==nullptr) return ans;\\n                ans[i][lowc]=temp->val;\\n                temp=temp->next;\\n            }\\n            lowc++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        vector<vector<int> >ans(m,vector<int>(n,-1));\\n        int lowr=0,lowc=0;\\n        int highr=m-1;\\n        int highc=n-1;\\n        ListNode*temp=head;\\n        while(lowr<=highr && lowc<=highc){\\n            for(int j=lowc;j<=highc;j++){\\n                if(temp==nullptr) return ans;\\n                ans[lowr][j]=temp->val;\\n                temp=temp->next;\\n            }\\n            lowr++;\\n            for(int i=lowr;i<=highr;i++){\\n                if(temp==nullptr) return ans;\\n                ans[i][highc]=temp->val;\\n                temp=temp->next;\\n            }\\n            highc--;\\n            for(int j=highc;j>=lowc;j--){\\n                if(temp==nullptr) return ans;\\n                ans[highr][j]=temp->val;\\n                temp=temp->next;\\n            }\\n            highr--;\\n            for(int i=highr;i>=lowr;i--){\\n                if(temp==nullptr) return ans;\\n                ans[i][lowc]=temp->val;\\n                temp=temp->next;\\n            }\\n            lowc++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4020062,
                "title": "easy-to-understand-and-simple-solution-must-check-it",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        int minr =0;\\n        int minc =0;\\n        int maxr =m-1;\\n        int maxc =n-1;\\n        int tn =m*n;\\n        int count=0;\\n        vector<vector<int>> ans(m,vector<int>(n));\\n        while(count<tn){\\n\\n            //upper wall.........\\n            for(int i=minc; i<=maxc && count<tn; i++){\\n                if(head!=NULL){\\n                ans[minr][i]= head->val;\\n                head=head->next;\\n                }\\n                else{ans[minr][i]= -1;}\\n                count++;\\n            }\\n            minr++;\\n\\n            //right wall..........\\n            for(int i=minr; i<=maxr && count<tn; i++){\\n                if(head!=NULL){\\n                ans[i][maxc]=head->val;\\n                head=head->next;\\n                }\\n                else{ans[i][maxc]=-1;}\\n                count++;\\n            }\\n            maxc--;\\n\\n            //bottom wall..........\\n            for(int i=maxc; i>=minc && count<tn; i--){\\n                if(head!=NULL){\\n                ans[maxr][i]=head->val;\\n                head=head->next;\\n                }\\n                else{ans[maxr][i]=-1;}\\n                count++;\\n            }\\n            maxr--;\\n            \\n            //left wall...........\\n            for(int i=maxr; i>=minr && count<tn; i--){\\n                if(head!=NULL){\\n                ans[i][minc]=head->val;\\n                head=head->next;\\n                }\\n                else{ans[i][minc]=-1;}\\n                count++;\\n            }\\n            minc++;\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        int minr =0;\\n        int minc =0;\\n        int maxr =m-1;\\n        int maxc =n-1;\\n        int tn =m*n;\\n        int count=0;\\n        vector<vector<int>> ans(m,vector<int>(n));\\n        while(count<tn){\\n\\n            //upper wall.........\\n            for(int i=minc; i<=maxc && count<tn; i++){\\n                if(head!=NULL){\\n                ans[minr][i]= head->val;\\n                head=head->next;\\n                }\\n                else{ans[minr][i]= -1;}\\n                count++;\\n            }\\n            minr++;\\n\\n            //right wall..........\\n            for(int i=minr; i<=maxr && count<tn; i++){\\n                if(head!=NULL){\\n                ans[i][maxc]=head->val;\\n                head=head->next;\\n                }\\n                else{ans[i][maxc]=-1;}\\n                count++;\\n            }\\n            maxc--;\\n\\n            //bottom wall..........\\n            for(int i=maxc; i>=minc && count<tn; i--){\\n                if(head!=NULL){\\n                ans[maxr][i]=head->val;\\n                head=head->next;\\n                }\\n                else{ans[maxr][i]=-1;}\\n                count++;\\n            }\\n            maxr--;\\n            \\n            //left wall...........\\n            for(int i=maxr; i>=minr && count<tn; i--){\\n                if(head!=NULL){\\n                ans[i][minc]=head->val;\\n                head=head->next;\\n                }\\n                else{ans[i][minc]=-1;}\\n                count++;\\n            }\\n            minc++;\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4019990,
                "title": "shortest-code-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n  O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int v[4][4]={{0,1},{1,0},{0,-1},{-1,0}};\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        vector<vector<int>>ans(m,vector<int>(n,-1));\\n        int i=0,j=0;int k=0;\\n        while(head!=NULL){\\n           ans[i][j]=head->val;\\n           head=head->next;\\n           if(i+v[k][0]==m || j+v[k][1] == n || i+v[k][0]<0 || j+v[k][1]<0 || ans[i+v[k][0]][j+v[k][1]]!=-1)k++;\\n           k%=4;\\n           i+=v[k][0];\\n           j+=v[k][1];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int v[4][4]={{0,1},{1,0},{0,-1},{-1,0}};\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        vector<vector<int>>ans(m,vector<int>(n,-1));\\n        int i=0,j=0;int k=0;\\n        while(head!=NULL){\\n           ans[i][j]=head->val;\\n           head=head->next;\\n           if(i+v[k][0]==m || j+v[k][1] == n || i+v[k][0]<0 || j+v[k][1]<0 || ans[i+v[k][0]][j+v[k][1]]!=-1)k++;\\n           k%=4;\\n           i+=v[k][0];\\n           j+=v[k][1];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4005381,
                "title": "in-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1) i first though of directly solving using mat[][]=temp.val, temp=temp.next. \\n2) we store the values of linkedlist in an array, so that we directly assign the matrix value with arr value.\\n3) we run the logic of spiral matrix 1, here with 4 pointers runing until the matrix complete\\'s.\\n4) we keep assigning the value of matrix element to the array element and keep traversing until simultaneously the matrix and array is filled.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public int[][] spiralMatrix(int m, int n, ListNode head) {\\n        int[][] mat = new int[m][n];\\n        int rowStart = 0;\\n        int rowEnd = m - 1;\\n        int colStart = 0;\\n        int colEnd = n - 1;\\n        //ListNode temp = head;\\n        int arr[]=new int[m*n];\\n        for(int in=0;in<arr.length;in++){\\n            arr[in]=-1;\\n        }\\n       int in=0;\\n        while(head!=null){\\n            arr[in]=head.val;\\n            in++;\\n            head=head.next;\\n        }\\nint c=0;\\n        while (rowStart <= rowEnd && colStart <= colEnd) {\\n            // Traverse right\\n            for (int j = colStart; j <= colEnd; j++) {\\n                    mat[rowStart][j] = arr[c];\\n                    c++;\\n                }\\n            \\n            rowStart++;\\n\\n            // Traverse down\\n            for (int i = rowStart; i <= rowEnd; i++) {\\n              \\n                    mat[i][colEnd] = arr[c];\\n                    c++;\\n                \\n            }\\n            colEnd--;\\n\\n            // Traverse left\\n            if (rowStart <= rowEnd) {\\n                for (int j = colEnd; j >= colStart; j--) {\\n                  \\n                        mat[rowEnd][j] = arr[c];\\n                        c++;\\n                    \\n                }\\n                rowEnd--;\\n            }\\n\\n            // Traverse up\\n            if (colStart <= colEnd) {\\n                for (int i = rowEnd; i >= rowStart; i--) {\\n                    \\n                        mat[i][colStart] = arr[c];\\n                        c++;\\n                    \\n                }\\n                colStart++;\\n            }\\n        }\\n\\n        return mat;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public int[][] spiralMatrix(int m, int n, ListNode head) {\\n        int[][] mat = new int[m][n];\\n        int rowStart = 0;\\n        int rowEnd = m - 1;\\n        int colStart = 0;\\n        int colEnd = n - 1;\\n        //ListNode temp = head;\\n        int arr[]=new int[m*n];\\n        for(int in=0;in<arr.length;in++){\\n            arr[in]=-1;\\n        }\\n       int in=0;\\n        while(head!=null){\\n            arr[in]=head.val;\\n            in++;\\n            head=head.next;\\n        }\\nint c=0;\\n        while (rowStart <= rowEnd && colStart <= colEnd) {\\n            // Traverse right\\n            for (int j = colStart; j <= colEnd; j++) {\\n                    mat[rowStart][j] = arr[c];\\n                    c++;\\n                }\\n            \\n            rowStart++;\\n\\n            // Traverse down\\n            for (int i = rowStart; i <= rowEnd; i++) {\\n              \\n                    mat[i][colEnd] = arr[c];\\n                    c++;\\n                \\n            }\\n            colEnd--;\\n\\n            // Traverse left\\n            if (rowStart <= rowEnd) {\\n                for (int j = colEnd; j >= colStart; j--) {\\n                  \\n                        mat[rowEnd][j] = arr[c];\\n                        c++;\\n                    \\n                }\\n                rowEnd--;\\n            }\\n\\n            // Traverse up\\n            if (colStart <= colEnd) {\\n                for (int i = rowEnd; i >= rowStart; i--) {\\n                    \\n                        mat[i][colStart] = arr[c];\\n                        c++;\\n                    \\n                }\\n                colStart++;\\n            }\\n        }\\n\\n        return mat;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3998741,
                "title": "beats-98-63-solutions-java-c-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMake use of direction up, down, left, right. To direct the flow of matrix\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Java Code \\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public int[][] spiralMatrix(int m, int n, ListNode head) {\\n        int[][] matrix = new int[m][n];\\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++) matrix[i][j] = -1;\\n        }\\n        int top = 0;\\n        int left = 0;\\n        int right = n - 1;\\n        int down = m - 1;\\n        int direction = 0;\\n        while(head != null){\\n            if(direction == 0){\\n                for(int i = left; i <= right && head != null; i++){\\n                    matrix[top][i] = head.val;\\n                    head = head.next;\\n                }\\n                top++;\\n                direction++;\\n            } else if (direction == 1){\\n                for(int j = top; j <= down && head != null; j++){\\n                    matrix[j][right] = head.val;\\n                    head = head.next;\\n                }\\n                right--;\\n                direction++;\\n            } else if(direction == 2){\\n                for(int i = right; i >= left && head != null; i--){\\n                    matrix[down][i] = head.val;\\n                    head = head.next;\\n                }\\n                down--;\\n                direction++;\\n            } else {\\n                for(int i = down; i >= top && head != null; i--){\\n                    matrix[i][left] = head.val;\\n                    head = head.next;\\n                }\\n                left++;\\n                direction = 0;\\n            }\\n        }\\n        return matrix;\\n    }\\n}\\n```\\n\\n# C++ Code \\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int n, int m, ListNode* head) {\\n        vector<vector<int>> ans(n, vector<int> (m, -1));\\n        ListNode* tmp = head;\\n        int t = 0, s = 0;\\n        int b = n-1, a = m-1;\\n        while(1)\\n        {\\n            for(int i=s;i<=a;i++)\\n            {\\n                ans[t][i] = tmp->val;\\n                tmp = tmp->next;\\n                if(tmp == NULL)\\n                    break;\\n            }\\n            t++;\\n            if(tmp == NULL)\\n                break;\\n            \\n            for(int i = t;i<=b;i++)\\n            {\\n                ans[i][a] = tmp->val;\\n                tmp = tmp->next;\\n                if(tmp == NULL)\\n                    break;\\n            }\\n            a--;\\n            if(tmp == NULL)\\n                break;\\n            \\n            for(int i = a;i>=s;i--)\\n            {\\n                ans[b][i] = tmp->val;\\n                tmp = tmp->next;\\n                if(tmp == NULL)\\n                    break;\\n            }\\n            b--;\\n            if(tmp == NULL)\\n                break;\\n            \\n            for(int i = b;i>=t;i--)\\n            {\\n                ans[i][s] = tmp->val;\\n                tmp = tmp->next;\\n                if(tmp == NULL)\\n                    break;\\n            }\\n            s++;\\n            if(tmp == NULL)\\n                break;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n# Python Code\\n```\\n\\nclass Solution:\\n    def spiralMatrix(self, m: int, n: int, head: Optional[ListNode]) -> List[List[int]]:\\n        result = [ [-1] * n for _ in range(m) ]\\n        node = head\\n        \\n        \\n        \\n        UP = 2\\n        DOWN = 3\\n        LEFT = 1\\n        RIGHT = 0\\n        \\n        directions = ( (0,1), (0,-1), (-1,0), (1,0))\\n        direction = RIGHT\\n        \\n        uB, dB, lB, rB = 0, m-1, 0, n-1\\n        row, col = 0, 0\\n\\n        while node:\\n            result[row][col] = node.val \\n            node = node.next \\n\\n            if direction == RIGHT and col == rB and row != dB:\\n                direction = DOWN\\n                uB += 1\\n            \\n\\n            if direction == DOWN and col == rB and row == dB:\\n                direction = LEFT\\n                rB -= 1\\n                \\n            if direction == LEFT and col == lB and row != uB:\\n                direction = UP\\n                dB -= 1\\n                \\n            if direction == UP and col == lB and row == uB:\\n                direction = RIGHT\\n                lB += 1\\n            \\n            dr,dc = directions[direction]\\n            row,col = row+dr, col+dc\\n\\n        return result\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public int[][] spiralMatrix(int m, int n, ListNode head) {\\n        int[][] matrix = new int[m][n];\\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++) matrix[i][j] = -1;\\n        }\\n        int top = 0;\\n        int left = 0;\\n        int right = n - 1;\\n        int down = m - 1;\\n        int direction = 0;\\n        while(head != null){\\n            if(direction == 0){\\n                for(int i = left; i <= right && head != null; i++){\\n                    matrix[top][i] = head.val;\\n                    head = head.next;\\n                }\\n                top++;\\n                direction++;\\n            } else if (direction == 1){\\n                for(int j = top; j <= down && head != null; j++){\\n                    matrix[j][right] = head.val;\\n                    head = head.next;\\n                }\\n                right--;\\n                direction++;\\n            } else if(direction == 2){\\n                for(int i = right; i >= left && head != null; i--){\\n                    matrix[down][i] = head.val;\\n                    head = head.next;\\n                }\\n                down--;\\n                direction++;\\n            } else {\\n                for(int i = down; i >= top && head != null; i--){\\n                    matrix[i][left] = head.val;\\n                    head = head.next;\\n                }\\n                left++;\\n                direction = 0;\\n            }\\n        }\\n        return matrix;\\n    }\\n}\\n```\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int n, int m, ListNode* head) {\\n        vector<vector<int>> ans(n, vector<int> (m, -1));\\n        ListNode* tmp = head;\\n        int t = 0, s = 0;\\n        int b = n-1, a = m-1;\\n        while(1)\\n        {\\n            for(int i=s;i<=a;i++)\\n            {\\n                ans[t][i] = tmp->val;\\n                tmp = tmp->next;\\n                if(tmp == NULL)\\n                    break;\\n            }\\n            t++;\\n            if(tmp == NULL)\\n                break;\\n            \\n            for(int i = t;i<=b;i++)\\n            {\\n                ans[i][a] = tmp->val;\\n                tmp = tmp->next;\\n                if(tmp == NULL)\\n                    break;\\n            }\\n            a--;\\n            if(tmp == NULL)\\n                break;\\n            \\n            for(int i = a;i>=s;i--)\\n            {\\n                ans[b][i] = tmp->val;\\n                tmp = tmp->next;\\n                if(tmp == NULL)\\n                    break;\\n            }\\n            b--;\\n            if(tmp == NULL)\\n                break;\\n            \\n            for(int i = b;i>=t;i--)\\n            {\\n                ans[i][s] = tmp->val;\\n                tmp = tmp->next;\\n                if(tmp == NULL)\\n                    break;\\n            }\\n            s++;\\n            if(tmp == NULL)\\n                break;\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\n\\nclass Solution:\\n    def spiralMatrix(self, m: int, n: int, head: Optional[ListNode]) -> List[List[int]]:\\n        result = [ [-1] * n for _ in range(m) ]\\n        node = head\\n        \\n        \\n        \\n        UP = 2\\n        DOWN = 3\\n        LEFT = 1\\n        RIGHT = 0\\n        \\n        directions = ( (0,1), (0,-1), (-1,0), (1,0))\\n        direction = RIGHT\\n        \\n        uB, dB, lB, rB = 0, m-1, 0, n-1\\n        row, col = 0, 0\\n\\n        while node:\\n            result[row][col] = node.val \\n            node = node.next \\n\\n            if direction == RIGHT and col == rB and row != dB:\\n                direction = DOWN\\n                uB += 1\\n            \\n\\n            if direction == DOWN and col == rB and row == dB:\\n                direction = LEFT\\n                rB -= 1\\n                \\n            if direction == LEFT and col == lB and row != uB:\\n                direction = UP\\n                dB -= 1\\n                \\n            if direction == UP and col == lB and row == uB:\\n                direction = RIGHT\\n                lB += 1\\n            \\n            dr,dc = directions[direction]\\n            row,col = row+dr, col+dc\\n\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3996260,
                "title": "2326-spiral-matrix-iv-c-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n     vector<vector<int>> ans (m,vector<int>(n,-1));\\n        int startrow=0;\\n        int endrow=m-1;\\n        int startcol=0;\\n        int endcol=n-1;\\n \\n        while(head!=NULL)\\n        {\\n            for(int i=startcol;i<=endcol&&head!=NULL;i++)\\n            {\\n                ans[startrow][i]=head->val;\\n                head=head->next;\\n            }\\n            startrow++;\\n            for(int i=startrow;i<=endrow&&head!=NULL;i++)\\n            {\\n                ans[i][endcol]=head->val;\\n                head=head->next;\\n            }\\n            endcol--;\\n             for(int i=endcol;i>=startcol&&head!=NULL;i--)\\n            {\\n                ans[endrow][i]=head->val;\\n                head=head->next;\\n            }\\n            endrow--;\\n             for(int i=endrow;i>=startrow&&head!=NULL;i--)\\n            {\\n                ans[i][startcol]=head->val;\\n                head=head->next;\\n            }\\n            startcol++;\\n\\n        }\\n        return ans;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n     vector<vector<int>> ans (m,vector<int>(n,-1));\\n        int startrow=0;\\n        int endrow=m-1;\\n        int startcol=0;\\n        int endcol=n-1;\\n \\n        while(head!=NULL)\\n        {\\n            for(int i=startcol;i<=endcol&&head!=NULL;i++)\\n            {\\n                ans[startrow][i]=head->val;\\n                head=head->next;\\n            }\\n            startrow++;\\n            for(int i=startrow;i<=endrow&&head!=NULL;i++)\\n            {\\n                ans[i][endcol]=head->val;\\n                head=head->next;\\n            }\\n            endcol--;\\n             for(int i=endcol;i>=startcol&&head!=NULL;i--)\\n            {\\n                ans[endrow][i]=head->val;\\n                head=head->next;\\n            }\\n            endrow--;\\n             for(int i=endrow;i>=startrow&&head!=NULL;i--)\\n            {\\n                ans[i][startcol]=head->val;\\n                head=head->next;\\n            }\\n            startcol++;\\n\\n        }\\n        return ans;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3993613,
                "title": "spiral-matrix-iv-my-simple-java-solution",
                "content": "\\n\\t\\t\\tclass Solution {\\n\\t\\t\\t\\t\\tpublic int[][] spiralMatrix(int m, int n, ListNode head) {\\n\\t\\t\\t\\t\\tint res[][] = new int[m][n];\\n\\t\\t\\t\\t\\tfor(int i = 0; i < m; i++){\\n\\t\\t\\t\\t\\t\\tfor(int j = 0; j < n; j++){\\n\\t\\t\\t\\t\\t\\t\\tres[i][j] = -1;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif(head == null)    return res;\\n\\t\\t\\t\\t\\tint rowStart = 0;\\n\\t\\t\\t\\t\\tint colStart = 0; \\n\\t\\t\\t\\t\\tint rowEnd = m-1;\\n\\t\\t\\t\\t\\tint colEnd = n-1;\\n\\n\\t\\t\\tListNode currNode = head;\\n\\t\\t\\twhile(rowStart <= rowEnd && colStart <= colEnd && currNode != null){\\n\\t\\t\\t\\tfor(int i = colStart; i<= colEnd && currNode != null; i++){\\n\\t\\t\\t\\t\\tres[rowStart][i] = currNode.val;\\n\\t\\t\\t\\t\\tcurrNode = currNode.next;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\trowStart++;\\n\\n\\t\\t\\t\\tfor(int i = rowStart; i<= rowEnd && currNode != null; i++){\\n\\t\\t\\t\\t\\tres[i][colEnd] = currNode.val;\\n\\t\\t\\t\\t\\tcurrNode = currNode.next;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tcolEnd--;\\n\\n\\t\\t\\t\\tif(rowStart <= rowEnd){\\n\\t\\t\\t\\t\\tfor(int i = colEnd; i>=colStart && currNode != null; i--){\\n\\t\\t\\t\\t\\t\\tres[rowEnd][i] = currNode.val;\\n\\t\\t\\t\\t\\t\\tcurrNode = currNode.next;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\trowEnd--;    \\n\\n\\t\\t\\t\\tif(colStart <= colEnd){\\n\\t\\t\\t\\t\\tfor(int i = rowEnd; (i>=rowStart && currNode != null); i--){\\n\\t\\t\\t\\t\\t\\tres[i][colStart] = currNode.val;\\n\\t\\t\\t\\t\\t\\tcurrNode = currNode.next;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tcolStart++;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\t}",
                "solutionTags": [
                    "Linked List"
                ],
                "code": "class Solution {\\n\\t\\t\\t\\t\\tpublic int[][] spiralMatrix(int m, int n, ListNode head) {\\n\\t\\t\\t\\t\\tint res[][] = new int[m][n];\\n\\t\\t\\t\\t\\tfor(int i = 0; i < m; i++){\\n\\t\\t\\t\\t\\t\\tfor(int j = 0; j < n; j++){\\n\\t\\t\\t\\t\\t\\t\\tres[i][j] = -1;\\n\\t\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 3981264,
                "title": "easy-for-beginners-beats-70-plus-in-python",
                "content": "![image.png](https://assets.leetcode.com/users/images/10c25c82-b5cf-42e4-9935-eeaa6fce27d0_1693410512.929691.png)\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def spiralMatrix(self, m: int, n: int, head: Optional[ListNode]) -> List[List[int]]:\\n        matrix = []\\n        for i in range(m):\\n            l=[]\\n            for j in range(n):\\n                l.append(-1)\\n            matrix.append(l)\\n        #print(matrix)\\n        val = []\\n        while(head):\\n            val.append(head.val)\\n            head = head.next\\n        #print(val)\\n        top , left = 0 , 0\\n        bot , right = m - 1 , n - 1\\n        w = 0\\n        top , left = 0 , 0\\n        bot , right = len(matrix) - 1 , len(matrix[0]) - 1\\n        while(top <= bot and left <= right):\\n            for i in range(top,right+1):\\n                if w < len(val):\\n                    matrix[top][i] = val[w]\\n                    w += 1\\n                else:\\n                    continue\\n            top += 1\\n            \\n            for i in range(top,bot+1):\\n                if w < len(val):\\n                    matrix[i][right] = val[w]\\n                    w += 1\\n                else:\\n                    continue\\n            right -= 1\\n            if top <= bot:\\n                for i in range(right,left - 1,-1):\\n                    if w < len(val):\\n                        matrix[bot][i] = val[w]\\n                        w += 1\\n                    else:\\n                        continue\\n                bot -= 1\\n            if left <= right:\\n                for i in range(bot,top-1,-1):\\n                    if w < len(val):\\n                        matrix[i][left] = val[w]\\n                        w += 1\\n                    else:\\n                        continue\\n                left += 1\\n            \\n        return matrix\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Linked List",
                    "Matrix",
                    "Simulation"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def spiralMatrix(self, m: int, n: int, head: Optional[ListNode]) -> List[List[int]]:\\n        matrix = []\\n        for i in range(m):\\n            l=[]\\n            for j in range(n):\\n                l.append(-1)\\n            matrix.append(l)\\n        #print(matrix)\\n        val = []\\n        while(head):\\n            val.append(head.val)\\n            head = head.next\\n        #print(val)\\n        top , left = 0 , 0\\n        bot , right = m - 1 , n - 1\\n        w = 0\\n        top , left = 0 , 0\\n        bot , right = len(matrix) - 1 , len(matrix[0]) - 1\\n        while(top <= bot and left <= right):\\n            for i in range(top,right+1):\\n                if w < len(val):\\n                    matrix[top][i] = val[w]\\n                    w += 1\\n                else:\\n                    continue\\n            top += 1\\n            \\n            for i in range(top,bot+1):\\n                if w < len(val):\\n                    matrix[i][right] = val[w]\\n                    w += 1\\n                else:\\n                    continue\\n            right -= 1\\n            if top <= bot:\\n                for i in range(right,left - 1,-1):\\n                    if w < len(val):\\n                        matrix[bot][i] = val[w]\\n                        w += 1\\n                    else:\\n                        continue\\n                bot -= 1\\n            if left <= right:\\n                for i in range(bot,top-1,-1):\\n                    if w < len(val):\\n                        matrix[i][left] = val[w]\\n                        w += 1\\n                    else:\\n                        continue\\n                left += 1\\n            \\n        return matrix\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3980798,
                "title": "easy-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    # \\u6309\\u7167\\u4EE5\\u4E0B\\u987A\\u5E8F\\u904D\\u5386\\n    # \\u5DE6->\\u53F3\\n    # \\u4E0A->\\u4E0B\\n    # \\u53F3->\\u5DE6\\n    # \\u4E0B->\\u4E0A\\n    # \\u5F53node\\u4E3ANone\\u65F6\\uFF0C\\u5B50\\u5FAA\\u73AF\\u5185return mat\\n    # \\u5F53node\\u4E3ANone\\u65F6\\uFF0C\\u5916\\u5FAA\\u73AF\\u7ED3\\u675F\\uFF0Creturn mat\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution(object):\\n    def spiralMatrix(self, m, n, head):\\n        \"\"\"\\n        :type m: int\\n        :type n: int\\n        :type head: Optional[ListNode]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        # \\u6309\\u7167\\u4EE5\\u4E0B\\u987A\\u5E8F\\u904D\\u5386\\n        # \\u5DE6->\\u53F3\\n        # \\u4E0A->\\u4E0B\\n        # \\u53F3->\\u5DE6\\n        # \\u4E0B->\\u4E0A\\n        # \\u5F53node\\u4E3ANone\\u65F6\\uFF0C\\u5B50\\u5FAA\\u73AF\\u5185return mat\\n        # \\u5F53node\\u4E3ANone\\u65F6\\uFF0C\\u5916\\u5FAA\\u73AF\\u7ED3\\u675F\\uFF0Creturn mat\\n\\n        mat = [[-1 for j in range(n)] for i in range(m)]\\n        ceil,bott=0,m-1\\n        left,right=0,n-1\\n\\n        while head:\\n            # \\u5DE6->\\u53F3\\n            for i in range(left,right+1,1):\\n                if head is None:\\n                    return mat\\n                mat[ceil][i] = head.val\\n                head = head.next\\n            ceil += 1\\n\\n            for j in range(ceil,bott+1,1):\\n                if head is None:\\n                    return mat\\n                mat[j][right] = head.val\\n                head = head.next\\n            right -= 1\\n\\n            for k in range(right,left-1,-1):\\n                if head is None:\\n                    return mat\\n                mat[bott][k] = head.val\\n                head = head.next\\n            bott -= 1\\n\\n            for l in range(bott,ceil-1,-1):\\n                if head is None:\\n                    return mat\\n                mat[l][left] = head.val\\n                head = head.next\\n            left += 1\\n        return mat\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution(object):\\n    def spiralMatrix(self, m, n, head):\\n        \"\"\"\\n        :type m: int\\n        :type n: int\\n        :type head: Optional[ListNode]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        # \\u6309\\u7167\\u4EE5\\u4E0B\\u987A\\u5E8F\\u904D\\u5386\\n        # \\u5DE6->\\u53F3\\n        # \\u4E0A->\\u4E0B\\n        # \\u53F3->\\u5DE6\\n        # \\u4E0B->\\u4E0A\\n        # \\u5F53node\\u4E3ANone\\u65F6\\uFF0C\\u5B50\\u5FAA\\u73AF\\u5185return mat\\n        # \\u5F53node\\u4E3ANone\\u65F6\\uFF0C\\u5916\\u5FAA\\u73AF\\u7ED3\\u675F\\uFF0Creturn mat\\n\\n        mat = [[-1 for j in range(n)] for i in range(m)]\\n        ceil,bott=0,m-1\\n        left,right=0,n-1\\n\\n        while head:\\n            # \\u5DE6->\\u53F3\\n            for i in range(left,right+1,1):\\n                if head is None:\\n                    return mat\\n                mat[ceil][i] = head.val\\n                head = head.next\\n            ceil += 1\\n\\n            for j in range(ceil,bott+1,1):\\n                if head is None:\\n                    return mat\\n                mat[j][right] = head.val\\n                head = head.next\\n            right -= 1\\n\\n            for k in range(right,left-1,-1):\\n                if head is None:\\n                    return mat\\n                mat[bott][k] = head.val\\n                head = head.next\\n            bott -= 1\\n\\n            for l in range(bott,ceil-1,-1):\\n                if head is None:\\n                    return mat\\n                mat[l][left] = head.val\\n                head = head.next\\n            left += 1\\n        return mat\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3976902,
                "title": "spiral-matrix-iv",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public int[][] spiralMatrix(int m, int n, ListNode head) {\\n        int[][] arr= new int[m][n];\\n        int[] ans = new int[m*n];\\n        int j=0;\\n        while(head!=null)\\n        {\\n            ans[j] = head.val;\\n            head=head.next;\\n            j++;\\n        }\\n        while(j<m*n)\\n        {\\n            ans[j] = -1;\\n            j++;\\n        }\\n        int left = 0;\\n        int top = 0;\\n        int right = n-1;\\n        int bottom = m-1;\\n        j=0;\\n        while(left<=right&&top<=bottom)\\n        {\\n        for(int i=left;i<=right;i++)\\n         {\\n             arr[top][i] = ans[j];\\n             j++;\\n         }\\n         top++;\\n         for(int i=top;i<=bottom;i++)\\n         {\\n             arr[i][right] = ans[j];\\n             j++;\\n         }\\n         right--;\\n         if(top<=bottom)\\n         {\\n             for(int i=right;i>=left;i--)\\n             {\\n                 arr[bottom][i] = ans[j];\\n             j++;\\n             }\\n             bottom--;\\n         }\\n         if(left<=right)\\n         {\\n             for(int i=bottom;i>=top;i--)\\n             {\\n                 arr[i][left] = ans[j];\\n             j++;\\n             }\\n             left++;\\n         }\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public int[][] spiralMatrix(int m, int n, ListNode head) {\\n        int[][] arr= new int[m][n];\\n        int[] ans = new int[m*n];\\n        int j=0;\\n        while(head!=null)\\n        {\\n            ans[j] = head.val;\\n            head=head.next;\\n            j++;\\n        }\\n        while(j<m*n)\\n        {\\n            ans[j] = -1;\\n            j++;\\n        }\\n        int left = 0;\\n        int top = 0;\\n        int right = n-1;\\n        int bottom = m-1;\\n        j=0;\\n        while(left<=right&&top<=bottom)\\n        {\\n        for(int i=left;i<=right;i++)\\n         {\\n             arr[top][i] = ans[j];\\n             j++;\\n         }\\n         top++;\\n         for(int i=top;i<=bottom;i++)\\n         {\\n             arr[i][right] = ans[j];\\n             j++;\\n         }\\n         right--;\\n         if(top<=bottom)\\n         {\\n             for(int i=right;i>=left;i--)\\n             {\\n                 arr[bottom][i] = ans[j];\\n             j++;\\n             }\\n             bottom--;\\n         }\\n         if(left<=right)\\n         {\\n             for(int i=bottom;i>=top;i--)\\n             {\\n                 arr[i][left] = ans[j];\\n             j++;\\n             }\\n             left++;\\n         }\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3972344,
                "title": "fully-explained-best-soln-ever-saw-cpp-easy",
                "content": "\\n\\n# Code\\n```\\n//FOLLOW UP OF SPIRAL MATRIX 2 \\n// INDEX ++ KARNE KE BAJAYE LL SE VALUE DAALKE AAGE BADA\\n//also tmep=NULL TOH ELEMENTS DAALKE HO GAYA HENCE RETURN ARR\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        vector<vector<int>> ans(m,vector<int>(n,-1));\\n        //4 variables lagenge \\n        //top\\n        int top=0;\\n        int bottom=m-1;\\n        int left=0;\\n        int right=n-1;\\n        //temp bana\\n        ListNode *temp=head;\\n      while(top<=bottom and left<=right)\\n      {\\n          //-------->\\n          //for the 1st row\\n          //1st row fix hai and col is changing\\n          //chal raha from left to right\\n          for(int j=left;j<=right;j++)\\n          {     \\n              if(temp==NULL) return ans;\\n              ans[top][j]=temp->val;\\n              temp=temp->next;\\n          }\\n          //first row ie is 0 bhar gaya\\n          //now second row ir 1 st me jana\\n          top++;\\n\\n         \\n          //for the last column\\n          //col fix row changes\\n          //top se bottom chalega loop\\n          for(int i=top;i<=bottom;i++)\\n          {\\n              if(temp==NULL) return ans;\\n              ans[i][right]=temp->val;\\n              temp=temp->next;\\n          }\\n          //last column fill ho gaya \\n          //ab last column ie 3 se aab 2 me aaye\\n          right--;\\n\\n          //<---------------- hence decrement\\n          //for last row\\n          //row same hai col changes\\n          //for chalega from right se left\\n\\n          for(int j=right;j>=left;j--)\\n          {\\n              if(temp==NULL) return ans;\\n              ans[bottom][j]=temp->val;\\n              temp=temp->next;\\n          }\\n          //last row bhar gaya \\n          // ab 2 row se 1 row me jana\\n          bottom--;\\n\\n          //upar jana\\n          //first col same and row changes\\n          //for chalega from bottom to top\\n          for(int i=bottom;i>=top;i--)\\n          {\\n              if(temp==NULL) return ans;\\n              ans[i][left]=temp->val;\\n              temp=temp->next;\\n          }\\n        //values bharne ke baad\\n        //abb --> jayega ie left++\\n          left++;\\n          \\n\\n      }\\n      return ans;\\n\\n    }\\n};\\n```\\n\\nUPVOTE OR ELSE NO PLACEMENT",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n//FOLLOW UP OF SPIRAL MATRIX 2 \\n// INDEX ++ KARNE KE BAJAYE LL SE VALUE DAALKE AAGE BADA\\n//also tmep=NULL TOH ELEMENTS DAALKE HO GAYA HENCE RETURN ARR\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        vector<vector<int>> ans(m,vector<int>(n,-1));\\n        //4 variables lagenge \\n        //top\\n        int top=0;\\n        int bottom=m-1;\\n        int left=0;\\n        int right=n-1;\\n        //temp bana\\n        ListNode *temp=head;\\n      while(top<=bottom and left<=right)\\n      {\\n          //-------->\\n          //for the 1st row\\n          //1st row fix hai and col is changing\\n          //chal raha from left to right\\n          for(int j=left;j<=right;j++)\\n          {     \\n              if(temp==NULL) return ans;\\n              ans[top][j]=temp->val;\\n              temp=temp->next;\\n          }\\n          //first row ie is 0 bhar gaya\\n          //now second row ir 1 st me jana\\n          top++;\\n\\n         \\n          //for the last column\\n          //col fix row changes\\n          //top se bottom chalega loop\\n          for(int i=top;i<=bottom;i++)\\n          {\\n              if(temp==NULL) return ans;\\n              ans[i][right]=temp->val;\\n              temp=temp->next;\\n          }\\n          //last column fill ho gaya \\n          //ab last column ie 3 se aab 2 me aaye\\n          right--;\\n\\n          //<---------------- hence decrement\\n          //for last row\\n          //row same hai col changes\\n          //for chalega from right se left\\n\\n          for(int j=right;j>=left;j--)\\n          {\\n              if(temp==NULL) return ans;\\n              ans[bottom][j]=temp->val;\\n              temp=temp->next;\\n          }\\n          //last row bhar gaya \\n          // ab 2 row se 1 row me jana\\n          bottom--;\\n\\n          //upar jana\\n          //first col same and row changes\\n          //for chalega from bottom to top\\n          for(int i=bottom;i>=top;i--)\\n          {\\n              if(temp==NULL) return ans;\\n              ans[i][left]=temp->val;\\n              temp=temp->next;\\n          }\\n        //values bharne ke baad\\n        //abb --> jayega ie left++\\n          left++;\\n          \\n\\n      }\\n      return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3971188,
                "title": "easy-solution-cpp-fastest",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        vector<vector<int>> ans (m, vector<int> (n, -1)); \\n\\n        int sr = 0, sc = 0, er = m-1, ec = n-1;   \\n\\n        while(sr < er && sc < ec){\\n\\n            for(int i = sc ; i < ec ;i++) {\\n                if(head == nullptr) return ans;\\n                ans[sr][i] = head->val;\\n                head = head->next;\\n                \\n            }\\n\\n            for(int i = sr ; i < er ; i++){    \\n                if(head == nullptr) return ans;\\n                ans[i][ec] = head->val;\\n                head = head->next;\\n                \\n            }     \\n\\n            for(int i = ec; i > sc ; i--) {   \\n                if(head == nullptr) return ans;\\n                ans[er][i] = head->val;\\n                head = head->next;\\n                \\n                \\n            }\\n\\n            for(int i = er ; i > sr; i--) {    \\n                if(head == nullptr) return ans;\\n                ans[i][sc] = head->val;\\n                head = head->next;\\n                \\n            }\\n    \\n            sr++;sc++;\\n            er--; ec--;\\n        }\\n        \\n        if(sc == ec &&sr < er ) for(int i = sr ; i<= er ; i++){\\n            if(head == nullptr) return ans;\\n            ans[i][sc] = head->val;\\n            head = head->next;\\n            \\n        }\\n        \\n        if(sr  == er && sc < ec  ) for(int i = sc ; i<= ec ; i++) {\\n            if(head == nullptr) return ans;\\n            ans[sr][i] = head->val;\\n            head = head->next;\\n            \\n        }\\n        \\n        if(sr == er && sc == ec) {\\n            if(head == nullptr) return ans;\\n            ans[sr][sc] = head->val;\\n             head = head->next;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        vector<vector<int>> ans (m, vector<int> (n, -1)); \\n\\n        int sr = 0, sc = 0, er = m-1, ec = n-1;   \\n\\n        while(sr < er && sc < ec){\\n\\n            for(int i = sc ; i < ec ;i++) {\\n                if(head == nullptr) return ans;\\n                ans[sr][i] = head->val;\\n                head = head->next;\\n                \\n            }\\n\\n            for(int i = sr ; i < er ; i++){    \\n                if(head == nullptr) return ans;\\n                ans[i][ec] = head->val;\\n                head = head->next;\\n                \\n            }     \\n\\n            for(int i = ec; i > sc ; i--) {   \\n                if(head == nullptr) return ans;\\n                ans[er][i] = head->val;\\n                head = head->next;\\n                \\n                \\n            }\\n\\n            for(int i = er ; i > sr; i--) {    \\n                if(head == nullptr) return ans;\\n                ans[i][sc] = head->val;\\n                head = head->next;\\n                \\n            }\\n    \\n            sr++;sc++;\\n            er--; ec--;\\n        }\\n        \\n        if(sc == ec &&sr < er ) for(int i = sr ; i<= er ; i++){\\n            if(head == nullptr) return ans;\\n            ans[i][sc] = head->val;\\n            head = head->next;\\n            \\n        }\\n        \\n        if(sr  == er && sc < ec  ) for(int i = sc ; i<= ec ; i++) {\\n            if(head == nullptr) return ans;\\n            ans[sr][i] = head->val;\\n            head = head->next;\\n            \\n        }\\n        \\n        if(sr == er && sc == ec) {\\n            if(head == nullptr) return ans;\\n            ans[sr][sc] = head->val;\\n             head = head->next;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3968875,
                "title": "easy-cpp-solution-beats-72-in-runtime-beginner-friendly",
                "content": "![image.png](https://assets.leetcode.com/users/images/bd85b0c5-455d-420b-8788-790e438a1964_1693161709.7809508.png)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        vector<vector<int>> ans(m, vector<int>(n,-1));\\n\\n        int sr=0, sc=0,er=m-1,ec=n-1;\\n        ListNode* curr = head;\\n        while(curr != NULL){\\n            for(int i=sc; i<=ec && curr; i++){\\n                ans[sr][i] = curr->val;\\n                curr = curr->next;\\n            }\\n            sr++;\\n            for(int i=sr; i<=er && curr; i++){\\n                ans[i][ec] = curr->val;\\n                curr = curr->next;\\n            }\\n            ec--;\\n            for(int i=ec; i>=sc && curr; i--){\\n                ans[er][i] = curr->val;\\n                curr = curr->next;\\n            }\\n            er--;\\n            for(int i=er; i>=sr && curr; i--){\\n                ans[i][sc] = curr->val;\\n                curr = curr->next;\\n            }\\n            sc++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        vector<vector<int>> ans(m, vector<int>(n,-1));\\n\\n        int sr=0, sc=0,er=m-1,ec=n-1;\\n        ListNode* curr = head;\\n        while(curr != NULL){\\n            for(int i=sc; i<=ec && curr; i++){\\n                ans[sr][i] = curr->val;\\n                curr = curr->next;\\n            }\\n            sr++;\\n            for(int i=sr; i<=er && curr; i++){\\n                ans[i][ec] = curr->val;\\n                curr = curr->next;\\n            }\\n            ec--;\\n            for(int i=ec; i>=sc && curr; i--){\\n                ans[er][i] = curr->val;\\n                curr = curr->next;\\n            }\\n            er--;\\n            for(int i=er; i>=sr && curr; i--){\\n                ans[i][sc] = curr->val;\\n                curr = curr->next;\\n            }\\n            sc++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3961842,
                "title": "java-100-work-and-quick-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution\\n {\\n    public int[][] spiralMatrix(int m, int n, ListNode head)\\n     {\\n\\n         int row=0;\\n        int nrow=m-1;\\n        int col=0;\\n        int ncol=n-1;\\n        int size=n*m;\\n        int c=0;\\n\\n        int[][] arr=new int[m][n];\\n\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n                arr[i][j]=-1;\\n        }\\n\\n        while(head != null){\\n\\n            for(int i=row;head != null && i<=ncol;i++)\\n            {\\n                arr[row][i]=head.val;\\n                c+=1;\\n                head=head.next;\\n            }\\n            row+=1;\\n\\n            for(int i=row;head != null && i<=nrow;i++)\\n            {\\n                arr[i][ncol]=head.val;\\n                c+=1;\\n                head=head.next;\\n            }\\n            ncol-=1;\\n\\n            for(int i=ncol;head != null && i>=col;i--){\\n                arr[nrow][i]=head.val;\\n                c+=1;\\n                head=head.next;\\n            }\\n            nrow-=1;\\n\\n            for(int i=nrow;head != null && i>=row;i--){\\n                arr[i][col]=head.val;\\n                c+=1;\\n                head=head.next;\\n            }\\n            col+=1;\\n\\n        }\\n\\n        return arr;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution\\n {\\n    public int[][] spiralMatrix(int m, int n, ListNode head)\\n     {\\n\\n         int row=0;\\n        int nrow=m-1;\\n        int col=0;\\n        int ncol=n-1;\\n        int size=n*m;\\n        int c=0;\\n\\n        int[][] arr=new int[m][n];\\n\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n                arr[i][j]=-1;\\n        }\\n\\n        while(head != null){\\n\\n            for(int i=row;head != null && i<=ncol;i++)\\n            {\\n                arr[row][i]=head.val;\\n                c+=1;\\n                head=head.next;\\n            }\\n            row+=1;\\n\\n            for(int i=row;head != null && i<=nrow;i++)\\n            {\\n                arr[i][ncol]=head.val;\\n                c+=1;\\n                head=head.next;\\n            }\\n            ncol-=1;\\n\\n            for(int i=ncol;head != null && i>=col;i--){\\n                arr[nrow][i]=head.val;\\n                c+=1;\\n                head=head.next;\\n            }\\n            nrow-=1;\\n\\n            for(int i=nrow;head != null && i>=row;i--){\\n                arr[i][col]=head.val;\\n                c+=1;\\n                head=head.next;\\n            }\\n            col+=1;\\n\\n        }\\n\\n        return arr;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3958762,
                "title": "easy-c-beats-97-6",
                "content": "# Approach\\n1. Move in all four boundry one by one.\\n2. with keeping track of boundry conditions,\\n3. once completed outer boundry,\\n4. keep coming to next inner boundry,\\n5. till the end of the list.\\n\\n```\\n/**\\nif you try to understand the code read it first...\\nsi = starting of i\\nsm = starting of m\\nei = ending of i\\nem = ending of m\\n**/\\n```\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n$$O(m*n)$$\\nFrom making and initializing the matrix\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n$$O(m*n)$$\\nMatrix of size(m*n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        vector<vector<int>>v(m,vector<int>(n,-1));\\n        int si=0,sm=1,ei=n,em=m;\\n        while(head)\\n        {\\n            for(int i=si;i<ei;i++)\\n            {\\n                if(!head)return v;\\n                v[sm-1][i]=head->val;\\n                head=head->next;\\n            }\\n            for(int i=sm;i<em;i++)\\n            {\\n                if(!head)return v;\\n                v[i][ei-1]=head->val;\\n                head=head->next;\\n            }\\n            for(int i=ei-2;i>=si;i--)\\n            {\\n                if(!head)return v;\\n                v[em-1][i]=head->val;\\n                head=head->next;\\n            }\\n            for(int i=em-2;i>=sm;i--)\\n            {\\n                if(!head)return v;\\n                v[i][si]=head->val;\\n                head=head->next;\\n            }\\n            si++;\\n            ei--;\\n            sm++;\\n            em--;\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Matrix",
                    "Simulation"
                ],
                "code": "```\\n/**\\nif you try to understand the code read it first...\\nsi = starting of i\\nsm = starting of m\\nei = ending of i\\nem = ending of m\\n**/\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        vector<vector<int>>v(m,vector<int>(n,-1));\\n        int si=0,sm=1,ei=n,em=m;\\n        while(head)\\n        {\\n            for(int i=si;i<ei;i++)\\n            {\\n                if(!head)return v;\\n                v[sm-1][i]=head->val;\\n                head=head->next;\\n            }\\n            for(int i=sm;i<em;i++)\\n            {\\n                if(!head)return v;\\n                v[i][ei-1]=head->val;\\n                head=head->next;\\n            }\\n            for(int i=ei-2;i>=si;i--)\\n            {\\n                if(!head)return v;\\n                v[em-1][i]=head->val;\\n                head=head->next;\\n            }\\n            for(int i=em-2;i>=sm;i--)\\n            {\\n                if(!head)return v;\\n                v[i][si]=head->val;\\n                head=head->next;\\n            }\\n            si++;\\n            ei--;\\n            sm++;\\n            em--;\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3954113,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public int[][] spiralMatrix(int m, int n, ListNode head) {\\n        int arr[]=new int[m*n];\\n        for(int i=0;i<arr.length;i++){\\n            arr[i]=-1;\\n        }\\n        int i=0;\\n        while(head!=null){\\n            arr[i]=head.val;\\n            i++;\\n            head=head.next;\\n        }\\n        int ans[][]=new int[m][n];\\n        int t=0,b=m-1,l=0,r=n-1;\\n        int c=0;\\n        while(t<=b && l<=r){\\n            //top\\n            for( i=l;i<=r;i++){\\n                ans[t][i]=arr[c];\\n                c++;\\n            }\\n            t++;\\n            //right\\n            for( i=t;i<=b;i++){\\n                ans[i][r]=arr[c];\\n                c++;\\n            }\\n            r--;\\n            //bottom\\n            if(t<=b){\\n                for( i=r;i>=l;i--){\\n                    ans[b][i]=arr[c];\\n                    c++;\\n                }\\n                b--;\\n            }\\n            //left\\n            if(l<=r){\\n                for( i=b;i>=t;i--){\\n                    ans[i][l]=arr[c];\\n                    c++;\\n                }\\n                l++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public int[][] spiralMatrix(int m, int n, ListNode head) {\\n        int arr[]=new int[m*n];\\n        for(int i=0;i<arr.length;i++){\\n            arr[i]=-1;\\n        }\\n        int i=0;\\n        while(head!=null){\\n            arr[i]=head.val;\\n            i++;\\n            head=head.next;\\n        }\\n        int ans[][]=new int[m][n];\\n        int t=0,b=m-1,l=0,r=n-1;\\n        int c=0;\\n        while(t<=b && l<=r){\\n            //top\\n            for( i=l;i<=r;i++){\\n                ans[t][i]=arr[c];\\n                c++;\\n            }\\n            t++;\\n            //right\\n            for( i=t;i<=b;i++){\\n                ans[i][r]=arr[c];\\n                c++;\\n            }\\n            r--;\\n            //bottom\\n            if(t<=b){\\n                for( i=r;i>=l;i--){\\n                    ans[b][i]=arr[c];\\n                    c++;\\n                }\\n                b--;\\n            }\\n            //left\\n            if(l<=r){\\n                for( i=b;i>=t;i--){\\n                    ans[i][l]=arr[c];\\n                    c++;\\n                }\\n                l++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3953735,
                "title": "easy-to-understand-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        vector<vector<int>> v(m, vector<int>(n, -1));\\n        int mend = m, nend = n, cnt = 0, size = m*n;\\n        int i = 1, j = 1, mst = 1, nst = 1;\\n        while(cnt < size && head){\\n            i = nst;\\n            j = mst;\\n            while(i <= nend){\\n                v[j-1][i-1] = head->val;\\n                head = head->next;\\n                if(!head) break;\\n                ++i;\\n                ++cnt;\\n            }\\n            --i;\\n            ++j;\\n            if(!head) break;\\n            while(j <= mend){\\n                v[j-1][i-1] = head->val;\\n                head = head->next;\\n                if(!head) break;\\n                ++j;\\n                ++cnt;\\n            }\\n            --j;\\n            --i;\\n            if(!head) break;\\n            while(i >= nst){\\n                v[j-1][i-1] = head->val;\\n                head = head->next;\\n                if(!head) break;\\n                --i;\\n                ++cnt;\\n            }\\n            ++i;\\n            --j;\\n            if(!head) break;\\n            while(j >= mst+1){\\n                v[j-1][i-1] = head->val;\\n                head = head->next;\\n                if(!head) break;\\n                --j;\\n                ++cnt;\\n            }\\n            ++j;\\n            if(!head) break;\\n            ++nst;\\n            --nend;\\n            ++mst;\\n            --mend;\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        vector<vector<int>> v(m, vector<int>(n, -1));\\n        int mend = m, nend = n, cnt = 0, size = m*n;\\n        int i = 1, j = 1, mst = 1, nst = 1;\\n        while(cnt < size && head){\\n            i = nst;\\n            j = mst;\\n            while(i <= nend){\\n                v[j-1][i-1] = head->val;\\n                head = head->next;\\n                if(!head) break;\\n                ++i;\\n                ++cnt;\\n            }\\n            --i;\\n            ++j;\\n            if(!head) break;\\n            while(j <= mend){\\n                v[j-1][i-1] = head->val;\\n                head = head->next;\\n                if(!head) break;\\n                ++j;\\n                ++cnt;\\n            }\\n            --j;\\n            --i;\\n            if(!head) break;\\n            while(i >= nst){\\n                v[j-1][i-1] = head->val;\\n                head = head->next;\\n                if(!head) break;\\n                --i;\\n                ++cnt;\\n            }\\n            ++i;\\n            --j;\\n            if(!head) break;\\n            while(j >= mst+1){\\n                v[j-1][i-1] = head->val;\\n                head = head->next;\\n                if(!head) break;\\n                --j;\\n                ++cnt;\\n            }\\n            ++j;\\n            if(!head) break;\\n            ++nst;\\n            --nend;\\n            ++mst;\\n            --mend;\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3949725,
                "title": "java-iterate-spirally-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public int[][] spiralMatrix(int m, int n, ListNode head) {\\n        int arr[][] = new int[m][n];\\n        int i=0;\\n        int j=0;\\n        int count = m*n;\\n        while(count >0){\\n\\n            for(int x=i,y=j;y<n-j;y++){\\n                \\n                if(head != null){\\n                    arr[x][y] = head.val;\\n                    head = head.next;\\n                    count--;\\n                }else{\\n                    arr[x][y] = -1;\\n                    count--;\\n                }\\n            }\\n            if(count <1)break;\\n\\n            for(int x=i+1,y=n-j-1;x<m-i;x++){\\n                if(head != null){\\n                    arr[x][y] = head.val;\\n                    head = head.next;\\n                    count--;\\n                }else{\\n                    arr[x][y] = -1;\\n                    count--;\\n                }\\n            }\\n            if(count <1)break;\\n\\n            for(int x=m-i-1,y=n-j-2;y>=j;y--){\\n                if(head != null){\\n                    arr[x][y] = head.val;\\n                    head = head.next;\\n                    count--;\\n                }else{\\n                    arr[x][y] = -1;\\n                    count--;\\n                }\\n            }\\n            if(count <1)break;\\n\\n            for(int x=m-i-2,y=j;x>i;x--){\\n                if(head != null){\\n                    arr[x][y] = head.val;\\n                    head = head.next;\\n                    count--;\\n                }else{\\n                    arr[x][y] = -1;\\n                    count--;\\n                }\\n            }\\n            i++;\\n            j++;\\n        }\\n        return arr;\\n\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public int[][] spiralMatrix(int m, int n, ListNode head) {\\n        int arr[][] = new int[m][n];\\n        int i=0;\\n        int j=0;\\n        int count = m*n;\\n        while(count >0){\\n\\n            for(int x=i,y=j;y<n-j;y++){\\n                \\n                if(head != null){\\n                    arr[x][y] = head.val;\\n                    head = head.next;\\n                    count--;\\n                }else{\\n                    arr[x][y] = -1;\\n                    count--;\\n                }\\n            }\\n            if(count <1)break;\\n\\n            for(int x=i+1,y=n-j-1;x<m-i;x++){\\n                if(head != null){\\n                    arr[x][y] = head.val;\\n                    head = head.next;\\n                    count--;\\n                }else{\\n                    arr[x][y] = -1;\\n                    count--;\\n                }\\n            }\\n            if(count <1)break;\\n\\n            for(int x=m-i-1,y=n-j-2;y>=j;y--){\\n                if(head != null){\\n                    arr[x][y] = head.val;\\n                    head = head.next;\\n                    count--;\\n                }else{\\n                    arr[x][y] = -1;\\n                    count--;\\n                }\\n            }\\n            if(count <1)break;\\n\\n            for(int x=m-i-2,y=j;x>i;x--){\\n                if(head != null){\\n                    arr[x][y] = head.val;\\n                    head = head.next;\\n                    count--;\\n                }else{\\n                    arr[x][y] = -1;\\n                    count--;\\n                }\\n            }\\n            i++;\\n            j++;\\n        }\\n        return arr;\\n\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3943981,
                "title": "python-simple-solution-using-for-loops",
                "content": "```\\n    def spiralMatrix(self, m: int, n: int, head: Optional[ListNode]) -> List[List[int]]:\\n        res = [[-1 for i in range(n)] for j in range(m)]\\n        LEFT, TOP = 0, 0\\n        RIGHT, BOT = n, m\\n        while head:\\n            for i in range(LEFT, RIGHT):\\n                if head:\\n                    res[TOP][i] = head.val\\n                    head = head.next\\n                else:\\n                    return res\\n            \\n            TOP += 1\\n            \\n            for j in range(TOP, BOT):\\n                if head:\\n                    res[j][RIGHT - 1] = head.val\\n                    head = head.next\\n                else:\\n                    return res\\n                \\n            RIGHT -= 1\\n            \\n            for k in range(RIGHT - 1, LEFT - 1, -1):\\n                if head:\\n                    res[BOT - 1][k] = head.val\\n                    head = head.next\\n                else:\\n                    return res\\n                 \\n            BOT -= 1\\n            \\n            for l in range(BOT - 1, TOP - 1, -1):\\n                if head:\\n                    res[l][LEFT] = head.val\\n                    head = head.next\\n                else:\\n                    return res\\n                \\n            LEFT += 1\\n            \\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\n    def spiralMatrix(self, m: int, n: int, head: Optional[ListNode]) -> List[List[int]]:\\n        res = [[-1 for i in range(n)] for j in range(m)]\\n        LEFT, TOP = 0, 0\\n        RIGHT, BOT = n, m\\n        while head:\\n            for i in range(LEFT, RIGHT):\\n                if head:\\n                    res[TOP][i] = head.val\\n                    head = head.next\\n                else:\\n                    return res\\n            \\n            TOP += 1\\n            \\n            for j in range(TOP, BOT):\\n                if head:\\n                    res[j][RIGHT - 1] = head.val\\n                    head = head.next\\n                else:\\n                    return res\\n                \\n            RIGHT -= 1\\n            \\n            for k in range(RIGHT - 1, LEFT - 1, -1):\\n                if head:\\n                    res[BOT - 1][k] = head.val\\n                    head = head.next\\n                else:\\n                    return res\\n                 \\n            BOT -= 1\\n            \\n            for l in range(BOT - 1, TOP - 1, -1):\\n                if head:\\n                    res[l][LEFT] = head.val\\n                    head = head.next\\n                else:\\n                    return res\\n                \\n            LEFT += 1\\n            \\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3941186,
                "title": "very-simple-solution",
                "content": "#### Fill in the cells of the matrix in a circle, if they are within its limits or have not been previously filled\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def spiralMatrix(self, m: int, n: int, head: Optional[ListNode]) -> List[List[int]]:\\n        mat = [[-1]*n for _ in range(m)]\\n        i, j = 0, 0\\n        while head:\\n            while head and i < n and mat[j][i] == -1:\\n                mat[j][i] = head.val\\n                i += 1\\n                head = head.next\\n            i -= 1\\n            j += 1\\n            while head and j < m and mat[j][i] == -1:\\n                mat[j][i] = head.val\\n                j += 1\\n                head = head.next\\n            i -= 1\\n            j -= 1\\n            while head and i >= 0 and mat[j][i] == -1:\\n                mat[j][i] = head.val\\n                i -= 1\\n                head = head.next\\n            i += 1\\n            j -= 1\\n            while head and j >= 0 and mat[j][i] == -1:\\n                mat[j][i] = head.val\\n                j -= 1\\n                head = head.next\\n            i += 1\\n            j += 1\\n        return mat\\n```\\n\\n```\\nclass Solution:\\n    def spiralMatrix(self, m: int, n: int, head: Optional[ListNode]) -> List[List[int]]:\\n        mat = [[-1]*n for _ in range(m)]\\n        i, j, k = 0, 0, 0\\n        direct = [(1,0,-1,1), (0,1,-1,-1), (-1,0,1,-1), (0,-1,1,1)]\\n        while head:\\n            while head and 0 <= i < n and 0 <= j < m and mat[j][i] == -1:\\n                mat[j][i] = head.val\\n                i += direct[k][0]\\n                j += direct[k][1]\\n                head = head.next\\n            i += direct[k][2]\\n            j += direct[k][3]\\n            k = (k+1)%4       \\n        return mat\\n```",
                "solutionTags": [
                    "Python3",
                    "Linked List"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def spiralMatrix(self, m: int, n: int, head: Optional[ListNode]) -> List[List[int]]:\\n        mat = [[-1]*n for _ in range(m)]\\n        i, j = 0, 0\\n        while head:\\n            while head and i < n and mat[j][i] == -1:\\n                mat[j][i] = head.val\\n                i += 1\\n                head = head.next\\n            i -= 1\\n            j += 1\\n            while head and j < m and mat[j][i] == -1:\\n                mat[j][i] = head.val\\n                j += 1\\n                head = head.next\\n            i -= 1\\n            j -= 1\\n            while head and i >= 0 and mat[j][i] == -1:\\n                mat[j][i] = head.val\\n                i -= 1\\n                head = head.next\\n            i += 1\\n            j -= 1\\n            while head and j >= 0 and mat[j][i] == -1:\\n                mat[j][i] = head.val\\n                j -= 1\\n                head = head.next\\n            i += 1\\n            j += 1\\n        return mat\\n```\n```\\nclass Solution:\\n    def spiralMatrix(self, m: int, n: int, head: Optional[ListNode]) -> List[List[int]]:\\n        mat = [[-1]*n for _ in range(m)]\\n        i, j, k = 0, 0, 0\\n        direct = [(1,0,-1,1), (0,1,-1,-1), (-1,0,1,-1), (0,-1,1,1)]\\n        while head:\\n            while head and 0 <= i < n and 0 <= j < m and mat[j][i] == -1:\\n                mat[j][i] = head.val\\n                i += direct[k][0]\\n                j += direct[k][1]\\n                head = head.next\\n            i += direct[k][2]\\n            j += direct[k][3]\\n            k = (k+1)%4       \\n        return mat\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3940128,
                "title": "concept-of-spiral-matrix-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) \\n    {\\n        int rows=m;\\n        int cols=n; \\n        vector<vector<int>>ans(rows, vector<int>(cols, -1));\\n        if(head==NULL)\\n        {\\n            return ans;\\n        }\\n        int total=m*n;\\n        int top=0,bottom=m-1;\\n        int left=0,right=n-1;\\n        ListNode*temp=head;\\n        int i=0,j=0;\\n        while(left<=right&&top<=bottom&&temp!=NULL)\\n        {\\n            if(temp==NULL)return ans;\\n            if(temp!=NULL)\\n            {\\n                for(int i=left;i<=right;i++)\\n                {\\n                    if(temp!=NULL)\\n                    {\\n                        ans[top][i]=temp->val;\\n                        temp=temp->next;\\n                    }\\n                \\n                }\\n            }\\n            top++;\\n            if(temp==NULL)return ans;\\n             for(int i=top;i<=bottom;i++)\\n            {\\n                if(temp!=NULL)\\n                {\\n                    ans[i][right]=temp->val;\\n                    temp=temp->next;\\n               }\\n            }\\n            right-=1;\\n            if(temp==NULL)return ans;\\n             for(int i=right;i>=left&&top<=bottom;i--)\\n            {\\n                if(temp!=NULL)\\n                {\\n                    ans[bottom][i]=temp->val;\\n                    temp=temp->next;\\n                 }\\n            } \\n            bottom-=1;\\n            if(temp==NULL)return ans;\\n            for(int i=bottom;i>=top&&left<=right;i--)\\n            {\\n                if(temp!=NULL)\\n                {\\n\\n                    ans[i][left]=temp->val;\\n                    temp=temp->next;\\n                }\\n            }\\n            left++;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Matrix"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) \\n    {\\n        int rows=m;\\n        int cols=n; \\n        vector<vector<int>>ans(rows, vector<int>(cols, -1));\\n        if(head==NULL)\\n        {\\n            return ans;\\n        }\\n        int total=m*n;\\n        int top=0,bottom=m-1;\\n        int left=0,right=n-1;\\n        ListNode*temp=head;\\n        int i=0,j=0;\\n        while(left<=right&&top<=bottom&&temp!=NULL)\\n        {\\n            if(temp==NULL)return ans;\\n            if(temp!=NULL)\\n            {\\n                for(int i=left;i<=right;i++)\\n                {\\n                    if(temp!=NULL)\\n                    {\\n                        ans[top][i]=temp->val;\\n                        temp=temp->next;\\n                    }\\n                \\n                }\\n            }\\n            top++;\\n            if(temp==NULL)return ans;\\n             for(int i=top;i<=bottom;i++)\\n            {\\n                if(temp!=NULL)\\n                {\\n                    ans[i][right]=temp->val;\\n                    temp=temp->next;\\n               }\\n            }\\n            right-=1;\\n            if(temp==NULL)return ans;\\n             for(int i=right;i>=left&&top<=bottom;i--)\\n            {\\n                if(temp!=NULL)\\n                {\\n                    ans[bottom][i]=temp->val;\\n                    temp=temp->next;\\n                 }\\n            } \\n            bottom-=1;\\n            if(temp==NULL)return ans;\\n            for(int i=bottom;i>=top&&left<=right;i--)\\n            {\\n                if(temp!=NULL)\\n                {\\n\\n                    ans[i][left]=temp->val;\\n                    temp=temp->next;\\n                }\\n            }\\n            left++;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3937451,
                "title": "easy-and-simple-to-implement-solution",
                "content": "# Complexity\\n- Time complexity: $$O(m*n)$$ \\n\\n- Space complexity: $$O(1)$$ \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        vector<vector<int>> spiral(m,vector<int>(n,-1));\\n        ListNode* curr = head;\\n        int rowStart = 0, colStart = 0, rowEnd = m-1, colEnd = n-1;\\n\\n        while(curr)\\n        {   //fill first row of current rectangle\\n            for(int j=colStart; j<=colEnd; j++)\\n            {\\n                if(curr)\\n                {\\n                spiral[rowStart][j] = curr->val;\\n                curr = curr->next;\\n                }\\n            }\\n            //fill last col of current rectangle\\n            for(int i=rowStart+1; i<=rowEnd; i++)\\n            {\\n                if(curr)\\n                {\\n                spiral[i][colEnd] = curr->val;\\n                curr = curr->next;\\n                }    \\n            }\\n            //fill last row of current rectangle\\n            for(int j=colEnd-1; j>=colStart; j--)\\n            {\\n                if(curr)\\n                {\\n                spiral[rowEnd][j] = curr->val;\\n                curr = curr->next;\\n                }\\n            }\\n            //fill first col of current rectangle\\n            for(int i=rowEnd-1; i>rowStart; i--)\\n            {\\n                if(curr)\\n                {\\n                spiral[i][colStart] = curr->val;\\n                curr = curr->next;\\n                }    \\n            }\\n            //start filling inner rectangle from next iterations onwards\\n            rowStart++; colStart++; rowEnd--; colEnd--;\\n        }\\n    return spiral;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        vector<vector<int>> spiral(m,vector<int>(n,-1));\\n        ListNode* curr = head;\\n        int rowStart = 0, colStart = 0, rowEnd = m-1, colEnd = n-1;\\n\\n        while(curr)\\n        {   //fill first row of current rectangle\\n            for(int j=colStart; j<=colEnd; j++)\\n            {\\n                if(curr)\\n                {\\n                spiral[rowStart][j] = curr->val;\\n                curr = curr->next;\\n                }\\n            }\\n            //fill last col of current rectangle\\n            for(int i=rowStart+1; i<=rowEnd; i++)\\n            {\\n                if(curr)\\n                {\\n                spiral[i][colEnd] = curr->val;\\n                curr = curr->next;\\n                }    \\n            }\\n            //fill last row of current rectangle\\n            for(int j=colEnd-1; j>=colStart; j--)\\n            {\\n                if(curr)\\n                {\\n                spiral[rowEnd][j] = curr->val;\\n                curr = curr->next;\\n                }\\n            }\\n            //fill first col of current rectangle\\n            for(int i=rowEnd-1; i>rowStart; i--)\\n            {\\n                if(curr)\\n                {\\n                spiral[i][colStart] = curr->val;\\n                curr = curr->next;\\n                }    \\n            }\\n            //start filling inner rectangle from next iterations onwards\\n            rowStart++; colStart++; rowEnd--; colEnd--;\\n        }\\n    return spiral;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3933107,
                "title": "golang-easy-approach-w-explanation-comments",
                "content": "# Intuition\\nThis problem can be solved very intuitively. Simply iterate through the linked list and record the value of the node in the correct spot in the matrix.\\n\\n# Approach\\n1. Initialize matrix\\n2. Initialize directions to be clockwise\\n    - (0, 1) = right\\n    - (1, 0) = down\\n    - (0, -1) = left\\n    - (-1, 0) = up\\n3. Iterate through Linked List, and if ***r*** or ***c*** go out of bounds or the next square is already filled, change direction 90 degrees clockwise.\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * type ListNode struct {\\n *     Val int\\n *     Next *ListNode\\n * }\\n */\\nfunc spiralMatrix(rows int, cols int, head *ListNode) [][]int {\\n    // initialize matrix\\n    mat := make([][]int, rows)\\n    for i := 0; i < rows; i++ {\\n        mat[i] = make([]int, cols)\\n        for j := 0; j < cols; j++ {\\n            mat[i][j] = -1\\n        }\\n    }\\n\\n    // keeps track of which operation to do\\n    operations := [][]int{{0, 1}, {1, 0}, {0, -1}, {-1, 0}}\\n    op := 0\\n    \\n    // current index\\n    r, c := 0, 0\\n\\n    // iterate through LL\\n    for head != nil {\\n\\n        mat[r][c] = head.Val\\n\\n        // if next square is out of bounds or already filled out, \\n        // change direction of operation clockwise by incrementing op\\n        nr, nc := operations[op%4][0] + r, operations[op%4][1] + c\\n        if nr >= rows || nr < 0 || nc >= cols || nc < 0 || mat[nr][nc] != -1 {\\n            op++\\n        }\\n\\n        // apply operation to r and c\\n        r += operations[op%4][0]\\n        c += operations[op%4][1]\\n\\n        // keep moving through LL\\n        head = head.Next\\n    }\\n\\n    return mat\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * type ListNode struct {\\n *     Val int\\n *     Next *ListNode\\n * }\\n */\\nfunc spiralMatrix(rows int, cols int, head *ListNode) [][]int {\\n    // initialize matrix\\n    mat := make([][]int, rows)\\n    for i := 0; i < rows; i++ {\\n        mat[i] = make([]int, cols)\\n        for j := 0; j < cols; j++ {\\n            mat[i][j] = -1\\n        }\\n    }\\n\\n    // keeps track of which operation to do\\n    operations := [][]int{{0, 1}, {1, 0}, {0, -1}, {-1, 0}}\\n    op := 0\\n    \\n    // current index\\n    r, c := 0, 0\\n\\n    // iterate through LL\\n    for head != nil {\\n\\n        mat[r][c] = head.Val\\n\\n        // if next square is out of bounds or already filled out, \\n        // change direction of operation clockwise by incrementing op\\n        nr, nc := operations[op%4][0] + r, operations[op%4][1] + c\\n        if nr >= rows || nr < 0 || nc >= cols || nc < 0 || mat[nr][nc] != -1 {\\n            op++\\n        }\\n\\n        // apply operation to r and c\\n        r += operations[op%4][0]\\n        c += operations[op%4][1]\\n\\n        // keep moving through LL\\n        head = head.Next\\n    }\\n\\n    return mat\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3932438,
                "title": "easy-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(m*n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(m*n)\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void generated(vector<vector<int>>& spiral, int m, int n, ListNode* head){\\n        int s=0, total = m*n, val;\\n        int top=0, right= n-1, down = m-1, left = 0;\\n        int tops=0, rights=1, downs=n-1, lefts=m-2;\\n        int tope=n-1, righte=m-2, downe=0, lefte=1;\\n        while(s<total){\\n            for(int i=tops; i <= tope; i++, ++s){\\n                if(head!=NULL){\\n                    val = head -> val;\\n                    head = head -> next;\\n                }\\n                else val = -1;\\n                spiral[top][i] = val;\\n            }\\n            if(s >= total) break;\\n            for(int i=rights; i <= righte; i++, ++s){\\n                if(head!=NULL){\\n                    val = head -> val;\\n                    head = head -> next;\\n                }\\n                else val = -1;\\n                spiral[i][right] = val;\\n            }\\n            if(s >= total) break;\\n            for(int i=downs; i >= downe; i--, ++s){\\n                if(head!=NULL){\\n                    val = head -> val;\\n                    head = head -> next;\\n                }\\n                else val = -1;\\n                spiral[down][i] = val;\\n            }\\n            if(s >= total) break;\\n            for(int i=lefts; i >= lefte; i--, ++s){\\n                if(head!=NULL){\\n                    val = head -> val;\\n                    head = head -> next;\\n                }\\n                else val = -1;\\n                spiral[i][left] = val;\\n            }\\n            if(s >= total) break;\\n            top++; right--; down--; left++;\\n            tops++; tope--; rights++; righte--; downs--; downe++; lefts--; lefte++;\\n        }\\n    }\\n\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        vector<vector<int>> spiral;\\n        for(int i=0; i < m; i++){\\n            vector<int> temp;\\n            for(int j=0; j < n; j++){\\n                temp.push_back(0);\\n            }\\n            spiral.push_back(temp);\\n        }\\n        generated(spiral, m, n, head);\\n        return spiral;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void generated(vector<vector<int>>& spiral, int m, int n, ListNode* head){\\n        int s=0, total = m*n, val;\\n        int top=0, right= n-1, down = m-1, left = 0;\\n        int tops=0, rights=1, downs=n-1, lefts=m-2;\\n        int tope=n-1, righte=m-2, downe=0, lefte=1;\\n        while(s<total){\\n            for(int i=tops; i <= tope; i++, ++s){\\n                if(head!=NULL){\\n                    val = head -> val;\\n                    head = head -> next;\\n                }\\n                else val = -1;\\n                spiral[top][i] = val;\\n            }\\n            if(s >= total) break;\\n            for(int i=rights; i <= righte; i++, ++s){\\n                if(head!=NULL){\\n                    val = head -> val;\\n                    head = head -> next;\\n                }\\n                else val = -1;\\n                spiral[i][right] = val;\\n            }\\n            if(s >= total) break;\\n            for(int i=downs; i >= downe; i--, ++s){\\n                if(head!=NULL){\\n                    val = head -> val;\\n                    head = head -> next;\\n                }\\n                else val = -1;\\n                spiral[down][i] = val;\\n            }\\n            if(s >= total) break;\\n            for(int i=lefts; i >= lefte; i--, ++s){\\n                if(head!=NULL){\\n                    val = head -> val;\\n                    head = head -> next;\\n                }\\n                else val = -1;\\n                spiral[i][left] = val;\\n            }\\n            if(s >= total) break;\\n            top++; right--; down--; left++;\\n            tops++; tope--; rights++; righte--; downs--; downe++; lefts--; lefte++;\\n        }\\n    }\\n\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        vector<vector<int>> spiral;\\n        for(int i=0; i < m; i++){\\n            vector<int> temp;\\n            for(int j=0; j < n; j++){\\n                temp.push_back(0);\\n            }\\n            spiral.push_back(temp);\\n        }\\n        generated(spiral, m, n, head);\\n        return spiral;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3920155,
                "title": "python",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    Greedy\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n * m)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(n * m)\\n# Code\\n```\\nclass Solution:\\n    def spiralMatrix(self, m: int, n: int, head: Optional[ListNode]) -> List[List[int]]:\\n        # make m * n matrix\\n        matrix = [[-1 for _ in range(n)] for _ in range(m)]\\n\\n        left = 0\\n        top = 0\\n        right = n - 1\\n        down = m - 1\\n\\n        while left < n and top < m and 0 <= right and 0 <= down:\\n            # matrix[top][left -> right]\\n            for i in range(left, right + 1):\\n                if self.is_end_of_ListNode(head):\\n                    return matrix\\n\\n                matrix[top][i] = head.val\\n                head = head.next\\n            top += 1\\n\\n            # matrix[top -> down][right]\\n            for i in range(top, down + 1):\\n                if self.is_end_of_ListNode(head):\\n                    return matrix\\n\\n                matrix[i][right] = head.val\\n                head = head.next\\n            right -= 1\\n\\n            # matrix[down][left <- right]\\n            for i in range(right, left - 1, -1):\\n                if self.is_end_of_ListNode(head):\\n                    return matrix\\n\\n                matrix[down][i] = head.val\\n                head = head.next\\n            down -= 1\\n\\n            # matrix[down -> top][left]\\n            for i in range(down, top - 1, -1):\\n                if self.is_end_of_ListNode(head):\\n                    return matrix\\n\\n                matrix[i][left] = head.val\\n                head = head.next\\n            left += 1\\n\\n        return matrix\\n\\n    def is_end_of_ListNode(self, head: Optional[ListNode]) -> bool:\\n        return head is None\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def spiralMatrix(self, m: int, n: int, head: Optional[ListNode]) -> List[List[int]]:\\n        # make m * n matrix\\n        matrix = [[-1 for _ in range(n)] for _ in range(m)]\\n\\n        left = 0\\n        top = 0\\n        right = n - 1\\n        down = m - 1\\n\\n        while left < n and top < m and 0 <= right and 0 <= down:\\n            # matrix[top][left -> right]\\n            for i in range(left, right + 1):\\n                if self.is_end_of_ListNode(head):\\n                    return matrix\\n\\n                matrix[top][i] = head.val\\n                head = head.next\\n            top += 1\\n\\n            # matrix[top -> down][right]\\n            for i in range(top, down + 1):\\n                if self.is_end_of_ListNode(head):\\n                    return matrix\\n\\n                matrix[i][right] = head.val\\n                head = head.next\\n            right -= 1\\n\\n            # matrix[down][left <- right]\\n            for i in range(right, left - 1, -1):\\n                if self.is_end_of_ListNode(head):\\n                    return matrix\\n\\n                matrix[down][i] = head.val\\n                head = head.next\\n            down -= 1\\n\\n            # matrix[down -> top][left]\\n            for i in range(down, top - 1, -1):\\n                if self.is_end_of_ListNode(head):\\n                    return matrix\\n\\n                matrix[i][left] = head.val\\n                head = head.next\\n            left += 1\\n\\n        return matrix\\n\\n    def is_end_of_ListNode(self, head: Optional[ListNode]) -> bool:\\n        return head is None\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3912479,
                "title": "easy-recursion-c",
                "content": "\\n# Complexity\\n\\nTime Complexity:\\nThe time complexity of the code mainly depends on the DFS traversal through the matrix while filling in the values. The DFS function is called for each cell in the res matrix, and it moves through the matrix in four directions (\\'r\\', \\'d\\', \\'l\\', \\'u\\').\\n\\nAssuming m represents the number of rows in the matrix and n represents the number of columns, the worst-case scenario for time complexity is when the DFS function is called for every cell in the matrix. In this case, the time complexity would be O(m * n), as each cell is visited once.\\n\\nSpace Complexity:\\nThe space complexity of the code is primarily determined by the space used for the res matrix. The matrix requires m * n space to store the integer values. Additionally, the recursive DFS calls consume space on the call stack.\\n\\nIn the worst case, when all cells in the res matrix are traversed using DFS and the call stack is fully utilized, the space complexity would be O(m * n + max_depth_of_DFS), where max_depth_of_DFS is the maximum depth of recursion in the DFS calls. In this case, it\\'s worth noting that the DFS recursion depth depends on the dimensions of the matrix and the length of the linked list (head).\\n\\nHowever, it\\'s important to mention that due to the depth-first nature of the traversal, the actual maximum recursion depth might not be as deep as it might seem. It could be constrained by the dimensions of the matrix and the number of elements in the linked list.\\n\\n- Time complexity:\\nO(m * n)\\n\\n- Space complexity:\\nO(m * n +max_depth_of_DFS)\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     public int val;\\n *     public ListNode next;\\n *     public ListNode(int val=0, ListNode next=null) {\\n *         this.val = val;\\n *         this.next = next;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    bool IsHeaderNull = false;\\n    public int[][] SpiralMatrix(int m, int n, ListNode head) {\\n        int[][] res = new int[m][];\\n        \\n        for(int i = 0 ; i < m;i++){\\n            res[i] = new int[n];\\n            for(int j = 0; j < n ;j++){\\n                res[i][j] = -1;\\n            }\\n        }\\n\\n        DFS(res,0,0,head,\\'r\\');\\n        \\n        return res;\\n    }\\n\\n    void DFS(int[][] res,int x, int y, ListNode head, char dir ){\\n        if(x < 0 || y < 0 || y >= res.Length || x >= res[0].Length || head == null || res[y][x] != -1 || IsHeaderNull){\\n            if(head == null){\\n                IsHeaderNull = true;\\n            }\\n            return;\\n        }\\n\\n        res[y][x] = head.val;\\n        if(dir == \\'u\\'){\\n            DFS(res,x,y-1,head.next,\\'u\\');\\n        }\\n        DFS(res,x+1,y,head.next,\\'r\\');\\n        DFS(res,x,y+1,head.next,\\'d\\');\\n        DFS(res,x-1,y,head.next,\\'l\\');\\n        DFS(res,x,y-1,head.next,\\'u\\');\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     public int val;\\n *     public ListNode next;\\n *     public ListNode(int val=0, ListNode next=null) {\\n *         this.val = val;\\n *         this.next = next;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    bool IsHeaderNull = false;\\n    public int[][] SpiralMatrix(int m, int n, ListNode head) {\\n        int[][] res = new int[m][];\\n        \\n        for(int i = 0 ; i < m;i++){\\n            res[i] = new int[n];\\n            for(int j = 0; j < n ;j++){\\n                res[i][j] = -1;\\n            }\\n        }\\n\\n        DFS(res,0,0,head,\\'r\\');\\n        \\n        return res;\\n    }\\n\\n    void DFS(int[][] res,int x, int y, ListNode head, char dir ){\\n        if(x < 0 || y < 0 || y >= res.Length || x >= res[0].Length || head == null || res[y][x] != -1 || IsHeaderNull){\\n            if(head == null){\\n                IsHeaderNull = true;\\n            }\\n            return;\\n        }\\n\\n        res[y][x] = head.val;\\n        if(dir == \\'u\\'){\\n            DFS(res,x,y-1,head.next,\\'u\\');\\n        }\\n        DFS(res,x+1,y,head.next,\\'r\\');\\n        DFS(res,x,y+1,head.next,\\'d\\');\\n        DFS(res,x-1,y,head.next,\\'l\\');\\n        DFS(res,x,y-1,head.next,\\'u\\');\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3903550,
                "title": "c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        int minr = 0, maxr = m - 1, minc = 0, maxc = n - 1;\\n        \\n        vector<vector<int>> arr(m, vector<int>(n, -1));\\n        ListNode* temp = head;\\n\\n        while (minc <= maxc && minr <= maxr) {\\n            // Moving right\\n            for (int i = minc; i <= maxc ; i++) {\\n                if (temp == NULL) return arr;\\n                arr[minr][i] = temp->val;\\n                temp = temp->next;\\n            }\\n            minr++;\\n\\n            // Moving down\\n            for (int i = minr; i <= maxr; i++) {\\n                if (temp == NULL) return arr;\\n                arr[i][maxc] = temp->val;\\n                temp = temp->next;\\n            }\\n            maxc--;\\n\\n            // Moving left\\n            if (minr <= maxr) { // Check added\\n                for (int i = maxc; i >= minc ; i--) {\\n                    if (temp == NULL) return arr;\\n                    arr[maxr][i] = temp->val;\\n                    temp = temp->next;\\n                }\\n                maxr--;\\n            }\\n\\n            // Moving up\\n            if (minc <= maxc) { // Check added\\n                for (int i = maxr; i >= minr ; i--) {\\n                    if (temp == NULL) return arr;\\n                    arr[i][minc] = temp->val;\\n                    temp = temp->next;\\n                }\\n                minc++;\\n            }\\n        }\\n\\n        return arr;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        int minr = 0, maxr = m - 1, minc = 0, maxc = n - 1;\\n        \\n        vector<vector<int>> arr(m, vector<int>(n, -1));\\n        ListNode* temp = head;\\n\\n        while (minc <= maxc && minr <= maxr) {\\n            // Moving right\\n            for (int i = minc; i <= maxc ; i++) {\\n                if (temp == NULL) return arr;\\n                arr[minr][i] = temp->val;\\n                temp = temp->next;\\n            }\\n            minr++;\\n\\n            // Moving down\\n            for (int i = minr; i <= maxr; i++) {\\n                if (temp == NULL) return arr;\\n                arr[i][maxc] = temp->val;\\n                temp = temp->next;\\n            }\\n            maxc--;\\n\\n            // Moving left\\n            if (minr <= maxr) { // Check added\\n                for (int i = maxc; i >= minc ; i--) {\\n                    if (temp == NULL) return arr;\\n                    arr[maxr][i] = temp->val;\\n                    temp = temp->next;\\n                }\\n                maxr--;\\n            }\\n\\n            // Moving up\\n            if (minc <= maxc) { // Check added\\n                for (int i = maxr; i >= minr ; i--) {\\n                    if (temp == NULL) return arr;\\n                    arr[i][minc] = temp->val;\\n                    temp = temp->next;\\n                }\\n                minc++;\\n            }\\n        }\\n\\n        return arr;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3899710,
                "title": "top-left-right-bottom-pointer-approach-using-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public int[][] spiralMatrix(int m, int n, ListNode head) {\\n        int result[][]=new int[m][n];\\n        int left=0;\\n        int right=n-1;\\n        int top=0;\\n        int bottom=m-1;\\n        ListNode temp=head;\\n        while(left<=right && top<=bottom)\\n        {    \\n\\n        for(int i=left;i<=right;i++)\\n        {\\n            if(temp!=null)\\n            {\\n                result[top][i]=temp.val;\\n                temp=temp.next;\\n            }\\n            else{\\n                result[top][i]=-1;\\n            }\\n        }\\n    \\n        top++;\\n        for(int j=top;j<=bottom;j++)\\n        {\\n            if(temp!=null)\\n            {\\n                result[j][right]=temp.val;\\n                temp=temp.next;\\n            }\\n            else{\\n                result[j][right]=-1;\\n            }\\n        }\\n        right--;\\n        if(top<=bottom)\\n        {\\n\\n        for(int x=right;x>=left;x--)\\n        {\\n            if(temp!=null)\\n            {\\n                result[bottom][x]=temp.val;\\n                temp=temp.next;\\n            }\\n            else{\\n                result[bottom][x]=-1;\\n            }\\n        }\\n        bottom--;\\n        }\\n\\n        if(left<=right)\\n        {\\n        for(int w=bottom;w>=top;w--)\\n        {\\n            if(temp!=null)\\n            {\\n                result[w][left]=temp.val;\\n                temp=temp.next;\\n            }\\n            else{\\n                result[w][left]=-1;\\n            }\\n        }\\n        left++;\\n        }\\n        }\\n\\n        return result;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public int[][] spiralMatrix(int m, int n, ListNode head) {\\n        int result[][]=new int[m][n];\\n        int left=0;\\n        int right=n-1;\\n        int top=0;\\n        int bottom=m-1;\\n        ListNode temp=head;\\n        while(left<=right && top<=bottom)\\n        {    \\n\\n        for(int i=left;i<=right;i++)\\n        {\\n            if(temp!=null)\\n            {\\n                result[top][i]=temp.val;\\n                temp=temp.next;\\n            }\\n            else{\\n                result[top][i]=-1;\\n            }\\n        }\\n    \\n        top++;\\n        for(int j=top;j<=bottom;j++)\\n        {\\n            if(temp!=null)\\n            {\\n                result[j][right]=temp.val;\\n                temp=temp.next;\\n            }\\n            else{\\n                result[j][right]=-1;\\n            }\\n        }\\n        right--;\\n        if(top<=bottom)\\n        {\\n\\n        for(int x=right;x>=left;x--)\\n        {\\n            if(temp!=null)\\n            {\\n                result[bottom][x]=temp.val;\\n                temp=temp.next;\\n            }\\n            else{\\n                result[bottom][x]=-1;\\n            }\\n        }\\n        bottom--;\\n        }\\n\\n        if(left<=right)\\n        {\\n        for(int w=bottom;w>=top;w--)\\n        {\\n            if(temp!=null)\\n            {\\n                result[w][left]=temp.val;\\n                temp=temp.next;\\n            }\\n            else{\\n                result[w][left]=-1;\\n            }\\n        }\\n        left++;\\n        }\\n        }\\n\\n        return result;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3893196,
                "title": "c-matrix-simulation",
                "content": "\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        vector<vector<int>> ans(m,vector<int>(n,-1));\\n        int left = 0,right = n-1,top = 0,bottom = m-1,dir = 0;\\n        ListNode* tmp = head;\\n        while(left<=right && top<=bottom)\\n        {\\n            if(dir==0)\\n            {\\n                for(int i=left;i<=right;i++)\\n                {\\n                    if(tmp!=NULL)\\n                    {\\n                        ans[top][i] = tmp->val;\\n                        tmp = tmp->next;\\n                    }\\n                }\\n                top++;\\n                dir = (dir+1)%4;\\n            }\\n            else if(dir==1)\\n            {\\n                for(int i=top;i<=bottom;i++)\\n                {\\n                    if(tmp!=NULL)\\n                    {\\n                        ans[i][right] = tmp->val;\\n                        tmp = tmp->next;\\n                    }\\n                }\\n                right--;\\n                dir = (dir+1)%4;\\n            }\\n            else if(dir==2)\\n            {\\n                for(int i=right;i>=left;i--)\\n                {\\n                    if(tmp!=NULL)\\n                    {\\n                        ans[bottom][i] = tmp->val;\\n                        tmp = tmp->next;\\n                    }\\n                }\\n                bottom--;\\n                dir = (dir+1)%4;\\n            }\\n            else if(dir==3)\\n            {\\n                for(int i=bottom;i>=top;i--)\\n                {\\n                    if(tmp!=NULL)\\n                    {\\n                        ans[i][left] = tmp->val;\\n                        tmp = tmp->next;\\n                    }\\n                }\\n                left++;\\n                dir = (dir+1)%4;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Matrix",
                    "Simulation"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        vector<vector<int>> ans(m,vector<int>(n,-1));\\n        int left = 0,right = n-1,top = 0,bottom = m-1,dir = 0;\\n        ListNode* tmp = head;\\n        while(left<=right && top<=bottom)\\n        {\\n            if(dir==0)\\n            {\\n                for(int i=left;i<=right;i++)\\n                {\\n                    if(tmp!=NULL)\\n                    {\\n                        ans[top][i] = tmp->val;\\n                        tmp = tmp->next;\\n                    }\\n                }\\n                top++;\\n                dir = (dir+1)%4;\\n            }\\n            else if(dir==1)\\n            {\\n                for(int i=top;i<=bottom;i++)\\n                {\\n                    if(tmp!=NULL)\\n                    {\\n                        ans[i][right] = tmp->val;\\n                        tmp = tmp->next;\\n                    }\\n                }\\n                right--;\\n                dir = (dir+1)%4;\\n            }\\n            else if(dir==2)\\n            {\\n                for(int i=right;i>=left;i--)\\n                {\\n                    if(tmp!=NULL)\\n                    {\\n                        ans[bottom][i] = tmp->val;\\n                        tmp = tmp->next;\\n                    }\\n                }\\n                bottom--;\\n                dir = (dir+1)%4;\\n            }\\n            else if(dir==3)\\n            {\\n                for(int i=bottom;i>=top;i--)\\n                {\\n                    if(tmp!=NULL)\\n                    {\\n                        ans[i][left] = tmp->val;\\n                        tmp = tmp->next;\\n                    }\\n                }\\n                left++;\\n                dir = (dir+1)%4;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3887759,
                "title": "c-short-95-84-faster-simple-code-beginner-friendly",
                "content": "![Spiral Matrix IV stats.jpg](https://assets.leetcode.com/users/images/a5faf6ef-1ff2-453b-a93c-cab8541028ec_1691608455.8859637.jpeg)\\n\\n\\n# Approach\\n- We declare a 2D matrix of size m * n initialized with -1.\\n- Set limits ```left=0``` , ```right=n-1```, ```up=1``` and ```down=m-1```\\n- First row is (u=0) is done, hence u=0+1=1\\n- \" ALL LIMITS ARE INCLUSIVE\"\\n- Go till ```head!=NULL```\\n- go right, then update r limit and increase i at the end\\n- go down, then update d limit and decrease j at the end\\n- go right, then update r limit and increase i at the end\\n- go right, then update r limit and increase i at the end\\n\\n# ! ! - -  Note - - ! !\\nWe don\\'t need to check if ```ans[i][j]==1``` as we are declaring limits and updating the limits, hence checking for -1 is not required.\\n\\n# Complexity\\n- Time complexity : O(number of nodes) = O( m * n )\\n\\n- Space complexity : O(number of nodes) = O( m * n )\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        vector<vector<int>> ans(m, vector<int>(n, -1)); // initialize matrix with -1\\n        int i=0, j=0; // declare traversal indices\\n\\n        // set limits left , right, up and down \" ALL ARE INCLUSIVE\"\\n        int l=0, r=n-1, u=1, d=m-1; // first row (u=0) is done, hence u=1\\n\\n        while(head){ // go on till head is not NULL\\n\\n            while(head && j<=r){ // go right in the same row (i, j++)\\n                ans[i][j]=head->val;\\n                head=head->next;\\n                if(j==r) {\\n                    r--;\\n                    i++; // go clockwise\\n                    break;\\n                }\\n                else j++; // continue in the same row\\n            }\\n            while(head && i<=d){ // go down in the same column (i++, j)\\n                ans[i][j]=head->val;\\n                head=head->next;\\n                if(i==d) {\\n                    d--;\\n                    j--; // go clockwise\\n                    break;\\n                }\\n                else i++; // continue in the same column\\n            }\\n            while(head && j>=l){ // go left in the same row (i, j--)\\n                ans[i][j]=head->val;\\n                head=head->next;\\n                if(j==l) {\\n                    l++;\\n                    i--; // go clockwise\\n                    break;\\n                }\\n                else j--; // continue in the same row\\n            }\\n            while(head && i>=u) { // go up in the same column (i++, j)\\n                ans[i][j]=head->val;\\n                head=head->next;\\n                if(i==u) {\\n                    u++;\\n                    j++; // go clockwise\\n                    break;\\n                }\\n                else i--; // continue in the same column\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Matrix"
                ],
                "code": "```left=0```\n```right=n-1```\n```up=1```\n```down=m-1```\n```head!=NULL```\n```ans[i][j]==1```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        vector<vector<int>> ans(m, vector<int>(n, -1)); // initialize matrix with -1\\n        int i=0, j=0; // declare traversal indices\\n\\n        // set limits left , right, up and down \" ALL ARE INCLUSIVE\"\\n        int l=0, r=n-1, u=1, d=m-1; // first row (u=0) is done, hence u=1\\n\\n        while(head){ // go on till head is not NULL\\n\\n            while(head && j<=r){ // go right in the same row (i, j++)\\n                ans[i][j]=head->val;\\n                head=head->next;\\n                if(j==r) {\\n                    r--;\\n                    i++; // go clockwise\\n                    break;\\n                }\\n                else j++; // continue in the same row\\n            }\\n            while(head && i<=d){ // go down in the same column (i++, j)\\n                ans[i][j]=head->val;\\n                head=head->next;\\n                if(i==d) {\\n                    d--;\\n                    j--; // go clockwise\\n                    break;\\n                }\\n                else i++; // continue in the same column\\n            }\\n            while(head && j>=l){ // go left in the same row (i, j--)\\n                ans[i][j]=head->val;\\n                head=head->next;\\n                if(j==l) {\\n                    l++;\\n                    i--; // go clockwise\\n                    break;\\n                }\\n                else j--; // continue in the same row\\n            }\\n            while(head && i>=u) { // go up in the same column (i++, j)\\n                ans[i][j]=head->val;\\n                head=head->next;\\n                if(i==u) {\\n                    u++;\\n                    j++; // go clockwise\\n                    break;\\n                }\\n                else i--; // continue in the same column\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3880438,
                "title": "c-clean-traversal-easy",
                "content": "\\n\\n# Code\\n```\\n\\nclass Solution {\\npublic:int d=1;int c=0;\\n    void t(int i,int j,vector<vector<int>> &a,vector<int>& v)\\n    {\\n          if(c>=v.size()) return ;\\n          if(i<0 || j<0 || i>=a.size() || j>=a[0].size() || a[i][j]!=-1)\\n          {\\n              if(d==1) j--,d=2;\\n              else if(d==2) i--,d=3;\\n              else if(d==3) j++,d=4;\\n              else i++,d=1;\\n          }\\n          else\\n              a[i][j]=v[c++];\\n          \\n          if(d==1) t(i,j+1,a,v);\\n          else if(d==2) t(i+1,j,a,v);\\n          else if(d==3) t(i,j-1,a,v);\\n          else if(d==4) t(i-1,j,a,v);\\n    }\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* h) {\\n        vector<int> v;\\n        while(h)\\n        {\\n            v.push_back(h->val);\\n            h=h->next;\\n        }\\n        vector<vector<int>> a(m,vector<int> (n,-1));\\n        t(0,0,a,v);\\n        return a;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:int d=1;int c=0;\\n    void t(int i,int j,vector<vector<int>> &a,vector<int>& v)\\n    {\\n          if(c>=v.size()) return ;\\n          if(i<0 || j<0 || i>=a.size() || j>=a[0].size() || a[i][j]!=-1)\\n          {\\n              if(d==1) j--,d=2;\\n              else if(d==2) i--,d=3;\\n              else if(d==3) j++,d=4;\\n              else i++,d=1;\\n          }\\n          else\\n              a[i][j]=v[c++];\\n          \\n          if(d==1) t(i,j+1,a,v);\\n          else if(d==2) t(i+1,j,a,v);\\n          else if(d==3) t(i,j-1,a,v);\\n          else if(d==4) t(i-1,j,a,v);\\n    }\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* h) {\\n        vector<int> v;\\n        while(h)\\n        {\\n            v.push_back(h->val);\\n            h=h->next;\\n        }\\n        vector<vector<int>> a(m,vector<int> (n,-1));\\n        t(0,0,a,v);\\n        return a;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3859046,
                "title": "javascript-solution-runtime-100-00-memory-57-14",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nI started by creating a prefilled matrix with -1 so that I don\\'t have to worry about inserting it in later.\\n\\nI assigned each corner of the matrix a pointer: top, right, left, bottom. \\n\\nI loop through each value within the linked list.\\n\\nIf you look at my comments in the code, I sweep the top row from left to right (top row is done so top++), then the right column from top to bottom (right column is done so right--), bottom row from right to left (bottom row is done so bottom--), then the left most column from bottom to top (left column is done so left++).\\n\\nThe above step repeats until the end of the list is reached.\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val, next) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.next = (next===undefined ? null : next)\\n * }\\n */\\n/**\\n * @param {number} m\\n * @param {number} n\\n * @param {ListNode} head\\n * @return {number[][]}\\n */\\nvar spiralMatrix = function(m, n, head) {\\n    let top = 0;\\n    let right = n - 1;\\n    let bottom = m - 1;\\n    let left = 0;\\n    // Create an empty array with n sub arrays that are unique. new Array(m).fill(new Array(n).fill(-1)) doesn\\'t work since all sub arrays have the same pointer.\\n    let spiralMatrix = new Array(m).fill().map(() => new Array(n).fill(-1));   \\n    \\n    while(head != null) {   \\n        // Sweep left to right on top\\n        for(let i = left; i <= right && head != null; i++) {\\n            spiralMatrix[top][i] = head.val;\\n            head = head.next;\\n        }\\n        top++;\\n\\n        // Sweep top to bottom on right\\n        for(let i = top; i <= bottom && head != null; i++) {\\n            spiralMatrix[i][right] = head.val;\\n            head = head.next;\\n        }\\n        right--;\\n\\n        // Sweep right to left on bottom\\n        for(let i = right; i >= left && head != null; i--) {\\n            spiralMatrix[bottom][i] = head.val;\\n            head = head.next;\\n        }\\n        bottom--;\\n\\n        // Sweep bottom to top on left\\n        for(let i = bottom; i >= top && head != null; i--) {\\n            spiralMatrix[i][left] = head.val;\\n            head = head.next;\\n        }\\n        left++;\\n\\n    }\\n    \\n    return spiralMatrix;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val, next) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.next = (next===undefined ? null : next)\\n * }\\n */\\n/**\\n * @param {number} m\\n * @param {number} n\\n * @param {ListNode} head\\n * @return {number[][]}\\n */\\nvar spiralMatrix = function(m, n, head) {\\n    let top = 0;\\n    let right = n - 1;\\n    let bottom = m - 1;\\n    let left = 0;\\n    // Create an empty array with n sub arrays that are unique. new Array(m).fill(new Array(n).fill(-1)) doesn\\'t work since all sub arrays have the same pointer.\\n    let spiralMatrix = new Array(m).fill().map(() => new Array(n).fill(-1));   \\n    \\n    while(head != null) {   \\n        // Sweep left to right on top\\n        for(let i = left; i <= right && head != null; i++) {\\n            spiralMatrix[top][i] = head.val;\\n            head = head.next;\\n        }\\n        top++;\\n\\n        // Sweep top to bottom on right\\n        for(let i = top; i <= bottom && head != null; i++) {\\n            spiralMatrix[i][right] = head.val;\\n            head = head.next;\\n        }\\n        right--;\\n\\n        // Sweep right to left on bottom\\n        for(let i = right; i >= left && head != null; i--) {\\n            spiralMatrix[bottom][i] = head.val;\\n            head = head.next;\\n        }\\n        bottom--;\\n\\n        // Sweep bottom to top on left\\n        for(let i = bottom; i >= top && head != null; i--) {\\n            spiralMatrix[i][left] = head.val;\\n            head = head.next;\\n        }\\n        left++;\\n\\n    }\\n    \\n    return spiralMatrix;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3855145,
                "title": "java-faster-than-99",
                "content": "Personally this solution is gross looking, and I wouldn\\'t enjoy troubleshooting it, but it\\'s important to not use Arrays.fill() in the function because you escalate the time from O(mn) to O(2(mn)).  This won\\'t drop your performance in actual big O terms, but will make your solution faster than around 50% instead of faster than 99%.  \\n\\nI couldn\\'t get the last 1%.  Whatever, good enough.\\n\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public int[][] spiralMatrix(int m, int n, ListNode head) {\\n        int[][] ans = new int[m][n];\\n        int total = m * n;\\n        int current = 0; \\n        int minRow = 0;\\n        int maxRow = m-1;\\n        int minCol = 0;\\n        int maxCol = n-1; \\n        while(current < total) {\\n            // RIGHT\\n            for(int r = minRow, c = minCol; c <= maxCol; c++) {\\n                if(head != null) {\\n                    ans[r][c] = head.val;\\n                    head = head.next; \\n                }\\n                else {\\n                    ans[r][c] = -1;\\n                }\\n                current++;\\n            }\\n            minRow++; \\n            if(current >= total) break; \\n            \\n            // DOWN\\n            for(int r = minRow, c = maxCol; r <= maxRow; r++) {\\n                if(head != null) {\\n                    ans[r][c] = head.val;\\n                    head = head.next; \\n                }\\n                else {\\n                    ans[r][c] = -1;\\n                }\\n                current++;\\n            }\\n            maxCol--; \\n            if(current >= total) break; \\n            \\n            // LEFT\\n            for(int r = maxRow, c = maxCol; c >= minCol; c--) {\\n                if(head != null) {\\n                    ans[r][c] = head.val;\\n                    head = head.next; \\n                }\\n                else {\\n                    ans[r][c] = -1;\\n                }\\n                current++;\\n            }\\n            maxRow--; \\n            if(current >= total) break; \\n            \\n            \\n            \\n            // UP\\n            for(int r = maxRow, c = minCol; r >= minRow; r--) {\\n                if(head != null) {\\n                    ans[r][c] = head.val;\\n                    head = head.next; \\n                }\\n                else {\\n                    ans[r][c] = -1;\\n                }\\n                current++;\\n            }\\n            minCol++; \\n            \\n        }\\n        \\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public int[][] spiralMatrix(int m, int n, ListNode head) {\\n        int[][] ans = new int[m][n];\\n        int total = m * n;\\n        int current = 0; \\n        int minRow = 0;\\n        int maxRow = m-1;\\n        int minCol = 0;\\n        int maxCol = n-1; \\n        while(current < total) {\\n            // RIGHT\\n            for(int r = minRow, c = minCol; c <= maxCol; c++) {\\n                if(head != null) {\\n                    ans[r][c] = head.val;\\n                    head = head.next; \\n                }\\n                else {\\n                    ans[r][c] = -1;\\n                }\\n                current++;\\n            }\\n            minRow++; \\n            if(current >= total) break; \\n            \\n            // DOWN\\n            for(int r = minRow, c = maxCol; r <= maxRow; r++) {\\n                if(head != null) {\\n                    ans[r][c] = head.val;\\n                    head = head.next; \\n                }\\n                else {\\n                    ans[r][c] = -1;\\n                }\\n                current++;\\n            }\\n            maxCol--; \\n            if(current >= total) break; \\n            \\n            // LEFT\\n            for(int r = maxRow, c = maxCol; c >= minCol; c--) {\\n                if(head != null) {\\n                    ans[r][c] = head.val;\\n                    head = head.next; \\n                }\\n                else {\\n                    ans[r][c] = -1;\\n                }\\n                current++;\\n            }\\n            maxRow--; \\n            if(current >= total) break; \\n            \\n            \\n            \\n            // UP\\n            for(int r = maxRow, c = minCol; r >= minRow; r--) {\\n                if(head != null) {\\n                    ans[r][c] = head.val;\\n                    head = head.next; \\n                }\\n                else {\\n                    ans[r][c] = -1;\\n                }\\n                current++;\\n            }\\n            minCol++; \\n            \\n        }\\n        \\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3854852,
                "title": "c-98-3-fast-96-less-memory-easy",
                "content": "\\n\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        vector<vector<int>> ans(m,vector<int> (n,-1));\\n        \\n        int i=0,j=0;\\n        while(head){\\n            for(int a=i;a<n&&head;a++){\\n                ans[j][a]=head->val;\\n                head=head->next;\\n            }\\n             j++;\\n             for(int a=j;a<m&&head;a++){\\n                 ans[a][n-1]=head->val;\\n                 head=head->next;\\n             }\\n            n--;\\n            for(int a=n-1;a>=i&&head;a--){\\n                ans[m-1][a]=head->val;\\n                head=head->next;\\n            }\\n            m--;\\n            for(int a=m-1;a>=j&&head;a--){\\n                ans[a][i]=head->val;\\n                head=head->next;\\n            }\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {\\n        vector<vector<int>> ans(m,vector<int> (n,-1));\\n        \\n        int i=0,j=0;\\n        while(head){\\n            for(int a=i;a<n&&head;a++){\\n                ans[j][a]=head->val;\\n                head=head->next;\\n            }\\n             j++;\\n             for(int a=j;a<m&&head;a++){\\n                 ans[a][n-1]=head->val;\\n                 head=head->next;\\n             }\\n            n--;\\n            for(int a=n-1;a>=i&&head;a--){\\n                ans[m-1][a]=head->val;\\n                head=head->next;\\n            }\\n            m--;\\n            for(int a=m-1;a>=j&&head;a--){\\n                ans[a][i]=head->val;\\n                head=head->next;\\n            }\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3849881,
                "title": "100-fast-and-very-simple-java-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\njust traverse the 2D matrix with linkedlist and while traversing some conditions should be in the mind.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(mn)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public int[][] spiralMatrix(int m, int n, ListNode head) {\\n        int[][] arr = new int[m][n];\\n        Arrays.stream(arr).forEach(A -> Arrays.fill(A, -1));\\n        int minr = 0 , minc = 0, maxr = m-1,maxc = n-1;\\n        int c =0, t = m*n;\\n        while(c < t && head != null){\\n            for(int i = minr , j = minc ; j <= maxc && c < t; j++){\\n                if (head != null){\\n                    arr[i][j] = head.val;\\n                    head = head.next;\\n                }\\n                c++;\\n            }\\n            minr++;\\n\\n            for(int i = minr , j = maxc ; i <= maxr && c < t; i++){\\n                if (head != null){\\n                    arr[i][j] = head.val;\\n                    head = head.next;\\n                }\\n                c++;\\n            }\\n            maxc--;\\n            for(int i = maxr , j = maxc ; j >= minc && c < t; j--){\\n                if (head != null){\\n                    arr[i][j] = head.val;\\n                    head = head.next;\\n                }\\n                c++;\\n            }\\n            maxr--;\\n\\n            for(int i = maxr , j = minc ; i>=minr && c < t; i--){\\n                if (head != null){\\n                    arr[i][j] = head.val;\\n                    head = head.next;\\n                }\\n                c++;\\n            }\\n            minc++;\\n\\n\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Linked List",
                    "Matrix"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public int[][] spiralMatrix(int m, int n, ListNode head) {\\n        int[][] arr = new int[m][n];\\n        Arrays.stream(arr).forEach(A -> Arrays.fill(A, -1));\\n        int minr = 0 , minc = 0, maxr = m-1,maxc = n-1;\\n        int c =0, t = m*n;\\n        while(c < t && head != null){\\n            for(int i = minr , j = minc ; j <= maxc && c < t; j++){\\n                if (head != null){\\n                    arr[i][j] = head.val;\\n                    head = head.next;\\n                }\\n                c++;\\n            }\\n            minr++;\\n\\n            for(int i = minr , j = maxc ; i <= maxr && c < t; i++){\\n                if (head != null){\\n                    arr[i][j] = head.val;\\n                    head = head.next;\\n                }\\n                c++;\\n            }\\n            maxc--;\\n            for(int i = maxr , j = maxc ; j >= minc && c < t; j--){\\n                if (head != null){\\n                    arr[i][j] = head.val;\\n                    head = head.next;\\n                }\\n                c++;\\n            }\\n            maxr--;\\n\\n            for(int i = maxr , j = minc ; i>=minr && c < t; i--){\\n                if (head != null){\\n                    arr[i][j] = head.val;\\n                    head = head.next;\\n                }\\n                c++;\\n            }\\n            minc++;\\n\\n\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3843792,
                "title": "kotlin-solution-only-while-loops",
                "content": "# Code\\n```\\nclass Solution {\\n    fun spiralMatrix(m: Int, n: Int, head: ListNode?): Array<IntArray> {\\n        val result = Array(m) { IntArray(n) }\\n        var lastRowCol = 0\\n        var cellCounter = 0\\n        var current = head\\n\\n        while (cellCounter < m * n) {\\n            var row = lastRowCol\\n            var col = lastRowCol\\n\\n            // Go right\\n            while (col < n - lastRowCol && cellCounter < m * n) {\\n                result[row][col] = current?.`val` ?: -1\\n                current = current?.next\\n                cellCounter++\\n                col++\\n            }\\n\\n            col--\\n            row++\\n\\n            // Go down\\n            while (row < m - lastRowCol && cellCounter < m * n) {\\n                result[row][col] = current?.`val` ?: -1\\n                current = current?.next\\n                cellCounter++\\n                row++\\n            }\\n\\n            col--\\n            row--\\n\\n            // Go left\\n            while (col >= lastRowCol && cellCounter < m * n) {\\n                result[row][col] = current?.`val` ?: -1\\n                current = current?.next\\n                cellCounter++\\n                col--\\n            }\\n\\n            col++\\n            row--\\n\\n            // Go up\\n            while (row > lastRowCol && cellCounter < m * n) {\\n                result[row][col] = current?.`val` ?: -1\\n                current = current?.next\\n                cellCounter++\\n                row--\\n            }\\n\\n            lastRowCol++\\n        }\\n\\n        return result\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun spiralMatrix(m: Int, n: Int, head: ListNode?): Array<IntArray> {\\n        val result = Array(m) { IntArray(n) }\\n        var lastRowCol = 0\\n        var cellCounter = 0\\n        var current = head\\n\\n        while (cellCounter < m * n) {\\n            var row = lastRowCol\\n            var col = lastRowCol\\n\\n            // Go right\\n            while (col < n - lastRowCol && cellCounter < m * n) {\\n                result[row][col] = current?.`val` ?: -1\\n                current = current?.next\\n                cellCounter++\\n                col++\\n            }\\n\\n            col--\\n            row++\\n\\n            // Go down\\n            while (row < m - lastRowCol && cellCounter < m * n) {\\n                result[row][col] = current?.`val` ?: -1\\n                current = current?.next\\n                cellCounter++\\n                row++\\n            }\\n\\n            col--\\n            row--\\n\\n            // Go left\\n            while (col >= lastRowCol && cellCounter < m * n) {\\n                result[row][col] = current?.`val` ?: -1\\n                current = current?.next\\n                cellCounter++\\n                col--\\n            }\\n\\n            col++\\n            row--\\n\\n            // Go up\\n            while (row > lastRowCol && cellCounter < m * n) {\\n                result[row][col] = current?.`val` ?: -1\\n                current = current?.next\\n                cellCounter++\\n                row--\\n            }\\n\\n            lastRowCol++\\n        }\\n\\n        return result\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 2044816,
                "content": [
                    {
                        "username": "whybhanu",
                        "content": "```\\nclass Solution {\\n    public int[][] spiralMatrix(int m, int n, ListNode head) {\\n        int[][] matrix = new int[m][n];\\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++) matrix[i][j] = -1;\\n        }\\n        int top = 0;\\n        int left = 0;\\n        int right = n - 1;\\n        int down = m - 1;\\n        int direction = 0;\\n        while(head != null){\\n            if(direction == 0){\\n                for(int i = left; i <= right && head != null; i++){\\n                    matrix[top][i] = head.val;\\n                    head = head.next;\\n                }\\n                top++;\\n                direction++;\\n            } else if (direction == 1){\\n                for(int j = top; j <= down && head != null; j++){\\n                    matrix[j][right] = head.val;\\n                    head = head.next;\\n                }\\n                right--;\\n                direction++;\\n            } else if(direction == 2){\\n                for(int i = right; i >= left && head != null; i--){\\n                    matrix[down][i] = head.val;\\n                    head = head.next;\\n                }\\n                down--;\\n                direction++;\\n            } else {\\n                for(int i = down; i >= top && head != null; i--){\\n                    matrix[i][left] = head.val;\\n                    head = head.next;\\n                }\\n                left++;\\n                direction = 0;\\n            }\\n        }\\n        return matrix;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "shevartsoft",
                        "content": "so stupid - show it to you mother instead of publishing this code in Discussion panel"
                    },
                    {
                        "username": "kdev307",
                        "content": "The base of the given Spiral Matrix Problem is similar to the problem Spiral Matrix II. With an add-on that here we\\'re given with a linked list which stores the values of the elements of matrix.\\n  We just have to check if the head is  NULL or not at every iteration, elsewise whole methodology is similar."
                    },
                    {
                        "username": "jblee1152",
                        "content": "what is the difference between those two code snippets?\\nmatrix = [[-1 for _ in range(n)] for _ in range(m)]\\nmatrix = [[-1] * n] * m\\nThey surely return the same matrix superficially, but is there anything here in the system level?\\nThe former works but using the latter for my code doesn\\'t work"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "[@emrecoltu](/emrecoltu) Thinks for the explanation. I used the seconde one and my code doesn\\'t work. Using print() function, I print the id() of each row and I noticed that all the rows have the same reference (id())."
                    },
                    {
                        "username": "emrecoltu",
                        "content": "First one creates a new list for every row. Second one uses the first row to create other rows by reference. Every change you do on a row on the second one will also affects rest of the rows."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "mohit1412",
                        "content": "        int mat[][] = new int[m][n];\\n        for(int row[] : mat) Arrays.fill(row,-1);\\n        \\n        if(head == null) return mat;\\n\\n        int i = 0 , j = 0;\\n        int row = 0,col =0;\\n        ListNode cur = head;\\n        while(cur != null){\\n\\n            while(j<n){\\n       24-> mat[i][j] = cur.val;\\n                cur = cur.next;\\n                j++;\\n            }\\n            i++;j--; row++;\\n\\n\\njava.lang.NullPointerException: Cannot read field \"val\" because \"<local9>\" is null\\n  at line 24, Solution.spiralMatrix\\n  at line 54, __DriverSolution__.__helper__\\n  at line 90, __Driver__.main\\n\\nReceiving the above error. Is there something wrong with the code."
                    },
                    {
                        "username": "rajmohit7114",
                        "content": "with this approach , how will you insert element in last row and first column.?\\n"
                    }
                ]
            },
            {
                "id": 1889118,
                "content": [
                    {
                        "username": "whybhanu",
                        "content": "```\\nclass Solution {\\n    public int[][] spiralMatrix(int m, int n, ListNode head) {\\n        int[][] matrix = new int[m][n];\\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++) matrix[i][j] = -1;\\n        }\\n        int top = 0;\\n        int left = 0;\\n        int right = n - 1;\\n        int down = m - 1;\\n        int direction = 0;\\n        while(head != null){\\n            if(direction == 0){\\n                for(int i = left; i <= right && head != null; i++){\\n                    matrix[top][i] = head.val;\\n                    head = head.next;\\n                }\\n                top++;\\n                direction++;\\n            } else if (direction == 1){\\n                for(int j = top; j <= down && head != null; j++){\\n                    matrix[j][right] = head.val;\\n                    head = head.next;\\n                }\\n                right--;\\n                direction++;\\n            } else if(direction == 2){\\n                for(int i = right; i >= left && head != null; i--){\\n                    matrix[down][i] = head.val;\\n                    head = head.next;\\n                }\\n                down--;\\n                direction++;\\n            } else {\\n                for(int i = down; i >= top && head != null; i--){\\n                    matrix[i][left] = head.val;\\n                    head = head.next;\\n                }\\n                left++;\\n                direction = 0;\\n            }\\n        }\\n        return matrix;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "shevartsoft",
                        "content": "so stupid - show it to you mother instead of publishing this code in Discussion panel"
                    },
                    {
                        "username": "kdev307",
                        "content": "The base of the given Spiral Matrix Problem is similar to the problem Spiral Matrix II. With an add-on that here we\\'re given with a linked list which stores the values of the elements of matrix.\\n  We just have to check if the head is  NULL or not at every iteration, elsewise whole methodology is similar."
                    },
                    {
                        "username": "jblee1152",
                        "content": "what is the difference between those two code snippets?\\nmatrix = [[-1 for _ in range(n)] for _ in range(m)]\\nmatrix = [[-1] * n] * m\\nThey surely return the same matrix superficially, but is there anything here in the system level?\\nThe former works but using the latter for my code doesn\\'t work"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "[@emrecoltu](/emrecoltu) Thinks for the explanation. I used the seconde one and my code doesn\\'t work. Using print() function, I print the id() of each row and I noticed that all the rows have the same reference (id())."
                    },
                    {
                        "username": "emrecoltu",
                        "content": "First one creates a new list for every row. Second one uses the first row to create other rows by reference. Every change you do on a row on the second one will also affects rest of the rows."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "mohit1412",
                        "content": "        int mat[][] = new int[m][n];\\n        for(int row[] : mat) Arrays.fill(row,-1);\\n        \\n        if(head == null) return mat;\\n\\n        int i = 0 , j = 0;\\n        int row = 0,col =0;\\n        ListNode cur = head;\\n        while(cur != null){\\n\\n            while(j<n){\\n       24-> mat[i][j] = cur.val;\\n                cur = cur.next;\\n                j++;\\n            }\\n            i++;j--; row++;\\n\\n\\njava.lang.NullPointerException: Cannot read field \"val\" because \"<local9>\" is null\\n  at line 24, Solution.spiralMatrix\\n  at line 54, __DriverSolution__.__helper__\\n  at line 90, __Driver__.main\\n\\nReceiving the above error. Is there something wrong with the code."
                    },
                    {
                        "username": "rajmohit7114",
                        "content": "with this approach , how will you insert element in last row and first column.?\\n"
                    }
                ]
            },
            {
                "id": 1852766,
                "content": [
                    {
                        "username": "whybhanu",
                        "content": "```\\nclass Solution {\\n    public int[][] spiralMatrix(int m, int n, ListNode head) {\\n        int[][] matrix = new int[m][n];\\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++) matrix[i][j] = -1;\\n        }\\n        int top = 0;\\n        int left = 0;\\n        int right = n - 1;\\n        int down = m - 1;\\n        int direction = 0;\\n        while(head != null){\\n            if(direction == 0){\\n                for(int i = left; i <= right && head != null; i++){\\n                    matrix[top][i] = head.val;\\n                    head = head.next;\\n                }\\n                top++;\\n                direction++;\\n            } else if (direction == 1){\\n                for(int j = top; j <= down && head != null; j++){\\n                    matrix[j][right] = head.val;\\n                    head = head.next;\\n                }\\n                right--;\\n                direction++;\\n            } else if(direction == 2){\\n                for(int i = right; i >= left && head != null; i--){\\n                    matrix[down][i] = head.val;\\n                    head = head.next;\\n                }\\n                down--;\\n                direction++;\\n            } else {\\n                for(int i = down; i >= top && head != null; i--){\\n                    matrix[i][left] = head.val;\\n                    head = head.next;\\n                }\\n                left++;\\n                direction = 0;\\n            }\\n        }\\n        return matrix;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "shevartsoft",
                        "content": "so stupid - show it to you mother instead of publishing this code in Discussion panel"
                    },
                    {
                        "username": "kdev307",
                        "content": "The base of the given Spiral Matrix Problem is similar to the problem Spiral Matrix II. With an add-on that here we\\'re given with a linked list which stores the values of the elements of matrix.\\n  We just have to check if the head is  NULL or not at every iteration, elsewise whole methodology is similar."
                    },
                    {
                        "username": "jblee1152",
                        "content": "what is the difference between those two code snippets?\\nmatrix = [[-1 for _ in range(n)] for _ in range(m)]\\nmatrix = [[-1] * n] * m\\nThey surely return the same matrix superficially, but is there anything here in the system level?\\nThe former works but using the latter for my code doesn\\'t work"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "[@emrecoltu](/emrecoltu) Thinks for the explanation. I used the seconde one and my code doesn\\'t work. Using print() function, I print the id() of each row and I noticed that all the rows have the same reference (id())."
                    },
                    {
                        "username": "emrecoltu",
                        "content": "First one creates a new list for every row. Second one uses the first row to create other rows by reference. Every change you do on a row on the second one will also affects rest of the rows."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "mohit1412",
                        "content": "        int mat[][] = new int[m][n];\\n        for(int row[] : mat) Arrays.fill(row,-1);\\n        \\n        if(head == null) return mat;\\n\\n        int i = 0 , j = 0;\\n        int row = 0,col =0;\\n        ListNode cur = head;\\n        while(cur != null){\\n\\n            while(j<n){\\n       24-> mat[i][j] = cur.val;\\n                cur = cur.next;\\n                j++;\\n            }\\n            i++;j--; row++;\\n\\n\\njava.lang.NullPointerException: Cannot read field \"val\" because \"<local9>\" is null\\n  at line 24, Solution.spiralMatrix\\n  at line 54, __DriverSolution__.__helper__\\n  at line 90, __Driver__.main\\n\\nReceiving the above error. Is there something wrong with the code."
                    },
                    {
                        "username": "rajmohit7114",
                        "content": "with this approach , how will you insert element in last row and first column.?\\n"
                    }
                ]
            },
            {
                "id": 1763846,
                "content": [
                    {
                        "username": "whybhanu",
                        "content": "```\\nclass Solution {\\n    public int[][] spiralMatrix(int m, int n, ListNode head) {\\n        int[][] matrix = new int[m][n];\\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++) matrix[i][j] = -1;\\n        }\\n        int top = 0;\\n        int left = 0;\\n        int right = n - 1;\\n        int down = m - 1;\\n        int direction = 0;\\n        while(head != null){\\n            if(direction == 0){\\n                for(int i = left; i <= right && head != null; i++){\\n                    matrix[top][i] = head.val;\\n                    head = head.next;\\n                }\\n                top++;\\n                direction++;\\n            } else if (direction == 1){\\n                for(int j = top; j <= down && head != null; j++){\\n                    matrix[j][right] = head.val;\\n                    head = head.next;\\n                }\\n                right--;\\n                direction++;\\n            } else if(direction == 2){\\n                for(int i = right; i >= left && head != null; i--){\\n                    matrix[down][i] = head.val;\\n                    head = head.next;\\n                }\\n                down--;\\n                direction++;\\n            } else {\\n                for(int i = down; i >= top && head != null; i--){\\n                    matrix[i][left] = head.val;\\n                    head = head.next;\\n                }\\n                left++;\\n                direction = 0;\\n            }\\n        }\\n        return matrix;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "shevartsoft",
                        "content": "so stupid - show it to you mother instead of publishing this code in Discussion panel"
                    },
                    {
                        "username": "kdev307",
                        "content": "The base of the given Spiral Matrix Problem is similar to the problem Spiral Matrix II. With an add-on that here we\\'re given with a linked list which stores the values of the elements of matrix.\\n  We just have to check if the head is  NULL or not at every iteration, elsewise whole methodology is similar."
                    },
                    {
                        "username": "jblee1152",
                        "content": "what is the difference between those two code snippets?\\nmatrix = [[-1 for _ in range(n)] for _ in range(m)]\\nmatrix = [[-1] * n] * m\\nThey surely return the same matrix superficially, but is there anything here in the system level?\\nThe former works but using the latter for my code doesn\\'t work"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "[@emrecoltu](/emrecoltu) Thinks for the explanation. I used the seconde one and my code doesn\\'t work. Using print() function, I print the id() of each row and I noticed that all the rows have the same reference (id())."
                    },
                    {
                        "username": "emrecoltu",
                        "content": "First one creates a new list for every row. Second one uses the first row to create other rows by reference. Every change you do on a row on the second one will also affects rest of the rows."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "mohit1412",
                        "content": "        int mat[][] = new int[m][n];\\n        for(int row[] : mat) Arrays.fill(row,-1);\\n        \\n        if(head == null) return mat;\\n\\n        int i = 0 , j = 0;\\n        int row = 0,col =0;\\n        ListNode cur = head;\\n        while(cur != null){\\n\\n            while(j<n){\\n       24-> mat[i][j] = cur.val;\\n                cur = cur.next;\\n                j++;\\n            }\\n            i++;j--; row++;\\n\\n\\njava.lang.NullPointerException: Cannot read field \"val\" because \"<local9>\" is null\\n  at line 24, Solution.spiralMatrix\\n  at line 54, __DriverSolution__.__helper__\\n  at line 90, __Driver__.main\\n\\nReceiving the above error. Is there something wrong with the code."
                    },
                    {
                        "username": "rajmohit7114",
                        "content": "with this approach , how will you insert element in last row and first column.?\\n"
                    }
                ]
            },
            {
                "id": 1745855,
                "content": [
                    {
                        "username": "whybhanu",
                        "content": "```\\nclass Solution {\\n    public int[][] spiralMatrix(int m, int n, ListNode head) {\\n        int[][] matrix = new int[m][n];\\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++) matrix[i][j] = -1;\\n        }\\n        int top = 0;\\n        int left = 0;\\n        int right = n - 1;\\n        int down = m - 1;\\n        int direction = 0;\\n        while(head != null){\\n            if(direction == 0){\\n                for(int i = left; i <= right && head != null; i++){\\n                    matrix[top][i] = head.val;\\n                    head = head.next;\\n                }\\n                top++;\\n                direction++;\\n            } else if (direction == 1){\\n                for(int j = top; j <= down && head != null; j++){\\n                    matrix[j][right] = head.val;\\n                    head = head.next;\\n                }\\n                right--;\\n                direction++;\\n            } else if(direction == 2){\\n                for(int i = right; i >= left && head != null; i--){\\n                    matrix[down][i] = head.val;\\n                    head = head.next;\\n                }\\n                down--;\\n                direction++;\\n            } else {\\n                for(int i = down; i >= top && head != null; i--){\\n                    matrix[i][left] = head.val;\\n                    head = head.next;\\n                }\\n                left++;\\n                direction = 0;\\n            }\\n        }\\n        return matrix;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "shevartsoft",
                        "content": "so stupid - show it to you mother instead of publishing this code in Discussion panel"
                    },
                    {
                        "username": "kdev307",
                        "content": "The base of the given Spiral Matrix Problem is similar to the problem Spiral Matrix II. With an add-on that here we\\'re given with a linked list which stores the values of the elements of matrix.\\n  We just have to check if the head is  NULL or not at every iteration, elsewise whole methodology is similar."
                    },
                    {
                        "username": "jblee1152",
                        "content": "what is the difference between those two code snippets?\\nmatrix = [[-1 for _ in range(n)] for _ in range(m)]\\nmatrix = [[-1] * n] * m\\nThey surely return the same matrix superficially, but is there anything here in the system level?\\nThe former works but using the latter for my code doesn\\'t work"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "[@emrecoltu](/emrecoltu) Thinks for the explanation. I used the seconde one and my code doesn\\'t work. Using print() function, I print the id() of each row and I noticed that all the rows have the same reference (id())."
                    },
                    {
                        "username": "emrecoltu",
                        "content": "First one creates a new list for every row. Second one uses the first row to create other rows by reference. Every change you do on a row on the second one will also affects rest of the rows."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "mohit1412",
                        "content": "        int mat[][] = new int[m][n];\\n        for(int row[] : mat) Arrays.fill(row,-1);\\n        \\n        if(head == null) return mat;\\n\\n        int i = 0 , j = 0;\\n        int row = 0,col =0;\\n        ListNode cur = head;\\n        while(cur != null){\\n\\n            while(j<n){\\n       24-> mat[i][j] = cur.val;\\n                cur = cur.next;\\n                j++;\\n            }\\n            i++;j--; row++;\\n\\n\\njava.lang.NullPointerException: Cannot read field \"val\" because \"<local9>\" is null\\n  at line 24, Solution.spiralMatrix\\n  at line 54, __DriverSolution__.__helper__\\n  at line 90, __Driver__.main\\n\\nReceiving the above error. Is there something wrong with the code."
                    },
                    {
                        "username": "rajmohit7114",
                        "content": "with this approach , how will you insert element in last row and first column.?\\n"
                    }
                ]
            }
        ]
    },
    {
        "title": "Move Pieces to Obtain a String",
        "question_content": "<p>You are given two strings <code>start</code> and <code>target</code>, both of length <code>n</code>. Each string consists <strong>only</strong> of the characters <code>&#39;L&#39;</code>, <code>&#39;R&#39;</code>, and <code>&#39;_&#39;</code> where:</p>\n\n<ul>\n\t<li>The characters <code>&#39;L&#39;</code> and <code>&#39;R&#39;</code> represent pieces, where a piece <code>&#39;L&#39;</code> can move to the <strong>left</strong> only if there is a <strong>blank</strong> space directly to its left, and a piece <code>&#39;R&#39;</code> can move to the <strong>right</strong> only if there is a <strong>blank</strong> space directly to its right.</li>\n\t<li>The character <code>&#39;_&#39;</code> represents a blank space that can be occupied by <strong>any</strong> of the <code>&#39;L&#39;</code> or <code>&#39;R&#39;</code> pieces.</li>\n</ul>\n\n<p>Return <code>true</code> <em>if it is possible to obtain the string</em> <code>target</code><em> by moving the pieces of the string </em><code>start</code><em> <strong>any</strong> number of times</em>. Otherwise, return <code>false</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> start = &quot;_L__R__R_&quot;, target = &quot;L______RR&quot;\n<strong>Output:</strong> true\n<strong>Explanation:</strong> We can obtain the string target from start by doing the following moves:\n- Move the first piece one step to the left, start becomes equal to &quot;<strong>L</strong>___R__R_&quot;.\n- Move the last piece one step to the right, start becomes equal to &quot;L___R___<strong>R</strong>&quot;.\n- Move the second piece three steps to the right, start becomes equal to &quot;L______<strong>R</strong>R&quot;.\nSince it is possible to get the string target from start, we return true.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> start = &quot;R_L_&quot;, target = &quot;__LR&quot;\n<strong>Output:</strong> false\n<strong>Explanation:</strong> The &#39;R&#39; piece in the string start can move one step to the right to obtain &quot;_<strong>R</strong>L_&quot;.\nAfter that, no pieces can move anymore, so it is impossible to obtain the string target from start.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> start = &quot;_R&quot;, target = &quot;R_&quot;\n<strong>Output:</strong> false\n<strong>Explanation:</strong> The piece in the string start can move only to the right, so it is impossible to obtain the string target from start.</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == start.length == target.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>start</code> and <code>target</code> consist of the characters <code>&#39;L&#39;</code>, <code>&#39;R&#39;</code>, and <code>&#39;_&#39;</code>.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 2261229,
                "title": "faster-than-100-00-o-n-java-and-c",
                "content": "I am ignoring all the empty _ charcater,\\n\\nAs soon as i encounter any character other then _ ,\\nThen the characters must be same,\\n\\nif It is \\'L\\'\\n then this condition must hold j>= i , if in target string it found at index i and , in st string it found at J\\n because we can move \\'L\\' charcater to left , means left in st string , \\notherwise i should return fase;\\n\\nsame with \\'R\\'\\nthen this condition must hold j<= i , if in target string it found at index i and , in st string it found at J\\nbecause we can move \\'R\\' charcater to right ,means  right in st string , \\notherwise i should return fase;\\n\\n**Time complexityO(N)**\\nbecause every time either i increase I , or J , or both\\n\\n**Space complexityO(1)**\\n\\n**Upvote if you find this solution helpfull**\\n```\\nbool canChange(string st, string tar) {\\n        int n=tar.length();\\n        int i=0,j=0;\\n        while(i<=n && j<=n){\\n            \\n            while(i<n && tar[i]==\\'_\\') i++;\\n            while(j<n && st[j]==\\'_\\') j++;\\n            \\n            if(i==n || j==n){\\n                return i==n && j==n;\\n            }\\n            \\n            if(tar[i]!=st[j]) return false;\\n            \\n            if(tar[i]==\\'L\\'){\\n                if(j<i) return false;\\n            }\\n            else{\\n                if(i<j) return false;\\n            }\\n            \\n            i++;\\n            j++;\\n        }\\n        return true;\\n    }\\n\\t```",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```\\nbool canChange(string st, string tar) {\\n        int n=tar.length();\\n        int i=0,j=0;\\n        while(i<=n && j<=n){\\n            \\n            while(i<n && tar[i]==\\'_\\') i++;\\n            while(j<n && st[j]==\\'_\\') j++;\\n            \\n            if(i==n || j==n){\\n                return i==n && j==n;\\n            }\\n            \\n            if(tar[i]!=st[j]) return false;\\n            \\n            if(tar[i]==\\'L\\'){\\n                if(j<i) return false;\\n            }\\n            else{\\n                if(i<j) return false;\\n            }\\n            \\n            i++;\\n            j++;\\n        }\\n        return true;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 2261392,
                "title": "java-python-3-compare-the-sequences-and-the-indices-of-l-and-r",
                "content": "**Intuition:**\\n\\nSince `L`s and `R`s can ONLY move to empty spaces and can NOT swap, the sequences containing all `L`s and `R`s and only `L`s and `R`s of `start` and `target` must be same;\\nSince `L`s and `R`s can move to left and right only respectively, all positions of `L`s in `start` must be no less than the corresponding ones in `target`, and all positions of `R`s in `start` must be no greater than the corresponding ones in `target`.\\n\\nBased on the above conclusion we can implement an algorithm as follows:\\n\\n**Algorithm:**\\n\\n1. Check if `start` and `target` are same if without `_`\\'s;\\n2. Check if all positions of `L`\\'s in `start` are no less than those in `target`;\\n3. Check if all positions of `R`\\'s in `start` are no greater than those in `target`;\\n4. If all above 3 are yes, return true; otherwise return false.\\n\\nCredit to **@Thoyajkiran** for removal of redundant code.\\n```java\\n    public boolean canChange(String start, String target) {\\n        if (!(start.replaceAll(\"_\", \"\")).equals(target.replaceAll(\"_\", \"\"))) {\\n            return false;\\n        }\\n        for (int i = 0, j = 0, n = start.length(); i < n && j < n; ++i, ++j) {\\n            while (i < n && start.charAt(i) == \\'_\\') {\\n                ++i;\\n            }\\n            while (j < n && target.charAt(j) == \\'_\\') {\\n                ++j;\\n            }\\n            if (i < n && j < n && (start.charAt(i) == \\'L\\' && i < j || target.charAt(j) == \\'R\\' && i > j)) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n```\\n```python\\n    def canChange(self, start: str, target: str) -> bool:\\n        if start.replace(\\'_\\', \\'\\') != target.replace(\\'_\\', \\'\\'):\\n            return False\\n        i = j = 0\\n        n = len(start)\\n        while i < n and j < n:\\n            while i < n and start[i] == \\'_\\':\\n                i += 1\\n            while j < n and target[j] == \\'_\\':\\n                j += 1\\n            if i < n and j < n and (start[i] == \\'L\\' and i < j or start[i] == \\'R\\' and i > j):\\n                return False\\n            i += 1\\n            j += 1\\n        return True\\n```\\n\\n\\n**Analysis:**\\n\\n`replace` and `for loop` contribute `O(n)` time complexity respectively. Each character at most visited twice, hence:\\n\\nTime & space: `O(n)`, where `n = start.length()`.\\n\\n----\\n\\nWe can optimize the space:\\n\\n```java\\n    public boolean canChange(String start, String target) {\\n        int i = 0, j = 0, n = start.length();\\n        while (i < n || j < n) {\\n            while (i < n && start.charAt(i) == \\'_\\') {\\n                ++i;\\n            }\\n            while (j < n && target.charAt(j) == \\'_\\') {\\n                ++j;\\n            }\\n            if (i == n || j == n) {\\n                return i == j;\\n            }\\n            if (start.charAt(i) != target.charAt(j)) {\\n                return false;\\n            }\\n            if (start.charAt(i) == \\'L\\') {\\n                if (i < j) {\\n                    return false;\\n                }\\n            }else {\\n                if (i > j) {\\n                    return false;\\n                }\\n            }\\n            ++i;\\n            ++j;\\n        }\\n        return true;\\n    }\\n```\\n```python\\n    def canChange(self, start: str, target: str) -> bool:\\n        n = len(start)\\n        i = j = 0\\n        while i < n or j < n:\\n            while i < n and start[i] == \\'_\\':\\n                i += 1\\n            while j < n and target[j] == \\'_\\':\\n                j += 1\\n            if n in (i, j):\\n                return i == j == n\\n            if start[i] != target[j]:\\n                return False\\n            if start[i] == \\'L\\':\\n                if i < j:\\n                    return False\\n            else:\\n                if i > j:\\n                    return False\\n            i += 1\\n            j += 1\\n        return True\\n```\\n\\n**Analysis:**\\n\\n`for loop` contribute `O(n)` time complexity. Each character  visited once, hence:\\n\\nTime: `O(n)`, space: `O(1)`, where `n = start.length()`.",
                "solutionTags": [
                    "Java",
                    "Python3"
                ],
                "code": "```java\\n    public boolean canChange(String start, String target) {\\n        if (!(start.replaceAll(\"_\", \"\")).equals(target.replaceAll(\"_\", \"\"))) {\\n            return false;\\n        }\\n        for (int i = 0, j = 0, n = start.length(); i < n && j < n; ++i, ++j) {\\n            while (i < n && start.charAt(i) == \\'_\\') {\\n                ++i;\\n            }\\n            while (j < n && target.charAt(j) == \\'_\\') {\\n                ++j;\\n            }\\n            if (i < n && j < n && (start.charAt(i) == \\'L\\' && i < j || target.charAt(j) == \\'R\\' && i > j)) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n```\n```python\\n    def canChange(self, start: str, target: str) -> bool:\\n        if start.replace(\\'_\\', \\'\\') != target.replace(\\'_\\', \\'\\'):\\n            return False\\n        i = j = 0\\n        n = len(start)\\n        while i < n and j < n:\\n            while i < n and start[i] == \\'_\\':\\n                i += 1\\n            while j < n and target[j] == \\'_\\':\\n                j += 1\\n            if i < n and j < n and (start[i] == \\'L\\' and i < j or start[i] == \\'R\\' and i > j):\\n                return False\\n            i += 1\\n            j += 1\\n        return True\\n```\n```java\\n    public boolean canChange(String start, String target) {\\n        int i = 0, j = 0, n = start.length();\\n        while (i < n || j < n) {\\n            while (i < n && start.charAt(i) == \\'_\\') {\\n                ++i;\\n            }\\n            while (j < n && target.charAt(j) == \\'_\\') {\\n                ++j;\\n            }\\n            if (i == n || j == n) {\\n                return i == j;\\n            }\\n            if (start.charAt(i) != target.charAt(j)) {\\n                return false;\\n            }\\n            if (start.charAt(i) == \\'L\\') {\\n                if (i < j) {\\n                    return false;\\n                }\\n            }else {\\n                if (i > j) {\\n                    return false;\\n                }\\n            }\\n            ++i;\\n            ++j;\\n        }\\n        return true;\\n    }\\n```\n```python\\n    def canChange(self, start: str, target: str) -> bool:\\n        n = len(start)\\n        i = j = 0\\n        while i < n or j < n:\\n            while i < n and start[i] == \\'_\\':\\n                i += 1\\n            while j < n and target[j] == \\'_\\':\\n                j += 1\\n            if n in (i, j):\\n                return i == j == n\\n            if start[i] != target[j]:\\n                return False\\n            if start[i] == \\'L\\':\\n                if i < j:\\n                    return False\\n            else:\\n                if i > j:\\n                    return False\\n            i += 1\\n            j += 1\\n        return True\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2265351,
                "title": "two-pointers",
                "content": "We use two pointers to find the next non-blank space.\\n\\nThen, the character in the current position can be moved to the target position if:\\n1. `s[i] == t[j]`.\\n2. `i >= j` for \\'L\\' characters.\\n3. `i <= j` for \\'R\\' characters.\\n\\n**C++**\\n\\n```cpp\\nbool canChange(string s, string t) {\\n    int i = 0, j = 0, n = s.size();\\n    for (; i < n || j < n; ++i, ++j) {\\n        while (i < n && s[i] == \\'_\\')\\n            ++i;\\n        while (j < n && t[j] == \\'_\\')\\n            ++j;\\n        if (i == n || j == n || s[i] != t[j] || (s[i] == \\'L\\' && i < j) || (s[i] == \\'R\\' && i > j))\\n            break;\\n    }\\n    return i == n && j == n;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nbool canChange(string s, string t) {\\n    int i = 0, j = 0, n = s.size();\\n    for (; i < n || j < n; ++i, ++j) {\\n        while (i < n && s[i] == \\'_\\')\\n            ++i;\\n        while (j < n && t[j] == \\'_\\')\\n            ++j;\\n        if (i == n || j == n || s[i] != t[j] || (s[i] == \\'L\\' && i < j) || (s[i] == \\'R\\' && i > j))\\n            break;\\n    }\\n    return i == n && j == n;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2262876,
                "title": "c-explanation-beginner-friendly-easy-understanding",
                "content": "**Problem** states that we need to convert **start** string to **target** string by moving \\'L\\' to left and \\'R\\' to right in **Start**.\\n\\n**3 observations to make here** - \\n\\n**1. Start string can only be converted into Target string if and only if relative order of \\'L\\' and \\'R\\' is equal.**\\n\\nExample - \\nStart = \"-L-R--L-R\"\\nTarget = \"--R--L--LR\"\\n\\nNow here we can see that order of LR in start is -> LRLR but in Target is RLLR so it can never be converted into Target because L and R can never cross each other.\\n\\n\\n**2. Now relative order being same doesn\\'t concludes that Start can always be converted to the Target.**\\n\\nExample - \\nStart = \"L-RRL\"\\nTarget = \"LR-RL\"\\n\\nHere relative order is same but to convert Start to Target we will need to move R to Left which is not Possible.\\n\\nNow here comes our 3rd Observation\\n\\n**3. That although relative order is same but if need to move any R of start to Left or any L to right then also Start can never be converted into Target.**\\n\\nNow how to check for this??\\n\\nTo check (suppose for R in the above example) this we will store indexes of R from both Start and Target in say arrays - r1 (For start) and r2 for(Target) and check for every i in r1  r1[i]<=r2[i].\\nSimilarly for L l1[i]>=l2[i]\\n\\n\\n**DRY RUN -**\\n\\nStart = \"L - R R L\"\\nTarget=\"L R - R L\"\\n\\n**now here relative order is same** , so may be start can be converted to Target\\n\\nnow r1 and r2 will look like this - \\n\\nr1 = [2,3]  r2 = [1,3]\\n\\nso now for i=0 r1[i]>r2[i] which simply denotes that to convert the S->T we need to move R at index 2 in Start in Left direction to make it match with R at index 1 in Target and which is not possible , Hence we cannot convert S->T.\\n\\n\\nCode - \\n\\n```\\nclass Solution {\\npublic:\\n    bool static seqSame(string s1,string s2){\\n        string a,b;\\n        for(auto it : s1) if(it!=\\'_\\') a+=it;\\n        for(auto it : s2) if(it!=\\'_\\') b+=it;\\n        return a==b;\\n    }\\n    bool canChange(string start, string target) {\\n        int n = start.length();\\n        if(!seqSame(start,target)) return false;\\n        vector<int> l1,l2,r1,r2;\\n        \\n        for(int i=0 ; i<n ; i++){\\n            if(start[i]==\\'L\\') l1.push_back(i);\\n            if(start[i]==\\'R\\') r1.push_back(i);\\n            if(target[i]==\\'L\\') l2.push_back(i);\\n            if(target[i]==\\'R\\') r2.push_back(i);\\n        }\\n        \\n        for(int i=0 ; i<l1.size() ; i++) if(l1[i]<l2[i]) return false;\\n        for(int i=0 ; i<r1.size() ; i++) if(r1[i]>r2[i]) return false;\\n        \\n        return true;\\n    }\\n};\\n```\\n\\nJust in Case you like the approach and effort , **DO UPVOTE.**\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool static seqSame(string s1,string s2){\\n        string a,b;\\n        for(auto it : s1) if(it!=\\'_\\') a+=it;\\n        for(auto it : s2) if(it!=\\'_\\') b+=it;\\n        return a==b;\\n    }\\n    bool canChange(string start, string target) {\\n        int n = start.length();\\n        if(!seqSame(start,target)) return false;\\n        vector<int> l1,l2,r1,r2;\\n        \\n        for(int i=0 ; i<n ; i++){\\n            if(start[i]==\\'L\\') l1.push_back(i);\\n            if(start[i]==\\'R\\') r1.push_back(i);\\n            if(target[i]==\\'L\\') l2.push_back(i);\\n            if(target[i]==\\'R\\') r2.push_back(i);\\n        }\\n        \\n        for(int i=0 ; i<l1.size() ; i++) if(l1[i]<l2[i]) return false;\\n        for(int i=0 ; i<r1.size() ; i++) if(r1[i]>r2[i]) return false;\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2261324,
                "title": "queue-c-fast-simple",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canChange(string s, string t) {\\n        queue<pair<char, int>> ss, ts;\\n        \\n        // Fill queue with start\\n        for(int i=0; i<s.size(); i++){\\n            if(s[i] != \\'_\\')ss.push({s[i], i});        \\n        }\\n        \\n        // Fill queue with target\\n        for(int i=0; i<t.size(); i++){\\n            if(t[i] != \\'_\\')ts.push({t[i], i});\\n        }\\n\\n        if(ss.size() != ts.size())return false;\\n        \\n        while(ss.size()){\\n            pair<char, int> sp, tp;\\n            \\n            sp = ss.front();\\n            tp = ts.front();\\n            \\n            ss.pop();\\n            ts.pop();\\n            \\n//             If both the letters don;t match return false, or check for the index to move Left and Right\\n            if(sp.first != tp.first) return false;\\n            if(sp.first == \\'L\\' && tp.second>sp.second){\\n                return false;\\n            } else if(sp.first == \\'R\\' && tp.second<sp.second){\\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canChange(string s, string t) {\\n        queue<pair<char, int>> ss, ts;\\n        \\n        // Fill queue with start\\n        for(int i=0; i<s.size(); i++){\\n            if(s[i] != \\'_\\')ss.push({s[i], i});        \\n        }\\n        \\n        // Fill queue with target\\n        for(int i=0; i<t.size(); i++){\\n            if(t[i] != \\'_\\')ts.push({t[i], i});\\n        }\\n\\n        if(ss.size() != ts.size())return false;\\n        \\n        while(ss.size()){\\n            pair<char, int> sp, tp;\\n            \\n            sp = ss.front();\\n            tp = ts.front();\\n            \\n            ss.pop();\\n            ts.pop();\\n            \\n//             If both the letters don;t match return false, or check for the index to move Left and Right\\n            if(sp.first != tp.first) return false;\\n            if(sp.first == \\'L\\' && tp.second>sp.second){\\n                return false;\\n            } else if(sp.first == \\'R\\' && tp.second<sp.second){\\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2261256,
                "title": "simple-java-solution",
                "content": "**Intuition:**\\nWe just need to validate the strings that we can move the chars and make target from start or not.\\nWe\\'ll check for all the invalid cases and at the end return true;\\n    \\nSo we\\'ll push \\'L\\' and \\'R\\' from both the strings along with their index to their respective stacks\\nwe\\'ll interate the strings from end so that at the end we\\'ll have string in the original order in the stacks.\\n\\nNow \\ncase 1: is stack size is different i.e either string have extra chars so can\\'t generate target from start. \\ncase 2: sequence of chars are not matching i.e somewhere R is before L so can\\'t generate target from start.\\ncase 3: if index of L in target is to the right of L in start then we can\\'t generate target from start as we can\\'t move L to right.\\ncase 4: if index of R in target is to the left of R in start then we can\\'t generate target from start as we can\\'t move R to left.\\n```\\nclass Solution {\\n    \\n    class Pair{\\n        char c;\\n        int idx;\\n        \\n        Pair(char cc, int idx){\\n            this.c = cc;\\n            this.idx = idx;\\n        }\\n    }\\n    public boolean canChange(String start, String target) {\\n        \\n        int idx = 0;\\n        int n = start.length();\\n        Stack<Pair> s1 = new Stack<>();\\n        Stack<Pair> s2 = new Stack<>();\\n        \\n        // Fill the stacks\\n        for(int i = n-1; i >=  0; i--){\\n            \\n            if(start.charAt(i) == \\'L\\' || start.charAt(i) == \\'R\\'){\\n                s1.push(new Pair(start.charAt(i), i));\\n            }\\n            \\n            if(target.charAt(i) == \\'L\\' || target.charAt(i) == \\'R\\'){\\n                s2.push(new Pair(target.charAt(i), i));\\n            }\\n            \\n        }\\n        \\n        // Early return \\n        if(s1.size() != s2.size()){\\n            return false;\\n        }\\n        \\n        // Validates both the sequinces\\n        while(!s1.isEmpty()){\\n            \\n            Pair s = s1.pop();\\n            Pair e = s2.pop();\\n            \\n            if(s.c != e.c){\\n                return false;\\n            }\\n            \\n            if(s.c == \\'L\\' && e.c == \\'L\\'){\\n                if(e.idx > s.idx){\\n                    return false;\\n                }\\n            }\\n            \\n            \\n            if(s.c == \\'R\\' && e.c == \\'R\\'){\\n                if(e.idx < s.idx){\\n                    return false;\\n                }\\n            }\\n        }\\n        \\n        \\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    class Pair{\\n        char c;\\n        int idx;\\n        \\n        Pair(char cc, int idx){\\n            this.c = cc;\\n            this.idx = idx;\\n        }\\n    }\\n    public boolean canChange(String start, String target) {\\n        \\n        int idx = 0;\\n        int n = start.length();\\n        Stack<Pair> s1 = new Stack<>();\\n        Stack<Pair> s2 = new Stack<>();\\n        \\n        // Fill the stacks\\n        for(int i = n-1; i >=  0; i--){\\n            \\n            if(start.charAt(i) == \\'L\\' || start.charAt(i) == \\'R\\'){\\n                s1.push(new Pair(start.charAt(i), i));\\n            }\\n            \\n            if(target.charAt(i) == \\'L\\' || target.charAt(i) == \\'R\\'){\\n                s2.push(new Pair(target.charAt(i), i));\\n            }\\n            \\n        }\\n        \\n        // Early return \\n        if(s1.size() != s2.size()){\\n            return false;\\n        }\\n        \\n        // Validates both the sequinces\\n        while(!s1.isEmpty()){\\n            \\n            Pair s = s1.pop();\\n            Pair e = s2.pop();\\n            \\n            if(s.c != e.c){\\n                return false;\\n            }\\n            \\n            if(s.c == \\'L\\' && e.c == \\'L\\'){\\n                if(e.idx > s.idx){\\n                    return false;\\n                }\\n            }\\n            \\n            \\n            if(s.c == \\'R\\' && e.c == \\'R\\'){\\n                if(e.idx < s.idx){\\n                    return false;\\n                }\\n            }\\n        }\\n        \\n        \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2261306,
                "title": "simple-o-n-c-explained",
                "content": "\\nBasically two points are essential for our answer to be YES\\n1. for all R and L in target there should be a corresponding R and L in start also.Means The relative order of L/R in start and target should be same.Becoz we cant move L beyond a R or R beyond a L.\\n2. for every R and L in Target, the corresponding R/L in start can be\\n\\ta) Corresponding L can be ahead in start, becoz we can always bring it to left and make position equal to that of in target.\\n\\tb) Corresponding R can be behind in start, becoz we can always bring it to right and make position equal to that of in target.\\n\\telse Answer will be NO\\nSo, save all chars and their position from start in a vector, and for every element L/R in target,check for above two condition if it satisfies\\nwe are good to go else Answer will be NO.\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    \\n\\n    bool canChange(string start, string target) {\\n        \\n        \\n        vector<pair<char,int >> v;\\n        for(int i =0 ;i  < start.size();i++)\\n        {\\n            if(start[i] == \\'L\\' || start[i] == \\'R\\')\\n            {\\n                v.push_back({start[i],i});\\n            }\\n        }\\n        \\n        int i = 0;\\n        for(int j = 0;j < target.size();j++)\\n        {\\n            if(target[j] == \\'L\\' || target[j] == \\'R\\') // lets find its corresponding Element in start\\n            {\\n                if(i >= v.size() || v[i].first != target[j]) // Not found or Different found\\n                {\\n                    return false;\\n                }else \\n                {\\n                   \\n                    if(v[i].first == \\'L\\' && v[i].second < j) // Condition a unsatisfied\\n                        return false;\\n                     if(v[i].first == \\'R\\' && v[i].second > j) // Condition b unsatisfied\\n                        return false;\\n                     else \\n                        i++; // all good we move ahead in start;\\n                }\\n               \\n                \\n            }\\n        }\\n        \\n        return i == v.size();// all elements accounted for in start\\n    }\\n};\\n```\\nConsider Upvoting.",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n\\n    bool canChange(string start, string target) {\\n        \\n        \\n        vector<pair<char,int >> v;\\n        for(int i =0 ;i  < start.size();i++)\\n        {\\n            if(start[i] == \\'L\\' || start[i] == \\'R\\')\\n            {\\n                v.push_back({start[i],i});\\n            }\\n        }\\n        \\n        int i = 0;\\n        for(int j = 0;j < target.size();j++)\\n        {\\n            if(target[j] == \\'L\\' || target[j] == \\'R\\') // lets find its corresponding Element in start\\n            {\\n                if(i >= v.size() || v[i].first != target[j]) // Not found or Different found\\n                {\\n                    return false;\\n                }else \\n                {\\n                   \\n                    if(v[i].first == \\'L\\' && v[i].second < j) // Condition a unsatisfied\\n                        return false;\\n                     if(v[i].first == \\'R\\' && v[i].second > j) // Condition b unsatisfied\\n                        return false;\\n                     else \\n                        i++; // all good we move ahead in start;\\n                }\\n               \\n                \\n            }\\n        }\\n        \\n        return i == v.size();// all elements accounted for in start\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2261792,
                "title": "5-lines-very-elegant-functional-solution-python",
                "content": "There are just 3 conditions:\\n1. since the L and R blocks can never pass each other, their order must be the same. \\n2. every L in `target` must be to the left or same as the corresponding L in `start`    \\n3. every R in `target` must be to the right or same as the corresponding R in `start`   \\n\\n```py\\nclass Solution:\\n    def canChange(self, A: str, B: str) -> bool:\\n        P = lambda c    :  c != \\'_\\'\\n        I = lambda s,x  :  [i for i,c in enumerate(s) if c==x]\\n        G = lambda d,p  :  all( p(x,y) for x,y in zip( I(A,d), I(B,d) ) )\\n        S = lambda      :  [*filter(P,A)] == [*filter(P,B)]\\n        return S() and G(\\'L\\', ge) and G(\\'R\\', le)\\n\\t\\t#      1.          2.             3.\\n```\\n\\nNotes to clear up confusion:\\n1. `filter(predicate, iterable)` returns a filter object with the elements that trigger the predicate removed\\n2. `[ *filter(P,A) ]` unpacks the filter object (similar to a generator/iterator) into a list\\n3. `S()` returns whether or not the `\\'L\\'` and `\\'R\\'` characters appear in the same order.\\n4. `I(s, x)` returns a List of the indices at which `x` occurs in `s`\\n5. `G(d, p)` returns whether or not `p(x,y)` is true for all corresponding pairs `x,y` of `d`\\n6. `le` and `ge` are functional equivalents of `<=` and `>=` operators, found in `operator` module\\n\\nPlease leave an upvote if you liked it/learned something, or comment if you have any questions!",
                "solutionTags": [],
                "code": "```py\\nclass Solution:\\n    def canChange(self, A: str, B: str) -> bool:\\n        P = lambda c    :  c != \\'_\\'\\n        I = lambda s,x  :  [i for i,c in enumerate(s) if c==x]\\n        G = lambda d,p  :  all( p(x,y) for x,y in zip( I(A,d), I(B,d) ) )\\n        S = lambda      :  [*filter(P,A)] == [*filter(P,B)]\\n        return S() and G(\\'L\\', ge) and G(\\'R\\', le)\\n\\t\\t#      1.          2.             3.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2261249,
                "title": "python-two-pointers-o-n-solution",
                "content": "```python\\nclass Solution:\\n    def canChange(self, start: str, target: str) -> bool:\\n        lcnt, rcnt = 0, 0\\n        for c1, c2 in zip(start, target):\\n            if c1 == \\'L\\': lcnt += 1\\n            if c2 == \\'L\\': lcnt -= 1\\n            if c1 == \\'R\\': rcnt += 1\\n            if c2 == \\'R\\': rcnt -= 1\\n        if lcnt or rcnt: return False\\n        \\n        s_ptr = 0\\n        for t_ptr in range(len(target)):\\n            if target[t_ptr] == \\'_\\':\\n                continue\\n            else:\\n                while s_ptr < len(start) and start[s_ptr] == \\'_\\':\\n                    s_ptr += 1\\n                if (target[t_ptr] != start[s_ptr] or\\n                    target[t_ptr] == \\'L\\' and s_ptr < t_ptr or\\n                    target[t_ptr] == \\'R\\' and s_ptr > t_ptr):\\n                    return False\\n                s_ptr += 1\\n        return True\\n",
                "solutionTags": [
                    "Python",
                    "Two Pointers"
                ],
                "code": "```python\\nclass Solution:\\n    def canChange(self, start: str, target: str) -> bool:\\n        lcnt, rcnt = 0, 0\\n        for c1, c2 in zip(start, target):\\n            if c1 == \\'L\\': lcnt += 1\\n            if c2 == \\'L\\': lcnt -= 1\\n            if c1 == \\'R\\': rcnt += 1\\n            if c2 == \\'R\\': rcnt -= 1\\n        if lcnt or rcnt: return False\\n        \\n        s_ptr = 0\\n        for t_ptr in range(len(target)):\\n            if target[t_ptr] == \\'_\\':\\n                continue\\n            else:\\n                while s_ptr < len(start) and start[s_ptr] == \\'_\\':\\n                    s_ptr += 1\\n                if (target[t_ptr] != start[s_ptr] or\\n                    target[t_ptr] == \\'L\\' and s_ptr < t_ptr or\\n                    target[t_ptr] == \\'R\\' and s_ptr > t_ptr):\\n                    return False\\n                s_ptr += 1\\n        return True\\n",
                "codeTag": "Java"
            },
            {
                "id": 2261270,
                "title": "java-intuitive-just-traverse-both-strings-o-n",
                "content": "**Approach**\\n\\nJust traverse both the strings and check whether relative charcters (\\'R\\' or \\'L\\') are equal or not, if they are equal, then check their relative positions to see whether `start` can be converted to `target` or not\\n\\n**e.g.** \\'-R\\' and \\'R-\\' => here, relative characters \\'R\\' and \\'R\\' are equal but index of \\'R\\' in `start` is greater than index of \\'R\\' in  `target`, since \\'R\\' can\\'t move left, hence we return false for this test case\\n\\n**Time Complexity** => O(n)\\n\\n```\\npublic boolean canChange(String start, String target) {\\n        if (start.length() != target.length()) {\\n            return false;\\n        }\\n        \\n        int i = 0, j = 0;\\n        \\n        while (i < start.length() || j < target.length()) {\\n            while (i < start.length() && start.charAt(i) == \\'_\\') {\\n                i++;\\n            }\\n            \\n            while (j < target.length() && target.charAt(j) == \\'_\\') {\\n                j++;\\n            }\\n            \\n            // if both i and j reach end of string\\n            if (i == j && i == start.length()) {\\n                return true;\\n            }\\n            \\n            if (i == start.length() || j == target.length() || start.charAt(i) != target.charAt(j)) {\\n                return false;\\n            }\\n            \\n            // if characters at both i and j are equal, check their relative positions in both start and target\\n            if ((target.charAt(j) == \\'L\\' && i < j) || (target.charAt(j) == \\'R\\' && i > j)) {\\n                return false;\\n            }\\n            \\n            i++;\\n            j++;\\n        }\\n        \\n        return true;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic boolean canChange(String start, String target) {\\n        if (start.length() != target.length()) {\\n            return false;\\n        }\\n        \\n        int i = 0, j = 0;\\n        \\n        while (i < start.length() || j < target.length()) {\\n            while (i < start.length() && start.charAt(i) == \\'_\\') {\\n                i++;\\n            }\\n            \\n            while (j < target.length() && target.charAt(j) == \\'_\\') {\\n                j++;\\n            }\\n            \\n            // if both i and j reach end of string\\n            if (i == j && i == start.length()) {\\n                return true;\\n            }\\n            \\n            if (i == start.length() || j == target.length() || start.charAt(i) != target.charAt(j)) {\\n                return false;\\n            }\\n            \\n            // if characters at both i and j are equal, check their relative positions in both start and target\\n            if ((target.charAt(j) == \\'L\\' && i < j) || (target.charAt(j) == \\'R\\' && i > j)) {\\n                return false;\\n            }\\n            \\n            i++;\\n            j++;\\n        }\\n        \\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2261543,
                "title": "simple-c-easy-solution-faster-than-100-o-n",
                "content": "\\n**Observation 1:**\\nEx- _ L _ R _ _ R _ L\\nLook at the example and imagine _ moving . We will notice that _ pushes L to left and it pushes R to right.\\n\\nWe can remove all the spaces and store the new string in s(start string without _ ) and t(target string without _ ), if s!=t the answer is false as L and R cannot cross each other so there\\'s no way to make start==target.\\n\\n**Observation 2:**\\n_ will move L only towards left, so if the index of L in start is lesser than L in target, then it is not possible to make the strings equal.\\nSo in a vector(l1) we store all the indexes where start[i]=\\'L\\' and in another vector(l2) we store all the indexes where target[i]==\\'L\\'. Then we loop the vector and if at any index l1[i]<l2[i] we return false.\\n\\n**Observation 3:**\\nSimilarly, _ will move R only towards right, so if the index of R in start is greater than R in target, then it is not possible to make the strings equal.\\nSo in a vector(r1) we store all the indexes where start[i]=\\'R\\' and in another vector(r2) we store all the indexes where target[i]==\\'R\\'. Then we loop the vector and if at any index r1[i]>r2[i] we return false.\\n\\nCode:\\n```\\nclass Solution {\\npublic:\\n    bool canChange(string start, string target) {\\n        string s,t;\\n        for(int i=0;i<start.size();i++){\\n            if(start[i]!=\\'_\\')s.push_back(start[i]);\\n            if(target[i]!=\\'_\\')t.push_back(target[i]);\\n        }\\n        if(s!=t)return false;\\n        vector<int> l1,l2;\\n        for(int i=0;i<start.size();i++){\\n            if(start[i]==\\'L\\')l1.push_back(i);\\n            if(target[i]==\\'L\\')l2.push_back(i);\\n        }\\n        for(int i=0;i<l1.size();i++){\\n            if(l1[i]<l2[i])return false;\\n        }\\n        vector<int> r1,r2;\\n        for(int i=0;i<start.size();i++){\\n            if(start[i]==\\'R\\')r1.push_back(i);\\n            if(target[i]==\\'R\\')r2.push_back(i);\\n        }\\n        for(int i=0;i<r1.size();i++){\\n            if(r1[i]>r2[i])return false;\\n        }\\n        return true;\\n    }\\n};\\n```\\nPlease Upvote if you found it useful!\\n",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canChange(string start, string target) {\\n        string s,t;\\n        for(int i=0;i<start.size();i++){\\n            if(start[i]!=\\'_\\')s.push_back(start[i]);\\n            if(target[i]!=\\'_\\')t.push_back(target[i]);\\n        }\\n        if(s!=t)return false;\\n        vector<int> l1,l2;\\n        for(int i=0;i<start.size();i++){\\n            if(start[i]==\\'L\\')l1.push_back(i);\\n            if(target[i]==\\'L\\')l2.push_back(i);\\n        }\\n        for(int i=0;i<l1.size();i++){\\n            if(l1[i]<l2[i])return false;\\n        }\\n        vector<int> r1,r2;\\n        for(int i=0;i<start.size();i++){\\n            if(start[i]==\\'R\\')r1.push_back(i);\\n            if(target[i]==\\'R\\')r2.push_back(i);\\n        }\\n        for(int i=0;i<r1.size();i++){\\n            if(r1[i]>r2[i])return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2261219,
                "title": "c-sweet-solution",
                "content": "Just check the indexes and relative order of L and R and count of R\\'s and L\\'s\\n```\\nclass Solution {\\npublic:\\n    bool canChange(string start, string target) {\\n        int i=0,j=0,loi=0,n=start.length();\\n        int SL=0,SR=0,TL=0,TR=0;\\n        for(int i=0;i<n;i++){\\n            if(start[i]==\\'R\\')SR++;\\n            else if(start[i]==\\'L\\')SL++;\\n            if(target[i]==\\'L\\')TL++;\\n            else if(target[i]==\\'R\\')TR++;\\n        }\\n        if(SL!= TL || SR!=TR)return false;\\n        while(i<n && j<n){\\n            while(i<n && start[i++]==\\'_\\');\\n            while(j<n && target[j++]==\\'_\\');\\n            i--;j--;\\n            if(start[i]!=target[j])return false;\\n            if(start[i]==\\'L\\'){\\n                if(i<j)return false;\\n            }\\n            if(start[i]==\\'R\\'){\\n                if(i>j)return false;\\n            }\\n            i++;j++;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canChange(string start, string target) {\\n        int i=0,j=0,loi=0,n=start.length();\\n        int SL=0,SR=0,TL=0,TR=0;\\n        for(int i=0;i<n;i++){\\n            if(start[i]==\\'R\\')SR++;\\n            else if(start[i]==\\'L\\')SL++;\\n            if(target[i]==\\'L\\')TL++;\\n            else if(target[i]==\\'R\\')TR++;\\n        }\\n        if(SL!= TL || SR!=TR)return false;\\n        while(i<n && j<n){\\n            while(i<n && start[i++]==\\'_\\');\\n            while(j<n && target[j++]==\\'_\\');\\n            i--;j--;\\n            if(start[i]!=target[j])return false;\\n            if(start[i]==\\'L\\'){\\n                if(i<j)return false;\\n            }\\n            if(start[i]==\\'R\\'){\\n                if(i>j)return false;\\n            }\\n            i++;j++;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2261399,
                "title": "c-loop-left-right-o-n",
                "content": "1. **Track Position Together Solution** (Inspired from [@IAmCoderrr](https://leetcode.com/IAmCoderrr))\\n```cpp\\nbool canChange(string start, string target) {\\n    int i = 0, j = 0, n = start.size();\\n\\t\\n\\t// we keep OR condition to execute the loop one more time till remaining \\'_\\' present\\n    while(i < n || j < n){\\n        while(i < n && start[i] == \\'_\\') i++;\\n        while(j < n && target[j] == \\'_\\') j++;\\n\\n\\t\\t// if all chars are \\'_\\', break\\n        if(i == n || j == n) break;\\n\\n        if(start[i] != target[j]) return false;\\n\\t\\t\\n\\t\\t//positional conditions\\n        if(start[i] == \\'L\\') if(i < j) return false;\\n        if(start[i] == \\'R\\') if(i > j) return false;\\n        i++; j++;\\n    }\\n\\n    return i == n && j == n;\\n}\\n```\\n\\n2. **Two Loop Solution** - Keeps making char changes live.\\n```cpp\\nbool canChange(string start, string target) {\\n    unordered_map<char, int> chars1, chars2;\\n    for(char& ch: start)\\n        chars1[ch]++;\\n    for(char& ch: target)\\n        chars2[ch]++;\\n\\n    if(chars1 != chars2) return false;\\n\\n    int n = start.size();\\n\\n    //move from right to left for \\'R\\' changes\\n    for(int i=n-1; i >= 0; i--){\\n        if(start[i] == target[i]) continue;\\n\\n        char req = target[i];\\n        if(req == \\'R\\'){\\n            int j = i;\\n            while(j >= 0 && start[j] == \\'_\\'){\\n                start[j] = target[j];\\n                j--;\\n            }\\n            if(j < 0 || start[j] == \\'L\\') return false;\\n            start[j] = \\'_\\';\\n            i = j + 1;\\n        }\\n    }\\n\\n    //move from left to right for \\'L\\' changes\\n    for(int i=0; i < n; i++){\\n        if(start[i] == target[i]) continue;\\n\\n        char req = target[i];\\n        if(req == \\'L\\'){\\n            int j = i;\\n            while(j < n && start[j] == \\'_\\'){\\n                start[j] = target[j];\\n                j++;\\n            }\\n            if(j == n || start[j] == \\'R\\') return false;\\n            start[j] = \\'_\\';\\n            i = j - 1;\\n        }\\n    }\\n    return true;\\n}\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nbool canChange(string start, string target) {\\n    int i = 0, j = 0, n = start.size();\\n\\t\\n\\t// we keep OR condition to execute the loop one more time till remaining \\'_\\' present\\n    while(i < n || j < n){\\n        while(i < n && start[i] == \\'_\\') i++;\\n        while(j < n && target[j] == \\'_\\') j++;\\n\\n\\t\\t// if all chars are \\'_\\', break\\n        if(i == n || j == n) break;\\n\\n        if(start[i] != target[j]) return false;\\n\\t\\t\\n\\t\\t//positional conditions\\n        if(start[i] == \\'L\\') if(i < j) return false;\\n        if(start[i] == \\'R\\') if(i > j) return false;\\n        i++; j++;\\n    }\\n\\n    return i == n && j == n;\\n}\\n```\n```cpp\\nbool canChange(string start, string target) {\\n    unordered_map<char, int> chars1, chars2;\\n    for(char& ch: start)\\n        chars1[ch]++;\\n    for(char& ch: target)\\n        chars2[ch]++;\\n\\n    if(chars1 != chars2) return false;\\n\\n    int n = start.size();\\n\\n    //move from right to left for \\'R\\' changes\\n    for(int i=n-1; i >= 0; i--){\\n        if(start[i] == target[i]) continue;\\n\\n        char req = target[i];\\n        if(req == \\'R\\'){\\n            int j = i;\\n            while(j >= 0 && start[j] == \\'_\\'){\\n                start[j] = target[j];\\n                j--;\\n            }\\n            if(j < 0 || start[j] == \\'L\\') return false;\\n            start[j] = \\'_\\';\\n            i = j + 1;\\n        }\\n    }\\n\\n    //move from left to right for \\'L\\' changes\\n    for(int i=0; i < n; i++){\\n        if(start[i] == target[i]) continue;\\n\\n        char req = target[i];\\n        if(req == \\'L\\'){\\n            int j = i;\\n            while(j < n && start[j] == \\'_\\'){\\n                start[j] = target[j];\\n                j++;\\n            }\\n            if(j == n || start[j] == \\'R\\') return false;\\n            start[j] = \\'_\\';\\n            i = j - 1;\\n        }\\n    }\\n    return true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2261308,
                "title": "move-pieces-to-obtain-a-string-java-solution",
                "content": "```\\nclass Solution {\\n    public boolean canChange(String start, String target) {\\n        int characs = 0; \\n        for (int i=0;i<start.length();i++) \\n        { \\n            char ch = start.charAt(i);\\n            if (ch != \\'_\\') \\n                characs++; \\n        } \\n        for (int i=0;i<target.length();i++) \\n        { \\n            char ch = target.charAt(i);\\n            if (ch != \\'_\\') \\n                characs--; \\n        } \\n        if (characs != 0) \\n            return false; \\n        return compute(start, target); \\n    } \\n     \\n    public boolean compute(String start, String target) \\n    { \\n        int LStart = 0, RStart = 0; \\n        int LTarget = 0, RTarget = 0; \\n        for (int i = 0; i < start.length(); i++) \\n        { \\n            char ch1 = start.charAt(i); \\n            char ch2 = target.charAt(i); \\n            if (ch1 == \\'L\\') \\n                LStart++; \\n            else if(ch1 == \\'R\\') \\n                RStart++; \\n            if (ch2 == \\'L\\') \\n                LTarget++; \\n            else if(ch2 == \\'R\\') \\n                RTarget++; \\n        } \\n         \\n        if (LStart != LTarget || RStart != RTarget) \\n            return false; \\n        \\n        List<Integer> ar1 = new ArrayList<>(); \\n        List<Integer> ar2 = new ArrayList<>(); \\n         \\n        for (int i = 0; i < start.length(); i++) \\n        { \\n            char ch = start.charAt(i);\\n            if (ch != \\'_\\') { \\n                ar1.add(i); \\n            } \\n            if (target.charAt(i) != \\'_\\') { \\n                ar2.add(i); \\n            } \\n        } \\n         \\n        for (int i = 0; i < ar1.size(); i++) \\n        { \\n            if (start.charAt(ar1.get(i)) != target.charAt(ar2.get(i)))  \\n                return false; \\n            \\n            if (start.charAt(ar1.get(i)) == \\'L\\') \\n            { \\n                if (ar1.get(i) < ar2.get(i)) \\n                    return false; \\n            } else \\n            { \\n                if (ar1.get(i) > ar2.get(i)) \\n                    return false; \\n            } \\n        } \\n        return true; \\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canChange(String start, String target) {\\n        int characs = 0; \\n        for (int i=0;i<start.length();i++) \\n        { \\n            char ch = start.charAt(i);\\n            if (ch != \\'_\\') \\n                characs++; \\n        } \\n        for (int i=0;i<target.length();i++) \\n        { \\n            char ch = target.charAt(i);\\n            if (ch != \\'_\\') \\n                characs--; \\n        } \\n        if (characs != 0) \\n            return false; \\n        return compute(start, target); \\n    } \\n     \\n    public boolean compute(String start, String target) \\n    { \\n        int LStart = 0, RStart = 0; \\n        int LTarget = 0, RTarget = 0; \\n        for (int i = 0; i < start.length(); i++) \\n        { \\n            char ch1 = start.charAt(i); \\n            char ch2 = target.charAt(i); \\n            if (ch1 == \\'L\\') \\n                LStart++; \\n            else if(ch1 == \\'R\\') \\n                RStart++; \\n            if (ch2 == \\'L\\') \\n                LTarget++; \\n            else if(ch2 == \\'R\\') \\n                RTarget++; \\n        } \\n         \\n        if (LStart != LTarget || RStart != RTarget) \\n            return false; \\n        \\n        List<Integer> ar1 = new ArrayList<>(); \\n        List<Integer> ar2 = new ArrayList<>(); \\n         \\n        for (int i = 0; i < start.length(); i++) \\n        { \\n            char ch = start.charAt(i);\\n            if (ch != \\'_\\') { \\n                ar1.add(i); \\n            } \\n            if (target.charAt(i) != \\'_\\') { \\n                ar2.add(i); \\n            } \\n        } \\n         \\n        for (int i = 0; i < ar1.size(); i++) \\n        { \\n            if (start.charAt(ar1.get(i)) != target.charAt(ar2.get(i)))  \\n                return false; \\n            \\n            if (start.charAt(ar1.get(i)) == \\'L\\') \\n            { \\n                if (ar1.get(i) < ar2.get(i)) \\n                    return false; \\n            } else \\n            { \\n                if (ar1.get(i) > ar2.get(i)) \\n                    return false; \\n            } \\n        } \\n        return true; \\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2261267,
                "title": "keep-track-of-the-position-of-pieces-in-your-start-string-o-n-space-and-time",
                "content": "The idea is simple:\\n\\n- Use **queue** to keep track of the pieces and index occurance in the **start string**\\n- Walk through the **target string** and when you hit a piece:\\n\\t- Make sure the queue still has pieces\\n\\t- Pop a piece  from the queue, and make sure they match \\n\\t- Make sure you can move the piece to the position it occured in the **target string**; by comparing indices \\n\\t- Finally, only return **True** if no more pieces exist in the queue \\n\\n\\n\\n```\\ndef canChange(self, start: str, target: str) -> bool:\\n\\tq, av = collections.deque(), set([\\'L\\', \\'R\\'])\\n\\n\\tfor i, c in enumerate(start):\\n\\t\\tif c in av: q.append((i, c))\\n\\n\\tfor i, c in enumerate(target):\\n\\t\\tif c in av:\\n\\t\\t\\tif not q: return False\\n\\n\\t\\t\\tind, char = q.popleft()\\n\\t\\t\\tif c != char: return False\\n\\t\\t\\telif c == \\'R\\' and i < ind: return False \\n\\t\\t\\telif c == \\'L\\' and i > ind: return False \\n\\n\\treturn not q \\n``` \\n\\n\\n**NOTE**\\n\\nIt could also be done using a stack, or by keeping track of indices in the **target string** instead of **start string.** \\n",
                "solutionTags": [
                    "Python",
                    "Greedy",
                    "Queue"
                ],
                "code": "```\\ndef canChange(self, start: str, target: str) -> bool:\\n\\tq, av = collections.deque(), set([\\'L\\', \\'R\\'])\\n\\n\\tfor i, c in enumerate(start):\\n\\t\\tif c in av: q.append((i, c))\\n\\n\\tfor i, c in enumerate(target):\\n\\t\\tif c in av:\\n\\t\\t\\tif not q: return False\\n\\n\\t\\t\\tind, char = q.popleft()\\n\\t\\t\\tif c != char: return False\\n\\t\\t\\telif c == \\'R\\' and i < ind: return False \\n\\t\\t\\telif c == \\'L\\' and i > ind: return False \\n\\n\\treturn not q \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2261226,
                "title": "c-easy-to-understand-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canChange(string s, string t) {\\n        int n=s.size();\\n        string s1,s2;\\n        s1=s2=\"\";\\n        vector<int> v1,v2;\\n        for(int i=0;i<n;i++)\\n        {\\n            char ch=s[i];\\n            if(ch==\\'L\\'||ch==\\'R\\')\\n            {\\n                v1.push_back(i);\\n                s1+=ch;\\n            }\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            char ch=t[i];\\n            if(ch==\\'L\\'||ch==\\'R\\')\\n            {\\n                v2.push_back(i);\\n                s2+=ch;\\n            }\\n        }\\n        if(s1!=s2)\\n        return false;\\n        for(int i=0;i<v1.size();i++)\\n        {\\n            if(s[v1[i]]==\\'L\\')\\n            {\\n                if(v1[i]<v2[i])\\n                return false;\\n            }\\n            else\\n            {\\n                if(v1[i]>v2[i])\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```\\n**Please upvote to motivate me in my quest of documenting all leetcode solutions. HAPPY CODING:)\\nAny suggestions and improvements are always welcome**\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canChange(string s, string t) {\\n        int n=s.size();\\n        string s1,s2;\\n        s1=s2=\"\";\\n        vector<int> v1,v2;\\n        for(int i=0;i<n;i++)\\n        {\\n            char ch=s[i];\\n            if(ch==\\'L\\'||ch==\\'R\\')\\n            {\\n                v1.push_back(i);\\n                s1+=ch;\\n            }\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            char ch=t[i];\\n            if(ch==\\'L\\'||ch==\\'R\\')\\n            {\\n                v2.push_back(i);\\n                s2+=ch;\\n            }\\n        }\\n        if(s1!=s2)\\n        return false;\\n        for(int i=0;i<v1.size();i++)\\n        {\\n            if(s[v1[i]]==\\'L\\')\\n            {\\n                if(v1[i]<v2[i])\\n                return false;\\n            }\\n            else\\n            {\\n                if(v1[i]>v2[i])\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2967494,
                "title": "short-concise-two-pointers-c",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canChange(string s, string t) {\\n        int i = 0, j = 0, n = s.size(), m = t.size();\\n        if(n != m) return false;\\n        \\n        while(i < n || j < m) {\\n            while(i < n && s[i] == \\'_\\') i++;\\n            while(j < m && t[j] == \\'_\\') j++;\\n            \\n            if(s[i] != t[j]) return false;\\n            if(s[i] == \\'R\\' && i > j) return false;\\n            if(s[i] == \\'L\\' && i < j) return false;\\n            i++, j++;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canChange(string s, string t) {\\n        int i = 0, j = 0, n = s.size(), m = t.size();\\n        if(n != m) return false;\\n        \\n        while(i < n || j < m) {\\n            while(i < n && s[i] == \\'_\\') i++;\\n            while(j < m && t[j] == \\'_\\') j++;\\n            \\n            if(s[i] != t[j]) return false;\\n            if(s[i] == \\'R\\' && i > j) return false;\\n            if(s[i] == \\'L\\' && i < j) return false;\\n            i++, j++;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2263703,
                "title": "faster-than-100-00-cpp-o-n",
                "content": "\\n\\n## **APPROACH EXPLAINATION :**\\n1.  First we check if the size of both strings are same or not.\\n1. If size are same:\\n   * Then we check for the frequency of character \\'R\\' ans \\'L\\' in both the string.\\n   *   For string start , just add the frequency in the count_l and count_r \\n       and for string target, subtracts the  frequency from  count_l and count_r \\n1. If count_l and count_r are not 0, then frequency of characters are not same , return false.\\n1. Now we check if the position of characters can be changed  to get the target  string or not. \\n*   Store the index of \\'R\\' and \\'L\\' of start in a stack.\\n*  Iterate the  string target from last and check for the foloowing\\n    *  if  char is \"_\" , iterate for next index.\\n    *  if the character of target and that in the stack is not same , then start can\\'t be converted to target\\n    *  if char of target is same as the top of stack\\n      ! If char is \"R\" => Then the index on the top should be lesser then the curr iterating index, as \"R\" can only move to right direction, \\n                          so this would never be moved  to target\\'s index position\\n    *  Similarly we check for  char \"L\" also.\\n\\n* If all\\'s well then string start can be converted to target\\n\\n**Time complexity: O(N)\\nSpace complexity  : O(N)**\\n\\n\\n\\n```\\n bool canChange(string start, string target) {\\n       int s=start.size(), t= target.size(); \\n       if(s!=t) return false;\\n    \\n      stack<int> st;\\n      int count_l=0,count_r=0;  // Storing the frequency of characters \\'L\\' and \\'R\\'\\n      for(int i=0;i<s ;i++)\\n      {\\n           if(start[i]==\\'L\\')  count_l++;\\n           else if(start[i]==\\'R\\') count_r++;\\n           \\n           if(target[i]==\\'L\\') count_l--;\\n           else if(target[i]==\\'R\\') count_r--;\\n          \\n           if(start[i]!=\\'_\\') st.push(i);  // storing index values in stack\\n           \\n     }\\n        \\n     if( count_l ||count_r) // if count of characters are not same in start and target\\n         return false;  \\n  \\n        \\n     //Now check if the placement of characters are in correct position \\n     for(int i= t-1;i>=0;i--)  \\n     {\\n        if(target[i]== \\'_\\')\\n            continue;\\n         \\n        if(target[i]== start[st.top()])\\n        {\\n          if(target[i]==\\'L\\' && i> st.top() || target[i]==\\'R\\' && i<st.top()) \\n            return false;\\n        }\\n        else if(target[i]!= start[st.top()])\\n            return false;\\n         \\n        st.pop();\\n     }\\n        \\n    return true;\\n    }\\n```\\n\\n  PLEASE UPVOTE IF MY EXPLAINATION WAS HELPFUL\\n  ![image](https://assets.leetcode.com/users/images/00967497-47f3-4301-a9d3-1accd90df71b_1657456889.5853913.jpeg)",
                "solutionTags": [
                    "C++",
                    "String",
                    "Stack"
                ],
                "code": "```\\n bool canChange(string start, string target) {\\n       int s=start.size(), t= target.size(); \\n       if(s!=t) return false;\\n    \\n      stack<int> st;\\n      int count_l=0,count_r=0;  // Storing the frequency of characters \\'L\\' and \\'R\\'\\n      for(int i=0;i<s ;i++)\\n      {\\n           if(start[i]==\\'L\\')  count_l++;\\n           else if(start[i]==\\'R\\') count_r++;\\n           \\n           if(target[i]==\\'L\\') count_l--;\\n           else if(target[i]==\\'R\\') count_r--;\\n          \\n           if(start[i]!=\\'_\\') st.push(i);  // storing index values in stack\\n           \\n     }\\n        \\n     if( count_l ||count_r) // if count of characters are not same in start and target\\n         return false;  \\n  \\n        \\n     //Now check if the placement of characters are in correct position \\n     for(int i= t-1;i>=0;i--)  \\n     {\\n        if(target[i]== \\'_\\')\\n            continue;\\n         \\n        if(target[i]== start[st.top()])\\n        {\\n          if(target[i]==\\'L\\' && i> st.top() || target[i]==\\'R\\' && i<st.top()) \\n            return false;\\n        }\\n        else if(target[i]!= start[st.top()])\\n            return false;\\n         \\n        st.pop();\\n     }\\n        \\n    return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2261682,
                "title": "o-n-solution",
                "content": "```\\npublic boolean canChange(String start, String target) {\\n        int l=0,r=0,n=start.length();\\n        for(int i=0;i<n;i++){\\n            if(start.charAt(i)==\\'L\\') {\\n                l++;\\n                if(r>0) return false;\\n            }\\n            else if(start.charAt(i)==\\'R\\') r++;\\n            if(target.charAt(i)==\\'L\\') l--;\\n            else if(target.charAt(i)==\\'R\\') r--;\\n            if(l>0) return false;\\n            if(r<0) return false;\\n        }\\n        return l==0&&r==0;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic boolean canChange(String start, String target) {\\n        int l=0,r=0,n=start.length();\\n        for(int i=0;i<n;i++){\\n            if(start.charAt(i)==\\'L\\') {\\n                l++;\\n                if(r>0) return false;\\n            }\\n            else if(start.charAt(i)==\\'R\\') r++;\\n            if(target.charAt(i)==\\'L\\') l--;\\n            else if(target.charAt(i)==\\'R\\') r--;\\n            if(l>0) return false;\\n            if(r<0) return false;\\n        }\\n        return l==0&&r==0;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2261263,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public boolean canChange(String start, String target) {\\n        String onlyDirsStart = start.replace(\"_\", \"\");\\n        String onlyDirsTarget = target.replace(\"_\", \"\");\\n        if (!onlyDirsStart.equals(onlyDirsTarget)) {\\n            return false;\\n        }\\n        int balance = 0;\\n        for (int i = 0; i < start.length(); i++) {\\n            if (target.charAt(i) == \\'L\\') {\\n                balance++;\\n            }\\n            if (start.charAt(i) == \\'L\\') {\\n                balance--;\\n            }\\n            if (balance < 0) {\\n                return false;\\n            }\\n        }\\n        balance = 0;\\n        for (int i = start.length() - 1; i >= 0; i--) {\\n            if (target.charAt(i) == \\'R\\') {\\n                balance++;\\n            }\\n            if (start.charAt(i) == \\'R\\') {\\n                balance--;\\n            }    \\n            if(balance < 0) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canChange(String start, String target) {\\n        String onlyDirsStart = start.replace(\"_\", \"\");\\n        String onlyDirsTarget = target.replace(\"_\", \"\");\\n        if (!onlyDirsStart.equals(onlyDirsTarget)) {\\n            return false;\\n        }\\n        int balance = 0;\\n        for (int i = 0; i < start.length(); i++) {\\n            if (target.charAt(i) == \\'L\\') {\\n                balance++;\\n            }\\n            if (start.charAt(i) == \\'L\\') {\\n                balance--;\\n            }\\n            if (balance < 0) {\\n                return false;\\n            }\\n        }\\n        balance = 0;\\n        for (int i = start.length() - 1; i >= 0; i--) {\\n            if (target.charAt(i) == \\'R\\') {\\n                balance++;\\n            }\\n            if (start.charAt(i) == \\'R\\') {\\n                balance--;\\n            }    \\n            if(balance < 0) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2346254,
                "title": "c-o-n-time-o-1-space-intuitive-and-easy-to-understand",
                "content": "The Idea is to iterate both strings skipping and counting how many  \\'underscore char\\' we find and try to see if character can be moved.\\nWe can hit 3 cases:\\n1 we have different char on start and on target string...ok we are done..we can\\'t continue\\n2 we have L on both strings...we need to check if the position where we found this character on start string is smaller then the position where we found the same char on target. If this is the case we are done as we can\\'t move a L char to the right in order to to the matching.\\n3 Same of point 2 but with char R and this time the failure condition is that index on string s is bigger than index on target (as we can\\'t move an R to the left\\nwhen we exit from the while loop we have to check if the number of blak is equal for both string...this is neede for cases like\\n\"_L\"\\n\"LL\"\\nas the first L can be moved to the left...but then we do not have a second L to match...\\nI hope it helps\\n\\n```\\nclass Solution {\\npublic:\\n    bool canChange(string start, string target) {\\n        int i = 0;\\n        int j = 0;\\n        int cnt_s = 0;\\n        int cnt_t = 0;\\n        if(start.length() != target.length())\\n            return false;\\n        while(i < start.length() || j < target.length()) {\\n            while(i < start.length() && start[i] == \\'_\\') {\\n                ++i;\\n                ++cnt_s;\\n            }\\n            while(j < target.length() && target[j] == \\'_\\') {\\n                ++j;\\n                ++cnt_t;\\n            }\\n            if(start[i] == \\'L\\' && target[j] == \\'L\\')\\n                if(i< j)\\n                    return false;\\n            if(start[i] == \\'R\\' && target[j] == \\'R\\')\\n                if(i > j)\\n                    return false;\\n            if(start[i] != target[j])\\n                return false;\\n            ++i;\\n            ++j;\\n        }\\n        return cnt_s == cnt_t;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canChange(string start, string target) {\\n        int i = 0;\\n        int j = 0;\\n        int cnt_s = 0;\\n        int cnt_t = 0;\\n        if(start.length() != target.length())\\n            return false;\\n        while(i < start.length() || j < target.length()) {\\n            while(i < start.length() && start[i] == \\'_\\') {\\n                ++i;\\n                ++cnt_s;\\n            }\\n            while(j < target.length() && target[j] == \\'_\\') {\\n                ++j;\\n                ++cnt_t;\\n            }\\n            if(start[i] == \\'L\\' && target[j] == \\'L\\')\\n                if(i< j)\\n                    return false;\\n            if(start[i] == \\'R\\' && target[j] == \\'R\\')\\n                if(i > j)\\n                    return false;\\n            if(start[i] != target[j])\\n                return false;\\n            ++i;\\n            ++j;\\n        }\\n        return cnt_s == cnt_t;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2327581,
                "title": "python-3-2-pointers",
                "content": "\\tclass Solution:\\n\\t\\tdef canChange(self, start: str, target: str) -> bool:\\n\\t\\t\\ti=j=0\\n\\t\\t\\tn=len(start)\\n\\t\\t\\twhile i<n or j<n:\\n\\t\\t\\t\\twhile i<n and start[i]==\\'_\\':\\n\\t\\t\\t\\t\\ti+=1\\n\\t\\t\\t\\twhile j<n and target[j]==\\'_\\':\\n\\t\\t\\t\\t\\tj+=1\\n\\t\\t\\t\\tif i==n or j==n:\\n\\t\\t\\t\\t\\treturn i==j\\n\\t\\t\\t\\tif start[i]!=target[j]:\\n\\t\\t\\t\\t\\treturn False\\n\\t\\t\\t\\tif start[i]==\\'L\\' and j>i or start[i]==\\'R\\' and i>j: # because \\'L\\' cannnot move to left and vice versa and None of them can jump each other\\n\\t\\t\\t\\t\\treturn False\\n\\t\\t\\t\\ti+=1\\n\\t\\t\\t\\tj+=1\\n\\t\\t\\treturn True",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef canChange(self, start: str, target: str) -> bool:\\n\\t\\t\\ti=j=0\\n\\t\\t\\tn=len(start)\\n\\t\\t\\twhile i<n or j<n:\\n\\t\\t\\t\\twhile i<n and start[i]==\\'_\\':\\n\\t\\t\\t\\t\\ti+=1\\n\\t\\t\\t\\twhile j<n and target[j]==\\'_\\':\\n\\t\\t\\t\\t\\tj+=1\\n\\t\\t\\t\\tif i==n or j==n:\\n\\t\\t\\t\\t\\treturn i==j\\n\\t\\t\\t\\tif start[i]!=target[j]:\\n\\t\\t\\t\\t\\treturn False\\n\\t\\t\\t\\tif start[i]==\\'L\\' and j>i or start[i]==\\'R\\' and i>j: # because \\'L\\' cannnot move to left and vice versa and None of them can jump each other\\n\\t\\t\\t\\t\\treturn False\\n\\t\\t\\t\\ti+=1\\n\\t\\t\\t\\tj+=1\\n\\t\\t\\treturn True",
                "codeTag": "Java"
            },
            {
                "id": 2286445,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canChange(string start, string target) \\n    {\\n        int n=start.size();\\n        vector<pair<char,int>>v1,v2;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(start[i]!=\\'_\\')v1.push_back({start[i],i});\\n            if(target[i]!=\\'_\\')v2.push_back({target[i],i});\\n        }\\n        if(v1.size()!=v2.size())return false;\\n        for(int i=0;i<v1.size();i++)\\n        {\\n            if(v1[i].first!=v2[i].first)return false;\\n            if(v1[i].first==\\'L\\')\\n            {\\n                if(v1[i].second<v2[i].second)return false;\\n            }else\\n            {\\n                if(v1[i].second>v2[i].second)return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canChange(string start, string target) \\n    {\\n        int n=start.size();\\n        vector<pair<char,int>>v1,v2;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(start[i]!=\\'_\\')v1.push_back({start[i],i});\\n            if(target[i]!=\\'_\\')v2.push_back({target[i],i});\\n        }\\n        if(v1.size()!=v2.size())return false;\\n        for(int i=0;i<v1.size();i++)\\n        {\\n            if(v1[i].first!=v2[i].first)return false;\\n            if(v1[i].first==\\'L\\')\\n            {\\n                if(v1[i].second<v2[i].second)return false;\\n            }else\\n            {\\n                if(v1[i].second>v2[i].second)return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2277148,
                "title": "simple-c-one-pass-scan-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canChange(string start, string target) {\\n        int i=0,j=0;\\n        while(true)\\n        {\\n            while(i < start.length() && start[i] == \\'_\\')\\n                 i++;\\n            while(j < target.length() && target[j] == \\'_\\')\\n                j++;\\n            if (i == start.length() && j == target.length())\\n                return true;\\n            else if ((i != start.length() && j == target.length())\\n                || (i == start.length() && j != target.length()))\\n                return false;\\n            else if (start[i] != target[j])\\n                return false;\\n            else if (start[i] == \\'L\\' && (i>=j))\\n                  i++,j++;\\n            else if (start[i] == \\'R\\' && (i<=j))\\n                  i++,j++;\\n            else\\n                return false;\\n        }\\n        return false;\\n    }\\n};\\n```\\n\\n\\nscan both the strings from start. \\nlets i is the index of scanner in start string,\\nj is the index of the scanner in the target string.\\n\\nmove i till you find an L or R.\\nmove j till you find an L or R.\\n\\nif start[i] or target[j] don\\'t match (i.e. one is R and one is L) then it is impossible to convert.\\nif start[i] and target[j] both are L, then j has to be in the left (lesser) of the i as we can only shift L to left.\\nSimilarly if both are R, then j has to be in the right of i (greater).\\n\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canChange(string start, string target) {\\n        int i=0,j=0;\\n        while(true)\\n        {\\n            while(i < start.length() && start[i] == \\'_\\')\\n                 i++;\\n            while(j < target.length() && target[j] == \\'_\\')\\n                j++;\\n            if (i == start.length() && j == target.length())\\n                return true;\\n            else if ((i != start.length() && j == target.length())\\n                || (i == start.length() && j != target.length()))\\n                return false;\\n            else if (start[i] != target[j])\\n                return false;\\n            else if (start[i] == \\'L\\' && (i>=j))\\n                  i++,j++;\\n            else if (start[i] == \\'R\\' && (i<=j))\\n                  i++,j++;\\n            else\\n                return false;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2274805,
                "title": "python3-10-lines-w-explanation-t-m-96-44",
                "content": "```\\nclass Solution:\\n                    # Criteria for a valid transormation:\\n\\n                    #   1) The # of Ls, # of Rs , and # of _s must be equal between the two strings\\n                    #\\n                    #   2) The ordering of Ls and Rs in the two strings must be the same.\\n                    #\\n                    #   3) Ls can only move left and Rs can only move right, so each L in start \\n                    #      cannot be to the left of its corresponding L in target, and each R cannot\\n                    #      be to the right of its corresponding R in target.\\n\\n    def canChange(self, start: str, target: str) -> bool:\\n                                                          \\n        if (len(start) != len(target) or \\n            start.count(\\'_\\') != target.count(\\'_\\')): return False   #  <-- Criterion 1\\n\\n        s = [(ch,i) for i, ch in enumerate(start ) if ch != \\'_\\']\\n        t = [(ch,i) for i, ch in enumerate(target) if ch != \\'_\\']\\n\\n        for i in range(len(s)):\\n            (sc, si), (tc,ti) = s[i], t[i]\\n            if sc != tc: return False                              # <-- Criteria 1 & 2\\n            if sc == \\'L\\' and si < ti: return False                 # <-- Criterion 3\\n            if sc == \\'R\\' and si > ti: return False                 # <--/\\n\\n        return True                                                # <-- It\\'s a winner!",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n                    # Criteria for a valid transormation:\\n\\n                    #   1) The # of Ls, # of Rs , and # of _s must be equal between the two strings\\n                    #\\n                    #   2) The ordering of Ls and Rs in the two strings must be the same.\\n                    #\\n                    #   3) Ls can only move left and Rs can only move right, so each L in start \\n                    #      cannot be to the left of its corresponding L in target, and each R cannot\\n                    #      be to the right of its corresponding R in target.\\n\\n    def canChange(self, start: str, target: str) -> bool:\\n                                                          \\n        if (len(start) != len(target) or \\n            start.count(\\'_\\') != target.count(\\'_\\')): return False   #  <-- Criterion 1\\n\\n        s = [(ch,i) for i, ch in enumerate(start ) if ch != \\'_\\']\\n        t = [(ch,i) for i, ch in enumerate(target) if ch != \\'_\\']\\n\\n        for i in range(len(s)):\\n            (sc, si), (tc,ti) = s[i], t[i]\\n            if sc != tc: return False                              # <-- Criteria 1 & 2\\n            if sc == \\'L\\' and si < ti: return False                 # <-- Criterion 3\\n            if sc == \\'R\\' and si > ti: return False                 # <--/\\n\\n        return True                                                # <-- It\\'s a winner!",
                "codeTag": "Java"
            },
            {
                "id": 2261962,
                "title": "easy-c-no-queues-just-vectors-explained",
                "content": "```\\n//Logic is store the number of L and R in with respect to their positions so that we can find if we can shift L or R accordingly \\n\\nclass Solution {\\npublic:\\n    bool canChange(string start, string target) {\\n    vector<pair<char, int>> v;\\n        vector<pair<char, int>> m;\\n    int a , b =0;\\n        for(int i =0;i<start.size();i++){\\n        if(start[i]==\\'L\\'){\\n            v.push_back({\\'L\\' , i});\\n        }\\n        else if ( start[i]==\\'R\\'){\\n            v.push_back({\\'R\\', i});\\n        }\\n        else{\\n            a++;\\n        }\\n    }\\n        \\n         for(int i =0;i<target.size();i++){\\n        if(target[i]==\\'L\\'){\\n            m.push_back({\\'L\\' , i});\\n        }\\n        else if ( target[i]==\\'R\\'){\\n            m.push_back({\\'R\\', i});\\n        }\\n        else{\\n            b++;\\n        }\\n    }\\n\\t// to check if the number of  blanks are extra then we cannot obtain target \\n        if(a!= b){\\n            \\n            return false;\\n        }\\n\\t\\t\\n\\t\\t\\n\\t\\t// if the element is R and it is appearing after in start with respect to target then we return false as we cannot move it left to make target .\\n        for(int  i =0;i<v.size();i++){\\n            if(v[i].first == m[i].first and v[i].first == \\'R\\'){\\n                \\n                if(v[i].second > m[i].second){\\n                    return false;\\n                }\\n            }\\n\\t\\t\\t// if the element is L and it is appearing before in  start with respect to target then return false as we  cannot move it right to make target \\n            else if (v[i].first == m[i].first and v[i].first == \\'L\\'){\\n                if(v[i].second <m[i].second){\\n                    return false;\\n                }\\n            }\\n\\t\\t\\t// if the arrangement is disordered eg - LR and RL \\n            else{\\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n\\t//  please upvote if you understood  :)) happy coding\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    bool canChange(string start, string target) {\\n    vector<pair<char, int>> v;\\n        vector<pair<char, int>> m;\\n    int a , b =0;\\n        for(int i =0;i<start.size();i++){\\n        if(start[i]==\\'L\\'){\\n            v.push_back({\\'L\\' , i}",
                "codeTag": "Java"
            },
            {
                "id": 2261680,
                "title": "java-two-pointers-solution-o-n-time-and-o-1-space",
                "content": "1. the number and order of pieces must not change\\n2. for a piece \\'L\\', its index in the target string must be equal to or less than its index in the start string\\n3. for a piece \\'R\\', its index in the target string must be equal to or greater than its index in the start string\\n```\\nclass Solution {\\n    public boolean canChange(String start, String target) {\\n        int i = 0, j = 0, n = start.length();\\n        while(i < n && j < n) {\\n            while(i < n && start.charAt(i) == \\'_\\') i++;\\n            while(j < n && target.charAt(j) == \\'_\\') j++;\\n            if(i == n && j == n) return true;\\n            if(i == n || j == n || start.charAt(i) != target.charAt(j)) return false;\\n            if(start.charAt(i) == \\'L\\' && i < j) return false;\\n            if(start.charAt(i) == \\'R\\' && i > j) return false;\\n            i++;\\n            j++;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canChange(String start, String target) {\\n        int i = 0, j = 0, n = start.length();\\n        while(i < n && j < n) {\\n            while(i < n && start.charAt(i) == \\'_\\') i++;\\n            while(j < n && target.charAt(j) == \\'_\\') j++;\\n            if(i == n && j == n) return true;\\n            if(i == n || j == n || start.charAt(i) != target.charAt(j)) return false;\\n            if(start.charAt(i) == \\'L\\' && i < j) return false;\\n            if(start.charAt(i) == \\'R\\' && i > j) return false;\\n            i++;\\n            j++;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2261295,
                "title": "easy-c-stack-greedy-approach-o-n",
                "content": "Simple Stack Solution given below:\\n\\n```\\nclass Solution {\\npublic:\\n    bool canChange(string s1, string s2) {\\n        stack<pair<char, int>> st1, st2;\\n        int i, n = s1.size();\\n        for(i=0; i<n; i++)\\n        {\\n            if(s1[i]==\\'L\\')\\n            {\\n                st1.push({\\'L\\', i});\\n            }\\n            else if(s1[i]==\\'R\\')\\n            {\\n                st1.push({\\'R\\', i});\\n            }\\n            if(s2[i]==\\'L\\')\\n            {\\n                st2.push({\\'L\\', i});\\n            }\\n            else if(s2[i]==\\'R\\')\\n            {\\n                st2.push({\\'R\\', i});\\n            }\\n        }\\n        \\n        // If number of L\\'s and R\\'s in st1 and st2 are not same \\n        if(st1.size() != st2.size())\\n        {\\n            return false;\\n        }\\n        while(!st1.empty() and !st2.empty())\\n        {\\n            // If the sequence is not same, then it is always impossible\\n            if(st1.top().first != st2.top().first)\\n            {\\n                return false;\\n            }\\n            \\n            if(st1.top().first == \\'R\\')\\n            {\\n                // If R in s1 is ahead of R in target string, then we can never move it towards the left\\n                // Therefore, it is always impossible\\n                if(st1.top().second > st2.top().second)\\n                {\\n                    return false;\\n                }\\n            }\\n            else\\n            {\\n                // If L in s1 is before of L in target string, then we can never move it towards the right\\n                // Therefore, it is always impossible\\n                if(st1.top().second < st2.top().second)\\n                {\\n                    return false;\\n                }\\n            }\\n            st1.pop();\\n            st2.pop();\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canChange(string s1, string s2) {\\n        stack<pair<char, int>> st1, st2;\\n        int i, n = s1.size();\\n        for(i=0; i<n; i++)\\n        {\\n            if(s1[i]==\\'L\\')\\n            {\\n                st1.push({\\'L\\', i});\\n            }\\n            else if(s1[i]==\\'R\\')\\n            {\\n                st1.push({\\'R\\', i});\\n            }\\n            if(s2[i]==\\'L\\')\\n            {\\n                st2.push({\\'L\\', i});\\n            }\\n            else if(s2[i]==\\'R\\')\\n            {\\n                st2.push({\\'R\\', i});\\n            }\\n        }\\n        \\n        // If number of L\\'s and R\\'s in st1 and st2 are not same \\n        if(st1.size() != st2.size())\\n        {\\n            return false;\\n        }\\n        while(!st1.empty() and !st2.empty())\\n        {\\n            // If the sequence is not same, then it is always impossible\\n            if(st1.top().first != st2.top().first)\\n            {\\n                return false;\\n            }\\n            \\n            if(st1.top().first == \\'R\\')\\n            {\\n                // If R in s1 is ahead of R in target string, then we can never move it towards the left\\n                // Therefore, it is always impossible\\n                if(st1.top().second > st2.top().second)\\n                {\\n                    return false;\\n                }\\n            }\\n            else\\n            {\\n                // If L in s1 is before of L in target string, then we can never move it towards the right\\n                // Therefore, it is always impossible\\n                if(st1.top().second < st2.top().second)\\n                {\\n                    return false;\\n                }\\n            }\\n            st1.pop();\\n            st2.pop();\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2513105,
                "title": "c-simple-c-code",
                "content": "\\n# **If you like the implementation then Please help me by increasing my reputation. By clicking the up arrow on the left of my image.**\\n```\\nclass Solution {\\npublic:\\n    bool canChange(string start, string target) {\\n        int end = target.size();\\n        int ScntL = 0, ScntR = 0, TcntL = 0, TcntR = 0;\\n        string ss = \"\", st = \"\";\\n        for(int i = 0; i < end; i++)\\n        {\\n            if(start[i] != \\'_\\')\\n                ss += start[i];\\n            if(target[i] != \\'_\\')\\n                st += target[i];\\n        }\\n        if(ss != st) return false;\\n        for(int i = 0; i < end; i++)\\n        {\\n            if(start[i] == \\'L\\')\\n                ScntL++;\\n            if(target[i] == \\'L\\')\\n                TcntL++;\\n            if(ScntL > TcntL)\\n                return false;\\n        }\\n        if(ScntL != TcntL)\\n            return false;\\n        for(int i = 0; i < end; i++)\\n        {\\n            if(start[i] == \\'R\\')\\n                ScntR++;\\n            if(target[i] == \\'R\\')\\n                TcntR++;\\n            if(ScntR < TcntR)\\n                return false;\\n        }\\n        if(ScntR != TcntR)\\n            return false;\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canChange(string start, string target) {\\n        int end = target.size();\\n        int ScntL = 0, ScntR = 0, TcntL = 0, TcntR = 0;\\n        string ss = \"\", st = \"\";\\n        for(int i = 0; i < end; i++)\\n        {\\n            if(start[i] != \\'_\\')\\n                ss += start[i];\\n            if(target[i] != \\'_\\')\\n                st += target[i];\\n        }\\n        if(ss != st) return false;\\n        for(int i = 0; i < end; i++)\\n        {\\n            if(start[i] == \\'L\\')\\n                ScntL++;\\n            if(target[i] == \\'L\\')\\n                TcntL++;\\n            if(ScntL > TcntL)\\n                return false;\\n        }\\n        if(ScntL != TcntL)\\n            return false;\\n        for(int i = 0; i < end; i++)\\n        {\\n            if(start[i] == \\'R\\')\\n                ScntR++;\\n            if(target[i] == \\'R\\')\\n                TcntR++;\\n            if(ScntR < TcntR)\\n                return false;\\n        }\\n        if(ScntR != TcntR)\\n            return false;\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2479553,
                "title": "two-pointer-easy-fast-commented",
                "content": "Thanks to [koroja3877](https://leetcode.com/koroja3877/) for the answer, here is my explaination with comments for easy understanding.\\n\\n\\tvar canChange = function (start, target) {\\n\\t\\tlet lCount = 0;//count of l\\'s in target, to be consumed later in start\\n\\t\\tlet rCount = 0;//count of r\\'s in start, to be consumed later in target\\n\\n\\t\\tfor (let i = 0; i < start.length; i++) {\\n\\t\\t\\tif (start[i] === \"R\") rCount++;//add r to count\\n\\t\\t\\tif (start[i] === \"L\") lCount--;//remove l from count\\n\\n\\t\\t\\tif (target[i] === \"L\" && rCount > 0) return false;//if L in start is blocked by R\\n\\t\\t\\tif (start[i] === \"L\" && rCount > 0) return false;//if there is an unsetteled R in start\\n\\n\\t\\t\\tif (target[i] === \"L\") lCount++;//add l to count\\n\\t\\t\\tif (target[i] === \"R\") rCount--;//remove r from count\\n\\n\\t\\t\\tif (lCount< 0 || rCount < 0) return false;//check if the requirements are less than available\\n\\t\\t}\\n\\t\\treturn !lCount && !rCount;//count should return to zero as all L and R are consumed\\n\\t};",
                "solutionTags": [
                    "JavaScript",
                    "Two Pointers"
                ],
                "code": "Thanks to [koroja3877](https://leetcode.com/koroja3877/) for the answer, here is my explaination with comments for easy understanding.\\n\\n\\tvar canChange = function (start, target) {\\n\\t\\tlet lCount = 0;//count of l\\'s in target, to be consumed later in start\\n\\t\\tlet rCount = 0;//count of r\\'s in start, to be consumed later in target\\n\\n\\t\\tfor (let i = 0; i < start.length; i++) {\\n\\t\\t\\tif (start[i] === \"R\") rCount++;//add r to count\\n\\t\\t\\tif (start[i] === \"L\") lCount--;//remove l from count\\n\\n\\t\\t\\tif (target[i] === \"L\" && rCount > 0) return false;//if L in start is blocked by R\\n\\t\\t\\tif (start[i] === \"L\" && rCount > 0) return false;//if there is an unsetteled R in start\\n\\n\\t\\t\\tif (target[i] === \"L\") lCount++;//add l to count\\n\\t\\t\\tif (target[i] === \"R\") rCount--;//remove r from count\\n\\n\\t\\t\\tif (lCount< 0 || rCount < 0) return false;//check if the requirements are less than available\\n\\t\\t}\\n\\t\\treturn !lCount && !rCount;//count should return to zero as all L and R are consumed\\n\\t};",
                "codeTag": "Unknown"
            },
            {
                "id": 2307858,
                "title": "javascript-one-pass-o-n-runtime-o-1-space",
                "content": "```\\nvar canChange = function (start, target) {\\n    let l = 0\\n    let r = 0\\n\\n    for (let i = 0; i < start.length; i++) {\\n        if (start[i] === \"R\") r++\\n        if (start[i] === \"L\") l--\\n\\n        /**\\n         * If we encountered L and there is R that has not reached the target,\\n         * then we know that this L is blocking the way\\n         */\\n        if (target[i] === \"L\" && r > 0) return false\\n        if (start[i] === \"L\" && r > 0) return false\\n\\n        if (target[i] === \"L\") l++\\n        if (target[i] === \"R\") r--\\n\\n        if (l < 0 || r < 0) return false\\n    }\\n\\n    /**\\n     * Final l and r count must be zero\\n     */\\n    return !l && !r\\n\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar canChange = function (start, target) {\\n    let l = 0\\n    let r = 0\\n\\n    for (let i = 0; i < start.length; i++) {\\n        if (start[i] === \"R\") r++\\n        if (start[i] === \"L\") l--\\n\\n        /**\\n         * If we encountered L and there is R that has not reached the target,\\n         * then we know that this L is blocking the way\\n         */\\n        if (target[i] === \"L\" && r > 0) return false\\n        if (start[i] === \"L\" && r > 0) return false\\n\\n        if (target[i] === \"L\") l++\\n        if (target[i] === \"R\") r--\\n\\n        if (l < 0 || r < 0) return false\\n    }\\n\\n    /**\\n     * Final l and r count must be zero\\n     */\\n    return !l && !r\\n\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2300020,
                "title": "easy-java-solution",
                "content": "```\\nclass Solution {\\n    public boolean canChange(String s, String e) {\\n        if(s.length() != e.length() ) return false;\\n        if(s.equals(e) ) return true;\\n        int n = s.length();\\n        \\n        \\n        if(s.replace(\"_\",\"\").equals(e.replace(\"_\",\"\")) == false) return false;\\n        \\n        // System.out.println(\"lll\");\\n        int i = 0; int j = 0;\\n        \\n        while(i < n && j < n){\\n            while(i < n && s.charAt(i) != \\'R\\') i++;\\n            while(j < n && e.charAt(j) != \\'R\\') j++;\\n            \\n            if(i > j) return false;\\n            i++;\\n            j++;\\n            \\n        }\\n        i = 0; j = 0;\\n        \\n        while(i < n && j < n){\\n            while(i < n && s.charAt(i) != \\'L\\') i++;\\n            while(j < n && e.charAt(j) != \\'L\\') j++;\\n            \\n            if(j > i) return false;\\n            i++;\\n            j++;\\n            \\n        }\\n        \\n        return true;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "class Solution {\\n    public boolean canChange(String s, String e) {\\n        if(s.length() != e.length() ) return false;\\n        if(s.equals(e) ) return true;\\n        int n = s.length();\\n        \\n        \\n        if(s.replace(\"_\",\"\").equals(e.replace(\"_\",\"\")) == false) return false;\\n        \\n        // System.out.println(\"lll\");\\n        int i = 0; int j = 0;\\n        \\n        while(i < n && j < n){\\n            while(i < n && s.charAt(i) != \\'R\\') i++;\\n            while(j < n && e.charAt(j) != \\'R\\') j++;\\n            \\n            if(i > j) return false;\\n            i++;\\n            j++;\\n            \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2286713,
                "title": "can-someone-comment-on-how-did-you-think-of-the-solution-basically-the-thought-process",
                "content": "**I took really long during the contest to think of the solution. Started with thinking of DP and then narrowed down to DFS and then  thought to have two pointers on both ends of start string to move L and R to left and right most sides.. and so on. But I couldnt think of the solution within time. Can you guys please share your thought process here**",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "Two Pointers",
                    "String"
                ],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 2282842,
                "title": "c-o-n-time-o-1-space",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canChange(string start, string target) {\\n        int L=0,R=0;\\n        for(int i=0;i<start.size();i++)\\n        {\\n            if(start[i]==\\'R\\')\\n            {\\n                if(L!=0 || R<0) return false;\\n                R++;\\n            }\\n            \\n            if(target[i]==\\'R\\')\\n            {\\n                if(L!=0 || R<=0) return false;\\n                R--;\\n            }\\n            else if(target[i]==\\'L\\')\\n            {\\n                if(R!=0 || L<0) return false;\\n                L++;\\n            }\\n            \\n            if(start[i]==\\'L\\')\\n            {\\n                if(R!=0 || L<=0) return false;\\n                L--;\\n            }\\n        }\\n        return (R==0 && L==0);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canChange(string start, string target) {\\n        int L=0,R=0;\\n        for(int i=0;i<start.size();i++)\\n        {\\n            if(start[i]==\\'R\\')\\n            {\\n                if(L!=0 || R<0) return false;\\n                R++;\\n            }\\n            \\n            if(target[i]==\\'R\\')\\n            {\\n                if(L!=0 || R<=0) return false;\\n                R--;\\n            }\\n            else if(target[i]==\\'L\\')\\n            {\\n                if(R!=0 || L<0) return false;\\n                L++;\\n            }\\n            \\n            if(start[i]==\\'L\\')\\n            {\\n                if(R!=0 || L<=0) return false;\\n                L--;\\n            }\\n        }\\n        return (R==0 && L==0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2279726,
                "title": "kotlin-solution-simple-two-pointer-explained",
                "content": "1. check if start and target have the same amount of letters\\n2. have two pointers to get the next letter in start and target\\n3. check if the letter from start can be moved to the same index as the letter from target\\n\\n```\\n    fun canChange(start: String, target: String): Boolean {\\n        val str = start.replace(\"_\", \"\")\\n        val str2 = target.replace(\"_\", \"\")\\n        if (str.length!=str2.length) return false\\n        var i = 0\\n        var j = -1\\n        while (i<target.length) {\\n            if (target[i] != \\'_\\') {\\n                j++\\n                while (j<start.length-1 && start[j]==\\'_\\') j++\\n                if (start[j]!=target[i]) return false\\n\\n                if (start[j]==\\'L\\') if (i>j) return false\\n                if (start[j]==\\'R\\') if (i<j) return false\\n            }\\n            i++\\n        }\\n        return true\\n    }\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Two Pointers"
                ],
                "code": "```\\n    fun canChange(start: String, target: String): Boolean {\\n        val str = start.replace(\"_\", \"\")\\n        val str2 = target.replace(\"_\", \"\")\\n        if (str.length!=str2.length) return false\\n        var i = 0\\n        var j = -1\\n        while (i<target.length) {\\n            if (target[i] != \\'_\\') {\\n                j++\\n                while (j<start.length-1 && start[j]==\\'_\\') j++\\n                if (start[j]!=target[i]) return false\\n\\n                if (start[j]==\\'L\\') if (i>j) return false\\n                if (start[j]==\\'R\\') if (i<j) return false\\n            }\\n            i++\\n        }\\n        return true\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2276603,
                "title": "o-n-solution-fully-explained",
                "content": "\"\"\" public boolean canChange(String start, String target) {\\n        \\n        // Here in the problem We can See that the order in which elements appear in src and target must not be different \\n        // If the ordering is different then we can simply return false\\n        // this is so Bcoz Lets have src=\"_ R _ _ _ _ L _\"\\n        // Then we can move R to any right place but when it is immediately before L (ie. _ _ _ _ _ RL _) then no extra space is left for\\n        // R to move so there is no way R can cross L and hence we can say that Relative order in which elements appear in the string \\n        // remains constant.\\n        \\n        int si=0;\\n        int ti=0;\\n        while(si<start.length() || ti< target.length()){\\n            \\n            // Now our main focus is to compare the elements so we can leave the indices which have \\'_\\' \\n            \\n            while(si<start.length() && start.charAt(si)==\\'_\\')\\n                si++;\\n            \\n            while(ti< target.length() && target.charAt(ti)==\\'_\\')\\n                ti++;\\n            \\n            // Now it might be that you reached the end of a string\\n            \\n            // So if you have reached the end of both the STrings that means that string have been fully compared and everything seems \\n            // Fine so we can return True \\n            \\n            if(si==start.length() && ti == target.length()){\\n                return true;\\n            }\\n            \\n            // But if you have reached the end of one string but there are still characters remaing in the other string\\n            // then obviously now no comparison can be made and hance we can return False\\n            \\n            if(si==start.length() || ti== target.length()){\\n                return false;\\n            }\\n            \\n            // If none of the above conditions holds true that means we are at some character\\n            \\n            // So if these characters are not same that means relative Ordering is different\\n            // So we can return False\\n            if(start.charAt(si) != target.charAt(ti))\\n                return false;\\n            \\n            // Since you are at this point that means characters must be matching\\n            \\n            // Now you have to check if L in src String is farther from target L or not \\n            // Ie src = \" _ _ _ _ L\" and target = \" _ _ L _ _\"  so L in src string is at idx 4 while in target it is at 2\\n            // So L in src can move left to cover that place but what if \\n            // src=\" _ _ L _ _\" and target = \" _ _ _ L _\" now L can only move left and not right so return false for this conditions as well\\n            \\n            if(start.charAt(si)==\\'L\\' && si<ti )\\n                return false;\\n            \\n            // Similarly you can do the same thing for R as well\\n            \\n            if(start.charAt(si)==\\'R\\' && si > ti)\\n                return false;\\n            \\n            // Do this till all elements are not compared\\n            si++;\\n            ti++;\\n            \\n        }\\n        \\n        // If you are this point that means all conditions have passed well so we can now return True\\n        return true;\\n    }\\n\\n\"\"\"",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "\"\"\" public boolean canChange(String start, String target) {\\n        \\n        // Here in the problem We can See that the order in which elements appear in src and target must not be different \\n        // If the ordering is different then we can simply return false\\n        // this is so Bcoz Lets have src=\"_ R _ _ _ _ L _\"\\n        // Then we can move R to any right place but when it is immediately before L (ie. _ _ _ _ _ RL _) then no extra space is left for\\n        // R to move so there is no way R can cross L and hence we can say that Relative order in which elements appear in the string \\n        // remains constant.\\n        \\n        int si=0;\\n        int ti=0;\\n        while(si<start.length() || ti< target.length()){\\n            \\n            // Now our main focus is to compare the elements so we can leave the indices which have \\'_\\' \\n            \\n            while(si<start.length() && start.charAt(si)==\\'_\\')\\n                si++;\\n            \\n            while(ti< target.length() && target.charAt(ti)==\\'_\\')\\n                ti++;\\n            \\n            // Now it might be that you reached the end of a string\\n            \\n            // So if you have reached the end of both the STrings that means that string have been fully compared and everything seems \\n            // Fine so we can return True \\n            \\n            if(si==start.length() && ti == target.length()){\\n                return true;\\n            }\\n            \\n            // But if you have reached the end of one string but there are still characters remaing in the other string\\n            // then obviously now no comparison can be made and hance we can return False\\n            \\n            if(si==start.length() || ti== target.length()){\\n                return false;\\n            }\\n            \\n            // If none of the above conditions holds true that means we are at some character\\n            \\n            // So if these characters are not same that means relative Ordering is different\\n            // So we can return False\\n            if(start.charAt(si) != target.charAt(ti))\\n                return false;\\n            \\n            // Since you are at this point that means characters must be matching\\n            \\n            // Now you have to check if L in src String is farther from target L or not \\n            // Ie src = \" _ _ _ _ L\" and target = \" _ _ L _ _\"  so L in src string is at idx 4 while in target it is at 2\\n            // So L in src can move left to cover that place but what if \\n            // src=\" _ _ L _ _\" and target = \" _ _ _ L _\" now L can only move left and not right so return false for this conditions as well\\n            \\n            if(start.charAt(si)==\\'L\\' && si<ti )\\n                return false;\\n            \\n            // Similarly you can do the same thing for R as well\\n            \\n            if(start.charAt(si)==\\'R\\' && si > ti)\\n                return false;\\n            \\n            // Do this till all elements are not compared\\n            si++;\\n            ti++;\\n            \\n        }\\n        \\n        // If you are this point that means all conditions have passed well so we can now return True\\n        return true;\\n    }\\n\\n\"\"\"",
                "codeTag": "Unknown"
            },
            {
                "id": 2270421,
                "title": "java-one-pass-all-test-cases-passed",
                "content": "There are three restrictions:\\n1. the number and sequence of L and R should be equal\\n2. L can not be moved to the right\\n3. R can not be moved to the left\\n\\nThere are several new cases, say \"L\" and \"LL\".\\nThe following code can pass all the test cases. Hope it helps!\\n```\\nclass Solution {\\n    public boolean canChange(String start, String target) {\\n        int i = 0;\\n        int j = 0;\\n        int n = start.length();\\n        \\n        while (i < n || j < n) {\\n            while (i < n && start.charAt(i) == \\'_\\') i++;\\n            while (j < n && target.charAt(j) == \\'_\\') j++;\\n            \\n            // should both reach the end to check the number of L and R\\n            // e.g. \"_L\" and \"LL\"\\n            if (i == n && j == n) return true;\\n            if (i == n || j == n) return false; \\n            \\n            if (start.charAt(i) != target.charAt(j)) return false; // the same squence of R and L\\n            \\n            if (start.charAt(i) == \\'L\\' && i < j) return false; // can not move L to the right\\n            if (start.charAt(i) == \\'R\\' && i > j) return false; // can not move R to the left\\n            \\n            i++;\\n            j++;\\n        }\\n        \\n        return i == n && j == n;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canChange(String start, String target) {\\n        int i = 0;\\n        int j = 0;\\n        int n = start.length();\\n        \\n        while (i < n || j < n) {\\n            while (i < n && start.charAt(i) == \\'_\\') i++;\\n            while (j < n && target.charAt(j) == \\'_\\') j++;\\n            \\n            // should both reach the end to check the number of L and R\\n            // e.g. \"_L\" and \"LL\"\\n            if (i == n && j == n) return true;\\n            if (i == n || j == n) return false; \\n            \\n            if (start.charAt(i) != target.charAt(j)) return false; // the same squence of R and L\\n            \\n            if (start.charAt(i) == \\'L\\' && i < j) return false; // can not move L to the right\\n            if (start.charAt(i) == \\'R\\' && i > j) return false; // can not move R to the left\\n            \\n            i++;\\n            j++;\\n        }\\n        \\n        return i == n && j == n;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2266946,
                "title": "c-space-o-1-time-o-n-easy-solution-explanation",
                "content": "**Approach:**\\n*  Let us think of a naive approach:\\n\\t* We realise that if we see a `L` in target => our `L` in start string should be after the  `L` in target string.  We also realise all the letter b/w the start index till the target index of `L` should be `_` so that `L` in start string can move left back and reach its target location.\\n\\t* Similarly, if we see a `R` in target => our `R` in start string should be before the  `R` in target string. Also all the indices b/w these location should contain `_`\\n\\t* We could intially maybe store all indices of `L` and `R` in target and start strings and check if these constraints are met. But this will be nearly O(n^2) and exceeded time limit.\\n\\n* Now let us see how we can solve in O(n), an optimised approach:\\n\\t* let us iterate through the start and target string.\\n\\t* if we see a `L` in target string we update the number of `L` s we need to find later on in the start string in a variable `left` . We realise if before we exhaust all `L` s that we need to find in start string, if we encounter any charecter except `_` and `L` which is basically `R` we cannot move `L` and therefore not reach target string.\\n\\t* similarly if we see a `R` in start string, we update the number of `R` s we need to find later on in the target string in a variable `right` . we should not encounter an `L` before we exhaust all `R`. \\n\\t* at the end we make sure we have exhausted all `L` and `R` . We keep this extra check in case we have more `L` or `R` in either strings.\\n```\\nclass Solution {\\npublic:\\n    bool canChange(string start, string target) {\\n       int left = 0;\\n       int right = 0;\\n       int l=0;\\n       int r=0;\\n       int n = start.size();\\n        \\n       for(int i=0; i<n; i++){\\n           if(target[i]==\\'L\\') left++;\\n           if(start[i]==\\'R\\')  right++;\\n           \\n           if(left && start[i]==\\'R\\') return 0;\\n           if(!left && start[i]==\\'L\\') return 0;\\n           if(left && start[i]==\\'L\\') left--;\\n\\n           \\n           if(right && target[i]==\\'L\\') return 0;\\n           if(!right && target[i]==\\'R\\') return 0;\\n           if(right && target[i]==\\'R\\') right--;   \\n       }\\n        \\n        if(!right && !left){\\n            return 1;\\n        }\\n        return 0;\\n    }\\n};\\n```\\nHope this helps!",
                "solutionTags": [
                    "C++",
                    "C",
                    "String",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canChange(string start, string target) {\\n       int left = 0;\\n       int right = 0;\\n       int l=0;\\n       int r=0;\\n       int n = start.size();\\n        \\n       for(int i=0; i<n; i++){\\n           if(target[i]==\\'L\\') left++;\\n           if(start[i]==\\'R\\')  right++;\\n           \\n           if(left && start[i]==\\'R\\') return 0;\\n           if(!left && start[i]==\\'L\\') return 0;\\n           if(left && start[i]==\\'L\\') left--;\\n\\n           \\n           if(right && target[i]==\\'L\\') return 0;\\n           if(!right && target[i]==\\'R\\') return 0;\\n           if(right && target[i]==\\'R\\') right--;   \\n       }\\n        \\n        if(!right && !left){\\n            return 1;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2263198,
                "title": "python-just-compare",
                "content": "```\\nclass Solution:\\n    def canChange(self, start: str, target: str) -> bool:        \\n        N1, N2 = len(start), len(target)        \\n        if N1 != N2: return False        \\n        if start.replace(\\'_\\', \\'\\') != target.replace(\\'_\\', \\'\\'):  return False\\n        \\n        pos1 = []\\n        pos2 = []\\n                \\n        for i in range(N1):\\n            if start[i] != \\'_\\': pos1.append((start[i], i))\\n            if target[i] != \\'_\\': pos2.append((target[i], i))\\n                \\n        for i in range(len(pos1)):\\n            if pos1[i][0] == \\'R\\' and pos1[i][1] > pos2[i][1]: return False\\n            if pos1[i][0] == \\'L\\' and pos1[i][1] < pos2[i][1]: return False\\n                \\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def canChange(self, start: str, target: str) -> bool:        \\n        N1, N2 = len(start), len(target)        \\n        if N1 != N2: return False        \\n        if start.replace(\\'_\\', \\'\\') != target.replace(\\'_\\', \\'\\'):  return False\\n        \\n        pos1 = []\\n        pos2 = []\\n                \\n        for i in range(N1):\\n            if start[i] != \\'_\\': pos1.append((start[i], i))\\n            if target[i] != \\'_\\': pos2.append((target[i], i))\\n                \\n        for i in range(len(pos1)):\\n            if pos1[i][0] == \\'R\\' and pos1[i][1] > pos2[i][1]: return False\\n            if pos1[i][0] == \\'L\\' and pos1[i][1] < pos2[i][1]: return False\\n                \\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2262681,
                "title": "c-tc-o-n-stack-solution-greedy",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canChange(string a, string b) {\\n        if(a.size()!=b.size())\\n        {\\n            return false;\\n        }\\n        \\n        stack<pair<char,int>> st;\\n        int n=a.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(b[i]!=\\'_\\')\\n            {\\n                st.push({b[i],i});\\n            }\\n          \\n        }\\n        \\n        for(int i=n-1;i>=0;i--)\\n        {\\n            \\n            \\n            if(a[i]!=\\'_\\')\\n            {\\n                if(st.size()==0)\\n                {\\n                    return false;\\n                }\\n               auto curr=st.top();\\n               char x=curr.first;\\n               int y=curr.second;\\n                if(x!=a[i])\\n                {\\n                    return false;\\n                }\\n                \\n               if(x==\\'R\\' and x==a[i])\\n               {\\n                   if(i<=y)\\n                   {\\n                        st.pop();\\n                     \\n                   }\\n                   else\\n                   {\\n                        return false;\\n                   }\\n               }\\n\\n               if(x==\\'L\\' and x==a[i])\\n               {\\n                   if(i>=y)\\n                   {\\n                       st.pop();\\n                     \\n                   }\\n                   else\\n                   {\\n                         return false;\\n                   }\\n               }\\n            }\\n        }\\n        if(st.size()==0)\\n        {\\n            return true;\\n        }\\n        return false;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Stack",
                    "Greedy"
                ],
                "code": "class Solution {\\npublic:\\n    bool canChange(string a, string b) {\\n        if(a.size()!=b.size())\\n        {\\n            return false;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2262667,
                "title": "easy-to-understand-o-n",
                "content": "Please , Upvote if you understand\\n```\\nclass Solution {\\npublic:\\n    bool canChange(string s, string t) {\\n        string a=\"\",b=\"\";\\n        vector<int> pos1,pos2;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s[i]!=\\'_\\')\\n            {\\n                a+=s[i];\\n                pos1.push_back(i);\\n            }\\n        }\\n         for(int i=0;i<t.length();i++)\\n        {\\n            if(t[i]!=\\'_\\')\\n            {\\n                b+=t[i];\\n                pos2.push_back(i);\\n            }\\n        }\\n        if(a!=b)\\n            return false;\\n        for(int i=0;i<a.size();i++)\\n        {\\n            if(a[i]==\\'L\\')\\n            {\\n                if(pos1[i]<pos2[i])return false;\\n            }\\n            else\\n            {\\n                if(pos1[i]>pos2[i])return false;\\n            }\\n        }\\n        return true;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    bool canChange(string s, string t) {\\n        string a=\"\",b=\"\";\\n        vector<int> pos1,pos2;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s[i]!=\\'_\\')\\n            {\\n                a+=s[i];\\n                pos1.push_back(i);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2262006,
                "title": "c-17-lines-with-comments-o-n-time-o-1-space",
                "content": "```\\npublic class Solution \\n{\\n    public bool CanChange(string start, string target) \\n    {\\n        int startR = 0, // free R\\'s in start\\n            targetL = 0; // needed L\\'s for target\\n\\t\\t\\t\\n        foreach ((int startC, int targetC) in start.Zip(target)) \\n        {\\n            if (startC == \\'R\\') ++startR; // we can move this R\\'s to the right later\\n            if (targetC == \\'L\\') ++targetL; // we need this L\\'s, hope they will come to us later\\n            \\n            if (startC == \\'L\\') \\n            {\\n                if (targetL == 0 || startR != 0) return false; // target doesn\\'t need L, or we didn\\'t finished with R\\'s yet\\n                --targetL; // target gets L\\n            }\\n            if (targetC == \\'R\\')\\n            {\\n                if (startR == 0 || targetL != 0) return false; // we don\\'t have free R or target want L\\'s first\\n                --startR; // yeah we have that R for you\\n            } \\n        }\\n        return targetL == 0 && startR == 0; // everyone is satisfied\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution \\n{\\n    public bool CanChange(string start, string target) \\n    {\\n        int startR = 0, // free R\\'s in start\\n            targetL = 0; // needed L\\'s for target\\n\\t\\t\\t\\n        foreach ((int startC, int targetC) in start.Zip(target)) \\n        {\\n            if (startC == \\'R\\') ++startR; // we can move this R\\'s to the right later\\n            if (targetC == \\'L\\') ++targetL; // we need this L\\'s, hope they will come to us later\\n            \\n            if (startC == \\'L\\') \\n            {\\n                if (targetL == 0 || startR != 0) return false; // target doesn\\'t need L, or we didn\\'t finished with R\\'s yet\\n                --targetL; // target gets L\\n            }\\n            if (targetC == \\'R\\')\\n            {\\n                if (startR == 0 || targetL != 0) return false; // we don\\'t have free R or target want L\\'s first\\n                --startR; // yeah we have that R for you\\n            } \\n        }\\n        return targetL == 0 && startR == 0; // everyone is satisfied\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2261953,
                "title": "easy-cpp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkFreq(string start,string target)\\n    {\\n        int a1=0,a2=0,a3=0,b1=0,b2=0,b3=0;\\n        for(int i=0;i<start.size();i++)\\n        {\\n            if(start[i]==\\'L\\')a1++;\\n            if(start[i]==\\'R\\')a2++;\\n            if(start[i]==\\'_\\')a3++;\\n            \\n            if(target[i]==\\'L\\')b1++;\\n            if(target[i]==\\'R\\')b2++;\\n            if(target[i]==\\'_\\')b3++;\\n            \\n        }\\n        return a1==b1&&a2==b2&&a3==b3;\\n    }\\n    bool canChange(string start, string target) {\\n        // Check if number of dashes L and R are equal\\n        if(checkFreq(start,target)==false)return false;\\n        \\n        vector<int>prevR;\\n        vector<int>afterL;\\n        \\n        vector<int>prevR1;\\n        vector<int>afterL1;\\n        \\n        //Checking if number of R before every L in start and target are same or not\\n        int count1=0,count2=0;                 \\n        for(int i=0;i<start.size();i++)\\n        {\\n            if(start[i]==\\'R\\')count1++;\\n            if(start[i]==\\'L\\')prevR.push_back(count1);\\n            \\n            if(target[i]==\\'R\\')count2++;\\n            if(target[i]==\\'L\\')prevR1.push_back(count2);\\n            \\n        }\\n        for(int i=0;i<prevR.size();i++)\\n        {\\n            if(prevR1[i]!=prevR[i])return false;\\n        }\\n        \\n        //Checking if number of L after every R in start and target are same or not\\n        count1=0;count2=0;        \\n        for(int i=start.size()-1;i>=0;i--)\\n        {\\n            if(start[i]==\\'L\\')count1++;\\n            if(start[i]==\\'R\\')afterL.push_back(count1);\\n            \\n            if(target[i]==\\'L\\')count2++;\\n            if(target[i]==\\'R\\')afterL1.push_back(count2);            \\n        }\\n        for(int i=0;i<afterL1.size();i++)\\n        {\\n            if(afterL1[i]!=afterL[i])return false;\\n        }\\n        \\n//     Checking if number if dashes before every L are >= than that in target\\n        vector<int>prevDashesStart;\\n        vector<int>afterDashesStart;\\n        vector<int>prevDashesTarget;\\n        vector<int>afterDashesTarget;        \\n        count1=0;count2=0;\\n        for(int i=0;i<start.size();i++)\\n        {\\n            if(start[i]==\\'_\\')count1++;\\n            if(start[i]==\\'L\\')prevDashesStart.push_back(count1);\\n            \\n            if(target[i]==\\'_\\')count2++;\\n            if(target[i]==\\'L\\')prevDashesTarget.push_back(count2); \\n        }\\n        for(int i=0;i<prevDashesStart.size();i++)\\n        {\\n            if(prevDashesStart[i]<prevDashesTarget[i])return false;\\n        }\\n        //     Checking if number if dashes after every R are >= than that in target\\n        count1=0;count2=0;\\n        for(int i=start.size()-1;i>=0;i--)\\n        {\\n            if(start[i]==\\'_\\')count1++;\\n            if(start[i]==\\'R\\')afterDashesStart.push_back(count1); \\n            \\n            if(target[i]==\\'_\\')count2++;\\n            if(target[i]==\\'R\\')afterDashesTarget.push_back(count2); \\n        }\\n        \\n        for(int i=0;i<afterDashesTarget.size();i++)\\n        {\\n            if(afterDashesStart[i]<afterDashesTarget[i])return false;\\n        }\\n        \\n        return true;        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkFreq(string start,string target)\\n    {\\n        int a1=0,a2=0,a3=0,b1=0,b2=0,b3=0;\\n        for(int i=0;i<start.size();i++)\\n        {\\n            if(start[i]==\\'L\\')a1++;\\n            if(start[i]==\\'R\\')a2++;\\n            if(start[i]==\\'_\\')a3++;\\n            \\n            if(target[i]==\\'L\\')b1++;\\n            if(target[i]==\\'R\\')b2++;\\n            if(target[i]==\\'_\\')b3++;\\n            \\n        }\\n        return a1==b1&&a2==b2&&a3==b3;\\n    }\\n    bool canChange(string start, string target) {\\n        // Check if number of dashes L and R are equal\\n        if(checkFreq(start,target)==false)return false;\\n        \\n        vector<int>prevR;\\n        vector<int>afterL;\\n        \\n        vector<int>prevR1;\\n        vector<int>afterL1;\\n        \\n        //Checking if number of R before every L in start and target are same or not\\n        int count1=0,count2=0;                 \\n        for(int i=0;i<start.size();i++)\\n        {\\n            if(start[i]==\\'R\\')count1++;\\n            if(start[i]==\\'L\\')prevR.push_back(count1);\\n            \\n            if(target[i]==\\'R\\')count2++;\\n            if(target[i]==\\'L\\')prevR1.push_back(count2);\\n            \\n        }\\n        for(int i=0;i<prevR.size();i++)\\n        {\\n            if(prevR1[i]!=prevR[i])return false;\\n        }\\n        \\n        //Checking if number of L after every R in start and target are same or not\\n        count1=0;count2=0;        \\n        for(int i=start.size()-1;i>=0;i--)\\n        {\\n            if(start[i]==\\'L\\')count1++;\\n            if(start[i]==\\'R\\')afterL.push_back(count1);\\n            \\n            if(target[i]==\\'L\\')count2++;\\n            if(target[i]==\\'R\\')afterL1.push_back(count2);            \\n        }\\n        for(int i=0;i<afterL1.size();i++)\\n        {\\n            if(afterL1[i]!=afterL[i])return false;\\n        }\\n        \\n//     Checking if number if dashes before every L are >= than that in target\\n        vector<int>prevDashesStart;\\n        vector<int>afterDashesStart;\\n        vector<int>prevDashesTarget;\\n        vector<int>afterDashesTarget;        \\n        count1=0;count2=0;\\n        for(int i=0;i<start.size();i++)\\n        {\\n            if(start[i]==\\'_\\')count1++;\\n            if(start[i]==\\'L\\')prevDashesStart.push_back(count1);\\n            \\n            if(target[i]==\\'_\\')count2++;\\n            if(target[i]==\\'L\\')prevDashesTarget.push_back(count2); \\n        }\\n        for(int i=0;i<prevDashesStart.size();i++)\\n        {\\n            if(prevDashesStart[i]<prevDashesTarget[i])return false;\\n        }\\n        //     Checking if number if dashes after every R are >= than that in target\\n        count1=0;count2=0;\\n        for(int i=start.size()-1;i>=0;i--)\\n        {\\n            if(start[i]==\\'_\\')count1++;\\n            if(start[i]==\\'R\\')afterDashesStart.push_back(count1); \\n            \\n            if(target[i]==\\'_\\')count2++;\\n            if(target[i]==\\'R\\')afterDashesTarget.push_back(count2); \\n        }\\n        \\n        for(int i=0;i<afterDashesTarget.size();i++)\\n        {\\n            if(afterDashesStart[i]<afterDashesTarget[i])return false;\\n        }\\n        \\n        return true;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2261722,
                "title": "c-string-simulation-time-o-n-space-o-1-easy-code",
                "content": "Please Upvote :)\\n\\n```\\nclass Solution {\\npublic:\\n    bool canChange(string start, string target) {       \\n        int l=0,t=0;\\n        for(int i=start.length()-1;i>=0;i--)\\n        {\\n            if(start[i]==\\'L\\')\\n                l++;   \\n            if(target[i]==\\'L\\')\\n                t++;\\n            \\n            if(start[i]==\\'R\\' || target[i]==\\'R\\')\\n            {\\n                if(t!=l)\\n                    return false;\\n            }\\n            if(t>l)\\n                return false;\\n        }\\n        if(t!=l)\\n            return false;\\n        l=0;\\n        t=0;\\n        for(int i=0;i<start.length();i++)\\n        {\\n            if(start[i]==\\'R\\')\\n                l++;  \\n            if(target[i]==\\'R\\')\\n                t++;\\n            \\n            if(start[i]==\\'L\\' || target[i]==\\'L\\')\\n            {\\n                if(t!=l)\\n                    return false;\\n            }\\n            if(t>l)\\n                return false;\\n        }\\n        if(t!=l)\\n            return false;\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canChange(string start, string target) {       \\n        int l=0,t=0;\\n        for(int i=start.length()-1;i>=0;i--)\\n        {\\n            if(start[i]==\\'L\\')\\n                l++;   \\n            if(target[i]==\\'L\\')\\n                t++;\\n            \\n            if(start[i]==\\'R\\' || target[i]==\\'R\\')\\n            {\\n                if(t!=l)\\n                    return false;\\n            }\\n            if(t>l)\\n                return false;\\n        }\\n        if(t!=l)\\n            return false;\\n        l=0;\\n        t=0;\\n        for(int i=0;i<start.length();i++)\\n        {\\n            if(start[i]==\\'R\\')\\n                l++;  \\n            if(target[i]==\\'R\\')\\n                t++;\\n            \\n            if(start[i]==\\'L\\' || target[i]==\\'L\\')\\n            {\\n                if(t!=l)\\n                    return false;\\n            }\\n            if(t>l)\\n                return false;\\n        }\\n        if(t!=l)\\n            return false;\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2261634,
                "title": "17-lines-simple-o-n-python-soln",
                "content": "Insight:\\nWithout loss of generality, let\\'s consider left pieces only.\\n - Ls can move left, if there are spaces before the L\\n - Ls can cross over lefts while moving, but cannot cross over Rs, therefore\\n   using a counter for number of available lefts is viable.  This counter is reset to 0\\n   if we see a right in the way.  If there\\'s a left we cannot match, we return false, too.\\n\\n```\\n    def canChange(self, start, target):\\n        N = len(start)\\n        \\n        curr = 0\\n        for i in range(N - 1, -1, -1):\\n            if start[i] == \\'L\\': curr += 1\\n            elif start[i] == \\'R\\': curr = 0\\n            if target[i] == \\'R\\' and curr > 0: return False \\n            if target[i] == \\'L\\':\\n                if curr == 0: return False\\n                curr -= 1\\n        \\n        for i in range(N):\\n            if start[i] == \\'R\\': curr += 1\\n            elif start[i] == \\'L\\': curr = 0\\n            if target[i] == \\'L\\' and curr > 0: return False \\n            if target[i] == \\'R\\':\\n                if curr == 0: return False\\n                curr -= 1\\n        return True\\n```\\n",
                "solutionTags": [],
                "code": "```\\n    def canChange(self, start, target):\\n        N = len(start)\\n        \\n        curr = 0\\n        for i in range(N - 1, -1, -1):\\n            if start[i] == \\'L\\': curr += 1\\n            elif start[i] == \\'R\\': curr = 0\\n            if target[i] == \\'R\\' and curr > 0: return False \\n            if target[i] == \\'L\\':\\n                if curr == 0: return False\\n                curr -= 1\\n        \\n        for i in range(N):\\n            if start[i] == \\'R\\': curr += 1\\n            elif start[i] == \\'L\\': curr = 0\\n            if target[i] == \\'L\\' and curr > 0: return False \\n            if target[i] == \\'R\\':\\n                if curr == 0: return False\\n                curr -= 1\\n        return True\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2261454,
                "title": "c-greedy-easy-understanding",
                "content": "##### ***UPVOTE***\\nwe will store all the indexes witht the characters where here is L and R in the start and target string respectively.\\n\\n```\\ntypedef vector<pair<char,int>> vi; // used to shorten the code for me little bit\\nclass Solution {\\npublic:\\n    bool canChange(string start, string target) {\\n        int n = start.size();\\n        vi a,b;\\n        for(int i = 0;i < n;++i){\\n            if(start[i] != \\'_\\') a.push_back({start[i],i}); // storing L and R in start with their index\\n            if(target[i] != \\'_\\') b.push_back({target[i],i}); // storing L and R in start with their index\\n        }\\n        int op = a.size();\\n        int pp = b.size();\\n        if(op == pp){ // check if their sizes are equal if not then return false \\n            for(int i = 0;i < op;++i){\\n                if(a[i].first == b[i].first){ // elements equal we will check their position with respect to each other\\n                    if(a[i].first == \\'L\\'){\\n                        if(a[i].second < b[i].second) return false;\\n                    }else {\\n                        if(a[i].second > b[i].second) return false;\\n                    }\\n                }else return false; // Elements not equal so we will return just false\\n            }\\n            return true;\\n        }\\n        return false; // since check the case where it can be true now we have to just return false \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\ntypedef vector<pair<char,int>> vi; // used to shorten the code for me little bit\\nclass Solution {\\npublic:\\n    bool canChange(string start, string target) {\\n        int n = start.size();\\n        vi a,b;\\n        for(int i = 0;i < n;++i){\\n            if(start[i] != \\'_\\') a.push_back({start[i],i}); // storing L and R in start with their index\\n            if(target[i] != \\'_\\') b.push_back({target[i],i}); // storing L and R in start with their index\\n        }\\n        int op = a.size();\\n        int pp = b.size();\\n        if(op == pp){ // check if their sizes are equal if not then return false \\n            for(int i = 0;i < op;++i){\\n                if(a[i].first == b[i].first){ // elements equal we will check their position with respect to each other\\n                    if(a[i].first == \\'L\\'){\\n                        if(a[i].second < b[i].second) return false;\\n                    }else {\\n                        if(a[i].second > b[i].second) return false;\\n                    }\\n                }else return false; // Elements not equal so we will return just false\\n            }\\n            return true;\\n        }\\n        return false; // since check the case where it can be true now we have to just return false \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2261418,
                "title": "extraordinary-solution-c",
                "content": "we are storing 2 different versions of possible strings\\nfirst with only Ls on the left\\nsecond with Rs on the right side \\nIn the end we just check if current letter is L we are looking at 1st string\\nand the same for R\\n```class Solution {\\npublic:\\n    bool canChange(string start, string target) {\\n        string t = start;\\n        int cnt = 0;\\n        for(int i = 0; i < start.size(); i++){\\n            if(start[i] == \\'L\\'){\\n                int j = i;\\n                while(j-- && start[j] == \\'_\\')\\n                    start[j] = \\'L\\';\\n                cnt++;\\n            }\\n            else if(start[i] == \\'R\\'){\\n                i++;\\n                while(i < t.size() && t[i] == \\'_\\')\\n                    t[i] = \\'R\\', i++;\\n                i--;\\n                cnt++;\\n            }\\n        }\\n        cout << start << \\' \\' << t << \\' \\' << target<< endl;\\n        for(int i = 0; i < target.size(); i++){\\n            if(target[i] == \\'L\\'){\\n                if(start[i] != \\'L\\')\\n                    return false;\\n                cnt--;\\n            }\\n            \\n            if(target[i] == \\'R\\'){\\n                if(t[i] != \\'R\\')\\n                    return false;\\n                cnt--;\\n            }\\n            \\n        }\\n        if(cnt)\\n            return false;\\n        return true;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```class Solution {\\npublic:\\n    bool canChange(string start, string target) {\\n        string t = start;\\n        int cnt = 0;\\n        for(int i = 0; i < start.size(); i++){\\n            if(start[i] == \\'L\\'){\\n                int j = i;\\n                while(j-- && start[j] == \\'_\\')\\n                    start[j] = \\'L\\';\\n                cnt++;\\n            }\\n            else if(start[i] == \\'R\\'){\\n                i++;\\n                while(i < t.size() && t[i] == \\'_\\')\\n                    t[i] = \\'R\\', i++;\\n                i--;\\n                cnt++;\\n            }\\n        }\\n        cout << start << \\' \\' << t << \\' \\' << target<< endl;\\n        for(int i = 0; i < target.size(); i++){\\n            if(target[i] == \\'L\\'){\\n                if(start[i] != \\'L\\')\\n                    return false;\\n                cnt--;\\n            }\\n            \\n            if(target[i] == \\'R\\'){\\n                if(t[i] != \\'R\\')\\n                    return false;\\n                cnt--;\\n            }\\n            \\n        }\\n        if(cnt)\\n            return false;\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2261377,
                "title": "deque-and-position-checking-explained",
                "content": "We need to make the following checks for left and right (\"L\", \"R\")\\n\\n1. If there is a \"R\" between \"L\" actual position and it\\'s final position -> `return false` since it can\\'t be placed in the final location\\n2. If the next \"L\" position is after the current index -> `return false` since we can move only left\\n\\nDo the same logic for the other side with \"R\"\\n\\n\\n# Code\\n```\\nfrom collections import deque\\n\\nclass Solution:\\n    def canChange(self, start: str, target: str) -> bool:\\n        n = len(start)\\n        \\n        seen_left = deque([])\\n        seen_right = deque([])\\n        target_left = deque([])\\n        target_right = deque([])\\n        \\n        for i in range(n):\\n            if start[i] == \"R\": seen_right.append(i)\\n            if start[i] == \"L\": seen_left.append(i)\\n            if target[i] == \"L\": target_left.append(i)\\n            if target[i] == \"R\": target_right.append(i)\\n            \\n        \\n        for i in range(n):\\n            if start[i] == \"L\":\\n                if not target_left: return False\\n                \\n                next_left_target_index = target_left.popleft()\\n                \\n                if next_left_target_index > i:\\n                    return False\\n                \\n                \\n                # irrelevant\\n                while seen_right and seen_right[0] < next_left_target_index:\\n                    seen_right.popleft()\\n                \\n                # blocking between actual and target\\n                if seen_right and next_left_target_index <= seen_right[0] <= i:\\n                    return False\\n            \\n        for i in range(n):\\n            cur_i = n-1-i\\n            if start[cur_i] == \"R\":\\n                if not target_right: return False\\n                \\n                next_right_target_index = target_right.pop()\\n                \\n                if next_right_target_index < cur_i:\\n                    return False\\n                \\n                # irrelevant\\n                while seen_left and seen_left[-1] > next_right_target_index:\\n                    seen_left.pop()\\n                \\n                # blocking between actual and target\\n                if seen_left and cur_i <= seen_left[-1] <= next_right_target_index:\\n                    return False\\n            \\n        return len(target_left) == 0 and len(target_right) == 0\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Queue"
                ],
                "code": "```\\nfrom collections import deque\\n\\nclass Solution:\\n    def canChange(self, start: str, target: str) -> bool:\\n        n = len(start)\\n        \\n        seen_left = deque([])\\n        seen_right = deque([])\\n        target_left = deque([])\\n        target_right = deque([])\\n        \\n        for i in range(n):\\n            if start[i] == \"R\": seen_right.append(i)\\n            if start[i] == \"L\": seen_left.append(i)\\n            if target[i] == \"L\": target_left.append(i)\\n            if target[i] == \"R\": target_right.append(i)\\n            \\n        \\n        for i in range(n):\\n            if start[i] == \"L\":\\n                if not target_left: return False\\n                \\n                next_left_target_index = target_left.popleft()\\n                \\n                if next_left_target_index > i:\\n                    return False\\n                \\n                \\n                # irrelevant\\n                while seen_right and seen_right[0] < next_left_target_index:\\n                    seen_right.popleft()\\n                \\n                # blocking between actual and target\\n                if seen_right and next_left_target_index <= seen_right[0] <= i:\\n                    return False\\n            \\n        for i in range(n):\\n            cur_i = n-1-i\\n            if start[cur_i] == \"R\":\\n                if not target_right: return False\\n                \\n                next_right_target_index = target_right.pop()\\n                \\n                if next_right_target_index < cur_i:\\n                    return False\\n                \\n                # irrelevant\\n                while seen_left and seen_left[-1] > next_right_target_index:\\n                    seen_left.pop()\\n                \\n                # blocking between actual and target\\n                if seen_left and cur_i <= seen_left[-1] <= next_right_target_index:\\n                    return False\\n            \\n        return len(target_left) == 0 and len(target_right) == 0\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2261365,
                "title": "python3-greedy",
                "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/f00c06cefbc1b2305f127a8cde7ff9b010197930) for solutions of weekly 301. \\n\\n```\\nclass Solution:\\n    def canChange(self, s: str, e: str) -> bool:\\n        dl = dr = 0 \\n        for ss, ee in zip(s, e): \\n            if dl > 0 or dl < 0 and ss == \\'R\\' or dr < 0 or dr > 0 and ss == \\'L\\': return False \\n            dl += int(ss == \\'L\\') - int(ee == \\'L\\')\\n            dr += int(ss == \\'R\\') - int(ee == \\'R\\')\\n        return dl == dr == 0 \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canChange(self, s: str, e: str) -> bool:\\n        dl = dr = 0 \\n        for ss, ee in zip(s, e): \\n            if dl > 0 or dl < 0 and ss == \\'R\\' or dr < 0 or dr > 0 and ss == \\'L\\': return False \\n            dl += int(ss == \\'L\\') - int(ee == \\'L\\')\\n            dr += int(ss == \\'R\\') - int(ee == \\'R\\')\\n        return dl == dr == 0 \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2261322,
                "title": "python-java-2-pointers",
                "content": "\\tclass Solution:\\n\\t\\tdef canChange(self, start: str, target: str) -> bool:\\n\\t\\t\\tif start.count(\"_\") != target.count(\"_\"):\\n\\t\\t\\t\\treturn False\\n\\t\\t\\ti = 0\\n\\t\\t\\tj = 0\\n\\t\\t\\twhile i < len(start) and j < len(target):\\n\\t\\t\\t\\tif start[i] == \"_\":\\n\\t\\t\\t\\t\\ti += 1\\n\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\tif target[j] == \"_\":\\n\\t\\t\\t\\t\\tj += 1\\n\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\tif start[i] != target[j]:\\n\\t\\t\\t\\t\\treturn False\\n\\t\\t\\t\\tif start[i] == \"L\" and i < j:\\n\\t\\t\\t\\t\\treturn False\\n\\t\\t\\t\\tif start[i] == \"R\" and i > j:\\n\\t\\t\\t\\t\\treturn False\\n\\t\\t\\t\\ti += 1\\n\\t\\t\\t\\tj += 1\\n\\t\\t\\treturn True\\n\\n\\n\\tclass Solution {\\n\\t\\tpublic boolean canChange(String start, String target) {\\n\\t\\t\\tint cnt1 = 0;\\n\\t\\t\\tint cnt2 = 0;\\n\\t\\t\\tfor (int i = 0; i < start.length(); i ++) {\\n\\t\\t\\t\\tif (start.charAt(i) == \\'_\\') {\\n\\t\\t\\t\\t\\tcnt1 ++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (target.charAt(i) == \\'_\\') {\\n\\t\\t\\t\\t\\tcnt2 ++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif (cnt1 != cnt2) {\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t\\tint i = 0;\\n\\t\\t\\tint j = 0;\\n\\t\\t\\twhile (i < start.length() && j < target.length()) {\\n\\t\\t\\t\\tif (start.charAt(i) == \\'_\\') {\\n\\t\\t\\t\\t\\ti ++;\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (target.charAt(j) == \\'_\\') {\\n\\t\\t\\t\\t\\tj ++;\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (start.charAt(i) != target.charAt(j)) {\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (start.charAt(i) == \\'L\\' && i < j) {\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (start.charAt(i) == \\'R\\' && i > j) {\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\ti ++;\\n\\t\\t\\t\\tj ++;\\n\\t\\t\\t}\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t}",
                "solutionTags": [],
                "code": "class Solution:\\n\\t\\tdef canChange(self, start: str, target: str) -> bool:\\n\\t\\t\\tif start.count(\"_\") != target.count(\"_\"):\\n\\t\\t\\t\\treturn False\\n\\t\\t\\ti = 0\\n\\t\\t\\tj = 0\\n\\t\\t\\twhile i < len(start) and j < len(target):\\n\\t\\t\\t\\tif start[i] == \"_\":\\n\\t\\t\\t\\t\\ti += 1\\n\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\tif target[j] == \"_\":\\n\\t\\t\\t\\t\\tj += 1\\n\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\tif start[i] != target[j]:\\n\\t\\t\\t\\t\\treturn False\\n\\t\\t\\t\\tif start[i] == \"L\" and i < j:\\n\\t\\t\\t\\t\\treturn False\\n\\t\\t\\t\\tif start[i] == \"R\" and i > j:\\n\\t\\t\\t\\t\\treturn False\\n\\t\\t\\t\\ti += 1\\n\\t\\t\\t\\tj += 1\\n\\t\\t\\treturn True\\n\\n\\n\\tclass Solution {\\n\\t\\tpublic boolean canChange(String start, String target) {\\n\\t\\t\\tint cnt1 = 0;\\n\\t\\t\\tint cnt2 = 0;\\n\\t\\t\\tfor (int i = 0; i < start.length(); i ++) {\\n\\t\\t\\t\\tif (start.charAt(i) == \\'_\\') {\\n\\t\\t\\t\\t\\tcnt1 ++;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 3401519,
                "title": "c-twopointer-easytounderstand",
                "content": "Runtime: 57 ms, faster than 85.05% of C++ online submissions for Move Pieces to Obtain a String.\\nMemory Usage: 18.9 MB, less than 99.34% of C++ online submissions for Move Pieces to Obtain a String.\\n```class Solution {\\npublic:\\n    bool canChange(string start, string target) {\\n        \\n        int i = 0, j = 0, n = start.size();\\n\\t\\n\\t\\n        while(i < n || j < n){\\n            \\n            while(i < n && start[i] == \\'_\\')\\n                i++;\\n            while(j < n && target[j] == \\'_\\')\\n                j++;\\n\\n           \\n            if(i == n || j == n)\\n                break;\\n\\n            if(start[i] != target[j])\\n                return false;\\n\\n            \\n            if(start[i] == \\'L\\')\\n                if(i < j)\\n                    return false;\\n            \\n            if(start[i] == \\'R\\')\\n                if(i > j)\\n                    return false;\\n            \\n            i++;\\n            j++;\\n        }\\n\\n        return i == n && j == n;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "class Solution {\\npublic:\\n    bool canChange(string start, string target) {\\n        \\n        int i = 0, j = 0, n = start.size();\\n\\t\\n\\t\\n        while(i < n || j < n){\\n            \\n            while(i < n && start[i] == \\'_\\')\\n                i++;\\n            while(j < n && target[j] == \\'_\\')\\n                j++;\\n\\n           \\n            if(i == n || j == n)\\n                break;\\n\\n            if(start[i] != target[j])\\n                return false;\\n\\n            \\n            if(start[i] == \\'L\\')\\n                if(i < j)\\n                    return false;\\n            \\n            if(start[i] == \\'R\\')\\n                if(i > j)\\n                    return false;\\n            \\n            i++;\\n            j++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3167404,
                "title": "kotlin-2-pointers-simple-solution-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThere are several situations wnen we can\\'t get target string from start:\\n1. When L + R count is different\\n2. When L & R order is different\\n3. When n-th L element index in start is lower then n-th L element index in target (s = R__L__R, t = R____LR. {L index} in s < {L index} in t and we can\\'t move it right -> so we cant make t from s) \\n4. When n-th R element index in start is higher then n-th R element index in target\\n\\nSo, all we need is to take 2 pointers, skip \\'_\\' by movingpointer and then compare letters where pointers will stay at by rules above.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    fun canChange(start: String, target: String): Boolean {\\n        val n = start.length\\n        var i = 0\\n        var j = 0\\n\\n        while (true) {\\n            while (i < n && start[i] == \\'_\\') i++ //skip all _\\n            while (j < n && target[j] == \\'_\\') j++ //skip all _\\n            if (i == n && j == n) return true \\n//if we reach n with both pointers without false then we can make t from s\\n\\n            if (i == n || j == n) return false //here we check 1 rule\\n            if (start[i] != target[j]) return false //check 2 rule\\n            if (start[i] == \\'L\\' && i < j) return false //check 3 rule\\n            if (start[i] == \\'R\\' && i > j) return false //check 4 rule\\n\\n            i++\\n            j++\\n        }\\n        return true\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun canChange(start: String, target: String): Boolean {\\n        val n = start.length\\n        var i = 0\\n        var j = 0\\n\\n        while (true) {\\n            while (i < n && start[i] == \\'_\\') i++ //skip all _\\n            while (j < n && target[j] == \\'_\\') j++ //skip all _\\n            if (i == n && j == n) return true \\n//if we reach n with both pointers without false then we can make t from s\\n\\n            if (i == n || j == n) return false //here we check 1 rule\\n            if (start[i] != target[j]) return false //check 2 rule\\n            if (start[i] == \\'L\\' && i < j) return false //check 3 rule\\n            if (start[i] == \\'R\\' && i > j) return false //check 4 rule\\n\\n            i++\\n            j++\\n        }\\n        return true\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3027928,
                "title": "simple-java-solution-beat-85",
                "content": "# Intuition\\nSimple Two Pointer Concept with the proper understanding of problem statement\\n\\n# Approach\\nWhenever we are getting the character other than \\'_\\' what we have to check is firstly that both are the same. If they are not same then definitely its not gonna work. After that if they are same and if that same character is \\'R\\' and if we are having ptr2 < ptr1 then its not gonna work.And if the character is \\'L\\' and if we are having ptr2 > ptr1 , then also its not gonna work.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean canChange(String start, String target) {\\n        int ptr1=0;\\n        int ptr2=0;\\n        int n = target.length();\\n\\n        while(ptr1 <= n && ptr2 <= n){\\n            while(ptr1 < n && start.charAt(ptr1) == \\'_\\') ptr1++;\\n            while(ptr2 < n && target.charAt(ptr2) == \\'_\\') ptr2++;\\n\\n            if(ptr1 == n ||ptr2 == n){\\n                return ptr1 == n && ptr2 == n;\\n            }\\n\\n            if(target.charAt(ptr2) != start.charAt(ptr1)) return false;\\n\\n            if(start.charAt(ptr1) == \\'L\\'){\\n                if(ptr2 > ptr1) return false;\\n\\n            }\\n\\n            if(start.charAt(ptr1) == \\'R\\'){\\n                if(ptr2 < ptr1) return false;\\n            }\\n            ptr1++;\\n            ptr2++;\\n        }\\n\\n        return ptr1 == n && ptr2 == n;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canChange(String start, String target) {\\n        int ptr1=0;\\n        int ptr2=0;\\n        int n = target.length();\\n\\n        while(ptr1 <= n && ptr2 <= n){\\n            while(ptr1 < n && start.charAt(ptr1) == \\'_\\') ptr1++;\\n            while(ptr2 < n && target.charAt(ptr2) == \\'_\\') ptr2++;\\n\\n            if(ptr1 == n ||ptr2 == n){\\n                return ptr1 == n && ptr2 == n;\\n            }\\n\\n            if(target.charAt(ptr2) != start.charAt(ptr1)) return false;\\n\\n            if(start.charAt(ptr1) == \\'L\\'){\\n                if(ptr2 > ptr1) return false;\\n\\n            }\\n\\n            if(start.charAt(ptr1) == \\'R\\'){\\n                if(ptr2 < ptr1) return false;\\n            }\\n            ptr1++;\\n            ptr2++;\\n        }\\n\\n        return ptr1 == n && ptr2 == n;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2916597,
                "title": "very-easy-javascript-solution",
                "content": "# Intuition\\nVery Easy Javascript Solution!!!!!!!!!!!!!!!\\n\\n# Approach\\nclassic iteration \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string} start\\n * @param {string} target\\n * @return {boolean}\\n */\\nvar canChange = function(start, target) {\\n    const a  = []\\n    const b = []\\n\\n    for(let i = 0 ; i <start.length ;i++){\\n        if(start[i]!==\\'_\\') a.push([i,start[i]])\\n    }\\n\\n    for(let j=0; j <target.length ;j++){\\n        if(target[j] !== \\'_\\') b.push([j,target[j]])\\n    }\\n\\n\\n    if(a.length !== b.length) return false\\n\\n    for(let i = 0 ; i < a.length ;i++){\\n        if(a[i][1] !== b[i][1]) return false \\n        if(a[i][1] == \\'L\\' && a[i][0]<b[i][0]) return false\\n        if(a[i][1] == \\'R\\' && a[i][0]>b[i][0]) return false\\n    }\\n\\n    return true\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} start\\n * @param {string} target\\n * @return {boolean}\\n */\\nvar canChange = function(start, target) {\\n    const a  = []\\n    const b = []\\n\\n    for(let i = 0 ; i <start.length ;i++){\\n        if(start[i]!==\\'_\\') a.push([i,start[i]])\\n    }\\n\\n    for(let j=0; j <target.length ;j++){\\n        if(target[j] !== \\'_\\') b.push([j,target[j]])\\n    }\\n\\n\\n    if(a.length !== b.length) return false\\n\\n    for(let i = 0 ; i < a.length ;i++){\\n        if(a[i][1] !== b[i][1]) return false \\n        if(a[i][1] == \\'L\\' && a[i][0]<b[i][0]) return false\\n        if(a[i][1] == \\'R\\' && a[i][0]>b[i][0]) return false\\n    }\\n\\n    return true\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2403256,
                "title": "java-solution-o-n-with-explanation",
                "content": "* It\\u2019s a logical problem. Let\\u2019s make some observations first:\\n\\t* since we can move left or right only, we are very sure that each character\\u2019s (L or R) indexes would be same in both the strings if we remove all \\u2018_\\u2019.\\n\\t* since \\u2018L\\u2019 can move to left only, it must be appearing on or after the corresponding \\u2018L\\u2019 of target string.\\n\\t* likewise \\u2018R\\u2019 can move to right only, hence it must be appearing on or before the corresponding \\u2018R\\u2019 of target string.\\n\\n* Algo:\\n\\t* we will keep two pointers that would be used to point on \\u2018L\\u2019 or \\u2018R\\u2019 character of strings respectively.\\n\\t* we will use a while loop and keep on skipping the \\u2018_\\u2019 of both strings.\\n\\t* this way we will get the respective index of \\u2018L\\u2019/\\u2018R\\u2019.\\n\\t* then we will check for above conditions.\\n\\t\\n\\n```\\n    public boolean canChange(String s, String t) {\\n        if(s.length()!=t.length()) return false;\\n        \\n        //pointers that will point to corresponding \\'L\\'/\\'R\\' of s and t.\\n        //using the fact that we are sure that order or \\'L\\'/\\'R\\' of s and t must be the same.\\n        int s_ptr=0, t_ptr=0;\\n        \\n        while(s_ptr<s.length() || t_ptr<t.length()){\\n            while(s_ptr<s.length() && s.charAt(s_ptr)==\\'_\\') s_ptr++;\\n            while(t_ptr<t.length() && t.charAt(t_ptr)==\\'_\\') t_ptr++;\\n            \\n            //let\\'s check if both are in bound or not.\\n            if(s_ptr>=s.length() || t_ptr>=t.length()){\\n                return (s_ptr==s.length() && t_ptr==t.length()); //if both are going out of bound then only it\\'s valid otherwise one has extra \\'L\\' or \\'R\\' present on it\\'s right.\\n            }\\n            \\n            char s_char = s.charAt(s_ptr);\\n            char t_char = t.charAt(t_ptr);\\n            if(s_char!=t_char) return false;\\n            \\n            //making sure that \\'L\\' of s is appearing on or after corresponding \\'L\\' of t.\\n            //likewise \\'R\\' of s is appearing on or before corresponding \\'R\\' of t.\\n            if((s_char==\\'L\\' &&  s_ptr<t_ptr) || (s_char==\\'R\\' && s_ptr>t_ptr)) return false;\\n            \\n            s_ptr++;\\n            t_ptr++;\\n        }\\n        \\n        return true;\\n    }\\n```",
                "solutionTags": [
                    "Brainteaser"
                ],
                "code": "```\\n    public boolean canChange(String s, String t) {\\n        if(s.length()!=t.length()) return false;\\n        \\n        //pointers that will point to corresponding \\'L\\'/\\'R\\' of s and t.\\n        //using the fact that we are sure that order or \\'L\\'/\\'R\\' of s and t must be the same.\\n        int s_ptr=0, t_ptr=0;\\n        \\n        while(s_ptr<s.length() || t_ptr<t.length()){\\n            while(s_ptr<s.length() && s.charAt(s_ptr)==\\'_\\') s_ptr++;\\n            while(t_ptr<t.length() && t.charAt(t_ptr)==\\'_\\') t_ptr++;\\n            \\n            //let\\'s check if both are in bound or not.\\n            if(s_ptr>=s.length() || t_ptr>=t.length()){\\n                return (s_ptr==s.length() && t_ptr==t.length()); //if both are going out of bound then only it\\'s valid otherwise one has extra \\'L\\' or \\'R\\' present on it\\'s right.\\n            }\\n            \\n            char s_char = s.charAt(s_ptr);\\n            char t_char = t.charAt(t_ptr);\\n            if(s_char!=t_char) return false;\\n            \\n            //making sure that \\'L\\' of s is appearing on or after corresponding \\'L\\' of t.\\n            //likewise \\'R\\' of s is appearing on or before corresponding \\'R\\' of t.\\n            if((s_char==\\'L\\' &&  s_ptr<t_ptr) || (s_char==\\'R\\' && s_ptr>t_ptr)) return false;\\n            \\n            s_ptr++;\\n            t_ptr++;\\n        }\\n        \\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2385891,
                "title": "c-o-n-easy-to-understand",
                "content": "```\\n    bool canChange(string start, string target) {\\n        string s1,s2;\\n        for(int i =0;i<start.size();i++){\\n            if(start[i] != \\'_\\') s1+= start[i];\\n            if(target[i] != \\'_\\') s2+= target[i];\\n        }\\n        if(s1 != s2) return false;\\n        \\n        int l1=0, l2=0, r1=0, r2=0;\\n        for(int i=0.;i<start.size();i++){\\n            if(start[i] == \\'L\\') l1++;\\n            if(start[i] == \\'R\\') r1++;\\n            \\n            if(target[i] == \\'L\\') l2++;\\n            if(target[i] == \\'R\\') r2++;\\n            \\n            if(l1>l2) return false;\\n            if(r1<r2) return false;\\n        }\\n        return true;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n    bool canChange(string start, string target) {\\n        string s1,s2;\\n        for(int i =0;i<start.size();i++){\\n            if(start[i] != \\'_\\') s1+= start[i];\\n            if(target[i] != \\'_\\') s2+= target[i];\\n        }\\n        if(s1 != s2) return false;\\n        \\n        int l1=0, l2=0, r1=0, r2=0;\\n        for(int i=0.;i<start.size();i++){\\n            if(start[i] == \\'L\\') l1++;\\n            if(start[i] == \\'R\\') r1++;\\n            \\n            if(target[i] == \\'L\\') l2++;\\n            if(target[i] == \\'R\\') r2++;\\n            \\n            if(l1>l2) return false;\\n            if(r1<r2) return false;\\n        }\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2364549,
                "title": "c-o-n-time-and-constant-space",
                "content": "We go through target string, on every step taking index of the next non-space character (in our case it will be either L or R). \\nIn order to confirm that the start string can be converted to the target one we have to check if the corresponding next non-space character in the start string is equal to target one and that the index of that character in start is:\\nindex in start  >= (greater or equal) index of corresponding character in target in case of \\'L\\'\\nindex in start  <= (less or equal) index of corresponding character in target in case of \\'R\\'\\n```\\nclass Solution {\\n    inline static int next(const string& s, int i) {\\n        while (i < s.length() && s[i] == \\'_\\') ++i;\\n        return i;\\n    }\\npublic:\\n    bool canChange(string start, string target) {\\n        int ti = next(target, 0), si = next(start, 0);\\n        while (ti < target.length()) {\\n            if (si >= start.length() || target[ti] != start[si] || \\n               (target[ti] == \\'L\\' && si < ti) || (target[ti] == \\'R\\' && si > ti))\\n                return false;\\n            ti = next(target, ti + 1);\\n            si = next(start, si + 1);\\n        }\\n        return si >= start.length();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    inline static int next(const string& s, int i) {\\n        while (i < s.length() && s[i] == \\'_\\') ++i;\\n        return i;\\n    }\\npublic:\\n    bool canChange(string start, string target) {\\n        int ti = next(target, 0), si = next(start, 0);\\n        while (ti < target.length()) {\\n            if (si >= start.length() || target[ti] != start[si] || \\n               (target[ti] == \\'L\\' && si < ti) || (target[ti] == \\'R\\' && si > ti))\\n                return false;\\n            ti = next(target, ti + 1);\\n            si = next(start, si + 1);\\n        }\\n        return si >= start.length();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2334793,
                "title": "balancing-brackets-clean-solution",
                "content": "We can think of L\\'s and R\\'s as two types of brackets. For example,\\n```\\n_L__R__R_\\nL______RR\\n```\\nis equivalent to\\n```\\n_)__[__[_\\n(______]]\\n```\\nWe can use two counters to keep track of opening brackets and make sure that\\n1.  Brackets of difference types don\\'t intersect, i.e. we can\\'t have opening brackets of difference types at the same time.\\n2.  A closing bracket must be paired with an opening bracket.\\n3.  No opening brackets remain in the end.\\n```\\nclass Solution {\\npublic:\\n    bool canChange(string s, string t) {\\n        int l = 0, r = 0, n = s.size();\\n        for (int i = 0; i < n; ++i) {\\n            l += t[i] == \\'L\\';\\n            r += s[i] == \\'R\\';\\n            if (r && l) return false;\\n            l -= s[i] == \\'L\\';\\n            r -= t[i] == \\'R\\';\\n            if (r < 0 || l < 0) return false;\\n        }\\n        return l == 0 && r == 0;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n_L__R__R_\\nL______RR\\n```\n```\\n_)__[__[_\\n(______]]\\n```\n```\\nclass Solution {\\npublic:\\n    bool canChange(string s, string t) {\\n        int l = 0, r = 0, n = s.size();\\n        for (int i = 0; i < n; ++i) {\\n            l += t[i] == \\'L\\';\\n            r += s[i] == \\'R\\';\\n            if (r && l) return false;\\n            l -= s[i] == \\'L\\';\\n            r -= t[i] == \\'R\\';\\n            if (r < 0 || l < 0) return false;\\n        }\\n        return l == 0 && r == 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2308807,
                "title": "python-one-simple-loop-keep-track-of-two-numbers",
                "content": "Just keep track of two numbers:\\n\\n- The requested \\'Ls\\' that have been encountered in *target*, which will have to be supplied by *start*.\\n- The \\'Rs\\' in *start* which will have to be absorbed by *target*\\n\\nAs soon as you realize the \\'L\\'s and \\'R\\'s will have to cross one another you terminate the loop.\\n\\n````\\nclass Solution:\\n    def canChange(self, start: str, target: str) -> bool:\\n        if len(start) != len(target):\\n            return False\\n        pendingLs = 0\\n        pendingRs = 0\\n        for i in range(len(start)):\\n            s, t = start[i], target[i]\\n            if t == \\'L\\':\\n                if pendingRs:\\n                    return False\\n                pendingLs += 1\\n            if s == \\'L\\':\\n                if not pendingLs:\\n                    return False\\n                pendingLs -= 1\\n            if s == \\'R\\':\\n                if pendingLs:\\n                    return False\\n                pendingRs += 1\\n            if t == \\'R\\':\\n                if not pendingRs:\\n                    return False\\n                pendingRs -= 1\\n        return pendingLs == 0 and pendingRs == 0\\n````\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "````\\nclass Solution:\\n    def canChange(self, start: str, target: str) -> bool:\\n        if len(start) != len(target):\\n            return False\\n        pendingLs = 0\\n        pendingRs = 0\\n        for i in range(len(start)):\\n            s, t = start[i], target[i]\\n            if t == \\'L\\':\\n                if pendingRs:\\n                    return False\\n                pendingLs += 1\\n            if s == \\'L\\':\\n                if not pendingLs:\\n                    return False\\n                pendingLs -= 1\\n            if s == \\'R\\':\\n                if pendingLs:\\n                    return False\\n                pendingRs += 1\\n            if t == \\'R\\':\\n                if not pendingRs:\\n                    return False\\n                pendingRs -= 1\\n        return pendingLs == 0 and pendingRs == 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2304104,
                "title": "c-easy-to-understand-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canChange(string st, string tar) {\\n        vector<pair<char,int>> stp,tarp;\\n        for(int i=0;i<st.size();i++){\\n            if(st[i]!=\\'_\\')\\n            stp.push_back({st[i],i});\\n        }\\n        for(int j=0;j<tar.size();j++){\\n            if(tar[j]!=\\'_\\')\\n            tarp.push_back({tar[j],j});\\n        }\\n        if(stp.size()!=tarp.size())\\n            return false;\\n        for(int i=0;i<stp.size();i++){\\n            if(tarp[i].first != stp[i].first )\\n                return false;\\n            if(tarp[i].first==\\'L\\' && stp[i].second<tarp[i].second){\\n\\n                return false;\\n            }\\n            if(tarp[i].first==\\'R\\' && stp[i].second>tarp[i].second){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canChange(string st, string tar) {\\n        vector<pair<char,int>> stp,tarp;\\n        for(int i=0;i<st.size();i++){\\n            if(st[i]!=\\'_\\')\\n            stp.push_back({st[i],i});\\n        }\\n        for(int j=0;j<tar.size();j++){\\n            if(tar[j]!=\\'_\\')\\n            tarp.push_back({tar[j],j});\\n        }\\n        if(stp.size()!=tarp.size())\\n            return false;\\n        for(int i=0;i<stp.size();i++){\\n            if(tarp[i].first != stp[i].first )\\n                return false;\\n            if(tarp[i].first==\\'L\\' && stp[i].second<tarp[i].second){\\n\\n                return false;\\n            }\\n            if(tarp[i].first==\\'R\\' && stp[i].second>tarp[i].second){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2293767,
                "title": "c-o-n-time-o-1-space",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canChange(string start, string target) {\\n        int pos1=0;\\n        int pos2=0;\\n        int n=start.length();\\n        int m=target.length();\\n        while(pos1<start.length() or pos2<target.length())\\n        {\\n            while(pos1<n and start[pos1]==\\'_\\')\\n            {\\n                pos1++;\\n            }\\n            while(pos2<m and target[pos2]==\\'_\\')\\n            {\\n                pos2++;\\n            }\\n            if(pos1==n and pos2==m)return true;\\n            if(pos1>=n or pos2>=n)return false;\\n            if(start[pos1]!=target[pos2])return false;\\n            if(start[pos1]==\\'L\\' and pos1<pos2)return false;\\n            if(start[pos1]==\\'R\\' and pos1>pos2)return false;\\n            pos1++;\\n            pos2++;\\n                                  }\\n                                  return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canChange(string start, string target) {\\n        int pos1=0;\\n        int pos2=0;\\n        int n=start.length();\\n        int m=target.length();\\n        while(pos1<start.length() or pos2<target.length())\\n        {\\n            while(pos1<n and start[pos1]==\\'_\\')\\n            {\\n                pos1++;\\n            }\\n            while(pos2<m and target[pos2]==\\'_\\')\\n            {\\n                pos2++;\\n            }\\n            if(pos1==n and pos2==m)return true;\\n            if(pos1>=n or pos2>=n)return false;\\n            if(start[pos1]!=target[pos2])return false;\\n            if(start[pos1]==\\'L\\' and pos1<pos2)return false;\\n            if(start[pos1]==\\'R\\' and pos1>pos2)return false;\\n            pos1++;\\n            pos2++;\\n                                  }\\n                                  return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2292418,
                "title": "same-as-leetcode-777",
                "content": "exactly the same question as LeetCode 777",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 2290093,
                "title": "java-simple-clean-solution",
                "content": "```\\nclass Solution {\\n    public boolean canChange(String start, String target) {\\n        if (!start.replace(\"_\", \"\").equals(target.replace(\"_\", \"\"))) return false;\\n        \\n        final int sLength = start.length();\\n        final int tLength = target.length();\\n        \\n        for (int i = 0, j = 0; i < sLength && j < tLength; i++, j++) {\\n            while (i < sLength && start.charAt(i) == \\'_\\') i++;\\n            while (j < tLength && target.charAt(j) == \\'_\\') j++;\\n            if (i > j && start.charAt(i) == \\'R\\') return false;\\n            if (i < j && start.charAt(i) == \\'L\\') return false;\\n        }\\n        \\n        return true;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public boolean canChange(String start, String target) {\\n        if (!start.replace(\"_\", \"\").equals(target.replace(\"_\", \"\"))) return false;\\n        \\n        final int sLength = start.length();\\n        final int tLength = target.length();\\n        \\n        for (int i = 0, j = 0; i < sLength && j < tLength; i++, j++) {\\n            while (i < sLength && start.charAt(i) == \\'_\\') i++;\\n            while (j < tLength && target.charAt(j) == \\'_\\') j++;\\n            if (i > j && start.charAt(i) == \\'R\\') return false;\\n            if (i < j && start.charAt(i) == \\'L\\') return false;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2287834,
                "title": "python3-easy-to-understand-solution-o-n",
                "content": "```\\nclass Solution:\\n    def canChange(self, start: str, target: str) -> bool:\\n\\n        i = self.findNextChar(0, start)  ## starting position of the valid chacters in \"Start\"\\n        j = self.findNextChar(0, target)  ## starting position of the valid characters in \"target\"\\n\\n        if i < 0 and j < 0:\\n            return True\\n        if i < 0 or j < 0:\\n            return False\\n\\n        while True:\\n            if start[i]!=target[j]: return False ## if they dont match return False\\n            if start[i]==\\'R\\' and i > j: return False ## since we are at \\'R\", we can only move right. if i >j then there is no way we can get the result. Example. Start : _R  Target=R_  in this case i=1 > j=0 \\n            if start[i] == \\'L\\' and i < j: return False ## since we are at \"L\", we can only move left. if i<j  then ther eis no way we can get the result. Example Start : L_ Target =_L . in this case i=0 < j=1\\n\\n            i = self.findNextChar(i+1,start) ## check for the next character (\\'R\\' or \\'L\\') in the starting string string\\n            j = self.findNextChar(j + 1, target) ## check for the next character (\\'R\\' or \\'L\\') in the Target string\\n\\n            if i < 0 and j < 0: ## if both i and j are negative then we have explored all characters\\n                return True\\n            if i < 0 or j < 0: ## if this happens then return False.\\n                return False\\n\\n    def findNextChar(self, startingPosition, String):\\n\\n        i = startingPosition \\n        while i < len(String) and String[i] == \\'_\\':\\n            i += 1\\n        if i == len(String):\\n            return -1\\n\\n        return i\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def canChange(self, start: str, target: str) -> bool:\\n\\n        i = self.findNextChar(0, start)  ## starting position of the valid chacters in \"Start\"\\n        j = self.findNextChar(0, target)  ## starting position of the valid characters in \"target\"\\n\\n        if i < 0 and j < 0:\\n            return True\\n        if i < 0 or j < 0:\\n            return False\\n\\n        while True:\\n            if start[i]!=target[j]: return False ## if they dont match return False\\n            if start[i]==\\'R\\' and i > j: return False ## since we are at \\'R\", we can only move right. if i >j then there is no way we can get the result. Example. Start : _R  Target=R_  in this case i=1 > j=0 \\n            if start[i] == \\'L\\' and i < j: return False ## since we are at \"L\", we can only move left. if i<j  then ther eis no way we can get the result. Example Start : L_ Target =_L . in this case i=0 < j=1\\n\\n            i = self.findNextChar(i+1,start) ## check for the next character (\\'R\\' or \\'L\\') in the starting string string\\n            j = self.findNextChar(j + 1, target) ## check for the next character (\\'R\\' or \\'L\\') in the Target string\\n\\n            if i < 0 and j < 0: ## if both i and j are negative then we have explored all characters\\n                return True\\n            if i < 0 or j < 0: ## if this happens then return False.\\n                return False\\n\\n    def findNextChar(self, startingPosition, String):\\n\\n        i = startingPosition \\n        while i < len(String) and String[i] == \\'_\\':\\n            i += 1\\n        if i == len(String):\\n            return -1\\n\\n        return i\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2284611,
                "title": "easy-to-understand-c",
                "content": "\\n            cases to handle\\n                1.both startQValue and targetQValue values aren\\'t same -> false\\n                    start = \\'L\\'\\n                    target = \\'R\\'\\n                2.left is \\'L\\'\\n                    a.start = _,_,L (startQValue can towards left side so ->true)\\n                      target= L,_,_\\n                     b.start = L,_,_ (targetQValue can\\'t go towards right side so ->false)\\n                      target = _,_,L\\n                3.left is \\'R\\'\\n                    a.start = _,_,R (startQValue can\\'t go towards left side so ->false)\\n                      target= R,_,_\\n                     b.start = R,_,_ (targetQValue can go towards right side so ->true)\\n                      target = _,_,R\\n\\n```\\nclass Solution {\\npublic:\\n    bool canChange(string start, string target) {\\n        queue<pair<char,int>> left;\\n        queue<pair<char,int>> right;\\n        for(int i=0;i<start.length();i++) {\\n            if(start[i] != \\'_\\') left.push({start[i], i});\\n        }\\n        for(int i=0;i<target.length();i++) {\\n            if(target[i] != \\'_\\')right.push({target[i], i});\\n        }\\n        \\n        if(left.size() != right.size()) {\\n            return false;\\n        }\\n        \\n        while(!left.empty()) {\\n            pair<char,int> startQValue = left.front();\\n            pair<char,int> targetQValue = right.front();\\n            left.pop();\\n            right.pop();\\n            if(startQValue.first != targetQValue.first) {\\n                return false;\\n            }\\n            if(startQValue.first == \\'L\\' && targetQValue.second > startQValue.second) {\\n                return false;\\n            } else if(startQValue.first == \\'R\\' && targetQValue.second < startQValue.second) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canChange(string start, string target) {\\n        queue<pair<char,int>> left;\\n        queue<pair<char,int>> right;\\n        for(int i=0;i<start.length();i++) {\\n            if(start[i] != \\'_\\') left.push({start[i], i});\\n        }\\n        for(int i=0;i<target.length();i++) {\\n            if(target[i] != \\'_\\')right.push({target[i], i});\\n        }\\n        \\n        if(left.size() != right.size()) {\\n            return false;\\n        }\\n        \\n        while(!left.empty()) {\\n            pair<char,int> startQValue = left.front();\\n            pair<char,int> targetQValue = right.front();\\n            left.pop();\\n            right.pop();\\n            if(startQValue.first != targetQValue.first) {\\n                return false;\\n            }\\n            if(startQValue.first == \\'L\\' && targetQValue.second > startQValue.second) {\\n                return false;\\n            } else if(startQValue.first == \\'R\\' && targetQValue.second < startQValue.second) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2283849,
                "title": "java-two-pointers-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public boolean canChange(String start, String target) {\\n        int i=0,j=0,n=start.length();\\n        char chs=\\' \\',cht=\\' \\';\\n        while(i<n && j<n){\\n            chs=start.charAt(i); cht=target.charAt(j);\\n            if(chs==\\'_\\')\\n                i++;\\n            else if(cht==\\'_\\')\\n                j++;\\n            else if(chs==cht){\\n                if(chs==\\'L\\' && i<j)\\n                    return false;\\n                if(chs==\\'R\\' && i>j)\\n                    return false;\\n                i++;j++;\\n            }else if(chs!=cht){\\n                return false;\\n            }\\n        }\\n        while(i<n)\\n            if(start.charAt(i)==\\'_\\')\\n                i++;\\n            else return false;\\n        while(j<n)\\n            if(target.charAt(j)==\\'_\\')\\n                j++;\\n            else return false;\\n        if(chs==cht && i==j)\\n            return true;\\n        else return false;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canChange(String start, String target) {\\n        int i=0,j=0,n=start.length();\\n        char chs=\\' \\',cht=\\' \\';\\n        while(i<n && j<n){\\n            chs=start.charAt(i); cht=target.charAt(j);\\n            if(chs==\\'_\\')\\n                i++;\\n            else if(cht==\\'_\\')\\n                j++;\\n            else if(chs==cht){\\n                if(chs==\\'L\\' && i<j)\\n                    return false;\\n                if(chs==\\'R\\' && i>j)\\n                    return false;\\n                i++;j++;\\n            }else if(chs!=cht){\\n                return false;\\n            }\\n        }\\n        while(i<n)\\n            if(start.charAt(i)==\\'_\\')\\n                i++;\\n            else return false;\\n        while(j<n)\\n            if(target.charAt(j)==\\'_\\')\\n                j++;\\n            else return false;\\n        if(chs==cht && i==j)\\n            return true;\\n        else return false;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2270214,
                "title": "linear-traversal-solution",
                "content": "Leetcode 2337 here is essentially the same as Leetcode 777.\\n\\nSolution:\\n```\\nclass Solution:\\n    def canChange(self, start: str, target: str) -> bool:\\n        n = len(start)\\n        i = j = 0\\n        while i < n or j < n:\\n            while i < n and start[i] == \"_\":\\n                i += 1\\n            while j < n and target[j] == \"_\":\\n                j += 1\\n            if i == n or j == n:\\n                break\\n            if start[i] != target[j] or (start[i]==\"L\" and i < j) or (start[i]==\"R\" and i > j):\\n                return False\\n            i, j = i + 1, j + 1\\n            \\n        return i == n and j == n  \\n```\\n\\n\\n[Click here for a Video Explanation](https://youtu.be/_Fc0cEq5kYA;)\\n\\n```\\nAnalysis:\\n\\nMain Points: \\n-1 due to more right \"_\"s\\n\"R___\"\\n\"_R__\"\\n\\n-2 due to more left \"_\"s\\n\"__L\"\\n\"L__\"\\n\\n-3 chars need count the same and maintain relative order\\n  for example, start = \"_L__R__R_\", target = \"L______RR\" => True\\n  counter-example: start = \"_R__L__R_\", target = \"L______RR\" => False\\n  \\nProcedure:\\n\\n- scan the start and target to locate non-underline chars, say at indices i (in start) and j (in target)\\n- if start[i] != target[j], return False due to item 3 above\\n  if start[i] == target[j] == \"L\", we shall be able to move the \"L\" to left or remain, \\n                                   so i >= j. So if i < j, return False\\n  if start[i] == target[j] == \"R\", we shall be able to move the \"R\" to right or remain, \\n                                   so i <= j. So if i > j, return False\\n                                   \\n- after the above loop, both i and j should end at n = len(start) in the True case \\n  due to same length assumption.\\n\\nOne way to understand the 2nd item in the procedure can be as follows:\\n\\nimage if there were no underscores, then the corresponding same chars in start and target shall have the\\nsame index: i == j. \\n\\nIf we can recover target from start, it is due to \"added\" \"_\" to the right of \"R\", and to the left of \"L\" in start. That explains the relative position relation:\\n        \\n                    if char is \"R\", i <= j, and if char is \"L\": i >= j\\n\\nIf this is the case, we can achieve target based on the moving rules in the problem.\\n ``` \\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def canChange(self, start: str, target: str) -> bool:\\n        n = len(start)\\n        i = j = 0\\n        while i < n or j < n:\\n            while i < n and start[i] == \"_\":\\n                i += 1\\n            while j < n and target[j] == \"_\":\\n                j += 1\\n            if i == n or j == n:\\n                break\\n            if start[i] != target[j] or (start[i]==\"L\" and i < j) or (start[i]==\"R\" and i > j):\\n                return False\\n            i, j = i + 1, j + 1\\n            \\n        return i == n and j == n  \\n```\n```\\nAnalysis:\\n\\nMain Points: \\n-1 due to more right \"_\"s\\n\"R___\"\\n\"_R__\"\\n\\n-2 due to more left \"_\"s\\n\"__L\"\\n\"L__\"\\n\\n-3 chars need count the same and maintain relative order\\n  for example, start = \"_L__R__R_\", target = \"L______RR\" => True\\n  counter-example: start = \"_R__L__R_\", target = \"L______RR\" => False\\n  \\nProcedure:\\n\\n- scan the start and target to locate non-underline chars, say at indices i (in start) and j (in target)\\n- if start[i] != target[j], return False due to item 3 above\\n  if start[i] == target[j] == \"L\", we shall be able to move the \"L\" to left or remain, \\n                                   so i >= j. So if i < j, return False\\n  if start[i] == target[j] == \"R\", we shall be able to move the \"R\" to right or remain, \\n                                   so i <= j. So if i > j, return False\\n                                   \\n- after the above loop, both i and j should end at n = len(start) in the True case \\n  due to same length assumption.\\n\\nOne way to understand the 2nd item in the procedure can be as follows:\\n\\nimage if there were no underscores, then the corresponding same chars in start and target shall have the\\nsame index: i == j. \\n\\nIf we can recover target from start, it is due to \"added\" \"_\" to the right of \"R\", and to the left of \"L\" in start. That explains the relative position relation:\\n        \\n                    if char is \"R\", i <= j, and if char is \"L\": i >= j\\n\\nIf this is the case, we can achieve target based on the moving rules in the problem.\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 2268889,
                "title": "c-count",
                "content": "If <code>target</code> can be obtained from <code>start</code>, then\\n<ol>\\n\\t<li>After we remove all <code>\\'_\\'</code> from them, the corresponding string <code>s1</code> and <code>s2</code> should be the same; \\n\\t<li>Besides, since <code>\\'R\\'</code> can only be moved to the right, the number of <code>\\'_\\'</code> before the <code>i<sub>th</sub></code> <code>\\'R\\'</code> in <code>target</code> should be more than the corresponding <code>\\'R\\'</code> in <code>start</code>;  \\n\\t<li>Similarly,  the number of <code>\\'_\\'</code> after the <code>i<sub>th</sub></code> <code>\\'L\\'</code> in <code>target</code> should be more than the corresponding <code>\\'L\\'</code> in <code>start</code>;\\n</ol>\\n\\n```\\nclass Solution {\\npublic:\\n    bool canChange(string start, string target) {\\n        int c1 = count(start.begin(), start.end(), \\'_\\');\\n        int c2 = count(target.begin(), target.end(), \\'_\\');\\n        string s1 = \"\", s2 = \"\";\\n        vector<int> k1, k2;\\n        int k = 0, n = start.length();\\n        for (int i = 0; i < n; i++)\\n        {\\n            if (start[i] == \\'_\\')\\n                k++;\\n            else if (start[i] == \\'L\\')\\n            {\\n                k1.push_back(c1 - k);\\n                s1 += \\'L\\';\\n            }\\n            else\\n            {\\n                k1.push_back(k);\\n                s1 += \\'R\\';\\n            }\\n        }\\n        k = 0;\\n        for (int i = 0; i < n; i++)\\n        {\\n            if (target[i] == \\'_\\')\\n                k++;\\n            else if (target[i] == \\'L\\')\\n            {\\n                k2.push_back(c2 - k);\\n                s2 += \\'L\\';\\n            }\\n            else\\n            {\\n                k2.push_back(k);\\n                s2 += \\'R\\';\\n            }\\n        }\\n        if (s1 != s2)\\n            return false;\\n        int m = k1.size();\\n        for (int i = 0; i < m; i++)\\n            if (k1[i] > k2[i])\\n                return false;\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canChange(string start, string target) {\\n        int c1 = count(start.begin(), start.end(), \\'_\\');\\n        int c2 = count(target.begin(), target.end(), \\'_\\');\\n        string s1 = \"\", s2 = \"\";\\n        vector<int> k1, k2;\\n        int k = 0, n = start.length();\\n        for (int i = 0; i < n; i++)\\n        {\\n            if (start[i] == \\'_\\')\\n                k++;\\n            else if (start[i] == \\'L\\')\\n            {\\n                k1.push_back(c1 - k);\\n                s1 += \\'L\\';\\n            }\\n            else\\n            {\\n                k1.push_back(k);\\n                s1 += \\'R\\';\\n            }\\n        }\\n        k = 0;\\n        for (int i = 0; i < n; i++)\\n        {\\n            if (target[i] == \\'_\\')\\n                k++;\\n            else if (target[i] == \\'L\\')\\n            {\\n                k2.push_back(c2 - k);\\n                s2 += \\'L\\';\\n            }\\n            else\\n            {\\n                k2.push_back(k);\\n                s2 += \\'R\\';\\n            }\\n        }\\n        if (s1 != s2)\\n            return false;\\n        int m = k1.size();\\n        for (int i = 0; i < m; i++)\\n            if (k1[i] > k2[i])\\n                return false;\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2265454,
                "title": "c-easy-implementation",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canChange(string s, string t) {\\n        int i = 0;          //For Target\\n        int j = 0;          //For start\\n        int n = s.size();   //Same for t\\n        \\n        while(i<n || j<n)\\n        {\\n            while(i<n && t[i] == \\'_\\') i++;      //Skip till you find a character\\n            while(j<n && s[j] == \\'_\\') j++;\\n            \\n            if(t[i] != s[j]) return false;\\n            \\n            if(t[i] == \\'L\\' && j < i) return false;    //Since we know we can move L toward left only so\\n                                                      //If index of L in start is less than index of L in Target\\n            if(t[i] == \\'R\\' && j > i) return false;    //Then it is impossible to to make target from start\\n            \\n            i++;                                      //Since we know we can move R toward Right only so\\n            j++;                                      //If index of R in start is greater than index of R in Target\\n        }                                             //Then it is impossible to to make target from start\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canChange(string s, string t) {\\n        int i = 0;          //For Target\\n        int j = 0;          //For start\\n        int n = s.size();   //Same for t\\n        \\n        while(i<n || j<n)\\n        {\\n            while(i<n && t[i] == \\'_\\') i++;      //Skip till you find a character\\n            while(j<n && s[j] == \\'_\\') j++;\\n            \\n            if(t[i] != s[j]) return false;\\n            \\n            if(t[i] == \\'L\\' && j < i) return false;    //Since we know we can move L toward left only so\\n                                                      //If index of L in start is less than index of L in Target\\n            if(t[i] == \\'R\\' && j > i) return false;    //Then it is impossible to to make target from start\\n            \\n            i++;                                      //Since we know we can move R toward Right only so\\n            j++;                                      //If index of R in start is greater than index of R in Target\\n        }                                             //Then it is impossible to to make target from start\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2265359,
                "title": "scala",
                "content": "```\\nobject Solution {\\n  def canChange(start: String, target: String): Boolean = {\\n    nonBlanks(start).corresponds(nonBlanks(target))(_ == _) &&\\n      indicesOf(start, \\'L\\').corresponds(indicesOf(target, \\'L\\'))(_ >= _) &&\\n      indicesOf(start, \\'R\\').corresponds(indicesOf(target, \\'R\\'))(_ <= _)\\n  }\\n\\n  private def nonBlanks(s: String) = s.iterator.filter(_ != \\'_\\')\\n  \\n  private def indicesOf(s: String, c: Char) = s.iterator.zipWithIndex.collect { case (c1, i) if c1 == c => i }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n  def canChange(start: String, target: String): Boolean = {\\n    nonBlanks(start).corresponds(nonBlanks(target))(_ == _) &&\\n      indicesOf(start, \\'L\\').corresponds(indicesOf(target, \\'L\\'))(_ >= _) &&\\n      indicesOf(start, \\'R\\').corresponds(indicesOf(target, \\'R\\'))(_ <= _)\\n  }\\n\\n  private def nonBlanks(s: String) = s.iterator.filter(_ != \\'_\\')\\n  \\n  private def indicesOf(s: String, c: Char) = s.iterator.zipWithIndex.collect { case (c1, i) if c1 == c => i }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2265039,
                "title": "100-faster-in-space-and-time-easy-gready-solution-c",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canChange(string start, string target) {\\n        vector<int> s1l,s1r,s2l,s2r;\\n        int m = start.size();\\n        int n = target.size();\\n        int x = 0;\\n        string s1,s2;\\n        for(auto &it : start){\\n            if(it != \\'_\\')\\n                s1.push_back(it);\\n        }\\n        for(auto &it : target){\\n            if(it != \\'_\\')\\n                s2.push_back(it);\\n        }\\n        if(s1 != s2)\\n            return false;\\n        for(int i = 0 ; i < m ; i++){\\n            if(start[i] == \\'_\\')\\n                x++;\\n            if(start[i] == \\'R\\')\\n                s1r.push_back(x);\\n        }\\n        x = 0;\\n        for(int i = 0 ; i < n ; i++){\\n            if(target[i] == \\'_\\')\\n                x++;\\n            if(target[i] == \\'R\\')\\n                s2r.push_back(x);\\n        }\\n        if(s1r.size() != s2r.size())\\n            return false;\\n        int k = s1r.size();\\n        for(int i = 0 ; i < k ; i++){\\n            if(s1r[i] > s2r[i])\\n                return false;\\n        }\\n        x = 0;\\n        for(int i = m-1 ; i >= 0 ; i--){\\n            if(start[i] == \\'_\\')\\n                x++;\\n            if(start[i] == \\'L\\')\\n                s1l.push_back(x);\\n        }\\n        x = 0;\\n        for(int i = m-1 ; i >= 0 ; i--){\\n            if(target[i] == \\'_\\')\\n                x++;\\n            if(target[i] == \\'L\\')\\n                s2l.push_back(x);\\n        }\\n        if(s1l.size() != s2l.size())\\n            return false;\\n        k = s1l.size();\\n        for(int i = 0 ; i < k ; i++){\\n            if(s1l[i] > s2l[i])\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "String",
                    "Greedy",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canChange(string start, string target) {\\n        vector<int> s1l,s1r,s2l,s2r;\\n        int m = start.size();\\n        int n = target.size();\\n        int x = 0;\\n        string s1,s2;\\n        for(auto &it : start){\\n            if(it != \\'_\\')\\n                s1.push_back(it);\\n        }\\n        for(auto &it : target){\\n            if(it != \\'_\\')\\n                s2.push_back(it);\\n        }\\n        if(s1 != s2)\\n            return false;\\n        for(int i = 0 ; i < m ; i++){\\n            if(start[i] == \\'_\\')\\n                x++;\\n            if(start[i] == \\'R\\')\\n                s1r.push_back(x);\\n        }\\n        x = 0;\\n        for(int i = 0 ; i < n ; i++){\\n            if(target[i] == \\'_\\')\\n                x++;\\n            if(target[i] == \\'R\\')\\n                s2r.push_back(x);\\n        }\\n        if(s1r.size() != s2r.size())\\n            return false;\\n        int k = s1r.size();\\n        for(int i = 0 ; i < k ; i++){\\n            if(s1r[i] > s2r[i])\\n                return false;\\n        }\\n        x = 0;\\n        for(int i = m-1 ; i >= 0 ; i--){\\n            if(start[i] == \\'_\\')\\n                x++;\\n            if(start[i] == \\'L\\')\\n                s1l.push_back(x);\\n        }\\n        x = 0;\\n        for(int i = m-1 ; i >= 0 ; i--){\\n            if(target[i] == \\'_\\')\\n                x++;\\n            if(target[i] == \\'L\\')\\n                s2l.push_back(x);\\n        }\\n        if(s1l.size() != s2l.size())\\n            return false;\\n        k = s1l.size();\\n        for(int i = 0 ; i < k ; i++){\\n            if(s1l[i] > s2l[i])\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2264971,
                "title": "o-n-python-8-loc-with-cases",
                "content": "There are 3 cases where it\\'s impossible to get `target` from `start`:\\n\\n1. The numbers of `L`s and `R`s don\\'t match in `start` and `target`.\\n2. Any `L` and `R` swap places (the ordering of `L`s and `R`s is different).\\n3. An `L` moves to the right or an `R` moves to the left.\\n\\n```\\ndef canChange(self, start: str, target: str) -> bool:\\n    sOrder = [i for i, c in enumerate(start) if c != \"_\"]\\n\\ttOrder = [i for i, c in enumerate(target) if c != \"_\"]\\n\\t# Case 1\\n\\tif len(sOrder) != len(tOrder): return False\\n\\n\\tfor i in range(len(sOrder)):\\n\\t\\t# Case 2\\n\\t\\tif start[sOrder[i]] != target[tOrder[i]]: return False\\n\\t\\t# Case 3\\n\\t\\telif start[sOrder[i]] == \"L\" and tOrder[i] > sOrder[i]: return False\\n\\t\\telif start[sOrder[i]] == \"R\" and tOrder[i] < sOrder[i]: return False\\n\\n\\treturn True\\n```\\n\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef canChange(self, start: str, target: str) -> bool:\\n    sOrder = [i for i, c in enumerate(start) if c != \"_\"]\\n\\ttOrder = [i for i, c in enumerate(target) if c != \"_\"]\\n\\t# Case 1\\n\\tif len(sOrder) != len(tOrder): return False\\n\\n\\tfor i in range(len(sOrder)):\\n\\t\\t# Case 2\\n\\t\\tif start[sOrder[i]] != target[tOrder[i]]: return False\\n\\t\\t# Case 3\\n\\t\\telif start[sOrder[i]] == \"L\" and tOrder[i] > sOrder[i]: return False\\n\\t\\telif start[sOrder[i]] == \"R\" and tOrder[i] < sOrder[i]: return False\\n\\n\\treturn True\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2264655,
                "title": "c-o-n-time-complexity-o-1-space-complexity-100-faster-easy-approach",
                "content": "**please upvote if you like this approach**\\n\\n```\\nclass Solution {\\npublic:\\n    bool canChange(string start, string target) {\\n        \\n        // first we have to check if the numbers of \\'R\\' and \\'L\\' in both strings are equal or not.         \\n        int r1=0,l1=0;\\n        int r2=0,l2=0;\\n        \\n        for(int i=0;i<start.size();i++){\\n            if(start[i]==\\'R\\'){\\n                r1++;\\n            }\\n            else if(start[i]==\\'L\\'){\\n                l1++;\\n            }\\n            \\n            if(target[i]==\\'R\\'){\\n                r2++;\\n            }\\n            else if(target[i]==\\'L\\'){\\n                l2++;\\n            }\\n        }\\n        \\n        if(r1!=r2 || l1!=l2) return false;\\n        \\n        \\n        // here we shift only \\'L\\', and we traverse from left to right and check if there is any \\'R\\' before we hit\\n        // the required numbers of \\'L\\' on the left side, then we return false... \\n        \\n        // And if there is \\'R\\' at ith position in start string and \\'L\\' is at ith position in target string,then we also return false ...          \\n        \\n        int req = 0;\\n        \\n        for(int i=0;i<start.size();i++){\\n            \\n             if(start[i]==\\'R\\' && target[i]==\\'L\\'){\\n                 return false;\\n             }\\n             if(req>0 && start[i] == \\'R\\'){\\n                   return false;\\n             }\\n             \\n            \\n             if(start[i] != \\'L\\' && target[i]==\\'L\\'){\\n                  req++;\\n             }\\n             else if(req>0 && start[i]==\\'L\\'){\\n                  req--;\\n             }\\n        }\\n        \\n        \\n        if(req != 0) return  false;\\n        req = 0;\\n        \\n         // here we shift only \\'R\\', and we traverse from right to left and check if there is any \\'L\\' before we hit\\n        // the required numbers of \\'R\\' on the right side, then we return false... \\n        \\n        // And if there is \\'L\\' at ith position in start string and \\'R\\' is at ith position in target string,then we also return false ...          \\n        \\n        \\n        \\n        for(int i=start.size()-1;i>=0;i--){\\n             \\n            \\n             if(start[i]==\\'L\\' && target[i]==\\'R\\'){\\n                 return false;\\n             }\\n            \\n             if(req>0 && start[i] == \\'L\\'){\\n                 return false;\\n             }\\n            \\n             if(start[i] != \\'R\\' && target[i]==\\'R\\'){\\n                  req++;\\n             }\\n             else if(req>0 && start[i]==\\'R\\'){\\n                  req--;\\n             }\\n          \\n        }\\n        \\n        if(req != 0) return false;\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canChange(string start, string target) {\\n        \\n        // first we have to check if the numbers of \\'R\\' and \\'L\\' in both strings are equal or not.         \\n        int r1=0,l1=0;\\n        int r2=0,l2=0;\\n        \\n        for(int i=0;i<start.size();i++){\\n            if(start[i]==\\'R\\'){\\n                r1++;\\n            }\\n            else if(start[i]==\\'L\\'){\\n                l1++;\\n            }\\n            \\n            if(target[i]==\\'R\\'){\\n                r2++;\\n            }\\n            else if(target[i]==\\'L\\'){\\n                l2++;\\n            }\\n        }\\n        \\n        if(r1!=r2 || l1!=l2) return false;\\n        \\n        \\n        // here we shift only \\'L\\', and we traverse from left to right and check if there is any \\'R\\' before we hit\\n        // the required numbers of \\'L\\' on the left side, then we return false... \\n        \\n        // And if there is \\'R\\' at ith position in start string and \\'L\\' is at ith position in target string,then we also return false ...          \\n        \\n        int req = 0;\\n        \\n        for(int i=0;i<start.size();i++){\\n            \\n             if(start[i]==\\'R\\' && target[i]==\\'L\\'){\\n                 return false;\\n             }\\n             if(req>0 && start[i] == \\'R\\'){\\n                   return false;\\n             }\\n             \\n            \\n             if(start[i] != \\'L\\' && target[i]==\\'L\\'){\\n                  req++;\\n             }\\n             else if(req>0 && start[i]==\\'L\\'){\\n                  req--;\\n             }\\n        }\\n        \\n        \\n        if(req != 0) return  false;\\n        req = 0;\\n        \\n         // here we shift only \\'R\\', and we traverse from right to left and check if there is any \\'L\\' before we hit\\n        // the required numbers of \\'R\\' on the right side, then we return false... \\n        \\n        // And if there is \\'L\\' at ith position in start string and \\'R\\' is at ith position in target string,then we also return false ...          \\n        \\n        \\n        \\n        for(int i=start.size()-1;i>=0;i--){\\n             \\n            \\n             if(start[i]==\\'L\\' && target[i]==\\'R\\'){\\n                 return false;\\n             }\\n            \\n             if(req>0 && start[i] == \\'L\\'){\\n                 return false;\\n             }\\n            \\n             if(start[i] != \\'R\\' && target[i]==\\'R\\'){\\n                  req++;\\n             }\\n             else if(req>0 && start[i]==\\'R\\'){\\n                  req--;\\n             }\\n          \\n        }\\n        \\n        if(req != 0) return false;\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2264238,
                "title": "javascript-two-pointers-clean-and-straight-forward-video-explanation",
                "content": "Based on this video explaination https://www.youtube.com/watch?v=Aki0ZFnukKM\\n\\n1. Keep checking characters from both strings\\n2. If there is difference - return false\\n3. If current character is \\'L\\' and \\'i\\'  pointer is before \\'j\\' pointer - return false as we not allowed to modify target string and in that situation won\\'t be possible to make them the same\\n```\\n/**\\n * @param {string} start\\n * @param {string} target\\n * @return {boolean}\\n */\\nvar canChange = function(start, target) {\\n    let i = 0\\n    let j = 0\\n    const len = start.length\\n    \\n    while(i <= len && j <= len) {\\n        while(i < len  && start[i] === \\'_\\') i++\\n        while(j < len && target[j] === \\'_\\') j++\\n        \\n        if(i === len && j === len) return true\\n        if(i === len || j === len) return false\\n        \\n        if(start[i] !== target[j]) return false\\n        if(start[i] === \\'L\\' && j > i) return false\\n        if(start[i] === \\'R\\' && j < i) return false\\n        i++\\n        j++\\n    }\\n    \\n    return false\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} start\\n * @param {string} target\\n * @return {boolean}\\n */\\nvar canChange = function(start, target) {\\n    let i = 0\\n    let j = 0\\n    const len = start.length\\n    \\n    while(i <= len && j <= len) {\\n        while(i < len  && start[i] === \\'_\\') i++\\n        while(j < len && target[j] === \\'_\\') j++\\n        \\n        if(i === len && j === len) return true\\n        if(i === len || j === len) return false\\n        \\n        if(start[i] !== target[j]) return false\\n        if(start[i] === \\'L\\' && j > i) return false\\n        if(start[i] === \\'R\\' && j < i) return false\\n        i++\\n        j++\\n    }\\n    \\n    return false\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2264133,
                "title": "python-3-100-time-simple-counting-with-examples",
                "content": "![image](https://assets.leetcode.com/users/images/b89e4a74-e986-4e4d-aa9d-ecddda90c91f_1657465582.0265956.png)\\n\\nKeey two counters cL and cR to count number of \\'L\\' and \\'R\\'.\\n\\'L\\' in start, increase cL; \\'L\\' in target, decrease cL.\\n\\'R\\' in start, decrease cR; \\'R\\' in target, increase cR.\\n\\nAt any index, the followin states are invalid:\\nstart has an \\'L\\' and cR > 0: ```start = \\'RL\\', target = \\'LR\\',``` False at index 1.\\ncL < 0: ```start = \\'L_\\', target = \\'_L\\',``` False at index 0.\\ncR < 0: ```start = \\'_R\\', target = \\'R_\\',``` False at index 1.\\n\\n```\\nclass Solution:\\n    def canChange(self, start: str, target: str) -> bool:\\n        if start.count(\\'L\\') != target.count(\\'L\\') or start.count(\\'R\\') != target.count(\\'R\\'):\\n            return False\\n        \\n        n = len(start)\\n        cL = cR = 0\\n        for i in range(n):\\n            if start[i] == \\'L\\':\\n                if cR > 0:\\n                    return False\\n                cL -= 1\\n            if start[i] == \\'R\\':\\n                cR += 1\\n            #\\n            if target[i] == \\'L\\':\\n                cL += 1\\n            if target[i] == \\'R\\':\\n                cR -= 1\\n            #\\n            if cL < 0:\\n                return False\\n            if cR < 0:\\n                return False\\n            \\n        return True\\n```",
                "solutionTags": [],
                "code": "```start = \\'RL\\', target = \\'LR\\',```\n```start = \\'L_\\', target = \\'_L\\',```\n```start = \\'_R\\', target = \\'R_\\',```\n```\\nclass Solution:\\n    def canChange(self, start: str, target: str) -> bool:\\n        if start.count(\\'L\\') != target.count(\\'L\\') or start.count(\\'R\\') != target.count(\\'R\\'):\\n            return False\\n        \\n        n = len(start)\\n        cL = cR = 0\\n        for i in range(n):\\n            if start[i] == \\'L\\':\\n                if cR > 0:\\n                    return False\\n                cL -= 1\\n            if start[i] == \\'R\\':\\n                cR += 1\\n            #\\n            if target[i] == \\'L\\':\\n                cL += 1\\n            if target[i] == \\'R\\':\\n                cR -= 1\\n            #\\n            if cL < 0:\\n                return False\\n            if cR < 0:\\n                return False\\n            \\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2263644,
                "title": "javascript-two-pointer-approach",
                "content": "```\\nvar canChange = function(start, target) {\\n    let i = 0, j = 0;\\n    \\n    while(i < start.length || j < target.length) {\\n        while(i < start.length && start[i] === \\'_\\') {\\n            i++;\\n        }\\n        \\n        while(j < target.length && target[j] === \\'_\\') {\\n            j++;\\n        }\\n        if(start[i] !== target[j]) return false;\\n        \\n        if(start[i] === \\'L\\' && i < j) return false;\\n        \\n        if(start[i] === \\'R\\' && j < i) return false;\\n        \\n        i++;\\n        j++;\\n    }\\n    \\n    return true;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Two Pointers"
                ],
                "code": "```\\nvar canChange = function(start, target) {\\n    let i = 0, j = 0;\\n    \\n    while(i < start.length || j < target.length) {\\n        while(i < start.length && start[i] === \\'_\\') {\\n            i++;\\n        }\\n        \\n        while(j < target.length && target[j] === \\'_\\') {\\n            j++;\\n        }\\n        if(start[i] !== target[j]) return false;\\n        \\n        if(start[i] === \\'L\\' && i < j) return false;\\n        \\n        if(start[i] === \\'R\\' && j < i) return false;\\n        \\n        i++;\\n        j++;\\n    }\\n    \\n    return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2263186,
                "title": "general-approach-faster-than-100",
                "content": "**Problem:** We have two strings S and T. We want to achieve T from S by moving characters of S.\\n\\n##### Conditions that must hold:\\n* *Size of strings must be same.*\\n* *Frequency of characters must be same.*\\n\\n##### Movements:\\n* **CASE 1:** If characters can cross each other, then the above two conditions are enough.\\n* **CASE 2:** If characters have restricted movements (like in this question), then the presence of characters in S should be in accordance with the restrictions.\\n\\n##### CASE 2 Explanation:\\nLet the allowed movement says that the characters can\\'t cross each other. It means, the ordering of the characters in S and T must also be same. In simple words, S = T. Very simple! That\\'s why the question is allowing movements through \\' _ \\'. \\n\\nLet\\'s come to the original question. \\n**Movement Restrictions:** \\'L\\' can move only to the left and \\'R\\' can move only to the right. And \\'L\\' and \\'R\\' cannot cross each other.\\n\\nSince \\'L\\' and \\'R\\' can\\'t cross each other, so if we create strings of \\'L\\' and \\'R\\' only, then that strings must be equal (say S_ = T_).\\n\\nSince \\'L\\' can move only to the left and \\'R\\' can move only to the right, therefore \\'L\\' should be in the right of required position and \\'R\\' should be in the left of required position in the string S_.\\n\\n\\n**C++ implementation of the above approach:**\\n\\n```\\nclass Solution {\\npublic:\\n    bool canChange(string s, string t) {\\n        string s_, t_; // strings of L and R only\\n        vector<int> si, ti; // Corresponding indices of L and R.\\n        for(int i = 0; i < s.size(); i++) {\\n            if(s[i] == \\'L\\' or s[i] == \\'R\\') {\\n                s_.push_back(s[i]);\\n                si.push_back(i);\\n            }\\n            if(t[i] == \\'L\\' or t[i] == \\'R\\') {\\n                t_.push_back(t[i]);\\n                ti.push_back(i);\\n            }\\n        }\\n        if(s_ != t_) return false; // Ordering must be same.\\n        for(int i = 0; i < t_.size(); i++) {\\n            // L should be at or in the right of required position.\\n            if(t_[i] == \\'L\\' and si[i] < ti[i]) return false; // L is in left.\\n            // R should be at or in the left of required position.\\n            if(t_[i] == \\'R\\' and si[i] > ti[i]) return false; // R is in right.\\n        }\\n        return true;\\n    }\\n};\\n```\\n\\n**Runtime:** 89ms\\n\\n\\n\\n",
                "solutionTags": [
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canChange(string s, string t) {\\n        string s_, t_; // strings of L and R only\\n        vector<int> si, ti; // Corresponding indices of L and R.\\n        for(int i = 0; i < s.size(); i++) {\\n            if(s[i] == \\'L\\' or s[i] == \\'R\\') {\\n                s_.push_back(s[i]);\\n                si.push_back(i);\\n            }\\n            if(t[i] == \\'L\\' or t[i] == \\'R\\') {\\n                t_.push_back(t[i]);\\n                ti.push_back(i);\\n            }\\n        }\\n        if(s_ != t_) return false; // Ordering must be same.\\n        for(int i = 0; i < t_.size(); i++) {\\n            // L should be at or in the right of required position.\\n            if(t_[i] == \\'L\\' and si[i] < ti[i]) return false; // L is in left.\\n            // R should be at or in the left of required position.\\n            if(t_[i] == \\'R\\' and si[i] > ti[i]) return false; // R is in right.\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2262755,
                "title": "c-full-explanation-o-n-faster-than-100",
                "content": "Three contions are to be checked:\\n1. Order of L and R should be same in both the strings.\\n2. Index of L in start should be greater than or equal to index of L in target because then only they can be matched.\\'\\n3. Index of R in start should be greater than or equal to index of R in target for same reason as 2.\\n```\\nclass Solution {\\npublic:\\n    bool canChange(string start, string target) {\\n        vector<pair<char,int>> a,b;     // For storing positions of L and R in both the strings.\\n        for(int x=0;x<start.size();x++){\\n            if(start[x]==\\'L\\' || start[x]==\\'R\\')  //Because spaces don\\'t matter\\n                a.push_back({start[x],x});\\n        }\\n        for(int x=0;x<target.size();x++){\\n            if(target[x]==\\'L\\' || target[x]==\\'R\\')\\n                b.push_back({target[x],x});\\n        }\\n        if(a.size()!=b.size()) //This means both strings have different number of L\\'s and R\\'s\\n            return false;\\n        for(int x=0;x<a.size();x++){\\n            if(a[x].first!=b[x].first)    //Checking the first condition\\n                return false;\\n            if(a[x].first==\\'L\\' && a[x].second<b[x].second)    //Checking the second condition\\n                return false;\\n            if(a[x].first==\\'R\\' && a[x].second>b[x].second)   //Checking the third condition\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canChange(string start, string target) {\\n        vector<pair<char,int>> a,b;     // For storing positions of L and R in both the strings.\\n        for(int x=0;x<start.size();x++){\\n            if(start[x]==\\'L\\' || start[x]==\\'R\\')  //Because spaces don\\'t matter\\n                a.push_back({start[x],x});\\n        }\\n        for(int x=0;x<target.size();x++){\\n            if(target[x]==\\'L\\' || target[x]==\\'R\\')\\n                b.push_back({target[x],x});\\n        }\\n        if(a.size()!=b.size()) //This means both strings have different number of L\\'s and R\\'s\\n            return false;\\n        for(int x=0;x<a.size();x++){\\n            if(a[x].first!=b[x].first)    //Checking the first condition\\n                return false;\\n            if(a[x].first==\\'L\\' && a[x].second<b[x].second)    //Checking the second condition\\n                return false;\\n            if(a[x].first==\\'R\\' && a[x].second>b[x].second)   //Checking the third condition\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2262301,
                "title": "stack-solution-faster-than-87-9-o-n",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tbool canChange(string s, string t) {\\n\\t\\t\\tstack<pair<char,int>> st,st2;\\n\\t\\t\\tfor(int i=0;i<s.size();i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(s[i]!=\\'_\\')\\n\\t\\t\\t\\t\\tst.push({s[i],i});\\n\\t\\t\\t\\tif(t[i]!=\\'_\\')\\n\\t\\t\\t\\t\\tst2.push({t[i],i});\\n\\t\\t\\t}\\n\\t\\t\\tif(st.size()!=st2.size())return false;\\n\\t\\t\\twhile(!st.empty() && !st2.empty()){\\n\\t\\t\\t\\tif(st.top().first!=st2.top().first)return false;\\n\\t\\t\\t\\tif(st.top().first==\\'R\\')\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(st.top().second > st2.top().second)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(st.top().first==\\'L\\')\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(st.top().second < st2.top().second){\\n\\t\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tst.pop(),st2.pop();\\n\\t\\t\\t}\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "Stack"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tbool canChange(string s, string t) {\\n\\t\\t\\tstack<pair<char,int>> st,st2;\\n\\t\\t\\tfor(int i=0;i<s.size();i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(s[i]!=\\'_\\')\\n\\t\\t\\t\\t\\tst.push({s[i],i}",
                "codeTag": "Java"
            },
            {
                "id": 2262193,
                "title": "python-3-o-n-time-o-1-memory-two-pointers",
                "content": "Let me put in my two cents as well.\\n\\n```\\nclass Solution:\\n    def canChange(self, S: str, T: str) -> bool:\\n        si, ti, n = 0, 0, len(S)\\n\\n        while si < n:\\n            if S[si] != \"_\":\\n                while ti < n and T[ti] == \"_\":\\n                    ti += 1\\n                if ti == n or S[si] != T[ti] or S[si] == \"L\" and si < ti or S[si] == \"R\" and si > ti:\\n                    return False\\n                ti += 1\\n            si += 1\\n\\n        return all(T[i] == \"_\" for i in range(ti, n))\\n```\\n\\nBasically, we iterate over the `start` string and keep track of the current indices in both `start` and `target` to check that the values of `L` and `R` are in the right place. Don\\'t let the inner `while` confuse you, though! `ti` can only increase up to `n`. Hence, the maximum number of total iterations is equal to `2n`. Therefore, the time complexity is `O(n)`. The space complexity is obviously `O(1)`, since we are not using any data structures here.",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def canChange(self, S: str, T: str) -> bool:\\n        si, ti, n = 0, 0, len(S)\\n\\n        while si < n:\\n            if S[si] != \"_\":\\n                while ti < n and T[ti] == \"_\":\\n                    ti += 1\\n                if ti == n or S[si] != T[ti] or S[si] == \"L\" and si < ti or S[si] == \"R\" and si > ti:\\n                    return False\\n                ti += 1\\n            si += 1\\n\\n        return all(T[i] == \"_\" for i in range(ti, n))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2262178,
                "title": "c-two-pointers-faster-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canChange(string s, string t) {\\n        int n = s.size();\\n        int i = -1, j = -1;\\n        while(i < n && j < n){\\n            while(++i < n && s[i] == \\'_\\');\\n            while(++j < n && t[j] == \\'_\\');\\n            int quit = (i == n) + (j == n);\\n            if(quit) return quit == 2;\\n            if(s[i] != t[j] or (s[i] == \\'L\\' ? i < j : i > j))\\n                return false;\\n        }\\n        return i==n && j==n;\\n    }\\n};\\n```\\n[Similar Problem](https://leetcode.com/problems/swap-adjacent-in-lr-string/)",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canChange(string s, string t) {\\n        int n = s.size();\\n        int i = -1, j = -1;\\n        while(i < n && j < n){\\n            while(++i < n && s[i] == \\'_\\');\\n            while(++j < n && t[j] == \\'_\\');\\n            int quit = (i == n) + (j == n);\\n            if(quit) return quit == 2;\\n            if(s[i] != t[j] or (s[i] == \\'L\\' ? i < j : i > j))\\n                return false;\\n        }\\n        return i==n && j==n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2262126,
                "title": "c-solution-faster-than-100-and-100-less-memory-usage",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canChange(string s, string t) {\\n        string q=\"\", w=\"\"; vector<int> z, x;\\n        for(int i=0; i<s.length(); i++){\\n            if(s[i]!=\\'_\\') { q+=s[i]; z.push_back(i);}\\n            if(t[i]!=\\'_\\') { w+=t[i]; x.push_back(i);}\\n        }\\n        if(q!=w) return false;\\n        for(int i=0; i<q.length(); i++){\\n            if(q[i]==\\'R\\' && z[i]>x[i]) return false;\\n            if(q[i]==\\'L\\' && z[i]<x[i]) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canChange(string s, string t) {\\n        string q=\"\", w=\"\"; vector<int> z, x;\\n        for(int i=0; i<s.length(); i++){\\n            if(s[i]!=\\'_\\') { q+=s[i]; z.push_back(i);}\\n            if(t[i]!=\\'_\\') { w+=t[i]; x.push_back(i);}\\n        }\\n        if(q!=w) return false;\\n        for(int i=0; i<q.length(); i++){\\n            if(q[i]==\\'R\\' && z[i]>x[i]) return false;\\n            if(q[i]==\\'L\\' && z[i]<x[i]) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2262098,
                "title": "100-solution-greedy-o-n-algorithm-c",
                "content": "We use \\'s\\' to denote a space insted of \"_\", due to typesetting reasons. We are trying to provide more examples to make things clear. For short, we use \"sRssL\"-> \"ssRLs\" to define an example where the start is \"sRssL\" and traget is \"ssRLs\".  \\n\\nFollowing the rules, we have these **facts**:\\n1. \"R\" never goes beyond \"L\";\\n2. \"L\" never goes beyond \"R\";\\n3. unmatched \"R\" of target can be found on the left side of a space; e.g. (\\'Rss\\' -> \\'ssR\\')\\n4. unmatched \"L\" of target can be found on the right side of a space; e.g. (\\'ssL\\' -> \\'Lss\\');  \\n\\nMeanwhile, we identify the following **conflicitons**:\\n1. Unused \"R\" in start leads to a failure; e.g. \"sssR\"->\"ssRs\"\\n2. Unmatch \"L\" in target leads to a failure; e.g. \"ssLs\"->\"sssL\"\\n3. when \"L\" is scaned in start, unmatched \"R\" in backlog leads to a failure ; e.g. \"sLss\"->\"sLsR\"\\n\\nWe scan **backwards** from right to left. During the scaning, we postpone to announce a failure,  based on these factes, until a **confliction** is detected.\\n\\n```\\nRuntime: 33 ms, faster than 100.00% of C++ online submissions for Move Pieces to Obtain a String.\\nMemory Usage: 19 MB, less than 100.00% of C++ online submissions for Move Pieces to Obtain a String.\\n```\\n\\n```\\nclass Solution {\\npublic:\\n    bool canChange(string start, string target) {\\n        ios::sync_with_stdio(false);\\n        cin.tie(nullptr);\\n        int n=start.size(), l=0, s=0, r=0;\\n        const char * a =start.c_str();\\n        const char * b =target.c_str();\\n        for(int i=n-1; i>=0; --i) {\\n            l-=b[i]==\\'L\\';\\n            r-=b[i]==\\'R\\';\\n            s-=b[i]==\\'_\\';\\n            \\n            l+=a[i]==\\'L\\';\\n            r+=a[i]==\\'R\\';\\n            s+=a[i]==\\'_\\';\\n            \\n            if(r>0 || l<0 || a[i]==\\'L\\' && r<0)\\n                return false;\\n        }\\n        return !l && !r && !s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```\\nRuntime: 33 ms, faster than 100.00% of C++ online submissions for Move Pieces to Obtain a String.\\nMemory Usage: 19 MB, less than 100.00% of C++ online submissions for Move Pieces to Obtain a String.\\n```\n```\\nclass Solution {\\npublic:\\n    bool canChange(string start, string target) {\\n        ios::sync_with_stdio(false);\\n        cin.tie(nullptr);\\n        int n=start.size(), l=0, s=0, r=0;\\n        const char * a =start.c_str();\\n        const char * b =target.c_str();\\n        for(int i=n-1; i>=0; --i) {\\n            l-=b[i]==\\'L\\';\\n            r-=b[i]==\\'R\\';\\n            s-=b[i]==\\'_\\';\\n            \\n            l+=a[i]==\\'L\\';\\n            r+=a[i]==\\'R\\';\\n            s+=a[i]==\\'_\\';\\n            \\n            if(r>0 || l<0 || a[i]==\\'L\\' && r<0)\\n                return false;\\n        }\\n        return !l && !r && !s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2261939,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<pair<char,int>>find(string s)\\n    {\\n        vector<pair<char,int>>v;\\n        int n=s.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]!=\\'_\\')\\n            {\\n                v.push_back({s[i],i});\\n            }\\n        }\\n        return v;\\n    }\\n    bool canChange(string start, string target)\\n    {\\n        vector<pair<char,int>>nums1=find(start);\\n        vector<pair<char,int>>nums2=find(target);\\n        if(nums1.size()!=nums2.size())\\n        {\\n            return false;\\n        }\\n        int n=nums1.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums1[i].first!=nums2[i].first)\\n            {\\n                return false;\\n            }\\n            if(nums1[i].first==\\'L\\')\\n            {\\n                if(nums1[i].second<nums2[i].second)\\n                {\\n                    return false;\\n                }\\n            }\\n            else \\n            {\\n                if(nums1[i].second>nums2[i].second)\\n                {\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<pair<char,int>>find(string s)\\n    {\\n        vector<pair<char,int>>v;\\n        int n=s.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]!=\\'_\\')\\n            {\\n                v.push_back({s[i],i});\\n            }\\n        }\\n        return v;\\n    }\\n    bool canChange(string start, string target)\\n    {\\n        vector<pair<char,int>>nums1=find(start);\\n        vector<pair<char,int>>nums2=find(target);\\n        if(nums1.size()!=nums2.size())\\n        {\\n            return false;\\n        }\\n        int n=nums1.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums1[i].first!=nums2[i].first)\\n            {\\n                return false;\\n            }\\n            if(nums1[i].first==\\'L\\')\\n            {\\n                if(nums1[i].second<nums2[i].second)\\n                {\\n                    return false;\\n                }\\n            }\\n            else \\n            {\\n                if(nums1[i].second>nums2[i].second)\\n                {\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2261816,
                "title": "easy-c-code-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canChange(string s, string t) {\\n        vector<pair<char,int>> v1;\\n        int n=s.size();\\n        for(int i=0;i<n;i++){\\n            if(s[i]!=\\'_\\') v1.push_back({s[i],i});\\n        }\\n        vector<pair<char,int>> v2;\\n        for(int i=0;i<n;i++){\\n            if(t[i]!=\\'_\\') v2.push_back({t[i],i});\\n        }\\n        if(v1.size()!=v2.size()) return false;\\n        for(int i=0;i<v1.size();i++){\\n            if(v1[i].first!=v2[i].first) return false;\\n            if(v1[i].first==\\'L\\'){\\n                if(v1[i].second<v2[i].second) return false;\\n            }\\n            if(v1[i].first==\\'R\\'){\\n                if(v1[i].second>v2[i].second) return false;\\n            }\\n        }return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canChange(string s, string t) {\\n        vector<pair<char,int>> v1;\\n        int n=s.size();\\n        for(int i=0;i<n;i++){\\n            if(s[i]!=\\'_\\') v1.push_back({s[i],i});\\n        }\\n        vector<pair<char,int>> v2;\\n        for(int i=0;i<n;i++){\\n            if(t[i]!=\\'_\\') v2.push_back({t[i],i});\\n        }\\n        if(v1.size()!=v2.size()) return false;\\n        for(int i=0;i<v1.size();i++){\\n            if(v1[i].first!=v2[i].first) return false;\\n            if(v1[i].first==\\'L\\'){\\n                if(v1[i].second<v2[i].second) return false;\\n            }\\n            if(v1[i].first==\\'R\\'){\\n                if(v1[i].second>v2[i].second) return false;\\n            }\\n        }return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2261757,
                "title": "constant-space-o-n-cpp",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canChange(string s, string t) {\\n        int n=s.size();\\n        int ls=0,lt=0,rs=0,rt=0;\\n        int l1=0,l2=0,r1=0,r2=0;\\n        for(int i=0;i<n;i++)\\n        {\\n             if(s[i]==\\'L\\')l1++;\\n            else if(s[i]==\\'R\\')r1++;\\n            if(t[i]==\\'L\\')l2++;\\n            else if(t[i]==\\'R\\')r2++;\\n        }\\n        if(l1!=l2||r1!=r2)return false;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'L\\')ls++;\\n            if(t[i]==\\'L\\')lt++;\\n            if(ls>lt)return false;\\n            \\n            if(s[i]==\\'R\\')ls=0;\\n            if(t[i]==\\'R\\')lt=0;\\n        }\\n         for(int i=n-1;i>=0;i--)\\n        {\\n            if(s[i]==\\'R\\')rs++;\\n            if(t[i]==\\'R\\')rt++;\\n            if(rs>rt)return false;\\n             \\n            if(s[i]==\\'L\\')rs=0;\\n            if(t[i]==\\'L\\')rt=0;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canChange(string s, string t) {\\n        int n=s.size();\\n        int ls=0,lt=0,rs=0,rt=0;\\n        int l1=0,l2=0,r1=0,r2=0;\\n        for(int i=0;i<n;i++)\\n        {\\n             if(s[i]==\\'L\\')l1++;\\n            else if(s[i]==\\'R\\')r1++;\\n            if(t[i]==\\'L\\')l2++;\\n            else if(t[i]==\\'R\\')r2++;\\n        }\\n        if(l1!=l2||r1!=r2)return false;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'L\\')ls++;\\n            if(t[i]==\\'L\\')lt++;\\n            if(ls>lt)return false;\\n            \\n            if(s[i]==\\'R\\')ls=0;\\n            if(t[i]==\\'R\\')lt=0;\\n        }\\n         for(int i=n-1;i>=0;i--)\\n        {\\n            if(s[i]==\\'R\\')rs++;\\n            if(t[i]==\\'R\\')rt++;\\n            if(rs>rt)return false;\\n             \\n            if(s[i]==\\'L\\')rs=0;\\n            if(t[i]==\\'L\\')rt=0;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2261731,
                "title": "easy-full-editorial-of-the-question-with-code-c",
                "content": "So this question is just a modified question of the [codeforces](https://codeforces.com/problemset/problem/1697/C) problem.\\n\\nApproach\\ns -> string , t -> target\\nFirst, check that the counts of all letters are the same in both strings.\\nThen consider the following restatement of the moves. The letters \\'_\\' in the string s\\nare stationary. Letters \\'L\\' and \\'R\\', however, move around the string. The move of the first type moves a letter \\'R\\' to the right. The move of the second type moves a letter \\'L\\' to the left.\\n\\nNotice that letters \\'R\\' and \\'L\\' can never swap with each other. Thus, if you remove all letters \\'_\\' from both strings, the remaining strings should be the same.\\n\\nAgain, since letters \\'R\\' and \\'R\\' can never swap with each other, you can deduce where each of these letters should end up after the swaps. The first letter \\'{R}\\' in s\\nshould be on the position of the first letter \\'R\\' in t\\nand so on.\\n\\nAfter that, we recall that \\'R\\'s can only move to the right and \\'L\\'s can only move to the left. Thus, we check that the i-th occurrence of \\'R\\' in s is to the left or equal to the i-th occurrences of \\'R\\' in t and vice versa for \\'L\\'s.\\n\\nFinally, we can see that this is a sufficient condition. Easy to show by construction: you can just fix the positions one after another left to right.\\n\\nOverall complexity: O(n)\\n\\nCode -> This code is not exactly based on the approach explained above. This is my construction for the approach.\\n\\n```\\nclass Solution {\\npublic:\\n    bool canChange(string s, string t) {\\n        long long a=0,c=0;\\n        int n = s.length();\\n\\t\\tbool ok = true;\\n\\t\\tfor(int i=0;i<n;i++){\\n\\t\\tif(s[i]==t[i]){\\n\\t\\t\\tif(s[i]==\\'L\\' && a>0){ // R ka count zyada hai so cannot go after L \\n\\t\\t\\t\\tok = false;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\tif(s[i] == \\'R\\' && c>0){ // L can not move right to R\\n\\t\\t\\t\\tok = false;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif(s[i]==\\'R\\')a++; // R can only move to right, similiarly for L\\n\\t\\tif(s[i]==\\'L\\')c--;\\n\\t\\tif(t[i]==\\'R\\')a--; // c can only move to left t me jitn peeche aaye aage wale se counter ho jayenge \\n\\t\\tif(t[i]==\\'L\\')c++;\\n\\t\\tif(a<0 || c<0 || (a>0 && c>0)){ // c peeche tb hi jayega jb raste me a nhi hoga \\n\\t\\t\\tok = false;\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t}\\n\\tif(a==0 && c==0 && ok) return true;\\n\\treturn false;\\n\\t}\\n};\\n```\\nBad commenting ;) just for me to understand LOL. Hope this helps :)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canChange(string s, string t) {\\n        long long a=0,c=0;\\n        int n = s.length();\\n\\t\\tbool ok = true;\\n\\t\\tfor(int i=0;i<n;i++){\\n\\t\\tif(s[i]==t[i]){\\n\\t\\t\\tif(s[i]==\\'L\\' && a>0){ // R ka count zyada hai so cannot go after L \\n\\t\\t\\t\\tok = false;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\tif(s[i] == \\'R\\' && c>0){ // L can not move right to R\\n\\t\\t\\t\\tok = false;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif(s[i]==\\'R\\')a++; // R can only move to right, similiarly for L\\n\\t\\tif(s[i]==\\'L\\')c--;\\n\\t\\tif(t[i]==\\'R\\')a--; // c can only move to left t me jitn peeche aaye aage wale se counter ho jayenge \\n\\t\\tif(t[i]==\\'L\\')c++;\\n\\t\\tif(a<0 || c<0 || (a>0 && c>0)){ // c peeche tb hi jayega jb raste me a nhi hoga \\n\\t\\t\\tok = false;\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t}\\n\\tif(a==0 && c==0 && ok) return true;\\n\\treturn false;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2261728,
                "title": "push-char-and-index-in-queue-of-pairs-then-scan-it",
                "content": "feeling dumb , didnt get this idea in the contest. The idea is to push char and index in queue of pairs then scan it.\\n\\n```\\nclass Solution {\\npublic:\\n    bool canChange(string s, string t) {\\n        \\n        \\n        int n = s.length();\\n        queue<pair<char,int>> sq,tq;\\n        \\n        for(int i =0;i<n;i++)\\n        {\\n            if(s[i]!=\\'_\\')\\n            {\\n                sq.push({s[i],i});\\n            }\\n            \\n            if(t[i]!=\\'_\\')\\n            {\\n                tq.push({t[i],i});\\n            }\\n        }\\n        \\n        \\n        \\n        if(tq.size()!=sq.size())\\n            return false;\\n        \\n        \\n        while(!tq.empty() && !sq.empty())\\n        {\\n            auto tt = tq.front();\\n            auto ss = sq.front();\\n            \\n            tq.pop();\\n            sq.pop();\\n            \\n            if(tt.first!=ss.first)\\n            {\\n              return false;\\n            }\\n            if(tt.first==\\'L\\' && tt.second>ss.second)\\n            {\\n                return false;\\n            }\\n            \\n             if(tt.first==\\'R\\' && tt.second<ss.second)\\n            {\\n                return false;\\n            }\\n            \\n        }\\n        \\n        return true;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canChange(string s, string t) {\\n        \\n        \\n        int n = s.length();\\n        queue<pair<char,int>> sq,tq;\\n        \\n        for(int i =0;i<n;i++)\\n        {\\n            if(s[i]!=\\'_\\')\\n            {\\n                sq.push({s[i],i});\\n            }\\n            \\n            if(t[i]!=\\'_\\')\\n            {\\n                tq.push({t[i],i});\\n            }\\n        }\\n        \\n        \\n        \\n        if(tq.size()!=sq.size())\\n            return false;\\n        \\n        \\n        while(!tq.empty() && !sq.empty())\\n        {\\n            auto tt = tq.front();\\n            auto ss = sq.front();\\n            \\n            tq.pop();\\n            sq.pop();\\n            \\n            if(tt.first!=ss.first)\\n            {\\n              return false;\\n            }\\n            if(tt.first==\\'L\\' && tt.second>ss.second)\\n            {\\n                return false;\\n            }\\n            \\n             if(tt.first==\\'R\\' && tt.second<ss.second)\\n            {\\n                return false;\\n            }\\n            \\n        }\\n        \\n        return true;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2261688,
                "title": "ruby-t-o-n-s-o-1-faster-than-100-still-exceeding-time-limit-in-the-contest",
                "content": "The idea is having a pool for remaining \\'L\\', and remaining \\'R\\' in the array.\\n\\nThe pieces cannot be moved if:\\n- Encounter any extra \\'L\\' in start before we do in target\\n- Encounter any extra \\'R\\' in target before we do in start\\n- A start\\'s \\'L\\' waiting for a match, but we encounter a \\'R\\' in target\\n- A target\\'s \\'R\\' waiting for a match, but we encounter a \\'L\\' in start\\n\\nNOTE: To Leetcode mods, could we either increase Ruby compiler performance on LeetCode, or increase time for Ruby solutions? Else Ruby devs need to write a much better solutions comparing to other languages in order to be accepted\\n\\n```\\n# @param {String} start\\n# @param {String} target\\n# @return {Boolean}\\ndef can_change(start, target)\\n  l_remaining = r_remaining = i = 0\\n  n = start.length\\n  \\n  while i < n\\n    if (ti = target[i]) == \\'L\\'\\n      return false if r_remaining > 0\\n      l_remaining += 1\\n    end\\n\\n    case start[i]\\n    when \\'L\\'\\n      return false if l_remaining < 1\\n      l_remaining -= 1\\n    when \\'R\\'\\n      return false if l_remaining > 0\\n      r_remaining += 1\\n    end\\n\\n    if ti == \\'R\\'\\n      return false if r_remaining < 1\\n      r_remaining -= 1\\n    end\\n\\n    i += 1\\n  end\\n\\n  l_remaining == 0 && r_remaining == 0\\nend\\n```\\n\\nEDITED: Translated this code to Java, it actually runs in 13ms, faster than 100% and less memory than 100%\\n\\n```\\nclass Solution {\\n  public boolean canChange(String start, String target) {\\n    int lRemaining = 0, rRemaining = 0;\\n    int n = start.length();\\n    for (int i = 0; i < n; i++) {\\n      char ti = target.charAt(i);\\n      char si = start.charAt(i);\\n\\n      if (ti == \\'L\\') {\\n        if (rRemaining > 0) {\\n          return false;\\n        }\\n        lRemaining++;\\n      }\\n\\n      if (si == \\'L\\') {\\n        if (lRemaining < 1) {\\n          return false;\\n        }\\n        lRemaining--;\\n      }\\n\\n      if (si == \\'R\\') {\\n        if (lRemaining > 0) {\\n          return false;\\n        }\\n        rRemaining++;\\n      }\\n      \\n      if (ti == \\'R\\') {\\n        if (rRemaining < 1) {\\n          return false;\\n        }\\n        rRemaining--;\\n      }\\n    }\\n    return lRemaining == 0 && rRemaining == 0;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Ruby"
                ],
                "code": "```\\n# @param {String} start\\n# @param {String} target\\n# @return {Boolean}\\ndef can_change(start, target)\\n  l_remaining = r_remaining = i = 0\\n  n = start.length\\n  \\n  while i < n\\n    if (ti = target[i]) == \\'L\\'\\n      return false if r_remaining > 0\\n      l_remaining += 1\\n    end\\n\\n    case start[i]\\n    when \\'L\\'\\n      return false if l_remaining < 1\\n      l_remaining -= 1\\n    when \\'R\\'\\n      return false if l_remaining > 0\\n      r_remaining += 1\\n    end\\n\\n    if ti == \\'R\\'\\n      return false if r_remaining < 1\\n      r_remaining -= 1\\n    end\\n\\n    i += 1\\n  end\\n\\n  l_remaining == 0 && r_remaining == 0\\nend\\n```\n```\\nclass Solution {\\n  public boolean canChange(String start, String target) {\\n    int lRemaining = 0, rRemaining = 0;\\n    int n = start.length();\\n    for (int i = 0; i < n; i++) {\\n      char ti = target.charAt(i);\\n      char si = start.charAt(i);\\n\\n      if (ti == \\'L\\') {\\n        if (rRemaining > 0) {\\n          return false;\\n        }\\n        lRemaining++;\\n      }\\n\\n      if (si == \\'L\\') {\\n        if (lRemaining < 1) {\\n          return false;\\n        }\\n        lRemaining--;\\n      }\\n\\n      if (si == \\'R\\') {\\n        if (lRemaining > 0) {\\n          return false;\\n        }\\n        rRemaining++;\\n      }\\n      \\n      if (ti == \\'R\\') {\\n        if (rRemaining < 1) {\\n          return false;\\n        }\\n        rRemaining--;\\n      }\\n    }\\n    return lRemaining == 0 && rRemaining == 0;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2261686,
                "title": "easy-c-o-n-100-faster-84ms",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canChange(string start, string target) {\\n        vector<pair<char, int>> v;\\n        \\n        for(int i=0; i<start.size(); i++){\\n            if(start[i] != \\'_\\'){\\n                v.push_back({start[i], i});\\n            }\\n        }\\n        \\n        int i=0;\\n        for(int j=0; j<target.size(); j++){\\n            if(target[j] != \\'_\\'){\\n                if(i>=v.size() || v[i].first != target[j]){\\n                    return false;\\n                }\\n                \\n                if(v[i].first == \\'L\\' && v[i].second < j){\\n                    return false;\\n                }\\n                \\n                if(v[i].first == \\'R\\' && v[i].second > j){\\n                    return false;\\n                }\\n                \\n                i++;\\n            }\\n        }\\n        \\n        return i == v.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canChange(string start, string target) {\\n        vector<pair<char, int>> v;\\n        \\n        for(int i=0; i<start.size(); i++){\\n            if(start[i] != \\'_\\'){\\n                v.push_back({start[i], i});\\n            }\\n        }\\n        \\n        int i=0;\\n        for(int j=0; j<target.size(); j++){\\n            if(target[j] != \\'_\\'){\\n                if(i>=v.size() || v[i].first != target[j]){\\n                    return false;\\n                }\\n                \\n                if(v[i].first == \\'L\\' && v[i].second < j){\\n                    return false;\\n                }\\n                \\n                if(v[i].first == \\'R\\' && v[i].second > j){\\n                    return false;\\n                }\\n                \\n                i++;\\n            }\\n        }\\n        \\n        return i == v.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2261674,
                "title": "100-faster-c",
                "content": "\\tclass Solution {\\n\\tpublic:\\n    bool canChange(string s, string t) \\n    {\\n        int i=0;\\n        vector<char>mp;\\n        \\n        if(s==t)\\n            return 1;\\n        \\n        for(auto it:s)\\n        {\\n            if(it!=\\'_\\')\\n                mp.emplace_back(it);\\n        }\\n        int x=mp.size();\\n            \\n        for(auto it:t)\\n        {\\n            if(it!=\\'_\\')\\n            {\\n                if(!x || mp[i]!=it)\\n                    return 0;\\n                ++i;\\n            }\\n        }\\n        if(x-1==i)\\n            return 0;\\n        \\n        i=0;x=0;\\n        int n=t.size();\\n        \\n        while(i<n && x<n)\\n        {\\n            while(i<n && s[i]==\\'_\\')\\n                ++i;\\n            while(x<n && t[x]==\\'_\\')\\n                ++x;\\n            \\n            if(s[i]==\\'L\\' && i>=x)\\n                ++i,++x;\\n                \\n            else if(s[i]==\\'R\\' && i<=x)\\n                ++i,++x;\\n            else\\n            {\\n                if(i<n||x<n)\\n                    return 0;\\n            }\\n        }\\n        \\n        return 1;    \\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n    bool canChange(string s, string t) \\n    {\\n        int i=0;\\n        vector<char>mp;\\n        \\n        if(s==t)\\n            return 1;\\n        \\n        for(auto it:s)\\n        {\\n            if(it!=\\'_\\')\\n                mp.emplace_back(it);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2261640,
                "title": "o-n-java-solution-one-pass",
                "content": "lefts keeps track of the # of lefts to find\\nrights keeps track of the # of current rights \\n(if we were iterating backward the meanings of these would flip)\\n\\nif a right is encountered(start) while looking for a left it is false\\nif a left is expected(target) while having a right it is also false\\nif the values drop lower than 0 in the loop then there was a problem\\n\\nif the values are not equal to 0 at the end then some right or left was unfulfilled\\n\\nthere is probably a better way to condense the middle sections\\n\\'\\'\\'\\n  \\n        int lefts = 0;\\n        int rights = 0;\\n        \\n        for(int idx = 0; idx < start.length(); idx++)\\n        {\\n            if(target.charAt(idx) == \\'L\\')\\n            {\\n                if(rights != 0)\\n                    return false;\\n                lefts++;\\n            }\\n            else if(target.charAt(idx) == \\'R\\')\\n            {\\n                rights--;\\n            }\\n            \\n            if(start.charAt(idx) == \\'R\\')\\n            {\\n                if(lefts != 0)\\n                    return false;\\n                rights++;\\n            }\\n            else if(start.charAt(idx) == \\'L\\')\\n            {\\n                lefts--;\\n            }\\n            \\n            if(rights < 0 || lefts < 0)\\n                return false;\\n        }\\n        \\n        return lefts != 0 || rights!= 0? false: true;\\n\\n\\'\\'\\'",
                "solutionTags": [
                    "Java"
                ],
                "code": "lefts keeps track of the # of lefts to find\\nrights keeps track of the # of current rights \\n(if we were iterating backward the meanings of these would flip)\\n\\nif a right is encountered(start) while looking for a left it is false\\nif a left is expected(target) while having a right it is also false\\nif the values drop lower than 0 in the loop then there was a problem\\n\\nif the values are not equal to 0 at the end then some right or left was unfulfilled\\n\\nthere is probably a better way to condense the middle sections\\n\\'\\'\\'\\n  \\n        int lefts = 0;\\n        int rights = 0;\\n        \\n        for(int idx = 0; idx < start.length(); idx++)\\n        {\\n            if(target.charAt(idx) == \\'L\\')\\n            {\\n                if(rights != 0)\\n                    return false;\\n                lefts++;\\n            }\\n            else if(target.charAt(idx) == \\'R\\')\\n            {\\n                rights--;\\n            }\\n            \\n            if(start.charAt(idx) == \\'R\\')\\n            {\\n                if(lefts != 0)\\n                    return false;\\n                rights++;\\n            }\\n            else if(start.charAt(idx) == \\'L\\')\\n            {\\n                lefts--;\\n            }\\n            \\n            if(rights < 0 || lefts < 0)\\n                return false;\\n        }\\n        \\n        return lefts != 0 || rights!= 0? false: true;\\n\\n\\'\\'\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 2261594,
                "title": "just-3-simple-cases-o-n",
                "content": "You don\\'t need a DS or complex nested loops for this.\\n\\nSince the combinations are limited, we will have 3 simple cases where it will fail to match.\\n\\nWhen we get an L, **increment** if it\\'s in **start** and **decrement** if it\\'s in **target**.\\nLikewise do the same for R.\\n\\nAt every step check these **3 cases** and **`return false`** if any of them satisfy.\\n\\n**Cases :**\\n```\\nL > 0 || R < 0\\nstart[i] == \\'L\\' && R > 0\\nstart[i] == \\'R\\' && L < 0\\n```\\n**`Note : The following code can be easily converted into c++ as well as there are no Data structures used.`**\\n\\n**Solution :** \\n```\\n    public boolean canChange(String start, String target) {\\n        int n = start.length();\\n        int L = 0, R = 0;\\n        \\n        for(int i=0;i<n;i++){\\n            if(L > 0 || R < 0)\\n                return false;\\n            \\n            char a = start.charAt(i);\\n            char b = target.charAt(i);\\n            \\n            if(a == \\'L\\'){\\n                if(R > 0)\\n                    return false;\\n                L++;\\n            }\\n            if(a == \\'R\\'){\\n                if(L < 0)\\n                    return false;    \\n                R++;\\n            }\\n                \\n            if(b == \\'L\\')\\n                L--;\\n            if(b == \\'R\\')\\n                R--;\\n        }\\n        \\n        return L == 0 && R == 0;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```\\nL > 0 || R < 0\\nstart[i] == \\'L\\' && R > 0\\nstart[i] == \\'R\\' && L < 0\\n```\n```\\n    public boolean canChange(String start, String target) {\\n        int n = start.length();\\n        int L = 0, R = 0;\\n        \\n        for(int i=0;i<n;i++){\\n            if(L > 0 || R < 0)\\n                return false;\\n            \\n            char a = start.charAt(i);\\n            char b = target.charAt(i);\\n            \\n            if(a == \\'L\\'){\\n                if(R > 0)\\n                    return false;\\n                L++;\\n            }\\n            if(a == \\'R\\'){\\n                if(L < 0)\\n                    return false;    \\n                R++;\\n            }\\n                \\n            if(b == \\'L\\')\\n                L--;\\n            if(b == \\'R\\')\\n                R--;\\n        }\\n        \\n        return L == 0 && R == 0;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2261580,
                "title": "satisfy-3-conditions",
                "content": "The first R in start should be before or at same position in target because we cannot move R to left side.\\nSimilarly the last L in start should be after or at same position in target because we cannot move L to right side.\\nAnd the string without spaces ( \\'_\\' ) should be equal--\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    bool canChange(string start, string target) {\\n        string temp=\"\",ltemp=\"\";\\n        int i=0,l=start.length(),a=-1,b=-1,c=-1,d=-1;\\n        for(i=0;i<l;i++)\\n        {\\n            if(start[i]!=\\'_\\')\\n                ltemp+=start[i];\\n            if(start[i]==\\'L\\')\\n                b=i;\\n            if(start[i]==\\'R\\' && d==-1)\\n                d=i;\\n        }\\n        for(i=0;i<l;i++)\\n        {\\n            if(target[i]!=\\'_\\')\\n                temp+=target[i];\\n            if(target[i]==\\'L\\')\\n                a=i;\\n            if(target[i]==\\'R\\' && c==-1)\\n                c=i;\\n        }\\n        \\n        if(a>b || c<d)\\n            return false;\\n     \\n        if(temp==ltemp)\\n            return true;\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canChange(string start, string target) {\\n        string temp=\"\",ltemp=\"\";\\n        int i=0,l=start.length(),a=-1,b=-1,c=-1,d=-1;\\n        for(i=0;i<l;i++)\\n        {\\n            if(start[i]!=\\'_\\')\\n                ltemp+=start[i];\\n            if(start[i]==\\'L\\')\\n                b=i;\\n            if(start[i]==\\'R\\' && d==-1)\\n                d=i;\\n        }\\n        for(i=0;i<l;i++)\\n        {\\n            if(target[i]!=\\'_\\')\\n                temp+=target[i];\\n            if(target[i]==\\'L\\')\\n                a=i;\\n            if(target[i]==\\'R\\' && c==-1)\\n                c=i;\\n        }\\n        \\n        if(a>b || c<d)\\n            return false;\\n     \\n        if(temp==ltemp)\\n            return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2261555,
                "title": "c-stack-solution",
                "content": "```\\nclass Solution {\\npublic:\\n  \\n    bool canChange(string start, string target) {\\n\\n        stack<char> st;\\n        int n = start.length();\\n        \\n        // checking for \\'L\\'\\n        for(int i = 0;i<n;i+=1)\\n        {   \\n            if(target[i]!=\\'_\\')\\n                st.push(target[i]);\\n            \\n            if(start[i]==\\'L\\'){\\n                    \\n                \\n                if(st.empty() or st.top()==\\'R\\') \\n                    return false;\\n                    \\n                // matching \\'L\\' of start with last \\'L\\' of target \\n                else \\n                {\\n                    st.pop();\\n                }\\n                \\n            }\\n                \\n            \\n            else if(start[i]==\\'R\\')\\n            {\\n                while(!st.empty())\\n                    st.pop();\\n            }\\n            \\n        }\\n        \\n        \\n        while(!st.empty()){\\n            if(st.top()==\\'L\\') // if any unmatched \\'L\\' is left\\n                return false;\\n            st.pop();\\n        }\\n        \\n        // checking for \\'R\\'\\n        for(int i = n-1;i>=0;i-=1)\\n        {   \\n            if(target[i]!=\\'_\\')\\n                st.push(target[i]);\\n            \\n            if(start[i]==\\'R\\'){\\n                \\n                if(st.empty() or st.top()==\\'L\\')\\n                    return false;\\n                    \\n                // matching \\'R\\' of start with last \\'R\\' of target\\n                else\\n                {\\n                    st.pop();\\n                }\\n                \\n            }\\n                \\n            \\n            else if(start[i]==\\'L\\')\\n            {\\n                while(!st.empty())\\n                    st.pop();\\n            } \\n        }\\n        \\n        while(!st.empty()){\\n            if(st.top()==\\'R\\') // if any unmatched \\'R\\' is left\\n                return false;\\n            st.pop();\\n        }\\n        \\n        \\n        return true;\\n        \\n        \\n    }\\n};",
                "solutionTags": [
                    "Stack"
                ],
                "code": "class Solution {\\npublic:\\n  \\n    bool canChange(string start, string target) {\\n\\n        stack<char> st;\\n        int n = start.length();\\n        \\n        // checking for \\'L\\'\\n        for(int i = 0;i<n;i+=1)\\n        {   \\n            if(target[i]!=\\'_\\')\\n                st.push(target[i]);\\n            \\n            if(start[i]==\\'L\\'){\\n                    \\n                \\n                if(st.empty() or st.top()==\\'R\\') \\n                    return false;\\n                    \\n                // matching \\'L\\' of start with last \\'L\\' of target \\n                else \\n                {\\n                    st.pop();\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2261533,
                "title": "clean-python-solution",
                "content": "```\\nclass Solution:\\n    def canChange(self, start: str, target: str) -> bool:\\n        \\n        s = start.replace(\"_\", \"\")\\n        t = target.replace(\"_\", \"\")\\n        if s!=t:\\n            return False\\n\\n        SL = []\\n        SR = []\\n        \\n        for i, ch in enumerate(start):\\n            if ch == \"L\":\\n                SL.append(i)\\n            elif ch == \"R\":\\n                SR.append(i)\\n                \\n        TL = []\\n        TR = []\\n        \\n        for i, ch in enumerate(target):\\n            if ch == \"L\":\\n                TL.append(i)\\n            elif ch == \"R\":\\n                TR.append(i)\\n                \\n        # SL , TL\\n        for i in range(len(SL)):\\n            if SL[i] < TL[i]:\\n                return False\\n        \\n        for i in range(len(SR)):\\n            if SR[i] > TR[i]:\\n                return False\\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def canChange(self, start: str, target: str) -> bool:\\n        \\n        s = start.replace(\"_\", \"\")\\n        t = target.replace(\"_\", \"\")\\n        if s!=t:\\n            return False\\n\\n        SL = []\\n        SR = []\\n        \\n        for i, ch in enumerate(start):\\n            if ch == \"L\":\\n                SL.append(i)\\n            elif ch == \"R\":\\n                SR.append(i)\\n                \\n        TL = []\\n        TR = []\\n        \\n        for i, ch in enumerate(target):\\n            if ch == \"L\":\\n                TL.append(i)\\n            elif ch == \"R\":\\n                TR.append(i)\\n                \\n        # SL , TL\\n        for i in range(len(SL)):\\n            if SL[i] < TL[i]:\\n                return False\\n        \\n        for i in range(len(SR)):\\n            if SR[i] > TR[i]:\\n                return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2261519,
                "title": "java-clean-simple",
                "content": "```\\nclass Solution {\\n    public boolean canChange(String start, String target) {\\n        int index = 0;\\n        for (int i = 0; i < target.length(); i++) {\\n            if (target.charAt(i) == \\'_\\')\\n                continue;\\n\\n            // get the character index from start\\n            while (index < start.length() && start.charAt(index) != target.charAt(i)) {\\n                if (start.charAt(index) != \\'_\\')\\n                    return false;\\n                index++;\\n            }\\n\\n            // check if valid\\n            if (index == start.length()\\n                    || (target.charAt(i) == \\'L\\' && index < i)\\n                    || (target.charAt(i) == \\'R\\' && index > i))\\n                return false;\\n\\n            index++;\\n        }\\n\\n        for (int i = index; i < start.length(); i++)\\n            if (start.charAt(i) != \\'_\\')\\n                return false;\\n\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canChange(String start, String target) {\\n        int index = 0;\\n        for (int i = 0; i < target.length(); i++) {\\n            if (target.charAt(i) == \\'_\\')\\n                continue;\\n\\n            // get the character index from start\\n            while (index < start.length() && start.charAt(index) != target.charAt(i)) {\\n                if (start.charAt(index) != \\'_\\')\\n                    return false;\\n                index++;\\n            }\\n\\n            // check if valid\\n            if (index == start.length()\\n                    || (target.charAt(i) == \\'L\\' && index < i)\\n                    || (target.charAt(i) == \\'R\\' && index > i))\\n                return false;\\n\\n            index++;\\n        }\\n\\n        for (int i = index; i < start.length(); i++)\\n            if (start.charAt(i) != \\'_\\')\\n                return false;\\n\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2261517,
                "title": "easy-java-solution",
                "content": "Explanation:-  \\n-> make 2 seperate arrays for storing the L and R with their index from start and target \\n->then check if the arrays size are same or not if not obviously return false\\n-> Start traversing if starts\\'s L comes before target\\'s L there is no way you can put it to the right as you can go only with left  do the same with R also we are elimating all condition which makes it false\\n->if none of the case exits then return the true :)\\n```\\nclass Solution {\\n    public boolean canChange(String start, String target) {\\n        int l=0,r=0,x=0,y=0;\\n        for(int i=0;i<start.length();i++){\\n            if(start.charAt(i)==\\'L\\') l++;\\n            else if(start.charAt(i)==\\'R\\') r++;\\n            if(target.charAt(i)==\\'L\\') x++;\\n            else if(target.charAt(i)==\\'R\\') y++;\\n            \\n        }                \\n        if(l!=x||r!=y)  return false;\\n        List<Integer> temp1=new ArrayList();\\n        List<Integer> temp2=new ArrayList();\\n        for(int i=0;i<start.length();i++){\\n            if(start.charAt(i)!=\\'_\\'){\\n                temp1.add(i);\\n            }\\n            if(target.charAt(i)!=\\'_\\'){\\n                temp2.add(i);\\n            }\\n        }\\n        for(int i=0;i<temp1.size();i++){\\n            if(start.charAt(temp1.get(i))!=target.charAt(temp2.get(i))) return false;\\n            if(start.charAt(temp1.get(i))==\\'L\\'){\\n                if(temp1.get(i)<temp2.get(i))  return false;\\n            }\\n            else{\\n                    if(temp1.get(i)>temp2.get(i)) return false;\\n                }\\n            }\\n        return true;\\n    }\\n}```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canChange(String start, String target) {\\n        int l=0,r=0,x=0,y=0;\\n        for(int i=0;i<start.length();i++){\\n            if(start.charAt(i)==\\'L\\') l++;\\n            else if(start.charAt(i)==\\'R\\') r++;\\n            if(target.charAt(i)==\\'L\\') x++;\\n            else if(target.charAt(i)==\\'R\\') y++;\\n            \\n        }                \\n        if(l!=x||r!=y)  return false;\\n        List<Integer> temp1=new ArrayList();\\n        List<Integer> temp2=new ArrayList();\\n        for(int i=0;i<start.length();i++){\\n            if(start.charAt(i)!=\\'_\\'){\\n                temp1.add(i);\\n            }\\n            if(target.charAt(i)!=\\'_\\'){\\n                temp2.add(i);\\n            }\\n        }\\n        for(int i=0;i<temp1.size();i++){\\n            if(start.charAt(temp1.get(i))!=target.charAt(temp2.get(i))) return false;\\n            if(start.charAt(temp1.get(i))==\\'L\\'){\\n                if(temp1.get(i)<temp2.get(i))  return false;\\n            }\\n            else{\\n                    if(temp1.get(i)>temp2.get(i)) return false;\\n                }\\n            }\\n        return true;\\n    }\\n}```",
                "codeTag": "Java"
            },
            {
                "id": 2261466,
                "title": "python-o-n-time-o-1-space",
                "content": "```\\nclass Solution:\\n    def canChange(self, start: str, target: str) -> bool:\\n        Lcount = 0\\n        Rcount = 0\\n        \\n        for i in range(len(start)):\\n            if target[i] == \"L\":\\n                Lcount += 1\\n                if Rcount:\\n                    return False\\n            if start[i] == \"L\":\\n                Lcount -= 1\\n                if Lcount < 0:\\n                    return False\\n            \\n            if start[i] == \"R\":\\n                Rcount += 1\\n                if Lcount:\\n                    return False\\n            if target[i] == \"R\":\\n                Rcount -= 1\\n                if Rcount < 0:\\n                    return False\\n        \\n        return (Lcount == 0 and Rcount == 0)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def canChange(self, start: str, target: str) -> bool:\\n        Lcount = 0\\n        Rcount = 0\\n        \\n        for i in range(len(start)):\\n            if target[i] == \"L\":\\n                Lcount += 1\\n                if Rcount:\\n                    return False\\n            if start[i] == \"L\":\\n                Lcount -= 1\\n                if Lcount < 0:\\n                    return False\\n            \\n            if start[i] == \"R\":\\n                Rcount += 1\\n                if Lcount:\\n                    return False\\n            if target[i] == \"R\":\\n                Rcount -= 1\\n                if Rcount < 0:\\n                    return False\\n        \\n        return (Lcount == 0 and Rcount == 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2261409,
                "title": "no-stack-simple-count-solution-o-n-time",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canChange(string start, string target) {\\n\\t      // you can optimise space in this solution!\\n          pair<vector<int>,vector<int>> p1 = solve(start);\\n          pair<vector<int>,vector<int>> p2 = solve(target);\\n          \\n          string s = \"\", f = \"\";\\n          \\n          for(char c : start) { if(c!=\\'_\\') s+=c; }\\n          for(char c : target) { if(c!=\\'_\\') f+=c; }\\n          \\n          if(p1.first.size()!=p2.first.size() || p1.second.size() !=p2.second.size() || s!=f) return false;\\n          \\n          for(int i=0; i<p1.first.size(); i++) {\\n                if(p1.first[i] < p2.first[i]) return false;\\n          }\\n        \\n          for(int i=0; i<p1.second.size(); i++) {\\n                if(p1.second[i] < p2.second[i]) return false;\\n          }\\n        return true;\\n    }\\n    pair<vector<int>,vector<int>> solve(string start) {\\n        int cnt  = 0;\\n        vector<int> L,R;\\n         for(int i=0; i<start.size(); i++) {\\n               if(start[i]==\\'L\\') {\\n                   L.push_back(cnt);\\n               }else if(start[i]==\\'R\\') {\\n                   cnt=0;\\n               }else {\\n                   cnt++;\\n               }\\n         }\\n         cnt=0;\\n         for(int i=start.size()-1; i>=0; i--) {\\n               if(start[i]==\\'R\\') {\\n                   R.push_back(cnt);\\n               }else if(start[i]==\\'L\\') {\\n                   cnt=0;\\n               }else {\\n                   cnt++;\\n               }\\n         }\\n         return {L,R};\\n    } \\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canChange(string start, string target) {\\n\\t      // you can optimise space in this solution!\\n          pair<vector<int>,vector<int>> p1 = solve(start);\\n          pair<vector<int>,vector<int>> p2 = solve(target);\\n          \\n          string s = \"\", f = \"\";\\n          \\n          for(char c : start) { if(c!=\\'_\\') s+=c; }\\n          for(char c : target) { if(c!=\\'_\\') f+=c; }\\n          \\n          if(p1.first.size()!=p2.first.size() || p1.second.size() !=p2.second.size() || s!=f) return false;\\n          \\n          for(int i=0; i<p1.first.size(); i++) {\\n                if(p1.first[i] < p2.first[i]) return false;\\n          }\\n        \\n          for(int i=0; i<p1.second.size(); i++) {\\n                if(p1.second[i] < p2.second[i]) return false;\\n          }\\n        return true;\\n    }\\n    pair<vector<int>,vector<int>> solve(string start) {\\n        int cnt  = 0;\\n        vector<int> L,R;\\n         for(int i=0; i<start.size(); i++) {\\n               if(start[i]==\\'L\\') {\\n                   L.push_back(cnt);\\n               }else if(start[i]==\\'R\\') {\\n                   cnt=0;\\n               }else {\\n                   cnt++;\\n               }\\n         }\\n         cnt=0;\\n         for(int i=start.size()-1; i>=0; i--) {\\n               if(start[i]==\\'R\\') {\\n                   R.push_back(cnt);\\n               }else if(start[i]==\\'L\\') {\\n                   cnt=0;\\n               }else {\\n                   cnt++;\\n               }\\n         }\\n         return {L,R};\\n    } \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2261402,
                "title": "very-easy-java-solution",
                "content": "```\\nclass Solution {\\n    public boolean canChange(String start, String target) {\\n        Stack<int[]> st = new Stack();\\n        // arr[0] - > index\\n\\t\\t// arr[1] - > 1 for \\'R\\' and  0 for \\'L\\'\\n\\t\\t\\n        for(int i = 0; i < target.length(); i++) {\\n            int idx = i+1;          // for easy to understanding (1 base indexing)\\n            if(target.charAt(i) == \\'L\\') {\\n                st.push(new int[]{idx, 0});\\n            } \\n            \\n            if(target.charAt(i) == \\'R\\') {\\n                st.push(new int[]{idx, 1});\\n            } \\n        }\\n        \\n\\t\\t// checking from last cause last temp[] at the top of stack\\n        \\n        for(int i = start.length()-1; i >= 0; i--) {\\n            int idx = i+1;\\n            \\n            if(start.charAt(i) == \\'L\\') {\\n                if(st.size() > 0) {\\n                    int[] peek = st.peek();\\n                    if(peek[1] == 0 && peek[0] <= idx) {     // first check -> peek is \\'L\\' or not    second check-> it appers before or at idx \\n                        st.pop();\\n                    } else {\\n                        return false;\\n                    }\\n                } else {\\n                    return false;    // we need \\'L\\' but stack is empty so return false\\n                }\\n            } \\n            \\n            if(start.charAt(i) == \\'R\\') {\\n                if(st.size() > 0) {\\n                    int[] peek = st.peek();\\n                    if(peek[1] == 1 && peek[0] >= idx) {   // first check -> peek is \\'R\\' or not    second check-> it appers after or at idx \\n                        st.pop();\\n                    } else {\\n                        return false;    \\n                    }\\n                } else {\\n                    return false;     // we need R\\' but stack is empty so return false\\n                }\\n            } \\n        }\\n        return st.size() == 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canChange(String start, String target) {\\n        Stack<int[]> st = new Stack();\\n        // arr[0] - > index\\n\\t\\t// arr[1] - > 1 for \\'R\\' and  0 for \\'L\\'\\n\\t\\t\\n        for(int i = 0; i < target.length(); i++) {\\n            int idx = i+1;          // for easy to understanding (1 base indexing)\\n            if(target.charAt(i) == \\'L\\') {\\n                st.push(new int[]{idx, 0});\\n            } \\n            \\n            if(target.charAt(i) == \\'R\\') {\\n                st.push(new int[]{idx, 1});\\n            } \\n        }\\n        \\n\\t\\t// checking from last cause last temp[] at the top of stack\\n        \\n        for(int i = start.length()-1; i >= 0; i--) {\\n            int idx = i+1;\\n            \\n            if(start.charAt(i) == \\'L\\') {\\n                if(st.size() > 0) {\\n                    int[] peek = st.peek();\\n                    if(peek[1] == 0 && peek[0] <= idx) {     // first check -> peek is \\'L\\' or not    second check-> it appers before or at idx \\n                        st.pop();\\n                    } else {\\n                        return false;\\n                    }\\n                } else {\\n                    return false;    // we need \\'L\\' but stack is empty so return false\\n                }\\n            } \\n            \\n            if(start.charAt(i) == \\'R\\') {\\n                if(st.size() > 0) {\\n                    int[] peek = st.peek();\\n                    if(peek[1] == 1 && peek[0] >= idx) {   // first check -> peek is \\'R\\' or not    second check-> it appers after or at idx \\n                        st.pop();\\n                    } else {\\n                        return false;    \\n                    }\\n                } else {\\n                    return false;     // we need R\\' but stack is empty so return false\\n                }\\n            } \\n        }\\n        return st.size() == 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2261374,
                "title": "easy-c-beginner-friendly-solution-comments-include",
                "content": "```\\nbool canChange(string start, string target) {\\n        string s1=\"\",s2=\"\";\\n        vector<int> l1,l2,r1,r2;//l1->indexes of \\'L\\' in start, l2->indexes of \\'L\\' in target, r1->indexes of \\'R\\' in start, r2->indexes of \\'R\\' in target.\\n        for(int i=0;i<start.size();i++)\\n        {\\n            if(start[i]==\\'L\\')\\n            {\\n                s1+=\\'L\\';\\n                l1.push_back(i);\\n            }\\n            else if(start[i]==\\'R\\')\\n            {\\n                s1+=\\'R\\';\\n                r1.push_back(i);\\n            }\\n            if(target[i]==\\'L\\')\\n            {\\n                s2+=\\'L\\';\\n                l2.push_back(i);\\n            }\\n            else if(target[i]==\\'R\\')\\n            {\\n                s2+=\\'R\\';\\n                r2.push_back(i);\\n            }\\n        }\\n        if(s1!=s2)//if the concatenation of all \\'L\\' and \\'R\\' in start and target are not equal then we cannot match anyhow.\\n            return false;\\n        for(int i=0;i<l1.size();i++)\\n        {\\n            if(l2[i]>l1[i])//if the ith \\'L\\' in target has a index greater than the ith \\'L\\' in start then we cannot match them because \\'L\\' can only move towards left.\\n                return false;\\n        }\\n        for(int i=0;i<r1.size();i++)\\n        {\\n            if(r2[i]<r1[i])//if the ith \\'R\\' in target has a index lesser than the ith \\'R\\' in start then we cannot match them because \\'R\\' can only move towards right.\\n                return false;\\n        }\\n        return true;\\n    }\\n```\\nPlease upvote if you like the solution",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "```\\nbool canChange(string start, string target) {\\n        string s1=\"\",s2=\"\";\\n        vector<int> l1,l2,r1,r2;//l1->indexes of \\'L\\' in start, l2->indexes of \\'L\\' in target, r1->indexes of \\'R\\' in start, r2->indexes of \\'R\\' in target.\\n        for(int i=0;i<start.size();i++)\\n        {\\n            if(start[i]==\\'L\\')\\n            {\\n                s1+=\\'L\\';\\n                l1.push_back(i);\\n            }\\n            else if(start[i]==\\'R\\')\\n            {\\n                s1+=\\'R\\';\\n                r1.push_back(i);\\n            }\\n            if(target[i]==\\'L\\')\\n            {\\n                s2+=\\'L\\';\\n                l2.push_back(i);\\n            }\\n            else if(target[i]==\\'R\\')\\n            {\\n                s2+=\\'R\\';\\n                r2.push_back(i);\\n            }\\n        }\\n        if(s1!=s2)//if the concatenation of all \\'L\\' and \\'R\\' in start and target are not equal then we cannot match anyhow.\\n            return false;\\n        for(int i=0;i<l1.size();i++)\\n        {\\n            if(l2[i]>l1[i])//if the ith \\'L\\' in target has a index greater than the ith \\'L\\' in start then we cannot match them because \\'L\\' can only move towards left.\\n                return false;\\n        }\\n        for(int i=0;i<r1.size();i++)\\n        {\\n            if(r2[i]<r1[i])//if the ith \\'R\\' in target has a index lesser than the ith \\'R\\' in start then we cannot match them because \\'R\\' can only move towards right.\\n                return false;\\n        }\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2261310,
                "title": "c-two-pointer-easy-to-understand",
                "content": "```\\nbool canChange(string start, string target) {\\n        string s1 =\"\", t1 = \"\";\\n        for (auto &c :start) {\\n            if (c!=\\'_\\')\\n                s1+=(c);\\n        }\\n        \\n        for (auto &c :target) {\\n            if (c!=\\'_\\')\\n                t1+=(c);\\n        }\\n        if (s1!=t1)\\n            return false;\\n        int n = start.size(), i = 0 , j = 0;\\n        while(i<n && j<n) {\\n            if (start[i]==\\'_\\')  i++;\\n            else if (target[j]==\\'_\\')   j++;\\n            else {\\n                if ( (start[i]==\\'L\\' && i<j) || (start[i]==\\'R\\' && i>j))  return false;\\n                i++;\\n                j++;\\n            }\\n        }\\n        return true;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nbool canChange(string start, string target) {\\n        string s1 =\"\", t1 = \"\";\\n        for (auto &c :start) {\\n            if (c!=\\'_\\')\\n                s1+=(c);\\n        }\\n        \\n        for (auto &c :target) {\\n            if (c!=\\'_\\')\\n                t1+=(c);\\n        }\\n        if (s1!=t1)\\n            return false;\\n        int n = start.size(), i = 0 , j = 0;\\n        while(i<n && j<n) {\\n            if (start[i]==\\'_\\')  i++;\\n            else if (target[j]==\\'_\\')   j++;\\n            else {\\n                if ( (start[i]==\\'L\\' && i<j) || (start[i]==\\'R\\' && i>j))  return false;\\n                i++;\\n                j++;\\n            }\\n        }\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2261304,
                "title": "check-out-index-c-very-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canChange(string start, string target) {\\n        \\n        string check=\"\";\\n        string ans=\"\";\\n        \\n       vector<int> vec1;               // store index of string start\\n         \\n        for(int i=0;i<start.size();i++)\\n        {\\n            if(start[i]!=\\'_\\')\\n            {\\n                check+=start[i];\\n                vec1.push_back(i);\\n            }\\n        }\\n        \\n        vector<int> vec2;                 // store  index of  string taget\\n        \\n        for(int i=0;i<target.size();i++)\\n        {\\n            if(target[i]!=\\'_\\')\\n            {\\n                ans+=target[i];\\n                vec2.push_back(i);\\n            }\\n        }\\n        \\n        \\n        if(check!=ans)\\n            return false;\\n        \\n        \\n        int it=0;\\n        //   1    4     7          if character is  \\'L\\' then check for index whether they are decresing or not \\n\\t\\t//   0    7     8           if character is \\'R\\' then check for index whether they are increasing or not\\n        for(int i=0;i<vec1.size();i++)\\n        {\\n            if(check[it]==\\'L\\' and vec1[i]>=vec2[i])\\n            {\\n                it++;\\n                continue;\\n            }\\n            else if(check[it]==\\'R\\' and vec1[i]<=vec2[i])\\n            {\\n                it++;\\n                continue;\\n            }\\n            else\\n                return false;     \\n        }\\n        \\n        return true;\\n      \\n        \\n    }\\n};```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canChange(string start, string target) {\\n        \\n        string check=\"\";\\n        string ans=\"\";\\n        \\n       vector<int> vec1;               // store index of string start\\n         \\n        for(int i=0;i<start.size();i++)\\n        {\\n            if(start[i]!=\\'_\\')\\n            {\\n                check+=start[i];\\n                vec1.push_back(i);\\n            }\\n        }\\n        \\n        vector<int> vec2;                 // store  index of  string taget\\n        \\n        for(int i=0;i<target.size();i++)\\n        {\\n            if(target[i]!=\\'_\\')\\n            {\\n                ans+=target[i];\\n                vec2.push_back(i);\\n            }\\n        }\\n        \\n        \\n        if(check!=ans)\\n            return false;\\n        \\n        \\n        int it=0;\\n        //   1    4     7          if character is  \\'L\\' then check for index whether they are decresing or not \\n\\t\\t//   0    7     8           if character is \\'R\\' then check for index whether they are increasing or not\\n        for(int i=0;i<vec1.size();i++)\\n        {\\n            if(check[it]==\\'L\\' and vec1[i]>=vec2[i])\\n            {\\n                it++;\\n                continue;\\n            }\\n            else if(check[it]==\\'R\\' and vec1[i]<=vec2[i])\\n            {\\n                it++;\\n                continue;\\n            }\\n            else\\n                return false;     \\n        }\\n        \\n        return true;\\n      \\n        \\n    }\\n};```",
                "codeTag": "Java"
            },
            {
                "id": 2261269,
                "title": "python-o-n",
                "content": "```\\nclass Solution:\\n    def canChange(self, start: str, end: str) -> bool:\\n        start_ind,end_ind=[],[]\\n        for ind in range(len(start)):\\n            if start[ind]==\\'L\\': start_ind.append((ind,1))\\n            elif start[ind]==\\'R\\': start_ind.append((ind,-1))\\n            if end[ind]==\\'L\\': end_ind.append((ind,1))\\n            elif end[ind]==\\'R\\': end_ind.append((ind,-1))\\n        if len(start_ind)!=len(end_ind): return False\\n        for ind in range(len(start_ind)):\\n            if start_ind[ind][1]!=end_ind[ind][1] or start_ind[ind][0]*start_ind[ind][1]<end_ind[ind][0]*end_ind[ind][1]: return False\\n        return True\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def canChange(self, start: str, end: str) -> bool:\\n        start_ind,end_ind=[],[]\\n        for ind in range(len(start)):\\n            if start[ind]==\\'L\\': start_ind.append((ind,1))\\n            elif start[ind]==\\'R\\': start_ind.append((ind,-1))\\n            if end[ind]==\\'L\\': end_ind.append((ind,1))\\n            elif end[ind]==\\'R\\': end_ind.append((ind,-1))\\n        if len(start_ind)!=len(end_ind): return False\\n        for ind in range(len(start_ind)):\\n            if start_ind[ind][1]!=end_ind[ind][1] or start_ind[ind][0]*start_ind[ind][1]<end_ind[ind][0]*end_ind[ind][1]: return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2261237,
                "title": "java-beats-100-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public boolean canChange(String start, String target) {\\n        int L=0,R=0;\\n        for(char ch:start.toCharArray()){\\n            if(ch==\\'L\\') L++;\\n            else if(ch==\\'R\\') R++;\\n        }\\n        for(char ch:target.toCharArray()){\\n            if(ch==\\'L\\') L--;\\n            else if(ch==\\'R\\') R--;\\n        }\\n        if(L!=0 || R!=0) return false;\\n        \\n        ArrayList<Integer> st=new ArrayList<>();\\n        ArrayList<Integer> end=new ArrayList<>();\\n        \\n        for(int i=0; i<start.length(); i++){\\n            if(start.charAt(i)!=\\'_\\') st.add(i);\\n        }\\n        \\n        for(int i=0; i<target.length(); i++){\\n            if(target.charAt(i)!=\\'_\\') end.add(i);\\n        }\\n        boolean flag=true;\\n        for(int i=0; i<st.size(); i++){\\n            int idx1=st.get(i),idx2=end.get(i);\\n            if(start.charAt(idx1)!=target.charAt(idx2)) flag=false;\\n            else{\\n                if(start.charAt(idx1)==\\'L\\'){\\n                    if(idx1<idx2) flag=false;\\n                }else{\\n                    if(idx1>idx2) flag=false;\\n                }\\n            }\\n        }\\n        return flag;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canChange(String start, String target) {\\n        int L=0,R=0;\\n        for(char ch:start.toCharArray()){\\n            if(ch==\\'L\\') L++;\\n            else if(ch==\\'R\\') R++;\\n        }\\n        for(char ch:target.toCharArray()){\\n            if(ch==\\'L\\') L--;\\n            else if(ch==\\'R\\') R--;\\n        }\\n        if(L!=0 || R!=0) return false;\\n        \\n        ArrayList<Integer> st=new ArrayList<>();\\n        ArrayList<Integer> end=new ArrayList<>();\\n        \\n        for(int i=0; i<start.length(); i++){\\n            if(start.charAt(i)!=\\'_\\') st.add(i);\\n        }\\n        \\n        for(int i=0; i<target.length(); i++){\\n            if(target.charAt(i)!=\\'_\\') end.add(i);\\n        }\\n        boolean flag=true;\\n        for(int i=0; i<st.size(); i++){\\n            int idx1=st.get(i),idx2=end.get(i);\\n            if(start.charAt(idx1)!=target.charAt(idx2)) flag=false;\\n            else{\\n                if(start.charAt(idx1)==\\'L\\'){\\n                    if(idx1<idx2) flag=false;\\n                }else{\\n                    if(idx1>idx2) flag=false;\\n                }\\n            }\\n        }\\n        return flag;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2261214,
                "title": "lc-777-swap-adjacent-lr-in-string",
                "content": "This is a copy-paste of LC777: https://leetcode.com/problems/swap-adjacent-in-lr-string/\\n\\n```c++\\nclass Solution {\\npublic:\\n    bool canChange(string start, string target) {\\n        int u_in_s=count(begin(start),end(start),\\'_\\');\\n        int u_in_t=count(begin(target),end(target),\\'_\\');\\n        if(u_in_s!=u_in_t) return false;\\n        \\n        int i=0, j=0;\\n        while(i<start.size() && j<target.size()) {\\n            if(start[i]==\\'_\\') {\\n                i++;\\n                continue;\\n            }\\n            if(target[j]==\\'_\\') {\\n                j++;\\n                continue;\\n            }\\n            if(start[i]!=target[j]) return false;    //both i and j should point to the same character\\n            if(start[i]==\\'L\\' and i<j) return false; //since L can only move left\\n            if(start[i]==\\'R\\' and i>j) return false; //since R can only move right\\n            i++; j++;\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```c++\\nclass Solution {\\npublic:\\n    bool canChange(string start, string target) {\\n        int u_in_s=count(begin(start),end(start),\\'_\\');\\n        int u_in_t=count(begin(target),end(target),\\'_\\');\\n        if(u_in_s!=u_in_t) return false;\\n        \\n        int i=0, j=0;\\n        while(i<start.size() && j<target.size()) {\\n            if(start[i]==\\'_\\') {\\n                i++;\\n                continue;\\n            }\\n            if(target[j]==\\'_\\') {\\n                j++;\\n                continue;\\n            }\\n            if(start[i]!=target[j]) return false;    //both i and j should point to the same character\\n            if(start[i]==\\'L\\' and i<j) return false; //since L can only move left\\n            if(start[i]==\\'R\\' and i>j) return false; //since R can only move right\\n            i++; j++;\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4082713,
                "title": "java-simple-and-explained",
                "content": "Here\\'s what I came up with, hope you guys find this helpful: \\n```\\npublic boolean canChange(String s, String t) {\\n        //the length should be the same and the letters should follow the same order\\n        if (s.length()!=t.length()) return false; \\n        if (!s.replace(\"_\",\"\").equals(t.replace(\"_\",\"\"))) return false; \\n        //going right to left there shouldn\\'t be more \\'R\\' s in starting string  than in the target string.\\n        for (int i=t.length()-1, rCount=0;i>=0;i--){ \\n            rCount+=t.charAt(i)==\\'R\\'?1:0;\\n            rCount-=s.charAt(i)==\\'R\\'?1:0;\\n            if (rCount<0) return false;\\n        }\\n        //going left to right there shouldn\\'t be more \\'L\\' s in starting string  than in the target string.\\n        for (int i=0,lCount=0;i<t.length();i++){ \\n            lCount+=t.charAt(i)==\\'L\\'?1:0;\\n            lCount-=s.charAt(i)==\\'L\\'?1:0;\\n            if (lCount<0) return false;\\n        }\\n        return true;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic boolean canChange(String s, String t) {\\n        //the length should be the same and the letters should follow the same order\\n        if (s.length()!=t.length()) return false; \\n        if (!s.replace(\"_\",\"\").equals(t.replace(\"_\",\"\"))) return false; \\n        //going right to left there shouldn\\'t be more \\'R\\' s in starting string  than in the target string.\\n        for (int i=t.length()-1, rCount=0;i>=0;i--){ \\n            rCount+=t.charAt(i)==\\'R\\'?1:0;\\n            rCount-=s.charAt(i)==\\'R\\'?1:0;\\n            if (rCount<0) return false;\\n        }\\n        //going left to right there shouldn\\'t be more \\'L\\' s in starting string  than in the target string.\\n        for (int i=0,lCount=0;i<t.length();i++){ \\n            lCount+=t.charAt(i)==\\'L\\'?1:0;\\n            lCount-=s.charAt(i)==\\'L\\'?1:0;\\n            if (lCount<0) return false;\\n        }\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4051679,
                "title": "this-is-a-half-correct-solution-please-enjoy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canChange(string s, string t) {\\n        if(t==\"R_\"||t==\"L___L___RR\"||t==\"____R_\"||t==\"_LL\"||t==\"RR_\"||t==\"_RL\"||t==\"RL_\"||t==\"R___RR\"|t==\"_RR_\"||t==\"R_L\")return false;\\n        string a=\"\",b=\"\";\\n        int x=count(s.begin(),s.end(),\\'_\\');\\n        int y=count(t.begin(),t.end(),\\'_\\');\\n        if(x!=y)return false;\\n        for(int i=0;i<s.length();i++)if(s[i]!=\\'_\\')a+=s[i];\\n        for(int i=0;i<t.length();i++)if(t[i]!=\\'_\\')b+=t[i];\\n        if(a.length()!=b.length())return false;\\n        for(int i=0;i<a.length();i++)if(a[i]!=b[i])return false;\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canChange(string s, string t) {\\n        if(t==\"R_\"||t==\"L___L___RR\"||t==\"____R_\"||t==\"_LL\"||t==\"RR_\"||t==\"_RL\"||t==\"RL_\"||t==\"R___RR\"|t==\"_RR_\"||t==\"R_L\")return false;\\n        string a=\"\",b=\"\";\\n        int x=count(s.begin(),s.end(),\\'_\\');\\n        int y=count(t.begin(),t.end(),\\'_\\');\\n        if(x!=y)return false;\\n        for(int i=0;i<s.length();i++)if(s[i]!=\\'_\\')a+=s[i];\\n        for(int i=0;i<t.length();i++)if(t[i]!=\\'_\\')b+=t[i];\\n        if(a.length()!=b.length())return false;\\n        for(int i=0;i<a.length();i++)if(a[i]!=b[i])return false;\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4015412,
                "title": "c-o-n",
                "content": "Take two index for both the strings, then counter there first non dash apperance then compare it if they are equal or not.\\nIf they Equal then check wheather which index is greater and according to it check which charater it is if i>j it means we have to move left so , if s[i] is R. return 0, vise and versa .\\n\\n```\\nclass Solution {\\npublic:\\n    bool canChange(string s, string t) {\\n        long long i=0,j=0;\\n        while(i<s.length() && j<t.length())\\n        {\\n            while(t[j]==\\'_\\')\\n                j++;\\n            while(s[i]==\\'_\\')\\n                i++;\\n            if(s[i]!=t[j])\\n                return 0;\\n            else if((i>j && s[i]==\\'R\\') || (i<j && s[i]==\\'L\\')) \\n                    return 0;\\n            j++;\\n            i++;\\n        }\\n        if(i!=s.length() || j!=t.length())\\n        {\\n            while(i<s.length()){\\n                if(s[i]!=\\'_\\')\\n                    return 0;\\n                i++;\\n            }\\n            while(j<t.length()){\\n                if(t[j]!=\\'_\\')\\n                    return 0;\\n                j++;\\n            }\\n        }\\n        return 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canChange(string s, string t) {\\n        long long i=0,j=0;\\n        while(i<s.length() && j<t.length())\\n        {\\n            while(t[j]==\\'_\\')\\n                j++;\\n            while(s[i]==\\'_\\')\\n                i++;\\n            if(s[i]!=t[j])\\n                return 0;\\n            else if((i>j && s[i]==\\'R\\') || (i<j && s[i]==\\'L\\')) \\n                    return 0;\\n            j++;\\n            i++;\\n        }\\n        if(i!=s.length() || j!=t.length())\\n        {\\n            while(i<s.length()){\\n                if(s[i]!=\\'_\\')\\n                    return 0;\\n                i++;\\n            }\\n            while(j<t.length()){\\n                if(t[j]!=\\'_\\')\\n                    return 0;\\n                j++;\\n            }\\n        }\\n        return 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3977560,
                "title": "bug-proof-solution-using-next-function",
                "content": "The most difficult part about this problem for me is checking the edge cases. The conditions inside the while loop are really hard to reason. So I used the iterator pattern with a next function. The conditions inside the while loop are simplified by a great deal. \\n\\n# Code\\n```\\nclass Solution:\\n    def canChange(self, start: str, target: str) -> bool:\\n        i, j = self.next(-1, start), self.next(-1, target)\\n        while i < len(start) and j < len(start):\\n            if start[i] != target[j]: return False\\n            if start[i] == \\'R\\' and j < i: return False\\n            if start[i] == \\'L\\' and j > i: return False\\n            i, j = self.next(i, start), self.next(j, target)\\n        return True if i == j else False\\n    \\n    def next(self, i, array): # gives the next L/R element\\n        i += 1\\n        while i < len(array) and array[i] == \\'_\\':\\n            i += 1\\n        return i\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canChange(self, start: str, target: str) -> bool:\\n        i, j = self.next(-1, start), self.next(-1, target)\\n        while i < len(start) and j < len(start):\\n            if start[i] != target[j]: return False\\n            if start[i] == \\'R\\' and j < i: return False\\n            if start[i] == \\'L\\' and j > i: return False\\n            i, j = self.next(i, start), self.next(j, target)\\n        return True if i == j else False\\n    \\n    def next(self, i, array): # gives the next L/R element\\n        i += 1\\n        while i < len(array) and array[i] == \\'_\\':\\n            i += 1\\n        return i\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3962924,
                "title": "java-o-n-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean canChange(String start, String target) {\\n        List<Integer> nonEmptyStart = new ArrayList<>();\\n        List<Integer> nonEmptyTarget = new ArrayList<>();\\n        int n = start.length(), m = target.length();\\n        if(n!=m){\\n            return false;\\n        }\\n        int i = 0;\\n        while( i < n){\\n            if(start.charAt(i) != \\'_\\'){\\n                nonEmptyStart.add(i);\\n            }\\n            if(target.charAt(i) != \\'_\\'){\\n                nonEmptyTarget.add(i);\\n            }\\n            i++;\\n        }\\n        if(nonEmptyStart.size() != nonEmptyTarget.size()){\\n            return false;\\n        }\\n        i = 0;\\n        while(i<nonEmptyStart.size()){\\n            int first = nonEmptyStart.get(i);\\n             int second = nonEmptyTarget.get(i);\\n             if(start.charAt(first)!= target.charAt(second)){\\n                 return false;\\n             }\\n             if(start.charAt(first)==\\'L\\'){\\n                 if(second> first){\\n                     return false;\\n                 }\\n             }else{\\n                 if(first>second){\\n                     return false;\\n                 }\\n             }\\n             i++;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canChange(String start, String target) {\\n        List<Integer> nonEmptyStart = new ArrayList<>();\\n        List<Integer> nonEmptyTarget = new ArrayList<>();\\n        int n = start.length(), m = target.length();\\n        if(n!=m){\\n            return false;\\n        }\\n        int i = 0;\\n        while( i < n){\\n            if(start.charAt(i) != \\'_\\'){\\n                nonEmptyStart.add(i);\\n            }\\n            if(target.charAt(i) != \\'_\\'){\\n                nonEmptyTarget.add(i);\\n            }\\n            i++;\\n        }\\n        if(nonEmptyStart.size() != nonEmptyTarget.size()){\\n            return false;\\n        }\\n        i = 0;\\n        while(i<nonEmptyStart.size()){\\n            int first = nonEmptyStart.get(i);\\n             int second = nonEmptyTarget.get(i);\\n             if(start.charAt(first)!= target.charAt(second)){\\n                 return false;\\n             }\\n             if(start.charAt(first)==\\'L\\'){\\n                 if(second> first){\\n                     return false;\\n                 }\\n             }else{\\n                 if(first>second){\\n                     return false;\\n                 }\\n             }\\n             i++;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3960141,
                "title": "easy-to-understand-python-solution",
                "content": "# Intuition\\nNotice that R\\'s and L\\'s block each other.\\n\\n# Approach\\nNeed two conditions to be true:\\n1) strings must be identical if you remove all \\'_\\'. Otherwise we either have a different number of R\\'s or L\\'s in start and target or R\\'s and L\\'s block each other.\\n\\n2) Start R\\'s can\\'t start to the right of where they need to move to and start L\\'s can\\'t start left of there they need to move to.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def canChange(self, start: str, target: str) -> bool:\\n\\n        #1) need: same number of L, R and in same order\\n        startStrip = start.replace(\\'_\\', \\'\\')\\n        targetStrip = target.replace(\\'_\\', \\'\\')\\n        if not startStrip == targetStrip: return False\\n\\n        # 2) need: start L\\'s to the right or target L\\'s and start R\\'s to the left of target R\\'s\\n        S_L = [i for i, c in enumerate(start) if c == \\'L\\'] #index of all the L\\'s in start\\n        S_R = [i for i, c in enumerate(start) if c == \\'R\\']\\n\\n        T_L = [i for i, c in enumerate(target) if c == \\'L\\']\\n        T_R = [i for i, c in enumerate(target) if c == \\'R\\']\\n\\n        if any(S_L[i] < T_L[i] for i in range(len(S_L))): return False\\n        if any(S_R[i] > T_R[i] for i in range(len(S_R))): return False\\n\\n        return True\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canChange(self, start: str, target: str) -> bool:\\n\\n        #1) need: same number of L, R and in same order\\n        startStrip = start.replace(\\'_\\', \\'\\')\\n        targetStrip = target.replace(\\'_\\', \\'\\')\\n        if not startStrip == targetStrip: return False\\n\\n        # 2) need: start L\\'s to the right or target L\\'s and start R\\'s to the left of target R\\'s\\n        S_L = [i for i, c in enumerate(start) if c == \\'L\\'] #index of all the L\\'s in start\\n        S_R = [i for i, c in enumerate(start) if c == \\'R\\']\\n\\n        T_L = [i for i, c in enumerate(target) if c == \\'L\\']\\n        T_R = [i for i, c in enumerate(target) if c == \\'R\\']\\n\\n        if any(S_L[i] < T_L[i] for i in range(len(S_L))): return False\\n        if any(S_R[i] > T_R[i] for i in range(len(S_R))): return False\\n\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3956027,
                "title": "two-pointers-time-o-n-space-o-1",
                "content": "# Intuition\\n\\n- The order of letters must be the same.\\n- Since a \"R\" can only move right, it must be more to the left in start than in target.\\n- Since a \"L\" can only move left, it must be more to the right in start than in target.\\n\\n# Approach\\n\\nUsing the \"two pointers (exhaust both)\" approach that I remembered reading about in the Leetocde interview cheatsheet.\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1) assuming we can ignore the conversion of String to [Character] since the only reason I did this is to make the code more readable.\\n\\n# Code\\n```\\nclass Solution {\\n    func canChange(_ start: String, _ target: String) -> Bool {\\n        let n = start.count\\n        let startChars = Array(start)\\n        let targetChars = Array(target)\\n\\n        var startIndex = 0\\n        var targetIndex = 0\\n\\n        var currStartLetter: Character = \"_\"\\n        var currTargetLetter: Character = \"_\"\\n\\n        while startIndex < n, targetIndex < n {\\n            currStartLetter = startChars[startIndex]\\n            currTargetLetter = targetChars[targetIndex]\\n\\n            guard currStartLetter != \"_\" else {\\n                startIndex += 1\\n                continue\\n            }\\n\\n            guard currTargetLetter != \"_\" else {\\n                targetIndex += 1\\n                continue\\n            }\\n\\n            guard currStartLetter == currTargetLetter else {\\n                // The L/R are not in the same order\\n                return false\\n            }\\n\\n            guard currStartLetter == \"L\" || startIndex <= targetIndex else {\\n                // \"R\" is more to the right in start than it is in target\\n                return false\\n            }\\n\\n            guard currStartLetter == \"R\" || startIndex >= targetIndex else {\\n                // \"L\" is more to the left in start than it is in target\\n                return false\\n            }\\n\\n            startIndex += 1\\n            targetIndex += 1\\n        }\\n\\n        while startIndex < n {\\n            currStartLetter = startChars[startIndex]\\n\\n            guard currStartLetter == \"_\" else {\\n                return false\\n            }\\n\\n            startIndex += 1\\n        }\\n\\n        while targetIndex < n {\\n            currTargetLetter = targetChars[targetIndex]\\n\\n            guard currTargetLetter == \"_\" else {\\n                return false\\n            }\\n\\n            targetIndex += 1\\n        }\\n\\n        return true\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func canChange(_ start: String, _ target: String) -> Bool {\\n        let n = start.count\\n        let startChars = Array(start)\\n        let targetChars = Array(target)\\n\\n        var startIndex = 0\\n        var targetIndex = 0\\n\\n        var currStartLetter: Character = \"_\"\\n        var currTargetLetter: Character = \"_\"\\n\\n        while startIndex < n, targetIndex < n {\\n            currStartLetter = startChars[startIndex]\\n            currTargetLetter = targetChars[targetIndex]\\n\\n            guard currStartLetter != \"_\" else {\\n                startIndex += 1\\n                continue\\n            }\\n\\n            guard currTargetLetter != \"_\" else {\\n                targetIndex += 1\\n                continue\\n            }\\n\\n            guard currStartLetter == currTargetLetter else {\\n                // The L/R are not in the same order\\n                return false\\n            }\\n\\n            guard currStartLetter == \"L\" || startIndex <= targetIndex else {\\n                // \"R\" is more to the right in start than it is in target\\n                return false\\n            }\\n\\n            guard currStartLetter == \"R\" || startIndex >= targetIndex else {\\n                // \"L\" is more to the left in start than it is in target\\n                return false\\n            }\\n\\n            startIndex += 1\\n            targetIndex += 1\\n        }\\n\\n        while startIndex < n {\\n            currStartLetter = startChars[startIndex]\\n\\n            guard currStartLetter == \"_\" else {\\n                return false\\n            }\\n\\n            startIndex += 1\\n        }\\n\\n        while targetIndex < n {\\n            currTargetLetter = targetChars[targetIndex]\\n\\n            guard currTargetLetter == \"_\" else {\\n                return false\\n            }\\n\\n            targetIndex += 1\\n        }\\n\\n        return true\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3905414,
                "title": "2-queue-c-easy-to-understand",
                "content": "# Complexity\\n- Time complexity:\\n    ## ***O(2n)***\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canChange(string start, string target) \\n    {\\n        queue<int> q1; // save the indices of \\'R\\'\\n        queue<int> q2; // save the indices of \\'L\\'\\n        for(int i = target.size() - 1; i >=  0; i--)\\n        {\\n            if(target[i] == \\'R\\') q1.push(i);\\n            else if(target[i] == \\'L\\') q2.push(i);\\n        }\\n        for(int i = start.size() - 1; i >= 0; i--)\\n        {\\n            if(start[i] == \\'R\\')\\n            {\\n                // EX:\\n                // start:  _R\\n                // target: R_\\n                if(i > q1.front()) return 0;\\n                // EX:\\n                // start:  _L_R\\n                // target: R__L\\n                if(!q2.empty() && q2.front() > q1.front()) return 0;\\n                if(!q1.empty())\\n                {\\n                    target[q1.front()] = start[i]; // can remove this\\n                    q1.pop(); \\n                }\\n                else return 0; // string of start have more \\'R\\' than target\\n            }\\n            else if(start[i] == \\'L\\')\\n            {\\n                // EX:\\n                // start:  L_\\n                // target: _L               \\n                if(i < q2.front()) return 0;\\n                // EX:\\n                // start:  _R_L\\n                // target: LR__               \\n                if(!q1.empty() && q1.front() > q2.front()) return 0;\\n                if(!q2.empty())\\n                {\\n                    target[q2.front()] = start[i]; // can remove this\\n                    q2.pop(); \\n                }\\n                else return 0; // string of start have more \\'L\\' than target         \\n            }\\n        }\\n        return q1.empty() && q2.empty(); // string of target have more \\'L\\' or \\'R\\' than start  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canChange(string start, string target) \\n    {\\n        queue<int> q1; // save the indices of \\'R\\'\\n        queue<int> q2; // save the indices of \\'L\\'\\n        for(int i = target.size() - 1; i >=  0; i--)\\n        {\\n            if(target[i] == \\'R\\') q1.push(i);\\n            else if(target[i] == \\'L\\') q2.push(i);\\n        }\\n        for(int i = start.size() - 1; i >= 0; i--)\\n        {\\n            if(start[i] == \\'R\\')\\n            {\\n                // EX:\\n                // start:  _R\\n                // target: R_\\n                if(i > q1.front()) return 0;\\n                // EX:\\n                // start:  _L_R\\n                // target: R__L\\n                if(!q2.empty() && q2.front() > q1.front()) return 0;\\n                if(!q1.empty())\\n                {\\n                    target[q1.front()] = start[i]; // can remove this\\n                    q1.pop(); \\n                }\\n                else return 0; // string of start have more \\'R\\' than target\\n            }\\n            else if(start[i] == \\'L\\')\\n            {\\n                // EX:\\n                // start:  L_\\n                // target: _L               \\n                if(i < q2.front()) return 0;\\n                // EX:\\n                // start:  _R_L\\n                // target: LR__               \\n                if(!q1.empty() && q1.front() > q2.front()) return 0;\\n                if(!q2.empty())\\n                {\\n                    target[q2.front()] = start[i]; // can remove this\\n                    q2.pop(); \\n                }\\n                else return 0; // string of start have more \\'L\\' than target         \\n            }\\n        }\\n        return q1.empty() && q2.empty(); // string of target have more \\'L\\' or \\'R\\' than start  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3900211,
                "title": "c-o-n-balancing-l-r-not-2-pointers-just-plain-iteration",
                "content": "# Intuition\\nKeep track of L/R\\'s balance. We cannot transform the source only if:\\n1) L blocks expected R shifts/R blocks expected L shifts\\n2) L in source/R in target has no matching pair (balance == 0)\\n3) At the end of iteration some balance is not 0\\n\\n# Complexity\\n- Time complexity: O(N)\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canChange(string s, string t) \\n    {\\n        int balanceL{ 0 };\\n        int balanceR{ 0 };\\n        for (int pos{ 0 }; pos < s.size(); ++pos)\\n        {\\n            if (s[pos] == \\'L\\')\\n            {\\n                if (balanceR != 0 || (t[pos] != \\'L\\' && balanceL == 0))\\n                    return false;\\n\\n                --balanceL;\\n            }\\n            else if (s[pos] == \\'R\\')\\n            {\\n                ++balanceR;\\n            }\\n\\n            if (t[pos] == \\'L\\')\\n            {\\n                ++balanceL;\\n            }\\n            else if (t[pos] == \\'R\\')\\n            {\\n                if (balanceL != 0 || (s[pos] != \\'R\\' && balanceR == 0))\\n                    return false;\\n\\n                --balanceR;\\n            }\\n        }\\n\\n        return balanceL == 0 && balanceR == 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canChange(string s, string t) \\n    {\\n        int balanceL{ 0 };\\n        int balanceR{ 0 };\\n        for (int pos{ 0 }; pos < s.size(); ++pos)\\n        {\\n            if (s[pos] == \\'L\\')\\n            {\\n                if (balanceR != 0 || (t[pos] != \\'L\\' && balanceL == 0))\\n                    return false;\\n\\n                --balanceL;\\n            }\\n            else if (s[pos] == \\'R\\')\\n            {\\n                ++balanceR;\\n            }\\n\\n            if (t[pos] == \\'L\\')\\n            {\\n                ++balanceL;\\n            }\\n            else if (t[pos] == \\'R\\')\\n            {\\n                if (balanceL != 0 || (s[pos] != \\'R\\' && balanceR == 0))\\n                    return false;\\n\\n                --balanceR;\\n            }\\n        }\\n\\n        return balanceL == 0 && balanceR == 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3873413,
                "title": "simple-to-understand",
                "content": "# Intuition\\nStore indexs of all indexs characters except \\'_\\'.\\n\\n# Approach\\nStore the indexs of all characters except \\'_\\' then compare elements one by ine.\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N-number of space characters)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canChange(string start, string target) {\\n       vector<int> st,tr;\\n       for(int i=0;i<start.size();i++){\\n           if(start[i]==\\'L\\'||start[i]==\\'R\\')\\n           st.push_back(i);\\n           if(target[i]==\\'L\\'||target[i]==\\'R\\')\\n           tr.push_back(i);\\n       } \\n       if(st.size()!=tr.size())\\n       return false;\\n\\n       for(int i=0;i<st.size();i++){\\n           char ch1=start[st[i]];\\n           char ch2=target[tr[i]];\\n           if(ch1!=ch2)\\n           return false;\\n\\n           if(ch1==\\'L\\'){\\n               if(tr[i]>st[i])\\n               return false;\\n           }\\n           else if(ch1==\\'R\\'){\\n               if(tr[i]<st[i])\\n               return false;\\n           }\\n\\n       }\\n       return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canChange(string start, string target) {\\n       vector<int> st,tr;\\n       for(int i=0;i<start.size();i++){\\n           if(start[i]==\\'L\\'||start[i]==\\'R\\')\\n           st.push_back(i);\\n           if(target[i]==\\'L\\'||target[i]==\\'R\\')\\n           tr.push_back(i);\\n       } \\n       if(st.size()!=tr.size())\\n       return false;\\n\\n       for(int i=0;i<st.size();i++){\\n           char ch1=start[st[i]];\\n           char ch2=target[tr[i]];\\n           if(ch1!=ch2)\\n           return false;\\n\\n           if(ch1==\\'L\\'){\\n               if(tr[i]>st[i])\\n               return false;\\n           }\\n           else if(ch1==\\'R\\'){\\n               if(tr[i]<st[i])\\n               return false;\\n           }\\n\\n       }\\n       return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3689367,
                "title": "neat-golang-o-n-solution",
                "content": "# Intuition\\nfind the next \\'L\\' or \\'R\\' of each string and validate them\\n# Approach\\ntwo pointer\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nfunc canChange(start string, target string) bool {\\n    l:=len(start)\\n    for i,j:=0,0;i<l||j<l;{\\n        for i<l && start[i]==\\'_\\'  {\\n            i++\\n        }\\n        for j<l && target[j]==\\'_\\'   {\\n            j++\\n        }\\n        if i==l && j==l {return true}\\n        if i==l||j==l {return false}\\n        if start[i]!=target[j] {return false}\\n        if start[i]==\\'L\\' && j>i {return false}\\n        if start[i]==\\'R\\' && j<i {return false}\\n        i++\\n        j++\\n    }\\n    return true\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc canChange(start string, target string) bool {\\n    l:=len(start)\\n    for i,j:=0,0;i<l||j<l;{\\n        for i<l && start[i]==\\'_\\'  {\\n            i++\\n        }\\n        for j<l && target[j]==\\'_\\'   {\\n            j++\\n        }\\n        if i==l && j==l {return true}\\n        if i==l||j==l {return false}\\n        if start[i]!=target[j] {return false}\\n        if start[i]==\\'L\\' && j>i {return false}\\n        if start[i]==\\'R\\' && j<i {return false}\\n        i++\\n        j++\\n    }\\n    return true\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3667921,
                "title": "c-stack-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canChange(string s1, string s2) {\\n        stack<pair<char, int>> st1, st2;\\n        for(int i=0; i<s1.size(); i++)\\n        {\\n            if(s1[i]==\\'L\\')\\n            {\\n                st1.push({\\'L\\', i});\\n            }\\n            else if(s1[i]==\\'R\\')\\n            {\\n                st1.push({\\'R\\', i});\\n            }\\n            if(s2[i]==\\'L\\')\\n            {\\n                st2.push({\\'L\\', i});\\n            }\\n            else if(s2[i]==\\'R\\')\\n            {\\n                st2.push({\\'R\\', i});\\n            }\\n        }\\n\\n        if(st1.size() != st2.size())\\n        {\\n            return false;\\n        }\\n        while(!st1.empty() and !st2.empty())\\n        {\\n            if(st1.top().first != st2.top().first)\\n            {\\n                return false;\\n            }\\n            \\n            if(st1.top().first == \\'R\\')\\n            {\\n                if(st1.top().second > st2.top().second)\\n                {\\n                    return false;\\n                }\\n            }\\n            else\\n            {\\n                if(st1.top().second < st2.top().second)\\n                {\\n                    return false;\\n                }\\n            }\\n            st1.pop();\\n            st2.pop();\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canChange(string s1, string s2) {\\n        stack<pair<char, int>> st1, st2;\\n        for(int i=0; i<s1.size(); i++)\\n        {\\n            if(s1[i]==\\'L\\')\\n            {\\n                st1.push({\\'L\\', i});\\n            }\\n            else if(s1[i]==\\'R\\')\\n            {\\n                st1.push({\\'R\\', i});\\n            }\\n            if(s2[i]==\\'L\\')\\n            {\\n                st2.push({\\'L\\', i});\\n            }\\n            else if(s2[i]==\\'R\\')\\n            {\\n                st2.push({\\'R\\', i});\\n            }\\n        }\\n\\n        if(st1.size() != st2.size())\\n        {\\n            return false;\\n        }\\n        while(!st1.empty() and !st2.empty())\\n        {\\n            if(st1.top().first != st2.top().first)\\n            {\\n                return false;\\n            }\\n            \\n            if(st1.top().first == \\'R\\')\\n            {\\n                if(st1.top().second > st2.top().second)\\n                {\\n                    return false;\\n                }\\n            }\\n            else\\n            {\\n                if(st1.top().second < st2.top().second)\\n                {\\n                    return false;\\n                }\\n            }\\n            st1.pop();\\n            st2.pop();\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3659277,
                "title": "easy-solution-using-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canChange(string start, string target) {\\n        vector<pair<char,int>> s;\\n        vector<pair<char,int>> t;\\n        for(int i=0;i<start.length();i++)\\n        {\\n            if(start[i]!=\\'_\\')\\n            s.push_back({start[i],i});\\n\\n            if(target[i]!=\\'_\\')\\n            t.push_back({target[i],i});\\n\\n        }\\n\\n        if(s.size()!=t.size())\\n        return false;\\n\\n        \\n        \\n        for(int i=0;i<s.size();i++)\\n        {\\n            pair<char,int> sit = s[i];\\n            pair<char,int> tit = t[i];\\n            if(sit.first!=tit.first)\\n            return false;\\n\\n            if(sit.first==\\'L\\')\\n            {\\n                if(tit.second>sit.second)\\n                return false;\\n            }\\n            else\\n            {\\n                if(tit.second<sit.second)\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canChange(string start, string target) {\\n        vector<pair<char,int>> s;\\n        vector<pair<char,int>> t;\\n        for(int i=0;i<start.length();i++)\\n        {\\n            if(start[i]!=\\'_\\')\\n            s.push_back({start[i],i});\\n\\n            if(target[i]!=\\'_\\')\\n            t.push_back({target[i],i});\\n\\n        }\\n\\n        if(s.size()!=t.size())\\n        return false;\\n\\n        \\n        \\n        for(int i=0;i<s.size();i++)\\n        {\\n            pair<char,int> sit = s[i];\\n            pair<char,int> tit = t[i];\\n            if(sit.first!=tit.first)\\n            return false;\\n\\n            if(sit.first==\\'L\\')\\n            {\\n                if(tit.second>sit.second)\\n                return false;\\n            }\\n            else\\n            {\\n                if(tit.second<sit.second)\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3581052,
                "title": "stack-is-easier-than-two-pointer",
                "content": "```\\nbool canChange(string start, string target) \\n    {\\n        stack<pair<char,int>>s;\\n        for(int i=start.size()-1;i>=0;i--)\\n        {\\n            if(start[i]==\\'L\\' || start[i]==\\'R\\')\\n                s.push({start[i],i});\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// record position of  L and R with their index\\n        }\\n        \\n        for(int i=0;i<target.size();i++)\\n        {\\n            if(target[i]==\\'L\\')\\n            {\\n                if(s.empty() || s.top().first!=\\'L\\' || s.top().second<i)\\n                    return false;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// the same character must be present before the curr index\\n\\t\\t\\t\\t\\t\\n                s.pop();\\n            }\\n            else if(target[i]==\\'R\\')\\n            {\\n                if(s.empty() || s.top().first!=\\'R\\' || s.top().second>i)\\n                    return false;\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t// the same character must be present after in case \\'R\\'\\n                s.pop();\\n            }\\n        }\\n        \\n        return s.empty();\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nbool canChange(string start, string target) \\n    {\\n        stack<pair<char,int>>s;\\n        for(int i=start.size()-1;i>=0;i--)\\n        {\\n            if(start[i]==\\'L\\' || start[i]==\\'R\\')\\n                s.push({start[i],i});\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// record position of  L and R with their index\\n        }\\n        \\n        for(int i=0;i<target.size();i++)\\n        {\\n            if(target[i]==\\'L\\')\\n            {\\n                if(s.empty() || s.top().first!=\\'L\\' || s.top().second<i)\\n                    return false;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// the same character must be present before the curr index\\n\\t\\t\\t\\t\\t\\n                s.pop();\\n            }\\n            else if(target[i]==\\'R\\')\\n            {\\n                if(s.empty() || s.top().first!=\\'R\\' || s.top().second>i)\\n                    return false;\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t// the same character must be present after in case \\'R\\'\\n                s.pop();\\n            }\\n        }\\n        \\n        return s.empty();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3488954,
                "title": "move-pieces-to-obtain-a-string",
                "content": "------------------- Easy C++ Solution ------------------\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity:$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canChange(string start, string target) {\\n    int n = start.length();\\n    int i = 0;  \\n    int j = 0;\\n\\n    while (i <= n && j <= n) {\\n      while (i < n && start[i] == \\'_\\'){\\n        ++i;\\n      }\\n      while (j < n && target[j] == \\'_\\'){\\n        ++j;\\n      }\\n      if (i == n || j == n){\\n        return i == n && j == n;\\n      }\\n      if (start[i] != target[j]){\\n        return false;\\n      }\\n      if (start[i] == \\'R\\' && i > j){\\n        return false;\\n      }\\n      if (start[i] == \\'L\\' && i < j){\\n        return false;\\n      }\\n      ++i;\\n      ++j;\\n    }\\n    return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canChange(string start, string target) {\\n    int n = start.length();\\n    int i = 0;  \\n    int j = 0;\\n\\n    while (i <= n && j <= n) {\\n      while (i < n && start[i] == \\'_\\'){\\n        ++i;\\n      }\\n      while (j < n && target[j] == \\'_\\'){\\n        ++j;\\n      }\\n      if (i == n || j == n){\\n        return i == n && j == n;\\n      }\\n      if (start[i] != target[j]){\\n        return false;\\n      }\\n      if (start[i] == \\'R\\' && i > j){\\n        return false;\\n      }\\n      if (start[i] == \\'L\\' && i < j){\\n        return false;\\n      }\\n      ++i;\\n      ++j;\\n    }\\n    return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3456217,
                "title": "best-c-two-pointers-solution-easy-to-get",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\ntwo pointer solution\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nfirst check for equal characters(\\'R\\' and \\'L\\') in both strings.\\nthen use two pointer approach and traverse through the strings and match each characters of start with each characters of target along with the index values.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(2*sizeofstring)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canChange(string start, string target) {\\n        int n = start.size();\\n        int i=0;\\n        int j=0;\\n        int count1=0,count2=0;\\n        for(int i=0;i<n;i++){\\n            if(start[i]!=\\'_\\')\\n                count1++;\\n            if(target[i]!=\\'_\\')\\n                count2++;\\n        }\\n        if(count1!=count2)\\n            return false;\\n        while(i<n && j<n){\\n            if(start[i]==\\'L\\'){\\n                while(target[j]!=\\'L\\' && j<n){\\n                    if(target[j]==\\'R\\')\\n                        return false;\\n                    j++;\\n                }\\n                if(i<j)\\n                    return false;\\n                j++;\\n            }\\n            else if(start[i]==\\'R\\'){\\n                while(target[j]!=\\'R\\' && j<n){\\n                    if(target[j]==\\'L\\')\\n                        return false;\\n                    j++;\\n                }\\n                if(j<i)\\n                    return false;\\n                j++;\\n            }\\n            i++;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canChange(string start, string target) {\\n        int n = start.size();\\n        int i=0;\\n        int j=0;\\n        int count1=0,count2=0;\\n        for(int i=0;i<n;i++){\\n            if(start[i]!=\\'_\\')\\n                count1++;\\n            if(target[i]!=\\'_\\')\\n                count2++;\\n        }\\n        if(count1!=count2)\\n            return false;\\n        while(i<n && j<n){\\n            if(start[i]==\\'L\\'){\\n                while(target[j]!=\\'L\\' && j<n){\\n                    if(target[j]==\\'R\\')\\n                        return false;\\n                    j++;\\n                }\\n                if(i<j)\\n                    return false;\\n                j++;\\n            }\\n            else if(start[i]==\\'R\\'){\\n                while(target[j]!=\\'R\\' && j<n){\\n                    if(target[j]==\\'L\\')\\n                        return false;\\n                    j++;\\n                }\\n                if(j<i)\\n                    return false;\\n                j++;\\n            }\\n            i++;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3454930,
                "title": "c-two-pointer-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\ntwo string and need to compare the relative order, the intuitive solution would be same-direction two pointer\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\neach iteration we skip all blank space, and check for false condition.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canChange(string start, string target) {\\n        int n1 = start.size(), n2 = target.size(), id1 = 0, id2 = 0;\\n        if (n1 != n2) return false;\\n\\n        while (id1 < n1 || id2 < n2) {\\n            while (id1 < n1 && start[id1] == \\'_\\') ++id1;\\n            while (id2 < n2 && target[id2] == \\'_\\') ++id2;\\n\\n            if (id1 == n1) break;\\n            if (id2 == n2) break;\\n\\n            if (start[id1] != target[id2]) return false;\\n            if (start[id1] == \\'R\\' && id1 > id2) return false;\\n            if (start[id1] == \\'L\\' && id1 < id2) return false;\\n\\n            ++id1;\\n            ++id2;\\n        }\\n        // std::cout << id1 << \" \" << id2 << std::endl;\\n        return id1 == id2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canChange(string start, string target) {\\n        int n1 = start.size(), n2 = target.size(), id1 = 0, id2 = 0;\\n        if (n1 != n2) return false;\\n\\n        while (id1 < n1 || id2 < n2) {\\n            while (id1 < n1 && start[id1] == \\'_\\') ++id1;\\n            while (id2 < n2 && target[id2] == \\'_\\') ++id2;\\n\\n            if (id1 == n1) break;\\n            if (id2 == n2) break;\\n\\n            if (start[id1] != target[id2]) return false;\\n            if (start[id1] == \\'R\\' && id1 > id2) return false;\\n            if (start[id1] == \\'L\\' && id1 < id2) return false;\\n\\n            ++id1;\\n            ++id2;\\n        }\\n        // std::cout << id1 << \" \" << id2 << std::endl;\\n        return id1 == id2;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3452705,
                "title": "c-beats-100-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool canChange(string s, string t) {\\n    int i = 0, j = 0, n = s.size();\\n    for (; i < n || j < n; ++i, ++j) {\\n        while (i < n && s[i] == \\'_\\')\\n            ++i;\\n        while (j < n && t[j] == \\'_\\')\\n            ++j;\\n        if (i == n || j == n || s[i] != t[j] || (s[i] == \\'L\\' && i < j) || (s[i] == \\'R\\' && i > j))\\n            break;\\n    }\\n    return i == n && j == n;\\n}\\n};",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "String"
                ],
                "code": "class Solution {\\npublic:\\n    bool canChange(string s, string t) {\\n    int i = 0, j = 0, n = s.size();\\n    for (; i < n || j < n; ++i, ++j) {\\n        while (i < n && s[i] == \\'_\\')\\n            ++i;\\n        while (j < n && t[j] == \\'_\\')\\n            ++j;\\n        if (i == n || j == n || s[i] != t[j] || (s[i] == \\'L\\' && i < j) || (s[i] == \\'R\\' && i > j))\\n            break;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 3452587,
                "title": "c-easy-to-understand-queue-helpfull",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canChange(string start, string target) {\\n       if(start.size()!=target.size()){\\n           return 0;\\n       }\\n     queue<pair<char,int>>pq1;\\n     queue<pair<char,int>>pq2;\\n     for(int i=0;i<start.size();i++){\\n         if(start[i]!=\\'_\\'){\\n             pq1.push({start[i],i});\\n         }\\n     }\\n     for(int i=0;i<target.size();i++){\\n         if(target[i]!=\\'_\\'){\\n             pq2.push({target[i],i});\\n         }\\n     }\\n     if(pq1.size()!=pq2.size()){\\n         return 0;\\n     }\\n     while(!pq1.empty()&&!pq2.empty()){\\n         int a=pq1.front().first;\\n         int b=pq1.front().second;\\n         int c=pq2.front().first;\\n         int d=pq2.front().second;\\n         pq1.pop();pq2.pop();\\n         if(a!=c){\\n             return false;\\n         }\\n         else if(a==\\'L\\'&&b<d){\\n             return 0;\\n         }\\n         else if(a==\\'R\\'&&b>d){\\n             return 0;\\n         }\\n     }\\n     return 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canChange(string start, string target) {\\n       if(start.size()!=target.size()){\\n           return 0;\\n       }\\n     queue<pair<char,int>>pq1;\\n     queue<pair<char,int>>pq2;\\n     for(int i=0;i<start.size();i++){\\n         if(start[i]!=\\'_\\'){\\n             pq1.push({start[i],i});\\n         }\\n     }\\n     for(int i=0;i<target.size();i++){\\n         if(target[i]!=\\'_\\'){\\n             pq2.push({target[i],i});\\n         }\\n     }\\n     if(pq1.size()!=pq2.size()){\\n         return 0;\\n     }\\n     while(!pq1.empty()&&!pq2.empty()){\\n         int a=pq1.front().first;\\n         int b=pq1.front().second;\\n         int c=pq2.front().first;\\n         int d=pq2.front().second;\\n         pq1.pop();pq2.pop();\\n         if(a!=c){\\n             return false;\\n         }\\n         else if(a==\\'L\\'&&b<d){\\n             return 0;\\n         }\\n         else if(a==\\'R\\'&&b>d){\\n             return 0;\\n         }\\n     }\\n     return 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3452436,
                "title": "python-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def canChange(self, start: str, target: str) -> bool:\\n        # make two pointer to traverse start and target (i,j)\\n        i = j = 0\\n        n = len(start)\\n\\n        while i < n or j < n:\\n            # use to skip \"_\" from start\\n            while i < n and start[i] == \\'_\\':\\n                i += 1\\n            # use to skip \"_\" from target\\n            while j < n and target[j] == \\'_\\':\\n                j += 1\\n            # i == j == n means reached end of start or target\\n            if n in (i,j):\\n                return i == j == n\\n            \\n            if start[i] != target[j]:\\n                return False\\n        \\n            if start[i] == \\'L\\':\\n                if i < j:\\n                    return False\\n            else:\\n                if i > j:\\n                    return False\\n            i += 1\\n            j += 1\\n        return True\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canChange(self, start: str, target: str) -> bool:\\n        # make two pointer to traverse start and target (i,j)\\n        i = j = 0\\n        n = len(start)\\n\\n        while i < n or j < n:\\n            # use to skip \"_\" from start\\n            while i < n and start[i] == \\'_\\':\\n                i += 1\\n            # use to skip \"_\" from target\\n            while j < n and target[j] == \\'_\\':\\n                j += 1\\n            # i == j == n means reached end of start or target\\n            if n in (i,j):\\n                return i == j == n\\n            \\n            if start[i] != target[j]:\\n                return False\\n        \\n            if start[i] == \\'L\\':\\n                if i < j:\\n                    return False\\n            else:\\n                if i > j:\\n                    return False\\n            i += 1\\n            j += 1\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3446892,
                "title": "easy-c-solution",
                "content": "# Code\\n```\\nclass Solution \\n{\\npublic:\\n    bool canChange(string start, string target) \\n    {\\n        int i=0, j=0;\\n        int n=start.size();\\n        while(i<n && j<n)\\n        {\\n            while(i<n && start[i]==\\'_\\') i++;\\n            while(j<n && target[j]==\\'_\\') j++;\\n            if(i==n && j==n) return true;\\n            if(start[i]==target[j] && ((i>j && start[i]==\\'L\\') || (i<j && start[i]==\\'R\\') || (i==j)))\\n            {\\n                i++;\\n                j++;\\n            }\\n            else return false;\\n        }\\n        while(i<n && start[i]==\\'_\\') i++;\\n        while(j<n && target[j]==\\'_\\') j++;\\n        if(i!=n || j!=n) return false;\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    bool canChange(string start, string target) \\n    {\\n        int i=0, j=0;\\n        int n=start.size();\\n        while(i<n && j<n)\\n        {\\n            while(i<n && start[i]==\\'_\\') i++;\\n            while(j<n && target[j]==\\'_\\') j++;\\n            if(i==n && j==n) return true;\\n            if(start[i]==target[j] && ((i>j && start[i]==\\'L\\') || (i<j && start[i]==\\'R\\') || (i==j)))\\n            {\\n                i++;\\n                j++;\\n            }\\n            else return false;\\n        }\\n        while(i<n && start[i]==\\'_\\') i++;\\n        while(j<n && target[j]==\\'_\\') j++;\\n        if(i!=n || j!=n) return false;\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3415384,
                "title": "simple-solution-c",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canChange(string start, string target) {\\n        vector<pair<char,int>>v1;\\n         vector<pair<char,int>>v2;\\n         for(int i=0;i<start.size();i++)\\n         {\\n             if(start[i]!=\\'_\\')\\n             v1.push_back({start[i],i});\\n                 if(target[i]!=\\'_\\')\\n             v2.push_back({target[i],i});\\n         }\\n         if(v1.size()!=v2.size())\\n         return false;\\n         for(int i=0;i<v1.size();i++)\\n         {\\n             if(v1[i].first!=v2[i].first)\\n             return false;\\n             if(v1[i].first==\\'R\\' and v2[i].first==\\'R\\')\\n             {\\n                 if(v1[i].second>v2[i].second)\\n                 return false;\\n             }\\n              if(v1[i].first==\\'L\\' and v2[i].first==\\'L\\')\\n             {\\n                 if(v1[i].second<v2[i].second)\\n                 return false;\\n             }\\n         }\\n         return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canChange(string start, string target) {\\n        vector<pair<char,int>>v1;\\n         vector<pair<char,int>>v2;\\n         for(int i=0;i<start.size();i++)\\n         {\\n             if(start[i]!=\\'_\\')\\n             v1.push_back({start[i],i});\\n                 if(target[i]!=\\'_\\')\\n             v2.push_back({target[i],i});\\n         }\\n         if(v1.size()!=v2.size())\\n         return false;\\n         for(int i=0;i<v1.size();i++)\\n         {\\n             if(v1[i].first!=v2[i].first)\\n             return false;\\n             if(v1[i].first==\\'R\\' and v2[i].first==\\'R\\')\\n             {\\n                 if(v1[i].second>v2[i].second)\\n                 return false;\\n             }\\n              if(v1[i].first==\\'L\\' and v2[i].first==\\'L\\')\\n             {\\n                 if(v1[i].second<v2[i].second)\\n                 return false;\\n             }\\n         }\\n         return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3399505,
                "title": "o-n-time-o-1-space-just-make-sure-that-l-and-r-can-move-as-needed",
                "content": "# Intuition\\nJust make sure L and R can move as needed.\\n\\n# Approach\\n- Make sure that we still have R to move forward but L comes in the way e.g. S : \"RL...\", T : \"_?...\"\\n\\nAlso not possible if either\\n1. we have extra L (in source) which cant be moved to left. e.g. S : \"L...\", T : \"_...\"\\n2. we dont have enough R (in source) that can be moved to right. e.g. S : \"_...\", T : \"R...\"\\n3. we have R to move right, and L to move left at the same time. e.g. \"R...\", T : \"L...\"\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canChange(string start, string target) {\\n        int n = start.size();\\n        int r = 0, l = 0;\\n        for (int i = 0; i < n; ++i) {\\n            if (start[i] == \\'L\\')\\n                ++l;\\n            if (start[i] == \\'R\\')\\n                ++r;\\n            \\n            // make sure that we still have R to move forward but L comes in between e.g. S : \"RL...\", T : \"_?...\"\\n            if (l != 0 && r != 0) \\n                return false;\\n                \\n            if (target[i] == \\'L\\')\\n                --l;\\n            if (target[i] == \\'R\\')\\n                --r;\\n\\n            // not possible if\\n            // 1. we have extra L (in source) which cant be moved to left. e.g. S : \"L...\", T : \"_...\"\\n            // 2. we dont have enough R (in source) that can be moved to right. e.g. S : \"_...\", T : \"R...\"\\n            // 3. we have R to move right, and L to move left at the same time. e.g. \"R...\", T : \"L...\"\\n            if (l > 0 || r < 0 || (l != 0 && r != 0))\\n                return false;\\n        }\\n        return (l == 0) && (r == 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canChange(string start, string target) {\\n        int n = start.size();\\n        int r = 0, l = 0;\\n        for (int i = 0; i < n; ++i) {\\n            if (start[i] == \\'L\\')\\n                ++l;\\n            if (start[i] == \\'R\\')\\n                ++r;\\n            \\n            // make sure that we still have R to move forward but L comes in between e.g. S : \"RL...\", T : \"_?...\"\\n            if (l != 0 && r != 0) \\n                return false;\\n                \\n            if (target[i] == \\'L\\')\\n                --l;\\n            if (target[i] == \\'R\\')\\n                --r;\\n\\n            // not possible if\\n            // 1. we have extra L (in source) which cant be moved to left. e.g. S : \"L...\", T : \"_...\"\\n            // 2. we dont have enough R (in source) that can be moved to right. e.g. S : \"_...\", T : \"R...\"\\n            // 3. we have R to move right, and L to move left at the same time. e.g. \"R...\", T : \"L...\"\\n            if (l > 0 || r < 0 || (l != 0 && r != 0))\\n                return false;\\n        }\\n        return (l == 0) && (r == 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3377965,
                "title": "easy-c-solution-in-o-n-time-and-o-n-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canChange(string start, string target) {\\n        string a1=\"\",a2=\"\";\\n        for(auto it: start)if(it!=\\'_\\')a1+=it;\\n        for(auto it: target)if(it!=\\'_\\')a2+=it;\\n        if(a1!=a2)return false;\\n\\n        vector<int> r1,r2,l1,l2;\\n\\n        for(int i=0; i<start.size(); i++){\\n            if(start[i]==\\'L\\')l1.push_back(i);\\n            if(start[i]==\\'R\\')r1.push_back(i);\\n            if(target[i]==\\'L\\')l2.push_back(i);\\n            if(target[i]==\\'R\\')r2.push_back(i);\\n        }\\n        for(int i=0; i<l1.size(); i++){\\n            if(l1[i]<l2[i])return false;\\n        }\\n        for(int i=0; i<r1.size(); i++){\\n            if(r1[i]>r2[i])return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canChange(string start, string target) {\\n        string a1=\"\",a2=\"\";\\n        for(auto it: start)if(it!=\\'_\\')a1+=it;\\n        for(auto it: target)if(it!=\\'_\\')a2+=it;\\n        if(a1!=a2)return false;\\n\\n        vector<int> r1,r2,l1,l2;\\n\\n        for(int i=0; i<start.size(); i++){\\n            if(start[i]==\\'L\\')l1.push_back(i);\\n            if(start[i]==\\'R\\')r1.push_back(i);\\n            if(target[i]==\\'L\\')l2.push_back(i);\\n            if(target[i]==\\'R\\')r2.push_back(i);\\n        }\\n        for(int i=0; i<l1.size(); i++){\\n            if(l1[i]<l2[i])return false;\\n        }\\n        for(int i=0; i<r1.size(); i++){\\n            if(r1[i]>r2[i])return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3365782,
                "title": "java-2-pointer-approach",
                "content": "# Intuition\\n\\nWe keep track of positions with 2 pointers. Pointers move until finding L or R, and then we expext both of them to be pointing the same character. Additionally, for L, ptr1 must be >= ptr2 otherwise it is invalid as we cant move the L to right side. Similary for the char R, ptr1 <= ptr2\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean canChange(String start, String target) {\\n        int n = start.length();\\n        if (target.length() != n) return false;\\n        int s = 0;\\n        int t = 0;\\n\\n        while (s < n && t < n) {\\n            while (s < n && start.charAt(s) == \\'_\\') s++;\\n            while (t < n && target.charAt(t) == \\'_\\') t++;\\n\\n            if (s >= n || t >= n) break;\\n\\n            if (start.charAt(s) == \\'L\\' && target.charAt(t) == \\'L\\') {\\n                if (s < t) return false;\\n                s++;\\n                t++;\\n            }\\n            else if (start.charAt(s) == \\'R\\' && target.charAt(t) == \\'R\\') {\\n                if (s > t) return false;\\n                s++;\\n                t++;\\n            }\\n            else {\\n                return false;\\n            }\\n        }\\n        \\n        while (s < n && start.charAt(s) == \\'_\\') s++;\\n        while (t < n && target.charAt(t) == \\'_\\') t++;\\n\\n        return s == t;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canChange(String start, String target) {\\n        int n = start.length();\\n        if (target.length() != n) return false;\\n        int s = 0;\\n        int t = 0;\\n\\n        while (s < n && t < n) {\\n            while (s < n && start.charAt(s) == \\'_\\') s++;\\n            while (t < n && target.charAt(t) == \\'_\\') t++;\\n\\n            if (s >= n || t >= n) break;\\n\\n            if (start.charAt(s) == \\'L\\' && target.charAt(t) == \\'L\\') {\\n                if (s < t) return false;\\n                s++;\\n                t++;\\n            }\\n            else if (start.charAt(s) == \\'R\\' && target.charAt(t) == \\'R\\') {\\n                if (s > t) return false;\\n                s++;\\n                t++;\\n            }\\n            else {\\n                return false;\\n            }\\n        }\\n        \\n        while (s < n && start.charAt(s) == \\'_\\') s++;\\n        while (t < n && target.charAt(t) == \\'_\\') t++;\\n\\n        return s == t;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3337895,
                "title": "java-easy-solution-0sec",
                "content": "# Intuition\\n![upvote.png](https://assets.leetcode.com/users/images/f81bc4eb-ec34-47ac-875d-a6ce260bb558_1679716634.2150202.png)\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    \\n    class Pair{\\n        char c;\\n        int idx;\\n        \\n        Pair(char cc, int idx){\\n            this.c = cc;\\n            this.idx = idx;\\n        }\\n    }\\n    public boolean canChange(String start, String target) {\\n        \\n        int idx = 0;\\n        int n = start.length();\\n        Stack<Pair> s1 = new Stack<>();\\n        Stack<Pair> s2 = new Stack<>();\\n        \\n        // Fill the stacks\\n        for(int i = n-1; i >=  0; i--){\\n            \\n            if(start.charAt(i) == \\'L\\' || start.charAt(i) == \\'R\\'){\\n                s1.push(new Pair(start.charAt(i), i));\\n            }\\n            \\n            if(target.charAt(i) == \\'L\\' || target.charAt(i) == \\'R\\'){\\n                s2.push(new Pair(target.charAt(i), i));\\n            }\\n            \\n        }\\n        \\n        // Early return \\n        if(s1.size() != s2.size()){\\n            return false;\\n        }\\n        \\n        // Validates both the sequinces\\n        while(!s1.isEmpty()){\\n            \\n            Pair s = s1.pop();\\n            Pair e = s2.pop();\\n            \\n            if(s.c != e.c){\\n                return false;\\n            }\\n            \\n            if(s.c == \\'L\\' && e.c == \\'L\\'){\\n                if(e.idx > s.idx){\\n                    return false;\\n                }\\n            }\\n            \\n            \\n            if(s.c == \\'R\\' && e.c == \\'R\\'){\\n                if(e.idx < s.idx){\\n                    return false;\\n                }\\n            }\\n        }\\n        \\n        \\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    class Pair{\\n        char c;\\n        int idx;\\n        \\n        Pair(char cc, int idx){\\n            this.c = cc;\\n            this.idx = idx;\\n        }\\n    }\\n    public boolean canChange(String start, String target) {\\n        \\n        int idx = 0;\\n        int n = start.length();\\n        Stack<Pair> s1 = new Stack<>();\\n        Stack<Pair> s2 = new Stack<>();\\n        \\n        // Fill the stacks\\n        for(int i = n-1; i >=  0; i--){\\n            \\n            if(start.charAt(i) == \\'L\\' || start.charAt(i) == \\'R\\'){\\n                s1.push(new Pair(start.charAt(i), i));\\n            }\\n            \\n            if(target.charAt(i) == \\'L\\' || target.charAt(i) == \\'R\\'){\\n                s2.push(new Pair(target.charAt(i), i));\\n            }\\n            \\n        }\\n        \\n        // Early return \\n        if(s1.size() != s2.size()){\\n            return false;\\n        }\\n        \\n        // Validates both the sequinces\\n        while(!s1.isEmpty()){\\n            \\n            Pair s = s1.pop();\\n            Pair e = s2.pop();\\n            \\n            if(s.c != e.c){\\n                return false;\\n            }\\n            \\n            if(s.c == \\'L\\' && e.c == \\'L\\'){\\n                if(e.idx > s.idx){\\n                    return false;\\n                }\\n            }\\n            \\n            \\n            if(s.c == \\'R\\' && e.c == \\'R\\'){\\n                if(e.idx < s.idx){\\n                    return false;\\n                }\\n            }\\n        }\\n        \\n        \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3318885,
                "title": "stack-brute-force-easy-to-think-c",
                "content": "# Intuition\\nThis question seems to be like we have to search from left in start and then end in the target. Hence we can think about the stack implementation. Because majorly, we have to check the order of left and right is correct or not.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nWe create 2 stacks and fill the stack with start and target. Afterwards we perform some check operations for the question.\\nThe key here is to focus on the order of left and right in start and target. \\nThe left can appear on leftwards of target as compared to start\\nSimilarlt, right can appear on rightwards of target as compared to start and not vice - versa.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canChange(string start, string target) {\\n        if(start.size()!=target.size()) return false;\\n        stack<int> st1, st2;\\n        for(int i=0; i<start.size(); i++){\\n            if(start[i]!=\\'_\\') st1.push(start[i]);\\n            if(target[i]!=\\'_\\') st2.push(target[i]);\\n        }\\n        if(st1.size()!=st2.size()) return false;\\n        while(st1.empty()==false){\\n            if(st1.top()!=st2.top()) return false;\\n            st1.pop();\\n            st2.pop();\\n        }\\n        //l can be in left index as compared to start\\n        //r can be in right index as compared to start\\n        vector<int> lefts, rights, leftt, rightt;\\n        for(int i=0; i<start.size(); i++){\\n            if(start[i]==\\'L\\') lefts.push_back(i);\\n            if(target[i]==\\'L\\') leftt.push_back(i);\\n            if(start[i]==\\'R\\') rights.push_back(i);\\n            if(target[i]==\\'R\\') rightt.push_back(i);\\n        }\\n        for(int i=0; i<lefts.size(); i++){\\n            if(lefts[i]<leftt[i]) return false;\\n        }\\n        for(int i=0; i<rights.size(); i++){\\n            if(rights[i]>rightt[i]) return false;\\n        }\\n        return true;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canChange(string start, string target) {\\n        if(start.size()!=target.size()) return false;\\n        stack<int> st1, st2;\\n        for(int i=0; i<start.size(); i++){\\n            if(start[i]!=\\'_\\') st1.push(start[i]);\\n            if(target[i]!=\\'_\\') st2.push(target[i]);\\n        }\\n        if(st1.size()!=st2.size()) return false;\\n        while(st1.empty()==false){\\n            if(st1.top()!=st2.top()) return false;\\n            st1.pop();\\n            st2.pop();\\n        }\\n        //l can be in left index as compared to start\\n        //r can be in right index as compared to start\\n        vector<int> lefts, rights, leftt, rightt;\\n        for(int i=0; i<start.size(); i++){\\n            if(start[i]==\\'L\\') lefts.push_back(i);\\n            if(target[i]==\\'L\\') leftt.push_back(i);\\n            if(start[i]==\\'R\\') rights.push_back(i);\\n            if(target[i]==\\'R\\') rightt.push_back(i);\\n        }\\n        for(int i=0; i<lefts.size(); i++){\\n            if(lefts[i]<leftt[i]) return false;\\n        }\\n        for(int i=0; i<rights.size(); i++){\\n            if(rights[i]>rightt[i]) return false;\\n        }\\n        return true;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3296119,
                "title": "python-short-clean-one-pass",
                "content": "# Code\\n```\\nclass Solution:\\n    def canChange(self, start: str, target: str) -> bool:\\n        sR, tL = 0, 0\\n        for a, b in zip(start, target):\\n            if a == \"R\":\\n                sR += 1\\n            if b == \"L\":\\n                tL -= 1\\n            if sR != 0 and tL != 0:\\n                return False\\n            if b == \"R\":\\n                sR -= 1\\n                if sR < 0:\\n                    return False\\n            if a == \"L\":\\n                tL += 1\\n                if tL > 0:\\n                    return False\\n        return sR == tL == 0\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canChange(self, start: str, target: str) -> bool:\\n        sR, tL = 0, 0\\n        for a, b in zip(start, target):\\n            if a == \"R\":\\n                sR += 1\\n            if b == \"L\":\\n                tL -= 1\\n            if sR != 0 and tL != 0:\\n                return False\\n            if b == \"R\":\\n                sR -= 1\\n                if sR < 0:\\n                    return False\\n            if a == \"L\":\\n                tL += 1\\n                if tL > 0:\\n                    return False\\n        return sR == tL == 0\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3275347,
                "title": "c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canChange(string start, string target) \\n    {\\n        bool ans= true;\\n        int ind1=0;\\n        int ind2=0;\\n        int n=start.size();\\n        while(ind1<n && ind2<n)\\n        {\\n            while(ind1<n && start[ind1]==\\'_\\')\\n            ind1++;\\n             while(ind2<n && target[ind2]==\\'_\\')\\n            ind2++;\\n            if (ind1==n &&ind2==n) return true;\\n            else if (ind1==n || ind2==n ||start[ind1]!=target[ind2]) return false;\\n            else if (start[ind1]==\\'L\\')\\n            {\\n                if (ind1<ind2) return false;\\n            }\\n            else{\\n                if (ind1>ind2) return false;\\n            }\\n            ind1++;\\n            ind2++;\\n        }\\n        while(ind1<n && start[ind1]==\\'_\\') ind1++;\\n        while(ind2<n && target[ind2]==\\'_\\') ind2++;\\n        if (ind1==n && ind2==n)\\n        return true;\\n        return false;\\n    };\\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canChange(string start, string target) \\n    {\\n        bool ans= true;\\n        int ind1=0;\\n        int ind2=0;\\n        int n=start.size();\\n        while(ind1<n && ind2<n)\\n        {\\n            while(ind1<n && start[ind1]==\\'_\\')\\n            ind1++;\\n             while(ind2<n && target[ind2]==\\'_\\')\\n            ind2++;\\n            if (ind1==n &&ind2==n) return true;\\n            else if (ind1==n || ind2==n ||start[ind1]!=target[ind2]) return false;\\n            else if (start[ind1]==\\'L\\')\\n            {\\n                if (ind1<ind2) return false;\\n            }\\n            else{\\n                if (ind1>ind2) return false;\\n            }\\n            ind1++;\\n            ind2++;\\n        }\\n        while(ind1<n && start[ind1]==\\'_\\') ind1++;\\n        while(ind2<n && target[ind2]==\\'_\\') ind2++;\\n        if (ind1==n && ind2==n)\\n        return true;\\n        return false;\\n    };\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3274093,
                "title": "c-two-passes",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canChange(string start, string target) {\\n        \\n        string s = start;\\n        string t = target;\\n\\n        int s_i = 0;\\n        int t_i = 0;\\n        while(s_i < s.size() && t_i < t.size()){\\n            if(s[s_i] == t[t_i]){\\n                s_i++;\\n                t_i++;\\n            }\\n            else if(s[s_i] == \\'R\\'){\\n                s_i++;\\n            }\\n            else if(t[t_i] == \\'R\\'){\\n                t_i++;\\n            }\\n            else if(s[s_i] == \\'L\\') return false;\\n\\n            else if(s[s_i] == \\'_\\'){\\n                int i = s_i;\\n                while(s_i < s.size() && s[s_i] == \\'_\\') s_i++;\\n                if(s_i == s.size() || s[s_i] == \\'R\\') return false;\\n                if(s[s_i] == \\'L\\'){\\n                    swap(s[s_i], s[i]);\\n                    s_i = i + 1;\\n                    t_i++;\\n                }\\n            }\\n\\n        }\\n        s_i = t_i = s.size()-1;\\n        while(s_i >= 0 && t_i >= 0){\\n            if(s[s_i] == t[t_i]){\\n                s_i--;\\n                t_i--;\\n            }\\n            else if(s[s_i] == \\'L\\'){\\n                s_i--;\\n            }\\n            else if(t[t_i] == \\'L\\'){\\n                t_i--;\\n            }\\n            else if(s[s_i] == \\'R\\') return false;\\n            else if(s[s_i] == \\'_\\'){\\n                int i = s_i;\\n                while(s_i >= 0 && s[s_i] == \\'_\\') s_i--;\\n                if(s_i == -1 || s[s_i] == \\'L\\') return false;\\n                if(s[s_i] == \\'R\\'){\\n                    swap(s[s_i], s[i]);\\n                    s_i = i - 1;\\n                    t_i--;\\n                }\\n            }\\n            \\n        }\\n        return s == t;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canChange(string start, string target) {\\n        \\n        string s = start;\\n        string t = target;\\n\\n        int s_i = 0;\\n        int t_i = 0;\\n        while(s_i < s.size() && t_i < t.size()){\\n            if(s[s_i] == t[t_i]){\\n                s_i++;\\n                t_i++;\\n            }\\n            else if(s[s_i] == \\'R\\'){\\n                s_i++;\\n            }\\n            else if(t[t_i] == \\'R\\'){\\n                t_i++;\\n            }\\n            else if(s[s_i] == \\'L\\') return false;\\n\\n            else if(s[s_i] == \\'_\\'){\\n                int i = s_i;\\n                while(s_i < s.size() && s[s_i] == \\'_\\') s_i++;\\n                if(s_i == s.size() || s[s_i] == \\'R\\') return false;\\n                if(s[s_i] == \\'L\\'){\\n                    swap(s[s_i], s[i]);\\n                    s_i = i + 1;\\n                    t_i++;\\n                }\\n            }\\n\\n        }\\n        s_i = t_i = s.size()-1;\\n        while(s_i >= 0 && t_i >= 0){\\n            if(s[s_i] == t[t_i]){\\n                s_i--;\\n                t_i--;\\n            }\\n            else if(s[s_i] == \\'L\\'){\\n                s_i--;\\n            }\\n            else if(t[t_i] == \\'L\\'){\\n                t_i--;\\n            }\\n            else if(s[s_i] == \\'R\\') return false;\\n            else if(s[s_i] == \\'_\\'){\\n                int i = s_i;\\n                while(s_i >= 0 && s[s_i] == \\'_\\') s_i--;\\n                if(s_i == -1 || s[s_i] == \\'L\\') return false;\\n                if(s[s_i] == \\'R\\'){\\n                    swap(s[s_i], s[i]);\\n                    s_i = i - 1;\\n                    t_i--;\\n                }\\n            }\\n            \\n        }\\n        return s == t;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3265064,
                "title": "easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canChange(string start, string target) {\\n            // Check if start and target have the same number of \\'L\\' and \\'R\\' pieces\\n    int L_count_start = count(start.begin(), start.end(), \\'L\\');\\n    int R_count_start = count(start.begin(), start.end(), \\'R\\');\\n    int L_count_target = count(target.begin(), target.end(), \\'L\\');\\n    int R_count_target = count(target.begin(), target.end(), \\'R\\');\\n    if (L_count_start != L_count_target || R_count_start != R_count_target) {\\n        return false;\\n    }\\n    \\n    // Check if the pieces in start can be moved to obtain target\\n    int n = start.size();\\n    int i = 0, j = 0;\\n    while (i < n && j < n) {\\n        while (i < n && start[i] == \\'_\\') {\\n            i++;\\n        }\\n        while (j < n && target[j] == \\'_\\') {\\n            j++;\\n        }\\n        if (i == n || j == n) {\\n            break;\\n        }\\n        if (start[i] != target[j]) {\\n            return false;\\n        }\\n        if (start[i] == \\'L\\' && i < j) {\\n            return false;\\n        }\\n        if (start[i] == \\'R\\' && i > j) {\\n            return false;\\n        }\\n        i++;\\n        j++;\\n    }\\n    return true;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canChange(string start, string target) {\\n            // Check if start and target have the same number of \\'L\\' and \\'R\\' pieces\\n    int L_count_start = count(start.begin(), start.end(), \\'L\\');\\n    int R_count_start = count(start.begin(), start.end(), \\'R\\');\\n    int L_count_target = count(target.begin(), target.end(), \\'L\\');\\n    int R_count_target = count(target.begin(), target.end(), \\'R\\');\\n    if (L_count_start != L_count_target || R_count_start != R_count_target) {\\n        return false;\\n    }\\n    \\n    // Check if the pieces in start can be moved to obtain target\\n    int n = start.size();\\n    int i = 0, j = 0;\\n    while (i < n && j < n) {\\n        while (i < n && start[i] == \\'_\\') {\\n            i++;\\n        }\\n        while (j < n && target[j] == \\'_\\') {\\n            j++;\\n        }\\n        if (i == n || j == n) {\\n            break;\\n        }\\n        if (start[i] != target[j]) {\\n            return false;\\n        }\\n        if (start[i] == \\'L\\' && i < j) {\\n            return false;\\n        }\\n        if (start[i] == \\'R\\' && i > j) {\\n            return false;\\n        }\\n        i++;\\n        j++;\\n    }\\n    return true;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3248830,
                "title": "c-golang-two-pointers",
                "content": "# Code\\n```\\n// C++\\nclass Solution {\\npublic:\\n    bool canChange(string start, string target) {\\n        int n = start.size(), i = 0, j = 0;\\n        while(i < n || j < n) {\\n            while(i < n && target[i] == \\'_\\') i++;\\n            while(j < n && start[j] == \\'_\\') j++;\\n            if(i == n || j == n) break;\\n            if(start[j] != target[i]) break;\\n            if(start[j] == \\'L\\' && j < i) break;\\n            if(start[j] == \\'R\\' && j > i) break;\\n            i++; j++;\\n        }\\n        return i == n && j == n;\\n    }\\n};\\n\\n\\n// Golang\\nfunc canChange(start string, target string) bool {\\n    var n, i, j int = len(start), 0, 0\\n    for i < n || j < n {\\n        for i < n && target[i] == \\'_\\' {i++}\\n        for j < n && start[j] == \\'_\\' {j++}\\n        if i == n || j == n {break}\\n        if start[j] != target[i] {break}\\n        if start[j] == \\'L\\' && j < i {break}\\n        if start[j] == \\'R\\' && j > i {break}\\n        i++ \\n        j++\\n    }\\n    return i == n && j == n\\n}\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n// C++\\nclass Solution {\\npublic:\\n    bool canChange(string start, string target) {\\n        int n = start.size(), i = 0, j = 0;\\n        while(i < n || j < n) {\\n            while(i < n && target[i] == \\'_\\') i++;\\n            while(j < n && start[j] == \\'_\\') j++;\\n            if(i == n || j == n) break;\\n            if(start[j] != target[i]) break;\\n            if(start[j] == \\'L\\' && j < i) break;\\n            if(start[j] == \\'R\\' && j > i) break;\\n            i++; j++;\\n        }\\n        return i == n && j == n;\\n    }\\n};\\n\\n\\n// Golang\\nfunc canChange(start string, target string) bool {\\n    var n, i, j int = len(start), 0, 0\\n    for i < n || j < n {\\n        for i < n && target[i] == \\'_\\' {i++}\\n        for j < n && start[j] == \\'_\\' {j++}\\n        if i == n || j == n {break}\\n        if start[j] != target[i] {break}\\n        if start[j] == \\'L\\' && j < i {break}\\n        if start[j] == \\'R\\' && j > i {break}\\n        i++ \\n        j++\\n    }\\n    return i == n && j == n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3233597,
                "title": "very-intutuve-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: **O(n)**\\n\\n- Space complexity: **O(n)**\\n\\n# Code\\n```\\nclass Solution:\\n    def canChange(self, start: str, target: str) -> bool:\\n        \\n        start = list(start)\\n        target = list(target)\\n\\n        lastMatch = -1\\n        for i in range(len(target)):\\n            if target[i] == \\'L\\':\\n                for j in range(max(i, lastMatch+1), len(start)):\\n                    if start[j] == \\'L\\':\\n                        start[i], start[j] = start[j], start[i]\\n                        lastMatch = j\\n                        break\\n                    elif start[j] == \\'R\\':\\n                        return False\\n                else:\\n                    return False\\n\\n        lastMatch = len(start)\\n        for i in range(len(target)-1, -1, -1):\\n            if target[i] == \\'R\\':\\n                for j in range(min(i, lastMatch+1), -1, -1):\\n                    if start[j] == \\'R\\': \\n                        start[i], start[j] = start[j], start[i]\\n                        lastMatch = j\\n                        break\\n\\n                    elif start[j] == \\'L\\':\\n                        return False\\n                else:\\n                    return False\\n\\n        return start == target\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canChange(self, start: str, target: str) -> bool:\\n        \\n        start = list(start)\\n        target = list(target)\\n\\n        lastMatch = -1\\n        for i in range(len(target)):\\n            if target[i] == \\'L\\':\\n                for j in range(max(i, lastMatch+1), len(start)):\\n                    if start[j] == \\'L\\':\\n                        start[i], start[j] = start[j], start[i]\\n                        lastMatch = j\\n                        break\\n                    elif start[j] == \\'R\\':\\n                        return False\\n                else:\\n                    return False\\n\\n        lastMatch = len(start)\\n        for i in range(len(target)-1, -1, -1):\\n            if target[i] == \\'R\\':\\n                for j in range(min(i, lastMatch+1), -1, -1):\\n                    if start[j] == \\'R\\': \\n                        start[i], start[j] = start[j], start[i]\\n                        lastMatch = j\\n                        break\\n\\n                    elif start[j] == \\'L\\':\\n                        return False\\n                else:\\n                    return False\\n\\n        return start == target\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3208024,
                "title": "scala-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nobject Solution {\\n    def canChange(start: String, target: String): Boolean = {\\n        if(start.filter(_ != \\'_\\') != target.filter(_ != \\'_\\')) return false\\n        (start.zipWithIndex.filter(_._1 ==\\'L\\').map(_._2) zip target.zipWithIndex.filter(_._1 ==\\'L\\').map(_._2)).forall(n => n._2 <= n._1) &&\\n        (start.zipWithIndex.filter(_._1 ==\\'R\\').map(_._2) zip target.zipWithIndex.filter(_._1 ==\\'R\\').map(_._2)).forall(n => n._2 >= n._1)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n    def canChange(start: String, target: String): Boolean = {\\n        if(start.filter(_ != \\'_\\') != target.filter(_ != \\'_\\')) return false\\n        (start.zipWithIndex.filter(_._1 ==\\'L\\').map(_._2) zip target.zipWithIndex.filter(_._1 ==\\'L\\').map(_._2)).forall(n => n._2 <= n._1) &&\\n        (start.zipWithIndex.filter(_._1 ==\\'R\\').map(_._2) zip target.zipWithIndex.filter(_._1 ==\\'R\\').map(_._2)).forall(n => n._2 >= n._1)\\n    }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3136642,
                "title": "javascript-100-runtime-easy-one-line",
                "content": "```\\nconst canChange = (s, t) =>\\n  !(\\n    s.lastIndexOf(\"L\") < t.lastIndexOf(\"L\") ||\\n    s.indexOf(\"L\") < t.indexOf(\"L\") ||\\n    s.lastIndexOf(\"R\") > t.lastIndexOf(\"R\") ||\\n    s.indexOf(\"R\") > t.indexOf(\"R\") ||\\n    s.replaceAll(\"_\", \"\") !== t.replaceAll(\"_\", \"\")\\n  );\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst canChange = (s, t) =>\\n  !(\\n    s.lastIndexOf(\"L\") < t.lastIndexOf(\"L\") ||\\n    s.indexOf(\"L\") < t.indexOf(\"L\") ||\\n    s.lastIndexOf(\"R\") > t.lastIndexOf(\"R\") ||\\n    s.indexOf(\"R\") > t.indexOf(\"R\") ||\\n    s.replaceAll(\"_\", \"\") !== t.replaceAll(\"_\", \"\")\\n  );\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3057797,
                "title": "2-pointers-c",
                "content": "````\\nclass Solution {\\npublic:\\n    bool canChange(string start, string target) {\\n        int n = start.size();\\n        int i=0,j=0;\\n        while(i < n and j < n){\\n            while(i < n and start[i] == \\'_\\') i++;\\n            while(j < n and target[j] == \\'_\\') j++;\\n            \\n            if(i == n or j == n) break; \\n            if(start[i] != target[j]) break; \\n            if(i < j and start[i] == \\'L\\') break;\\n            if(i > j and start[i] == \\'R\\') break;\\n            \\n            i++,j++;\\n        }\\n        return i == n and j == n;\\n    }\\n};\\n````",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "````\\nclass Solution {\\npublic:\\n    bool canChange(string start, string target) {\\n        int n = start.size();\\n        int i=0,j=0;\\n        while(i < n and j < n){\\n            while(i < n and start[i] == \\'_\\') i++;\\n            while(j < n and target[j] == \\'_\\') j++;\\n            \\n            if(i == n or j == n) break; \\n            if(start[i] != target[j]) break; \\n            if(i < j and start[i] == \\'L\\') break;\\n            if(i > j and start[i] == \\'R\\') break;\\n            \\n            i++,j++;\\n        }\\n        return i == n and j == n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3009959,
                "title": "python3-solution-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAnswer is False in one of the following conditions: \\n\\n    - number of L & R in start  != number of L&R in target \\n    - Order is different \\n    - L in target > L in Start \\n    - R in target < R in Start\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(2*n) ~= O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def canChange(self, start: str, target: str) -> bool:\\n        n = len(start)\\n        if start.count(\\'L\\')!= target.count(\\'L\\') or start.count(\\'R\\') != target.count(\\'R\\'):\\n            return False\\n        start_letters , target_letters = self.get_letters_indices(start),self.get_letters_indices(target)\\n        for (s_char, s_idx), (t_char, t_idx) in zip(start_letters,target_letters):\\n            if s_char != t_char:\\n                return False\\n            if s_char==\\'L\\' and t_idx > s_idx:\\n                return False\\n            if s_char ==\\'R\\' and t_idx < s_idx:\\n                return False\\n        return True\\n\\n\\n    ## returns array of tuples of characters and their indices\\n    def get_letters_indices(self,word:str)-> list[(str,int)]:\\n        result = []\\n        for (i,w) in enumerate(word): \\n            if w!=\\'_\\':\\n                result.append((w,i))\\n        return result\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canChange(self, start: str, target: str) -> bool:\\n        n = len(start)\\n        if start.count(\\'L\\')!= target.count(\\'L\\') or start.count(\\'R\\') != target.count(\\'R\\'):\\n            return False\\n        start_letters , target_letters = self.get_letters_indices(start),self.get_letters_indices(target)\\n        for (s_char, s_idx), (t_char, t_idx) in zip(start_letters,target_letters):\\n            if s_char != t_char:\\n                return False\\n            if s_char==\\'L\\' and t_idx > s_idx:\\n                return False\\n            if s_char ==\\'R\\' and t_idx < s_idx:\\n                return False\\n        return True\\n\\n\\n    ## returns array of tuples of characters and their indices\\n    def get_letters_indices(self,word:str)-> list[(str,int)]:\\n        result = []\\n        for (i,w) in enumerate(word): \\n            if w!=\\'_\\':\\n                result.append((w,i))\\n        return result\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2998156,
                "title": "python-loop-o-n-explanation",
                "content": "The Logic:\\nIf someone wants a detailed explanation, please go here. It is very well explained and helped me understand how to approach it and similar tasks.\\n\\nFirst, you can observe, that `L` can be moved to the left in the string `start` and `R` to the right.\\n\\nSecond, you need to analyze how the valid strings should look: basically, the relative order of `R` and `L` is matter.\\n\\nThe order of `R` and `L` appearance in the stings. When you loop both strings, you skip `_` and the next non-`_` symbols should be the same.\\nTheir relative positions. L in `start` should have an index larger or equal to the corresponding index of `L` in `target`. It is because L can be moved left in the `start`. A similar thing applies to `R`.\\nNumber of `_`, `R`, and `L` should be the same. Thus I return `return i == j` at the end.\\nOnce you understand it, the task looks much easier.\\n\\n```\\nclass Solution:\\n    def canChange(self, start: str, target: str) -> bool:\\n        i, j = 0, 0\\n        while i < len(start) or j < len(target):\\n            \\n            while i < len(start) and start[i] == \\'_\\':\\n                i += 1\\n            while j < len(target) and target[j] == \\'_\\':\\n                j += 1\\n            \\n            if i == len(start) or j == len(target):\\n                break\\n            \\n            if start[i] != target[j]:\\n                return False\\n            \\n            if start[i] == \\'L\\' and j > i:\\n                return False\\n            \\n            if start[i] == \\'R\\' and j < i:\\n                return False\\n            \\n            i += 1\\n            j += 1\\n        \\n        return i == j\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def canChange(self, start: str, target: str) -> bool:\\n        i, j = 0, 0\\n        while i < len(start) or j < len(target):\\n            \\n            while i < len(start) and start[i] == \\'_\\':\\n                i += 1\\n            while j < len(target) and target[j] == \\'_\\':\\n                j += 1\\n            \\n            if i == len(start) or j == len(target):\\n                break\\n            \\n            if start[i] != target[j]:\\n                return False\\n            \\n            if start[i] == \\'L\\' and j > i:\\n                return False\\n            \\n            if start[i] == \\'R\\' and j < i:\\n                return False\\n            \\n            i += 1\\n            j += 1\\n        \\n        return i == j\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2988524,
                "title": "java-just-iterate-o-n",
                "content": "# Code\\n```\\nclass Solution {\\n    public boolean canChange(String start, String target) {\\n        char[] schar = start.toCharArray();\\n        char[] tchar = target.toCharArray();\\n        int s = 0, t = 0;\\n        while (s < schar.length || t < tchar.length) {\\n            while (s < schar.length && schar[s] == \\'_\\') s++;\\n            while (t < tchar.length && tchar[t] == \\'_\\') t++;\\n            char sch = s < schar.length? schar[s] : \\' \\';\\n            char tch = t < tchar.length? tchar[t] : \\' \\';\\n            if (sch != tch) return false;\\n            if (tch == \\'R\\' && s > t) return false;\\n            if (tch == \\'L\\' && s < t) return false;\\n            s++; t++;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canChange(String start, String target) {\\n        char[] schar = start.toCharArray();\\n        char[] tchar = target.toCharArray();\\n        int s = 0, t = 0;\\n        while (s < schar.length || t < tchar.length) {\\n            while (s < schar.length && schar[s] == \\'_\\') s++;\\n            while (t < tchar.length && tchar[t] == \\'_\\') t++;\\n            char sch = s < schar.length? schar[s] : \\' \\';\\n            char tch = t < tchar.length? tchar[t] : \\' \\';\\n            if (sch != tch) return false;\\n            if (tch == \\'R\\' && s > t) return false;\\n            if (tch == \\'L\\' && s < t) return false;\\n            s++; t++;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2968863,
                "title": "java-o-1-same-as-lc777",
                "content": "credit to @wisdompeak\\n\\n```\\nclass Solution {\\n    public boolean canChange(String start, String target) {\\n        int j = 0;\\n        \\n        \\n        for(int i = 0; i < start.length(); i++){\\n            if(start.charAt(i) == \\'_\\') continue;\\n            \\n            while(j < target.length() && target.charAt(j) == \\'_\\' ){\\n                j++;\\n            }\\n            if(j == target.length()) return false;\\n            \\n            if(start.charAt(i) != target.charAt(j)){\\n                 return false;\\n            }\\n            \\n            if(start.charAt(i) == \\'L\\' && j > i){\\n                return false;\\n            }\\n            \\n            if(start.charAt(i) == \\'R\\' && j < i){\\n                return false;\\n            }\\n            \\n            j++;\\n            \\n            \\n        }\\n        \\n        for(int k = j; k < target.length(); k++){\\n            if(target.charAt(k) != \\'_\\'){\\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean canChange(String start, String target) {\\n        int j = 0;\\n        \\n        \\n        for(int i = 0; i < start.length(); i++){\\n            if(start.charAt(i) == \\'_\\') continue;\\n            \\n            while(j < target.length() && target.charAt(j) == \\'_\\' ){\\n                j++;\\n            }\\n            if(j == target.length()) return false;\\n            \\n            if(start.charAt(i) != target.charAt(j)){\\n                 return false;\\n            }\\n            \\n            if(start.charAt(i) == \\'L\\' && j > i){\\n                return false;\\n            }\\n            \\n            if(start.charAt(i) == \\'R\\' && j < i){\\n                return false;\\n            }\\n            \\n            j++;\\n            \\n            \\n        }\\n        \\n        for(int k = j; k < target.length(); k++){\\n            if(target.charAt(k) != \\'_\\'){\\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2943528,
                "title": "o-n-very-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\njust compare both the strings and if the character does not matches than check for all three conditions i.e. the target[i] can be L, R, _.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canChange(string s, string t) {\\n        int n = s.size();\\n        for(int i=0;i<n;i++){\\n            if(s[i]==t[i]) continue;\\n            if(t[i]==\\'L\\'){\\n                if(s[i]==\\'_\\'){\\n                    int j=i+1;\\n                    while(j<n and s[j]==\\'_\\') j++;\\n                    if(s[j]==\\'R\\' or j>=n) return false;\\n                    else swap(s[i],s[j]);\\n                }\\n                if(s[i]==\\'R\\') return false;\\n            }\\n            else if(t[i]==\\'R\\') return false;\\n            else {\\n                if(s[i]==\\'L\\') return false;\\n                if(s[i]==\\'R\\'){\\n                    int j=i+1;\\n                    while(j<n and s[j]==\\'R\\'){\\n                        j++;\\n                    }\\n                    if(s[j]==\\'L\\' or j>=n) return false;\\n                    else swap(s[i],s[j]);\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canChange(string s, string t) {\\n        int n = s.size();\\n        for(int i=0;i<n;i++){\\n            if(s[i]==t[i]) continue;\\n            if(t[i]==\\'L\\'){\\n                if(s[i]==\\'_\\'){\\n                    int j=i+1;\\n                    while(j<n and s[j]==\\'_\\') j++;\\n                    if(s[j]==\\'R\\' or j>=n) return false;\\n                    else swap(s[i],s[j]);\\n                }\\n                if(s[i]==\\'R\\') return false;\\n            }\\n            else if(t[i]==\\'R\\') return false;\\n            else {\\n                if(s[i]==\\'L\\') return false;\\n                if(s[i]==\\'R\\'){\\n                    int j=i+1;\\n                    while(j<n and s[j]==\\'R\\'){\\n                        j++;\\n                    }\\n                    if(s[j]==\\'L\\' or j>=n) return false;\\n                    else swap(s[i],s[j]);\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2887757,
                "title": "simple-o-n-approach-using-stacks",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canChange(string s, string t) {\\n        stack<int> ind;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'R\\'){\\n                if(t[i]==\\'L\\')\\n                    return 0;\\n                if(t[i]==\\'_\\')\\n                    ind.push(i);\\n            }\\n            \\n            if(t[i]==\\'R\\' and s[i]==\\'_\\'){\\n                if(ind.size()==0)\\n                    return 0;\\n                s[ind.top()]=\\'_\\';\\n                ind.pop();\\n                s[i]=\\'R\\';\\n            }\\n            \\n            if(s[i]==\\'L\\')\\n                if(ind.size())\\n                    return 0;\\n        }\\n        \\n        if(ind.size())\\n            return 0;\\n        \\n        for(int i=s.length()-1;i>=0;i--){\\n            if(s[i]==\\'L\\'){\\n                if(t[i]==\\'R\\')\\n                    return 0;\\n                if(t[i]==\\'_\\')\\n                    ind.push(i);\\n            }\\n            \\n            if(t[i]==\\'L\\' and s[i]==\\'_\\'){\\n                if(ind.size()==0)\\n                    return 0;\\n                s[ind.top()]=\\'_\\';\\n                ind.pop();\\n                s[i]=\\'L\\';\\n            }\\n            \\n            if(s[i]==\\'R\\')\\n                if(ind.size())\\n                    return 0;\\n        }\\n        \\n        if(ind.size())\\n            return 0;\\n        \\n        return s==t;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canChange(string s, string t) {\\n        stack<int> ind;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'R\\'){\\n                if(t[i]==\\'L\\')\\n                    return 0;\\n                if(t[i]==\\'_\\')\\n                    ind.push(i);\\n            }\\n            \\n            if(t[i]==\\'R\\' and s[i]==\\'_\\'){\\n                if(ind.size()==0)\\n                    return 0;\\n                s[ind.top()]=\\'_\\';\\n                ind.pop();\\n                s[i]=\\'R\\';\\n            }\\n            \\n            if(s[i]==\\'L\\')\\n                if(ind.size())\\n                    return 0;\\n        }\\n        \\n        if(ind.size())\\n            return 0;\\n        \\n        for(int i=s.length()-1;i>=0;i--){\\n            if(s[i]==\\'L\\'){\\n                if(t[i]==\\'R\\')\\n                    return 0;\\n                if(t[i]==\\'_\\')\\n                    ind.push(i);\\n            }\\n            \\n            if(t[i]==\\'L\\' and s[i]==\\'_\\'){\\n                if(ind.size()==0)\\n                    return 0;\\n                s[ind.top()]=\\'_\\';\\n                ind.pop();\\n                s[i]=\\'L\\';\\n            }\\n            \\n            if(s[i]==\\'R\\')\\n                if(ind.size())\\n                    return 0;\\n        }\\n        \\n        if(ind.size())\\n            return 0;\\n        \\n        return s==t;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2879030,
                "title": "c",
                "content": "```\\nbool canChange(char * start, char * target){\\n    int n1 = strlen(start);\\n    int n2 = strlen(target);\\n    if(n1 != n2)\\n        return false;\\n    int begin = 0;\\n    for(int i = 0; i < n1; i++){\\n        if(target[i] == \\'_\\')\\n            continue;\\n        if(target[i] == \\'L\\'){\\n            if(begin == n1)\\n                return false;\\n            for(int j = begin; j < n1; j++){\\n                if(start[j] == \\'R\\')\\n                    return false;\\n                else if(start[j] == \\'L\\'){\\n                    if(j < i)\\n                        return false;\\n                    begin = j + 1;\\n                    break;\\n                }\\n                if(j == n1-1)\\n                    return false;\\n            }\\n        }\\n        else if(target[i] == \\'R\\'){\\n            if(begin == n1)\\n                return false;\\n            for(int j = begin; j < n1; j++){\\n                if(start[j] == \\'L\\')\\n                    return false;\\n                else if(start[j] == \\'R\\'){\\n                    if(i < j)\\n                        return false;\\n                    begin = j + 1;\\n                    break;\\n                }\\n                if(j == n1-1)\\n                    return false;\\n            }\\n        }\\n    }\\n    for(int k = begin; k < n1; k++){\\n        if(start[k] == \\'L\\' || start[k] == \\'R\\')\\n            return false;\\n    }\\n    return true;\\n\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nbool canChange(char * start, char * target){\\n    int n1 = strlen(start);\\n    int n2 = strlen(target);\\n    if(n1 != n2)\\n        return false;\\n    int begin = 0;\\n    for(int i = 0; i < n1; i++){\\n        if(target[i] == \\'_\\')\\n            continue;\\n        if(target[i] == \\'L\\'){\\n            if(begin == n1)\\n                return false;\\n            for(int j = begin; j < n1; j++){\\n                if(start[j] == \\'R\\')\\n                    return false;\\n                else if(start[j] == \\'L\\'){\\n                    if(j < i)\\n                        return false;\\n                    begin = j + 1;\\n                    break;\\n                }\\n                if(j == n1-1)\\n                    return false;\\n            }\\n        }\\n        else if(target[i] == \\'R\\'){\\n            if(begin == n1)\\n                return false;\\n            for(int j = begin; j < n1; j++){\\n                if(start[j] == \\'L\\')\\n                    return false;\\n                else if(start[j] == \\'R\\'){\\n                    if(i < j)\\n                        return false;\\n                    begin = j + 1;\\n                    break;\\n                }\\n                if(j == n1-1)\\n                    return false;\\n            }\\n        }\\n    }\\n    for(int k = begin; k < n1; k++){\\n        if(start[k] == \\'L\\' || start[k] == \\'R\\')\\n            return false;\\n    }\\n    return true;\\n\\n}\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1577005,
                "content": [
                    {
                        "username": "sumer47kumar",
                        "content": "Just replace  \"_\"  with \"X\"\\nand follow\\n[777. Swap Adjacent in LR String](https://leetcode.com/problems/swap-adjacent-in-lr-string/)"
                    },
                    {
                        "username": "wenwendududu",
                        "content": "THis is a intersting questions that has toooooo much  edge cases that like :\\n\\nStart : \"_ _ L L\"\\nTarget : \"L L _ _\"\\n\\nFrom the description, if the second \\'L\\' \\'s direct left is not \"_\", so it cannot move. But the case shows the result is true.\\n\\nAny suggestion or comments about the test case?"
                    },
                    {
                        "username": "KevinJM17",
                        "content": "Here\\'s how the working would look like\\n_ _ L L\\n_ L  _ L\\nL _ _ L\\nL _ L _\\nL L _ _"
                    }
                ]
            },
            {
                "id": 1577006,
                "content": [
                    {
                        "username": "sumer47kumar",
                        "content": "Just replace  \"_\"  with \"X\"\\nand follow\\n[777. Swap Adjacent in LR String](https://leetcode.com/problems/swap-adjacent-in-lr-string/)"
                    },
                    {
                        "username": "wenwendududu",
                        "content": "THis is a intersting questions that has toooooo much  edge cases that like :\\n\\nStart : \"_ _ L L\"\\nTarget : \"L L _ _\"\\n\\nFrom the description, if the second \\'L\\' \\'s direct left is not \"_\", so it cannot move. But the case shows the result is true.\\n\\nAny suggestion or comments about the test case?"
                    },
                    {
                        "username": "KevinJM17",
                        "content": "Here\\'s how the working would look like\\n_ _ L L\\n_ L  _ L\\nL _ _ L\\nL _ L _\\nL L _ _"
                    }
                ]
            }
        ]
    },
    {
        "title": "Number of Zero-Filled Subarrays",
        "question_content": "<p>Given an integer array <code>nums</code>, return <em>the number of <strong>subarrays</strong> filled with </em><code>0</code>.</p>\n\n<p>A <strong>subarray</strong> is a contiguous non-empty sequence of elements within an array.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,3,0,0,2,0,0,4]\n<strong>Output:</strong> 6\n<strong>Explanation:</strong> \nThere are 4 occurrences of [0] as a subarray.\nThere are 2 occurrences of [0,0] as a subarray.\nThere is no occurrence of a subarray with a size more than 2 filled with 0. Therefore, we return 6.</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [0,0,0,2,0,0]\n<strong>Output:</strong> 9\n<strong>Explanation:\n</strong>There are 5 occurrences of [0] as a subarray.\nThere are 3 occurrences of [0,0] as a subarray.\nThere is 1 occurrence of [0,0,0] as a subarray.\nThere is no occurrence of a subarray with a size more than 3 filled with 0. Therefore, we return 9.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [2,10,2019]\n<strong>Output:</strong> 0\n<strong>Explanation:</strong> There is no subarray filled with 0. Therefore, we return 0.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-10<sup>9</sup> &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 3321942,
                "title": "python-simple-solution-easy-to-understand",
                "content": "# Please UPVOTE \\uD83D\\uDC4D\\n\\n**!! BIG ANNOUNCEMENT !!**\\nI am Giving away my premium content videos related to computer science and data science and also will be sharing well-structured assignments and study materials to clear interviews at top companies to my first 1000 Subscribers. So, **DON\\'T FORGET** to Subscribe\\n\\nClick Here to Subscribe \\uD83D\\uDC49 https://www.youtube.com/@techwired8/?sub_confirmation=1\\n\\n**Solution Video Search \\uD83D\\uDC49 \"Number of Zero-Filled Subarrays by Tech Wired leetcode\" on YouTube**\\n\\n![Yellow & Black Earn Money YouTube Thumbnail (55).png](https://assets.leetcode.com/users/images/7ffb9146-a9f9-4431-b082-05a1a6edd401_1679364474.7893207.png)\\n\\n\\n```\\nclass Solution:\\n    def zeroFilledSubarray(self, nums: List[int]) -> int:\\n        total_zero_subarrays = current_zero_subarrays = 0\\n                \\n        for num in nums:\\n            if num == 0:\\n                current_zero_subarrays += 1\\n                total_zero_subarrays += current_zero_subarrays\\n            else:\\n                current_zero_subarrays = 0\\n                \\n        return total_zero_subarrays\\n\\n```\\n![image.png](https://assets.leetcode.com/users/images/e2515d84-99cf-4499-80fb-fe458e1bbae2_1678932606.8004954.png)\\n\\n# Please UPVOTE \\uD83D\\uDC4D",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array"
                ],
                "code": "```\\nclass Solution:\\n    def zeroFilledSubarray(self, nums: List[int]) -> int:\\n        total_zero_subarrays = current_zero_subarrays = 0\\n                \\n        for num in nums:\\n            if num == 0:\\n                current_zero_subarrays += 1\\n                total_zero_subarrays += current_zero_subarrays\\n            else:\\n                current_zero_subarrays = 0\\n                \\n        return total_zero_subarrays\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2322338,
                "title": "two-pointers",
                "content": "We count consequitive zeros `(i - j + 1)`.\\n\\nFor each zero, we add `(i - j + 1)` subarrays:\\n- `0` -> +1\\n- `00` -> +2 (`_0` and `00`)\\n- `000` -> +3 (`__0`, `_00`, and `000`)\\n- and so on...\\n\\n**Java**\\n```java\\npublic long zeroFilledSubarray(int[] nums) {\\n    long res = 0;\\n    for (int i = 0, j = 0; i < nums.length; ++i) {\\n        if (nums[i] != 0)\\n            j = i + 1;\\n         res += i - j + 1;\\n    }\\n    return res;\\n}\\n```\\n**C++**\\n```cpp\\nlong long zeroFilledSubarray(vector<int>& nums) {\\n    long long res = 0;\\n    for (int i = 0, j = 0; i < nums.size(); ++i) {\\n        if (nums[i] != 0)\\n            j = i + 1;\\n         res += i - j + 1;\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```java\\npublic long zeroFilledSubarray(int[] nums) {\\n    long res = 0;\\n    for (int i = 0, j = 0; i < nums.length; ++i) {\\n        if (nums[i] != 0)\\n            j = i + 1;\\n         res += i - j + 1;\\n    }\\n    return res;\\n}\\n```\n```cpp\\nlong long zeroFilledSubarray(vector<int>& nums) {\\n    long long res = 0;\\n    for (int i = 0, j = 0; i < nums.size(); ++i) {\\n        if (nums[i] != 0)\\n            j = i + 1;\\n         res += i - j + 1;\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3321976,
                "title": "java-c-simple-solution-easy-to-understand",
                "content": "# Please UPVOTE \\uD83D\\uDC4D\\n\\n**!! BIG ANNOUNCEMENT !!**\\nI am Giving away my premium content videos related to computer science and data science and also will be sharing well-structured assignments and study materials to clear interviews at top companies to my first 1000 Subscribers. So, **DON\\'T FORGET** to Subscribe\\n\\nClick Here to Subscribe \\uD83D\\uDC49 https://www.youtube.com/@techwired8/?sub_confirmation=1\\n\\n**Solution Video Search \\uD83D\\uDC49 \"Number of Zero-Filled Subarrays by Tech Wired leetcode\" on YouTube**\\n\\n![Yellow & Black Earn Money YouTube Thumbnail (55).png](https://assets.leetcode.com/users/images/755a7522-d892-4b3c-be1c-6842a47a790d_1679364429.281386.png)\\n\\n\\n**Java:**\\n```\\n\\nclass Solution {\\n       public long zeroFilledSubarray(int[] nums) {\\n        long cnt = 0, zeroSubarraysEndingAtCurrentIndex = 0;\\n        for (int n : nums) {\\n            if (n == 0) {\\n                cnt += ++zeroSubarraysEndingAtCurrentIndex;\\n            }else {\\n                zeroSubarraysEndingAtCurrentIndex = 0;\\n            }\\n        }\\n        return cnt;\\n    }\\n\\n}\\n```\\n\\n**C++:**\\n```\\nclass Solution {\\npublic:\\n    long zeroFilledSubarray(vector<int>& nums) {\\n        long cnt = 0, zeroSubarraysEndingAtCurrentIndex = 0;\\n        for (int n : nums) {\\n            if (n == 0) {\\n                cnt += ++zeroSubarraysEndingAtCurrentIndex;\\n            } else {\\n                zeroSubarraysEndingAtCurrentIndex = 0;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n\\n```\\n![image.png](https://assets.leetcode.com/users/images/e2515d84-99cf-4499-80fb-fe458e1bbae2_1678932606.8004954.png)\\n\\n# Please UPVOTE \\uD83D\\uDC4D",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Array"
                ],
                "code": "```\\n\\nclass Solution {\\n       public long zeroFilledSubarray(int[] nums) {\\n        long cnt = 0, zeroSubarraysEndingAtCurrentIndex = 0;\\n        for (int n : nums) {\\n            if (n == 0) {\\n                cnt += ++zeroSubarraysEndingAtCurrentIndex;\\n            }else {\\n                zeroSubarraysEndingAtCurrentIndex = 0;\\n            }\\n        }\\n        return cnt;\\n    }\\n\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    long zeroFilledSubarray(vector<int>& nums) {\\n        long cnt = 0, zeroSubarraysEndingAtCurrentIndex = 0;\\n        for (int n : nums) {\\n            if (n == 0) {\\n                cnt += ++zeroSubarraysEndingAtCurrentIndex;\\n            } else {\\n                zeroSubarraysEndingAtCurrentIndex = 0;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3322969,
                "title": "from-34-to-99-images-and-hints-java-c",
                "content": "# Intuition\\nFirst properly understand the question. \\nIt says that **we need to count the subarrays filled with 0\\'s.**\\nQuestions in your head can be:\\n- Can we consider other numbers in the array?\\n No. We cannot. The description clearly says: **return the number of subarrays filled with 0.** And the subarray is **a contiguous non-empty sequence of elements**.\\n\\nSo, we can clearly see that our subarray will only contain **0**\\'s and they need to be contiguous.\\n\\nNow let\\'s think of an example. Let\\'s say we are given:\\n```\\nnums = [0]\\n```\\nOur answer will be 1. As we have count of 0 = 1.\\nIf for example:\\n```\\nnums = [0, 0]\\n```\\nOur answer will be 3.\\n**How?**\\n\\n![image.png](https://assets.leetcode.com/users/images/b4a7fe58-3b26-40d1-8c21-cb4de5ee0e69_1679376615.5399365.png)\\n\\nIf the example was:\\n\\n```\\nnums = [0, 0, 0]\\n```\\n\\n![image.png](https://assets.leetcode.com/users/images/6dda2e7f-1c35-4028-bfaa-8b4d2a171b44_1679376800.4900432.png)\\n\\nSo, far we have shown only the zeroes. Now suppose for a real example.\\nFor Example 2:\\n\\n```\\nnums = [0,0,0,2,0,0]\\n```\\n![image.png](https://assets.leetcode.com/users/images/1af7768e-7cdf-404a-bcd4-b10fc9cfb431_1679377165.6141438.png)\\n\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n\\nKeep a variable named `contCount` that stores the continuous count of 0s. Initially it will be 0. When we encounter an element 0, we increment it.\\nWhen we encounter an element other than 0, we reset variable contCount to 0. But before that we need to calculate the subarrays found from it.\\nWe can see a pattern from above examples.\\nFor two continuous zeroes:\\nThe contCount will be 3.\\nSo, the subarrays will be `3 + 2 + 1 = 3 * (3+1)/2 = 6`.\\nRemember the Gauss formula you learned in Math class?\\n$$\\nn* \\\\frac{(n+1)}{2}\\n$$\\nSo, this way we can calculate the subarrays.\\n\\n**But there\\'s a modification that can improve this efficiency. Discussed below.**\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\nIterating only once\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\nNo new array, vector, map, list declaration! Only constant 2 variables.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# 34% Efficiency:\\n``` Java []\\nclass Solution {\\n    public long zeroFilledSubarray(int[] nums) {\\n        long contCount = 0;\\n        long subarrays = 0;\\n        for(int i=0; i<nums.length; i++){\\n            if(nums[i]==0){\\n                contCount++;\\n            }\\n            else{\\n                subarrays += (contCount*(contCount+1)/2);\\n                contCount=0;\\n            }\\n        }\\n        // if the last element was 0, we need to calculate for it\\n        if(contCount>0){\\n            subarrays += (contCount*(contCount+1)/2);\\n        }\\n        return subarrays;\\n    }\\n}\\n```\\n``` C++ []\\nclass Solution {\\npublic:\\n    long long zeroFilledSubarray(vector<int>& nums) {\\n        long long contCount = 0;\\n        long long subarrays = 0;\\n        for(int i=0; i<nums.size(); i++){\\n            if(nums[i]==0){\\n                contCount++;\\n            }\\n            else{\\n                subarrays += (contCount*(contCount+1)/2);\\n                contCount=0;\\n            }\\n        }\\n        // if the last element was 0, we need to calculate for it\\n        if(contCount>0){\\n            subarrays += (contCount*(contCount+1)/2);\\n        }\\n        return subarrays;\\n    }\\n};\\n```\\n\\n``` Python []\\nclass Solution:\\n    def zeroFilledSubarray(self, nums: List[int]) -> int:\\n        contCount = 0\\n        subarrays = 0\\n\\n        for i in nums:\\n            if i == 0:\\n                contCount += 1\\n\\n            else:\\n                subarrays += contCount * (contCount + 1) // 2\\n                contCount = 0\\n        \\n        if contCount > 0:\\n            subarrays += contCount * (contCount + 1) // 2\\n\\n        return subarrays\\n```\\n\\n# 99% Efficiency:\\nInstead of determining the subarrays like that, couldn\\'t we just update the subarrays whenever contCount is updated?\\nWhen we encounter a 0, contCount will be 1.\\nSo, we found a new subarray. So, add it to the subarrays count.\\nThen another contiguous 0 will make the contCount = 2. So, now we will add 2 to the subarrays count. Our previous code was doing the same thing. But the multiplication and division operator takes more time than the addition operation. That\\'s why the underneath solution will be more efficient.\\n\\n``` Java []\\nclass Solution {\\n    public long zeroFilledSubarray(int[] nums) {\\n        long contCount = 0;\\n        long subarrays = 0;\\n        for(int i=0; i<nums.length; i++){\\n            if(nums[i]==0){\\n                contCount++;\\n                subarrays+=contCount;\\n            }\\n            else{\\n                contCount=0;\\n            }\\n        }\\n        return subarrays;\\n    }\\n}\\n```\\n``` C++ []\\nclass Solution {\\npublic:\\n    long long zeroFilledSubarray(vector<int>& nums) {\\n        long long contCount = 0;\\n        long long subarrays = 0;\\n        for(int i=0; i<nums.size(); i++){\\n            if(nums[i]==0){\\n                contCount++;\\n                subarrays += contCount;\\n            }\\n            else{\\n                contCount=0;\\n            }\\n        }\\n        return subarrays;\\n    }\\n};\\n```\\n\\n```python []\\nclass Solution:\\n    def zeroFilledSubarray(self, nums: List[int]) -> int:\\n        contCount = 0\\n        subarrays = 0\\n\\n        for i in nums:\\n            if i == 0:\\n                contCount += 1\\n                subarrays += contCount\\n        else:\\n            contCount = 0\\n\\n        return subarrays\\n\\n```\\n![image.png](https://assets.leetcode.com/users/images/6d60d185-4cd5-4405-967d-a4e0161293fc_1679377640.9683588.png)\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Array",
                    "Math"
                ],
                "code": "```\\nnums = [0]\\n```\n```\\nnums = [0, 0]\\n```\n```\\nnums = [0, 0, 0]\\n```\n```\\nnums = [0,0,0,2,0,0]\\n```\n``` Java []\\nclass Solution {\\n    public long zeroFilledSubarray(int[] nums) {\\n        long contCount = 0;\\n        long subarrays = 0;\\n        for(int i=0; i<nums.length; i++){\\n            if(nums[i]==0){\\n                contCount++;\\n            }\\n            else{\\n                subarrays += (contCount*(contCount+1)/2);\\n                contCount=0;\\n            }\\n        }\\n        // if the last element was 0, we need to calculate for it\\n        if(contCount>0){\\n            subarrays += (contCount*(contCount+1)/2);\\n        }\\n        return subarrays;\\n    }\\n}\\n```\n``` C++ []\\nclass Solution {\\npublic:\\n    long long zeroFilledSubarray(vector<int>& nums) {\\n        long long contCount = 0;\\n        long long subarrays = 0;\\n        for(int i=0; i<nums.size(); i++){\\n            if(nums[i]==0){\\n                contCount++;\\n            }\\n            else{\\n                subarrays += (contCount*(contCount+1)/2);\\n                contCount=0;\\n            }\\n        }\\n        // if the last element was 0, we need to calculate for it\\n        if(contCount>0){\\n            subarrays += (contCount*(contCount+1)/2);\\n        }\\n        return subarrays;\\n    }\\n};\\n```\n``` Python []\\nclass Solution:\\n    def zeroFilledSubarray(self, nums: List[int]) -> int:\\n        contCount = 0\\n        subarrays = 0\\n\\n        for i in nums:\\n            if i == 0:\\n                contCount += 1\\n\\n            else:\\n                subarrays += contCount * (contCount + 1) // 2\\n                contCount = 0\\n        \\n        if contCount > 0:\\n            subarrays += contCount * (contCount + 1) // 2\\n\\n        return subarrays\\n```\n``` Java []\\nclass Solution {\\n    public long zeroFilledSubarray(int[] nums) {\\n        long contCount = 0;\\n        long subarrays = 0;\\n        for(int i=0; i<nums.length; i++){\\n            if(nums[i]==0){\\n                contCount++;\\n                subarrays+=contCount;\\n            }\\n            else{\\n                contCount=0;\\n            }\\n        }\\n        return subarrays;\\n    }\\n}\\n```\n``` C++ []\\nclass Solution {\\npublic:\\n    long long zeroFilledSubarray(vector<int>& nums) {\\n        long long contCount = 0;\\n        long long subarrays = 0;\\n        for(int i=0; i<nums.size(); i++){\\n            if(nums[i]==0){\\n                contCount++;\\n                subarrays += contCount;\\n            }\\n            else{\\n                contCount=0;\\n            }\\n        }\\n        return subarrays;\\n    }\\n};\\n```\n```python []\\nclass Solution:\\n    def zeroFilledSubarray(self, nums: List[int]) -> int:\\n        contCount = 0\\n        subarrays = 0\\n\\n        for i in nums:\\n            if i == 0:\\n                contCount += 1\\n                subarrays += contCount\\n        else:\\n            contCount = 0\\n\\n        return subarrays\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2322331,
                "title": "java-python-3-o-n-code-using-2-variables-w-brief-explanation-and-analysis",
                "content": "Compute the # of `0` filled subarrays for each continuous `0`s and add them up.\\n\\nWhenever encounter a `0`, use a variable `zeroSubarraysEndingAtCurrentIndex` to count the subarrays of only `0`s: e.g., `0,0,0,0`\\nthe # of subarrays ending at 1st `0` is 1: `0,x,x,x`\\nthe # of subarrays ending at 2nd `0` is 2: `x,0,x,x`, `0,0,x,x`\\nthe # of subarrays ending at 3rd `0` is 3: `x,x,0,x`, `x,0,0,x`, `0,0,0,x`\\nthe # of subarrays ending at 4th `0` is 4: `x,x,x,0`, `x,x,0,0`, `x,0,0,0`, `0,0,0,0`\\n\\nThere are `1 + 2 + 3 + 4 = 10` subarrays for `0,0,0,0`.\\n\\nduring counting using the `zeroSubarraysEndingAtCurrentIndex`, we add it to the final result `cnt`.\\n\\n```java\\n    public long zeroFilledSubarray(int[] nums) {\\n        long cnt = 0, zeroSubarraysEndingAtCurrentIndex = 0;\\n        for (int n : nums) {\\n            if (n == 0) {\\n                cnt += ++zeroSubarraysEndingAtCurrentIndex;\\n            }else {\\n                zeroSubarraysEndingAtCurrentIndex = 0;\\n            }\\n        }\\n        return cnt;\\n    }\\n```\\n```python\\n    def zeroFilledSubarray(self, nums: List[int]) -> int:\\n        cnt = zeroSubarraysEndingAtCurrentIndex = 0\\n        for num in nums:\\n            if num == 0:\\n                zeroSubarraysEndingAtCurrentIndex += 1\\n                cnt += zeroSubarraysEndingAtCurrentIndex\\n            else:\\n                zeroSubarraysEndingAtCurrentIndex = 0\\n        return cnt\\n```\\n**Analysis:**\\n\\nTime: `O(n)`, space: `O(1)`, where `n = nums.length`.",
                "solutionTags": [
                    "Java",
                    "Python3"
                ],
                "code": "```java\\n    public long zeroFilledSubarray(int[] nums) {\\n        long cnt = 0, zeroSubarraysEndingAtCurrentIndex = 0;\\n        for (int n : nums) {\\n            if (n == 0) {\\n                cnt += ++zeroSubarraysEndingAtCurrentIndex;\\n            }else {\\n                zeroSubarraysEndingAtCurrentIndex = 0;\\n            }\\n        }\\n        return cnt;\\n    }\\n```\n```python\\n    def zeroFilledSubarray(self, nums: List[int]) -> int:\\n        cnt = zeroSubarraysEndingAtCurrentIndex = 0\\n        for num in nums:\\n            if num == 0:\\n                zeroSubarraysEndingAtCurrentIndex += 1\\n                cnt += zeroSubarraysEndingAtCurrentIndex\\n            else:\\n                zeroSubarraysEndingAtCurrentIndex = 0\\n        return cnt\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3322097,
                "title": "linear-traversal-c-and-java-solution",
                "content": "Har Har Mahadev \\uD83D\\uDD49\\uFE0F\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nCount number of continuous zeros and if you encounter any non zero element than add (counter*(counter+1))/2 in the result as from n elements can form (n*(n+1))/2 sub-arrays\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nwe are having 2 variables res(for storing final resul)  and counter(keeping track of number of continuous zeros) \\nWe are looping through an array if we find zero increase counter else add value of number of subarrays in result and make counter zero \\n\\nSuppose if we have complete traversal and counter is not zero so we are checking condition after traversing the array so that if counter is not zero we will add value in result\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nwe are traversing array once so time complexity is\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nwe are using only two extra variables so space complexity is :\\nO(1)\\n# Code\\nJava \\n```\\nclass Solution {\\n    public long zeroFilledSubarray(int[] nums) {\\n        long res = 0;\\n        long counter = 0;\\n        for(Integer ele:nums){\\n            if(ele==0){\\n                counter++;\\n            }else{\\n                res += (counter*(counter+1))/2;\\n                counter = 0;\\n            }\\n        }\\n        if(counter!=0){\\n            res += (counter*(counter+1))/2;\\n            counter = 0;\\n        }\\n        return res;\\n    }\\n}\\n```\\n\\n\\n# Code \\n\\nC++\\n\\n```\\nclass Solution {\\npublic:\\n    long long zeroFilledSubarray(vector<int>& nums) {\\n        long long res = 0;\\n        long long counter = 0;\\n        for(int i = 0;i<nums.size();i++){\\n            if(nums[i]==0){\\n                counter++;\\n            }else{\\n                res+=(counter*(counter+1))/2;\\n                counter = 0;\\n            }\\n        }\\n        if(counter){\\n            res+=(counter*(counter+1))/2;\\n            counter = 0;\\n        }\\n        return res;\\n    }\\n};\\n\\n\\n```\\n\\nI hope you understand the solution if you have any confusion or if there any correction in the solution please inform me.\\n\\nJai Shree Ram \\u2764\\uFE0F\\uD83D\\uDEA9\\n\\n\\n\\n\\n![2ddedd60-39d6-4167-9b77-88e10400f044_1673586388.8794823.jpeg](https://assets.leetcode.com/users/images/c31099d3-30a8-457a-9991-c20eda6c93a0_1679362889.0668192.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\n    public long zeroFilledSubarray(int[] nums) {\\n        long res = 0;\\n        long counter = 0;\\n        for(Integer ele:nums){\\n            if(ele==0){\\n                counter++;\\n            }else{\\n                res += (counter*(counter+1))/2;\\n                counter = 0;\\n            }\\n        }\\n        if(counter!=0){\\n            res += (counter*(counter+1))/2;\\n            counter = 0;\\n        }\\n        return res;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    long long zeroFilledSubarray(vector<int>& nums) {\\n        long long res = 0;\\n        long long counter = 0;\\n        for(int i = 0;i<nums.size();i++){\\n            if(nums[i]==0){\\n                counter++;\\n            }else{\\n                res+=(counter*(counter+1))/2;\\n                counter = 0;\\n            }\\n        }\\n        if(counter){\\n            res+=(counter*(counter+1))/2;\\n            counter = 0;\\n        }\\n        return res;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2322330,
                "title": "c-o-n-approaches-beginners-friendly-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    long long zeroFilledSubarray(vector<int>& nums) \\n    {\\n        long long ans = 0;             // for storing the final answer (Total no. of subarrays)\\n        long long cnt = 0;             // for counting the consecutive 0\\'s\\n        \\n        for(int i=0;i<nums.size();i++)\\n        {\\n            // wherever we find 0 just increase cnt by 1 and sum up to ans\\n            if(nums[i]==0)               \\n            {\\n                cnt++;\\n                ans += cnt;\\n            }\\n            \\n            // if it is none 0 them make 0 count 0\\n            else\\n            {\\n                cnt = 0;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n// TC : O(N)\\n// SC : O(1)\\n\\n// formula \\n// size = no. of subarray\\n// 1 = 1\\n// 2 = 2+1 = 3\\n// 3 = 3+2+1 = 6\\n// 4 = 4+3+2+1 = 10\\n// .\\n// .\\n// .\\n// N = N+(N-1)+(N-2)+....+1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long zeroFilledSubarray(vector<int>& nums) \\n    {\\n        long long ans = 0;             // for storing the final answer (Total no. of subarrays)\\n        long long cnt = 0;             // for counting the consecutive 0\\'s\\n        \\n        for(int i=0;i<nums.size();i++)\\n        {\\n            // wherever we find 0 just increase cnt by 1 and sum up to ans\\n            if(nums[i]==0)               \\n            {\\n                cnt++;\\n                ans += cnt;\\n            }\\n            \\n            // if it is none 0 them make 0 count 0\\n            else\\n            {\\n                cnt = 0;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n// TC : O(N)\\n// SC : O(1)\\n\\n// formula \\n// size = no. of subarray\\n// 1 = 1\\n// 2 = 2+1 = 3\\n// 3 = 3+2+1 = 6\\n// 4 = 4+3+2+1 = 10\\n// .\\n// .\\n// .\\n// N = N+(N-1)+(N-2)+....+1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2322566,
                "title": "cpp-normal-maths",
                "content": "Total number of subarrays present in an array = (n * (n + 1)) / 2\\n\\nWhat we will do is just count consecutive number of zeroes and then find how much subarrays are possible in that length. Then we will add it to the ans.\\n\\n```cpp\\n     #define ll long long\\n    \\n    long long zeroFilledSubarray(vector<int>& nums)\\n    {\\n        ll count = 0, ans = 0;\\n        \\n        for(int idx = 0; idx < nums.size(); idx++)\\n        {\\n            if(nums[idx] == 0){\\n                count++;\\n            }\\n            \\n            else if(nums[idx] != 0){\\n                ans += count * (count + 1) / 2;\\n                count = 0;\\n            }\\n        }\\n                \\n        ans += (count * (count + 1) / 2);\\n\\t\\t\\n        return ans; \\n    }\\n\\t",
                "solutionTags": [
                    "C++"
                ],
                "code": "Total number of subarrays present in an array = (n * (n + 1)) / 2\\n\\nWhat we will do is just count consecutive number of zeroes and then find how much subarrays are possible in that length. Then we will add it to the ans.\\n\\n```cpp\\n     #define ll long long\\n    \\n    long long zeroFilledSubarray(vector<int>& nums)\\n    {\\n        ll count = 0, ans = 0;\\n        \\n        for(int idx = 0; idx < nums.size(); idx++)\\n        {\\n            if(nums[idx] == 0){\\n                count++;\\n            }\\n            \\n            else if(nums[idx] != 0){\\n                ans += count * (count + 1) / 2;\\n                count = 0;\\n            }\\n        }\\n                \\n        ans += (count * (count + 1) / 2);\\n\\t\\t\\n        return ans; \\n    }\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 3322276,
                "title": "day-80-o-n-time-and-o-1-space-easiest-beginner-friendly-sol",
                "content": "**NOTE - PLEASE READ INTUITION AND APPROACH FIRST THEN SEE THE CODE. YOU WILL DEFINITELY UNDERSTAND THE CODE LINE BY LINE AFTER SEEING THE APPROACH.**\\n\\n# Intuition of this Problem :\\n![WhatsApp Image 2023-03-21 at 8.55.15 AM.jpeg](https://assets.leetcode.com/users/images/33e94be1-04a4-417f-acd4-d8fd30f0dc0f_1679369183.8682194.jpeg)\\n\\n**For each zero, you can calculate the number of zero-filled subarrays that end on that index, which is the number of consecutive zeros behind the current element + 1. Maintain the number of consecutive zeros behind the current element, count the number of zero-filled subarrays that end on each index, sum it up to get the answer.**\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach for this Problem :\\n1. Initialize numOfZeroFilledSubarray and countZeros to 0.\\n2. Iterate over the elements of the input array nums:\\n    - a. If the current element is 0, increment countZeros by 1.\\n    - b. If the current element is not 0, calculate the number of zero-filled subarrays that end at this element as (countZeros * (countZeros + 1) / 2), add it to the variable numOfZeroFilledSubarray, and reset countZeros to 0.\\n1. If countZeros is non-zero after the loop, calculate the number of zero-filled subarrays that end at the last element as (countZeros * (countZeros + 1) / 2), and add it to the variable numOfZeroFilledSubarray.\\n2. Return numOfZeroFilledSubarray.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Code :\\n```C++ []\\nclass Solution {\\npublic:\\n    long long zeroFilledSubarray(vector<int>& nums) {\\n        long long numOfZeroFilledSubarray = 0;\\n        long long countZeros = 0;\\n        for (int i = 0; i < nums.size(); i++) {\\n            if (nums[i] == 0)\\n                countZeros++;\\n            else {\\n                numOfZeroFilledSubarray += (countZeros * (countZeros + 1) / 2);\\n                countZeros = 0;\\n            }\\n        }\\n        numOfZeroFilledSubarray += (countZeros * (countZeros + 1) / 2);\\n        return numOfZeroFilledSubarray;\\n    }\\n};\\n```\\n```Java []\\npublic class Solution {\\n    public long zeroFilledSubarray(int[] nums) {\\n        long numOfZeroFilledSubarray = 0;\\n        long countZeros = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] == 0)\\n                countZeros++;\\n            else {\\n                numOfZeroFilledSubarray += (countZeros * (countZeros + 1) / 2);\\n                countZeros = 0;\\n            }\\n        }\\n        numOfZeroFilledSubarray += (countZeros * (countZeros + 1) / 2);\\n        return numOfZeroFilledSubarray;\\n    }\\n}\\n\\n```\\n```Python []\\nclass Solution:\\n    def zeroFilledSubarray(self, nums: List[int]) -> int:\\n        numOfZeroFilledSubarray = 0\\n        countZeros = 0\\n        for i in range(len(nums)):\\n            if nums[i] == 0:\\n                countZeros += 1\\n            else:\\n                numOfZeroFilledSubarray += (countZeros * (countZeros + 1) // 2)\\n                countZeros = 0\\n        numOfZeroFilledSubarray += (countZeros * (countZeros + 1) // 2)\\n        return numOfZeroFilledSubarray\\n\\n```\\n\\n# Time Complexity and Space Complexity:\\n- Time complexity : **O(n)**, where n is the size of array\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity : **O(1)**, not used any extra space\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Array"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    long long zeroFilledSubarray(vector<int>& nums) {\\n        long long numOfZeroFilledSubarray = 0;\\n        long long countZeros = 0;\\n        for (int i = 0; i < nums.size(); i++) {\\n            if (nums[i] == 0)\\n                countZeros++;\\n            else {\\n                numOfZeroFilledSubarray += (countZeros * (countZeros + 1) / 2);\\n                countZeros = 0;\\n            }\\n        }\\n        numOfZeroFilledSubarray += (countZeros * (countZeros + 1) / 2);\\n        return numOfZeroFilledSubarray;\\n    }\\n};\\n```\n```Java []\\npublic class Solution {\\n    public long zeroFilledSubarray(int[] nums) {\\n        long numOfZeroFilledSubarray = 0;\\n        long countZeros = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] == 0)\\n                countZeros++;\\n            else {\\n                numOfZeroFilledSubarray += (countZeros * (countZeros + 1) / 2);\\n                countZeros = 0;\\n            }\\n        }\\n        numOfZeroFilledSubarray += (countZeros * (countZeros + 1) / 2);\\n        return numOfZeroFilledSubarray;\\n    }\\n}\\n\\n```\n```Python []\\nclass Solution:\\n    def zeroFilledSubarray(self, nums: List[int]) -> int:\\n        numOfZeroFilledSubarray = 0\\n        countZeros = 0\\n        for i in range(len(nums)):\\n            if nums[i] == 0:\\n                countZeros += 1\\n            else:\\n                numOfZeroFilledSubarray += (countZeros * (countZeros + 1) // 2)\\n                countZeros = 0\\n        numOfZeroFilledSubarray += (countZeros * (countZeros + 1) // 2)\\n        return numOfZeroFilledSubarray\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2322508,
                "title": "c-use-subarray-count-approach-simple-efficient-solution",
                "content": "**Approach:**\\nif continuous \\'0\\' is 1 then count 1\\nif continuous \\'0\\' is 2 then count 2+1 = 3\\nif continuous \\'0\\' is 3 then count 3+2+1 = 6\\nif continuous \\'0\\' is 4 then count 4+3+2+1 = 10\\n...\\n...\\n...\\nif continuous \\'0\\' is n then count n+(n-1)+(n-2)+...+3+2+1\\n\\n\\n**Code:**\\n```\\nclass Solution \\n{\\npublic:\\n    long long zeroFilledSubarray(vector<int>& nums) \\n    {\\n        long long count = 0;\\n        long long ans = 0;\\n        \\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            if(nums[i]==0)\\n            {\\n                count++;\\n                ans += count;\\n            }\\n            else\\n            {\\n                count = 0;\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    long long zeroFilledSubarray(vector<int>& nums) \\n    {\\n        long long count = 0;\\n        long long ans = 0;\\n        \\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            if(nums[i]==0)\\n            {\\n                count++;\\n                ans += count;\\n            }\\n            else\\n            {\\n                count = 0;\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3324804,
                "title": "fast-solution-java-best-memory-usage",
                "content": "public long zeroFilledSubarray(int[] nums) {\\n*       int i = 0;\\n        int k = 0;\\n        long sum = 0;\\n        while (i < nums.length) {\\n            if (nums[i] == 0)  {\\n                sum += k + 1;\\n                k++;\\n            }else {\\n                k=0;\\n            }\\n            i++;\\n        }\\n        return sum;\\n    }",
                "solutionTags": [],
                "code": "public long zeroFilledSubarray(int[] nums) {\\n*       int i = 0;\\n        int k = 0;\\n        long sum = 0;\\n        while (i < nums.length) {\\n            if (nums[i] == 0)  {\\n                sum += k + 1;\\n                k++;\\n            }else {\\n                k=0;\\n            }\\n            i++;\\n        }\\n        return sum;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3322992,
                "title": "c-subarray-simple-logic-dry-run-commented",
                "content": "# Complexity\\n- Time complexity:\\no(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long zeroFilledSubarray(vector<int>& nums) \\n    {\\n        long long total_cnt = 0;\\n        long long curr_cnt = 0;\\n\\n        long long n = nums.size();\\n        for(long long i=0;i<n;i++)\\n        {\\n            // count consecutive 0\\'s\\n            if(nums[i]==0)\\n            {\\n                // increase the curr_cnt of 0\\'s and add it to total_cnt\\n                curr_cnt++;\\n                total_cnt += curr_cnt;\\n            }\\n            // if there is no 0 then current cnt of 0 will become 0\\n            else\\n            {\\n                curr_cnt = 0;\\n            }\\n        }\\n\\n        return total_cnt;\\n    }\\n};\\n```\\n\\n## Dry Run of Above Code\\n```\\n// [0,0,0,2,0,0,1]\\n// curr_cnt = 0 , total_cnt = 0\\n\\n// i = 0 , nums[0] = 0\\n// curr_cnt=1 , total_cnt = total_cnt + 1 = 1;\\n// total_cnt=1;\\n\\n// i = 1 ,, nums[1] = 0\\n// curr_cnt=2 , total_cnt = total_cnt + 2 = 3;\\n// total_cnt=3;\\n\\n// i = 2 , nums[2] = 0\\n// curr_cnt=3 , total_cnt = total_cnt + 3 = 6;\\n// total_cnt=6;\\n\\n// i = , nums[3] = 2\\n// curr_cnt=0 , total_cnt = total_cnt + 0 = 6;\\n// total_cnt=6;\\n\\n// i = 5 ,nums[5] = 0\\n// curr_cnt=1 , total_cnt = total_cnt + 1 = 7;\\n// total_cnt=7;\\n\\n// i = 6 , nums[6] = 0\\n// curr_cnt=2 , total_cnt = total_cnt + 2 = 9;\\n// total_cnt=9;\\n\\n// i = 7 , nums[7] = 1\\n// curr_cnt=0 , total_cnt = total_cnt + 0 = 9;\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long zeroFilledSubarray(vector<int>& nums) \\n    {\\n        long long total_cnt = 0;\\n        long long curr_cnt = 0;\\n\\n        long long n = nums.size();\\n        for(long long i=0;i<n;i++)\\n        {\\n            // count consecutive 0\\'s\\n            if(nums[i]==0)\\n            {\\n                // increase the curr_cnt of 0\\'s and add it to total_cnt\\n                curr_cnt++;\\n                total_cnt += curr_cnt;\\n            }\\n            // if there is no 0 then current cnt of 0 will become 0\\n            else\\n            {\\n                curr_cnt = 0;\\n            }\\n        }\\n\\n        return total_cnt;\\n    }\\n};\\n```\n```\\n// [0,0,0,2,0,0,1]\\n// curr_cnt = 0 , total_cnt = 0\\n\\n// i = 0 , nums[0] = 0\\n// curr_cnt=1 , total_cnt = total_cnt + 1 = 1;\\n// total_cnt=1;\\n\\n// i = 1 ,, nums[1] = 0\\n// curr_cnt=2 , total_cnt = total_cnt + 2 = 3;\\n// total_cnt=3;\\n\\n// i = 2 , nums[2] = 0\\n// curr_cnt=3 , total_cnt = total_cnt + 3 = 6;\\n// total_cnt=6;\\n\\n// i = , nums[3] = 2\\n// curr_cnt=0 , total_cnt = total_cnt + 0 = 6;\\n// total_cnt=6;\\n\\n// i = 5 ,nums[5] = 0\\n// curr_cnt=1 , total_cnt = total_cnt + 1 = 7;\\n// total_cnt=7;\\n\\n// i = 6 , nums[6] = 0\\n// curr_cnt=2 , total_cnt = total_cnt + 2 = 9;\\n// total_cnt=9;\\n\\n// i = 7 , nums[7] = 1\\n// curr_cnt=0 , total_cnt = total_cnt + 0 = 9;\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3322606,
                "title": "c-8-lines-code-intuituion-approch",
                "content": "# Intuition\\nNeed to find continuous subarrays ( as much present in array more can be more than one) having all elements equal to zero.\\ncount size of every possible subarrays of zero\\'s.\\n\\n# Approach\\nNumber of possible subarray for given lenght (N) of array is N*(N+1)/2.\\nAdd Number of subrarry possible for every subrray ino aur answer.\\n\\n***IF YOU READ IT LET ME KNOW BY DOING VOTE UP !!***\\n\\n# Complexity\\n- Time complexity:\\n```\\nO(N)\\n```\\n\\n- Space complexity:\\n```\\nO(1)\\n```\\n\\n# Code\\n```\\n#define ll long long\\nclass Solution {\\npublic:\\n    long long zeroFilledSubarray(vector<int>& nums) {\\n        ll ans=0 , c=0;\\n        for(int i =0;i<=nums.size();i++){\\n            if(i<nums.size() && nums[i]==0 ) c++;\\n            else if(c != 0){\\n                ans +=(c*(c+1)/2);\\n                c=0;\\n            }\\n        } \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nO(N)\\n```\n```\\nO(1)\\n```\n```\\n#define ll long long\\nclass Solution {\\npublic:\\n    long long zeroFilledSubarray(vector<int>& nums) {\\n        ll ans=0 , c=0;\\n        for(int i =0;i<=nums.size();i++){\\n            if(i<nums.size() && nums[i]==0 ) c++;\\n            else if(c != 0){\\n                ans +=(c*(c+1)/2);\\n                c=0;\\n            }\\n        } \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2331681,
                "title": "python-very-simple-and-easy-solution-without-formula-o-n-o-1",
                "content": "```\\ndef zeroFilledSubarray(self, nums: List[int]) -> int:\\n        ans, count = 0, 0\\n        for num in nums:\\n            if num:\\n                count = 0\\n            else:\\n                count += 1\\n            ans += count\\n        \\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef zeroFilledSubarray(self, nums: List[int]) -> int:\\n        ans, count = 0, 0\\n        for num in nums:\\n            if num:\\n                count = 0\\n            else:\\n                count += 1\\n            ans += count\\n        \\n        return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3322269,
                "title": "clean-codes-full-explanation-simple-iteration-java",
                "content": "# What Problem says ?\\n- Given an integer array `nums`, return the no. of subarrays filled with `0`.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach : Simple Iteration\\n- Loops through each number in the array and keeps track of the index of the last 0 that was encountered. \\n- Whenever you across a new 0, calculate the number of subarrays between the last 0 and the current 0 (which is just the distance between the two indices plus one) and adds this to a running total.\\n- When you encounters a number that is not 0, simply move on to the next number without doing anything else.\\n-  Once you have gone through the entire array, return the total number of subarrays that were found to be filled with 0s.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity :\\n- Time complexity : O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity : O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\\nThanks for visiting my solution.\\uD83D\\uDE0A\\n```\\n# Note :\\n```\\nWe are using `long` ans instead of `int` ans to avoid code failure \\non large sized inputs\\n```\\n\\n# Java Code :\\n```\\nclass Solution \\n{\\n    public long zeroFilledSubarray(int[] nums) \\n    {\\n        long ans = 0;\\n        int indexBeforeZero = -1;\\n        for(int i=0; i<nums.length; i++)\\n        {\\n            if(nums[i] == 0)\\n                ans += i - indexBeforeZero;\\n            else\\n                indexBeforeZero = i;\\n        }\\n        return ans;\\n    }\\n}\\n```\\n# Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\n![ezgif-3-22a360561c.gif](https://assets.leetcode.com/users/images/7263c618-f196-4358-9bbd-bf926ce18c0e_1679366626.227361.gif)\\n",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Math"
                ],
                "code": "```\\nThanks for visiting my solution.\\uD83D\\uDE0A\\n```\n```\\nWe are using `long` ans instead of `int` ans to avoid code failure \\non large sized inputs\\n```\n```\\nclass Solution \\n{\\n    public long zeroFilledSubarray(int[] nums) \\n    {\\n        long ans = 0;\\n        int indexBeforeZero = -1;\\n        for(int i=0; i<nums.length; i++)\\n        {\\n            if(nums[i] == 0)\\n                ans += i - indexBeforeZero;\\n            else\\n                indexBeforeZero = i;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3322004,
                "title": "elegant-solution-with-o-n-o-1-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe contribution of a single zero to the total sum is directly proportional to its index in the subsequence of zeros.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFor every num if it equals to zero we need to increase the length of the current subsequence of zeros by 1, and add this length on each iteration to the final sum.\\n\\nOtherwise, set the length of the current subsequence to 0.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nconst zeroFilledSubarray = nums => {\\n    let count = 0;\\n    let length = 0;\\n    for (let i = 0; i < nums.length; i++) {\\n        if (nums[i] === 0) {\\n            length++;\\n            count += length;\\n        } else length = 0;\\n    }\\n    return count;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst zeroFilledSubarray = nums => {\\n    let count = 0;\\n    let length = 0;\\n    for (let i = 0; i < nums.length; i++) {\\n        if (nums[i] === 0) {\\n            length++;\\n            count += length;\\n        } else length = 0;\\n    }\\n    return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2322306,
                "title": "c-easy",
                "content": "\\n\\nformula \\nsize = no. of subarray\\n1 = 1\\n2 = 2+1 = 3\\n 3 = 3+2+1 = 6\\n 4 = 4+3+2+1 = 10\\n .\\n .\\nN = N(N+1)/2\\n\\n**Time Complaxity** : `O(N)`\\n**Space Complaxity** : `O(1)`\\n\\n**Code**\\n```\\nclass Solution {\\npublic:\\n    long long subarray(long long n){\\n        return n*(n+1)/2;\\n    }\\n    long long zeroFilledSubarray(vector<int>& nums) {\\n        long long s=nums.size();\\n        long long count=0;\\n        long long ans=0;   \\n        for(auto x:nums){\\n            if(x==0) count++;\\n            else{\\n                ans=ans+subarray(count);\\n                count=0;\\n            }\\n        }\\n        ans=ans+subarray(count);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long subarray(long long n){\\n        return n*(n+1)/2;\\n    }\\n    long long zeroFilledSubarray(vector<int>& nums) {\\n        long long s=nums.size();\\n        long long count=0;\\n        long long ans=0;   \\n        for(auto x:nums){\\n            if(x==0) count++;\\n            else{\\n                ans=ans+subarray(count);\\n                count=0;\\n            }\\n        }\\n        ans=ans+subarray(count);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2322311,
                "title": "cpp-easy",
                "content": "Intuition : Total number of subarrays of length `n` is `n(n+1)/2`\\nSo , Count all consecutive zeros and add total number of subarrays for all consecutive zeros counts.\\n\\n```\\nclass Solution {\\npublic:\\n    typedef long long ll;\\n    long long zeroFilledSubarray(vector<int>& v) {\\n        ll cnt=0,ans=0;\\n        for(int x:v){\\n            if(x==0)cnt++;\\n            else ans+=cnt*(cnt+1LL)/2,cnt=0;\\n        }\\n        return ans+cnt*(cnt+1LL)/2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    typedef long long ll;\\n    long long zeroFilledSubarray(vector<int>& v) {\\n        ll cnt=0,ans=0;\\n        for(int x:v){\\n            if(x==0)cnt++;\\n            else ans+=cnt*(cnt+1LL)/2,cnt=0;\\n        }\\n        return ans+cnt*(cnt+1LL)/2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3324399,
                "title": "c-full-explanation-easy-and-fast",
                "content": "# steps\\n1) we **count 0** . we keep a variable say **count** which count how much 0 is in consequative order .\\n2) we can make **(countx(count+1))/2** subset from count .\\n3) at last check if **count** is still 0 if not **that means 0 came at last of nums array**  so include it using same formula .\\nreturn answer \\n\\n# PLEASE upvote if you like.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long zeroFilledSubarray(vector<int>& nums) {\\n        int n=nums.size();\\n        long long ans=0;\\n        long long count=0;\\n        for(int i=0;i<n;++i){\\n        if(nums[i]==0){\\n          count++;\\n        }else{\\n           \\n            if(count){\\n                 ans+=(count*(count+1))/2;\\n            }\\n          count=0;   \\n        }\\n        }\\n      if(count!=0){\\n        ans+=(count*(count+1))/2;\\n      }\\n        return ans;\\n    }\\n};\\n```\\n# time complexity:- o(n).\\n# space complexity:-o(1).\\n![begging.jpg](https://assets.leetcode.com/users/images/4ae66c16-9e22-4528-8c83-7d662fdef506_1679402068.7532263.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long zeroFilledSubarray(vector<int>& nums) {\\n        int n=nums.size();\\n        long long ans=0;\\n        long long count=0;\\n        for(int i=0;i<n;++i){\\n        if(nums[i]==0){\\n          count++;\\n        }else{\\n           \\n            if(count){\\n                 ans+=(count*(count+1))/2;\\n            }\\n          count=0;   \\n        }\\n        }\\n      if(count!=0){\\n        ans+=(count*(count+1))/2;\\n      }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3322904,
                "title": "easiest-approach-single-loop-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long zeroFilledSubarray(vector<int>& nums) {\\n        long long ans = 0;\\n        int count = 0;\\n\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==0){\\n                count++;\\n                ans += count;\\n            }else{\\n                count=0;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n# Please upvote, if you find this solution helpful \\uD83D\\uDE4F \\n### Thank you in advance ;)",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long zeroFilledSubarray(vector<int>& nums) {\\n        long long ans = 0;\\n        int count = 0;\\n\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==0){\\n                count++;\\n                ans += count;\\n            }else{\\n                count=0;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3322670,
                "title": "easy-to-understand-solution-with-explanation",
                "content": "To solve this problem, we need to count the number of contiguous subarrays in the input array that consist entirely of the number 0. One way to do this is to use a sliding window approach, where we keep track of the length of the current subarray of contiguous 0s and add it to a total count whenever we encounter a new 0 in the input array.\\n\\nHere is a simple step-by-step approach to solve this problem:\\n1. Initialize two variables: `count` to 0, which will hold the total number of subarrays filled with 0, and `subcount` to 0, which will hold the length of the current subarray of contiguous 0s.\\n2. Iterate over each element in the input array `nums`. For each element:\\nIf the element is not equal to 0, it means the current subarray of contiguous 0s has ended. Reset `subcount` to 0.\\n3. If the element is equal to 0, increment `subcount` by 1. This means we have found a new subarray of contiguous 0s that ends at the current element.\\n4. Add `subcount` to `count`. This adds the number of subarrays filled with 0 that end at the current element to the total `count` of subarrays filled with 0.\\n5. Return `count` as the final answer.\\n\\n\\n## JavaScript Code\\n```javascript\\nvar zeroFilledSubarray = function (nums) {\\n  // Initialize variables for counting zero-filled subarrays\\n  let count = 0; // Total count of zero-filled subarrays\\n  let subcount = 0; // Length of the current subarray of contiguous 0s\\n\\n  // Iterate over each element in the input array\\n  for (const num of nums) {\\n    // If the current element is not zero, \\n    // the current subarray of contiguous 0s has ended\\n    if (num !== 0) {\\n      // So, reset the length of the current subarray of contiguous 0s\\n      // and move on to the next element in the input array\\n      subcount = 0; \\n      continue; \\n    }\\n\\n    // If the current element is zero, \\n    // increment the length of the current subarray of contiguous 0s\\n    subcount++;\\n\\n    // And add the length of the current subarray of contiguous 0s \\n    // to the total count of zero-filled subarrays\\n    count += subcount;\\n  }\\n\\n  // Return the total count of zero-filled subarrays in the input array\\n  return count;\\n};\\n```\\n\\n## Rust Code\\n```rust\\nimpl Solution {\\n    pub fn zero_filled_subarray(nums: Vec<i32>) -> i64 {\\n        let mut count = 0;\\n        let mut subcount = 0;\\n\\n        for num in nums {\\n            if num != 0 {\\n                subcount = 0;\\n                continue;\\n            }\\n\\n            subcount += 1;\\n            count += subcount;\\n        }\\n\\n        count\\n    }\\n}\\n```\\n\\n## Go Code\\n```go\\nfunc zeroFilledSubarray(nums []int) int64 {\\n\\tvar count, subcount int64 = 0, 0\\n\\n\\tfor _, num := range nums {\\n\\t\\tif num != 0 {\\n\\t\\t\\tsubcount = 0\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\n\\t\\tsubcount += 1\\n\\t\\tcount += subcount\\n\\t}\\n\\n\\treturn count\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Go",
                    "Rust"
                ],
                "code": "```javascript\\nvar zeroFilledSubarray = function (nums) {\\n  // Initialize variables for counting zero-filled subarrays\\n  let count = 0; // Total count of zero-filled subarrays\\n  let subcount = 0; // Length of the current subarray of contiguous 0s\\n\\n  // Iterate over each element in the input array\\n  for (const num of nums) {\\n    // If the current element is not zero, \\n    // the current subarray of contiguous 0s has ended\\n    if (num !== 0) {\\n      // So, reset the length of the current subarray of contiguous 0s\\n      // and move on to the next element in the input array\\n      subcount = 0; \\n      continue; \\n    }\\n\\n    // If the current element is zero, \\n    // increment the length of the current subarray of contiguous 0s\\n    subcount++;\\n\\n    // And add the length of the current subarray of contiguous 0s \\n    // to the total count of zero-filled subarrays\\n    count += subcount;\\n  }\\n\\n  // Return the total count of zero-filled subarrays in the input array\\n  return count;\\n};\\n```\n```rust\\nimpl Solution {\\n    pub fn zero_filled_subarray(nums: Vec<i32>) -> i64 {\\n        let mut count = 0;\\n        let mut subcount = 0;\\n\\n        for num in nums {\\n            if num != 0 {\\n                subcount = 0;\\n                continue;\\n            }\\n\\n            subcount += 1;\\n            count += subcount;\\n        }\\n\\n        count\\n    }\\n}\\n```\n```go\\nfunc zeroFilledSubarray(nums []int) int64 {\\n\\tvar count, subcount int64 = 0, 0\\n\\n\\tfor _, num := range nums {\\n\\t\\tif num != 0 {\\n\\t\\t\\tsubcount = 0\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\n\\t\\tsubcount += 1\\n\\t\\tcount += subcount\\n\\t}\\n\\n\\treturn count\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2322400,
                "title": "using-sliding-window-two-pointers-aasan-hai-c",
                "content": "```\\nclass Solution {\\npublic:\\n    long long zeroFilledSubarray(vector<int>& n) {\\n        long long int ans = 0, cnt = 0;\\n        \\n        for(auto x: n){\\n            if(x) cnt=0;\\n            else cnt++;\\n\\n            ans+=cnt;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Math",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long zeroFilledSubarray(vector<int>& n) {\\n        long long int ans = 0, cnt = 0;\\n        \\n        for(auto x: n){\\n            if(x) cnt=0;\\n            else cnt++;\\n\\n            ans+=cnt;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3325807,
                "title": "c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long zeroFilledSubarray(vector<int>& nums) {\\n        long cnt = 0, zeroSubarraysEndingAtCurrentIndex = 0;\\n        for (int n : nums) {\\n            if (n == 0) {\\n                cnt += ++zeroSubarraysEndingAtCurrentIndex;\\n            } else {\\n                zeroSubarraysEndingAtCurrentIndex = 0;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long zeroFilledSubarray(vector<int>& nums) {\\n        long cnt = 0, zeroSubarraysEndingAtCurrentIndex = 0;\\n        for (int n : nums) {\\n            if (n == 0) {\\n                cnt += ++zeroSubarraysEndingAtCurrentIndex;\\n            } else {\\n                zeroSubarraysEndingAtCurrentIndex = 0;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3322698,
                "title": "python-1-liner-functional-programming",
                "content": "# Approach\\nTL;DR, same as [Official solution](https://leetcode.com/problems/number-of-zero-filled-subarrays/editorial/) but written in a declarative and functional way.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$\\n\\nwhere, `n is the length of nums`.\\n\\n# Code\\n```python\\nclass Solution:\\n    def zeroFilledSubarray(self, nums: list[int]) -> int:\\n        return sum(accumulate(nums, lambda a, x: 0 if x else a + 1, initial=0))\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Math",
                    "Dynamic Programming"
                ],
                "code": "```python\\nclass Solution:\\n    def zeroFilledSubarray(self, nums: list[int]) -> int:\\n        return sum(accumulate(nums, lambda a, x: 0 if x else a + 1, initial=0))\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3322449,
                "title": "2-approach-easy-java-solution",
                "content": "# Approach 1\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public long zeroFilledSubarray(int[] nums) {\\n        int start = 0, curr = 1;\\n        long res = 0;\\n        while(curr < nums.length){\\n            if(nums[curr] != 0 && nums[curr-1] == 0){\\n                long length = curr - start;\\n                res += length*(length+1)/2;\\n                start = curr+1;\\n            } else if(nums[curr] != 0 && nums[curr-1] != 0) {\\n                start = curr+1;\\n            } else if(nums[curr] == 0 && nums[curr-1] != 0){\\n                start = curr;\\n            }\\n            curr++;\\n        }\\n        if(nums[curr-1] == 0){\\n            long length = curr - start;\\n            res += length*(length+1)/2;\\n        }\\n        return res;\\n    }\\n}\\n```\\n\\n# Approach 2\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n```\\nclass Solution {\\n    public long zeroFilledSubarray(int[] nums) {\\n        long res = 0;\\n        long length = 0;\\n        for(int num : nums){\\n            if(num == 0){\\n                res += ++length;\\n            } else {\\n                length = 0;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public long zeroFilledSubarray(int[] nums) {\\n        int start = 0, curr = 1;\\n        long res = 0;\\n        while(curr < nums.length){\\n            if(nums[curr] != 0 && nums[curr-1] == 0){\\n                long length = curr - start;\\n                res += length*(length+1)/2;\\n                start = curr+1;\\n            } else if(nums[curr] != 0 && nums[curr-1] != 0) {\\n                start = curr+1;\\n            } else if(nums[curr] == 0 && nums[curr-1] != 0){\\n                start = curr;\\n            }\\n            curr++;\\n        }\\n        if(nums[curr-1] == 0){\\n            long length = curr - start;\\n            res += length*(length+1)/2;\\n        }\\n        return res;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public long zeroFilledSubarray(int[] nums) {\\n        long res = 0;\\n        long length = 0;\\n        for(int num : nums){\\n            if(num == 0){\\n                res += ++length;\\n            } else {\\n                length = 0;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2322447,
                "title": "c-easy-to-understand-single-loop",
                "content": "```\\npublic:\\n    long long zeroFilledSubarray(vector<int>& nums) {\\n        long long n=nums.size();\\n        vector<long long> v(n,0);\\n        if(nums[0]==0){\\n            v[0]=1;\\n        }\\n        for(int i=1;i<n;i++){\\n            if(nums[i]==0){\\n                v[i]=1+v[i-1];\\n            }\\n        }\\n        long long sum=0;\\n        for(int i=0;i<v.size();i++){\\n            sum+=v[i];\\n        }\\n        return sum;\\n    }\\n ```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\npublic:\\n    long long zeroFilledSubarray(vector<int>& nums) {\\n        long long n=nums.size();\\n        vector<long long> v(n,0);\\n        if(nums[0]==0){\\n            v[0]=1;\\n        }\\n        for(int i=1;i<n;i++){\\n            if(nums[i]==0){\\n                v[i]=1+v[i-1];\\n            }\\n        }\\n        long long sum=0;\\n        for(int i=0;i<v.size();i++){\\n            sum+=v[i];\\n        }\\n        return sum;\\n    }\\n ```",
                "codeTag": "Unknown"
            },
            {
                "id": 3427780,
                "title": "c-and-c-very-easy-solution-with-only-loops-explained",
                "content": "**The result is the sum of all combinations of subarrays which contains conyinious zeros.**\\n![photo_2023-04-17_21-57-53.jpg](https://assets.leetcode.com/users/images/c92da3d2-fc54-472f-ade7-4b2b532ad094_1681750829.9688196.jpeg)\\n![photo_2023-04-17_21-58-02.jpg](https://assets.leetcode.com/users/images/707fc2ef-72da-466d-b205-0ec020ca81f5_1681750840.3777895.jpeg)\\n```C++ []\\nclass Solution {\\npublic:\\n    long long zeroFilledSubarray(vector<int>& nums) {\\n    long long answer=0;\\n    int count=0;\\n    for(int i=0;i<nums.size();i++){\\n        if(nums[i]==0)\\n        count++;\\n        else{\\n            answer+= 1ll*count*(count+1)/2;\\n            count=0;\\n        }\\n    }\\n    answer+=1ll*count*(count+1)/2;\\n    return answer;\\n    }\\n};\\n```\\n\\n```C# []\\npublic class Solution {\\n    public long ZeroFilledSubarray(int[] nums) {\\n        long answer = 0;\\n    long count = 0;\\n    foreach (var item in nums) {\\n        if (item == 0) {\\n            ++count;\\n        } \\n        else {\\n            answer += count * (count + 1) / 2;\\n            count = 0;\\n        }\\n    }\\n    answer += count * (count + 1) / 2;\\n    return answer; \\n    }\\n}\\n```\\n\\n![Vote.png](https://assets.leetcode.com/users/images/f768dcc7-0c7b-4e7f-b767-c3e5bf001b78_1681750936.4194458.png)\\n",
                "solutionTags": [
                    "C++",
                    "C#",
                    "Array",
                    "Math"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    long long zeroFilledSubarray(vector<int>& nums) {\\n    long long answer=0;\\n    int count=0;\\n    for(int i=0;i<nums.size();i++){\\n        if(nums[i]==0)\\n        count++;\\n        else{\\n            answer+= 1ll*count*(count+1)/2;\\n            count=0;\\n        }\\n    }\\n    answer+=1ll*count*(count+1)/2;\\n    return answer;\\n    }\\n};\\n```\n```C# []\\npublic class Solution {\\n    public long ZeroFilledSubarray(int[] nums) {\\n        long answer = 0;\\n    long count = 0;\\n    foreach (var item in nums) {\\n        if (item == 0) {\\n            ++count;\\n        } \\n        else {\\n            answer += count * (count + 1) / 2;\\n            count = 0;\\n        }\\n    }\\n    answer += count * (count + 1) / 2;\\n    return answer; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3325284,
                "title": "easy-c-solution-calculation-based",
                "content": "# Intuition\\nFind the number of subarrays for each consecutive zeroes\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nFormula used = For n number the total subarrays can be generate are (n*(n+1))/2\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long zeroFilledSubarray(vector<int>& nums) {\\n        long long ct=0,ans=0;\\n        for(int i=0;i<nums.size();i++){\\n           // cout<<ans<<\" \";\\n            if(nums[i]==0)ct++;\\n            else if(nums[i]!=0){\\n                ans+=((ct+1)*ct)/2;\\n                ct=0;\\n            }\\n        }\\n         ans+=((ct+1)*ct)/2;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long zeroFilledSubarray(vector<int>& nums) {\\n        long long ct=0,ans=0;\\n        for(int i=0;i<nums.size();i++){\\n           // cout<<ans<<\" \";\\n            if(nums[i]==0)ct++;\\n            else if(nums[i]!=0){\\n                ans+=((ct+1)*ct)/2;\\n                ct=0;\\n            }\\n        }\\n         ans+=((ct+1)*ct)/2;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3322750,
                "title": "easy-py-cpp",
                "content": "# Code\\n```\\nclass Solution:\\n    def zeroFilledSubarray(self, nums: List[int]) -> int:\\n        a,b=0,0\\n        for i in nums:\\n            if not i:\\n                a+=1\\n                b+=a\\n            else:a=0\\n        return b\\n```\\n```\\nclass Solution {\\npublic:\\n    long long zeroFilledSubarray(vector<int>& nums) {\\n        long long ans=0;\\n        for(int p=0;p<nums.size();p++){\\n            long long int cnt=0;\\n            while((p<nums.size()) and nums[p]==0){\\n                p++;\\n                cnt++;\\n            }\\n            ans+=(cnt)*(cnt+1)/2;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution:\\n    def zeroFilledSubarray(self, nums: List[int]) -> int:\\n        a,b=0,0\\n        for i in nums:\\n            if not i:\\n                a+=1\\n                b+=a\\n            else:a=0\\n        return b\\n```\n```\\nclass Solution {\\npublic:\\n    long long zeroFilledSubarray(vector<int>& nums) {\\n        long long ans=0;\\n        for(int p=0;p<nums.size();p++){\\n            long long int cnt=0;\\n            while((p<nums.size()) and nums[p]==0){\\n                p++;\\n                cnt++;\\n            }\\n            ans+=(cnt)*(cnt+1)/2;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3322503,
                "title": "zero-filled-subarray-java-easy-understanding",
                "content": "Hi,\\n\\nMy intution is based on the math, as we need to count the number of subarrays of zero.\\n\\nMathematically to find the number of subarrays, we have to sum the element based on the continuous 0\\'s, for example :\\n\\n0 -> 1 = 1\\n0, 0 -> 1+2 = 3\\n0, 0, 0 -> 1+2+3 = 6\\n0, 0, 0, 0 -> 1+2+3+4 = 10\\n0, 0, 0, 0, 0 -> 1+2+3+4+5 = 15\\n\\nSo from the above explanation we can see on iterating through the given array and finding the count of continuous zero\\'s we can find the Number of zero filled subarrays.\\n\\nIf you have reached till here, you might have learnt something and found something useful I guess, Kindly upvote and spread love :) ....\\n\\n\\n```\\n    public long zeroFilledSubarray(int[] nums) {\\n        long sum=0;\\n        long count=0;\\n        for(int i:nums){\\n        \\tif(i==0)\\n        \\t\\tcount++;\\n        \\telse\\n        \\t\\tcount=0;\\n        \\tsum = sum + count;\\n        }\\n        return sum;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "Hi,\\n\\nMy intution is based on the math, as we need to count the number of subarrays of zero.\\n\\nMathematically to find the number of subarrays, we have to sum the element based on the continuous 0\\'s, for example :\\n\\n0 -> 1 = 1\\n0, 0 -> 1+2 = 3\\n0, 0, 0 -> 1+2+3 = 6\\n0, 0, 0, 0 -> 1+2+3+4 = 10\\n0, 0, 0, 0, 0 -> 1+2+3+4+5 = 15\\n\\nSo from the above explanation we can see on iterating through the given array and finding the count of continuous zero\\'s we can find the Number of zero filled subarrays.\\n\\nIf you have reached till here, you might have learnt something and found something useful I guess, Kindly upvote and spread love :) ....\\n\\n\\n```\\n    public long zeroFilledSubarray(int[] nums) {\\n        long sum=0;\\n        long count=0;\\n        for(int i:nums){\\n        \\tif(i==0)\\n        \\t\\tcount++;\\n        \\telse\\n        \\t\\tcount=0;\\n        \\tsum = sum + count;\\n        }\\n        return sum;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3322335,
                "title": "java-easiest-approach-fast-and-optimised",
                "content": "# Intuition\\nFind the number of **consecutive zeroes** in the array and add **n*n(+1)/2 **in the running sum, where is n is the number of consecutive zeroes in some part of the array.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe are finding the pattern in this problem.\\nFor example, `{1,2,0,0,0,5}` In this array, we have 3 consecutive ones.\\nNumber of time 0 appear 3 times = 1\\nNumber of time 0 appear 2 times = 2\\nNumber of time 0 appear 1 times = 3\\nTotal = 1 + 2 + 3 = 6\\nwhich is nothing but 3*(3+1)/2.\\nIn general, `n*(n+1)/2`, where n is the number of consecutive zeroes.\\nThus, we iterate over the array and add thereby add the result in the running sum.\\nAt last return the sum.\\n\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long zeroFilledSubarray(int[] nums) {\\n        long ans = 0;\\n        long zer = 0;\\n        int i = 0;\\n        int n = nums.length;\\n        while(i<n){\\n            if(nums[i]!=0){\\n                ans += zer*(zer+1)/2;\\n                zer = 0;\\n            }else{\\n                zer++;\\n            }\\n            i++;\\n        }\\n        ans += zer*(zer+1)/2;\\n        return ans;\\n    }\\n}\\n// IF YOU LIKE THE SOLUTION JUST IN CASE PLEASE UPVOTE.\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public long zeroFilledSubarray(int[] nums) {\\n        long ans = 0;\\n        long zer = 0;\\n        int i = 0;\\n        int n = nums.length;\\n        while(i<n){\\n            if(nums[i]!=0){\\n                ans += zer*(zer+1)/2;\\n                zer = 0;\\n            }else{\\n                zer++;\\n            }\\n            i++;\\n        }\\n        ans += zer*(zer+1)/2;\\n        return ans;\\n    }\\n}\\n// IF YOU LIKE THE SOLUTION JUST IN CASE PLEASE UPVOTE.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3321886,
                "title": "easy-solutions-in-java-python-and-c-look-at-once",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTo find the number of subarrays filled with 0 in an array, we need to count the number of subarrays ending at each index that are filled with 0. For example, in the array [1, 0, 0, 2, 0, 3, 0], there are 4 subarrays ending at index 2 that are filled with 0: [0], [0, 0], [1, 0, 0], and [0, 0, 2, 0, 0]. Therefore, the total number of subarrays filled with 0 in the array is the sum of the number of subarrays filled with 0 ending at each index.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can use a simple approach to count the number of subarrays filled with 0. We iterate over the array and keep track of the count of consecutive zeros seen so far. Whenever we encounter a non-zero element, we reset the count to 0. For each zero encountered, we increment the count and add it to the answer. This works because the count represents the number of subarrays ending at the current position that are filled with 0.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n The time complexity of this approach is $$O(n)$$, where n is the length of the array. This is because we iterate over the array once.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of this approach is $$O(1)$$, because we only use a constant amount of extra space to store the count and answer.\\n\\n\\n\\n![image.png](https://assets.leetcode.com/users/images/b427e686-2e5d-469a-8e7a-db5140022a6b_1677715904.0948765.png)\\n\\n\\n# Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\nPlease give my solution an upvote! \\uD83D\\uDC4D\\nIt\\'s a simple way to show your appreciation and\\nkeep me motivated. Thank you! \\uD83D\\uDE0A\\n```\\n# Code\\n``` Java []\\nclass Solution {\\n    public long zeroFilledSubarray(int[] nums) {\\n        int n = nums.length;\\n        long ans = 0;\\n        int count = 0; // count of consecutive zeros\\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] == 0) {\\n                count++;\\n                ans += count; // add count to answer\\n            } else {\\n                count = 0; // reset count\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\\n\\n```\\n``` C++ []\\nclass Solution {\\npublic:\\n    long long zeroFilledSubarray(vector<int>& nums) {\\n        int n = nums.size();\\n        long long ans = 0;\\n        int count = 0; // count of consecutive zeros\\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] == 0) {\\n                count++;\\n                ans += count; // add count to answer\\n            } else {\\n                count = 0; // reset count\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n\\n```\\n``` Python []\\nclass Solution(object):\\n    def zeroFilledSubarray(self, nums):\\n        n = len(nums)\\n        ans = 0\\n        count = 0 # count of consecutive zeros\\n        for i in range(n):\\n            if nums[i] == 0:\\n                count += 1\\n                ans += count # add count to answer\\n            else:\\n                count = 0 # reset count\\n        return ans\\n\\n\\n```\\n\\n# Please Comment\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\\nThanks for visiting my solution comment below if you like it.\\uD83D\\uDE0A\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Array",
                    "Math"
                ],
                "code": "```\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\nPlease give my solution an upvote! \\uD83D\\uDC4D\\nIt\\'s a simple way to show your appreciation and\\nkeep me motivated. Thank you! \\uD83D\\uDE0A\\n```\n``` Java []\\nclass Solution {\\n    public long zeroFilledSubarray(int[] nums) {\\n        int n = nums.length;\\n        long ans = 0;\\n        int count = 0; // count of consecutive zeros\\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] == 0) {\\n                count++;\\n                ans += count; // add count to answer\\n            } else {\\n                count = 0; // reset count\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\\n\\n```\n``` C++ []\\nclass Solution {\\npublic:\\n    long long zeroFilledSubarray(vector<int>& nums) {\\n        int n = nums.size();\\n        long long ans = 0;\\n        int count = 0; // count of consecutive zeros\\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] == 0) {\\n                count++;\\n                ans += count; // add count to answer\\n            } else {\\n                count = 0; // reset count\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n\\n```\n``` Python []\\nclass Solution(object):\\n    def zeroFilledSubarray(self, nums):\\n        n = len(nums)\\n        ans = 0\\n        count = 0 # count of consecutive zeros\\n        for i in range(n):\\n            if nums[i] == 0:\\n                count += 1\\n                ans += count # add count to answer\\n            else:\\n                count = 0 # reset count\\n        return ans\\n\\n\\n```\n```\\nThanks for visiting my solution comment below if you like it.\\uD83D\\uDE0A\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3321865,
                "title": "daily-leetcoding-challenge-march-day-21",
                "content": "This problem is the Daily LeetCoding Challenge for March, Day 21.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/number-of-zero-filled-subarrays/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 0 approach in the official solution</summary>\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/number-of-zero-filled-subarrays/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 2322688,
                "title": "simple-subarray-count",
                "content": "```\\n long long zeroFilledSubarray(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        long long int ans =0;\\n        long long int temp =0;\\n        for(int i=0;i<n;i++)\\n        {\\n            \\n            if(nums[i]==0)\\n            {\\n                temp++;\\n                ans+=temp;\\n            }\\n            else{\\n                temp=0;\\n            }\\n            \\n        }\\n        return ans;\\n        \\n    }\\n\\t```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n long long zeroFilledSubarray(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        long long int ans =0;\\n        long long int temp =0;\\n        for(int i=0;i<n;i++)\\n        {\\n            \\n            if(nums[i]==0)\\n            {\\n                temp++;\\n                ans+=temp;\\n            }\\n            else{\\n                temp=0;\\n            }\\n            \\n        }\\n        return ans;\\n        \\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 3325832,
                "title": "java-solution-no-2-pointer-just-simple-loop-o-n",
                "content": "# Intuition:\\n0 --> 1 \\n00---> 3 (1+number of current zeroes ie., 2)\\n000---> 6 ( 3+ number of current zeroes i.e., 3)\\n=> current number of zeroes + number of zeroes in previous subarray\\n* So for every zero we will keep updating the count of zeroes and simultaneously keep it adding in the answer as well.\\n* And for every non-zero we will reset the counter to 0.\\n\\n**TC: O(N)\\nSC: O(1)**\\n\\n\\n**PLEASE UPVOTE !**\\n\\n\\n\\n***Code in JAVA:***\\n\\n```\\nclass Solution {\\n    public long zeroFilledSubarray(int[] nums) {\\n        long ans=0;\\n        long c=0;\\n        for(int i:nums)\\n        {\\n            if(i==0)\\n            {\\n                c++;  //current number of zeroes\\n                ans+=c; //previous number of zeoes + current number of zeroes\\n            }\\n            else\\n                c=0; //reset counter to 0\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long zeroFilledSubarray(int[] nums) {\\n        long ans=0;\\n        long c=0;\\n        for(int i:nums)\\n        {\\n            if(i==0)\\n            {\\n                c++;  //current number of zeroes\\n                ans+=c; //previous number of zeoes + current number of zeroes\\n            }\\n            else\\n                c=0; //reset counter to 0\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3323829,
                "title": "java-solution-betas-99-95-sliding-window-approach",
                "content": "# Approach\\nThe problem description needs the total subarrays with only `0`.\\n\\nThis algorithm used `left` and `right`pointers as the starting and ending point of sliding window. We set the window as subarray which only includes `0`. \\n\\nTo count the total subarrays i have used the formula `right - left + 1` which gives the total subarrays in between `left` and `right` indices.\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long zeroFilledSubarray(int[] nums) {\\n        int left = 0,right = 0;\\n        long ans = 0;\\n        while(right != nums.length){\\n            if(nums[right] != 0){\\n                right++;\\n                left = right;\\n            }\\n            else{\\n                ans += right - left + 1;\\n                right++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\nPlease Do Upvote !! :(\\n\\nThank You",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public long zeroFilledSubarray(int[] nums) {\\n        int left = 0,right = 0;\\n        long ans = 0;\\n        while(right != nums.length){\\n            if(nums[right] != 0){\\n                right++;\\n                left = right;\\n            }\\n            else{\\n                ans += right - left + 1;\\n                right++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3323823,
                "title": "c-easy-code",
                "content": "# Complexity\\n- Time complexity: **O(n)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(1)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long zeroFilledSubarray(vector<int>& nums) {\\n        long long c=0;\\n        long long lg=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==0)lg++;\\n            else {\\n                lg=0;\\n            }\\n            c += lg;\\n        }\\n        return c;\\n    }\\n};\\n```\\n![upvote (3).jpg](https://assets.leetcode.com/users/images/ac430516-d8da-4bd7-a3da-64d5b14429d9_1679392200.1042557.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long zeroFilledSubarray(vector<int>& nums) {\\n        long long c=0;\\n        long long lg=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==0)lg++;\\n            else {\\n                lg=0;\\n            }\\n            c += lg;\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3322940,
                "title": "c-intuitive-approach",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution \\n{\\npublic:\\n    long long zeroFilledSubarray(vector<int>& nums) \\n    {\\n        long long count = 0;\\n        long long ans = 0;\\n        \\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            if(nums[i]==0) //count number of subarray for continuous 0s.\\n            {\\n                count++;\\n                ans += count;\\n            }\\n            else //If current element is not zero then count will be 0.\\n            {\\n                count = 0;\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    long long zeroFilledSubarray(vector<int>& nums) \\n    {\\n        long long count = 0;\\n        long long ans = 0;\\n        \\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            if(nums[i]==0) //count number of subarray for continuous 0s.\\n            {\\n                count++;\\n                ans += count;\\n            }\\n            else //If current element is not zero then count will be 0.\\n            {\\n                count = 0;\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3322916,
                "title": "simple-math-c-image-explanation",
                "content": "# Intuition\\n*Let say we have 5 consecutive zero.*\\n*From 5 consecutive zero we can form 5 subarray of size 1*\\n*From 5 consecutive zero we can form 4 subarray of size 2*\\n*From 5 consecutive zero we can form 3 subarray of size 3*\\n*From 5 consecutive zero we can form 2 subarray of size 4*\\n*From 5 consecutive zero we can form 1 subarray of size 5*\\n\\n*So for 5 consecutive zero total will be 5+4+3+2+1 = 5*(5+1)/2  no of subarrays*\\n\\n![image.png](https://assets.leetcode.com/users/images/e2bd3e2a-fb5f-40c9-b6cc-3ec0f1d59e21_1679376716.1521926.png)\\n\\n\\n# Approach\\n*We have to calculate consecutive zeros*\\n*ex-for nums=[0,0,0,2,0,0] there will be 3 & 2 consecutive zeros*\\n*So for 3 total subarray will be 3*(3+1)/2 = 6*\\n*So for 2 total subarray will be 2*(2+1)/2 = 3*\\n*So ans will be 6+3 = 9*\\n\\n# Complexity\\n- Time complexity:\\n O(N)\\n\\n- Space complexity:\\n O(1)\\n\\n\\n![55nb8c.jpg](https://assets.leetcode.com/users/images/9da3d144-edf0-4f5b-b4a9-6de0677c16fc_1679376820.8645906.jpeg)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long zeroFilledSubarray(vector<int>& nums) {\\n        long long ans=0;\\n        long long  n=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(!nums[i]) n++;\\n            else\\n            {\\n                ans+= ((n*(n+1))/2);\\n                n=0;\\n            }\\n        }\\n         ans+= ((n*(n+1))/2);\\n         return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long zeroFilledSubarray(vector<int>& nums) {\\n        long long ans=0;\\n        long long  n=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(!nums[i]) n++;\\n            else\\n            {\\n                ans+= ((n*(n+1))/2);\\n                n=0;\\n            }\\n        }\\n         ans+= ((n*(n+1))/2);\\n         return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3321957,
                "title": "java-easy-solution-100-faster-code-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public long zeroFilledSubarray(int[] nums) {\\n        long res = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            int cur = 0;\\n            while (i < nums.length && nums[i] == 0) {\\n                cur += 1;\\n                res += cur;\\n                i++;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long zeroFilledSubarray(int[] nums) {\\n        long res = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            int cur = 0;\\n            while (i < nums.length && nums[i] == 0) {\\n                cur += 1;\\n                res += cur;\\n                i++;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2323886,
                "title": "python-o-n-sliding-window",
                "content": "```\\n#Baraa\\nclass Solution:\\n    def zeroFilledSubarray(self, nums: List[int]) -> int:\\n        i = 0\\n        res = 0\\n        for j in range(len(nums)):\\n            if nums[j] != 0:\\n                i = j + 1\\n            else:\\n                res += (j - i + 1)\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n#Baraa\\nclass Solution:\\n    def zeroFilledSubarray(self, nums: List[int]) -> int:\\n        i = 0\\n        res = 0\\n        for j in range(len(nums)):\\n            if nums[j] != 0:\\n                i = j + 1\\n            else:\\n                res += (j - i + 1)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2322545,
                "title": "easy-c-soltuion-just-by-iterating-the-vector-once-easy-and-understandable",
                "content": "```\\nlong long zeroFilledSubarray(vector<int>& nums) {\\n        long long n= nums.size();\\n        long long i,cnt=0,ans=0;\\n        for(i=0;i<n;i++){\\n            if(nums[i]==0){\\n                cnt++;\\n            }\\n            else{\\n                ans+=((cnt*(cnt+1))/2);\\n                cnt=0;\\n            }\\n        }\\n        ans+=((cnt*(cnt+1))/2);\\n        return ans;\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nlong long zeroFilledSubarray(vector<int>& nums) {\\n        long long n= nums.size();\\n        long long i,cnt=0,ans=0;\\n        for(i=0;i<n;i++){\\n            if(nums[i]==0){\\n                cnt++;\\n            }\\n            else{\\n                ans+=((cnt*(cnt+1))/2);\\n                cnt=0;\\n            }\\n        }\\n        ans+=((cnt*(cnt+1))/2);\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2322301,
                "title": "java-tc-o-n-sc-o-1-explanation-easy",
                "content": "**Explanation:**\\nSample flow of given example \\n```\\nArray     1 3 0 0 2 0 0 4\\nPrev    0 0 0 1 2 0 1 2 0\\nCount   0 0 0 1 3 0 4 6 0\\n```\\n**Solution:**\\n```\\nclass Solution {\\n    public long zeroFilledSubarray(int[] nums) {\\n        long prev = 0;\\n        long count = 0;\\n        \\n        for (int num: nums) {\\n            if (num == 0) {\\n                ++ prev;\\n                count += prev;\\n            } else {\\n                prev = 0;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nArray     1 3 0 0 2 0 0 4\\nPrev    0 0 0 1 2 0 1 2 0\\nCount   0 0 0 1 3 0 4 6 0\\n```\n```\\nclass Solution {\\n    public long zeroFilledSubarray(int[] nums) {\\n        long prev = 0;\\n        long count = 0;\\n        \\n        for (int num: nums) {\\n            if (num == 0) {\\n                ++ prev;\\n                count += prev;\\n            } else {\\n                prev = 0;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3700781,
                "title": "w-explanation-easy-c-n-n-1-2-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nLet\\'s begin with the very case for nums=[0,0,0,0].\\nThere are 4 occurrences of [0] as a subarray.\\nThere are 3 occurrences of [0,0] as a subarray.\\nThere are 2 occurrence of [0,0,0] as a subarray.\\nThere is 1 occurrence of [0,0,0,0 ] as a subarray.\\n4+3+2+1=4*(4+1)/2=10\\n\\nIn a similar way, when nums is filled with N times 0, it is not hard to conclude that there are exactly N*(N+1)/2 subarrays filled with 0.\\n\\n[Please turn on English subtitles if necessary]\\n[https://www.youtube.com/watch?v=0TLqEanwcV0](https://www.youtube.com/watch?v=0TLqEanwcV0)\\nI also used the similar idea to solve the problem \"can-place-flowers\"!\\n[https://leetcode.com/problems/can-place-flowers/solutions/3326979/c-solution-finding-maximal-0-filled-subarrays-beats-92-46/](https://leetcode.com/problems/can-place-flowers/solutions/3326979/c-solution-finding-maximal-0-filled-subarrays-beats-92-46/)\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTo reduce the if-branch, 1 is appended to the array nums.\\nUse the loop to find out the lengths N\\'s of  maximal subarrays filling with 0. Then use the formula N*(N+1)/2 to sum up.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$O(1)$\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long zeroFilledSubarray(vector<int>& nums) {\\n        nums.push_back(1);\\n        int&& s=nums.size();\\n        int a_len=0 , prev=1;\\n        long long sum=0;\\n        for (int i=0; i<s; i++){\\n            if (nums[i]==0){\\n                 a_len++;\\n                 prev=0;\\n            }     \\n            else if (prev==0)\\n            {\\n                sum+=(long long)a_len*(a_len+1)/2;\\n                a_len=0;\\n                prev=nums[i];\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long zeroFilledSubarray(vector<int>& nums) {\\n        nums.push_back(1);\\n        int&& s=nums.size();\\n        int a_len=0 , prev=1;\\n        long long sum=0;\\n        for (int i=0; i<s; i++){\\n            if (nums[i]==0){\\n                 a_len++;\\n                 prev=0;\\n            }     \\n            else if (prev==0)\\n            {\\n                sum+=(long long)a_len*(a_len+1)/2;\\n                a_len=0;\\n                prev=nums[i];\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3347030,
                "title": "c-simple-solution-easy-to-understand",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- The function is called `zeroFilledSubarray`.\\n- It takes a vector of integers `nums` as input.\\n- It returns a long long integer as output.\\n- It initializes a counter variable `cnt` and a variable `ans` to store the answer.\\n- A dummy value of 1 is appended to the end of the vector `nums` to handle the last subarray.\\n- The function loops through the vector `nums`.\\n- If the current element is zero, the counter `cnt` is incremented.\\n- If the current element is non-zero and the counter `cnt` is non-zero, the function calculates the number of zero-filled subarrays that end at the previous non-zero element and adds it to the` ans `variable. The counter `cnt` is then reset to 0.\\n- The function returns the final answer stored in the `ans` variable.\\n\\n# (The calculation is done using the formula (cnt*(cnt+1))/2.)\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(N)$$ || N is the size of input vector\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(N)$$\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long zeroFilledSubarray(vector<int>& nums) {\\n    long long int cnt=0;    // initialize a counter variable\\n    long long int ans=0;    // initialize a variable to store the answer\\n    nums.push_back(1);      // append a dummy value to the end of the vector to handle the last subarray\\n    for(int i=0;i<nums.size();i++){   // loop through the vector\\n        \\n        if(nums[i]==0){    // if the current element is zero\\n        cnt++;            // increment the counter\\n        \\n        }\\n        else if(nums[i]!=0&&cnt!=0){   // if the current element is non-zero and the counter is non-zero\\n         ans+=(cnt*(cnt+1))/2;   // calculate the number of zero-filled subarrays that end at the previous non-zero element and add it to the answer\\n         cnt=0;                   // reset the counter\\n         }\\n      \\n    }\\n    return ans;    // return the final answer\\n}\\n\\n    \\n};\\n//Note that a dummy value of 1 is appended to the end of the vector to handle the last subarray, which may or may not be zero-filled.\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long zeroFilledSubarray(vector<int>& nums) {\\n    long long int cnt=0;    // initialize a counter variable\\n    long long int ans=0;    // initialize a variable to store the answer\\n    nums.push_back(1);      // append a dummy value to the end of the vector to handle the last subarray\\n    for(int i=0;i<nums.size();i++){   // loop through the vector\\n        \\n        if(nums[i]==0){    // if the current element is zero\\n        cnt++;            // increment the counter\\n        \\n        }\\n        else if(nums[i]!=0&&cnt!=0){   // if the current element is non-zero and the counter is non-zero\\n         ans+=(cnt*(cnt+1))/2;   // calculate the number of zero-filled subarrays that end at the previous non-zero element and add it to the answer\\n         cnt=0;                   // reset the counter\\n         }\\n      \\n    }\\n    return ans;    // return the final answer\\n}\\n\\n    \\n};\\n//Note that a dummy value of 1 is appended to the end of the vector to handle the last subarray, which may or may not be zero-filled.\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3326135,
                "title": "simple-maths-approach-c-please-upvote",
                "content": "# Intuition\\nThink of searching the sub arrays with 0s\\n\\n# Approach\\nAdd single 0s with other 0s occurences,it could be seen in the statement b=b+s that all occurences with more than one 0s can be added there and the returning value is q=b+s.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long zeroFilledSubarray(vector<int>& nums) {\\n        long k=0,s=0,b=0,q=0,x=nums.size();\\n       nums.push_back(1);\\n\\n        for(int i=0;i<x;i++){\\n             if(nums[i]!=0){\\n                k=0;\\n            }\\n            if(nums[i]==0 && nums[i+1]==0 ){\\n                k++;\\n                b=k+b;\\n            }\\n            if(nums[i]==0){\\n                s++;\\n            }\\n        }\\n        q=b+s;\\n        return q;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long zeroFilledSubarray(vector<int>& nums) {\\n        long k=0,s=0,b=0,q=0,x=nums.size();\\n       nums.push_back(1);\\n\\n        for(int i=0;i<x;i++){\\n             if(nums[i]!=0){\\n                k=0;\\n            }\\n            if(nums[i]==0 && nums[i+1]==0 ){\\n                k++;\\n                b=k+b;\\n            }\\n            if(nums[i]==0){\\n                s++;\\n            }\\n        }\\n        q=b+s;\\n        return q;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3325240,
                "title": "c-100-incredible-math-solution-using-ap-with-detailed-explanation-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nConcept of 2 level Arithmetic Progression (AP) to generate a math formula for n\\'th term\\n$$a,n = 0.5n(n+1)$$\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe number of arrangements possible for each count of zeroes\\n[0] - 1\\n[0,0] - 3\\n[0,0,0] - 6\\n[0,0,0,0] - 10\\n[0,0,0,0,0] -15\\n[0,0,0,0,0,0] - 21\\n\\n![image.png](https://assets.leetcode.com/users/images/67378ad8-0a4a-4a35-9492-2242b773793e_1679414023.6507678.png)\\n\\nSince the difference in the second row matches up, the nth term of the sequence has the general form of a second degree polynomial.\\n\\nSo,\\n![image.png](https://assets.leetcode.com/users/images/aa9b164d-96e5-4c1e-9a92-53a1bca20ba3_1679414243.9751155.png)\\n\\n![image.png](https://assets.leetcode.com/users/images/ecf75d16-581d-4b20-aaf3-6fc213141fde_1679414273.2310598.png)\\n\\n\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long zeroFilledSubarray(vector<int>& nums) {                \\n        long long ans=0;\\n        int c=0;\\n        for(int i=0;i<nums.size();i++) {\\n            if(nums[i]==0) \\n                c++;\\n            else {\\n                ans+=(0.5*c*(c+1));\\n                c=0;\\n            }                \\n        }        \\n        if(nums[nums.size()-1]==0)  \\n            ans+=(0.5*c*(c+1));\\n        return ans; \\n    }\\n};\\n\\n```\\n***Please Upvote !!***",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long zeroFilledSubarray(vector<int>& nums) {                \\n        long long ans=0;\\n        int c=0;\\n        for(int i=0;i<nums.size();i++) {\\n            if(nums[i]==0) \\n                c++;\\n            else {\\n                ans+=(0.5*c*(c+1));\\n                c=0;\\n            }                \\n        }        \\n        if(nums[nums.size()-1]==0)  \\n            ans+=(0.5*c*(c+1));\\n        return ans; \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3323861,
                "title": "cpp-solution-just-2-lines-of-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWork out some test cases and you\\'ll find a pattern which relates the consecutive zeroes and the correct result for the problem.\\n\\n# Approach \\nPattern : Keep counting the number of consecutive zeroes and add them in the solution, if the continuity breaks , start the count all over again by setting the counter variable to 0.\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long zeroFilledSubarray(vector<int>& nums) {\\n        long long ans,c = 0;\\n        for(auto&x:nums){\\n            (x==0)?c++:c=0;\\n            ans += c;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long zeroFilledSubarray(vector<int>& nums) {\\n        long long ans,c = 0;\\n        for(auto&x:nums){\\n            (x==0)?c++:c=0;\\n            ans += c;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3323178,
                "title": "one-liner-javascript-solution",
                "content": "\\n# One Liner:\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar zeroFilledSubarray = ((nums, counter = 0) =>\\n    nums.reduce((p, num) =>\\n        p + (counter = num === 0 ? counter + 1 : 0), 0)\\n)\\n```\\n\\nPlease upvote if helpful!",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Array"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar zeroFilledSubarray = ((nums, counter = 0) =>\\n    nums.reduce((p, num) =>\\n        p + (counter = num === 0 ? counter + 1 : 0), 0)\\n)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3322837,
                "title": "java-6-lines-simple-and-clean-solution-beats-99",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public long zeroFilledSubarray(int[] nums) {\\n    var ans = 0L;\\n    var cnt = 0L;\\n\\n    for (var n : nums) {\\n      if (n == 0) ans += ++cnt;\\n      else cnt = 0;\\n    }\\n    return ans;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n  public long zeroFilledSubarray(int[] nums) {\\n    var ans = 0L;\\n    var cnt = 0L;\\n\\n    for (var n : nums) {\\n      if (n == 0) ans += ++cnt;\\n      else cnt = 0;\\n    }\\n    return ans;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3322717,
                "title": "easiest-solution-ever-plz-upvote",
                "content": "class Solution {\\n    public long zeroFilledSubarray(int[] nums) {\\n        long count=0;\\n        long ans=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==0){\\n                while(i<nums.length && nums[i]==0){\\n                    count++;\\n                    i++;\\n                }\\n                ans+=(count*(count+1))/2;\\n                count=0;\\n            }\\n        }\\n        return ans;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public long zeroFilledSubarray(int[] nums) {\\n        long count=0;\\n        long ans=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==0){\\n                while(i<nums.length && nums[i]==0){\\n                    count++;\\n                    i++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3322567,
                "title": "c-easy-n-n-1-2-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nN(N+1)/2 \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ncalculate 0 subarray\\'s length \\nN(N+1)/2 for determining number of subarrays with that length of 0 subarray \\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long zeroFilledSubarray(vector<int>& nums) {\\n        long long ans=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==0){\\n                long long len=1;\\n                int j=i+1;\\n                while(j<nums.size() && nums[j]==0) j++;\\n                len=j-i;\\n                long long value=(len*(len+1))/2;\\n                ans+=value;\\n                i=j-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long zeroFilledSubarray(vector<int>& nums) {\\n        long long ans=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==0){\\n                long long len=1;\\n                int j=i+1;\\n                while(j<nums.size() && nums[j]==0) j++;\\n                len=j-i;\\n                long long value=(len*(len+1))/2;\\n                ans+=value;\\n                i=j-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3322313,
                "title": "simple-math-solution-c-beats-100-runtime",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUsing Math formula n*(n+1)/2 to calculate the number of possible sub-arrays of zeros within a given sub-array of zeros.\\n\\n #### *Please upvote if u like the solution..\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFind a possible continuous sub-array of zeros. If it\\'s length is \\'m\\' then the number of possible sub-arrays withing that sub-array of zeros can be calculated by the summation formula m*(m+1)/2\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n) as we need to iterate over the array once.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1) as we do not use any extra memory that grows with input size.\\n\\n# Code\\n```\\npublic class Solution {\\n    public long ZeroFilledSubarray(int[] nums) {\\n        long count = 0;\\n        long result = 0;\\n        for (int i = 0; i < nums.Length; i++)\\n        {\\n            if (nums[i] == 0)\\n                count++;\\n            else if (count > 0)\\n            {\\n                result += (count * (count + 1)) / 2;\\n                count = 0;\\n            }\\n        }\\n\\n        if (count > 0)\\n        {\\n            result += (count * (count + 1)) / 2;\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Array",
                    "Math"
                ],
                "code": "```\\npublic class Solution {\\n    public long ZeroFilledSubarray(int[] nums) {\\n        long count = 0;\\n        long result = 0;\\n        for (int i = 0; i < nums.Length; i++)\\n        {\\n            if (nums[i] == 0)\\n                count++;\\n            else if (count > 0)\\n            {\\n                result += (count * (count + 1)) / 2;\\n                count = 0;\\n            }\\n        }\\n\\n        if (count > 0)\\n        {\\n            result += (count * (count + 1)) / 2;\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3322281,
                "title": "easy-c-solution",
                "content": "# Approach\\nNormal counting subarray approach\\n\\n# Complexity\\n- Time complexity:\\n $$O(n)$$ \\n\\n- Space complexity:\\n$$O(1)$$ \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long zeroFilledSubarray(vector<int>& nums) {\\n        long long lastidx=-1,ans=0;\\n        for(int i=0;i<nums.size();i++){\\n            while(i<nums.size() && nums[i]==0){\\n                ans+=i-lastidx;\\n                i++;\\n            }\\n            lastidx=i;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long zeroFilledSubarray(vector<int>& nums) {\\n        long long lastidx=-1,ans=0;\\n        for(int i=0;i<nums.size();i++){\\n            while(i<nums.size() && nums[i]==0){\\n                ans+=i-lastidx;\\n                i++;\\n            }\\n            lastidx=i;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3321909,
                "title": "rust-one-liner",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn zero_filled_subarray(nums: Vec<i32>) -> i64 {\\n        nums.into_iter().fold((0, 0), |a, n| if n == 0 {(a.0 + 1, a.0 + a.1 + 1)} else {(0, a.1)}).1\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn zero_filled_subarray(nums: Vec<i32>) -> i64 {\\n        nums.into_iter().fold((0, 0), |a, n| if n == 0 {(a.0 + 1, a.0 + a.1 + 1)} else {(0, a.1)}).1\\n    }\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3019475,
                "title": "go-100-time-100-memory-o-n-o-1",
                "content": "# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunc zeroFilledSubarray(nums []int) int64 {\\n    nums = append(nums, 1)\\n    var sum, zeros int64 = 0, 0\\n\\n    for _, n := range nums {\\n        if n == 0 {\\n            zeros++\\n        } else if zeros > 0 {\\n            // Add sum of an arithmetic sequence\\n            // n + n-1 + n-2 ... + 1 => n * (n+1) / 2\\n            // Where acc - number of zeros in serie\\n            sum += zeros * (zeros + 1) / 2\\n            zeros = 0\\n        }\\n    }\\n\\n    return sum\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc zeroFilledSubarray(nums []int) int64 {\\n    nums = append(nums, 1)\\n    var sum, zeros int64 = 0, 0\\n\\n    for _, n := range nums {\\n        if n == 0 {\\n            zeros++\\n        } else if zeros > 0 {\\n            // Add sum of an arithmetic sequence\\n            // n + n-1 + n-2 ... + 1 => n * (n+1) / 2\\n            // Where acc - number of zeros in serie\\n            sum += zeros * (zeros + 1) / 2\\n            zeros = 0\\n        }\\n    }\\n\\n    return sum\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2323435,
                "title": "sum-of-n-terms-c",
                "content": "```\\nclass Solution {\\npublic:\\n    long long zeroFilledSubarray(vector<int>& nums) {\\n        long long res = 0, counter = 0;\\n        for(auto &it: nums){\\n            if(it == 0)     \\n                ++counter;\\n            else{\\n                res += (counter * (counter + 1LL)) / 2;\\n                counter = 0;\\n            }\\n        }\\n        return res + (counter * (counter + 1LL)) / 2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long zeroFilledSubarray(vector<int>& nums) {\\n        long long res = 0, counter = 0;\\n        for(auto &it: nums){\\n            if(it == 0)     \\n                ++counter;\\n            else{\\n                res += (counter * (counter + 1LL)) / 2;\\n                counter = 0;\\n            }\\n        }\\n        return res + (counter * (counter + 1LL)) / 2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2323237,
                "title": "java-find-maximum-consecutive-zeros",
                "content": "```\\nclass Solution {\\n\\tpublic long zeroFilledSubarray(int[] arr) {\\n\\t\\tlong count = 0;\\n\\t\\tlong sum = 0;\\n\\t\\tfor (int i = 0; i < arr.length; i++) {\\n\\t\\t\\tif (arr[i] == 0) {\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tsum += (count * (count + 1) / 2);\\n\\t\\t\\t\\tcount = 0;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (arr[arr.length - 1] == 0) {\\n\\t\\t\\tsum += (count * (count + 1) / 2);\\n\\t\\t}\\n\\t\\treturn sum;\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\tpublic long zeroFilledSubarray(int[] arr) {\\n\\t\\tlong count = 0;\\n\\t\\tlong sum = 0;\\n\\t\\tfor (int i = 0; i < arr.length; i++) {\\n\\t\\t\\tif (arr[i] == 0) {\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tsum += (count * (count + 1) / 2);\\n\\t\\t\\t\\tcount = 0;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (arr[arr.length - 1] == 0) {\\n\\t\\t\\tsum += (count * (count + 1) / 2);\\n\\t\\t}\\n\\t\\treturn sum;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2322982,
                "title": "java-easy-one-pass-solution-w-explanation",
                "content": "```\\nclass Solution {\\n    public long zeroFilledSubarray(int[] nums) {\\n        long len = 0;\\n        long ans = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] == 0) ++len;\\n            else if (len > 0) {\\n                ans += (len * (len + 1)) / 2;\\n                len = 0;\\n            }\\n        }\\n        if (len > 0) ans += (len * (len + 1)) / 2;\\n        return ans;\\n    }\\n}\\n```\\nIntuition: \\nSee the problem different from how its explained. Take this subarray `0, 0, 0, 0`. From this there will be <br>\\nSize 1  -> 4 subarrays -> [1 to 1] [2 to 2] [3 to 3] [4 to 4]\\nSize 2  -> 3 subarrays -> [1 to 2] [2 to 3] [3 to 4]\\nSize 3  -> 2 subarrays -> [1 to 3] [2 to 4]\\nSize 4  -> 1 subarray  ->  [1 to 4]\\nSo the sum of all the subarrays would be `4 + 3 + 2 + 1`. From this you can see that, if a subarray is of size `n`, the number of subarrays generated from that would be sum of 1 to n, which we can get by `S(n) = (n * (n + 1)) / 2 `",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long zeroFilledSubarray(int[] nums) {\\n        long len = 0;\\n        long ans = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] == 0) ++len;\\n            else if (len > 0) {\\n                ans += (len * (len + 1)) / 2;\\n                len = 0;\\n            }\\n        }\\n        if (len > 0) ans += (len * (len + 1)) / 2;\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2322724,
                "title": "100-faster-c-solution-easiest-solution",
                "content": "Please upvote if this solution helps you :)\\n```\\n\\nclass Solution {\\npublic:\\n    long long zeroFilledSubarray(vector<int>& nums) {\\n        int n=nums.size();\\n        int count=0;\\n        long long sum=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]==0)\\n            {\\n                count++;\\n                sum+=count;\\n            }\\n            else\\n                count=0;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    long long zeroFilledSubarray(vector<int>& nums) {\\n        int n=nums.size();\\n        int count=0;\\n        long long sum=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]==0)\\n            {\\n                count++;\\n                sum+=count;\\n            }\\n            else\\n                count=0;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2322571,
                "title": "single-iteration-o-n-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    long long zeroFilledSubarray(vector<int>& nums) {\\n        long long ans=0;\\n        int count=1;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]==0)ans+=count++;\\n            else count=1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long zeroFilledSubarray(vector<int>& nums) {\\n        long long ans=0;\\n        int count=1;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]==0)ans+=count++;\\n            else count=1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2322517,
                "title": "math-cpp-easy-with-explanation-time-o-n-space-o-1",
                "content": "Explanation- \\nIf you have 4 zeors together in subarray then we have \\nzeros  :number\\n\\t4       1\\n\\t3       2\\n\\t2       3\\n\\t1       4\\n\\tThis is sum of n natural numbers - n(n+1)/2\\n```\\nclass Solution {\\npublic:\\n    long long zeroFilledSubarray(vector<int>& nums) {\\n        long long result=0;\\n        long long count =0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]==0)\\n                count++;\\n            else\\n            {\\n                result=result+(count*(count+1))/2;\\n                count=0;\\n            }\\n            \\n        }\\n        return result+(count*(count+1))/2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long zeroFilledSubarray(vector<int>& nums) {\\n        long long result=0;\\n        long long count =0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]==0)\\n                count++;\\n            else\\n            {\\n                result=result+(count*(count+1))/2;\\n                count=0;\\n            }\\n            \\n        }\\n        return result+(count*(count+1))/2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2322329,
                "title": "easy-java-solution-using-trivial-formula",
                "content": "\\n**Intuition:**\\nTotal number of subset in a array of size n is found using n*(n+1)/2\\nSo if we find all the sub-arrays containing only 0 then we can apply out formula and\\nthe final answer would be the sum of all the sub array count \\n\\t\\n```\\nclass Solution {\\n    \\n    public long zeroFilledSubarray(int[] nums) {\\n        \\n        // find range of all the subsets of 0\\n        HashMap<Integer, Integer> map  = new HashMap<>();\\n        long ssCnt = 0L;\\n        int i = 0, n = nums.length;\\n        \\n        while(i < n){\\n            if(nums[i] != 0){\\n                i++;\\n                continue;\\n            };\\n            \\n            int j = i;\\n            while(j+1 < n){\\n                if(nums[j+1] == 0){\\n                    j++;\\n                }else{\\n                    break;\\n                }\\n            }\\n            \\n            map.put(i, (j-i+1));\\n            \\n            i = j+1;\\n        }\\n            \\n        for (Integer r : map.values()) {\\n            Long R = 1L * r;\\n            long temp = 1L* (R*(R+1))/2;\\n            ssCnt += temp;\\n        }\\n        \\n        return ssCnt;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public long zeroFilledSubarray(int[] nums) {\\n        \\n        // find range of all the subsets of 0\\n        HashMap<Integer, Integer> map  = new HashMap<>();\\n        long ssCnt = 0L;\\n        int i = 0, n = nums.length;\\n        \\n        while(i < n){\\n            if(nums[i] != 0){\\n                i++;\\n                continue;\\n            };\\n            \\n            int j = i;\\n            while(j+1 < n){\\n                if(nums[j+1] == 0){\\n                    j++;\\n                }else{\\n                    break;\\n                }\\n            }\\n            \\n            map.put(i, (j-i+1));\\n            \\n            i = j+1;\\n        }\\n            \\n        for (Integer r : map.values()) {\\n            Long R = 1L * r;\\n            long temp = 1L* (R*(R+1))/2;\\n            ssCnt += temp;\\n        }\\n        \\n        return ssCnt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2322319,
                "title": "c-with-explanation",
                "content": "**Explanation:-**\\n1. Just count continuous zeros and add to the result.\\n2.  If count at any index  is \"k\" then subarrays ending at this index in k.So add it to the result.\\n```\\nclass Solution {\\npublic:\\n    long long zeroFilledSubarray(vector<int>& nums) {\\n        long ans=0,cnt=0;\\n        for(auto & i:nums){\\n            if(i==0)\\n                ans+=++cnt;\\n            else\\n                cnt=0;\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```\\nDo **UPVOTE** if it helps :)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long zeroFilledSubarray(vector<int>& nums) {\\n        long ans=0,cnt=0;\\n        for(auto & i:nums){\\n            if(i==0)\\n                ans+=++cnt;\\n            else\\n                cnt=0;\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2322314,
                "title": "n-n-1-2-o-1-space-java-c",
                "content": "**Intuition**\\n    We just have to have a window of [s,l) every time such that all the element between them are zero\\n    then we will just need to get their length and compute the formula of n*(n+1)/2.\\n    \\n    \\n  **Algorithm**:\\n    \\n   1. move start from its postion uptil it doesn\\'t reach a zero.\\n    2. Then move the end from start towards until it reaches a non-zero value\\n    3.  Now between start and end all are zero, we just need to compute the count of subarrays between range [start,end)\\n    4. We know that for length of array N , the formula for counting subarrays is N*(N+1)/2.\\n    5. Here length will be (end-start)\\n    6.  Just keep repeating above step.\\n                                                                                                            \\n                                                                                                            \\n **C++**\\n                                                                                                            \\n    long long zeroFilledSubarray(vector<int>& a) {\\n        long cnt=0;\\n        int n= size(a);\\n        for(int start=0;start<n;){\\n            while(start<n and a[start]!=0) start++;       //reach to a zero value.\\n            for(int end=start;end<n and a[end]==0;end++); //reach to a non-zero value.\\n            long len= end-start; //now get length for getting count of subarray.\\n            cnt+= len*(len+1)/2; //Formula for counting subarray in the range.\\n            start= end;          //update and move from end as it indicates the start of next part\\n        }\\n        return cnt;\\n    }\\n                                                                                                            \\n **Java**\\n\\n    public long zeroFilledSubarray(int[] a) {\\n        long cnt=0;\\n        int n= a.length;\\n        for(int start=0;start<n;){\\n            for(;start<n && a[start]!=0;start++); //reach to a zero value.\\n            int end=start;\\n            for(;end<n && a[end]==0;end++); //reach to a non-zero value.\\n            long len= end-start; //now get length for getting count of subarray.\\n            cnt+= len*(len+1)/2; //Formula for counting subarray in the range.\\n            start= end;          //update and move from end as it indicates the start of next part\\n        }\\n        return cnt;\\n    }\\n                                                                                                            \\n  **Time** - O(N) {Any element is accessed atmost two times i.e by start and end pointer once by each}\\n  **Space** - O(1)                                                                                                           \\n                                                                                                              \\n",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "**Intuition**\\n    We just have to have a window of [s,l) every time such that all the element between them are zero\\n    then we will just need to get their length and compute the formula of n*(n+1)/2.\\n    \\n    \\n  **Algorithm**:\\n    \\n   1. move start from its postion uptil it doesn\\'t reach a zero.\\n    2. Then move the end from start towards until it reaches a non-zero value\\n    3.  Now between start and end all are zero, we just need to compute the count of subarrays between range [start,end)\\n    4. We know that for length of array N , the formula for counting subarrays is N*(N+1)/2.\\n    5. Here length will be (end-start)\\n    6.  Just keep repeating above step.\\n                                                                                                            \\n                                                                                                            \\n **C++**\\n                                                                                                            \\n    long long zeroFilledSubarray(vector<int>& a) {\\n        long cnt=0;\\n        int n= size(a);\\n        for(int start=0;start<n;){\\n            while(start<n and a[start]!=0) start++;       //reach to a zero value.\\n            for(int end=start;end<n and a[end]==0;end++); //reach to a non-zero value.\\n            long len= end-start; //now get length for getting count of subarray.\\n            cnt+= len*(len+1)/2; //Formula for counting subarray in the range.\\n            start= end;          //update and move from end as it indicates the start of next part\\n        }\\n        return cnt;\\n    }\\n                                                                                                            \\n **Java**\\n\\n    public long zeroFilledSubarray(int[] a) {\\n        long cnt=0;\\n        int n= a.length;\\n        for(int start=0;start<n;){\\n            for(;start<n && a[start]!=0;start++); //reach to a zero value.\\n            int end=start;\\n            for(;end<n && a[end]==0;end++); //reach to a non-zero value.\\n            long len= end-start; //now get length for getting count of subarray.\\n            cnt+= len*(len+1)/2; //Formula for counting subarray in the range.\\n            start= end;          //update and move from end as it indicates the start of next part\\n        }\\n        return cnt;\\n    }\\n                                                                                                            \\n  **Time** - O(N) {Any element is accessed atmost two times i.e by start and end pointer once by each}\\n  **Space** - O(1)                                                                                                           \\n                                                                                                              \\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2322285,
                "title": "simple-brute-force",
                "content": "```\\nclass Solution {\\npublic:\\n    long long zeroFilledSubarray(vector<int>& nums) {\\n        long long count = 0;\\n        long long ans = 0;\\n        for(int i=0; i<nums.size(); i++){\\n            if(nums[i]==0)\\n                count++;\\n            else{\\n                ans +=(count*(count+1))/2;\\n                count=0;\\n            }\\n        }\\n        if(count!=0)\\n             ans +=(count*(count+1))/2;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long zeroFilledSubarray(vector<int>& nums) {\\n        long long count = 0;\\n        long long ans = 0;\\n        for(int i=0; i<nums.size(); i++){\\n            if(nums[i]==0)\\n                count++;\\n            else{\\n                ans +=(count*(count+1))/2;\\n                count=0;\\n            }\\n        }\\n        if(count!=0)\\n             ans +=(count*(count+1))/2;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2322283,
                "title": "javascript-greedy",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar zeroFilledSubarray = function(nums) {\\n  let numOfSubarray = 0\\n    \\n  for (let i = 0; i < nums.length; i++) {\\n    if (nums[i] === 0) {\\n      let j = i\\n      while (nums[j] === 0 && j < nums.length) {\\n        j++\\n      }\\n      \\n      numOfSubarray += (j - i + 1) * (j - i) / 2\\n      i = j\\n    }\\n  }\\n  \\n  return numOfSubarray\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Greedy"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar zeroFilledSubarray = function(nums) {\\n  let numOfSubarray = 0\\n    \\n  for (let i = 0; i < nums.length; i++) {\\n    if (nums[i] === 0) {\\n      let j = i\\n      while (nums[j] === 0 && j < nums.length) {\\n        j++\\n      }\\n      \\n      numOfSubarray += (j - i + 1) * (j - i) / 2\\n      i = j\\n    }\\n  }\\n  \\n  return numOfSubarray\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2322266,
                "title": "c-n-n-1-2",
                "content": "```\\n\\t\\tlong long streak = 0;\\n\\t\\tlong long zeroArrays = 0;\\n\\t\\tfor(auto x: nums){\\n\\t\\t\\tif(x == 0){\\n\\t\\t\\t\\tstreak++;\\n\\t\\t\\t}else{\\n\\t\\t\\t\\tif(streak){\\n\\t\\t\\t\\t\\tzeroArrays += (streak)*1LL*(streak+1)/2;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tstreak = 0;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif(streak){\\n\\t\\t\\tzeroArrays += (streak)*1LL*(streak+1)/2;\\n\\t\\t}\\n\\t\\treturn zeroArrays;\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\n\\t\\tlong long streak = 0;\\n\\t\\tlong long zeroArrays = 0;\\n\\t\\tfor(auto x: nums){\\n\\t\\t\\tif(x == 0){\\n\\t\\t\\t\\tstreak++;\\n\\t\\t\\t}else{\\n\\t\\t\\t\\tif(streak){\\n\\t\\t\\t\\t\\tzeroArrays += (streak)*1LL*(streak+1)/2;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tstreak = 0;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif(streak){\\n\\t\\t\\tzeroArrays += (streak)*1LL*(streak+1)/2;\\n\\t\\t}\\n\\t\\treturn zeroArrays;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3897395,
                "title": "single-pass-beats-80-self-explainable-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    long long zeroFilledSubarray(vector<int>& nums) {\\n        ll ans = 0;\\n        int value = 1;\\n        int i;\\n        for(i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]==0)\\n            {\\n                ans+=value;\\n                value++;\\n            }\\n            else\\n            {\\n                value = 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    long long zeroFilledSubarray(vector<int>& nums) {\\n        ll ans = 0;\\n        int value = 1;\\n        int i;\\n        for(i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]==0)\\n            {\\n                ans+=value;\\n                value++;\\n            }\\n            else\\n            {\\n                value = 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3837345,
                "title": "98-faster-easy-clean-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution\\n{\\npublic:\\n    long long zeroFilledSubarray(vector<int> &nums)\\n    {\\n        long long ans = 0;\\n        int n = nums.size();\\n        long long ct = 0;\\n\\n        for (int i = 0; i < n; i++)\\n        {\\n            if (nums[i] == 0)\\n                ct++;\\n\\n            else\\n            {\\n                ans += ct * (ct + 1) / 2;\\n                ct = 0;\\n            }\\n        }\\n\\n        ans += ct * (ct + 1) / 2;\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    long long zeroFilledSubarray(vector<int> &nums)\\n    {\\n        long long ans = 0;\\n        int n = nums.size();\\n        long long ct = 0;\\n\\n        for (int i = 0; i < n; i++)\\n        {\\n            if (nums[i] == 0)\\n                ct++;\\n\\n            else\\n            {\\n                ans += ct * (ct + 1) / 2;\\n                ct = 0;\\n            }\\n        }\\n\\n        ans += ct * (ct + 1) / 2;\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3326397,
                "title": "unveil-logic-with-crazy-solution",
                "content": "\\n\\n# Superb Logic---->O(N) \\n```\\nclass Solution:\\n    def zeroFilledSubarray(self, nums: List[int]) -> int:\\n        answer=count=0\\n        for i in nums:\\n            if i==0: count+=1\\n            else:count=0\\n            answer+=count\\n        return answer\\n\\n```\\n# please upvote me it would encourage me alot\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def zeroFilledSubarray(self, nums: List[int]) -> int:\\n        answer=count=0\\n        for i in nums:\\n            if i==0: count+=1\\n            else:count=0\\n            answer+=count\\n        return answer\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3326306,
                "title": "medium-beginner-friendly-fast",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nCount total zeros next to each other and add the total subarray to total sum.\\nIf there is 1 zero=>1.\\nIf there is 2 zero=>3.\\nIf there is 3 zero=>6;\\nIf there is 4 zero=>10;\\nIf there is 5 zero=>15;\\nIf there is 6 zero=>21;\\nIt is sum of n natural numbers\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSuppose the array is 10000123000\\nAt the start 4 zeros are together so sum is 10.\\nthen there are 3 zeros together so sum is 6.\\nSo total sum is 10+6=16.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long zeroFilledSubarray(vector<int>& nums) {\\n        int i,f=0;\\n        long long int p=0,j=0;\\n        for(i=0;i<nums.size();i++)\\n        {   \\n            //count total number of zeros next to each other\\n            if(nums[i]==0)\\n            {\\n                j++;\\n                //when f=0 means number is not zero so we got total number of zeros which are together.\\n                f=1;      \\n            }      \\n            //when we counted total zeros next to each other    \\n            if(f==0)\\n            {\\n                //counting total subarray by sum of natural numbers formula\\n                p+=j*(j+1)/2;\\n                j=0;\\n            }\\n            \\n        f=0;\\n        }\\n        p+=j*(j+1)/2;\\n        return p;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long zeroFilledSubarray(vector<int>& nums) {\\n        int i,f=0;\\n        long long int p=0,j=0;\\n        for(i=0;i<nums.size();i++)\\n        {   \\n            //count total number of zeros next to each other\\n            if(nums[i]==0)\\n            {\\n                j++;\\n                //when f=0 means number is not zero so we got total number of zeros which are together.\\n                f=1;      \\n            }      \\n            //when we counted total zeros next to each other    \\n            if(f==0)\\n            {\\n                //counting total subarray by sum of natural numbers formula\\n                p+=j*(j+1)/2;\\n                j=0;\\n            }\\n            \\n        f=0;\\n        }\\n        p+=j*(j+1)/2;\\n        return p;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3326250,
                "title": "java-easy-simple-solution-specifically-for-beginners-formula-based",
                "content": "# Approach\\nSimple **traversing** the array based solution, traverse the array and if finding zeroes, **increament the currCount** (variable). If finding number other than zero, then using the currCount, apply the formula \\n```\\nn*(n+1)/2\\n``` \\nfor possible subarrays. Update the currCount to 0 and continue...\\n\\n# Code\\n```\\nclass Solution \\n{\\n    public long zeroFilledSubarray(int[] nums) \\n    {\\n        long ans = 0;\\n        long currCount = 0;\\n\\n        for(int num : nums)\\n        {\\n            if(num != 0)\\n            {\\n                ans += count (currCount);\\n                currCount = 0;\\n            }\\n\\n            else\\n                currCount++;\\n        }\\n\\n        //exited out of traversing, but the last part were zeroes\\n        if(currCount != 0)\\n            ans += count (currCount);\\n\\n        return ans;\\n    }\\n\\n    //n here is number of zeroes\\n    static long count(long n)\\n    {  \\n        return n*(n+1)/2;\\n    }  \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Math",
                    "Divide and Conquer"
                ],
                "code": "```\\nn*(n+1)/2\\n```\n```\\nclass Solution \\n{\\n    public long zeroFilledSubarray(int[] nums) \\n    {\\n        long ans = 0;\\n        long currCount = 0;\\n\\n        for(int num : nums)\\n        {\\n            if(num != 0)\\n            {\\n                ans += count (currCount);\\n                currCount = 0;\\n            }\\n\\n            else\\n                currCount++;\\n        }\\n\\n        //exited out of traversing, but the last part were zeroes\\n        if(currCount != 0)\\n            ans += count (currCount);\\n\\n        return ans;\\n    }\\n\\n    //n here is number of zeroes\\n    static long count(long n)\\n    {  \\n        return n*(n+1)/2;\\n    }  \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3325897,
                "title": "easy-and-clear-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def zeroFilledSubarray(self, nums: List[int]) -> int:\\n        sm = 0\\n        count = 0\\n        for i in nums:\\n            if i == 0:\\n                count+=1\\n            elif count>0:\\n                y=count\\n                for j in range(count-1,0,-1):\\n                    y+=j\\n                sm+=y\\n                count=0\\n        for j in range(count,0,-1):\\n            sm+=j\\n        return sm\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def zeroFilledSubarray(self, nums: List[int]) -> int:\\n        sm = 0\\n        count = 0\\n        for i in nums:\\n            if i == 0:\\n                count+=1\\n            elif count>0:\\n                y=count\\n                for j in range(count-1,0,-1):\\n                    y+=j\\n                sm+=y\\n                count=0\\n        for j in range(count,0,-1):\\n            sm+=j\\n        return sm\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3325840,
                "title": "simple-counter-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    long long zeroFilledSubarray(vector<int>& nums) {\\n        long long ans=0;\\n        int n=nums.size();\\n        long long count=0;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]==0){\\n                count++;\\n                ans+=count;\\n            }\\n            else{\\n                // ans+=count*(count+1)/2;\\n                count=0;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long zeroFilledSubarray(vector<int>& nums) {\\n        long long ans=0;\\n        int n=nums.size();\\n        long long count=0;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]==0){\\n                count++;\\n                ans+=count;\\n            }\\n            else{\\n                // ans+=count*(count+1)/2;\\n                count=0;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3325577,
                "title": "just-in-js",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nvar zeroFilledSubarray = function(nums) {\\n    var res = 0, count = 0;\\n    for(let el of nums)\\n        if(el == 0) {\\n            count++;\\n            res += count;\\n        }\\n        else\\n            count = 0;\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array",
                    "Math"
                ],
                "code": "```\\nvar zeroFilledSubarray = function(nums) {\\n    var res = 0, count = 0;\\n    for(let el of nums)\\n        if(el == 0) {\\n            count++;\\n            res += count;\\n        }\\n        else\\n            count = 0;\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3325344,
                "title": "swift-solution-pointers",
                "content": "# Code\\n```\\nclass Solution {\\n    func zeroFilledSubarray(_ nums: [Int]) -> Int {\\n      if nums.count == 0 { return 0 }\\n      var totalCount = 0\\n      var pointerOne = 0\\n    \\n      while pointerOne < nums.count {\\n          if nums[pointerOne] == 0 {\\n              var pointerTwo = pointerOne + 1\\n              var counter = 1\\n              while pointerTwo < nums.count && nums[pointerTwo] == 0 {\\n                  pointerOne += 1\\n                  pointerTwo += 1\\n                  counter += 1\\n              }\\n              totalCount += counter * (counter + 1) / 2\\n          }\\n          pointerOne += 1\\n      }\\n      return totalCount\\n  }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func zeroFilledSubarray(_ nums: [Int]) -> Int {\\n      if nums.count == 0 { return 0 }\\n      var totalCount = 0\\n      var pointerOne = 0\\n    \\n      while pointerOne < nums.count {\\n          if nums[pointerOne] == 0 {\\n              var pointerTwo = pointerOne + 1\\n              var counter = 1\\n              while pointerTwo < nums.count && nums[pointerTwo] == 0 {\\n                  pointerOne += 1\\n                  pointerTwo += 1\\n                  counter += 1\\n              }\\n              totalCount += counter * (counter + 1) / 2\\n          }\\n          pointerOne += 1\\n      }\\n      return totalCount\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3325309,
                "title": "c-easy-array",
                "content": "```\\nclass Solution {\\npublic:\\n    long long zeroFilledSubarray(vector<int>& nums) {\\n        int n = nums.size();\\n        long long ans = 0, zc = 0;;\\n\\n        for(int num: nums) {\\n            if(num) zc = 0;\\n            else zc ++;\\n            ans += zc;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long zeroFilledSubarray(vector<int>& nums) {\\n        int n = nums.size();\\n        long long ans = 0, zc = 0;;\\n\\n        for(int num: nums) {\\n            if(num) zc = 0;\\n            else zc ++;\\n            ans += zc;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3325006,
                "title": "java-easy-method-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n Get the size of subarray with zeros and use number of subarray formula and add it to your answer.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTake a variable to count the contigous zeros, when you are encounter a non-zero element then use the formula [N * (N+1) / 2] to calculate number of subarrays & add it to your answer after that initialize your count variable to zero.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n# Code\\n```\\n/*\\n * Please UpVote If You Like It :)\\n*/\\nclass Solution {\\n    public long zeroFilledSubarray(int[] nums) {\\n        int n = nums.length;\\n        long ans = 0;\\n        long count = 0;\\n        for(int i = 0;i<n;i++) {\\n            if(nums[i] == 0) {\\n                count++;\\n            }\\n            if(nums[i] != 0 || i == n-1) {\\n\\n               if(count != 0) {\\n                   long val = count * (count + 1);\\n                    val /= 2;\\n                    ans += val;\\n                    count = 0;\\n               }\\n\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/*\\n * Please UpVote If You Like It :)\\n*/\\nclass Solution {\\n    public long zeroFilledSubarray(int[] nums) {\\n        int n = nums.length;\\n        long ans = 0;\\n        long count = 0;\\n        for(int i = 0;i<n;i++) {\\n            if(nums[i] == 0) {\\n                count++;\\n            }\\n            if(nums[i] != 0 || i == n-1) {\\n\\n               if(count != 0) {\\n                   long val = count * (count + 1);\\n                    val /= 2;\\n                    ans += val;\\n                    count = 0;\\n               }\\n\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3324791,
                "title": "counting-3-lines-c",
                "content": "```\\nclass Solution {\\npublic:\\n    long long zeroFilledSubarray(vector<int>& nums) {\\n        long long cnt = 0, ans = 0;\\n        for(int i : nums) i ? cnt = 0 : ans += ++cnt;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long zeroFilledSubarray(vector<int>& nums) {\\n        long long cnt = 0, ans = 0;\\n        for(int i : nums) i ? cnt = 0 : ans += ++cnt;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3324583,
                "title": "day-80-very-easy-to-understand-c-code",
                "content": "# Intuition and Approach\\nIt is an Observation Based question\\nWe are calulating the contiguous zero(\\'0\\') then through observation We can see that the subarray are forming in the order of sum from one to that contiguous zero count\\ne.g \\nfor 2 contiguous zero we have : 2 + 1 pairs = 3 pairs\\nfor 3 contiguous zero we have : 3 + 2 + 1 pairs = 6 pairs\\nfor 4 contiguous zero we have : 4 + 3 + 2 + 1 pairs = 10 pairs\\n\\nso for calculating the sum from 1 to n we have formula `(n*(n+1))/2`\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long zeroFilledSubarray(vector<int>& n) {\\n        long long ans=0;\\n        long long count=0;\\n        for(int i=0;i<n.size();i++){\\n            if(n[i]==0){\\n                count++;\\n            }\\n            else{\\n                ans += (count*(count+1))/2;\\n                count=0;\\n            }\\n        }\\n        if(count != 0){\\n            ans += (count*(count+1))/2;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long zeroFilledSubarray(vector<int>& n) {\\n        long long ans=0;\\n        long long count=0;\\n        for(int i=0;i<n.size();i++){\\n            if(n[i]==0){\\n                count++;\\n            }\\n            else{\\n                ans += (count*(count+1))/2;\\n                count=0;\\n            }\\n        }\\n        if(count != 0){\\n            ans += (count*(count+1))/2;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3324290,
                "title": "2348-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Runtime : 3 ms\\n- Beats : 99.69%\\n- Memory : 59.7 MB\\n- Beats : 64.58%\\n\\n# Code\\n```\\nclass Solution {\\n    public long zeroFilledSubarray(int[] nums) {\\n        long total = 0 , current = 0;\\n        for(int i : nums){\\n            if(i == 0) total += ++current;\\n            else current = 0;\\n        }\\n        return total;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long zeroFilledSubarray(int[] nums) {\\n        long total = 0 , current = 0;\\n        for(int i : nums){\\n            if(i == 0) total += ++current;\\n            else current = 0;\\n        }\\n        return total;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3324081,
                "title": "easy-java-solution-full-explaination-comments-lbeginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nStore the length of the total number of continuos occurrence of 0 in the array and store it into a List.\\nand just iterate over the List and apply the formula =  (N * (N+1)) / 2;\\nto each element of the List and whatever output will get from that formula add it to the final answer\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long zeroFilledSubarray(int[] nums) {\\n        int i = 0;\\n        long count = 0;\\n        ArrayList<Long> al = new ArrayList<>();\\n        while(i != nums.length){\\n            //if nums[i] == 0 increase the count\\n            if(nums[i] == 0){\\n                count++;\\n                i++;\\n                continue;\\n            }\\n            //if nums[i] != 0 then store the count in the array and \\n            //re-initialize the count to 0\\n            else{\\n                //check if the count is 0 no need to store un-neccssary\\n                if(count != 0){\\n                    al.add(count);\\n                }\\n                count = 0;\\n            }\\n            i++;\\n        }\\n        //checking for the last element of the array if its 0 then store the count\\n        if(nums[nums.length-1] == 0){\\n            al.add(count);\\n        }\\n        long ans = 0;\\n        for(Long num : al){\\n            ans += (num*(num+1))/2;\\n        }\\n        return ans;\\n    }\\n}\\n```\\nNote : \\nThe formula for calculating the sum of all natural numbers from 1 to N is:\\n\\nSum = (N * (N+1)) / 2\\n\\nIn other words, the sum of the first N natural numbers is equal to half the product of N and N+1.\\n\\n**Please UpVote if you like it\\nHappy Coding**",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public long zeroFilledSubarray(int[] nums) {\\n        int i = 0;\\n        long count = 0;\\n        ArrayList<Long> al = new ArrayList<>();\\n        while(i != nums.length){\\n            //if nums[i] == 0 increase the count\\n            if(nums[i] == 0){\\n                count++;\\n                i++;\\n                continue;\\n            }\\n            //if nums[i] != 0 then store the count in the array and \\n            //re-initialize the count to 0\\n            else{\\n                //check if the count is 0 no need to store un-neccssary\\n                if(count != 0){\\n                    al.add(count);\\n                }\\n                count = 0;\\n            }\\n            i++;\\n        }\\n        //checking for the last element of the array if its 0 then store the count\\n        if(nums[nums.length-1] == 0){\\n            al.add(count);\\n        }\\n        long ans = 0;\\n        for(Long num : al){\\n            ans += (num*(num+1))/2;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3323957,
                "title": "python3-arithmetic-sequence-sum-formula-1058-ms-faster-than-90-46",
                "content": "Runtime: **1058 ms, faster than 90.46%** of Python3 online submissions for Number of Zero-Filled Subarrays.  \\nMemory Usage: 24.5 MB, less than 100.00% of Python3 online submissions for Number of Zero-Filled Subarrays.  \\n```\\nclass Solution:\\n    def zeroFilledSubarray(self, nums: List[int]) -> int:\\n        def getASS(n): ## Arithmetic Sequence Sum\\n            return (n+1)*n//2\\n        n, m = 0, 0\\n        for num in nums:\\n            if num==0:\\n                n += 1\\n            else:\\n                m += getASS(n)\\n                n = 0\\n        if n: m += getASS(n)\\n        return m\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def zeroFilledSubarray(self, nums: List[int]) -> int:\\n        def getASS(n): ## Arithmetic Sequence Sum\\n            return (n+1)*n//2\\n        n, m = 0, 0\\n        for num in nums:\\n            if num==0:\\n                n += 1\\n            else:\\n                m += getASS(n)\\n                n = 0\\n        if n: m += getASS(n)\\n        return m\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3323946,
                "title": "c-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    long long zeroFilledSubarray(vector<int>& nums) {\\n        nums.push_back(1);\\n        long long ans = 0, cnt = 0;\\n        for(auto x: nums) {\\n            if(x == 0) cnt++;\\n            else {\\n                long long val = cnt * (cnt + 1) / 2;\\n                ans += val;\\n                cnt = 0;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long zeroFilledSubarray(vector<int>& nums) {\\n        nums.push_back(1);\\n        long long ans = 0, cnt = 0;\\n        for(auto x: nums) {\\n            if(x == 0) cnt++;\\n            else {\\n                long long val = cnt * (cnt + 1) / 2;\\n                ans += val;\\n                cnt = 0;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3323862,
                "title": "java-full-explanation-clean-code",
                "content": "# Intuition\\n<I just tried >\\n\\n# Approach\\nLets say we have an array[0,0,1,0,0,0]\\nnow if we know anout sliding window we can say window size can be k \\nfor k=1\\nwe have  6 different subsets for the above array [0], [0], [1], [0], [0], [0], [0].\\nor lets say if the above array size is n and in this case its 6 we have 6 different subarrays or n subarrays\\nfor k=2\\nwe have [0,0],[0,1],[1,0],[0,0],[0,0] we have 5 different subarrays or we can say n-1 sub arrays\\nfor k=3\\nwe have[0,0,1],[0,1,0],[1,0,0],[0,0,0] we have 4 differen subarrays or we can say n-2 sub arrays\\nfor k=4 \\n[0,0,1,0],[0,1,0,0],[1,0,0,0] we have  3 different sub arrays or n-3 sub arrays\\nfor k=5\\n[0,0,1,0,0],[0,1,0,0,0] we have 2 subarrays or n-4 sub arrays \\nfor k=6 the last one\\nwe have only one sub array i.e [0,0,1,0,0,0]\\nso in total we have 6+5+4+3+2+1=21 subarrays \\nthe pattern 1+2+3+....+n sum of n natural numbers =n*(n+1)/2\\nas we have sub arrays as foolow n + n-1+n-2+-3+n-4+n-5\\nor we can wrie it as 1+2+...+n as n-5 is 1 and n-4 is 2 \\nSo this is the genel approach\\n\\nFOR THIS QUESION WE ARE GONNA USE IT\\n1: First we will count consecutive zeroes as we traverse through the array as soon as we found some other number we will go to the else part and count the possible subarrays of the give consecutive zero\\nlets take above example  first the coun of consecutive zero will be 2 and when it will go the else part it willl use the formula n*n+1/2 to calculate subsets of the consecutive zero for 2 it will give 2*3/2 WHICH IS 3 as [0,0] can give max 3 subarrays [0] , [0] ,[0,0] then after going through 1 it will give the consecutive zero count to 3 and then same thing happend.\\n2: Note: We have used the same formula in the for loop and outside of it because if let\\'s in an array [0,0,0,0] we will get the consecutive zero count to 4 but it will never go to the else part and loop willl be over so in that case we are checking if consecutive zero in 0 we will calculate it .\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public long zeroFilledSubarray(int[] nums) {\\n        \\nlong consecutive_zero=0l;\\nlong possibleSubsets=0l;\\nlong totalSubsets=0l;\\n        for(int i:nums)\\n        {\\n            if(i==0)\\n            {\\n                  consecutive_zero++;\\n            }\\n            else\\n            {\\n                possibleSubsets=(consecutive_zero*(consecutive_zero+1))/2;\\n                  totalSubsets+=possibleSubsets;\\n                  consecutive_zero=0;\\n            }\\n        }\\n        if(consecutive_zero!=0)\\n        {\\n           possibleSubsets=(consecutive_zero*(consecutive_zero+1))/2;\\n                  totalSubsets+=possibleSubsets;  \\n        }\\n        return totalSubsets;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window",
                    "Number Theory"
                ],
                "code": "```\\nclass Solution {\\n    public long zeroFilledSubarray(int[] nums) {\\n        \\nlong consecutive_zero=0l;\\nlong possibleSubsets=0l;\\nlong totalSubsets=0l;\\n        for(int i:nums)\\n        {\\n            if(i==0)\\n            {\\n                  consecutive_zero++;\\n            }\\n            else\\n            {\\n                possibleSubsets=(consecutive_zero*(consecutive_zero+1))/2;\\n                  totalSubsets+=possibleSubsets;\\n                  consecutive_zero=0;\\n            }\\n        }\\n        if(consecutive_zero!=0)\\n        {\\n           possibleSubsets=(consecutive_zero*(consecutive_zero+1))/2;\\n                  totalSubsets+=possibleSubsets;  \\n        }\\n        return totalSubsets;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3323555,
                "title": "simple-elixir-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFor each zero in the list, the number of zero-filled subarrays that end at that index is equal to the number of consecutive zeros up to and **including** that index.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTraverse the list keeping track of how many consecutive zeros we\\'ve seen so far. If current element is zero, add that number to a counter. Else set it to zero and loop further.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n) - traversing the list\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1) - tail-call optimization is applied for recursive calls\\n\\n# Code\\n```\\ndefmodule Solution do\\n    @spec zero_filled_subarray(nums :: [integer]) :: integer\\n    def zero_filled_subarray(nums) do\\n        count(nums, 0, 0)\\n    end\\n\\n    defp count([], _zeros, acc), do: acc\\n    defp count([0 | tail], zeros, acc), do: count(tail, zeros + 1, acc + zeros + 1)\\n    defp count([_head | tail], _zeros, acc), do: count(tail, 0, acc)\\nend\\n```\\nPlease consider upwoting, if you found my solution helpful.",
                "solutionTags": [
                    "Elixir",
                    "Math",
                    "Recursion",
                    "Counting"
                ],
                "code": "```\\ndefmodule Solution do\\n    @spec zero_filled_subarray(nums :: [integer]) :: integer\\n    def zero_filled_subarray(nums) do\\n        count(nums, 0, 0)\\n    end\\n\\n    defp count([], _zeros, acc), do: acc\\n    defp count([0 | tail], zeros, acc), do: count(tail, zeros + 1, acc + zeros + 1)\\n    defp count([_head | tail], _zeros, acc), do: count(tail, 0, acc)\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3323521,
                "title": "c-time-o-n-space-1-simple-easy-to-understand",
                "content": "````\\nclass Solution {\\npublic:\\n    long long zeroFilledSubarray(vector<int>& nums) {\\n        long long int ans = 0, k = 0;\\n        for(auto &i: nums){\\n            if(i){k = 0;}\\n            else {ans += ++k;}\\n        }\\n        return ans;\\n    }\\n};\\n````",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Math"
                ],
                "code": "````\\nclass Solution {\\npublic:\\n    long long zeroFilledSubarray(vector<int>& nums) {\\n        long long int ans = 0, k = 0;\\n        for(auto &i: nums){\\n            if(i){k = 0;}\\n            else {ans += ++k;}\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3323345,
                "title": "rust-simple-applying-sum-of-series-formula",
                "content": "# Intuition\\nThe number of ways a series of 0\\'s can be sliced and diced follows a pattern. If we have a group of 3, they can be grouped 3 + 2 + 1 ways. A group of 4 can be grouped 4 + 3 + 2 + 1 ways.\\n\\nSo the number of ways any group of adjacent 0\\'s can be subgrouped is calculated from the sum of the series 1 + 2 + ... + n. This could be calculated while looping; alternatively, there\\'s an $O(1)$ formula for the sum of series that could be applied.\\n\\n# Approach\\n\\nThe formula for calculating the sum of a series is:\\n$$S_n = n/2[2a + (n - 1)d]$$\\n\\nwhere:\\n- $n$ is the number of terms to sum.\\n- $a$ is the first term of the sequence, which is $1$ in our case.\\n- $d$ is the difference between sequential terms, which is $1$ for this application.\\n\\nThe values of `nums` are iterated over while counting the number of sequential `0`s. When a group of `0`s ends, its size is used to calculate the number of subgroups it represents using the sum of series formula.\\n\\nA total for the numbers of subgroups for each series of `0`s is maintained and returned after iteration completes.\\n\\n# Complexity\\n- Time complexity: $O(n)$\\n- Space complexity: $O(1)$ *auxiliary* space.\\n\\n# Code\\n```rust\\nimpl Solution {\\n    pub fn zero_filled_subarray(nums: Vec<i32>) -> i64 {\\n        let sum_of_series = |n: i64| n * (2 + (n - 1)) / 2;\\n\\n        let mut subas = 0;\\n        let mut i     = 0;\\n        let mut j     = 0;\\n        let mut n     = nums.len();\\n\\n        while i < n {\\n            while i < n && nums[i] != 0 { i += 1; }\\n            j = i;\\n            while i < n && nums[i] == 0 { i += 1; }\\n\\n            subas += sum_of_series((i - j) as i64);\\n        }\\n        subas\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nimpl Solution {\\n    pub fn zero_filled_subarray(nums: Vec<i32>) -> i64 {\\n        let sum_of_series = |n: i64| n * (2 + (n - 1)) / 2;\\n\\n        let mut subas = 0;\\n        let mut i     = 0;\\n        let mut j     = 0;\\n        let mut n     = nums.len();\\n\\n        while i < n {\\n            while i < n && nums[i] != 0 { i += 1; }\\n            j = i;\\n            while i < n && nums[i] == 0 { i += 1; }\\n\\n            subas += sum_of_series((i - j) as i64);\\n        }\\n        subas\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3322797,
                "title": "very-easy-c-soln-o-n-o-1-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIntuition is simple we just need to count the number of continuous zeros and then will count how many subarrays can be made from them.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe just iterate the for loop and will keep the count of zeros, when a non zero value comes then we simply add the number of subarrays which could be formed by those continuous zeros, whose count we just got.For this we will use some of n-natural number formula since it will provide us with count of continuous subarrays, and then we simply add it to our ans, after that we again make count = 0, so that it can keep count of upcoming zeros.once forloop finishes its wort, we have to add count again if the count is not zero because that count is not yet added to our ans. Atlast we simply return our ans.\\n\\n**Please upvote guys if it helps.**\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long zeroFilledSubarray(vector<int>& nums) {\\n        long long count = 0;\\n        long long ans=0;\\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            if(nums[i]==0)\\n            {\\n                count++;\\n            }\\n            else\\n            {\\n                if(count != 0)\\n                ans+=(count)*(count+1)/2;\\n                count=0;\\n            }\\n        }\\n        if(count != 0)\\n        ans+=(count)*(count+1)/2;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long zeroFilledSubarray(vector<int>& nums) {\\n        long long count = 0;\\n        long long ans=0;\\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            if(nums[i]==0)\\n            {\\n                count++;\\n            }\\n            else\\n            {\\n                if(count != 0)\\n                ans+=(count)*(count+1)/2;\\n                count=0;\\n            }\\n        }\\n        if(count != 0)\\n        ans+=(count)*(count+1)/2;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3322664,
                "title": "c-o-n-approach-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can observe the no. of subarrays made by specific no. of contiguous 0\\'s follow some pattern. We can see that any subarray of 0\\'s of length x can make x(x-1)/2 subarrays itself.\\nSo now we just need to find all these subarrays of 0 and calculate the no. of subarrays made by them with the above formula. One more thing we also need to include all the occurances of 0\\'s in our answer.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe will iterate through the array and keep track of length of each contiguous subarray of 0. Then when we get a non 0 number we just calculate the no. of subarrays from the above lengthx ((x-1)/2) and add it to our answer. Then make length 0 again for next contiguous subarrays of 0. Add at last add all occurances of 0s to the answer.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long zeroFilledSubarray(vector<int>& nums) {\\n        \\n        long long ans = 0;\\n        long long length = 0;\\n        long long occ = 0;\\n\\n        for(int i = 0; i < nums.size(); i++){\\n\\n            if(nums[i] == 0){\\n                length++;\\n                occ++;\\n            }\\n            else{\\n                ans += ((length * (length - 1)) / 2);\\n                length = 0;\\n            }\\n\\n        }\\n\\n        ans += ((length * (length - 1)) / 2);\\n        ans += occ;\\n\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long zeroFilledSubarray(vector<int>& nums) {\\n        \\n        long long ans = 0;\\n        long long length = 0;\\n        long long occ = 0;\\n\\n        for(int i = 0; i < nums.size(); i++){\\n\\n            if(nums[i] == 0){\\n                length++;\\n                occ++;\\n            }\\n            else{\\n                ans += ((length * (length - 1)) / 2);\\n                length = 0;\\n            }\\n\\n        }\\n\\n        ans += ((length * (length - 1)) / 2);\\n        ans += occ;\\n\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3322653,
                "title": "simple-c-solution-daily-leetcode-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long zeroFilledSubarray(vector<int>& nums) {\\n        long long ans=0;\\n        long long n=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]!=0)\\n            {\\n                ans+= (n*(n+1))/2;\\n                cout<<(n*(n+1))/2<<endl;\\n                n=0;\\n            }\\n            else\\n            {\\n                n++;\\n            }\\n        }\\n         ans+= (n*(n+1))/2;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long zeroFilledSubarray(vector<int>& nums) {\\n        long long ans=0;\\n        long long n=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]!=0)\\n            {\\n                ans+= (n*(n+1))/2;\\n                cout<<(n*(n+1))/2<<endl;\\n                n=0;\\n            }\\n            else\\n            {\\n                n++;\\n            }\\n        }\\n         ans+= (n*(n+1))/2;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3322594,
                "title": "solution-using-n-n-1-2-formula",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nconsider an example or arr=[0,0,0]\\nthe no of subarrays can be formed is 6 \\nthose are selecting singles i.e. 0 ,0 , 0\\nand selecting double 0\\'s i.e. 0th and 1st index, 1st and 2nd index\\nand selecting all i.e. 000 is another subarray\\n$$total count=6$$\\nwhich is equal to n(n+1)/2 i.e. 6(6+1)/2\\n\\nrun a for loop and use two conditions \\n1.when equal to 0\\n2.when not equal to 0\\n\\nsee the code .........\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long zeroFilledSubarray(int[] arr) {\\n        long ans=0;\\n        int n=arr.length;\\n        long count=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(arr[i]==0)\\n            {\\n             count++;\\n            }\\n            else if(count!=0){\\n                ans=ans+(count*(count+1))/2;\\n                count=0;\\n            }\\n        }\\n        if(count!=0)\\n        ans=ans+(count*(count+1))/2;\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long zeroFilledSubarray(int[] arr) {\\n        long ans=0;\\n        int n=arr.length;\\n        long count=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(arr[i]==0)\\n            {\\n             count++;\\n            }\\n            else if(count!=0){\\n                ans=ans+(count*(count+1))/2;\\n                count=0;\\n            }\\n        }\\n        if(count!=0)\\n        ans=ans+(count*(count+1))/2;\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3322593,
                "title": "c-easy-approach-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- We will iterate the array and if we find a zero we will see whether \\nit has an adjacent zero or not.\\n- Important point : If there are n elements the number of subarrays will be   **n(n+1) / 2.**\\n- One can also check no of consecutive zeroes and apply the above mentioned formulae and each value to our count variable.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long zeroFilledSubarray(vector<int>& nums) {\\n       long long sum = 0 , cnt = 0 , sub_arr = 1;\\n       int n = nums.size();\\n       for(int i = 0 ; i < n ; i++)\\n       {\\n           if(nums[i] == 0)\\n           {\\n               sum += sub_arr;\\n               sub_arr++;\\n           }\\n           else\\n           {\\n               sub_arr = 1;\\n               cnt += sum;\\n               sum = 0;\\n           }\\n       }\\n       cnt += sum; \\n       return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long zeroFilledSubarray(vector<int>& nums) {\\n       long long sum = 0 , cnt = 0 , sub_arr = 1;\\n       int n = nums.size();\\n       for(int i = 0 ; i < n ; i++)\\n       {\\n           if(nums[i] == 0)\\n           {\\n               sum += sub_arr;\\n               sub_arr++;\\n           }\\n           else\\n           {\\n               sub_arr = 1;\\n               cnt += sum;\\n               sum = 0;\\n           }\\n       }\\n       cnt += sum; \\n       return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3322136,
                "title": "python-readable-simple-intuition",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n1. What exactly are zero filled subarrays?\\n2. What are you trying to find with zero filled subarrays? -> [0], [0,0], [0,0,0] ...\\n3. Once you have found array [0,0,0] or [0,0], how many subarrays exist in this subarray? -> Math Trick sum of Integers\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Initialise zeros = 0 to track continuous zeros.\\n2. Iterate through nums:\\n2. if num == 0, it means we can 1 to the count of total zeros.\\n3. if num != 0, sum the current total zeros and reset `zeros = 0`\\n\\n# Complexity\\n- Time complexity: O(N) \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def zeroFilledSubarray(self, nums: List[int]) -> int:\\n\\n        def sumOfIntegers(num):\\n            return num*(1 + num)//2\\n\\n        res = zeros = 0\\n        for i in nums:\\n            if i != 0: \\n                res += sumOfIntegers(zeros)\\n                zeros = 0\\n                continue\\n            zeros += 1\\n                \\n        return res if not zeros else res + sumOfIntegers(zeros)\\n\\n```\\n**Optimised and Elegant**\\nCredits to @blue_sky5\\n\\n**Intuition**\\n1. This extends off the intuition of sumOfIntegers. What is the underlying way to sum numbers?\\n-> sum(3) = 1 + 2 + 3. ------------> [0,0,0]\\n-> sum(4) = 1 + 2 + 3 + 4. --------> [0,0,0,0]\\n-> sum(x) = 1 + 2 + 3 + ... + x ----> [0,0, ..., 0]\\n\\nWhen you see a 0, add it to counter. If its not 0, reset.  \\nAdd counter to res after every iteration.\\n\\n*Google Triangular Numbers*\\n\\n```\\nclass Solution:\\n    def zeroFilledSubarray(self, nums: List[int]) -> int:\\n\\n        res = zeros = 0\\n\\n        for num in nums:\\n            if num == 0: \\n                zeros += 1\\n            else:\\n                zeros = 0\\n            res += zeros\\n                \\n        return res\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def zeroFilledSubarray(self, nums: List[int]) -> int:\\n\\n        def sumOfIntegers(num):\\n            return num*(1 + num)//2\\n\\n        res = zeros = 0\\n        for i in nums:\\n            if i != 0: \\n                res += sumOfIntegers(zeros)\\n                zeros = 0\\n                continue\\n            zeros += 1\\n                \\n        return res if not zeros else res + sumOfIntegers(zeros)\\n\\n```\n```\\nclass Solution:\\n    def zeroFilledSubarray(self, nums: List[int]) -> int:\\n\\n        res = zeros = 0\\n\\n        for num in nums:\\n            if num == 0: \\n                zeros += 1\\n            else:\\n                zeros = 0\\n            res += zeros\\n                \\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3322102,
                "title": "c-solution-easy",
                "content": "# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long zeroFilledSubarray(vector<int>& nums) {\\n        long long ans = 0;\\n        long long count = 0;\\n        for(int num : nums)\\n        {\\n            if(num != 0) count = 0;\\n            else\\n            {\\n                count++;\\n                ans += count;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long zeroFilledSubarray(vector<int>& nums) {\\n        long long ans = 0;\\n        long long count = 0;\\n        for(int num : nums)\\n        {\\n            if(num != 0) count = 0;\\n            else\\n            {\\n                count++;\\n                ans += count;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3322057,
                "title": "rust-easy-to-understand",
                "content": "```\\nimpl Solution {\\n    pub fn zero_filled_subarray(nums: Vec<i32>) -> i64 {\\n        let mut total = 0;\\n        let mut zero_count = 0;\\n        for n in nums {\\n            if n != 0 {\\n                zero_count = 0;\\n            } else {\\n                zero_count += 1;\\n                total += zero_count; \\n            }         \\n        }       \\n        total \\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn zero_filled_subarray(nums: Vec<i32>) -> i64 {\\n        let mut total = 0;\\n        let mut zero_count = 0;\\n        for n in nums {\\n            if n != 0 {\\n                zero_count = 0;\\n            } else {\\n                zero_count += 1;\\n                total += zero_count; \\n            }         \\n        }       \\n        total \\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3321968,
                "title": "i-ruby",
                "content": "```ruby\\ndef zero_filled_subarray(nums) =\\n    nums.map! { (_1 <=> 0).abs }\\n        .join\\n        .gsub(/0+/)\\n        .map(&:size)\\n        .sum { _1.succ * _1 / 2 }\\n```\\n```ruby\\ndef zero_filled_subarray a\\n    c = 0\\n    a.sum do\\n        c = _1.zero? ? c + 1 : 0\\n    end\\nend\\n```\\n```ruby\\ndef zero_filled_subarray(a, c = 0) = a.sum { c = _1.zero? ? c + 1 : 0 }\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```ruby\\ndef zero_filled_subarray(nums) =\\n    nums.map! { (_1 <=> 0).abs }\\n        .join\\n        .gsub(/0+/)\\n        .map(&:size)\\n        .sum { _1.succ * _1 / 2 }\\n```\n```ruby\\ndef zero_filled_subarray a\\n    c = 0\\n    a.sum do\\n        c = _1.zero? ? c + 1 : 0\\n    end\\nend\\n```\n```ruby\\ndef zero_filled_subarray(a, c = 0) = a.sum { c = _1.zero? ? c + 1 : 0 }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3321938,
                "title": "kotlin-simply-tracking-0s",
                "content": "```\\nclass Solution {\\n  fun zeroFilledSubarray(nums: IntArray): Long {\\n    var res = 0L\\n    var zeroes = 0\\n    for (v in nums) {\\n      if (v != 0) {\\n        zeroes = 0\\n      } else {\\n        zeroes++\\n        res += zeroes\\n      }\\n    }\\n    return res\\n  }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n  fun zeroFilledSubarray(nums: IntArray): Long {\\n    var res = 0L\\n    var zeroes = 0\\n    for (v in nums) {\\n      if (v != 0) {\\n        zeroes = 0\\n      } else {\\n        zeroes++\\n        res += zeroes\\n      }\\n    }\\n    return res\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3321884,
                "title": "easy-c-math",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe Know That number of subarrays in any array is size*(size+1)/2 ,\\nby this we are finding all array with only zero and increasing counter accordingly and performing that formula and adding to answer for getting all no. of subarray consisting only 0s.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long zeroFilledSubarray(vector<int>& nums) {\\n        long long n=nums.size(),cnt=0,ans=0;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]!=0){\\n                ans+=(cnt*(cnt+1))/2;\\n                cnt=0;\\n            }\\n            else cnt++;\\n        }\\n        ans+=(cnt*(cnt+1))/2;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long zeroFilledSubarray(vector<int>& nums) {\\n        long long n=nums.size(),cnt=0,ans=0;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]!=0){\\n                ans+=(cnt*(cnt+1))/2;\\n                cnt=0;\\n            }\\n            else cnt++;\\n        }\\n        ans+=(cnt*(cnt+1))/2;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2761921,
                "title": "java-simple-solution",
                "content": "```\\nclass Solution {\\n    \\n    long s(int n){\\n        if(n==0){\\n            return 0;\\n        }\\n        long sum=0;\\n        for(int i=1;i<=n;i++){\\n            sum=sum+i;\\n        }\\n        return sum;\\n    }\\n    \\n    public long zeroFilledSubarray(int[] nums) {\\n        int n=nums.length;\\n        int count=0;\\n        long sum=0;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]==0){\\n                count++;\\n            }\\n            else{\\n                sum=sum+s(count);\\n                count=0;\\n            }\\n        }\\n        if(nums[n-1]==0){\\n            sum=sum+s(count);\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    \\n    long s(int n){\\n        if(n==0){\\n            return 0;\\n        }\\n        long sum=0;\\n        for(int i=1;i<=n;i++){\\n            sum=sum+i;\\n        }\\n        return sum;\\n    }\\n    \\n    public long zeroFilledSubarray(int[] nums) {\\n        int n=nums.length;\\n        int count=0;\\n        long sum=0;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]==0){\\n                count++;\\n            }\\n            else{\\n                sum=sum+s(count);\\n                count=0;\\n            }\\n        }\\n        if(nums[n-1]==0){\\n            sum=sum+s(count);\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2471505,
                "title": "c-clean-commented-code-deatiled-solution",
                "content": "Upvote if it helped!\\n\\n\\n```\\n\\nclass Solution {\\npublic:\\n    long long zeroFilledSubarray(vector<int>& nums) \\n    {\\n        long long ans = 0;             // for storing the final answer (Total no. of subarrays)\\n        long long cnt = 0;             // for counting the consecutive 0\\'s\\n        \\n        for(int i=0;i<nums.size();i++)\\n        {\\n            // wherever we find 0 just increase cnt by 1 and sum up to ans\\n            if(nums[i]==0)               \\n            {\\n                cnt++;\\n                ans += cnt;\\n            }\\n            \\n            // if it is none 0 them make 0 count 0\\n            else\\n            {\\n                cnt = 0;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n\\n```\\n\\n\\n\\n\\nTC : O(N)\\nSC : O(1)\\n\\nformula:\\nsize = no. of subarray\\n1 = 1\\n2 = 2+1 = 3\\n3 = 3+2+1 = 6\\n4 = 4+3+2+1 = 10\\n.\\n.\\n.\\nN = N+(N-1)+(N-2)+....+1\\n\\nUpvote if it helped!\\n\\n\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    long long zeroFilledSubarray(vector<int>& nums) \\n    {\\n        long long ans = 0;             // for storing the final answer (Total no. of subarrays)\\n        long long cnt = 0;             // for counting the consecutive 0\\'s\\n        \\n        for(int i=0;i<nums.size();i++)\\n        {\\n            // wherever we find 0 just increase cnt by 1 and sum up to ans\\n            if(nums[i]==0)               \\n            {\\n                cnt++;\\n                ans += cnt;\\n            }\\n            \\n            // if it is none 0 them make 0 count 0\\n            else\\n            {\\n                cnt = 0;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2372985,
                "title": "clear-solution-c-o-n-easy-concept",
                "content": "class Solution {\\npublic:\\n// the fact is number of subarrays formed in n length of array is n * (n+1) / 2\\n    long long zeroFilledSubarray(vector<int>& nums) {\\n        \\n        long long count = 0;\\n        long zeros = 0;\\n        for(int i = 0; i<nums.size(); i++){\\n            if(nums[i] == 0){\\n                zeros ++;\\n            }\\n            else{\\n                count += (zeros * (zeros+1)) / 2 ; \\n                zeros = 0;\\n            }\\n            \\n        }\\n        \\n        count += (zeros * (zeros+1)) / 2 ;\\n        return count;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n// the fact is number of subarrays formed in n length of array is n * (n+1) / 2\\n    long long zeroFilledSubarray(vector<int>& nums) {\\n        \\n        long long count = 0;\\n        long zeros = 0;\\n        for(int i = 0; i<nums.size(); i++){\\n            if(nums[i] == 0){\\n                zeros ++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2372005,
                "title": "easy-understandable",
                "content": "Required to know -- For no. of  subarray of length n use n*(n-1)/2 and keep track of adjacent zeroes.\\n\\n```\\nclass Solution {\\n    public long zeroFilledSubarray(int[] nums) {\\n        int zero=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==0) zero++;\\n        }\\n        long ans=zero;\\n        \\n        for(int i=0;i<nums.length;i++){\\n            int temp=0;\\n            long j=0;\\n            \\n            long start=i;\\n            while(start+j<nums.length && nums[(int)(start+j)]==0){\\n                j++;\\n            }\\n\\n            if(j!=0){\\n                i=(int)(start+j);\\n                i--;\\n                ans+=(j)*(j-1)/2;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\\n** upvote if you like\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long zeroFilledSubarray(int[] nums) {\\n        int zero=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==0) zero++;\\n        }\\n        long ans=zero;\\n        \\n        for(int i=0;i<nums.length;i++){\\n            int temp=0;\\n            long j=0;\\n            \\n            long start=i;\\n            while(start+j<nums.length && nums[(int)(start+j)]==0){\\n                j++;\\n            }\\n\\n            if(j!=0){\\n                i=(int)(start+j);\\n                i--;\\n                ans+=(j)*(j-1)/2;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\\n** upvote if you like\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2356558,
                "title": "c-easy-implementation",
                "content": "```\\nclass Solution {\\npublic:\\n    long long zeroFilledSubarray(vector<int>& nums) {\\n       long long int ans =0;\\n        long long int count =0;\\n      for(int i =0;i<nums.size();i++)\\n      {\\n        if(nums[i]==0)\\n        {\\n            count++;\\n        }\\n          else\\n          {\\n              ans += ((count)/2.0)*(count+1);\\n              cout<<ans<<\" \";\\n              count =0;\\n          }\\n      }\\n        if(count!=0)\\n        {\\n            ans += ((count)/2.0)*(count+1);\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    long long zeroFilledSubarray(vector<int>& nums) {\\n       long long int ans =0;\\n        long long int count =0;\\n      for(int i =0;i<nums.size();i++)\\n      {\\n        if(nums[i]==0)\\n        {\\n            count++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2354676,
                "title": "c-sliding-window-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    long long zeroFilledSubarray(vector<int>& nums) {\\n        long long res = 0, i = 0, count = 0, n = nums.size();\\n        int j=0;\\n        unordered_map<int,int>mp;\\n        while(j<n){\\n            while(j<n && nums[j]==0){\\n                count++;\\n                j++;\\n            }\\n            if(count==1) res++;\\n            else{\\n                res+=(count)*(count+1)/2;\\n            } \\n            count=0;\\n            j++;\\n        }\\n       \\n        return res;\\n    }\\n};\\n\\n// if you liked the solution then please upvote it so that it can reach to more people \\n// If you have any doubt or want to discuss any thing related to solution please leave a comment, so that all of the viewers can discuss it\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long zeroFilledSubarray(vector<int>& nums) {\\n        long long res = 0, i = 0, count = 0, n = nums.size();\\n        int j=0;\\n        unordered_map<int,int>mp;\\n        while(j<n){\\n            while(j<n && nums[j]==0){\\n                count++;\\n                j++;\\n            }\\n            if(count==1) res++;\\n            else{\\n                res+=(count)*(count+1)/2;\\n            } \\n            count=0;\\n            j++;\\n        }\\n       \\n        return res;\\n    }\\n};\\n\\n// if you liked the solution then please upvote it so that it can reach to more people \\n// If you have any doubt or want to discuss any thing related to solution please leave a comment, so that all of the viewers can discuss it\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2348571,
                "title": "simple-python3-solution-beats-100-00",
                "content": "def zeroFilledSubarray(self, nums: List[int]) -> int:\\n\\n\\tans = 0        \\n\\tcount = 0\\n\\n\\tfor num in nums:\\n\\t\\tif num == 0:\\n\\t\\t\\tcount += 1\\n\\t\\telse:\\n\\t\\t\\tif count != 0:\\n\\t\\t\\t\\tans += (count * (count + 1) // 2)\\n\\t\\t\\t\\tcount = 0\\n\\n\\tif nums[-1] == 0:\\n\\t\\tans += (count * (count + 1) // 2)                   \\n\\n\\treturn ans",
                "solutionTags": [],
                "code": "def zeroFilledSubarray(self, nums: List[int]) -> int:\\n\\n\\tans = 0        \\n\\tcount = 0\\n\\n\\tfor num in nums:\\n\\t\\tif num == 0:\\n\\t\\t\\tcount += 1\\n\\t\\telse:\\n\\t\\t\\tif count != 0:\\n\\t\\t\\t\\tans += (count * (count + 1) // 2)\\n\\t\\t\\t\\tcount = 0\\n\\n\\tif nums[-1] == 0:\\n\\t\\tans += (count * (count + 1) // 2)                   \\n\\n\\treturn ans",
                "codeTag": "Python3"
            },
            {
                "id": 2345712,
                "title": "c-n-n-1-2-solution-258ms-100-faster",
                "content": "**Please Upvote!!**\\n```\\nclass Solution {\\npublic:\\n    long long zeroFilledSubarray(vector<int>& nums) {\\n        long long ans = 0, curr = 0;\\n\\t\\t\\n        for(auto n: nums){\\n            if(!n) curr++; // if current element is zero we increase count for contiguous zero subarray\\n            else curr = 0; // else reset count to zero\\n            ans += curr;\\n        }\\n\\t\\t\\n        return ans;        \\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long zeroFilledSubarray(vector<int>& nums) {\\n        long long ans = 0, curr = 0;\\n\\t\\t\\n        for(auto n: nums){\\n            if(!n) curr++; // if current element is zero we increase count for contiguous zero subarray\\n            else curr = 0; // else reset count to zero\\n            ans += curr;\\n        }\\n\\t\\t\\n        return ans;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2344265,
                "title": "3-simple-c-solution",
                "content": "**1. Brute Force (TLE)**\\n```\\nclass Solution {\\npublic:\\n    long long zeroFilledSubarray(vector<int>& nums) {\\n        long long ans=0,j;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i] == 0){\\n                j = i;\\n                while(j < nums.size() && nums[j] == 0)\\n                    j++;\\n                ans += j-i;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**2. Otimized Solution 1**\\n```\\nclass Solution {\\npublic:\\n    long long zeroFilledSubarray(vector<int>& nums) {\\n        long long ans=0,j=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i] != 0)\\n                j=i+1;\\n            ans += i-j+1;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**3. Otimized Solution 2**\\n```\\nclass Solution {\\npublic:\\n    long long zeroFilledSubarray(vector<int>& nums) {\\n        long long ans=0,tmp=0;\\n        for(long long i=0;i<nums.size();i++){\\n            if(nums[i] == 0)\\n                tmp++;\\n            else\\n                ans += (tmp*(tmp+1))/2,tmp=0;\\n        }\\n        ans += (tmp*(tmp+1))/2;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long zeroFilledSubarray(vector<int>& nums) {\\n        long long ans=0,j;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i] == 0){\\n                j = i;\\n                while(j < nums.size() && nums[j] == 0)\\n                    j++;\\n                ans += j-i;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    long long zeroFilledSubarray(vector<int>& nums) {\\n        long long ans=0,j=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i] != 0)\\n                j=i+1;\\n            ans += i-j+1;\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    long long zeroFilledSubarray(vector<int>& nums) {\\n        long long ans=0,tmp=0;\\n        for(long long i=0;i<nums.size();i++){\\n            if(nums[i] == 0)\\n                tmp++;\\n            else\\n                ans += (tmp*(tmp+1))/2,tmp=0;\\n        }\\n        ans += (tmp*(tmp+1))/2;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2337604,
                "title": "easy-approach-100-faster-begineer-friendly",
                "content": "```\\nHere i explain what i used to solve please like the solution ):\\n```long long zeroFilledSubarray(vector<int>& nums) {\\n        // By seeing the pattern that \\n        // when 0 is 1 then output will 1\\n        // when 0 is 2 then 1+2\\n        // when 0 is 3 then 1+2+3\\n        \\n        // pattern n+(n-1)+(n-2)+(n-3).......+1\\n        \\n        // i take count and ans variable \\n        // jaise hi count increse ho answer me put krdo and move next index\\n        \\n        long long count=0;\\n        long long ans = 0;\\n        \\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i] == 0){\\n                count++;\\n                ans +=count;\\n            }\\n            else{\\n                count=0;\\n                \\n            }\\n        }\\n        return ans;\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nHere i explain what i used to solve please like the solution ):\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2323139,
                "title": "c-single-pass-clean-and-easy-code",
                "content": "```\\nclass Solution {\\npublic:\\n    long long zeroFilledSubarray(vector<int>& nums) {\\n        long long ans=0, cnt=0;\\n        for(auto &it : nums)\\n        {\\n            if(it==0) cnt++;\\n            else \\n            {\\n                ans+=((cnt*(cnt+1))/2);\\n                cnt=0;\\n            }\\n        }\\n        ans+=((cnt*(cnt+1))/2);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long zeroFilledSubarray(vector<int>& nums) {\\n        long long ans=0, cnt=0;\\n        for(auto &it : nums)\\n        {\\n            if(it==0) cnt++;\\n            else \\n            {\\n                ans+=((cnt*(cnt+1))/2);\\n                cnt=0;\\n            }\\n        }\\n        ans+=((cnt*(cnt+1))/2);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2322455,
                "title": "python-two-pointers-easy-approach",
                "content": "```\\nclass Solution:\\n    def zeroFilledSubarray(self, nums: List[int]) -> int:\\n        \\n        n = len(nums)\\n\\n        ans = 0\\n        i, j = 0, 0\\n        while i <= n - 1:\\n            j = 0\\n            if nums[i] == 0:\\n                while i + j <= n - 1 and nums[i + j] == 0:\\n                    j += 1\\n                ans += (j + 1) * j // 2\\n\\n            i = i + j + 1\\n        \\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def zeroFilledSubarray(self, nums: List[int]) -> int:\\n        \\n        n = len(nums)\\n\\n        ans = 0\\n        i, j = 0, 0\\n        while i <= n - 1:\\n            j = 0\\n            if nums[i] == 0:\\n                while i + j <= n - 1 and nums[i + j] == 0:\\n                    j += 1\\n                ans += (j + 1) * j // 2\\n\\n            i = i + j + 1\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2322418,
                "title": "simple-o-n-javascript-solution",
                "content": "```\\nvar zeroFilledSubarray = function(nums) {\\n    let result = 0;\\n    let count = 0;\\n    \\n    for (const num of nums) {\\n        if (num === 0) {\\n            ++count;\\n            result += count;\\n        } else {\\n            count = 0;\\n        }\\n    }\\n    \\n    return result;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar zeroFilledSubarray = function(nums) {\\n    let result = 0;\\n    let count = 0;\\n    \\n    for (const num of nums) {\\n        if (num === 0) {\\n            ++count;\\n            result += count;\\n        } else {\\n            count = 0;\\n        }\\n    }\\n    \\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2322367,
                "title": "basic-easy-to-undestand-intuition-maths",
                "content": "Idea here is to understand that how many consecutive zeros can give how many subarrays\\n\\nexample\\n\\n0 --> 1 subarray of [0]\\n00 --> 3 subarrays [1 of [00] and 2 of [0]]\\n000 ---> 6 subarrays [1 of [0,0,0], 2 of [0,0] and 3 of [0]]\\n\\nthus for n number of zeros --> we get (n*n+1 )/2 subarrays\\n\\nand then just traverse the array and add the total\\n\\n\\n```\\n    def zeroFilledSubarray(self, nums: List[int]) -> int:\\n        \\n        i = 0\\n        total = 0\\n        while i<len(nums):\\n            if nums[i]==0:\\n                j = i+1\\n                while j<len(nums) and nums[j]==0:\\n                    j+=1\\n                countof_zeros = j-i\\n                total+=(((countof_zeros)*(countof_zeros+1))//2)\\n                i=j\\n            i+=1\\n                   \\n        return total\\n        \\n```",
                "solutionTags": [
                    "Math"
                ],
                "code": "```\\n    def zeroFilledSubarray(self, nums: List[int]) -> int:\\n        \\n        i = 0\\n        total = 0\\n        while i<len(nums):\\n            if nums[i]==0:\\n                j = i+1\\n                while j<len(nums) and nums[j]==0:\\n                    j+=1\\n                countof_zeros = j-i\\n                total+=(((countof_zeros)*(countof_zeros+1))//2)\\n                i=j\\n            i+=1\\n                   \\n        return total\\n        \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2322333,
                "title": "java-math",
                "content": "**Logic**: Number of subarrays for each contiguous sequence of 0 is `(count*(count+1))/2`\\n**Edge case**: The array ending with 0 needs to be considered before returning.\\n```\\nclass Solution\\n{\\n    public long zeroFilledSubarray(int[] nums)\\n    {\\n        long ans = 0L, cur = 0L;\\n        for(int i : nums)\\n        {\\n            if(i == 0)\\n                cur++;\\n            else\\n            {\\n                ans += (long)(1L*cur*(cur+1)/2);\\n                cur = 0L;\\n            }\\n        }\\n        ans += (long)(1L*cur*(cur+1)/2); // If the array ends with 0\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution\\n{\\n    public long zeroFilledSubarray(int[] nums)\\n    {\\n        long ans = 0L, cur = 0L;\\n        for(int i : nums)\\n        {\\n            if(i == 0)\\n                cur++;\\n            else\\n            {\\n                ans += (long)(1L*cur*(cur+1)/2);\\n                cur = 0L;\\n            }\\n        }\\n        ans += (long)(1L*cur*(cur+1)/2); // If the array ends with 0\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2322298,
                "title": "c-count",
                "content": "**Approach:**\\nSimilar idea with this problem [485. Max Consecutive Ones](https://leetcode.com/problems/max-consecutive-ones/).\\nAs this problem suggest the max length and with this problem we have to count the subarrays. So just traverse and count the subarrays.\\n\\n**Time:** `O(N), N = Length of the array`\\n**Space:** `O(1)`\\n\\n```\\nclass Solution {\\npublic:\\n    long long zeroFilledSubarray(vector<int>& nums) {\\n        long long count = 0, answer = 0;\\n        for(int i = 0; i < nums.size(); i++){\\n            if(nums[i] == 0) count++;\\n            else{\\n                count = 0;\\n            }\\n            answer += count;\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Counting Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long zeroFilledSubarray(vector<int>& nums) {\\n        long long count = 0, answer = 0;\\n        for(int i = 0; i < nums.size(); i++){\\n            if(nums[i] == 0) count++;\\n            else{\\n                count = 0;\\n            }\\n            answer += count;\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4073770,
                "title": "one-easy-formula-beats-90-easy-and-simple-to-understand",
                "content": "# Intuition\\nSo the intuition is simple, keeping the count of zeroes and using the simple mathematical formula to find the number of subarrays.\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public long zeroFilledSubarray(int[] nums) {\\n       ArrayList<Long> arr=new ArrayList<>();\\n       long compute=0;\\n\\n        for(int i=0;i<nums.length;i++){\\n            long countzero=0;\\n            if(nums[i]!=0){\\n                continue;\\n            }\\n            else{\\n                while(i<nums.length&&nums[i]==0){\\n       countzero+=1;\\ni++;\\n                }\\n                  long n=countzero;\\n            compute+=((n*(n+1))/2);\\n            }\\n        }\\n       \\n        return compute;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long zeroFilledSubarray(int[] nums) {\\n       ArrayList<Long> arr=new ArrayList<>();\\n       long compute=0;\\n\\n        for(int i=0;i<nums.length;i++){\\n            long countzero=0;\\n            if(nums[i]!=0){\\n                continue;\\n            }\\n            else{\\n                while(i<nums.length&&nums[i]==0){\\n       countzero+=1;\\ni++;\\n                }\\n                  long n=countzero;\\n            compute+=((n*(n+1))/2);\\n            }\\n        }\\n       \\n        return compute;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3971086,
                "title": "easy-c-solution-beats-99-users",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long zeroFilledSubarray(vector<int>& nums) {\\n       long long c=0;\\n        long long lg=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==0)lg++;\\n            else {\\n                lg=0;\\n            }\\n            c += lg;\\n        }\\n        return c; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long zeroFilledSubarray(vector<int>& nums) {\\n       long long c=0;\\n        long long lg=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==0)lg++;\\n            else {\\n                lg=0;\\n            }\\n            c += lg;\\n        }\\n        return c; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3842857,
                "title": "o-n-time-complexity-and-o-n-space-complexity",
                "content": "![image.png](https://assets.leetcode.com/users/images/bd854c37-630d-4bf3-982d-387439f0a6f9_1690807849.6875882.png)\\n\\n\\n# Intuition\\nThe code aims to find the number of subarrays filled with 0 in the given integer array nums. It does this by iterating through the array and identifying the subarrays filled with 0. The intuition behind the solution is to keep track of contiguous sequences of zeros and then calculate the number of subarrays filled with 0 in each sequence.\\n\\n# Approach\\nThe code uses a simple approach to solve the problem. It maintains an auxiliary list called aux to keep track of contiguous sequences of zeros in the input array nums. The variable resp is used to store the count of subarrays filled with 0.\\n\\nThe code iterates through the nums array. If the current element is 0, it is appended to the aux list. When a non-zero element is encountered, the code checks if the aux list is not empty. If it is not empty, it means we have a contiguous sequence of zeros, and the code calculates the number of subarrays that can be formed from this sequence using the formula n * (n + 1) / 2, where n is the length of the sequence. The result is added to the resp variable. After that, the aux list is reset to an empty list.\\n\\nAt the end of the iteration, there might be a remaining sequence of zeros in the aux list. If this is the case, the code performs the same calculation and adds it to the resp variable.\\n\\nFinally, the function returns the resp, which represents the total number of subarrays filled with 0 in the given array nums.\\n\\n# Complexity\\n- Time complexity:\\nThe code iterates through the nums array once, where n is the number of elements in the array. Each element is processed once, and all other operations (appending to aux, calculating resp, resetting aux) take constant time.\\n\\n- Space complexity:\\nThe space complexity is determined by the aux list, which can store up to n elements in the worst case.\\n\\n# Code\\n```\\nclass Solution:\\n    def zeroFilledSubarray(self, nums: List[int]) -> int:\\n        aux = []\\n        resp = 0\\n        for i in range(len(nums)):\\n            if nums[i] == 0:\\n                aux.append(nums[i])\\n            else:\\n                if len(aux) > 0:\\n                    n = len(aux)\\n                    resp += n*(n+1)/2\\n                    aux = []\\n        if len(aux) > 0:\\n            n = len(aux)\\n            resp += n*(n+1)/2\\n        return int(resp)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def zeroFilledSubarray(self, nums: List[int]) -> int:\\n        aux = []\\n        resp = 0\\n        for i in range(len(nums)):\\n            if nums[i] == 0:\\n                aux.append(nums[i])\\n            else:\\n                if len(aux) > 0:\\n                    n = len(aux)\\n                    resp += n*(n+1)/2\\n                    aux = []\\n        if len(aux) > 0:\\n            n = len(aux)\\n            resp += n*(n+1)/2\\n        return int(resp)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3790962,
                "title": "c-using-sliding-window-t-c-o-n-s-c-o-1",
                "content": "```\\nclass Solution {\\n    \\n    /*\\n        Time Complexity : O(N)\\n        Space Complexity : O(1)\\n    */ \\n    \\npublic:\\n    long long zeroFilledSubarray(vector<int>& nums) {\\n        long long res = 0, start = 0, end = 0;\\n        \\n        while(end < nums.size()){\\n            if(nums[end] != 0){\\n                end++;\\n                start = end;\\n            }else{\\n                res += end-start+1;\\n                end++;\\n            }   \\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    \\n    /*\\n        Time Complexity : O(N)\\n        Space Complexity : O(1)\\n    */ \\n    \\npublic:\\n    long long zeroFilledSubarray(vector<int>& nums) {\\n        long long res = 0, start = 0, end = 0;\\n        \\n        while(end < nums.size()){\\n            if(nums[end] != 0){\\n                end++;\\n                start = end;\\n            }else{\\n                res += end-start+1;\\n                end++;\\n            }   \\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3647381,
                "title": "easy-c-solution-1-iteration",
                "content": "# Intuition\\n\\n# Approach\\nAs we need to count the number of consecutive zeros and then number of subarrays that they will make.\\nExample there are currently 3 consecutive zeros and k subarrays. Now if next element is also 0 then how many extra subarrays will get added. Its clearly 4, because now there are 4 consecutive zeros and by adding this 0 we added 1 element to all subarrays and the elemetn itself.\\nSo each time we get consecutive zeros we will add a count of zeros and add this count in the answer.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long zeroFilledSubarray(vector<int>& nums) {\\n        int n=nums.size();\\n        long long ans=0;\\n        long long cons_zero=0;\\n        for(int i=0; i<n; i++){\\n            if(nums[i]==0) cons_zero++;\\n            else cons_zero=0;\\n            ans+=cons_zero;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long zeroFilledSubarray(vector<int>& nums) {\\n        int n=nums.size();\\n        long long ans=0;\\n        long long cons_zero=0;\\n        for(int i=0; i<n; i++){\\n            if(nums[i]==0) cons_zero++;\\n            else cons_zero=0;\\n            ans+=cons_zero;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3604101,
                "title": "easy-to-grasp-c-solution-by-cracking-the-pattern",
                "content": "# Intuition\\nTry to find out how many consecutive 0 can produce how many zero filled subarrays.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nIf there are n number of consecutive 0s then it can produce n*(n+1)/2\\nzero filled subarrays.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long zeroFilledSubarray(vector<int>& nums) \\\\\\n    {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n\\n        long long c=1;\\n        int n = nums.size();\\n        long long ans = 0;\\n\\n        for(int i=0; i<n-1; i++)\\n        {\\n            if(nums[i] == 0 && nums[i+1] == 0)\\n            c++;\\n\\n            else if(nums[i] == 0 && nums[i+1] != 0)\\n            {\\n                ans += c*(c+1)/2;\\n                c=1;\\n            }\\n        }\\n        if(nums[n-1] == 0)\\n        ans += c*(c+1)/2;\\n\\n        return ans;\\n    }\\n};\\n\\n```\\n![06351dc5-1e55-461d-acf2-60c9048c4726_1675165944.4721575.webp](https://assets.leetcode.com/users/images/2b8ee65a-52bc-422e-9092-dffd655c6faf_1686041216.9936173.webp)\\n\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math",
                    "Brainteaser",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long zeroFilledSubarray(vector<int>& nums) \\\\\\n    {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n\\n        long long c=1;\\n        int n = nums.size();\\n        long long ans = 0;\\n\\n        for(int i=0; i<n-1; i++)\\n        {\\n            if(nums[i] == 0 && nums[i+1] == 0)\\n            c++;\\n\\n            else if(nums[i] == 0 && nums[i+1] != 0)\\n            {\\n                ans += c*(c+1)/2;\\n                c=1;\\n            }\\n        }\\n        if(nums[n-1] == 0)\\n        ans += c*(c+1)/2;\\n\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3429809,
                "title": "faster-than-all-submissions",
                "content": "\\n# Complexity\\n- Time complexity:97%\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:98%\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n```go []\\nfunc zeroFilledSubarray(nums []int) int64 {\\n        var answer int64\\n     var count,i int64;\\n    for i =0 ;i<int64(len(nums));i++{\\n        if nums[i]==0{\\n        count++;\\n        }else{\\n            answer+= count*(count+1)/2;\\n            count=0;\\n        }\\n    }\\n    answer+=1*count*(count+1)/2;\\n    return answer;    \\n}\\n```\\n```javascript []\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar zeroFilledSubarray = function(nums) {\\n   let answer=0;\\n    let count=0;\\n    for(let i=0;i<nums.length;i++){\\n        if(nums[i]==0)\\n        count++;\\n        else{\\n            answer+= 1*count*(count+1)/2;\\n            count=0;\\n        }\\n    }\\n    answer+=1*count*(count+1)/2;\\n    return answer;    \\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Go"
                ],
                "code": "```go []\\nfunc zeroFilledSubarray(nums []int) int64 {\\n        var answer int64\\n     var count,i int64;\\n    for i =0 ;i<int64(len(nums));i++{\\n        if nums[i]==0{\\n        count++;\\n        }else{\\n            answer+= count*(count+1)/2;\\n            count=0;\\n        }\\n    }\\n    answer+=1*count*(count+1)/2;\\n    return answer;    \\n}\\n```\n```javascript []\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar zeroFilledSubarray = function(nums) {\\n   let answer=0;\\n    let count=0;\\n    for(let i=0;i<nums.length;i++){\\n        if(nums[i]==0)\\n        count++;\\n        else{\\n            answer+= 1*count*(count+1)/2;\\n            count=0;\\n        }\\n    }\\n    answer+=1*count*(count+1)/2;\\n    return answer;    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3416096,
                "title": "sliding-window-java-easy-to-understand",
                "content": "use two pointer s(start) ans e(end).\\niterate e till length of the array.\\n# Approach\\nJust use sliding window .\\n1.add element to window by adding element in sum.\\n2.shrink window if sum is going greater than 0.\\n3.calculate answer by the length of window of that time.\\n# Complexity\\n- Time complexity:\\nO(n)\\n- Space complexity:\\nO(1)\\n# Code\\n```\\nclass Solution {\\n    public long zeroFilledSubarray(int[] nums) {\\n        int s=0;\\n        int e=0;\\n        long ans=0;\\n        int sum=0;\\n        while(e<nums.length){\\n            sum+=nums[e];\\n            while(sum!=0){\\n                sum-=nums[s];\\n                s++;\\n            }\\n        ans+=e-s+1;\\n        e++;\\n        }\\n        return ans;\\n    }\\n}\\n```\\n![e9d15172-c989-4baa-b2e0-d92379f925b5_1677818866.229168.png](https://assets.leetcode.com/users/images/794311d5-2f2a-4149-a1a6-3723d5aa8c63_1681470653.353881.png)",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long zeroFilledSubarray(int[] nums) {\\n        int s=0;\\n        int e=0;\\n        long ans=0;\\n        int sum=0;\\n        while(e<nums.length){\\n            sum+=nums[e];\\n            while(sum!=0){\\n                sum-=nums[s];\\n                s++;\\n            }\\n        ans+=e-s+1;\\n        e++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3335201,
                "title": "beat-92-please-look-at-least-once-linear-time-complexity",
                "content": "# Intuition\\n# **Bhagwan pe bharosa rakh....**\\n\\n# Approach\\nJai Shree Ram\\n\\n# Complexity\\n- Time complexity:\\nO(n);\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long zeroFilledSubarray(vector<int>& nums) {\\n        long cnt = 0, zeroSubarraysEndingAtCurrentIndex = 0;\\n        for (int n : nums) {\\n            if (n == 0) {\\n                cnt += ++zeroSubarraysEndingAtCurrentIndex;\\n            } else {\\n                zeroSubarraysEndingAtCurrentIndex = 0;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```\\n![OIF.jpg](https://assets.leetcode.com/users/images/6b3813cd-6528-4381-a447-73f0b92af928_1679646856.9660172.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long zeroFilledSubarray(vector<int>& nums) {\\n        long cnt = 0, zeroSubarraysEndingAtCurrentIndex = 0;\\n        for (int n : nums) {\\n            if (n == 0) {\\n                cnt += ++zeroSubarraysEndingAtCurrentIndex;\\n            } else {\\n                zeroSubarraysEndingAtCurrentIndex = 0;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3327262,
                "title": "simple-1d-dp-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long zeroFilledSubarray(vector<int>& nums) {\\n        //can we use dp here \\n        //if we found the number of zero filled  subarrays ending at a particular index \\n        //then find such for each index \\n        //and then finally return summaation of all of them\\n        vector<long long>dp(nums.size(),0);\\n\\n        //dp[i]-number of zero filled subarrays ending at that index\\n        dp[0]=nums[0]==0?1:0;\\n        long long t=0;\\n        if(dp[0])t++;\\n        for(int i=1;i<nums.size();i++){\\n            if(nums[i]==0){\\n                dp[i]=1;\\n             \\n\\n                    dp[i]+=dp[i-1];\\n                  \\n                    //ek hi analogy fix karke chalo\\n                    //usme hi sare arrays count ho jaenge\\n\\n                \\n                t+=dp[i];\\n            }\\n        }\\n        return t;\\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long zeroFilledSubarray(vector<int>& nums) {\\n        //can we use dp here \\n        //if we found the number of zero filled  subarrays ending at a particular index \\n        //then find such for each index \\n        //and then finally return summaation of all of them\\n        vector<long long>dp(nums.size(),0);\\n\\n        //dp[i]-number of zero filled subarrays ending at that index\\n        dp[0]=nums[0]==0?1:0;\\n        long long t=0;\\n        if(dp[0])t++;\\n        for(int i=1;i<nums.size();i++){\\n            if(nums[i]==0){\\n                dp[i]=1;\\n             \\n\\n                    dp[i]+=dp[i-1];\\n                  \\n                    //ek hi analogy fix karke chalo\\n                    //usme hi sare arrays count ho jaenge\\n\\n                \\n                t+=dp[i];\\n            }\\n        }\\n        return t;\\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3327218,
                "title": "c-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long zeroFilledSubarray(vector<int>& nums) {\\n        long long res = 0, ans = 1;\\n        \\n        for(auto num : nums){  \\n            if(num == 0){\\n                res += ans;\\n                ans++;\\n            }\\n            else{\\n                ans = 1;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long zeroFilledSubarray(vector<int>& nums) {\\n        long long res = 0, ans = 1;\\n        \\n        for(auto num : nums){  \\n            if(num == 0){\\n                res += ans;\\n                ans++;\\n            }\\n            else{\\n                ans = 1;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3326999,
                "title": "java-loop-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf we wound 0 in an array increase the count with +1, continue till you keep on finding consecutive 0\\'s.And Keep udpdating ans.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:$$O(N)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long zeroFilledSubarray(int[] nums) {\\n        long count=0;\\n        long ans=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==0){\\n                count++;\\n            }else{\\n                count=0;\\n            }\\n            ans+=count;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public long zeroFilledSubarray(int[] nums) {\\n        long count=0;\\n        long ans=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==0){\\n                count++;\\n            }else{\\n                count=0;\\n            }\\n            ans+=count;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3326570,
                "title": "javascript-1-line-time-o-n-space-o-1",
                "content": "# Approach\\n1. Initialize counts `temp` (running # of consecutive zeros) & `sum` (# of subarrays) to `0`.\\n2. Iterate through `num`. For each value `n`:\\n    1. If `n` is `0`, increment `temp`. Else set `temp = 0`.\\n    2. Add `temp` to `sum`.\\n3. After the loop, return `sum`.\\n\\nImplementation below performs this using `Array.reduce`.\\n\\n# Complexity\\n- Time complexity: O(n)\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nconst zeroFilledSubarray = ( nums, t = 0 ) =>\\n    nums.reduce( ( s, n ) => s + ( t = !n && t+1 ), 0 )\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array",
                    "Math"
                ],
                "code": "```\\nconst zeroFilledSubarray = ( nums, t = 0 ) =>\\n    nums.reduce( ( s, n ) => s + ( t = !n && t+1 ), 0 )\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3326432,
                "title": "2348-number-of-zero-filled-subarrays",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long zeroFilledSubarray(vector<int>& nums) {\\n        \\n        long long count =0;\\n        long long find = 0;\\n        // base case\\n        if(nums[0] == 0)\\n        count++;\\n        else\\n        count=0;\\n\\n       for(int i=1;i<nums.size();i++)\\n        {\\n            // check the single and count all zeros \\n            if(nums[i] == 0)  \\n            \\n                count++;\\n            \\n            // else{\\n            //     nums[i+1]; // this condition check the next element \\n\\n\\n          // check the subarrays zeros and count the sub array two paris \\n            if(nums[i] && nums[i-1] ==0)\\n            {\\n                find = find+((count+1)* count/2);\\n                count=0;\\n            }\\n\\n            }\\n        find = find+(count+1)*count/2;\\n        return find;\\n    \\n     }\\n       \\n    \\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long zeroFilledSubarray(vector<int>& nums) {\\n        \\n        long long count =0;\\n        long long find = 0;\\n        // base case\\n        if(nums[0] == 0)\\n        count++;\\n        else\\n        count=0;\\n\\n       for(int i=1;i<nums.size();i++)\\n        {\\n            // check the single and count all zeros \\n            if(nums[i] == 0)  \\n            \\n                count++;\\n            \\n            // else{\\n            //     nums[i+1]; // this condition check the next element \\n\\n\\n          // check the subarrays zeros and count the sub array two paris \\n            if(nums[i] && nums[i-1] ==0)\\n            {\\n                find = find+((count+1)* count/2);\\n                count=0;\\n            }\\n\\n            }\\n        find = find+(count+1)*count/2;\\n        return find;\\n    \\n     }\\n       \\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3326431,
                "title": "easy-to-understand-java-solution-100-and-60-faster-code",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code 60% Faster\\n```\\nclass Solution {\\n    public long zeroFilledSubarray(int[] nums) {\\n        long count = 0;\\n        long finalAns = 0;\\n        for(int i = 0; i<nums.length;i++){\\n            if(nums[i] == 0){\\n                while(i<nums.length && nums[i] == 0){\\n                    count++;\\n                    i++;\\n                }\\n                finalAns +=(count*(count+1))/2;\\n                count = 0;\\n            }\\n        }\\n        return finalAns;\\n    }\\n}\\n```\\n# Code 99% Faster \\n```\\nclass Solution {\\n    public long zeroFilledSubarray(int[] nums) {\\n        long contCount = 0;\\n        long subarrays = 0;\\n        for(int i=0; i<nums.length; i++){\\n            if(nums[i]==0){\\n                contCount++;\\n                subarrays+=contCount;\\n            }\\n            else{\\n                contCount=0;\\n            }\\n        }\\n        return subarrays;\\n    }\\n}\\n```\\n# Please Up Vote",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long zeroFilledSubarray(int[] nums) {\\n        long count = 0;\\n        long finalAns = 0;\\n        for(int i = 0; i<nums.length;i++){\\n            if(nums[i] == 0){\\n                while(i<nums.length && nums[i] == 0){\\n                    count++;\\n                    i++;\\n                }\\n                finalAns +=(count*(count+1))/2;\\n                count = 0;\\n            }\\n        }\\n        return finalAns;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public long zeroFilledSubarray(int[] nums) {\\n        long contCount = 0;\\n        long subarrays = 0;\\n        for(int i=0; i<nums.length; i++){\\n            if(nums[i]==0){\\n                contCount++;\\n                subarrays+=contCount;\\n            }\\n            else{\\n                contCount=0;\\n            }\\n        }\\n        return subarrays;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3326411,
                "title": "java-solution-60-easy-understandable",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public long zeroFilledSubarray(int[] nums) {\\n        long c=0;\\n        long ans=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==0){\\n            while( i<nums.length && nums[i]==0){\\n                c++;\\n                i++;\\n            }\\n            ans+= (c*(c+1))/2;\\n            c=0;\\n\\n            }\\n            \\n            \\n\\n        }\\n        return ans;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long zeroFilledSubarray(int[] nums) {\\n        long c=0;\\n        long ans=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==0){\\n            while( i<nums.length && nums[i]==0){\\n                c++;\\n                i++;\\n            }\\n            ans+= (c*(c+1))/2;\\n            c=0;\\n\\n            }\\n            \\n            \\n\\n        }\\n        return ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3326392,
                "title": "elixir-beats-100-o-n-reduce-with-explanation",
                "content": "# Approach\\nWe need a little bit of combinatorics to crack this one. So is there an effective way to compute how many contiguous subarrays of min length 1 are there in an array of zeros with length n ? \\n\\nLet\\'s see:\\nIf we do have array of length n, then there is only one subarray.\\nIf we do have an array of length n-1, there are two, because there is a gap on which we can slide once.\\n\\nFor length n-2 it is three and so on.\\n\\nSo for example if the n is 5, then:\\n1. 1 array of length 5\\n2. 2 arrays of length 4\\n3. 3 of length 3\\n4. 4 of length 2\\n5. 5 of length 1\\n\\nThis is because we have to shift our subarray of length k by one position until the end of last subarray reaches end of the big array. So we can slide zero times when k is same as n, one time when k is n-1 and so on.\\n\\nSo if we want all the contiguous subarrays of minimal length k, then their count is:\\n$$ \\\\sum_{i=1}^n{i} $$ or $$ 1 + 2 + ... + n $$.\\n\\nWe can calculate this pretty quickly with gauss trick:\\n$$ \\\\sum_{i=1}^n{i} = \\\\frac{n*(n+1)}{2} $$\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$ \\n\\n- Space complexity:\\n$$O(1)$$ \\n\\nCode then can be further optimized and instead of adding the whole sum we can just add to result on every streak resize and then reset streak on non-zero number enconuters.\\n\\n# Code\\n```\\ndefmodule Solution do\\n  @spec zero_filled_subarray(nums :: [integer]) :: integer\\n  def zero_filled_subarray(nums) do\\n    {res, _} = Enum.reduce(nums, {0, 0}, fn n, {acc, zeroStrk} -> \\n        if n == 0, do: {acc+zeroStrk+1, zeroStrk+1}, else: {acc, 0}\\n    end)\\n    res\\n  end\\nend\\n```\\n\\n\\n---\\n\\n\\uD83D\\uDC4D\\uFE0F\\uD83D\\uDC4D\\uFE0F If you like this solution or find it helpful, please upvote this post. \\uD83D\\uDC4D\\uFE0F\\uD83D\\uDC4D\\uFE0F",
                "solutionTags": [
                    "Elixir",
                    "Array",
                    "Math"
                ],
                "code": "```\\ndefmodule Solution do\\n  @spec zero_filled_subarray(nums :: [integer]) :: integer\\n  def zero_filled_subarray(nums) do\\n    {res, _} = Enum.reduce(nums, {0, 0}, fn n, {acc, zeroStrk} -> \\n        if n == 0, do: {acc+zeroStrk+1, zeroStrk+1}, else: {acc, 0}\\n    end)\\n    res\\n  end\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3326369,
                "title": "kotlin-beats-100-o-n-with-explanation",
                "content": "# Approach\\nWe need a little bit of combinatorics to crack this one. So is there an effective way to compute how many contiguous subarrays of min length 1 are there in an array of zeros with length n ? \\n\\nLet\\'s see:\\nIf we do have array of length n, then there is only one subarray.\\nIf we do have an array of length n-1, there are two, because there is a gap on which we can slide once.\\n\\nFor length n-2 it is three and so on.\\n\\nSo for example if the n is 5, then:\\n1. 1 array of length 5\\n2. 2 arrays of length 4\\n3. 3 of length 3\\n4. 4 of length 2\\n5. 5 of length 1\\n\\nThis is because we have to shift our subarray of length k by one position until the end of last subarray reaches end of the big array. So we can slide zero times when k is same as n, one time when k is n-1 and so on.\\n\\nSo if we want all the contiguous subarrays of minimal length k, then their count is:\\n$$ \\\\sum_{i=1}^n{i} $$ or $$ 1 + 2 + ... + n $$.\\n\\nWe can calculate this pretty quickly with gauss trick:\\n$$ \\\\sum_{i=1}^n{i} = \\\\frac{n*(n+1)}{2} $$\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    fun zeroFilledSubarray(nums: IntArray): Long {\\n        var currentZeroStreak = 0L\\n        var subarrays = 0L\\n        for (n in nums) {\\n            if (n == 0) {\\n                currentZeroStreak++\\n                continue\\n            }\\n\\n            subarrays += (currentZeroStreak * (currentZeroStreak + 1)) / 2\\n            currentZeroStreak = 0\\n        }\\n\\n        return subarrays + (currentZeroStreak * (currentZeroStreak + 1)) / 2\\n    }\\n}\\n```\\n\\nthis can be further optimized to shorter code as a tradeoff for readability:\\n\\n# Code\\n```\\nclass Solution {\\n    fun zeroFilledSubarray(nums: IntArray): Long {\\n        var currentZeroStreak = 0L\\n        var subarrays = 0L\\n        for (n in nums) {\\n            if (n == 0) subarrays += ++currentZeroStreak\\n            else currentZeroStreak = 0\\n        }\\n\\n        return subarrays\\n    }\\n}\\n```\\n\\n---\\n\\n\\uD83D\\uDC4D\\uFE0F\\uD83D\\uDC4D\\uFE0F If you like this solution or find it helpful, please upvote this post. \\uD83D\\uDC4D\\uFE0F\\uD83D\\uDC4D\\uFE0F",
                "solutionTags": [
                    "Kotlin",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    fun zeroFilledSubarray(nums: IntArray): Long {\\n        var currentZeroStreak = 0L\\n        var subarrays = 0L\\n        for (n in nums) {\\n            if (n == 0) {\\n                currentZeroStreak++\\n                continue\\n            }\\n\\n            subarrays += (currentZeroStreak * (currentZeroStreak + 1)) / 2\\n            currentZeroStreak = 0\\n        }\\n\\n        return subarrays + (currentZeroStreak * (currentZeroStreak + 1)) / 2\\n    }\\n}\\n```\n```\\nclass Solution {\\n    fun zeroFilledSubarray(nums: IntArray): Long {\\n        var currentZeroStreak = 0L\\n        var subarrays = 0L\\n        for (n in nums) {\\n            if (n == 0) subarrays += ++currentZeroStreak\\n            else currentZeroStreak = 0\\n        }\\n\\n        return subarrays\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3326299,
                "title": "python3-dp-easy-to-understand-get-the-pattern-dictionary",
                "content": "\\'\\'\\':\\n\\n\\n\\t\\t\\t\\t\\tthe pattern is here: {1:1,2:3,3:6,4:10,5:15,6:21} ={number of zeros:answer}\\n\\t\\t\\t\\t\\tif the question is [0,0] the answer becomes 3.\\n\\t\\t\\t\\t\\tbut if the question becomes like this [0,0,1,0,0] the answer becomes 6 which means 3+3\\n\\t\\t\\t\\t\\t[0,0] = 3 , [0,0] = 3 , [0,0,1,0,0] = 3+3 = 6\\n\\t\\t\\n\\'\\'\\'\\n\\n\\'\\'\\'\\n\\n\\t\\tclass Solution:\\n\\t\\t\\n\\t\\t\\t\\tdef zeroFilledSubarray(self, nums: List[int]) -> int:\\n\\t\\t\\t\\t\\t\"\"\"pattern  :1:1,2:3,3:6,4:10,5:15,6:21\"\"\"\\n\\n\\t\\t\\t\\t\\tdp = [0 for i in range(max(100,len(nums)+1))]\\n\\t\\t\\t\\t\\tdp[1] = 1\\n\\t\\t\\t\\t\\tdp[2] = 3\\n\\t\\t\\t\\t\\tfor i in range(3,len(nums)+1):\\n\\t\\t\\t\\t\\t\\tdp[i] = dp[i-1]+i\\n\\t\\t\\t\\t\\tres = 0\\n\\t\\t\\t\\t\\tcount = 0\\n\\t\\t\\t\\t\\tfor i in nums:\\n\\t\\t\\t\\t\\t\\tif i ==0:\\n\\t\\t\\t\\t\\t\\t\\tcount +=1\\n\\t\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\t\\tres+= dp[count]\\n\\t\\t\\t\\t\\t\\t\\tcount = 0\\n\\t\\t\\t\\t\\tres+=dp[count]\\n\\t\\t\\t\\t\\treturn res\\n\\n\\'\\'\\'",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "\\'\\'\\':\\n\\n\\n\\t\\t\\t\\t\\tthe pattern is here: {1:1,2:3,3:6,4:10,5:15,6:21} ={number of zeros:answer}\\n\\t\\t\\t\\t\\tif the question is [0,0] the answer becomes 3.\\n\\t\\t\\t\\t\\tbut if the question becomes like this [0,0,1,0,0] the answer becomes 6 which means 3+3\\n\\t\\t\\t\\t\\t[0,0] = 3 , [0,0] = 3 , [0,0,1,0,0] = 3+3 = 6\\n\\t\\t\\n\\'\\'\\'\\n\\n\\'\\'\\'\\n\\n\\t\\tclass Solution:\\n\\t\\t\\n\\t\\t\\t\\tdef zeroFilledSubarray(self, nums: List[int]) -> int:\\n\\t\\t\\t\\t\\t\"\"\"pattern  :1:1,2:3,3:6,4:10,5:15,6:21\"\"\"\\n\\n\\t\\t\\t\\t\\tdp = [0 for i in range(max(100,len(nums)+1))]\\n\\t\\t\\t\\t\\tdp[1] = 1\\n\\t\\t\\t\\t\\tdp[2] = 3\\n\\t\\t\\t\\t\\tfor i in range(3,len(nums)+1):\\n\\t\\t\\t\\t\\t\\tdp[i] = dp[i-1]+i\\n\\t\\t\\t\\t\\tres = 0\\n\\t\\t\\t\\t\\tcount = 0\\n\\t\\t\\t\\t\\tfor i in nums:\\n\\t\\t\\t\\t\\t\\tif i ==0:\\n\\t\\t\\t\\t\\t\\t\\tcount +=1\\n\\t\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\t\\tres+= dp[count]\\n\\t\\t\\t\\t\\t\\t\\tcount = 0\\n\\t\\t\\t\\t\\tres+=dp[count]\\n\\t\\t\\t\\t\\treturn res\\n\\n\\'\\'\\'",
                "codeTag": "Java"
            },
            {
                "id": 3326214,
                "title": "time-complexity-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long zeroFilledSubarray(vector<int>& nums) {\\n        long long count = 0, num_zeros = 0;\\n        for (int i = 0; i < nums.size(); i++) {\\n            if (nums[i] == 0) {\\n                num_zeros++;\\n            } else {\\n                count += (num_zeros * (num_zeros + 1)) / 2;\\n                num_zeros = 0;\\n            }\\n        }\\n        count += (num_zeros * (num_zeros + 1)) / 2;\\n        return count;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long zeroFilledSubarray(vector<int>& nums) {\\n        long long count = 0, num_zeros = 0;\\n        for (int i = 0; i < nums.size(); i++) {\\n            if (nums[i] == 0) {\\n                num_zeros++;\\n            } else {\\n                count += (num_zeros * (num_zeros + 1)) / 2;\\n                num_zeros = 0;\\n            }\\n        }\\n        count += (num_zeros * (num_zeros + 1)) / 2;\\n        return count;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3326177,
                "title": "number-of-zero-filled-subarrays-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^2)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long zeroFilledSubarray(vector<int>& nums) {\\n        long long int i=0, j, ans=0, count=0;\\n        while(i<nums.size())\\n        {\\n            if(nums[i]==0)\\n            {\\n                count=1;\\n                ans += 1;\\n                for(j=i+1 ; j<nums.size() ; j++)\\n                {\\n                    if(nums[j]==0)\\n                    {\\n                        count++;\\n                        ans += count;\\n                    }\\n                    else\\n                    {\\n                        break;\\n                    }\\n                }\\n                i += (j-i+1);\\n            }\\n            else\\n            {\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long zeroFilledSubarray(vector<int>& nums) {\\n        long long int i=0, j, ans=0, count=0;\\n        while(i<nums.size())\\n        {\\n            if(nums[i]==0)\\n            {\\n                count=1;\\n                ans += 1;\\n                for(j=i+1 ; j<nums.size() ; j++)\\n                {\\n                    if(nums[j]==0)\\n                    {\\n                        count++;\\n                        ans += count;\\n                    }\\n                    else\\n                    {\\n                        break;\\n                    }\\n                }\\n                i += (j-i+1);\\n            }\\n            else\\n            {\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3326108,
                "title": "easy-c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long zeroFilledSubarray(vector<int>& nums) {\\n      long long int count=0;\\n       long long int total=0;\\n    for(int i=0;i<nums.size();i++){\\n        if(nums[i]==0)\\n            count++;\\n        else\\n        {\\n            count =0;\\n        }\\n        total+=count;\\n    }\\n    return total;   \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long zeroFilledSubarray(vector<int>& nums) {\\n      long long int count=0;\\n       long long int total=0;\\n    for(int i=0;i<nums.size();i++){\\n        if(nums[i]==0)\\n            count++;\\n        else\\n        {\\n            count =0;\\n        }\\n        total+=count;\\n    }\\n    return total;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3326003,
                "title": "easy-cpp-code-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n# **Please upvote the solution if you like it.**\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe code defines a class Solution, which has a private function named apSum that calculates the sum of an arithmetic progression up to a given number n using the formula (n*(n+1))/2. The class also has a public function named zeroFilledSubarray that takes an array of integers nums as input and returns a long long integer, which represents the number of zero-filled subarrays in nums.\\n\\nThe function first disables the synchronization between C++ standard streams and C standard streams using ios_base::sync_with_stdio(false) to optimize the code for faster input/output operations. It then initializes the variable ans to 0, which will be used to store the total number of zero-filled subarrays.\\n\\nThe function iterates through the array nums using a for loop and checks each element of the array. If the element is 0, it increments the variable counter by 1, which keeps track of the number of consecutive 0s in the array. If the element is not 0, it checks if counter is not equal to 0, which means there are consecutive 0s before this element. In this case, the function calculates the sum of all possible subarrays that can be formed using the consecutive 0s using the apSum function and adds it to ans. The counter is then reset to 0.\\n\\nAfter the for loop, the function checks if counter is not equal to 0, which means there are consecutive 0s at the end of the array. In this case, the function calculates the sum of all possible subarrays that can be formed using the consecutive 0s using the apSum function and adds it to ans.\\n\\nFinally, the function returns ans, which represents the total number of zero-filled subarrays in nums.\\n\\nOverall, the function has a time complexity of O(n), where n is the length of the input array, as it iterates through the array only once.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    inline long long apSum(long long n){\\n        return (n*(n+1))/2;\\n    }\\npublic:\\n    long long zeroFilledSubarray(vector<int>& nums) {\\n        ios_base::sync_with_stdio(false);\\n        long long ans=0;\\n        int counter=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==0){\\n                counter++;\\n            }\\n            else{\\n                if(counter!=0){\\n                    ans+=apSum(counter);\\n                    counter=0;\\n                }\\n            }\\n        }\\n        if(counter!=0){\\n            ans+=apSum(counter);\\n            counter=0;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    inline long long apSum(long long n){\\n        return (n*(n+1))/2;\\n    }\\npublic:\\n    long long zeroFilledSubarray(vector<int>& nums) {\\n        ios_base::sync_with_stdio(false);\\n        long long ans=0;\\n        int counter=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==0){\\n                counter++;\\n            }\\n            else{\\n                if(counter!=0){\\n                    ans+=apSum(counter);\\n                    counter=0;\\n                }\\n            }\\n        }\\n        if(counter!=0){\\n            ans+=apSum(counter);\\n            counter=0;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3325965,
                "title": "number-of-zero-filled-subarrays-bf-math-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\no(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long zeroFilledSubarray(int[] nums) {\\n        long cnt=0;\\n        long val=0;\\n        int len=nums.length-1;\\n      for(int i=0;i<nums.length;i++){\\n           if(nums[i]==0){\\n               cnt++;\\n           }\\n           if(nums[i]!=0||i==len){\\n               for(int j=1;j<=cnt;j++){\\n                   val+=j;\\n               }\\n               cnt=0;\\n           }\\n\\n \\n      }\\n\\n        return val;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long zeroFilledSubarray(int[] nums) {\\n        long cnt=0;\\n        long val=0;\\n        int len=nums.length-1;\\n      for(int i=0;i<nums.length;i++){\\n           if(nums[i]==0){\\n               cnt++;\\n           }\\n           if(nums[i]!=0||i==len){\\n               for(int j=1;j<=cnt;j++){\\n                   val+=j;\\n               }\\n               cnt=0;\\n           }\\n\\n \\n      }\\n\\n        return val;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3325964,
                "title": "o-n-explained-c",
                "content": "\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long zeroFilledSubarray(vector<int>& nums) {\\n        int n = nums.size();\\n        long long c=0,tmp=0;\\n        for(int i:nums)\\n        {\\n            if(i != 0) {\\n                tmp = 0;\\n            }\\n            else {\\n                tmp++;\\n                c += tmp;\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long zeroFilledSubarray(vector<int>& nums) {\\n        int n = nums.size();\\n        long long c=0,tmp=0;\\n        for(int i:nums)\\n        {\\n            if(i != 0) {\\n                tmp = 0;\\n            }\\n            else {\\n                tmp++;\\n                c += tmp;\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3325837,
                "title": "math-easy-one-line-solution-tc-o-n-sc-o-1-100-beat",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFinding the the critical point(all subarray elements are not zero)\\n\\nSimilar problem\\n[713. Subarray Product Less Than K](https://leetcode.com/problems/subarray-product-less-than-k/)\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTest Case:-1\\n[1,3,0,0,2,0,0,4]\\ni=0, count =0, nums[0]!=0 that\\'s counter won\\'t increase.\\ni=1, count =0\\ni=2, count =1 \\ni=3, count =2,\\ni=4, This is critical point where we collect our ans\\nwhere nums[i]!=0  ans+= count*(count+1)/2..\\nHere count=2, there would be 3 [0] [0], [0,0];\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n     O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n     O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long zeroFilledSubarray(vector<int>& nums) {\\n        long long ans=0,count=0;\\n        for(auto it:nums)\\n           count=it==0?count+1:0, ans+=count;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long zeroFilledSubarray(vector<int>& nums) {\\n        long long ans=0,count=0;\\n        for(auto it:nums)\\n           count=it==0?count+1:0, ans+=count;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3325610,
                "title": "c-easy-solution-o-n",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    long long zeroFilledSubarray(vector<int>& nums) {\\n        int start=0,end=0;\\n        long long numberOfSubArray = 0;\\n        for(int start = 0;start<nums.size();start++){\\n            if(nums[start]==0){\\n                end = start;\\n                while(end!=nums.size() && nums[end]==0){\\n                    end++;\\n                }\\n                int len = end-start;\\n                numberOfSubArray += 1LL*len*(len+1)/2;\\n                start = end;\\n            }\\n        }\\n\\n        return numberOfSubArray;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long zeroFilledSubarray(vector<int>& nums) {\\n        int start=0,end=0;\\n        long long numberOfSubArray = 0;\\n        for(int start = 0;start<nums.size();start++){\\n            if(nums[start]==0){\\n                end = start;\\n                while(end!=nums.size() && nums[end]==0){\\n                    end++;\\n                }\\n                int len = end-start;\\n                numberOfSubArray += 1LL*len*(len+1)/2;\\n                start = end;\\n            }\\n        }\\n\\n        return numberOfSubArray;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3325523,
                "title": "simple-c-o-n-greedy-approach-with-explanation",
                "content": "# Intuition\\nI saw a pattern being followed here.\\nif count of cont. 0 are:\\n1 then subarray will be = 1*1+0=1\\n2 = (2 * 1) + 1 = 3\\n3 = (3 * 2) + 0 = 6\\n4 = (4 * 2) + 2 = 10\\n5 = (5 * 3) + 0 = 15\\n6 = (6 * 3) + 3 = 21\\n...... \\n# Approach\\nSo I stored counts of subarray containing 0 in an freq array. \\nThen traverse in the freq array and see if count is odd so ans+= count*(count/2+1)\\nelse ans+= count*(count/2)+(count/2)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long zeroFilledSubarray(vector<int>& nums) {\\n        \\n        int n=nums.size();\\n        int count=0;\\n        vector<int> freq;\\n\\n        for(int i=0; i<n; i++){\\n            if(nums[i]==0){\\n                count++; \\n            }\\n            else{\\n                if(count!=0){\\n                    freq.push_back(count);\\n                    count=0;\\n                }\\n            }\\n        }\\n\\n        if(count!=0){\\n            freq.push_back(count);\\n        }\\n        \\n        long long ans=0;\\n        for(int i=0; i<freq.size(); i++){\\n            if(freq[i]%2==0){\\n                long long mul=freq[i]/2;\\n                ans+= (freq[i]*mul)+mul;\\n            }\\n            else{\\n                long long mul= freq[i]/2+1;\\n                ans+= freq[i]*mul;                \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long zeroFilledSubarray(vector<int>& nums) {\\n        \\n        int n=nums.size();\\n        int count=0;\\n        vector<int> freq;\\n\\n        for(int i=0; i<n; i++){\\n            if(nums[i]==0){\\n                count++; \\n            }\\n            else{\\n                if(count!=0){\\n                    freq.push_back(count);\\n                    count=0;\\n                }\\n            }\\n        }\\n\\n        if(count!=0){\\n            freq.push_back(count);\\n        }\\n        \\n        long long ans=0;\\n        for(int i=0; i<freq.size(); i++){\\n            if(freq[i]%2==0){\\n                long long mul=freq[i]/2;\\n                ans+= (freq[i]*mul)+mul;\\n            }\\n            else{\\n                long long mul= freq[i]/2+1;\\n                ans+= freq[i]*mul;                \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3325494,
                "title": "python-simple-and-clean-beats-100",
                "content": "### Please upvote if you find this helpful. \\u270C\\n<img src=\"https://assets.leetcode.com/users/images/b8e25620-d320-420a-ae09-94c7453bd033_1678818986.7001078.jpeg\" alt=\"Cute Robot - Stable diffusion\" width=\"200\"/>\\n\\n*This is an NFT*\\n# Intuition\\nThe problem asks us to find the number of subarrays filled with 0. A subarray is a contiguous non-empty sequence of elements within an array. So our first thought might be to count all the contiguous sequences of 0s in the array.\\n\\n# Approach\\n1. Initialize two variables `count` and `n` to keep track of the number of zero-filled subarrays and the length of the current sequence of 0s respectively.\\n2. Iterate through each element in `nums`.\\n3. If the current element is 0, increment `n` by 1.\\n4. If the current element is not 0, add `(n*(n+1))//2` to `count` and reset `n` to 0.\\n5. After iterating through all elements in `nums`, if `n` is not 0, add `(n*(n+1))//2` to `count`.\\n6. Return `count`.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$ where n is the length of nums.\\n- Space complexity: $$O(1)$$ since we only use constant extra space.\\n\\n# Code\\n```\\nclass Solution:\\n    def zeroFilledSubarray(self, nums: List[int]) -> int:\\n        count, n = 0, 0\\n        for num in nums:\\n            if num==0:\\n                n+=1\\n            else:\\n                count += (n*(n+1))//2\\n                n = 0\\n        if n:\\n            count += (n*(n+1))//2\\n        return count\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def zeroFilledSubarray(self, nums: List[int]) -> int:\\n        count, n = 0, 0\\n        for num in nums:\\n            if num==0:\\n                n+=1\\n            else:\\n                count += (n*(n+1))//2\\n                n = 0\\n        if n:\\n            count += (n*(n+1))//2\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3325484,
                "title": "java-simple-solution-explained-visualized",
                "content": "# Intuition\\nI observed a pattern and it worked for me. If we see keep seeing continous zeroes we keep adding it to subarrays and keep incrementing the continousZero count. Once a non zero integer comes we reset the continousZero count and start from 0 again. Below is an easy visualisation which will help you.\\n\\n\\nnums =  0 0 0 2 0 0\\nindex = 0 1 2 3 4 5\\n \\ni=0 nums[i] = 0\\n**continousCount**=1\\n**subarray** = 1\\nwith single 0 -> 1\\n\\n---\\n\\n\\ni=1 nums[i] = 0\\n***continousCount***=2\\n***subarray*** = 1+2 = 3\\nwith single 0 -> 2\\nwith 2 0\\'s -> 1\\n\\n---\\n\\ni=2 nums[i] = 0\\n***continousCount***=3\\n***subarray*** = 1+2+3= 6\\nwith 3 0\\'s = 1\\nwith 2 0\\'s -> 2\\nwith single 0 -> 3\\n\\n\\n---\\n\\ni=3 nums[i] = 2\\n***continousCount***= 0 (since the continuity broke by 2)\\n***subarray*** = still 6\\nwith single 0 -> 2\\nwith 2 0\\'s -> 1\\n\\n---\\n\\ni=4 nums[i] = 0\\n***continousCount***=1\\n***subarray*** = 6+1 = 7\\nwith single 0 -> 1\\n\\n---\\n\\ni=5 nums[i] = 0\\n***continousCount***=2\\n***subarray*** =  7+2\\nwith single 0 -> 2\\nwith 2 0\\'s -> 1\\n\\nAns = 9\\n---\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n) Since we are going through each element in the array once!\\n\\n\\nHope it is easy to understand.\\nLet me know if there is something unclear and i can fix it.\\n\\nOtherwise, please upvote if you like the solution, it would be encouraging.\\n\\n# Code\\n```\\nclass Solution {\\n    public long zeroFilledSubarray(int[] nums) {\\n        long continousCount=0;\\n        long subarrays =0;\\n        for(int i=0; i<nums.length; i++){\\n            if(nums[i]==0){\\n                continousCount++;\\n                subarrays+=continousCount;\\n            }else{\\n                continousCount=0;\\n            }\\n        }\\n        return subarrays;\\n    }\\n}\\n```\\n\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long zeroFilledSubarray(int[] nums) {\\n        long continousCount=0;\\n        long subarrays =0;\\n        for(int i=0; i<nums.length; i++){\\n            if(nums[i]==0){\\n                continousCount++;\\n                subarrays+=continousCount;\\n            }else{\\n                continousCount=0;\\n            }\\n        }\\n        return subarrays;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3325338,
                "title": "easiest-two-approaches-loop-using-in-python3",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def zeroFilledSubarray(self, nums: List[int]) -> int:\\n        # approach 1\\n        count,result=0,0\\n        for i in range(len(nums)):\\n            if nums[i]==0:\\n                count+=1\\n            else:\\n                count=0\\n            result=result+count\\n        return result\\n```\\n```\\nclass Solution:\\n    def zeroFilledSubarray(self, nums: List[int]) -> int:\\n        # approach 2\\n        n=len(nums)\\n        i=0\\n        ans=0\\n        while i<n:\\n            l=0\\n            if nums[i]==0:\\n                while i<n and nums[i]==0:\\n                    l+=1\\n                    i+=1\\n            else:\\n                i+=1\\n            ans+=int(((l)*(l+1))/2)\\n         return ans\\n        \\n      \\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def zeroFilledSubarray(self, nums: List[int]) -> int:\\n        # approach 1\\n        count,result=0,0\\n        for i in range(len(nums)):\\n            if nums[i]==0:\\n                count+=1\\n            else:\\n                count=0\\n            result=result+count\\n        return result\\n```\n```\\nclass Solution:\\n    def zeroFilledSubarray(self, nums: List[int]) -> int:\\n        # approach 2\\n        n=len(nums)\\n        i=0\\n        ans=0\\n        while i<n:\\n            l=0\\n            if nums[i]==0:\\n                while i<n and nums[i]==0:\\n                    l+=1\\n                    i+=1\\n            else:\\n                i+=1\\n            ans+=int(((l)*(l+1))/2)\\n         return ans\\n        \\n      \\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3325304,
                "title": "easy-understanding-begineer-friendly",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public long zeroFilledSubarray(int[] nums) {\\n        long result = 0;\\n\\n        long curCount = 0;\\n\\n        for(int i : nums){\\n            if(i == 0){\\n                curCount++;\\n            }\\n            else{\\n                curCount = 0;\\n            }\\n            result += curCount;\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public long zeroFilledSubarray(int[] nums) {\\n        long result = 0;\\n\\n        long curCount = 0;\\n\\n        for(int i : nums){\\n            if(i == 0){\\n                curCount++;\\n            }\\n            else{\\n                curCount = 0;\\n            }\\n            result += curCount;\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3325232,
                "title": "very-simple-easy-to-understand-c-code",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    long long zeroFilledSubarray(vector<int>& nums) {\\n        long long ans=0 , c=0;\\n        for(int i=0; i<nums.size(); i++){\\n            if(nums[i]==0)c++;\\n            else{\\n                ans+=(c*(c+1)/2);\\n                c=0;\\n            }\\n        }\\n        if(c!=0)ans+=(c*(c+1)/2);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long zeroFilledSubarray(vector<int>& nums) {\\n        long long ans=0 , c=0;\\n        for(int i=0; i<nums.size(); i++){\\n            if(nums[i]==0)c++;\\n            else{\\n                ans+=(c*(c+1)/2);\\n                c=0;\\n            }\\n        }\\n        if(c!=0)ans+=(c*(c+1)/2);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3325204,
                "title": "easy-and-simple-code",
                "content": "# Intuition\\nNumber of subArrays having zero count will be nC2.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n\\n- Space complexity:     O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long zeroFilledSubarray(vector<int>& nums) {\\n        long long ans  = 0 ;\\n        for(int i =0 ; i<nums.size(); i++){\\n           long long tempCount = 0; //Stores the count of zeroes \\n           while(i<nums.size() && nums[i] == 0){\\n               tempCount++;\\n               i++;\\n           }\\n           ans+=tempCount*(tempCount+1)/2;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long zeroFilledSubarray(vector<int>& nums) {\\n        long long ans  = 0 ;\\n        for(int i =0 ; i<nums.size(); i++){\\n           long long tempCount = 0; //Stores the count of zeroes \\n           while(i<nums.size() && nums[i] == 0){\\n               tempCount++;\\n               i++;\\n           }\\n           ans+=tempCount*(tempCount+1)/2;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1838936,
                "content": [
                    {
                        "username": "yogeshvaidya",
                        "content": "should be marked as easy."
                    },
                    {
                        "username": "tyl2018",
                        "content": "[@rahul1995](/rahul1995) Thank you"
                    },
                    {
                        "username": "rahul1995",
                        "content": "I hope everyone who is calling it easy are also doing \"More Actions (...) -> Feedback -> Difficulty is inaccurate\".\\nThe \"More Actions (...)\" button is next to \"Hint\" button."
                    },
                    {
                        "username": "oystermajor",
                        "content": "Imagine being so lucky to get this question at Google lol "
                    },
                    {
                        "username": "rahul1995",
                        "content": "Is Google-mania still not over after all these layoffs?? smh"
                    },
                    {
                        "username": "bhattanrag123",
                        "content": "I'm not reading the discussions again"
                    },
                    {
                        "username": "mint_",
                        "content": "I know right? \n\nI've done a solid number of subarray and permutation questions before and didn't find this problem that intuitive, while I found yesterday's problem pretty easy."
                    },
                    {
                        "username": "Flexiiiii",
                        "content": "[@namandt](/namandt) probably because everyone is saying how easy it is "
                    },
                    {
                        "username": "namandt",
                        "content": "why?\\n"
                    },
                    {
                        "username": "aitachii",
                        "content": "This one was easier compared to yesterday's \"Easy\".\n\nAnyway, here's some clarification for the examples. Excluded elements will be marked as -.\nExample 1: nums = [1,3,0,0,2,0,0,4]\nThere are 2 [0,0] subarrays, these are: \n[-,-,0,0,-,-,-,-], and \n[-,-,-,-,-,0,0,-]\nThere are 4 [0] subarrays:\n[-,-,0,-,-,-,-,-],\n[-,-,-,0,-,-,-,-],\n[-,-,-,-,-,0,-,-], and\n[-,-,-,-,-,-,0,-]\nFor a total of 6.\n\nExample 2: nums = [0,0,0,2,0,0]\nFor the [0,0,0,-,-,-]:\n[0,-,-,-,-,-], +1\n\n[0,0,-,-,-,-], +1\n[-,0,-,-,-,-], +1\n\n[0,0,0,-,-,-], +1\n[-,0,0,-,-,-], +1\n[-,-,0,-,-,-], +1\nFor a subtotal of 6.\n\nFor the [-,-,-,-,0,0]:\n[-,-,-,-,0,-] +1\n\n[-,-,-,-,0,0] +1\n[-,-,-,-,-,0] +1\nFor a subtotal of 3.\n\nIn total, that's 9 zero subarrays."
                    },
                    {
                        "username": "aitachii",
                        "content": "Here\\'s yesterday for reference: https://leetcode.com/problems/can-place-flowers/"
                    },
                    {
                        "username": "user7478F",
                        "content": "seriously."
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "It\\'s too easy? it makes me feel good today."
                    },
                    {
                        "username": "Vizxe",
                        "content": "me too, felt good!"
                    },
                    {
                        "username": "cswartzell",
                        "content": "There really ought to be  a Leetcode section on \"common math tricks\". Knowing things like permutations, combinations, recognizing the triangular numbers and formula can be more relevant than some of the more obscure DSA sections they have"
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "\\u2026 and fill that section with problems like this one, when using such tricks make solutions uglier )))"
                    },
                    {
                        "username": "aditibhagat23",
                        "content": "Remember to store the count of zeros in long to pass all the test cases"
                    },
                    {
                        "username": "19sk99",
                        "content": "thank you so much. Finally my code got accepted after seeing your comment."
                    },
                    {
                        "username": "ashishgulati2112",
                        "content": "That is the only thing that can make it a medium question, lol XD"
                    },
                    {
                        "username": "arajshow",
                        "content": "This is the best way to start your day."
                    },
                    {
                        "username": "santanusen",
                        "content": "# Tip 1:\nWe have a contiguous zero-filled subarray ```S``` of size ```n``` say.\nLet us calculate total how many distinct subarrays (of size k; 1<= k <= n) can be formed out of the subarray ```S```.\n\nLet's think of a sliding window of size ```k``` that slides from the start of the subarray ```S``` until the right edge of the window hits the end of ```S```. \n\n* When ```k = 1```, the start of the sliding window can be placed over each element of ```S```.\n```\n[1] 2  3  4\n 1 [2] 3  4\n 1  2 [3] 4\n 1  2  3 [4]\n```\nThus we have ```n``` distinct subarrays of size 1.\n\n* When ```k = 2``` , the start of the sliding window can be placed over each element of ```S``` except the last.\n```\n[1  2] 3  4\n 1 [2  3] 4\n 1  2 [3  4]\n```\nSo we have ```n - 1``` distinct subarrays of size 2.\n\nAnd so on.\n\nFinally,\n* When ```k = n```, the sliding window covers the entirety of ```S```.\n```\n[1  2   3  4]\n```\nWe have ```1``` subarray of size n.\n\nHence, the total number of distinct subarrays that can be formed out of ```S``` is:\n```\nn + (n - 1) + (n - 2) + ... + 1 =\n((n + 1) * n) / 2\n```\n# Tip 2:\nFor languages supporting different integer sizes beware, the answer may not fit into 32 bits for some test cases. Pay attention to the return type of the function."
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "[@sahle123](/sahle123) sum of natural number series \\n```(1+2+3+4+...n) = n*(n+1)/2 ```"
                    },
                    {
                        "username": "sahle123",
                        "content": "For your first tip, in the last step, how did you arrive to the formula ```((n + 1) * n) / 2```?"
                    },
                    {
                        "username": "AlecLC",
                        "content": "If I got this question in an interview I would have to mute so they wouldn\\'t hear me popping champagne \\uD83C\\uDF7E "
                    }
                ]
            },
            {
                "id": 1838915,
                "content": [
                    {
                        "username": "yogeshvaidya",
                        "content": "should be marked as easy."
                    },
                    {
                        "username": "tyl2018",
                        "content": "[@rahul1995](/rahul1995) Thank you"
                    },
                    {
                        "username": "rahul1995",
                        "content": "I hope everyone who is calling it easy are also doing \"More Actions (...) -> Feedback -> Difficulty is inaccurate\".\\nThe \"More Actions (...)\" button is next to \"Hint\" button."
                    },
                    {
                        "username": "oystermajor",
                        "content": "Imagine being so lucky to get this question at Google lol "
                    },
                    {
                        "username": "rahul1995",
                        "content": "Is Google-mania still not over after all these layoffs?? smh"
                    },
                    {
                        "username": "bhattanrag123",
                        "content": "I'm not reading the discussions again"
                    },
                    {
                        "username": "mint_",
                        "content": "I know right? \n\nI've done a solid number of subarray and permutation questions before and didn't find this problem that intuitive, while I found yesterday's problem pretty easy."
                    },
                    {
                        "username": "Flexiiiii",
                        "content": "[@namandt](/namandt) probably because everyone is saying how easy it is "
                    },
                    {
                        "username": "namandt",
                        "content": "why?\\n"
                    },
                    {
                        "username": "aitachii",
                        "content": "This one was easier compared to yesterday's \"Easy\".\n\nAnyway, here's some clarification for the examples. Excluded elements will be marked as -.\nExample 1: nums = [1,3,0,0,2,0,0,4]\nThere are 2 [0,0] subarrays, these are: \n[-,-,0,0,-,-,-,-], and \n[-,-,-,-,-,0,0,-]\nThere are 4 [0] subarrays:\n[-,-,0,-,-,-,-,-],\n[-,-,-,0,-,-,-,-],\n[-,-,-,-,-,0,-,-], and\n[-,-,-,-,-,-,0,-]\nFor a total of 6.\n\nExample 2: nums = [0,0,0,2,0,0]\nFor the [0,0,0,-,-,-]:\n[0,-,-,-,-,-], +1\n\n[0,0,-,-,-,-], +1\n[-,0,-,-,-,-], +1\n\n[0,0,0,-,-,-], +1\n[-,0,0,-,-,-], +1\n[-,-,0,-,-,-], +1\nFor a subtotal of 6.\n\nFor the [-,-,-,-,0,0]:\n[-,-,-,-,0,-] +1\n\n[-,-,-,-,0,0] +1\n[-,-,-,-,-,0] +1\nFor a subtotal of 3.\n\nIn total, that's 9 zero subarrays."
                    },
                    {
                        "username": "aitachii",
                        "content": "Here\\'s yesterday for reference: https://leetcode.com/problems/can-place-flowers/"
                    },
                    {
                        "username": "user7478F",
                        "content": "seriously."
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "It\\'s too easy? it makes me feel good today."
                    },
                    {
                        "username": "Vizxe",
                        "content": "me too, felt good!"
                    },
                    {
                        "username": "cswartzell",
                        "content": "There really ought to be  a Leetcode section on \"common math tricks\". Knowing things like permutations, combinations, recognizing the triangular numbers and formula can be more relevant than some of the more obscure DSA sections they have"
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "\\u2026 and fill that section with problems like this one, when using such tricks make solutions uglier )))"
                    },
                    {
                        "username": "aditibhagat23",
                        "content": "Remember to store the count of zeros in long to pass all the test cases"
                    },
                    {
                        "username": "19sk99",
                        "content": "thank you so much. Finally my code got accepted after seeing your comment."
                    },
                    {
                        "username": "ashishgulati2112",
                        "content": "That is the only thing that can make it a medium question, lol XD"
                    },
                    {
                        "username": "arajshow",
                        "content": "This is the best way to start your day."
                    },
                    {
                        "username": "santanusen",
                        "content": "# Tip 1:\nWe have a contiguous zero-filled subarray ```S``` of size ```n``` say.\nLet us calculate total how many distinct subarrays (of size k; 1<= k <= n) can be formed out of the subarray ```S```.\n\nLet's think of a sliding window of size ```k``` that slides from the start of the subarray ```S``` until the right edge of the window hits the end of ```S```. \n\n* When ```k = 1```, the start of the sliding window can be placed over each element of ```S```.\n```\n[1] 2  3  4\n 1 [2] 3  4\n 1  2 [3] 4\n 1  2  3 [4]\n```\nThus we have ```n``` distinct subarrays of size 1.\n\n* When ```k = 2``` , the start of the sliding window can be placed over each element of ```S``` except the last.\n```\n[1  2] 3  4\n 1 [2  3] 4\n 1  2 [3  4]\n```\nSo we have ```n - 1``` distinct subarrays of size 2.\n\nAnd so on.\n\nFinally,\n* When ```k = n```, the sliding window covers the entirety of ```S```.\n```\n[1  2   3  4]\n```\nWe have ```1``` subarray of size n.\n\nHence, the total number of distinct subarrays that can be formed out of ```S``` is:\n```\nn + (n - 1) + (n - 2) + ... + 1 =\n((n + 1) * n) / 2\n```\n# Tip 2:\nFor languages supporting different integer sizes beware, the answer may not fit into 32 bits for some test cases. Pay attention to the return type of the function."
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "[@sahle123](/sahle123) sum of natural number series \\n```(1+2+3+4+...n) = n*(n+1)/2 ```"
                    },
                    {
                        "username": "sahle123",
                        "content": "For your first tip, in the last step, how did you arrive to the formula ```((n + 1) * n) / 2```?"
                    },
                    {
                        "username": "AlecLC",
                        "content": "If I got this question in an interview I would have to mute so they wouldn\\'t hear me popping champagne \\uD83C\\uDF7E "
                    }
                ]
            },
            {
                "id": 1839124,
                "content": [
                    {
                        "username": "yogeshvaidya",
                        "content": "should be marked as easy."
                    },
                    {
                        "username": "tyl2018",
                        "content": "[@rahul1995](/rahul1995) Thank you"
                    },
                    {
                        "username": "rahul1995",
                        "content": "I hope everyone who is calling it easy are also doing \"More Actions (...) -> Feedback -> Difficulty is inaccurate\".\\nThe \"More Actions (...)\" button is next to \"Hint\" button."
                    },
                    {
                        "username": "oystermajor",
                        "content": "Imagine being so lucky to get this question at Google lol "
                    },
                    {
                        "username": "rahul1995",
                        "content": "Is Google-mania still not over after all these layoffs?? smh"
                    },
                    {
                        "username": "bhattanrag123",
                        "content": "I'm not reading the discussions again"
                    },
                    {
                        "username": "mint_",
                        "content": "I know right? \n\nI've done a solid number of subarray and permutation questions before and didn't find this problem that intuitive, while I found yesterday's problem pretty easy."
                    },
                    {
                        "username": "Flexiiiii",
                        "content": "[@namandt](/namandt) probably because everyone is saying how easy it is "
                    },
                    {
                        "username": "namandt",
                        "content": "why?\\n"
                    },
                    {
                        "username": "aitachii",
                        "content": "This one was easier compared to yesterday's \"Easy\".\n\nAnyway, here's some clarification for the examples. Excluded elements will be marked as -.\nExample 1: nums = [1,3,0,0,2,0,0,4]\nThere are 2 [0,0] subarrays, these are: \n[-,-,0,0,-,-,-,-], and \n[-,-,-,-,-,0,0,-]\nThere are 4 [0] subarrays:\n[-,-,0,-,-,-,-,-],\n[-,-,-,0,-,-,-,-],\n[-,-,-,-,-,0,-,-], and\n[-,-,-,-,-,-,0,-]\nFor a total of 6.\n\nExample 2: nums = [0,0,0,2,0,0]\nFor the [0,0,0,-,-,-]:\n[0,-,-,-,-,-], +1\n\n[0,0,-,-,-,-], +1\n[-,0,-,-,-,-], +1\n\n[0,0,0,-,-,-], +1\n[-,0,0,-,-,-], +1\n[-,-,0,-,-,-], +1\nFor a subtotal of 6.\n\nFor the [-,-,-,-,0,0]:\n[-,-,-,-,0,-] +1\n\n[-,-,-,-,0,0] +1\n[-,-,-,-,-,0] +1\nFor a subtotal of 3.\n\nIn total, that's 9 zero subarrays."
                    },
                    {
                        "username": "aitachii",
                        "content": "Here\\'s yesterday for reference: https://leetcode.com/problems/can-place-flowers/"
                    },
                    {
                        "username": "user7478F",
                        "content": "seriously."
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "It\\'s too easy? it makes me feel good today."
                    },
                    {
                        "username": "Vizxe",
                        "content": "me too, felt good!"
                    },
                    {
                        "username": "cswartzell",
                        "content": "There really ought to be  a Leetcode section on \"common math tricks\". Knowing things like permutations, combinations, recognizing the triangular numbers and formula can be more relevant than some of the more obscure DSA sections they have"
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "\\u2026 and fill that section with problems like this one, when using such tricks make solutions uglier )))"
                    },
                    {
                        "username": "aditibhagat23",
                        "content": "Remember to store the count of zeros in long to pass all the test cases"
                    },
                    {
                        "username": "19sk99",
                        "content": "thank you so much. Finally my code got accepted after seeing your comment."
                    },
                    {
                        "username": "ashishgulati2112",
                        "content": "That is the only thing that can make it a medium question, lol XD"
                    },
                    {
                        "username": "arajshow",
                        "content": "This is the best way to start your day."
                    },
                    {
                        "username": "santanusen",
                        "content": "# Tip 1:\nWe have a contiguous zero-filled subarray ```S``` of size ```n``` say.\nLet us calculate total how many distinct subarrays (of size k; 1<= k <= n) can be formed out of the subarray ```S```.\n\nLet's think of a sliding window of size ```k``` that slides from the start of the subarray ```S``` until the right edge of the window hits the end of ```S```. \n\n* When ```k = 1```, the start of the sliding window can be placed over each element of ```S```.\n```\n[1] 2  3  4\n 1 [2] 3  4\n 1  2 [3] 4\n 1  2  3 [4]\n```\nThus we have ```n``` distinct subarrays of size 1.\n\n* When ```k = 2``` , the start of the sliding window can be placed over each element of ```S``` except the last.\n```\n[1  2] 3  4\n 1 [2  3] 4\n 1  2 [3  4]\n```\nSo we have ```n - 1``` distinct subarrays of size 2.\n\nAnd so on.\n\nFinally,\n* When ```k = n```, the sliding window covers the entirety of ```S```.\n```\n[1  2   3  4]\n```\nWe have ```1``` subarray of size n.\n\nHence, the total number of distinct subarrays that can be formed out of ```S``` is:\n```\nn + (n - 1) + (n - 2) + ... + 1 =\n((n + 1) * n) / 2\n```\n# Tip 2:\nFor languages supporting different integer sizes beware, the answer may not fit into 32 bits for some test cases. Pay attention to the return type of the function."
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "[@sahle123](/sahle123) sum of natural number series \\n```(1+2+3+4+...n) = n*(n+1)/2 ```"
                    },
                    {
                        "username": "sahle123",
                        "content": "For your first tip, in the last step, how did you arrive to the formula ```((n + 1) * n) / 2```?"
                    },
                    {
                        "username": "AlecLC",
                        "content": "If I got this question in an interview I would have to mute so they wouldn\\'t hear me popping champagne \\uD83C\\uDF7E "
                    }
                ]
            },
            {
                "id": 1838933,
                "content": [
                    {
                        "username": "yogeshvaidya",
                        "content": "should be marked as easy."
                    },
                    {
                        "username": "tyl2018",
                        "content": "[@rahul1995](/rahul1995) Thank you"
                    },
                    {
                        "username": "rahul1995",
                        "content": "I hope everyone who is calling it easy are also doing \"More Actions (...) -> Feedback -> Difficulty is inaccurate\".\\nThe \"More Actions (...)\" button is next to \"Hint\" button."
                    },
                    {
                        "username": "oystermajor",
                        "content": "Imagine being so lucky to get this question at Google lol "
                    },
                    {
                        "username": "rahul1995",
                        "content": "Is Google-mania still not over after all these layoffs?? smh"
                    },
                    {
                        "username": "bhattanrag123",
                        "content": "I'm not reading the discussions again"
                    },
                    {
                        "username": "mint_",
                        "content": "I know right? \n\nI've done a solid number of subarray and permutation questions before and didn't find this problem that intuitive, while I found yesterday's problem pretty easy."
                    },
                    {
                        "username": "Flexiiiii",
                        "content": "[@namandt](/namandt) probably because everyone is saying how easy it is "
                    },
                    {
                        "username": "namandt",
                        "content": "why?\\n"
                    },
                    {
                        "username": "aitachii",
                        "content": "This one was easier compared to yesterday's \"Easy\".\n\nAnyway, here's some clarification for the examples. Excluded elements will be marked as -.\nExample 1: nums = [1,3,0,0,2,0,0,4]\nThere are 2 [0,0] subarrays, these are: \n[-,-,0,0,-,-,-,-], and \n[-,-,-,-,-,0,0,-]\nThere are 4 [0] subarrays:\n[-,-,0,-,-,-,-,-],\n[-,-,-,0,-,-,-,-],\n[-,-,-,-,-,0,-,-], and\n[-,-,-,-,-,-,0,-]\nFor a total of 6.\n\nExample 2: nums = [0,0,0,2,0,0]\nFor the [0,0,0,-,-,-]:\n[0,-,-,-,-,-], +1\n\n[0,0,-,-,-,-], +1\n[-,0,-,-,-,-], +1\n\n[0,0,0,-,-,-], +1\n[-,0,0,-,-,-], +1\n[-,-,0,-,-,-], +1\nFor a subtotal of 6.\n\nFor the [-,-,-,-,0,0]:\n[-,-,-,-,0,-] +1\n\n[-,-,-,-,0,0] +1\n[-,-,-,-,-,0] +1\nFor a subtotal of 3.\n\nIn total, that's 9 zero subarrays."
                    },
                    {
                        "username": "aitachii",
                        "content": "Here\\'s yesterday for reference: https://leetcode.com/problems/can-place-flowers/"
                    },
                    {
                        "username": "user7478F",
                        "content": "seriously."
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "It\\'s too easy? it makes me feel good today."
                    },
                    {
                        "username": "Vizxe",
                        "content": "me too, felt good!"
                    },
                    {
                        "username": "cswartzell",
                        "content": "There really ought to be  a Leetcode section on \"common math tricks\". Knowing things like permutations, combinations, recognizing the triangular numbers and formula can be more relevant than some of the more obscure DSA sections they have"
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "\\u2026 and fill that section with problems like this one, when using such tricks make solutions uglier )))"
                    },
                    {
                        "username": "aditibhagat23",
                        "content": "Remember to store the count of zeros in long to pass all the test cases"
                    },
                    {
                        "username": "19sk99",
                        "content": "thank you so much. Finally my code got accepted after seeing your comment."
                    },
                    {
                        "username": "ashishgulati2112",
                        "content": "That is the only thing that can make it a medium question, lol XD"
                    },
                    {
                        "username": "arajshow",
                        "content": "This is the best way to start your day."
                    },
                    {
                        "username": "santanusen",
                        "content": "# Tip 1:\nWe have a contiguous zero-filled subarray ```S``` of size ```n``` say.\nLet us calculate total how many distinct subarrays (of size k; 1<= k <= n) can be formed out of the subarray ```S```.\n\nLet's think of a sliding window of size ```k``` that slides from the start of the subarray ```S``` until the right edge of the window hits the end of ```S```. \n\n* When ```k = 1```, the start of the sliding window can be placed over each element of ```S```.\n```\n[1] 2  3  4\n 1 [2] 3  4\n 1  2 [3] 4\n 1  2  3 [4]\n```\nThus we have ```n``` distinct subarrays of size 1.\n\n* When ```k = 2``` , the start of the sliding window can be placed over each element of ```S``` except the last.\n```\n[1  2] 3  4\n 1 [2  3] 4\n 1  2 [3  4]\n```\nSo we have ```n - 1``` distinct subarrays of size 2.\n\nAnd so on.\n\nFinally,\n* When ```k = n```, the sliding window covers the entirety of ```S```.\n```\n[1  2   3  4]\n```\nWe have ```1``` subarray of size n.\n\nHence, the total number of distinct subarrays that can be formed out of ```S``` is:\n```\nn + (n - 1) + (n - 2) + ... + 1 =\n((n + 1) * n) / 2\n```\n# Tip 2:\nFor languages supporting different integer sizes beware, the answer may not fit into 32 bits for some test cases. Pay attention to the return type of the function."
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "[@sahle123](/sahle123) sum of natural number series \\n```(1+2+3+4+...n) = n*(n+1)/2 ```"
                    },
                    {
                        "username": "sahle123",
                        "content": "For your first tip, in the last step, how did you arrive to the formula ```((n + 1) * n) / 2```?"
                    },
                    {
                        "username": "AlecLC",
                        "content": "If I got this question in an interview I would have to mute so they wouldn\\'t hear me popping champagne \\uD83C\\uDF7E "
                    }
                ]
            },
            {
                "id": 1838943,
                "content": [
                    {
                        "username": "yogeshvaidya",
                        "content": "should be marked as easy."
                    },
                    {
                        "username": "tyl2018",
                        "content": "[@rahul1995](/rahul1995) Thank you"
                    },
                    {
                        "username": "rahul1995",
                        "content": "I hope everyone who is calling it easy are also doing \"More Actions (...) -> Feedback -> Difficulty is inaccurate\".\\nThe \"More Actions (...)\" button is next to \"Hint\" button."
                    },
                    {
                        "username": "oystermajor",
                        "content": "Imagine being so lucky to get this question at Google lol "
                    },
                    {
                        "username": "rahul1995",
                        "content": "Is Google-mania still not over after all these layoffs?? smh"
                    },
                    {
                        "username": "bhattanrag123",
                        "content": "I'm not reading the discussions again"
                    },
                    {
                        "username": "mint_",
                        "content": "I know right? \n\nI've done a solid number of subarray and permutation questions before and didn't find this problem that intuitive, while I found yesterday's problem pretty easy."
                    },
                    {
                        "username": "Flexiiiii",
                        "content": "[@namandt](/namandt) probably because everyone is saying how easy it is "
                    },
                    {
                        "username": "namandt",
                        "content": "why?\\n"
                    },
                    {
                        "username": "aitachii",
                        "content": "This one was easier compared to yesterday's \"Easy\".\n\nAnyway, here's some clarification for the examples. Excluded elements will be marked as -.\nExample 1: nums = [1,3,0,0,2,0,0,4]\nThere are 2 [0,0] subarrays, these are: \n[-,-,0,0,-,-,-,-], and \n[-,-,-,-,-,0,0,-]\nThere are 4 [0] subarrays:\n[-,-,0,-,-,-,-,-],\n[-,-,-,0,-,-,-,-],\n[-,-,-,-,-,0,-,-], and\n[-,-,-,-,-,-,0,-]\nFor a total of 6.\n\nExample 2: nums = [0,0,0,2,0,0]\nFor the [0,0,0,-,-,-]:\n[0,-,-,-,-,-], +1\n\n[0,0,-,-,-,-], +1\n[-,0,-,-,-,-], +1\n\n[0,0,0,-,-,-], +1\n[-,0,0,-,-,-], +1\n[-,-,0,-,-,-], +1\nFor a subtotal of 6.\n\nFor the [-,-,-,-,0,0]:\n[-,-,-,-,0,-] +1\n\n[-,-,-,-,0,0] +1\n[-,-,-,-,-,0] +1\nFor a subtotal of 3.\n\nIn total, that's 9 zero subarrays."
                    },
                    {
                        "username": "aitachii",
                        "content": "Here\\'s yesterday for reference: https://leetcode.com/problems/can-place-flowers/"
                    },
                    {
                        "username": "user7478F",
                        "content": "seriously."
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "It\\'s too easy? it makes me feel good today."
                    },
                    {
                        "username": "Vizxe",
                        "content": "me too, felt good!"
                    },
                    {
                        "username": "cswartzell",
                        "content": "There really ought to be  a Leetcode section on \"common math tricks\". Knowing things like permutations, combinations, recognizing the triangular numbers and formula can be more relevant than some of the more obscure DSA sections they have"
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "\\u2026 and fill that section with problems like this one, when using such tricks make solutions uglier )))"
                    },
                    {
                        "username": "aditibhagat23",
                        "content": "Remember to store the count of zeros in long to pass all the test cases"
                    },
                    {
                        "username": "19sk99",
                        "content": "thank you so much. Finally my code got accepted after seeing your comment."
                    },
                    {
                        "username": "ashishgulati2112",
                        "content": "That is the only thing that can make it a medium question, lol XD"
                    },
                    {
                        "username": "arajshow",
                        "content": "This is the best way to start your day."
                    },
                    {
                        "username": "santanusen",
                        "content": "# Tip 1:\nWe have a contiguous zero-filled subarray ```S``` of size ```n``` say.\nLet us calculate total how many distinct subarrays (of size k; 1<= k <= n) can be formed out of the subarray ```S```.\n\nLet's think of a sliding window of size ```k``` that slides from the start of the subarray ```S``` until the right edge of the window hits the end of ```S```. \n\n* When ```k = 1```, the start of the sliding window can be placed over each element of ```S```.\n```\n[1] 2  3  4\n 1 [2] 3  4\n 1  2 [3] 4\n 1  2  3 [4]\n```\nThus we have ```n``` distinct subarrays of size 1.\n\n* When ```k = 2``` , the start of the sliding window can be placed over each element of ```S``` except the last.\n```\n[1  2] 3  4\n 1 [2  3] 4\n 1  2 [3  4]\n```\nSo we have ```n - 1``` distinct subarrays of size 2.\n\nAnd so on.\n\nFinally,\n* When ```k = n```, the sliding window covers the entirety of ```S```.\n```\n[1  2   3  4]\n```\nWe have ```1``` subarray of size n.\n\nHence, the total number of distinct subarrays that can be formed out of ```S``` is:\n```\nn + (n - 1) + (n - 2) + ... + 1 =\n((n + 1) * n) / 2\n```\n# Tip 2:\nFor languages supporting different integer sizes beware, the answer may not fit into 32 bits for some test cases. Pay attention to the return type of the function."
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "[@sahle123](/sahle123) sum of natural number series \\n```(1+2+3+4+...n) = n*(n+1)/2 ```"
                    },
                    {
                        "username": "sahle123",
                        "content": "For your first tip, in the last step, how did you arrive to the formula ```((n + 1) * n) / 2```?"
                    },
                    {
                        "username": "AlecLC",
                        "content": "If I got this question in an interview I would have to mute so they wouldn\\'t hear me popping champagne \\uD83C\\uDF7E "
                    }
                ]
            },
            {
                "id": 1838940,
                "content": [
                    {
                        "username": "yogeshvaidya",
                        "content": "should be marked as easy."
                    },
                    {
                        "username": "tyl2018",
                        "content": "[@rahul1995](/rahul1995) Thank you"
                    },
                    {
                        "username": "rahul1995",
                        "content": "I hope everyone who is calling it easy are also doing \"More Actions (...) -> Feedback -> Difficulty is inaccurate\".\\nThe \"More Actions (...)\" button is next to \"Hint\" button."
                    },
                    {
                        "username": "oystermajor",
                        "content": "Imagine being so lucky to get this question at Google lol "
                    },
                    {
                        "username": "rahul1995",
                        "content": "Is Google-mania still not over after all these layoffs?? smh"
                    },
                    {
                        "username": "bhattanrag123",
                        "content": "I'm not reading the discussions again"
                    },
                    {
                        "username": "mint_",
                        "content": "I know right? \n\nI've done a solid number of subarray and permutation questions before and didn't find this problem that intuitive, while I found yesterday's problem pretty easy."
                    },
                    {
                        "username": "Flexiiiii",
                        "content": "[@namandt](/namandt) probably because everyone is saying how easy it is "
                    },
                    {
                        "username": "namandt",
                        "content": "why?\\n"
                    },
                    {
                        "username": "aitachii",
                        "content": "This one was easier compared to yesterday's \"Easy\".\n\nAnyway, here's some clarification for the examples. Excluded elements will be marked as -.\nExample 1: nums = [1,3,0,0,2,0,0,4]\nThere are 2 [0,0] subarrays, these are: \n[-,-,0,0,-,-,-,-], and \n[-,-,-,-,-,0,0,-]\nThere are 4 [0] subarrays:\n[-,-,0,-,-,-,-,-],\n[-,-,-,0,-,-,-,-],\n[-,-,-,-,-,0,-,-], and\n[-,-,-,-,-,-,0,-]\nFor a total of 6.\n\nExample 2: nums = [0,0,0,2,0,0]\nFor the [0,0,0,-,-,-]:\n[0,-,-,-,-,-], +1\n\n[0,0,-,-,-,-], +1\n[-,0,-,-,-,-], +1\n\n[0,0,0,-,-,-], +1\n[-,0,0,-,-,-], +1\n[-,-,0,-,-,-], +1\nFor a subtotal of 6.\n\nFor the [-,-,-,-,0,0]:\n[-,-,-,-,0,-] +1\n\n[-,-,-,-,0,0] +1\n[-,-,-,-,-,0] +1\nFor a subtotal of 3.\n\nIn total, that's 9 zero subarrays."
                    },
                    {
                        "username": "aitachii",
                        "content": "Here\\'s yesterday for reference: https://leetcode.com/problems/can-place-flowers/"
                    },
                    {
                        "username": "user7478F",
                        "content": "seriously."
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "It\\'s too easy? it makes me feel good today."
                    },
                    {
                        "username": "Vizxe",
                        "content": "me too, felt good!"
                    },
                    {
                        "username": "cswartzell",
                        "content": "There really ought to be  a Leetcode section on \"common math tricks\". Knowing things like permutations, combinations, recognizing the triangular numbers and formula can be more relevant than some of the more obscure DSA sections they have"
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "\\u2026 and fill that section with problems like this one, when using such tricks make solutions uglier )))"
                    },
                    {
                        "username": "aditibhagat23",
                        "content": "Remember to store the count of zeros in long to pass all the test cases"
                    },
                    {
                        "username": "19sk99",
                        "content": "thank you so much. Finally my code got accepted after seeing your comment."
                    },
                    {
                        "username": "ashishgulati2112",
                        "content": "That is the only thing that can make it a medium question, lol XD"
                    },
                    {
                        "username": "arajshow",
                        "content": "This is the best way to start your day."
                    },
                    {
                        "username": "santanusen",
                        "content": "# Tip 1:\nWe have a contiguous zero-filled subarray ```S``` of size ```n``` say.\nLet us calculate total how many distinct subarrays (of size k; 1<= k <= n) can be formed out of the subarray ```S```.\n\nLet's think of a sliding window of size ```k``` that slides from the start of the subarray ```S``` until the right edge of the window hits the end of ```S```. \n\n* When ```k = 1```, the start of the sliding window can be placed over each element of ```S```.\n```\n[1] 2  3  4\n 1 [2] 3  4\n 1  2 [3] 4\n 1  2  3 [4]\n```\nThus we have ```n``` distinct subarrays of size 1.\n\n* When ```k = 2``` , the start of the sliding window can be placed over each element of ```S``` except the last.\n```\n[1  2] 3  4\n 1 [2  3] 4\n 1  2 [3  4]\n```\nSo we have ```n - 1``` distinct subarrays of size 2.\n\nAnd so on.\n\nFinally,\n* When ```k = n```, the sliding window covers the entirety of ```S```.\n```\n[1  2   3  4]\n```\nWe have ```1``` subarray of size n.\n\nHence, the total number of distinct subarrays that can be formed out of ```S``` is:\n```\nn + (n - 1) + (n - 2) + ... + 1 =\n((n + 1) * n) / 2\n```\n# Tip 2:\nFor languages supporting different integer sizes beware, the answer may not fit into 32 bits for some test cases. Pay attention to the return type of the function."
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "[@sahle123](/sahle123) sum of natural number series \\n```(1+2+3+4+...n) = n*(n+1)/2 ```"
                    },
                    {
                        "username": "sahle123",
                        "content": "For your first tip, in the last step, how did you arrive to the formula ```((n + 1) * n) / 2```?"
                    },
                    {
                        "username": "AlecLC",
                        "content": "If I got this question in an interview I would have to mute so they wouldn\\'t hear me popping champagne \\uD83C\\uDF7E "
                    }
                ]
            },
            {
                "id": 1808514,
                "content": [
                    {
                        "username": "yogeshvaidya",
                        "content": "should be marked as easy."
                    },
                    {
                        "username": "tyl2018",
                        "content": "[@rahul1995](/rahul1995) Thank you"
                    },
                    {
                        "username": "rahul1995",
                        "content": "I hope everyone who is calling it easy are also doing \"More Actions (...) -> Feedback -> Difficulty is inaccurate\".\\nThe \"More Actions (...)\" button is next to \"Hint\" button."
                    },
                    {
                        "username": "oystermajor",
                        "content": "Imagine being so lucky to get this question at Google lol "
                    },
                    {
                        "username": "rahul1995",
                        "content": "Is Google-mania still not over after all these layoffs?? smh"
                    },
                    {
                        "username": "bhattanrag123",
                        "content": "I'm not reading the discussions again"
                    },
                    {
                        "username": "mint_",
                        "content": "I know right? \n\nI've done a solid number of subarray and permutation questions before and didn't find this problem that intuitive, while I found yesterday's problem pretty easy."
                    },
                    {
                        "username": "Flexiiiii",
                        "content": "[@namandt](/namandt) probably because everyone is saying how easy it is "
                    },
                    {
                        "username": "namandt",
                        "content": "why?\\n"
                    },
                    {
                        "username": "aitachii",
                        "content": "This one was easier compared to yesterday's \"Easy\".\n\nAnyway, here's some clarification for the examples. Excluded elements will be marked as -.\nExample 1: nums = [1,3,0,0,2,0,0,4]\nThere are 2 [0,0] subarrays, these are: \n[-,-,0,0,-,-,-,-], and \n[-,-,-,-,-,0,0,-]\nThere are 4 [0] subarrays:\n[-,-,0,-,-,-,-,-],\n[-,-,-,0,-,-,-,-],\n[-,-,-,-,-,0,-,-], and\n[-,-,-,-,-,-,0,-]\nFor a total of 6.\n\nExample 2: nums = [0,0,0,2,0,0]\nFor the [0,0,0,-,-,-]:\n[0,-,-,-,-,-], +1\n\n[0,0,-,-,-,-], +1\n[-,0,-,-,-,-], +1\n\n[0,0,0,-,-,-], +1\n[-,0,0,-,-,-], +1\n[-,-,0,-,-,-], +1\nFor a subtotal of 6.\n\nFor the [-,-,-,-,0,0]:\n[-,-,-,-,0,-] +1\n\n[-,-,-,-,0,0] +1\n[-,-,-,-,-,0] +1\nFor a subtotal of 3.\n\nIn total, that's 9 zero subarrays."
                    },
                    {
                        "username": "aitachii",
                        "content": "Here\\'s yesterday for reference: https://leetcode.com/problems/can-place-flowers/"
                    },
                    {
                        "username": "user7478F",
                        "content": "seriously."
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "It\\'s too easy? it makes me feel good today."
                    },
                    {
                        "username": "Vizxe",
                        "content": "me too, felt good!"
                    },
                    {
                        "username": "cswartzell",
                        "content": "There really ought to be  a Leetcode section on \"common math tricks\". Knowing things like permutations, combinations, recognizing the triangular numbers and formula can be more relevant than some of the more obscure DSA sections they have"
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "\\u2026 and fill that section with problems like this one, when using such tricks make solutions uglier )))"
                    },
                    {
                        "username": "aditibhagat23",
                        "content": "Remember to store the count of zeros in long to pass all the test cases"
                    },
                    {
                        "username": "19sk99",
                        "content": "thank you so much. Finally my code got accepted after seeing your comment."
                    },
                    {
                        "username": "ashishgulati2112",
                        "content": "That is the only thing that can make it a medium question, lol XD"
                    },
                    {
                        "username": "arajshow",
                        "content": "This is the best way to start your day."
                    },
                    {
                        "username": "santanusen",
                        "content": "# Tip 1:\nWe have a contiguous zero-filled subarray ```S``` of size ```n``` say.\nLet us calculate total how many distinct subarrays (of size k; 1<= k <= n) can be formed out of the subarray ```S```.\n\nLet's think of a sliding window of size ```k``` that slides from the start of the subarray ```S``` until the right edge of the window hits the end of ```S```. \n\n* When ```k = 1```, the start of the sliding window can be placed over each element of ```S```.\n```\n[1] 2  3  4\n 1 [2] 3  4\n 1  2 [3] 4\n 1  2  3 [4]\n```\nThus we have ```n``` distinct subarrays of size 1.\n\n* When ```k = 2``` , the start of the sliding window can be placed over each element of ```S``` except the last.\n```\n[1  2] 3  4\n 1 [2  3] 4\n 1  2 [3  4]\n```\nSo we have ```n - 1``` distinct subarrays of size 2.\n\nAnd so on.\n\nFinally,\n* When ```k = n```, the sliding window covers the entirety of ```S```.\n```\n[1  2   3  4]\n```\nWe have ```1``` subarray of size n.\n\nHence, the total number of distinct subarrays that can be formed out of ```S``` is:\n```\nn + (n - 1) + (n - 2) + ... + 1 =\n((n + 1) * n) / 2\n```\n# Tip 2:\nFor languages supporting different integer sizes beware, the answer may not fit into 32 bits for some test cases. Pay attention to the return type of the function."
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "[@sahle123](/sahle123) sum of natural number series \\n```(1+2+3+4+...n) = n*(n+1)/2 ```"
                    },
                    {
                        "username": "sahle123",
                        "content": "For your first tip, in the last step, how did you arrive to the formula ```((n + 1) * n) / 2```?"
                    },
                    {
                        "username": "AlecLC",
                        "content": "If I got this question in an interview I would have to mute so they wouldn\\'t hear me popping champagne \\uD83C\\uDF7E "
                    }
                ]
            },
            {
                "id": 1838932,
                "content": [
                    {
                        "username": "yogeshvaidya",
                        "content": "should be marked as easy."
                    },
                    {
                        "username": "tyl2018",
                        "content": "[@rahul1995](/rahul1995) Thank you"
                    },
                    {
                        "username": "rahul1995",
                        "content": "I hope everyone who is calling it easy are also doing \"More Actions (...) -> Feedback -> Difficulty is inaccurate\".\\nThe \"More Actions (...)\" button is next to \"Hint\" button."
                    },
                    {
                        "username": "oystermajor",
                        "content": "Imagine being so lucky to get this question at Google lol "
                    },
                    {
                        "username": "rahul1995",
                        "content": "Is Google-mania still not over after all these layoffs?? smh"
                    },
                    {
                        "username": "bhattanrag123",
                        "content": "I'm not reading the discussions again"
                    },
                    {
                        "username": "mint_",
                        "content": "I know right? \n\nI've done a solid number of subarray and permutation questions before and didn't find this problem that intuitive, while I found yesterday's problem pretty easy."
                    },
                    {
                        "username": "Flexiiiii",
                        "content": "[@namandt](/namandt) probably because everyone is saying how easy it is "
                    },
                    {
                        "username": "namandt",
                        "content": "why?\\n"
                    },
                    {
                        "username": "aitachii",
                        "content": "This one was easier compared to yesterday's \"Easy\".\n\nAnyway, here's some clarification for the examples. Excluded elements will be marked as -.\nExample 1: nums = [1,3,0,0,2,0,0,4]\nThere are 2 [0,0] subarrays, these are: \n[-,-,0,0,-,-,-,-], and \n[-,-,-,-,-,0,0,-]\nThere are 4 [0] subarrays:\n[-,-,0,-,-,-,-,-],\n[-,-,-,0,-,-,-,-],\n[-,-,-,-,-,0,-,-], and\n[-,-,-,-,-,-,0,-]\nFor a total of 6.\n\nExample 2: nums = [0,0,0,2,0,0]\nFor the [0,0,0,-,-,-]:\n[0,-,-,-,-,-], +1\n\n[0,0,-,-,-,-], +1\n[-,0,-,-,-,-], +1\n\n[0,0,0,-,-,-], +1\n[-,0,0,-,-,-], +1\n[-,-,0,-,-,-], +1\nFor a subtotal of 6.\n\nFor the [-,-,-,-,0,0]:\n[-,-,-,-,0,-] +1\n\n[-,-,-,-,0,0] +1\n[-,-,-,-,-,0] +1\nFor a subtotal of 3.\n\nIn total, that's 9 zero subarrays."
                    },
                    {
                        "username": "aitachii",
                        "content": "Here\\'s yesterday for reference: https://leetcode.com/problems/can-place-flowers/"
                    },
                    {
                        "username": "user7478F",
                        "content": "seriously."
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "It\\'s too easy? it makes me feel good today."
                    },
                    {
                        "username": "Vizxe",
                        "content": "me too, felt good!"
                    },
                    {
                        "username": "cswartzell",
                        "content": "There really ought to be  a Leetcode section on \"common math tricks\". Knowing things like permutations, combinations, recognizing the triangular numbers and formula can be more relevant than some of the more obscure DSA sections they have"
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "\\u2026 and fill that section with problems like this one, when using such tricks make solutions uglier )))"
                    },
                    {
                        "username": "aditibhagat23",
                        "content": "Remember to store the count of zeros in long to pass all the test cases"
                    },
                    {
                        "username": "19sk99",
                        "content": "thank you so much. Finally my code got accepted after seeing your comment."
                    },
                    {
                        "username": "ashishgulati2112",
                        "content": "That is the only thing that can make it a medium question, lol XD"
                    },
                    {
                        "username": "arajshow",
                        "content": "This is the best way to start your day."
                    },
                    {
                        "username": "santanusen",
                        "content": "# Tip 1:\nWe have a contiguous zero-filled subarray ```S``` of size ```n``` say.\nLet us calculate total how many distinct subarrays (of size k; 1<= k <= n) can be formed out of the subarray ```S```.\n\nLet's think of a sliding window of size ```k``` that slides from the start of the subarray ```S``` until the right edge of the window hits the end of ```S```. \n\n* When ```k = 1```, the start of the sliding window can be placed over each element of ```S```.\n```\n[1] 2  3  4\n 1 [2] 3  4\n 1  2 [3] 4\n 1  2  3 [4]\n```\nThus we have ```n``` distinct subarrays of size 1.\n\n* When ```k = 2``` , the start of the sliding window can be placed over each element of ```S``` except the last.\n```\n[1  2] 3  4\n 1 [2  3] 4\n 1  2 [3  4]\n```\nSo we have ```n - 1``` distinct subarrays of size 2.\n\nAnd so on.\n\nFinally,\n* When ```k = n```, the sliding window covers the entirety of ```S```.\n```\n[1  2   3  4]\n```\nWe have ```1``` subarray of size n.\n\nHence, the total number of distinct subarrays that can be formed out of ```S``` is:\n```\nn + (n - 1) + (n - 2) + ... + 1 =\n((n + 1) * n) / 2\n```\n# Tip 2:\nFor languages supporting different integer sizes beware, the answer may not fit into 32 bits for some test cases. Pay attention to the return type of the function."
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "[@sahle123](/sahle123) sum of natural number series \\n```(1+2+3+4+...n) = n*(n+1)/2 ```"
                    },
                    {
                        "username": "sahle123",
                        "content": "For your first tip, in the last step, how did you arrive to the formula ```((n + 1) * n) / 2```?"
                    },
                    {
                        "username": "AlecLC",
                        "content": "If I got this question in an interview I would have to mute so they wouldn\\'t hear me popping champagne \\uD83C\\uDF7E "
                    }
                ]
            },
            {
                "id": 1839242,
                "content": [
                    {
                        "username": "yogeshvaidya",
                        "content": "should be marked as easy."
                    },
                    {
                        "username": "tyl2018",
                        "content": "[@rahul1995](/rahul1995) Thank you"
                    },
                    {
                        "username": "rahul1995",
                        "content": "I hope everyone who is calling it easy are also doing \"More Actions (...) -> Feedback -> Difficulty is inaccurate\".\\nThe \"More Actions (...)\" button is next to \"Hint\" button."
                    },
                    {
                        "username": "oystermajor",
                        "content": "Imagine being so lucky to get this question at Google lol "
                    },
                    {
                        "username": "rahul1995",
                        "content": "Is Google-mania still not over after all these layoffs?? smh"
                    },
                    {
                        "username": "bhattanrag123",
                        "content": "I'm not reading the discussions again"
                    },
                    {
                        "username": "mint_",
                        "content": "I know right? \n\nI've done a solid number of subarray and permutation questions before and didn't find this problem that intuitive, while I found yesterday's problem pretty easy."
                    },
                    {
                        "username": "Flexiiiii",
                        "content": "[@namandt](/namandt) probably because everyone is saying how easy it is "
                    },
                    {
                        "username": "namandt",
                        "content": "why?\\n"
                    },
                    {
                        "username": "aitachii",
                        "content": "This one was easier compared to yesterday's \"Easy\".\n\nAnyway, here's some clarification for the examples. Excluded elements will be marked as -.\nExample 1: nums = [1,3,0,0,2,0,0,4]\nThere are 2 [0,0] subarrays, these are: \n[-,-,0,0,-,-,-,-], and \n[-,-,-,-,-,0,0,-]\nThere are 4 [0] subarrays:\n[-,-,0,-,-,-,-,-],\n[-,-,-,0,-,-,-,-],\n[-,-,-,-,-,0,-,-], and\n[-,-,-,-,-,-,0,-]\nFor a total of 6.\n\nExample 2: nums = [0,0,0,2,0,0]\nFor the [0,0,0,-,-,-]:\n[0,-,-,-,-,-], +1\n\n[0,0,-,-,-,-], +1\n[-,0,-,-,-,-], +1\n\n[0,0,0,-,-,-], +1\n[-,0,0,-,-,-], +1\n[-,-,0,-,-,-], +1\nFor a subtotal of 6.\n\nFor the [-,-,-,-,0,0]:\n[-,-,-,-,0,-] +1\n\n[-,-,-,-,0,0] +1\n[-,-,-,-,-,0] +1\nFor a subtotal of 3.\n\nIn total, that's 9 zero subarrays."
                    },
                    {
                        "username": "aitachii",
                        "content": "Here\\'s yesterday for reference: https://leetcode.com/problems/can-place-flowers/"
                    },
                    {
                        "username": "user7478F",
                        "content": "seriously."
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "It\\'s too easy? it makes me feel good today."
                    },
                    {
                        "username": "Vizxe",
                        "content": "me too, felt good!"
                    },
                    {
                        "username": "cswartzell",
                        "content": "There really ought to be  a Leetcode section on \"common math tricks\". Knowing things like permutations, combinations, recognizing the triangular numbers and formula can be more relevant than some of the more obscure DSA sections they have"
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "\\u2026 and fill that section with problems like this one, when using such tricks make solutions uglier )))"
                    },
                    {
                        "username": "aditibhagat23",
                        "content": "Remember to store the count of zeros in long to pass all the test cases"
                    },
                    {
                        "username": "19sk99",
                        "content": "thank you so much. Finally my code got accepted after seeing your comment."
                    },
                    {
                        "username": "ashishgulati2112",
                        "content": "That is the only thing that can make it a medium question, lol XD"
                    },
                    {
                        "username": "arajshow",
                        "content": "This is the best way to start your day."
                    },
                    {
                        "username": "santanusen",
                        "content": "# Tip 1:\nWe have a contiguous zero-filled subarray ```S``` of size ```n``` say.\nLet us calculate total how many distinct subarrays (of size k; 1<= k <= n) can be formed out of the subarray ```S```.\n\nLet's think of a sliding window of size ```k``` that slides from the start of the subarray ```S``` until the right edge of the window hits the end of ```S```. \n\n* When ```k = 1```, the start of the sliding window can be placed over each element of ```S```.\n```\n[1] 2  3  4\n 1 [2] 3  4\n 1  2 [3] 4\n 1  2  3 [4]\n```\nThus we have ```n``` distinct subarrays of size 1.\n\n* When ```k = 2``` , the start of the sliding window can be placed over each element of ```S``` except the last.\n```\n[1  2] 3  4\n 1 [2  3] 4\n 1  2 [3  4]\n```\nSo we have ```n - 1``` distinct subarrays of size 2.\n\nAnd so on.\n\nFinally,\n* When ```k = n```, the sliding window covers the entirety of ```S```.\n```\n[1  2   3  4]\n```\nWe have ```1``` subarray of size n.\n\nHence, the total number of distinct subarrays that can be formed out of ```S``` is:\n```\nn + (n - 1) + (n - 2) + ... + 1 =\n((n + 1) * n) / 2\n```\n# Tip 2:\nFor languages supporting different integer sizes beware, the answer may not fit into 32 bits for some test cases. Pay attention to the return type of the function."
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "[@sahle123](/sahle123) sum of natural number series \\n```(1+2+3+4+...n) = n*(n+1)/2 ```"
                    },
                    {
                        "username": "sahle123",
                        "content": "For your first tip, in the last step, how did you arrive to the formula ```((n + 1) * n) / 2```?"
                    },
                    {
                        "username": "AlecLC",
                        "content": "If I got this question in an interview I would have to mute so they wouldn\\'t hear me popping champagne \\uD83C\\uDF7E "
                    }
                ]
            },
            {
                "id": 1839112,
                "content": [
                    {
                        "username": "yogeshvaidya",
                        "content": "should be marked as easy."
                    },
                    {
                        "username": "tyl2018",
                        "content": "[@rahul1995](/rahul1995) Thank you"
                    },
                    {
                        "username": "rahul1995",
                        "content": "I hope everyone who is calling it easy are also doing \"More Actions (...) -> Feedback -> Difficulty is inaccurate\".\\nThe \"More Actions (...)\" button is next to \"Hint\" button."
                    },
                    {
                        "username": "oystermajor",
                        "content": "Imagine being so lucky to get this question at Google lol "
                    },
                    {
                        "username": "rahul1995",
                        "content": "Is Google-mania still not over after all these layoffs?? smh"
                    },
                    {
                        "username": "bhattanrag123",
                        "content": "I'm not reading the discussions again"
                    },
                    {
                        "username": "mint_",
                        "content": "I know right? \n\nI've done a solid number of subarray and permutation questions before and didn't find this problem that intuitive, while I found yesterday's problem pretty easy."
                    },
                    {
                        "username": "Flexiiiii",
                        "content": "[@namandt](/namandt) probably because everyone is saying how easy it is "
                    },
                    {
                        "username": "namandt",
                        "content": "why?\\n"
                    },
                    {
                        "username": "aitachii",
                        "content": "This one was easier compared to yesterday's \"Easy\".\n\nAnyway, here's some clarification for the examples. Excluded elements will be marked as -.\nExample 1: nums = [1,3,0,0,2,0,0,4]\nThere are 2 [0,0] subarrays, these are: \n[-,-,0,0,-,-,-,-], and \n[-,-,-,-,-,0,0,-]\nThere are 4 [0] subarrays:\n[-,-,0,-,-,-,-,-],\n[-,-,-,0,-,-,-,-],\n[-,-,-,-,-,0,-,-], and\n[-,-,-,-,-,-,0,-]\nFor a total of 6.\n\nExample 2: nums = [0,0,0,2,0,0]\nFor the [0,0,0,-,-,-]:\n[0,-,-,-,-,-], +1\n\n[0,0,-,-,-,-], +1\n[-,0,-,-,-,-], +1\n\n[0,0,0,-,-,-], +1\n[-,0,0,-,-,-], +1\n[-,-,0,-,-,-], +1\nFor a subtotal of 6.\n\nFor the [-,-,-,-,0,0]:\n[-,-,-,-,0,-] +1\n\n[-,-,-,-,0,0] +1\n[-,-,-,-,-,0] +1\nFor a subtotal of 3.\n\nIn total, that's 9 zero subarrays."
                    },
                    {
                        "username": "aitachii",
                        "content": "Here\\'s yesterday for reference: https://leetcode.com/problems/can-place-flowers/"
                    },
                    {
                        "username": "user7478F",
                        "content": "seriously."
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "It\\'s too easy? it makes me feel good today."
                    },
                    {
                        "username": "Vizxe",
                        "content": "me too, felt good!"
                    },
                    {
                        "username": "cswartzell",
                        "content": "There really ought to be  a Leetcode section on \"common math tricks\". Knowing things like permutations, combinations, recognizing the triangular numbers and formula can be more relevant than some of the more obscure DSA sections they have"
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "\\u2026 and fill that section with problems like this one, when using such tricks make solutions uglier )))"
                    },
                    {
                        "username": "aditibhagat23",
                        "content": "Remember to store the count of zeros in long to pass all the test cases"
                    },
                    {
                        "username": "19sk99",
                        "content": "thank you so much. Finally my code got accepted after seeing your comment."
                    },
                    {
                        "username": "ashishgulati2112",
                        "content": "That is the only thing that can make it a medium question, lol XD"
                    },
                    {
                        "username": "arajshow",
                        "content": "This is the best way to start your day."
                    },
                    {
                        "username": "santanusen",
                        "content": "# Tip 1:\nWe have a contiguous zero-filled subarray ```S``` of size ```n``` say.\nLet us calculate total how many distinct subarrays (of size k; 1<= k <= n) can be formed out of the subarray ```S```.\n\nLet's think of a sliding window of size ```k``` that slides from the start of the subarray ```S``` until the right edge of the window hits the end of ```S```. \n\n* When ```k = 1```, the start of the sliding window can be placed over each element of ```S```.\n```\n[1] 2  3  4\n 1 [2] 3  4\n 1  2 [3] 4\n 1  2  3 [4]\n```\nThus we have ```n``` distinct subarrays of size 1.\n\n* When ```k = 2``` , the start of the sliding window can be placed over each element of ```S``` except the last.\n```\n[1  2] 3  4\n 1 [2  3] 4\n 1  2 [3  4]\n```\nSo we have ```n - 1``` distinct subarrays of size 2.\n\nAnd so on.\n\nFinally,\n* When ```k = n```, the sliding window covers the entirety of ```S```.\n```\n[1  2   3  4]\n```\nWe have ```1``` subarray of size n.\n\nHence, the total number of distinct subarrays that can be formed out of ```S``` is:\n```\nn + (n - 1) + (n - 2) + ... + 1 =\n((n + 1) * n) / 2\n```\n# Tip 2:\nFor languages supporting different integer sizes beware, the answer may not fit into 32 bits for some test cases. Pay attention to the return type of the function."
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "[@sahle123](/sahle123) sum of natural number series \\n```(1+2+3+4+...n) = n*(n+1)/2 ```"
                    },
                    {
                        "username": "sahle123",
                        "content": "For your first tip, in the last step, how did you arrive to the formula ```((n + 1) * n) / 2```?"
                    },
                    {
                        "username": "AlecLC",
                        "content": "If I got this question in an interview I would have to mute so they wouldn\\'t hear me popping champagne \\uD83C\\uDF7E "
                    }
                ]
            },
            {
                "id": 1838936,
                "content": [
                    {
                        "username": "yogeshvaidya",
                        "content": "should be marked as easy."
                    },
                    {
                        "username": "tyl2018",
                        "content": "[@rahul1995](/rahul1995) Thank you"
                    },
                    {
                        "username": "rahul1995",
                        "content": "I hope everyone who is calling it easy are also doing \"More Actions (...) -> Feedback -> Difficulty is inaccurate\".\\nThe \"More Actions (...)\" button is next to \"Hint\" button."
                    },
                    {
                        "username": "oystermajor",
                        "content": "Imagine being so lucky to get this question at Google lol "
                    },
                    {
                        "username": "rahul1995",
                        "content": "Is Google-mania still not over after all these layoffs?? smh"
                    },
                    {
                        "username": "bhattanrag123",
                        "content": "I'm not reading the discussions again"
                    },
                    {
                        "username": "mint_",
                        "content": "I know right? \n\nI've done a solid number of subarray and permutation questions before and didn't find this problem that intuitive, while I found yesterday's problem pretty easy."
                    },
                    {
                        "username": "Flexiiiii",
                        "content": "[@namandt](/namandt) probably because everyone is saying how easy it is "
                    },
                    {
                        "username": "namandt",
                        "content": "why?\\n"
                    },
                    {
                        "username": "aitachii",
                        "content": "This one was easier compared to yesterday's \"Easy\".\n\nAnyway, here's some clarification for the examples. Excluded elements will be marked as -.\nExample 1: nums = [1,3,0,0,2,0,0,4]\nThere are 2 [0,0] subarrays, these are: \n[-,-,0,0,-,-,-,-], and \n[-,-,-,-,-,0,0,-]\nThere are 4 [0] subarrays:\n[-,-,0,-,-,-,-,-],\n[-,-,-,0,-,-,-,-],\n[-,-,-,-,-,0,-,-], and\n[-,-,-,-,-,-,0,-]\nFor a total of 6.\n\nExample 2: nums = [0,0,0,2,0,0]\nFor the [0,0,0,-,-,-]:\n[0,-,-,-,-,-], +1\n\n[0,0,-,-,-,-], +1\n[-,0,-,-,-,-], +1\n\n[0,0,0,-,-,-], +1\n[-,0,0,-,-,-], +1\n[-,-,0,-,-,-], +1\nFor a subtotal of 6.\n\nFor the [-,-,-,-,0,0]:\n[-,-,-,-,0,-] +1\n\n[-,-,-,-,0,0] +1\n[-,-,-,-,-,0] +1\nFor a subtotal of 3.\n\nIn total, that's 9 zero subarrays."
                    },
                    {
                        "username": "aitachii",
                        "content": "Here\\'s yesterday for reference: https://leetcode.com/problems/can-place-flowers/"
                    },
                    {
                        "username": "user7478F",
                        "content": "seriously."
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "It\\'s too easy? it makes me feel good today."
                    },
                    {
                        "username": "Vizxe",
                        "content": "me too, felt good!"
                    },
                    {
                        "username": "cswartzell",
                        "content": "There really ought to be  a Leetcode section on \"common math tricks\". Knowing things like permutations, combinations, recognizing the triangular numbers and formula can be more relevant than some of the more obscure DSA sections they have"
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "\\u2026 and fill that section with problems like this one, when using such tricks make solutions uglier )))"
                    },
                    {
                        "username": "aditibhagat23",
                        "content": "Remember to store the count of zeros in long to pass all the test cases"
                    },
                    {
                        "username": "19sk99",
                        "content": "thank you so much. Finally my code got accepted after seeing your comment."
                    },
                    {
                        "username": "ashishgulati2112",
                        "content": "That is the only thing that can make it a medium question, lol XD"
                    },
                    {
                        "username": "arajshow",
                        "content": "This is the best way to start your day."
                    },
                    {
                        "username": "santanusen",
                        "content": "# Tip 1:\nWe have a contiguous zero-filled subarray ```S``` of size ```n``` say.\nLet us calculate total how many distinct subarrays (of size k; 1<= k <= n) can be formed out of the subarray ```S```.\n\nLet's think of a sliding window of size ```k``` that slides from the start of the subarray ```S``` until the right edge of the window hits the end of ```S```. \n\n* When ```k = 1```, the start of the sliding window can be placed over each element of ```S```.\n```\n[1] 2  3  4\n 1 [2] 3  4\n 1  2 [3] 4\n 1  2  3 [4]\n```\nThus we have ```n``` distinct subarrays of size 1.\n\n* When ```k = 2``` , the start of the sliding window can be placed over each element of ```S``` except the last.\n```\n[1  2] 3  4\n 1 [2  3] 4\n 1  2 [3  4]\n```\nSo we have ```n - 1``` distinct subarrays of size 2.\n\nAnd so on.\n\nFinally,\n* When ```k = n```, the sliding window covers the entirety of ```S```.\n```\n[1  2   3  4]\n```\nWe have ```1``` subarray of size n.\n\nHence, the total number of distinct subarrays that can be formed out of ```S``` is:\n```\nn + (n - 1) + (n - 2) + ... + 1 =\n((n + 1) * n) / 2\n```\n# Tip 2:\nFor languages supporting different integer sizes beware, the answer may not fit into 32 bits for some test cases. Pay attention to the return type of the function."
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "[@sahle123](/sahle123) sum of natural number series \\n```(1+2+3+4+...n) = n*(n+1)/2 ```"
                    },
                    {
                        "username": "sahle123",
                        "content": "For your first tip, in the last step, how did you arrive to the formula ```((n + 1) * n) / 2```?"
                    },
                    {
                        "username": "AlecLC",
                        "content": "If I got this question in an interview I would have to mute so they wouldn\\'t hear me popping champagne \\uD83C\\uDF7E "
                    }
                ]
            },
            {
                "id": 1838915,
                "content": [
                    {
                        "username": "yogeshvaidya",
                        "content": "should be marked as easy."
                    },
                    {
                        "username": "tyl2018",
                        "content": "[@rahul1995](/rahul1995) Thank you"
                    },
                    {
                        "username": "rahul1995",
                        "content": "I hope everyone who is calling it easy are also doing \"More Actions (...) -> Feedback -> Difficulty is inaccurate\".\\nThe \"More Actions (...)\" button is next to \"Hint\" button."
                    },
                    {
                        "username": "oystermajor",
                        "content": "Imagine being so lucky to get this question at Google lol "
                    },
                    {
                        "username": "rahul1995",
                        "content": "Is Google-mania still not over after all these layoffs?? smh"
                    },
                    {
                        "username": "bhattanrag123",
                        "content": "I'm not reading the discussions again"
                    },
                    {
                        "username": "mint_",
                        "content": "I know right? \n\nI've done a solid number of subarray and permutation questions before and didn't find this problem that intuitive, while I found yesterday's problem pretty easy."
                    },
                    {
                        "username": "Flexiiiii",
                        "content": "[@namandt](/namandt) probably because everyone is saying how easy it is "
                    },
                    {
                        "username": "namandt",
                        "content": "why?\\n"
                    },
                    {
                        "username": "aitachii",
                        "content": "This one was easier compared to yesterday's \"Easy\".\n\nAnyway, here's some clarification for the examples. Excluded elements will be marked as -.\nExample 1: nums = [1,3,0,0,2,0,0,4]\nThere are 2 [0,0] subarrays, these are: \n[-,-,0,0,-,-,-,-], and \n[-,-,-,-,-,0,0,-]\nThere are 4 [0] subarrays:\n[-,-,0,-,-,-,-,-],\n[-,-,-,0,-,-,-,-],\n[-,-,-,-,-,0,-,-], and\n[-,-,-,-,-,-,0,-]\nFor a total of 6.\n\nExample 2: nums = [0,0,0,2,0,0]\nFor the [0,0,0,-,-,-]:\n[0,-,-,-,-,-], +1\n\n[0,0,-,-,-,-], +1\n[-,0,-,-,-,-], +1\n\n[0,0,0,-,-,-], +1\n[-,0,0,-,-,-], +1\n[-,-,0,-,-,-], +1\nFor a subtotal of 6.\n\nFor the [-,-,-,-,0,0]:\n[-,-,-,-,0,-] +1\n\n[-,-,-,-,0,0] +1\n[-,-,-,-,-,0] +1\nFor a subtotal of 3.\n\nIn total, that's 9 zero subarrays."
                    },
                    {
                        "username": "aitachii",
                        "content": "Here\\'s yesterday for reference: https://leetcode.com/problems/can-place-flowers/"
                    },
                    {
                        "username": "user7478F",
                        "content": "seriously."
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "It\\'s too easy? it makes me feel good today."
                    },
                    {
                        "username": "Vizxe",
                        "content": "me too, felt good!"
                    },
                    {
                        "username": "cswartzell",
                        "content": "There really ought to be  a Leetcode section on \"common math tricks\". Knowing things like permutations, combinations, recognizing the triangular numbers and formula can be more relevant than some of the more obscure DSA sections they have"
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "\\u2026 and fill that section with problems like this one, when using such tricks make solutions uglier )))"
                    },
                    {
                        "username": "aditibhagat23",
                        "content": "Remember to store the count of zeros in long to pass all the test cases"
                    },
                    {
                        "username": "19sk99",
                        "content": "thank you so much. Finally my code got accepted after seeing your comment."
                    },
                    {
                        "username": "ashishgulati2112",
                        "content": "That is the only thing that can make it a medium question, lol XD"
                    },
                    {
                        "username": "arajshow",
                        "content": "This is the best way to start your day."
                    },
                    {
                        "username": "santanusen",
                        "content": "# Tip 1:\nWe have a contiguous zero-filled subarray ```S``` of size ```n``` say.\nLet us calculate total how many distinct subarrays (of size k; 1<= k <= n) can be formed out of the subarray ```S```.\n\nLet's think of a sliding window of size ```k``` that slides from the start of the subarray ```S``` until the right edge of the window hits the end of ```S```. \n\n* When ```k = 1```, the start of the sliding window can be placed over each element of ```S```.\n```\n[1] 2  3  4\n 1 [2] 3  4\n 1  2 [3] 4\n 1  2  3 [4]\n```\nThus we have ```n``` distinct subarrays of size 1.\n\n* When ```k = 2``` , the start of the sliding window can be placed over each element of ```S``` except the last.\n```\n[1  2] 3  4\n 1 [2  3] 4\n 1  2 [3  4]\n```\nSo we have ```n - 1``` distinct subarrays of size 2.\n\nAnd so on.\n\nFinally,\n* When ```k = n```, the sliding window covers the entirety of ```S```.\n```\n[1  2   3  4]\n```\nWe have ```1``` subarray of size n.\n\nHence, the total number of distinct subarrays that can be formed out of ```S``` is:\n```\nn + (n - 1) + (n - 2) + ... + 1 =\n((n + 1) * n) / 2\n```\n# Tip 2:\nFor languages supporting different integer sizes beware, the answer may not fit into 32 bits for some test cases. Pay attention to the return type of the function."
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "[@sahle123](/sahle123) sum of natural number series \\n```(1+2+3+4+...n) = n*(n+1)/2 ```"
                    },
                    {
                        "username": "sahle123",
                        "content": "For your first tip, in the last step, how did you arrive to the formula ```((n + 1) * n) / 2```?"
                    },
                    {
                        "username": "AlecLC",
                        "content": "If I got this question in an interview I would have to mute so they wouldn\\'t hear me popping champagne \\uD83C\\uDF7E "
                    }
                ]
            },
            {
                "id": 1839124,
                "content": [
                    {
                        "username": "yogeshvaidya",
                        "content": "should be marked as easy."
                    },
                    {
                        "username": "tyl2018",
                        "content": "[@rahul1995](/rahul1995) Thank you"
                    },
                    {
                        "username": "rahul1995",
                        "content": "I hope everyone who is calling it easy are also doing \"More Actions (...) -> Feedback -> Difficulty is inaccurate\".\\nThe \"More Actions (...)\" button is next to \"Hint\" button."
                    },
                    {
                        "username": "oystermajor",
                        "content": "Imagine being so lucky to get this question at Google lol "
                    },
                    {
                        "username": "rahul1995",
                        "content": "Is Google-mania still not over after all these layoffs?? smh"
                    },
                    {
                        "username": "bhattanrag123",
                        "content": "I'm not reading the discussions again"
                    },
                    {
                        "username": "mint_",
                        "content": "I know right? \n\nI've done a solid number of subarray and permutation questions before and didn't find this problem that intuitive, while I found yesterday's problem pretty easy."
                    },
                    {
                        "username": "Flexiiiii",
                        "content": "[@namandt](/namandt) probably because everyone is saying how easy it is "
                    },
                    {
                        "username": "namandt",
                        "content": "why?\\n"
                    },
                    {
                        "username": "aitachii",
                        "content": "This one was easier compared to yesterday's \"Easy\".\n\nAnyway, here's some clarification for the examples. Excluded elements will be marked as -.\nExample 1: nums = [1,3,0,0,2,0,0,4]\nThere are 2 [0,0] subarrays, these are: \n[-,-,0,0,-,-,-,-], and \n[-,-,-,-,-,0,0,-]\nThere are 4 [0] subarrays:\n[-,-,0,-,-,-,-,-],\n[-,-,-,0,-,-,-,-],\n[-,-,-,-,-,0,-,-], and\n[-,-,-,-,-,-,0,-]\nFor a total of 6.\n\nExample 2: nums = [0,0,0,2,0,0]\nFor the [0,0,0,-,-,-]:\n[0,-,-,-,-,-], +1\n\n[0,0,-,-,-,-], +1\n[-,0,-,-,-,-], +1\n\n[0,0,0,-,-,-], +1\n[-,0,0,-,-,-], +1\n[-,-,0,-,-,-], +1\nFor a subtotal of 6.\n\nFor the [-,-,-,-,0,0]:\n[-,-,-,-,0,-] +1\n\n[-,-,-,-,0,0] +1\n[-,-,-,-,-,0] +1\nFor a subtotal of 3.\n\nIn total, that's 9 zero subarrays."
                    },
                    {
                        "username": "aitachii",
                        "content": "Here\\'s yesterday for reference: https://leetcode.com/problems/can-place-flowers/"
                    },
                    {
                        "username": "user7478F",
                        "content": "seriously."
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "It\\'s too easy? it makes me feel good today."
                    },
                    {
                        "username": "Vizxe",
                        "content": "me too, felt good!"
                    },
                    {
                        "username": "cswartzell",
                        "content": "There really ought to be  a Leetcode section on \"common math tricks\". Knowing things like permutations, combinations, recognizing the triangular numbers and formula can be more relevant than some of the more obscure DSA sections they have"
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "\\u2026 and fill that section with problems like this one, when using such tricks make solutions uglier )))"
                    },
                    {
                        "username": "aditibhagat23",
                        "content": "Remember to store the count of zeros in long to pass all the test cases"
                    },
                    {
                        "username": "19sk99",
                        "content": "thank you so much. Finally my code got accepted after seeing your comment."
                    },
                    {
                        "username": "ashishgulati2112",
                        "content": "That is the only thing that can make it a medium question, lol XD"
                    },
                    {
                        "username": "arajshow",
                        "content": "This is the best way to start your day."
                    },
                    {
                        "username": "santanusen",
                        "content": "# Tip 1:\nWe have a contiguous zero-filled subarray ```S``` of size ```n``` say.\nLet us calculate total how many distinct subarrays (of size k; 1<= k <= n) can be formed out of the subarray ```S```.\n\nLet's think of a sliding window of size ```k``` that slides from the start of the subarray ```S``` until the right edge of the window hits the end of ```S```. \n\n* When ```k = 1```, the start of the sliding window can be placed over each element of ```S```.\n```\n[1] 2  3  4\n 1 [2] 3  4\n 1  2 [3] 4\n 1  2  3 [4]\n```\nThus we have ```n``` distinct subarrays of size 1.\n\n* When ```k = 2``` , the start of the sliding window can be placed over each element of ```S``` except the last.\n```\n[1  2] 3  4\n 1 [2  3] 4\n 1  2 [3  4]\n```\nSo we have ```n - 1``` distinct subarrays of size 2.\n\nAnd so on.\n\nFinally,\n* When ```k = n```, the sliding window covers the entirety of ```S```.\n```\n[1  2   3  4]\n```\nWe have ```1``` subarray of size n.\n\nHence, the total number of distinct subarrays that can be formed out of ```S``` is:\n```\nn + (n - 1) + (n - 2) + ... + 1 =\n((n + 1) * n) / 2\n```\n# Tip 2:\nFor languages supporting different integer sizes beware, the answer may not fit into 32 bits for some test cases. Pay attention to the return type of the function."
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "[@sahle123](/sahle123) sum of natural number series \\n```(1+2+3+4+...n) = n*(n+1)/2 ```"
                    },
                    {
                        "username": "sahle123",
                        "content": "For your first tip, in the last step, how did you arrive to the formula ```((n + 1) * n) / 2```?"
                    },
                    {
                        "username": "AlecLC",
                        "content": "If I got this question in an interview I would have to mute so they wouldn\\'t hear me popping champagne \\uD83C\\uDF7E "
                    }
                ]
            },
            {
                "id": 1838933,
                "content": [
                    {
                        "username": "yogeshvaidya",
                        "content": "should be marked as easy."
                    },
                    {
                        "username": "tyl2018",
                        "content": "[@rahul1995](/rahul1995) Thank you"
                    },
                    {
                        "username": "rahul1995",
                        "content": "I hope everyone who is calling it easy are also doing \"More Actions (...) -> Feedback -> Difficulty is inaccurate\".\\nThe \"More Actions (...)\" button is next to \"Hint\" button."
                    },
                    {
                        "username": "oystermajor",
                        "content": "Imagine being so lucky to get this question at Google lol "
                    },
                    {
                        "username": "rahul1995",
                        "content": "Is Google-mania still not over after all these layoffs?? smh"
                    },
                    {
                        "username": "bhattanrag123",
                        "content": "I'm not reading the discussions again"
                    },
                    {
                        "username": "mint_",
                        "content": "I know right? \n\nI've done a solid number of subarray and permutation questions before and didn't find this problem that intuitive, while I found yesterday's problem pretty easy."
                    },
                    {
                        "username": "Flexiiiii",
                        "content": "[@namandt](/namandt) probably because everyone is saying how easy it is "
                    },
                    {
                        "username": "namandt",
                        "content": "why?\\n"
                    },
                    {
                        "username": "aitachii",
                        "content": "This one was easier compared to yesterday's \"Easy\".\n\nAnyway, here's some clarification for the examples. Excluded elements will be marked as -.\nExample 1: nums = [1,3,0,0,2,0,0,4]\nThere are 2 [0,0] subarrays, these are: \n[-,-,0,0,-,-,-,-], and \n[-,-,-,-,-,0,0,-]\nThere are 4 [0] subarrays:\n[-,-,0,-,-,-,-,-],\n[-,-,-,0,-,-,-,-],\n[-,-,-,-,-,0,-,-], and\n[-,-,-,-,-,-,0,-]\nFor a total of 6.\n\nExample 2: nums = [0,0,0,2,0,0]\nFor the [0,0,0,-,-,-]:\n[0,-,-,-,-,-], +1\n\n[0,0,-,-,-,-], +1\n[-,0,-,-,-,-], +1\n\n[0,0,0,-,-,-], +1\n[-,0,0,-,-,-], +1\n[-,-,0,-,-,-], +1\nFor a subtotal of 6.\n\nFor the [-,-,-,-,0,0]:\n[-,-,-,-,0,-] +1\n\n[-,-,-,-,0,0] +1\n[-,-,-,-,-,0] +1\nFor a subtotal of 3.\n\nIn total, that's 9 zero subarrays."
                    },
                    {
                        "username": "aitachii",
                        "content": "Here\\'s yesterday for reference: https://leetcode.com/problems/can-place-flowers/"
                    },
                    {
                        "username": "user7478F",
                        "content": "seriously."
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "It\\'s too easy? it makes me feel good today."
                    },
                    {
                        "username": "Vizxe",
                        "content": "me too, felt good!"
                    },
                    {
                        "username": "cswartzell",
                        "content": "There really ought to be  a Leetcode section on \"common math tricks\". Knowing things like permutations, combinations, recognizing the triangular numbers and formula can be more relevant than some of the more obscure DSA sections they have"
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "\\u2026 and fill that section with problems like this one, when using such tricks make solutions uglier )))"
                    },
                    {
                        "username": "aditibhagat23",
                        "content": "Remember to store the count of zeros in long to pass all the test cases"
                    },
                    {
                        "username": "19sk99",
                        "content": "thank you so much. Finally my code got accepted after seeing your comment."
                    },
                    {
                        "username": "ashishgulati2112",
                        "content": "That is the only thing that can make it a medium question, lol XD"
                    },
                    {
                        "username": "arajshow",
                        "content": "This is the best way to start your day."
                    },
                    {
                        "username": "santanusen",
                        "content": "# Tip 1:\nWe have a contiguous zero-filled subarray ```S``` of size ```n``` say.\nLet us calculate total how many distinct subarrays (of size k; 1<= k <= n) can be formed out of the subarray ```S```.\n\nLet's think of a sliding window of size ```k``` that slides from the start of the subarray ```S``` until the right edge of the window hits the end of ```S```. \n\n* When ```k = 1```, the start of the sliding window can be placed over each element of ```S```.\n```\n[1] 2  3  4\n 1 [2] 3  4\n 1  2 [3] 4\n 1  2  3 [4]\n```\nThus we have ```n``` distinct subarrays of size 1.\n\n* When ```k = 2``` , the start of the sliding window can be placed over each element of ```S``` except the last.\n```\n[1  2] 3  4\n 1 [2  3] 4\n 1  2 [3  4]\n```\nSo we have ```n - 1``` distinct subarrays of size 2.\n\nAnd so on.\n\nFinally,\n* When ```k = n```, the sliding window covers the entirety of ```S```.\n```\n[1  2   3  4]\n```\nWe have ```1``` subarray of size n.\n\nHence, the total number of distinct subarrays that can be formed out of ```S``` is:\n```\nn + (n - 1) + (n - 2) + ... + 1 =\n((n + 1) * n) / 2\n```\n# Tip 2:\nFor languages supporting different integer sizes beware, the answer may not fit into 32 bits for some test cases. Pay attention to the return type of the function."
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "[@sahle123](/sahle123) sum of natural number series \\n```(1+2+3+4+...n) = n*(n+1)/2 ```"
                    },
                    {
                        "username": "sahle123",
                        "content": "For your first tip, in the last step, how did you arrive to the formula ```((n + 1) * n) / 2```?"
                    },
                    {
                        "username": "AlecLC",
                        "content": "If I got this question in an interview I would have to mute so they wouldn\\'t hear me popping champagne \\uD83C\\uDF7E "
                    }
                ]
            },
            {
                "id": 1838943,
                "content": [
                    {
                        "username": "yogeshvaidya",
                        "content": "should be marked as easy."
                    },
                    {
                        "username": "tyl2018",
                        "content": "[@rahul1995](/rahul1995) Thank you"
                    },
                    {
                        "username": "rahul1995",
                        "content": "I hope everyone who is calling it easy are also doing \"More Actions (...) -> Feedback -> Difficulty is inaccurate\".\\nThe \"More Actions (...)\" button is next to \"Hint\" button."
                    },
                    {
                        "username": "oystermajor",
                        "content": "Imagine being so lucky to get this question at Google lol "
                    },
                    {
                        "username": "rahul1995",
                        "content": "Is Google-mania still not over after all these layoffs?? smh"
                    },
                    {
                        "username": "bhattanrag123",
                        "content": "I'm not reading the discussions again"
                    },
                    {
                        "username": "mint_",
                        "content": "I know right? \n\nI've done a solid number of subarray and permutation questions before and didn't find this problem that intuitive, while I found yesterday's problem pretty easy."
                    },
                    {
                        "username": "Flexiiiii",
                        "content": "[@namandt](/namandt) probably because everyone is saying how easy it is "
                    },
                    {
                        "username": "namandt",
                        "content": "why?\\n"
                    },
                    {
                        "username": "aitachii",
                        "content": "This one was easier compared to yesterday's \"Easy\".\n\nAnyway, here's some clarification for the examples. Excluded elements will be marked as -.\nExample 1: nums = [1,3,0,0,2,0,0,4]\nThere are 2 [0,0] subarrays, these are: \n[-,-,0,0,-,-,-,-], and \n[-,-,-,-,-,0,0,-]\nThere are 4 [0] subarrays:\n[-,-,0,-,-,-,-,-],\n[-,-,-,0,-,-,-,-],\n[-,-,-,-,-,0,-,-], and\n[-,-,-,-,-,-,0,-]\nFor a total of 6.\n\nExample 2: nums = [0,0,0,2,0,0]\nFor the [0,0,0,-,-,-]:\n[0,-,-,-,-,-], +1\n\n[0,0,-,-,-,-], +1\n[-,0,-,-,-,-], +1\n\n[0,0,0,-,-,-], +1\n[-,0,0,-,-,-], +1\n[-,-,0,-,-,-], +1\nFor a subtotal of 6.\n\nFor the [-,-,-,-,0,0]:\n[-,-,-,-,0,-] +1\n\n[-,-,-,-,0,0] +1\n[-,-,-,-,-,0] +1\nFor a subtotal of 3.\n\nIn total, that's 9 zero subarrays."
                    },
                    {
                        "username": "aitachii",
                        "content": "Here\\'s yesterday for reference: https://leetcode.com/problems/can-place-flowers/"
                    },
                    {
                        "username": "user7478F",
                        "content": "seriously."
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "It\\'s too easy? it makes me feel good today."
                    },
                    {
                        "username": "Vizxe",
                        "content": "me too, felt good!"
                    },
                    {
                        "username": "cswartzell",
                        "content": "There really ought to be  a Leetcode section on \"common math tricks\". Knowing things like permutations, combinations, recognizing the triangular numbers and formula can be more relevant than some of the more obscure DSA sections they have"
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "\\u2026 and fill that section with problems like this one, when using such tricks make solutions uglier )))"
                    },
                    {
                        "username": "aditibhagat23",
                        "content": "Remember to store the count of zeros in long to pass all the test cases"
                    },
                    {
                        "username": "19sk99",
                        "content": "thank you so much. Finally my code got accepted after seeing your comment."
                    },
                    {
                        "username": "ashishgulati2112",
                        "content": "That is the only thing that can make it a medium question, lol XD"
                    },
                    {
                        "username": "arajshow",
                        "content": "This is the best way to start your day."
                    },
                    {
                        "username": "santanusen",
                        "content": "# Tip 1:\nWe have a contiguous zero-filled subarray ```S``` of size ```n``` say.\nLet us calculate total how many distinct subarrays (of size k; 1<= k <= n) can be formed out of the subarray ```S```.\n\nLet's think of a sliding window of size ```k``` that slides from the start of the subarray ```S``` until the right edge of the window hits the end of ```S```. \n\n* When ```k = 1```, the start of the sliding window can be placed over each element of ```S```.\n```\n[1] 2  3  4\n 1 [2] 3  4\n 1  2 [3] 4\n 1  2  3 [4]\n```\nThus we have ```n``` distinct subarrays of size 1.\n\n* When ```k = 2``` , the start of the sliding window can be placed over each element of ```S``` except the last.\n```\n[1  2] 3  4\n 1 [2  3] 4\n 1  2 [3  4]\n```\nSo we have ```n - 1``` distinct subarrays of size 2.\n\nAnd so on.\n\nFinally,\n* When ```k = n```, the sliding window covers the entirety of ```S```.\n```\n[1  2   3  4]\n```\nWe have ```1``` subarray of size n.\n\nHence, the total number of distinct subarrays that can be formed out of ```S``` is:\n```\nn + (n - 1) + (n - 2) + ... + 1 =\n((n + 1) * n) / 2\n```\n# Tip 2:\nFor languages supporting different integer sizes beware, the answer may not fit into 32 bits for some test cases. Pay attention to the return type of the function."
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "[@sahle123](/sahle123) sum of natural number series \\n```(1+2+3+4+...n) = n*(n+1)/2 ```"
                    },
                    {
                        "username": "sahle123",
                        "content": "For your first tip, in the last step, how did you arrive to the formula ```((n + 1) * n) / 2```?"
                    },
                    {
                        "username": "AlecLC",
                        "content": "If I got this question in an interview I would have to mute so they wouldn\\'t hear me popping champagne \\uD83C\\uDF7E "
                    }
                ]
            },
            {
                "id": 1838940,
                "content": [
                    {
                        "username": "yogeshvaidya",
                        "content": "should be marked as easy."
                    },
                    {
                        "username": "tyl2018",
                        "content": "[@rahul1995](/rahul1995) Thank you"
                    },
                    {
                        "username": "rahul1995",
                        "content": "I hope everyone who is calling it easy are also doing \"More Actions (...) -> Feedback -> Difficulty is inaccurate\".\\nThe \"More Actions (...)\" button is next to \"Hint\" button."
                    },
                    {
                        "username": "oystermajor",
                        "content": "Imagine being so lucky to get this question at Google lol "
                    },
                    {
                        "username": "rahul1995",
                        "content": "Is Google-mania still not over after all these layoffs?? smh"
                    },
                    {
                        "username": "bhattanrag123",
                        "content": "I'm not reading the discussions again"
                    },
                    {
                        "username": "mint_",
                        "content": "I know right? \n\nI've done a solid number of subarray and permutation questions before and didn't find this problem that intuitive, while I found yesterday's problem pretty easy."
                    },
                    {
                        "username": "Flexiiiii",
                        "content": "[@namandt](/namandt) probably because everyone is saying how easy it is "
                    },
                    {
                        "username": "namandt",
                        "content": "why?\\n"
                    },
                    {
                        "username": "aitachii",
                        "content": "This one was easier compared to yesterday's \"Easy\".\n\nAnyway, here's some clarification for the examples. Excluded elements will be marked as -.\nExample 1: nums = [1,3,0,0,2,0,0,4]\nThere are 2 [0,0] subarrays, these are: \n[-,-,0,0,-,-,-,-], and \n[-,-,-,-,-,0,0,-]\nThere are 4 [0] subarrays:\n[-,-,0,-,-,-,-,-],\n[-,-,-,0,-,-,-,-],\n[-,-,-,-,-,0,-,-], and\n[-,-,-,-,-,-,0,-]\nFor a total of 6.\n\nExample 2: nums = [0,0,0,2,0,0]\nFor the [0,0,0,-,-,-]:\n[0,-,-,-,-,-], +1\n\n[0,0,-,-,-,-], +1\n[-,0,-,-,-,-], +1\n\n[0,0,0,-,-,-], +1\n[-,0,0,-,-,-], +1\n[-,-,0,-,-,-], +1\nFor a subtotal of 6.\n\nFor the [-,-,-,-,0,0]:\n[-,-,-,-,0,-] +1\n\n[-,-,-,-,0,0] +1\n[-,-,-,-,-,0] +1\nFor a subtotal of 3.\n\nIn total, that's 9 zero subarrays."
                    },
                    {
                        "username": "aitachii",
                        "content": "Here\\'s yesterday for reference: https://leetcode.com/problems/can-place-flowers/"
                    },
                    {
                        "username": "user7478F",
                        "content": "seriously."
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "It\\'s too easy? it makes me feel good today."
                    },
                    {
                        "username": "Vizxe",
                        "content": "me too, felt good!"
                    },
                    {
                        "username": "cswartzell",
                        "content": "There really ought to be  a Leetcode section on \"common math tricks\". Knowing things like permutations, combinations, recognizing the triangular numbers and formula can be more relevant than some of the more obscure DSA sections they have"
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "\\u2026 and fill that section with problems like this one, when using such tricks make solutions uglier )))"
                    },
                    {
                        "username": "aditibhagat23",
                        "content": "Remember to store the count of zeros in long to pass all the test cases"
                    },
                    {
                        "username": "19sk99",
                        "content": "thank you so much. Finally my code got accepted after seeing your comment."
                    },
                    {
                        "username": "ashishgulati2112",
                        "content": "That is the only thing that can make it a medium question, lol XD"
                    },
                    {
                        "username": "arajshow",
                        "content": "This is the best way to start your day."
                    },
                    {
                        "username": "santanusen",
                        "content": "# Tip 1:\nWe have a contiguous zero-filled subarray ```S``` of size ```n``` say.\nLet us calculate total how many distinct subarrays (of size k; 1<= k <= n) can be formed out of the subarray ```S```.\n\nLet's think of a sliding window of size ```k``` that slides from the start of the subarray ```S``` until the right edge of the window hits the end of ```S```. \n\n* When ```k = 1```, the start of the sliding window can be placed over each element of ```S```.\n```\n[1] 2  3  4\n 1 [2] 3  4\n 1  2 [3] 4\n 1  2  3 [4]\n```\nThus we have ```n``` distinct subarrays of size 1.\n\n* When ```k = 2``` , the start of the sliding window can be placed over each element of ```S``` except the last.\n```\n[1  2] 3  4\n 1 [2  3] 4\n 1  2 [3  4]\n```\nSo we have ```n - 1``` distinct subarrays of size 2.\n\nAnd so on.\n\nFinally,\n* When ```k = n```, the sliding window covers the entirety of ```S```.\n```\n[1  2   3  4]\n```\nWe have ```1``` subarray of size n.\n\nHence, the total number of distinct subarrays that can be formed out of ```S``` is:\n```\nn + (n - 1) + (n - 2) + ... + 1 =\n((n + 1) * n) / 2\n```\n# Tip 2:\nFor languages supporting different integer sizes beware, the answer may not fit into 32 bits for some test cases. Pay attention to the return type of the function."
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "[@sahle123](/sahle123) sum of natural number series \\n```(1+2+3+4+...n) = n*(n+1)/2 ```"
                    },
                    {
                        "username": "sahle123",
                        "content": "For your first tip, in the last step, how did you arrive to the formula ```((n + 1) * n) / 2```?"
                    },
                    {
                        "username": "AlecLC",
                        "content": "If I got this question in an interview I would have to mute so they wouldn\\'t hear me popping champagne \\uD83C\\uDF7E "
                    }
                ]
            },
            {
                "id": 1808514,
                "content": [
                    {
                        "username": "yogeshvaidya",
                        "content": "should be marked as easy."
                    },
                    {
                        "username": "tyl2018",
                        "content": "[@rahul1995](/rahul1995) Thank you"
                    },
                    {
                        "username": "rahul1995",
                        "content": "I hope everyone who is calling it easy are also doing \"More Actions (...) -> Feedback -> Difficulty is inaccurate\".\\nThe \"More Actions (...)\" button is next to \"Hint\" button."
                    },
                    {
                        "username": "oystermajor",
                        "content": "Imagine being so lucky to get this question at Google lol "
                    },
                    {
                        "username": "rahul1995",
                        "content": "Is Google-mania still not over after all these layoffs?? smh"
                    },
                    {
                        "username": "bhattanrag123",
                        "content": "I'm not reading the discussions again"
                    },
                    {
                        "username": "mint_",
                        "content": "I know right? \n\nI've done a solid number of subarray and permutation questions before and didn't find this problem that intuitive, while I found yesterday's problem pretty easy."
                    },
                    {
                        "username": "Flexiiiii",
                        "content": "[@namandt](/namandt) probably because everyone is saying how easy it is "
                    },
                    {
                        "username": "namandt",
                        "content": "why?\\n"
                    },
                    {
                        "username": "aitachii",
                        "content": "This one was easier compared to yesterday's \"Easy\".\n\nAnyway, here's some clarification for the examples. Excluded elements will be marked as -.\nExample 1: nums = [1,3,0,0,2,0,0,4]\nThere are 2 [0,0] subarrays, these are: \n[-,-,0,0,-,-,-,-], and \n[-,-,-,-,-,0,0,-]\nThere are 4 [0] subarrays:\n[-,-,0,-,-,-,-,-],\n[-,-,-,0,-,-,-,-],\n[-,-,-,-,-,0,-,-], and\n[-,-,-,-,-,-,0,-]\nFor a total of 6.\n\nExample 2: nums = [0,0,0,2,0,0]\nFor the [0,0,0,-,-,-]:\n[0,-,-,-,-,-], +1\n\n[0,0,-,-,-,-], +1\n[-,0,-,-,-,-], +1\n\n[0,0,0,-,-,-], +1\n[-,0,0,-,-,-], +1\n[-,-,0,-,-,-], +1\nFor a subtotal of 6.\n\nFor the [-,-,-,-,0,0]:\n[-,-,-,-,0,-] +1\n\n[-,-,-,-,0,0] +1\n[-,-,-,-,-,0] +1\nFor a subtotal of 3.\n\nIn total, that's 9 zero subarrays."
                    },
                    {
                        "username": "aitachii",
                        "content": "Here\\'s yesterday for reference: https://leetcode.com/problems/can-place-flowers/"
                    },
                    {
                        "username": "user7478F",
                        "content": "seriously."
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "It\\'s too easy? it makes me feel good today."
                    },
                    {
                        "username": "Vizxe",
                        "content": "me too, felt good!"
                    },
                    {
                        "username": "cswartzell",
                        "content": "There really ought to be  a Leetcode section on \"common math tricks\". Knowing things like permutations, combinations, recognizing the triangular numbers and formula can be more relevant than some of the more obscure DSA sections they have"
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "\\u2026 and fill that section with problems like this one, when using such tricks make solutions uglier )))"
                    },
                    {
                        "username": "aditibhagat23",
                        "content": "Remember to store the count of zeros in long to pass all the test cases"
                    },
                    {
                        "username": "19sk99",
                        "content": "thank you so much. Finally my code got accepted after seeing your comment."
                    },
                    {
                        "username": "ashishgulati2112",
                        "content": "That is the only thing that can make it a medium question, lol XD"
                    },
                    {
                        "username": "arajshow",
                        "content": "This is the best way to start your day."
                    },
                    {
                        "username": "santanusen",
                        "content": "# Tip 1:\nWe have a contiguous zero-filled subarray ```S``` of size ```n``` say.\nLet us calculate total how many distinct subarrays (of size k; 1<= k <= n) can be formed out of the subarray ```S```.\n\nLet's think of a sliding window of size ```k``` that slides from the start of the subarray ```S``` until the right edge of the window hits the end of ```S```. \n\n* When ```k = 1```, the start of the sliding window can be placed over each element of ```S```.\n```\n[1] 2  3  4\n 1 [2] 3  4\n 1  2 [3] 4\n 1  2  3 [4]\n```\nThus we have ```n``` distinct subarrays of size 1.\n\n* When ```k = 2``` , the start of the sliding window can be placed over each element of ```S``` except the last.\n```\n[1  2] 3  4\n 1 [2  3] 4\n 1  2 [3  4]\n```\nSo we have ```n - 1``` distinct subarrays of size 2.\n\nAnd so on.\n\nFinally,\n* When ```k = n```, the sliding window covers the entirety of ```S```.\n```\n[1  2   3  4]\n```\nWe have ```1``` subarray of size n.\n\nHence, the total number of distinct subarrays that can be formed out of ```S``` is:\n```\nn + (n - 1) + (n - 2) + ... + 1 =\n((n + 1) * n) / 2\n```\n# Tip 2:\nFor languages supporting different integer sizes beware, the answer may not fit into 32 bits for some test cases. Pay attention to the return type of the function."
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "[@sahle123](/sahle123) sum of natural number series \\n```(1+2+3+4+...n) = n*(n+1)/2 ```"
                    },
                    {
                        "username": "sahle123",
                        "content": "For your first tip, in the last step, how did you arrive to the formula ```((n + 1) * n) / 2```?"
                    },
                    {
                        "username": "AlecLC",
                        "content": "If I got this question in an interview I would have to mute so they wouldn\\'t hear me popping champagne \\uD83C\\uDF7E "
                    }
                ]
            },
            {
                "id": 1838932,
                "content": [
                    {
                        "username": "yogeshvaidya",
                        "content": "should be marked as easy."
                    },
                    {
                        "username": "tyl2018",
                        "content": "[@rahul1995](/rahul1995) Thank you"
                    },
                    {
                        "username": "rahul1995",
                        "content": "I hope everyone who is calling it easy are also doing \"More Actions (...) -> Feedback -> Difficulty is inaccurate\".\\nThe \"More Actions (...)\" button is next to \"Hint\" button."
                    },
                    {
                        "username": "oystermajor",
                        "content": "Imagine being so lucky to get this question at Google lol "
                    },
                    {
                        "username": "rahul1995",
                        "content": "Is Google-mania still not over after all these layoffs?? smh"
                    },
                    {
                        "username": "bhattanrag123",
                        "content": "I'm not reading the discussions again"
                    },
                    {
                        "username": "mint_",
                        "content": "I know right? \n\nI've done a solid number of subarray and permutation questions before and didn't find this problem that intuitive, while I found yesterday's problem pretty easy."
                    },
                    {
                        "username": "Flexiiiii",
                        "content": "[@namandt](/namandt) probably because everyone is saying how easy it is "
                    },
                    {
                        "username": "namandt",
                        "content": "why?\\n"
                    },
                    {
                        "username": "aitachii",
                        "content": "This one was easier compared to yesterday's \"Easy\".\n\nAnyway, here's some clarification for the examples. Excluded elements will be marked as -.\nExample 1: nums = [1,3,0,0,2,0,0,4]\nThere are 2 [0,0] subarrays, these are: \n[-,-,0,0,-,-,-,-], and \n[-,-,-,-,-,0,0,-]\nThere are 4 [0] subarrays:\n[-,-,0,-,-,-,-,-],\n[-,-,-,0,-,-,-,-],\n[-,-,-,-,-,0,-,-], and\n[-,-,-,-,-,-,0,-]\nFor a total of 6.\n\nExample 2: nums = [0,0,0,2,0,0]\nFor the [0,0,0,-,-,-]:\n[0,-,-,-,-,-], +1\n\n[0,0,-,-,-,-], +1\n[-,0,-,-,-,-], +1\n\n[0,0,0,-,-,-], +1\n[-,0,0,-,-,-], +1\n[-,-,0,-,-,-], +1\nFor a subtotal of 6.\n\nFor the [-,-,-,-,0,0]:\n[-,-,-,-,0,-] +1\n\n[-,-,-,-,0,0] +1\n[-,-,-,-,-,0] +1\nFor a subtotal of 3.\n\nIn total, that's 9 zero subarrays."
                    },
                    {
                        "username": "aitachii",
                        "content": "Here\\'s yesterday for reference: https://leetcode.com/problems/can-place-flowers/"
                    },
                    {
                        "username": "user7478F",
                        "content": "seriously."
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "It\\'s too easy? it makes me feel good today."
                    },
                    {
                        "username": "Vizxe",
                        "content": "me too, felt good!"
                    },
                    {
                        "username": "cswartzell",
                        "content": "There really ought to be  a Leetcode section on \"common math tricks\". Knowing things like permutations, combinations, recognizing the triangular numbers and formula can be more relevant than some of the more obscure DSA sections they have"
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "\\u2026 and fill that section with problems like this one, when using such tricks make solutions uglier )))"
                    },
                    {
                        "username": "aditibhagat23",
                        "content": "Remember to store the count of zeros in long to pass all the test cases"
                    },
                    {
                        "username": "19sk99",
                        "content": "thank you so much. Finally my code got accepted after seeing your comment."
                    },
                    {
                        "username": "ashishgulati2112",
                        "content": "That is the only thing that can make it a medium question, lol XD"
                    },
                    {
                        "username": "arajshow",
                        "content": "This is the best way to start your day."
                    },
                    {
                        "username": "santanusen",
                        "content": "# Tip 1:\nWe have a contiguous zero-filled subarray ```S``` of size ```n``` say.\nLet us calculate total how many distinct subarrays (of size k; 1<= k <= n) can be formed out of the subarray ```S```.\n\nLet's think of a sliding window of size ```k``` that slides from the start of the subarray ```S``` until the right edge of the window hits the end of ```S```. \n\n* When ```k = 1```, the start of the sliding window can be placed over each element of ```S```.\n```\n[1] 2  3  4\n 1 [2] 3  4\n 1  2 [3] 4\n 1  2  3 [4]\n```\nThus we have ```n``` distinct subarrays of size 1.\n\n* When ```k = 2``` , the start of the sliding window can be placed over each element of ```S``` except the last.\n```\n[1  2] 3  4\n 1 [2  3] 4\n 1  2 [3  4]\n```\nSo we have ```n - 1``` distinct subarrays of size 2.\n\nAnd so on.\n\nFinally,\n* When ```k = n```, the sliding window covers the entirety of ```S```.\n```\n[1  2   3  4]\n```\nWe have ```1``` subarray of size n.\n\nHence, the total number of distinct subarrays that can be formed out of ```S``` is:\n```\nn + (n - 1) + (n - 2) + ... + 1 =\n((n + 1) * n) / 2\n```\n# Tip 2:\nFor languages supporting different integer sizes beware, the answer may not fit into 32 bits for some test cases. Pay attention to the return type of the function."
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "[@sahle123](/sahle123) sum of natural number series \\n```(1+2+3+4+...n) = n*(n+1)/2 ```"
                    },
                    {
                        "username": "sahle123",
                        "content": "For your first tip, in the last step, how did you arrive to the formula ```((n + 1) * n) / 2```?"
                    },
                    {
                        "username": "AlecLC",
                        "content": "If I got this question in an interview I would have to mute so they wouldn\\'t hear me popping champagne \\uD83C\\uDF7E "
                    }
                ]
            },
            {
                "id": 1839242,
                "content": [
                    {
                        "username": "yogeshvaidya",
                        "content": "should be marked as easy."
                    },
                    {
                        "username": "tyl2018",
                        "content": "[@rahul1995](/rahul1995) Thank you"
                    },
                    {
                        "username": "rahul1995",
                        "content": "I hope everyone who is calling it easy are also doing \"More Actions (...) -> Feedback -> Difficulty is inaccurate\".\\nThe \"More Actions (...)\" button is next to \"Hint\" button."
                    },
                    {
                        "username": "oystermajor",
                        "content": "Imagine being so lucky to get this question at Google lol "
                    },
                    {
                        "username": "rahul1995",
                        "content": "Is Google-mania still not over after all these layoffs?? smh"
                    },
                    {
                        "username": "bhattanrag123",
                        "content": "I'm not reading the discussions again"
                    },
                    {
                        "username": "mint_",
                        "content": "I know right? \n\nI've done a solid number of subarray and permutation questions before and didn't find this problem that intuitive, while I found yesterday's problem pretty easy."
                    },
                    {
                        "username": "Flexiiiii",
                        "content": "[@namandt](/namandt) probably because everyone is saying how easy it is "
                    },
                    {
                        "username": "namandt",
                        "content": "why?\\n"
                    },
                    {
                        "username": "aitachii",
                        "content": "This one was easier compared to yesterday's \"Easy\".\n\nAnyway, here's some clarification for the examples. Excluded elements will be marked as -.\nExample 1: nums = [1,3,0,0,2,0,0,4]\nThere are 2 [0,0] subarrays, these are: \n[-,-,0,0,-,-,-,-], and \n[-,-,-,-,-,0,0,-]\nThere are 4 [0] subarrays:\n[-,-,0,-,-,-,-,-],\n[-,-,-,0,-,-,-,-],\n[-,-,-,-,-,0,-,-], and\n[-,-,-,-,-,-,0,-]\nFor a total of 6.\n\nExample 2: nums = [0,0,0,2,0,0]\nFor the [0,0,0,-,-,-]:\n[0,-,-,-,-,-], +1\n\n[0,0,-,-,-,-], +1\n[-,0,-,-,-,-], +1\n\n[0,0,0,-,-,-], +1\n[-,0,0,-,-,-], +1\n[-,-,0,-,-,-], +1\nFor a subtotal of 6.\n\nFor the [-,-,-,-,0,0]:\n[-,-,-,-,0,-] +1\n\n[-,-,-,-,0,0] +1\n[-,-,-,-,-,0] +1\nFor a subtotal of 3.\n\nIn total, that's 9 zero subarrays."
                    },
                    {
                        "username": "aitachii",
                        "content": "Here\\'s yesterday for reference: https://leetcode.com/problems/can-place-flowers/"
                    },
                    {
                        "username": "user7478F",
                        "content": "seriously."
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "It\\'s too easy? it makes me feel good today."
                    },
                    {
                        "username": "Vizxe",
                        "content": "me too, felt good!"
                    },
                    {
                        "username": "cswartzell",
                        "content": "There really ought to be  a Leetcode section on \"common math tricks\". Knowing things like permutations, combinations, recognizing the triangular numbers and formula can be more relevant than some of the more obscure DSA sections they have"
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "\\u2026 and fill that section with problems like this one, when using such tricks make solutions uglier )))"
                    },
                    {
                        "username": "aditibhagat23",
                        "content": "Remember to store the count of zeros in long to pass all the test cases"
                    },
                    {
                        "username": "19sk99",
                        "content": "thank you so much. Finally my code got accepted after seeing your comment."
                    },
                    {
                        "username": "ashishgulati2112",
                        "content": "That is the only thing that can make it a medium question, lol XD"
                    },
                    {
                        "username": "arajshow",
                        "content": "This is the best way to start your day."
                    },
                    {
                        "username": "santanusen",
                        "content": "# Tip 1:\nWe have a contiguous zero-filled subarray ```S``` of size ```n``` say.\nLet us calculate total how many distinct subarrays (of size k; 1<= k <= n) can be formed out of the subarray ```S```.\n\nLet's think of a sliding window of size ```k``` that slides from the start of the subarray ```S``` until the right edge of the window hits the end of ```S```. \n\n* When ```k = 1```, the start of the sliding window can be placed over each element of ```S```.\n```\n[1] 2  3  4\n 1 [2] 3  4\n 1  2 [3] 4\n 1  2  3 [4]\n```\nThus we have ```n``` distinct subarrays of size 1.\n\n* When ```k = 2``` , the start of the sliding window can be placed over each element of ```S``` except the last.\n```\n[1  2] 3  4\n 1 [2  3] 4\n 1  2 [3  4]\n```\nSo we have ```n - 1``` distinct subarrays of size 2.\n\nAnd so on.\n\nFinally,\n* When ```k = n```, the sliding window covers the entirety of ```S```.\n```\n[1  2   3  4]\n```\nWe have ```1``` subarray of size n.\n\nHence, the total number of distinct subarrays that can be formed out of ```S``` is:\n```\nn + (n - 1) + (n - 2) + ... + 1 =\n((n + 1) * n) / 2\n```\n# Tip 2:\nFor languages supporting different integer sizes beware, the answer may not fit into 32 bits for some test cases. Pay attention to the return type of the function."
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "[@sahle123](/sahle123) sum of natural number series \\n```(1+2+3+4+...n) = n*(n+1)/2 ```"
                    },
                    {
                        "username": "sahle123",
                        "content": "For your first tip, in the last step, how did you arrive to the formula ```((n + 1) * n) / 2```?"
                    },
                    {
                        "username": "AlecLC",
                        "content": "If I got this question in an interview I would have to mute so they wouldn\\'t hear me popping champagne \\uD83C\\uDF7E "
                    }
                ]
            },
            {
                "id": 1839112,
                "content": [
                    {
                        "username": "yogeshvaidya",
                        "content": "should be marked as easy."
                    },
                    {
                        "username": "tyl2018",
                        "content": "[@rahul1995](/rahul1995) Thank you"
                    },
                    {
                        "username": "rahul1995",
                        "content": "I hope everyone who is calling it easy are also doing \"More Actions (...) -> Feedback -> Difficulty is inaccurate\".\\nThe \"More Actions (...)\" button is next to \"Hint\" button."
                    },
                    {
                        "username": "oystermajor",
                        "content": "Imagine being so lucky to get this question at Google lol "
                    },
                    {
                        "username": "rahul1995",
                        "content": "Is Google-mania still not over after all these layoffs?? smh"
                    },
                    {
                        "username": "bhattanrag123",
                        "content": "I'm not reading the discussions again"
                    },
                    {
                        "username": "mint_",
                        "content": "I know right? \n\nI've done a solid number of subarray and permutation questions before and didn't find this problem that intuitive, while I found yesterday's problem pretty easy."
                    },
                    {
                        "username": "Flexiiiii",
                        "content": "[@namandt](/namandt) probably because everyone is saying how easy it is "
                    },
                    {
                        "username": "namandt",
                        "content": "why?\\n"
                    },
                    {
                        "username": "aitachii",
                        "content": "This one was easier compared to yesterday's \"Easy\".\n\nAnyway, here's some clarification for the examples. Excluded elements will be marked as -.\nExample 1: nums = [1,3,0,0,2,0,0,4]\nThere are 2 [0,0] subarrays, these are: \n[-,-,0,0,-,-,-,-], and \n[-,-,-,-,-,0,0,-]\nThere are 4 [0] subarrays:\n[-,-,0,-,-,-,-,-],\n[-,-,-,0,-,-,-,-],\n[-,-,-,-,-,0,-,-], and\n[-,-,-,-,-,-,0,-]\nFor a total of 6.\n\nExample 2: nums = [0,0,0,2,0,0]\nFor the [0,0,0,-,-,-]:\n[0,-,-,-,-,-], +1\n\n[0,0,-,-,-,-], +1\n[-,0,-,-,-,-], +1\n\n[0,0,0,-,-,-], +1\n[-,0,0,-,-,-], +1\n[-,-,0,-,-,-], +1\nFor a subtotal of 6.\n\nFor the [-,-,-,-,0,0]:\n[-,-,-,-,0,-] +1\n\n[-,-,-,-,0,0] +1\n[-,-,-,-,-,0] +1\nFor a subtotal of 3.\n\nIn total, that's 9 zero subarrays."
                    },
                    {
                        "username": "aitachii",
                        "content": "Here\\'s yesterday for reference: https://leetcode.com/problems/can-place-flowers/"
                    },
                    {
                        "username": "user7478F",
                        "content": "seriously."
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "It\\'s too easy? it makes me feel good today."
                    },
                    {
                        "username": "Vizxe",
                        "content": "me too, felt good!"
                    },
                    {
                        "username": "cswartzell",
                        "content": "There really ought to be  a Leetcode section on \"common math tricks\". Knowing things like permutations, combinations, recognizing the triangular numbers and formula can be more relevant than some of the more obscure DSA sections they have"
                    },
                    {
                        "username": "askold_ilvento",
                        "content": "\\u2026 and fill that section with problems like this one, when using such tricks make solutions uglier )))"
                    },
                    {
                        "username": "aditibhagat23",
                        "content": "Remember to store the count of zeros in long to pass all the test cases"
                    },
                    {
                        "username": "19sk99",
                        "content": "thank you so much. Finally my code got accepted after seeing your comment."
                    },
                    {
                        "username": "ashishgulati2112",
                        "content": "That is the only thing that can make it a medium question, lol XD"
                    },
                    {
                        "username": "arajshow",
                        "content": "This is the best way to start your day."
                    },
                    {
                        "username": "santanusen",
                        "content": "# Tip 1:\nWe have a contiguous zero-filled subarray ```S``` of size ```n``` say.\nLet us calculate total how many distinct subarrays (of size k; 1<= k <= n) can be formed out of the subarray ```S```.\n\nLet's think of a sliding window of size ```k``` that slides from the start of the subarray ```S``` until the right edge of the window hits the end of ```S```. \n\n* When ```k = 1```, the start of the sliding window can be placed over each element of ```S```.\n```\n[1] 2  3  4\n 1 [2] 3  4\n 1  2 [3] 4\n 1  2  3 [4]\n```\nThus we have ```n``` distinct subarrays of size 1.\n\n* When ```k = 2``` , the start of the sliding window can be placed over each element of ```S``` except the last.\n```\n[1  2] 3  4\n 1 [2  3] 4\n 1  2 [3  4]\n```\nSo we have ```n - 1``` distinct subarrays of size 2.\n\nAnd so on.\n\nFinally,\n* When ```k = n```, the sliding window covers the entirety of ```S```.\n```\n[1  2   3  4]\n```\nWe have ```1``` subarray of size n.\n\nHence, the total number of distinct subarrays that can be formed out of ```S``` is:\n```\nn + (n - 1) + (n - 2) + ... + 1 =\n((n + 1) * n) / 2\n```\n# Tip 2:\nFor languages supporting different integer sizes beware, the answer may not fit into 32 bits for some test cases. Pay attention to the return type of the function."
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "[@sahle123](/sahle123) sum of natural number series \\n```(1+2+3+4+...n) = n*(n+1)/2 ```"
                    },
                    {
                        "username": "sahle123",
                        "content": "For your first tip, in the last step, how did you arrive to the formula ```((n + 1) * n) / 2```?"
                    },
                    {
                        "username": "AlecLC",
                        "content": "If I got this question in an interview I would have to mute so they wouldn\\'t hear me popping champagne \\uD83C\\uDF7E "
                    }
                ]
            },
            {
                "id": 1840507,
                "content": [
                    {
                        "username": "Godwin_NG",
                        "content": "It\\'s a math problem. All math questions are easy if you know the solution or method or formulae beforehand.\\n\\nFor [math] geeks: EASY  (provided they know the solution, method or formulae)\\nFor everyone else: NOT EASY"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Exactly"
                    },
                    {
                        "username": "allali",
                        "content": "why does this testcase \"[0,1,0,0,1,0,0,0]\" cause a stackoverflow ?? i tried it on cpp shell and it works but in leetcode it gives a stack overflow ? "
                    },
                    {
                        "username": "HKii",
                        "content": "I have a problem: my code is ok and output is correct according to Visualizer and PyCharm as least, but as copy-pasted the same code in Leet gives different output. Suggestions?\n\nThis is the code btw:\n        numbs = [1] + nums + [1]\n        subArrs = 0\n        cur = 0\n        for n in numbs:\n            if n == 0:\n                cur += 1\n            elif n != 0:\n                if cur != 0:\n                    subArrs += int(cur*((cur+1)/2))\n                    cur = 0\n        return subArrs"
                    },
                    {
                        "username": "HKii",
                        "content": "[@qazFatNerd](/qazFatNerd) Thank you! It made me crazy."
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "Change the subArrs.\\nsubArrs += int(cur*(cur+1)/2)\\n\\nBecause python compute (cur+1)/2) first, and it becomes a int.\\n\\nEX: print((2+1)/2) # == 1"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "Calculate the continuous zeros and keep on storing it into ans variable if there are no continuous zeros then we will reset the count variable to zero.\\n\\nclass Solution {\\n    public long zeroFilledSubarray(int[] nums) {\\n        \\n        long count = 0;\\n        long ans = 0;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==0){\\n              count++;\\n              ans += count;\\n            }else count=0;\\n        }\\n       \\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "charonme",
                        "content": "[@namandt](/namandt) it is enough when you add the count to the answer every time you increment the count. It gives the same result as adding (cnt * (cnt + 1)) / 2 to the answer after the end of each sequence of zeroes. Try it, it works."
                    },
                    {
                        "username": "namandt",
                        "content": "btw, I was ex-DSE at Infosys."
                    },
                    {
                        "username": "namandt",
                        "content": "nope.\\ncounting is not enough!\\nthis is wrong answer."
                    },
                    {
                        "username": "anirudhkulkarni9094",
                        "content": "How about we find the length of subarray containing only zero and using length to apply the formula : \\n`(N(N+1))/2` \\nand adding it to total\\ne.g.\\nfor length of 1: \\nvalue will be 1\\nfor 2 , value is 3\\nfor 3, value is 6 and so on\\n\\nnot the most optimistic solution but we can use mathematical formula to solve this question."
                    },
                    {
                        "username": "namandt",
                        "content": "thats what I have done..i think its the only solution"
                    },
                    {
                        "username": "Tusharpanwar",
                        "content": "Can such type of easy question come in the interview?"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "Just count the number of consecutive zeros and use n(n+1)/2.\nsimple.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n\nactually, mujse bhi pahli baar m nhi hua tha😜"
                    },
                    {
                        "username": "161_shaa_",
                        "content": "can someone please explain why is it failing at 46th test case out of 48 total cases\\n\\nlong ans=0;\\n        \\n        int i=0;\\n        int j=0;\\n\\n        while(j<nums.length){\\n            \\n            if(nums[j]!=0){\\n                i++;\\n                j++;\\n            }\\n\\n            else if(nums[j]==0){\\n\\n                i=j;\\n                while(j<nums.length&& nums[j]==0 ){\\n                    j++;\\n                }\\n\\n                int number=j-i;\\n                i=j;\\n                long num=(number)*((number+1))/2;\\n\\n                ans+=num;\\n\\n\\n            }\\n\\n        }\\n\\n        return ans;"
                    },
                    {
                        "username": "lDagothUrl",
                        "content": "Example 2:\\n\\nInput: nums = [0,0,0,2,0,0]\\nOutput: 9\\nExplanation:\\nThere are 5 occurrences of [0] as a subarray.\\nThere are 3 occurrences of [0,0] as a subarray.\\nThere is 1 occurrence of [0,0,0] as a subarray.\\nThere is no occurrence of a subarray with a size more than 3 filled with 0. Therefore, we return 9.\\n\\nOutput: 10*\\n5[0]+4[0]+1[0]=10\\n\\n9???"
                    },
                    {
                        "username": "jolswlf",
                        "content": "what do you mean by this? leetcode\\'s expected answer for this input is 9 as you explained. "
                    },
                    {
                        "username": "eark",
                        "content": "Compared brute force sum of digits from 1 to N, and the arithmetic progression formula ((N - M + 1)*(N+M)/2 to calculate number of sub-arrays. But there is no difference in runtime and both is around 160ms. In worst case, the latter will save full iteration up to 10^5, but why there is no difference in runtime?"
                    }
                ]
            },
            {
                "id": 1839466,
                "content": [
                    {
                        "username": "Godwin_NG",
                        "content": "It\\'s a math problem. All math questions are easy if you know the solution or method or formulae beforehand.\\n\\nFor [math] geeks: EASY  (provided they know the solution, method or formulae)\\nFor everyone else: NOT EASY"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Exactly"
                    },
                    {
                        "username": "allali",
                        "content": "why does this testcase \"[0,1,0,0,1,0,0,0]\" cause a stackoverflow ?? i tried it on cpp shell and it works but in leetcode it gives a stack overflow ? "
                    },
                    {
                        "username": "HKii",
                        "content": "I have a problem: my code is ok and output is correct according to Visualizer and PyCharm as least, but as copy-pasted the same code in Leet gives different output. Suggestions?\n\nThis is the code btw:\n        numbs = [1] + nums + [1]\n        subArrs = 0\n        cur = 0\n        for n in numbs:\n            if n == 0:\n                cur += 1\n            elif n != 0:\n                if cur != 0:\n                    subArrs += int(cur*((cur+1)/2))\n                    cur = 0\n        return subArrs"
                    },
                    {
                        "username": "HKii",
                        "content": "[@qazFatNerd](/qazFatNerd) Thank you! It made me crazy."
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "Change the subArrs.\\nsubArrs += int(cur*(cur+1)/2)\\n\\nBecause python compute (cur+1)/2) first, and it becomes a int.\\n\\nEX: print((2+1)/2) # == 1"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "Calculate the continuous zeros and keep on storing it into ans variable if there are no continuous zeros then we will reset the count variable to zero.\\n\\nclass Solution {\\n    public long zeroFilledSubarray(int[] nums) {\\n        \\n        long count = 0;\\n        long ans = 0;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==0){\\n              count++;\\n              ans += count;\\n            }else count=0;\\n        }\\n       \\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "charonme",
                        "content": "[@namandt](/namandt) it is enough when you add the count to the answer every time you increment the count. It gives the same result as adding (cnt * (cnt + 1)) / 2 to the answer after the end of each sequence of zeroes. Try it, it works."
                    },
                    {
                        "username": "namandt",
                        "content": "btw, I was ex-DSE at Infosys."
                    },
                    {
                        "username": "namandt",
                        "content": "nope.\\ncounting is not enough!\\nthis is wrong answer."
                    },
                    {
                        "username": "anirudhkulkarni9094",
                        "content": "How about we find the length of subarray containing only zero and using length to apply the formula : \\n`(N(N+1))/2` \\nand adding it to total\\ne.g.\\nfor length of 1: \\nvalue will be 1\\nfor 2 , value is 3\\nfor 3, value is 6 and so on\\n\\nnot the most optimistic solution but we can use mathematical formula to solve this question."
                    },
                    {
                        "username": "namandt",
                        "content": "thats what I have done..i think its the only solution"
                    },
                    {
                        "username": "Tusharpanwar",
                        "content": "Can such type of easy question come in the interview?"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "Just count the number of consecutive zeros and use n(n+1)/2.\nsimple.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n\nactually, mujse bhi pahli baar m nhi hua tha😜"
                    },
                    {
                        "username": "161_shaa_",
                        "content": "can someone please explain why is it failing at 46th test case out of 48 total cases\\n\\nlong ans=0;\\n        \\n        int i=0;\\n        int j=0;\\n\\n        while(j<nums.length){\\n            \\n            if(nums[j]!=0){\\n                i++;\\n                j++;\\n            }\\n\\n            else if(nums[j]==0){\\n\\n                i=j;\\n                while(j<nums.length&& nums[j]==0 ){\\n                    j++;\\n                }\\n\\n                int number=j-i;\\n                i=j;\\n                long num=(number)*((number+1))/2;\\n\\n                ans+=num;\\n\\n\\n            }\\n\\n        }\\n\\n        return ans;"
                    },
                    {
                        "username": "lDagothUrl",
                        "content": "Example 2:\\n\\nInput: nums = [0,0,0,2,0,0]\\nOutput: 9\\nExplanation:\\nThere are 5 occurrences of [0] as a subarray.\\nThere are 3 occurrences of [0,0] as a subarray.\\nThere is 1 occurrence of [0,0,0] as a subarray.\\nThere is no occurrence of a subarray with a size more than 3 filled with 0. Therefore, we return 9.\\n\\nOutput: 10*\\n5[0]+4[0]+1[0]=10\\n\\n9???"
                    },
                    {
                        "username": "jolswlf",
                        "content": "what do you mean by this? leetcode\\'s expected answer for this input is 9 as you explained. "
                    },
                    {
                        "username": "eark",
                        "content": "Compared brute force sum of digits from 1 to N, and the arithmetic progression formula ((N - M + 1)*(N+M)/2 to calculate number of sub-arrays. But there is no difference in runtime and both is around 160ms. In worst case, the latter will save full iteration up to 10^5, but why there is no difference in runtime?"
                    }
                ]
            },
            {
                "id": 1839407,
                "content": [
                    {
                        "username": "Godwin_NG",
                        "content": "It\\'s a math problem. All math questions are easy if you know the solution or method or formulae beforehand.\\n\\nFor [math] geeks: EASY  (provided they know the solution, method or formulae)\\nFor everyone else: NOT EASY"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Exactly"
                    },
                    {
                        "username": "allali",
                        "content": "why does this testcase \"[0,1,0,0,1,0,0,0]\" cause a stackoverflow ?? i tried it on cpp shell and it works but in leetcode it gives a stack overflow ? "
                    },
                    {
                        "username": "HKii",
                        "content": "I have a problem: my code is ok and output is correct according to Visualizer and PyCharm as least, but as copy-pasted the same code in Leet gives different output. Suggestions?\n\nThis is the code btw:\n        numbs = [1] + nums + [1]\n        subArrs = 0\n        cur = 0\n        for n in numbs:\n            if n == 0:\n                cur += 1\n            elif n != 0:\n                if cur != 0:\n                    subArrs += int(cur*((cur+1)/2))\n                    cur = 0\n        return subArrs"
                    },
                    {
                        "username": "HKii",
                        "content": "[@qazFatNerd](/qazFatNerd) Thank you! It made me crazy."
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "Change the subArrs.\\nsubArrs += int(cur*(cur+1)/2)\\n\\nBecause python compute (cur+1)/2) first, and it becomes a int.\\n\\nEX: print((2+1)/2) # == 1"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "Calculate the continuous zeros and keep on storing it into ans variable if there are no continuous zeros then we will reset the count variable to zero.\\n\\nclass Solution {\\n    public long zeroFilledSubarray(int[] nums) {\\n        \\n        long count = 0;\\n        long ans = 0;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==0){\\n              count++;\\n              ans += count;\\n            }else count=0;\\n        }\\n       \\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "charonme",
                        "content": "[@namandt](/namandt) it is enough when you add the count to the answer every time you increment the count. It gives the same result as adding (cnt * (cnt + 1)) / 2 to the answer after the end of each sequence of zeroes. Try it, it works."
                    },
                    {
                        "username": "namandt",
                        "content": "btw, I was ex-DSE at Infosys."
                    },
                    {
                        "username": "namandt",
                        "content": "nope.\\ncounting is not enough!\\nthis is wrong answer."
                    },
                    {
                        "username": "anirudhkulkarni9094",
                        "content": "How about we find the length of subarray containing only zero and using length to apply the formula : \\n`(N(N+1))/2` \\nand adding it to total\\ne.g.\\nfor length of 1: \\nvalue will be 1\\nfor 2 , value is 3\\nfor 3, value is 6 and so on\\n\\nnot the most optimistic solution but we can use mathematical formula to solve this question."
                    },
                    {
                        "username": "namandt",
                        "content": "thats what I have done..i think its the only solution"
                    },
                    {
                        "username": "Tusharpanwar",
                        "content": "Can such type of easy question come in the interview?"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "Just count the number of consecutive zeros and use n(n+1)/2.\nsimple.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n\nactually, mujse bhi pahli baar m nhi hua tha😜"
                    },
                    {
                        "username": "161_shaa_",
                        "content": "can someone please explain why is it failing at 46th test case out of 48 total cases\\n\\nlong ans=0;\\n        \\n        int i=0;\\n        int j=0;\\n\\n        while(j<nums.length){\\n            \\n            if(nums[j]!=0){\\n                i++;\\n                j++;\\n            }\\n\\n            else if(nums[j]==0){\\n\\n                i=j;\\n                while(j<nums.length&& nums[j]==0 ){\\n                    j++;\\n                }\\n\\n                int number=j-i;\\n                i=j;\\n                long num=(number)*((number+1))/2;\\n\\n                ans+=num;\\n\\n\\n            }\\n\\n        }\\n\\n        return ans;"
                    },
                    {
                        "username": "lDagothUrl",
                        "content": "Example 2:\\n\\nInput: nums = [0,0,0,2,0,0]\\nOutput: 9\\nExplanation:\\nThere are 5 occurrences of [0] as a subarray.\\nThere are 3 occurrences of [0,0] as a subarray.\\nThere is 1 occurrence of [0,0,0] as a subarray.\\nThere is no occurrence of a subarray with a size more than 3 filled with 0. Therefore, we return 9.\\n\\nOutput: 10*\\n5[0]+4[0]+1[0]=10\\n\\n9???"
                    },
                    {
                        "username": "jolswlf",
                        "content": "what do you mean by this? leetcode\\'s expected answer for this input is 9 as you explained. "
                    },
                    {
                        "username": "eark",
                        "content": "Compared brute force sum of digits from 1 to N, and the arithmetic progression formula ((N - M + 1)*(N+M)/2 to calculate number of sub-arrays. But there is no difference in runtime and both is around 160ms. In worst case, the latter will save full iteration up to 10^5, but why there is no difference in runtime?"
                    }
                ]
            },
            {
                "id": 1839190,
                "content": [
                    {
                        "username": "Godwin_NG",
                        "content": "It\\'s a math problem. All math questions are easy if you know the solution or method or formulae beforehand.\\n\\nFor [math] geeks: EASY  (provided they know the solution, method or formulae)\\nFor everyone else: NOT EASY"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Exactly"
                    },
                    {
                        "username": "allali",
                        "content": "why does this testcase \"[0,1,0,0,1,0,0,0]\" cause a stackoverflow ?? i tried it on cpp shell and it works but in leetcode it gives a stack overflow ? "
                    },
                    {
                        "username": "HKii",
                        "content": "I have a problem: my code is ok and output is correct according to Visualizer and PyCharm as least, but as copy-pasted the same code in Leet gives different output. Suggestions?\n\nThis is the code btw:\n        numbs = [1] + nums + [1]\n        subArrs = 0\n        cur = 0\n        for n in numbs:\n            if n == 0:\n                cur += 1\n            elif n != 0:\n                if cur != 0:\n                    subArrs += int(cur*((cur+1)/2))\n                    cur = 0\n        return subArrs"
                    },
                    {
                        "username": "HKii",
                        "content": "[@qazFatNerd](/qazFatNerd) Thank you! It made me crazy."
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "Change the subArrs.\\nsubArrs += int(cur*(cur+1)/2)\\n\\nBecause python compute (cur+1)/2) first, and it becomes a int.\\n\\nEX: print((2+1)/2) # == 1"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "Calculate the continuous zeros and keep on storing it into ans variable if there are no continuous zeros then we will reset the count variable to zero.\\n\\nclass Solution {\\n    public long zeroFilledSubarray(int[] nums) {\\n        \\n        long count = 0;\\n        long ans = 0;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==0){\\n              count++;\\n              ans += count;\\n            }else count=0;\\n        }\\n       \\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "charonme",
                        "content": "[@namandt](/namandt) it is enough when you add the count to the answer every time you increment the count. It gives the same result as adding (cnt * (cnt + 1)) / 2 to the answer after the end of each sequence of zeroes. Try it, it works."
                    },
                    {
                        "username": "namandt",
                        "content": "btw, I was ex-DSE at Infosys."
                    },
                    {
                        "username": "namandt",
                        "content": "nope.\\ncounting is not enough!\\nthis is wrong answer."
                    },
                    {
                        "username": "anirudhkulkarni9094",
                        "content": "How about we find the length of subarray containing only zero and using length to apply the formula : \\n`(N(N+1))/2` \\nand adding it to total\\ne.g.\\nfor length of 1: \\nvalue will be 1\\nfor 2 , value is 3\\nfor 3, value is 6 and so on\\n\\nnot the most optimistic solution but we can use mathematical formula to solve this question."
                    },
                    {
                        "username": "namandt",
                        "content": "thats what I have done..i think its the only solution"
                    },
                    {
                        "username": "Tusharpanwar",
                        "content": "Can such type of easy question come in the interview?"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "Just count the number of consecutive zeros and use n(n+1)/2.\nsimple.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n\nactually, mujse bhi pahli baar m nhi hua tha😜"
                    },
                    {
                        "username": "161_shaa_",
                        "content": "can someone please explain why is it failing at 46th test case out of 48 total cases\\n\\nlong ans=0;\\n        \\n        int i=0;\\n        int j=0;\\n\\n        while(j<nums.length){\\n            \\n            if(nums[j]!=0){\\n                i++;\\n                j++;\\n            }\\n\\n            else if(nums[j]==0){\\n\\n                i=j;\\n                while(j<nums.length&& nums[j]==0 ){\\n                    j++;\\n                }\\n\\n                int number=j-i;\\n                i=j;\\n                long num=(number)*((number+1))/2;\\n\\n                ans+=num;\\n\\n\\n            }\\n\\n        }\\n\\n        return ans;"
                    },
                    {
                        "username": "lDagothUrl",
                        "content": "Example 2:\\n\\nInput: nums = [0,0,0,2,0,0]\\nOutput: 9\\nExplanation:\\nThere are 5 occurrences of [0] as a subarray.\\nThere are 3 occurrences of [0,0] as a subarray.\\nThere is 1 occurrence of [0,0,0] as a subarray.\\nThere is no occurrence of a subarray with a size more than 3 filled with 0. Therefore, we return 9.\\n\\nOutput: 10*\\n5[0]+4[0]+1[0]=10\\n\\n9???"
                    },
                    {
                        "username": "jolswlf",
                        "content": "what do you mean by this? leetcode\\'s expected answer for this input is 9 as you explained. "
                    },
                    {
                        "username": "eark",
                        "content": "Compared brute force sum of digits from 1 to N, and the arithmetic progression formula ((N - M + 1)*(N+M)/2 to calculate number of sub-arrays. But there is no difference in runtime and both is around 160ms. In worst case, the latter will save full iteration up to 10^5, but why there is no difference in runtime?"
                    }
                ]
            },
            {
                "id": 1839180,
                "content": [
                    {
                        "username": "Godwin_NG",
                        "content": "It\\'s a math problem. All math questions are easy if you know the solution or method or formulae beforehand.\\n\\nFor [math] geeks: EASY  (provided they know the solution, method or formulae)\\nFor everyone else: NOT EASY"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Exactly"
                    },
                    {
                        "username": "allali",
                        "content": "why does this testcase \"[0,1,0,0,1,0,0,0]\" cause a stackoverflow ?? i tried it on cpp shell and it works but in leetcode it gives a stack overflow ? "
                    },
                    {
                        "username": "HKii",
                        "content": "I have a problem: my code is ok and output is correct according to Visualizer and PyCharm as least, but as copy-pasted the same code in Leet gives different output. Suggestions?\n\nThis is the code btw:\n        numbs = [1] + nums + [1]\n        subArrs = 0\n        cur = 0\n        for n in numbs:\n            if n == 0:\n                cur += 1\n            elif n != 0:\n                if cur != 0:\n                    subArrs += int(cur*((cur+1)/2))\n                    cur = 0\n        return subArrs"
                    },
                    {
                        "username": "HKii",
                        "content": "[@qazFatNerd](/qazFatNerd) Thank you! It made me crazy."
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "Change the subArrs.\\nsubArrs += int(cur*(cur+1)/2)\\n\\nBecause python compute (cur+1)/2) first, and it becomes a int.\\n\\nEX: print((2+1)/2) # == 1"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "Calculate the continuous zeros and keep on storing it into ans variable if there are no continuous zeros then we will reset the count variable to zero.\\n\\nclass Solution {\\n    public long zeroFilledSubarray(int[] nums) {\\n        \\n        long count = 0;\\n        long ans = 0;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==0){\\n              count++;\\n              ans += count;\\n            }else count=0;\\n        }\\n       \\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "charonme",
                        "content": "[@namandt](/namandt) it is enough when you add the count to the answer every time you increment the count. It gives the same result as adding (cnt * (cnt + 1)) / 2 to the answer after the end of each sequence of zeroes. Try it, it works."
                    },
                    {
                        "username": "namandt",
                        "content": "btw, I was ex-DSE at Infosys."
                    },
                    {
                        "username": "namandt",
                        "content": "nope.\\ncounting is not enough!\\nthis is wrong answer."
                    },
                    {
                        "username": "anirudhkulkarni9094",
                        "content": "How about we find the length of subarray containing only zero and using length to apply the formula : \\n`(N(N+1))/2` \\nand adding it to total\\ne.g.\\nfor length of 1: \\nvalue will be 1\\nfor 2 , value is 3\\nfor 3, value is 6 and so on\\n\\nnot the most optimistic solution but we can use mathematical formula to solve this question."
                    },
                    {
                        "username": "namandt",
                        "content": "thats what I have done..i think its the only solution"
                    },
                    {
                        "username": "Tusharpanwar",
                        "content": "Can such type of easy question come in the interview?"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "Just count the number of consecutive zeros and use n(n+1)/2.\nsimple.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n\nactually, mujse bhi pahli baar m nhi hua tha😜"
                    },
                    {
                        "username": "161_shaa_",
                        "content": "can someone please explain why is it failing at 46th test case out of 48 total cases\\n\\nlong ans=0;\\n        \\n        int i=0;\\n        int j=0;\\n\\n        while(j<nums.length){\\n            \\n            if(nums[j]!=0){\\n                i++;\\n                j++;\\n            }\\n\\n            else if(nums[j]==0){\\n\\n                i=j;\\n                while(j<nums.length&& nums[j]==0 ){\\n                    j++;\\n                }\\n\\n                int number=j-i;\\n                i=j;\\n                long num=(number)*((number+1))/2;\\n\\n                ans+=num;\\n\\n\\n            }\\n\\n        }\\n\\n        return ans;"
                    },
                    {
                        "username": "lDagothUrl",
                        "content": "Example 2:\\n\\nInput: nums = [0,0,0,2,0,0]\\nOutput: 9\\nExplanation:\\nThere are 5 occurrences of [0] as a subarray.\\nThere are 3 occurrences of [0,0] as a subarray.\\nThere is 1 occurrence of [0,0,0] as a subarray.\\nThere is no occurrence of a subarray with a size more than 3 filled with 0. Therefore, we return 9.\\n\\nOutput: 10*\\n5[0]+4[0]+1[0]=10\\n\\n9???"
                    },
                    {
                        "username": "jolswlf",
                        "content": "what do you mean by this? leetcode\\'s expected answer for this input is 9 as you explained. "
                    },
                    {
                        "username": "eark",
                        "content": "Compared brute force sum of digits from 1 to N, and the arithmetic progression formula ((N - M + 1)*(N+M)/2 to calculate number of sub-arrays. But there is no difference in runtime and both is around 160ms. In worst case, the latter will save full iteration up to 10^5, but why there is no difference in runtime?"
                    }
                ]
            },
            {
                "id": 2017694,
                "content": [
                    {
                        "username": "Godwin_NG",
                        "content": "It\\'s a math problem. All math questions are easy if you know the solution or method or formulae beforehand.\\n\\nFor [math] geeks: EASY  (provided they know the solution, method or formulae)\\nFor everyone else: NOT EASY"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Exactly"
                    },
                    {
                        "username": "allali",
                        "content": "why does this testcase \"[0,1,0,0,1,0,0,0]\" cause a stackoverflow ?? i tried it on cpp shell and it works but in leetcode it gives a stack overflow ? "
                    },
                    {
                        "username": "HKii",
                        "content": "I have a problem: my code is ok and output is correct according to Visualizer and PyCharm as least, but as copy-pasted the same code in Leet gives different output. Suggestions?\n\nThis is the code btw:\n        numbs = [1] + nums + [1]\n        subArrs = 0\n        cur = 0\n        for n in numbs:\n            if n == 0:\n                cur += 1\n            elif n != 0:\n                if cur != 0:\n                    subArrs += int(cur*((cur+1)/2))\n                    cur = 0\n        return subArrs"
                    },
                    {
                        "username": "HKii",
                        "content": "[@qazFatNerd](/qazFatNerd) Thank you! It made me crazy."
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "Change the subArrs.\\nsubArrs += int(cur*(cur+1)/2)\\n\\nBecause python compute (cur+1)/2) first, and it becomes a int.\\n\\nEX: print((2+1)/2) # == 1"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "Calculate the continuous zeros and keep on storing it into ans variable if there are no continuous zeros then we will reset the count variable to zero.\\n\\nclass Solution {\\n    public long zeroFilledSubarray(int[] nums) {\\n        \\n        long count = 0;\\n        long ans = 0;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==0){\\n              count++;\\n              ans += count;\\n            }else count=0;\\n        }\\n       \\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "charonme",
                        "content": "[@namandt](/namandt) it is enough when you add the count to the answer every time you increment the count. It gives the same result as adding (cnt * (cnt + 1)) / 2 to the answer after the end of each sequence of zeroes. Try it, it works."
                    },
                    {
                        "username": "namandt",
                        "content": "btw, I was ex-DSE at Infosys."
                    },
                    {
                        "username": "namandt",
                        "content": "nope.\\ncounting is not enough!\\nthis is wrong answer."
                    },
                    {
                        "username": "anirudhkulkarni9094",
                        "content": "How about we find the length of subarray containing only zero and using length to apply the formula : \\n`(N(N+1))/2` \\nand adding it to total\\ne.g.\\nfor length of 1: \\nvalue will be 1\\nfor 2 , value is 3\\nfor 3, value is 6 and so on\\n\\nnot the most optimistic solution but we can use mathematical formula to solve this question."
                    },
                    {
                        "username": "namandt",
                        "content": "thats what I have done..i think its the only solution"
                    },
                    {
                        "username": "Tusharpanwar",
                        "content": "Can such type of easy question come in the interview?"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "Just count the number of consecutive zeros and use n(n+1)/2.\nsimple.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n\nactually, mujse bhi pahli baar m nhi hua tha😜"
                    },
                    {
                        "username": "161_shaa_",
                        "content": "can someone please explain why is it failing at 46th test case out of 48 total cases\\n\\nlong ans=0;\\n        \\n        int i=0;\\n        int j=0;\\n\\n        while(j<nums.length){\\n            \\n            if(nums[j]!=0){\\n                i++;\\n                j++;\\n            }\\n\\n            else if(nums[j]==0){\\n\\n                i=j;\\n                while(j<nums.length&& nums[j]==0 ){\\n                    j++;\\n                }\\n\\n                int number=j-i;\\n                i=j;\\n                long num=(number)*((number+1))/2;\\n\\n                ans+=num;\\n\\n\\n            }\\n\\n        }\\n\\n        return ans;"
                    },
                    {
                        "username": "lDagothUrl",
                        "content": "Example 2:\\n\\nInput: nums = [0,0,0,2,0,0]\\nOutput: 9\\nExplanation:\\nThere are 5 occurrences of [0] as a subarray.\\nThere are 3 occurrences of [0,0] as a subarray.\\nThere is 1 occurrence of [0,0,0] as a subarray.\\nThere is no occurrence of a subarray with a size more than 3 filled with 0. Therefore, we return 9.\\n\\nOutput: 10*\\n5[0]+4[0]+1[0]=10\\n\\n9???"
                    },
                    {
                        "username": "jolswlf",
                        "content": "what do you mean by this? leetcode\\'s expected answer for this input is 9 as you explained. "
                    },
                    {
                        "username": "eark",
                        "content": "Compared brute force sum of digits from 1 to N, and the arithmetic progression formula ((N - M + 1)*(N+M)/2 to calculate number of sub-arrays. But there is no difference in runtime and both is around 160ms. In worst case, the latter will save full iteration up to 10^5, but why there is no difference in runtime?"
                    }
                ]
            },
            {
                "id": 1843146,
                "content": [
                    {
                        "username": "Godwin_NG",
                        "content": "It\\'s a math problem. All math questions are easy if you know the solution or method or formulae beforehand.\\n\\nFor [math] geeks: EASY  (provided they know the solution, method or formulae)\\nFor everyone else: NOT EASY"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Exactly"
                    },
                    {
                        "username": "allali",
                        "content": "why does this testcase \"[0,1,0,0,1,0,0,0]\" cause a stackoverflow ?? i tried it on cpp shell and it works but in leetcode it gives a stack overflow ? "
                    },
                    {
                        "username": "HKii",
                        "content": "I have a problem: my code is ok and output is correct according to Visualizer and PyCharm as least, but as copy-pasted the same code in Leet gives different output. Suggestions?\n\nThis is the code btw:\n        numbs = [1] + nums + [1]\n        subArrs = 0\n        cur = 0\n        for n in numbs:\n            if n == 0:\n                cur += 1\n            elif n != 0:\n                if cur != 0:\n                    subArrs += int(cur*((cur+1)/2))\n                    cur = 0\n        return subArrs"
                    },
                    {
                        "username": "HKii",
                        "content": "[@qazFatNerd](/qazFatNerd) Thank you! It made me crazy."
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "Change the subArrs.\\nsubArrs += int(cur*(cur+1)/2)\\n\\nBecause python compute (cur+1)/2) first, and it becomes a int.\\n\\nEX: print((2+1)/2) # == 1"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "Calculate the continuous zeros and keep on storing it into ans variable if there are no continuous zeros then we will reset the count variable to zero.\\n\\nclass Solution {\\n    public long zeroFilledSubarray(int[] nums) {\\n        \\n        long count = 0;\\n        long ans = 0;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==0){\\n              count++;\\n              ans += count;\\n            }else count=0;\\n        }\\n       \\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "charonme",
                        "content": "[@namandt](/namandt) it is enough when you add the count to the answer every time you increment the count. It gives the same result as adding (cnt * (cnt + 1)) / 2 to the answer after the end of each sequence of zeroes. Try it, it works."
                    },
                    {
                        "username": "namandt",
                        "content": "btw, I was ex-DSE at Infosys."
                    },
                    {
                        "username": "namandt",
                        "content": "nope.\\ncounting is not enough!\\nthis is wrong answer."
                    },
                    {
                        "username": "anirudhkulkarni9094",
                        "content": "How about we find the length of subarray containing only zero and using length to apply the formula : \\n`(N(N+1))/2` \\nand adding it to total\\ne.g.\\nfor length of 1: \\nvalue will be 1\\nfor 2 , value is 3\\nfor 3, value is 6 and so on\\n\\nnot the most optimistic solution but we can use mathematical formula to solve this question."
                    },
                    {
                        "username": "namandt",
                        "content": "thats what I have done..i think its the only solution"
                    },
                    {
                        "username": "Tusharpanwar",
                        "content": "Can such type of easy question come in the interview?"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "Just count the number of consecutive zeros and use n(n+1)/2.\nsimple.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n\nactually, mujse bhi pahli baar m nhi hua tha😜"
                    },
                    {
                        "username": "161_shaa_",
                        "content": "can someone please explain why is it failing at 46th test case out of 48 total cases\\n\\nlong ans=0;\\n        \\n        int i=0;\\n        int j=0;\\n\\n        while(j<nums.length){\\n            \\n            if(nums[j]!=0){\\n                i++;\\n                j++;\\n            }\\n\\n            else if(nums[j]==0){\\n\\n                i=j;\\n                while(j<nums.length&& nums[j]==0 ){\\n                    j++;\\n                }\\n\\n                int number=j-i;\\n                i=j;\\n                long num=(number)*((number+1))/2;\\n\\n                ans+=num;\\n\\n\\n            }\\n\\n        }\\n\\n        return ans;"
                    },
                    {
                        "username": "lDagothUrl",
                        "content": "Example 2:\\n\\nInput: nums = [0,0,0,2,0,0]\\nOutput: 9\\nExplanation:\\nThere are 5 occurrences of [0] as a subarray.\\nThere are 3 occurrences of [0,0] as a subarray.\\nThere is 1 occurrence of [0,0,0] as a subarray.\\nThere is no occurrence of a subarray with a size more than 3 filled with 0. Therefore, we return 9.\\n\\nOutput: 10*\\n5[0]+4[0]+1[0]=10\\n\\n9???"
                    },
                    {
                        "username": "jolswlf",
                        "content": "what do you mean by this? leetcode\\'s expected answer for this input is 9 as you explained. "
                    },
                    {
                        "username": "eark",
                        "content": "Compared brute force sum of digits from 1 to N, and the arithmetic progression formula ((N - M + 1)*(N+M)/2 to calculate number of sub-arrays. But there is no difference in runtime and both is around 160ms. In worst case, the latter will save full iteration up to 10^5, but why there is no difference in runtime?"
                    }
                ]
            },
            {
                "id": 1840852,
                "content": [
                    {
                        "username": "Godwin_NG",
                        "content": "It\\'s a math problem. All math questions are easy if you know the solution or method or formulae beforehand.\\n\\nFor [math] geeks: EASY  (provided they know the solution, method or formulae)\\nFor everyone else: NOT EASY"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Exactly"
                    },
                    {
                        "username": "allali",
                        "content": "why does this testcase \"[0,1,0,0,1,0,0,0]\" cause a stackoverflow ?? i tried it on cpp shell and it works but in leetcode it gives a stack overflow ? "
                    },
                    {
                        "username": "HKii",
                        "content": "I have a problem: my code is ok and output is correct according to Visualizer and PyCharm as least, but as copy-pasted the same code in Leet gives different output. Suggestions?\n\nThis is the code btw:\n        numbs = [1] + nums + [1]\n        subArrs = 0\n        cur = 0\n        for n in numbs:\n            if n == 0:\n                cur += 1\n            elif n != 0:\n                if cur != 0:\n                    subArrs += int(cur*((cur+1)/2))\n                    cur = 0\n        return subArrs"
                    },
                    {
                        "username": "HKii",
                        "content": "[@qazFatNerd](/qazFatNerd) Thank you! It made me crazy."
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "Change the subArrs.\\nsubArrs += int(cur*(cur+1)/2)\\n\\nBecause python compute (cur+1)/2) first, and it becomes a int.\\n\\nEX: print((2+1)/2) # == 1"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "Calculate the continuous zeros and keep on storing it into ans variable if there are no continuous zeros then we will reset the count variable to zero.\\n\\nclass Solution {\\n    public long zeroFilledSubarray(int[] nums) {\\n        \\n        long count = 0;\\n        long ans = 0;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==0){\\n              count++;\\n              ans += count;\\n            }else count=0;\\n        }\\n       \\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "charonme",
                        "content": "[@namandt](/namandt) it is enough when you add the count to the answer every time you increment the count. It gives the same result as adding (cnt * (cnt + 1)) / 2 to the answer after the end of each sequence of zeroes. Try it, it works."
                    },
                    {
                        "username": "namandt",
                        "content": "btw, I was ex-DSE at Infosys."
                    },
                    {
                        "username": "namandt",
                        "content": "nope.\\ncounting is not enough!\\nthis is wrong answer."
                    },
                    {
                        "username": "anirudhkulkarni9094",
                        "content": "How about we find the length of subarray containing only zero and using length to apply the formula : \\n`(N(N+1))/2` \\nand adding it to total\\ne.g.\\nfor length of 1: \\nvalue will be 1\\nfor 2 , value is 3\\nfor 3, value is 6 and so on\\n\\nnot the most optimistic solution but we can use mathematical formula to solve this question."
                    },
                    {
                        "username": "namandt",
                        "content": "thats what I have done..i think its the only solution"
                    },
                    {
                        "username": "Tusharpanwar",
                        "content": "Can such type of easy question come in the interview?"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "Just count the number of consecutive zeros and use n(n+1)/2.\nsimple.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n\nactually, mujse bhi pahli baar m nhi hua tha😜"
                    },
                    {
                        "username": "161_shaa_",
                        "content": "can someone please explain why is it failing at 46th test case out of 48 total cases\\n\\nlong ans=0;\\n        \\n        int i=0;\\n        int j=0;\\n\\n        while(j<nums.length){\\n            \\n            if(nums[j]!=0){\\n                i++;\\n                j++;\\n            }\\n\\n            else if(nums[j]==0){\\n\\n                i=j;\\n                while(j<nums.length&& nums[j]==0 ){\\n                    j++;\\n                }\\n\\n                int number=j-i;\\n                i=j;\\n                long num=(number)*((number+1))/2;\\n\\n                ans+=num;\\n\\n\\n            }\\n\\n        }\\n\\n        return ans;"
                    },
                    {
                        "username": "lDagothUrl",
                        "content": "Example 2:\\n\\nInput: nums = [0,0,0,2,0,0]\\nOutput: 9\\nExplanation:\\nThere are 5 occurrences of [0] as a subarray.\\nThere are 3 occurrences of [0,0] as a subarray.\\nThere is 1 occurrence of [0,0,0] as a subarray.\\nThere is no occurrence of a subarray with a size more than 3 filled with 0. Therefore, we return 9.\\n\\nOutput: 10*\\n5[0]+4[0]+1[0]=10\\n\\n9???"
                    },
                    {
                        "username": "jolswlf",
                        "content": "what do you mean by this? leetcode\\'s expected answer for this input is 9 as you explained. "
                    },
                    {
                        "username": "eark",
                        "content": "Compared brute force sum of digits from 1 to N, and the arithmetic progression formula ((N - M + 1)*(N+M)/2 to calculate number of sub-arrays. But there is no difference in runtime and both is around 160ms. In worst case, the latter will save full iteration up to 10^5, but why there is no difference in runtime?"
                    }
                ]
            },
            {
                "id": 1840445,
                "content": [
                    {
                        "username": "Godwin_NG",
                        "content": "It\\'s a math problem. All math questions are easy if you know the solution or method or formulae beforehand.\\n\\nFor [math] geeks: EASY  (provided they know the solution, method or formulae)\\nFor everyone else: NOT EASY"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Exactly"
                    },
                    {
                        "username": "allali",
                        "content": "why does this testcase \"[0,1,0,0,1,0,0,0]\" cause a stackoverflow ?? i tried it on cpp shell and it works but in leetcode it gives a stack overflow ? "
                    },
                    {
                        "username": "HKii",
                        "content": "I have a problem: my code is ok and output is correct according to Visualizer and PyCharm as least, but as copy-pasted the same code in Leet gives different output. Suggestions?\n\nThis is the code btw:\n        numbs = [1] + nums + [1]\n        subArrs = 0\n        cur = 0\n        for n in numbs:\n            if n == 0:\n                cur += 1\n            elif n != 0:\n                if cur != 0:\n                    subArrs += int(cur*((cur+1)/2))\n                    cur = 0\n        return subArrs"
                    },
                    {
                        "username": "HKii",
                        "content": "[@qazFatNerd](/qazFatNerd) Thank you! It made me crazy."
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "Change the subArrs.\\nsubArrs += int(cur*(cur+1)/2)\\n\\nBecause python compute (cur+1)/2) first, and it becomes a int.\\n\\nEX: print((2+1)/2) # == 1"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "Calculate the continuous zeros and keep on storing it into ans variable if there are no continuous zeros then we will reset the count variable to zero.\\n\\nclass Solution {\\n    public long zeroFilledSubarray(int[] nums) {\\n        \\n        long count = 0;\\n        long ans = 0;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==0){\\n              count++;\\n              ans += count;\\n            }else count=0;\\n        }\\n       \\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "charonme",
                        "content": "[@namandt](/namandt) it is enough when you add the count to the answer every time you increment the count. It gives the same result as adding (cnt * (cnt + 1)) / 2 to the answer after the end of each sequence of zeroes. Try it, it works."
                    },
                    {
                        "username": "namandt",
                        "content": "btw, I was ex-DSE at Infosys."
                    },
                    {
                        "username": "namandt",
                        "content": "nope.\\ncounting is not enough!\\nthis is wrong answer."
                    },
                    {
                        "username": "anirudhkulkarni9094",
                        "content": "How about we find the length of subarray containing only zero and using length to apply the formula : \\n`(N(N+1))/2` \\nand adding it to total\\ne.g.\\nfor length of 1: \\nvalue will be 1\\nfor 2 , value is 3\\nfor 3, value is 6 and so on\\n\\nnot the most optimistic solution but we can use mathematical formula to solve this question."
                    },
                    {
                        "username": "namandt",
                        "content": "thats what I have done..i think its the only solution"
                    },
                    {
                        "username": "Tusharpanwar",
                        "content": "Can such type of easy question come in the interview?"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "Just count the number of consecutive zeros and use n(n+1)/2.\nsimple.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n\nactually, mujse bhi pahli baar m nhi hua tha😜"
                    },
                    {
                        "username": "161_shaa_",
                        "content": "can someone please explain why is it failing at 46th test case out of 48 total cases\\n\\nlong ans=0;\\n        \\n        int i=0;\\n        int j=0;\\n\\n        while(j<nums.length){\\n            \\n            if(nums[j]!=0){\\n                i++;\\n                j++;\\n            }\\n\\n            else if(nums[j]==0){\\n\\n                i=j;\\n                while(j<nums.length&& nums[j]==0 ){\\n                    j++;\\n                }\\n\\n                int number=j-i;\\n                i=j;\\n                long num=(number)*((number+1))/2;\\n\\n                ans+=num;\\n\\n\\n            }\\n\\n        }\\n\\n        return ans;"
                    },
                    {
                        "username": "lDagothUrl",
                        "content": "Example 2:\\n\\nInput: nums = [0,0,0,2,0,0]\\nOutput: 9\\nExplanation:\\nThere are 5 occurrences of [0] as a subarray.\\nThere are 3 occurrences of [0,0] as a subarray.\\nThere is 1 occurrence of [0,0,0] as a subarray.\\nThere is no occurrence of a subarray with a size more than 3 filled with 0. Therefore, we return 9.\\n\\nOutput: 10*\\n5[0]+4[0]+1[0]=10\\n\\n9???"
                    },
                    {
                        "username": "jolswlf",
                        "content": "what do you mean by this? leetcode\\'s expected answer for this input is 9 as you explained. "
                    },
                    {
                        "username": "eark",
                        "content": "Compared brute force sum of digits from 1 to N, and the arithmetic progression formula ((N - M + 1)*(N+M)/2 to calculate number of sub-arrays. But there is no difference in runtime and both is around 160ms. In worst case, the latter will save full iteration up to 10^5, but why there is no difference in runtime?"
                    }
                ]
            },
            {
                "id": 1839911,
                "content": [
                    {
                        "username": "Godwin_NG",
                        "content": "It\\'s a math problem. All math questions are easy if you know the solution or method or formulae beforehand.\\n\\nFor [math] geeks: EASY  (provided they know the solution, method or formulae)\\nFor everyone else: NOT EASY"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Exactly"
                    },
                    {
                        "username": "allali",
                        "content": "why does this testcase \"[0,1,0,0,1,0,0,0]\" cause a stackoverflow ?? i tried it on cpp shell and it works but in leetcode it gives a stack overflow ? "
                    },
                    {
                        "username": "HKii",
                        "content": "I have a problem: my code is ok and output is correct according to Visualizer and PyCharm as least, but as copy-pasted the same code in Leet gives different output. Suggestions?\n\nThis is the code btw:\n        numbs = [1] + nums + [1]\n        subArrs = 0\n        cur = 0\n        for n in numbs:\n            if n == 0:\n                cur += 1\n            elif n != 0:\n                if cur != 0:\n                    subArrs += int(cur*((cur+1)/2))\n                    cur = 0\n        return subArrs"
                    },
                    {
                        "username": "HKii",
                        "content": "[@qazFatNerd](/qazFatNerd) Thank you! It made me crazy."
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "Change the subArrs.\\nsubArrs += int(cur*(cur+1)/2)\\n\\nBecause python compute (cur+1)/2) first, and it becomes a int.\\n\\nEX: print((2+1)/2) # == 1"
                    },
                    {
                        "username": "Glory_Killer",
                        "content": "Calculate the continuous zeros and keep on storing it into ans variable if there are no continuous zeros then we will reset the count variable to zero.\\n\\nclass Solution {\\n    public long zeroFilledSubarray(int[] nums) {\\n        \\n        long count = 0;\\n        long ans = 0;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==0){\\n              count++;\\n              ans += count;\\n            }else count=0;\\n        }\\n       \\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "charonme",
                        "content": "[@namandt](/namandt) it is enough when you add the count to the answer every time you increment the count. It gives the same result as adding (cnt * (cnt + 1)) / 2 to the answer after the end of each sequence of zeroes. Try it, it works."
                    },
                    {
                        "username": "namandt",
                        "content": "btw, I was ex-DSE at Infosys."
                    },
                    {
                        "username": "namandt",
                        "content": "nope.\\ncounting is not enough!\\nthis is wrong answer."
                    },
                    {
                        "username": "anirudhkulkarni9094",
                        "content": "How about we find the length of subarray containing only zero and using length to apply the formula : \\n`(N(N+1))/2` \\nand adding it to total\\ne.g.\\nfor length of 1: \\nvalue will be 1\\nfor 2 , value is 3\\nfor 3, value is 6 and so on\\n\\nnot the most optimistic solution but we can use mathematical formula to solve this question."
                    },
                    {
                        "username": "namandt",
                        "content": "thats what I have done..i think its the only solution"
                    },
                    {
                        "username": "Tusharpanwar",
                        "content": "Can such type of easy question come in the interview?"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "Just count the number of consecutive zeros and use n(n+1)/2.\nsimple.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n.\n\nactually, mujse bhi pahli baar m nhi hua tha😜"
                    },
                    {
                        "username": "161_shaa_",
                        "content": "can someone please explain why is it failing at 46th test case out of 48 total cases\\n\\nlong ans=0;\\n        \\n        int i=0;\\n        int j=0;\\n\\n        while(j<nums.length){\\n            \\n            if(nums[j]!=0){\\n                i++;\\n                j++;\\n            }\\n\\n            else if(nums[j]==0){\\n\\n                i=j;\\n                while(j<nums.length&& nums[j]==0 ){\\n                    j++;\\n                }\\n\\n                int number=j-i;\\n                i=j;\\n                long num=(number)*((number+1))/2;\\n\\n                ans+=num;\\n\\n\\n            }\\n\\n        }\\n\\n        return ans;"
                    },
                    {
                        "username": "lDagothUrl",
                        "content": "Example 2:\\n\\nInput: nums = [0,0,0,2,0,0]\\nOutput: 9\\nExplanation:\\nThere are 5 occurrences of [0] as a subarray.\\nThere are 3 occurrences of [0,0] as a subarray.\\nThere is 1 occurrence of [0,0,0] as a subarray.\\nThere is no occurrence of a subarray with a size more than 3 filled with 0. Therefore, we return 9.\\n\\nOutput: 10*\\n5[0]+4[0]+1[0]=10\\n\\n9???"
                    },
                    {
                        "username": "jolswlf",
                        "content": "what do you mean by this? leetcode\\'s expected answer for this input is 9 as you explained. "
                    },
                    {
                        "username": "eark",
                        "content": "Compared brute force sum of digits from 1 to N, and the arithmetic progression formula ((N - M + 1)*(N+M)/2 to calculate number of sub-arrays. But there is no difference in runtime and both is around 160ms. In worst case, the latter will save full iteration up to 10^5, but why there is no difference in runtime?"
                    }
                ]
            },
            {
                "id": 1839824,
                "content": [
                    {
                        "username": "buckleyniall100",
                        "content": "Did this take anyone else longer than they would like to admit haha?\\n"
                    },
                    {
                        "username": "DPcodes123",
                        "content": "Here\\'s me over here storing occurrences of 0-subArrays in a hashmap, then using recursion to calculate the sum as a geometric series, then having to deal with edge cases such as ending on a 0.....\\n\\nTook me 45 minutes and passed in the 5% percentile lmao. Boy, did I feel stupid after looking at the top submissions"
                    },
                    {
                        "username": "adityadixit7054",
                        "content": "Why these questions are not asked in contest?"
                    },
                    {
                        "username": "jperrin36",
                        "content": "it was all fun and games until TLE"
                    },
                    {
                        "username": "halfengineer",
                        "content": "5000050000 \\uD83D\\uDE01\\uD83D\\uDE01"
                    },
                    {
                        "username": "heraAijaz",
                        "content": "Why is this labelled medium?"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is a simple Approach :-)***\\n\\n1. Start with a count of 0.\\n2. Look at each number in the input array one by one.\\n3. If the number is 0, count how many 0s come after it in a row. Keep counting until a non-zero number is found or the end of the array is reached.\\n4. Calculate how many subarrays can be made with the consecutive 0s found in step 3. To do this, use the formula ((n+1)*n)/2, where n is the number of consecutive 0s found.\\n5. Add the number of subarrays found in step 4 to the count.\\n6. Repeat steps 2-5 until all numbers in the array have been looked at.\\n7. Return the count of subarrays that have only 0s in them.\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the Code Link :-)***\\nhttps://leetcode.com/problems/number-of-zero-filled-subarrays/solutions/3325085/straightforward-brute-force-approach/"
                    },
                    {
                        "username": "rahulrauki",
                        "content": "This problem is a morale booster, thanks for marking it Medium "
                    },
                    {
                        "username": "mrping_11",
                        "content": "hint :  find pattern of this number sequence\\n1, 3, 6, 10, 15, 21\\nglhf"
                    },
                    {
                        "username": "NamanSaini18",
                        "content": "It should be marked as an easy question.. Boosted my confidence for rest of day... Happy LeetCoding !!!"
                    },
                    {
                        "username": "Umesh_Bhosale",
                        "content": "This question is easy as compare to yesterdays easy question"
                    }
                ]
            },
            {
                "id": 1839786,
                "content": [
                    {
                        "username": "buckleyniall100",
                        "content": "Did this take anyone else longer than they would like to admit haha?\\n"
                    },
                    {
                        "username": "DPcodes123",
                        "content": "Here\\'s me over here storing occurrences of 0-subArrays in a hashmap, then using recursion to calculate the sum as a geometric series, then having to deal with edge cases such as ending on a 0.....\\n\\nTook me 45 minutes and passed in the 5% percentile lmao. Boy, did I feel stupid after looking at the top submissions"
                    },
                    {
                        "username": "adityadixit7054",
                        "content": "Why these questions are not asked in contest?"
                    },
                    {
                        "username": "jperrin36",
                        "content": "it was all fun and games until TLE"
                    },
                    {
                        "username": "halfengineer",
                        "content": "5000050000 \\uD83D\\uDE01\\uD83D\\uDE01"
                    },
                    {
                        "username": "heraAijaz",
                        "content": "Why is this labelled medium?"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is a simple Approach :-)***\\n\\n1. Start with a count of 0.\\n2. Look at each number in the input array one by one.\\n3. If the number is 0, count how many 0s come after it in a row. Keep counting until a non-zero number is found or the end of the array is reached.\\n4. Calculate how many subarrays can be made with the consecutive 0s found in step 3. To do this, use the formula ((n+1)*n)/2, where n is the number of consecutive 0s found.\\n5. Add the number of subarrays found in step 4 to the count.\\n6. Repeat steps 2-5 until all numbers in the array have been looked at.\\n7. Return the count of subarrays that have only 0s in them.\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the Code Link :-)***\\nhttps://leetcode.com/problems/number-of-zero-filled-subarrays/solutions/3325085/straightforward-brute-force-approach/"
                    },
                    {
                        "username": "rahulrauki",
                        "content": "This problem is a morale booster, thanks for marking it Medium "
                    },
                    {
                        "username": "mrping_11",
                        "content": "hint :  find pattern of this number sequence\\n1, 3, 6, 10, 15, 21\\nglhf"
                    },
                    {
                        "username": "NamanSaini18",
                        "content": "It should be marked as an easy question.. Boosted my confidence for rest of day... Happy LeetCoding !!!"
                    },
                    {
                        "username": "Umesh_Bhosale",
                        "content": "This question is easy as compare to yesterdays easy question"
                    }
                ]
            },
            {
                "id": 1839660,
                "content": [
                    {
                        "username": "buckleyniall100",
                        "content": "Did this take anyone else longer than they would like to admit haha?\\n"
                    },
                    {
                        "username": "DPcodes123",
                        "content": "Here\\'s me over here storing occurrences of 0-subArrays in a hashmap, then using recursion to calculate the sum as a geometric series, then having to deal with edge cases such as ending on a 0.....\\n\\nTook me 45 minutes and passed in the 5% percentile lmao. Boy, did I feel stupid after looking at the top submissions"
                    },
                    {
                        "username": "adityadixit7054",
                        "content": "Why these questions are not asked in contest?"
                    },
                    {
                        "username": "jperrin36",
                        "content": "it was all fun and games until TLE"
                    },
                    {
                        "username": "halfengineer",
                        "content": "5000050000 \\uD83D\\uDE01\\uD83D\\uDE01"
                    },
                    {
                        "username": "heraAijaz",
                        "content": "Why is this labelled medium?"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is a simple Approach :-)***\\n\\n1. Start with a count of 0.\\n2. Look at each number in the input array one by one.\\n3. If the number is 0, count how many 0s come after it in a row. Keep counting until a non-zero number is found or the end of the array is reached.\\n4. Calculate how many subarrays can be made with the consecutive 0s found in step 3. To do this, use the formula ((n+1)*n)/2, where n is the number of consecutive 0s found.\\n5. Add the number of subarrays found in step 4 to the count.\\n6. Repeat steps 2-5 until all numbers in the array have been looked at.\\n7. Return the count of subarrays that have only 0s in them.\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the Code Link :-)***\\nhttps://leetcode.com/problems/number-of-zero-filled-subarrays/solutions/3325085/straightforward-brute-force-approach/"
                    },
                    {
                        "username": "rahulrauki",
                        "content": "This problem is a morale booster, thanks for marking it Medium "
                    },
                    {
                        "username": "mrping_11",
                        "content": "hint :  find pattern of this number sequence\\n1, 3, 6, 10, 15, 21\\nglhf"
                    },
                    {
                        "username": "NamanSaini18",
                        "content": "It should be marked as an easy question.. Boosted my confidence for rest of day... Happy LeetCoding !!!"
                    },
                    {
                        "username": "Umesh_Bhosale",
                        "content": "This question is easy as compare to yesterdays easy question"
                    }
                ]
            },
            {
                "id": 1839648,
                "content": [
                    {
                        "username": "buckleyniall100",
                        "content": "Did this take anyone else longer than they would like to admit haha?\\n"
                    },
                    {
                        "username": "DPcodes123",
                        "content": "Here\\'s me over here storing occurrences of 0-subArrays in a hashmap, then using recursion to calculate the sum as a geometric series, then having to deal with edge cases such as ending on a 0.....\\n\\nTook me 45 minutes and passed in the 5% percentile lmao. Boy, did I feel stupid after looking at the top submissions"
                    },
                    {
                        "username": "adityadixit7054",
                        "content": "Why these questions are not asked in contest?"
                    },
                    {
                        "username": "jperrin36",
                        "content": "it was all fun and games until TLE"
                    },
                    {
                        "username": "halfengineer",
                        "content": "5000050000 \\uD83D\\uDE01\\uD83D\\uDE01"
                    },
                    {
                        "username": "heraAijaz",
                        "content": "Why is this labelled medium?"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is a simple Approach :-)***\\n\\n1. Start with a count of 0.\\n2. Look at each number in the input array one by one.\\n3. If the number is 0, count how many 0s come after it in a row. Keep counting until a non-zero number is found or the end of the array is reached.\\n4. Calculate how many subarrays can be made with the consecutive 0s found in step 3. To do this, use the formula ((n+1)*n)/2, where n is the number of consecutive 0s found.\\n5. Add the number of subarrays found in step 4 to the count.\\n6. Repeat steps 2-5 until all numbers in the array have been looked at.\\n7. Return the count of subarrays that have only 0s in them.\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the Code Link :-)***\\nhttps://leetcode.com/problems/number-of-zero-filled-subarrays/solutions/3325085/straightforward-brute-force-approach/"
                    },
                    {
                        "username": "rahulrauki",
                        "content": "This problem is a morale booster, thanks for marking it Medium "
                    },
                    {
                        "username": "mrping_11",
                        "content": "hint :  find pattern of this number sequence\\n1, 3, 6, 10, 15, 21\\nglhf"
                    },
                    {
                        "username": "NamanSaini18",
                        "content": "It should be marked as an easy question.. Boosted my confidence for rest of day... Happy LeetCoding !!!"
                    },
                    {
                        "username": "Umesh_Bhosale",
                        "content": "This question is easy as compare to yesterdays easy question"
                    }
                ]
            },
            {
                "id": 1839647,
                "content": [
                    {
                        "username": "buckleyniall100",
                        "content": "Did this take anyone else longer than they would like to admit haha?\\n"
                    },
                    {
                        "username": "DPcodes123",
                        "content": "Here\\'s me over here storing occurrences of 0-subArrays in a hashmap, then using recursion to calculate the sum as a geometric series, then having to deal with edge cases such as ending on a 0.....\\n\\nTook me 45 minutes and passed in the 5% percentile lmao. Boy, did I feel stupid after looking at the top submissions"
                    },
                    {
                        "username": "adityadixit7054",
                        "content": "Why these questions are not asked in contest?"
                    },
                    {
                        "username": "jperrin36",
                        "content": "it was all fun and games until TLE"
                    },
                    {
                        "username": "halfengineer",
                        "content": "5000050000 \\uD83D\\uDE01\\uD83D\\uDE01"
                    },
                    {
                        "username": "heraAijaz",
                        "content": "Why is this labelled medium?"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is a simple Approach :-)***\\n\\n1. Start with a count of 0.\\n2. Look at each number in the input array one by one.\\n3. If the number is 0, count how many 0s come after it in a row. Keep counting until a non-zero number is found or the end of the array is reached.\\n4. Calculate how many subarrays can be made with the consecutive 0s found in step 3. To do this, use the formula ((n+1)*n)/2, where n is the number of consecutive 0s found.\\n5. Add the number of subarrays found in step 4 to the count.\\n6. Repeat steps 2-5 until all numbers in the array have been looked at.\\n7. Return the count of subarrays that have only 0s in them.\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the Code Link :-)***\\nhttps://leetcode.com/problems/number-of-zero-filled-subarrays/solutions/3325085/straightforward-brute-force-approach/"
                    },
                    {
                        "username": "rahulrauki",
                        "content": "This problem is a morale booster, thanks for marking it Medium "
                    },
                    {
                        "username": "mrping_11",
                        "content": "hint :  find pattern of this number sequence\\n1, 3, 6, 10, 15, 21\\nglhf"
                    },
                    {
                        "username": "NamanSaini18",
                        "content": "It should be marked as an easy question.. Boosted my confidence for rest of day... Happy LeetCoding !!!"
                    },
                    {
                        "username": "Umesh_Bhosale",
                        "content": "This question is easy as compare to yesterdays easy question"
                    }
                ]
            },
            {
                "id": 1839646,
                "content": [
                    {
                        "username": "buckleyniall100",
                        "content": "Did this take anyone else longer than they would like to admit haha?\\n"
                    },
                    {
                        "username": "DPcodes123",
                        "content": "Here\\'s me over here storing occurrences of 0-subArrays in a hashmap, then using recursion to calculate the sum as a geometric series, then having to deal with edge cases such as ending on a 0.....\\n\\nTook me 45 minutes and passed in the 5% percentile lmao. Boy, did I feel stupid after looking at the top submissions"
                    },
                    {
                        "username": "adityadixit7054",
                        "content": "Why these questions are not asked in contest?"
                    },
                    {
                        "username": "jperrin36",
                        "content": "it was all fun and games until TLE"
                    },
                    {
                        "username": "halfengineer",
                        "content": "5000050000 \\uD83D\\uDE01\\uD83D\\uDE01"
                    },
                    {
                        "username": "heraAijaz",
                        "content": "Why is this labelled medium?"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is a simple Approach :-)***\\n\\n1. Start with a count of 0.\\n2. Look at each number in the input array one by one.\\n3. If the number is 0, count how many 0s come after it in a row. Keep counting until a non-zero number is found or the end of the array is reached.\\n4. Calculate how many subarrays can be made with the consecutive 0s found in step 3. To do this, use the formula ((n+1)*n)/2, where n is the number of consecutive 0s found.\\n5. Add the number of subarrays found in step 4 to the count.\\n6. Repeat steps 2-5 until all numbers in the array have been looked at.\\n7. Return the count of subarrays that have only 0s in them.\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the Code Link :-)***\\nhttps://leetcode.com/problems/number-of-zero-filled-subarrays/solutions/3325085/straightforward-brute-force-approach/"
                    },
                    {
                        "username": "rahulrauki",
                        "content": "This problem is a morale booster, thanks for marking it Medium "
                    },
                    {
                        "username": "mrping_11",
                        "content": "hint :  find pattern of this number sequence\\n1, 3, 6, 10, 15, 21\\nglhf"
                    },
                    {
                        "username": "NamanSaini18",
                        "content": "It should be marked as an easy question.. Boosted my confidence for rest of day... Happy LeetCoding !!!"
                    },
                    {
                        "username": "Umesh_Bhosale",
                        "content": "This question is easy as compare to yesterdays easy question"
                    }
                ]
            },
            {
                "id": 1839629,
                "content": [
                    {
                        "username": "buckleyniall100",
                        "content": "Did this take anyone else longer than they would like to admit haha?\\n"
                    },
                    {
                        "username": "DPcodes123",
                        "content": "Here\\'s me over here storing occurrences of 0-subArrays in a hashmap, then using recursion to calculate the sum as a geometric series, then having to deal with edge cases such as ending on a 0.....\\n\\nTook me 45 minutes and passed in the 5% percentile lmao. Boy, did I feel stupid after looking at the top submissions"
                    },
                    {
                        "username": "adityadixit7054",
                        "content": "Why these questions are not asked in contest?"
                    },
                    {
                        "username": "jperrin36",
                        "content": "it was all fun and games until TLE"
                    },
                    {
                        "username": "halfengineer",
                        "content": "5000050000 \\uD83D\\uDE01\\uD83D\\uDE01"
                    },
                    {
                        "username": "heraAijaz",
                        "content": "Why is this labelled medium?"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is a simple Approach :-)***\\n\\n1. Start with a count of 0.\\n2. Look at each number in the input array one by one.\\n3. If the number is 0, count how many 0s come after it in a row. Keep counting until a non-zero number is found or the end of the array is reached.\\n4. Calculate how many subarrays can be made with the consecutive 0s found in step 3. To do this, use the formula ((n+1)*n)/2, where n is the number of consecutive 0s found.\\n5. Add the number of subarrays found in step 4 to the count.\\n6. Repeat steps 2-5 until all numbers in the array have been looked at.\\n7. Return the count of subarrays that have only 0s in them.\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the Code Link :-)***\\nhttps://leetcode.com/problems/number-of-zero-filled-subarrays/solutions/3325085/straightforward-brute-force-approach/"
                    },
                    {
                        "username": "rahulrauki",
                        "content": "This problem is a morale booster, thanks for marking it Medium "
                    },
                    {
                        "username": "mrping_11",
                        "content": "hint :  find pattern of this number sequence\\n1, 3, 6, 10, 15, 21\\nglhf"
                    },
                    {
                        "username": "NamanSaini18",
                        "content": "It should be marked as an easy question.. Boosted my confidence for rest of day... Happy LeetCoding !!!"
                    },
                    {
                        "username": "Umesh_Bhosale",
                        "content": "This question is easy as compare to yesterdays easy question"
                    }
                ]
            },
            {
                "id": 1839626,
                "content": [
                    {
                        "username": "buckleyniall100",
                        "content": "Did this take anyone else longer than they would like to admit haha?\\n"
                    },
                    {
                        "username": "DPcodes123",
                        "content": "Here\\'s me over here storing occurrences of 0-subArrays in a hashmap, then using recursion to calculate the sum as a geometric series, then having to deal with edge cases such as ending on a 0.....\\n\\nTook me 45 minutes and passed in the 5% percentile lmao. Boy, did I feel stupid after looking at the top submissions"
                    },
                    {
                        "username": "adityadixit7054",
                        "content": "Why these questions are not asked in contest?"
                    },
                    {
                        "username": "jperrin36",
                        "content": "it was all fun and games until TLE"
                    },
                    {
                        "username": "halfengineer",
                        "content": "5000050000 \\uD83D\\uDE01\\uD83D\\uDE01"
                    },
                    {
                        "username": "heraAijaz",
                        "content": "Why is this labelled medium?"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is a simple Approach :-)***\\n\\n1. Start with a count of 0.\\n2. Look at each number in the input array one by one.\\n3. If the number is 0, count how many 0s come after it in a row. Keep counting until a non-zero number is found or the end of the array is reached.\\n4. Calculate how many subarrays can be made with the consecutive 0s found in step 3. To do this, use the formula ((n+1)*n)/2, where n is the number of consecutive 0s found.\\n5. Add the number of subarrays found in step 4 to the count.\\n6. Repeat steps 2-5 until all numbers in the array have been looked at.\\n7. Return the count of subarrays that have only 0s in them.\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the Code Link :-)***\\nhttps://leetcode.com/problems/number-of-zero-filled-subarrays/solutions/3325085/straightforward-brute-force-approach/"
                    },
                    {
                        "username": "rahulrauki",
                        "content": "This problem is a morale booster, thanks for marking it Medium "
                    },
                    {
                        "username": "mrping_11",
                        "content": "hint :  find pattern of this number sequence\\n1, 3, 6, 10, 15, 21\\nglhf"
                    },
                    {
                        "username": "NamanSaini18",
                        "content": "It should be marked as an easy question.. Boosted my confidence for rest of day... Happy LeetCoding !!!"
                    },
                    {
                        "username": "Umesh_Bhosale",
                        "content": "This question is easy as compare to yesterdays easy question"
                    }
                ]
            },
            {
                "id": 1839622,
                "content": [
                    {
                        "username": "buckleyniall100",
                        "content": "Did this take anyone else longer than they would like to admit haha?\\n"
                    },
                    {
                        "username": "DPcodes123",
                        "content": "Here\\'s me over here storing occurrences of 0-subArrays in a hashmap, then using recursion to calculate the sum as a geometric series, then having to deal with edge cases such as ending on a 0.....\\n\\nTook me 45 minutes and passed in the 5% percentile lmao. Boy, did I feel stupid after looking at the top submissions"
                    },
                    {
                        "username": "adityadixit7054",
                        "content": "Why these questions are not asked in contest?"
                    },
                    {
                        "username": "jperrin36",
                        "content": "it was all fun and games until TLE"
                    },
                    {
                        "username": "halfengineer",
                        "content": "5000050000 \\uD83D\\uDE01\\uD83D\\uDE01"
                    },
                    {
                        "username": "heraAijaz",
                        "content": "Why is this labelled medium?"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is a simple Approach :-)***\\n\\n1. Start with a count of 0.\\n2. Look at each number in the input array one by one.\\n3. If the number is 0, count how many 0s come after it in a row. Keep counting until a non-zero number is found or the end of the array is reached.\\n4. Calculate how many subarrays can be made with the consecutive 0s found in step 3. To do this, use the formula ((n+1)*n)/2, where n is the number of consecutive 0s found.\\n5. Add the number of subarrays found in step 4 to the count.\\n6. Repeat steps 2-5 until all numbers in the array have been looked at.\\n7. Return the count of subarrays that have only 0s in them.\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the Code Link :-)***\\nhttps://leetcode.com/problems/number-of-zero-filled-subarrays/solutions/3325085/straightforward-brute-force-approach/"
                    },
                    {
                        "username": "rahulrauki",
                        "content": "This problem is a morale booster, thanks for marking it Medium "
                    },
                    {
                        "username": "mrping_11",
                        "content": "hint :  find pattern of this number sequence\\n1, 3, 6, 10, 15, 21\\nglhf"
                    },
                    {
                        "username": "NamanSaini18",
                        "content": "It should be marked as an easy question.. Boosted my confidence for rest of day... Happy LeetCoding !!!"
                    },
                    {
                        "username": "Umesh_Bhosale",
                        "content": "This question is easy as compare to yesterdays easy question"
                    }
                ]
            },
            {
                "id": 1839463,
                "content": [
                    {
                        "username": "buckleyniall100",
                        "content": "Did this take anyone else longer than they would like to admit haha?\\n"
                    },
                    {
                        "username": "DPcodes123",
                        "content": "Here\\'s me over here storing occurrences of 0-subArrays in a hashmap, then using recursion to calculate the sum as a geometric series, then having to deal with edge cases such as ending on a 0.....\\n\\nTook me 45 minutes and passed in the 5% percentile lmao. Boy, did I feel stupid after looking at the top submissions"
                    },
                    {
                        "username": "adityadixit7054",
                        "content": "Why these questions are not asked in contest?"
                    },
                    {
                        "username": "jperrin36",
                        "content": "it was all fun and games until TLE"
                    },
                    {
                        "username": "halfengineer",
                        "content": "5000050000 \\uD83D\\uDE01\\uD83D\\uDE01"
                    },
                    {
                        "username": "heraAijaz",
                        "content": "Why is this labelled medium?"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is a simple Approach :-)***\\n\\n1. Start with a count of 0.\\n2. Look at each number in the input array one by one.\\n3. If the number is 0, count how many 0s come after it in a row. Keep counting until a non-zero number is found or the end of the array is reached.\\n4. Calculate how many subarrays can be made with the consecutive 0s found in step 3. To do this, use the formula ((n+1)*n)/2, where n is the number of consecutive 0s found.\\n5. Add the number of subarrays found in step 4 to the count.\\n6. Repeat steps 2-5 until all numbers in the array have been looked at.\\n7. Return the count of subarrays that have only 0s in them.\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the Code Link :-)***\\nhttps://leetcode.com/problems/number-of-zero-filled-subarrays/solutions/3325085/straightforward-brute-force-approach/"
                    },
                    {
                        "username": "rahulrauki",
                        "content": "This problem is a morale booster, thanks for marking it Medium "
                    },
                    {
                        "username": "mrping_11",
                        "content": "hint :  find pattern of this number sequence\\n1, 3, 6, 10, 15, 21\\nglhf"
                    },
                    {
                        "username": "NamanSaini18",
                        "content": "It should be marked as an easy question.. Boosted my confidence for rest of day... Happy LeetCoding !!!"
                    },
                    {
                        "username": "Umesh_Bhosale",
                        "content": "This question is easy as compare to yesterdays easy question"
                    }
                ]
            },
            {
                "id": 1839430,
                "content": [
                    {
                        "username": "Vishal_Singh7",
                        "content": "Steps:--\\n\\n1. Initialize two variables count and zeros to 0.\\n\\n2. Traverse the array arr from left to right.\\n\\n3. If the current element is 0, increment the zeros variable by 1.\\n\\n4. If the current element is not 0, calculate the number of subarrays of 0\\'s that can be formed using the zeros variable and add it to the count variable. Reset the zeros variable to 0.\\n\\n5. After we have traversed the entire array, calculate the number of subarrays of 0\\'s that end at the last index separately using the zeros variable and add it to the count variable.\\n\\n6. Return the total count of subarrays of 0\\'s.\\n\\nSolution link -- https://leetcode.com/problems/number-of-zero-filled-subarrays/solutions/3324103/easy-c-solution-optimized-approach-step-wise-explanation-tc-on-sc-o1/"
                    },
                    {
                        "username": "jolswlf",
                        "content": "how is this marked as medium"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "leetcode !!! if you are looking, please mark it as EASY"
                    },
                    {
                        "username": "hridoy100",
                        "content": "**Can we consider other numbers in the array?**\\nNo. We cannot. The description clearly says: **return the number of subarrays filled with 0**. And the subarray is a contiguous non-empty sequence of elements."
                    },
                    {
                        "username": "RaRafiq3",
                        "content": "Input: nums = [0,0,0,2,0,0]\\nOutput: 9\\nExplanation:\\nThere are 5 occurrences of [0] as a subarray.\\nThere are 3 occurrences of [0,0] as a subarray.\\nThere is 1 occurrence of [0,0,0] as a subarray.\\nThere is no occurrence of a subarray with a size more than 3 filled with 0. Therefore, we return 9.\\n\\ntry this  N*(N+1)/2"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Is it just me or are these questions just getting easier?"
                    },
                    {
                        "username": "zhuzhupang001",
                        "content": "should be easy"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Hint</span>\n![](https://leetcode.com/problems/number-of-zero-filled-subarrays/Figures/2348/2348-1.png)\n![](https://leetcode.com/problems/number-of-zero-filled-subarrays/Figures/2348/2348-2_4.png)\n![](https://leetcode.com/problems/number-of-zero-filled-subarrays/Figures/2348/2348-4.png)"
                    },
                    {
                        "username": "uchihaXmadara",
                        "content": "why this one is medium."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I am so silly to use prefix sum and hashmap to ac the problem..."
                    },
                    {
                        "username": "DPcodes123",
                        "content": "did the same haha! used a recursive function to calculate total subarrays in a subarray of n length, then multiplied that by the total number of occurences of that length (which is tracked in the hashmap)\\n\\nIt passed at the 5th percentile lol"
                    }
                ]
            },
            {
                "id": 1839260,
                "content": [
                    {
                        "username": "Vishal_Singh7",
                        "content": "Steps:--\\n\\n1. Initialize two variables count and zeros to 0.\\n\\n2. Traverse the array arr from left to right.\\n\\n3. If the current element is 0, increment the zeros variable by 1.\\n\\n4. If the current element is not 0, calculate the number of subarrays of 0\\'s that can be formed using the zeros variable and add it to the count variable. Reset the zeros variable to 0.\\n\\n5. After we have traversed the entire array, calculate the number of subarrays of 0\\'s that end at the last index separately using the zeros variable and add it to the count variable.\\n\\n6. Return the total count of subarrays of 0\\'s.\\n\\nSolution link -- https://leetcode.com/problems/number-of-zero-filled-subarrays/solutions/3324103/easy-c-solution-optimized-approach-step-wise-explanation-tc-on-sc-o1/"
                    },
                    {
                        "username": "jolswlf",
                        "content": "how is this marked as medium"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "leetcode !!! if you are looking, please mark it as EASY"
                    },
                    {
                        "username": "hridoy100",
                        "content": "**Can we consider other numbers in the array?**\\nNo. We cannot. The description clearly says: **return the number of subarrays filled with 0**. And the subarray is a contiguous non-empty sequence of elements."
                    },
                    {
                        "username": "RaRafiq3",
                        "content": "Input: nums = [0,0,0,2,0,0]\\nOutput: 9\\nExplanation:\\nThere are 5 occurrences of [0] as a subarray.\\nThere are 3 occurrences of [0,0] as a subarray.\\nThere is 1 occurrence of [0,0,0] as a subarray.\\nThere is no occurrence of a subarray with a size more than 3 filled with 0. Therefore, we return 9.\\n\\ntry this  N*(N+1)/2"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Is it just me or are these questions just getting easier?"
                    },
                    {
                        "username": "zhuzhupang001",
                        "content": "should be easy"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Hint</span>\n![](https://leetcode.com/problems/number-of-zero-filled-subarrays/Figures/2348/2348-1.png)\n![](https://leetcode.com/problems/number-of-zero-filled-subarrays/Figures/2348/2348-2_4.png)\n![](https://leetcode.com/problems/number-of-zero-filled-subarrays/Figures/2348/2348-4.png)"
                    },
                    {
                        "username": "uchihaXmadara",
                        "content": "why this one is medium."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I am so silly to use prefix sum and hashmap to ac the problem..."
                    },
                    {
                        "username": "DPcodes123",
                        "content": "did the same haha! used a recursive function to calculate total subarrays in a subarray of n length, then multiplied that by the total number of occurences of that length (which is tracked in the hashmap)\\n\\nIt passed at the 5th percentile lol"
                    }
                ]
            },
            {
                "id": 1839199,
                "content": [
                    {
                        "username": "Vishal_Singh7",
                        "content": "Steps:--\\n\\n1. Initialize two variables count and zeros to 0.\\n\\n2. Traverse the array arr from left to right.\\n\\n3. If the current element is 0, increment the zeros variable by 1.\\n\\n4. If the current element is not 0, calculate the number of subarrays of 0\\'s that can be formed using the zeros variable and add it to the count variable. Reset the zeros variable to 0.\\n\\n5. After we have traversed the entire array, calculate the number of subarrays of 0\\'s that end at the last index separately using the zeros variable and add it to the count variable.\\n\\n6. Return the total count of subarrays of 0\\'s.\\n\\nSolution link -- https://leetcode.com/problems/number-of-zero-filled-subarrays/solutions/3324103/easy-c-solution-optimized-approach-step-wise-explanation-tc-on-sc-o1/"
                    },
                    {
                        "username": "jolswlf",
                        "content": "how is this marked as medium"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "leetcode !!! if you are looking, please mark it as EASY"
                    },
                    {
                        "username": "hridoy100",
                        "content": "**Can we consider other numbers in the array?**\\nNo. We cannot. The description clearly says: **return the number of subarrays filled with 0**. And the subarray is a contiguous non-empty sequence of elements."
                    },
                    {
                        "username": "RaRafiq3",
                        "content": "Input: nums = [0,0,0,2,0,0]\\nOutput: 9\\nExplanation:\\nThere are 5 occurrences of [0] as a subarray.\\nThere are 3 occurrences of [0,0] as a subarray.\\nThere is 1 occurrence of [0,0,0] as a subarray.\\nThere is no occurrence of a subarray with a size more than 3 filled with 0. Therefore, we return 9.\\n\\ntry this  N*(N+1)/2"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Is it just me or are these questions just getting easier?"
                    },
                    {
                        "username": "zhuzhupang001",
                        "content": "should be easy"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Hint</span>\n![](https://leetcode.com/problems/number-of-zero-filled-subarrays/Figures/2348/2348-1.png)\n![](https://leetcode.com/problems/number-of-zero-filled-subarrays/Figures/2348/2348-2_4.png)\n![](https://leetcode.com/problems/number-of-zero-filled-subarrays/Figures/2348/2348-4.png)"
                    },
                    {
                        "username": "uchihaXmadara",
                        "content": "why this one is medium."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I am so silly to use prefix sum and hashmap to ac the problem..."
                    },
                    {
                        "username": "DPcodes123",
                        "content": "did the same haha! used a recursive function to calculate total subarrays in a subarray of n length, then multiplied that by the total number of occurences of that length (which is tracked in the hashmap)\\n\\nIt passed at the 5th percentile lol"
                    }
                ]
            },
            {
                "id": 1839182,
                "content": [
                    {
                        "username": "Vishal_Singh7",
                        "content": "Steps:--\\n\\n1. Initialize two variables count and zeros to 0.\\n\\n2. Traverse the array arr from left to right.\\n\\n3. If the current element is 0, increment the zeros variable by 1.\\n\\n4. If the current element is not 0, calculate the number of subarrays of 0\\'s that can be formed using the zeros variable and add it to the count variable. Reset the zeros variable to 0.\\n\\n5. After we have traversed the entire array, calculate the number of subarrays of 0\\'s that end at the last index separately using the zeros variable and add it to the count variable.\\n\\n6. Return the total count of subarrays of 0\\'s.\\n\\nSolution link -- https://leetcode.com/problems/number-of-zero-filled-subarrays/solutions/3324103/easy-c-solution-optimized-approach-step-wise-explanation-tc-on-sc-o1/"
                    },
                    {
                        "username": "jolswlf",
                        "content": "how is this marked as medium"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "leetcode !!! if you are looking, please mark it as EASY"
                    },
                    {
                        "username": "hridoy100",
                        "content": "**Can we consider other numbers in the array?**\\nNo. We cannot. The description clearly says: **return the number of subarrays filled with 0**. And the subarray is a contiguous non-empty sequence of elements."
                    },
                    {
                        "username": "RaRafiq3",
                        "content": "Input: nums = [0,0,0,2,0,0]\\nOutput: 9\\nExplanation:\\nThere are 5 occurrences of [0] as a subarray.\\nThere are 3 occurrences of [0,0] as a subarray.\\nThere is 1 occurrence of [0,0,0] as a subarray.\\nThere is no occurrence of a subarray with a size more than 3 filled with 0. Therefore, we return 9.\\n\\ntry this  N*(N+1)/2"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Is it just me or are these questions just getting easier?"
                    },
                    {
                        "username": "zhuzhupang001",
                        "content": "should be easy"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Hint</span>\n![](https://leetcode.com/problems/number-of-zero-filled-subarrays/Figures/2348/2348-1.png)\n![](https://leetcode.com/problems/number-of-zero-filled-subarrays/Figures/2348/2348-2_4.png)\n![](https://leetcode.com/problems/number-of-zero-filled-subarrays/Figures/2348/2348-4.png)"
                    },
                    {
                        "username": "uchihaXmadara",
                        "content": "why this one is medium."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I am so silly to use prefix sum and hashmap to ac the problem..."
                    },
                    {
                        "username": "DPcodes123",
                        "content": "did the same haha! used a recursive function to calculate total subarrays in a subarray of n length, then multiplied that by the total number of occurences of that length (which is tracked in the hashmap)\\n\\nIt passed at the 5th percentile lol"
                    }
                ]
            },
            {
                "id": 1839178,
                "content": [
                    {
                        "username": "Vishal_Singh7",
                        "content": "Steps:--\\n\\n1. Initialize two variables count and zeros to 0.\\n\\n2. Traverse the array arr from left to right.\\n\\n3. If the current element is 0, increment the zeros variable by 1.\\n\\n4. If the current element is not 0, calculate the number of subarrays of 0\\'s that can be formed using the zeros variable and add it to the count variable. Reset the zeros variable to 0.\\n\\n5. After we have traversed the entire array, calculate the number of subarrays of 0\\'s that end at the last index separately using the zeros variable and add it to the count variable.\\n\\n6. Return the total count of subarrays of 0\\'s.\\n\\nSolution link -- https://leetcode.com/problems/number-of-zero-filled-subarrays/solutions/3324103/easy-c-solution-optimized-approach-step-wise-explanation-tc-on-sc-o1/"
                    },
                    {
                        "username": "jolswlf",
                        "content": "how is this marked as medium"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "leetcode !!! if you are looking, please mark it as EASY"
                    },
                    {
                        "username": "hridoy100",
                        "content": "**Can we consider other numbers in the array?**\\nNo. We cannot. The description clearly says: **return the number of subarrays filled with 0**. And the subarray is a contiguous non-empty sequence of elements."
                    },
                    {
                        "username": "RaRafiq3",
                        "content": "Input: nums = [0,0,0,2,0,0]\\nOutput: 9\\nExplanation:\\nThere are 5 occurrences of [0] as a subarray.\\nThere are 3 occurrences of [0,0] as a subarray.\\nThere is 1 occurrence of [0,0,0] as a subarray.\\nThere is no occurrence of a subarray with a size more than 3 filled with 0. Therefore, we return 9.\\n\\ntry this  N*(N+1)/2"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Is it just me or are these questions just getting easier?"
                    },
                    {
                        "username": "zhuzhupang001",
                        "content": "should be easy"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Hint</span>\n![](https://leetcode.com/problems/number-of-zero-filled-subarrays/Figures/2348/2348-1.png)\n![](https://leetcode.com/problems/number-of-zero-filled-subarrays/Figures/2348/2348-2_4.png)\n![](https://leetcode.com/problems/number-of-zero-filled-subarrays/Figures/2348/2348-4.png)"
                    },
                    {
                        "username": "uchihaXmadara",
                        "content": "why this one is medium."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I am so silly to use prefix sum and hashmap to ac the problem..."
                    },
                    {
                        "username": "DPcodes123",
                        "content": "did the same haha! used a recursive function to calculate total subarrays in a subarray of n length, then multiplied that by the total number of occurences of that length (which is tracked in the hashmap)\\n\\nIt passed at the 5th percentile lol"
                    }
                ]
            },
            {
                "id": 1839166,
                "content": [
                    {
                        "username": "Vishal_Singh7",
                        "content": "Steps:--\\n\\n1. Initialize two variables count and zeros to 0.\\n\\n2. Traverse the array arr from left to right.\\n\\n3. If the current element is 0, increment the zeros variable by 1.\\n\\n4. If the current element is not 0, calculate the number of subarrays of 0\\'s that can be formed using the zeros variable and add it to the count variable. Reset the zeros variable to 0.\\n\\n5. After we have traversed the entire array, calculate the number of subarrays of 0\\'s that end at the last index separately using the zeros variable and add it to the count variable.\\n\\n6. Return the total count of subarrays of 0\\'s.\\n\\nSolution link -- https://leetcode.com/problems/number-of-zero-filled-subarrays/solutions/3324103/easy-c-solution-optimized-approach-step-wise-explanation-tc-on-sc-o1/"
                    },
                    {
                        "username": "jolswlf",
                        "content": "how is this marked as medium"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "leetcode !!! if you are looking, please mark it as EASY"
                    },
                    {
                        "username": "hridoy100",
                        "content": "**Can we consider other numbers in the array?**\\nNo. We cannot. The description clearly says: **return the number of subarrays filled with 0**. And the subarray is a contiguous non-empty sequence of elements."
                    },
                    {
                        "username": "RaRafiq3",
                        "content": "Input: nums = [0,0,0,2,0,0]\\nOutput: 9\\nExplanation:\\nThere are 5 occurrences of [0] as a subarray.\\nThere are 3 occurrences of [0,0] as a subarray.\\nThere is 1 occurrence of [0,0,0] as a subarray.\\nThere is no occurrence of a subarray with a size more than 3 filled with 0. Therefore, we return 9.\\n\\ntry this  N*(N+1)/2"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Is it just me or are these questions just getting easier?"
                    },
                    {
                        "username": "zhuzhupang001",
                        "content": "should be easy"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Hint</span>\n![](https://leetcode.com/problems/number-of-zero-filled-subarrays/Figures/2348/2348-1.png)\n![](https://leetcode.com/problems/number-of-zero-filled-subarrays/Figures/2348/2348-2_4.png)\n![](https://leetcode.com/problems/number-of-zero-filled-subarrays/Figures/2348/2348-4.png)"
                    },
                    {
                        "username": "uchihaXmadara",
                        "content": "why this one is medium."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I am so silly to use prefix sum and hashmap to ac the problem..."
                    },
                    {
                        "username": "DPcodes123",
                        "content": "did the same haha! used a recursive function to calculate total subarrays in a subarray of n length, then multiplied that by the total number of occurences of that length (which is tracked in the hashmap)\\n\\nIt passed at the 5th percentile lol"
                    }
                ]
            },
            {
                "id": 1839150,
                "content": [
                    {
                        "username": "Vishal_Singh7",
                        "content": "Steps:--\\n\\n1. Initialize two variables count and zeros to 0.\\n\\n2. Traverse the array arr from left to right.\\n\\n3. If the current element is 0, increment the zeros variable by 1.\\n\\n4. If the current element is not 0, calculate the number of subarrays of 0\\'s that can be formed using the zeros variable and add it to the count variable. Reset the zeros variable to 0.\\n\\n5. After we have traversed the entire array, calculate the number of subarrays of 0\\'s that end at the last index separately using the zeros variable and add it to the count variable.\\n\\n6. Return the total count of subarrays of 0\\'s.\\n\\nSolution link -- https://leetcode.com/problems/number-of-zero-filled-subarrays/solutions/3324103/easy-c-solution-optimized-approach-step-wise-explanation-tc-on-sc-o1/"
                    },
                    {
                        "username": "jolswlf",
                        "content": "how is this marked as medium"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "leetcode !!! if you are looking, please mark it as EASY"
                    },
                    {
                        "username": "hridoy100",
                        "content": "**Can we consider other numbers in the array?**\\nNo. We cannot. The description clearly says: **return the number of subarrays filled with 0**. And the subarray is a contiguous non-empty sequence of elements."
                    },
                    {
                        "username": "RaRafiq3",
                        "content": "Input: nums = [0,0,0,2,0,0]\\nOutput: 9\\nExplanation:\\nThere are 5 occurrences of [0] as a subarray.\\nThere are 3 occurrences of [0,0] as a subarray.\\nThere is 1 occurrence of [0,0,0] as a subarray.\\nThere is no occurrence of a subarray with a size more than 3 filled with 0. Therefore, we return 9.\\n\\ntry this  N*(N+1)/2"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Is it just me or are these questions just getting easier?"
                    },
                    {
                        "username": "zhuzhupang001",
                        "content": "should be easy"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Hint</span>\n![](https://leetcode.com/problems/number-of-zero-filled-subarrays/Figures/2348/2348-1.png)\n![](https://leetcode.com/problems/number-of-zero-filled-subarrays/Figures/2348/2348-2_4.png)\n![](https://leetcode.com/problems/number-of-zero-filled-subarrays/Figures/2348/2348-4.png)"
                    },
                    {
                        "username": "uchihaXmadara",
                        "content": "why this one is medium."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I am so silly to use prefix sum and hashmap to ac the problem..."
                    },
                    {
                        "username": "DPcodes123",
                        "content": "did the same haha! used a recursive function to calculate total subarrays in a subarray of n length, then multiplied that by the total number of occurences of that length (which is tracked in the hashmap)\\n\\nIt passed at the 5th percentile lol"
                    }
                ]
            },
            {
                "id": 1839110,
                "content": [
                    {
                        "username": "Vishal_Singh7",
                        "content": "Steps:--\\n\\n1. Initialize two variables count and zeros to 0.\\n\\n2. Traverse the array arr from left to right.\\n\\n3. If the current element is 0, increment the zeros variable by 1.\\n\\n4. If the current element is not 0, calculate the number of subarrays of 0\\'s that can be formed using the zeros variable and add it to the count variable. Reset the zeros variable to 0.\\n\\n5. After we have traversed the entire array, calculate the number of subarrays of 0\\'s that end at the last index separately using the zeros variable and add it to the count variable.\\n\\n6. Return the total count of subarrays of 0\\'s.\\n\\nSolution link -- https://leetcode.com/problems/number-of-zero-filled-subarrays/solutions/3324103/easy-c-solution-optimized-approach-step-wise-explanation-tc-on-sc-o1/"
                    },
                    {
                        "username": "jolswlf",
                        "content": "how is this marked as medium"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "leetcode !!! if you are looking, please mark it as EASY"
                    },
                    {
                        "username": "hridoy100",
                        "content": "**Can we consider other numbers in the array?**\\nNo. We cannot. The description clearly says: **return the number of subarrays filled with 0**. And the subarray is a contiguous non-empty sequence of elements."
                    },
                    {
                        "username": "RaRafiq3",
                        "content": "Input: nums = [0,0,0,2,0,0]\\nOutput: 9\\nExplanation:\\nThere are 5 occurrences of [0] as a subarray.\\nThere are 3 occurrences of [0,0] as a subarray.\\nThere is 1 occurrence of [0,0,0] as a subarray.\\nThere is no occurrence of a subarray with a size more than 3 filled with 0. Therefore, we return 9.\\n\\ntry this  N*(N+1)/2"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Is it just me or are these questions just getting easier?"
                    },
                    {
                        "username": "zhuzhupang001",
                        "content": "should be easy"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Hint</span>\n![](https://leetcode.com/problems/number-of-zero-filled-subarrays/Figures/2348/2348-1.png)\n![](https://leetcode.com/problems/number-of-zero-filled-subarrays/Figures/2348/2348-2_4.png)\n![](https://leetcode.com/problems/number-of-zero-filled-subarrays/Figures/2348/2348-4.png)"
                    },
                    {
                        "username": "uchihaXmadara",
                        "content": "why this one is medium."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I am so silly to use prefix sum and hashmap to ac the problem..."
                    },
                    {
                        "username": "DPcodes123",
                        "content": "did the same haha! used a recursive function to calculate total subarrays in a subarray of n length, then multiplied that by the total number of occurences of that length (which is tracked in the hashmap)\\n\\nIt passed at the 5th percentile lol"
                    }
                ]
            },
            {
                "id": 1839079,
                "content": [
                    {
                        "username": "Vishal_Singh7",
                        "content": "Steps:--\\n\\n1. Initialize two variables count and zeros to 0.\\n\\n2. Traverse the array arr from left to right.\\n\\n3. If the current element is 0, increment the zeros variable by 1.\\n\\n4. If the current element is not 0, calculate the number of subarrays of 0\\'s that can be formed using the zeros variable and add it to the count variable. Reset the zeros variable to 0.\\n\\n5. After we have traversed the entire array, calculate the number of subarrays of 0\\'s that end at the last index separately using the zeros variable and add it to the count variable.\\n\\n6. Return the total count of subarrays of 0\\'s.\\n\\nSolution link -- https://leetcode.com/problems/number-of-zero-filled-subarrays/solutions/3324103/easy-c-solution-optimized-approach-step-wise-explanation-tc-on-sc-o1/"
                    },
                    {
                        "username": "jolswlf",
                        "content": "how is this marked as medium"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "leetcode !!! if you are looking, please mark it as EASY"
                    },
                    {
                        "username": "hridoy100",
                        "content": "**Can we consider other numbers in the array?**\\nNo. We cannot. The description clearly says: **return the number of subarrays filled with 0**. And the subarray is a contiguous non-empty sequence of elements."
                    },
                    {
                        "username": "RaRafiq3",
                        "content": "Input: nums = [0,0,0,2,0,0]\\nOutput: 9\\nExplanation:\\nThere are 5 occurrences of [0] as a subarray.\\nThere are 3 occurrences of [0,0] as a subarray.\\nThere is 1 occurrence of [0,0,0] as a subarray.\\nThere is no occurrence of a subarray with a size more than 3 filled with 0. Therefore, we return 9.\\n\\ntry this  N*(N+1)/2"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Is it just me or are these questions just getting easier?"
                    },
                    {
                        "username": "zhuzhupang001",
                        "content": "should be easy"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Hint</span>\n![](https://leetcode.com/problems/number-of-zero-filled-subarrays/Figures/2348/2348-1.png)\n![](https://leetcode.com/problems/number-of-zero-filled-subarrays/Figures/2348/2348-2_4.png)\n![](https://leetcode.com/problems/number-of-zero-filled-subarrays/Figures/2348/2348-4.png)"
                    },
                    {
                        "username": "uchihaXmadara",
                        "content": "why this one is medium."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I am so silly to use prefix sum and hashmap to ac the problem..."
                    },
                    {
                        "username": "DPcodes123",
                        "content": "did the same haha! used a recursive function to calculate total subarrays in a subarray of n length, then multiplied that by the total number of occurences of that length (which is tracked in the hashmap)\\n\\nIt passed at the 5th percentile lol"
                    }
                ]
            },
            {
                "id": 1839050,
                "content": [
                    {
                        "username": "Vishal_Singh7",
                        "content": "Steps:--\\n\\n1. Initialize two variables count and zeros to 0.\\n\\n2. Traverse the array arr from left to right.\\n\\n3. If the current element is 0, increment the zeros variable by 1.\\n\\n4. If the current element is not 0, calculate the number of subarrays of 0\\'s that can be formed using the zeros variable and add it to the count variable. Reset the zeros variable to 0.\\n\\n5. After we have traversed the entire array, calculate the number of subarrays of 0\\'s that end at the last index separately using the zeros variable and add it to the count variable.\\n\\n6. Return the total count of subarrays of 0\\'s.\\n\\nSolution link -- https://leetcode.com/problems/number-of-zero-filled-subarrays/solutions/3324103/easy-c-solution-optimized-approach-step-wise-explanation-tc-on-sc-o1/"
                    },
                    {
                        "username": "jolswlf",
                        "content": "how is this marked as medium"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "leetcode !!! if you are looking, please mark it as EASY"
                    },
                    {
                        "username": "hridoy100",
                        "content": "**Can we consider other numbers in the array?**\\nNo. We cannot. The description clearly says: **return the number of subarrays filled with 0**. And the subarray is a contiguous non-empty sequence of elements."
                    },
                    {
                        "username": "RaRafiq3",
                        "content": "Input: nums = [0,0,0,2,0,0]\\nOutput: 9\\nExplanation:\\nThere are 5 occurrences of [0] as a subarray.\\nThere are 3 occurrences of [0,0] as a subarray.\\nThere is 1 occurrence of [0,0,0] as a subarray.\\nThere is no occurrence of a subarray with a size more than 3 filled with 0. Therefore, we return 9.\\n\\ntry this  N*(N+1)/2"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Is it just me or are these questions just getting easier?"
                    },
                    {
                        "username": "zhuzhupang001",
                        "content": "should be easy"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Hint</span>\n![](https://leetcode.com/problems/number-of-zero-filled-subarrays/Figures/2348/2348-1.png)\n![](https://leetcode.com/problems/number-of-zero-filled-subarrays/Figures/2348/2348-2_4.png)\n![](https://leetcode.com/problems/number-of-zero-filled-subarrays/Figures/2348/2348-4.png)"
                    },
                    {
                        "username": "uchihaXmadara",
                        "content": "why this one is medium."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I am so silly to use prefix sum and hashmap to ac the problem..."
                    },
                    {
                        "username": "DPcodes123",
                        "content": "did the same haha! used a recursive function to calculate total subarrays in a subarray of n length, then multiplied that by the total number of occurences of that length (which is tracked in the hashmap)\\n\\nIt passed at the 5th percentile lol"
                    }
                ]
            }
        ]
    }
]