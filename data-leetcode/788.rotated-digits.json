[
    {
        "title": "Rotated Digits",
        "question_content": "An integer x is a good if after rotating each digit individually by 180 degrees, we get a valid number that is different from x. Each digit must be rotated - we cannot choose to leave it alone.\nA number is valid if each digit remains a digit after rotation. For example:\n\n\t0, 1, and 8 rotate to themselves,\n\t2 and 5 rotate to each other (in this case they are rotated in a different direction, in other words, 2 or 5 gets mirrored),\n\t6 and 9 rotate to each other, and\n\tthe rest of the numbers do not rotate to any other number and become invalid.\n\nGiven an integer n, return the number of good integers in the range [1, n].\n&nbsp;\nExample 1:\n\nInput: n = 10\nOutput: 4\nExplanation: There are four good numbers in the range [1, 10] : 2, 5, 6, 9.\nNote that 1 and 10 are not good numbers, since they remain unchanged after rotating.\n\nExample 2:\n\nInput: n = 1\nOutput: 0\n\nExample 3:\n\nInput: n = 2\nOutput: 1\n\n&nbsp;\nConstraints:\n\n\t1 <= n <= 104",
        "solutions": [
            {
                "id": 117975,
                "title": "java-dp-solution-9ms",
                "content": "Using a int[] for dp.\ndp[i] = 0, invalid number\ndp[i] = 1, valid and same number\ndp[i] = 2, valid and different number\n```\n    public int rotatedDigits(int N) {\n        int[] dp = new int[N + 1];\n        int count = 0;\n        for(int i = 0; i <= N; i++){\n            if(i < 10){\n                if(i == 0 || i == 1 || i == 8) dp[i] = 1;\n                else if(i == 2 || i == 5 || i == 6 || i == 9){\n                    dp[i] = 2;\n                    count++;\n                }\n            } else {\n                int a = dp[i / 10], b = dp[i % 10];\n                if(a == 1 && b == 1) dp[i] = 1;\n                else if(a >= 1 && b >= 1){\n                    dp[i] = 2;\n                    count++;\n                }\n            }\n        }\n        return count;\n    }\n```",
                "solutionTags": [],
                "code": "```\n    public int rotatedDigits(int N) {\n        int[] dp = new int[N + 1];\n        int count = 0;\n        for(int i = 0; i <= N; i++){\n            if(i < 10){\n                if(i == 0 || i == 1 || i == 8) dp[i] = 1;\n                else if(i == 2 || i == 5 || i == 6 || i == 9){\n                    dp[i] = 2;\n                    count++;\n                }\n            } else {\n                int a = dp[i / 10], b = dp[i % 10];\n                if(a == 1 && b == 1) dp[i] = 1;\n                else if(a >= 1 && b >= 1){\n                    dp[i] = 2;\n                    count++;\n                }\n            }\n        }\n        return count;\n    }\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 116547,
                "title": "easily-understood-java-solution",
                "content": "```\nclass Solution {\n    public int rotatedDigits(int N) {\n        int count = 0;\n        for (int i = 1; i <= N; i ++) {\n            if (isValid(i)) count ++;\n        }\n        return count;\n    }\n    \n    public boolean isValid(int N) {\n        /*\n         Valid if N contains ATLEAST ONE 2, 5, 6, 9\n         AND NO 3, 4 or 7s\n         */\n        boolean validFound = false;\n        while (N > 0) {\n            if (N % 10 == 2) validFound = true;\n            if (N % 10 == 5) validFound = true;\n            if (N % 10 == 6) validFound = true;\n            if (N % 10 == 9) validFound = true;\n            if (N % 10 == 3) return false;\n            if (N % 10 == 4) return false;\n            if (N % 10 == 7) return false;\n            N = N / 10;\n        }\n        return validFound;\n    }\n}\n```",
                "solutionTags": [],
                "code": "```\nclass Solution {\n    public int rotatedDigits(int N) {\n        int count = 0;\n        for (int i = 1; i <= N; i ++) {\n            if (isValid(i)) count ++;\n        }\n        return count;\n    }\n    \n    public boolean isValid(int N) {\n        /*\n         Valid if N contains ATLEAST ONE 2, 5, 6, 9\n         AND NO 3, 4 or 7s\n         */\n        boolean validFound = false;\n        while (N > 0) {\n            if (N % 10 == 2) validFound = true;\n            if (N % 10 == 5) validFound = true;\n            if (N % 10 == 6) validFound = true;\n            if (N % 10 == 9) validFound = true;\n            if (N % 10 == 3) return false;\n            if (N % 10 == 4) return false;\n            if (N % 10 == 7) return false;\n            N = N / 10;\n        }\n        return validFound;\n    }\n}\n```",
                "codeTag": "Java"
            },
            {
                "id": 116530,
                "title": "java-python-o-logn-time-o-1-space",
                "content": "# Soluton 1\\n5 lines, self-explaining\\n\\n`s1 = set([1, 8, 0])` \"A number is valid if each digit remains a digit after rotation. 0, 1, and 8 rotate to themselves\"\\n`s2 = set([1, 8, 0, 6, 9, 2, 5])`, \"2 and 5 rotate to each other, 6 and 9 rotate to each other\"\\n\\n`s.issubset(s2)`, \"X is a good number if after rotating each digit individually by 180 degrees, \"\\n`not s.issubset(s1)` \"we get a valid number that is different from X. \"\\n\\n```py\\n  def rotatedDigits(self, N):\\n        s1 = set([1, 8, 0])\\n        s2 = set([1, 8, 0, 6, 9, 2, 5])\\n        def isGood(x):\\n            s = set([int(i) for i in str(x)])\\n            return s.issubset(s2) and not s.issubset(s1)\\n        return sum(isGood(i) for i in range(N + 1))\\n```\\n<br>\\n\\n# Solution 2\\n`O(NlogN)` solution is simple in all languages.\\nHere is solution in `O(logN)` complexity.\\n```py\\n  def rotatedDigits(self, N):\\n        s1 = set([0, 1, 8])\\n        s2 = set([0, 1, 8, 2, 5, 6, 9])\\n        s = set()\\n        res = 0\\n        N = map(int, str(N))\\n        for i, v in enumerate(N):\\n            for j in range(v):\\n                if s.issubset(s2) and j in s2:\\n                    res += 7**(len(N) - i - 1)\\n                if s.issubset(s1) and j in s1:\\n                    res -= 3**(len(N) - i - 1)\\n            if v not in s2:\\n                return res\\n            s.add(v)\\n        return res + (s.issubset(s2) and not s.issubset(s1))\\n```\\n**Java**\\n```java\\npublic int rotatedDigits(int N) {\\n    char[] chars = Integer.toString(N).toCharArray();\\n    int res = 0;\\n    HashSet<Integer> digits = new HashSet<>();\\n    for (int i = 0; i < chars.length; i++) {\\n        int digit = chars[i] - \\'0\\';\\n        for (int j = 0; j < digit; j++) {\\n            if (set2.contains(j)) {\\n                res += (int)Math.pow(7, chars.length - i - 1);\\n            }\\n            if (set1.containsAll(digits) && set1.contains(j)) {\\n                res -= (int)Math.pow(3, chars.length - i - 1);\\n            }\\n        }\\n        digits.add(digit);\\n        if (!set2.contains(digit)) {\\n            return res;\\n        }\\n\\n    }\\n\\n    return res + (!set1.containsAll(digits) ? 1 : 0);\\n}\\n```",
                "solutionTags": [],
                "code": "```py\\n  def rotatedDigits(self, N):\\n        s1 = set([1, 8, 0])\\n        s2 = set([1, 8, 0, 6, 9, 2, 5])\\n        def isGood(x):\\n            s = set([int(i) for i in str(x)])\\n            return s.issubset(s2) and not s.issubset(s1)\\n        return sum(isGood(i) for i in range(N + 1))\\n```\n```py\\n  def rotatedDigits(self, N):\\n        s1 = set([0, 1, 8])\\n        s2 = set([0, 1, 8, 2, 5, 6, 9])\\n        s = set()\\n        res = 0\\n        N = map(int, str(N))\\n        for i, v in enumerate(N):\\n            for j in range(v):\\n                if s.issubset(s2) and j in s2:\\n                    res += 7**(len(N) - i - 1)\\n                if s.issubset(s1) and j in s1:\\n                    res -= 3**(len(N) - i - 1)\\n            if v not in s2:\\n                return res\\n            s.add(v)\\n        return res + (s.issubset(s2) and not s.issubset(s1))\\n```\n```java\\npublic int rotatedDigits(int N) {\\n    char[] chars = Integer.toString(N).toCharArray();\\n    int res = 0;\\n    HashSet<Integer> digits = new HashSet<>();\\n    for (int i = 0; i < chars.length; i++) {\\n        int digit = chars[i] - \\'0\\';\\n        for (int j = 0; j < digit; j++) {\\n            if (set2.contains(j)) {\\n                res += (int)Math.pow(7, chars.length - i - 1);\\n            }\\n            if (set1.containsAll(digits) && set1.contains(j)) {\\n                res -= (int)Math.pow(3, chars.length - i - 1);\\n            }\\n        }\\n        digits.add(digit);\\n        if (!set2.contains(digit)) {\\n            return res;\\n        }\\n\\n    }\\n\\n    return res + (!set1.containsAll(digits) ? 1 : 0);\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 130681,
                "title": "simple-easy-c",
                "content": "```\\n        int f[] = {1,1,2,0,0,2,2,0,1,2};\\n        int res = 0;\\n        for(int i = 1; i <= N; i++){\\n            int p = i;\\n            int s = 1;\\n            while(p){\\n                s *= f[p%10];\\n                p /= 10;\\n            }\\n            if(s >=2) res+=1;\\n        }\\n        return res;",
                "solutionTags": [],
                "code": "```\\n        int f[] = {1,1,2,0,0,2,2,0,1,2};\\n        int res = 0;\\n        for(int i = 1; i <= N; i++){\\n            int p = i;\\n            int s = 1;\\n            while(p){\\n                s *= f[p%10];\\n                p /= 10;\\n            }\\n            if(s >=2) res+=1;\\n        }\\n        return res;",
                "codeTag": "Unknown"
            },
            {
                "id": 116658,
                "title": "the-question-need-to-be-explained-clearly",
                "content": "after looking at the accepted solution, I found that, to be a \"good\" number, every digit must be roated, for example ```23``` is not a good number although, it can be roated to ```53```\\n\\nUpdate: The question description has been updated as mentioned by @awice",
                "solutionTags": [],
                "code": "```23```\n```53```",
                "codeTag": "Unknown"
            },
            {
                "id": 116539,
                "title": "easy-to-understand-python-solution-using-string",
                "content": "Used string indexing instead of integer division in my solution, which might be inefficient. But here's my solution anyways:\n```\nclass Solution(object):\n    def rotatedDigits(self, N):\n        counts = 0\n        for num in range(1, N+1):\n            number = str(num)\n            if '3' in number or '7' in number or '4' in number: # This will be an invalid number upon rotation\n                continue # Skip this number and go to next iteration\n            if '2' in number or '5' in number or '6' in number or '9' in number:\n                counts += 1\n        return counts\n```",
                "solutionTags": [],
                "code": "```\nclass Solution(object):\n    def rotatedDigits(self, N):\n        counts = 0\n        for num in range(1, N+1):\n            number = str(num)\n            if '3' in number or '7' in number or '4' in number: # This will be an invalid number upon rotation\n                continue # Skip this number and go to next iteration\n            if '2' in number or '5' in number or '6' in number or '9' in number:\n                counts += 1\n        return counts\n```",
                "codeTag": "Java"
            },
            {
                "id": 485290,
                "title": "easy-understand-solution-python-o-1-space",
                "content": "```\\ndef rotatedDigits(self, N: int) -> int:\\n        count = 0\\n        for d in range(1, N+1):\\n            d = str(d)\\n            if \\'3\\' in d or \\'4\\' in d or \\'7\\' in d:\\n                continue\\n            if \\'2\\' in d or \\'5\\' in d or \\'6\\' in d or \\'9\\' in d:\\n                count+=1\\n        return count\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef rotatedDigits(self, N: int) -> int:\\n        count = 0\\n        for d in range(1, N+1):\\n            d = str(d)\\n            if \\'3\\' in d or \\'4\\' in d or \\'7\\' in d:\\n                continue\\n            if \\'2\\' in d or \\'5\\' in d or \\'6\\' in d or \\'9\\' in d:\\n                count+=1\\n        return count\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 379257,
                "title": "easy-c-solution-0ms-less-than-100-memory",
                "content": "Runtime: 0 ms, faster than 100.00% of C++ online submissions for Rotated Digits.\\nMemory Usage: 8.1 MB, less than 100.00% of C++ online submissions for Rotated Digits.\\n\\n```\\nint rotatedDigits(int N) {\\n        \\n        int count = 0;\\n        for(int i=1; i<=N; i++)\\n        {\\n            bool flag = false;\\n            int num = i;\\n            while(num > 0)\\n            {\\n                int d = num%10;\\n                if(d == 3 || d == 4 || d == 7)\\n                {\\n                    flag = false;\\n                    break;\\n                }\\n                if(d == 2 || d == 5 || d == 6 || d == 9)\\n                    flag = true;\\n                \\n                num = num/10;\\n            }\\n            if(flag) count++;\\n        }\\n        return count;\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "Runtime: 0 ms, faster than 100.00% of C++ online submissions for Rotated Digits.\\nMemory Usage: 8.1 MB, less than 100.00% of C++ online submissions for Rotated Digits.\\n\\n```\\nint rotatedDigits(int N) {\\n        \\n        int count = 0;\\n        for(int i=1; i<=N; i++)\\n        {\\n            bool flag = false;\\n            int num = i;\\n            while(num > 0)\\n            {\\n                int d = num%10;\\n                if(d == 3 || d == 4 || d == 7)\\n                {\\n                    flag = false;\\n                    break;\\n                }\\n                if(d == 2 || d == 5 || d == 6 || d == 9)\\n                    flag = true;\\n                \\n                num = num/10;\\n            }\\n            if(flag) count++;\\n        }\\n        return count;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 116674,
                "title": "o-log10-n-easy-to-understand-java-solution",
                "content": "\n```\nclass Solution {\n    private int[] allPossibleCount =  new int[]{1,2,3,3,3,4,5,5,6,7}; // 0,1,2,5,6,8,9\n    private int[] excludeNumCount = new int[]{1,2,2,2,2,2,2,2,3,3}; // 0, 1, 8\n    private boolean[] isExclude = new boolean[] {true,true,false,false,false,false,false,false,true,false};\n    private boolean[] isValid = new boolean[]{true, true, true, false,false,true, true,false,true,true};\n    public int rotatedDigits(int N) {\n        char[] cs = Integer.toString(N).toCharArray();\n        int len = cs.length, count = 0;        \n        boolean exclude = true;\n        for(int i = 0, mul = len; i<len; i++, mul--)\n        {\n            if(cs[i] == '0'&& i != len-1 )continue;\n            int index = i == len-1? cs[i]-'0': cs[i]-'0'-1;\n            double c =  allPossibleCount[index]*Math.pow(7,mul-1);   \n            double e =  exclude ? excludeNumCount[index]*Math.pow(3,mul-1) : 0; // # of numbers which only contain 0,1,8\n            count+=c-e;\n            if(!isValid[cs[i]-'0'])break;\n            exclude = exclude & isExclude[cs[i]-'0'];\n        }\n        return count;\n    }\n}\n```",
                "solutionTags": [],
                "code": "```\nclass Solution {\n    private int[] allPossibleCount =  new int[]{1,2,3,3,3,4,5,5,6,7}; // 0,1,2,5,6,8,9\n    private int[] excludeNumCount = new int[]{1,2,2,2,2,2,2,2,3,3}; // 0, 1, 8\n    private boolean[] isExclude = new boolean[] {true,true,false,false,false,false,false,false,true,false};\n    private boolean[] isValid = new boolean[]{true, true, true, false,false,true, true,false,true,true};\n    public int rotatedDigits(int N) {\n        char[] cs = Integer.toString(N).toCharArray();\n        int len = cs.length, count = 0;        \n        boolean exclude = true;\n        for(int i = 0, mul = len; i<len; i++, mul--)\n        {\n            if(cs[i] == '0'&& i != len-1 )continue;\n            int index = i == len-1? cs[i]-'0': cs[i]-'0'-1;\n            double c =  allPossibleCount[index]*Math.pow(7,mul-1);   \n            double e =  exclude ? excludeNumCount[index]*Math.pow(3,mul-1) : 0; // # of numbers which only contain 0,1,8\n            count+=c-e;\n            if(!isValid[cs[i]-'0'])break;\n            exclude = exclude & isExclude[cs[i]-'0'];\n        }\n        return count;\n    }\n}\n```",
                "codeTag": "Java"
            },
            {
                "id": 1307796,
                "title": "stupid-solution-to-stupid-problem-java",
                "content": "Basically, if you your number contains any digits that cannot be rotated, it becomes invalid (3, 4, 7)\\nIf it contains any of the digits that can be rotated that creates a new digit (2, 5, 6, 9), then rotating it will always create a new overall number.\\nThe ones that can rotate and do not create a new digit (0, 1, 8) don\\'t do anything to the overall number. 808 flipped is still 808. The only way a new number can be created is if the number contains a 2, 5, 6, or 9.\\n\\n```\\nclass Solution {\\n    public int rotatedDigits(int N) {\\n      int count = 0;\\n      for(int i = 0; i <= N; i++) {\\n        String s = String.valueOf(i);\\n        if(s.contains(\"3\")) continue;\\n        if(s.contains(\"4\")) continue;\\n        if(s.contains(\"7\")) continue;\\n        \\n        if(s.contains(\"2\") || s.contains(\"5\") || s.contains(\"6\") || s.contains(\"9\")) count++;\\n        \\n      }\\n      return count;\\n    }\\n}\\n```\\nUpvote if this helped you \\uD83D\\uDC4D",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int rotatedDigits(int N) {\\n      int count = 0;\\n      for(int i = 0; i <= N; i++) {\\n        String s = String.valueOf(i);\\n        if(s.contains(\"3\")) continue;\\n        if(s.contains(\"4\")) continue;\\n        if(s.contains(\"7\")) continue;\\n        \\n        if(s.contains(\"2\") || s.contains(\"5\") || s.contains(\"6\") || s.contains(\"9\")) count++;\\n        \\n      }\\n      return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 116519,
                "title": "python-solution",
                "content": "```\ndef rotatedDigits(self, N):\n    def isValidRotation(num):\n        return (not any(s in {'3', '4', '7'} for s in num)) and any(s in {'2', '5', '6', '9'} for s in num)\n\n    return sum([isValidRotation(str(i)) for i in range(1, N+1)])\n```",
                "solutionTags": [],
                "code": "```\ndef rotatedDigits(self, N):\n    def isValidRotation(num):\n        return (not any(s in {'3', '4', '7'} for s in num)) and any(s in {'2', '5', '6', '9'} for s in num)\n\n    return sum([isValidRotation(str(i)) for i in range(1, N+1)])\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1286139,
                "title": "100-faster-very-easy-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int rotatedDigits(int N) {\\n        int ans=0;\\n        for(int i=2;i<=N;i++)\\n        {\\n            ans+=check(i);\\n        }\\n        return ans;\\n    }\\n    \\n    bool check(int n)\\n    {\\n        int t;\\n        bool flag=0;\\n        while(n)\\n        {\\n            t=n%10;\\n            if(t==3 || t==4 || t==7 )return 0;\\n            if(t==2 || t==5 || t==6 || t==9) flag=1;\\n            n/=10;\\n        }\\n        return flag;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int rotatedDigits(int N) {\\n        int ans=0;\\n        for(int i=2;i<=N;i++)\\n        {\\n            ans+=check(i);\\n        }\\n        return ans;\\n    }\\n    \\n    bool check(int n)\\n    {\\n        int t;\\n        bool flag=0;\\n        while(n)\\n        {\\n            t=n%10;\\n            if(t==3 || t==4 || t==7 )return 0;\\n            if(t==2 || t==5 || t==6 || t==9) flag=1;\\n            n/=10;\\n        }\\n        return flag;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 335145,
                "title": "python-maybe-o-log-n-with-comments",
                "content": "This turned out quite complicated as there are a few edge-cases. The basic idea is this:\\n\\nSay you have the number `N = 6789`.  We will break the count into two parts:\\n1. We will first count all of the good numbers in `{0000, 0001, ..., 5999}`. For each choice of first digit in `{0, 1, ..., 5}` we do the following:\\n\\t* If it is not rotatable (i.e. it is 3, 4, or 7), we add nothing to the count.\\n\\t* If it is rotatable and not symmetric (i.e. it is 2, 5, 6, or 9), we add 7^3 to the count -- this is the number of good numbers in `{000, 001, ..., 999}` when you include those that transform to themselves.\\n\\t* If it is rotatable and symmetric (i.e. it is 0, 1, or 8), we add (7^3 - 3^3) to the count -- this is the number of good numbers in `{000, 001, ..., 999}` when you exclude those that transform to themselves.\\n2. We will then count all of the good numbers in `{6000, 6001, ..., 6789}`. We can do this part recursively as we just need to count the good numbers in `{000, 001, ..., 789}`. But because 6 is not symmetric, we will include numbers that transform to themselves. If the first digit were 0, 1, or 8, we would exclude from the count numbers that transform to themselves.\\n\\nI\\'m fairly sure this algorithm is either O(log(n)) or O((log(n))<sup>2</sup>). If anyone wants to do the analysis, feel free to leave it in the comments.\\n\\n```python\\nrotatable_digits = (0, 1, 2, 5, 6, 8, 9)\\nsymmetric_digits = (0, 1, 8)\\n\\ndef count_good_numbers(n, must_change=True):\\n    \"\"\"Count how many \\'good\\' numbers there are in {1, ... , n}.\\n\\n    A number is considered \\'good\\' if rotating all of it\\'s digits\\n    individually produces a valid number.  If must_change, the\\n    resultant number must be different from the original number.\\n\\n     - The digits 0, 1, and 8 rotate to produce themselves.\\n     - The digit 2 rotates to produce 5, and vice-versa.\\n     - The digit 6 rotates to produce 9, and vice-versa.\\n    \"\"\"\\n    digits      = str(n)\\n    first_digit = int(digits[0])\\n    total       = 0\\n\\n    # First, we will count all of the \\'good\\' numbers up to, but not including\\n    # first_digit * 10^k, where k = len(digits)-1.\\n    \\n    # For example, if n = 6789, we will count all of the good numbers in \\n    # {0, ..., 5999}. (We include 0 to simplify the implementation, but as it is not a\\n    # good number, it will not be counted.)\\n\\n    for digit in range(first_digit):\\n        # We add the numbers that start with `digit`, and have the same number of digits\\n        # as n (after adding leading zeroes), and are composed of only rotatable digits.\\n\\n        # How many are there? There are seven rotatable digits, so the number\\n        # of ways of building a length-i sequence of them is 7^i.\\n\\n        if digit in rotatable_digits:\\n            total += 7**(len(digits)-1)\\n\\n        # We subtract out the numbers that are composed of only symmetric digits. \\n        # (These numbers are not \\'good\\' as they transform to themselves.)  We only \\n        # do this if `must_change` is True.\\n\\n        # How many are there? There are three symmetric digits, so the number of \\n        # ways of building a length-i sequence of them is 3^i.\\n\\n        if must_change and (digit in symmetric_digits):\\n            total -= 3**(len(digits)-1)\\n\\n    # If n is a multi-digit number, we might not yet have counted all the \\'good\\' numbers.\\n\\n    # For example, if n = 6789, we\\'ve counted all the good numbers in {0, ..., 5999},\\n    # but we\\'ve not yet counted all the good numbers in {6000, ..., 6789}.\\n\\n    # But we only need to do this if the first digit is rotatable, as otherwise none of\\n    # these numbers are \\'good\\'.\\n\\n    if (len(digits) > 1) and (first_digit in rotatable_digits):\\n        rest_of_digits = int(digits[1:])\\n        total += count_good_numbers(\\n            rest_of_digits,\\n            # If the first digit is non-symmetric, then the transformed number\\n\\t\\t\\t# will be different from the original number regardless of whether the\\n\\t\\t\\t# rest of the digits are symmetric.\\n            must_change = False if (first_digit not in symmetric_digits) else must_change\\n        )\\n\\n    # Otherwise, if n is a single-digit number, we may need to include  n itself in the \\n    # count.\\n    \\n    # For example, if n = 6, so far we have only counted 2 and 5, and we need to include 6.\\n\\n    if (len(digits) == 1) and (first_digit in rotatable_digits):\\n        if (not must_change) or (first_digit not in symmetric_digits):\\n            total += 1\\n\\n    return total\\n```",
                "solutionTags": [],
                "code": "```python\\nrotatable_digits = (0, 1, 2, 5, 6, 8, 9)\\nsymmetric_digits = (0, 1, 8)\\n\\ndef count_good_numbers(n, must_change=True):\\n    \"\"\"Count how many \\'good\\' numbers there are in {1, ... , n}.\\n\\n    A number is considered \\'good\\' if rotating all of it\\'s digits\\n    individually produces a valid number.  If must_change, the\\n    resultant number must be different from the original number.\\n\\n     - The digits 0, 1, and 8 rotate to produce themselves.\\n     - The digit 2 rotates to produce 5, and vice-versa.\\n     - The digit 6 rotates to produce 9, and vice-versa.\\n    \"\"\"\\n    digits      = str(n)\\n    first_digit = int(digits[0])\\n    total       = 0\\n\\n    # First, we will count all of the \\'good\\' numbers up to, but not including\\n    # first_digit * 10^k, where k = len(digits)-1.\\n    \\n    # For example, if n = 6789, we will count all of the good numbers in \\n    # {0, ..., 5999}. (We include 0 to simplify the implementation, but as it is not a\\n    # good number, it will not be counted.)\\n\\n    for digit in range(first_digit):\\n        # We add the numbers that start with `digit`, and have the same number of digits\\n        # as n (after adding leading zeroes), and are composed of only rotatable digits.\\n\\n        # How many are there? There are seven rotatable digits, so the number\\n        # of ways of building a length-i sequence of them is 7^i.\\n\\n        if digit in rotatable_digits:\\n            total += 7**(len(digits)-1)\\n\\n        # We subtract out the numbers that are composed of only symmetric digits. \\n        # (These numbers are not \\'good\\' as they transform to themselves.)  We only \\n        # do this if `must_change` is True.\\n\\n        # How many are there? There are three symmetric digits, so the number of \\n        # ways of building a length-i sequence of them is 3^i.\\n\\n        if must_change and (digit in symmetric_digits):\\n            total -= 3**(len(digits)-1)\\n\\n    # If n is a multi-digit number, we might not yet have counted all the \\'good\\' numbers.\\n\\n    # For example, if n = 6789, we\\'ve counted all the good numbers in {0, ..., 5999},\\n    # but we\\'ve not yet counted all the good numbers in {6000, ..., 6789}.\\n\\n    # But we only need to do this if the first digit is rotatable, as otherwise none of\\n    # these numbers are \\'good\\'.\\n\\n    if (len(digits) > 1) and (first_digit in rotatable_digits):\\n        rest_of_digits = int(digits[1:])\\n        total += count_good_numbers(\\n            rest_of_digits,\\n            # If the first digit is non-symmetric, then the transformed number\\n\\t\\t\\t# will be different from the original number regardless of whether the\\n\\t\\t\\t# rest of the digits are symmetric.\\n            must_change = False if (first_digit not in symmetric_digits) else must_change\\n        )\\n\\n    # Otherwise, if n is a single-digit number, we may need to include  n itself in the \\n    # count.\\n    \\n    # For example, if n = 6, so far we have only counted 2 and 5, and we need to include 6.\\n\\n    if (len(digits) == 1) and (first_digit in rotatable_digits):\\n        if (not must_change) or (first_digit not in symmetric_digits):\\n            total += 1\\n\\n    return total\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 144466,
                "title": "javascript-solution-68ms-beats-82-02-use-regular-expression-simple-and-straightforward",
                "content": "```\\nvar rotatedDigits = function(N) {\\n    let count = 0;\\n    for(let i=1; i<=N; i++){\\n    \\tlet tmp = i+\\'\\';\\n    \\tif(!/[347]/g.test(tmp) && /[2569]/g.test(tmp)) count++;\\n    }\\n    return count;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar rotatedDigits = function(N) {\\n    let count = 0;\\n    for(let i=1; i<=N; i++){\\n    \\tlet tmp = i+\\'\\';\\n    \\tif(!/[347]/g.test(tmp) && /[2569]/g.test(tmp)) count++;\\n    }\\n    return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 264282,
                "title": "java-o-logn-0ms-100",
                "content": "```\\nclass Solution {\\n    public int rotatedDigits(int N) {\\n        int[] rotate = {0, 0, 1, -1, -1, 1, 1, -1, 0, 1};\\n        List<Integer> ds = new ArrayList();\\n        while (N > 0) {\\n            ds.add(N % 10);\\n            N /= 10;\\n        }\\n        int count = 0;\\n        boolean diff = false;\\n        for (int i = ds.size() - 1; i > -1; --i) {\\n            int good = 0, soso = 0, d = ds.get(i);\\n            for (int j = 0; j < d; ++j) {\\n                if (rotate[j] == 1) ++good;\\n                else if (rotate[j] == 0) ++soso;\\n            }\\n            count += (good + soso) * Math.pow(7, i);\\n            if (!diff) count -= soso * Math.pow(3, i);\\n            if (rotate[d] == -1) return count;\\n            if (rotate[d] == 1) diff = true;\\n        }\\n        return diff && rotate[ds.get(0)] > -1 ? count + 1 : count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int rotatedDigits(int N) {\\n        int[] rotate = {0, 0, 1, -1, -1, 1, 1, -1, 0, 1};\\n        List<Integer> ds = new ArrayList();\\n        while (N > 0) {\\n            ds.add(N % 10);\\n            N /= 10;\\n        }\\n        int count = 0;\\n        boolean diff = false;\\n        for (int i = ds.size() - 1; i > -1; --i) {\\n            int good = 0, soso = 0, d = ds.get(i);\\n            for (int j = 0; j < d; ++j) {\\n                if (rotate[j] == 1) ++good;\\n                else if (rotate[j] == 0) ++soso;\\n            }\\n            count += (good + soso) * Math.pow(7, i);\\n            if (!diff) count -= soso * Math.pow(3, i);\\n            if (rotate[d] == -1) return count;\\n            if (rotate[d] == 1) diff = true;\\n        }\\n        return diff && rotate[ds.get(0)] > -1 ? count + 1 : count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1172132,
                "title": "java-clean-dfs-solution-with-interview-tips",
                "content": "This problem for me should not be under \"Easy\" tag. It is a similar problem to the Strobogrammatic Number\\'s series that I mentioned below. I recommand checking this solution and get familiar with the structure of dfs algorithm. \\n\\nIt\\'s worth mentioning that, as mentioned in many other posts, there are mathematics-based solutions of this questions, achieving O(logN) time complexity. However, this article is devoted to the dfs solution for a couple of reasons. \\n\\nThis dfs solution works more generally; its structure is applied in many similar questions, including those mentioned below. It\\'s indeed lucky if we see this exact question in a real interview. Chances are that, however, the question might be in a modified version. Thus instead of finding the mathematic rule based on each question, mastering writing **your own** version of dfs solution seems like a safer choice. \\n\\nBesides its robustness, the dfs solution is very natural. You can easily introduce the thought process and demo your algorithm to the interviewer. This is in particularly true if you only have the access to an online doc. As you might not have a pen and a white board, a math-based solution can be sometimes tricky to understand.  \\n\\nThus this article is on my version of dfs solution. This is my \"go-to\" guideline if I can\\'t make up a clever solution or can\\'t convince myself its correctness. It\\'s great if you might take something from my solution to generate yours. \\n\\nThis structure of code works very well in all similar problems:\\n\\n* [1088. Confusing Number II](https://leetcode.com/problems/confusing-number-ii/discuss/1117746/Java-Clean-Backtracking-Solution-oror-with-detailed-explanation)\\n* [247. Strobogrammatic Number II](https://leetcode.com/problems/strobogrammatic-number-ii/discuss/1117755/Java-clean-Backtracking-Solution-oror-with-comments) \\n* [248. Strobogrammatic Number III](https://leetcode.com/problems/strobogrammatic-number-iii/discuss/1117750/Java-clean-Backtracking-Solution-oror-with-comments)\\n\\n```\\nclass Solution {\\n    private static final char[] ROTATE_SAME = {\\'0\\', \\'1\\', \\'8\\'};\\n    private static final char[] ROTATE_DIFF = {\\'2\\', \\'5\\', \\'6\\', \\'9\\'};\\n    private int count = 0;\\n    private String high;\\n    \\n    public int rotatedDigits(int N) {\\n        this.high = String.valueOf(N);\\n        \\n        for (int len = 1; len <= high.length(); len++) \\n            dfs(0, new char[len], false);\\n        \\n        return count;\\n    }\\n    \\n    private void dfs(int idx, char[] arr, boolean valid) {\\n        if (idx == arr.length) {\\n            if (!valid) return;\\n            String res = new String(arr);\\n            if (!(res.length() == high.length() && res.compareTo(high) > 0)) count++;\\n            return;\\n        }\\n        \\n        for (char c : ROTATE_SAME) {\\n            if (idx == 0 && c == \\'0\\') continue;\\n            arr[idx] = c;\\n            dfs(idx + 1, arr, valid);\\n        }\\n        \\n        for (char c : ROTATE_DIFF) {\\n            arr[idx] = c;\\n            dfs(idx + 1, arr, true);\\n        }\\n    }\\n}\\n```\\n\\n**Time Complexity:**\\n\\nGiven an input N, we know it\\'s length (number of digits) is of O(logN). The time complexity of the main function is determined by the for-loop. The for-loop iterating through different lengths **len** from 1 to logN.  \\n\\nFor each length **len**, the helper function dfs() does these two things:\\n```\\n1. (recursive step)  try each of 7 options at each digit             (from index 0 to len - 1)\\n\\t\\t==> O(7 ^ len)  time\\n2. (base case)       construct new String() and compare each digit   (after index len - 1)\\n\\t\\t==> O(len)  time\\n```\\nThus the dfs() call with length **len** takes O(7 ^ len * len) time. \\n\\nNow we return to the main function and denote\\n```\\n// O(T) := total time complexity \\nT  =  7 ^ 1 * 1  +  7 ^ 2 * 2  +  ...  +  7 ^ (logN) * (logN)\\n  >=  7 ^ (logN) * (logN)\\n   =  O(N * logN)\\n\\n// Also from the other direction of the Squeeze Theorem: \\nT  <=  7 ^ 1 * (logN)  +  7 ^ 2 * (logN)  +  ...  + 7 ^ (logN) * (logN)\\n    =  (logN)  *  (7 ^ 1  +  7 ^ 2  +  ...  + 7 ^ logN)\\n    =  (logN)  * (7 ^ logN * 7 - 7) / 6\\n    =  (logN)  * O(7 ^ logN)\\n\\t=  O(N * logN)\\n```\\nThus the total time complexity is **O(N * logN)**.",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    private static final char[] ROTATE_SAME = {\\'0\\', \\'1\\', \\'8\\'};\\n    private static final char[] ROTATE_DIFF = {\\'2\\', \\'5\\', \\'6\\', \\'9\\'};\\n    private int count = 0;\\n    private String high;\\n    \\n    public int rotatedDigits(int N) {\\n        this.high = String.valueOf(N);\\n        \\n        for (int len = 1; len <= high.length(); len++) \\n            dfs(0, new char[len], false);\\n        \\n        return count;\\n    }\\n    \\n    private void dfs(int idx, char[] arr, boolean valid) {\\n        if (idx == arr.length) {\\n            if (!valid) return;\\n            String res = new String(arr);\\n            if (!(res.length() == high.length() && res.compareTo(high) > 0)) count++;\\n            return;\\n        }\\n        \\n        for (char c : ROTATE_SAME) {\\n            if (idx == 0 && c == \\'0\\') continue;\\n            arr[idx] = c;\\n            dfs(idx + 1, arr, valid);\\n        }\\n        \\n        for (char c : ROTATE_DIFF) {\\n            arr[idx] = c;\\n            dfs(idx + 1, arr, true);\\n        }\\n    }\\n}\\n```\n```\\n1. (recursive step)  try each of 7 options at each digit             (from index 0 to len - 1)\\n\\t\\t==> O(7 ^ len)  time\\n2. (base case)       construct new String() and compare each digit   (after index len - 1)\\n\\t\\t==> O(len)  time\\n```\n```\\n// O(T) := total time complexity \\nT  =  7 ^ 1 * 1  +  7 ^ 2 * 2  +  ...  +  7 ^ (logN) * (logN)\\n  >=  7 ^ (logN) * (logN)\\n   =  O(N * logN)\\n\\n// Also from the other direction of the Squeeze Theorem: \\nT  <=  7 ^ 1 * (logN)  +  7 ^ 2 * (logN)  +  ...  + 7 ^ (logN) * (logN)\\n    =  (logN)  *  (7 ^ 1  +  7 ^ 2  +  ...  + 7 ^ logN)\\n    =  (logN)  * (7 ^ logN * 7 - 7) / 6\\n    =  (logN)  * O(7 ^ logN)\\n\\t=  O(N * logN)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1075957,
                "title": "java-o-n-straight-forward-solution",
                "content": "```\\nclass Solution {\\n    public int rotatedDigits(int N) {\\n        int count = 0;\\n        for (int i = 1;i<=N;i++) if (getCount(i) > 0) count++;\\n        return count;\\n    }\\n    \\n    public int getCount(int num){\\n        int count  = 0;\\n        while (num > 0){\\n                int r = num % 10;\\n                if (r == 3 || r == 4 || r == 7) return 0;\\n                if (r == 2 || r == 5 || r == 6 || r == 9) count++;\\n                num = num / 10;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int rotatedDigits(int N) {\\n        int count = 0;\\n        for (int i = 1;i<=N;i++) if (getCount(i) > 0) count++;\\n        return count;\\n    }\\n    \\n    public int getCount(int num){\\n        int count  = 0;\\n        while (num > 0){\\n                int r = num % 10;\\n                if (r == 3 || r == 4 || r == 7) return 0;\\n                if (r == 2 || r == 5 || r == 6 || r == 9) count++;\\n                num = num / 10;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 845786,
                "title": "c-clean-code-dp",
                "content": "```\\nint rotatedDigits(int N) {\\n  //3,4,7 invalid ->0\\n  //0,1,8 valid ->1\\n  //2,5,6,9 good ->2\\n  vector<int> dp(N+1,0);\\n  int cnt=0;\\n  for(int i=0;i<=N;++i){\\n\\tif(i<10){\\n\\t  if(i==0 || i==1 || i==8) dp[i]=1;\\n\\t  else if(i==2 || i==5 || i==6 || i==9) dp[i]=2,++cnt; \\n\\t}else{\\n\\t  if(dp[i/10]==1 && dp[i%10]==1) dp[i]=1;\\n\\t  else if(dp[i/10]>=1 && dp[i%10]>=1) dp[i]=2,++cnt;\\n\\t}\\n  }\\n  return cnt;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint rotatedDigits(int N) {\\n  //3,4,7 invalid ->0\\n  //0,1,8 valid ->1\\n  //2,5,6,9 good ->2\\n  vector<int> dp(N+1,0);\\n  int cnt=0;\\n  for(int i=0;i<=N;++i){\\n\\tif(i<10){\\n\\t  if(i==0 || i==1 || i==8) dp[i]=1;\\n\\t  else if(i==2 || i==5 || i==6 || i==9) dp[i]=2,++cnt; \\n\\t}else{\\n\\t  if(dp[i/10]==1 && dp[i%10]==1) dp[i]=1;\\n\\t  else if(dp[i/10]>=1 && dp[i%10]>=1) dp[i]=2,++cnt;\\n\\t}\\n  }\\n  return cnt;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 508130,
                "title": "javascript-straight-forward-solution",
                "content": "```javascript\\n/**\\n * @param {number} N\\n * @return {number}\\n */\\nvar rotatedDigits = function(N) {\\n  let counter = 0;\\n  for (let i = 1; i <= N; i++) {\\n    if (isValid(i)) counter++;\\n  }\\n  return counter;\\n};\\n\\nconst isValid = n => {\\n  let valid = false;\\n  while (n) {\\n    const a = n % 10;\\n    if (a === 3 || a === 4 || a === 7) return false;\\n    if (a === 2 || a === 5 || a === 6 || a === 9) valid = true;\\n    n = Math.trunc(n / 10);\\n  }\\n  return valid;\\n};\\n```\\n\\n* 50/50 cases passed (48 ms)\\n* Your runtime beats 100 % of javascript submissions\\n* Your memory usage beats 100 % of javascript submissions (34.2 MB)",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\n/**\\n * @param {number} N\\n * @return {number}\\n */\\nvar rotatedDigits = function(N) {\\n  let counter = 0;\\n  for (let i = 1; i <= N; i++) {\\n    if (isValid(i)) counter++;\\n  }\\n  return counter;\\n};\\n\\nconst isValid = n => {\\n  let valid = false;\\n  while (n) {\\n    const a = n % 10;\\n    if (a === 3 || a === 4 || a === 7) return false;\\n    if (a === 2 || a === 5 || a === 6 || a === 9) valid = true;\\n    n = Math.trunc(n / 10);\\n  }\\n  return valid;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 116655,
                "title": "simple-easy-to-understand-code-in-c",
                "content": "```\n#define SAME 0 // 0, 1, 8\n#define VALID 1 // 2, 6, 8, 9\n#define INVALID 2 // 3, 4, 7\n\nint rotatedDigits(int n) {\n    int i, num, count = 0, is_valid[] = {SAME, SAME, VALID, INVALID, INVALID, VALID, VALID, INVALID, SAME, VALID};\n    bool found = false;\n    \n    for(i = 2; i <= n; i++){\n        num = i; found = false;\n        while(num){\n           if(is_valid[num % 10] == INVALID) {found = false; break;}\n           if(is_valid[num % 10] == VALID) found = true; \n           num = num/10;\n        }\n        if(found == true) count++;\n    }\n    \n    return count;\n}\n```",
                "solutionTags": [],
                "code": "```\n#define SAME 0 // 0, 1, 8\n#define VALID 1 // 2, 6, 8, 9\n#define INVALID 2 // 3, 4, 7\n\nint rotatedDigits(int n) {\n    int i, num, count = 0, is_valid[] = {SAME, SAME, VALID, INVALID, INVALID, VALID, VALID, INVALID, SAME, VALID};\n    bool found = false;\n    \n    for(i = 2; i <= n; i++){\n        num = i; found = false;\n        while(num){\n           if(is_valid[num % 10] == INVALID) {found = false; break;}\n           if(is_valid[num % 10] == VALID) found = true; \n           num = num/10;\n        }\n        if(found == true) count++;\n    }\n    \n    return count;\n}\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2602721,
                "title": "python3-7-lines-sets-t-m-63-100",
                "content": "```\\nclass Solution:\\n    def rotatedDigits(self, n: int) -> int:\\n\\n        count = 0\\n        \\n        for i in range(1,n+1):\\n            nSet = set(str(i))\\n            \\n            if (not nSet.intersection({\\'3\\',\\'4\\',\\'7\\'}) and \\n                    nSet.intersection({\\'2\\',\\'5\\',\\'6\\',\\'9\\'})):\\n                count += 1\\n                \\n        return count\\n```\\n[https://leetcode.com/problems/rotated-digits/submissions/1006307495/](http://)\\n\\nI could be wrong, but I think that time complexity is *O*(*N*log*N*) and space complexity is *O*log*N*), in which *N* ~ `n`.",
                "solutionTags": [
                    "Python",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution:\\n    def rotatedDigits(self, n: int) -> int:\\n\\n        count = 0\\n        \\n        for i in range(1,n+1):\\n            nSet = set(str(i))\\n            \\n            if (not nSet.intersection({\\'3\\',\\'4\\',\\'7\\'}) and \\n                    nSet.intersection({\\'2\\',\\'5\\',\\'6\\',\\'9\\'})):\\n                count += 1\\n                \\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1320211,
                "title": "easy-approach-dynamic-programming-c",
                "content": "there are following steps to solve this question easily.\\nDivide your problem in two halves.\\n1.Less than 10\\n2.greater than 10\\n\\n1. Fill you dp table by default 0 in whole.\\nFilling zeros will tell you that by default all the numbers are invalid.\\n2.Fill 1 in your dp to esure that numbers are valid but they are same after flipping\\n3.Fill 2 in your dp array once you find valid and different number after rotating.\\n4.Finally do it for all the n and return the count,you have to keep increasing count whenever you fill 2 in your table because this is the case for which you are solving this problem.\\n \\n```\\nclass Solution {\\npublic:\\n \\n    int rotatedDigits(int n) {\\n        int dp[n+1];\\n        memset(dp,0,sizeof(dp));\\n        int count=0;\\n        for(int i=0;i<=n;i++)\\n        {\\n            if(i<10)\\n            {\\n                if(i==0 || i==1 || i==8)\\n                     dp[i]=1;\\n                else if(i==2 || i==5 || i==6 || i==9)\\n                {\\n                     dp[i]=2;\\n                      count++;\\n                }\\n\\n            }\\n            else\\n            {\\n                int a=dp[i/10];\\n                int b=dp[i%10];\\n                if(a==1 && b==1)\\n                    dp[i]=1;\\n                else if(a>=1 && b>=1)\\n                {\\n                    dp[i]=2;\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n \\n    int rotatedDigits(int n) {\\n        int dp[n+1];\\n        memset(dp,0,sizeof(dp));\\n        int count=0;\\n        for(int i=0;i<=n;i++)\\n        {\\n            if(i<10)\\n            {\\n                if(i==0 || i==1 || i==8)\\n                     dp[i]=1;\\n                else if(i==2 || i==5 || i==6 || i==9)\\n                {\\n                     dp[i]=2;\\n                      count++;\\n                }\\n\\n            }\\n            else\\n            {\\n                int a=dp[i/10];\\n                int b=dp[i%10];\\n                if(a==1 && b==1)\\n                    dp[i]=1;\\n                else if(a>=1 && b>=1)\\n                {\\n                    dp[i]=2;\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1205605,
                "title": "python3-simple-solution-using-two-approaches",
                "content": "```\\nclass Solution:\\n    def rotatedDigits(self, N: int) -> int:\\n        count = 0\\n        for x in range(1, N+1):\\n            x = str(x)\\n            if \\'3\\' in x or \\'4\\' in x or \\'7\\' in x:\\n                continue\\n            if \\'2\\' in x or \\'5\\' in x or \\'6\\' in x or \\'9\\' in x:\\n                count+=1\\n        return count\\n```\\n\\n```\\nclass Solution:\\n    def rotatedDigits(self, N: int) -> int:\\n        d = {\\'0\\':\\'0\\',\\'1\\':\\'1\\',\\'2\\':\\'5\\',\\'5\\':\\'2\\',\\'6\\':\\'9\\',\\'8\\':\\'8\\',\\'9\\':\\'6\\'}\\n        count = 0\\n        for i in range(1,N+1):\\n            x = \\'\\'\\n            flag = True\\n            for j in str(i):\\n                if j not in d.keys():\\n                    flag = False\\n                    break\\n                else:\\n                    x += d[j]\\n            if flag and x != str(i):\\n                count += 1\\n        return count\\n```\\n**If you like this solution, please upvote for this**",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rotatedDigits(self, N: int) -> int:\\n        count = 0\\n        for x in range(1, N+1):\\n            x = str(x)\\n            if \\'3\\' in x or \\'4\\' in x or \\'7\\' in x:\\n                continue\\n            if \\'2\\' in x or \\'5\\' in x or \\'6\\' in x or \\'9\\' in x:\\n                count+=1\\n        return count\\n```\n```\\nclass Solution:\\n    def rotatedDigits(self, N: int) -> int:\\n        d = {\\'0\\':\\'0\\',\\'1\\':\\'1\\',\\'2\\':\\'5\\',\\'5\\':\\'2\\',\\'6\\':\\'9\\',\\'8\\':\\'8\\',\\'9\\':\\'6\\'}\\n        count = 0\\n        for i in range(1,N+1):\\n            x = \\'\\'\\n            flag = True\\n            for j in str(i):\\n                if j not in d.keys():\\n                    flag = False\\n                    break\\n                else:\\n                    x += d[j]\\n            if flag and x != str(i):\\n                count += 1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 116562,
                "title": "java-regex-one-line-java8",
                "content": "Simple, but poor performance.\n\n    public int rotatedDigits(int N) {\n        int count = 0;\n        for(int i = 1; i <= N; i++) {\n            if (Integer.toString(i).matches(\"^([018]*[2569]+[018]*)+$\"))\n                count++;\n        }\n        return count;\n    }\n\nOne line in java 8:\n\n    public int rotatedDigits(int N) {\n        return IntStream.range(1, N+1).map(i -> Integer.toString(i).matches(\"^([018]*[2569]+[018]*)+$\") ? 1 : 0).sum();\n    }\n\nA much faster solution:\n```\n   public int rotatedDigits(int N) {\n        int ans = 0;\n        outer: for(int i = 1; i <= N; i++) {\n            int d = 0;\n            for(char ch : Integer.toString(i).toCharArray()) {\n                if (ch == '3' || ch == '4' || ch == '7')\n                    continue outer;\n                if (ch == '2' || ch == '5' || ch == '6' || ch == '9')\n                    d = 1;\n            }\n            ans += d;\n        }\n        return ans;\n    }\n```",
                "solutionTags": [],
                "code": "```\n   public int rotatedDigits(int N) {\n        int ans = 0;\n        outer: for(int i = 1; i <= N; i++) {\n            int d = 0;\n            for(char ch : Integer.toString(i).toCharArray()) {\n                if (ch == '3' || ch == '4' || ch == '7')\n                    continue outer;\n                if (ch == '2' || ch == '5' || ch == '6' || ch == '9')\n                    d = 1;\n            }\n            ans += d;\n        }\n        return ans;\n    }\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3557037,
                "title": "easy-understandable-python-code",
                "content": "\\n\\n# Approach\\n-  Valid if N contains ATLEAST ```ONE 2, 5, 6, 9```\\n AND ``` NO 3, 4 or 7```\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def rotatedDigits(self, n: int) -> int:\\n        invalid = [3,4,7]\\n        good = 0\\n        check = False\\n\\n        for i in range(1,n+1):\\n            j = i\\n        \\n            while j != 0:\\n                d = j % 10\\n                \\n                if d == 2 or d == 5 or d == 6 or d == 9:\\n                    check = True\\n                \\n                elif d in invalid:\\n                    check = False\\n                    break\\n                \\n                j = j // 10\\n\\n            if check:\\n                good += 1\\n\\n            check = False        \\n        \\n        return good\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```ONE 2, 5, 6, 9```\n``` NO 3, 4 or 7```\n```\\nclass Solution:\\n    def rotatedDigits(self, n: int) -> int:\\n        invalid = [3,4,7]\\n        good = 0\\n        check = False\\n\\n        for i in range(1,n+1):\\n            j = i\\n        \\n            while j != 0:\\n                d = j % 10\\n                \\n                if d == 2 or d == 5 or d == 6 or d == 9:\\n                    check = True\\n                \\n                elif d in invalid:\\n                    check = False\\n                    break\\n                \\n                j = j // 10\\n\\n            if check:\\n                good += 1\\n\\n            check = False        \\n        \\n        return good\\n```",
                "codeTag": "Java"
            },
            {
                "id": 446920,
                "title": "simple-python-using-sets-o-n",
                "content": "```\\nclass Solution:\\n    def rotatedDigits(self, N: int) -> int:\\n        valid = {\\'2\\',\\'5\\',\\'6\\',\\'9\\'}\\n        invalid = {\\'3\\',\\'4\\',\\'7\\'}\\n        result = 0\\n        for num in range(2, N+1):\\n            s = set(str(num))\\n            if s & invalid:\\n                continue\\n            elif s & valid:\\n                result += 1\\n        return result\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def rotatedDigits(self, N: int) -> int:\\n        valid = {\\'2\\',\\'5\\',\\'6\\',\\'9\\'}\\n        invalid = {\\'3\\',\\'4\\',\\'7\\'}\\n        result = 0\\n        for num in range(2, N+1):\\n            s = set(str(num))\\n            if s & invalid:\\n                continue\\n            elif s & valid:\\n                result += 1\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 288300,
                "title": "javascript-clear-simple-faster-than-100-56ms",
                "content": "```\\n\\nvar rotatedDigits = function(N) {\\n    count = 0\\n    for(i=1;i<N+1;i++){\\n        x = (\"\"+i).split(\"\")\\n        if(x.includes(\\'2\\') || x.includes(\\'5\\') || x.includes(\\'6\\') || x.includes(\\'9\\')){\\n            count += 1\\n            if(x.includes(\\'3\\') || x.includes(\\'4\\') || x.includes(\\'7\\')){\\n                count -= 1\\n            }\\n        }\\n    }\\n    return count\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nvar rotatedDigits = function(N) {\\n    count = 0\\n    for(i=1;i<N+1;i++){\\n        x = (\"\"+i).split(\"\")\\n        if(x.includes(\\'2\\') || x.includes(\\'5\\') || x.includes(\\'6\\') || x.includes(\\'9\\')){\\n            count += 1\\n            if(x.includes(\\'3\\') || x.includes(\\'4\\') || x.includes(\\'7\\')){\\n                count -= 1\\n            }\\n        }\\n    }\\n    return count\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 116527,
                "title": "o-len-n-method",
                "content": "Clearly we can do better than O(N) by reuse results from shorter numbers.\nHere is my O(len(N)) method. Took me some time in the contest...\n```\nclass Solution(object):\n    def rotatedDigits(self, N):\n        \"\"\"\n        :type N: int\n        :rtype: int\n        \"\"\"\n        same = [1, 2, 2, 2, 2, 2, 2, 2, 3, 3]\n        diff = [0, 0, 1, 1, 1, 2, 3, 3, 3, 4]\n        \n        def calc(num):\n            if len(num)==1:\n                return same[int(num)], diff[int(num)]\n            lead = int(num[0])\n            if lead == 0:\n                return calc(num[1:])\n            else:\n                n_s, n_d = calc('9'*(len(num)-1))\n                nxt_same, nxt_diff = calc(num[1:])\n                \n                s = same[lead-1] * n_s\n                if lead in [0, 1, 8]:\n                    s += nxt_same\n                \n                d = (same[lead-1]+diff[lead-1]) * n_d + diff[lead-1] * n_s\n                if lead in [0, 1, 8]:\n                    d += nxt_diff\n                if lead in [2, 5, 6, 9]:\n                    d += nxt_diff + nxt_same\n                \n                return s, d\n        \n        return calc(str(N))[1]\n```",
                "solutionTags": [],
                "code": "```\nclass Solution(object):\n    def rotatedDigits(self, N):\n        \"\"\"\n        :type N: int\n        :rtype: int\n        \"\"\"\n        same = [1, 2, 2, 2, 2, 2, 2, 2, 3, 3]\n        diff = [0, 0, 1, 1, 1, 2, 3, 3, 3, 4]\n        \n        def calc(num):\n            if len(num)==1:\n                return same[int(num)], diff[int(num)]\n            lead = int(num[0])\n            if lead == 0:\n                return calc(num[1:])\n            else:\n                n_s, n_d = calc('9'*(len(num)-1))\n                nxt_same, nxt_diff = calc(num[1:])\n                \n                s = same[lead-1] * n_s\n                if lead in [0, 1, 8]:\n                    s += nxt_same\n                \n                d = (same[lead-1]+diff[lead-1]) * n_d + diff[lead-1] * n_s\n                if lead in [0, 1, 8]:\n                    d += nxt_diff\n                if lead in [2, 5, 6, 9]:\n                    d += nxt_diff + nxt_same\n                \n                return s, d\n        \n        return calc(str(N))[1]\n```",
                "codeTag": "Java"
            },
            {
                "id": 2618289,
                "title": "c-easy-0ms-solution-with-comments-explained",
                "content": "```\\nclass Solution {\\npublic:\\n    int rotatedDigits(int n) {\\n        \\n        int count = 0 ;\\n        \\n        for(int i = 1 ; i<= n ; i++)\\n        {\\n            // Copy The Number\\n            int x = i;\\n            \\n            // We will be checking two conditions\\n            bool flag1 = false , flag = true ;\\n            \\n            while(x)\\n            {\\n                // get last digit of the number and remove that digit from current number\\n                int k = x%10;\\n                x = x/10;\\n                \\n                \\n                // if digit is 3 , 4 or  7 then there rotation will be invalid so break the loop\\n                // and make flag false\\n                if(k == 3 || k == 4 || k == 7 )\\n                {\\n                     flag = false ;\\n                      break;\\n                }\\n                \\n                // if digit is 6 , 9 , 5 or 2 there rotaion will be valid and value will be changed so make flag1 true\\n                else if( k == 6 || k == 9 || k == 5 || k == 2  )\\n                {\\n                   flag1 = true;\\n                }\\n                \\n            }\\n            \\n            // this condition says that if we encountered all valid digits and at least \\n            // one digit whose value changes after rotation than increment the answer\\n            if(flag && flag1)\\n                count++;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/01cc07e2-4a14-4890-87dd-8dbbd12e0bdf_1664026410.8298378.png)\\n",
                "solutionTags": [
                    "C",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int rotatedDigits(int n) {\\n        \\n        int count = 0 ;\\n        \\n        for(int i = 1 ; i<= n ; i++)\\n        {\\n            // Copy The Number\\n            int x = i;\\n            \\n            // We will be checking two conditions\\n            bool flag1 = false , flag = true ;\\n            \\n            while(x)\\n            {\\n                // get last digit of the number and remove that digit from current number\\n                int k = x%10;\\n                x = x/10;\\n                \\n                \\n                // if digit is 3 , 4 or  7 then there rotation will be invalid so break the loop\\n                // and make flag false\\n                if(k == 3 || k == 4 || k == 7 )\\n                {\\n                     flag = false ;\\n                      break;\\n                }\\n                \\n                // if digit is 6 , 9 , 5 or 2 there rotaion will be valid and value will be changed so make flag1 true\\n                else if( k == 6 || k == 9 || k == 5 || k == 2  )\\n                {\\n                   flag1 = true;\\n                }\\n                \\n            }\\n            \\n            // this condition says that if we encountered all valid digits and at least \\n            // one digit whose value changes after rotation than increment the answer\\n            if(flag && flag1)\\n                count++;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2137269,
                "title": "c-digit-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    map<int, int> rotationMap;\\n\\n    int dp[10004][2][2];\\n\\n\\n    int solve(int pos, bool bound, int hasChanged, string &s) {\\n        if (pos == s.length()) {\\n\\n            if (hasChanged) return 1;\\n            return 0;\\n        }\\n\\n        int ans = 0;\\n        if (dp[pos][bound][hasChanged] != -1) return  dp[pos][bound][hasChanged];\\n\\n        int maxDigit = bound ? s[pos] - \\'0\\' : 9;\\n        for (int digit = 0; digit <= maxDigit; digit++) {\\n            if (rotationMap.count(digit)) {\\n                ans += solve(pos + 1, bound && (digit == s[pos] - \\'0\\'), hasChanged || (rotationMap[digit] != digit), s);\\n            }\\n        }\\n\\n        return dp[pos][bound][hasChanged] = ans;\\n    }\\n\\n    int rotatedDigits(int n) {\\n        rotationMap[0] = 0;\\n        rotationMap[1] = 1;\\n        rotationMap[8] = 8;\\n\\n        rotationMap[2] = 5;\\n        rotationMap[5] = 2;\\n\\n        rotationMap[6] = 9;\\n        rotationMap[9] = 6;\\n        memset(dp, -1, sizeof(dp));\\n\\n        string s = to_string(n);\\n        return solve(0, true, false, s);\\n\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    map<int, int> rotationMap;\\n\\n    int dp[10004][2][2];\\n\\n\\n    int solve(int pos, bool bound, int hasChanged, string &s) {\\n        if (pos == s.length()) {\\n\\n            if (hasChanged) return 1;\\n            return 0;\\n        }\\n\\n        int ans = 0;\\n        if (dp[pos][bound][hasChanged] != -1) return  dp[pos][bound][hasChanged];\\n\\n        int maxDigit = bound ? s[pos] - \\'0\\' : 9;\\n        for (int digit = 0; digit <= maxDigit; digit++) {\\n            if (rotationMap.count(digit)) {\\n                ans += solve(pos + 1, bound && (digit == s[pos] - \\'0\\'), hasChanged || (rotationMap[digit] != digit), s);\\n            }\\n        }\\n\\n        return dp[pos][bound][hasChanged] = ans;\\n    }\\n\\n    int rotatedDigits(int n) {\\n        rotationMap[0] = 0;\\n        rotationMap[1] = 1;\\n        rotationMap[8] = 8;\\n\\n        rotationMap[2] = 5;\\n        rotationMap[5] = 2;\\n\\n        rotationMap[6] = 9;\\n        rotationMap[9] = 6;\\n        memset(dp, -1, sizeof(dp));\\n\\n        string s = to_string(n);\\n        return solve(0, true, false, s);\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1399229,
                "title": "c-easy-digitdp-solution",
                "content": "The dp will we as follows::\\n\\t\\t\\t`dp[index][flag][leading_zeroes][mask] `\\n*index = index of the number which we are currently at \\nflag  = it tells us whether we are inside the limits \\nleadingzeroes = it tells us whether the number has started or we are still at the leading zeroes\\nmask  = keeps the track of the numbers which we have encountered at the current recussion \\n*\\n**AFTER ROTATION  ::**\\n*the invalid numbers *                         : :     `3 4 7`\\nthe numbers which remains same       : :       `0 1 8`\\nthe numbers which change                : :      `2 5 6 9`\\n\\n\\n**CODE EXPLANATION :: **\\n\\nAll the numbers are produced by using the index and flag parameters and (basic of DIGIT DP)\\nTo read more upon Digit Dp you may refer to this blog :: \\nhttps://codeforces.com/blog/entry/53960\\n\\nBase case :: \\n\\n\\t\\t1. we check whether the number contains any invalid digits or no if present we return 0\\n\\t\\t2. we check if it contains any digit which ehrn rotated gives another number then we return 1 because if these digits are there then it is guaranteed to produce a new number \\n\\t\\t3. if above conditions are not met then we return 0. \\n\\n\\n\\n###     CODE STARTS HERE :: \\n\\n```\\nlong long dp[6][2][2][1<<10];\\n    string s;\\n    int digitDP(int ind , int flag , int lead , int mask)\\n    {\\n        if (ind == s.size()) {\\n            if(mask&(1<<3) or mask&(1<<4) or mask&(1<<7))   return 0;\\n            if(mask&(1<<2) or mask&(1<<5) or mask&(1<<6) or mask&(1<<9))   return 1;\\n            return 0;\\n        }\\n        \\n        long long &ans = dp[ind][flag][lead][mask];\\n        if(ans != -1)   return ans;\\n        ans = 0 ;\\n        int limit = (flag==0) ? s[ind] - \\'0\\' : 9;\\n\\n        for (int i = 0; i <= limit; i++)\\n        {\\n            \\n            int nl = lead || (i>0);   //new_lead\\n            int nf = flag || (i<limit) ;  //new_flag\\n            \\n           if(nl)\\n               ans += digitDP(ind+1 , nf , nl , mask|(1<<i));\\n            else\\n                ans += digitDP(ind+1 , nf , nl , mask);\\n        }\\n        return ans;\\n    }\\n    \\n    int rotatedDigits(int n) {\\n        memset(dp , -1 , sizeof dp);\\n        while(n)\\n            s+= to_string(n%10) , n/=10;\\n        reverse(s.begin() , s.end());\\n        return digitDP(0 , 0 , 0 , 0);  //flag 0 mane within limit nite parbo\\n    }\\n```\\n\\nPlease upvote if this solution is of any help to you . \\n\\nKeep coding ..\\n",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nlong long dp[6][2][2][1<<10];\\n    string s;\\n    int digitDP(int ind , int flag , int lead , int mask)\\n    {\\n        if (ind == s.size()) {\\n            if(mask&(1<<3) or mask&(1<<4) or mask&(1<<7))   return 0;\\n            if(mask&(1<<2) or mask&(1<<5) or mask&(1<<6) or mask&(1<<9))   return 1;\\n            return 0;\\n        }\\n        \\n        long long &ans = dp[ind][flag][lead][mask];\\n        if(ans != -1)   return ans;\\n        ans = 0 ;\\n        int limit = (flag==0) ? s[ind] - \\'0\\' : 9;\\n\\n        for (int i = 0; i <= limit; i++)\\n        {\\n            \\n            int nl = lead || (i>0);   //new_lead\\n            int nf = flag || (i<limit) ;  //new_flag\\n            \\n           if(nl)\\n               ans += digitDP(ind+1 , nf , nl , mask|(1<<i));\\n            else\\n                ans += digitDP(ind+1 , nf , nl , mask);\\n        }\\n        return ans;\\n    }\\n    \\n    int rotatedDigits(int n) {\\n        memset(dp , -1 , sizeof dp);\\n        while(n)\\n            s+= to_string(n%10) , n/=10;\\n        reverse(s.begin() , s.end());\\n        return digitDP(0 , 0 , 0 , 0);  //flag 0 mane within limit nite parbo\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1277567,
                "title": "super-simple-java-dfs-faster-than100",
                "content": "```\\nclass Solution {\\n    int count = 0;\\n    public int rotatedDigits(int n) {\\n        dfs(n, 0, 0);\\n        return count;\\n    }\\n    public void dfs(int n, int num, int d) {\\n        if (num > n) {\\n            return;\\n        }\\n        if (d > 0) {\\n            count++;\\n        }\\n        if (num > 0) {\\n            dfs(n, num * 10, d);\\n        }\\n        dfs(n, num * 10 + 8, d);\\n        dfs(n, num * 10 + 1, d);\\n        dfs(n, num * 10 + 2, d + 1);\\n        dfs(n, num * 10 + 5, d + 1);\\n        dfs(n, num * 10 + 6, d + 1);\\n        dfs(n, num * 10 + 9, d + 1);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int count = 0;\\n    public int rotatedDigits(int n) {\\n        dfs(n, 0, 0);\\n        return count;\\n    }\\n    public void dfs(int n, int num, int d) {\\n        if (num > n) {\\n            return;\\n        }\\n        if (d > 0) {\\n            count++;\\n        }\\n        if (num > 0) {\\n            dfs(n, num * 10, d);\\n        }\\n        dfs(n, num * 10 + 8, d);\\n        dfs(n, num * 10 + 1, d);\\n        dfs(n, num * 10 + 2, d + 1);\\n        dfs(n, num * 10 + 5, d + 1);\\n        dfs(n, num * 10 + 6, d + 1);\\n        dfs(n, num * 10 + 9, d + 1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 747637,
                "title": "c-faster-than-100-easy-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int rotatedDigits(int N) {\\n        int c=0;\\n       for(int i=1;i<=N;i++)\\n       {\\n           if(check(i)==0)\\n               continue;\\n           else\\n               c++;\\n       }\\n        return c;\\n        \\n    }\\n    int check(int num)\\n    {\\n        int count=0;\\n        while(num>0)\\n        {\\n            int a=num%10;\\n            if(a==3||a==7||a==4)\\n                return 0;\\n            if(a==5||a==2||a==6||a==9)\\n                count++;\\n            num/=10;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int rotatedDigits(int N) {\\n        int c=0;\\n       for(int i=1;i<=N;i++)\\n       {\\n           if(check(i)==0)\\n               continue;\\n           else\\n               c++;\\n       }\\n        return c;\\n        \\n    }\\n    int check(int num)\\n    {\\n        int count=0;\\n        while(num>0)\\n        {\\n            int a=num%10;\\n            if(a==3||a==7||a==4)\\n                return 0;\\n            if(a==5||a==2||a==6||a==9)\\n                count++;\\n            num/=10;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 746350,
                "title": "c-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int rotatedDigits(int N) {\\n        int goodNumbers = 0;\\n        for (int i = 1; i <= N; i++) {\\n            if (isRotatedNumber(i))\\n                goodNumbers++;\\n        }\\n        return goodNumbers;\\n    }\\nprivate:\\n    bool isRotatedNumber(int n) {\\n        bool bRotated = false;\\n        while (n) {\\n            int digit = n % 10;\\n            if (digit == 3 || digit == 4 || digit == 7)\\n                return false;\\n            if (digit == 2 || digit == 5 || digit == 6 || digit == 9)\\n                bRotated = true;\\n            n /= 10;\\n        }\\n        return bRotated;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int rotatedDigits(int N) {\\n        int goodNumbers = 0;\\n        for (int i = 1; i <= N; i++) {\\n            if (isRotatedNumber(i))\\n                goodNumbers++;\\n        }\\n        return goodNumbers;\\n    }\\nprivate:\\n    bool isRotatedNumber(int n) {\\n        bool bRotated = false;\\n        while (n) {\\n            int digit = n % 10;\\n            if (digit == 3 || digit == 4 || digit == 7)\\n                return false;\\n            if (digit == 2 || digit == 5 || digit == 6 || digit == 9)\\n                bRotated = true;\\n            n /= 10;\\n        }\\n        return bRotated;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 666800,
                "title": "easy-to-understand-c-code-100-time-100-space",
                "content": "**There are 3 cases that can affect solution.\\na) 1, 8,0 -> No affect to numbers.\\nb) 2,5,6,9 ->Changes values of numbers.\\nc) 3,4,7 -> makes number invalid.**\\n\\nWe should include all numbers containing case b except all numbers of case c.\\n\\n* Check for each number if it has any one of case b -> can be answer.\\n* Check for case c -> it will discard the number as answer. \\n\\n```\\nint rotatedDigits(int N) {\\n        int ans = 0, dig,temp,flag;\\n        for(int i=1;i<=N;i++){\\n            temp = i;\\n            flag =0;\\n            while(temp){\\n                dig = temp%10;\\n                if(dig == 2 ||dig == 5 ||dig == 6 ||dig == 9){\\n                    flag = 1;\\n                }\\n                else if(dig == 3 ||dig == 4 ||dig == 7 ){\\n                    flag = 2;\\n                    break;\\n                }\\n                temp = temp/10;\\n            }\\n            if(flag == 1)   ans++;\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint rotatedDigits(int N) {\\n        int ans = 0, dig,temp,flag;\\n        for(int i=1;i<=N;i++){\\n            temp = i;\\n            flag =0;\\n            while(temp){\\n                dig = temp%10;\\n                if(dig == 2 ||dig == 5 ||dig == 6 ||dig == 9){\\n                    flag = 1;\\n                }\\n                else if(dig == 3 ||dig == 4 ||dig == 7 ){\\n                    flag = 2;\\n                    break;\\n                }\\n                temp = temp/10;\\n            }\\n            if(flag == 1)   ans++;\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 564593,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public boolean change(int n)\\n    {\\n        boolean res=false;\\n        while(n>0)\\n        {\\n            int i=n%10;\\n            if(i==3 || i==4 || i==7)\\n                return false;\\n            if(i==2 || i==5 || i==6 || i==9)\\n                res=true;\\n            n/=10;\\n        }\\n        return res;\\n    }\\n    public int rotatedDigits(int N) {\\n        int count=0;\\n        for(int i=1;i<=N;i++)\\n        {\\n            if(change(i))\\n                count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean change(int n)\\n    {\\n        boolean res=false;\\n        while(n>0)\\n        {\\n            int i=n%10;\\n            if(i==3 || i==4 || i==7)\\n                return false;\\n            if(i==2 || i==5 || i==6 || i==9)\\n                res=true;\\n            n/=10;\\n        }\\n        return res;\\n    }\\n    public int rotatedDigits(int N) {\\n        int count=0;\\n        for(int i=1;i<=N;i++)\\n        {\\n            if(change(i))\\n                count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 494436,
                "title": "easy-python-100",
                "content": "```Python\\nclass Solution:\\n    def rotatedDigits(self, N: int) -> int:\\n        self.good = set([2,5,6,9])\\n        self.bad = set([3,4,7])\\n        def isGoodNo(N):\\n            ans = False\\n            while N:\\n                if N%10 in self.bad:\\n                    return False\\n                if N%10 in self.good:\\n                    ans = True\\n                N//=10\\n            return ans   \\n        count = 0\\n        for i in range(1,N+1):\\n            if isGoodNo(i):\\n                count += 1\\n        return count\\n```",
                "solutionTags": [],
                "code": "```Python\\nclass Solution:\\n    def rotatedDigits(self, N: int) -> int:\\n        self.good = set([2,5,6,9])\\n        self.bad = set([3,4,7])\\n        def isGoodNo(N):\\n            ans = False\\n            while N:\\n                if N%10 in self.bad:\\n                    return False\\n                if N%10 in self.good:\\n                    ans = True\\n                N//=10\\n            return ans   \\n        count = 0\\n        for i in range(1,N+1):\\n            if isGoodNo(i):\\n                count += 1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 116541,
                "title": "c-3-ms-o-log10-n-solution",
                "content": "```\nclass Solution {\npublic:\n    int rotatedDigits(int N) {\n        static int goodsame[10] = {1,2,2,2,2,2,2,2,3,3};\n        static int gooddiff[10] = {0,0,1,1,1,2,3,3,3,4};\n        static int digittype[10]= {0,0,1,2,2,1,1,2,0,1};\n        if (N>9999)\n            return 0;\n        int count=0;\n        int foundfirst=0;\n        int vartype=0;\n        int nn=N;\n        int d=nn/1000;\n        if (d > 0) {\n            foundfirst=1;\n            vartype=digittype[d];\n            int goods=goodsame[d-1]+gooddiff[d-1];\n            count += (goods*7*7*7 - goodsame[d-1]*3*3*3);\n        }\n        nn -= d*1000;\n        d=nn/100;\n        if ((!foundfirst || (foundfirst && vartype<2)) && d > 0) {\n            foundfirst=1;\n            int goods=goodsame[d-1]+gooddiff[d-1];\n            count += goods*7*7;\n            if (vartype==0)\n                count -= goodsame[d-1]*3*3;\n            vartype=(digittype[d] > vartype)? digittype[d]:vartype;\n        }\n        nn -= d*100;\n        d=nn/10;\n        if ((!foundfirst || (foundfirst && vartype<2)) && d > 0) {\n            foundfirst=1;\n            int goods=goodsame[d-1]+gooddiff[d-1];\n            count += goods*7;\n            if (vartype==0)\n                count -= goodsame[d-1]*3;\n            vartype=(digittype[d] > vartype)? digittype[d]:vartype;\n        }\n        nn -= d*10;\n        d = nn;\n        if ((!foundfirst || (foundfirst && vartype<2)) && d >= 0) {\n            int goods=goodsame[d]+gooddiff[d];\n            count += goods;\n            if (vartype==0)\n                count -= goodsame[d];\n        }\n        return count;\n    }\n};\n```",
                "solutionTags": [],
                "code": "```\nclass Solution {\npublic:\n    int rotatedDigits(int N) {\n        static int goodsame[10] = {1,2,2,2,2,2,2,2,3,3};\n        static int gooddiff[10] = {0,0,1,1,1,2,3,3,3,4};\n        static int digittype[10]= {0,0,1,2,2,1,1,2,0,1};\n        if (N>9999)\n            return 0;\n        int count=0;\n        int foundfirst=0;\n        int vartype=0;\n        int nn=N;\n        int d=nn/1000;\n        if (d > 0) {\n            foundfirst=1;\n            vartype=digittype[d];\n            int goods=goodsame[d-1]+gooddiff[d-1];\n            count += (goods*7*7*7 - goodsame[d-1]*3*3*3);\n        }\n        nn -= d*1000;\n        d=nn/100;\n        if ((!foundfirst || (foundfirst && vartype<2)) && d > 0) {\n            foundfirst=1;\n            int goods=goodsame[d-1]+gooddiff[d-1];\n            count += goods*7*7;\n            if (vartype==0)\n                count -= goodsame[d-1]*3*3;\n            vartype=(digittype[d] > vartype)? digittype[d]:vartype;\n        }\n        nn -= d*100;\n        d=nn/10;\n        if ((!foundfirst || (foundfirst && vartype<2)) && d > 0) {\n            foundfirst=1;\n            int goods=goodsame[d-1]+gooddiff[d-1];\n            count += goods*7;\n            if (vartype==0)\n                count -= goodsame[d-1]*3;\n            vartype=(digittype[d] > vartype)? digittype[d]:vartype;\n        }\n        nn -= d*10;\n        d = nn;\n        if ((!foundfirst || (foundfirst && vartype<2)) && d >= 0) {\n            int goods=goodsame[d]+gooddiff[d];\n            count += goods;\n            if (vartype==0)\n                count -= goodsame[d];\n        }\n        return count;\n    }\n};\n```",
                "codeTag": "Java"
            },
            {
                "id": 3822534,
                "title": "c-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int rotatedDigits(int n) {\\n        int res = 0;\\n        while(n){\\n            int temp = n,judge = 1,diff = 0;\\n            while(temp){\\n                int y = temp % 10;\\n                if(y == 3 || y == 4 || y == 7){\\n                    judge = 0;\\n                    break;\\n                }\\n                if(y == 2 || y == 5 || y == 6 || y == 9){\\n                    diff = 1;\\n                }\\n                temp /= 10;\\n            }\\n            if(judge && diff){\\n                res++;\\n            }\\n            n--;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int rotatedDigits(int n) {\\n        int res = 0;\\n        while(n){\\n            int temp = n,judge = 1,diff = 0;\\n            while(temp){\\n                int y = temp % 10;\\n                if(y == 3 || y == 4 || y == 7){\\n                    judge = 0;\\n                    break;\\n                }\\n                if(y == 2 || y == 5 || y == 6 || y == 9){\\n                    diff = 1;\\n                }\\n                temp /= 10;\\n            }\\n            if(judge && diff){\\n                res++;\\n            }\\n            n--;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3465692,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    bool good(int x)\\n    {\\n        bool ans=false;\\n        int y;\\n        while(x>0)\\n        {\\n            y=x%10;\\n            switch(y)\\n            {\\n                case 0:\\n                case 1:\\n                case 8:\\n                    break;\\n                case 2:\\n                case 5:\\n                case 6:\\n                case 9:\\n                    ans=true;\\n                    break;\\n                default:\\n                    return false;\\n            }\\n            x/=10;\\n        }\\n        return ans;\\n    }\\n    int rotatedDigits(int n) {\\n        int c=0;\\n        for(int i=1;i<=n;i++)\\n        {\\n            if(good(i))\\n            {\\n                c++;\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def restrictedNumbersUsingDigits(self, n: int, digits: list) -> int:\\n        s = str(n)\\n        num_smaller_first_digits = len([d for d in digits if d <= int(s[0])])\\n        num_strictly_smaller_first_digits = len([d for d in digits if d < int(s[0])])\\n        num_digits = len(digits)\\n        if len(s) == 1:\\n            return num_smaller_first_digits\\n        if int(s[0]) in digits:\\n            same_first_digit_number =  self.restrictedNumbersUsingDigits(int(s[1:]), digits)\\n        else:\\n            same_first_digit_number = 0\\n        different_first_digit_number = num_strictly_smaller_first_digits * num_digits ** (len(s) - 1)\\n        return same_first_digit_number + different_first_digit_number\\n        \\n    def rotatedDigits(self, n: int) -> int:\\n        all_digits = [0, 1, 2, 5, 6, 8, 9]\\n        mediocre_digits = [0, 1, 8]\\n        total_numbers = self.restrictedNumbersUsingDigits(n, all_digits)\\n        mediocre_numbers = self.restrictedNumbersUsingDigits(n, mediocre_digits)\\n        return total_numbers - mediocre_numbers\\n```\\n\\n```Java []\\nclass Solution {\\n    int[] available = new int[]{0,1,2,5,6,8,9};\\n    int[] swaps = new int[]{2,5,6,9};\\n    public int rotatedDigits(int n) {\\n        List<Integer> arr = new ArrayList();\\n        int a = n;\\n        while(a > 0){\\n            arr.add(a % 10);\\n            a/=10;\\n        }\\n        int[] nums = new int[arr.size()];\\n        for(int i = 0; i < arr.size(); i++){\\n            nums[i] = arr.get(arr.size() - 1 - i);\\n        }\\n        return g(nums,0, false);\\n    }\\n    int g(int[] A, int index, boolean allowed){\\n        int ans = 0;\\n        if(index == A.length - 1){\\n            for(int i = 0; i <  available.length && available[i] <= A[index]; i++){\\n                if(swapsToDifferent(available[i]) || allowed) {\\n                    ans++;\\n                }\\n            }\\n        }else{\\n            for(int i = 0; i <  available.length && available[i] <= A[index]; i++){\\n                if(available[i] == A[index]){\\n                    int res = g(A, index + 1, allowed || swapsToDifferent(A[index]));\\n                    ans += res;\\n                }else{\\n                    int res = f(A.length - index - 1, allowed || swapsToDifferent(available[i]));\\n                    ans += res;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    boolean swapsToDifferent(int number){\\n        for(int i : swaps){\\n            if(number == i) return true;\\n        }\\n        return false;\\n    }\\n    int f(int digits, boolean swapsToDifferent){\\n        if(digits == 0) return 0;\\n        if(digits == 1 && !swapsToDifferent) return 4;\\n        if(digits == 1 && swapsToDifferent) return 7;\\n        if(digits == 2 && !swapsToDifferent) return 40;\\n        if(digits == 2 && swapsToDifferent) return 49;\\n        if(digits == 3 && !swapsToDifferent) return 316;\\n        if(digits == 3 && swapsToDifferent) return 343;\\n        return -1;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    bool good(int x)\\n    {\\n        bool ans=false;\\n        int y;\\n        while(x>0)\\n        {\\n            y=x%10;\\n            switch(y)\\n            {\\n                case 0:\\n                case 1:\\n                case 8:\\n                    break;\\n                case 2:\\n                case 5:\\n                case 6:\\n                case 9:\\n                    ans=true;\\n                    break;\\n                default:\\n                    return false;\\n            }\\n            x/=10;\\n        }\\n        return ans;\\n    }\\n    int rotatedDigits(int n) {\\n        int c=0;\\n        for(int i=1;i<=n;i++)\\n        {\\n            if(good(i))\\n            {\\n                c++;\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def restrictedNumbersUsingDigits(self, n: int, digits: list) -> int:\\n        s = str(n)\\n        num_smaller_first_digits = len([d for d in digits if d <= int(s[0])])\\n        num_strictly_smaller_first_digits = len([d for d in digits if d < int(s[0])])\\n        num_digits = len(digits)\\n        if len(s) == 1:\\n            return num_smaller_first_digits\\n        if int(s[0]) in digits:\\n            same_first_digit_number =  self.restrictedNumbersUsingDigits(int(s[1:]), digits)\\n        else:\\n            same_first_digit_number = 0\\n        different_first_digit_number = num_strictly_smaller_first_digits * num_digits ** (len(s) - 1)\\n        return same_first_digit_number + different_first_digit_number\\n        \\n    def rotatedDigits(self, n: int) -> int:\\n        all_digits = [0, 1, 2, 5, 6, 8, 9]\\n        mediocre_digits = [0, 1, 8]\\n        total_numbers = self.restrictedNumbersUsingDigits(n, all_digits)\\n        mediocre_numbers = self.restrictedNumbersUsingDigits(n, mediocre_digits)\\n        return total_numbers - mediocre_numbers\\n```\n```Java []\\nclass Solution {\\n    int[] available = new int[]{0,1,2,5,6,8,9};\\n    int[] swaps = new int[]{2,5,6,9};\\n    public int rotatedDigits(int n) {\\n        List<Integer> arr = new ArrayList();\\n        int a = n;\\n        while(a > 0){\\n            arr.add(a % 10);\\n            a/=10;\\n        }\\n        int[] nums = new int[arr.size()];\\n        for(int i = 0; i < arr.size(); i++){\\n            nums[i] = arr.get(arr.size() - 1 - i);\\n        }\\n        return g(nums,0, false);\\n    }\\n    int g(int[] A, int index, boolean allowed){\\n        int ans = 0;\\n        if(index == A.length - 1){\\n            for(int i = 0; i <  available.length && available[i] <= A[index]; i++){\\n                if(swapsToDifferent(available[i]) || allowed) {\\n                    ans++;\\n                }\\n            }\\n        }else{\\n            for(int i = 0; i <  available.length && available[i] <= A[index]; i++){\\n                if(available[i] == A[index]){\\n                    int res = g(A, index + 1, allowed || swapsToDifferent(A[index]));\\n                    ans += res;\\n                }else{\\n                    int res = f(A.length - index - 1, allowed || swapsToDifferent(available[i]));\\n                    ans += res;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    boolean swapsToDifferent(int number){\\n        for(int i : swaps){\\n            if(number == i) return true;\\n        }\\n        return false;\\n    }\\n    int f(int digits, boolean swapsToDifferent){\\n        if(digits == 0) return 0;\\n        if(digits == 1 && !swapsToDifferent) return 4;\\n        if(digits == 1 && swapsToDifferent) return 7;\\n        if(digits == 2 && !swapsToDifferent) return 40;\\n        if(digits == 2 && swapsToDifferent) return 49;\\n        if(digits == 3 && !swapsToDifferent) return 316;\\n        if(digits == 3 && swapsToDifferent) return 343;\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2400716,
                "title": "rotated-digits-java-easy-approach",
                "content": "In this approach we run a loop from 1 to given number and call our function isGood which checks whether the no. contain 2,5,6,9 if it is then it returns a true, otherwise false. And we keep counting through count variable if it is true.\\n\\n```\\nclass Solution {\\n     public int rotatedDigits(int n) {\\n        int ans = 0;\\n        for (int i = 1; i <= n; i++)\\n            if (isGood(i))\\n                ans++;\\n            return ans;\\n     }\\n      public boolean isGood(int n) {\\n           boolean check = false;\\n        while (n > 0)\\n        {\\n            int k = n % 10;\\n            if (k == 2 || k == 5 || k == 6 || k == 9)\\n                check = true;\\n            if (k == 3 || k == 4 || k == 7)\\n                return false;\\n            n /= 10;\\n        }\\n        return check;\\n     }\\n}\\n```\\nSpace Complexity: - O(1)\\nTime complexity: - O(N)\\n\\n**Please upvote if you find the solution helpful.**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n     public int rotatedDigits(int n) {\\n        int ans = 0;\\n        for (int i = 1; i <= n; i++)\\n            if (isGood(i))\\n                ans++;\\n            return ans;\\n     }\\n      public boolean isGood(int n) {\\n           boolean check = false;\\n        while (n > 0)\\n        {\\n            int k = n % 10;\\n            if (k == 2 || k == 5 || k == 6 || k == 9)\\n                check = true;\\n            if (k == 3 || k == 4 || k == 7)\\n                return false;\\n            n /= 10;\\n        }\\n        return check;\\n     }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2107725,
                "title": "0ms-faster-than-100-cpp-easy-solution",
                "content": "Basic idea behind this question is-\\n i) a number containing **3,4,7** can never be a good number.\\n ii) a number containing **only 0,1,8** can never be a good number.\\n iii) Rest all numbers are good numbers.\\n Here is the Code->\\n \\n\\t\\t  bool f(int k){\\n\\t\\t\\t\\tint n=k;\\n\\t\\t\\t\\tint total=0,c=0;\\n\\t\\t\\t\\tint a;\\n\\t\\t\\t\\twhile(n!=0){\\n\\t\\t\\t\\t\\t\\t\\ttotal++; //counts total digits in number k\\n\\t\\t\\t\\t\\t\\t\\ta = n%10;\\n\\t\\t\\t\\t\\t\\t\\tif(a==3 || a==4 || a==7) return false;  // return false if number k contains 3,4,7\\n\\t\\t\\t\\t\\t\\t\\tif(a==0 || a==1 || a==8 ) c++; //counts number of 0,1,8 in number k\\n            \\n\\t\\t\\t\\t\\t\\t\\tn=n/10;\\n        }\\n        return (c==total)?false:true;   //checks if number k contains only 0,1,8\\n    }\\n    int rotatedDigits(int n) {\\n        long long ans=0;\\n        for(int i=1;i<=n;i++){\\n            if(f(i)) ans++;\\n        }\\n        return ans;\\n    }\\n Please Do upvote this, if you find this solution helping.",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "Basic idea behind this question is-\\n i) a number containing **3,4,7** can never be a good number.\\n ii) a number containing **only 0,1,8** can never be a good number.\\n iii) Rest all numbers are good numbers.\\n Here is the Code->\\n \\n\\t\\t  bool f(int k){\\n\\t\\t\\t\\tint n=k;\\n\\t\\t\\t\\tint total=0,c=0;\\n\\t\\t\\t\\tint a;\\n\\t\\t\\t\\twhile(n!=0){\\n\\t\\t\\t\\t\\t\\t\\ttotal++; //counts total digits in number k\\n\\t\\t\\t\\t\\t\\t\\ta = n%10;\\n\\t\\t\\t\\t\\t\\t\\tif(a==3 || a==4 || a==7) return false;  // return false if number k contains 3,4,7\\n\\t\\t\\t\\t\\t\\t\\tif(a==0 || a==1 || a==8 ) c++; //counts number of 0,1,8 in number k\\n            \\n\\t\\t\\t\\t\\t\\t\\tn=n/10;\\n        }\\n        return (c==total)?false:true;   //checks if number k contains only 0,1,8\\n    }\\n    int rotatedDigits(int n) {\\n        long long ans=0;\\n        for(int i=1;i<=n;i++){\\n            if(f(i)) ans++;\\n        }\\n        return ans;\\n    }\\n Please Do upvote this, if you find this solution helping.",
                "codeTag": "Unknown"
            },
            {
                "id": 1792438,
                "title": "very-easy-c-implementation-with-easy-to-understand-explanation",
                "content": "**Observations-**\\n* We know that if a number contains 3, 4 or 7 then it\\'s not a good number.\\n* And if the number contains 2, 5, 6 or 9 then it can be rotated hence it can be a good number unless there is 3, 4 or 7 in the number.\\n\\nSo we will iterate through the digits of the number and check each digit for the conditions stated in the observations.\\n\\nBelow is C++ implementation of the approach-\\n\\n```\\nclass Solution {\\npublic:\\n    bool isGood(string s){\\n        bool isChanged=false;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'3\\' ||s[i]==\\'4\\' ||s[i]==\\'7\\')return false;\\n            if(s[i]==\\'2\\'|| s[i]==\\'5\\' || s[i]==\\'6\\'||s[i]==\\'9\\'){\\n                isChanged=true;\\n            }\\n        }\\n        return isChanged;\\n    }\\n    int rotatedDigits(int n) {\\n        int ans=0;\\n        for(int i=1;i<=n;i++){\\n            if(isGood(to_string(i)))ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nPlease upvote if you liked it... :)",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isGood(string s){\\n        bool isChanged=false;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'3\\' ||s[i]==\\'4\\' ||s[i]==\\'7\\')return false;\\n            if(s[i]==\\'2\\'|| s[i]==\\'5\\' || s[i]==\\'6\\'||s[i]==\\'9\\'){\\n                isChanged=true;\\n            }\\n        }\\n        return isChanged;\\n    }\\n    int rotatedDigits(int n) {\\n        int ans=0;\\n        for(int i=1;i<=n;i++){\\n            if(isGood(to_string(i)))ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1392591,
                "title": "easy-to-understand-100ms-digit-dp-c",
                "content": "class Solution {\\npublic:\\n\\n\\n\\n    int dp[6][2][2];\\n    int digit(string s, int n, bool tight, bool newnum)\\n    {\\n        if(n==0)\\n        {\\n            if(newnum)// to check have we ever incorporated a rotatable digit\\n                return 1;\\n            else\\n                return 0;\\n        }\\n        \\n        if(dp[n][tight][newnum]!=-1)\\n            return dp[n][tight][newnum];\\n            \\n            int ans=0;\\n        \\n            int ub= tight? s[s.size()-n]-\\'0\\': 9;\\n        \\n          for(int dig=0; dig<=ub; dig++)\\n          {\\n              if(dig==3 || dig == 7 || dig==4 )// we know if we incorporate these digits into our digit formation we will never be able to rotate it.\\n                  continue;\\n              \\n              if((dig==2 || dig==5 || dig==6 || dig==9))// if have atleast one of the rotateable digit we will be getting some new digit after rotation.\\n                  ans+= digit(s, n-1, tight && (dig== ub), 1);\\n              else\\n                  ans+= digit(s, n-1, tight && (dig==ub), newnum);\\n          }\\n        \\n        return dp[n][tight][newnum]= ans;\\n    }\\n    int rotatedDigits(int n) {\\n        \\n        string s= to_string(n);\\n        memset(dp, -1, sizeof(dp));\\n        return digit(s, s.size(), 1, 0);\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\n\\n\\n    int dp[6][2][2];\\n    int digit(string s, int n, bool tight, bool newnum)\\n    {\\n        if(n==0)\\n        {\\n            if(newnum)// to check have we ever incorporated a rotatable digit\\n                return 1;\\n            else\\n                return 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1389730,
                "title": "java-soln-faster-than-94-6-using-dynamic-programming",
                "content": "\\tpublic int rotatedDigits(int n) {\\n\\t\\t\\n\\t\\tint dp[] = new int[n+1];\\n        if(n<=1){\\n            return 0;\\n        }else if(n<=4){\\n            return 1;\\n        }else if(n<=5){\\n            return 2;\\n        }else if(n<=8){\\n            return 3;\\n        }else if(n<=10){\\n            return 4;\\n        }\\n        \\n        for(int i = 0 ; i<10; i++){\\n            if(i == 2 || i == 5 || i == 6 || i == 9){\\n                dp[i] = 1;\\n            }else if(i==0 || i == 1 || i==8){\\n                dp[i] = 2;                \\n            }\\n        }\\n        \\n        for(int i = 10 ; i<n+1; i++){\\n            int up = i%10;\\n            int rod = i /10;\\n            \\n            if(dp[up] == 0 || dp[rod] == 0){\\n                dp[i] = 0;\\n            }else if( (dp[up] == 1 && (dp[rod] == 1 || dp[rod] == 2)) || (dp[rod] ==1 && (dp[rod] == 2 || dp[rod] == 1)) ) {\\n                dp[i] = 1;\\n            }else if( (dp[up] == 2 && dp[rod] == 2) || (dp[rod]==2 && dp[up] ==2)){\\n                dp[i] = 2;\\n            }\\n        }\\n        \\n        int count = 0;\\n        for(int i =2; i< n+1; i++){\\n            if(dp[i] == 1) count++;\\n        }\\n        \\n        return count;\\n    }",
                "solutionTags": [],
                "code": "\\tpublic int rotatedDigits(int n) {\\n\\t\\t\\n\\t\\tint dp[] = new int[n+1];\\n        if(n<=1){\\n            return 0;\\n        }else if(n<=4){\\n            return 1;\\n        }else if(n<=5){\\n            return 2;\\n        }else if(n<=8){\\n            return 3;\\n        }else if(n<=10){\\n            return 4;\\n        }\\n        \\n        for(int i = 0 ; i<10; i++){\\n            if(i == 2 || i == 5 || i == 6 || i == 9){\\n                dp[i] = 1;\\n            }else if(i==0 || i == 1 || i==8){\\n                dp[i] = 2;                \\n            }\\n        }\\n        \\n        for(int i = 10 ; i<n+1; i++){\\n            int up = i%10;\\n            int rod = i /10;\\n            \\n            if(dp[up] == 0 || dp[rod] == 0){\\n                dp[i] = 0;\\n            }else if( (dp[up] == 1 && (dp[rod] == 1 || dp[rod] == 2)) || (dp[rod] ==1 && (dp[rod] == 2 || dp[rod] == 1)) ) {\\n                dp[i] = 1;\\n            }else if( (dp[up] == 2 && dp[rod] == 2) || (dp[rod]==2 && dp[up] ==2)){\\n                dp[i] = 2;\\n            }\\n        }\\n        \\n        int count = 0;\\n        for(int i =2; i< n+1; i++){\\n            if(dp[i] == 1) count++;\\n        }\\n        \\n        return count;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1300065,
                "title": "c-easy-2-approach",
                "content": "class Solution {\\npublic:\\n    \\n\\t\\n# \\tMethod 1:\\n    //using dp\\n    /*\\n    0--invalid 3 4 7 \\n    1--valid 1 8 0\\n    2--good 2 5 6 9\\n    */\\n    int rotatedDigitsHelper(int n){\\n        int count=0;\\n        int *dp=new int[n+1];\\n        for(int i=0;i<=n;i++){\\n            if(i<10){\\n                if(i==0||i==1||i==8){ //valid \\n                    dp[i]=1;\\n                }\\n                else if(i==2||i==5||i==6||i==9){//good\\n                    count++;\\n                    dp[i]=2;\\n                }\\n                else{dp[i]=0;} //invalid\\n            }\\n            else{\\n                int digit=dp[i%10];\\n                int num=dp[i/10];\\n                if(num==1 && digit==1) dp[i]=1; //contain valid only\\n                else if(num>=1 && digit>=1) {count++; dp[i]=2;} \\n            }\\n        }\\n        //free memory\\n        delete[] dp; \\n        return count;\\n    }\\n    int rotatedDigits(int n){\\n        return rotatedDigitsHelper(n);\\n    }\\n    \\n# \\tMethod2:\\n\\t\\n    //brute force\\n    bool isGood(int n){\\n        int rotating =false;\\n        while(n){\\n            int d=n%10;\\n            if(d==3||d==4||d==7) return false;\\n            if(d==2||d==5||d==6||d==9) rotating =true;\\n            n/=10;\\n        }\\n        return rotating;\\n    }\\n    \\n    int rotatedDigitsRec(int n) {\\n      int count=0;  \\n      for(int i=1;i<=n;i++)  \\n        if(isGood(i)) count++;\\n      return count;  \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n\\t\\n# \\tMethod 1:\\n    //using dp\\n    /*\\n    0--invalid 3 4 7 \\n    1--valid 1 8 0\\n    2--good 2 5 6 9\\n    */\\n    int rotatedDigitsHelper(int n){\\n        int count=0;\\n        int *dp=new int[n+1];\\n        for(int i=0;i<=n;i++){\\n            if(i<10){\\n                if(i==0||i==1||i==8){ //valid \\n                    dp[i]=1;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1248603,
                "title": "python-easy-implementation-commented-line-wise",
                "content": "class Solution:\\n    def rotatedDigits(self, n: int) -> int:\\n        \\n\\t\\tcount = 0\\n        for i in range(1, n+1):\\n\\t\\t    #convert in string, easy to work with digit of varying length\\n            i = str(i)\\n\\t\\t\\t# if any value in between contain 3,4,7 then that value becomes invalid, should not be counted\\n            if \\'3\\' in i or \\'4\\' in i or \\'7\\' in i:\\n                continue\\n\\t\\t\\t#only for 2,5,6,9 we can see change happen, and when there\\'s a change number will change.\\n            if \\'2\\' in i or \\'5\\' in i or \\'6\\' in i or \\'9\\' in i:\\n                count+=1\\n        return count\\n                    \\n                    \\n",
                "solutionTags": [],
                "code": "class Solution:\\n    def rotatedDigits(self, n: int) -> int:\\n        \\n\\t\\tcount = 0\\n        for i in range(1, n+1):\\n\\t\\t    #convert in string, easy to work with digit of varying length\\n            i = str(i)\\n\\t\\t\\t# if any value in between contain 3,4,7 then that value becomes invalid, should not be counted\\n            if \\'3\\' in i or \\'4\\' in i or \\'7\\' in i:\\n                continue\\n\\t\\t\\t#only for 2,5,6,9 we can see change happen, and when there\\'s a change number will change.\\n            if \\'2\\' in i or \\'5\\' in i or \\'6\\' in i or \\'9\\' in i:\\n                count+=1\\n        return count\\n                    \\n                    \\n",
                "codeTag": "Java"
            },
            {
                "id": 1167460,
                "title": "easy-java-solution",
                "content": "```\\nclass Solution {\\n\\n    public int rotatedDigits(int N) {\\n        \\n        int count = 0;\\n        \\n        for (int i = 1; i <= N; i++) {\\n            \\n            if (canRotate(i) && hasRotatableDigit(i)) {\\n                count++;\\n            } \\n        }\\n        \\n        return count;\\n        \\n    }\\n    \\n    \\n    private boolean canRotate(int num) {\\n        \\n        while (num > 0) {\\n            int r = num % 10;\\n            if (r == 3 || r == 4 || r == 7) {\\n                return false;\\n            }\\n            \\n            num /= 10;\\n        }\\n        \\n        return true;\\n    }\\n    \\n    private boolean hasRotatableDigit(int num) {\\n        \\n        while (num > 0) {\\n            int r = num % 10;\\n            if (r == 2 || r == 5 || r == 6 || r == 9) {\\n                return true;\\n            }\\n            \\n            num /= 10;\\n        }\\n        \\n        return false;\\n    }\\n    \\n}",
                "solutionTags": [],
                "code": "class Solution {\\n\\n    public int rotatedDigits(int N) {\\n        \\n        int count = 0;\\n        \\n        for (int i = 1; i <= N; i++) {\\n            \\n            if (canRotate(i) && hasRotatableDigit(i)) {\\n                count++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1049060,
                "title": "simple-c-using-strings",
                "content": "```\\n    int rotatedDigits(int N) {\\n        int count = 0;\\n        \\n        for (int i = 1; i <= N; i++) {\\n            bool isgood = false;\\n            \\n            string s = to_string(i);\\n            for (char& c : s) {\\n                if ( == \\'3\\' || c == \\'4\\' || c == \\'7\\') {\\n                    isgood = false;\\n                    break;\\n                }\\n                else if (c == \\'2\\' || c == \\'5\\' || c == \\'6\\' || c == \\'9\\')\\n                    isgood = true;\\n            }\\n            if (isgood)\\n                count++;\\n        }\\n        return count;      \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    int rotatedDigits(int N) {\\n        int count = 0;\\n        \\n        for (int i = 1; i <= N; i++) {\\n            bool isgood = false;\\n            \\n            string s = to_string(i);\\n            for (char& c : s) {\\n                if ( == \\'3\\' || c == \\'4\\' || c == \\'7\\') {\\n                    isgood = false;\\n                    break;\\n                }\\n                else if (c == \\'2\\' || c == \\'5\\' || c == \\'6\\' || c == \\'9\\')\\n                    isgood = true;\\n            }\\n            if (isgood)\\n                count++;\\n        }\\n        return count;      \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 829096,
                "title": "ruby-solution-with-explanation-104ms",
                "content": "```\\n# @param {Integer} n\\n# @return {Integer}\\n\\n# Runtime: 104 ms, faster than 82.35% of Ruby online submissions for Rotated Digits.\\n# Memory Usage: 10.1 MB, less than 35.29% of Ruby online submissions for Rotated Digits.\\ndef rotated_digits(n)\\n  return (1..n).count do |i|\\n    digits = i.digits\\n     \\n    # if [3,4,7] is inside digits, it is no good\\n    # if [0,1,8] are the only types of numbers that \"digits\" have it is no good\\n    !digits.any? { |digit| [3, 4, 7].include?(digit) } && !digits.all? { |digit| [0, 1, 8].include?(digit) }\\n  end\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\n# @param {Integer} n\\n# @return {Integer}\\n\\n# Runtime: 104 ms, faster than 82.35% of Ruby online submissions for Rotated Digits.\\n# Memory Usage: 10.1 MB, less than 35.29% of Ruby online submissions for Rotated Digits.\\ndef rotated_digits(n)\\n  return (1..n).count do |i|\\n    digits = i.digits\\n     \\n    # if [3,4,7] is inside digits, it is no good\\n    # if [0,1,8] are the only types of numbers that \"digits\" have it is no good\\n    !digits.any? { |digit| [3, 4, 7].include?(digit) } && !digits.all? { |digit| [0, 1, 8].include?(digit) }\\n  end\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 756817,
                "title": "python-simple-solution-in-one-line",
                "content": "```\\nclass Solution:\\n    def rotatedDigits(self, N: int) -> int:\\n        \\n        return len([i  for i in range(1, N+1) if (\\'2\\' in str(i) or  \\'5\\' in str(i) or  \\'6\\' in str(i) or  \\'9\\' in str(i)) and (\\'3\\' not in str(i) and  \\'4\\' not in str(i) and  \\'7\\' not in str(i))]) \\n```\\n\\nIncase it\\'s not clear, feel free to ask!",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rotatedDigits(self, N: int) -> int:\\n        \\n        return len([i  for i in range(1, N+1) if (\\'2\\' in str(i) or  \\'5\\' in str(i) or  \\'6\\' in str(i) or  \\'9\\' in str(i)) and (\\'3\\' not in str(i) and  \\'4\\' not in str(i) and  \\'7\\' not in str(i))]) \\n```",
                "codeTag": "Java"
            },
            {
                "id": 670117,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int rotatedDigits(int N) {\\n        int fans=0;\\n        for(int i=1;i<= N;i++){\\n            int mult=1;\\n            int ans=0;\\n            int num = i;\\n            if(isvalid(num)){\\n                 while(num !=0){\\n                     int rem= num %10;\\n                     ans = ans+ mult* afterrotation(rem);\\n                     mult=mult*10;\\n                     num=num/10;\\n                 }\\n                if(ans != i) fans++;\\n            }\\n            \\n            \\n        }\\n        \\n        return fans;\\n        \\n        \\n    }\\n    \\n    \\n    public int afterrotation(int n){\\n       if(n==0) return 0;\\n        if(n==1) return 1;\\n        if(n==8) return 8;\\n        if(n==2) return 5;\\n        if(n==5) return 2;\\n        if(n==6) return 9;\\n        if(n==9) return 6;\\n        return -1;\\n    }\\n    \\n    \\n    \\n    public boolean isvalid(int n){\\n        while(n!=0){\\n            int rem= n%10;\\n            if(rem == 3 || rem == 4 || rem==7){\\n                return false;\\n            }\\n            n=n/10;\\n        }\\n        return true;\\n    }\\n    \\n    \\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int rotatedDigits(int N) {\\n        int fans=0;\\n        for(int i=1;i<= N;i++){\\n            int mult=1;\\n            int ans=0;\\n            int num = i;\\n            if(isvalid(num)){\\n                 while(num !=0){\\n                     int rem= num %10;\\n                     ans = ans+ mult* afterrotation(rem);\\n                     mult=mult*10;\\n                     num=num/10;\\n                 }\\n                if(ans != i) fans++;\\n            }\\n            \\n            \\n        }\\n        \\n        return fans;\\n        \\n        \\n    }\\n    \\n    \\n    public int afterrotation(int n){\\n       if(n==0) return 0;\\n        if(n==1) return 1;\\n        if(n==8) return 8;\\n        if(n==2) return 5;\\n        if(n==5) return 2;\\n        if(n==6) return 9;\\n        if(n==9) return 6;\\n        return -1;\\n    }\\n    \\n    \\n    \\n    public boolean isvalid(int n){\\n        while(n!=0){\\n            int rem= n%10;\\n            if(rem == 3 || rem == 4 || rem==7){\\n                return false;\\n            }\\n            n=n/10;\\n        }\\n        return true;\\n    }\\n    \\n    \\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 618941,
                "title": "java-dp",
                "content": "orig: https://leetcode.com/problems/rotated-digits/discuss/117975/Java-dp-solution-9ms\\n```\\n    public int rotatedDigits(int N) {\\n        int[] dp = new int[N+1];\\n        int res = 0;\\n        Set<Integer> s1 = Set.of(0, 1, 8), s2 = Set.of(2, 5, 6, 9);\\n        for (int i = 0; i < Math.min(10, N + 1); i++) {\\n            if (s1.contains(i)) dp[i] = 1;\\n            else if (s2.contains(i)) {\\n                dp[i] = 2;\\n                res++;\\n            }\\n        }\\n        for (int i = 10; i <= N; i++) {\\n            int a = dp[i / 10],  b = dp[i % 10];\\n            if (a == 1 && b == 1) dp[i] = 1;\\n            else if (a >= 1 && b >= 1) {\\n                dp[i] = 2;\\n                res++;\\n            }\\n        }\\n        return res;\\n    }\\n\\n```\\n",
                "solutionTags": [],
                "code": "```\\n    public int rotatedDigits(int N) {\\n        int[] dp = new int[N+1];\\n        int res = 0;\\n        Set<Integer> s1 = Set.of(0, 1, 8), s2 = Set.of(2, 5, 6, 9);\\n        for (int i = 0; i < Math.min(10, N + 1); i++) {\\n            if (s1.contains(i)) dp[i] = 1;\\n            else if (s2.contains(i)) {\\n                dp[i] = 2;\\n                res++;\\n            }\\n        }\\n        for (int i = 10; i <= N; i++) {\\n            int a = dp[i / 10],  b = dp[i % 10];\\n            if (a == 1 && b == 1) dp[i] = 1;\\n            else if (a >= 1 && b >= 1) {\\n                dp[i] = 2;\\n                res++;\\n            }\\n        }\\n        return res;\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 573571,
                "title": "python-intuitive-code",
                "content": "```\\ndict_ = {0:0,1:1,2:5,5:2,6:9,8:8,9:6} # mirrors - 180 degrees\\ns = str(N)\\ncount = 0\\n\\nfor i in range(1, N+1):\\n\\tclone = \"\"\\n\\ts = str(i)\\n\\tnot_in_dict = True\\n\\tfor digit in s:\\n\\t\\ta = int(digit)\\n\\t\\tif a in dict_:\\n\\t\\t\\tclone += str(dict_[a])\\n\\t\\telse:\\n\\t\\t\\tnot_in_dict = False\\n\\n\\tif not_in_dict == True:\\n\\t\\tnew_image_number = int(clone)\\n\\t\\tif new_image_number != i:\\n\\t\\t\\tcount += 1\\n\\nprint(count)\\nreturn count\\n```",
                "solutionTags": [],
                "code": "```\\ndict_ = {0:0,1:1,2:5,5:2,6:9,8:8,9:6} # mirrors - 180 degrees\\ns = str(N)\\ncount = 0\\n\\nfor i in range(1, N+1):\\n\\tclone = \"\"\\n\\ts = str(i)\\n\\tnot_in_dict = True\\n\\tfor digit in s:\\n\\t\\ta = int(digit)\\n\\t\\tif a in dict_:\\n\\t\\t\\tclone += str(dict_[a])\\n\\t\\telse:\\n\\t\\t\\tnot_in_dict = False\\n\\n\\tif not_in_dict == True:\\n\\t\\tnew_image_number = int(clone)\\n\\t\\tif new_image_number != i:\\n\\t\\t\\tcount += 1\\n\\nprint(count)\\nreturn count\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 551837,
                "title": "python3-solution-using-a-string-conversion",
                "content": "Convert the number to a string, then check for any() and all() of the filtering digits.\\n```\\nclass Solution:\\n    def rotatedDigits(self, N: int) -> int:\\n        quantity = 0\\n        for num in range(1, N+1):\\n            tally = str(num)\\n            if any([True if x in \\'347\\' else False for x in tally]):\\n                continue\\n            if all([True if x in \\'018\\' else False for x in tally]):\\n                continue\\n            quantity += 1\\n        return quantity\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rotatedDigits(self, N: int) -> int:\\n        quantity = 0\\n        for num in range(1, N+1):\\n            tally = str(num)\\n            if any([True if x in \\'347\\' else False for x in tally]):\\n                continue\\n            if all([True if x in \\'018\\' else False for x in tally]):\\n                continue\\n            quantity += 1\\n        return quantity\\n```",
                "codeTag": "Java"
            },
            {
                "id": 538741,
                "title": "simple-java-explained",
                "content": "```\\n//Check if the number contains the desired digits ( 2 5 6 9 ). If yes, just make sure that no remaining digits are invalid. \\n//Else, false\\npublic int rotatedDigits(int N) {\\n        int count = 0;\\n        for(int i = 1; i <= N; i++) {\\n            if(!isGoodNumber(i)) continue;\\n            count++;\\n        }\\n        return count;\\n    }\\n\\n    private boolean isGoodNumber(int N) {\\n        boolean foundGoodDigit = false;\\n        while(N > 0) {\\n            int rem = N%10;\\n            N /= 10;\\n            if(rem == 2 || rem == 5 || rem == 6 || rem == 9) {\\n                foundGoodDigit = true;\\n            }\\n            if(rem == 3 || rem == 4 || rem == 7) return false;\\n        }\\n        return foundGoodDigit;\\n    }",
                "solutionTags": [],
                "code": "```\\n//Check if the number contains the desired digits ( 2 5 6 9 ). If yes, just make sure that no remaining digits are invalid. \\n//Else, false\\npublic int rotatedDigits(int N) {\\n        int count = 0;\\n        for(int i = 1; i <= N; i++) {\\n            if(!isGoodNumber(i)) continue;\\n            count++;\\n        }\\n        return count;\\n    }\\n\\n    private boolean isGoodNumber(int N) {\\n        boolean foundGoodDigit = false;\\n        while(N > 0) {\\n            int rem = N%10;\\n            N /= 10;\\n            if(rem == 2 || rem == 5 || rem == 6 || rem == 9) {\\n                foundGoodDigit = true;\\n            }\\n            if(rem == 3 || rem == 4 || rem == 7) return false;\\n        }\\n        return foundGoodDigit;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 435449,
                "title": "c-o-logn-time-code-similar-as-lc1012",
                "content": "get intution from lee215\\'s post:\\n[1012. Count the Number Without Repeated Digit]( https://leetcode.com/problems/numbers-with-repeated-digits/discuss/256725/JavaPython-Count-the-Number-Without-Repeated-Digiot)\\nTheir structure is very similar\\n\\nif you have read the post above, it would be easy to understand my code \\n```\\nclass Solution {\\npublic:\\n    int rotatedDigits(int N) {\\n        vector<int> digits;\\n        int res = 0;\\n        \\n        for (int i = N + 1; i > 0; i /= 10) {\\n            digits.push_back(i % 10);\\n        }\\n        reverse(digits.begin(), digits.end());\\n        \\n        int n = digits.size();\\n        int flag = 0, j =0, k = 0;\\n        int spNum[7] = {0, 1, 2, 5, 6, 8, 9};\\n        \\n        for (int i = 0; i < n; i++){\\n            for (j = 0, k = 0; spNum[j] < digits[i]; j++){\\n                if (flag) continue;\\n                if (spNum[j] == 0 || spNum[j] == 1 || spNum[j] == 8) k++;\\n            }\\n            res += j * pow(7, n - i - 1) - k * pow(3, n - i - 1);\\n            if (digits[i] == 2 || digits[i] == 5 || digits[i] == 6 || digits[i] == 9) flag = 1;\\n            if (digits[i] == 3 || digits[i] == 4 || digits[i] == 7) break;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int rotatedDigits(int N) {\\n        vector<int> digits;\\n        int res = 0;\\n        \\n        for (int i = N + 1; i > 0; i /= 10) {\\n            digits.push_back(i % 10);\\n        }\\n        reverse(digits.begin(), digits.end());\\n        \\n        int n = digits.size();\\n        int flag = 0, j =0, k = 0;\\n        int spNum[7] = {0, 1, 2, 5, 6, 8, 9};\\n        \\n        for (int i = 0; i < n; i++){\\n            for (j = 0, k = 0; spNum[j] < digits[i]; j++){\\n                if (flag) continue;\\n                if (spNum[j] == 0 || spNum[j] == 1 || spNum[j] == 8) k++;\\n            }\\n            res += j * pow(7, n - i - 1) - k * pow(3, n - i - 1);\\n            if (digits[i] == 2 || digits[i] == 5 || digits[i] == 6 || digits[i] == 9) flag = 1;\\n            if (digits[i] == 3 || digits[i] == 4 || digits[i] == 7) break;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 378707,
                "title": "java-2ms-solution-with-explanation",
                "content": "/*\\nthe problem can be rephrased as:\\nfind numbers from [1,N], which should:\\n1. Can\\'t contain any one digit of 3,4,7   (invalid digits)\\n2. Must contain at least one digit in:  2,5,6,9        (update digits)    \\n\\ndigits of 0,1,8 doesn\\'t matter to this problem. \\n\\nin order to achieve above.\\n1. first create a table to init value for digit 0 -9 as below: -1 means invalid numbers, 1 means it change values, 0 doesn\\'t matter\\n        int[] validTable= {0,0,1,-1,-1,1,1,-1,0,1};\\n2. check each number i, by check each digits of i against it.\\n\\n*/\\n```\\nclass Solution {   \\n    \\n    public int rotatedDigits(int N) {\\n        \\n        //need contains one of 2,5,6,9, can\\'t container 3,4,7         \\n        //0,1,8 will be 0,  2,5,6,9 will be 1,  3,4,7:2\\n        int[] validTable= {0,0,1,-1,-1,1,1,-1,0,1};\\n        int res = 0;\\n        for(int i=2; i<=N; i++) {\\n            if(isGoodNumber(validTable,i)) res++;            \\n        }\\n        return res;\\n        \\n    }\\n    \\n    private boolean isGoodNumber(int[] validTable,int num) {\\n        //in order to be a good number, num mustn\\'t contain any digits of 3,4,7, \\n        //and must contain one of 2,5,6,9\\n        //0,1,8 has no effect on the result;\\n        \\n        boolean isDifferent = false;\\n        while(num>0){\\n            int digit = num%10;\\n            if(validTable[digit]==-1) return false;\\n            else if (validTable[digit]==1) isDifferent=true;\\n            num/=10;\\n        }\\n        return isDifferent;\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {   \\n    \\n    public int rotatedDigits(int N) {\\n        \\n        //need contains one of 2,5,6,9, can\\'t container 3,4,7         \\n        //0,1,8 will be 0,  2,5,6,9 will be 1,  3,4,7:2\\n        int[] validTable= {0,0,1,-1,-1,1,1,-1,0,1};\\n        int res = 0;\\n        for(int i=2; i<=N; i++) {\\n            if(isGoodNumber(validTable,i)) res++;            \\n        }\\n        return res;\\n        \\n    }\\n    \\n    private boolean isGoodNumber(int[] validTable,int num) {\\n        //in order to be a good number, num mustn\\'t contain any digits of 3,4,7, \\n        //and must contain one of 2,5,6,9\\n        //0,1,8 has no effect on the result;\\n        \\n        boolean isDifferent = false;\\n        while(num>0){\\n            int digit = num%10;\\n            if(validTable[digit]==-1) return false;\\n            else if (validTable[digit]==1) isDifferent=true;\\n            num/=10;\\n        }\\n        return isDifferent;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 352128,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public int rotatedDigits(int N) {\\n        int count=0;\\n        for(int i=1; i<=N; i++)\\n            if(isValid(i)) count++;\\n        return count;\\n    }\\n    \\n    public boolean isValid(int n){\\n        boolean valid = false;\\n        while(n > 0){\\n        if((n % 10) == 2 || (n % 10) == 5 || (n % 10) == 6 || (n % 10) == 9)\\n            valid = true; \\n        if((n % 10) == 3 || (n % 10) == 4 || (n % 10) == 7)\\n            return false;\\n        n /= 10;\\n        }    \\n        return valid;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int rotatedDigits(int N) {\\n        int count=0;\\n        for(int i=1; i<=N; i++)\\n            if(isValid(i)) count++;\\n        return count;\\n    }\\n    \\n    public boolean isValid(int n){\\n        boolean valid = false;\\n        while(n > 0){\\n        if((n % 10) == 2 || (n % 10) == 5 || (n % 10) == 6 || (n % 10) == 9)\\n            valid = true; \\n        if((n % 10) == 3 || (n % 10) == 4 || (n % 10) == 7)\\n            return false;\\n        n /= 10;\\n        }    \\n        return valid;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 343982,
                "title": "solution-in-python-3-beats-100-o-log-n-combinatoric-solution-not-brute-force",
                "content": "```\\nclass Solution:\\n    def rotatedDigits(self, N: int) -> int:\\n    \\tN, t, c = str(N), 0, 1\\n    \\tL, a, b = len(N) - 1, [1,2,3,3,3,4,5,5,6,7], [1,2,2,2,2,2,2,2,3,3] \\n    \\t\\n    \\tfor i in range(L):\\n    \\t\\tif N[i] == \\'0\\': continue\\n    \\t\\tt += a[int(N[i])-1]*7**(L-i) - c*b[int(N[i])-1]*3**(L-i)\\n    \\t\\tif N[i] in \\'347\\': return t\\n    \\t\\tif N[i] not in \\'18\\': c = 0\\n    \\treturn t + a[int(N[-1])] - c*b[int(N[-1])]\\n\\t\\t\\n\\t\\t\\n- Junaid Mansuri",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rotatedDigits(self, N: int) -> int:\\n    \\tN, t, c = str(N), 0, 1\\n    \\tL, a, b = len(N) - 1, [1,2,3,3,3,4,5,5,6,7], [1,2,2,2,2,2,2,2,3,3] \\n    \\t\\n    \\tfor i in range(L):\\n    \\t\\tif N[i] == \\'0\\': continue\\n    \\t\\tt += a[int(N[i])-1]*7**(L-i) - c*b[int(N[i])-1]*3**(L-i)\\n    \\t\\tif N[i] in \\'347\\': return t\\n    \\t\\tif N[i] not in \\'18\\': c = 0\\n    \\treturn t + a[int(N[-1])] - c*b[int(N[-1])]\\n\\t\\t\\n\\t\\t\\n- Junaid Mansuri",
                "codeTag": "Java"
            },
            {
                "id": 325162,
                "title": "simple-java-solution-using-regex",
                "content": "```\\nclass Solution {\\n    public int rotatedDigits(int N) {\\n        int ans =0;\\n        int minus=0;\\n        for(int i=1;i<=N;++i){\\n            String temp = String.valueOf(i);\\n            if(temp.matches(\"^[1082569]*$\")){\\n                ans++;\\n            }\\n            if(temp.matches(\"^[108]*$\")){ // We need to subtact the count of those numbers which on roation remains the same, i.e all number formed by ONLY 1, 0 or 8.\\n                minus++;\\n            }\\n        }\\n        return ans-minus;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int rotatedDigits(int N) {\\n        int ans =0;\\n        int minus=0;\\n        for(int i=1;i<=N;++i){\\n            String temp = String.valueOf(i);\\n            if(temp.matches(\"^[1082569]*$\")){\\n                ans++;\\n            }\\n            if(temp.matches(\"^[108]*$\")){ // We need to subtact the count of those numbers which on roation remains the same, i.e all number formed by ONLY 1, 0 or 8.\\n                minus++;\\n            }\\n        }\\n        return ans-minus;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 238808,
                "title": "simple-o-ln-n",
                "content": "Suppose:\\n   `R7` - numbers, consisting only of digits `0,1,2,5,6,8,9`, on the interval `1..N`\\n   `R3` - numbers, consisting only of digits `0,1,8`, on the interval `1..N`\\n   `r7` and `r3` - their sizes respectevely\\nSo we must find `r7 - r3`\\nAll numbers from `R7` can be represented as consequent numbers of 7-based number system. So if `N7` is the biggest number from `R7`, the value of N7, interpreted as 7-based number, is `r7`\\nThe same correct about `r3`\\nFor searching `N7` ( `N3`) we can start from the most significant digit of `N`, let\\'s call it `n`. If `n` is a digit from the set `0,1,2,5,6,8,9` (`0,1,8`) we can keep it unchanged and go the the next digit. If `n` is not from the set, we must replace it by the biggest digit from the set, which is smaller than `n` and replace the rest of digits by the max digit from the set - `9` (`8`). Example:\\nN:   12345\\nN7: 12299\\nN3: 11888\\n```\\t\\nval floor7 = Array(0, 1, 2, 2, 2, 3, 4, 4, 5, 6) // floorN(i) - value, represented by digit i in N-based system\\nval floor3 = Array(0, 1, 1, 1, 1, 1, 1, 1, 2, 2) \\nval set7 = Array(true, true, true, false, false, true, true, false, true, true) // setN(i) - if digit i is a member of a N-set\\nval set3 = Array(true, true, false, false, false, false, false, false, true, false)\\ncase class State(res7: Int, res3: Int, turbo7: Boolean, turbo3: Boolean) //turboN - if we must use the max digit from the N-set\\n    \\ndef rotatedDigits(N: Int): Int = {\\n\\tval res = (State(0, 0, false, false) /: toDigits(N)){ (s, n) => State(\\n\\t\\tres7    = s.res7 * 7 + (if (s.turbo7) 6 else floor7(n)),\\n\\t\\tres3    = s.res3 * 3 + (if (s.turbo3) 2 else floor3(n)),\\n\\t\\tturbo7  = s.turbo7 || !set7(n),\\n\\t\\tturbo3  = s.turbo3 || !set3(n)\\n\\t)}\\n\\tres.res7 - res.res3\\n}\\n\\nprivate def toDigits(N: Int, res: Seq[Int] = Seq.empty[Int]): Seq[Int] = \\n\\tif (N==0) res \\n\\telse toDigits(N/10, (N % 10) +: res)\\n```",
                "solutionTags": [],
                "code": "```\\t\\nval floor7 = Array(0, 1, 2, 2, 2, 3, 4, 4, 5, 6) // floorN(i) - value, represented by digit i in N-based system\\nval floor3 = Array(0, 1, 1, 1, 1, 1, 1, 1, 2, 2) \\nval set7 = Array(true, true, true, false, false, true, true, false, true, true) // setN(i) - if digit i is a member of a N-set\\nval set3 = Array(true, true, false, false, false, false, false, false, true, false)\\ncase class State(res7: Int, res3: Int, turbo7: Boolean, turbo3: Boolean) //turboN - if we must use the max digit from the N-set\\n    \\ndef rotatedDigits(N: Int): Int = {\\n\\tval res = (State(0, 0, false, false) /: toDigits(N)){ (s, n) => State(\\n\\t\\tres7    = s.res7 * 7 + (if (s.turbo7) 6 else floor7(n)),\\n\\t\\tres3    = s.res3 * 3 + (if (s.turbo3) 2 else floor3(n)),\\n\\t\\tturbo7  = s.turbo7 || !set7(n),\\n\\t\\tturbo3  = s.turbo3 || !set3(n)\\n\\t)}\\n\\tres.res7 - res.res3\\n}\\n\\nprivate def toDigits(N: Int, res: Seq[Int] = Seq.empty[Int]): Seq[Int] = \\n\\tif (N==0) res \\n\\telse toDigits(N/10, (N % 10) +: res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 238427,
                "title": "o-logn-time-o-1-space-java-solution",
                "content": "There are at most around hundred iterations in this question.\\n\\n```\\npublic int rotatedDigits(int N) {\\n    int[] sum = new int[2];\\n    sum[1] = 1;\\n\\n    int[][] dp = new int[2][10];\\n    dp[1][0] = 1;\\n    while (N > 0) {\\n        // update dp\\n        for (int i = 1; i < 10; i++) {\\n            if (i == 3 || i == 4 || i == 7) {\\n                dp[0][i] = dp[0][i - 1];\\n                dp[1][i] = dp[1][i - 1];\\n            } else if (i == 0 || i == 1 || i == 8) {\\n                dp[0][i] = dp[0][i - 1] + dp[0][0];\\n                dp[1][i] = dp[1][i - 1] + dp[1][0];\\n            } else { // i == 2 || 5 || 6 || 9\\n                dp[0][i] = dp[0][i - 1] + dp[1][0];\\n                dp[1][i] = dp[1][i - 1] + dp[1][0];\\n            }\\n        }\\n\\n        int d = N % 10;\\n        // update sum\\n        if (d == 0) {\\n\\n        } else if (d == 3 || d == 4 || d == 7) {\\n            sum[0] = dp[0][d];\\n            sum[1] = dp[1][d];\\n        } else if (d == 1 || d == 8) {\\n            sum[0] = dp[0][d - 1] + sum[0];\\n            sum[1] = dp[1][d - 1] + sum[1];\\n        } else { // d == 2 || 5 || 6 || 9\\n            sum[0] = dp[0][d - 1] + sum[1];\\n            sum[1] = dp[1][d - 1] + sum[1];   \\n        }\\n\\n        // update dp\\n        dp[0][0] = dp[0][9];\\n        dp[1][0] = dp[1][9];\\n        // update N\\n        N /= 10;\\n    }\\n    return sum[0];\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int rotatedDigits(int N) {\\n    int[] sum = new int[2];\\n    sum[1] = 1;\\n\\n    int[][] dp = new int[2][10];\\n    dp[1][0] = 1;\\n    while (N > 0) {\\n        // update dp\\n        for (int i = 1; i < 10; i++) {\\n            if (i == 3 || i == 4 || i == 7) {\\n                dp[0][i] = dp[0][i - 1];\\n                dp[1][i] = dp[1][i - 1];\\n            } else if (i == 0 || i == 1 || i == 8) {\\n                dp[0][i] = dp[0][i - 1] + dp[0][0];\\n                dp[1][i] = dp[1][i - 1] + dp[1][0];\\n            } else { // i == 2 || 5 || 6 || 9\\n                dp[0][i] = dp[0][i - 1] + dp[1][0];\\n                dp[1][i] = dp[1][i - 1] + dp[1][0];\\n            }\\n        }\\n\\n        int d = N % 10;\\n        // update sum\\n        if (d == 0) {\\n\\n        } else if (d == 3 || d == 4 || d == 7) {\\n            sum[0] = dp[0][d];\\n            sum[1] = dp[1][d];\\n        } else if (d == 1 || d == 8) {\\n            sum[0] = dp[0][d - 1] + sum[0];\\n            sum[1] = dp[1][d - 1] + sum[1];\\n        } else { // d == 2 || 5 || 6 || 9\\n            sum[0] = dp[0][d - 1] + sum[1];\\n            sum[1] = dp[1][d - 1] + sum[1];   \\n        }\\n\\n        // update dp\\n        dp[0][0] = dp[0][9];\\n        dp[1][0] = dp[1][9];\\n        // update N\\n        N /= 10;\\n    }\\n    return sum[0];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 212259,
                "title": "4ms-java-dp-solution",
                "content": "To simplify the question, a number is good if it has 2,5,6 or 9, and a number is invalid if it has 3,4 or 7\\nSo we only need to look at digits 0,1,2,4,6,8,9 and do a dp for all number < N\\nif there exists a good digit (i.e. 2,5,6 or 9), the numbers after that recursion are also good.\\n\\n\\tclass Solution {\\n\\t\\tpublic int rotatedDigits(int N) {\\n\\t\\t\\treturn rotatedDigits(N, 0, false);\\n\\t\\t}\\n\\n\\t\\tpublic int rotatedDigits(int N, int i, boolean isGood) {\\n\\t\\t\\tif (i > N) return 0;\\n\\t\\t\\tint count = 0;\\n\\t\\t\\tfor (int j : new int[]{2, 5, 6, 9}) {\\n\\t\\t\\t\\tcount += rotatedDigits(N, i * 10 + j, true);\\n\\t\\t\\t}\\n\\t\\t\\tfor (int j : new int[]{0, 1, 8}) {\\n\\t\\t\\t\\tif (i == 0 && j == 0) continue;\\n\\t\\t\\t\\tcount += rotatedDigits(N, i * 10 + j, isGood);\\n\\t\\t\\t}\\n\\t\\t\\tif (isGood) count++;\\n\\t\\t\\treturn count;\\n\\t\\t}\\n\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tpublic int rotatedDigits(int N) {\\n\\t\\t\\treturn rotatedDigits(N, 0, false);\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 205213,
                "title": "java-3-line-o-log-n-beats-100",
                "content": "...because the O(1) solution wouldn\\'t fit!\\n```\\n    public int rotatedDigits(int N) {\\n        int n = Arrays.binarySearch( x, N );\\n        return n<0?-2-n:n;\\n    }\\n\\nprivate static final int[] x = { 0, 2, 5, 6, 9, 12, 15, 16, 19, 20, 21, 22, 25, 26, 28, 29, 50, 51, 52, 55, 56, 58, 59, 60, 61, 62, 65, 66, 68, 69, 82, 85, 86, 89, 90, 91, 92, 95, 96, 98, 99, 102, 105, 106, 109, 112, 115, 116, 119, 120, 121, 122, 125, 126, 128, 129, 150, 151, 152, 155, 156, 158, 159, 160, 161, 162, 165, 166, 168, 169, 182, 185, 186, 189, 190, 191, 192, 195, 196, 198, 199, 200, 201, 202, 205, 206, 208, 209, 210, 211, 212, 215, 216, 218, 219, 220, 221, 222, 225, 226, 228, 229, 250, 251, 252, 255, 256, 258, 259, 260, 261, 262, 265, 266, 268, 269, 280, 281, 282, 285, 286, 288, 289, 290, 291, 292, 295, 296, 298, 299, 500, 501, 502, 505, 506, 508, 509, 510, 511, 512, 515, 516, 518, 519, 520, 521, 522, 525, 526, 528, 529, 550, 551, 552, 555, 556, 558, 559, 560, 561, 562, 565, 566, 568, 569, 580, 581, 582, 585, 586, 588, 589, 590, 591, 592, 595, 596, 598, 599, 600, 601, 602, 605, 606, 608, 609, 610, 611, 612, 615, 616, 618, 619, 620, 621, 622, 625, 626, 628, 629, 650, 651, 652, 655, 656, 658, 659, 660, 661, 662, 665, 666, 668, 669, 680, 681, 682, 685, 686, 688, 689, 690, 691, 692, 695, 696, 698, 699, 802, 805, 806, 809, 812, 815, 816, 819, 820, 821, 822, 825, 826, 828, 829, 850, 851, 852, 855, 856, 858, 859, 860, 861, 862, 865, 866, 868, 869, 882, 885, 886, 889, 890, 891, 892, 895, 896, 898, 899, 900, 901, 902, 905, 906, 908, 909, 910, 911, 912, 915, 916, 918, 919, 920, 921, 922, 925, 926, 928, 929, 950, 951, 952, 955, 956, 958, 959, 960, 961, 962, 965, 966, 968, 969, 980, 981, 982, 985, 986, 988, 989, 990, 991, 992, 995, 996, 998, 999, 1002, 1005, 1006, 1009, 1012, 1015, 1016, 1019, 1020, 1021, 1022, 1025, 1026, 1028, 1029, 1050, 1051, 1052, 1055, 1056, 1058, 1059, 1060, 1061, 1062, 1065, 1066, 1068, 1069, 1082, 1085, 1086, 1089, 1090, 1091, 1092, 1095, 1096, 1098, 1099, 1102, 1105, 1106, 1109, 1112, 1115, 1116, 1119, 1120, 1121, 1122, 1125, 1126, 1128, 1129, 1150, 1151, 1152, 1155, 1156, 1158, 1159, 1160, 1161, 1162, 1165, 1166, 1168, 1169, 1182, 1185, 1186, 1189, 1190, 1191, 1192, 1195, 1196, 1198, 1199, 1200, 1201, 1202, 1205, 1206, 1208, 1209, 1210, 1211, 1212, 1215, 1216, 1218, 1219, 1220, 1221, 1222, 1225, 1226, 1228, 1229, 1250, 1251, 1252, 1255, 1256, 1258, 1259, 1260, 1261, 1262, 1265, 1266, 1268, 1269, 1280, 1281, 1282, 1285, 1286, 1288, 1289, 1290, 1291, 1292, 1295, 1296, 1298, 1299, 1500, 1501, 1502, 1505, 1506, 1508, 1509, 1510, 1511, 1512, 1515, 1516, 1518, 1519, 1520, 1521, 1522, 1525, 1526, 1528, 1529, 1550, 1551, 1552, 1555, 1556, 1558, 1559, 1560, 1561, 1562, 1565, 1566, 1568, 1569, 1580, 1581, 1582, 1585, 1586, 1588, 1589, 1590, 1591, 1592, 1595, 1596, 1598, 1599, 1600, 1601, 1602, 1605, 1606, 1608, 1609, 1610, 1611, 1612, 1615, 1616, 1618, 1619, 1620, 1621, 1622, 1625, 1626, 1628, 1629, 1650, 1651, 1652, 1655, 1656, 1658, 1659, 1660, 1661, 1662, 1665, 1666, 1668, 1669, 1680, 1681, 1682, 1685, 1686, 1688, 1689, 1690, 1691, 1692, 1695, 1696, 1698, 1699, 1802, 1805, 1806, 1809, 1812, 1815, 1816, 1819, 1820, 1821, 1822, 1825, 1826, 1828, 1829, 1850, 1851, 1852, 1855, 1856, 1858, 1859, 1860, 1861, 1862, 1865, 1866, 1868, 1869, 1882, 1885, 1886, 1889, 1890, 1891, 1892, 1895, 1896, 1898, 1899, 1900, 1901, 1902, 1905, 1906, 1908, 1909, 1910, 1911, 1912, 1915, 1916, 1918, 1919, 1920, 1921, 1922, 1925, 1926, 1928, 1929, 1950, 1951, 1952, 1955, 1956, 1958, 1959, 1960, 1961, 1962, 1965, 1966, 1968, 1969, 1980, 1981, 1982, 1985, 1986, 1988, 1989, 1990, 1991, 1992, 1995, 1996, 1998, 1999, 2000, 2001, 2002, 2005, 2006, 2008, 2009, 2010, 2011, 2012, 2015, 2016, 2018, 2019, 2020, 2021, 2022, 2025, 2026, 2028, 2029, 2050, 2051, 2052, 2055, 2056, 2058, 2059, 2060, 2061, 2062, 2065, 2066, 2068, 2069, 2080, 2081, 2082, 2085, 2086, 2088, 2089, 2090, 2091, 2092, 2095, 2096, 2098, 2099, 2100, 2101, 2102, 2105, 2106, 2108, 2109, 2110, 2111, 2112, 2115, 2116, 2118, 2119, 2120, 2121, 2122, 2125, 2126, 2128, 2129, 2150, 2151, 2152, 2155, 2156, 2158, 2159, 2160, 2161, 2162, 2165, 2166, 2168, 2169, 2180, 2181, 2182, 2185, 2186, 2188, 2189, 2190, 2191, 2192, 2195, 2196, 2198, 2199, 2200, 2201, 2202, 2205, 2206, 2208, 2209, 2210, 2211, 2212, 2215, 2216, 2218, 2219, 2220, 2221, 2222, 2225, 2226, 2228, 2229, 2250, 2251, 2252, 2255, 2256, 2258, 2259, 2260, 2261, 2262, 2265, 2266, 2268, 2269, 2280, 2281, 2282, 2285, 2286, 2288, 2289, 2290, 2291, 2292, 2295, 2296, 2298, 2299, 2500, 2501, 2502, 2505, 2506, 2508, 2509, 2510, 2511, 2512, 2515, 2516, 2518, 2519, 2520, 2521, 2522, 2525, 2526, 2528, 2529, 2550, 2551, 2552, 2555, 2556, 2558, 2559, 2560, 2561, 2562, 2565, 2566, 2568, 2569, 2580, 2581, 2582, 2585, 2586, 2588, 2589, 2590, 2591, 2592, 2595, 2596, 2598, 2599, 2600, 2601, 2602, 2605, 2606, 2608, 2609, 2610, 2611, 2612, 2615, 2616, 2618, 2619, 2620, 2621, 2622, 2625, 2626, 2628, 2629, 2650, 2651, 2652, 2655, 2656, 2658, 2659, 2660, 2661, 2662, 2665, 2666, 2668, 2669, 2680, 2681, 2682, 2685, 2686, 2688, 2689, 2690, 2691, 2692, 2695, 2696, 2698, 2699, 2800, 2801, 2802, 2805, 2806, 2808, 2809, 2810, 2811, 2812, 2815, 2816, 2818, 2819, 2820, 2821, 2822, 2825, 2826, 2828, 2829, 2850, 2851, 2852, 2855, 2856, 2858, 2859, 2860, 2861, 2862, 2865, 2866, 2868, 2869, 2880, 2881, 2882, 2885, 2886, 2888, 2889, 2890, 2891, 2892, 2895, 2896, 2898, 2899, 2900, 2901, 2902, 2905, 2906, 2908, 2909, 2910, 2911, 2912, 2915, 2916, 2918, 2919, 2920, 2921, 2922, 2925, 2926, 2928, 2929, 2950, 2951, 2952, 2955, 2956, 2958, 2959, 2960, 2961, 2962, 2965, 2966, 2968, 2969, 2980, 2981, 2982, 2985, 2986, 2988, 2989, 2990, 2991, 2992, 2995, 2996, 2998, 2999, 5000, 5001, 5002, 5005, 5006, 5008, 5009, 5010, 5011, 5012, 5015, 5016, 5018, 5019, 5020, 5021, 5022, 5025, 5026, 5028, 5029, 5050, 5051, 5052, 5055, 5056, 5058, 5059, 5060, 5061, 5062, 5065, 5066, 5068, 5069, 5080, 5081, 5082, 5085, 5086, 5088, 5089, 5090, 5091, 5092, 5095, 5096, 5098, 5099, 5100, 5101, 5102, 5105, 5106, 5108, 5109, 5110, 5111, 5112, 5115, 5116, 5118, 5119, 5120, 5121, 5122, 5125, 5126, 5128, 5129, 5150, 5151, 5152, 5155, 5156, 5158, 5159, 5160, 5161, 5162, 5165, 5166, 5168, 5169, 5180, 5181, 5182, 5185, 5186, 5188, 5189, 5190, 5191, 5192, 5195, 5196, 5198, 5199, 5200, 5201, 5202, 5205, 5206, 5208, 5209, 5210, 5211, 5212, 5215, 5216, 5218, 5219, 5220, 5221, 5222, 5225, 5226, 5228, 5229, 5250, 5251, 5252, 5255, 5256, 5258, 5259, 5260, 5261, 5262, 5265, 5266, 5268, 5269, 5280, 5281, 5282, 5285, 5286, 5288, 5289, 5290, 5291, 5292, 5295, 5296, 5298, 5299, 5500, 5501, 5502, 5505, 5506, 5508, 5509, 5510, 5511, 5512, 5515, 5516, 5518, 5519, 5520, 5521, 5522, 5525, 5526, 5528, 5529, 5550, 5551, 5552, 5555, 5556, 5558, 5559, 5560, 5561, 5562, 5565, 5566, 5568, 5569, 5580, 5581, 5582, 5585, 5586, 5588, 5589, 5590, 5591, 5592, 5595, 5596, 5598, 5599, 5600, 5601, 5602, 5605, 5606, 5608, 5609, 5610, 5611, 5612, 5615, 5616, 5618, 5619, 5620, 5621, 5622, 5625, 5626, 5628, 5629, 5650, 5651, 5652, 5655, 5656, 5658, 5659, 5660, 5661, 5662, 5665, 5666, 5668, 5669, 5680, 5681, 5682, 5685, 5686, 5688, 5689, 5690, 5691, 5692, 5695, 5696, 5698, 5699, 5800, 5801, 5802, 5805, 5806, 5808, 5809, 5810, 5811, 5812, 5815, 5816, 5818, 5819, 5820, 5821, 5822, 5825, 5826, 5828, 5829, 5850, 5851, 5852, 5855, 5856, 5858, 5859, 5860, 5861, 5862, 5865, 5866, 5868, 5869, 5880, 5881, 5882, 5885, 5886, 5888, 5889, 5890, 5891, 5892, 5895, 5896, 5898, 5899, 5900, 5901, 5902, 5905, 5906, 5908, 5909, 5910, 5911, 5912, 5915, 5916, 5918, 5919, 5920, 5921, 5922, 5925, 5926, 5928, 5929, 5950, 5951, 5952, 5955, 5956, 5958, 5959, 5960, 5961, 5962, 5965, 5966, 5968, 5969, 5980, 5981, 5982, 5985, 5986, 5988, 5989, 5990, 5991, 5992, 5995, 5996, 5998, 5999, 6000, 6001, 6002, 6005, 6006, 6008, 6009, 6010, 6011, 6012, 6015, 6016, 6018, 6019, 6020, 6021, 6022, 6025, 6026, 6028, 6029, 6050, 6051, 6052, 6055, 6056, 6058, 6059, 6060, 6061, 6062, 6065, 6066, 6068, 6069, 6080, 6081, 6082, 6085, 6086, 6088, 6089, 6090, 6091, 6092, 6095, 6096, 6098, 6099, 6100, 6101, 6102, 6105, 6106, 6108, 6109, 6110, 6111, 6112, 6115, 6116, 6118, 6119, 6120, 6121, 6122, 6125, 6126, 6128, 6129, 6150, 6151, 6152, 6155, 6156, 6158, 6159, 6160, 6161, 6162, 6165, 6166, 6168, 6169, 6180, 6181, 6182, 6185, 6186, 6188, 6189, 6190, 6191, 6192, 6195, 6196, 6198, 6199, 6200, 6201, 6202, 6205, 6206, 6208, 6209, 6210, 6211, 6212, 6215, 6216, 6218, 6219, 6220, 6221, 6222, 6225, 6226, 6228, 6229, 6250, 6251, 6252, 6255, 6256, 6258, 6259, 6260, 6261, 6262, 6265, 6266, 6268, 6269, 6280, 6281, 6282, 6285, 6286, 6288, 6289, 6290, 6291, 6292, 6295, 6296, 6298, 6299, 6500, 6501, 6502, 6505, 6506, 6508, 6509, 6510, 6511, 6512, 6515, 6516, 6518, 6519, 6520, 6521, 6522, 6525, 6526, 6528, 6529, 6550, 6551, 6552, 6555, 6556, 6558, 6559, 6560, 6561, 6562, 6565, 6566, 6568, 6569, 6580, 6581, 6582, 6585, 6586, 6588, 6589, 6590, 6591, 6592, 6595, 6596, 6598, 6599, 6600, 6601, 6602, 6605, 6606, 6608, 6609, 6610, 6611, 6612, 6615, 6616, 6618, 6619, 6620, 6621, 6622, 6625, 6626, 6628, 6629, 6650, 6651, 6652, 6655, 6656, 6658, 6659, 6660, 6661, 6662, 6665, 6666, 6668, 6669, 6680, 6681, 6682, 6685, 6686, 6688, 6689, 6690, 6691, 6692, 6695, 6696, 6698, 6699, 6800, 6801, 6802, 6805, 6806, 6808, 6809, 6810, 6811, 6812, 6815, 6816, 6818, 6819, 6820, 6821, 6822, 6825, 6826, 6828, 6829, 6850, 6851, 6852, 6855, 6856, 6858, 6859, 6860, 6861, 6862, 6865, 6866, 6868, 6869, 6880, 6881, 6882, 6885, 6886, 6888, 6889, 6890, 6891, 6892, 6895, 6896, 6898, 6899, 6900, 6901, 6902, 6905, 6906, 6908, 6909, 6910, 6911, 6912, 6915, 6916, 6918, 6919, 6920, 6921, 6922, 6925, 6926, 6928, 6929, 6950, 6951, 6952, 6955, 6956, 6958, 6959, 6960, 6961, 6962, 6965, 6966, 6968, 6969, 6980, 6981, 6982, 6985, 6986, 6988, 6989, 6990, 6991, 6992, 6995, 6996, 6998, 6999, 8002, 8005, 8006, 8009, 8012, 8015, 8016, 8019, 8020, 8021, 8022, 8025, 8026, 8028, 8029, 8050, 8051, 8052, 8055, 8056, 8058, 8059, 8060, 8061, 8062, 8065, 8066, 8068, 8069, 8082, 8085, 8086, 8089, 8090, 8091, 8092, 8095, 8096, 8098, 8099, 8102, 8105, 8106, 8109, 8112, 8115, 8116, 8119, 8120, 8121, 8122, 8125, 8126, 8128, 8129, 8150, 8151, 8152, 8155, 8156, 8158, 8159, 8160, 8161, 8162, 8165, 8166, 8168, 8169, 8182, 8185, 8186, 8189, 8190, 8191, 8192, 8195, 8196, 8198, 8199, 8200, 8201, 8202, 8205, 8206, 8208, 8209, 8210, 8211, 8212, 8215, 8216, 8218, 8219, 8220, 8221, 8222, 8225, 8226, 8228, 8229, 8250, 8251, 8252, 8255, 8256, 8258, 8259, 8260, 8261, 8262, 8265, 8266, 8268, 8269, 8280, 8281, 8282, 8285, 8286, 8288, 8289, 8290, 8291, 8292, 8295, 8296, 8298, 8299, 8500, 8501, 8502, 8505, 8506, 8508, 8509, 8510, 8511, 8512, 8515, 8516, 8518, 8519, 8520, 8521, 8522, 8525, 8526, 8528, 8529, 8550, 8551, 8552, 8555, 8556, 8558, 8559, 8560, 8561, 8562, 8565, 8566, 8568, 8569, 8580, 8581, 8582, 8585, 8586, 8588, 8589, 8590, 8591, 8592, 8595, 8596, 8598, 8599, 8600, 8601, 8602, 8605, 8606, 8608, 8609, 8610, 8611, 8612, 8615, 8616, 8618, 8619, 8620, 8621, 8622, 8625, 8626, 8628, 8629, 8650, 8651, 8652, 8655, 8656, 8658, 8659, 8660, 8661, 8662, 8665, 8666, 8668, 8669, 8680, 8681, 8682, 8685, 8686, 8688, 8689, 8690, 8691, 8692, 8695, 8696, 8698, 8699, 8802, 8805, 8806, 8809, 8812, 8815, 8816, 8819, 8820, 8821, 8822, 8825, 8826, 8828, 8829, 8850, 8851, 8852, 8855, 8856, 8858, 8859, 8860, 8861, 8862, 8865, 8866, 8868, 8869, 8882, 8885, 8886, 8889, 8890, 8891, 8892, 8895, 8896, 8898, 8899, 8900, 8901, 8902, 8905, 8906, 8908, 8909, 8910, 8911, 8912, 8915, 8916, 8918, 8919, 8920, 8921, 8922, 8925, 8926, 8928, 8929, 8950, 8951, 8952, 8955, 8956, 8958, 8959, 8960, 8961, 8962, 8965, 8966, 8968, 8969, 8980, 8981, 8982, 8985, 8986, 8988, 8989, 8990, 8991, 8992, 8995, 8996, 8998, 8999, 9000, 9001, 9002, 9005, 9006, 9008, 9009, 9010, 9011, 9012, 9015, 9016, 9018, 9019, 9020, 9021, 9022, 9025, 9026, 9028, 9029, 9050, 9051, 9052, 9055, 9056, 9058, 9059, 9060, 9061, 9062, 9065, 9066, 9068, 9069, 9080, 9081, 9082, 9085, 9086, 9088, 9089, 9090, 9091, 9092, 9095, 9096, 9098, 9099, 9100, 9101, 9102, 9105, 9106, 9108, 9109, 9110, 9111, 9112, 9115, 9116, 9118, 9119, 9120, 9121, 9122, 9125, 9126, 9128, 9129, 9150, 9151, 9152, 9155, 9156, 9158, 9159, 9160, 9161, 9162, 9165, 9166, 9168, 9169, 9180, 9181, 9182, 9185, 9186, 9188, 9189, 9190, 9191, 9192, 9195, 9196, 9198, 9199, 9200, 9201, 9202, 9205, 9206, 9208, 9209, 9210, 9211, 9212, 9215, 9216, 9218, 9219, 9220, 9221, 9222, 9225, 9226, 9228, 9229, 9250, 9251, 9252, 9255, 9256, 9258, 9259, 9260, 9261, 9262, 9265, 9266, 9268, 9269, 9280, 9281, 9282, 9285, 9286, 9288, 9289, 9290, 9291, 9292, 9295, 9296, 9298, 9299, 9500, 9501, 9502, 9505, 9506, 9508, 9509, 9510, 9511, 9512, 9515, 9516, 9518, 9519, 9520, 9521, 9522, 9525, 9526, 9528, 9529, 9550, 9551, 9552, 9555, 9556, 9558, 9559, 9560, 9561, 9562, 9565, 9566, 9568, 9569, 9580, 9581, 9582, 9585, 9586, 9588, 9589, 9590, 9591, 9592, 9595, 9596, 9598, 9599, 9600, 9601, 9602, 9605, 9606, 9608, 9609, 9610, 9611, 9612, 9615, 9616, 9618, 9619, 9620, 9621, 9622, 9625, 9626, 9628, 9629, 9650, 9651, 9652, 9655, 9656, 9658, 9659, 9660, 9661, 9662, 9665, 9666, 9668, 9669, 9680, 9681, 9682, 9685, 9686, 9688, 9689, 9690, 9691, 9692, 9695, 9696, 9698, 9699, 9800, 9801, 9802, 9805, 9806, 9808, 9809, 9810, 9811, 9812, 9815, 9816, 9818, 9819, 9820, 9821, 9822, 9825, 9826, 9828, 9829, 9850, 9851, 9852, 9855, 9856, 9858, 9859, 9860, 9861, 9862, 9865, 9866, 9868, 9869, 9880, 9881, 9882, 9885, 9886, 9888, 9889, 9890, 9891, 9892, 9895, 9896, 9898, 9899, 9900, 9901, 9902, 9905, 9906, 9908, 9909, 9910, 9911, 9912, 9915, 9916, 9918, 9919, 9920, 9921, 9922, 9925, 9926, 9928, 9929, 9950, 9951, 9952, 9955, 9956, 9958, 9959, 9960, 9961, 9962, 9965, 9966, 9968, 9969, 9980, 9981, 9982, 9985, 9986, 9988, 9989, 9990, 9991, 9992, 9995, 9996, 9998, 9999\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n    public int rotatedDigits(int N) {\\n        int n = Arrays.binarySearch( x, N );\\n        return n<0?-2-n:n;\\n    }\\n\\nprivate static final int[] x = { 0, 2, 5, 6, 9, 12, 15, 16, 19, 20, 21, 22, 25, 26, 28, 29, 50, 51, 52, 55, 56, 58, 59, 60, 61, 62, 65, 66, 68, 69, 82, 85, 86, 89, 90, 91, 92, 95, 96, 98, 99, 102, 105, 106, 109, 112, 115, 116, 119, 120, 121, 122, 125, 126, 128, 129, 150, 151, 152, 155, 156, 158, 159, 160, 161, 162, 165, 166, 168, 169, 182, 185, 186, 189, 190, 191, 192, 195, 196, 198, 199, 200, 201, 202, 205, 206, 208, 209, 210, 211, 212, 215, 216, 218, 219, 220, 221, 222, 225, 226, 228, 229, 250, 251, 252, 255, 256, 258, 259, 260, 261, 262, 265, 266, 268, 269, 280, 281, 282, 285, 286, 288, 289, 290, 291, 292, 295, 296, 298, 299, 500, 501, 502, 505, 506, 508, 509, 510, 511, 512, 515, 516, 518, 519, 520, 521, 522, 525, 526, 528, 529, 550, 551, 552, 555, 556, 558, 559, 560, 561, 562, 565, 566, 568, 569, 580, 581, 582, 585, 586, 588, 589, 590, 591, 592, 595, 596, 598, 599, 600, 601, 602, 605, 606, 608, 609, 610, 611, 612, 615, 616, 618, 619, 620, 621, 622, 625, 626, 628, 629, 650, 651, 652, 655, 656, 658, 659, 660, 661, 662, 665, 666, 668, 669, 680, 681, 682, 685, 686, 688, 689, 690, 691, 692, 695, 696, 698, 699, 802, 805, 806, 809, 812, 815, 816, 819, 820, 821, 822, 825, 826, 828, 829, 850, 851, 852, 855, 856, 858, 859, 860, 861, 862, 865, 866, 868, 869, 882, 885, 886, 889, 890, 891, 892, 895, 896, 898, 899, 900, 901, 902, 905, 906, 908, 909, 910, 911, 912, 915, 916, 918, 919, 920, 921, 922, 925, 926, 928, 929, 950, 951, 952, 955, 956, 958, 959, 960, 961, 962, 965, 966, 968, 969, 980, 981, 982, 985, 986, 988, 989, 990, 991, 992, 995, 996, 998, 999, 1002, 1005, 1006, 1009, 1012, 1015, 1016, 1019, 1020, 1021, 1022, 1025, 1026, 1028, 1029, 1050, 1051, 1052, 1055, 1056, 1058, 1059, 1060, 1061, 1062, 1065, 1066, 1068, 1069, 1082, 1085, 1086, 1089, 1090, 1091, 1092, 1095, 1096, 1098, 1099, 1102, 1105, 1106, 1109, 1112, 1115, 1116, 1119, 1120, 1121, 1122, 1125, 1126, 1128, 1129, 1150, 1151, 1152, 1155, 1156, 1158, 1159, 1160, 1161, 1162, 1165, 1166, 1168, 1169, 1182, 1185, 1186, 1189, 1190, 1191, 1192, 1195, 1196, 1198, 1199, 1200, 1201, 1202, 1205, 1206, 1208, 1209, 1210, 1211, 1212, 1215, 1216, 1218, 1219, 1220, 1221, 1222, 1225, 1226, 1228, 1229, 1250, 1251, 1252, 1255, 1256, 1258, 1259, 1260, 1261, 1262, 1265, 1266, 1268, 1269, 1280, 1281, 1282, 1285, 1286, 1288, 1289, 1290, 1291, 1292, 1295, 1296, 1298, 1299, 1500, 1501, 1502, 1505, 1506, 1508, 1509, 1510, 1511, 1512, 1515, 1516, 1518, 1519, 1520, 1521, 1522, 1525, 1526, 1528, 1529, 1550, 1551, 1552, 1555, 1556, 1558, 1559, 1560, 1561, 1562, 1565, 1566, 1568, 1569, 1580, 1581, 1582, 1585, 1586, 1588, 1589, 1590, 1591, 1592, 1595, 1596, 1598, 1599, 1600, 1601, 1602, 1605, 1606, 1608, 1609, 1610, 1611, 1612, 1615, 1616, 1618, 1619, 1620, 1621, 1622, 1625, 1626, 1628, 1629, 1650, 1651, 1652, 1655, 1656, 1658, 1659, 1660, 1661, 1662, 1665, 1666, 1668, 1669, 1680, 1681, 1682, 1685, 1686, 1688, 1689, 1690, 1691, 1692, 1695, 1696, 1698, 1699, 1802, 1805, 1806, 1809, 1812, 1815, 1816, 1819, 1820, 1821, 1822, 1825, 1826, 1828, 1829, 1850, 1851, 1852, 1855, 1856, 1858, 1859, 1860, 1861, 1862, 1865, 1866, 1868, 1869, 1882, 1885, 1886, 1889, 1890, 1891, 1892, 1895, 1896, 1898, 1899, 1900, 1901, 1902, 1905, 1906, 1908, 1909, 1910, 1911, 1912, 1915, 1916, 1918, 1919, 1920, 1921, 1922, 1925, 1926, 1928, 1929, 1950, 1951, 1952, 1955, 1956, 1958, 1959, 1960, 1961, 1962, 1965, 1966, 1968, 1969, 1980, 1981, 1982, 1985, 1986, 1988, 1989, 1990, 1991, 1992, 1995, 1996, 1998, 1999, 2000, 2001, 2002, 2005, 2006, 2008, 2009, 2010, 2011, 2012, 2015, 2016, 2018, 2019, 2020, 2021, 2022, 2025, 2026, 2028, 2029, 2050, 2051, 2052, 2055, 2056, 2058, 2059, 2060, 2061, 2062, 2065, 2066, 2068, 2069, 2080, 2081, 2082, 2085, 2086, 2088, 2089, 2090, 2091, 2092, 2095, 2096, 2098, 2099, 2100, 2101, 2102, 2105, 2106, 2108, 2109, 2110, 2111, 2112, 2115, 2116, 2118, 2119, 2120, 2121, 2122, 2125, 2126, 2128, 2129, 2150, 2151, 2152, 2155, 2156, 2158, 2159, 2160, 2161, 2162, 2165, 2166, 2168, 2169, 2180, 2181, 2182, 2185, 2186, 2188, 2189, 2190, 2191, 2192, 2195, 2196, 2198, 2199, 2200, 2201, 2202, 2205, 2206, 2208, 2209, 2210, 2211, 2212, 2215, 2216, 2218, 2219, 2220, 2221, 2222, 2225, 2226, 2228, 2229, 2250, 2251, 2252, 2255, 2256, 2258, 2259, 2260, 2261, 2262, 2265, 2266, 2268, 2269, 2280, 2281, 2282, 2285, 2286, 2288, 2289, 2290, 2291, 2292, 2295, 2296, 2298, 2299, 2500, 2501, 2502, 2505, 2506, 2508, 2509, 2510, 2511, 2512, 2515, 2516, 2518, 2519, 2520, 2521, 2522, 2525, 2526, 2528, 2529, 2550, 2551, 2552, 2555, 2556, 2558, 2559, 2560, 2561, 2562, 2565, 2566, 2568, 2569, 2580, 2581, 2582, 2585, 2586, 2588, 2589, 2590, 2591, 2592, 2595, 2596, 2598, 2599, 2600, 2601, 2602, 2605, 2606, 2608, 2609, 2610, 2611, 2612, 2615, 2616, 2618, 2619, 2620, 2621, 2622, 2625, 2626, 2628, 2629, 2650, 2651, 2652, 2655, 2656, 2658, 2659, 2660, 2661, 2662, 2665, 2666, 2668, 2669, 2680, 2681, 2682, 2685, 2686, 2688, 2689, 2690, 2691, 2692, 2695, 2696, 2698, 2699, 2800, 2801, 2802, 2805, 2806, 2808, 2809, 2810, 2811, 2812, 2815, 2816, 2818, 2819, 2820, 2821, 2822, 2825, 2826, 2828, 2829, 2850, 2851, 2852, 2855, 2856, 2858, 2859, 2860, 2861, 2862, 2865, 2866, 2868, 2869, 2880, 2881, 2882, 2885, 2886, 2888, 2889, 2890, 2891, 2892, 2895, 2896, 2898, 2899, 2900, 2901, 2902, 2905, 2906, 2908, 2909, 2910, 2911, 2912, 2915, 2916, 2918, 2919, 2920, 2921, 2922, 2925, 2926, 2928, 2929, 2950, 2951, 2952, 2955, 2956, 2958, 2959, 2960, 2961, 2962, 2965, 2966, 2968, 2969, 2980, 2981, 2982, 2985, 2986, 2988, 2989, 2990, 2991, 2992, 2995, 2996, 2998, 2999, 5000, 5001, 5002, 5005, 5006, 5008, 5009, 5010, 5011, 5012, 5015, 5016, 5018, 5019, 5020, 5021, 5022, 5025, 5026, 5028, 5029, 5050, 5051, 5052, 5055, 5056, 5058, 5059, 5060, 5061, 5062, 5065, 5066, 5068, 5069, 5080, 5081, 5082, 5085, 5086, 5088, 5089, 5090, 5091, 5092, 5095, 5096, 5098, 5099, 5100, 5101, 5102, 5105, 5106, 5108, 5109, 5110, 5111, 5112, 5115, 5116, 5118, 5119, 5120, 5121, 5122, 5125, 5126, 5128, 5129, 5150, 5151, 5152, 5155, 5156, 5158, 5159, 5160, 5161, 5162, 5165, 5166, 5168, 5169, 5180, 5181, 5182, 5185, 5186, 5188, 5189, 5190, 5191, 5192, 5195, 5196, 5198, 5199, 5200, 5201, 5202, 5205, 5206, 5208, 5209, 5210, 5211, 5212, 5215, 5216, 5218, 5219, 5220, 5221, 5222, 5225, 5226, 5228, 5229, 5250, 5251, 5252, 5255, 5256, 5258, 5259, 5260, 5261, 5262, 5265, 5266, 5268, 5269, 5280, 5281, 5282, 5285, 5286, 5288, 5289, 5290, 5291, 5292, 5295, 5296, 5298, 5299, 5500, 5501, 5502, 5505, 5506, 5508, 5509, 5510, 5511, 5512, 5515, 5516, 5518, 5519, 5520, 5521, 5522, 5525, 5526, 5528, 5529, 5550, 5551, 5552, 5555, 5556, 5558, 5559, 5560, 5561, 5562, 5565, 5566, 5568, 5569, 5580, 5581, 5582, 5585, 5586, 5588, 5589, 5590, 5591, 5592, 5595, 5596, 5598, 5599, 5600, 5601, 5602, 5605, 5606, 5608, 5609, 5610, 5611, 5612, 5615, 5616, 5618, 5619, 5620, 5621, 5622, 5625, 5626, 5628, 5629, 5650, 5651, 5652, 5655, 5656, 5658, 5659, 5660, 5661, 5662, 5665, 5666, 5668, 5669, 5680, 5681, 5682, 5685, 5686, 5688, 5689, 5690, 5691, 5692, 5695, 5696, 5698, 5699, 5800, 5801, 5802, 5805, 5806, 5808, 5809, 5810, 5811, 5812, 5815, 5816, 5818, 5819, 5820, 5821, 5822, 5825, 5826, 5828, 5829, 5850, 5851, 5852, 5855, 5856, 5858, 5859, 5860, 5861, 5862, 5865, 5866, 5868, 5869, 5880, 5881, 5882, 5885, 5886, 5888, 5889, 5890, 5891, 5892, 5895, 5896, 5898, 5899, 5900, 5901, 5902, 5905, 5906, 5908, 5909, 5910, 5911, 5912, 5915, 5916, 5918, 5919, 5920, 5921, 5922, 5925, 5926, 5928, 5929, 5950, 5951, 5952, 5955, 5956, 5958, 5959, 5960, 5961, 5962, 5965, 5966, 5968, 5969, 5980, 5981, 5982, 5985, 5986, 5988, 5989, 5990, 5991, 5992, 5995, 5996, 5998, 5999, 6000, 6001, 6002, 6005, 6006, 6008, 6009, 6010, 6011, 6012, 6015, 6016, 6018, 6019, 6020, 6021, 6022, 6025, 6026, 6028, 6029, 6050, 6051, 6052, 6055, 6056, 6058, 6059, 6060, 6061, 6062, 6065, 6066, 6068, 6069, 6080, 6081, 6082, 6085, 6086, 6088, 6089, 6090, 6091, 6092, 6095, 6096, 6098, 6099, 6100, 6101, 6102, 6105, 6106, 6108, 6109, 6110, 6111, 6112, 6115, 6116, 6118, 6119, 6120, 6121, 6122, 6125, 6126, 6128, 6129, 6150, 6151, 6152, 6155, 6156, 6158, 6159, 6160, 6161, 6162, 6165, 6166, 6168, 6169, 6180, 6181, 6182, 6185, 6186, 6188, 6189, 6190, 6191, 6192, 6195, 6196, 6198, 6199, 6200, 6201, 6202, 6205, 6206, 6208, 6209, 6210, 6211, 6212, 6215, 6216, 6218, 6219, 6220, 6221, 6222, 6225, 6226, 6228, 6229, 6250, 6251, 6252, 6255, 6256, 6258, 6259, 6260, 6261, 6262, 6265, 6266, 6268, 6269, 6280, 6281, 6282, 6285, 6286, 6288, 6289, 6290, 6291, 6292, 6295, 6296, 6298, 6299, 6500, 6501, 6502, 6505, 6506, 6508, 6509, 6510, 6511, 6512, 6515, 6516, 6518, 6519, 6520, 6521, 6522, 6525, 6526, 6528, 6529, 6550, 6551, 6552, 6555, 6556, 6558, 6559, 6560, 6561, 6562, 6565, 6566, 6568, 6569, 6580, 6581, 6582, 6585, 6586, 6588, 6589, 6590, 6591, 6592, 6595, 6596, 6598, 6599, 6600, 6601, 6602, 6605, 6606, 6608, 6609, 6610, 6611, 6612, 6615, 6616, 6618, 6619, 6620, 6621, 6622, 6625, 6626, 6628, 6629, 6650, 6651, 6652, 6655, 6656, 6658, 6659, 6660, 6661, 6662, 6665, 6666, 6668, 6669, 6680, 6681, 6682, 6685, 6686, 6688, 6689, 6690, 6691, 6692, 6695, 6696, 6698, 6699, 6800, 6801, 6802, 6805, 6806, 6808, 6809, 6810, 6811, 6812, 6815, 6816, 6818, 6819, 6820, 6821, 6822, 6825, 6826, 6828, 6829, 6850, 6851, 6852, 6855, 6856, 6858, 6859, 6860, 6861, 6862, 6865, 6866, 6868, 6869, 6880, 6881, 6882, 6885, 6886, 6888, 6889, 6890, 6891, 6892, 6895, 6896, 6898, 6899, 6900, 6901, 6902, 6905, 6906, 6908, 6909, 6910, 6911, 6912, 6915, 6916, 6918, 6919, 6920, 6921, 6922, 6925, 6926, 6928, 6929, 6950, 6951, 6952, 6955, 6956, 6958, 6959, 6960, 6961, 6962, 6965, 6966, 6968, 6969, 6980, 6981, 6982, 6985, 6986, 6988, 6989, 6990, 6991, 6992, 6995, 6996, 6998, 6999, 8002, 8005, 8006, 8009, 8012, 8015, 8016, 8019, 8020, 8021, 8022, 8025, 8026, 8028, 8029, 8050, 8051, 8052, 8055, 8056, 8058, 8059, 8060, 8061, 8062, 8065, 8066, 8068, 8069, 8082, 8085, 8086, 8089, 8090, 8091, 8092, 8095, 8096, 8098, 8099, 8102, 8105, 8106, 8109, 8112, 8115, 8116, 8119, 8120, 8121, 8122, 8125, 8126, 8128, 8129, 8150, 8151, 8152, 8155, 8156, 8158, 8159, 8160, 8161, 8162, 8165, 8166, 8168, 8169, 8182, 8185, 8186, 8189, 8190, 8191, 8192, 8195, 8196, 8198, 8199, 8200, 8201, 8202, 8205, 8206, 8208, 8209, 8210, 8211, 8212, 8215, 8216, 8218, 8219, 8220, 8221, 8222, 8225, 8226, 8228, 8229, 8250, 8251, 8252, 8255, 8256, 8258, 8259, 8260, 8261, 8262, 8265, 8266, 8268, 8269, 8280, 8281, 8282, 8285, 8286, 8288, 8289, 8290, 8291, 8292, 8295, 8296, 8298, 8299, 8500, 8501, 8502, 8505, 8506, 8508, 8509, 8510, 8511, 8512, 8515, 8516, 8518, 8519, 8520, 8521, 8522, 8525, 8526, 8528, 8529, 8550, 8551, 8552, 8555, 8556, 8558, 8559, 8560, 8561, 8562, 8565, 8566, 8568, 8569, 8580, 8581, 8582, 8585, 8586, 8588, 8589, 8590, 8591, 8592, 8595, 8596, 8598, 8599, 8600, 8601, 8602, 8605, 8606, 8608, 8609, 8610, 8611, 8612, 8615, 8616, 8618, 8619, 8620, 8621, 8622, 8625, 8626, 8628, 8629, 8650, 8651, 8652, 8655, 8656, 8658, 8659, 8660, 8661, 8662, 8665, 8666, 8668, 8669, 8680, 8681, 8682, 8685, 8686, 8688, 8689, 8690, 8691, 8692, 8695, 8696, 8698, 8699, 8802, 8805, 8806, 8809, 8812, 8815, 8816, 8819, 8820, 8821, 8822, 8825, 8826, 8828, 8829, 8850, 8851, 8852, 8855, 8856, 8858, 8859, 8860, 8861, 8862, 8865, 8866, 8868, 8869, 8882, 8885, 8886, 8889, 8890, 8891, 8892, 8895, 8896, 8898, 8899, 8900, 8901, 8902, 8905, 8906, 8908, 8909, 8910, 8911, 8912, 8915, 8916, 8918, 8919, 8920, 8921, 8922, 8925, 8926, 8928, 8929, 8950, 8951, 8952, 8955, 8956, 8958, 8959, 8960, 8961, 8962, 8965, 8966, 8968, 8969, 8980, 8981, 8982, 8985, 8986, 8988, 8989, 8990, 8991, 8992, 8995, 8996, 8998, 8999, 9000, 9001, 9002, 9005, 9006, 9008, 9009, 9010, 9011, 9012, 9015, 9016, 9018, 9019, 9020, 9021, 9022, 9025, 9026, 9028, 9029, 9050, 9051, 9052, 9055, 9056, 9058, 9059, 9060, 9061, 9062, 9065, 9066, 9068, 9069, 9080, 9081, 9082, 9085, 9086, 9088, 9089, 9090, 9091, 9092, 9095, 9096, 9098, 9099, 9100, 9101, 9102, 9105, 9106, 9108, 9109, 9110, 9111, 9112, 9115, 9116, 9118, 9119, 9120, 9121, 9122, 9125, 9126, 9128, 9129, 9150, 9151, 9152, 9155, 9156, 9158, 9159, 9160, 9161, 9162, 9165, 9166, 9168, 9169, 9180, 9181, 9182, 9185, 9186, 9188, 9189, 9190, 9191, 9192, 9195, 9196, 9198, 9199, 9200, 9201, 9202, 9205, 9206, 9208, 9209, 9210, 9211, 9212, 9215, 9216, 9218, 9219, 9220, 9221, 9222, 9225, 9226, 9228, 9229, 9250, 9251, 9252, 9255, 9256, 9258, 9259, 9260, 9261, 9262, 9265, 9266, 9268, 9269, 9280, 9281, 9282, 9285, 9286, 9288, 9289, 9290, 9291, 9292, 9295, 9296, 9298, 9299, 9500, 9501, 9502, 9505, 9506, 9508, 9509, 9510, 9511, 9512, 9515, 9516, 9518, 9519, 9520, 9521, 9522, 9525, 9526, 9528, 9529, 9550, 9551, 9552, 9555, 9556, 9558, 9559, 9560, 9561, 9562, 9565, 9566, 9568, 9569, 9580, 9581, 9582, 9585, 9586, 9588, 9589, 9590, 9591, 9592, 9595, 9596, 9598, 9599, 9600, 9601, 9602, 9605, 9606, 9608, 9609, 9610, 9611, 9612, 9615, 9616, 9618, 9619, 9620, 9621, 9622, 9625, 9626, 9628, 9629, 9650, 9651, 9652, 9655, 9656, 9658, 9659, 9660, 9661, 9662, 9665, 9666, 9668, 9669, 9680, 9681, 9682, 9685, 9686, 9688, 9689, 9690, 9691, 9692, 9695, 9696, 9698, 9699, 9800, 9801, 9802, 9805, 9806, 9808, 9809, 9810, 9811, 9812, 9815, 9816, 9818, 9819, 9820, 9821, 9822, 9825, 9826, 9828, 9829, 9850, 9851, 9852, 9855, 9856, 9858, 9859, 9860, 9861, 9862, 9865, 9866, 9868, 9869, 9880, 9881, 9882, 9885, 9886, 9888, 9889, 9890, 9891, 9892, 9895, 9896, 9898, 9899, 9900, 9901, 9902, 9905, 9906, 9908, 9909, 9910, 9911, 9912, 9915, 9916, 9918, 9919, 9920, 9921, 9922, 9925, 9926, 9928, 9929, 9950, 9951, 9952, 9955, 9956, 9958, 9959, 9960, 9961, 9962, 9965, 9966, 9968, 9969, 9980, 9981, 9982, 9985, 9986, 9988, 9989, 9990, 9991, 9992, 9995, 9996, 9998, 9999\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 173248,
                "title": "c-write-an-elegant-solution-using-hashset-issubsetof-api",
                "content": "Sept. 22, 2018\\nIt is an easy level string algorithm. I studied one of most popular post in the discuss and wrote the one using the same idea. \\n\\n```\\npublic class Solution {\\n    /// <summary>\\n        /// convert integer to string\\n        /// go over each string to determine if it is a good number\\n        /// 0, 1, 8 -> rotate to itself\\n        /// 2<->5\\n        /// 6<->9\\n        /// 3, 4, 7, 8 does not apply rotation\\n        /// </summary>\\n        /// <param name=\"N\"></param>\\n        /// <returns></returns>\\n    public int RotatedDigits(int N)\\n        {\\n            if (N <= 0)\\n                return -1;\\n\\n            int goodNumberCount = 0;           \\n            \\n            var rotateToItself = new HashSet<char>(\"018\".ToCharArray());\\n            var rotable = new HashSet<char>(\"2569018\".ToCharArray());\\n\\n            for(int i = 1; i <= N; i++)\\n            {     \\n                var digits = new HashSet<char>(i.ToString().ToCharArray());\\n                if (digits.IsSubsetOf(rotable) && !digits.IsSubsetOf(rotateToItself))\\n                    goodNumberCount++;                                 \\n            }\\n\\n            return goodNumberCount;\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    /// <summary>\\n        /// convert integer to string\\n        /// go over each string to determine if it is a good number\\n        /// 0, 1, 8 -> rotate to itself\\n        /// 2<->5\\n        /// 6<->9\\n        /// 3, 4, 7, 8 does not apply rotation\\n        /// </summary>\\n        /// <param name=\"N\"></param>\\n        /// <returns></returns>\\n    public int RotatedDigits(int N)\\n        {\\n            if (N <= 0)\\n                return -1;\\n\\n            int goodNumberCount = 0;           \\n            \\n            var rotateToItself = new HashSet<char>(\"018\".ToCharArray());\\n            var rotable = new HashSet<char>(\"2569018\".ToCharArray());\\n\\n            for(int i = 1; i <= N; i++)\\n            {     \\n                var digits = new HashSet<char>(i.ToString().ToCharArray());\\n                if (digits.IsSubsetOf(rotable) && !digits.IsSubsetOf(rotateToItself))\\n                    goodNumberCount++;                                 \\n            }\\n\\n            return goodNumberCount;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 159921,
                "title": "python-simple-solution-easy-to-understand",
                "content": "```\\nclass Solution(object):\\n    def rotatedDigits(self, N):\\n        \"\"\"\\n        :type N: int\\n        :rtype: int\\n        \"\"\"\\n        counter = 0\\n        \\n        # digits that are valid after rotation\\n        valid_digits = set([0,1,2,5,6,8,9])\\n        # digits that are different after rotation\\n        flip_different = set([2,5,6,9])\\n        \\n        # iterate thru numbers\\n        for num in range(0,N+1):\\n            digits = [int(i) for i in str(num)]\\n            # to have a good number: 1) all digits have to be valid, 2) at least one digit is differnt after rotation\\n            if (set(digits).issubset(valid_digits) and set(digits).intersection(flip_different)):\\n                counter += 1\\n        \\n        return counter\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def rotatedDigits(self, N):\\n        \"\"\"\\n        :type N: int\\n        :rtype: int\\n        \"\"\"\\n        counter = 0\\n        \\n        # digits that are valid after rotation\\n        valid_digits = set([0,1,2,5,6,8,9])\\n        # digits that are different after rotation\\n        flip_different = set([2,5,6,9])\\n        \\n        # iterate thru numbers\\n        for num in range(0,N+1):\\n            digits = [int(i) for i in str(num)]\\n            # to have a good number: 1) all digits have to be valid, 2) at least one digit is differnt after rotation\\n            if (set(digits).issubset(valid_digits) and set(digits).intersection(flip_different)):\\n                counter += 1\\n        \\n        return counter\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4005982,
                "title": "simple-string-based-beginners-approach",
                "content": "# Approach\\nWe go through all the integer values from [1,n] range and then check if rotated string satifies the condition\\n\\nif it does then increment the count and simply return the count value\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n*log(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string rotate(string s){\\n        string temp=\"\";\\n        bool check=true;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'0\\' || s[i]==\\'1\\' || s[i]==\\'8\\'){\\n                temp+=s[i];\\n            }\\n            else if(s[i]==\\'2\\'){\\n                temp+=\\'5\\';\\n            }\\n            else if(s[i]==\\'5\\'){\\n                temp+=\\'2\\';\\n            }\\n            else if(s[i]==\\'6\\'){\\n                temp+=\\'9\\';\\n            }\\n            else if(s[i]==\\'9\\'){\\n                temp+=\\'6\\';\\n            }\\n            else{\\n                check=false;\\n                break;\\n            }\\n        }\\n        if(check==false){\\n            return \"-1\";\\n        }\\n        return temp;\\n    }\\n    int rotatedDigits(int n) {\\n        int count=0;\\n        for(int i=1;i<=n;i++){\\n            string s=to_string(i);\\n            string check=rotate(s);\\n            if(s!=check && check!=\"-1\"){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string rotate(string s){\\n        string temp=\"\";\\n        bool check=true;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'0\\' || s[i]==\\'1\\' || s[i]==\\'8\\'){\\n                temp+=s[i];\\n            }\\n            else if(s[i]==\\'2\\'){\\n                temp+=\\'5\\';\\n            }\\n            else if(s[i]==\\'5\\'){\\n                temp+=\\'2\\';\\n            }\\n            else if(s[i]==\\'6\\'){\\n                temp+=\\'9\\';\\n            }\\n            else if(s[i]==\\'9\\'){\\n                temp+=\\'6\\';\\n            }\\n            else{\\n                check=false;\\n                break;\\n            }\\n        }\\n        if(check==false){\\n            return \"-1\";\\n        }\\n        return temp;\\n    }\\n    int rotatedDigits(int n) {\\n        int count=0;\\n        for(int i=1;i<=n;i++){\\n            string s=to_string(i);\\n            string check=rotate(s);\\n            if(s!=check && check!=\"-1\"){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3769647,
                "title": "java-easy-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n     public int rotatedDigits(int n) {\\n        int count = 0;\\n\\n        for(int i = 1; i <= n; i++){\\n            String temp = String.valueOf(i) ;\\n            if(temp.contains(\"2\") || temp.contains(\"5\") || temp.contains(\"6\") || temp.contains(\"9\")) {\\n                if(!temp.contains(\"3\") && !temp.contains(\"7\") && !temp.contains(\"4\")){\\n                    count++;\\n                }\\n            }\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n     public int rotatedDigits(int n) {\\n        int count = 0;\\n\\n        for(int i = 1; i <= n; i++){\\n            String temp = String.valueOf(i) ;\\n            if(temp.contains(\"2\") || temp.contains(\"5\") || temp.contains(\"6\") || temp.contains(\"9\")) {\\n                if(!temp.contains(\"3\") && !temp.contains(\"7\") && !temp.contains(\"4\")){\\n                    count++;\\n                }\\n            }\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3669936,
                "title": "typical-digit-dp",
                "content": "If you know digit dp then this is trivial\\n\\nIf you contain a 3 or 4 or 7 then this number cannot be good\\n\\nIf you contain 2 or 5 or 6 or 9 then this number is automatically good provided that it doesnt contain any 3 or 4 or 7\\n\\n0,1,8 do nothing. \\n\\nStore pareamter good, good = True means that the number is going to be good\\n\\n# Code\\n```\\nclass Solution:\\n    def rotatedDigits(self, n: int) -> int:\\n        \\n        n = str(n)\\n        def helper(strict, pointer, good):\\n            if pointer == len(n) and good:\\n                return 1\\n            if pointer == len(n) and not good: return 0\\n            currentBound = int(n[pointer])\\n            s = 0\\n            if strict:\\n                for i in [0,1,8]:\\n                    if i < currentBound: s+= helper(False, pointer + 1, good)\\n                    elif i == currentBound: s += helper(True, pointer + 1, good)\\n                    else: pass\\n                for i in [2,5,6,9]:\\n                    if i < currentBound: s+= helper(False, pointer + 1, True)\\n                    elif i == currentBound: s += helper(True, pointer + 1, True)\\n                    else: pass\\n            else:\\n                for i in [0,1,8]:\\n                    s += helper(False, pointer + 1, good)\\n                for i in [2,5,6,9]:\\n                    s += helper(False, pointer + 1, True)            \\n            return s\\n\\n        return helper(True, 0, False)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rotatedDigits(self, n: int) -> int:\\n        \\n        n = str(n)\\n        def helper(strict, pointer, good):\\n            if pointer == len(n) and good:\\n                return 1\\n            if pointer == len(n) and not good: return 0\\n            currentBound = int(n[pointer])\\n            s = 0\\n            if strict:\\n                for i in [0,1,8]:\\n                    if i < currentBound: s+= helper(False, pointer + 1, good)\\n                    elif i == currentBound: s += helper(True, pointer + 1, good)\\n                    else: pass\\n                for i in [2,5,6,9]:\\n                    if i < currentBound: s+= helper(False, pointer + 1, True)\\n                    elif i == currentBound: s += helper(True, pointer + 1, True)\\n                    else: pass\\n            else:\\n                for i in [0,1,8]:\\n                    s += helper(False, pointer + 1, good)\\n                for i in [2,5,6,9]:\\n                    s += helper(False, pointer + 1, True)            \\n            return s\\n\\n        return helper(True, 0, False)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3136317,
                "title": "very-easy-to-understand-c-solution",
                "content": "# Code\\n```\\nclass Solution \\n{\\npublic:\\n    int rotatedDigits(int n) \\n    {\\n        map<int,int> m;\\n        m[0]=0; m[1]=1; m[8]=8; m[6]=9; m[9]=6; m[2]=5; m[5]=2;\\n        int count=0;\\n        for(int x=1; x<=n; x++)\\n        {\\n            string s=to_string(x);\\n            auto i1=s.find(\"2\"), i2=s.find(\"5\"), i3=s.find(\"6\"), i4=s.find(\"9\"), i5=s.find(\"3\"), i6=s.find(\"4\"), i7=s.find(\"7\");\\n            if((i1!=string::npos || i2!=string::npos || i3!=string::npos || i4!=string::npos) && (i5==string::npos && i6==string::npos && i7==string::npos)) count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int rotatedDigits(int n) \\n    {\\n        map<int,int> m;\\n        m[0]=0; m[1]=1; m[8]=8; m[6]=9; m[9]=6; m[2]=5; m[5]=2;\\n        int count=0;\\n        for(int x=1; x<=n; x++)\\n        {\\n            string s=to_string(x);\\n            auto i1=s.find(\"2\"), i2=s.find(\"5\"), i3=s.find(\"6\"), i4=s.find(\"9\"), i5=s.find(\"3\"), i6=s.find(\"4\"), i7=s.find(\"7\");\\n            if((i1!=string::npos || i2!=string::npos || i3!=string::npos || i4!=string::npos) && (i5==string::npos && i6==string::npos && i7==string::npos)) count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2097809,
                "title": "brute-force-method-java",
                "content": "class Solution {\\n    public int rotatedDigits(int n) {\\n        int count=0;\\n        for(int i=2;i<=n;i++){\\n            int temp=i;\\n            int flag=0;\\n            \\n            while(temp!=0){\\n                int d=temp%10;\\n                \\n                if(d==3 || d==4 || d==7){\\n                    break;\\n                }else if(d==2||d==5||d==6||d==9){\\n                    flag++;\\n                }\\n                \\n                \\n                temp=temp/10;\\n            }\\n            if(temp==0 && flag>0){\\n                count++;\\n            }\\n            \\n        }\\n        return count;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int rotatedDigits(int n) {\\n        int count=0;\\n        for(int i=2;i<=n;i++){\\n            int temp=i;\\n            int flag=0;\\n            \\n            while(temp!=0){\\n                int d=temp%10;\\n                \\n                if(d==3 || d==4 || d==7){\\n                    break;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2063497,
                "title": "python-straightforward-solution",
                "content": "```\\nclass Solution:\\n    def rotatedDigits(self, n: int) -> int:\\n        ans = 0\\n        for i in range(1, n+1):\\n            p = \\'\\'\\n            if \\'3\\' in str(i) or \\'4\\' in str(i) or \\'7\\' in str(i):\\n                continue\\n            for j in str(i):\\n                if j == \\'0\\':\\n                    p += \\'0\\'\\n                elif j == \\'1\\':\\n                    p += \\'1\\'\\n                elif j == \\'8\\':\\n                    p += \\'8\\'\\n                \\n                elif j == \\'2\\':\\n                    p += \\'5\\'\\n                elif j == \\'5\\':\\n                    p += \\'2\\'\\n                \\n                elif j == \\'6\\':\\n                    p += \\'9\\'\\n                elif j == \\'9\\':\\n                    p += \\'6\\'\\n                    \\n            if p != str(i):\\n                ans += 1\\n        \\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rotatedDigits(self, n: int) -> int:\\n        ans = 0\\n        for i in range(1, n+1):\\n            p = \\'\\'\\n            if \\'3\\' in str(i) or \\'4\\' in str(i) or \\'7\\' in str(i):\\n                continue\\n            for j in str(i):\\n                if j == \\'0\\':\\n                    p += \\'0\\'\\n                elif j == \\'1\\':\\n                    p += \\'1\\'\\n                elif j == \\'8\\':\\n                    p += \\'8\\'\\n                \\n                elif j == \\'2\\':\\n                    p += \\'5\\'\\n                elif j == \\'5\\':\\n                    p += \\'2\\'\\n                \\n                elif j == \\'6\\':\\n                    p += \\'9\\'\\n                elif j == \\'9\\':\\n                    p += \\'6\\'\\n                    \\n            if p != str(i):\\n                ans += 1\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2032388,
                "title": "easy-python-again",
                "content": "```\\nclass Solution:\\n    def rotatedDigits(self, n: int) -> int:\\n        res = 0\\n        for i in range(n+1):\\n            tmp = set(str(i))\\n            if (tmp - {\\'1\\', \\'0\\', \\'8\\'}) and not tmp & {\\'3\\', \\'7\\', \\'4\\'}:\\n                res += 1\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def rotatedDigits(self, n: int) -> int:\\n        res = 0\\n        for i in range(n+1):\\n            tmp = set(str(i))\\n            if (tmp - {\\'1\\', \\'0\\', \\'8\\'}) and not tmp & {\\'3\\', \\'7\\', \\'4\\'}:\\n                res += 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1678352,
                "title": "c-n-log10-n-100-fast",
                "content": "// idea is simple \\n// just go through each numbers digit and as soon as we encounter a digit \\n// that\\'s rotation is not valid according to the conditions that is given in the\\n// problem we simply say that, that number is not the answer and we move ahead\\n// to next number\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int rotatedDigits(int n) {\\n           int ans = 0;\\n        \\n          for(int i = 1; i<=n; i++){\\n               bool flag = false;\\n               int num = i;\\n               while(num > 0){\\n                   int dig = num % 10;\\n                   if( dig == 3 || dig == 4 || dig == 7)\\n                   { flag = false; break;}\\n                   \\n                   if(dig == 2 || dig == 5 || dig == 6 || dig == 9)\\n                       flag = true;\\n                   num /= 10;\\n               }\\n              \\n              if(flag) ans++;\\n          }\\n            return ans;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int rotatedDigits(int n) {\\n           int ans = 0;\\n        \\n          for(int i = 1; i<=n; i++){\\n               bool flag = false;\\n               int num = i;\\n               while(num > 0){\\n                   int dig = num % 10;\\n                   if( dig == 3 || dig == 4 || dig == 7)\\n                   { flag = false; break;}",
                "codeTag": "Java"
            },
            {
                "id": 1586850,
                "title": "c-simple-o-nlogn-sol-well-commented-for-beginners",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    bool check(int n){\\n        int arr[10];\\n        memset(arr,0, sizeof(arr));\\n        \\n        //Extract all digits present in n\\n        while(n){\\n            arr[n%10] = 1;\\n            n /= 10;\\n        }\\n        \\n        //If number contains digit 3,4 or 7 then it will not give a valid number after rotation\\n        for(int i=0; i<10; i++){\\n            if(arr[i] && (i==3 || i == 4 || i == 7))\\n                return false;\\n        }\\n        \\n        //If number doesn\\'t have 3,4 or 7 mean all other digits are rotatable\\n        //If number have digits other then 0,1 & 8 then it will always give different number after rotation\\n        for(int i=0; i<10; i++){\\n            if(arr[i] && i != 0 && i!=1 && i!=8 )\\n                return true;\\n        }\\n        //If digits are just 0,1 or 8 then number will be the same after rotation, thatswhy return false\\n        return false;\\n    }\\n    \\n    int rotatedDigits(int n) {\\n        int c=0;\\n        \\n        //Check for each good number from 2 to n\\n        for(int i=2; i<=n; i++){\\n            if(check(i))\\n                c++;\\n        }\\n        \\n        return c;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    bool check(int n){\\n        int arr[10];\\n        memset(arr,0, sizeof(arr));\\n        \\n        //Extract all digits present in n\\n        while(n){\\n            arr[n%10] = 1;\\n            n /= 10;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1498691,
                "title": "python3-accepted-solution",
                "content": "```\\nclass Solution:\\n    def rotatedDigits(self, n: int) -> int:\\n        count=0\\n        li = []\\n        for i in range(1,n+1):\\n            if(str(i).count(\"3\")>0 or str(i).count(\"4\")>0 or str(i).count(\"7\")>0):\\n                continue\\n            elif(str(i).count(\"0\") + str(i).count(\"1\") + str(i).count(\"8\") == len(str(i))):\\n                continue\\n            else:\\n                count+=1\\n        return count\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def rotatedDigits(self, n: int) -> int:\\n        count=0\\n        li = []\\n        for i in range(1,n+1):\\n            if(str(i).count(\"3\")>0 or str(i).count(\"4\")>0 or str(i).count(\"7\")>0):\\n                continue\\n            elif(str(i).count(\"0\") + str(i).count(\"1\") + str(i).count(\"8\") == len(str(i))):\\n                continue\\n            else:\\n                count+=1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1472757,
                "title": "c-0ms-100-faster-digit-dp-top-down-method",
                "content": "step 1: convert integer to string\\nstep 2: for each character, check \"are we under tight contraint\" :\\n\\t\\t\\ttight contraint means have we reached its max value ie its upper bound\\n\\t\\t\\tif we are under tight contraint then set ub = s[i] (s[i] is max value it can go, if it goes greater than s[i] then it will not be in range [1, n])\\n\\t\\t\\telse set ub = 9\\nstep 3: if we are geting j == 3 or j == 4 or j ==7, we simply continue because they are not good.\\nstep 4: when i am calling solve(), i am passing  \" p | rot[j] \":\\n\\t\\t\\tif that is true or 1, then we have already found good number and we have got 1 good number so return 1\\n\\t\\t\\telse\\n\\t\\t\\t\\treturn 0;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t\\n\\tstring s;\\n    unordered_map <int, bool> rot;\\n    int dp[10001][2][2];\\n    int solve(int i, int t, int p) {\\n        \\n        if (i == s.length()) {\\n            if (p)\\n                return 1;\\n            else \\n                return 0;\\n        }\\n        \\n        if (dp[i][t][p] != -1)\\n            return dp[i][t][p];\\n        \\n        int ub = t ? s[i]-\\'0\\' : 9;\\n        int ans = 0;\\n        for (int j = 0; j <= ub; j++) {\\n            if (j == 3 || j == 4 || j == 7)\\n                continue;\\n            \\n            ans += solve(i+1, t&(j==ub), p|rot[j]);\\n        }\\n        \\n        return dp[i][t][p] = ans;\\n    }\\n    int rotatedDigits(int n) {\\n        memset(dp, -1, sizeof(dp));\\n        s = to_string(n);\\n        rot[2] = true;\\n        rot[5] = true;\\n        rot[6] = true;\\n        rot[9] = true;\\n        return solve(0,1,0);\\n    }",
                "solutionTags": [],
                "code": "step 1: convert integer to string\\nstep 2: for each character, check \"are we under tight contraint\" :\\n\\t\\t\\ttight contraint means have we reached its max value ie its upper bound\\n\\t\\t\\tif we are under tight contraint then set ub = s[i] (s[i] is max value it can go, if it goes greater than s[i] then it will not be in range [1, n])\\n\\t\\t\\telse set ub = 9\\nstep 3: if we are geting j == 3 or j == 4 or j ==7, we simply continue because they are not good.\\nstep 4: when i am calling solve(), i am passing  \" p | rot[j] \":\\n\\t\\t\\tif that is true or 1, then we have already found good number and we have got 1 good number so return 1\\n\\t\\t\\telse\\n\\t\\t\\t\\treturn 0;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t\\n\\tstring s;\\n    unordered_map <int, bool> rot;\\n    int dp[10001][2][2];\\n    int solve(int i, int t, int p) {\\n        \\n        if (i == s.length()) {\\n            if (p)\\n                return 1;\\n            else \\n                return 0;\\n        }\\n        \\n        if (dp[i][t][p] != -1)\\n            return dp[i][t][p];\\n        \\n        int ub = t ? s[i]-\\'0\\' : 9;\\n        int ans = 0;\\n        for (int j = 0; j <= ub; j++) {\\n            if (j == 3 || j == 4 || j == 7)\\n                continue;\\n            \\n            ans += solve(i+1, t&(j==ub), p|rot[j]);\\n        }\\n        \\n        return dp[i][t][p] = ans;\\n    }\\n    int rotatedDigits(int n) {\\n        memset(dp, -1, sizeof(dp));\\n        s = to_string(n);\\n        rot[2] = true;\\n        rot[5] = true;\\n        rot[6] = true;\\n        rot[9] = true;\\n        return solve(0,1,0);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1427945,
                "title": "c-solution-easy-solution-just-comparing-the-digits-of-num-with-the-digits-given-in-condition",
                "content": "```\\nclass Solution {\\npublic:\\n    int rotatedDigits(int n) {\\n        int c=0,i;\\n        for(int j=1;j<=n;j++)\\n        {\\n            bool f=false;\\n            i=j;\\n            while(i>0)\\n            {\\n                int r=i%10;\\n                if(r==3 || r==4 || r==7)\\n                {\\n                   f=false;\\n                   break;\\n                } \\n                else if(r==2 || r==5 || r==6 || r==9)\\n                   f=true;\\n                i=i/10;\\n            }\\n            if(f)\\n              c+=1;\\n        }\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int rotatedDigits(int n) {\\n        int c=0,i;\\n        for(int j=1;j<=n;j++)\\n        {\\n            bool f=false;\\n            i=j;\\n            while(i>0)\\n            {\\n                int r=i%10;\\n                if(r==3 || r==4 || r==7)\\n                {\\n                   f=false;\\n                   break;\\n                } \\n                else if(r==2 || r==5 || r==6 || r==9)\\n                   f=true;\\n                i=i/10;\\n            }\\n            if(f)\\n              c+=1;\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1343888,
                "title": "simple-memorization-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int rotatedDigits(int n) {\\n        vector<int> vec(n+10,-1);\\n        \\n        int count = 0;\\n        vec[0]=0;\\n        for(int i=1;i<=n;i++){\\n            \\n            int a=i%10;\\n            int b=i/10;\\n            if(a==2||a==5||a==6||a==9) vec[a]=1;\\n            \\n            if(a==0||a==1||a==8) vec[a]=0;\\n            \\n            if(a==4||a==7||a==3) {\\n                vec[i]=-1;\\n                continue;\\n            }\\n            if(vec[b]==-1) continue;\\n            \\n            if(vec[a]==1 || vec[b]==1){\\n                count++;\\n                vec[i]=1;\\n            }\\n            \\n            else vec[i]=0;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int rotatedDigits(int n) {\\n        vector<int> vec(n+10,-1);\\n        \\n        int count = 0;\\n        vec[0]=0;\\n        for(int i=1;i<=n;i++){\\n            \\n            int a=i%10;\\n            int b=i/10;\\n            if(a==2||a==5||a==6||a==9) vec[a]=1;\\n            \\n            if(a==0||a==1||a==8) vec[a]=0;\\n            \\n            if(a==4||a==7||a==3) {\\n                vec[i]=-1;\\n                continue;\\n            }\\n            if(vec[b]==-1) continue;\\n            \\n            if(vec[a]==1 || vec[b]==1){\\n                count++;\\n                vec[i]=1;\\n            }\\n            \\n            else vec[i]=0;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1306240,
                "title": "python-simplest-solution",
                "content": "```\\nclass Solution:\\n    def rotatedDigits(self, n: int) -> int:\\n        count = 0\\n        for i in range(1, n + 1):\\n            num = str(i)\\n            if \\'3\\' in num or \\'7\\' in num or \\'4\\' in num: \\n                continue\\n            if \\'2\\' in num or \\'5\\' in num or \\'6\\' in num or \\'9\\' in num:\\n                count += 1\\n        return count\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def rotatedDigits(self, n: int) -> int:\\n        count = 0\\n        for i in range(1, n + 1):\\n            num = str(i)\\n            if \\'3\\' in num or \\'7\\' in num or \\'4\\' in num: \\n                continue\\n            if \\'2\\' in num or \\'5\\' in num or \\'6\\' in num or \\'9\\' in num:\\n                count += 1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1296633,
                "title": "self-explanatory-c-easy-faster-than-100-00-of-c-online-submissions",
                "content": "```\\n// x is a good number if after rotating each digit individually by 180 degrees,\\n// we get a valid number that is different from x\\n//logic is give in second para of the question \\n//  1 and 10 are not good numbers, since they remain unchanged after rotating\\n// 2 and 5 rotate to each other\\n// 6 and 9 rotate to each other\\nclass Solution {\\npublic:\\n    bool checkdigit(int n){\\n        int t;\\n        bool f=0;\\n        while(n){\\n            t=n%10;\\n            if(t==3 || t==4 || t==7) return 0;\\n            if(t==2 || t==5 || t==6 || t==9) f=1;     \\n            n/=10;\\n        }\\n        return f;\\n    }\\n    int rotatedDigits(int N) {\\n        int ans=0;\\n        for(int i=2;i<=N;i++){\\n            ans+=checkdigit(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n// x is a good number if after rotating each digit individually by 180 degrees,\\n// we get a valid number that is different from x\\n//logic is give in second para of the question \\n//  1 and 10 are not good numbers, since they remain unchanged after rotating\\n// 2 and 5 rotate to each other\\n// 6 and 9 rotate to each other\\nclass Solution {\\npublic:\\n    bool checkdigit(int n){\\n        int t;\\n        bool f=0;\\n        while(n){\\n            t=n%10;\\n            if(t==3 || t==4 || t==7) return 0;\\n            if(t==2 || t==5 || t==6 || t==9) f=1;     \\n            n/=10;\\n        }\\n        return f;\\n    }\\n    int rotatedDigits(int N) {\\n        int ans=0;\\n        for(int i=2;i<=N;i++){\\n            ans+=checkdigit(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1278012,
                "title": "c-solution-0-ms",
                "content": "```\\n\\n\\nint rotatedDigits(int n){\\n    int i,c=0;\\n    bool flg=false;\\n    char* is_valid[]={\"same\",\"same\",\"valid\",\"invalid\",\"invalid\",\"valid\",\"valid\",\"invalid\",\"same\",\"valid\"};\\n    for(i=2;i<=n;i++)\\n    {\\n        int r=i,flg=false;\\n        while(r>0){\\n            int t=r%10;\\n            if(is_valid[t]==\"invalid\") {flg=false;break;}\\n            if(is_valid[t]==\"valid\") flg=true;\\n            r=r/10;\\n        }\\n        if(flg) c++;\\n    }\\n    return c;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n\\n\\nint rotatedDigits(int n){\\n    int i,c=0;\\n    bool flg=false;\\n    char* is_valid[]={\"same\",\"same\",\"valid\",\"invalid\",\"invalid\",\"valid\",\"valid\",\"invalid\",\"same\",\"valid\"};\\n    for(i=2;i<=n;i++)\\n    {\\n        int r=i,flg=false;\\n        while(r>0){\\n            int t=r%10;\\n            if(is_valid[t]==\"invalid\") {flg=false;break;}\\n            if(is_valid[t]==\"valid\") flg=true;\\n            r=r/10;\\n        }\\n        if(flg) c++;\\n    }\\n    return c;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1259978,
                "title": "python-simple-solution-using-sets",
                "content": "```python\\ndef rotatedDigits(self, n: int) -> int:\\n        invalid_nums = set([3,4,7])\\n        change_nums = set([2,5,6,9])\\n        \\n        def isGood(num):\\n            changed_num = False\\n            while num:\\n                num, rem = divmod(num, 10)\\n                if rem in invalid_nums:\\n                    return False\\n                if rem in change_nums:\\n                    changed_num = True\\n            return changed_num\\n    \\n        return sum(isGood(i) for i in range(1,n+1))\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\ndef rotatedDigits(self, n: int) -> int:\\n        invalid_nums = set([3,4,7])\\n        change_nums = set([2,5,6,9])\\n        \\n        def isGood(num):\\n            changed_num = False\\n            while num:\\n                num, rem = divmod(num, 10)\\n                if rem in invalid_nums:\\n                    return False\\n                if rem in change_nums:\\n                    changed_num = True\\n            return changed_num\\n    \\n        return sum(isGood(i) for i in range(1,n+1))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1238923,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\nprivate:\\n    bool numberRotates(int num){\\n        bool rotates = false;\\n        while (num > 0) {\\n\\t\\t    int t = num % 10;\\n            \\n            if (t == 2 || t == 5 || t == 6 || t == 9)\\n\\t\\t\\t    rotates = true;\\n\\t\\t\\t\\n            if (t == 3 || t == 4 || t == 7) \\n                return false;\\n            \\n            num /= 10;\\n\\t\\t}\\n        \\n        return rotates;\\n    }\\n    \\npublic:\\n\\tint rotatedDigits(int n) {\\n\\t\\tint count = 0;\\n\\t\\tfor (int i = 1; i <= n; i++)\\n            if(numberRotates(i)) count++;\\n\\t\\t\\t\\n\\t\\treturn count;\\n\\t}\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\nprivate:\\n    bool numberRotates(int num){\\n        bool rotates = false;\\n        while (num > 0) {\\n\\t\\t    int t = num % 10;\\n            \\n            if (t == 2 || t == 5 || t == 6 || t == 9)\\n\\t\\t\\t    rotates = true;\\n\\t\\t\\t\\n            if (t == 3 || t == 4 || t == 7) \\n                return false;\\n            \\n            num /= 10;\\n\\t\\t}\\n        \\n        return rotates;\\n    }\\n    \\npublic:\\n\\tint rotatedDigits(int n) {\\n\\t\\tint count = 0;\\n\\t\\tfor (int i = 1; i <= n; i++)\\n            if(numberRotates(i)) count++;\\n\\t\\t\\t\\n\\t\\treturn count;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1222475,
                "title": "c-hashsets",
                "content": "```\\npublic class Solution {\\n    public int RotatedDigits(int n) {\\n        \\n        var good = new HashSet<int>() {2, 5, 6, 9 };\\n        var set = new HashSet<int>() {0, 1, 8};\\n        \\n        int count = 0;\\n        for(int i = 1; i <= n; i++)\\n        {\\n            var isGood = false;\\n            var num = i; //gotcha           \\n            while(num > 0)\\n            {\\n                var digit = num%10; \\n                if(!good.Contains(digit) && !set.Contains(digit))\\n                    break;\\n                \\n                if (good.Contains(digit))\\n                {\\n                    isGood = true;\\n                }                   \\n                num = num/10;\\n            }\\n            if(num == 0 && isGood)\\n            {               \\n                count++;   \\n            }                           \\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int RotatedDigits(int n) {\\n        \\n        var good = new HashSet<int>() {2, 5, 6, 9 };\\n        var set = new HashSet<int>() {0, 1, 8};\\n        \\n        int count = 0;\\n        for(int i = 1; i <= n; i++)\\n        {\\n            var isGood = false;\\n            var num = i; //gotcha           \\n            while(num > 0)\\n            {\\n                var digit = num%10; \\n                if(!good.Contains(digit) && !set.Contains(digit))\\n                    break;\\n                \\n                if (good.Contains(digit))\\n                {\\n                    isGood = true;\\n                }                   \\n                num = num/10;\\n            }\\n            if(num == 0 && isGood)\\n            {               \\n                count++;   \\n            }                           \\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1203054,
                "title": "c-speed-o-log-n-space-o-log-n",
                "content": "Since n <= 10000, any O(n x log(n)) solution would pass, but if this is a Google interview, most likely such a solution would be considered sub-optimal, so here is the O(log(n)) solution.\\n\\nThere are 7 valid digits, i.e. 0, 1, 2, 5, 6, 8, 9;\\nand 3 valid, non-rotatable digits, i.e. 0,1,8.\\n\\nFor n = 1234, we count as follows:\\n-- aaa: 7^3-3^3\\n7^3 for aaa, a = 0,1,2,5,6,8,9\\nover counting: 3^3 for aaa, a = 0,1,8\\n\\n-- 1baa, b < 2: 7^2x2 - 3^2x2\\n7^2 for each of 10aa and 11aa, a = 0,1,2,5,6,8,9\\nover counting: 3^2 for each of 10aa and 11aa, a = 0,1,8\\n\\n-- 12ca, c < 3; 7x3 = 21\\n7 for each of 120a, 121a and 122a, a = 0,1,2,5,6,8,9\\nno over counting\\n\\n-- 123a: 0\\nno valid numer\\n\\n```\\npublic:\\n    int rotatedDigits(int n) {\\n        vector<int> digits;\\n        int m = n+1, ans = 0, p7 = 1, p3 = 1;;\\n        while (m > 0) {\\n            int d = m%10;\\n            digits.push_back(d);\\n            m = (m-d)/10;\\n            p7 *= 7, p3 *= 3;\\n        }\\n        \\n        bool prefix = false;\\n        while (!digits.empty()) {\\n            int d = digits.back();\\n            digits.pop_back();\\n            p7 /= 7;\\n            p3 /= 3;\\n            \\n            ans += b[d]*p7 - (prefix ? 0 : a[d]*p3);\\n            \\n            if (d == 3 || d == 4 || d == 7) break;\\n            prefix = prefix || d == 2 || d == 5 || d == 6 || d == 9;\\n        }\\n        return ans;\\n    }\\nprivate:\\n    // counting 0, 1, 8\\n    int a [10] = {0, 1, 2, 2, 2, 2, 2, 2, 2, 3};\\n    \\n    // counting 0, 1, 2, 5, 6, 8, 9\\n    int b [10] = {0, 1, 2, 3, 3, 3, 4, 5, 5, 6};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\npublic:\\n    int rotatedDigits(int n) {\\n        vector<int> digits;\\n        int m = n+1, ans = 0, p7 = 1, p3 = 1;;\\n        while (m > 0) {\\n            int d = m%10;\\n            digits.push_back(d);\\n            m = (m-d)/10;\\n            p7 *= 7, p3 *= 3;\\n        }\\n        \\n        bool prefix = false;\\n        while (!digits.empty()) {\\n            int d = digits.back();\\n            digits.pop_back();\\n            p7 /= 7;\\n            p3 /= 3;\\n            \\n            ans += b[d]*p7 - (prefix ? 0 : a[d]*p3);\\n            \\n            if (d == 3 || d == 4 || d == 7) break;\\n            prefix = prefix || d == 2 || d == 5 || d == 6 || d == 9;\\n        }\\n        return ans;\\n    }\\nprivate:\\n    // counting 0, 1, 8\\n    int a [10] = {0, 1, 2, 2, 2, 2, 2, 2, 2, 3};\\n    \\n    // counting 0, 1, 2, 5, 6, 8, 9\\n    int b [10] = {0, 1, 2, 3, 3, 3, 4, 5, 5, 6};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1167312,
                "title": "javascript-easy-and-short-solution-90-80",
                "content": "Runtime: 80 ms, faster than 90.68% of JavaScript online submissions for Rotated Digits.\\nMemory Usage: 39 MB, less than 80.12% of JavaScript online submissions for Rotated Digits.\\n```\\nvar rotatedDigits = function(N) {\\n    var res = 0\\n    for(i=1;i<=N;i++){\\n        let j = i.toString()\\n        if(j.includes(\"3\")||j.includes(\"4\")||j.includes(\"7\")) continue;\\n        if(j.includes(\"2\")||j.includes(\"5\")||j.includes(\"6\")||j.includes(\"9\")) res++\\n    }\\n    return res\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar rotatedDigits = function(N) {\\n    var res = 0\\n    for(i=1;i<=N;i++){\\n        let j = i.toString()\\n        if(j.includes(\"3\")||j.includes(\"4\")||j.includes(\"7\")) continue;\\n        if(j.includes(\"2\")||j.includes(\"5\")||j.includes(\"6\")||j.includes(\"9\")) res++\\n    }\\n    return res\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1072163,
                "title": "4-ms-faster-than-73-54-of-java",
                "content": "```\\nclass Solution {\\n    public int rotatedDigits(int N) {\\n        int count = 0;\\n        for(int i = 1; i <= N; i++) {\\n            if(isGoodNumber(i)) {\\n                count++;\\n            }\\n        }\\n        return count;        \\n    }\\n    \\n    private boolean isGoodNumber(int num) {\\n        boolean isValid = false;\\n        \\n        int n = num;\\n        while(n > 0) {\\n            int rem = n % 10;\\n            if(rem == 3 || rem == 4 || rem == 7) return false;\\n            if(rem == 2 || rem == 5 || rem == 6 || rem == 9) isValid = true;\\n            n /= 10;\\n        }\\n        return isValid;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int rotatedDigits(int N) {\\n        int count = 0;\\n        for(int i = 1; i <= N; i++) {\\n            if(isGoodNumber(i)) {\\n                count++;\\n            }\\n        }\\n        return count;        \\n    }\\n    \\n    private boolean isGoodNumber(int num) {\\n        boolean isValid = false;\\n        \\n        int n = num;\\n        while(n > 0) {\\n            int rem = n % 10;\\n            if(rem == 3 || rem == 4 || rem == 7) return false;\\n            if(rem == 2 || rem == 5 || rem == 6 || rem == 9) isValid = true;\\n            n /= 10;\\n        }\\n        return isValid;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1026037,
                "title": "java-4ms-solution",
                "content": "class Solution\\n{\\n    public int rotatedDigits(int N) \\n    {\\n        int ans=0;\\n        for(int i=1;i<=N;i++)\\n        {\\n            ans+=check(i);\\n        }\\n        return ans;\\n    }\\n    int check(int n)\\n    {\\n        boolean flag=false;\\n        while(n!=0)\\n        {\\n            int a=n%10;\\n            if(a==2 || a==5 || a==6 || a==9) flag=true;\\n            if(a==3 || a==4 || a==7) return 0;\\n            n=n/10;\\n        }\\n        return flag?1:0;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution\\n{\\n    public int rotatedDigits(int N) \\n    {\\n        int ans=0;\\n        for(int i=1;i<=N;i++)\\n        {\\n            ans+=check(i);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 957783,
                "title": "0ms-100-faster-simple-solution-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    bool good(int x){\\n        int y;\\n        bool rotated=false;\\n        while(x>0){\\n            y=x%10;\\n            switch(y){\\n                case 0:\\n                case 1:\\n                case 8:\\n                    break;\\n                case 2:\\n                case 5:\\n                case 6:\\n                case 9:\\n                    rotated = true;\\n                    break;\\n                default:\\n                    return false;\\n            }\\n            x=x/10;\\n        }\\n        return rotated;\\n    }\\n    \\n    int rotatedDigits(int N) {\\n        int count =0;\\n        for(int i=1;i<=N;i++){\\n            if(good(i)){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool good(int x){\\n        int y;\\n        bool rotated=false;\\n        while(x>0){\\n            y=x%10;\\n            switch(y){\\n                case 0:\\n                case 1:\\n                case 8:\\n                    break;\\n                case 2:\\n                case 5:\\n                case 6:\\n                case 9:\\n                    rotated = true;\\n                    break;\\n                default:\\n                    return false;\\n            }\\n            x=x/10;\\n        }\\n        return rotated;\\n    }\\n    \\n    int rotatedDigits(int N) {\\n        int count =0;\\n        for(int i=1;i<=N;i++){\\n            if(good(i)){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 937182,
                "title": "javascript-solution-brute-force-solution",
                "content": "```\\nvar rotatedDigits = function(N) {\\n    let count = 0;\\n    \\n    for (let i = 1; i <= N; i++) {\\n        if (isValidDiffNum(i)) count++;\\n    }\\n\\n    return count;\\n        \\n    function isValidDiffNum(num) {\\n        let isValid = true;\\n        let isDiff = false;\\n        \\n        while (num > 0) {\\n            const lastDig = num % 10;\\n            \\n            if (lastDig === 3 || lastDig === 4 || lastDig === 7) {\\n                isValid = false;\\n                break;\\n            }\\n            else if (lastDig === 2 || lastDig === 5 || lastDig === 6 || lastDig === 9) {\\n                isDiff = true;\\n            }\\n            \\n            num = Math.floor(num / 10);\\n        }\\n        \\n        return isValid && isDiff;\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar rotatedDigits = function(N) {\\n    let count = 0;\\n    \\n    for (let i = 1; i <= N; i++) {\\n        if (isValidDiffNum(i)) count++;\\n    }\\n\\n    return count;\\n        \\n    function isValidDiffNum(num) {\\n        let isValid = true;\\n        let isDiff = false;\\n        \\n        while (num > 0) {\\n            const lastDig = num % 10;\\n            \\n            if (lastDig === 3 || lastDig === 4 || lastDig === 7) {\\n                isValid = false;\\n                break;\\n            }\\n            else if (lastDig === 2 || lastDig === 5 || lastDig === 6 || lastDig === 9) {\\n                isDiff = true;\\n            }\\n            \\n            num = Math.floor(num / 10);\\n        }\\n        \\n        return isValid && isDiff;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 925355,
                "title": "python-3-easy-understanding-explained-80-ms-faster-100-mem",
                "content": "Note that the ten individual digits (0-9) can be classified into three catagaries: rotatable digits that become different digits ([\"2\", \"5\", \"6\", \"9\"]), non-rotatable digits ([\"3\", \"4\", \"7\"]), and rotate-to-themselves ones ([\"0\", \"1\", \"8\"]). Based on these catagaries, we can come up with the below solution to determine if the number as a whole is rotatable or in other words, number X is a good number.\\nWe iterate the number digit by digit.\\nIf the digit is in the non-rotatable digits list, e.g. for number 359, the first digit 3 is in the non-rotatable digits list, then we can conclude this number as a whole is invalid because \"**each digit must be rotated**\". In this case, we can move on to the next number.\\nThen if the digit is in the rotatable digits list, we add 1 to the counter \"rotated\".\\nThen if the digit is in the rotate-to-themselves list, we add 1 to the counter \"same\".\\nAfter iterating this number, we need to make a conclusion about whether this number is rotatable or not.\\nHere we need to consider three different scenarios. The *first* one is that all the digits of this number are rotated, e.g. for number 596, it becomes 269 showing all three digits are rotated. So the number is rotatable. We make the conclusion based on the fact that the counter \"rotated\" (in this example, it is 3) is equal to the length of the number (3). Then the *second* scenario is that some digits of this number are rotated and some digits are themselves, e.g. number 2160, it becomes 5190 showing \\'2\\' and \\'6\\' are rotated, and \\'1\\' and \\'0\\' are themselves, this number 2160 counts. The conclusion is made based on the fact that the counter \"rotated\" (in this example, it is 2) plus the counter \"same\" (it is 2) is equal to the length of the number (2+2=4). The *last* scenario is that all the digits are themselves after the rotation, e.g. number 1810. This number doesn\\'t count. The conclusion is made based on the fact that the counter \"rotated\" is zero.\\nSo we combine the above three scenarios, the logic implemention in the code is such \"**(rotated == slen) or (((rotated+same) == slen) and (rotated > 0))**\".\\nAnd don\\'t forget to reset both counters after each number iteration.\\n~~~\\nclass Solution:\\n    def rotatedDigits(self, N: int) -> int:\\n        count, rotated, same = 0, 0, 0\\n        rotation = [\"2\", \"5\", \"6\", \"9\"]\\n        themselves = [\"0\", \"1\", \"8\"]\\n        non_rot = [\"3\", \"4\", \"7\"]\\n        for i in range(1, N+1, 1):\\n            nth = str(i)\\n            slen = len(nth)\\n            for char in nth:\\n                if char in non_rot:\\n                    break\\n                elif char in rotation:\\n                    rotated +=1\\n                elif char in themselves:\\n                    same += 1\\n            if (rotated == slen) or (((rotated+same) == slen) and (rotated > 0)):\\n                count += 1\\n            rotated = 0\\n            same = 0\\n        return count\\n~~~",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "Note that the ten individual digits (0-9) can be classified into three catagaries: rotatable digits that become different digits ([\"2\", \"5\", \"6\", \"9\"]), non-rotatable digits ([\"3\", \"4\", \"7\"]), and rotate-to-themselves ones ([\"0\", \"1\", \"8\"]). Based on these catagaries, we can come up with the below solution to determine if the number as a whole is rotatable or in other words, number X is a good number.\\nWe iterate the number digit by digit.\\nIf the digit is in the non-rotatable digits list, e.g. for number 359, the first digit 3 is in the non-rotatable digits list, then we can conclude this number as a whole is invalid because \"**each digit must be rotated**\". In this case, we can move on to the next number.\\nThen if the digit is in the rotatable digits list, we add 1 to the counter \"rotated\".\\nThen if the digit is in the rotate-to-themselves list, we add 1 to the counter \"same\".\\nAfter iterating this number, we need to make a conclusion about whether this number is rotatable or not.\\nHere we need to consider three different scenarios. The *first* one is that all the digits of this number are rotated, e.g. for number 596, it becomes 269 showing all three digits are rotated. So the number is rotatable. We make the conclusion based on the fact that the counter \"rotated\" (in this example, it is 3) is equal to the length of the number (3). Then the *second* scenario is that some digits of this number are rotated and some digits are themselves, e.g. number 2160, it becomes 5190 showing \\'2\\' and \\'6\\' are rotated, and \\'1\\' and \\'0\\' are themselves, this number 2160 counts. The conclusion is made based on the fact that the counter \"rotated\" (in this example, it is 2) plus the counter \"same\" (it is 2) is equal to the length of the number (2+2=4). The *last* scenario is that all the digits are themselves after the rotation, e.g. number 1810. This number doesn\\'t count. The conclusion is made based on the fact that the counter \"rotated\" is zero.\\nSo we combine the above three scenarios, the logic implemention in the code is such \"**(rotated == slen) or (((rotated+same) == slen) and (rotated > 0))**\".\\nAnd don\\'t forget to reset both counters after each number iteration.\\n~~~\\nclass Solution:\\n    def rotatedDigits(self, N: int) -> int:\\n        count, rotated, same = 0, 0, 0\\n        rotation = [\"2\", \"5\", \"6\", \"9\"]\\n        themselves = [\"0\", \"1\", \"8\"]\\n        non_rot = [\"3\", \"4\", \"7\"]\\n        for i in range(1, N+1, 1):\\n            nth = str(i)\\n            slen = len(nth)\\n            for char in nth:\\n                if char in non_rot:\\n                    break\\n                elif char in rotation:\\n                    rotated +=1\\n                elif char in themselves:\\n                    same += 1\\n            if (rotated == slen) or (((rotated+same) == slen) and (rotated > 0)):\\n                count += 1\\n            rotated = 0\\n            same = 0\\n        return count\\n~~~",
                "codeTag": "Java"
            },
            {
                "id": 891924,
                "title": "python-simple-checking",
                "content": "```\\nclass Solution:\\n    def rotatedDigits(self, N: int) -> int:\\n        count = 0\\n        for num in range(1, N+1):\\n            s = str(num)\\n            if \\'3\\' in s or \\'4\\' in s or \\'7\\' in s:\\n                continue\\n            if \\'2\\' in s or \\'5\\' in s or \\'6\\' in s or \\'9\\' in s:\\n                count += 1\\n            \\n        return count\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def rotatedDigits(self, N: int) -> int:\\n        count = 0\\n        for num in range(1, N+1):\\n            s = str(num)\\n            if \\'3\\' in s or \\'4\\' in s or \\'7\\' in s:\\n                continue\\n            if \\'2\\' in s or \\'5\\' in s or \\'6\\' in s or \\'9\\' in s:\\n                count += 1\\n            \\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 882659,
                "title": "javascript-3-lines-solution",
                "content": "```\\nvar rotatedDigits = function(N) {\\n  let counter = 0;\\n  for (let i = 1; i <= N; i++) if((/2|5|6|9/g).test(i) && !(/3|4|7/).test(i)) counter++;\\n  return counter;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar rotatedDigits = function(N) {\\n  let counter = 0;\\n  for (let i = 1; i <= N; i++) if((/2|5|6|9/g).test(i) && !(/3|4|7/).test(i)) counter++;\\n  return counter;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 878807,
                "title": "c-memory-usage",
                "content": "Does somebody know why for the solution below the platform tells me:\\n\\n**Memory Usage: 6.2 MB, less than 22.61% of C++ online submissions for Rotated Digits.**\\n\\nWhat occupies so much memory? There\\'s no recursivity, only the 3 arrays occupy 4 * 10 * 3 = 120 bytes and the array inside rotatedDigits, which occupies 5 * 4 = 20 bytes..\\n\\n```\\n//\\n// \\'same\\' digit = 0/1/8\\n// \\'good\\' digit = 2/5/6/9\\n// \\'invalid\\' digit = 3/4/7\\n//\\n// Given functions:\\n//      v(N) = valids between [0, N]    (easily computable for N ending in 9s)\\n//      s(N) = sames between [0, N]     (easily computable for N ending in 9s)\\n//      g(N) = goods between [0, N]     (easily computable for N ending in 9s)\\n// , we make use of the following facts:\\n//\\n//  1) g(N) = g(number ending in 9s below N) + g(N without 1st digit), if N starts with \\'same\\' digit\\n//      e.g. for N = 8253, since first digit is 8, i.e. \\'same\\' => g(8253) = g(7999) + g(253)\\n//      we can then easily compute g(7999) = v(7999) - s(7999) = D_V[7] * 7^3 + D_S[7] * 3^3\\n//\\n//  2) g(N) = g(number ending in 9s below N) + v(N without 1st digit), if N starts with \\'good\\' digit\\n//      e.g. for n = 253: g(253) = g(199) + v(53)\\n//      we can then easily compute g(199) = v(199) - s(199) = D_V[1] * 7^2 + D_S[1] * 3^2\\n//\\n//  3) Finally, g(N) = g(number ending in 9s below N), if N starts with \\'invalid\\' digit\\n//      e.g. for n = 377: g(377) = g(299)\\n//      we can then easily compute g(299) = v(299) - s(299) = D_V[2] * 7^2 + D_S[2] * 3^2\\n//\\n// More natural to implement recursively, but consumes more memory.\\n// Below solution is iterative.\\n//\\n\\nclass Solution\\n{\\nprivate:\\n    // Precomputed goods/valids/sames counts from 0 to 9.\\n    static constexpr int D_G[] = { 0, 0, 1, 1, 1, 2, 3, 3, 3, 4 };\\n    static constexpr int D_V[] = { 1, 2, 3, 3, 3, 4, 5, 5, 6, 7 };\\n    static constexpr int D_S[] = { 1, 2, 2, 2, 2, 2, 2, 2, 3, 3 };\\n\\nprivate:\\n    static inline int pow(int p, int n)\\n    {\\n        int r = 1;\\n        for (int i = 0; i < n; i++) r *= p;\\n        return r;\\n    }\\n    \\n    static inline bool is_inv_d(int d)\\n    {\\n        switch(d)\\n        {\\n            case 3:\\n            case 4:\\n            case 7:\\n                return true;\\n            default: return false;\\n        }\\n    }\\n\\npublic:\\n    int rotatedDigits(int N)\\n    {\\n        constexpr int MAX_DIGITS_COUNT = 5; // N <= 10000\\n\\n        if (N < 10) return D_G[N];\\n\\n        // Extract digits of N\\n        int ds[MAX_DIGITS_COUNT];\\n        int dc_dec = 0, N_cpy = N;\\n        while (N_cpy > 9)\\n        {\\n            ds[dc_dec++] = (N_cpy % 10);\\n            N_cpy /= 10;\\n        }\\n        ds[dc_dec] = N_cpy;\\n\\n        // Count goods.\\n        int goods = 0;\\n        int p7 = pow(7, dc_dec), p3 = pow(3, dc_dec);\\n        int i = dc_dec;\\n        bool switched_to_valids = false;\\n        while(i > 0 && !switched_to_valids)\\n        {\\n            int d = ds[i--];\\n            if (d != 0)\\n            {\\n                goods += p7 * D_V[d-1] - p3 * D_S[d-1];\\n                switched_to_valids = true;\\n                if (is_inv_d(d)) return goods;\\n                if (d == 1 || d == 8) switched_to_valids = false;\\n            }\\n            p7 /= 7; p3 /= 3;\\n        }\\n\\n        // Switch to counting valids instead.\\n        while (i > 0)\\n        {\\n            int d = ds[i--];\\n            if (d != 0)\\n            {\\n                goods += p7 * D_V[d-1];\\n                if (is_inv_d(d)) return goods;\\n            }\\n            p7 /= 7;\\n        }\\n\\n        // We need to add either goods or valids for the last digit.\\n        int last_d = ds[0];\\n        goods += (switched_to_valids ? D_V[last_d] : D_G[last_d]);\\n        return goods;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\n//\\n// \\'same\\' digit = 0/1/8\\n// \\'good\\' digit = 2/5/6/9\\n// \\'invalid\\' digit = 3/4/7\\n//\\n// Given functions:\\n//      v(N) = valids between [0, N]    (easily computable for N ending in 9s)\\n//      s(N) = sames between [0, N]     (easily computable for N ending in 9s)\\n//      g(N) = goods between [0, N]     (easily computable for N ending in 9s)\\n// , we make use of the following facts:\\n//\\n//  1) g(N) = g(number ending in 9s below N) + g(N without 1st digit), if N starts with \\'same\\' digit\\n//      e.g. for N = 8253, since first digit is 8, i.e. \\'same\\' => g(8253) = g(7999) + g(253)\\n//      we can then easily compute g(7999) = v(7999) - s(7999) = D_V[7] * 7^3 + D_S[7] * 3^3\\n//\\n//  2) g(N) = g(number ending in 9s below N) + v(N without 1st digit), if N starts with \\'good\\' digit\\n//      e.g. for n = 253: g(253) = g(199) + v(53)\\n//      we can then easily compute g(199) = v(199) - s(199) = D_V[1] * 7^2 + D_S[1] * 3^2\\n//\\n//  3) Finally, g(N) = g(number ending in 9s below N), if N starts with \\'invalid\\' digit\\n//      e.g. for n = 377: g(377) = g(299)\\n//      we can then easily compute g(299) = v(299) - s(299) = D_V[2] * 7^2 + D_S[2] * 3^2\\n//\\n// More natural to implement recursively, but consumes more memory.\\n// Below solution is iterative.\\n//\\n\\nclass Solution\\n{\\nprivate:\\n    // Precomputed goods/valids/sames counts from 0 to 9.\\n    static constexpr int D_G[] = { 0, 0, 1, 1, 1, 2, 3, 3, 3, 4 };\\n    static constexpr int D_V[] = { 1, 2, 3, 3, 3, 4, 5, 5, 6, 7 };\\n    static constexpr int D_S[] = { 1, 2, 2, 2, 2, 2, 2, 2, 3, 3 };\\n\\nprivate:\\n    static inline int pow(int p, int n)\\n    {\\n        int r = 1;\\n        for (int i = 0; i < n; i++) r *= p;\\n        return r;\\n    }\\n    \\n    static inline bool is_inv_d(int d)\\n    {\\n        switch(d)\\n        {\\n            case 3:\\n            case 4:\\n            case 7:\\n                return true;\\n            default: return false;\\n        }\\n    }\\n\\npublic:\\n    int rotatedDigits(int N)\\n    {\\n        constexpr int MAX_DIGITS_COUNT = 5; // N <= 10000\\n\\n        if (N < 10) return D_G[N];\\n\\n        // Extract digits of N\\n        int ds[MAX_DIGITS_COUNT];\\n        int dc_dec = 0, N_cpy = N;\\n        while (N_cpy > 9)\\n        {\\n            ds[dc_dec++] = (N_cpy % 10);\\n            N_cpy /= 10;\\n        }\\n        ds[dc_dec] = N_cpy;\\n\\n        // Count goods.\\n        int goods = 0;\\n        int p7 = pow(7, dc_dec), p3 = pow(3, dc_dec);\\n        int i = dc_dec;\\n        bool switched_to_valids = false;\\n        while(i > 0 && !switched_to_valids)\\n        {\\n            int d = ds[i--];\\n            if (d != 0)\\n            {\\n                goods += p7 * D_V[d-1] - p3 * D_S[d-1];\\n                switched_to_valids = true;\\n                if (is_inv_d(d)) return goods;\\n                if (d == 1 || d == 8) switched_to_valids = false;\\n            }\\n            p7 /= 7; p3 /= 3;\\n        }\\n\\n        // Switch to counting valids instead.\\n        while (i > 0)\\n        {\\n            int d = ds[i--];\\n            if (d != 0)\\n            {\\n                goods += p7 * D_V[d-1];\\n                if (is_inv_d(d)) return goods;\\n            }\\n            p7 /= 7;\\n        }\\n\\n        // We need to add either goods or valids for the last digit.\\n        int last_d = ds[0];\\n        goods += (switched_to_valids ? D_V[last_d] : D_G[last_d]);\\n        return goods;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 820734,
                "title": "python-simple-solution",
                "content": "```\\nclass Solution:\\n    def rotatedDigits(self, N: int) -> int:\\n        number_of_rotated = 0\\n\\n        for i in range(1, N + 1):\\n            flag = False\\n            while i > 0:\\n                if i % 10 in [2, 5, 6, 9]:\\n                     flag = True\\n                elif i % 10 in [3,4,7]:\\n                    flag = False\\n                    break\\n                        \\n                i //= 10       \\n            number_of_rotated += 1 if flag else 0\\n                    \\n                \\n\\n        return number_of_rotated\\n    \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def rotatedDigits(self, N: int) -> int:\\n        number_of_rotated = 0\\n\\n        for i in range(1, N + 1):\\n            flag = False\\n            while i > 0:\\n                if i % 10 in [2, 5, 6, 9]:\\n                     flag = True\\n                elif i % 10 in [3,4,7]:\\n                    flag = False\\n                    break\\n                        \\n                i //= 10       \\n            number_of_rotated += 1 if flag else 0\\n                    \\n                \\n\\n        return number_of_rotated\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 779395,
                "title": "java-o-log-n-time-and-space-solution-expalined",
                "content": "Explanation: We consider 2 cases; When a number is valid after rotation, and when a number is both valid and good after rotation. From 0 to the max n-digit number, the amount of numbers that would remain valid after rotation would be 7^n since they can only contain (0,1,2,5,6,8,9). While the number that are both valid and good after rotation would be 7^n - 3^n since they have to be valid and must not all be (0,1,8). \\n\\nLet\\'s say we have an (n+1)-digit number. We take the only first digit A and iterate for 0 to A - 1 and consider cases where the number could be good. For each iteration. if the first digit is not valid, we skip all entire numbers starting with that digit, If the first digit is valid but not good, we use the formular(7^n - 3^n) to determine the total numbers that start with that digit but is valid and good since one of the corresponding digits have to be valid and good. If the first digit is valid and good, then we use (7^n) since all of the corresponding digits just have to be valid.\\n\\nFinally we consider numbers where first digit is A. Since it doesn\\'t cover all the n + 1 digit numbers that start with A, we use recursion to get the number of Valid and good digits up to N.\\n\\nExample: Suppose we want to find the valid and good numbers up to 5378;\\nValidAndGood( 5378 )\\nIt is a 4 digit number, so n = 3.\\nThe first digit is 5, so we iterate from 0 to 4:\\nAt iteration 0: 0 is valid but not good so total valid and good numbers from 0000 to 0999 is 7^3 - 3^3 = 316\\nAt iteration 1: 1 is also valid but not good, so total valid and good numbers from 1000 to 1999 is 7^3 - 3^3 = 316\\nAt iteration 2: 2 is valid and good, so total valid and good numbers from 2000 to 2999 is 7^3 =343\\nAt ieration 3: 3 is not valid, so we skip\\nAt iteration 4: 4 is also not valid so we skip\\n\\nSo total valid numbers from 0 to 4999 is 316 + 316 + 343 = 975\\n\\nFinally for the digit 5, Since 5 is valid and good we use recursion to find the number of valid and good from 5000 to 5378\\nvalidAndGood(5378) = 975 + validButNotNecessarilyGood( 378 )\\n\\nIn the solution a boolean value checkValChanged is passed to determine if the method should return all valid numbers or numbers that are both valid and good.\\n```\\nclass Solution {\\n    public int rotatedDigits(int N) {\\n        return validRotatedCount (N, true);\\n    }\\n    \\n    // Returns all rotated Numbers that are valid and changed(good) if checkValChanged is true\\n    // Returns all rotated Numbers that are valid but may or may not be changed when checkValChanged is false\\n    public int validRotatedCount(int N, boolean checkValChanged) {\\n        \\n        // For single digits numbers\\n        if (N < 0)\\n            return 0;\\n        else if (N < 10 ) {\\n            int totalNums = 0;\\n            int numValid;\\n            for (int i = 0; i <= N; ++i){\\n                numValid = numberValid(i);\\n                if (numValid == -1){\\n                    continue;\\n                }\\n                if (!checkValChanged || numValid == 1)\\n                    ++totalNums;\\n            \\n            }\\n            return totalNums;\\n        }\\n        \\n        \\n        String num = N + \"\";\\n        int val = num.charAt(0) - 48; // First Digit\\n        int index = num.length() - 1;\\n        int total = 0;\\n        int valid;\\n        \\n        //Iterate from 0 to the number before the first Digit\\n        for (int i = 0; i < val; ++i){\\n            valid = numberValid(i);\\n            if (valid == -1){\\n                continue;\\n            }\\n            else if (valid == 1 || !checkValChanged) {\\n                total += Math.pow(7 , index);\\n            } else {\\n                total += Math.pow(7 , index) -  Math.pow(3 , index);\\n            }\\n        }\\n        \\n        // Handles the final iteration for the first Digit\\n        valid = numberValid(val);\\n        if (valid == -1){\\n            return total;\\n        } else if (valid == 1 || !checkValChanged ) {\\n            total += validRotatedCount((int) (N % Math.pow(10 , index) ) , false);\\n        } else {\\n            total += validRotatedCount( (int) (N % Math.pow(10 , index) ), true);\\n        }\\n        \\n        return total;\\n        \\n    }\\n    \\n    public int numberValid(int n){\\n        switch(n) {\\n            case 2:\\n            case 5:\\n            case 6:\\n            case 9:\\n                return 1;\\n            case 3:\\n            case 4:\\n            case 7:\\n                return -1;\\n        }\\n        \\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int rotatedDigits(int N) {\\n        return validRotatedCount (N, true);\\n    }\\n    \\n    // Returns all rotated Numbers that are valid and changed(good) if checkValChanged is true\\n    // Returns all rotated Numbers that are valid but may or may not be changed when checkValChanged is false\\n    public int validRotatedCount(int N, boolean checkValChanged) {\\n        \\n        // For single digits numbers\\n        if (N < 0)\\n            return 0;\\n        else if (N < 10 ) {\\n            int totalNums = 0;\\n            int numValid;\\n            for (int i = 0; i <= N; ++i){\\n                numValid = numberValid(i);\\n                if (numValid == -1){\\n                    continue;\\n                }\\n                if (!checkValChanged || numValid == 1)\\n                    ++totalNums;\\n            \\n            }\\n            return totalNums;\\n        }\\n        \\n        \\n        String num = N + \"\";\\n        int val = num.charAt(0) - 48; // First Digit\\n        int index = num.length() - 1;\\n        int total = 0;\\n        int valid;\\n        \\n        //Iterate from 0 to the number before the first Digit\\n        for (int i = 0; i < val; ++i){\\n            valid = numberValid(i);\\n            if (valid == -1){\\n                continue;\\n            }\\n            else if (valid == 1 || !checkValChanged) {\\n                total += Math.pow(7 , index);\\n            } else {\\n                total += Math.pow(7 , index) -  Math.pow(3 , index);\\n            }\\n        }\\n        \\n        // Handles the final iteration for the first Digit\\n        valid = numberValid(val);\\n        if (valid == -1){\\n            return total;\\n        } else if (valid == 1 || !checkValChanged ) {\\n            total += validRotatedCount((int) (N % Math.pow(10 , index) ) , false);\\n        } else {\\n            total += validRotatedCount( (int) (N % Math.pow(10 , index) ), true);\\n        }\\n        \\n        return total;\\n        \\n    }\\n    \\n    public int numberValid(int n){\\n        switch(n) {\\n            case 2:\\n            case 5:\\n            case 6:\\n            case 9:\\n                return 1;\\n            case 3:\\n            case 4:\\n            case 7:\\n                return -1;\\n        }\\n        \\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 777744,
                "title": "c-0ms",
                "content": "```c++\\nclass Solution {\\npublic:\\n    int rotatedDigits(int n) {\\n        int help[]={1,1,2,0,0,2,2,0,1,2};\\n        int ans=0;\\n        for(int i=1;i<=n;i++){\\n            int s=1;\\n            int p=i;\\n            while(p){\\n                s*=help[p%10];\\n                p/=10;\\n            }\\n            if(s>=2)ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```c++\\nclass Solution {\\npublic:\\n    int rotatedDigits(int n) {\\n        int help[]={1,1,2,0,0,2,2,0,1,2};\\n        int ans=0;\\n        for(int i=1;i<=n;i++){\\n            int s=1;\\n            int p=i;\\n            while(p){\\n                s*=help[p%10];\\n                p/=10;\\n            }\\n            if(s>=2)ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 747625,
                "title": "c-very-easy-and-simple-faster-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isGood(int n)\\n    {\\n        if(n == 2 || n == 5 || n == 6 || n == 9)\\n            return true;\\n        int unchanged = 0, digits = 0;\\n        while(n > 0)\\n        {\\n            int rem = n % 10;\\n            n /= 10;\\n            digits++;\\n            if(rem == 3 || rem == 4 || rem == 7)\\n                return false;\\n            else if(rem == 0 || rem == 1 || rem == 8)\\n                unchanged++;\\n        }\\n        if(unchanged == digits)\\n            return false;\\n        else\\n            return true;\\n    }\\n    int rotatedDigits(int N) {\\n        if(N <= 1)\\n            return 0;\\n        int count = 0;\\n        for(int i=2; i<=N; i++)\\n        {\\n            if(isGood(i))\\n                count++;\\n        }\\n        return count;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    bool isGood(int n)\\n    {\\n        if(n == 2 || n == 5 || n == 6 || n == 9)\\n            return true;\\n        int unchanged = 0, digits = 0;\\n        while(n > 0)\\n        {\\n            int rem = n % 10;\\n            n /= 10;\\n            digits++;\\n            if(rem == 3 || rem == 4 || rem == 7)\\n                return false;\\n            else if(rem == 0 || rem == 1 || rem == 8)\\n                unchanged++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 732911,
                "title": "c-brute-force-solution-explaining-question-s-meaning",
                "content": "***Runtime: 52 ms, faster than 16.67% of C++ online submissions for Rotated Digits.\\nMemory Usage: 5.9 MB, less than 90.00% of C++ online submissions for Rotated Digits.***\\n```\\nclass Solution {\\npublic:\\n    int rotatedDigits(int N) {\\n        int result = 0;\\n        for(int i=1; i<=N ;i++){\\n            if(isGoodNumber(i)){\\n                result ++;\\n            }\\n        }\\n        return result;\\n    }\\n    bool isGoodNumber(int N){\\n        string s = to_string(N);\\n        string temp;\\n        for(int i=0;i<s.size();i++){\\n            switch(s[i]){                    \\n                case \\'0\\':   temp += \\'0\\';    break;\\n                case \\'1\\':   temp += \\'1\\';    break;\\n                case \\'2\\':   temp += \\'5\\';    break;\\n                case \\'5\\':   temp += \\'2\\';    break;\\n                case \\'6\\':   temp += \\'9\\';    break;\\n                case \\'8\\':   temp += \\'8\\';    break;\\n                case \\'9\\':   temp += \\'6\\';    break;\\n                default :   return false;\\n            }\\n        }\\n        return temp != s;\\n    }\\n};\\n```\\nReally struggled a lot (like Ananya Pandey) to get the meaning of this question.\\nThis question describes a `good number` as write the number on a piece of paper, then digit by digit perform transformation (180\\' rotation), \\nDo transitions as ::\\n0 -> 0\\n1 -> 1\\n2 -> 5\\n3 -> NOT POSSIBLE\\n4 -> NOT POSSIBLE\\n5 -> 2\\n6 -> 9\\n7 -> NOT POSSIBLE\\n8 -> 8\\n9 -> 9\\n\\n(God knows on which earth, 180\\' rotation of 2 makes 5 or vice versa).\\nSimply, you have to count the number of good numbers in range [1, N] both inclusive.",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int rotatedDigits(int N) {\\n        int result = 0;\\n        for(int i=1; i<=N ;i++){\\n            if(isGoodNumber(i)){\\n                result ++;\\n            }\\n        }\\n        return result;\\n    }\\n    bool isGoodNumber(int N){\\n        string s = to_string(N);\\n        string temp;\\n        for(int i=0;i<s.size();i++){\\n            switch(s[i]){                    \\n                case \\'0\\':   temp += \\'0\\';    break;\\n                case \\'1\\':   temp += \\'1\\';    break;\\n                case \\'2\\':   temp += \\'5\\';    break;\\n                case \\'5\\':   temp += \\'2\\';    break;\\n                case \\'6\\':   temp += \\'9\\';    break;\\n                case \\'8\\':   temp += \\'8\\';    break;\\n                case \\'9\\':   temp += \\'6\\';    break;\\n                default :   return false;\\n            }\\n        }\\n        return temp != s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 685227,
                "title": "java-o-logn-solution",
                "content": "The general idea into three parts :\\n1. If there are ```m``` digits remaining to be chosen, then there are ```(3+4)^m``` possible valid numbers.\\n2. If a flipable number i.e **{2,5,6,9}** has been seen, each of the remaining ```(3+4)^m``` possible valid numbers are good numbers; otherwise, ```3^m``` of those valid numbers are not good numbers and must be subtracted from the over estimation.\\n3. The less significant digits do not affect the good numbers contained in the more significant digits.\\n ```Consider an example of n = 424; we can break this number into [0,400), [400, 420), [420, 425). The least significant numbers 2 & 4 will have minimum effect as compared to [0, 400). ```\\n```\\nclass Solution {\\n    int[] type = {0,0,1,2,2,1,1,2,0,1};    //whether number is self-rotating, mirror-rotating or invalid\\n    int[] validRotation = {1,2,3,3,3,4,5,5,6,7};    //valid rotations {0,1,2,5,6,8,9}\\n    int[] sameRotation = {1,2,2,2,2,2,2,2,3,3};    //0,1,8 have same rotations\\n    int[] differentRotation = {0,0,1,1,1,2,3,3,3,4};     //to check if valid number i.e 2,5,6,9 is present in the digit\\n    public int rotatedDigits(int N) {\\n        String number = String.valueOf(N);\\n        return rotatedDigitsUtility(number, false);\\n    }\\n    \\n    public int rotatedDigitsUtility(String number, boolean isFlipable){\\n        int digit = number.charAt(0) - \\'0\\';\\n        \\n        if(number.length() == 1) return (isFlipable) ? validRotation[digit] : differentRotation[digit];\\n        \\n        int countGoodNumbers = 0;\\n        if(digit != 0){\\n            //Total number of valid counts will always be (3 + 4)^m, where 3 -> {0,1,8}; 4 -> {2,5,6,9}; m -> length of string;\\n            //we don\\'t consider invalid number i.e {3,4,7}\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0countGoodNumbers += (validRotation[digit - 1] * Math.pow(7, number.length() - 1)); \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0\\n            //if {2,5,6,9} haven\\'t occured yet, then we subtract 3 from the total estimation since there are 7 valid rotations out of which 4 rotations gives us a good number i.e {2,5,6,9}.\\n            if(!isFlipable) countGoodNumbers -= (sameRotation[digit - 1] * Math.pow(3, number.length() - 1));\\n        }\\n        \\n \\xA0 \\xA0 \\xA0 \\xA0//if the digit is a validRotation i.e {2,5,6,9}\\n        if(type[digit] == 1) isFlipable = true;\\n        \\n        if(type[digit] != 2) countGoodNumbers += rotatedDigitsUtility(number.substring(1, number.length()), isFlipable);\\n        \\n        return countGoodNumbers;\\n    }\\n}\\n```\\n##### Click [here](http://www.frankmadrid.com/ALudicFallacy/2018/02/28/rotated-digits-leet-code-788/) for concise explanation.!",
                "solutionTags": [],
                "code": "```m```\n```(3+4)^m```\n```(3+4)^m```\n```3^m```\n```Consider an example of n = 424; we can break this number into [0,400), [400, 420), [420, 425). The least significant numbers 2 & 4 will have minimum effect as compared to [0, 400). ```\n```\\nclass Solution {\\n    int[] type = {0,0,1,2,2,1,1,2,0,1};    //whether number is self-rotating, mirror-rotating or invalid\\n    int[] validRotation = {1,2,3,3,3,4,5,5,6,7};    //valid rotations {0,1,2,5,6,8,9}\\n    int[] sameRotation = {1,2,2,2,2,2,2,2,3,3};    //0,1,8 have same rotations\\n    int[] differentRotation = {0,0,1,1,1,2,3,3,3,4};     //to check if valid number i.e 2,5,6,9 is present in the digit\\n    public int rotatedDigits(int N) {\\n        String number = String.valueOf(N);\\n        return rotatedDigitsUtility(number, false);\\n    }\\n    \\n    public int rotatedDigitsUtility(String number, boolean isFlipable){\\n        int digit = number.charAt(0) - \\'0\\';\\n        \\n        if(number.length() == 1) return (isFlipable) ? validRotation[digit] : differentRotation[digit];\\n        \\n        int countGoodNumbers = 0;\\n        if(digit != 0){\\n            //Total number of valid counts will always be (3 + 4)^m, where 3 -> {0,1,8}; 4 -> {2,5,6,9}; m -> length of string;\\n            //we don\\'t consider invalid number i.e {3,4,7}\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0countGoodNumbers += (validRotation[digit - 1] * Math.pow(7, number.length() - 1)); \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0\\n            //if {2,5,6,9} haven\\'t occured yet, then we subtract 3 from the total estimation since there are 7 valid rotations out of which 4 rotations gives us a good number i.e {2,5,6,9}.\\n            if(!isFlipable) countGoodNumbers -= (sameRotation[digit - 1] * Math.pow(3, number.length() - 1));\\n        }\\n        \\n \\xA0 \\xA0 \\xA0 \\xA0//if the digit is a validRotation i.e {2,5,6,9}\\n        if(type[digit] == 1) isFlipable = true;\\n        \\n        if(type[digit] != 2) countGoodNumbers += rotatedDigitsUtility(number.substring(1, number.length()), isFlipable);\\n        \\n        return countGoodNumbers;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 683891,
                "title": "java-standard-solution",
                "content": "### Theory\\nHave a mapping defined from original digit to the rotated version. This will make our algoirthm have O(1) lookups.\\nWe basically go through the numbers [1, N] and check to see if the current number `i` is good.\\n\\n### Solution\\n```\\n    private int[] rotations = new int[] {0, 1, 5 , -1, -1, 2, 9, -1, 8, 6};\\n    \\n    public int rotatedDigits(int N) {\\n        int count = 0;\\n        for (int i = 1; i <= N; i++) if (isGood(i)) count++;\\n        return count;        \\n    }\\n    \\n    private boolean isGood(int num) {\\n        int copy = num, rotatedNum = 0, place = 1;\\n        while (copy > 0) {\\n            int lastDigit = copy % 10;\\n            if (rotations[lastDigit] == -1) return false;\\n            else rotatedNum += place * rotations[lastDigit];\\n            copy /= 10;\\n            place *= 10;\\n        }\\n        return rotatedNum != num;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    private int[] rotations = new int[] {0, 1, 5 , -1, -1, 2, 9, -1, 8, 6};\\n    \\n    public int rotatedDigits(int N) {\\n        int count = 0;\\n        for (int i = 1; i <= N; i++) if (isGood(i)) count++;\\n        return count;        \\n    }\\n    \\n    private boolean isGood(int num) {\\n        int copy = num, rotatedNum = 0, place = 1;\\n        while (copy > 0) {\\n            int lastDigit = copy % 10;\\n            if (rotations[lastDigit] == -1) return false;\\n            else rotatedNum += place * rotations[lastDigit];\\n            copy /= 10;\\n            place *= 10;\\n        }\\n        return rotatedNum != num;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 579348,
                "title": "go-clean-code-0ms-beats-100",
                "content": "```\\nfunc rotatedDigits(N int) int {\\n\\tvar cnt int\\n\\tfor i := 2; i <= N; i++ {\\n\\t\\tif isValid(i) {\\n\\t\\t\\tcnt++\\n\\t\\t}\\n\\t}\\n\\treturn cnt\\n}\\n\\nfunc isValid(num int) bool {\\n\\tvar ret bool\\n\\tfor ; num > 0; num /= 10 {\\n\\t\\tswitch num % 10 {\\n\\t\\tcase 2, 5, 6, 9:\\n\\t\\t\\tret = true\\n\\t\\tcase 3, 4, 7:\\n\\t\\t\\treturn false\\n\\t\\t}\\n\\t}\\n\\treturn ret\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc rotatedDigits(N int) int {\\n\\tvar cnt int\\n\\tfor i := 2; i <= N; i++ {\\n\\t\\tif isValid(i) {\\n\\t\\t\\tcnt++\\n\\t\\t}\\n\\t}\\n\\treturn cnt\\n}\\n\\nfunc isValid(num int) bool {\\n\\tvar ret bool\\n\\tfor ; num > 0; num /= 10 {\\n\\t\\tswitch num % 10 {\\n\\t\\tcase 2, 5, 6, 9:\\n\\t\\t\\tret = true\\n\\t\\tcase 3, 4, 7:\\n\\t\\t\\treturn false\\n\\t\\t}\\n\\t}\\n\\treturn ret\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 560601,
                "title": "python-digit-dp-pattern-for-similar-questions",
                "content": "Theory: https://codeforces.com/blog/entry/53960\\n\\nMore of the same approach:\\n[1012. Numbers With Repeated Digits](https://leetcode.com/problems/numbers-with-repeated-digits/discuss/560346/python-digit-dp)\\n[357. Count Numbers with Unique Digits](https://leetcode.com/problems/count-numbers-with-unique-digits/discuss/560898/Python-Digit-DP)\\n[902. Numbers At Most N Given Digit Set](https://leetcode.com/problems/numbers-at-most-n-given-digit-set/discuss/559624/python-digit-dp)\\n[1397. Find All Good Strings](https://leetcode.com/problems/find-all-good-strings/discuss/560841/Python-Digit-DP)\\n[233. Number of Digit One](https://leetcode.com/problems/number-of-digit-one/discuss/560876/Python-Digit-DP)\\n[600. Non-negative Integers without Consecutive Ones](https://leetcode.com/problems/non-negative-integers-without-consecutive-ones/discuss/584350/Python-Digit-DP-(Pattern-For-Similar-Questions))\\n\\nAt each recursive call (adding digit to less significant position) compute:\\n\\nisPrefix - if the new number is the prefix of N\\nisBigger - if the new number will be bigger than N when we reach final position\\nrepeated - there exists repeated digit\\nAnyone has an idea how to optimize when current number is lower than N?  I tried addig this but without luck:\\n```\\n\\tif hasRotating and not isPrefix and not isBigger:\\n\\t\\treturn int(pow(7, len(N) - pos))\\n```\\nCode:\\n```\\n    def rotatedDigits(self, N: int) -> int:\\n        N = list(map(int, str(N)))\\n        rotatings = {2, 5, 6, 9}\\n        nonrotatings = {0, 1, 8}\\n\\n        @functools.lru_cache(None)\\n        def dp(pos, isPrefix, isBigger, hasRotating):\\n            if pos == len(N):\\n                return 0\\n            result = 0\\n            for i in range(0 if pos > 0 else 1, 10):\\n                if i not in rotatings and i not in nonrotatings:\\n                    continue\\n                _isPrefix = isPrefix and i == N[pos]\\n                _isBigger = isBigger or (isPrefix and i > N[pos])\\n\\n                _hasRotating = hasRotating or i in rotatings\\n                if _hasRotating and not (pos == len(N) - 1 and _isBigger):\\n                    result += 1\\n                result += dp(pos + 1, _isPrefix, _isBigger, _hasRotating)\\n            return result\\n        return dp(0, True, False, False)",
                "solutionTags": [],
                "code": "```\\n\\tif hasRotating and not isPrefix and not isBigger:\\n\\t\\treturn int(pow(7, len(N) - pos))\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 519025,
                "title": "ez-understood-java-dfs-log-n-solution",
                "content": "The idea is start from 0 and add one digit at the end of the current number. If the parent number is already valid, the rest numbers that generate from it are all valid. To make a number valid, you just need to insert 2 or 5 or 6 or 9.\\n```\\nstatic final int[] key = new int[]{0, 1, 8, 2, 5, 6, 9};\\n    int res = 0;\\n    public int rotatedDigits(int N) {\\n        if(N<2) return 0;\\n        dfs(0, N, false);\\n        return res;\\n    }\\n    \\n    private void dfs(int cur, int N, boolean valid){\\n        cur*=10;\\n        if(cur>N) return;\\n        for(int i=0; i<key.length; i++){\\n            boolean va = valid || i>2;\\n            int next = cur+key[i];\\n            if(next==0 || next>N) continue;\\n            if(va)\\n                res++;\\n            dfs(next, N, va);\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nstatic final int[] key = new int[]{0, 1, 8, 2, 5, 6, 9};\\n    int res = 0;\\n    public int rotatedDigits(int N) {\\n        if(N<2) return 0;\\n        dfs(0, N, false);\\n        return res;\\n    }\\n    \\n    private void dfs(int cur, int N, boolean valid){\\n        cur*=10;\\n        if(cur>N) return;\\n        for(int i=0; i<key.length; i++){\\n            boolean va = valid || i>2;\\n            int next = cur+key[i];\\n            if(next==0 || next>N) continue;\\n            if(va)\\n                res++;\\n            dfs(next, N, va);\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 516104,
                "title": "easy-solution-with-explanation-python",
                "content": "The idea is to count all numbers (<=N) made of numbers {0,1,2,5,6,8,9} minus those made of {0,1,8}.  Notice that we don\\'t really care about leading zeros. \\n\\n\\n\\n\\n```\\nimport math\\ndef f(k,s):\\n    if k<10:\\n        return len({i for i in s if i<=k})\\n    digit=int(math.log10(k))\\n    lead_digit=k//10**digit\\n    k-=lead_digit*10**digit\\n    num=len(s)**digit*len({i for i in s if i<lead_digit})\\n    if lead_digit in s:\\n        return num+f(k,s)\\n    return num\\n\\nclass Solution:\\n    def rotatedDigits(self, N: int) -> int:\\n        s1={1,2,5,6,8,9,0}\\n        s2={1,8,0}\\n        return f(N,s1)-f(N,s2)\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nimport math\\ndef f(k,s):\\n    if k<10:\\n        return len({i for i in s if i<=k})\\n    digit=int(math.log10(k))\\n    lead_digit=k//10**digit\\n    k-=lead_digit*10**digit\\n    num=len(s)**digit*len({i for i in s if i<lead_digit})\\n    if lead_digit in s:\\n        return num+f(k,s)\\n    return num\\n\\nclass Solution:\\n    def rotatedDigits(self, N: int) -> int:\\n        s1={1,2,5,6,8,9,0}\\n        s2={1,8,0}\\n        return f(N,s1)-f(N,s2)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 515458,
                "title": "accepted-straightforward-c-solution",
                "content": "```\\n    public class Solution\\n    {\\n        private bool Check(int num)\\n        {\\n            bool contains2569 = false;\\n            while (num > 0)\\n            {\\n                int digit = num % 10;\\n                num /= 10;\\n\\n                if (digit == 2 || digit == 5 || digit == 6 || digit == 9)\\n                {\\n                    contains2569 = true;\\n                    continue;\\n                }\\n\\n                if (digit == 0 || digit == 1 || digit == 8)\\n                {\\n                    continue;\\n                }\\n\\n                return false;\\n            }\\n\\n            return contains2569;\\n        }\\n\\n        public int RotatedDigits(int n)\\n        {\\n            int res = 0;\\n\\n            for (int i = 1; i <= n; i++)\\n            {\\n                if (Check(i))\\n                {\\n                    res++;\\n                }\\n            }\\n\\n            return res;\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public class Solution\\n    {\\n        private bool Check(int num)\\n        {\\n            bool contains2569 = false;\\n            while (num > 0)\\n            {\\n                int digit = num % 10;\\n                num /= 10;\\n\\n                if (digit == 2 || digit == 5 || digit == 6 || digit == 9)\\n                {\\n                    contains2569 = true;\\n                    continue;\\n                }\\n\\n                if (digit == 0 || digit == 1 || digit == 8)\\n                {\\n                    continue;\\n                }\\n\\n                return false;\\n            }\\n\\n            return contains2569;\\n        }\\n\\n        public int RotatedDigits(int n)\\n        {\\n            int res = 0;\\n\\n            for (int i = 1; i <= n; i++)\\n            {\\n                if (Check(i))\\n                {\\n                    res++;\\n                }\\n            }\\n\\n            return res;\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 507882,
                "title": "python-set",
                "content": "```\\n    def rotatedDigits(self, N: int) -> int:\\n        ans = 0\\n        for num in range(1, N+1):\\n            num_s = str(num)\\n            if not set(\\'347\\').intersection(set(num_s)) and not set(num_s).issubset(set(\\'018\\')):\\n                ans += 1\\n                \\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\n    def rotatedDigits(self, N: int) -> int:\\n        ans = 0\\n        for num in range(1, N+1):\\n            num_s = str(num)\\n            if not set(\\'347\\').intersection(set(num_s)) and not set(num_s).issubset(set(\\'018\\')):\\n                ans += 1\\n                \\n        return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 494760,
                "title": "python-simple-sol-by-digit-scan-with-comment",
                "content": "Python simple sol. by digit scan.\\n\\n---\\n\\n```\\nclass Solution:\\n    def rotatedDigits(self, N: int) -> int:\\n        \\n        counter = 0\\n        for i in range(1, N+1):\\n            \\n            # convert number i to digit character array\\n            str_num_list = list( str(i) )\\n            \\n            # flag for good number judgement\\n            is_good_number = False\\n            \\n            for digit in str_num_list:\\n                \\n                if digit in {\\'3\\',\\'4\\',\\'7\\'}:\\n                    # invalid number after rotation\\n                    is_good_number = False\\n                    break\\n                elif digit in {\\'2\\',\\'5\\',\\'6\\',\\'9\\'}:\\n                    is_good_number = True\\n                    \\n                    \\n            if is_good_number:\\n                # update conter for good number\\n                counter += 1\\n                    \\n            \\n        return counter\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def rotatedDigits(self, N: int) -> int:\\n        \\n        counter = 0\\n        for i in range(1, N+1):\\n            \\n            # convert number i to digit character array\\n            str_num_list = list( str(i) )\\n            \\n            # flag for good number judgement\\n            is_good_number = False\\n            \\n            for digit in str_num_list:\\n                \\n                if digit in {\\'3\\',\\'4\\',\\'7\\'}:\\n                    # invalid number after rotation\\n                    is_good_number = False\\n                    break\\n                elif digit in {\\'2\\',\\'5\\',\\'6\\',\\'9\\'}:\\n                    is_good_number = True\\n                    \\n                    \\n            if is_good_number:\\n                # update conter for good number\\n                counter += 1\\n                    \\n            \\n        return counter\\n```",
                "codeTag": "Java"
            },
            {
                "id": 454860,
                "title": "python3-20ms-99-86-faster-12-7mb-100-memory",
                "content": "If you are curious about algorithm, please leave your comment below and I will update description with detailed algorithm.\\n```python\\nclass Solution:\\n    def rotatedDigits(self, N: int) -> int:\\n        smallSet = {0,1,8}\\n        bigSet = {2,5,6,9}\\n        smallNum = [0,0,1,1,1,2,3,3,3,4][N % 10]\\n        bigNum = [1,2,3,3,3,4,5,5,6,7][N % 10]\\n        N = N // 10\\n        smInc, bgInc = 4, 7\\n        while N:\\n            x = N % 10\\n            N = N // 10\\n            sm, bg = 0, 0\\n            for i in range(x):\\n                if i in smallSet:\\n                    sm += smInc\\n                    bg += bgInc\\n                elif i in bigSet:\\n                    sm += bgInc\\n                    bg += bgInc\\n            if x in smallSet:\\n                smallNum += sm\\n                bigNum += bg\\n            elif x in bigSet:\\n                smallNum = bigNum + sm\\n                bigNum += bg\\n            else:\\n                smallNum = sm\\n                bigNum = bg\\n            smInc, bgInc = 4*bgInc + 3*smInc, bgInc * 7\\n        return smallNum\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def rotatedDigits(self, N: int) -> int:\\n        smallSet = {0,1,8}\\n        bigSet = {2,5,6,9}\\n        smallNum = [0,0,1,1,1,2,3,3,3,4][N % 10]\\n        bigNum = [1,2,3,3,3,4,5,5,6,7][N % 10]\\n        N = N // 10\\n        smInc, bgInc = 4, 7\\n        while N:\\n            x = N % 10\\n            N = N // 10\\n            sm, bg = 0, 0\\n            for i in range(x):\\n                if i in smallSet:\\n                    sm += smInc\\n                    bg += bgInc\\n                elif i in bigSet:\\n                    sm += bgInc\\n                    bg += bgInc\\n            if x in smallSet:\\n                smallNum += sm\\n                bigNum += bg\\n            elif x in bigSet:\\n                smallNum = bigNum + sm\\n                bigNum += bg\\n            else:\\n                smallNum = sm\\n                bigNum = bg\\n            smInc, bgInc = 4*bgInc + 3*smInc, bgInc * 7\\n        return smallNum\\n```",
                "codeTag": "Java"
            },
            {
                "id": 439436,
                "title": "java-simple-solution",
                "content": "```\\npublic int rotatedDigits(int N) {\\n\\tint count = 0;\\n\\n\\tfor (int i = 1; i <= N; i ++) \\n\\t\\tif (isValid(i)) count ++;\\n\\n\\treturn count;\\n}\\n\\npublic boolean isValid(int N) {\\n\\t/*\\n\\t Valid if N contains ATLEAST ONE 2, 5, 6, 9\\n\\t AND NO 3, 4 or 7s\\n\\t */\\n\\tboolean validFound = false;\\n\\twhile (N > 0) {\\n\\t\\tint d = N%10;\\n\\t\\tif (d==2 || d==5 || d==6 || d==9) validFound = true;\\n\\t\\tif (d==3 || d==4 || d==7) return false;\\n\\t\\tN = N / 10;\\n\\t}\\n\\treturn validFound;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int rotatedDigits(int N) {\\n\\tint count = 0;\\n\\n\\tfor (int i = 1; i <= N; i ++) \\n\\t\\tif (isValid(i)) count ++;\\n\\n\\treturn count;\\n}\\n\\npublic boolean isValid(int N) {\\n\\t/*\\n\\t Valid if N contains ATLEAST ONE 2, 5, 6, 9\\n\\t AND NO 3, 4 or 7s\\n\\t */\\n\\tboolean validFound = false;\\n\\twhile (N > 0) {\\n\\t\\tint d = N%10;\\n\\t\\tif (d==2 || d==5 || d==6 || d==9) validFound = true;\\n\\t\\tif (d==3 || d==4 || d==7) return false;\\n\\t\\tN = N / 10;\\n\\t}\\n\\treturn validFound;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 373397,
                "title": "simple-c-solution",
                "content": "```\\npublic class Solution {\\n    public int RotatedDigits (int N) {\\n        int counter = 0;\\n        for (int i = 1; i <= N; i++) {\\n            if (isGoodNumber (i)) {\\n                counter++;\\n            }\\n        }\\n        return counter;\\n    }\\n\\n    private bool isGoodNumber (int num) {\\n        int origNum = num;\\n        int newNum = 0;\\n        int p = 0;\\n        while (num > 0) {\\n            int rem = num % 10;\\n            int rotatedDigit = getRotatedDigit (rem);\\n            if (rotatedDigit < 0) {\\n                return false;\\n            }\\n            newNum = newNum + rotatedDigit * (int) System.Math.Pow (10.0, p);\\n            num = num / 10;\\n            p++;\\n        }\\n        return origNum != newNum;\\n    }\\n    private int getRotatedDigit (int digit) {\\n        if (digit == 0 || digit == 1 || digit == 8) {\\n            return digit;\\n        }\\n        if (digit == 2) {\\n            return 5;\\n        }\\n        if (digit == 5) {\\n            return 2;\\n        }\\n        if (digit == 6) {\\n            return 9;\\n        }\\n        if (digit == 9) {\\n            return 6;\\n        }\\n        return -1;\\n\\n    }\\n\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int RotatedDigits (int N) {\\n        int counter = 0;\\n        for (int i = 1; i <= N; i++) {\\n            if (isGoodNumber (i)) {\\n                counter++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 369220,
                "title": "c-beats-100-speed-and-memory",
                "content": "```\\nclass Solution {\\n    \\n    // from 0 to 9\\n    int single_digit_code (int x){\\n        if(x==3 || x==4 || x==7) return 0;\\n        if(x==2 || x==5 || x==6 || x==9) return 1;\\n        return 2;\\n        \\n    }\\n    \\npublic:\\n    int rotatedDigits(int N) {\\n        int count = 0;\\n        for(int i=1; i<=N; i++){\\n            bool is_good = false;\\n            int x=i;\\n            while(x>0){\\n                int code = single_digit_code(x%10);\\n                if(code==0) {\\n                    is_good = false; \\n                    break;\\n                }\\n                if(code==1){\\n                    is_good = true;\\n                }\\n                x/=10;\\n            }\\n            if(is_good) ++count;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    // from 0 to 9\\n    int single_digit_code (int x){\\n        if(x==3 || x==4 || x==7) return 0;\\n        if(x==2 || x==5 || x==6 || x==9) return 1;\\n        return 2;\\n        \\n    }\\n    \\npublic:\\n    int rotatedDigits(int N) {\\n        int count = 0;\\n        for(int i=1; i<=N; i++){\\n            bool is_good = false;\\n            int x=i;\\n            while(x>0){\\n                int code = single_digit_code(x%10);\\n                if(code==0) {\\n                    is_good = false; \\n                    break;\\n                }\\n                if(code==1){\\n                    is_good = true;\\n                }\\n                x/=10;\\n            }\\n            if(is_good) ++count;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 364386,
                "title": "lg-n-same-as-lc902",
                "content": "```\\nclass Solution:\\n     def rotatedDigits(self, N: int) -> int:          \\n        N = str(N)\\n        def cal(num):\\n            dp = [0 for _ in N]\\n            dp.append(1)\\n            for i in range(len(N)-1,-1,-1):\\n                res = 0\\n                for j in num:\\n                    if j<int(N[i]):\\n                        res += 1\\n                    elif j == int(N[i]):\\n                        dp[i] = dp[i+1]\\n                if i == 0:\\n                    res -= 1\\n                dp[i] += res*(len(num)**(len(N)-i-1))\\n             return dp[0] + sum([len(num) ** i - len(num) **(i-1) for i in range(1,len(N))])\\n        return cal([0,1,2,5,6,8,9]) -cal([0,1,8])\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n     def rotatedDigits(self, N: int) -> int:          \\n        N = str(N)\\n        def cal(num):\\n            dp = [0 for _ in N]\\n            dp.append(1)\\n            for i in range(len(N)-1,-1,-1):\\n                res = 0\\n                for j in num:\\n                    if j<int(N[i]):\\n                        res += 1\\n                    elif j == int(N[i]):\\n                        dp[i] = dp[i+1]\\n                if i == 0:\\n                    res -= 1\\n                dp[i] += res*(len(num)**(len(N)-i-1))\\n             return dp[0] + sum([len(num) ** i - len(num) **(i-1) for i in range(1,len(N))])\\n        return cal([0,1,2,5,6,8,9]) -cal([0,1,8])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 329264,
                "title": "simple-with-contains",
                "content": "```\\npublic class Solution {\\n    public int RotatedDigits(int N) {\\n        int counter = 0;\\n            for (int i = 0; i <= N; i++)\\n            {\\n                Boolean compare = false;\\n                foreach (var item in i.ToString())\\n                {\\n                    if (\"347\".Contains(item))\\n                    {compare = false;\\n                        break;\\n                    }\\n                    if (\"2569\".Contains(item))\\n                    {\\n                        compare=true;\\n                    }\\n                }\\n                if (compare)\\n                {\\n                    counter++;\\n                }\\n            }\\n            return counter;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int RotatedDigits(int N) {\\n        int counter = 0;\\n            for (int i = 0; i <= N; i++)\\n            {\\n                Boolean compare = false;\\n                foreach (var item in i.ToString())\\n                {\\n                    if (\"347\".Contains(item))\\n                    {compare = false;\\n                        break;\\n                    }\\n                    if (\"2569\".Contains(item))\\n                    {\\n                        compare=true;\\n                    }\\n                }\\n                if (compare)\\n                {\\n                    counter++;\\n                }\\n            }\\n            return counter;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 325844,
                "title": "java-backtracking",
                "content": "I like DP solution better. Just post another way as food for thought.\\n```\\nclass Solution {\\n    int[] rotate = new int[]{0, 1, 5, -1, -1, 2, 9, -1, 8, 6};\\n    int[] digits = new int[]{0, 1, 2, 5, 6, 8, 9};\\n    \\n    int res;\\n    public int rotatedDigits(int N) {\\n        res = 0;\\n        dfs(0, N);\\n        return res;\\n    }\\n    \\n    private void dfs(int cur, int N) {\\n        if (cur > 0 && check(cur)) {\\n            res++;\\n        }\\n        \\n        for (int i = (cur == 0 ? 1 : 0); i < digits.length; i++) {\\n            if (cur * 10 + digits[i] <= N) {\\n                dfs(cur * 10 + digits[i], N);\\n            }\\n        }\\n    }\\n    \\n    private boolean check(int N) {\\n        int t = N, r = 0, k = 1;\\n        \\n        while (t > 0) {\\n            r = r + rotate[t % 10] * k;\\n            k *= 10;\\n            t /= 10;\\n        }\\n        \\n        return r != N;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int[] rotate = new int[]{0, 1, 5, -1, -1, 2, 9, -1, 8, 6};\\n    int[] digits = new int[]{0, 1, 2, 5, 6, 8, 9};\\n    \\n    int res;\\n    public int rotatedDigits(int N) {\\n        res = 0;\\n        dfs(0, N);\\n        return res;\\n    }\\n    \\n    private void dfs(int cur, int N) {\\n        if (cur > 0 && check(cur)) {\\n            res++;\\n        }\\n        \\n        for (int i = (cur == 0 ? 1 : 0); i < digits.length; i++) {\\n            if (cur * 10 + digits[i] <= N) {\\n                dfs(cur * 10 + digits[i], N);\\n            }\\n        }\\n    }\\n    \\n    private boolean check(int N) {\\n        int t = N, r = 0, k = 1;\\n        \\n        while (t > 0) {\\n            r = r + rotate[t % 10] * k;\\n            k *= 10;\\n            t /= 10;\\n        }\\n        \\n        return r != N;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 325045,
                "title": "python-solution-using-dictionary",
                "content": "Please comment for any doubt\\n\\n```\\nclass Solution:\\n    def rotatedDigits(self, N: int) -> int:\\n        count=0\\n        d={0:0,1:1,2:5,3:-1,4:-1,5:2,6:9,7:-1,8:8,9:6}\\n        for i in range(1,N+1):\\n            l=list(str(i))\\n            res=[]\\n            for j in l:\\n                if d[int(j)]!=-1:\\n                    res.append(str(d[int(j)]))\\n                else:break\\n            if len(res)==len(l) and int(\\'\\'.join(res))!=i:\\n                count+=1\\n        return count\\n                        \\n                    \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rotatedDigits(self, N: int) -> int:\\n        count=0\\n        d={0:0,1:1,2:5,3:-1,4:-1,5:2,6:9,7:-1,8:8,9:6}\\n        for i in range(1,N+1):\\n            l=list(str(i))\\n            res=[]\\n            for j in l:\\n                if d[int(j)]!=-1:\\n                    res.append(str(d[int(j)]))\\n                else:break\\n            if len(res)==len(l) and int(\\'\\'.join(res))!=i:\\n                count+=1\\n        return count\\n                        \\n                    \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 303213,
                "title": "c-solution-with-o-logn-time-o-1-space",
                "content": "```\\nclass Solution {\\npublic:\\n    int rotatedDigits(int N) {\\n        int same[10] = {1, 2, 2, 2, 2, 2, 2, 2, 3, 3};\\n        int dif[10] = {0, 0, 1, 1, 1, 2, 3, 3, 3, 4};\\n        int judge[10] = {2, 2, 1, 0, 0, 1, 1, 0, 2, 1};\\n        \\n        int res = 0;\\n        int valid = 2;\\n        int first = 0;\\n        \\n        for (int i = 4; i >= 1; i--) {\\n            int div = pow(10, i);\\n            int num = N / div;\\n            if (num > 0 && (first == 0 || (first != 0 && valid > 0))) {\\n                if (first == 0)\\n                    first = 1;\\n                if (valid == 2)\\n                    res += (same[num - 1] + dif[num - 1]) * pow(7, i) - same[num - 1] * pow(3, i);\\n                else if (valid == 1) \\n                    res += (same[num - 1] + dif[num - 1]) * pow(7, i);\\n                valid = min(valid, judge[num]);\\n                N -= num * div;\\n            }     \\n        }\\n        \\n\\t\\t// When it comes to ones place, we need some changes.\\n        if (N >= 0 && (first == 0 || (first != 0 && valid > 0))) {\\n            if (valid == 2)\\n                res += dif[N];\\n            else if (valid == 1) {\\n                res += dif[N] + same[N];\\n            }\\n        }\\n            \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int rotatedDigits(int N) {\\n        int same[10] = {1, 2, 2, 2, 2, 2, 2, 2, 3, 3};\\n        int dif[10] = {0, 0, 1, 1, 1, 2, 3, 3, 3, 4};\\n        int judge[10] = {2, 2, 1, 0, 0, 1, 1, 0, 2, 1};\\n        \\n        int res = 0;\\n        int valid = 2;\\n        int first = 0;\\n        \\n        for (int i = 4; i >= 1; i--) {\\n            int div = pow(10, i);\\n            int num = N / div;\\n            if (num > 0 && (first == 0 || (first != 0 && valid > 0))) {\\n                if (first == 0)\\n                    first = 1;\\n                if (valid == 2)\\n                    res += (same[num - 1] + dif[num - 1]) * pow(7, i) - same[num - 1] * pow(3, i);\\n                else if (valid == 1) \\n                    res += (same[num - 1] + dif[num - 1]) * pow(7, i);\\n                valid = min(valid, judge[num]);\\n                N -= num * div;\\n            }     \\n        }\\n        \\n\\t\\t// When it comes to ones place, we need some changes.\\n        if (N >= 0 && (first == 0 || (first != 0 && valid > 0))) {\\n            if (valid == 2)\\n                res += dif[N];\\n            else if (valid == 1) {\\n                res += dif[N] + same[N];\\n            }\\n        }\\n            \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 289369,
                "title": "12-lines-solution-regex-too-slow-but-i-like-use-it-hhh",
                "content": "```\\nclass Solution {\\n    public int rotatedDigits(int N) {\\n        String regexOfGoodNum = \"([018]*[2569]+[018]*)*\";\\n        int ans = 0;\\n        for (int i = 1; i <= N; i++) {\\n            if (Integer.toString(i).matches(regexOfGoodNum)) {\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int rotatedDigits(int N) {\\n        String regexOfGoodNum = \"([018]*[2569]+[018]*)*\";\\n        int ans = 0;\\n        for (int i = 1; i <= N; i++) {\\n            if (Integer.toString(i).matches(regexOfGoodNum)) {\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 279346,
                "title": "python-self-explanatory",
                "content": "```\\n    def rotatedDigits(self, N):\\n        \"\"\"\\n        :type N: int\\n        :rtype: int\\n        \"\"\"\\n        count = 0\\n        for i in range(1,N+1):\\n            s = str(i)\\n            # print s \\n            if \\'3\\' in  s or \\'4\\' in s or  \\'7\\' in s :\\n                count += 0\\n            elif  \\'2\\' in s or \\'5\\' in s or \\'6\\' in s or \\'9\\' in s:\\n                count += 1\\n                # print \\'count\\'\\n            # print i\\n        return count\\n\\t\\t```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n    def rotatedDigits(self, N):\\n        \"\"\"\\n        :type N: int\\n        :rtype: int\\n        \"\"\"\\n        count = 0\\n        for i in range(1,N+1):\\n            s = str(i)\\n            # print s \\n            if \\'3\\' in  s or \\'4\\' in s or  \\'7\\' in s :\\n                count += 0\\n            elif  \\'2\\' in s or \\'5\\' in s or \\'6\\' in s or \\'9\\' in s:\\n                count += 1\\n                # print \\'count\\'\\n            # print i\\n        return count\\n\\t\\t```",
                "codeTag": "Python3"
            },
            {
                "id": 264053,
                "title": "python-solution",
                "content": "\\t\\'\\'\\'\\n\\tclass Solution:\\n\\t\\tdef rotatedDigits(self, N: int) -> int:\\n\\t\\t\\tgood_numbers = []\\n\\t\\t\\tnums = [str(i) for i in range(N+1)]\\n\\n\\t\\t\\tfor num in nums:\\n\\t\\t\\t\\tif (\\'3\\' not in num and \\'4\\' not in num and \\'7\\' not in num) and (\\'2\\' in num or \\'5\\' in num or \\'6\\' in num or \\'9\\' in num):\\n\\t\\t\\t\\t\\tgood_numbers.append(num)\\n\\n\\t\\t\\treturn len(good_numbers)\\n\\t\\'\\'\\'",
                "solutionTags": [],
                "code": "\\t\\'\\'\\'\\n\\tclass Solution:\\n\\t\\tdef rotatedDigits(self, N: int) -> int:\\n\\t\\t\\tgood_numbers = []\\n\\t\\t\\tnums = [str(i) for i in range(N+1)]\\n\\n\\t\\t\\tfor num in nums:\\n\\t\\t\\t\\tif (\\'3\\' not in num and \\'4\\' not in num and \\'7\\' not in num) and (\\'2\\' in num or \\'5\\' in num or \\'6\\' in num or \\'9\\' in num):\\n\\t\\t\\t\\t\\tgood_numbers.append(num)\\n\\n\\t\\t\\treturn len(good_numbers)\\n\\t\\'\\'\\'",
                "codeTag": "Java"
            },
            {
                "id": 243992,
                "title": "a-simple-java-solution",
                "content": "```\\n\\nclass Solution {\\n    boolean is(int n) {\\n        int[] tab = new int[10];\\n        for(char c: Integer.toString(n).toCharArray()) {\\n            tab[c - \\'0\\'] = 1;\\n        }\\n        if (tab[3] == 1 || tab[4] == 1 || tab[7] == 1) return false;\\n        if (tab[6] + tab[9] + tab[2] + tab[5] == 0 && tab[1] + tab[0] + tab[8] > 0) return false;\\n        return true;\\n    }\\n    public int rotatedDigits(int N) {\\n        int res = 0;\\n        for(int i = 0; i <= N; i++) {\\n            if (is(i)) res++;\\n        }\\n        return res;\\n    }\\n}\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\n    boolean is(int n) {\\n        int[] tab = new int[10];\\n        for(char c: Integer.toString(n).toCharArray()) {\\n            tab[c - \\'0\\'] = 1;\\n        }\\n        if (tab[3] == 1 || tab[4] == 1 || tab[7] == 1) return false;\\n        if (tab[6] + tab[9] + tab[2] + tab[5] == 0 && tab[1] + tab[0] + tab[8] > 0) return false;\\n        return true;\\n    }\\n    public int rotatedDigits(int N) {\\n        int res = 0;\\n        for(int i = 0; i <= N; i++) {\\n            if (is(i)) res++;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 214588,
                "title": "clean-c-solution-beats-100-o-n-helper-func",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canRotate(int N){\\n        bool dif{false};\\n        while(N){\\n            int cur = N%10;\\n            if (cur == 2 || cur == 5 || cur == 6 || cur == 9)\\n                dif = true;\\n            else if (cur == 3 || cur == 4 || cur == 7)\\n                return false;\\n            N /= 10;\\n        }\\n        return dif;\\n    }\\n    int rotatedDigits(int N) {\\n        int count{0};\\n        for (int i = 1; i <= N; i++)\\n            if (canRotate(i)) count++;\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canRotate(int N){\\n        bool dif{false};\\n        while(N){\\n            int cur = N%10;\\n            if (cur == 2 || cur == 5 || cur == 6 || cur == 9)\\n                dif = true;\\n            else if (cur == 3 || cur == 4 || cur == 7)\\n                return false;\\n            N /= 10;\\n        }\\n        return dif;\\n    }\\n    int rotatedDigits(int N) {\\n        int count{0};\\n        for (int i = 1; i <= N; i++)\\n            if (canRotate(i)) count++;\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 211747,
                "title": "rust-12ms-solution",
                "content": "```Rust\\nimpl Solution {\\n    pub fn rotated_digits(n: i32) -> i32 {\\n        let mut count = 0;\\n        for i in 1..(n + 1) {\\n            let n_s = i.to_string();\\n            if n_s.contains(\"3\") || n_s.contains(\"7\") || n_s.contains(\"4\") {\\n                continue;\\n            }\\n            \\n            if n_s.contains(\"2\") || n_s.contains(\"5\") || n_s.contains(\"6\") || n_s.contains(\"9\") {\\n                count += 1;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```Rust\\nimpl Solution {\\n    pub fn rotated_digits(n: i32) -> i32 {\\n        let mut count = 0;\\n        for i in 1..(n + 1) {\\n            let n_s = i.to_string();\\n            if n_s.contains(\"3\") || n_s.contains(\"7\") || n_s.contains(\"4\") {\\n                continue;\\n            }\\n            \\n            if n_s.contains(\"2\") || n_s.contains(\"5\") || n_s.contains(\"6\") || n_s.contains(\"9\") {\\n                count += 1;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 208065,
                "title": "java-easiest-simplest",
                "content": "```\\nclass Solution {\\n    public int rotatedDigits(int N) {\\n        Set<Integer> good = new HashSet<Integer>(Arrays.asList(2,5,6,9));\\n        Set<Integer> bad = new HashSet<Integer>(Arrays.asList(3,4,7));\\n        int count=0;\\n        for(int i=1;i<=N;i++) {\\n            boolean gud=false;\\n            int num=i;\\n            while(num!=0) {\\n                int digit = num%10;\\n                if(bad.contains(digit))\\n                {\\n                    gud=false; break;\\n                }\\n                else if(good.contains(digit))\\n                       gud=true;\\n                num=num/10;\\n            }\\n            if(gud)\\n                count++; \\n        }\\n        return count;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int rotatedDigits(int N) {\\n        Set<Integer> good = new HashSet<Integer>(Arrays.asList(2,5,6,9));\\n        Set<Integer> bad = new HashSet<Integer>(Arrays.asList(3,4,7));\\n        int count=0;\\n        for(int i=1;i<=N;i++) {\\n            boolean gud=false;\\n            int num=i;\\n            while(num!=0) {\\n                int digit = num%10;\\n                if(bad.contains(digit))\\n                {\\n                    gud=false; break;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 146290,
                "title": "788-rotated-digits-java-c-python",
                "content": "Firstly, keep rotation for 0-9. 3, 4, 7 don`t have valid rotation. When we check a number, check if each digit rotation is valid. When we meet with a invalid roation, just return false. 127, because it has 7, so it is not good. Also, we should exclude the ones which is equal to itself after rotation. For example, 10, 101, 1081, etc. In that case, return false.\\n#### C++\\n```cpp\\nclass Solution {\\nprivate:\\n    char rotates[10] = {\\'0\\', \\'1\\', \\'5\\', \\'-\\', \\'-\\', \\'2\\', \\'9\\', \\'-\\', \\'8\\', \\'6\\'};\\npublic:\\n    int rotatedDigits(int N) {\\n        int cnt = 0;\\n        for(int i = 1; i <= N; i++) {\\n            cnt += good(i);\\n        }\\n        return cnt;\\n    }\\n    \\n    bool good(int N) {\\n        string s = to_string(N);\\n        int same = 0;\\n        for(auto c : s) {\\n            if(rotates[c-\\'0\\'] == \\'-\\') {//invalid rotation, return false\\n                return false;\\n            }\\n            else if(rotates[c-\\'0\\'] == c){\\n                same++; // keep identical after rotation\\n            }\\n        }\\n        return same != s.size();\\n    }\\n};\\n```\\n#### Java\\n```java\\nclass Solution {\\n    private char rotates[] = {\\'0\\', \\'1\\', \\'5\\', \\'-\\', \\'-\\', \\'2\\', \\'9\\', \\'-\\', \\'8\\', \\'6\\'};// keep rotate num for each num\\n    public int rotatedDigits(int N) {\\n        int cnt = 0;\\n        for(int i = 1; i <= N; i++) {\\n            if(good(i)) {\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n    \\n    private boolean good(int N) {\\n        String s = String.valueOf(N);\\n        int same = 0;\\n        int len = s.length();\\n        for(int i = 0; i < len; i++) {\\n            if(rotates[s.charAt(i)-\\'0\\'] == s.charAt(i)) {// keep identical after rotation\\n                same++;\\n            }\\n            else if(rotates[s.charAt(i)-\\'0\\'] == \\'-\\'){// invalid rotation\\n                return false;\\n            }\\n        }\\n        return same != len;\\n    }\\n}\\n```\\n#### Python\\n```python\\nclass Solution(object):\\n    rotates = \"015--29-86\"\\n    def rotatedDigits(self, N):\\n        \"\"\"\\n        :type N: int\\n        :rtype: int\\n        \"\"\"\\n        cnt = 0\\n        for i in range(1, N+1):\\n            if self.good(i):\\n                cnt += 1\\n        return cnt\\n                \\n    \\n    def good(self, N):\\n        strN = str(N)\\n        same = 0\\n        for c in strN:\\n            if self.rotates[int(c)] == \\'-\\': # invalid rotation\\n                return False\\n            elif self.rotates[int(c)] == c: # identical after rotation\\n                same += 1\\n        return same != len(strN)\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\nprivate:\\n    char rotates[10] = {\\'0\\', \\'1\\', \\'5\\', \\'-\\', \\'-\\', \\'2\\', \\'9\\', \\'-\\', \\'8\\', \\'6\\'};\\npublic:\\n    int rotatedDigits(int N) {\\n        int cnt = 0;\\n        for(int i = 1; i <= N; i++) {\\n            cnt += good(i);\\n        }\\n        return cnt;\\n    }\\n    \\n    bool good(int N) {\\n        string s = to_string(N);\\n        int same = 0;\\n        for(auto c : s) {\\n            if(rotates[c-\\'0\\'] == \\'-\\') {//invalid rotation, return false\\n                return false;\\n            }\\n            else if(rotates[c-\\'0\\'] == c){\\n                same++; // keep identical after rotation\\n            }\\n        }\\n        return same != s.size();\\n    }\\n};\\n```\n```java\\nclass Solution {\\n    private char rotates[] = {\\'0\\', \\'1\\', \\'5\\', \\'-\\', \\'-\\', \\'2\\', \\'9\\', \\'-\\', \\'8\\', \\'6\\'};// keep rotate num for each num\\n    public int rotatedDigits(int N) {\\n        int cnt = 0;\\n        for(int i = 1; i <= N; i++) {\\n            if(good(i)) {\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n    \\n    private boolean good(int N) {\\n        String s = String.valueOf(N);\\n        int same = 0;\\n        int len = s.length();\\n        for(int i = 0; i < len; i++) {\\n            if(rotates[s.charAt(i)-\\'0\\'] == s.charAt(i)) {// keep identical after rotation\\n                same++;\\n            }\\n            else if(rotates[s.charAt(i)-\\'0\\'] == \\'-\\'){// invalid rotation\\n                return false;\\n            }\\n        }\\n        return same != len;\\n    }\\n}\\n```\n```python\\nclass Solution(object):\\n    rotates = \"015--29-86\"\\n    def rotatedDigits(self, N):\\n        \"\"\"\\n        :type N: int\\n        :rtype: int\\n        \"\"\"\\n        cnt = 0\\n        for i in range(1, N+1):\\n            if self.good(i):\\n                cnt += 1\\n        return cnt\\n                \\n    \\n    def good(self, N):\\n        strN = str(N)\\n        same = 0\\n        for c in strN:\\n            if self.rotates[int(c)] == \\'-\\': # invalid rotation\\n                return False\\n            elif self.rotates[int(c)] == c: # identical after rotation\\n                same += 1\\n        return same != len(strN)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 142756,
                "title": "python-beats-87",
                "content": "```\\ndef rotatedDigits(self, N):\\n\\tcount = 0\\n\\tfor i in range(1, N + 1):\\n\\t\\tif self.rotate(str(i)):\\n\\t\\t    count += 1\\n        return count\\n```\\n\\n```\\ndef rotate(self, n):\\n            if \\'4\\' in n or \\'7\\' in n or \\'3\\' in n:\\n                return False\\n            elif \\'2\\' in n or \\'5\\' in n or \\'6\\' in n or \\'9\\' in n:\\n                return True\\n            else:\\n                return None\\n```",
                "solutionTags": [],
                "code": "```\\ndef rotatedDigits(self, N):\\n\\tcount = 0\\n\\tfor i in range(1, N + 1):\\n\\t\\tif self.rotate(str(i)):\\n\\t\\t    count += 1\\n        return count\\n```\n```\\ndef rotate(self, n):\\n            if \\'4\\' in n or \\'7\\' in n or \\'3\\' in n:\\n                return False\\n            elif \\'2\\' in n or \\'5\\' in n or \\'6\\' in n or \\'9\\' in n:\\n                return True\\n            else:\\n                return None\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 139574,
                "title": "rotated-digits-simple-python-with-explanation",
                "content": "* A number is invalid if it contains at least one of (3, 4, 7)\\n* A number is valid and counted if it contains at least on of (2, 5, 6, 9)\\n* A number is valid, but not counted if all it\\u2019s digits comprise only (0, 1, 8)\\n\\n**Step 1:**\\nConsider numbers in batches of 10, they either have 4, 7 or 0 good numbers.\\n\\tExample:\\n\\tFrom 10 to 19, there are 4 good numbers\\n\\tFrom 20 to 29, there are 7 good numbers\\n\\tFrom 30 to 39, there are 0 good numbers etc.\\n**Step 2:**\\nAfter completing all batches of 10, count the remaining good numbers left in N-9 to N\\n i.e count increases by 1 only if the number is one of (2, 5, 6, 9)\\n\\n```\\n    def rotatedDigits(self, N):\\n        \"\"\"\\n        :type N: int\\n        :rtype: int\\n        \"\"\"\\n        if N < 10:\\n            return self.rotated(1, N+1, 1, 0)\\n        else:\\n            return self.rotated(0, N//10, 7, 4) + self.rotated(N-(N%10), N+1, 1, 0)\\n        \\n    def rotated(self, start, end, valid_res, invalid_res):\\n        invalid, valid, result = {3,4,7}, {2,5,6,9}, 0\\n        for i in range(start, end):\\n            digits = {int(x) for x in str(i)}\\n            if bool(digits & invalid):\\n                continue\\n            result += valid_res if bool(digits & valid) else invalid_res\\n        return result\\n```\\n",
                "solutionTags": [],
                "code": "```\\n    def rotatedDigits(self, N):\\n        \"\"\"\\n        :type N: int\\n        :rtype: int\\n        \"\"\"\\n        if N < 10:\\n            return self.rotated(1, N+1, 1, 0)\\n        else:\\n            return self.rotated(0, N//10, 7, 4) + self.rotated(N-(N%10), N+1, 1, 0)\\n        \\n    def rotated(self, start, end, valid_res, invalid_res):\\n        invalid, valid, result = {3,4,7}, {2,5,6,9}, 0\\n        for i in range(start, end):\\n            digits = {int(x) for x in str(i)}\\n            if bool(digits & invalid):\\n                continue\\n            result += valid_res if bool(digits & valid) else invalid_res\\n        return result\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 138543,
                "title": "my-python-solution",
                "content": "```\\nclass Solution:\\n    def rotatedDigits(self, N):\\n        \"\"\"\\n        :type N: int\\n        :rtype: int\\n        \"\"\"\\n        ret=0\\n        for i in range(1, N + 1):\\n            l = 0\\n            flag = 1\\n            for v in str(i):\\n                if v not in \\'0182569\\':\\n                    flag = 0\\n                    break\\n                if v in \\'018\\':\\n                    l += 1\\n            if l == len(str(i)):\\n                flag = 0\\n            if flag:\\n                ret+=1\\n        return ret\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def rotatedDigits(self, N):\\n        \"\"\"\\n        :type N: int\\n        :rtype: int\\n        \"\"\"\\n        ret=0\\n        for i in range(1, N + 1):\\n            l = 0\\n            flag = 1\\n            for v in str(i):\\n                if v not in \\'0182569\\':\\n                    flag = 0\\n                    break\\n                if v in \\'018\\':\\n                    l += 1\\n            if l == len(str(i)):\\n                flag = 0\\n            if flag:\\n                ret+=1\\n        return ret\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 131565,
                "title": "easy-java",
                "content": "public int rotatedDigits(int N) {\\n    int result = 0;\\n\\n    for (int i = 2; i <= N; i++) {\\n      String str = \"\" + i;\\n      str = str.replace(\\'3\\', \\' \\').replace(\\'4\\', \\' \\').replace(\\'7\\', \\' \\');\\n      if (!str.equals(\"\" + i)) {\\n        continue;\\n      }\\n      str = str.replace(\\'2\\', \\'3\\').replace(\\'5\\', \\'2\\').replace(\\'3\\', \\'5\\');\\n      str = str.replace(\\'6\\', \\'3\\').replace(\\'9\\', \\'6\\').replace(\\'3\\', \\'9\\');\\n      if (!str.equals(\"\" + i)) {\\n        result++;\\n      }\\n    }\\n    return result;\\n  }",
                "solutionTags": [],
                "code": "public int rotatedDigits(int N) {\\n    int result = 0;\\n\\n    for (int i = 2; i <= N; i++) {\\n      String str = \"\" + i;\\n      str = str.replace(\\'3\\', \\' \\').replace(\\'4\\', \\' \\').replace(\\'7\\', \\' \\');\\n      if (!str.equals(\"\" + i)) {\\n        continue;\\n      }\\n      str = str.replace(\\'2\\', \\'3\\').replace(\\'5\\', \\'2\\').replace(\\'3\\', \\'5\\');\\n      str = str.replace(\\'6\\', \\'3\\').replace(\\'9\\', \\'6\\').replace(\\'3\\', \\'9\\');\\n      if (!str.equals(\"\" + i)) {\\n        result++;\\n      }\\n    }\\n    return result;\\n  }",
                "codeTag": "Unknown"
            },
            {
                "id": 130879,
                "title": "kotlin-solution",
                "content": "```\\nclass Solution {\\n    fun rotatedDigits(N: Int): Int {\\n        return (1..N).map {\\n            val original = it.toString()\\n            val rotated = rotate(original)\\n            rotated != null && rotated != original\\n        }.count { it }\\n    }\\n\\n    private fun rotate(s: String): String? {\\n        return if (s.map { rules.containsKey(it) }.all { it }) s.map { rules[it] }.joinToString(\"\") else null\\n    }\\n\\n    companion object {\\n        val rules = hashMapOf(\\n                Pair(\\'0\\', \\'0\\'),\\n                Pair(\\'1\\', \\'1\\'),\\n                Pair(\\'8\\', \\'8\\'),\\n                Pair(\\'2\\', \\'5\\'),\\n                Pair(\\'5\\', \\'2\\'),\\n                Pair(\\'6\\', \\'9\\'),\\n                Pair(\\'9\\', \\'6\\'))\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun rotatedDigits(N: Int): Int {\\n        return (1..N).map {\\n            val original = it.toString()\\n            val rotated = rotate(original)\\n            rotated != null && rotated != original\\n        }.count { it }\\n    }\\n\\n    private fun rotate(s: String): String? {\\n        return if (s.map { rules.containsKey(it) }.all { it }) s.map { rules[it] }.joinToString(\"\") else null\\n    }\\n\\n    companion object {\\n        val rules = hashMapOf(\\n                Pair(\\'0\\', \\'0\\'),\\n                Pair(\\'1\\', \\'1\\'),\\n                Pair(\\'8\\', \\'8\\'),\\n                Pair(\\'2\\', \\'5\\'),\\n                Pair(\\'5\\', \\'2\\'),\\n                Pair(\\'6\\', \\'9\\'),\\n                Pair(\\'9\\', \\'6\\'))\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 130513,
                "title": "beats-99-64-short-python-solution-o-log10n-complexity",
                "content": "    def rotatedDigits(self, N):\\n        possible=set([0,1,2,5,6,8,9])\\n        not_possible=set([0,1,8])\\n        digits=[int(x) for x in str(N)]\\n        n=len(digits)\\n        def getCount(i,p):\\n            if i==n:return 1\\n            if p: return (len([x for x in possible if x<digits[i]])*(7**(len(digits)-1-i)))+\\\\\\n                        (getCount(i+1,True) if digits[i] in possible else 0)\\n            else: return (len([x for x in not_possible if x<digits[i]])*(3**(len(digits)-1-i)))+\\\\\\n                        (getCount(i+1,False) if digits[i] in not_possible else 0)\\n        return getCount(0,True)-getCount(0,False)",
                "solutionTags": [],
                "code": "    def rotatedDigits(self, N):\\n        possible=set([0,1,2,5,6,8,9])\\n        not_possible=set([0,1,8])\\n        digits=[int(x) for x in str(N)]\\n        n=len(digits)\\n        def getCount(i,p):\\n            if i==n:return 1\\n            if p: return (len([x for x in possible if x<digits[i]])*(7**(len(digits)-1-i)))+\\\\\\n                        (getCount(i+1,True) if digits[i] in possible else 0)\\n            else: return (len([x for x in not_possible if x<digits[i]])*(3**(len(digits)-1-i)))+\\\\\\n                        (getCount(i+1,False) if digits[i] in not_possible else 0)\\n        return getCount(0,True)-getCount(0,False)",
                "codeTag": "Python3"
            },
            {
                "id": 125583,
                "title": "my-python-solution-fast-and-simple",
                "content": "if any digit in {3,4,7} in a num, the num must not valid after rotate.\\nbut if any digit in {2,5,6,9} in a num, the num  is a good number.\\n```\\ncount=0\\nfor i in range(1,N+1):\\n\\ts =str(i) \\n        if \\'3\\' in s or \\'4\\' in s or\\'7\\' in s :\\n\\t\\tcontinue\\n        elif \\'2\\' in s or \\'5\\' in s or\\'6\\' in s or \\'9\\' in s:\\n                count+=1   \\nreturn count\\n```\\n        ",
                "solutionTags": [],
                "code": "```\\ncount=0\\nfor i in range(1,N+1):\\n\\ts =str(i) \\n        if \\'3\\' in s or \\'4\\' in s or\\'7\\' in s :\\n\\t\\tcontinue\\n        elif \\'2\\' in s or \\'5\\' in s or\\'6\\' in s or \\'9\\' in s:\\n                count+=1   \\nreturn count\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 124512,
                "title": "python-code-beats-99-over-submissions",
                "content": "This problem is in fact a combinatoric problem.\\n```\\nclass Solution(object):\\n    def rotatedDigits(self, N):\\n        \"\"\"\\n        :type N: int\\n        :rtype: int\\n        \"\"\"\\n        \\n        N += 1\\n        \\n        sym = [0,1,2,5,6,8,9]\\n        sym1 = [0,1,8]\\n        \\n        my_list = list(str(N))\\n        \\n        result = 0\\n        flag = True\\n        for i,c in enumerate(my_list):\\n            tmp = [x for x in sym if x < int(c)]\\n            if tmp != []:\\n                result += len(tmp) * (len(sym))**(len(my_list)-1-i) \\\\\\n                    - (flag == True) * len(set(tmp) & set(sym1)) * (len(sym1))**(len(my_list)-1-i)\\n                    \\n            if int(c) not in sym1:\\n                flag = False\\n            if int(c) not in sym:\\n                break\\n                \\n        return result\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def rotatedDigits(self, N):\\n        \"\"\"\\n        :type N: int\\n        :rtype: int\\n        \"\"\"\\n        \\n        N += 1\\n        \\n        sym = [0,1,2,5,6,8,9]\\n        sym1 = [0,1,8]\\n        \\n        my_list = list(str(N))\\n        \\n        result = 0\\n        flag = True\\n        for i,c in enumerate(my_list):\\n            tmp = [x for x in sym if x < int(c)]\\n            if tmp != []:\\n                result += len(tmp) * (len(sym))**(len(my_list)-1-i) \\\\\\n                    - (flag == True) * len(set(tmp) & set(sym1)) * (len(sym1))**(len(my_list)-1-i)\\n                    \\n            if int(c) not in sym1:\\n                flag = False\\n            if int(c) not in sym:\\n                break\\n                \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 123567,
                "title": "regex-simple-short",
                "content": "Number is valid if both conditions are true:\\n1. It does not contain any of the digits 3,4,7\\n2. It contains at least one of the digits 2,5,6,9\\n```\\nclass Solution {\\n    public int rotatedDigits(int N) {\\n      int res = 0;\\n      for (int i = 1; i <= N; i++) {\\n        String s = \"\" + i;\\n        if (!s.matches(\".*[347]+.*\") && s.matches(\".*[2569]+.*\")) res++;\\n      }\\n      return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int rotatedDigits(int N) {\\n      int res = 0;\\n      for (int i = 1; i <= N; i++) {\\n        String s = \"\" + i;\\n        if (!s.matches(\".*[347]+.*\") && s.matches(\".*[2569]+.*\")) res++;\\n      }\\n      return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 118887,
                "title": "python-solution-use-set",
                "content": "according to the question, the good number must have at least one of (2, 5, 9, 6) and may be exist anyone or None of (1, 0, 8)\\n\\n```\\n        must_set = set(\\'2596\\')\\n        optional_set = set(\\'108\\')\\n        good_number = 0\\n        for i in range(1, N + 1):\\n            number_set = set(str(i))\\n            if (number_set & must_set) == set(\\'\\'):\\n                continue\\n            if (number_set | must_set) == must_set:\\n                good_number += 1\\n            elif ((number_set - must_set) | optional_set) == optional_set:\\n                good_number += 1\\n\\n        return good_number\\n```",
                "solutionTags": [],
                "code": "```\\n        must_set = set(\\'2596\\')\\n        optional_set = set(\\'108\\')\\n        good_number = 0\\n        for i in range(1, N + 1):\\n            number_set = set(str(i))\\n            if (number_set & must_set) == set(\\'\\'):\\n                continue\\n            if (number_set | must_set) == must_set:\\n                good_number += 1\\n            elif ((number_set - must_set) | optional_set) == optional_set:\\n                good_number += 1\\n\\n        return good_number\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 118431,
                "title": "my-dfs-java-solution",
                "content": "Pretty StraightForward. Starting from 0, always append new candidate to the end of current number. If it\\'s larger than N, return; If it\\'s valid, increament res.\\nI think the time complexity is O(res), cause we just find the exact res numbers.\\n```\\nclass Solution {\\n    \\n    int res = 0;\\n    int[] candidates = {0, 1, 2, 5, 6, 8, 9};\\n    Set<Integer> difWithSelf = new HashSet<>(Arrays.asList(2, 5, 6, 9));\\n    \\n    public int rotatedDigits(int N) {\\n        if (N == 1) {\\n            return 0;\\n        }\\n        count(N, 0, false);\\n        return res;\\n    }\\n    \\n    public void count(int N, int curVal, boolean valid) {\\n        if (curVal > N) {\\n            return;\\n        }\\n        if (curVal >= 1 && valid) {\\n            res++;\\n        }\\n        for (int candidate : candidates) {\\n            if (curVal == 0 && candidate == 0) {\\n                continue;\\n            }\\n            count(N, curVal * 10 + candidate, valid || difWithSelf.contains(candidate));\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    int res = 0;\\n    int[] candidates = {0, 1, 2, 5, 6, 8, 9};\\n    Set<Integer> difWithSelf = new HashSet<>(Arrays.asList(2, 5, 6, 9));\\n    \\n    public int rotatedDigits(int N) {\\n        if (N == 1) {\\n            return 0;\\n        }\\n        count(N, 0, false);\\n        return res;\\n    }\\n    \\n    public void count(int N, int curVal, boolean valid) {\\n        if (curVal > N) {\\n            return;\\n        }\\n        if (curVal >= 1 && valid) {\\n            res++;\\n        }\\n        for (int candidate : candidates) {\\n            if (curVal == 0 && candidate == 0) {\\n                continue;\\n            }\\n            count(N, curVal * 10 + candidate, valid || difWithSelf.contains(candidate));\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 118419,
                "title": "python-one-liner-but-not-efficient-for-space-complexity-128ms",
                "content": "Storing every good number might not be efficient but here it is: \\n\\t\\t\\t\\n\\tclass Solution:\\n\\t\\tdef rotatedDigits(self, N):\\n\\t\\t\\treturn len([num for num in range(1, N+1) if not set(str(num)) & {\"3\",\"4\",\"7\"} and set(str(num)) & {\"2\",\"5\",\"6\",\"9\"}])",
                "solutionTags": [],
                "code": "class Solution:\\n\\t\\tdef rotatedDigits(self, N):\\n\\t\\t\\treturn len([num for num in range(1, N+1) if not set(str(num)) & {\"3\",\"4\",\"7\"}",
                "codeTag": "Java"
            },
            {
                "id": 118243,
                "title": "easy-to-understand-java-solution",
                "content": "The idea is to count the number of invalid numbers. Iterate from 1 to N. Convert it to string. Iterate over the string. If there is any character 3,4,7 consider it invalid straighaway and so break out of the loop as we dont need to iterate over remaining part of string. If you encounter 2,5,6 or 9; do nothing. For that particular number if you encounter 1,8 or 0, count the number of such occurences. When you are done iterating over the string of particular number, if such occurences is equal to string length, that number is invalid .\\n```\\nclass Solution {\\n    public int rotatedDigits(int N) {\\n        int i = 1;\\n        int count = 0;\\n        while(i <= N){\\n            String s = Integer.toString(i);\\n            int unchanged = 0;\\n            for(int j=0; j<s.length(); j++){\\n                \\n                if(s.charAt(j) == \\'3\\' || s.charAt(j) == \\'4\\' || s.charAt(j) == \\'7\\'){\\n                    count++;\\n                    break;\\n                }\\n                else if(s.charAt(j) == \\'2\\' || s.charAt(j) == \\'5\\' || s.charAt(j) == \\'6\\' || s.charAt(j) == \\'9\\'){\\n                }\\n                else{\\n                    unchanged++;\\n                }\\n                \\n            }\\n            if(unchanged == s.length()){\\n                count++;\\n            }\\n            i++;\\n        }\\n        return N-count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int rotatedDigits(int N) {\\n        int i = 1;\\n        int count = 0;\\n        while(i <= N){\\n            String s = Integer.toString(i);\\n            int unchanged = 0;\\n            for(int j=0; j<s.length(); j++){\\n                \\n                if(s.charAt(j) == \\'3\\' || s.charAt(j) == \\'4\\' || s.charAt(j) == \\'7\\'){\\n                    count++;\\n                    break;\\n                }\\n                else if(s.charAt(j) == \\'2\\' || s.charAt(j) == \\'5\\' || s.charAt(j) == \\'6\\' || s.charAt(j) == \\'9\\'){\\n                }\\n                else{\\n                    unchanged++;\\n                }\\n                \\n            }\\n            if(unchanged == s.length()){\\n                count++;\\n            }\\n            i++;\\n        }\\n        return N-count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 117148,
                "title": "c-easy-to-understand-unordered-set",
                "content": "The idea here is to use ```unordered_set<int>``` to keep track of which are \n1. `st` -- numbers which can be rotated\n2. `non_st` -- numbers that cannot be rotated\n3. `sp` -- special numbers that are the same as it's rotation\n\nNow once we have this we just need to check if \n1. If there is a `non_st` number it cannot be rotated thus ```return false```\n2. If there is a `sp` number but no `st` number then it's the same so ```return false```\n3. If there is a `sp` number and a `st` number then it can possibly make a different number so ```return true```\n4. If there is only ```st``` numbers then ```return true```\n```\n bool checkDigits(const unordered_set<int>& st, const unordered_set<int>& not_st,const unordered_set<int>& sp, int pos) {\n        int st_count=0, sp_count = 0;\n        \n        while(pos > 0) {\n            int digit = pos%10;\n            \n            if(not_st.find(digit) != not_st.end())\n                return false;\n            \n            if(st.find(digit) != st.end())\n                ++st_count;\n            \n            if(sp.find(digit) != sp.end())\n                ++sp_count;\n            \n            pos /= 10;\n        }\n\n        if(sp_count > 0 && st_count < 1) {\n            return false;\n        }\n            \n        \n        return true;\n    }\n    \n    int rotatedDigits(int N) {\n        unordered_set<int>not_st{3,4,7}, st{2,5,6,9}, sp{0,1,8};\n        int valid =0;\n        for(int i=1; i<=N; ++i) {\n            if(checkDigits(st, not_st, sp, i)) {\n                //cout << i << \" \";\n                ++valid;\n            }\n        }\n        //cout << endl;\n        return valid;\n    }\n\n```",
                "solutionTags": [],
                "code": "```unordered_set<int>```\n```return false```\n```return false```\n```return true```\n```st```\n```return true```\n```\n bool checkDigits(const unordered_set<int>& st, const unordered_set<int>& not_st,const unordered_set<int>& sp, int pos) {\n        int st_count=0, sp_count = 0;\n        \n        while(pos > 0) {\n            int digit = pos%10;\n            \n            if(not_st.find(digit) != not_st.end())\n                return false;\n            \n            if(st.find(digit) != st.end())\n                ++st_count;\n            \n            if(sp.find(digit) != sp.end())\n                ++sp_count;\n            \n            pos /= 10;\n        }\n\n        if(sp_count > 0 && st_count < 1) {\n            return false;\n        }\n            \n        \n        return true;\n    }\n    \n    int rotatedDigits(int N) {\n        unordered_set<int>not_st{3,4,7}, st{2,5,6,9}, sp{0,1,8};\n        int valid =0;\n        for(int i=1; i<=N; ++i) {\n            if(checkDigits(st, not_st, sp, i)) {\n                //cout << i << \" \";\n                ++valid;\n            }\n        }\n        //cout << endl;\n        return valid;\n    }\n\n```",
                "codeTag": "C++"
            },
            {
                "id": 116596,
                "title": "c-4-ms-bit-mask",
                "content": "```\nclass Solution {\npublic:\n  int isValid(int n) {    \n    constexpr int kInValidMask = (1 << 3) | (1 << 4) | (1 << 7);\n    constexpr int kValidMask = (1 << 2) | (1 << 5) | (1 << 6) | (1 << 9);\n    \n    int valid = 0;\n    \n    while (n > 0) {\n      int r = 1 << (n % 10);\n      if (r & kInValidMask)\n        return 0;\n      else if (r & kValidMask)\n        valid = 1;\n      n /= 10;\n    }\n      \n    return valid;\n  }\n  \n  int rotatedDigits(int N) {\n    int ans = 0;\n    for (int i = 1; i <= N; ++i)\n      ans += isValid(i);\n    return ans;\n  }\n};\n```",
                "solutionTags": [],
                "code": "```\nclass Solution {\npublic:\n  int isValid(int n) {    \n    constexpr int kInValidMask = (1 << 3) | (1 << 4) | (1 << 7);\n    constexpr int kValidMask = (1 << 2) | (1 << 5) | (1 << 6) | (1 << 9);\n    \n    int valid = 0;\n    \n    while (n > 0) {\n      int r = 1 << (n % 10);\n      if (r & kInValidMask)\n        return 0;\n      else if (r & kValidMask)\n        valid = 1;\n      n /= 10;\n    }\n      \n    return valid;\n  }\n  \n  int rotatedDigits(int N) {\n    int ans = 0;\n    for (int i = 1; i <= N; ++i)\n      ans += isValid(i);\n    return ans;\n  }\n};\n```",
                "codeTag": "Java"
            },
            {
                "id": 116501,
                "title": "java-solution",
                "content": "```\nclass Solution {\n    static int[] map = {0, 1, 5, -1, -1, 2, 9, -1, 8, 6};\n    public int rotatedDigits(int N) {\n        int result = 0;\n        for (int i = 2; i <= N; i++) {\n            if (isGoodNumber(i)) result++;\n        }\n        return result;\n    }\n    private boolean isGoodNumber(int n) {\n        int t = n, m = 0, base = 1;\n        while (t > 0) {\n            if (map[t % 10] == -1) return false;\n            m = m + map[t % 10] * base;\n            t /= 10;\n            base *= 10;\n        }\n        return n != m;\n    }\n}\n```",
                "solutionTags": [],
                "code": "```\nclass Solution {\n    static int[] map = {0, 1, 5, -1, -1, 2, 9, -1, 8, 6};\n    public int rotatedDigits(int N) {\n        int result = 0;\n        for (int i = 2; i <= N; i++) {\n            if (isGoodNumber(i)) result++;\n        }\n        return result;\n    }\n    private boolean isGoodNumber(int n) {\n        int t = n, m = 0, base = 1;\n        while (t > 0) {\n            if (map[t % 10] == -1) return false;\n            m = m + map[t % 10] * base;\n            t /= 10;\n            base *= 10;\n        }\n        return n != m;\n    }\n}\n```",
                "codeTag": "Java"
            },
            {
                "id": 4100506,
                "title": "simple-digit-dp-faster-than-100",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dp[6][3][3][3];\\n    int solve(int ind,int tight,int leading_zero,string &s,vector<int> &digit,bool change){\\n        if(ind==s.size()){\\n            if(change)return 1;\\n            return 0;\\n        }\\n        if(dp[ind][tight][leading_zero][change]!=-1)return dp[ind][tight][leading_zero][change];\\n        int limit=9;\\n        if(tight)limit=s[ind]-\\'0\\';\\n        int ans=0;\\n        if(leading_zero){\\n            ans+=solve(ind+1,0,1,s,digit,change);\\n        }\\n        for(int i=0;i<digit.size();i++){\\n            if(digit[i]>limit)break;\\n            if(leading_zero && digit[i]==0){\\n                continue;\\n            }\\n            if(digit[i]==2 ||digit[i]==5 ||digit[i]==6 ||digit[i]==9 )\\n            ans+=solve(ind+1,(tight&&(limit==digit[i])),0,s,digit,1);\\n            else ans+=solve(ind+1,(tight&&(limit==digit[i])),0,s,digit,change);\\n        }return dp[ind][tight][leading_zero][change]=ans;\\n    }\\n    int rotatedDigits(int n) {\\n        string s=to_string(n);\\n        vector<int> digit={0,1,2,5,6,8,9};\\n        memset(dp,-1,sizeof(dp));\\n        return solve(0,1,1,s,digit,0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[6][3][3][3];\\n    int solve(int ind,int tight,int leading_zero,string &s,vector<int> &digit,bool change){\\n        if(ind==s.size()){\\n            if(change)return 1;\\n            return 0;\\n        }\\n        if(dp[ind][tight][leading_zero][change]!=-1)return dp[ind][tight][leading_zero][change];\\n        int limit=9;\\n        if(tight)limit=s[ind]-\\'0\\';\\n        int ans=0;\\n        if(leading_zero){\\n            ans+=solve(ind+1,0,1,s,digit,change);\\n        }\\n        for(int i=0;i<digit.size();i++){\\n            if(digit[i]>limit)break;\\n            if(leading_zero && digit[i]==0){\\n                continue;\\n            }\\n            if(digit[i]==2 ||digit[i]==5 ||digit[i]==6 ||digit[i]==9 )\\n            ans+=solve(ind+1,(tight&&(limit==digit[i])),0,s,digit,1);\\n            else ans+=solve(ind+1,(tight&&(limit==digit[i])),0,s,digit,change);\\n        }return dp[ind][tight][leading_zero][change]=ans;\\n    }\\n    int rotatedDigits(int n) {\\n        string s=to_string(n);\\n        vector<int> digit={0,1,2,5,6,8,9};\\n        memset(dp,-1,sizeof(dp));\\n        return solve(0,1,1,s,digit,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4063988,
                "title": "overcomplicated-js-solution",
                "content": "```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nconst rotatedDigits = function(n) {\\n    \\n    let hash = {\\n        0: 0,\\n        1: 1,\\n        2: 5,\\n        5: 2,\\n        6: 9,\\n        8: 8,\\n        9: 6,\\n    }\\n    \\n    let res = 0\\n      \\n    for (let i = 1; i <= n; i++) {\\n        \\n       const str  = i + \\'\\'\\n       \\n       let counter = 0\\n       \\n       for (let k = 0; k < str.length; k++) {\\n           \\n           if (str[k] == 3 || str[k] == 4 || str[k] == 7) {\\n               break\\n           } else {\\n               counter++\\n           }\\n              \\n       }\\n        \\n        if (counter === str.length) {\\n            \\n            let arr = []\\n            \\n            for (let i = 0; i < str.length; i++) {\\n                \\n                arr.push(hash[str[i]])\\n                \\n            }\\n            \\n            if (arr.join(\\'\\') !== str) res++\\n            \\n        }\\n        \\n        \\n    }\\n    \\n    return res\\n    \\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nconst rotatedDigits = function(n) {\\n    \\n    let hash = {\\n        0: 0,\\n        1: 1,\\n        2: 5,\\n        5: 2,\\n        6: 9,\\n        8: 8,\\n        9: 6,\\n    }\\n    \\n    let res = 0\\n      \\n    for (let i = 1; i <= n; i++) {\\n        \\n       const str  = i + \\'\\'\\n       \\n       let counter = 0\\n       \\n       for (let k = 0; k < str.length; k++) {\\n           \\n           if (str[k] == 3 || str[k] == 4 || str[k] == 7) {\\n               break\\n           } else {\\n               counter++\\n           }\\n              \\n       }\\n        \\n        if (counter === str.length) {\\n            \\n            let arr = []\\n            \\n            for (let i = 0; i < str.length; i++) {\\n                \\n                arr.push(hash[str[i]])\\n                \\n            }\\n            \\n            if (arr.join(\\'\\') !== str) res++\\n            \\n        }\\n        \\n        \\n    }\\n    \\n    return res\\n    \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4054337,
                "title": "simple-and-optimum-java-based-solution",
                "content": "# Approach\\nMy first thought was to divide this problem and conquer one problem at a time. So I created a function that finds if a given number is a good number. I concluded from the description of question that a number would be good only if it does not contain any invalid digit (3,4,7) and any one of the digit of the number is a good number (2,5,6,9).\\n\\n# Complexity\\n- Time complexity: O(n) \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int rotatedDigits(int n) {\\n        int goodNumberCounter = 0;\\n        for (int i = 1; i <= n; i++) {\\n            if (isGoodNumber(i)) {\\n                goodNumberCounter++;\\n            }\\n        }\\n        return goodNumberCounter;\\n    }\\n\\n    public boolean isGoodNumber(int num) {\\n        boolean hasGoodDigit = false;\\n        while (num > 0) {\\n            int digit = num % 10;\\n            if (digit == 2 || digit == 5 || digit == 6 || digit == 9) {\\n                hasGoodDigit = true;\\n            } else if (digit == 3 || digit == 4 || digit == 7) {\\n                return false; // If it contains invalid digits, return false immediately\\n            }\\n            num /= 10;\\n        }\\n        return hasGoodDigit;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int rotatedDigits(int n) {\\n        int goodNumberCounter = 0;\\n        for (int i = 1; i <= n; i++) {\\n            if (isGoodNumber(i)) {\\n                goodNumberCounter++;\\n            }\\n        }\\n        return goodNumberCounter;\\n    }\\n\\n    public boolean isGoodNumber(int num) {\\n        boolean hasGoodDigit = false;\\n        while (num > 0) {\\n            int digit = num % 10;\\n            if (digit == 2 || digit == 5 || digit == 6 || digit == 9) {\\n                hasGoodDigit = true;\\n            } else if (digit == 3 || digit == 4 || digit == 7) {\\n                return false; // If it contains invalid digits, return false immediately\\n            }\\n            num /= 10;\\n        }\\n        return hasGoodDigit;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4033060,
                "title": "rotated-digits-java-solution",
                "content": "```\\nclass Solution {\\n    public static int rotatedDigits(int n) {\\n        int start = 2;\\n        int count = 0;\\n        boolean isRotated = false;\\n        String str = \"\";\\n\\n        while (start <= n) {\\n            isRotated = false;\\n            str = Integer.toString(start);\\n            int sub_start = 0;\\n\\n            while (sub_start < str.length()) {\\n                if (str.charAt(sub_start) == \\'2\\' || str.charAt(sub_start) == \\'5\\' || \\n                    str.charAt(sub_start) == \\'6\\' || str.charAt(sub_start) == \\'9\\') {\\n                    isRotated = true;\\n                } \\n                else if (str.charAt(sub_start) == \\'3\\' || str.charAt(sub_start) == \\'4\\' || \\n                         str.charAt(sub_start) == \\'7\\') {\\n                    isRotated = false;\\n                    break;\\n                }\\n                sub_start++;\\n            }\\n\\n            if (isRotated) {\\n                count++;\\n            }\\n\\n            start++;\\n        }\\n\\n        return count;\\n    }\\n}\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public static int rotatedDigits(int n) {\\n        int start = 2;\\n        int count = 0;\\n        boolean isRotated = false;\\n        String str = \"\";\\n\\n        while (start <= n) {\\n            isRotated = false;\\n            str = Integer.toString(start);\\n            int sub_start = 0;\\n\\n            while (sub_start < str.length()) {\\n                if (str.charAt(sub_start) == \\'2\\' || str.charAt(sub_start) == \\'5\\' || \\n                    str.charAt(sub_start) == \\'6\\' || str.charAt(sub_start) == \\'9\\') {\\n                    isRotated = true;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 4023008,
                "title": "easy-solution-c-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFor each number k in 1 to n\\ncheck the digits of k and decide accordingly\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIf digits of a number are 3/4/7 they cannot rotate to valid digit -> therefore they do not contibute to the ans\\n\\nOther case if number has digits 2/5/6/9 then they rotate and form a valid digit -> if number has these digits and do not have 3/4/7 -> they contribute towards the ans.\\n\\n# Complexity\\n- Time complexity: O(nlog(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int rotatedDigits(int n) {\\n        int ans=0;\\n        vector<int> v(10,1);\\n        v[0]=0,v[1]=0,v[8]=0; //rotate to themselves\\n        v[3]=-1,v[4]=-1,v[7]=-1; // when these are rotated they do not form valid digits\\n\\n        // check for digits in x\\n        while(n){\\n            int x=n;\\n            bool key=false;\\n            while(x){\\n                int d=x%10;\\n                if(v[d]==1){\\n                    key=true;\\n                }\\n                else if(v[d]==-1){\\n                    // case of 3/4/7\\n                    key=false;\\n                    break;\\n                }\\n                x/=10;\\n            }\\n            if(key) ans++;\\n            n--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int rotatedDigits(int n) {\\n        int ans=0;\\n        vector<int> v(10,1);\\n        v[0]=0,v[1]=0,v[8]=0; //rotate to themselves\\n        v[3]=-1,v[4]=-1,v[7]=-1; // when these are rotated they do not form valid digits\\n\\n        // check for digits in x\\n        while(n){\\n            int x=n;\\n            bool key=false;\\n            while(x){\\n                int d=x%10;\\n                if(v[d]==1){\\n                    key=true;\\n                }\\n                else if(v[d]==-1){\\n                    // case of 3/4/7\\n                    key=false;\\n                    break;\\n                }\\n                x/=10;\\n            }\\n            if(key) ans++;\\n            n--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3997522,
                "title": "java-fast-solution-brute-force",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int rotatedDigits(int n) {\\n        int ans = 0;\\n        for(int i =1;n>=i;i++){\\n            ans += check(i);\\n        }\\n        return ans;\\n    }public int check(int i){\\n        int count=-1;\\n        while(i>0){\\n            int c = i%10;\\n            if(c==4||c==3||c==7)return 0;\\n            else if(c==2||c==5||c==6||c==9){\\n                count=1;\\n            }\\n            i/=10;\\n        }\\n        if(count>0)return 1;\\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int rotatedDigits(int n) {\\n        int ans = 0;\\n        for(int i =1;n>=i;i++){\\n            ans += check(i);\\n        }\\n        return ans;\\n    }public int check(int i){\\n        int count=-1;\\n        while(i>0){\\n            int c = i%10;\\n            if(c==4||c==3||c==7)return 0;\\n            else if(c==2||c==5||c==6||c==9){\\n                count=1;\\n            }\\n            i/=10;\\n        }\\n        if(count>0)return 1;\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3980814,
                "title": "best-solution-for-beginners-very-easy-highly-understandable-tc-o-n-log-n-java",
                "content": "# Intuition\\nFor each number in range we will check if the number id valid or not.\\n# Approach\\nIf a number contains 3,4, 7 then it is invalid. If a number contains at least 1  of them in any counts{2,5,6,9} then the number by rotating will get us a unique value.\\n\\nSo we will check if the number contains 3,4,7 then it will return false if the number contains any muber of (2,5,7,8) then it will return us true. \\n\\n# Complexity\\n- Time complexity:\\nthe digits of number is always less then the number itself except for 1.\\n\\nso at max the checking complexity will take O(n) or precisely we can say that the digits in number is around log n\\n\\nso total time complexity is O(n log n).\\n\\n- Space complexity:\\nspace complexity is constant i.e O(1).\\n\\n# Code\\n```\\nclass Solution {\\n    public int rotatedDigits(int n) {\\n        int countvalid = 0;\\n        for (int i = 1; i <= n; i++){\\n            if (check(i)){\\n                countvalid++;\\n            }\\n        }\\n        return countvalid;\\n    }\\n\\n    //this function checks if the number is valid or not\\n\\n    private boolean check(int n){\\n        int count = 0; //count of {2,5,6,9} in the number\\n        while (n > 0){\\n            if (n % 10 == 2 || n % 10 == 5 || n % 10 == 6 || n % 10 == 9){\\n                count++;\\n            }\\n            \\n            else if(n % 10 == 0 || n % 10 == 1 || n % 10 == 8){}\\n\\n            else{\\n                return false;\\n            }\\n            n = n/10;\\n        }\\n        if (count > 0){\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int rotatedDigits(int n) {\\n        int countvalid = 0;\\n        for (int i = 1; i <= n; i++){\\n            if (check(i)){\\n                countvalid++;\\n            }\\n        }\\n        return countvalid;\\n    }\\n\\n    //this function checks if the number is valid or not\\n\\n    private boolean check(int n){\\n        int count = 0; //count of {2,5,6,9} in the number\\n        while (n > 0){\\n            if (n % 10 == 2 || n % 10 == 5 || n % 10 == 6 || n % 10 == 9){\\n                count++;\\n            }\\n            \\n            else if(n % 10 == 0 || n % 10 == 1 || n % 10 == 8){}\\n\\n            else{\\n                return false;\\n            }\\n            n = n/10;\\n        }\\n        if (count > 0){\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1564759,
                "content": [
                    {
                        "username": "edzaferovic",
                        "content": "The question says that a number is good if each individual number is rotated and the original number is different to the rotated number.\\n\\nHere is how rotations work:\\n\\n0 rotates to 0\\n1 rotates to 1\\n8 rotates to 8\\n\\n2 rotates to 5\\n5 rotates to 2\\n6 rotates to 9\\n9 rotates to 6 \\n\\nEvery other number 3,4 and 7 do not rotate and are invalid meaning if the number contains one of these it cannot be changed. \\n\\nSO this means that 20 would rotate to 50 bc 2 rotates to 5 and 0 stays the same. This number is good since 20 != 50.\\nAnother example is 33, since 3 is the first int it becomes invalid. Another example of this is 23, since 3 is the second int in the number it becomes invalid meaning even tho 2 changes to 5 and the number is 53, and 53 != 23, the 3 invalidates the number making it no good.\\n\\nHope this helps you guys understand what the question is asking for!\\n"
                    },
                    {
                        "username": "companion",
                        "content": "After rotating 180, 2 is still 2?"
                    },
                    {
                        "username": "shashwatpandeyy",
                        "content": "it become 5"
                    },
                    {
                        "username": "fmadrid",
                        "content": "[A Ludic Fallacy - Rotating Digits (Leet Code 788)](http://www.frankmadrid.com/ALudicFallacy/2018/02/28/rotated-digits-leet-code-788/)\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "guys the link is showing Ads don\\'t open ! It is un-relevant "
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "they should add in example 1 - > \\n[1,10] -> 2 , 5 ,  6  , 9 \\n\\n1 , `8` and 10 are not good numbers .\\nThey forgot to mention that 8 also comes under the range [1,10] and remains same after the rotation."
                    },
                    {
                        "username": "prajapatikunal7",
                        "content": "Can someone help me in understanding of \"180 degree of digit\" ?\\n\\nLike \\n1) How 2 can be rotated 180 degree to 5? \\n2) How 1 or 8 can be rotated 180 degree to digit themeselves ?\\n\\nThanks in advance"
                    },
                    {
                        "username": "mchim",
                        "content": "Flip it upside down, then 2 becomes 5."
                    },
                    {
                        "username": "yuweila",
                        "content": "I input 22 and 23 into testcase and get the result 11 and 11 respectively, \\nthat meas the nubmer 23 is a bad number. Is it? 2 to 5 and 3 to 3, so 23 to 53?\\n\\nIs it a bug or the problem is the definition of **rotating each digit individually by 180 degrees** is not clear? I think the roatation might be:\\n\\n**1. rotate clockwise/counterclockwise?**\\n(X) 2 and 5 rotate to itself, and it is conflict with the problem description.\\n\\n**2. flip vertically** (Put a mirror besides the number and see what inside)\\n(O) 2 and 5 rotate to each other.\\n(X) 6 and 9 roate to itself, conflict.\\n\\n**3. flip horizontally** (Put a mirror under the number and see what inside)\\n(O) 2 and 5 rotate to each other.\\n(O) 6 and 9 roate to each other. (If 9 is wirtten like a lollipop)\\n**How about 3, 4, and 7?** \\n4 and 7 can not get a valid number, and 3 can rotate to itself. But the problem description does not mention about 3 and the testcase shows 3 is a bad number. Does that mean the rotation is not flip horizontally? So what is **rotating each digit individually by 180 degrees**?"
                    },
                    {
                        "username": "leetcode_yao",
                        "content": "2 and 5 rotate each other? why?\\nwhy 2->2 5->5 ?"
                    },
                    {
                        "username": "heesub",
                        "content": "This question makes me post my first comment here. I tried to understand this question and derive an optimal solution, but it was just a waste of time. Only brute-force solution exists. If this can be solved in a more efficient way, please enlighten me."
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "brute force is working without tle"
                    },
                    {
                        "username": "genegenehou",
                        "content": "I think `69` is not a good number, since if we rotate it by 180 degree, it\\'s still `69`.\\n\\nBut if you print out the good numbers with the AC solution, you\\'ll find `69` is a good number. Why?"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "we all know why it is a `good number` pun intended.\\n\\nactually -> 69 becomes 96 according to description."
                    }
                ]
            },
            {
                "id": 1565675,
                "content": [
                    {
                        "username": "edzaferovic",
                        "content": "The question says that a number is good if each individual number is rotated and the original number is different to the rotated number.\\n\\nHere is how rotations work:\\n\\n0 rotates to 0\\n1 rotates to 1\\n8 rotates to 8\\n\\n2 rotates to 5\\n5 rotates to 2\\n6 rotates to 9\\n9 rotates to 6 \\n\\nEvery other number 3,4 and 7 do not rotate and are invalid meaning if the number contains one of these it cannot be changed. \\n\\nSO this means that 20 would rotate to 50 bc 2 rotates to 5 and 0 stays the same. This number is good since 20 != 50.\\nAnother example is 33, since 3 is the first int it becomes invalid. Another example of this is 23, since 3 is the second int in the number it becomes invalid meaning even tho 2 changes to 5 and the number is 53, and 53 != 23, the 3 invalidates the number making it no good.\\n\\nHope this helps you guys understand what the question is asking for!\\n"
                    },
                    {
                        "username": "companion",
                        "content": "After rotating 180, 2 is still 2?"
                    },
                    {
                        "username": "shashwatpandeyy",
                        "content": "it become 5"
                    },
                    {
                        "username": "fmadrid",
                        "content": "[A Ludic Fallacy - Rotating Digits (Leet Code 788)](http://www.frankmadrid.com/ALudicFallacy/2018/02/28/rotated-digits-leet-code-788/)\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "guys the link is showing Ads don\\'t open ! It is un-relevant "
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "they should add in example 1 - > \\n[1,10] -> 2 , 5 ,  6  , 9 \\n\\n1 , `8` and 10 are not good numbers .\\nThey forgot to mention that 8 also comes under the range [1,10] and remains same after the rotation."
                    },
                    {
                        "username": "prajapatikunal7",
                        "content": "Can someone help me in understanding of \"180 degree of digit\" ?\\n\\nLike \\n1) How 2 can be rotated 180 degree to 5? \\n2) How 1 or 8 can be rotated 180 degree to digit themeselves ?\\n\\nThanks in advance"
                    },
                    {
                        "username": "mchim",
                        "content": "Flip it upside down, then 2 becomes 5."
                    },
                    {
                        "username": "yuweila",
                        "content": "I input 22 and 23 into testcase and get the result 11 and 11 respectively, \\nthat meas the nubmer 23 is a bad number. Is it? 2 to 5 and 3 to 3, so 23 to 53?\\n\\nIs it a bug or the problem is the definition of **rotating each digit individually by 180 degrees** is not clear? I think the roatation might be:\\n\\n**1. rotate clockwise/counterclockwise?**\\n(X) 2 and 5 rotate to itself, and it is conflict with the problem description.\\n\\n**2. flip vertically** (Put a mirror besides the number and see what inside)\\n(O) 2 and 5 rotate to each other.\\n(X) 6 and 9 roate to itself, conflict.\\n\\n**3. flip horizontally** (Put a mirror under the number and see what inside)\\n(O) 2 and 5 rotate to each other.\\n(O) 6 and 9 roate to each other. (If 9 is wirtten like a lollipop)\\n**How about 3, 4, and 7?** \\n4 and 7 can not get a valid number, and 3 can rotate to itself. But the problem description does not mention about 3 and the testcase shows 3 is a bad number. Does that mean the rotation is not flip horizontally? So what is **rotating each digit individually by 180 degrees**?"
                    },
                    {
                        "username": "leetcode_yao",
                        "content": "2 and 5 rotate each other? why?\\nwhy 2->2 5->5 ?"
                    },
                    {
                        "username": "heesub",
                        "content": "This question makes me post my first comment here. I tried to understand this question and derive an optimal solution, but it was just a waste of time. Only brute-force solution exists. If this can be solved in a more efficient way, please enlighten me."
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "brute force is working without tle"
                    },
                    {
                        "username": "genegenehou",
                        "content": "I think `69` is not a good number, since if we rotate it by 180 degree, it\\'s still `69`.\\n\\nBut if you print out the good numbers with the AC solution, you\\'ll find `69` is a good number. Why?"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "we all know why it is a `good number` pun intended.\\n\\nactually -> 69 becomes 96 according to description."
                    }
                ]
            },
            {
                "id": 1565164,
                "content": [
                    {
                        "username": "edzaferovic",
                        "content": "The question says that a number is good if each individual number is rotated and the original number is different to the rotated number.\\n\\nHere is how rotations work:\\n\\n0 rotates to 0\\n1 rotates to 1\\n8 rotates to 8\\n\\n2 rotates to 5\\n5 rotates to 2\\n6 rotates to 9\\n9 rotates to 6 \\n\\nEvery other number 3,4 and 7 do not rotate and are invalid meaning if the number contains one of these it cannot be changed. \\n\\nSO this means that 20 would rotate to 50 bc 2 rotates to 5 and 0 stays the same. This number is good since 20 != 50.\\nAnother example is 33, since 3 is the first int it becomes invalid. Another example of this is 23, since 3 is the second int in the number it becomes invalid meaning even tho 2 changes to 5 and the number is 53, and 53 != 23, the 3 invalidates the number making it no good.\\n\\nHope this helps you guys understand what the question is asking for!\\n"
                    },
                    {
                        "username": "companion",
                        "content": "After rotating 180, 2 is still 2?"
                    },
                    {
                        "username": "shashwatpandeyy",
                        "content": "it become 5"
                    },
                    {
                        "username": "fmadrid",
                        "content": "[A Ludic Fallacy - Rotating Digits (Leet Code 788)](http://www.frankmadrid.com/ALudicFallacy/2018/02/28/rotated-digits-leet-code-788/)\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "guys the link is showing Ads don\\'t open ! It is un-relevant "
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "they should add in example 1 - > \\n[1,10] -> 2 , 5 ,  6  , 9 \\n\\n1 , `8` and 10 are not good numbers .\\nThey forgot to mention that 8 also comes under the range [1,10] and remains same after the rotation."
                    },
                    {
                        "username": "prajapatikunal7",
                        "content": "Can someone help me in understanding of \"180 degree of digit\" ?\\n\\nLike \\n1) How 2 can be rotated 180 degree to 5? \\n2) How 1 or 8 can be rotated 180 degree to digit themeselves ?\\n\\nThanks in advance"
                    },
                    {
                        "username": "mchim",
                        "content": "Flip it upside down, then 2 becomes 5."
                    },
                    {
                        "username": "yuweila",
                        "content": "I input 22 and 23 into testcase and get the result 11 and 11 respectively, \\nthat meas the nubmer 23 is a bad number. Is it? 2 to 5 and 3 to 3, so 23 to 53?\\n\\nIs it a bug or the problem is the definition of **rotating each digit individually by 180 degrees** is not clear? I think the roatation might be:\\n\\n**1. rotate clockwise/counterclockwise?**\\n(X) 2 and 5 rotate to itself, and it is conflict with the problem description.\\n\\n**2. flip vertically** (Put a mirror besides the number and see what inside)\\n(O) 2 and 5 rotate to each other.\\n(X) 6 and 9 roate to itself, conflict.\\n\\n**3. flip horizontally** (Put a mirror under the number and see what inside)\\n(O) 2 and 5 rotate to each other.\\n(O) 6 and 9 roate to each other. (If 9 is wirtten like a lollipop)\\n**How about 3, 4, and 7?** \\n4 and 7 can not get a valid number, and 3 can rotate to itself. But the problem description does not mention about 3 and the testcase shows 3 is a bad number. Does that mean the rotation is not flip horizontally? So what is **rotating each digit individually by 180 degrees**?"
                    },
                    {
                        "username": "leetcode_yao",
                        "content": "2 and 5 rotate each other? why?\\nwhy 2->2 5->5 ?"
                    },
                    {
                        "username": "heesub",
                        "content": "This question makes me post my first comment here. I tried to understand this question and derive an optimal solution, but it was just a waste of time. Only brute-force solution exists. If this can be solved in a more efficient way, please enlighten me."
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "brute force is working without tle"
                    },
                    {
                        "username": "genegenehou",
                        "content": "I think `69` is not a good number, since if we rotate it by 180 degree, it\\'s still `69`.\\n\\nBut if you print out the good numbers with the AC solution, you\\'ll find `69` is a good number. Why?"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "we all know why it is a `good number` pun intended.\\n\\nactually -> 69 becomes 96 according to description."
                    }
                ]
            },
            {
                "id": 1676058,
                "content": [
                    {
                        "username": "edzaferovic",
                        "content": "The question says that a number is good if each individual number is rotated and the original number is different to the rotated number.\\n\\nHere is how rotations work:\\n\\n0 rotates to 0\\n1 rotates to 1\\n8 rotates to 8\\n\\n2 rotates to 5\\n5 rotates to 2\\n6 rotates to 9\\n9 rotates to 6 \\n\\nEvery other number 3,4 and 7 do not rotate and are invalid meaning if the number contains one of these it cannot be changed. \\n\\nSO this means that 20 would rotate to 50 bc 2 rotates to 5 and 0 stays the same. This number is good since 20 != 50.\\nAnother example is 33, since 3 is the first int it becomes invalid. Another example of this is 23, since 3 is the second int in the number it becomes invalid meaning even tho 2 changes to 5 and the number is 53, and 53 != 23, the 3 invalidates the number making it no good.\\n\\nHope this helps you guys understand what the question is asking for!\\n"
                    },
                    {
                        "username": "companion",
                        "content": "After rotating 180, 2 is still 2?"
                    },
                    {
                        "username": "shashwatpandeyy",
                        "content": "it become 5"
                    },
                    {
                        "username": "fmadrid",
                        "content": "[A Ludic Fallacy - Rotating Digits (Leet Code 788)](http://www.frankmadrid.com/ALudicFallacy/2018/02/28/rotated-digits-leet-code-788/)\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "guys the link is showing Ads don\\'t open ! It is un-relevant "
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "they should add in example 1 - > \\n[1,10] -> 2 , 5 ,  6  , 9 \\n\\n1 , `8` and 10 are not good numbers .\\nThey forgot to mention that 8 also comes under the range [1,10] and remains same after the rotation."
                    },
                    {
                        "username": "prajapatikunal7",
                        "content": "Can someone help me in understanding of \"180 degree of digit\" ?\\n\\nLike \\n1) How 2 can be rotated 180 degree to 5? \\n2) How 1 or 8 can be rotated 180 degree to digit themeselves ?\\n\\nThanks in advance"
                    },
                    {
                        "username": "mchim",
                        "content": "Flip it upside down, then 2 becomes 5."
                    },
                    {
                        "username": "yuweila",
                        "content": "I input 22 and 23 into testcase and get the result 11 and 11 respectively, \\nthat meas the nubmer 23 is a bad number. Is it? 2 to 5 and 3 to 3, so 23 to 53?\\n\\nIs it a bug or the problem is the definition of **rotating each digit individually by 180 degrees** is not clear? I think the roatation might be:\\n\\n**1. rotate clockwise/counterclockwise?**\\n(X) 2 and 5 rotate to itself, and it is conflict with the problem description.\\n\\n**2. flip vertically** (Put a mirror besides the number and see what inside)\\n(O) 2 and 5 rotate to each other.\\n(X) 6 and 9 roate to itself, conflict.\\n\\n**3. flip horizontally** (Put a mirror under the number and see what inside)\\n(O) 2 and 5 rotate to each other.\\n(O) 6 and 9 roate to each other. (If 9 is wirtten like a lollipop)\\n**How about 3, 4, and 7?** \\n4 and 7 can not get a valid number, and 3 can rotate to itself. But the problem description does not mention about 3 and the testcase shows 3 is a bad number. Does that mean the rotation is not flip horizontally? So what is **rotating each digit individually by 180 degrees**?"
                    },
                    {
                        "username": "leetcode_yao",
                        "content": "2 and 5 rotate each other? why?\\nwhy 2->2 5->5 ?"
                    },
                    {
                        "username": "heesub",
                        "content": "This question makes me post my first comment here. I tried to understand this question and derive an optimal solution, but it was just a waste of time. Only brute-force solution exists. If this can be solved in a more efficient way, please enlighten me."
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "brute force is working without tle"
                    },
                    {
                        "username": "genegenehou",
                        "content": "I think `69` is not a good number, since if we rotate it by 180 degree, it\\'s still `69`.\\n\\nBut if you print out the good numbers with the AC solution, you\\'ll find `69` is a good number. Why?"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "we all know why it is a `good number` pun intended.\\n\\nactually -> 69 becomes 96 according to description."
                    }
                ]
            },
            {
                "id": 1573766,
                "content": [
                    {
                        "username": "edzaferovic",
                        "content": "The question says that a number is good if each individual number is rotated and the original number is different to the rotated number.\\n\\nHere is how rotations work:\\n\\n0 rotates to 0\\n1 rotates to 1\\n8 rotates to 8\\n\\n2 rotates to 5\\n5 rotates to 2\\n6 rotates to 9\\n9 rotates to 6 \\n\\nEvery other number 3,4 and 7 do not rotate and are invalid meaning if the number contains one of these it cannot be changed. \\n\\nSO this means that 20 would rotate to 50 bc 2 rotates to 5 and 0 stays the same. This number is good since 20 != 50.\\nAnother example is 33, since 3 is the first int it becomes invalid. Another example of this is 23, since 3 is the second int in the number it becomes invalid meaning even tho 2 changes to 5 and the number is 53, and 53 != 23, the 3 invalidates the number making it no good.\\n\\nHope this helps you guys understand what the question is asking for!\\n"
                    },
                    {
                        "username": "companion",
                        "content": "After rotating 180, 2 is still 2?"
                    },
                    {
                        "username": "shashwatpandeyy",
                        "content": "it become 5"
                    },
                    {
                        "username": "fmadrid",
                        "content": "[A Ludic Fallacy - Rotating Digits (Leet Code 788)](http://www.frankmadrid.com/ALudicFallacy/2018/02/28/rotated-digits-leet-code-788/)\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "guys the link is showing Ads don\\'t open ! It is un-relevant "
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "they should add in example 1 - > \\n[1,10] -> 2 , 5 ,  6  , 9 \\n\\n1 , `8` and 10 are not good numbers .\\nThey forgot to mention that 8 also comes under the range [1,10] and remains same after the rotation."
                    },
                    {
                        "username": "prajapatikunal7",
                        "content": "Can someone help me in understanding of \"180 degree of digit\" ?\\n\\nLike \\n1) How 2 can be rotated 180 degree to 5? \\n2) How 1 or 8 can be rotated 180 degree to digit themeselves ?\\n\\nThanks in advance"
                    },
                    {
                        "username": "mchim",
                        "content": "Flip it upside down, then 2 becomes 5."
                    },
                    {
                        "username": "yuweila",
                        "content": "I input 22 and 23 into testcase and get the result 11 and 11 respectively, \\nthat meas the nubmer 23 is a bad number. Is it? 2 to 5 and 3 to 3, so 23 to 53?\\n\\nIs it a bug or the problem is the definition of **rotating each digit individually by 180 degrees** is not clear? I think the roatation might be:\\n\\n**1. rotate clockwise/counterclockwise?**\\n(X) 2 and 5 rotate to itself, and it is conflict with the problem description.\\n\\n**2. flip vertically** (Put a mirror besides the number and see what inside)\\n(O) 2 and 5 rotate to each other.\\n(X) 6 and 9 roate to itself, conflict.\\n\\n**3. flip horizontally** (Put a mirror under the number and see what inside)\\n(O) 2 and 5 rotate to each other.\\n(O) 6 and 9 roate to each other. (If 9 is wirtten like a lollipop)\\n**How about 3, 4, and 7?** \\n4 and 7 can not get a valid number, and 3 can rotate to itself. But the problem description does not mention about 3 and the testcase shows 3 is a bad number. Does that mean the rotation is not flip horizontally? So what is **rotating each digit individually by 180 degrees**?"
                    },
                    {
                        "username": "leetcode_yao",
                        "content": "2 and 5 rotate each other? why?\\nwhy 2->2 5->5 ?"
                    },
                    {
                        "username": "heesub",
                        "content": "This question makes me post my first comment here. I tried to understand this question and derive an optimal solution, but it was just a waste of time. Only brute-force solution exists. If this can be solved in a more efficient way, please enlighten me."
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "brute force is working without tle"
                    },
                    {
                        "username": "genegenehou",
                        "content": "I think `69` is not a good number, since if we rotate it by 180 degree, it\\'s still `69`.\\n\\nBut if you print out the good numbers with the AC solution, you\\'ll find `69` is a good number. Why?"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "we all know why it is a `good number` pun intended.\\n\\nactually -> 69 becomes 96 according to description."
                    }
                ]
            },
            {
                "id": 1569229,
                "content": [
                    {
                        "username": "edzaferovic",
                        "content": "The question says that a number is good if each individual number is rotated and the original number is different to the rotated number.\\n\\nHere is how rotations work:\\n\\n0 rotates to 0\\n1 rotates to 1\\n8 rotates to 8\\n\\n2 rotates to 5\\n5 rotates to 2\\n6 rotates to 9\\n9 rotates to 6 \\n\\nEvery other number 3,4 and 7 do not rotate and are invalid meaning if the number contains one of these it cannot be changed. \\n\\nSO this means that 20 would rotate to 50 bc 2 rotates to 5 and 0 stays the same. This number is good since 20 != 50.\\nAnother example is 33, since 3 is the first int it becomes invalid. Another example of this is 23, since 3 is the second int in the number it becomes invalid meaning even tho 2 changes to 5 and the number is 53, and 53 != 23, the 3 invalidates the number making it no good.\\n\\nHope this helps you guys understand what the question is asking for!\\n"
                    },
                    {
                        "username": "companion",
                        "content": "After rotating 180, 2 is still 2?"
                    },
                    {
                        "username": "shashwatpandeyy",
                        "content": "it become 5"
                    },
                    {
                        "username": "fmadrid",
                        "content": "[A Ludic Fallacy - Rotating Digits (Leet Code 788)](http://www.frankmadrid.com/ALudicFallacy/2018/02/28/rotated-digits-leet-code-788/)\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "guys the link is showing Ads don\\'t open ! It is un-relevant "
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "they should add in example 1 - > \\n[1,10] -> 2 , 5 ,  6  , 9 \\n\\n1 , `8` and 10 are not good numbers .\\nThey forgot to mention that 8 also comes under the range [1,10] and remains same after the rotation."
                    },
                    {
                        "username": "prajapatikunal7",
                        "content": "Can someone help me in understanding of \"180 degree of digit\" ?\\n\\nLike \\n1) How 2 can be rotated 180 degree to 5? \\n2) How 1 or 8 can be rotated 180 degree to digit themeselves ?\\n\\nThanks in advance"
                    },
                    {
                        "username": "mchim",
                        "content": "Flip it upside down, then 2 becomes 5."
                    },
                    {
                        "username": "yuweila",
                        "content": "I input 22 and 23 into testcase and get the result 11 and 11 respectively, \\nthat meas the nubmer 23 is a bad number. Is it? 2 to 5 and 3 to 3, so 23 to 53?\\n\\nIs it a bug or the problem is the definition of **rotating each digit individually by 180 degrees** is not clear? I think the roatation might be:\\n\\n**1. rotate clockwise/counterclockwise?**\\n(X) 2 and 5 rotate to itself, and it is conflict with the problem description.\\n\\n**2. flip vertically** (Put a mirror besides the number and see what inside)\\n(O) 2 and 5 rotate to each other.\\n(X) 6 and 9 roate to itself, conflict.\\n\\n**3. flip horizontally** (Put a mirror under the number and see what inside)\\n(O) 2 and 5 rotate to each other.\\n(O) 6 and 9 roate to each other. (If 9 is wirtten like a lollipop)\\n**How about 3, 4, and 7?** \\n4 and 7 can not get a valid number, and 3 can rotate to itself. But the problem description does not mention about 3 and the testcase shows 3 is a bad number. Does that mean the rotation is not flip horizontally? So what is **rotating each digit individually by 180 degrees**?"
                    },
                    {
                        "username": "leetcode_yao",
                        "content": "2 and 5 rotate each other? why?\\nwhy 2->2 5->5 ?"
                    },
                    {
                        "username": "heesub",
                        "content": "This question makes me post my first comment here. I tried to understand this question and derive an optimal solution, but it was just a waste of time. Only brute-force solution exists. If this can be solved in a more efficient way, please enlighten me."
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "brute force is working without tle"
                    },
                    {
                        "username": "genegenehou",
                        "content": "I think `69` is not a good number, since if we rotate it by 180 degree, it\\'s still `69`.\\n\\nBut if you print out the good numbers with the AC solution, you\\'ll find `69` is a good number. Why?"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "we all know why it is a `good number` pun intended.\\n\\nactually -> 69 becomes 96 according to description."
                    }
                ]
            },
            {
                "id": 1569211,
                "content": [
                    {
                        "username": "edzaferovic",
                        "content": "The question says that a number is good if each individual number is rotated and the original number is different to the rotated number.\\n\\nHere is how rotations work:\\n\\n0 rotates to 0\\n1 rotates to 1\\n8 rotates to 8\\n\\n2 rotates to 5\\n5 rotates to 2\\n6 rotates to 9\\n9 rotates to 6 \\n\\nEvery other number 3,4 and 7 do not rotate and are invalid meaning if the number contains one of these it cannot be changed. \\n\\nSO this means that 20 would rotate to 50 bc 2 rotates to 5 and 0 stays the same. This number is good since 20 != 50.\\nAnother example is 33, since 3 is the first int it becomes invalid. Another example of this is 23, since 3 is the second int in the number it becomes invalid meaning even tho 2 changes to 5 and the number is 53, and 53 != 23, the 3 invalidates the number making it no good.\\n\\nHope this helps you guys understand what the question is asking for!\\n"
                    },
                    {
                        "username": "companion",
                        "content": "After rotating 180, 2 is still 2?"
                    },
                    {
                        "username": "shashwatpandeyy",
                        "content": "it become 5"
                    },
                    {
                        "username": "fmadrid",
                        "content": "[A Ludic Fallacy - Rotating Digits (Leet Code 788)](http://www.frankmadrid.com/ALudicFallacy/2018/02/28/rotated-digits-leet-code-788/)\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "guys the link is showing Ads don\\'t open ! It is un-relevant "
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "they should add in example 1 - > \\n[1,10] -> 2 , 5 ,  6  , 9 \\n\\n1 , `8` and 10 are not good numbers .\\nThey forgot to mention that 8 also comes under the range [1,10] and remains same after the rotation."
                    },
                    {
                        "username": "prajapatikunal7",
                        "content": "Can someone help me in understanding of \"180 degree of digit\" ?\\n\\nLike \\n1) How 2 can be rotated 180 degree to 5? \\n2) How 1 or 8 can be rotated 180 degree to digit themeselves ?\\n\\nThanks in advance"
                    },
                    {
                        "username": "mchim",
                        "content": "Flip it upside down, then 2 becomes 5."
                    },
                    {
                        "username": "yuweila",
                        "content": "I input 22 and 23 into testcase and get the result 11 and 11 respectively, \\nthat meas the nubmer 23 is a bad number. Is it? 2 to 5 and 3 to 3, so 23 to 53?\\n\\nIs it a bug or the problem is the definition of **rotating each digit individually by 180 degrees** is not clear? I think the roatation might be:\\n\\n**1. rotate clockwise/counterclockwise?**\\n(X) 2 and 5 rotate to itself, and it is conflict with the problem description.\\n\\n**2. flip vertically** (Put a mirror besides the number and see what inside)\\n(O) 2 and 5 rotate to each other.\\n(X) 6 and 9 roate to itself, conflict.\\n\\n**3. flip horizontally** (Put a mirror under the number and see what inside)\\n(O) 2 and 5 rotate to each other.\\n(O) 6 and 9 roate to each other. (If 9 is wirtten like a lollipop)\\n**How about 3, 4, and 7?** \\n4 and 7 can not get a valid number, and 3 can rotate to itself. But the problem description does not mention about 3 and the testcase shows 3 is a bad number. Does that mean the rotation is not flip horizontally? So what is **rotating each digit individually by 180 degrees**?"
                    },
                    {
                        "username": "leetcode_yao",
                        "content": "2 and 5 rotate each other? why?\\nwhy 2->2 5->5 ?"
                    },
                    {
                        "username": "heesub",
                        "content": "This question makes me post my first comment here. I tried to understand this question and derive an optimal solution, but it was just a waste of time. Only brute-force solution exists. If this can be solved in a more efficient way, please enlighten me."
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "brute force is working without tle"
                    },
                    {
                        "username": "genegenehou",
                        "content": "I think `69` is not a good number, since if we rotate it by 180 degree, it\\'s still `69`.\\n\\nBut if you print out the good numbers with the AC solution, you\\'ll find `69` is a good number. Why?"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "we all know why it is a `good number` pun intended.\\n\\nactually -> 69 becomes 96 according to description."
                    }
                ]
            },
            {
                "id": 1571911,
                "content": [
                    {
                        "username": "edzaferovic",
                        "content": "The question says that a number is good if each individual number is rotated and the original number is different to the rotated number.\\n\\nHere is how rotations work:\\n\\n0 rotates to 0\\n1 rotates to 1\\n8 rotates to 8\\n\\n2 rotates to 5\\n5 rotates to 2\\n6 rotates to 9\\n9 rotates to 6 \\n\\nEvery other number 3,4 and 7 do not rotate and are invalid meaning if the number contains one of these it cannot be changed. \\n\\nSO this means that 20 would rotate to 50 bc 2 rotates to 5 and 0 stays the same. This number is good since 20 != 50.\\nAnother example is 33, since 3 is the first int it becomes invalid. Another example of this is 23, since 3 is the second int in the number it becomes invalid meaning even tho 2 changes to 5 and the number is 53, and 53 != 23, the 3 invalidates the number making it no good.\\n\\nHope this helps you guys understand what the question is asking for!\\n"
                    },
                    {
                        "username": "companion",
                        "content": "After rotating 180, 2 is still 2?"
                    },
                    {
                        "username": "shashwatpandeyy",
                        "content": "it become 5"
                    },
                    {
                        "username": "fmadrid",
                        "content": "[A Ludic Fallacy - Rotating Digits (Leet Code 788)](http://www.frankmadrid.com/ALudicFallacy/2018/02/28/rotated-digits-leet-code-788/)\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "guys the link is showing Ads don\\'t open ! It is un-relevant "
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "they should add in example 1 - > \\n[1,10] -> 2 , 5 ,  6  , 9 \\n\\n1 , `8` and 10 are not good numbers .\\nThey forgot to mention that 8 also comes under the range [1,10] and remains same after the rotation."
                    },
                    {
                        "username": "prajapatikunal7",
                        "content": "Can someone help me in understanding of \"180 degree of digit\" ?\\n\\nLike \\n1) How 2 can be rotated 180 degree to 5? \\n2) How 1 or 8 can be rotated 180 degree to digit themeselves ?\\n\\nThanks in advance"
                    },
                    {
                        "username": "mchim",
                        "content": "Flip it upside down, then 2 becomes 5."
                    },
                    {
                        "username": "yuweila",
                        "content": "I input 22 and 23 into testcase and get the result 11 and 11 respectively, \\nthat meas the nubmer 23 is a bad number. Is it? 2 to 5 and 3 to 3, so 23 to 53?\\n\\nIs it a bug or the problem is the definition of **rotating each digit individually by 180 degrees** is not clear? I think the roatation might be:\\n\\n**1. rotate clockwise/counterclockwise?**\\n(X) 2 and 5 rotate to itself, and it is conflict with the problem description.\\n\\n**2. flip vertically** (Put a mirror besides the number and see what inside)\\n(O) 2 and 5 rotate to each other.\\n(X) 6 and 9 roate to itself, conflict.\\n\\n**3. flip horizontally** (Put a mirror under the number and see what inside)\\n(O) 2 and 5 rotate to each other.\\n(O) 6 and 9 roate to each other. (If 9 is wirtten like a lollipop)\\n**How about 3, 4, and 7?** \\n4 and 7 can not get a valid number, and 3 can rotate to itself. But the problem description does not mention about 3 and the testcase shows 3 is a bad number. Does that mean the rotation is not flip horizontally? So what is **rotating each digit individually by 180 degrees**?"
                    },
                    {
                        "username": "leetcode_yao",
                        "content": "2 and 5 rotate each other? why?\\nwhy 2->2 5->5 ?"
                    },
                    {
                        "username": "heesub",
                        "content": "This question makes me post my first comment here. I tried to understand this question and derive an optimal solution, but it was just a waste of time. Only brute-force solution exists. If this can be solved in a more efficient way, please enlighten me."
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "brute force is working without tle"
                    },
                    {
                        "username": "genegenehou",
                        "content": "I think `69` is not a good number, since if we rotate it by 180 degree, it\\'s still `69`.\\n\\nBut if you print out the good numbers with the AC solution, you\\'ll find `69` is a good number. Why?"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "we all know why it is a `good number` pun intended.\\n\\nactually -> 69 becomes 96 according to description."
                    }
                ]
            },
            {
                "id": 1917071,
                "content": [
                    {
                        "username": "edzaferovic",
                        "content": "The question says that a number is good if each individual number is rotated and the original number is different to the rotated number.\\n\\nHere is how rotations work:\\n\\n0 rotates to 0\\n1 rotates to 1\\n8 rotates to 8\\n\\n2 rotates to 5\\n5 rotates to 2\\n6 rotates to 9\\n9 rotates to 6 \\n\\nEvery other number 3,4 and 7 do not rotate and are invalid meaning if the number contains one of these it cannot be changed. \\n\\nSO this means that 20 would rotate to 50 bc 2 rotates to 5 and 0 stays the same. This number is good since 20 != 50.\\nAnother example is 33, since 3 is the first int it becomes invalid. Another example of this is 23, since 3 is the second int in the number it becomes invalid meaning even tho 2 changes to 5 and the number is 53, and 53 != 23, the 3 invalidates the number making it no good.\\n\\nHope this helps you guys understand what the question is asking for!\\n"
                    },
                    {
                        "username": "companion",
                        "content": "After rotating 180, 2 is still 2?"
                    },
                    {
                        "username": "shashwatpandeyy",
                        "content": "it become 5"
                    },
                    {
                        "username": "fmadrid",
                        "content": "[A Ludic Fallacy - Rotating Digits (Leet Code 788)](http://www.frankmadrid.com/ALudicFallacy/2018/02/28/rotated-digits-leet-code-788/)\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "guys the link is showing Ads don\\'t open ! It is un-relevant "
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "they should add in example 1 - > \\n[1,10] -> 2 , 5 ,  6  , 9 \\n\\n1 , `8` and 10 are not good numbers .\\nThey forgot to mention that 8 also comes under the range [1,10] and remains same after the rotation."
                    },
                    {
                        "username": "prajapatikunal7",
                        "content": "Can someone help me in understanding of \"180 degree of digit\" ?\\n\\nLike \\n1) How 2 can be rotated 180 degree to 5? \\n2) How 1 or 8 can be rotated 180 degree to digit themeselves ?\\n\\nThanks in advance"
                    },
                    {
                        "username": "mchim",
                        "content": "Flip it upside down, then 2 becomes 5."
                    },
                    {
                        "username": "yuweila",
                        "content": "I input 22 and 23 into testcase and get the result 11 and 11 respectively, \\nthat meas the nubmer 23 is a bad number. Is it? 2 to 5 and 3 to 3, so 23 to 53?\\n\\nIs it a bug or the problem is the definition of **rotating each digit individually by 180 degrees** is not clear? I think the roatation might be:\\n\\n**1. rotate clockwise/counterclockwise?**\\n(X) 2 and 5 rotate to itself, and it is conflict with the problem description.\\n\\n**2. flip vertically** (Put a mirror besides the number and see what inside)\\n(O) 2 and 5 rotate to each other.\\n(X) 6 and 9 roate to itself, conflict.\\n\\n**3. flip horizontally** (Put a mirror under the number and see what inside)\\n(O) 2 and 5 rotate to each other.\\n(O) 6 and 9 roate to each other. (If 9 is wirtten like a lollipop)\\n**How about 3, 4, and 7?** \\n4 and 7 can not get a valid number, and 3 can rotate to itself. But the problem description does not mention about 3 and the testcase shows 3 is a bad number. Does that mean the rotation is not flip horizontally? So what is **rotating each digit individually by 180 degrees**?"
                    },
                    {
                        "username": "leetcode_yao",
                        "content": "2 and 5 rotate each other? why?\\nwhy 2->2 5->5 ?"
                    },
                    {
                        "username": "heesub",
                        "content": "This question makes me post my first comment here. I tried to understand this question and derive an optimal solution, but it was just a waste of time. Only brute-force solution exists. If this can be solved in a more efficient way, please enlighten me."
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "brute force is working without tle"
                    },
                    {
                        "username": "genegenehou",
                        "content": "I think `69` is not a good number, since if we rotate it by 180 degree, it\\'s still `69`.\\n\\nBut if you print out the good numbers with the AC solution, you\\'ll find `69` is a good number. Why?"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "we all know why it is a `good number` pun intended.\\n\\nactually -> 69 becomes 96 according to description."
                    }
                ]
            },
            {
                "id": 1571920,
                "content": [
                    {
                        "username": "edzaferovic",
                        "content": "The question says that a number is good if each individual number is rotated and the original number is different to the rotated number.\\n\\nHere is how rotations work:\\n\\n0 rotates to 0\\n1 rotates to 1\\n8 rotates to 8\\n\\n2 rotates to 5\\n5 rotates to 2\\n6 rotates to 9\\n9 rotates to 6 \\n\\nEvery other number 3,4 and 7 do not rotate and are invalid meaning if the number contains one of these it cannot be changed. \\n\\nSO this means that 20 would rotate to 50 bc 2 rotates to 5 and 0 stays the same. This number is good since 20 != 50.\\nAnother example is 33, since 3 is the first int it becomes invalid. Another example of this is 23, since 3 is the second int in the number it becomes invalid meaning even tho 2 changes to 5 and the number is 53, and 53 != 23, the 3 invalidates the number making it no good.\\n\\nHope this helps you guys understand what the question is asking for!\\n"
                    },
                    {
                        "username": "companion",
                        "content": "After rotating 180, 2 is still 2?"
                    },
                    {
                        "username": "shashwatpandeyy",
                        "content": "it become 5"
                    },
                    {
                        "username": "fmadrid",
                        "content": "[A Ludic Fallacy - Rotating Digits (Leet Code 788)](http://www.frankmadrid.com/ALudicFallacy/2018/02/28/rotated-digits-leet-code-788/)\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "guys the link is showing Ads don\\'t open ! It is un-relevant "
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "they should add in example 1 - > \\n[1,10] -> 2 , 5 ,  6  , 9 \\n\\n1 , `8` and 10 are not good numbers .\\nThey forgot to mention that 8 also comes under the range [1,10] and remains same after the rotation."
                    },
                    {
                        "username": "prajapatikunal7",
                        "content": "Can someone help me in understanding of \"180 degree of digit\" ?\\n\\nLike \\n1) How 2 can be rotated 180 degree to 5? \\n2) How 1 or 8 can be rotated 180 degree to digit themeselves ?\\n\\nThanks in advance"
                    },
                    {
                        "username": "mchim",
                        "content": "Flip it upside down, then 2 becomes 5."
                    },
                    {
                        "username": "yuweila",
                        "content": "I input 22 and 23 into testcase and get the result 11 and 11 respectively, \\nthat meas the nubmer 23 is a bad number. Is it? 2 to 5 and 3 to 3, so 23 to 53?\\n\\nIs it a bug or the problem is the definition of **rotating each digit individually by 180 degrees** is not clear? I think the roatation might be:\\n\\n**1. rotate clockwise/counterclockwise?**\\n(X) 2 and 5 rotate to itself, and it is conflict with the problem description.\\n\\n**2. flip vertically** (Put a mirror besides the number and see what inside)\\n(O) 2 and 5 rotate to each other.\\n(X) 6 and 9 roate to itself, conflict.\\n\\n**3. flip horizontally** (Put a mirror under the number and see what inside)\\n(O) 2 and 5 rotate to each other.\\n(O) 6 and 9 roate to each other. (If 9 is wirtten like a lollipop)\\n**How about 3, 4, and 7?** \\n4 and 7 can not get a valid number, and 3 can rotate to itself. But the problem description does not mention about 3 and the testcase shows 3 is a bad number. Does that mean the rotation is not flip horizontally? So what is **rotating each digit individually by 180 degrees**?"
                    },
                    {
                        "username": "leetcode_yao",
                        "content": "2 and 5 rotate each other? why?\\nwhy 2->2 5->5 ?"
                    },
                    {
                        "username": "heesub",
                        "content": "This question makes me post my first comment here. I tried to understand this question and derive an optimal solution, but it was just a waste of time. Only brute-force solution exists. If this can be solved in a more efficient way, please enlighten me."
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "brute force is working without tle"
                    },
                    {
                        "username": "genegenehou",
                        "content": "I think `69` is not a good number, since if we rotate it by 180 degree, it\\'s still `69`.\\n\\nBut if you print out the good numbers with the AC solution, you\\'ll find `69` is a good number. Why?"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "we all know why it is a `good number` pun intended.\\n\\nactually -> 69 becomes 96 according to description."
                    }
                ]
            },
            {
                "id": 1564759,
                "content": [
                    {
                        "username": "edzaferovic",
                        "content": "The question says that a number is good if each individual number is rotated and the original number is different to the rotated number.\\n\\nHere is how rotations work:\\n\\n0 rotates to 0\\n1 rotates to 1\\n8 rotates to 8\\n\\n2 rotates to 5\\n5 rotates to 2\\n6 rotates to 9\\n9 rotates to 6 \\n\\nEvery other number 3,4 and 7 do not rotate and are invalid meaning if the number contains one of these it cannot be changed. \\n\\nSO this means that 20 would rotate to 50 bc 2 rotates to 5 and 0 stays the same. This number is good since 20 != 50.\\nAnother example is 33, since 3 is the first int it becomes invalid. Another example of this is 23, since 3 is the second int in the number it becomes invalid meaning even tho 2 changes to 5 and the number is 53, and 53 != 23, the 3 invalidates the number making it no good.\\n\\nHope this helps you guys understand what the question is asking for!\\n"
                    },
                    {
                        "username": "companion",
                        "content": "After rotating 180, 2 is still 2?"
                    },
                    {
                        "username": "shashwatpandeyy",
                        "content": "it become 5"
                    },
                    {
                        "username": "fmadrid",
                        "content": "[A Ludic Fallacy - Rotating Digits (Leet Code 788)](http://www.frankmadrid.com/ALudicFallacy/2018/02/28/rotated-digits-leet-code-788/)\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "guys the link is showing Ads don\\'t open ! It is un-relevant "
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "they should add in example 1 - > \\n[1,10] -> 2 , 5 ,  6  , 9 \\n\\n1 , `8` and 10 are not good numbers .\\nThey forgot to mention that 8 also comes under the range [1,10] and remains same after the rotation."
                    },
                    {
                        "username": "prajapatikunal7",
                        "content": "Can someone help me in understanding of \"180 degree of digit\" ?\\n\\nLike \\n1) How 2 can be rotated 180 degree to 5? \\n2) How 1 or 8 can be rotated 180 degree to digit themeselves ?\\n\\nThanks in advance"
                    },
                    {
                        "username": "mchim",
                        "content": "Flip it upside down, then 2 becomes 5."
                    },
                    {
                        "username": "yuweila",
                        "content": "I input 22 and 23 into testcase and get the result 11 and 11 respectively, \\nthat meas the nubmer 23 is a bad number. Is it? 2 to 5 and 3 to 3, so 23 to 53?\\n\\nIs it a bug or the problem is the definition of **rotating each digit individually by 180 degrees** is not clear? I think the roatation might be:\\n\\n**1. rotate clockwise/counterclockwise?**\\n(X) 2 and 5 rotate to itself, and it is conflict with the problem description.\\n\\n**2. flip vertically** (Put a mirror besides the number and see what inside)\\n(O) 2 and 5 rotate to each other.\\n(X) 6 and 9 roate to itself, conflict.\\n\\n**3. flip horizontally** (Put a mirror under the number and see what inside)\\n(O) 2 and 5 rotate to each other.\\n(O) 6 and 9 roate to each other. (If 9 is wirtten like a lollipop)\\n**How about 3, 4, and 7?** \\n4 and 7 can not get a valid number, and 3 can rotate to itself. But the problem description does not mention about 3 and the testcase shows 3 is a bad number. Does that mean the rotation is not flip horizontally? So what is **rotating each digit individually by 180 degrees**?"
                    },
                    {
                        "username": "leetcode_yao",
                        "content": "2 and 5 rotate each other? why?\\nwhy 2->2 5->5 ?"
                    },
                    {
                        "username": "heesub",
                        "content": "This question makes me post my first comment here. I tried to understand this question and derive an optimal solution, but it was just a waste of time. Only brute-force solution exists. If this can be solved in a more efficient way, please enlighten me."
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "brute force is working without tle"
                    },
                    {
                        "username": "genegenehou",
                        "content": "I think `69` is not a good number, since if we rotate it by 180 degree, it\\'s still `69`.\\n\\nBut if you print out the good numbers with the AC solution, you\\'ll find `69` is a good number. Why?"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "we all know why it is a `good number` pun intended.\\n\\nactually -> 69 becomes 96 according to description."
                    }
                ]
            },
            {
                "id": 1565675,
                "content": [
                    {
                        "username": "edzaferovic",
                        "content": "The question says that a number is good if each individual number is rotated and the original number is different to the rotated number.\\n\\nHere is how rotations work:\\n\\n0 rotates to 0\\n1 rotates to 1\\n8 rotates to 8\\n\\n2 rotates to 5\\n5 rotates to 2\\n6 rotates to 9\\n9 rotates to 6 \\n\\nEvery other number 3,4 and 7 do not rotate and are invalid meaning if the number contains one of these it cannot be changed. \\n\\nSO this means that 20 would rotate to 50 bc 2 rotates to 5 and 0 stays the same. This number is good since 20 != 50.\\nAnother example is 33, since 3 is the first int it becomes invalid. Another example of this is 23, since 3 is the second int in the number it becomes invalid meaning even tho 2 changes to 5 and the number is 53, and 53 != 23, the 3 invalidates the number making it no good.\\n\\nHope this helps you guys understand what the question is asking for!\\n"
                    },
                    {
                        "username": "companion",
                        "content": "After rotating 180, 2 is still 2?"
                    },
                    {
                        "username": "shashwatpandeyy",
                        "content": "it become 5"
                    },
                    {
                        "username": "fmadrid",
                        "content": "[A Ludic Fallacy - Rotating Digits (Leet Code 788)](http://www.frankmadrid.com/ALudicFallacy/2018/02/28/rotated-digits-leet-code-788/)\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "guys the link is showing Ads don\\'t open ! It is un-relevant "
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "they should add in example 1 - > \\n[1,10] -> 2 , 5 ,  6  , 9 \\n\\n1 , `8` and 10 are not good numbers .\\nThey forgot to mention that 8 also comes under the range [1,10] and remains same after the rotation."
                    },
                    {
                        "username": "prajapatikunal7",
                        "content": "Can someone help me in understanding of \"180 degree of digit\" ?\\n\\nLike \\n1) How 2 can be rotated 180 degree to 5? \\n2) How 1 or 8 can be rotated 180 degree to digit themeselves ?\\n\\nThanks in advance"
                    },
                    {
                        "username": "mchim",
                        "content": "Flip it upside down, then 2 becomes 5."
                    },
                    {
                        "username": "yuweila",
                        "content": "I input 22 and 23 into testcase and get the result 11 and 11 respectively, \\nthat meas the nubmer 23 is a bad number. Is it? 2 to 5 and 3 to 3, so 23 to 53?\\n\\nIs it a bug or the problem is the definition of **rotating each digit individually by 180 degrees** is not clear? I think the roatation might be:\\n\\n**1. rotate clockwise/counterclockwise?**\\n(X) 2 and 5 rotate to itself, and it is conflict with the problem description.\\n\\n**2. flip vertically** (Put a mirror besides the number and see what inside)\\n(O) 2 and 5 rotate to each other.\\n(X) 6 and 9 roate to itself, conflict.\\n\\n**3. flip horizontally** (Put a mirror under the number and see what inside)\\n(O) 2 and 5 rotate to each other.\\n(O) 6 and 9 roate to each other. (If 9 is wirtten like a lollipop)\\n**How about 3, 4, and 7?** \\n4 and 7 can not get a valid number, and 3 can rotate to itself. But the problem description does not mention about 3 and the testcase shows 3 is a bad number. Does that mean the rotation is not flip horizontally? So what is **rotating each digit individually by 180 degrees**?"
                    },
                    {
                        "username": "leetcode_yao",
                        "content": "2 and 5 rotate each other? why?\\nwhy 2->2 5->5 ?"
                    },
                    {
                        "username": "heesub",
                        "content": "This question makes me post my first comment here. I tried to understand this question and derive an optimal solution, but it was just a waste of time. Only brute-force solution exists. If this can be solved in a more efficient way, please enlighten me."
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "brute force is working without tle"
                    },
                    {
                        "username": "genegenehou",
                        "content": "I think `69` is not a good number, since if we rotate it by 180 degree, it\\'s still `69`.\\n\\nBut if you print out the good numbers with the AC solution, you\\'ll find `69` is a good number. Why?"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "we all know why it is a `good number` pun intended.\\n\\nactually -> 69 becomes 96 according to description."
                    }
                ]
            },
            {
                "id": 1565164,
                "content": [
                    {
                        "username": "edzaferovic",
                        "content": "The question says that a number is good if each individual number is rotated and the original number is different to the rotated number.\\n\\nHere is how rotations work:\\n\\n0 rotates to 0\\n1 rotates to 1\\n8 rotates to 8\\n\\n2 rotates to 5\\n5 rotates to 2\\n6 rotates to 9\\n9 rotates to 6 \\n\\nEvery other number 3,4 and 7 do not rotate and are invalid meaning if the number contains one of these it cannot be changed. \\n\\nSO this means that 20 would rotate to 50 bc 2 rotates to 5 and 0 stays the same. This number is good since 20 != 50.\\nAnother example is 33, since 3 is the first int it becomes invalid. Another example of this is 23, since 3 is the second int in the number it becomes invalid meaning even tho 2 changes to 5 and the number is 53, and 53 != 23, the 3 invalidates the number making it no good.\\n\\nHope this helps you guys understand what the question is asking for!\\n"
                    },
                    {
                        "username": "companion",
                        "content": "After rotating 180, 2 is still 2?"
                    },
                    {
                        "username": "shashwatpandeyy",
                        "content": "it become 5"
                    },
                    {
                        "username": "fmadrid",
                        "content": "[A Ludic Fallacy - Rotating Digits (Leet Code 788)](http://www.frankmadrid.com/ALudicFallacy/2018/02/28/rotated-digits-leet-code-788/)\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "guys the link is showing Ads don\\'t open ! It is un-relevant "
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "they should add in example 1 - > \\n[1,10] -> 2 , 5 ,  6  , 9 \\n\\n1 , `8` and 10 are not good numbers .\\nThey forgot to mention that 8 also comes under the range [1,10] and remains same after the rotation."
                    },
                    {
                        "username": "prajapatikunal7",
                        "content": "Can someone help me in understanding of \"180 degree of digit\" ?\\n\\nLike \\n1) How 2 can be rotated 180 degree to 5? \\n2) How 1 or 8 can be rotated 180 degree to digit themeselves ?\\n\\nThanks in advance"
                    },
                    {
                        "username": "mchim",
                        "content": "Flip it upside down, then 2 becomes 5."
                    },
                    {
                        "username": "yuweila",
                        "content": "I input 22 and 23 into testcase and get the result 11 and 11 respectively, \\nthat meas the nubmer 23 is a bad number. Is it? 2 to 5 and 3 to 3, so 23 to 53?\\n\\nIs it a bug or the problem is the definition of **rotating each digit individually by 180 degrees** is not clear? I think the roatation might be:\\n\\n**1. rotate clockwise/counterclockwise?**\\n(X) 2 and 5 rotate to itself, and it is conflict with the problem description.\\n\\n**2. flip vertically** (Put a mirror besides the number and see what inside)\\n(O) 2 and 5 rotate to each other.\\n(X) 6 and 9 roate to itself, conflict.\\n\\n**3. flip horizontally** (Put a mirror under the number and see what inside)\\n(O) 2 and 5 rotate to each other.\\n(O) 6 and 9 roate to each other. (If 9 is wirtten like a lollipop)\\n**How about 3, 4, and 7?** \\n4 and 7 can not get a valid number, and 3 can rotate to itself. But the problem description does not mention about 3 and the testcase shows 3 is a bad number. Does that mean the rotation is not flip horizontally? So what is **rotating each digit individually by 180 degrees**?"
                    },
                    {
                        "username": "leetcode_yao",
                        "content": "2 and 5 rotate each other? why?\\nwhy 2->2 5->5 ?"
                    },
                    {
                        "username": "heesub",
                        "content": "This question makes me post my first comment here. I tried to understand this question and derive an optimal solution, but it was just a waste of time. Only brute-force solution exists. If this can be solved in a more efficient way, please enlighten me."
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "brute force is working without tle"
                    },
                    {
                        "username": "genegenehou",
                        "content": "I think `69` is not a good number, since if we rotate it by 180 degree, it\\'s still `69`.\\n\\nBut if you print out the good numbers with the AC solution, you\\'ll find `69` is a good number. Why?"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "we all know why it is a `good number` pun intended.\\n\\nactually -> 69 becomes 96 according to description."
                    }
                ]
            },
            {
                "id": 1676058,
                "content": [
                    {
                        "username": "edzaferovic",
                        "content": "The question says that a number is good if each individual number is rotated and the original number is different to the rotated number.\\n\\nHere is how rotations work:\\n\\n0 rotates to 0\\n1 rotates to 1\\n8 rotates to 8\\n\\n2 rotates to 5\\n5 rotates to 2\\n6 rotates to 9\\n9 rotates to 6 \\n\\nEvery other number 3,4 and 7 do not rotate and are invalid meaning if the number contains one of these it cannot be changed. \\n\\nSO this means that 20 would rotate to 50 bc 2 rotates to 5 and 0 stays the same. This number is good since 20 != 50.\\nAnother example is 33, since 3 is the first int it becomes invalid. Another example of this is 23, since 3 is the second int in the number it becomes invalid meaning even tho 2 changes to 5 and the number is 53, and 53 != 23, the 3 invalidates the number making it no good.\\n\\nHope this helps you guys understand what the question is asking for!\\n"
                    },
                    {
                        "username": "companion",
                        "content": "After rotating 180, 2 is still 2?"
                    },
                    {
                        "username": "shashwatpandeyy",
                        "content": "it become 5"
                    },
                    {
                        "username": "fmadrid",
                        "content": "[A Ludic Fallacy - Rotating Digits (Leet Code 788)](http://www.frankmadrid.com/ALudicFallacy/2018/02/28/rotated-digits-leet-code-788/)\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "guys the link is showing Ads don\\'t open ! It is un-relevant "
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "they should add in example 1 - > \\n[1,10] -> 2 , 5 ,  6  , 9 \\n\\n1 , `8` and 10 are not good numbers .\\nThey forgot to mention that 8 also comes under the range [1,10] and remains same after the rotation."
                    },
                    {
                        "username": "prajapatikunal7",
                        "content": "Can someone help me in understanding of \"180 degree of digit\" ?\\n\\nLike \\n1) How 2 can be rotated 180 degree to 5? \\n2) How 1 or 8 can be rotated 180 degree to digit themeselves ?\\n\\nThanks in advance"
                    },
                    {
                        "username": "mchim",
                        "content": "Flip it upside down, then 2 becomes 5."
                    },
                    {
                        "username": "yuweila",
                        "content": "I input 22 and 23 into testcase and get the result 11 and 11 respectively, \\nthat meas the nubmer 23 is a bad number. Is it? 2 to 5 and 3 to 3, so 23 to 53?\\n\\nIs it a bug or the problem is the definition of **rotating each digit individually by 180 degrees** is not clear? I think the roatation might be:\\n\\n**1. rotate clockwise/counterclockwise?**\\n(X) 2 and 5 rotate to itself, and it is conflict with the problem description.\\n\\n**2. flip vertically** (Put a mirror besides the number and see what inside)\\n(O) 2 and 5 rotate to each other.\\n(X) 6 and 9 roate to itself, conflict.\\n\\n**3. flip horizontally** (Put a mirror under the number and see what inside)\\n(O) 2 and 5 rotate to each other.\\n(O) 6 and 9 roate to each other. (If 9 is wirtten like a lollipop)\\n**How about 3, 4, and 7?** \\n4 and 7 can not get a valid number, and 3 can rotate to itself. But the problem description does not mention about 3 and the testcase shows 3 is a bad number. Does that mean the rotation is not flip horizontally? So what is **rotating each digit individually by 180 degrees**?"
                    },
                    {
                        "username": "leetcode_yao",
                        "content": "2 and 5 rotate each other? why?\\nwhy 2->2 5->5 ?"
                    },
                    {
                        "username": "heesub",
                        "content": "This question makes me post my first comment here. I tried to understand this question and derive an optimal solution, but it was just a waste of time. Only brute-force solution exists. If this can be solved in a more efficient way, please enlighten me."
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "brute force is working without tle"
                    },
                    {
                        "username": "genegenehou",
                        "content": "I think `69` is not a good number, since if we rotate it by 180 degree, it\\'s still `69`.\\n\\nBut if you print out the good numbers with the AC solution, you\\'ll find `69` is a good number. Why?"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "we all know why it is a `good number` pun intended.\\n\\nactually -> 69 becomes 96 according to description."
                    }
                ]
            },
            {
                "id": 1573766,
                "content": [
                    {
                        "username": "edzaferovic",
                        "content": "The question says that a number is good if each individual number is rotated and the original number is different to the rotated number.\\n\\nHere is how rotations work:\\n\\n0 rotates to 0\\n1 rotates to 1\\n8 rotates to 8\\n\\n2 rotates to 5\\n5 rotates to 2\\n6 rotates to 9\\n9 rotates to 6 \\n\\nEvery other number 3,4 and 7 do not rotate and are invalid meaning if the number contains one of these it cannot be changed. \\n\\nSO this means that 20 would rotate to 50 bc 2 rotates to 5 and 0 stays the same. This number is good since 20 != 50.\\nAnother example is 33, since 3 is the first int it becomes invalid. Another example of this is 23, since 3 is the second int in the number it becomes invalid meaning even tho 2 changes to 5 and the number is 53, and 53 != 23, the 3 invalidates the number making it no good.\\n\\nHope this helps you guys understand what the question is asking for!\\n"
                    },
                    {
                        "username": "companion",
                        "content": "After rotating 180, 2 is still 2?"
                    },
                    {
                        "username": "shashwatpandeyy",
                        "content": "it become 5"
                    },
                    {
                        "username": "fmadrid",
                        "content": "[A Ludic Fallacy - Rotating Digits (Leet Code 788)](http://www.frankmadrid.com/ALudicFallacy/2018/02/28/rotated-digits-leet-code-788/)\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "guys the link is showing Ads don\\'t open ! It is un-relevant "
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "they should add in example 1 - > \\n[1,10] -> 2 , 5 ,  6  , 9 \\n\\n1 , `8` and 10 are not good numbers .\\nThey forgot to mention that 8 also comes under the range [1,10] and remains same after the rotation."
                    },
                    {
                        "username": "prajapatikunal7",
                        "content": "Can someone help me in understanding of \"180 degree of digit\" ?\\n\\nLike \\n1) How 2 can be rotated 180 degree to 5? \\n2) How 1 or 8 can be rotated 180 degree to digit themeselves ?\\n\\nThanks in advance"
                    },
                    {
                        "username": "mchim",
                        "content": "Flip it upside down, then 2 becomes 5."
                    },
                    {
                        "username": "yuweila",
                        "content": "I input 22 and 23 into testcase and get the result 11 and 11 respectively, \\nthat meas the nubmer 23 is a bad number. Is it? 2 to 5 and 3 to 3, so 23 to 53?\\n\\nIs it a bug or the problem is the definition of **rotating each digit individually by 180 degrees** is not clear? I think the roatation might be:\\n\\n**1. rotate clockwise/counterclockwise?**\\n(X) 2 and 5 rotate to itself, and it is conflict with the problem description.\\n\\n**2. flip vertically** (Put a mirror besides the number and see what inside)\\n(O) 2 and 5 rotate to each other.\\n(X) 6 and 9 roate to itself, conflict.\\n\\n**3. flip horizontally** (Put a mirror under the number and see what inside)\\n(O) 2 and 5 rotate to each other.\\n(O) 6 and 9 roate to each other. (If 9 is wirtten like a lollipop)\\n**How about 3, 4, and 7?** \\n4 and 7 can not get a valid number, and 3 can rotate to itself. But the problem description does not mention about 3 and the testcase shows 3 is a bad number. Does that mean the rotation is not flip horizontally? So what is **rotating each digit individually by 180 degrees**?"
                    },
                    {
                        "username": "leetcode_yao",
                        "content": "2 and 5 rotate each other? why?\\nwhy 2->2 5->5 ?"
                    },
                    {
                        "username": "heesub",
                        "content": "This question makes me post my first comment here. I tried to understand this question and derive an optimal solution, but it was just a waste of time. Only brute-force solution exists. If this can be solved in a more efficient way, please enlighten me."
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "brute force is working without tle"
                    },
                    {
                        "username": "genegenehou",
                        "content": "I think `69` is not a good number, since if we rotate it by 180 degree, it\\'s still `69`.\\n\\nBut if you print out the good numbers with the AC solution, you\\'ll find `69` is a good number. Why?"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "we all know why it is a `good number` pun intended.\\n\\nactually -> 69 becomes 96 according to description."
                    }
                ]
            },
            {
                "id": 1569229,
                "content": [
                    {
                        "username": "edzaferovic",
                        "content": "The question says that a number is good if each individual number is rotated and the original number is different to the rotated number.\\n\\nHere is how rotations work:\\n\\n0 rotates to 0\\n1 rotates to 1\\n8 rotates to 8\\n\\n2 rotates to 5\\n5 rotates to 2\\n6 rotates to 9\\n9 rotates to 6 \\n\\nEvery other number 3,4 and 7 do not rotate and are invalid meaning if the number contains one of these it cannot be changed. \\n\\nSO this means that 20 would rotate to 50 bc 2 rotates to 5 and 0 stays the same. This number is good since 20 != 50.\\nAnother example is 33, since 3 is the first int it becomes invalid. Another example of this is 23, since 3 is the second int in the number it becomes invalid meaning even tho 2 changes to 5 and the number is 53, and 53 != 23, the 3 invalidates the number making it no good.\\n\\nHope this helps you guys understand what the question is asking for!\\n"
                    },
                    {
                        "username": "companion",
                        "content": "After rotating 180, 2 is still 2?"
                    },
                    {
                        "username": "shashwatpandeyy",
                        "content": "it become 5"
                    },
                    {
                        "username": "fmadrid",
                        "content": "[A Ludic Fallacy - Rotating Digits (Leet Code 788)](http://www.frankmadrid.com/ALudicFallacy/2018/02/28/rotated-digits-leet-code-788/)\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "guys the link is showing Ads don\\'t open ! It is un-relevant "
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "they should add in example 1 - > \\n[1,10] -> 2 , 5 ,  6  , 9 \\n\\n1 , `8` and 10 are not good numbers .\\nThey forgot to mention that 8 also comes under the range [1,10] and remains same after the rotation."
                    },
                    {
                        "username": "prajapatikunal7",
                        "content": "Can someone help me in understanding of \"180 degree of digit\" ?\\n\\nLike \\n1) How 2 can be rotated 180 degree to 5? \\n2) How 1 or 8 can be rotated 180 degree to digit themeselves ?\\n\\nThanks in advance"
                    },
                    {
                        "username": "mchim",
                        "content": "Flip it upside down, then 2 becomes 5."
                    },
                    {
                        "username": "yuweila",
                        "content": "I input 22 and 23 into testcase and get the result 11 and 11 respectively, \\nthat meas the nubmer 23 is a bad number. Is it? 2 to 5 and 3 to 3, so 23 to 53?\\n\\nIs it a bug or the problem is the definition of **rotating each digit individually by 180 degrees** is not clear? I think the roatation might be:\\n\\n**1. rotate clockwise/counterclockwise?**\\n(X) 2 and 5 rotate to itself, and it is conflict with the problem description.\\n\\n**2. flip vertically** (Put a mirror besides the number and see what inside)\\n(O) 2 and 5 rotate to each other.\\n(X) 6 and 9 roate to itself, conflict.\\n\\n**3. flip horizontally** (Put a mirror under the number and see what inside)\\n(O) 2 and 5 rotate to each other.\\n(O) 6 and 9 roate to each other. (If 9 is wirtten like a lollipop)\\n**How about 3, 4, and 7?** \\n4 and 7 can not get a valid number, and 3 can rotate to itself. But the problem description does not mention about 3 and the testcase shows 3 is a bad number. Does that mean the rotation is not flip horizontally? So what is **rotating each digit individually by 180 degrees**?"
                    },
                    {
                        "username": "leetcode_yao",
                        "content": "2 and 5 rotate each other? why?\\nwhy 2->2 5->5 ?"
                    },
                    {
                        "username": "heesub",
                        "content": "This question makes me post my first comment here. I tried to understand this question and derive an optimal solution, but it was just a waste of time. Only brute-force solution exists. If this can be solved in a more efficient way, please enlighten me."
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "brute force is working without tle"
                    },
                    {
                        "username": "genegenehou",
                        "content": "I think `69` is not a good number, since if we rotate it by 180 degree, it\\'s still `69`.\\n\\nBut if you print out the good numbers with the AC solution, you\\'ll find `69` is a good number. Why?"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "we all know why it is a `good number` pun intended.\\n\\nactually -> 69 becomes 96 according to description."
                    }
                ]
            },
            {
                "id": 1569211,
                "content": [
                    {
                        "username": "edzaferovic",
                        "content": "The question says that a number is good if each individual number is rotated and the original number is different to the rotated number.\\n\\nHere is how rotations work:\\n\\n0 rotates to 0\\n1 rotates to 1\\n8 rotates to 8\\n\\n2 rotates to 5\\n5 rotates to 2\\n6 rotates to 9\\n9 rotates to 6 \\n\\nEvery other number 3,4 and 7 do not rotate and are invalid meaning if the number contains one of these it cannot be changed. \\n\\nSO this means that 20 would rotate to 50 bc 2 rotates to 5 and 0 stays the same. This number is good since 20 != 50.\\nAnother example is 33, since 3 is the first int it becomes invalid. Another example of this is 23, since 3 is the second int in the number it becomes invalid meaning even tho 2 changes to 5 and the number is 53, and 53 != 23, the 3 invalidates the number making it no good.\\n\\nHope this helps you guys understand what the question is asking for!\\n"
                    },
                    {
                        "username": "companion",
                        "content": "After rotating 180, 2 is still 2?"
                    },
                    {
                        "username": "shashwatpandeyy",
                        "content": "it become 5"
                    },
                    {
                        "username": "fmadrid",
                        "content": "[A Ludic Fallacy - Rotating Digits (Leet Code 788)](http://www.frankmadrid.com/ALudicFallacy/2018/02/28/rotated-digits-leet-code-788/)\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "guys the link is showing Ads don\\'t open ! It is un-relevant "
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "they should add in example 1 - > \\n[1,10] -> 2 , 5 ,  6  , 9 \\n\\n1 , `8` and 10 are not good numbers .\\nThey forgot to mention that 8 also comes under the range [1,10] and remains same after the rotation."
                    },
                    {
                        "username": "prajapatikunal7",
                        "content": "Can someone help me in understanding of \"180 degree of digit\" ?\\n\\nLike \\n1) How 2 can be rotated 180 degree to 5? \\n2) How 1 or 8 can be rotated 180 degree to digit themeselves ?\\n\\nThanks in advance"
                    },
                    {
                        "username": "mchim",
                        "content": "Flip it upside down, then 2 becomes 5."
                    },
                    {
                        "username": "yuweila",
                        "content": "I input 22 and 23 into testcase and get the result 11 and 11 respectively, \\nthat meas the nubmer 23 is a bad number. Is it? 2 to 5 and 3 to 3, so 23 to 53?\\n\\nIs it a bug or the problem is the definition of **rotating each digit individually by 180 degrees** is not clear? I think the roatation might be:\\n\\n**1. rotate clockwise/counterclockwise?**\\n(X) 2 and 5 rotate to itself, and it is conflict with the problem description.\\n\\n**2. flip vertically** (Put a mirror besides the number and see what inside)\\n(O) 2 and 5 rotate to each other.\\n(X) 6 and 9 roate to itself, conflict.\\n\\n**3. flip horizontally** (Put a mirror under the number and see what inside)\\n(O) 2 and 5 rotate to each other.\\n(O) 6 and 9 roate to each other. (If 9 is wirtten like a lollipop)\\n**How about 3, 4, and 7?** \\n4 and 7 can not get a valid number, and 3 can rotate to itself. But the problem description does not mention about 3 and the testcase shows 3 is a bad number. Does that mean the rotation is not flip horizontally? So what is **rotating each digit individually by 180 degrees**?"
                    },
                    {
                        "username": "leetcode_yao",
                        "content": "2 and 5 rotate each other? why?\\nwhy 2->2 5->5 ?"
                    },
                    {
                        "username": "heesub",
                        "content": "This question makes me post my first comment here. I tried to understand this question and derive an optimal solution, but it was just a waste of time. Only brute-force solution exists. If this can be solved in a more efficient way, please enlighten me."
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "brute force is working without tle"
                    },
                    {
                        "username": "genegenehou",
                        "content": "I think `69` is not a good number, since if we rotate it by 180 degree, it\\'s still `69`.\\n\\nBut if you print out the good numbers with the AC solution, you\\'ll find `69` is a good number. Why?"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "we all know why it is a `good number` pun intended.\\n\\nactually -> 69 becomes 96 according to description."
                    }
                ]
            },
            {
                "id": 1571911,
                "content": [
                    {
                        "username": "edzaferovic",
                        "content": "The question says that a number is good if each individual number is rotated and the original number is different to the rotated number.\\n\\nHere is how rotations work:\\n\\n0 rotates to 0\\n1 rotates to 1\\n8 rotates to 8\\n\\n2 rotates to 5\\n5 rotates to 2\\n6 rotates to 9\\n9 rotates to 6 \\n\\nEvery other number 3,4 and 7 do not rotate and are invalid meaning if the number contains one of these it cannot be changed. \\n\\nSO this means that 20 would rotate to 50 bc 2 rotates to 5 and 0 stays the same. This number is good since 20 != 50.\\nAnother example is 33, since 3 is the first int it becomes invalid. Another example of this is 23, since 3 is the second int in the number it becomes invalid meaning even tho 2 changes to 5 and the number is 53, and 53 != 23, the 3 invalidates the number making it no good.\\n\\nHope this helps you guys understand what the question is asking for!\\n"
                    },
                    {
                        "username": "companion",
                        "content": "After rotating 180, 2 is still 2?"
                    },
                    {
                        "username": "shashwatpandeyy",
                        "content": "it become 5"
                    },
                    {
                        "username": "fmadrid",
                        "content": "[A Ludic Fallacy - Rotating Digits (Leet Code 788)](http://www.frankmadrid.com/ALudicFallacy/2018/02/28/rotated-digits-leet-code-788/)\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "guys the link is showing Ads don\\'t open ! It is un-relevant "
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "they should add in example 1 - > \\n[1,10] -> 2 , 5 ,  6  , 9 \\n\\n1 , `8` and 10 are not good numbers .\\nThey forgot to mention that 8 also comes under the range [1,10] and remains same after the rotation."
                    },
                    {
                        "username": "prajapatikunal7",
                        "content": "Can someone help me in understanding of \"180 degree of digit\" ?\\n\\nLike \\n1) How 2 can be rotated 180 degree to 5? \\n2) How 1 or 8 can be rotated 180 degree to digit themeselves ?\\n\\nThanks in advance"
                    },
                    {
                        "username": "mchim",
                        "content": "Flip it upside down, then 2 becomes 5."
                    },
                    {
                        "username": "yuweila",
                        "content": "I input 22 and 23 into testcase and get the result 11 and 11 respectively, \\nthat meas the nubmer 23 is a bad number. Is it? 2 to 5 and 3 to 3, so 23 to 53?\\n\\nIs it a bug or the problem is the definition of **rotating each digit individually by 180 degrees** is not clear? I think the roatation might be:\\n\\n**1. rotate clockwise/counterclockwise?**\\n(X) 2 and 5 rotate to itself, and it is conflict with the problem description.\\n\\n**2. flip vertically** (Put a mirror besides the number and see what inside)\\n(O) 2 and 5 rotate to each other.\\n(X) 6 and 9 roate to itself, conflict.\\n\\n**3. flip horizontally** (Put a mirror under the number and see what inside)\\n(O) 2 and 5 rotate to each other.\\n(O) 6 and 9 roate to each other. (If 9 is wirtten like a lollipop)\\n**How about 3, 4, and 7?** \\n4 and 7 can not get a valid number, and 3 can rotate to itself. But the problem description does not mention about 3 and the testcase shows 3 is a bad number. Does that mean the rotation is not flip horizontally? So what is **rotating each digit individually by 180 degrees**?"
                    },
                    {
                        "username": "leetcode_yao",
                        "content": "2 and 5 rotate each other? why?\\nwhy 2->2 5->5 ?"
                    },
                    {
                        "username": "heesub",
                        "content": "This question makes me post my first comment here. I tried to understand this question and derive an optimal solution, but it was just a waste of time. Only brute-force solution exists. If this can be solved in a more efficient way, please enlighten me."
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "brute force is working without tle"
                    },
                    {
                        "username": "genegenehou",
                        "content": "I think `69` is not a good number, since if we rotate it by 180 degree, it\\'s still `69`.\\n\\nBut if you print out the good numbers with the AC solution, you\\'ll find `69` is a good number. Why?"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "we all know why it is a `good number` pun intended.\\n\\nactually -> 69 becomes 96 according to description."
                    }
                ]
            },
            {
                "id": 1917071,
                "content": [
                    {
                        "username": "edzaferovic",
                        "content": "The question says that a number is good if each individual number is rotated and the original number is different to the rotated number.\\n\\nHere is how rotations work:\\n\\n0 rotates to 0\\n1 rotates to 1\\n8 rotates to 8\\n\\n2 rotates to 5\\n5 rotates to 2\\n6 rotates to 9\\n9 rotates to 6 \\n\\nEvery other number 3,4 and 7 do not rotate and are invalid meaning if the number contains one of these it cannot be changed. \\n\\nSO this means that 20 would rotate to 50 bc 2 rotates to 5 and 0 stays the same. This number is good since 20 != 50.\\nAnother example is 33, since 3 is the first int it becomes invalid. Another example of this is 23, since 3 is the second int in the number it becomes invalid meaning even tho 2 changes to 5 and the number is 53, and 53 != 23, the 3 invalidates the number making it no good.\\n\\nHope this helps you guys understand what the question is asking for!\\n"
                    },
                    {
                        "username": "companion",
                        "content": "After rotating 180, 2 is still 2?"
                    },
                    {
                        "username": "shashwatpandeyy",
                        "content": "it become 5"
                    },
                    {
                        "username": "fmadrid",
                        "content": "[A Ludic Fallacy - Rotating Digits (Leet Code 788)](http://www.frankmadrid.com/ALudicFallacy/2018/02/28/rotated-digits-leet-code-788/)\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "guys the link is showing Ads don\\'t open ! It is un-relevant "
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "they should add in example 1 - > \\n[1,10] -> 2 , 5 ,  6  , 9 \\n\\n1 , `8` and 10 are not good numbers .\\nThey forgot to mention that 8 also comes under the range [1,10] and remains same after the rotation."
                    },
                    {
                        "username": "prajapatikunal7",
                        "content": "Can someone help me in understanding of \"180 degree of digit\" ?\\n\\nLike \\n1) How 2 can be rotated 180 degree to 5? \\n2) How 1 or 8 can be rotated 180 degree to digit themeselves ?\\n\\nThanks in advance"
                    },
                    {
                        "username": "mchim",
                        "content": "Flip it upside down, then 2 becomes 5."
                    },
                    {
                        "username": "yuweila",
                        "content": "I input 22 and 23 into testcase and get the result 11 and 11 respectively, \\nthat meas the nubmer 23 is a bad number. Is it? 2 to 5 and 3 to 3, so 23 to 53?\\n\\nIs it a bug or the problem is the definition of **rotating each digit individually by 180 degrees** is not clear? I think the roatation might be:\\n\\n**1. rotate clockwise/counterclockwise?**\\n(X) 2 and 5 rotate to itself, and it is conflict with the problem description.\\n\\n**2. flip vertically** (Put a mirror besides the number and see what inside)\\n(O) 2 and 5 rotate to each other.\\n(X) 6 and 9 roate to itself, conflict.\\n\\n**3. flip horizontally** (Put a mirror under the number and see what inside)\\n(O) 2 and 5 rotate to each other.\\n(O) 6 and 9 roate to each other. (If 9 is wirtten like a lollipop)\\n**How about 3, 4, and 7?** \\n4 and 7 can not get a valid number, and 3 can rotate to itself. But the problem description does not mention about 3 and the testcase shows 3 is a bad number. Does that mean the rotation is not flip horizontally? So what is **rotating each digit individually by 180 degrees**?"
                    },
                    {
                        "username": "leetcode_yao",
                        "content": "2 and 5 rotate each other? why?\\nwhy 2->2 5->5 ?"
                    },
                    {
                        "username": "heesub",
                        "content": "This question makes me post my first comment here. I tried to understand this question and derive an optimal solution, but it was just a waste of time. Only brute-force solution exists. If this can be solved in a more efficient way, please enlighten me."
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "brute force is working without tle"
                    },
                    {
                        "username": "genegenehou",
                        "content": "I think `69` is not a good number, since if we rotate it by 180 degree, it\\'s still `69`.\\n\\nBut if you print out the good numbers with the AC solution, you\\'ll find `69` is a good number. Why?"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "we all know why it is a `good number` pun intended.\\n\\nactually -> 69 becomes 96 according to description."
                    }
                ]
            },
            {
                "id": 1571920,
                "content": [
                    {
                        "username": "edzaferovic",
                        "content": "The question says that a number is good if each individual number is rotated and the original number is different to the rotated number.\\n\\nHere is how rotations work:\\n\\n0 rotates to 0\\n1 rotates to 1\\n8 rotates to 8\\n\\n2 rotates to 5\\n5 rotates to 2\\n6 rotates to 9\\n9 rotates to 6 \\n\\nEvery other number 3,4 and 7 do not rotate and are invalid meaning if the number contains one of these it cannot be changed. \\n\\nSO this means that 20 would rotate to 50 bc 2 rotates to 5 and 0 stays the same. This number is good since 20 != 50.\\nAnother example is 33, since 3 is the first int it becomes invalid. Another example of this is 23, since 3 is the second int in the number it becomes invalid meaning even tho 2 changes to 5 and the number is 53, and 53 != 23, the 3 invalidates the number making it no good.\\n\\nHope this helps you guys understand what the question is asking for!\\n"
                    },
                    {
                        "username": "companion",
                        "content": "After rotating 180, 2 is still 2?"
                    },
                    {
                        "username": "shashwatpandeyy",
                        "content": "it become 5"
                    },
                    {
                        "username": "fmadrid",
                        "content": "[A Ludic Fallacy - Rotating Digits (Leet Code 788)](http://www.frankmadrid.com/ALudicFallacy/2018/02/28/rotated-digits-leet-code-788/)\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "guys the link is showing Ads don\\'t open ! It is un-relevant "
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "they should add in example 1 - > \\n[1,10] -> 2 , 5 ,  6  , 9 \\n\\n1 , `8` and 10 are not good numbers .\\nThey forgot to mention that 8 also comes under the range [1,10] and remains same after the rotation."
                    },
                    {
                        "username": "prajapatikunal7",
                        "content": "Can someone help me in understanding of \"180 degree of digit\" ?\\n\\nLike \\n1) How 2 can be rotated 180 degree to 5? \\n2) How 1 or 8 can be rotated 180 degree to digit themeselves ?\\n\\nThanks in advance"
                    },
                    {
                        "username": "mchim",
                        "content": "Flip it upside down, then 2 becomes 5."
                    },
                    {
                        "username": "yuweila",
                        "content": "I input 22 and 23 into testcase and get the result 11 and 11 respectively, \\nthat meas the nubmer 23 is a bad number. Is it? 2 to 5 and 3 to 3, so 23 to 53?\\n\\nIs it a bug or the problem is the definition of **rotating each digit individually by 180 degrees** is not clear? I think the roatation might be:\\n\\n**1. rotate clockwise/counterclockwise?**\\n(X) 2 and 5 rotate to itself, and it is conflict with the problem description.\\n\\n**2. flip vertically** (Put a mirror besides the number and see what inside)\\n(O) 2 and 5 rotate to each other.\\n(X) 6 and 9 roate to itself, conflict.\\n\\n**3. flip horizontally** (Put a mirror under the number and see what inside)\\n(O) 2 and 5 rotate to each other.\\n(O) 6 and 9 roate to each other. (If 9 is wirtten like a lollipop)\\n**How about 3, 4, and 7?** \\n4 and 7 can not get a valid number, and 3 can rotate to itself. But the problem description does not mention about 3 and the testcase shows 3 is a bad number. Does that mean the rotation is not flip horizontally? So what is **rotating each digit individually by 180 degrees**?"
                    },
                    {
                        "username": "leetcode_yao",
                        "content": "2 and 5 rotate each other? why?\\nwhy 2->2 5->5 ?"
                    },
                    {
                        "username": "heesub",
                        "content": "This question makes me post my first comment here. I tried to understand this question and derive an optimal solution, but it was just a waste of time. Only brute-force solution exists. If this can be solved in a more efficient way, please enlighten me."
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "brute force is working without tle"
                    },
                    {
                        "username": "genegenehou",
                        "content": "I think `69` is not a good number, since if we rotate it by 180 degree, it\\'s still `69`.\\n\\nBut if you print out the good numbers with the AC solution, you\\'ll find `69` is a good number. Why?"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "we all know why it is a `good number` pun intended.\\n\\nactually -> 69 becomes 96 according to description."
                    }
                ]
            }
        ]
    }
]