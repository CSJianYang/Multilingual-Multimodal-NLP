[
    {
        "title": "Flipping an Image",
        "question_content": "Given an n x n binary matrix image, flip the image horizontally, then invert it, and return the resulting image.\nTo flip an image horizontally means that each row of the image is reversed.\n\n\tFor example, flipping [1,1,0] horizontally results in [0,1,1].\n\nTo invert an image means that each 0 is replaced by 1, and each 1 is replaced by 0.\n\n\tFor example, inverting [0,1,1] results in [1,0,0].\n\n&nbsp;\nExample 1:\n\nInput: image = [[1,1,0],[1,0,1],[0,0,0]]\nOutput: [[1,0,0],[0,1,0],[1,1,1]]\nExplanation: First reverse each row: [[0,1,1],[1,0,1],[0,0,0]].\nThen, invert the image: [[1,0,0],[0,1,0],[1,1,1]]\n\nExample 2:\n\nInput: image = [[1,1,0,0],[1,0,0,1],[0,1,1,1],[1,0,1,0]]\nOutput: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]\nExplanation: First reverse each row: [[0,0,1,1],[1,0,0,1],[1,1,1,0],[0,1,0,1]].\nThen invert the image: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]\n\n&nbsp;\nConstraints:\n\n\tn == image.length\n\tn == image[i].length\n\t1 <= n <= 20\n\timages[i][j] is either 0 or 1.",
        "solutions": [
            {
                "id": 130590,
                "title": "java-c-python-reverse-and-toggle",
                "content": "# **Explanation**:\\n1. reverse every row.\\n2. toggle every value.\\n\\nIn Java, I did both steps together:\\nCompare the `i` th and `n - i - 1` th in a row.\\nThe \"trick\" is that if the values are not the same,\\nbut you swap and flip, nothing will change.\\nSo if they are same, we toggle both, otherwise we do nothing.\\n<br>\\n\\n# **Complexity**:\\nTime `O(N^2)`\\nSpace `O(N^2)` for output\\n<br>\\n\\n**Java:**\\n```java\\n    public int[][] flipAndInvertImage(int[][] A) {\\n        int n = A.length;\\n        for (int[] row : A)\\n            for (int i = 0; i * 2 < n; i++)\\n                if (row[i] == row[n - i - 1])\\n                    row[i] = row[n - i - 1] ^= 1;\\n        return A;\\n    }\\n```\\n**C++:**\\nby @guybrush2323\\n```cpp\\n    static const vector<vector<int>>& flipAndInvertImage(vector<vector<int>>& A) {\\n        for (auto& row : A) {\\n            reverse(row.begin(), row.end());\\n            for (auto& v : row) v ^= 1;\\n        }\\n        return A;\\n    }\\n```\\n**1-line Python:**\\n```python\\n    def flipAndInvertImage(self, A):\\n        return [[1 ^ i for i in reversed(row)] for row in A]\\n```\\n",
                "solutionTags": [],
                "code": "```java\\n    public int[][] flipAndInvertImage(int[][] A) {\\n        int n = A.length;\\n        for (int[] row : A)\\n            for (int i = 0; i * 2 < n; i++)\\n                if (row[i] == row[n - i - 1])\\n                    row[i] = row[n - i - 1] ^= 1;\\n        return A;\\n    }\\n```\n```cpp\\n    static const vector<vector<int>>& flipAndInvertImage(vector<vector<int>>& A) {\\n        for (auto& row : A) {\\n            reverse(row.begin(), row.end());\\n            for (auto& v : row) v ^= 1;\\n        }\\n        return A;\\n    }\\n```\n```python\\n    def flipAndInvertImage(self, A):\\n        return [[1 ^ i for i in reversed(row)] for row in A]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 148272,
                "title": "easy-understand-one-pass-java-solution-absolutely-beat-100",
                "content": "The idea is simple. For each row, use two pointers. One is going forward and the other is going backward. \\n(1). If the two elements are the same, then make a slight change like this 0 -> 1 or 1 -> 0. \\n(2). If the two elements are different, DON\\'T do anything. Just let it go.\\n\\nOnly scan the whole matrix once.\\n\\n```\\nclass Solution {\\n    public int[][] flipAndInvertImage(int[][] A) {\\n        for (int i = 0; i < A.length; i++) {\\n            int lo = 0, hi = A[0].length - 1;\\n            while (lo <= hi) {\\n                if (A[i][lo] == A[i][hi]) {\\n                    A[i][lo] = 1 - A[i][lo];\\n                    A[i][hi] = A[i][lo];\\n                }\\n                lo++;\\n                hi--;\\n            }\\n        }\\n        \\n        return A;\\n    }\\n}\\n````",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[][] flipAndInvertImage(int[][] A) {\\n        for (int i = 0; i < A.length; i++) {\\n            int lo = 0, hi = A[0].length - 1;\\n            while (lo <= hi) {\\n                if (A[i][lo] == A[i][hi]) {\\n                    A[i][lo] = 1 - A[i][lo];\\n                    A[i][hi] = A[i][lo];\\n                }\\n                lo++;\\n                hi--;\\n            }\\n        }\\n        \\n        return A;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 132026,
                "title": "python-1-line",
                "content": "```\\nclass Solution(object):\\n    def flipAndInvertImage(self, A):\\n        \"\"\"\\n        :type A: List[List[int]]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        \\n        return [[1-i for i in row[::-1]] for row in A]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def flipAndInvertImage(self, A):\\n        \"\"\"\\n        :type A: List[List[int]]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        \\n        return [[1-i for i in row[::-1]] for row in A]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 930378,
                "title": "c-short-and-simple-in-place-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& A) {\\n        for (int i=0; i<A.size(); i++) {\\n            reverse(A[i].begin(), A[i].end());\\n            for (int j=0; j<A[i].size(); j++) {\\n                A[i][j] ^= 0x1;\\n            }\\n        }\\n        return A;\\n    }\\n};\\n```\\n**Like it? please upvote...**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& A) {\\n        for (int i=0; i<A.size(); i++) {\\n            reverse(A[i].begin(), A[i].end());\\n            for (int j=0; j<A[i].size(); j++) {\\n                A[i][j] ^= 0x1;\\n            }\\n        }\\n        return A;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 230318,
                "title": "python3-beats-99-78-with-explanation",
                "content": "```\\ndef flipAndInvertImage(self, A):\\n\\tfor row in A:\\n\\t\\ti, j = 0, len(row) - 1\\n\\t\\twhile i <= j:\\n\\t\\t\\tif row[i] == row[j]:\\n\\t\\t\\t\\trow[i], row[j] = row[i]^1, row[j]^1\\n\\t\\t\\ti += 1\\n\\t\\t\\tj -= 1\\n\\treturn A\\n```\\n\\n\\nAfter reviewing some examples you will notice the following patterns:\\n\\t\\t1) Look at first and last value of row.  If they are the same (1,1 or 0,0), they will be flipped in the output.  \\n\\t\\t\\tIf they are different (1,0 or 0,1), they do not change.  Work your way inward to the middle of the list \\n\\t\\t\\tapplying this rule.\\n\\t\\t2) If the row has an odd number of entries, the middle value always flips.  For example if len(row) = 5, \\n\\t\\t\\tthen row[2] must change values.\\n\\nBitwise XOR --> 0^1 = 1, 1^1 =0 \\n\\nLet i be the index at the beginning of the row, and j be the index at the end of the row.  If the the values at \\nthese indices (row[i] and row[j]) are equal, flip their values using XOR ^.  If they values are not equal, do \\nnothing and move i and j closer to the middle.  When i == j , the code still executes as it should. \\n\\n**Edit**:\\nIf `len(A) = num_words = M` and `len(A[0]) = word_length = N`, we iterate over `(word_length / 2) * num_words` or `(N/2) * M` values.  Time complexity is `O((N/2) * M)`, but its still just linear with the input so we can generalize as `O(N)`.  Space complexity is `O(1)`.",
                "solutionTags": [],
                "code": "```\\ndef flipAndInvertImage(self, A):\\n\\tfor row in A:\\n\\t\\ti, j = 0, len(row) - 1\\n\\t\\twhile i <= j:\\n\\t\\t\\tif row[i] == row[j]:\\n\\t\\t\\t\\trow[i], row[j] = row[i]^1, row[j]^1\\n\\t\\t\\ti += 1\\n\\t\\t\\tj -= 1\\n\\treturn A\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 930392,
                "title": "python-oneliner-explained",
                "content": "Let us do exactly what is asked in this problem: for each row: flip the image horizontally, then invert it. Quick way to get `0` from `1` and `1` from `0` is to use `1^q` (however tests are so small, so difference is not very big).\\n\\n**Complexity**: time complexity is `O(mn)`, where `m`, `n` are sizes of image. Space complexity is also `O(mn)` if we count output and `O(1)` space if we do not count. Note, that if we allowed to modify original image, than we can have `O(1)` space.\\n\\n```\\nclass Solution:\\n    def flipAndInvertImage(self, A):\\n        return [[1^q for q in row[::-1]] for row in A]\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def flipAndInvertImage(self, A):\\n        return [[1^q for q in row[::-1]] for row in A]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1520742,
                "title": "java-tc-o-n-2-sc-o-1-optimal-one-pass-in-place-solution",
                "content": "```java\\n/**\\n * Optimal one-pass in-place solution\\n *\\n * If the values are not same, swap and flip will not change anything.\\n * If the values are same, we will flip both.\\n *\\n * Time Complexity: O(N^2)\\n *\\n * Space Complexity: O(1)\\n *\\n * N = Matrix Size\\n */\\nclass Solution {\\n    public int[][] flipAndInvertImage(int[][] image) {\\n        if (image == null || image.length == 0 || image[0].length == 0) {\\n            return image;\\n        }\\n\\n        for (int[] row : image) {\\n            int start = 0;\\n            int end = row.length - 1;\\n            while (start <= end) {\\n                if (row[start] == row[end]) {\\n                    row[start] ^= 1;\\n                    row[end] = row[start];\\n                }\\n                start++;\\n                end--;\\n            }\\n        }\\n\\n        return image;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Two Pointers",
                    "Matrix"
                ],
                "code": "```java\\n/**\\n * Optimal one-pass in-place solution\\n *\\n * If the values are not same, swap and flip will not change anything.\\n * If the values are same, we will flip both.\\n *\\n * Time Complexity: O(N^2)\\n *\\n * Space Complexity: O(1)\\n *\\n * N = Matrix Size\\n */\\nclass Solution {\\n    public int[][] flipAndInvertImage(int[][] image) {\\n        if (image == null || image.length == 0 || image[0].length == 0) {\\n            return image;\\n        }\\n\\n        for (int[] row : image) {\\n            int start = 0;\\n            int end = row.length - 1;\\n            while (start <= end) {\\n                if (row[start] == row[end]) {\\n                    row[start] ^= 1;\\n                    row[end] = row[start];\\n                }\\n                start++;\\n                end--;\\n            }\\n        }\\n\\n        return image;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 130644,
                "title": "one-liner-javascript-solution",
                "content": "```\\nvar flipAndInvertImage = function(A) {\\n    // take each row, reverse it, then map each number in it and invert it. map returns a list\\n    return A.map(row => row.reverse().map(num => num^1));\\n\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar flipAndInvertImage = function(A) {\\n    // take each row, reverse it, then map each number in it and invert it. map returns a list\\n    return A.map(row => row.reverse().map(num => num^1));\\n\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 931580,
                "title": "java-easy-solution",
                "content": "```\\npublic int[][] flipAndInvertImage(int[][] A) {\\n        int row = A.length;\\n        int col = A[0].length;\\n        int[][] result = new int[row][col];\\n        \\n\\t\\t// Step 1 : revert\\n        for(int i = 0; i < row; i++){\\n            for(int j = 0; j < col; j++){\\n                result[i][j] = A[i][col-j-1];\\n            }\\n        }\\n        // Step 2: invert\\n        for(int i = 0; i < row; i++){\\n            for(int j = 0; j < col; j++){\\n                result[i][j] = result[i][j] == 1 ? 0 : 1;\\n            }\\n        }\\n        return result;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int[][] flipAndInvertImage(int[][] A) {\\n        int row = A.length;\\n        int col = A[0].length;\\n        int[][] result = new int[row][col];\\n        \\n\\t\\t// Step 1 : revert\\n        for(int i = 0; i < row; i++){\\n            for(int j = 0; j < col; j++){\\n                result[i][j] = A[i][col-j-1];\\n            }\\n        }\\n        // Step 2: invert\\n        for(int i = 0; i < row; i++){\\n            for(int j = 0; j < col; j++){\\n                result[i][j] = result[i][j] == 1 ? 0 : 1;\\n            }\\n        }\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 602813,
                "title": "simple-javascript-solution",
                "content": "```\\nvar flipAndInvertImage = function(A) {\\n\\t\\tfor(let row in A) {\\n\\t\\t\\tA[row] = A[row].reverse();\\n\\t\\t\\tA[row] = A[row].map(x => 1 - x);\\n\\t\\t}\\n\\treturn A;\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar flipAndInvertImage = function(A) {\\n\\t\\tfor(let row in A) {\\n\\t\\t\\tA[row] = A[row].reverse();\\n\\t\\t\\tA[row] = A[row].map(x => 1 - x);\\n\\t\\t}\\n\\treturn A;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 1124348,
                "title": "c-100-fast-highly-readable-beginner-friendly",
                "content": "**Plz Upvote If You Liked This Solution - -**\\n\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        for(int i=0;i<image.size();i++){\\n            vector<int> x=image[i];\\n            reverse(x.begin(),x.end());\\n            image[i]=x;\\n        }\\n        \\n        for(int i=0;i<image.size();i++){\\n            for(int j=0;j<image[i].size();j++)\\n                image[i][j]^=1;\\n        }\\n        \\n        return image;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        for(int i=0;i<image.size();i++){\\n            vector<int> x=image[i];\\n            reverse(x.begin(),x.end());\\n            image[i]=x;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 260718,
                "title": "javascript-beats-93-1-line",
                "content": "```\\nvar flipAndInvertImage = function(A) {\\n    return A.map(a=>{return a.reverse().map(b=>b^1)})\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar flipAndInvertImage = function(A) {\\n    return A.map(a=>{return a.reverse().map(b=>b^1)})\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 550889,
                "title": "the-python3-one-liner",
                "content": "```\\nreturn [[0 if x==1 else 1 for x in x][::-1] for x in A] \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nreturn [[0 if x==1 else 1 for x in x][::-1] for x in A] \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 140128,
                "title": "one-pass-in-place-java-solution",
                "content": "```\\nclass Solution {\\n    public int[][] flipAndInvertImage(int[][] A) {\\n        int n = A.length;\\n        for(int j = 0; j < n / 2 + n % 2; j++){\\n            for(int i = 0; i < n; i++) {\\n                int tmp = A[i][j];\\n                A[i][j] = A[i][n - 1 - j] ^ 1;\\n                A[i][n - 1 - j] = tmp ^ 1;\\n            }\\n        }\\n        return A;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[][] flipAndInvertImage(int[][] A) {\\n        int n = A.length;\\n        for(int j = 0; j < n / 2 + n % 2; j++){\\n            for(int i = 0; i < n; i++) {\\n                int tmp = A[i][j];\\n                A[i][j] = A[i][n - 1 - j] ^ 1;\\n                A[i][n - 1 - j] = tmp ^ 1;\\n            }\\n        }\\n        return A;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3380062,
                "title": "easy-c-solution-100-time",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n- First I\\'ve copied the image array to new `ans` array.\\n- then reversed every array that is inside it`(as mentioned in question)`\\n- then replaced every `0` value to `1`.\\n- and every `1` value to `0`.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n`Upvote! It only takes 1 click :)`\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        int n = image.size();\\n        vector<vector<int>> ans = image;\\n\\n        for(int i=0;i<n;i++) {\\n            reverse(ans[i].begin(), ans[i].end());\\n            for(int j=0;j<n;j++) {\\n                if(ans[i][j] == 0){\\n                    ans[i][j] = 1;\\n                }\\n                else{\\n                    ans[i][j] = 0;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n![Upvote.jpeg](https://assets.leetcode.com/users/images/c8af91b5-b6f6-463d-9ff5-3bbdf63eed2e_1680625991.9136252.jpeg)",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        int n = image.size();\\n        vector<vector<int>> ans = image;\\n\\n        for(int i=0;i<n;i++) {\\n            reverse(ans[i].begin(), ans[i].end());\\n            for(int j=0;j<n;j++) {\\n                if(ans[i][j] == 0){\\n                    ans[i][j] = 1;\\n                }\\n                else{\\n                    ans[i][j] = 0;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3137586,
                "title": "java-best-solution-beats-100",
                "content": "# Approach\\n- First, Reverse Every Row.\\n- Then, Change the Value of the Elements\\n- From 1 to 0 and 0 to 1.\\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] flipAndInvertImage(int[][] image) {\\n        for (int i = 0; i < image.length; i++) {\\n            int a = 0, r = image[0].length - 1;\\n            while (a <= r) {\\n                int temp = image[i][a];\\n                image[i][a] = image[i][r];\\n                image[i][r] = temp;\\n                a++;\\n                r--;\\n            }\\n        }\\n        for (int i = 0; i < image.length; i++) {\\n            for (int j = 0; j < image[0].length; j++) {\\n                if (image[i][j] == 0) {\\n                    image[i][j] = 1;\\n                } else {\\n                    image[i][j] = 0;\\n                }\\n            }\\n        }\\n        return image;\\n    }\\n}\\n```\\n![please-upvote-and.jpg](https://assets.leetcode.com/users/images/e78315ef-8a9d-492b-9908-e3917f23eb31_1674946036.087042.jpeg)",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] flipAndInvertImage(int[][] image) {\\n        for (int i = 0; i < image.length; i++) {\\n            int a = 0, r = image[0].length - 1;\\n            while (a <= r) {\\n                int temp = image[i][a];\\n                image[i][a] = image[i][r];\\n                image[i][r] = temp;\\n                a++;\\n                r--;\\n            }\\n        }\\n        for (int i = 0; i < image.length; i++) {\\n            for (int j = 0; j < image[0].length; j++) {\\n                if (image[i][j] == 0) {\\n                    image[i][j] = 1;\\n                } else {\\n                    image[i][j] = 0;\\n                }\\n            }\\n        }\\n        return image;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1363051,
                "title": "python-very-very-easy-soln-3-solutions-explained-o-n-with-or-without-inbuilt-functions",
                "content": "```\\nclass Solution:\\n    def flipAndInvertImage(self, image: List[List[int]]) -> List[List[int]]:\\n        \"\"\"\\n        Simple & striaghtforward without using inbuilt functions.\\n     \\n        In actual the run time is very less as we are iterating only n/2 time\\n        for each image list.\\n        Time complexity : O(n * n/2) == O(n^2) \\n        Space complexity : O(1)\\n        \"\"\"\\n        \\n        for im in image: #Iterate through each im list in the image list.\\n            i, j = 0, len(im)-1    #Maintain two pointers one at start and one at end.\\n            while i <= j:          #Iterate while first pointer is less than or equal to second pointer.\\n                im[i], im[j] = im[j]^1, im[i]^1   #swap element at both pointer & complement them at the same time.\\n                i +=1              #increment first pointer to move forward\\n                j -=1              #decrement second pointer to move backward\\n            \\n        return image         # return same list\\n    \\n    \\n        \"\"\"\\n        Using inbuilt functions\\n        \"\"\"\\n        # for im in range(len(image)):\\n        #     image[im] = list(map(lambda a : abs(a-1), reversed(image[im])))\\n        # return image\\n    \\n        \"\"\"\\n        One liner\\n        \"\"\"\\n        return [[i^1 for i in im[::-1]] for im in image]\\n        \\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def flipAndInvertImage(self, image: List[List[int]]) -> List[List[int]]:\\n        \"\"\"\\n        Simple & striaghtforward without using inbuilt functions.\\n     \\n        In actual the run time is very less as we are iterating only n/2 time\\n        for each image list.\\n        Time complexity : O(n * n/2) == O(n^2) \\n        Space complexity : O(1)\\n        \"\"\"\\n        \\n        for im in image: #Iterate through each im list in the image list.\\n            i, j = 0, len(im)-1    #Maintain two pointers one at start and one at end.\\n            while i <= j:          #Iterate while first pointer is less than or equal to second pointer.\\n                im[i], im[j] = im[j]^1, im[i]^1   #swap element at both pointer & complement them at the same time.\\n                i +=1              #increment first pointer to move forward\\n                j -=1              #decrement second pointer to move backward\\n            \\n        return image         # return same list\\n    \\n    \\n        \"\"\"\\n        Using inbuilt functions\\n        \"\"\"\\n        # for im in range(len(image)):\\n        #     image[im] = list(map(lambda a : abs(a-1), reversed(image[im])))\\n        # return image\\n    \\n        \"\"\"\\n        One liner\\n        \"\"\"\\n        return [[i^1 for i in im[::-1]] for im in image]\\n        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3737887,
                "title": "google-3-832-flipping-an-image-o-n-solution-c",
                "content": "# Approach\\nAll the approach is well explained in the question. During swapping for reversal of array used xor with 1 to flip the bit i.e inverting because 1^1=0 , 0^1=1 for simplicity of code.By combining both steps it decreases time complexity from O(N^2) to O(N).\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\nIt seems O(N^2) but the loops are running for each row and half column so Actual Time comlexity is O(rows*columns) which is equal to O(N) as N=no of elements=rows*columns(as per this question).\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n        vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        int n=image.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<(n+1)/2;j++)\\n            {\\n                int temp=image[i][j]^1;\\n                image[i][j]=image[i][n-1-j]^1;\\n                image[i][n-1-j]=temp;\\n            }\\n        }\\n        return image;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n        vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        int n=image.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<(n+1)/2;j++)\\n            {\\n                int temp=image[i][j]^1;\\n                image[i][j]=image[i][n-1-j]^1;\\n                image[i][n-1-j]=temp;\\n            }\\n        }\\n        return image;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2763690,
                "title": "very-simple-solution-using-python",
                "content": "```\\nclass Solution:\\n    def flipAndInvertImage(self, image: List[List[int]]) -> List[List[int]]:\\n        res = []\\n        for i in image:\\n            res.append([x ^ 1 for x in i[::-1]])\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def flipAndInvertImage(self, image: List[List[int]]) -> List[List[int]]:\\n        res = []\\n        for i in image:\\n            res.append([x ^ 1 for x in i[::-1]])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2033336,
                "title": "c-easy-xor-operation",
                "content": "```\\n//kindly dry run each and every input for better understanding\\nclass Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        for(int i=0;i<image.size();i++){\\n            reverse(image[i].begin(),image[i].end());\\n            for(auto j=0;j<image[i].size();j++){\\n                image[i][j]^=1;\\n            }\\n        }       \\n        return image;       \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n//kindly dry run each and every input for better understanding\\nclass Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        for(int i=0;i<image.size();i++){\\n            reverse(image[i].begin(),image[i].end());\\n            for(auto j=0;j<image[i].size();j++){\\n                image[i][j]^=1;\\n            }\\n        }       \\n        return image;       \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1780606,
                "title": "python3-solution-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def flipAndInvertImage(self, image: List[List[int]]) -> List[List[int]]:\\n        for i in range(len(image)):\\n            image[i] = image[i][::-1]\\n            for j in range(len(image[i])):\\n                if image[i][j] == 0:\\n                    image[i][j] = 1\\n                else:\\n                    image[i][j] = 0\\n        return image\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def flipAndInvertImage(self, image: List[List[int]]) -> List[List[int]]:\\n        for i in range(len(image)):\\n            image[i] = image[i][::-1]\\n            for j in range(len(image[i])):\\n                if image[i][j] == 0:\\n                    image[i][j] = 1\\n                else:\\n                    image[i][j] = 0\\n        return image\\n```",
                "codeTag": "Java"
            },
            {
                "id": 930613,
                "title": "clean-in-place-java-solution-one-pass-0ms",
                "content": "The logic is simular to swaping two position within an array but just done over many position. Idea is that you will perform the swap over every row of the matrix and only to the half way point of the row. When performing the swap, invert the value to achieve the invert. Inversion is done using 1 - cell value since it\\'s only 1 and 0. (1 - 1 = 0, 1 - 0 = 1).\\nHere is the code. \\n```\\nclass Solution {\\n    public int[][] flipAndInvertImage(int[][] A) {\\n        for(int i = 0; i < A.length ; i++){\\n            for(int j = 0; j < (A[0].length+1)/2; j++){\\n                int temp = 1-A[i][j];\\n                A[i][j] = 1-A[i][A[i].length-j-1];\\n                A[i][A[i].length-j-1] = temp;\\n            }\\n        }\\n        return A;\\n    }\\n}\\n```\\nIf you enjoy this solution, feel free to **upvote** it or **comment** to it if you have any question. I will be happy to answer.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] flipAndInvertImage(int[][] A) {\\n        for(int i = 0; i < A.length ; i++){\\n            for(int j = 0; j < (A[0].length+1)/2; j++){\\n                int temp = 1-A[i][j];\\n                A[i][j] = 1-A[i][A[i].length-j-1];\\n                A[i][A[i].length-j-1] = temp;\\n            }\\n        }\\n        return A;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2816547,
                "title": "java-100-faster-logical-solution",
                "content": "```\\nclass Solution {\\n    public int[][] flipAndInvertImage(int[][] img) {\\n        int m=img.length,n=img[0].length;\\n        for(int i=0;i<m;i++)\\n        {\\n            int l=0,r=n-1;\\n            while(l<=r)\\n            {\\n                if(img[i][l]==img[i][r])\\n                {\\n                    if(img[i][l]==0)\\n                    {\\n                        img[i][l]=1;\\n                        img[i][r]=1;\\n                    }\\n                    else\\n                    {\\n                        img[i][l]=0;\\n                        img[i][r]=0;\\n                    }\\n                }\\n                l++;\\n                r--;\\n            }\\n        }\\n        return img;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] flipAndInvertImage(int[][] img) {\\n        int m=img.length,n=img[0].length;\\n        for(int i=0;i<m;i++)\\n        {\\n            int l=0,r=n-1;\\n            while(l<=r)\\n            {\\n                if(img[i][l]==img[i][r])\\n                {\\n                    if(img[i][l]==0)\\n                    {\\n                        img[i][l]=1;\\n                        img[i][r]=1;\\n                    }\\n                    else\\n                    {\\n                        img[i][l]=0;\\n                        img[i][r]=0;\\n                    }\\n                }\\n                l++;\\n                r--;\\n            }\\n        }\\n        return img;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1044064,
                "title": "python-6-methods-with-explanation",
                "content": "**Platform**: leetcode.com\\n**832.** Flipping an Image\\n**Link**: https://leetcode.com/problems/flipping-an-image/\\n**Difficulty**: Easy\\n**Author** : hritik5102\\n**Date**: 31/1/2021\\n**Post Discussion** : https://leetcode.com/problems/flipping-an-image/discuss/1044064/python-or-6-Methods-with-explanation\\n**Submission** : https://leetcode.com/submissions/detail/450220569/\\n**(Time, Space) Complexity** : O(n), O(n)\\n\\n\\n# Method 1 : Easy and consice\\n\\n## Reverse the row and the invert the number i.e. if 1 then convert it into 0 or vice versa\\n```python\\n>> arr = [1,2,3]  \\n>> arr[::-1]   \\n>> [3,2,1]\\n```\\n\\n```\\nclass Solution:\\n    def flipAndInvertImage(self, A):\\n        res = []\\n        for arr in A:\\n            res.append(list(map(lambda x:0 if x else 1, arr[::-1])))\\n        return res            \\n```\\n\\n# Method 02 : Create a dictionary and the same is logic\\n\\n```\\nclass Solution:\\n    def flipAndInvertImage(self, A):\\n        res = []\\n        d = {\\n            0:1,\\n            1:0\\n        }\\n        for arr in A:\\n            res.append(list(map(lambda x: d[x], arr[::-1])))\\n        return res            \\n```\\n\\n# Method 03 : Instead of using map and lambda function, use list comprehesion which is faster\\n\\n```\\nclass Solution:\\n    def flipAndInvertImage(self, A):\\n        res = []\\n        d = {\\n            0:1,\\n            1:0\\n        }\\n        for arr in A:\\n            res.append([d[i] for i in arr[::-1]])\\n        return res            \\n```\\n\\n# Method 04 : List comprehension\\n```\\nclass Solution:\\n    def flipAndInvertImage(self, A):\\n        d = {\\n            0:1,\\n            1:0\\n        }\\n        return [[d[i] for i in arr[::-1]] for arr in A]\\n```\\n        \\n# Method 05 : One liner but faster\\n```\\nclass Solution:\\n    def flipAndInvertImage(self, A):\\n        return [[1^i for i in arr[::-1]] for arr in A]\\n```\\n\\n# Method 06 : Fastest method  (Reference from : [@xieal](https://leetcode.com/xieal) )\\n```\\nclass Solution:\\n    def flipAndInvertImage(self, A):\\n        return [[l[i] ^ 1 for i in range(len(l) - 1, -1, -1)] for l in A]\\n\\nobj = Solution()\\nprint(obj.flipAndInvertImage(A = [[1,1,0],[1,0,1],[0,0,0]]))        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\n>> arr = [1,2,3]  \\n>> arr[::-1]   \\n>> [3,2,1]\\n```\n```\\nclass Solution:\\n    def flipAndInvertImage(self, A):\\n        res = []\\n        for arr in A:\\n            res.append(list(map(lambda x:0 if x else 1, arr[::-1])))\\n        return res            \\n```\n```\\nclass Solution:\\n    def flipAndInvertImage(self, A):\\n        res = []\\n        d = {\\n            0:1,\\n            1:0\\n        }\\n        for arr in A:\\n            res.append(list(map(lambda x: d[x], arr[::-1])))\\n        return res            \\n```\n```\\nclass Solution:\\n    def flipAndInvertImage(self, A):\\n        res = []\\n        d = {\\n            0:1,\\n            1:0\\n        }\\n        for arr in A:\\n            res.append([d[i] for i in arr[::-1]])\\n        return res            \\n```\n```\\nclass Solution:\\n    def flipAndInvertImage(self, A):\\n        d = {\\n            0:1,\\n            1:0\\n        }\\n        return [[d[i] for i in arr[::-1]] for arr in A]\\n```\n```\\nclass Solution:\\n    def flipAndInvertImage(self, A):\\n        return [[1^i for i in arr[::-1]] for arr in A]\\n```\n```\\nclass Solution:\\n    def flipAndInvertImage(self, A):\\n        return [[l[i] ^ 1 for i in range(len(l) - 1, -1, -1)] for l in A]\\n\\nobj = Solution()\\nprint(obj.flipAndInvertImage(A = [[1,1,0],[1,0,1],[0,0,0]]))        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 224813,
                "title": "rust-simple-one-liner",
                "content": "```\\nimpl Solution {\\n    pub fn flip_and_invert_image(a: Vec<Vec<i32>>) -> Vec<Vec<i32>> {\\n        a.iter()\\n         .map(|r| r.iter().rev().map(|i| 1 - i).collect())\\n         .collect()\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimpl Solution {\\n    pub fn flip_and_invert_image(a: Vec<Vec<i32>>) -> Vec<Vec<i32>> {\\n        a.iter()\\n         .map(|r| r.iter().rev().map(|i| 1 - i).collect())\\n         .collect()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 136893,
                "title": "1-line-c",
                "content": "1 line using C# Linq\\n```\\npublic int[][] FlipAndInvertImage2(int[][] A) {\\n    return A.Select(row => row.Reverse().Select(col => col ^ 1).ToArray()).ToArray();\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int[][] FlipAndInvertImage2(int[][] A) {\\n    return A.Select(row => row.Reverse().Select(col => col ^ 1).ToArray()).ToArray();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1905120,
                "title": "java-0ms-100-faster-simple-easy-solution-with-o-1-space",
                "content": "![image](https://assets.leetcode.com/users/images/f42b9943-7177-4657-a40e-c32e5135d651_1648870130.589014.png)\\n***Please Upvote if you find this helpful***\\n```\\nclass Solution {\\n    public int[][] flipAndInvertImage(int[][] image) {\\n        for (int i = 0; i < image.length; i++){\\n            int s = 0;\\n            int e = image[i].length-1;\\n            while (s<e){\\n                int temp = image[i][s];\\n                image[i][s] = image[i][e];\\n                image[i][e] = temp;\\n                s++;\\n                e--;\\n            }\\n        }\\n        for(int i = 0; i < image.length; i++){\\n            for (int j = 0; j < image[i].length; j++){\\n                if(image[i][j] == 0){\\n                    image[i][j] = 1;\\n                }\\n                else if(image[i][j] == 1){\\n                    image[i][j] = 0;\\n                }\\n            }\\n        }\\n        return image;\\n    }\\n}\\n```\\n```\\nclass Solution {\\n    public int[][] flipAndInvertImage(int[][] image) {\\n        for (int i = 0; i < image.length; i++) {\\n            int temp = image[i].length;\\n            if (temp % 2 == 1) {\\n                image[i][temp/2] = image[i][temp/2] == 1 ? 0 : 1;\\n            }\\n            int start = 0;\\n            int end = temp - 1;\\n            while (end > start) {\\n                flip(image[i], start, end);\\n                start++;\\n                end--;\\n            }\\n        }\\n        return image;\\n    }\\n    private void flip(int[] arr, int firstIndex, int lastIndex) {\\n        int temp = arr[firstIndex];\\n        arr[firstIndex] = arr[lastIndex];\\n        arr[lastIndex] = temp;\\n        arr[firstIndex] = arr[firstIndex] == 1 ? 0 : 1;\\n        arr[lastIndex] = arr[lastIndex] == 1 ? 0 : 1;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] flipAndInvertImage(int[][] image) {\\n        for (int i = 0; i < image.length; i++){\\n            int s = 0;\\n            int e = image[i].length-1;\\n            while (s<e){\\n                int temp = image[i][s];\\n                image[i][s] = image[i][e];\\n                image[i][e] = temp;\\n                s++;\\n                e--;\\n            }\\n        }\\n        for(int i = 0; i < image.length; i++){\\n            for (int j = 0; j < image[i].length; j++){\\n                if(image[i][j] == 0){\\n                    image[i][j] = 1;\\n                }\\n                else if(image[i][j] == 1){\\n                    image[i][j] = 0;\\n                }\\n            }\\n        }\\n        return image;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int[][] flipAndInvertImage(int[][] image) {\\n        for (int i = 0; i < image.length; i++) {\\n            int temp = image[i].length;\\n            if (temp % 2 == 1) {\\n                image[i][temp/2] = image[i][temp/2] == 1 ? 0 : 1;\\n            }\\n            int start = 0;\\n            int end = temp - 1;\\n            while (end > start) {\\n                flip(image[i], start, end);\\n                start++;\\n                end--;\\n            }\\n        }\\n        return image;\\n    }\\n    private void flip(int[] arr, int firstIndex, int lastIndex) {\\n        int temp = arr[firstIndex];\\n        arr[firstIndex] = arr[lastIndex];\\n        arr[lastIndex] = temp;\\n        arr[firstIndex] = arr[firstIndex] == 1 ? 0 : 1;\\n        arr[lastIndex] = arr[lastIndex] == 1 ? 0 : 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 439620,
                "title": "c-3-solutions-compared-and-explained-100-time-100-space",
                "content": "This problem is literally telling us what to do, so I guess there is no much to explain in terms of theory or mathematical tricks here - just fun to tackle it in multiple ways if you wish so.\\n\\nFirst of all, a simple, concise version taking each row as a reference, reversing it and then switching the bits on it:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& arr) {\\n        for (auto &row: arr) {\\n            // reversing the row\\n\\t\\t\\treverse(begin(row), end(row));\\n\\t\\t\\t// flipping its bits\\n            transform(begin(row), end(row), begin(row), [](auto b){return !b;});\\n        }\\n        return arr;\\n    }\\n}\\n```\\n\\nA slightly more performance version came to me from [Abishek\\'s brilliant solution](https://leetcode.com/problems/flipping-an-image/discuss/930432/), that I tweaked a bit to see if I can make it even a bit more optimal.\\n\\nFirst of all we declare 2 support variables:\\n* `halfLen` is half the size of each row, to save recomputing it all the time;\\n* `len` is the full length of it `- 1`, again because we want to avoid recomputing the same stuff over and over again.\\n\\nAbishek\\'s idea was that things change only when the values of 2 elements with the same distance from the centre is different.\\n\\nFor example, given the row:\\n\\n```cpp\\n0 0 1 1 1 0 1\\n```\\n\\nThe first and the last element will stay the same, because you swap them and then flip them, you will still end up with `0 ... 1` at his extremes:\\n\\n```cpp\\n0 0 1 1 1 0 1\\n```\\n\\nProceeding with second and penultimate, you will see that both are equals, so this time we will have a change, which means both will flip:\\n\\n```cpp\\n0 1 1 1 1 1 1\\n```\\n\\nSimilarly with third and antepenultimate, both equal to `1`:\\n\\n```cpp\\n0 1 0 1 0 1 1\\n```\\n\\nFinally, with odd length rows, the central element is always going to be flipped:\\n\\n```cpp\\n0 1 0 0 0 1 1\\n```\\n\\nWith a nested loop, going by row first and by element later, we can easily work like that and save ourselves the pain (and computatinal cost) of a few unnecessary swaps and flips).\\n\\nOnce we are done, time to return `arr` :)\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& arr) {\\n        // support variables\\n        int halfLen = arr[0].size() / 2, len = arr[0].size() - 1;\\n        for (auto &row: arr) {\\n            for (int i = 0; i < halfLen; i++) {\\n                // working only on equal pairss\\n                if (row[i] == row[len - i]) {\\n                    row[i] = !row[i];\\n                    row[len - i] = row[i];\\n                }\\n            }\\n            // swapping the central element for rows of odd length\\n            if (len % 2 == 0) row[halfLen] = !row[halfLen];\\n        }\\n        return arr;\\n    }\\n};\\n```\\n\\nFor comparison, the needlessly complicated solution I came up with months ago - thanks LeetCode for improving my skills to the point in which I no longer write this kind of stuff :D\\n\\nThe previous code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& A) {\\n        int i, tmp, lastPos;\\n        transform(begin(A), end(A), begin(A), [&](vector<int> e){\\n            lastPos = e.size() -1;\\n            for (i = 0; i < e.size() / 2; i++) {\\n                tmp = e[i];\\n                e[i] = !(e[lastPos - i]);\\n                e[lastPos - i] = !tmp;\\n            }\\n            if (e.size() % 2) e[e.size() / 2] = !e[e.size() / 2];\\n            return e;\\n        });\\n        return A;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Matrix"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& arr) {\\n        for (auto &row: arr) {\\n            // reversing the row\\n\\t\\t\\treverse(begin(row), end(row));\\n\\t\\t\\t// flipping its bits\\n            transform(begin(row), end(row), begin(row), [](auto b){return !b;});\\n        }\\n        return arr;\\n    }\\n}\\n```\n```cpp\\n0 0 1 1 1 0 1\\n```\n```cpp\\n0 0 1 1 1 0 1\\n```\n```cpp\\n0 1 1 1 1 1 1\\n```\n```cpp\\n0 1 0 1 0 1 1\\n```\n```cpp\\n0 1 0 0 0 1 1\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& arr) {\\n        // support variables\\n        int halfLen = arr[0].size() / 2, len = arr[0].size() - 1;\\n        for (auto &row: arr) {\\n            for (int i = 0; i < halfLen; i++) {\\n                // working only on equal pairss\\n                if (row[i] == row[len - i]) {\\n                    row[i] = !row[i];\\n                    row[len - i] = row[i];\\n                }\\n            }\\n            // swapping the central element for rows of odd length\\n            if (len % 2 == 0) row[halfLen] = !row[halfLen];\\n        }\\n        return arr;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& A) {\\n        int i, tmp, lastPos;\\n        transform(begin(A), end(A), begin(A), [&](vector<int> e){\\n            lastPos = e.size() -1;\\n            for (i = 0; i < e.size() / 2; i++) {\\n                tmp = e[i];\\n                e[i] = !(e[lastPos - i]);\\n                e[lastPos - i] = !tmp;\\n            }\\n            if (e.size() % 2) e[e.size() / 2] = !e[e.size() / 2];\\n            return e;\\n        });\\n        return A;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 143191,
                "title": "python-readable",
                "content": "```\\n        for row in xrange(len(A)):\\n            A[row] = A[row][::-1] # reverse the row\\n            \\n            for invert in xrange(len(A[row])): # invert each element\\n                if A[row][invert] == 0:\\n                    A[row][invert] = 1\\n                else:\\n                    A[row][invert] = 0\\n                    \\n        return A\\n```",
                "solutionTags": [],
                "code": "```\\n        for row in xrange(len(A)):\\n            A[row] = A[row][::-1] # reverse the row\\n            \\n            for invert in xrange(len(A[row])): # invert each element\\n                if A[row][invert] == 0:\\n                    A[row][invert] = 1\\n                else:\\n                    A[row][invert] = 0\\n                    \\n        return A\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2717567,
                "title": "two-pointer-solution",
                "content": "```\\n/**\\n * @param {number[][]} image\\n * @return {number[][]}\\n */\\nvar flipAndInvertImage = function(image) {\\n    for(let i = 0; i < image.length; i++){\\n        let left = 0;\\n        let right = image[i].length-1;\\n        while(left <= right){\\n            if(left === right){\\n                image[i][left] = image[i][left] === 0 ? 1 : 0\\n            }else{\\n                [image[i][left], image[i][right]] = [image[i][right], image[i][left]]\\n                image[i][left] = image[i][left] === 0 ? 1 : 0\\n                image[i][right] = image[i][right] === 0 ? 1 : 0\\n            }\\n            left++\\n            right--\\n        }\\n    }\\n    return image\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Two Pointers"
                ],
                "code": "```\\n/**\\n * @param {number[][]} image\\n * @return {number[][]}\\n */\\nvar flipAndInvertImage = function(image) {\\n    for(let i = 0; i < image.length; i++){\\n        let left = 0;\\n        let right = image[i].length-1;\\n        while(left <= right){\\n            if(left === right){\\n                image[i][left] = image[i][left] === 0 ? 1 : 0\\n            }else{\\n                [image[i][left], image[i][right]] = [image[i][right], image[i][left]]\\n                image[i][left] = image[i][left] === 0 ? 1 : 0\\n                image[i][right] = image[i][right] === 0 ? 1 : 0\\n            }\\n            left++\\n            right--\\n        }\\n    }\\n    return image\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1548646,
                "title": "python-xor-simplest-solution-beats-97",
                "content": "```\\nclass Solution:\\n    def flipAndInvertImage(self, image: List[List[int]]) -> List[List[int]]:\\n        for i in range(len(image)):\\n            start = 0\\n            end = len(image[i]) - 1\\n            while start <= end:\\n                image[i][start], image[i][end] = image[i][end]^1, image[i][start]^1\\n                start += 1\\n                end -= 1\\n        return image\\n```\\n\\n***If you liked the above solution then please upvote!***",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def flipAndInvertImage(self, image: List[List[int]]) -> List[List[int]]:\\n        for i in range(len(image)):\\n            start = 0\\n            end = len(image[i]) - 1\\n            while start <= end:\\n                image[i][start], image[i][end] = image[i][end]^1, image[i][start]^1\\n                start += 1\\n                end -= 1\\n        return image\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1480909,
                "title": "simple-javascript-solution",
                "content": "```\\nfunction invert(arr) {\\n    return arr.reverse();\\n}\\n\\nfunction flip(arr) {\\n    for(let i = 0; i<arr.length; i++) {\\n        if(arr[i] == 1) {\\n            arr.splice(i, 1, 0);\\n        } else if(arr[i] == 0 ) {\\n            arr.splice(i, 1, 1);\\n        }\\n    }\\n    return arr;\\n}\\n\\nvar flipAndInvertImage = function(image) {\\n   return image.map(img => flip(invert(img)));\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nfunction invert(arr) {\\n    return arr.reverse();\\n}\\n\\nfunction flip(arr) {\\n    for(let i = 0; i<arr.length; i++) {\\n        if(arr[i] == 1) {\\n            arr.splice(i, 1, 0);\\n        } else if(arr[i] == 0 ) {\\n            arr.splice(i, 1, 1);\\n        }\\n    }\\n    return arr;\\n}\\n\\nvar flipAndInvertImage = function(image) {\\n   return image.map(img => flip(invert(img)));\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1370149,
                "title": "java-0-ms-100-faster",
                "content": "```\\nclass Solution {\\n    public int[][] flipAndInvertImage(int[][] image) {\\n       int i =0;\\n        for(int [] mat : image){\\n            mat = flip(mat);\\n            mat = invert(mat);\\n            image[i++] = mat;\\n        }\\n        return image;\\n    }\\n\\t//flipping \\n    public int[] flip(int [] mat){\\n        int i = 0;\\n        int j = mat.length-1;\\n        while(i < j){\\n            int temp = mat[i];\\n            mat[i++] = mat[j];\\n            mat[j--] = temp;\\n        }\\n        \\n        return mat;\\n    }\\n    //inverting\\n    public int[] invert(int [] mat){\\n       for(int i = 0; i < mat.length; i++){\\n            if(mat[i] == 1){\\n                mat[i] = 0;\\n            }\\n           else {\\n               mat[i] = 1;\\n           }\\n        }\\n        return mat;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] flipAndInvertImage(int[][] image) {\\n       int i =0;\\n        for(int [] mat : image){\\n            mat = flip(mat);\\n            mat = invert(mat);\\n            image[i++] = mat;\\n        }\\n        return image;\\n    }\\n\\t//flipping \\n    public int[] flip(int [] mat){\\n        int i = 0;\\n        int j = mat.length-1;\\n        while(i < j){\\n            int temp = mat[i];\\n            mat[i++] = mat[j];\\n            mat[j--] = temp;\\n        }\\n        \\n        return mat;\\n    }\\n    //inverting\\n    public int[] invert(int [] mat){\\n       for(int i = 0; i < mat.length; i++){\\n            if(mat[i] == 1){\\n                mat[i] = 0;\\n            }\\n           else {\\n               mat[i] = 1;\\n           }\\n        }\\n        return mat;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 843663,
                "title": "c-short-and-simple-in-place-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& A) {\\n        for (int i=0; i<A.size(); i++) {\\n            reverse(A[i].begin(), A[i].end());\\n            for (int j=0; j<A[i].size(); j++) {\\n                A[i][j] ^= 0x1;\\n            }\\n        }\\n        return A;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& A) {\\n        for (int i=0; i<A.size(); i++) {\\n            reverse(A[i].begin(), A[i].end());\\n            for (int j=0; j<A[i].size(); j++) {\\n                A[i][j] ^= 0x1;\\n            }\\n        }\\n        return A;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 396821,
                "title": "multiple-simple-solutions-with-explanation-python",
                "content": "1. **Reverse each row** \\n\\n`flipped = [row[::-1] for row in A]`\\n\\n2. **Invert binary values** \\n\\nHere the trick is to use `map` as it applies a given function to all elements of the list. Here\\'s the blueprint from the official documentation:\\n\\n`map(function_to_apply, list_of_inputs)`\\n\\nDon\\'t forget to **cast it to list**!\\n\\nWe can now solve the problem with a compact expression like this:\\n\\n```\\ntranslation = {0:1, 1:0}\\nreturn [list(map(lambda x: translation[x], row[::-1])) for row in A] \\n```\\n\\nWhenever you want to operate with binary values, consider using bitwise operators. In this case \"AND\" allows us to translate 0 to 1 and viceversa:\\n\\n```\\nfor row in A:\\n  for i in range((len(row) + 1) // 2):\\n    row[i], row[~i] = row[~i] ^ 1, row[i] ^ 1\\n    return A \\n```\\n\\nNow combining this wisdom with our previous list comprehension solution:\\n\\n```\\nreturn [[i ^ 1 for i in row[::-1]] for row in A]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ntranslation = {0:1, 1:0}\\nreturn [list(map(lambda x: translation[x], row[::-1])) for row in A] \\n```\n```\\nfor row in A:\\n  for i in range((len(row) + 1) // 2):\\n    row[i], row[~i] = row[~i] ^ 1, row[i] ^ 1\\n    return A \\n```\n```\\nreturn [[i ^ 1 for i in row[::-1]] for row in A]\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 346663,
                "title": "python-3-accepted-solution",
                "content": "```\\nclass Solution:\\n    def flipAndInvertImage(self, A: List[List[int]]) -> List[List[int]]:\\n\\n        return [[abs(1-i) for i in row[::-1]] for row in A]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def flipAndInvertImage(self, A: List[List[int]]) -> List[List[int]]:\\n\\n        return [[abs(1-i) for i in row[::-1]] for row in A]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 130593,
                "title": "python-1-liner-48-ms",
                "content": "```\\nclass Solution(object):\\n    def flipAndInvertImage(self, A):\\n        return [[1 - x for x in A[i][::-1]] for i in range(len(A))]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def flipAndInvertImage(self, A):\\n        return [[1 - x for x in A[i][::-1]] for i in range(len(A))]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2893480,
                "title": "java-solution-with-0ms-runtime-beats-100-tc-o-n-n",
                "content": "**If you found it easy to understand, Please do upvote :)\\nThankyou!!**\\n**--------------------------------------------------------------------------------------------------**\\n![Today Leetcode Pic.JPG](https://assets.leetcode.com/users/images/c219a0c5-a102-4ce7-9d88-f5a3a783acdc_1670570648.5850391.jpeg)\\n**--------------------------------------------------------------------------------------------------**\\n# Complexity\\n- Time complexity: O(n*n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution \\n{\\n    public int[][] flipAndInvertImage(int[][] image) \\n    {\\n        //Flipping\\n        for(int i=0; i<image.length; i++)\\n        {            \\n            for(int left=0, right=image[i].length-1; left<=right; left++, right--)\\n            {\\n                //Two-pointer approach\\n                int temp = image[i][left];\\n                image[i][left] = image[i][right];\\n                image[i][right] = temp;\\n            }\\n        }\\n\\n        //Inverting\\n        for(int i=0; i<image.length; i++)\\n        {\\n            for(int j=0; j<image[i].length; j++)\\n            {\\n                image[i][j] = image[i][j]==0 ? 1 : 0;\\n            }\\n        }\\n        return image;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Matrix"
                ],
                "code": "```\\nclass Solution \\n{\\n    public int[][] flipAndInvertImage(int[][] image) \\n    {\\n        //Flipping\\n        for(int i=0; i<image.length; i++)\\n        {            \\n            for(int left=0, right=image[i].length-1; left<=right; left++, right--)\\n            {\\n                //Two-pointer approach\\n                int temp = image[i][left];\\n                image[i][left] = image[i][right];\\n                image[i][right] = temp;\\n            }\\n        }\\n\\n        //Inverting\\n        for(int i=0; i<image.length; i++)\\n        {\\n            for(int j=0; j<image[i].length; j++)\\n            {\\n                image[i][j] = image[i][j]==0 ? 1 : 0;\\n            }\\n        }\\n        return image;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2848365,
                "title": "python-easy-solution-99-81-faster",
                "content": "```\\nclass Solution:\\n    def flipAndInvertImage(self, image: List[List[int]]) -> List[List[int]]:\\n        m,n=len(image),len(image[0])\\n        for i in range(m):\\n            image[i]=image[i][-1::-1]\\n        for i in range(m):\\n            for j in range(n):\\n                if image[i][j]==0:\\n                    image[i][j]=1\\n                else:\\n                    image[i][j]=0\\n        return image\\n```\\n\\n**An upvote will be encouraging**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Matrix"
                ],
                "code": "```\\nclass Solution:\\n    def flipAndInvertImage(self, image: List[List[int]]) -> List[List[int]]:\\n        m,n=len(image),len(image[0])\\n        for i in range(m):\\n            image[i]=image[i][-1::-1]\\n        for i in range(m):\\n            for j in range(n):\\n                if image[i][j]==0:\\n                    image[i][j]=1\\n                else:\\n                    image[i][j]=0\\n        return image\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2788649,
                "title": "c-solution-using-xor",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        for(int i=0;i<image.size();i++){\\n            reverse(image[i].begin(),image[i].end()); // reverse each row\\n            for(int j=0; j<image[0].size(); j++){\\n                image[i][j] = image[i][j] ^ 1;      // flip each number\\n            }\\n        }\\n        return image;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        for(int i=0;i<image.size();i++){\\n            reverse(image[i].begin(),image[i].end()); // reverse each row\\n            for(int j=0; j<image[0].size(); j++){\\n                image[i][j] = image[i][j] ^ 1;      // flip each number\\n            }\\n        }\\n        return image;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2711033,
                "title": "java-solution-100-faster",
                "content": "```\\nclass Solution {\\n    public int[][] flipAndInvertImage(int[][] image) {\\n        \\n        for(int i=0;i<image.length;i++){\\n           reverse(image[i]);\\n           invert(image[i]);\\n        }\\n   \\n        // Either can use the for loop to invert the array individually or can use in single for loop\\n        // for(int i=0;i<image.length;i++){\\n        //    invert(image[i]);\\n        // }\\n        \\n        return image;\\n        \\n    }\\n    \\n    static void reverse(int []image){\\n        int s=0;\\n        int e=image.length-1;\\n        \\n        while(s<e){\\n            int temp=image[s];\\n            image[s] = image[e];\\n            image[e] = temp;\\n            s++;\\n            e--;\\n        }\\n    }\\n    \\n    static void invert(int []arr){\\n           for(int i=0;i<arr.length;i++){\\n               if(arr[i]==0){\\n                   arr[i]=1;\\n               }\\n               else{\\n                   arr[i]=0;\\n               }\\n           }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] flipAndInvertImage(int[][] image) {\\n        \\n        for(int i=0;i<image.length;i++){\\n           reverse(image[i]);\\n           invert(image[i]);\\n        }\\n   \\n        // Either can use the for loop to invert the array individually or can use in single for loop\\n        // for(int i=0;i<image.length;i++){\\n        //    invert(image[i]);\\n        // }\\n        \\n        return image;\\n        \\n    }\\n    \\n    static void reverse(int []image){\\n        int s=0;\\n        int e=image.length-1;\\n        \\n        while(s<e){\\n            int temp=image[s];\\n            image[s] = image[e];\\n            image[e] = temp;\\n            s++;\\n            e--;\\n        }\\n    }\\n    \\n    static void invert(int []arr){\\n           for(int i=0;i<arr.length;i++){\\n               if(arr[i]==0){\\n                   arr[i]=1;\\n               }\\n               else{\\n                   arr[i]=0;\\n               }\\n           }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1935953,
                "title": "runtime-1ms",
                "content": "```\\nclass Solution {\\n    public int[][] flipAndInvertImage(int[][] image) {\\n        int[][] magic=image;\\n        for(int i=0;i<magic.length;i++){\\n            reverse(magic[i]);\\n        }\\n        \\n        for(int i=0;i<magic.length;i++){\\n           for(int j=0;j<magic[0].length;j++){\\n               if(magic[i][j]==1){\\n                   magic[i][j]=0;\\n               }\\n               else if(magic[i][j]==0){\\n                   magic[i][j]=1;\\n               }\\n           }\\n        }\\n        return magic;\\n        \\n    }\\n    public void reverse(int[]nums){\\n        int max=nums.length-1;\\n        int half=max/2;\\n        for(int i=0;i<=half;i++){\\n            int temp=nums[i];\\n            nums[i]=nums[max-i];\\n            nums[max-i]=temp;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] flipAndInvertImage(int[][] image) {\\n        int[][] magic=image;\\n        for(int i=0;i<magic.length;i++){\\n            reverse(magic[i]);\\n        }\\n        \\n        for(int i=0;i<magic.length;i++){\\n           for(int j=0;j<magic[0].length;j++){\\n               if(magic[i][j]==1){\\n                   magic[i][j]=0;\\n               }\\n               else if(magic[i][j]==0){\\n                   magic[i][j]=1;\\n               }\\n           }\\n        }\\n        return magic;\\n        \\n    }\\n    public void reverse(int[]nums){\\n        int max=nums.length-1;\\n        int half=max/2;\\n        for(int i=0;i<=half;i++){\\n            int temp=nums[i];\\n            nums[i]=nums[max-i];\\n            nums[max-i]=temp;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1738309,
                "title": "c-faster-than-100-00",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        int n  = image.size();\\n        for(int i = 0 ; i < n ;i ++)\\n        {\\n            reverse(image[i].begin(),image[i].end());\\n            for(int j = 0 ; j < image[i].size() ; j ++)\\n                image[i][j] ^= 1;\\n        }\\n        return image;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        int n  = image.size();\\n        for(int i = 0 ; i < n ;i ++)\\n        {\\n            reverse(image[i].begin(),image[i].end());\\n            for(int j = 0 ; j < image[i].size() ; j ++)\\n                image[i][j] ^= 1;\\n        }\\n        return image;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1467103,
                "title": "c-0ms-beat-100-highly-readable-beginner-friendly",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        \\n        \\n        for(int idx = 0; idx < image.size(); idx++){\\n            reverse(image[idx].begin(), image[idx].end());\\n            \\n            for(int jdx = 0; jdx < image[0].size(); jdx++){\\n                if(image[idx][jdx] == 0)\\n                    image[idx][jdx] = 1;\\n                else\\n                    image[idx][jdx] = 0;\\n            }\\n        }\\n        \\n        return image;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        \\n        \\n        for(int idx = 0; idx < image.size(); idx++){\\n            reverse(image[idx].begin(), image[idx].end());\\n            \\n            for(int jdx = 0; jdx < image[0].size(); jdx++){\\n                if(image[idx][jdx] == 0)\\n                    image[idx][jdx] = 1;\\n                else\\n                    image[idx][jdx] = 0;\\n            }\\n        }\\n        \\n        return image;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1456179,
                "title": "c-soln",
                "content": "```class Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        for(int index = 0 ; index < image.size() ; index++)\\n        { \\n            reverse(image[index].begin() , image[index].end());\\n            for(int jindex = 0 ; jindex < image[0].size() ; jindex++)\\n            {\\n                image[index][jindex] =  !image[index][jindex];\\n            }\\n        }\\n        return image;\\n        \\n    }\\n};\\n\\n```\\nsimple reverse the row and then inverse each element",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```class Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        for(int index = 0 ; index < image.size() ; index++)\\n        { \\n            reverse(image[index].begin() , image[index].end());\\n            for(int jindex = 0 ; jindex < image[0].size() ; jindex++)\\n            {\\n                image[index][jindex] =  !image[index][jindex];\\n            }\\n        }\\n        return image;\\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1445622,
                "title": "java-simple-runtime-0-ms-faster-than-100-00-of-java-online-submissions",
                "content": "Kindly upvote if this solution helps you!\\n```\\npublic int[][] flipAndInvertImage(int[][] image) {\\n        for(int i =0; i< image.length; i++){\\n            int start =0, end=image[i].length -1;\\n\\t\\t\\t//Flipping\\n            while(start <= end){\\n                int temp = image[i][end];\\n                image[i][end] = image[i][start];\\n                image[i][start] = temp;\\n                start++;\\n                end--;\\n            }\\n\\t\\t\\t//Revert\\n            for(int j =0; j< image[i].length; j++){\\n                image[i][j] = (image[i][j] == 0) ? 1 : 0;\\n            }\\n        }\\n        return image;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int[][] flipAndInvertImage(int[][] image) {\\n        for(int i =0; i< image.length; i++){\\n            int start =0, end=image[i].length -1;\\n\\t\\t\\t//Flipping\\n            while(start <= end){\\n                int temp = image[i][end];\\n                image[i][end] = image[i][start];\\n                image[i][start] = temp;\\n                start++;\\n                end--;\\n            }\\n\\t\\t\\t//Revert\\n            for(int j =0; j< image[i].length; j++){\\n                image[i][j] = (image[i][j] == 0) ? 1 : 0;\\n            }\\n        }\\n        return image;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1057188,
                "title": "javascript",
                "content": "Runtime: 76 ms, faster than 98.04% of JavaScript online submissions for Flipping an Image.\\nMemory Usage: 40.6 MB, less than 40.43% of JavaScript online submissions for Flipping an Image.\\n\\n```\\nvar flipAndInvertImage = function(A) {\\n    var a = A.map((item)=> item.map((innerItem)=> innerItem===1? 0:1).reverse());\\n    return a;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar flipAndInvertImage = function(A) {\\n    var a = A.map((item)=> item.map((innerItem)=> innerItem===1? 0:1).reverse());\\n    return a;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1000802,
                "title": "runtime-92-85-faster-memory-86-81-simple-walk-through",
                "content": "class Solution:\\n    def flipAndInvertImage(self, A: List[List[int]]) -> List[List[int]]:\\n        \\n\\t\\t# Creating horizontally flipped array\\n\\t\\thoriz = []\\n\\t\\tfor row in A:\\n\\t\\t\\t\\thoriz.append(row[::-1])\\n\\t\\t\\n\\t\\t# Since it is a binary matrix, you can subtract 1 to change 1s to 0s. \\n\\t\\t# Your 0s will become -1s  once you subtract 1 so you will need to use absolute value.\\n\\t\\tfor i in range(len(horiz)):\\n\\t\\t\\t\\thoriz[i] = [abs(x-1) for x in horiz[i]]\\n\\n\\t\\treturn horiz",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math"
                ],
                "code": "class Solution:\\n    def flipAndInvertImage(self, A: List[List[int]]) -> List[List[int]]:\\n        \\n\\t\\t# Creating horizontally flipped array\\n\\t\\thoriz = []\\n\\t\\tfor row in A:\\n\\t\\t\\t\\thoriz.append(row[::-1])\\n\\t\\t\\n\\t\\t# Since it is a binary matrix, you can subtract 1 to change 1s to 0s. \\n\\t\\t# Your 0s will become -1s  once you subtract 1 so you will need to use absolute value.\\n\\t\\tfor i in range(len(horiz)):\\n\\t\\t\\t\\thoriz[i] = [abs(x-1) for x in horiz[i]]\\n\\n\\t\\treturn horiz",
                "codeTag": "Java"
            },
            {
                "id": 930868,
                "title": "simplest-and-most-intuitive-c-solution",
                "content": "```\\nvector<vector<int>> flipAndInvertImage(vector<vector<int>>& A) {\\n        int row = A.size(), col = A[0].size();\\n        for(int i = 0; i < row; i++)        \\n            for(int j = 0; j <= (col - 1) / 2; j++)\\n            {\\n                int temp = A[i][j];\\n                A[i][j] = !A[i][col - j - 1];\\n                A[i][col - j - 1] = !temp;\\n            }\\n        \\n        return A;\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nvector<vector<int>> flipAndInvertImage(vector<vector<int>>& A) {\\n        int row = A.size(), col = A[0].size();\\n        for(int i = 0; i < row; i++)        \\n            for(int j = 0; j <= (col - 1) / 2; j++)\\n            {\\n                int temp = A[i][j];\\n                A[i][j] = !A[i][col - j - 1];\\n                A[i][col - j - 1] = !temp;\\n            }\\n        \\n        return A;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 930805,
                "title": "flipping-an-image-java-updated",
                "content": "```\\nclass Solution \\n{\\n    /* Pretty straight foreword.  Grab one row from the matrix at a time.  Set a pointer to the \\n     * first element and the last element in the row.  If the elements pointed at are of different\\n     * values performing a swap would flip the values in the first and last pointers, then \\n     * performing an invert would flip them back.  It would be as though nothing had happened.  If\\n     * both the first and last values are the same the swap would maintain the value and the \\n     * invert would flip them.  They\\'re the same so no need to swap, just flip thier values.  Then\\n     * update pointers one step towords the center.\\n     */\\n    \\n    public int[][] flipAndInvertImage(int[][] A) \\n    {\\n        for( int[] r : A )\\n        {\\n            int     i = -1;\\n            int     j = r.length;\\n            \\n            while( ++i <= --j )\\n            {\\n                if( r[ i ] == r[ j ] )\\n                {\\n                    r[ j ] = r[ i ] = 1 ^ r[ i ];\\n                }\\n            }\\n        }\\n        \\n        return A;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution \\n{\\n    /* Pretty straight foreword.  Grab one row from the matrix at a time.  Set a pointer to the \\n     * first element and the last element in the row.  If the elements pointed at are of different\\n     * values performing a swap would flip the values in the first and last pointers, then \\n     * performing an invert would flip them back.  It would be as though nothing had happened.  If\\n     * both the first and last values are the same the swap would maintain the value and the \\n     * invert would flip them.  They\\'re the same so no need to swap, just flip thier values.  Then\\n     * update pointers one step towords the center.\\n     */\\n    \\n    public int[][] flipAndInvertImage(int[][] A) \\n    {\\n        for( int[] r : A )\\n        {\\n            int     i = -1;\\n            int     j = r.length;\\n            \\n            while( ++i <= --j )\\n            {\\n                if( r[ i ] == r[ j ] )\\n                {\\n                    r[ j ] = r[ i ] = 1 ^ r[ i ];\\n                }\\n            }\\n        }\\n        \\n        return A;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 843714,
                "title": "java-simplest-in-place-solution-0-ms-faster-than-100",
                "content": "```\\nclass Solution {\\n    // helper function to reverse array in-place:\\n    void rev(int[] A) {\\n        for(int i = 0; i < A.length / 2; i++)\\n        {\\n            int temp = A[i];\\n            A[i] = A[A.length - i - 1];\\n            A[A.length - i - 1] = temp;\\n        }\\n    }\\n    public int[][] flipAndInvertImage(int[][] A) {\\n        for (int i=0; i<A.length; i++) {\\n            rev(A[i]); // reverse the array\\n            for (int j=0; j<A[i].length; j++) { // flip\\n                A[i][j] ^= 0x1;\\n            }\\n        }\\n        return A;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    // helper function to reverse array in-place:\\n    void rev(int[] A) {\\n        for(int i = 0; i < A.length / 2; i++)\\n        {\\n            int temp = A[i];\\n            A[i] = A[A.length - i - 1];\\n            A[A.length - i - 1] = temp;\\n        }\\n    }\\n    public int[][] flipAndInvertImage(int[][] A) {\\n        for (int i=0; i<A.length; i++) {\\n            rev(A[i]); // reverse the array\\n            for (int j=0; j<A[i].length; j++) { // flip\\n                A[i][j] ^= 0x1;\\n            }\\n        }\\n        return A;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 720753,
                "title": "java-solution-0ms",
                "content": "```\\npublic int[][] flipAndInvertImage(int[][] A) {\\n        int[][] result = new int[A.length][A[0].length];\\n        \\n        for(int i = 0; i < A.length; i++){\\n            for(int j = A[i].length-1; j >= 0; j--){\\n                result[i][(A[i].length-1) - j] = A[i][j] ^ 1;\\n            }\\n        }\\n        return result;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int[][] flipAndInvertImage(int[][] A) {\\n        int[][] result = new int[A.length][A[0].length];\\n        \\n        for(int i = 0; i < A.length; i++){\\n            for(int j = A[i].length-1; j >= 0; j--){\\n                result[i][(A[i].length-1) - j] = A[i][j] ^ 1;\\n            }\\n        }\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 709751,
                "title": "python-simple-short-solution",
                "content": "```\\nclass Solution:\\n    def flipAndInvertImage(self, A: List[List[int]]) -> List[List[int]]:\\n        for i in range(len(A)):\\n            A[i] = list(map(lambda x: x^1,(A[i])))[::-1]\\n        \\n        return A",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def flipAndInvertImage(self, A: List[List[int]]) -> List[List[int]]:\\n        for i in range(len(A)):\\n            A[i] = list(map(lambda x: x^1,(A[i])))[::-1]\\n        \\n        return A",
                "codeTag": "Java"
            },
            {
                "id": 688789,
                "title": "c-solution",
                "content": "```\\nvector<vector<int>> flipAndInvertImage(vector<vector<int>>& A) {\\n\\tfor (auto& v : A) {\\n\\t\\treverse(v.begin(), v.end());\\n\\t\\tfor (auto& n : v)\\n\\t\\t\\tn = !n;\\n\\t}\\n\\treturn A;\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nvector<vector<int>> flipAndInvertImage(vector<vector<int>>& A) {\\n\\tfor (auto& v : A) {\\n\\t\\treverse(v.begin(), v.end());\\n\\t\\tfor (auto& n : v)\\n\\t\\t\\tn = !n;\\n\\t}\\n\\treturn A;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 601504,
                "title": "4-ms-faster-than-100-00-of-c-1-pass-solution",
                "content": "Let us Make an observation for following row [1,0,1,1]\\n\\n1)After row is reversed [1,0,1,1] -> [1,1,0,1]\\n2)After inversion [1,1,0,1]->[0,0,1,0]\\n\\nCompleted process is\\nA=[1,0,1,1] -> [1,1,0,1]->[0,0,1,0]\\n\\nLets take index i=0 and j = len-1 = 3\\nA[i] = 1 and A[j] = 1 initially and their final values are A[i] = 0 A[j] = 0 \\nfor i = 0 and j = 2\\nA[i] =0 and A[j] = 1 initially and their final vales are A[i] = 0 A[j] = 1\\n\\n1)We can observe that when both the **values are same** there is no point in swaping to get reverse hence just **flipping the bits** is enough\\n2)If the values are different such as 0,1 or 1,0 after they are reversed they become 1,0 and o,1 and then after flipping them become 0,1 and 1,0 which are its initial values.Hence we **do not need to make any change** for these values.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& A) {\\n        int n = A.size();\\n        int m = A[0].size();\\n        int j,i;\\n        for(int k=0;k<n;k++)\\n        {\\n            i = 0;\\n            j = m-1;\\n            while(i<j)\\n            {\\n                if(A[k][i]==A[k][j]) // As bits are same we flip the bits using XOR operation\\n                {\\n                    A[k][i]^=1;\\n                    A[k][j]^=1;\\n                }\\n                i++;\\n                j--;\\n            }\\n            if(i==j) //In case of the row length is odd flip the  middle bit  as i==j have same bit\\n                A[k][i]^=1;\\n            \\n        }\\n        return A;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& A) {\\n        int n = A.size();\\n        int m = A[0].size();\\n        int j,i;\\n        for(int k=0;k<n;k++)\\n        {\\n            i = 0;\\n            j = m-1;\\n            while(i<j)\\n            {\\n                if(A[k][i]==A[k][j]) // As bits are same we flip the bits using XOR operation\\n                {\\n                    A[k][i]^=1;\\n                    A[k][j]^=1;\\n                }\\n                i++;\\n                j--;\\n            }\\n            if(i==j) //In case of the row length is odd flip the  middle bit  as i==j have same bit\\n                A[k][i]^=1;\\n            \\n        }\\n        return A;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 500487,
                "title": "short-c-solution",
                "content": "```\\n    public class Solution\\n    {\\n        public int[][] FlipAndInvertImage(int[][] matrix)\\n        {\\n            \\n            for (int i = 0; i < matrix.Length; i++)\\n            {\\n                Array.Reverse(matrix[i]);\\n                for (int j = 0; j < matrix[i].Length; j++)\\n                {\\n                    matrix[i][j]++;\\n                    matrix[i][j] %= 2;\\n                }\\n            }\\n\\n            return matrix;\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public class Solution\\n    {\\n        public int[][] FlipAndInvertImage(int[][] matrix)\\n        {\\n            \\n            for (int i = 0; i < matrix.Length; i++)\\n            {\\n                Array.Reverse(matrix[i]);\\n                for (int j = 0; j < matrix[i].Length; j++)\\n                {\\n                    matrix[i][j]++;\\n                    matrix[i][j] %= 2;\\n                }\\n            }\\n\\n            return matrix;\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 327584,
                "title": "c-code-faster-than-100",
                "content": "```\\n\\nint** flipAndInvertImage(int** A, int ASize, int* AColSize, int* returnSize, int** returnColumnSizes){\\n\\t*returnSize = ASize;  //\\u8FD4\\u56DE\\u5217\\u7684\\u5927\\u5C0F(\\u6709\\u5E7E\\u5217)\\n\\tint colsize = *AColSize;  //\\u884C\\u7684\\u5927\\u5C0F(\\u6709\\u5E7E\\u884C)\\n\\tint** retarr = (int**)malloc(sizeof(int*) * ASize); //\\u52D5\\u614B\\u5BA3\\u544A\\u4E00\\u500B\\u96D9\\u91CD\\u6307\\u6A19\\n\\t*returnColumnSizes = (int*)malloc(sizeof(int) * (*AColSize)); //\\u76EE\\u7684:\\u8FD4\\u56DE\\u6BCF\\u4E00\\u5217\\u6709\\u5E7E\\u884C\\n\\tfor (int i = 0; i < ASize; i ++)  //\\u5C0D\\u6BCF\\u4E00\\u5217\\u5206\\u5225\\u8655\\u7406\\n    {\\n\\t\\tint* newone = (int*)malloc(sizeof(int) * colsize);\\n\\t\\tfor (int j = 0; j < colsize; j ++) \\n        {\\n\\t\\t\\tint t = A[i][j];\\n\\t\\t\\tt^=1; //\\u5148\\u5C07t\\u76841\\u8B8A0\\uFF0C0\\u8B8A1\\u3002\\n\\t\\t\\tnewone[colsize - j - 1] = t;  //\\u4F7F\\u8A72\\u884C\\u524D\\u5F8C\\u9806\\u5E8F\\u5C0D\\u8ABF\\n\\t\\t}\\n\\t\\tretarr[i] = newone;  \\n\\t\\t(*returnColumnSizes)[i] = colsize;\\n\\t}\\n\\treturn retarr;\\n}\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\nint** flipAndInvertImage(int** A, int ASize, int* AColSize, int* returnSize, int** returnColumnSizes){\\n\\t*returnSize = ASize;  //\\u8FD4\\u56DE\\u5217\\u7684\\u5927\\u5C0F(\\u6709\\u5E7E\\u5217)\\n\\tint colsize = *AColSize;  //\\u884C\\u7684\\u5927\\u5C0F(\\u6709\\u5E7E\\u884C)\\n\\tint** retarr = (int**)malloc(sizeof(int*) * ASize); //\\u52D5\\u614B\\u5BA3\\u544A\\u4E00\\u500B\\u96D9\\u91CD\\u6307\\u6A19\\n\\t*returnColumnSizes = (int*)malloc(sizeof(int) * (*AColSize)); //\\u76EE\\u7684:\\u8FD4\\u56DE\\u6BCF\\u4E00\\u5217\\u6709\\u5E7E\\u884C\\n\\tfor (int i = 0; i < ASize; i ++)  //\\u5C0D\\u6BCF\\u4E00\\u5217\\u5206\\u5225\\u8655\\u7406\\n    {\\n\\t\\tint* newone = (int*)malloc(sizeof(int) * colsize);\\n\\t\\tfor (int j = 0; j < colsize; j ++) \\n        {\\n\\t\\t\\tint t = A[i][j];\\n\\t\\t\\tt^=1; //\\u5148\\u5C07t\\u76841\\u8B8A0\\uFF0C0\\u8B8A1\\u3002\\n\\t\\t\\tnewone[colsize - j - 1] = t;  //\\u4F7F\\u8A72\\u884C\\u524D\\u5F8C\\u9806\\u5E8F\\u5C0D\\u8ABF\\n\\t\\t}\\n\\t\\tretarr[i] = newone;  \\n\\t\\t(*returnColumnSizes)[i] = colsize;\\n\\t}\\n\\treturn retarr;\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 310141,
                "title": "python-1-liner-with-abs",
                "content": "About 30ms \\n```\\nclass Solution(object):\\n    def flipAndInvertImage(self, A):\\n        return [[abs(y-1) for y in x][::-1] for x in A]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution(object):\\n    def flipAndInvertImage(self, A):\\n        return [[abs(y-1) for y in x][::-1] for x in A]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 285571,
                "title": "c-why-is-returncolumnsizes-a-double-int-pointer",
                "content": "Since ```ASize``` is already a parameter, wouldn\\'t a 1D array (of length `ASize`) suffice to mention the length of columns for each row?\\n\\nWhy are `*returnSize`  and `returnColSize` required when `ASize` and `*AColSize` are already passed to us?",
                "solutionTags": [],
                "code": "```ASize```",
                "codeTag": "Unknown"
            },
            {
                "id": 169705,
                "title": "javascript-es6-one-liner",
                "content": "```\\nvar flipAndInvertImage = function(A) {\\n    return A.map((row) => row.reverse().map((pixel) => pixel ^ 1));\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar flipAndInvertImage = function(A) {\\n    return A.map((row) => row.reverse().map((pixel) => pixel ^ 1));\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 144414,
                "title": "c-solution-in-4ms",
                "content": "```\\n/**\\n * Return an array of arrays of size *returnSize.\\n * The sizes of the arrays are returned as *columnSizes array.\\n * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().\\n */\\nint** flipAndInvertImage(int** A, int ARowSize, int *AColSizes, int** columnSizes, int* returnSize) {\\n\\t*returnSize = ARowSize;\\n\\tint colsize = *AColSizes;\\n\\tint** retarr = (int**)malloc(sizeof(void*) * ARowSize);\\n\\t*columnSizes = (int*)malloc(sizeof(int) * ARowSize);\\n\\tfor (int i = 0; i < ARowSize; i ++) {\\n\\t\\tint* one = A[i];\\n\\t\\tint* newone = (int*)malloc(sizeof(int) * colsize);\\n\\t\\tfor (int j = 0; j < colsize; j ++) {\\n\\t\\t\\tint t = one[j];\\n\\t\\t\\tif (t == 1) t = 0;\\n\\t\\t\\telse t = 1;\\n\\t\\t\\tnewone[colsize - j - 1] = t;\\n\\t\\t}\\n\\t\\tretarr[i] = newone;\\n\\t\\t(*columnSizes)[i] = colsize;\\n\\t}\\n\\treturn retarr;\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Return an array of arrays of size *returnSize.\\n * The sizes of the arrays are returned as *columnSizes array.\\n * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().\\n */\\nint** flipAndInvertImage(int** A, int ARowSize, int *AColSizes, int** columnSizes, int* returnSize) {\\n\\t*returnSize = ARowSize;\\n\\tint colsize = *AColSizes;\\n\\tint** retarr = (int**)malloc(sizeof(void*) * ARowSize);\\n\\t*columnSizes = (int*)malloc(sizeof(int) * ARowSize);\\n\\tfor (int i = 0; i < ARowSize; i ++) {\\n\\t\\tint* one = A[i];\\n\\t\\tint* newone = (int*)malloc(sizeof(int) * colsize);\\n\\t\\tfor (int j = 0; j < colsize; j ++) {\\n\\t\\t\\tint t = one[j];\\n\\t\\t\\tif (t == 1) t = 0;\\n\\t\\t\\telse t = 1;\\n\\t\\t\\tnewone[colsize - j - 1] = t;\\n\\t\\t}\\n\\t\\tretarr[i] = newone;\\n\\t\\t(*columnSizes)[i] = colsize;\\n\\t}\\n\\treturn retarr;\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 133838,
                "title": "java-clean-and-easy-to-understand-in-7-ms",
                "content": "```\\nclass Solution {\\n    public int[][] flipAndInvertImage(int[][] A) {\\n        int invertedImage[][] = new int[A.length][];\\n        for(int i = 0; i < A.length; i++)\\n        {\\n           int rev[] = reverseNum(A[i]);\\n           int inv[] = inverseNum(rev);\\n           invertedImage[i] = inv;  \\n        }\\n        return invertedImage;\\n    }\\n    \\n    private int[] reverseNum(int num[])\\n    {\\n        for(int i = 0; i < (num.length)/2; i++)\\n        {\\n            int temp = num[i];\\n            num[i]  = num[num.length - i - 1];\\n            num[num.length - i - 1] = temp;\\n        }\\n        return num;\\n    }\\n    \\n    private int[] inverseNum(int num[])\\n    {\\n        for(int i = 0; i < num.length; i++)\\n        {\\n             num[i] = num[i]^1;\\n        }\\n        return num;\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[][] flipAndInvertImage(int[][] A) {\\n        int invertedImage[][] = new int[A.length][];\\n        for(int i = 0; i < A.length; i++)\\n        {\\n           int rev[] = reverseNum(A[i]);\\n           int inv[] = inverseNum(rev);\\n           invertedImage[i] = inv;  \\n        }\\n        return invertedImage;\\n    }\\n    \\n    private int[] reverseNum(int num[])\\n    {\\n        for(int i = 0; i < (num.length)/2; i++)\\n        {\\n            int temp = num[i];\\n            num[i]  = num[num.length - i - 1];\\n            num[num.length - i - 1] = temp;\\n        }\\n        return num;\\n    }\\n    \\n    private int[] inverseNum(int num[])\\n    {\\n        for(int i = 0; i < num.length; i++)\\n        {\\n             num[i] = num[i]^1;\\n        }\\n        return num;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 130569,
                "title": "my-easy-5-lines-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& A) {\\n\\tvector<vector<int>> res(A.size());\\n\\tfor (int i = 0; i < A.size(); ++i) {\\n\\t    for (int j = A[i].size() - 1; j >= 0; --j) {\\n\\t\\tres[i].push_back(!A[i][j]);\\n\\t    }\\n\\t}\\n\\treturn res;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& A) {\\n\\tvector<vector<int>> res(A.size());\\n\\tfor (int i = 0; i < A.size(); ++i) {\\n\\t    for (int j = A[i].size() - 1; j >= 0; --j) {\\n\\t\\tres[i].push_back(!A[i][j]);\\n\\t    }",
                "codeTag": "Java"
            },
            {
                "id": 3088304,
                "title": "python-1-map-functools-partial-lambda-reversed-2-list-comprehension-xor-reversed-3-hybrid",
                "content": "**Solution 1: map, functools.partial, lambda, reversed**  \\nhttps://leetcode.com/submissions/detail/883403380/  \\nRuntime: **69 ms**, faster than 35.35% of Python3 online submissions for Flipping an Image.  \\nMemory Usage: 13.8 MB, less than 58.85% of Python3 online submissions for Flipping an Image.  \\n```\\nclass Solution:\\n    def flipAndInvertImage(self, image: List[List[int]]) -> List[List[int]]:\\n        return map(partial(map, lambda x: 0 if x else 1), map(reversed, image))\\n```\\n\\n**Solution 2: list comprehension, xor, reversed**  \\nhttps://leetcode.com/submissions/detail/883408340/\\nRuntime: **50 ms**, faster than 87.19% of Python3 online submissions for Flipping an Image.  \\nMemory Usage: 13.9 MB, less than 58.85% of Python3 online submissions for Flipping an Image.  \\n```\\nclass Solution:\\n    def flipAndInvertImage(self, image: List[List[int]]) -> List[List[int]]:\\n        return [reversed([pixel^1 for pixel in row]) for row in image]\\n```\\n\\n**Solution 3: hybrid**  \\nhttps://leetcode.com/submissions/detail/883418919/  \\nRuntime: **43 ms**, faster than 98.69% of Python3 online submissions for Flipping an Image.  \\nMemory Usage: 13.9 MB, less than 58.85% of Python3 online submissions for Flipping an Image.  \\n```\\nclass Solution:\\n    def flipAndInvertImage(self, image: List[List[int]]) -> List[List[int]]:\\n        return [reversed(list(map(int, map(operator.not_, row)))) for row in image]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def flipAndInvertImage(self, image: List[List[int]]) -> List[List[int]]:\\n        return map(partial(map, lambda x: 0 if x else 1), map(reversed, image))\\n```\n```\\nclass Solution:\\n    def flipAndInvertImage(self, image: List[List[int]]) -> List[List[int]]:\\n        return [reversed([pixel^1 for pixel in row]) for row in image]\\n```\n```\\nclass Solution:\\n    def flipAndInvertImage(self, image: List[List[int]]) -> List[List[int]]:\\n        return [reversed(list(map(int, map(operator.not_, row)))) for row in image]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3049038,
                "title": "runtime-beats-100-memory-beats-91-26-simple-java-solution",
                "content": "# Intuition\\nThe task is to first reverse all the contents of all the sub arrays inside the given two dimentional array, then to inverse the contents of the array(ie. to replace 1 with 0 and vice versa).\\n\\n# Approach\\nInvertion is the easy part, just an if-else loop to change 1 from 0 and vice versa.\\nReversal is carried out by taking two variables each pointing to the extreme most end indices of the sub-arrays, then swapping them with the help of a temporary variable. this is carried out until the two indices variables don\\'t cross each other.\\n\\nIn case you need a detailed understanding on how the program iterates and how the value of the variables change respectively for iteration, uncomment the reference code given in the code and run. \\n\\n# Upvote if you like my solution.\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] flipAndInvertImage(int[][] image) {\\n        int i = 0;\\n        int a = 0;\\n        int temp = 0;\\n\\n        //Reversal\\n        while(i < image.length){\\n            int b = image.length-1;\\n            while(a <= b){\\n                /*System.out.println(i);*/\\n                temp = image[i][b];\\n                image[i][b] = image[i][a];\\n                image[i][a] = temp;\\n                /*System.out.println(a+\" \"+b);*/\\n                a++;\\n                b--;\\n                /*System.out.println(a+\" \"+b);*/\\n            }\\n            a = 0;\\n            b = 0;\\n            i++;\\n        }\\n\\n//Output for reference.\\n/*for(int o=0; o<image.length; o++){\\nfor(int j=0; j<image.length; j++){\\nSystem.out.print(image[o][j]);\\n}\\nSystem.out.println();\\n}\\nSystem.out.println();*/\\n\\n        //Inverting\\n        for(int j = 0; j < image.length; j++){\\n            for(int k = 0; k < image.length; k++){\\n                if(image[j][k] == 0){\\n                    image[j][k] = 1;\\n                }else{\\n                    image[j][k] = 0;\\n                }\\n            }\\n        }\\n\\n//Output for reference.\\n/*for(int o=0; o<image.length; o++){\\nfor(int j=0; j<image.length; j++){\\nSystem.out.print(image[o][j]);\\n}\\nSystem.out.println();\\n}*/\\n\\n        return image;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] flipAndInvertImage(int[][] image) {\\n        int i = 0;\\n        int a = 0;\\n        int temp = 0;\\n\\n        //Reversal\\n        while(i < image.length){\\n            int b = image.length-1;\\n            while(a <= b){\\n                /*System.out.println(i);*/\\n                temp = image[i][b];\\n                image[i][b] = image[i][a];\\n                image[i][a] = temp;\\n                /*System.out.println(a+\" \"+b);*/\\n                a++;\\n                b--;\\n                /*System.out.println(a+\" \"+b);*/\\n            }\\n            a = 0;\\n            b = 0;\\n            i++;\\n        }\\n\\n//Output for reference.\\n/*for(int o=0; o<image.length; o++){\\nfor(int j=0; j<image.length; j++){\\nSystem.out.print(image[o][j]);\\n}\\nSystem.out.println();\\n}\\nSystem.out.println();*/\\n\\n        //Inverting\\n        for(int j = 0; j < image.length; j++){\\n            for(int k = 0; k < image.length; k++){\\n                if(image[j][k] == 0){\\n                    image[j][k] = 1;\\n                }else{\\n                    image[j][k] = 0;\\n                }\\n            }\\n        }\\n\\n//Output for reference.\\n/*for(int o=0; o<image.length; o++){\\nfor(int j=0; j<image.length; j++){\\nSystem.out.print(image[o][j]);\\n}\\nSystem.out.println();\\n}*/\\n\\n        return image;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2868600,
                "title": "python-faster-than-97-71-memory-beats-96-95",
                "content": "# Code\\n### Credits: qiy2019, jiny2019\\n```\\nclass Solution:\\n    def flipAndInvertImage(self, image: List[List[int]]) -> List[List[int]]:\\n        newMatrix = []\\n        for row in image:\\n            reversedRow = reversed(row)\\n            newRow = []\\n            for item in reversedRow:\\n                if item == 1: newRow.append(0)\\n                else: newRow.append(1)\\n            newMatrix.append(newRow)\\n        return newMatrix\\n```\\n\\n![image.png](https://assets.leetcode.com/users/images/17175a9a-d48f-4d01-9aeb-36bf77483609_1669957888.1098146.png)\\n![image.png](https://assets.leetcode.com/users/images/dfbc41cb-730c-4fda-8934-f44032149a83_1669957915.5076413.png)\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def flipAndInvertImage(self, image: List[List[int]]) -> List[List[int]]:\\n        newMatrix = []\\n        for row in image:\\n            reversedRow = reversed(row)\\n            newRow = []\\n            for item in reversedRow:\\n                if item == 1: newRow.append(0)\\n                else: newRow.append(1)\\n            newMatrix.append(newRow)\\n        return newMatrix\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2651809,
                "title": "java-easy-100-0ms-o-n",
                "content": "# Please Upvote\\n\\n```\\npublic int[][] flipAndInvertImage(int[][] image) {\\n        int r = image.length, c = image[0].length;\\n        int ans[][] = new int[r][c];\\n        for(int i = 0; i < r; i++)\\n            ans[i] = reverse(image[i]);\\n        return ans;\\n    }\\n    public int[] reverse(int a[]){\\n        int ans[] = new int[a.length];\\n        int n = a.length;\\n        for(int i = 0; i < n; i++)\\n            ans[i] = a[n - 1 - i] == 0 ? 1 : 0;\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int[][] flipAndInvertImage(int[][] image) {\\n        int r = image.length, c = image[0].length;\\n        int ans[][] = new int[r][c];\\n        for(int i = 0; i < r; i++)\\n            ans[i] = reverse(image[i]);\\n        return ans;\\n    }\\n    public int[] reverse(int a[]){\\n        int ans[] = new int[a.length];\\n        int n = a.length;\\n        for(int i = 0; i < n; i++)\\n            ans[i] = a[n - 1 - i] == 0 ? 1 : 0;\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2641683,
                "title": "c-7ms-code-o-n-k-time-complexity",
                "content": "There is a two dimensional vector and it consists of a lot of subarrays. now we need to traverse the whole array using for loop and also we need to access each element of the subarrays. We have initialized the front =0 and end = image[i].size()-1, which means the size of each subarrays  that we need to traverse. \\n\\nThe question says that we need to flip the image. For flipping the image we need to reverse each element of the subarray and then changing the bits as 0 to 1 and 1 to 0.  The next i have used while loop to reverse each subarray by simply swapping it using 2 pointers. After doing this we have incremented the front part and decremented the end part.\\n\\nThe for loop that we have used in 7th line is helping us traverse through all array as whole. The first part of our question is finished.\\nNow second part of our question says that we need to reverse the bits or change the bits as 0 to 1 and 1 to 0.For that we have used a second for loop which again is traversing through an array as whole the second for loop here is simply accessing the subarray. We have used not gate and simply returned the vector \\n\\n```\\nclass Solution {\\npublic\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        int front =0;\\n        int end = image[front].size()-1;\\n        for(int i=0;i<image.size();i++){\\n            front = 0;\\n            end = image[i].size()-1;\\n            while(front<=end){\\n                swap(image[i][front],image[i][end]);\\n                  front++;\\n                   end--;\\n               }\\n            }\\n         for(int i=0;i<image.size();i++){\\n             for(int j = 0; j < image[i].size();j++){\\n                 image[i][j]=!image[i][j];\\n                 \\n             }\\n         }\\n         \\n        \\n         return image;\\n        }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        int front =0;\\n        int end = image[front].size()-1;\\n        for(int i=0;i<image.size();i++){\\n            front = 0;\\n            end = image[i].size()-1;\\n            while(front<=end){\\n                swap(image[i][front],image[i][end]);\\n                  front++;\\n                   end--;\\n               }\\n            }\\n         for(int i=0;i<image.size();i++){\\n             for(int j = 0; j < image[i].size();j++){\\n                 image[i][j]=!image[i][j];\\n                 \\n             }\\n         }\\n         \\n        \\n         return image;\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2469608,
                "title": "one-pass-with-go",
                "content": "```\\nfunc flipAndInvertImage(image [][]int) [][]int {\\n    flip := func(a int) int {\\n        if a == 0 {\\n            return 1\\n        }\\n        \\n        return 0\\n    }\\n    \\n    for row := 0; row < len(image); row++ {\\n        l, r := 0, len(image[row])-1\\n        \\n        for l < r {\\n            image[row][l], image[row][r] = flip(image[row][r]), flip(image[row][l])\\n            l++\\n            r--\\n        }\\n        \\n        if l == r {\\n            image[row][r] = flip(image[row][r])\\n        }\\n    }\\n    \\n    return image\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc flipAndInvertImage(image [][]int) [][]int {\\n    flip := func(a int) int {\\n        if a == 0 {\\n            return 1\\n        }\\n        \\n        return 0\\n    }\\n    \\n    for row := 0; row < len(image); row++ {\\n        l, r := 0, len(image[row])-1\\n        \\n        for l < r {\\n            image[row][l], image[row][r] = flip(image[row][r]), flip(image[row][l])\\n            l++\\n            r--\\n        }\\n        \\n        if l == r {\\n            image[row][r] = flip(image[row][r])\\n        }\\n    }\\n    \\n    return image\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2398328,
                "title": "c-easy-to-understand-in-place",
                "content": "```\\nclass Solution {\\npublic:\\n    void change(vector<int>& arr){\\n        for(int i = 0; i < arr.size(); i++){\\n            if(arr[i] == 0){\\n                arr[i] = 1;\\n            } else {\\n                arr[i] = 0;\\n            }\\n        }\\n    }\\n    \\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        for(int i = 0; i < image.size(); i++){\\n            reverse(image[i].begin(), image[i].end());\\n            change(image[i]);\\n        }\\n        return image;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void change(vector<int>& arr){\\n        for(int i = 0; i < arr.size(); i++){\\n            if(arr[i] == 0){\\n                arr[i] = 1;\\n            } else {\\n                arr[i] = 0;\\n            }\\n        }\\n    }\\n    \\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        for(int i = 0; i < image.size(); i++){\\n            reverse(image[i].begin(), image[i].end());\\n            change(image[i]);\\n        }\\n        return image;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2256536,
                "title": "python-very-easy-solution-simple-to-understand",
                "content": "\\n```\\n\\nflipped = []\\n\\nfor items in image:\\n\\tlst = []\\n\\tfor e in items:\\n\\t\\tif e == 1:\\n\\t\\t\\tlst.append(0)\\n\\t\\telif e == 0:\\n\\t\\t\\tlst.append(1)\\n\\tflipped.append(lst[::-1])\\n\\nreturn flipped\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n\\nflipped = []\\n\\nfor items in image:\\n\\tlst = []\\n\\tfor e in items:\\n\\t\\tif e == 1:\\n\\t\\t\\tlst.append(0)\\n\\t\\telif e == 0:\\n\\t\\t\\tlst.append(1)\\n\\tflipped.append(lst[::-1])\\n\\nreturn flipped\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1280790,
                "title": "kotlin-style-simple-one-line",
                "content": "```\\nfun flipAndInvertImage(image: Array<IntArray>) = \\n\\timage.map{ it.map{ i -> if( i == 1) 0 else 1 }.reversed()}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nfun flipAndInvertImage(image: Array<IntArray>) = \\n\\timage.map{ it.map{ i -> if( i == 1) 0 else 1 }.reversed()}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1225285,
                "title": "32ms-python-with-comments",
                "content": "If you find this post helpful, please **Upvote** :)\\n```\\nclass Solution(object):\\n    def flipAndInvertImage(self, image):\\n        \"\"\"\\n        :type image: List[List[int]]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n\\t\\t#create a variable to store the result\\n        result = []\\n\\t\\t#create a variable for storing the number of elements in each sublist as we need it later, saving some computation time, by declaring it as a constant\\n        length = len(image[0])\\n\\t\\t#looping through each pixel in the images list\\n        for pixel in image:\\n\\t\\t#mapping each element in the pixel with xor of 1, ^1, because it returns the opposite of 0,1!\\n\\t\\t#We also reverse the list by slicing\\n          temp = map(operator.xor,pixel,[1]*length)[::-1]\\n\\t\\t  #Add each sublist in the desired formate in the result list\\n          result.append(temp)\\n        return result\\n```\\n![image](https://assets.leetcode.com/users/images/3e28b665-f943-43f6-89b4-87068b566358_1621757552.7224703.png)\\nPlease comment if you have any doubts or suggestions :)",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution(object):\\n    def flipAndInvertImage(self, image):\\n        \"\"\"\\n        :type image: List[List[int]]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n\\t\\t#create a variable to store the result\\n        result = []\\n\\t\\t#create a variable for storing the number of elements in each sublist as we need it later, saving some computation time, by declaring it as a constant\\n        length = len(image[0])\\n\\t\\t#looping through each pixel in the images list\\n        for pixel in image:\\n\\t\\t#mapping each element in the pixel with xor of 1, ^1, because it returns the opposite of 0,1!\\n\\t\\t#We also reverse the list by slicing\\n          temp = map(operator.xor,pixel,[1]*length)[::-1]\\n\\t\\t  #Add each sublist in the desired formate in the result list\\n          result.append(temp)\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 934987,
                "title": "c-fast-and-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n       vector<vector<int>> flipAndInvertImage(vector<vector<int>>& A) {\\n        for (auto& row : A) reverse(row.begin(), row.end());\\n        for (auto& row : A) for (int& i: row) i ^= 1;\\n        return A;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n       vector<vector<int>> flipAndInvertImage(vector<vector<int>>& A) {\\n        for (auto& row : A) reverse(row.begin(), row.end());\\n        for (auto& row : A) for (int& i: row) i ^= 1;\\n        return A;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 931245,
                "title": "python-3-solution-for-those-who-only-start-solving-leetcode-problems",
                "content": "...but it still beats 94% of all submissions.\\n\\n**Idea**:\\nFirst create a list ```flipped``` that will contain flipped rows\\nThen go through every row and every element in ```flipped``` and change ones to zeros and vice versa saving the result in ```invert```.\\n\\n```\\ndef flipAndInvertImage(A):\\n    if len(A) == 0: return []\\n    flipped = []\\n    for row in A:\\n        flipped.append(row[::-1])\\n    invert = []\\n    for row in flipped:\\n        curr = []\\n        for element in row:\\n            if element == 1:\\n                curr.append(0)\\n            else:\\n                curr.append(1)\\n        invert.append(curr)\\n    return invert\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```flipped```\n```flipped```\n```invert```\n```\\ndef flipAndInvertImage(A):\\n    if len(A) == 0: return []\\n    flipped = []\\n    for row in A:\\n        flipped.append(row[::-1])\\n    invert = []\\n    for row in flipped:\\n        curr = []\\n        for element in row:\\n            if element == 1:\\n                curr.append(0)\\n            else:\\n                curr.append(1)\\n        invert.append(curr)\\n    return invert\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 930554,
                "title": "python-one-liner-cool-clear-solution-runtime-faster-than-98-82-memory-less-than-100-00",
                "content": "\\tclass Solution:\\n\\t\\tdef flipAndInvertImage(self, A: List[List[int]]) -> List[List[int]]:\\n\\t\\t\\treturn [[num ^ 1 for num in line[::-1]] for line in A]\\n\\n        \\n\\n\\nliked? please upvote....",
                "solutionTags": [
                    "Python3"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef flipAndInvertImage(self, A: List[List[int]]) -> List[List[int]]:\\n\\t\\t\\treturn [[num ^ 1 for num in line[::-1]] for line in A]\\n\\n        \\n\\n\\nliked? please upvote....",
                "codeTag": "Java"
            },
            {
                "id": 930423,
                "title": "rust-makes-this-one-too-easy",
                "content": "```\\nimpl Solution {\\n    pub fn flip_and_invert_image(mut a: Vec<Vec<i32>>) -> Vec<Vec<i32>> {\\n        for v in a.iter_mut() {\\n            v.reverse();\\n            for l in v.iter_mut() {\\n                *l ^= 1;\\n            }\\n        }\\n        a\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn flip_and_invert_image(mut a: Vec<Vec<i32>>) -> Vec<Vec<i32>> {\\n        for v in a.iter_mut() {\\n            v.reverse();\\n            for l in v.iter_mut() {\\n                *l ^= 1;\\n            }\\n        }\\n        a\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 930376,
                "title": "java-simplest-in-place-solution-0-ms-faster-than-100",
                "content": "```\\nclass Solution {\\n    // helper function to reverse array in-place:\\n    void rev(int[] A) {\\n        for(int i = 0; i < A.length / 2; i++)\\n        {\\n            int temp = A[i];\\n            A[i] = A[A.length - i - 1];\\n            A[A.length - i - 1] = temp;\\n        }\\n    }\\n    public int[][] flipAndInvertImage(int[][] A) {\\n        for (int i=0; i<A.length; i++) {\\n            rev(A[i]); // reverse the array\\n            for (int j=0; j<A[i].length; j++) { // flip\\n                A[i][j] ^= 0x1;\\n            }\\n        }\\n        return A;\\n    }\\n}\\n```\\n**Like it? please upvote...**",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    // helper function to reverse array in-place:\\n    void rev(int[] A) {\\n        for(int i = 0; i < A.length / 2; i++)\\n        {\\n            int temp = A[i];\\n            A[i] = A[A.length - i - 1];\\n            A[A.length - i - 1] = temp;\\n        }\\n    }\\n    public int[][] flipAndInvertImage(int[][] A) {\\n        for (int i=0; i<A.length; i++) {\\n            rev(A[i]); // reverse the array\\n            for (int j=0; j<A[i].length; j++) { // flip\\n                A[i][j] ^= 0x1;\\n            }\\n        }\\n        return A;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 732337,
                "title": "c-solution-o-n-2",
                "content": "Second Solution\\n```\\nint** flipAndInvertImage(int** A, int ASize, int* AColSize, int* returnSize, int** returnColumnSizes){\\n    *returnSize= ASize;\\n    *returnColumnSizes = AColSize;\\n    float col = *AColSize;\\n    col/=2;\\n    for(int i=0, tmp;i<ASize;i++)\\n        for(int j=0;j<col;j++){\\n            tmp = A[i][(*AColSize-1)-j];\\n            A[i][(*AColSize-1)-j] = !A[i][j];\\n            A[i][j] = !tmp;\\n        }\\n    return A;\\n}\\n\\n\\n\\n```\\n\\nFirst Solution\\n\\n```\\nint** flipAndInvertImage(int** A, int ASize, int* AColSize, int* returnSize, int** returnColumnSizes){\\n    int **flipped = (int**)malloc(sizeof(int*)*(*returnSize= ASize));\\n    for(int i=0;i<ASize;i++){\\n        flipped[i] = malloc(sizeof(int)*(*(*returnColumnSizes = AColSize)));\\n        for(int j=0;j<*AColSize;j++)\\n            flipped[i][(*AColSize-1)-j] = !A[i][j];}\\n    return flipped;\\n}",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint** flipAndInvertImage(int** A, int ASize, int* AColSize, int* returnSize, int** returnColumnSizes){\\n    *returnSize= ASize;\\n    *returnColumnSizes = AColSize;\\n    float col = *AColSize;\\n    col/=2;\\n    for(int i=0, tmp;i<ASize;i++)\\n        for(int j=0;j<col;j++){\\n            tmp = A[i][(*AColSize-1)-j];\\n            A[i][(*AColSize-1)-j] = !A[i][j];\\n            A[i][j] = !tmp;\\n        }\\n    return A;\\n}\\n\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 507244,
                "title": "rust-1-line",
                "content": "```rust\\nimpl Solution {\\n    pub fn flip_and_invert_image(a: Vec<Vec<i32>>) -> Vec<Vec<i32>> {\\n        a.into_iter().map(|r| r.into_iter().map(|x| x ^ 1).rev().collect::<Vec<i32>>()).collect()\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```rust\\nimpl Solution {\\n    pub fn flip_and_invert_image(a: Vec<Vec<i32>>) -> Vec<Vec<i32>> {\\n        a.into_iter().map(|r| r.into_iter().map(|x| x ^ 1).rev().collect::<Vec<i32>>()).collect()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 426759,
                "title": "python-1-liner-clean-and-easy-to-understand",
                "content": "```python\\ndef flipAndInvertImage(A: List[List[int]]) -> List[List[int]]:\\n      return [list(map(lambda x:1-x, reversed(l))) for l in A]\\n```",
                "solutionTags": [],
                "code": "```python\\ndef flipAndInvertImage(A: List[List[int]]) -> List[List[int]]:\\n      return [list(map(lambda x:1-x, reversed(l))) for l in A]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 367770,
                "title": "don-t-overthink-just-follow-the-description-8ms-clear-and-simple-5-lines",
                "content": "```\\nvector<vector<int>> flipAndInvertImage(vector<vector<int>>& A) {\\n        for (int i = 0; i < A.size(); i++) {\\n            std::reverse(A[i].begin(), A[i].end()); // reverse each row\\n            for (int j = 0; j < A[i].size(); j++) {\\n                A[i][j] = A[i][j]^1; // flip the image\\n            }\\n        }\\n        return A; // return the image\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nvector<vector<int>> flipAndInvertImage(vector<vector<int>>& A) {\\n        for (int i = 0; i < A.size(); i++) {\\n            std::reverse(A[i].begin(), A[i].end()); // reverse each row\\n            for (int j = 0; j < A[i].size(); j++) {\\n                A[i][j] = A[i][j]^1; // flip the image\\n            }\\n        }\\n        return A; // return the image\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 287088,
                "title": "simple-solang-solution",
                "content": "```\\nfunc flipAndInvertImage(A [][]int) [][]int {\\n    m := len(A)\\n\\tn := len(A[0])\\n\\t\\n\\tfor row:=0;row<m;row++{\\n\\t\\ti:=0\\n\\t\\tj:= n-1\\n\\t\\tfor  ; i<=j ;{\\n            A[row][i],A[row][j] = 1-A[row][j], 1-A[row][i]\\n\\t\\t\\ti++\\n\\t\\t\\tj--\\n\\t\\t}\\n\\t}\\n\\t\\n\\treturn A\\n    \\n}",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc flipAndInvertImage(A [][]int) [][]int {\\n    m := len(A)\\n\\tn := len(A[0])\\n\\t\\n\\tfor row:=0;row<m;row++{\\n\\t\\ti:=0\\n\\t\\tj:= n-1\\n\\t\\tfor  ; i<=j ;{\\n            A[row][i],A[row][j] = 1-A[row][j], 1-A[row][i]\\n\\t\\t\\ti++\\n\\t\\t\\tj--\\n\\t\\t}\\n\\t}\\n\\t\\n\\treturn A\\n    \\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 241858,
                "title": "python-100-faster-1-line",
                "content": "```class Solution:\\n    def flipAndInvertImage(self, A: \\'List[List[int]]\\') -> \\'List[List[int]]\\':\\n        return [[1-j for j in i[::-1]] for i in A]",
                "solutionTags": [],
                "code": "```class Solution:\\n    def flipAndInvertImage(self, A: \\'List[List[int]]\\') -> \\'List[List[int]]\\':\\n        return [[1-j for j in i[::-1]] for i in A]",
                "codeTag": "Java"
            },
            {
                "id": 131721,
                "title": "kt-js-py3-cpp-1-liners",
                "content": "**Synopsis:**\\n\\nFlip each value `x` of each reversed `row` of the input array `A`.\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun flipAndInvertImage(A: Array<IntArray>): Array<IntArray> {\\n        return A.map{ row -> row.reversed().map{ x -> x xor 1 }.toIntArray() }.toTypedArray()\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet flipAndInvertImage = A => A.map(row => row.reverse().map(x => x ^ 1));\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def flipAndInvertImage(self, A: List[List[int]]) -> List[List[int]]:\\n        return [[x ^ 1 for x in reversed(row)] for row in A]\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    VVI flipAndInvertImage(VVI& A) {\\n        for (auto& row: A) {\\n            reverse(row.begin(), row.end());\\n            transform(row.begin(), row.end(), row.begin(), [&](auto x) { return x ^ 1; });\\n        }\\n        return A;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun flipAndInvertImage(A: Array<IntArray>): Array<IntArray> {\\n        return A.map{ row -> row.reversed().map{ x -> x xor 1 }.toIntArray() }.toTypedArray()\\n    }\\n}\\n```\n```\\nlet flipAndInvertImage = A => A.map(row => row.reverse().map(x => x ^ 1));\\n```\n```\\nclass Solution:\\n    def flipAndInvertImage(self, A: List[List[int]]) -> List[List[int]]:\\n        return [[x ^ 1 for x in reversed(row)] for row in A]\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    VVI flipAndInvertImage(VVI& A) {\\n        for (auto& row: A) {\\n            reverse(row.begin(), row.end());\\n            transform(row.begin(), row.end(), row.begin(), [&](auto x) { return x ^ 1; });\\n        }\\n        return A;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4100114,
                "title": "0-ms-solution-beats-100-java-users-simple-solution-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] flipAndInvertImage(int[][] image) {\\n        for(int i=0;i<image.length;i++){\\n            int s=0,e=image.length-1;\\n            while(s<=e){\\n                int t=(image[i][s]+1)%2;\\n                image[i][s]=(image[i][e]+1)%2;\\n                image[i][e]=t;\\n                s++;\\n                e--;\\n            }\\n        }\\n        return image;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] flipAndInvertImage(int[][] image) {\\n        for(int i=0;i<image.length;i++){\\n            int s=0,e=image.length-1;\\n            while(s<=e){\\n                int t=(image[i][s]+1)%2;\\n                image[i][s]=(image[i][e]+1)%2;\\n                image[i][e]=t;\\n                s++;\\n                e--;\\n            }\\n        }\\n        return image;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3948567,
                "title": "java-code-beginners-verithanam",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] flipAndInvertImage(int[][] image) {\\n        int [][] res=new int[image.length][image[0].length];\\n        for(int i=0;i<image.length;i++){\\n            int n=image.length;\\n            int idx=0;\\n            for(int j=n-1;j>=0;--j){\\n                res[i][idx++]=image[i][j];\\n            }\\n\\n        }\\n        for(int i=0;i<res.length;i++){\\n            for(int j=0;j<res[0].length;j++){\\n                if(res[i][j]==0)\\n                res[i][j]=1;\\n                else\\n                res[i][j]=0;\\n\\n            }\\n\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] flipAndInvertImage(int[][] image) {\\n        int [][] res=new int[image.length][image[0].length];\\n        for(int i=0;i<image.length;i++){\\n            int n=image.length;\\n            int idx=0;\\n            for(int j=n-1;j>=0;--j){\\n                res[i][idx++]=image[i][j];\\n            }\\n\\n        }\\n        for(int i=0;i<res.length;i++){\\n            for(int j=0;j<res[0].length;j++){\\n                if(res[i][j]==0)\\n                res[i][j]=1;\\n                else\\n                res[i][j]=0;\\n\\n            }\\n\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3835760,
                "title": "two-pointers-and-bit-manip",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nthis is classic tp\\nbut i had used that rule:\\n0^1=1\\n1^1=0\\n^ is xsor\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def flipAndInvertImage(self, image: List[List[int]]) -> List[List[int]]:\\n        for row in image:\\n            l, r = 0, len(row) - 1\\n            while l <= r:\\n                row[l], row[r] = row[r]^1, row[l]^1\\n                r -= 1\\n                l += 1\\n        return image\\n```",
                "solutionTags": [
                    "Python3",
                    "Two Pointers",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def flipAndInvertImage(self, image: List[List[int]]) -> List[List[int]]:\\n        for row in image:\\n            l, r = 0, len(row) - 1\\n            while l <= r:\\n                row[l], row[r] = row[r]^1, row[l]^1\\n                r -= 1\\n                l += 1\\n        return image\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3824997,
                "title": "fully-explained-c-code-beats-100-in-time-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n- The given code uses a straightforward approach to flip and invert a 2D binary image. Let\\'s break down the steps of the approach:\\n\\n# Complexity\\n- Time complexity:\\n$$O(n^2)$$\\n\\n- Space complexity:\\n$$O(n)$$ \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    // Helper function to reverse an array\\n    void reverseArr(int arr[], int n){\\n        int start = 0;\\n        int end = n-1;\\n        while(start < end){\\n            swap(arr[start], arr[end]);\\n            start++;\\n            end--;\\n        }\\n    }\\n\\n    // Main function to flip and invert the input image\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        int n = image.size(); // Get the number of rows in the image\\n        int arr[image.size()]; // Create an integer array \\'arr\\' of the same size as the number of rows in the image\\n\\n        for(int i = 0; i < n; i++){ // Iterate through each row of the image\\n\\n            for(int j = 0; j < n; j++){ // Iterate through each element of the current row\\n\\n                // Invert the value of each element in the current row\\n                if(image[i][j] == 1)\\n                    arr[j] = 0; // If the element is 1, set arr[j] to 0 (invert 1 to 0)\\n                else\\n                    arr[j] = 1; // If the element is 0, set arr[j] to 1 (invert 0 to 1)\\n            }\\n\\n            reverseArr(arr, n); // Reverse the \\'arr\\' array using the helper function\\n\\n            for(int j = 0; j < n; j++){\\n                image[i][j] = arr[j]; // Copy the reversed and inverted values back to the image row\\n            }\\n        }\\n\\n        return image; // Return the modified image after flipping and inverting each row\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    // Helper function to reverse an array\\n    void reverseArr(int arr[], int n){\\n        int start = 0;\\n        int end = n-1;\\n        while(start < end){\\n            swap(arr[start], arr[end]);\\n            start++;\\n            end--;\\n        }\\n    }\\n\\n    // Main function to flip and invert the input image\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        int n = image.size(); // Get the number of rows in the image\\n        int arr[image.size()]; // Create an integer array \\'arr\\' of the same size as the number of rows in the image\\n\\n        for(int i = 0; i < n; i++){ // Iterate through each row of the image\\n\\n            for(int j = 0; j < n; j++){ // Iterate through each element of the current row\\n\\n                // Invert the value of each element in the current row\\n                if(image[i][j] == 1)\\n                    arr[j] = 0; // If the element is 1, set arr[j] to 0 (invert 1 to 0)\\n                else\\n                    arr[j] = 1; // If the element is 0, set arr[j] to 1 (invert 0 to 1)\\n            }\\n\\n            reverseArr(arr, n); // Reverse the \\'arr\\' array using the helper function\\n\\n            for(int j = 0; j < n; j++){\\n                image[i][j] = arr[j]; // Copy the reversed and inverted values back to the image row\\n            }\\n        }\\n\\n        return image; // Return the modified image after flipping and inverting each row\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3709042,
                "title": "100-easy-java-solution",
                "content": "# Intuition\\n![5kej8w.jpg](https://assets.leetcode.com/users/images/302aa7c7-ed02-427c-8d85-9a3a4079042b_1688310427.8130434.jpeg)\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] flipAndInvertImage(int[][] image) {\\n        for(int [] row:image){\\n            //Reverse this array\\n            for(int i=0;i<(image[0].length +1)/2;i++)\\n            { //swap\\n             int temp=row[i] ^1;\\n             row[i]=row[image[0].length-i-1] ^ 1;\\n             row[image[0].length-i-1]=temp;\\n             \\n\\n            }\\n        \\n     }\\n     return image;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] flipAndInvertImage(int[][] image) {\\n        for(int [] row:image){\\n            //Reverse this array\\n            for(int i=0;i<(image[0].length +1)/2;i++)\\n            { //swap\\n             int temp=row[i] ^1;\\n             row[i]=row[image[0].length-i-1] ^ 1;\\n             row[image[0].length-i-1]=temp;\\n             \\n\\n            }\\n        \\n     }\\n     return image;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3629365,
                "title": "pythone-one-line-solution-beats-84-99",
                "content": "# Code\\n```\\nclass Solution:\\n    def flipAndInvertImage(self, image: List[List[int]]) -> List[List[int]]:\\n        return [[1 if element == 0 else 0 for element in item[::-1] ] for item in image]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def flipAndInvertImage(self, image: List[List[int]]) -> List[List[int]]:\\n        return [[1 if element == 0 else 0 for element in item[::-1] ] for item in image]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3586877,
                "title": "easiest-c-sol",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        int n=image.size();\\n        int m=image[0].size();\\n        for(int i=0;i<n;i++)\\n        {\\n            reverse(image[i].begin(),image[i].end());\\n        }\\n        for(int i=0;i<image.size();i++)\\n        {\\n            for(int j=0;j<m;j++)\\n                image[i][j]^=1;\\n        }\\n\\n\\n        return image;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        int n=image.size();\\n        int m=image[0].size();\\n        for(int i=0;i<n;i++)\\n        {\\n            reverse(image[i].begin(),image[i].end());\\n        }\\n        for(int i=0;i<image.size();i++)\\n        {\\n            for(int j=0;j<m;j++)\\n                image[i][j]^=1;\\n        }\\n\\n\\n        return image;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3529520,
                "title": "easy-solution",
                "content": "\\n# Complexity\\n- Time complexity: O(N^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] flipAndInvertImage(int[][] image) {\\n\\n        int[][] res=new int[image.length][image.length];\\n        for(int i=0;i<image.length;i++){\\n\\n            for(int j=0;j<image[i].length;j++){\\n                if(image[i][j] ==1){\\n                    res[i][image.length-j-1]=0;\\n                } else{\\n                    res[i][image.length-j-1]=1;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] flipAndInvertImage(int[][] image) {\\n\\n        int[][] res=new int[image.length][image.length];\\n        for(int i=0;i<image.length;i++){\\n\\n            for(int j=0;j<image[i].length;j++){\\n                if(image[i][j] ==1){\\n                    res[i][image.length-j-1]=0;\\n                } else{\\n                    res[i][image.length-j-1]=1;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3484882,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\nprivate:\\n    void reverse(vector<int> &arr) {\\n        int mid = arr.size() / 2;\\n        for (int i = 0; i < mid; i++)\\n            swap(arr[i], arr[arr.size()-1-i]);\\n    }\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        for (auto &row: image) {\\n            reverse(row);\\n            for (auto &val: row)\\n                val = val == 1 ? 0 : 1;\\n        }\\n        return image;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def flipAndInvertImage(self, image: List[List[int]]) -> List[List[int]]:\\n        for inst in image:\\n            start = 0\\n            end = len(inst) - 1\\n            while start <= end:\\n                inst[start], inst[end] = inst[end], inst[start]\\n                if inst[start] == 1:\\n                    inst[start] = 0\\n                else:\\n                    inst[start] = 1\\n                if start != end:\\n                    if inst[end] == 1:\\n                        inst[end] = 0\\n                    else:\\n                        inst[end] = 1\\n                start += 1\\n                end -= 1\\n        return image\\n```\\n\\n```Java []\\nclass Solution {\\n    public int[][] flipAndInvertImage(int[][] image) {\\n        int [][] a = new int[image.length][image[0].length];\\n        for(int i =0;i<image.length;i++){\\n            for(int j =0;j<image[i].length;j++){\\n               if(image[i][image[i].length-1-j] == 1){\\n                   a[i][j] = 0;\\n               } else {\\n                 a[i][j] = 1;   \\n               }\\n            }\\n        }        \\n        return a;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\nprivate:\\n    void reverse(vector<int> &arr) {\\n        int mid = arr.size() / 2;\\n        for (int i = 0; i < mid; i++)\\n            swap(arr[i], arr[arr.size()-1-i]);\\n    }\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        for (auto &row: image) {\\n            reverse(row);\\n            for (auto &val: row)\\n                val = val == 1 ? 0 : 1;\\n        }\\n        return image;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def flipAndInvertImage(self, image: List[List[int]]) -> List[List[int]]:\\n        for inst in image:\\n            start = 0\\n            end = len(inst) - 1\\n            while start <= end:\\n                inst[start], inst[end] = inst[end], inst[start]\\n                if inst[start] == 1:\\n                    inst[start] = 0\\n                else:\\n                    inst[start] = 1\\n                if start != end:\\n                    if inst[end] == 1:\\n                        inst[end] = 0\\n                    else:\\n                        inst[end] = 1\\n                start += 1\\n                end -= 1\\n        return image\\n```\n```Java []\\nclass Solution {\\n    public int[][] flipAndInvertImage(int[][] image) {\\n        int [][] a = new int[image.length][image[0].length];\\n        for(int i =0;i<image.length;i++){\\n            for(int j =0;j<image[i].length;j++){\\n               if(image[i][image[i].length-1-j] == 1){\\n                   a[i][j] = 0;\\n               } else {\\n                 a[i][j] = 1;   \\n               }\\n            }\\n        }        \\n        return a;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3477465,
                "title": "easy-multiple-user-defined-java-solution-beats-100-explained",
                "content": "# Approach\\n- To create two user defined functions that take individual arrays and return the reversed as well as flipped bits array.\\n- Loop through each array in the array of array and pass it to both reverse as well as flip functions.\\n- Each of these functions take O(n) time given there are n elements in each array of the given array of arrays.\\n- and repeating this for m number of arrays id O(m).\\n\\n\\n# Complexity\\n- Time complexity: O(m*n)\\n\\n- Space complexity:O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] flipAndInvertImage(int[][] image) {\\n        for(int i = 0;i<image.length;i++){\\n\\n            // calling the user defined function reverse for reversal of the array\\n\\n            image[i] = reverse(image[i]);\\n\\n            // calling the user define dfunction to flip the bits in the array\\n\\n            image[i] = flip(image[i]);\\n        }\\n\\n        // returns the original array of arrays as we make changes in it\\n\\n        return image;\\n    }\\n\\n    // reverse the elements of the array\\n\\n    // for elements arranged as ---> [0][1][2][3][4]\\n                    // [0] <---> [4]\\n                    // [1] <---> [3]\\n                    // [2] <---> [2]\\n\\n    public int[] reverse(int[] arr){\\n        int ind = arr.length - 1;\\n        for(int i = 0;i<arr.length;i++){\\n            if(ind >= i){    \\n                int temp = arr[i];\\n                arr[i] = arr[ind];\\n                arr[ind] = temp;\\n                ind--;\\n            }\\n        }\\n        return arr;\\n    }\\n\\n    // flip the bits of the array\\n\\n    // for elements arranged as ---> [0][0][1][0][1]\\n            // new array ---> [1][1][0][1][0]\\n\\n    public int[] flip(int[] arr){\\n        for(int i = 0;i<arr.length;i++){\\n            if(arr[i] == 0){\\n                arr[i] = 1;\\n            }else{\\n                arr[i] = 0;\\n            }\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] flipAndInvertImage(int[][] image) {\\n        for(int i = 0;i<image.length;i++){\\n\\n            // calling the user defined function reverse for reversal of the array\\n\\n            image[i] = reverse(image[i]);\\n\\n            // calling the user define dfunction to flip the bits in the array\\n\\n            image[i] = flip(image[i]);\\n        }\\n\\n        // returns the original array of arrays as we make changes in it\\n\\n        return image;\\n    }\\n\\n    // reverse the elements of the array\\n\\n    // for elements arranged as ---> [0][1][2][3][4]\\n                    // [0] <---> [4]\\n                    // [1] <---> [3]\\n                    // [2] <---> [2]\\n\\n    public int[] reverse(int[] arr){\\n        int ind = arr.length - 1;\\n        for(int i = 0;i<arr.length;i++){\\n            if(ind >= i){    \\n                int temp = arr[i];\\n                arr[i] = arr[ind];\\n                arr[ind] = temp;\\n                ind--;\\n            }\\n        }\\n        return arr;\\n    }\\n\\n    // flip the bits of the array\\n\\n    // for elements arranged as ---> [0][0][1][0][1]\\n            // new array ---> [1][1][0][1][0]\\n\\n    public int[] flip(int[] arr){\\n        for(int i = 0;i<arr.length;i++){\\n            if(arr[i] == 0){\\n                arr[i] = 1;\\n            }else{\\n                arr[i] = 0;\\n            }\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3362083,
                "title": "c-easy-solution",
                "content": "\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n * n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n * n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        int n = image.size();\\n        vector<vector<int>> ans = image;\\n\\n        for(int i=0;i<n;i++) {\\n            reverse(ans[i].begin(), ans[i].end());\\n            for(int j=0;j<n;j++) {\\n                ans[i][j] = !ans[i][j];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        int n = image.size();\\n        vector<vector<int>> ans = image;\\n\\n        for(int i=0;i<n;i++) {\\n            reverse(ans[i].begin(), ans[i].end());\\n            for(int j=0;j<n;j++) {\\n                ans[i][j] = !ans[i][j];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3356593,
                "title": "python-solution-flipping-an-image",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1.Reverse each row\\n2.invert each bits\\nFirst for loop is use to reverse each row and then second for loop is use to invert the bits.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n![image.png](https://assets.leetcode.com/users/images/f597ed5f-3107-43ba-ab8a-8fe40ddf5649_1680111960.2864885.png)\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def flipAndInvertImage(self, image: List[List[int]]) -> List[List[int]]:\\n        for i in range(len(image)):\\n            image[i]=image[i][::-1]\\n        for i in range(len(image)):\\n            for j in range(len(image[i])):\\n                image[i][j]^=1\\n                \\n        return image\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def flipAndInvertImage(self, image: List[List[int]]) -> List[List[int]]:\\n        for i in range(len(image)):\\n            image[i]=image[i][::-1]\\n        for i in range(len(image)):\\n            for j in range(len(image[i])):\\n                image[i][j]^=1\\n                \\n        return image\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3347522,
                "title": "understandable-naive-approach-for-beginners-best-solution-1ms",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] flipAndInvertImage(int[][] image) {\\n        int row = image.length;\\n        int col = image[0].length;\\n        int[][] res = new int[row][col];\\n        for (int i = 0; i < row; i++) {\\n            for (int j = 0; j < col; j++) {\\n                res[i][j] = image[i][col-j-1];\\n            }\\n        }\\n        for (int i = 0; i < row; i++) {\\n            for (int j = 0; j < col; j++) {\\n                res[i][j] = res[i][j] == 1 ? 0 : 1; \\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] flipAndInvertImage(int[][] image) {\\n        int row = image.length;\\n        int col = image[0].length;\\n        int[][] res = new int[row][col];\\n        for (int i = 0; i < row; i++) {\\n            for (int j = 0; j < col; j++) {\\n                res[i][j] = image[i][col-j-1];\\n            }\\n        }\\n        for (int i = 0; i < row; i++) {\\n            for (int j = 0; j < col; j++) {\\n                res[i][j] = res[i][j] == 1 ? 0 : 1; \\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3334894,
                "title": "flipping-an-image-c-easy-approach-fast-simple",
                "content": "**IF YOU LIKE, PLEASE UPVOTE.**\\n\\n# Complexity\\n- Time complexity: O(n*n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) \\n    {\\n        for(int i = 0; i<image.size(); i++)\\n        {\\n            reverse(image[i].begin(),image[i].end());\\n            for(int j = 0; j<image[i].size(); j++)\\n            {\\n                image[i][j] = !image[i][j];\\n            }\\n        }\\n        return image;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) \\n    {\\n        for(int i = 0; i<image.size(); i++)\\n        {\\n            reverse(image[i].begin(),image[i].end());\\n            for(int j = 0; j<image[i].size(); j++)\\n            {\\n                image[i][j] = !image[i][j];\\n            }\\n        }\\n        return image;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3287497,
                "title": "easy-c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        int n=image.size();\\n        vector<vector<int>>ans(n);\\n        for (int i=0;i<n;i++)\\n        {\\n            for (int j=image[i].size()-1;j>=0;j--)\\n            {\\n                int cur=1-image[i][j];\\n                ans[i].push_back(cur);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        int n=image.size();\\n        vector<vector<int>>ans(n);\\n        for (int i=0;i<n;i++)\\n        {\\n            for (int j=image[i].size()-1;j>=0;j--)\\n            {\\n                int cur=1-image[i][j];\\n                ans[i].push_back(cur);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3152702,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        \\n        vector<vector<int>> ans;\\n        int n=image.size();\\n        int m=image[0].size();\\n        for(int i=0;i<n;i++)\\n        {\\n            vector<int> v;\\n            for(int j=m-1;j>=0;j--)\\n            {\\n                if(image[i][j]==1)\\n                {\\n                v.push_back(0);\\n                }\\n                else if(image[i][j]==0)\\n                {\\n                v.push_back(1);\\n                }\\n            }\\n            ans.push_back(v);\\n        }\\n        return ans;\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        \\n        vector<vector<int>> ans;\\n        int n=image.size();\\n        int m=image[0].size();\\n        for(int i=0;i<n;i++)\\n        {\\n            vector<int> v;\\n            for(int j=m-1;j>=0;j--)\\n            {\\n                if(image[i][j]==1)\\n                {\\n                v.push_back(0);\\n                }\\n                else if(image[i][j]==0)\\n                {\\n                v.push_back(1);\\n                }\\n            }\\n            ans.push_back(v);\\n        }\\n        return ans;\\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3128156,
                "title": "c-easy-approach-97-faster-easy-to-understand",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\nO(n2)\\n\\nPlease upvote if you found it helpful!\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        vector<vector<int>> ans;\\n        int n=image.size()-1;\\n        for(int i=0;i<=n;i++){\\n            vector<int> row;\\n            for(int j=n;j>=0;j--){\\n                int digit=!image[i][j];\\n                row.push_back(digit);\\n            }\\n            ans.push_back(row);\\n        }return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        vector<vector<int>> ans;\\n        int n=image.size()-1;\\n        for(int i=0;i<=n;i++){\\n            vector<int> row;\\n            for(int j=n;j>=0;j--){\\n                int digit=!image[i][j];\\n                row.push_back(digit);\\n            }\\n            ans.push_back(row);\\n        }return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3068874,
                "title": "easy-java-solution-1ms-runtime",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- $$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] flipAndInvertImage(int[][] image) {\\n        int n = image.length;\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < n/2; j++){\\n                int temp = image[i][j];\\n                image[i][j] = image[i][n - j - 1];\\n                image[i][n - j - 1] = temp;\\n            }\\n        }\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < n; j++){\\n                if(image[i][j] == 1)\\n                    image[i][j] -= 1;\\n                else\\n                    image[i][j] += 1;\\n            }\\n        }\\n        return image;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] flipAndInvertImage(int[][] image) {\\n        int n = image.length;\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < n/2; j++){\\n                int temp = image[i][j];\\n                image[i][j] = image[i][n - j - 1];\\n                image[i][n - j - 1] = temp;\\n            }\\n        }\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < n; j++){\\n                if(image[i][j] == 1)\\n                    image[i][j] -= 1;\\n                else\\n                    image[i][j] += 1;\\n            }\\n        }\\n        return image;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3020903,
                "title": "java-easy-solution-beats-100-runtime-0ms",
                "content": "\\n# Approach\\nBit Manipulation to invert each array element by taking its XOR operation with 1 because when we perform XOR operation with 1 , the digits invert i.e. 1 changes to 0 and 0 changes to 1.\\n\\nAlso, to flip the image horizontally, we use Traversal of array and Swapping technique to flip the image horizontally(i.e column wise)\\n\\nHope this helps!!\\nDo Upvote if you like it.\\n\\nThanks :)\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] flipAndInvertImage(int[][] image) {\\n    \\n        for(int []row: image){\\n            //reverse this array\\n            for(int col=0; col<(image[0].length+1)/2; col++){\\n                //swap to flip the image horizontally and xor each digit(0 or 1) with 1 to invert it at the same time.\\n                int temp = row[col] ^ 1;\\n                row[col] = row[image[0].length - col -1] ^ 1 ;\\n                row[image[0].length - col -1] = temp;\\n       \\n            }  \\n        }\\n        return image;  \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] flipAndInvertImage(int[][] image) {\\n    \\n        for(int []row: image){\\n            //reverse this array\\n            for(int col=0; col<(image[0].length+1)/2; col++){\\n                //swap to flip the image horizontally and xor each digit(0 or 1) with 1 to invert it at the same time.\\n                int temp = row[col] ^ 1;\\n                row[col] = row[image[0].length - col -1] ^ 1 ;\\n                row[image[0].length - col -1] = temp;\\n       \\n            }  \\n        }\\n        return image;  \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2925685,
                "title": "c-easy-to-understand-solution-beat-98",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& img) {\\n       int n=img.size(); \\n       int p;\\n     for(int i=0;i<n;i++)\\n     {\\n         for(int j=0;j<n;j++)\\n         {\\n             if(img[i][j]==0)\\n             img[i][j]=1;\\n\\n             else\\n             img[i][j]=0;\\n         }\\n     }\\n\\n      for(int i=0;i<n;i++)\\n     {    p=n-1;\\n         for(int j=0;j<p;j++)\\n         {\\n             swap(img[i][j],img[i][p]);\\n             p--;\\n\\n         }\\n     }\\nreturn img;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& img) {\\n       int n=img.size(); \\n       int p;\\n     for(int i=0;i<n;i++)\\n     {\\n         for(int j=0;j<n;j++)\\n         {\\n             if(img[i][j]==0)\\n             img[i][j]=1;\\n\\n             else\\n             img[i][j]=0;\\n         }\\n     }\\n\\n      for(int i=0;i<n;i++)\\n     {    p=n-1;\\n         for(int j=0;j<p;j++)\\n         {\\n             swap(img[i][j],img[i][p]);\\n             p--;\\n\\n         }\\n     }\\nreturn img;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2873432,
                "title": "java-simple-solution-1-ms-beats-83-40",
                "content": "```\\nclass Solution {\\n    public int[][] flipAndInvertImage(int[][] image) {\\n        for( int [] row : image){\\n            for(int i=0 ; i < (image[0].length + 1)/2 ;i++){\\n                int temp = row[i] ^ 1;\\n                row[i] = row[image[0].length - i -1] ^ 1;\\n                row[image[0].length - i -1] = temp;\\n            }\\n        }\\n        return image;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[][] flipAndInvertImage(int[][] image) {\\n        for( int [] row : image){\\n            for(int i=0 ; i < (image[0].length + 1)/2 ;i++){\\n                int temp = row[i] ^ 1;\\n                row[i] = row[image[0].length - i -1] ^ 1;\\n                row[image[0].length - i -1] = temp;\\n            }\\n        }\\n        return image;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2793358,
                "title": "2-ways-c-solution-brute-force-two-pointers-o-1-space",
                "content": "Easy C++ Solution:\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        for (auto &row: image){\\n            reverse(row.begin(),row.end());\\n            for (auto &ele : row){\\n                ele= !ele;\\n            }\\n        }\\n        return image;\\n    }\\n};\\n```\\n\\nTwo Pointers Approach :-\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        int n= image[0].size();\\n        for (int r=0; r<image.size(); r++){\\n            int i= 0; int j= n-1;\\n            while (i<=j){\\n                swap(image[r][i],image[r][j]);\\n                int t1= image[r][i]; int t2= image[r][j];\\n                image[r][i]= !t1;\\n                image[r][j]= !t2;\\n                cout<<image[r][i]<<image[r][j]<<\"     \";\\n                i++; j--;\\n            }cout<<endl;\\n        }\\n        return image;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        for (auto &row: image){\\n            reverse(row.begin(),row.end());\\n            for (auto &ele : row){\\n                ele= !ele;\\n            }\\n        }\\n        return image;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        int n= image[0].size();\\n        for (int r=0; r<image.size(); r++){\\n            int i= 0; int j= n-1;\\n            while (i<=j){\\n                swap(image[r][i],image[r][j]);\\n                int t1= image[r][i]; int t2= image[r][j];\\n                image[r][i]= !t1;\\n                image[r][j]= !t2;\\n                cout<<image[r][i]<<image[r][j]<<\"     \";\\n                i++; j--;\\n            }cout<<endl;\\n        }\\n        return image;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2747000,
                "title": "two-pointer-c-solution-o-n-k",
                "content": "```cpp \\nclass Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& Image) {\\n        for (int i = 0; i < Image.size(); i++) { // iterating  the matrix //{ [i==0] ,[i==1]  , [i==3] }\\n            int lo = 0, hi = Image[0].size() - 1; // now in inside the row like for i = 0 [ 0, 1 , 1 ]  -- we have to make this - rev =>110 => then 001\\n            while (lo <= hi) {                                                           // ^      ^\\n                                                                                          //    ^\\n\\n                if (Image[i][lo] == Image[i][hi]) {  // P1-i=0,lo =0,hi=2 is 0==1-no l++,h--| p2 - is 1==1 yes\\n                    Image[i][lo] = 1 - Image[i][lo];//p2 - 1----> 0 chages to 0  // Image[0] = [0 0 1]\\n                    Image[i][hi] = Image[i][lo];  // // inverting the array\\n                }\\n                lo++; //simply increasing and decreasing the pointer\\n                hi--;\\n            }\\n        }\\n\\n        return Image;\\n\\n    }\\n};```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```cpp \\nclass Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& Image) {\\n        for (int i = 0; i < Image.size(); i++) { // iterating  the matrix //{ [i==0] ,[i==1]  , [i==3] }\\n            int lo = 0, hi = Image[0].size() - 1; // now in inside the row like for i = 0 [ 0, 1 , 1 ]  -- we have to make this - rev =>110 => then 001\\n            while (lo <= hi) {                                                           // ^      ^\\n                                                                                          //    ^\\n\\n                if (Image[i][lo] == Image[i][hi]) {  // P1-i=0,lo =0,hi=2 is 0==1-no l++,h--| p2 - is 1==1 yes\\n                    Image[i][lo] = 1 - Image[i][lo];//p2 - 1----> 0 chages to 0  // Image[0] = [0 0 1]\\n                    Image[i][hi] = Image[i][lo];  // // inverting the array\\n                }\\n                lo++; //simply increasing and decreasing the pointer\\n                hi--;\\n            }\\n        }\\n\\n        return Image;\\n\\n    }\\n};```",
                "codeTag": "Java"
            },
            {
                "id": 2683098,
                "title": "java-solution-using-for-loop",
                "content": "class Solution {\\n    public int[][] flipAndInvertImage(int[][] image) {\\n         int[][] result=new int[image.length][image[0].length];\\n        for(int i=0;i<image.length;i++)\\n        {\\n            int k=image[i].length-1;\\n            for(int j=0;j<image[i].length;j++)\\n            {\\n             \\n                \\n                result[i][j]=image[i][k--];\\n             \\n                \\n            }\\n             for(int j=0;j<image[i].length;j++)\\n           {\\n               if(result[i][j]==0)\\n                   result[i][j]=1;\\n               \\n               else\\n                   result[i][j]=0;\\n           }\\n        \\n          \\n        }\\n        return result;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int[][] flipAndInvertImage(int[][] image) {\\n         int[][] result=new int[image.length][image[0].length];\\n        for(int i=0;i<image.length;i++)\\n        {\\n            int k=image[i].length-1;\\n            for(int j=0;j<image[i].length;j++)\\n            {\\n             \\n                \\n                result[i][j]=image[i][k--];\\n             \\n                \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2672265,
                "title": "pretty-simple-java-solution-flip-2-pointers-invert-make-0-to-1-and-vice-versa",
                "content": "```\\nclass Solution {\\n    public int[][] flipAndInvertImage(int[][] image) {\\n        //flip\\n        for(int i=0; i<image.length; i++){\\n            int left=0, right=image.length-1;\\n            while(left<=right){\\n                int temp = image[i][left];\\n                image[i][left] = image[i][right];\\n                image[i][right] = temp;\\n                left++;right--;\\n            }\\n        }\\n        \\n        //invert\\n        for(int i=0; i<image.length; i++){\\n            for(int j=0; j<image.length; j++){\\n                if(image[i][j]==0) image[i][j]=1;\\n                else image[i][j]=0;\\n            }\\n        }\\n        \\n        return image;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] flipAndInvertImage(int[][] image) {\\n        //flip\\n        for(int i=0; i<image.length; i++){\\n            int left=0, right=image.length-1;\\n            while(left<=right){\\n                int temp = image[i][left];\\n                image[i][left] = image[i][right];\\n                image[i][right] = temp;\\n                left++;right--;\\n            }\\n        }\\n        \\n        //invert\\n        for(int i=0; i<image.length; i++){\\n            for(int j=0; j<image.length; j++){\\n                if(image[i][j]==0) image[i][j]=1;\\n                else image[i][j]=0;\\n            }\\n        }\\n        \\n        return image;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2642927,
                "title": "java-easy-explained",
                "content": "# Code\\n```\\nclass Solution {\\n    public int[][] flipAndInvertImage(int[][] image) {\\n        \\n        for(int i=0;i<image.length;i++)\\n        {\\n            // now we can simply reverse the array - flipping the image horizontally\\n            \\n            int start = 0;\\n            int end = image[i].length-1;\\n\\n            while(start<=end)\\n            {\\n                int temp = image[i][start]^1;   // this xor is explained below\\n                image[i][start] = image[i][end]^1;\\n                image[i][end] = temp;\\n\\n                start++;\\n                end--;\\n            }\\n        }\\n\\n        // Now instead of putting up this loop using XOR, in the above loop itself we can incorporate it\\n\\n        // for(int i=0;i<image.length;i++)\\n        // {\\n        //     for(int j=0;j<image[i].length;j++)\\n        //     {\\n        //         image[i][j] = image[i][j]^1;\\n        //         // because we know that n^1 = complement of n\\n        //     }\\n        // }\\n\\n        return image;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] flipAndInvertImage(int[][] image) {\\n        \\n        for(int i=0;i<image.length;i++)\\n        {\\n            // now we can simply reverse the array - flipping the image horizontally\\n            \\n            int start = 0;\\n            int end = image[i].length-1;\\n\\n            while(start<=end)\\n            {\\n                int temp = image[i][start]^1;   // this xor is explained below\\n                image[i][start] = image[i][end]^1;\\n                image[i][end] = temp;\\n\\n                start++;\\n                end--;\\n            }\\n        }\\n\\n        // Now instead of putting up this loop using XOR, in the above loop itself we can incorporate it\\n\\n        // for(int i=0;i<image.length;i++)\\n        // {\\n        //     for(int j=0;j<image[i].length;j++)\\n        //     {\\n        //         image[i][j] = image[i][j]^1;\\n        //         // because we know that n^1 = complement of n\\n        //     }\\n        // }\\n\\n        return image;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2618687,
                "title": "just-flip-and-reverse-c",
                "content": "class Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) \\n    {\\n        vector<vector<int>>ans;\\n        int n=image.size();\\n        int m=image[0].size();\\n        for(int i=0;i<m;i++)\\n        {\\n           vector<int>v;\\n            for(int j=0;j<m;j++)\\n            {\\n                if(image[i][j]==0)\\n                  v.push_back(1);\\n                else\\n                   v.push_back(0);\\n            }\\n            reverse(v.begin(),v.end());\\n            ans.push_back(v);\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) \\n    {\\n        vector<vector<int>>ans;\\n        int n=image.size();\\n        int m=image[0].size();\\n        for(int i=0;i<m;i++)\\n        {\\n           vector<int>v;\\n            for(int j=0;j<m;j++)\\n            {\\n                if(image[i][j]==0)\\n                  v.push_back(1);\\n                else\\n                   v.push_back(0);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2580012,
                "title": "java-solution-brute-force",
                "content": "\\tclass Solution {\\n\\t\\tpublic int[][] flipAndInvertImage(int[][] image) {\\n\\t\\t\\tfor(int i=0;i<image.length;i++){\\n\\t\\t\\t\\tint n=image.length-1;\\n\\t\\t\\t   int s=0;\\n\\n\\t\\t\\t\\twhile(s<n){\\n\\t\\t\\t\\t  int temp=image[i][s];\\n\\t\\t\\t\\t\\timage[i][s]=image[i][n];\\n\\t\\t\\t\\t\\timage[i][n]=temp;\\n\\t\\t\\t\\t\\ts++;\\n\\t\\t\\t\\t\\tn--;\\n\\t\\t\\t\\t}\\n\\n\\n\\t\\t\\t\\t   for(int j =0;j<image[0].length;j++){\\n\\t\\t\\t\\t\\t   if(image[i][j]==0)image[i][j]=1;\\n\\t\\t\\t\\t\\t   else\\n\\t\\t\\t\\t\\t   image[i][j]=0;\\n\\t\\t\\t\\t   }\\n\\t\\t\\t}\\n\\t\\t\\treturn image;\\n\\t\\t}\\n\\t}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\t\\tpublic int[][] flipAndInvertImage(int[][] image) {\\n\\t\\t\\tfor(int i=0;i<image.length;i++){\\n\\t\\t\\t\\tint n=image.length-1;\\n\\t\\t\\t   int s=0;\\n\\n\\t\\t\\t\\twhile(s<n){\\n\\t\\t\\t\\t  int temp=image[i][s];\\n\\t\\t\\t\\t\\timage[i][s]=image[i][n];\\n\\t\\t\\t\\t\\timage[i][n]=temp;\\n\\t\\t\\t\\t\\ts++;\\n\\t\\t\\t\\t\\tn--;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2573890,
                "title": "java-0ms-using-two-pointers",
                "content": "Traverse through each row, and reverse the row values.\\nWhile reversing, change the values from 1 to 0, and 0 to 1.\\n\\n```java\\nclass Solution {\\n    public int[][] flipAndInvertImage(int[][] image) {\\n        \\n        for(int[] row : image){\\n            int l = 0;\\n            int r = row.length - 1;\\n            \\n            while(l <= r) {\\n                int t = row[l] == 1 ? 0 : 1;\\n                row[l] = row[r] == 1 ? 0 : 1;\\n                row[r] = t;\\n                \\n                ++l;\\n                --r;\\n            }\\n        }\\n        \\n        return image;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Matrix"
                ],
                "code": "```java\\nclass Solution {\\n    public int[][] flipAndInvertImage(int[][] image) {\\n        \\n        for(int[] row : image){\\n            int l = 0;\\n            int r = row.length - 1;\\n            \\n            while(l <= r) {\\n                int t = row[l] == 1 ? 0 : 1;\\n                row[l] = row[r] == 1 ? 0 : 1;\\n                row[r] = t;\\n                \\n                ++l;\\n                --r;\\n            }\\n        }\\n        \\n        return image;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2556694,
                "title": "js-simple-solution-o-n-2",
                "content": "```\\nvar flipAndInvertImage = function(image) {\\n    const output = [];\\n    for (let i = 0; i < image.length; i++) {\\n        output[i] = [...image[i]];\\n        for (let j = 0; j < image[i].length; j++) {\\n            output[i][j] = image[i][image[i].length - j - 1] ? 0 : 1;\\n        }\\n    }\\n    return output;\\n};\\n```\\n\\n```\\nvar flipAndInvertImage = function(image) {\\n    for (let i = 0; i < image.length; i++) {\\n        const row = [...image[i]];\\n        for (let j = 0; j < image[i].length; j++) {\\n            image[i][j] = row[image[i].length - j - 1] ? 0 : 1;\\n        }\\n    }\\n    return image;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar flipAndInvertImage = function(image) {\\n    const output = [];\\n    for (let i = 0; i < image.length; i++) {\\n        output[i] = [...image[i]];\\n        for (let j = 0; j < image[i].length; j++) {\\n            output[i][j] = image[i][image[i].length - j - 1] ? 0 : 1;\\n        }\\n    }\\n    return output;\\n};\\n```\n```\\nvar flipAndInvertImage = function(image) {\\n    for (let i = 0; i < image.length; i++) {\\n        const row = [...image[i]];\\n        for (let j = 0; j < image[i].length; j++) {\\n            image[i][j] = row[image[i].length - j - 1] ? 0 : 1;\\n        }\\n    }\\n    return image;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2548722,
                "title": "java-solution-finding-reverse-first-and-then-finding-inverse-and-storing-it-in-o-n-2",
                "content": "```\\npublic int[][] flipAndInvertImage(int[][] image) {\\n\\n        int[][] res = new int[image.length][image[0].length];\\n        for(int i=0; i<image.length; i++){\\n            for(int j=0; j<image[i].length; j++){\\n                int num = image[i][image[i].length-1-j];\\n                System.out.print(num + \" \");\\n                res[i][j] = (num == 1)? 0:1;\\n            }\\n        }\\n        return res;\\n    }\\n```\\n",
                "solutionTags": [],
                "code": "```\\npublic int[][] flipAndInvertImage(int[][] image) {\\n\\n        int[][] res = new int[image.length][image[0].length];\\n        for(int i=0; i<image.length; i++){\\n            for(int j=0; j<image[i].length; j++){\\n                int num = image[i][image[i].length-1-j];\\n                System.out.print(num + \" \");\\n                res[i][j] = (num == 1)? 0:1;\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2528712,
                "title": "1liner-faster-than-60-less-memory-than-98",
                "content": "```\\n/**\\n * @param {number[][]} image\\n * @return {number[][]}\\n */\\nvar flipAndInvertImage = function(image) {\\n    return image.map((x)=>x.reverse().map((y)=>y?0:1))\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Iterator"
                ],
                "code": "```\\n/**\\n * @param {number[][]} image\\n * @return {number[][]}\\n */\\nvar flipAndInvertImage = function(image) {\\n    return image.map((x)=>x.reverse().map((y)=>y?0:1))\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2512279,
                "title": "java-c-solution-using-xor",
                "content": "Please upvote if it helps\\n\\nJava Solution:\\n```\\npublic int[][] flipAndInvertImage(int[][] image) {\\n        int n=image.length,temp;\\n        boolean odd=false;\\n        if(n%2==1){\\n            odd=true;    \\n        }\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n/2;j++){\\n//if different u will get same as input after invert so only checking when both are same \\n                if(image[i][j]==image[i][n-1-j]){   \\n                    image[i][j]^=1;       //changes 0 to 1 nd viseversa\\n                    image[i][n-1-j]^=1;\\n                }\\n            }\\n            if(odd){\\n                image[i][n/2]^=1;   //to invert mid in case of odd cases\\n            }\\n        }\\n        return image;\\n    }\\n```\\nC++ Solution:\\n```\\nvector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        int n=image.size(),temp;\\n        bool odd=false;\\n        if(n%2==1){\\n            odd=true;    \\n        }\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n/2;j++){\\n//if different u will get same as input after invert so only checking when both are same \\n                if(image[i][j]==image[i][n-1-j]){   \\n                    image[i][j]^=1;       //changes 0 to 1 nd viseversa\\n                    image[i][n-1-j]^=1;\\n                }\\n            }\\n            if(odd){\\n                image[i][n/2]^=1;   //to invert mid in case of odd cases\\n            }\\n        }\\n        return image;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\npublic int[][] flipAndInvertImage(int[][] image) {\\n        int n=image.length,temp;\\n        boolean odd=false;\\n        if(n%2==1){\\n            odd=true;    \\n        }\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n/2;j++){\\n//if different u will get same as input after invert so only checking when both are same \\n                if(image[i][j]==image[i][n-1-j]){   \\n                    image[i][j]^=1;       //changes 0 to 1 nd viseversa\\n                    image[i][n-1-j]^=1;\\n                }\\n            }\\n            if(odd){\\n                image[i][n/2]^=1;   //to invert mid in case of odd cases\\n            }\\n        }\\n        return image;\\n    }\\n```\n```\\nvector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        int n=image.size(),temp;\\n        bool odd=false;\\n        if(n%2==1){\\n            odd=true;    \\n        }\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n/2;j++){\\n//if different u will get same as input after invert so only checking when both are same \\n                if(image[i][j]==image[i][n-1-j]){   \\n                    image[i][j]^=1;       //changes 0 to 1 nd viseversa\\n                    image[i][n-1-j]^=1;\\n                }\\n            }\\n            if(odd){\\n                image[i][n/2]^=1;   //to invert mid in case of odd cases\\n            }\\n        }\\n        return image;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2510677,
                "title": "simple-java-code-100-faster",
                "content": "```\\n\\n   class Solution {\\n    public int[][] flipAndInvertImage(int[][] image) {\\n        for(int A[]: image){\\n            swap(A);\\n            flip(A);\\n        }\\n        return image;\\n    }\\n    void swap(int A[]){\\n        int i=0,j=A.length-1;\\n        while(i<=j){\\n            int temp=A[i];\\n            A[i]=A[j];\\n            A[j]=temp;\\n            i++;\\n            j--;\\n        }\\n        \\n    }\\n    void flip(int A[]){\\n        for(int i=0;i<A.length;i++){\\n            if(A[i]==0)A[i]=1;\\n            else A[i]=0;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n\\n   class Solution {\\n    public int[][] flipAndInvertImage(int[][] image) {\\n        for(int A[]: image){\\n            swap(A);\\n            flip(A);\\n        }\\n        return image;\\n    }\\n    void swap(int A[]){\\n        int i=0,j=A.length-1;\\n        while(i<=j){\\n            int temp=A[i];\\n            A[i]=A[j];\\n            A[j]=temp;\\n            i++;\\n            j--;\\n        }\\n        \\n    }\\n    void flip(int A[]){\\n        for(int i=0;i<A.length;i++){\\n            if(A[i]==0)A[i]=1;\\n            else A[i]=0;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2349250,
                "title": "cpp-solution-shortest-code-97-faster-simple-method",
                "content": "class Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        int n = image.size();\\n        float m = image[0].size();\\n        \\n        for(int i=0; i<n; i++){\\n            for(int j=0, k=m-1; j<ceil(m/2) ; j++,k--){\\n                int a = image[i][j], b = image[i][k];\\n                image[i][j] = !b;\\n                image[i][k] = !a;\\n            }\\n        }\\n        return image;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        int n = image.size();\\n        float m = image[0].size();\\n        \\n        for(int i=0; i<n; i++){\\n            for(int j=0, k=m-1; j<ceil(m/2) ; j++,k--){\\n                int a = image[i][j], b = image[i][k];\\n                image[i][j] = !b;\\n                image[i][k] = !a;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2282524,
                "title": "easiest-implementation-pure-stl-fastest-0ms",
                "content": "```\\nvector<vector<int>> flipAndInvertImage(vector<vector<int>>& images) {\\n        \\n        for(int i=0;i<images.size();i++)\\n        {\\n            replace(images[i].begin(),images[i].end(),0,2);\\n            replace(images[i].begin(),images[i].end(),1,0);\\n            replace(images[i].begin(),images[i].end(),2,1);\\n            reverse(images[i].begin(),images[i].end());\\n        }\\n        \\n        return images;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Array",
                    "Matrix"
                ],
                "code": "```\\nvector<vector<int>> flipAndInvertImage(vector<vector<int>>& images) {\\n        \\n        for(int i=0;i<images.size();i++)\\n        {\\n            replace(images[i].begin(),images[i].end(),0,2);\\n            replace(images[i].begin(),images[i].end(),1,0);\\n            replace(images[i].begin(),images[i].end(),2,1);\\n            reverse(images[i].begin(),images[i].end());\\n        }\\n        \\n        return images;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2165079,
                "title": "c-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n      int m=image.size();\\n        int n=image[0].size();\\n        for(int i=0;i<m;i++){\\n            reverse(image[i].begin(),image[i].end());\\n        }\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                image[i][j]^=1;\\n            }\\n        }\\n        return image;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n      int m=image.size();\\n        int n=image[0].size();\\n        for(int i=0;i<m;i++){\\n            reverse(image[i].begin(),image[i].end());\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2153695,
                "title": "c-easiests-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        int m=image.size();\\n        int n =image[0].size();\\n        for(int i=0;i<m;i++){\\n            reverse(image[i].begin(),image[i].end());\\n        }\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                image[i][j]^=1;\\n}\\n    }\\n        return image;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        int m=image.size();\\n        int n =image[0].size();\\n        for(int i=0;i<m;i++){\\n            reverse(image[i].begin(),image[i].end());\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2110936,
                "title": "100-faster-code",
                "content": "class Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& img) {\\n        vector<vector<int>> image=img;\\n        for(int i=0;i<image.size();i++)\\n        {   int l=image[i].size();\\n            int s=0;\\n            int e=l-1;\\n            while(s<=e)\\n            {   \\n                if(s==e)\\n                {\\n                    if(image[i][s]==0)\\n                        image[i][s]=1;\\n                    else\\n                        image[i][s]=0;\\n                    s++;\\n                    e--;\\n                    continue;\\n                }\\n                \\n                int temp=image[i][s];\\n                image[i][s]=image[i][e];\\n                image[i][e]=temp;\\n                \\n                if(image[i][e]==0)\\n                   image[i][e]=1;\\n                else\\n                    image[i][e]=0;\\n                if(image[i][s]==0)\\n                   image[i][s]=1;\\n                else\\n                    image[i][s]=0;\\n                s++;\\n                e--;\\n            }\\n        }\\n        \\n    return image;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "class Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& img) {\\n        vector<vector<int>> image=img;\\n        for(int i=0;i<image.size();i++)\\n        {   int l=image[i].size();\\n            int s=0;\\n            int e=l-1;\\n            while(s<=e)\\n            {   \\n                if(s==e)\\n                {\\n                    if(image[i][s]==0)\\n                        image[i][s]=1;\\n                    else\\n                        image[i][s]=0;\\n                    s++;\\n                    e--;\\n                    continue;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1965869,
                "title": "java-beats-100-00-memory-speed-0ms-april-2022",
                "content": "\\n\\tclass Solution {\\n\\n    public int[][] flipAndInvertImage(int[][] image) {\\n        if (image == null || image.length == 0 || image[0].length == 0) {\\n            return image;\\n        }\\n\\n        for (int[] row : image) {\\n            int start = 0;\\n            int end = row.length - 1;\\n            while (start <= end) {\\n                if (row[start] == row[end]) {\\n                    row[start] ^= 1;\\n                    row[end] = row[start];\\n                }\\n                start++;\\n                end--;\\n            }\\n        }\\n\\n        return image;\\n    }\\n\\t}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\n    public int[][] flipAndInvertImage(int[][] image) {\\n        if (image == null || image.length == 0 || image[0].length == 0) {\\n            return image;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1899750,
                "title": "2-c-solutions-with-detailed-explanation",
                "content": "As the question statement states that we are given an n x n binary matrix image, flip the image horizontally, then invert it, and return the resulting image.\\n\\nThe question itself states and tells us what we need .So we just follow what we need to do:\\n- We will first flip the image horizontally i.e. flip all its rows simply a reverse operation will do this task for each row or we could make our own reversal function using the two pointer approch\\n- Then we need to invert it this can be done in multiple ways like we can use ```image[i][j]=1-image[i][j] ``` or just a simple if else will also do the job ``` if(image[i][j]==0)\\n                    image[i][j]=1;\\n                else \\n                    image[i][j]=0; ```\\n\\t\\t\\t\\t\\tor a ternary operator ``` image[i][j] == 0 ? image[i][j] = 1 : image[i][j] = 0; ```\\n# Solution 1(using a traditional for loop)\\nWe just traverse the 2d matrix and reverse its rows first and than for each row check and reverse its value from 0 to 1 or viceversa.\\n```\\n  for(int i=0;i<image.size();i++){\\n            reverse(image[i].begin(),image[i].end());\\n            for(int j=0;j<image[0].size();j++){\\n                if(image[i][j]==0)\\n                    image[i][j]=1;\\n                else \\n                    image[i][j]=0;\\n            }\\n        }\\n        return image;\\n```\\n# Solution 2 \\nA more cleaner solution using the same concept as mentioned in the above solution.\\n```\\n            for(auto &row:image){\\n\\t\\t\\treverse(row.begin(),row.end());\\n\\t\\t\\tfor(auto &j:row)    j==0?j=1:j=0;   }\\n\\t\\t\\treturn image;\\n```\\n\\nWhen we look at the TC and SC they will be :\\n- TC O(n*n) as it is a n x n binary matrix and we are iterating over the whole matrix every row and its values \\n- SC O(1) as we are not using any extra space we are just performing operations on the matrix itself",
                "solutionTags": [
                    "C"
                ],
                "code": "```image[i][j]=1-image[i][j] ```\n``` if(image[i][j]==0)\\n                    image[i][j]=1;\\n                else \\n                    image[i][j]=0; ```\n``` image[i][j] == 0 ? image[i][j] = 1 : image[i][j] = 0; ```\n```\\n  for(int i=0;i<image.size();i++){\\n            reverse(image[i].begin(),image[i].end());\\n            for(int j=0;j<image[0].size();j++){\\n                if(image[i][j]==0)\\n                    image[i][j]=1;\\n                else \\n                    image[i][j]=0;\\n            }\\n        }\\n        return image;\\n```\n```\\n            for(auto &row:image){\\n\\t\\t\\treverse(row.begin(),row.end());\\n\\t\\t\\tfor(auto &j:row)    j==0?j=1:j=0;   }\\n\\t\\t\\treturn image;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1863127,
                "title": "python-two-pointers-the-most-standard-template-for-two-pointers",
                "content": "I would say: although those 1-liner solutions are fancy, but as a SWE, \\n**the step by step thinking with strict logic is essentially the most significant treasure and is precious.**\\n```\\nclass Solution:\\n    def flipAndInvertImage(self, image: List[List[int]]) -> List[List[int]]:\\n        \\n        def reverse(listt, left, right):\\n            \\n            while left < right:                \\n                listt[left], listt[right] = listt[right], listt[left]\\n                \\n                left += 1\\n                right -= 1\\n        \\n        \\n        # 1. reverse every list in image\\n        for listt in image:\\n            reverse(listt, 0, len(listt) - 1)\\n        \\n        # 2. invert every elements in the matrix\\n        for i in range(len(image)):\\n            for j in range(len(image[0])):\\n                \\n                if image[i][j] == 0:\\n                    image[i][j] = 1\\n                    \\n                elif image[i][j] == 1:\\n                    image[i][j] = 0\\n        \\n        return image\\n```",
                "solutionTags": [
                    "Python",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def flipAndInvertImage(self, image: List[List[int]]) -> List[List[int]]:\\n        \\n        def reverse(listt, left, right):\\n            \\n            while left < right:                \\n                listt[left], listt[right] = listt[right], listt[left]\\n                \\n                left += 1\\n                right -= 1\\n        \\n        \\n        # 1. reverse every list in image\\n        for listt in image:\\n            reverse(listt, 0, len(listt) - 1)\\n        \\n        # 2. invert every elements in the matrix\\n        for i in range(len(image)):\\n            for j in range(len(image[0])):\\n                \\n                if image[i][j] == 0:\\n                    image[i][j] = 1\\n                    \\n                elif image[i][j] == 1:\\n                    image[i][j] = 0\\n        \\n        return image\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1753565,
                "title": "javascript-without-builtin-methods",
                "content": "Do not use builtin methods in such questions because it\\'s obvious they want to test your basic knowledge of how to reverse an array and inverse values in one pass.\\nAlso, always extract helper functions to make the code clearer.\\n```\\nconst reverse = (row) => {\\n    let start = 0;\\n    while (start < row.length / 2) {\\n        let end = row.length - 1 - start;\\n        let tmp = row[start] === 0 ? 1 : 0;\\n        row[start] = row[end] === 0 ? 1 : 0;\\n        row[end] = tmp;\\n        start++;\\n    }\\n}\\n\\nvar flipAndInvertImage = function(image) {\\n    const rows = image.length;\\n    for (let r = 0; r < rows; r++) {\\n        reverse(image[r])\\n    }\\n    \\n    return image;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst reverse = (row) => {\\n    let start = 0;\\n    while (start < row.length / 2) {\\n        let end = row.length - 1 - start;\\n        let tmp = row[start] === 0 ? 1 : 0;\\n        row[start] = row[end] === 0 ? 1 : 0;\\n        row[end] = tmp;\\n        start++;\\n    }\\n}\\n\\nvar flipAndInvertImage = function(image) {\\n    const rows = image.length;\\n    for (let r = 0; r < rows; r++) {\\n        reverse(image[r])\\n    }\\n    \\n    return image;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1663756,
                "title": "javascript-in-memory-two-pointers-clean-code",
                "content": "```\\nvar flipAndInvertImage = function(image) {\\n    for (let i = 0; i < image.length; i++) {\\n        reverse(image[i])\\n        flip(image[i])\\n    }\\n    \\n    function reverse(array) {\\n        let firstIndex = 0\\n        let secondIndex = array.length - 1\\n        while(firstIndex < secondIndex) {\\n            swap(array, firstIndex, secondIndex)\\n            firstIndex++\\n            secondIndex--\\n        }\\n    }\\n    \\n    function flip(array) {\\n        for (let i = 0; i < array.length; i++) {\\n            array[i] = array[i] ^ 1\\n        }\\n    }    \\n    \\n    function swap(array, firstIndex, secondIndex) {\\n        let tmp = array[firstIndex]\\n        array[firstIndex] = array[secondIndex]\\n        array[secondIndex] = tmp\\n    }\\n\\n    return image\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Two Pointers"
                ],
                "code": "```\\nvar flipAndInvertImage = function(image) {\\n    for (let i = 0; i < image.length; i++) {\\n        reverse(image[i])\\n        flip(image[i])\\n    }\\n    \\n    function reverse(array) {\\n        let firstIndex = 0\\n        let secondIndex = array.length - 1\\n        while(firstIndex < secondIndex) {\\n            swap(array, firstIndex, secondIndex)\\n            firstIndex++\\n            secondIndex--\\n        }\\n    }\\n    \\n    function flip(array) {\\n        for (let i = 0; i < array.length; i++) {\\n            array[i] = array[i] ^ 1\\n        }\\n    }    \\n    \\n    function swap(array, firstIndex, secondIndex) {\\n        let tmp = array[firstIndex]\\n        array[firstIndex] = array[secondIndex]\\n        array[secondIndex] = tmp\\n    }\\n\\n    return image\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1636916,
                "title": "java-simple-100-faster",
                "content": "```\\n\\tpublic int[][] flipAndInvertImage(int[][] image) {\\n        \\n        for(int []row : image) {\\n            int i = 0;\\n            int j = row.length-1;\\n            \\n            while(i <= j) {\\n                if(i != j) {\\n                    int t = row[i];\\n                    row[i] = row[j];\\n                    row[j] = t;\\n                    row[i] = 1 - row[i];\\n                    row[j] = 1 - row[j];\\n                } else {\\n                    row[i] = 1 - row[i];   \\n                }\\n                i++;\\n                j--;\\n                \\n            }\\n        }\\n        return image;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\tpublic int[][] flipAndInvertImage(int[][] image) {\\n        \\n        for(int []row : image) {\\n            int i = 0;\\n            int j = row.length-1;\\n            \\n            while(i <= j) {\\n                if(i != j) {\\n                    int t = row[i];\\n                    row[i] = row[j];\\n                    row[j] = t;\\n                    row[i] = 1 - row[i];\\n                    row[j] = 1 - row[j];\\n                } else {\\n                    row[i] = 1 - row[i];   \\n                }\\n                i++;\\n                j--;\\n                \\n            }\\n        }\\n        return image;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1556941,
                "title": "python-very-fast-one-liner-with-nested-list-comprehension-comments",
                "content": "```\\nclass Solution:\\n    def flipAndInvertImage(self, image: List[List[int]]) -> List[List[int]]:\\n\\t\\t# row[::-1] reverts rows/ flips horizontally\\n\\t\\t# 1-i inverts zeros and ones\\n        return [[1-i for i in row[::-1]] for row in image]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def flipAndInvertImage(self, image: List[List[int]]) -> List[List[int]]:\\n\\t\\t# row[::-1] reverts rows/ flips horizontally\\n\\t\\t# 1-i inverts zeros and ones\\n        return [[1-i for i in row[::-1]] for row in image]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1496136,
                "title": "simple-and-easy-to-understand-for-beginners-java-solution-0ms-runtime-38-8mb-memory-usage",
                "content": "0ms runtime. \\n38.8MB memory usage.\\n\\n```\\nclass Solution {\\n    public int[][] flipAndInvertImage(int[][] image) {\\n        for(int i=0; i<image.length; i++){\\n            int start = 0;\\n            int end = image[i].length-1;\\n            while(start<end){\\n                int temp = image[i][start];\\n                image[i][start] = image[i][end];\\n                image[i][end] = temp;\\n                start++;\\n                end--;\\n            }\\n            for(int j=0; j<image[i].length; j++){\\n                if(image[i][j] == 0){\\n                    image[i][j] = 1;\\n                } else {\\n                    image[i][j] = 0;\\n                }\\n            }\\n        }\\n        return image;\\n    }\\n}\\n```\\nPlease upvote if you like the solution.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] flipAndInvertImage(int[][] image) {\\n        for(int i=0; i<image.length; i++){\\n            int start = 0;\\n            int end = image[i].length-1;\\n            while(start<end){\\n                int temp = image[i][start];\\n                image[i][start] = image[i][end];\\n                image[i][end] = temp;\\n                start++;\\n                end--;\\n            }\\n            for(int j=0; j<image[i].length; j++){\\n                if(image[i][j] == 0){\\n                    image[i][j] = 1;\\n                } else {\\n                    image[i][j] = 0;\\n                }\\n            }\\n        }\\n        return image;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1487556,
                "title": "naive-and-optimized-approach-100-java",
                "content": "**# Naive Approach (19ms) & Optimized Solution(0ms) -- Main Concepts covered**\\n\\n***Naive Solution***\\nThe idea is simple we first have to reverse each array and then we change the each element 1-->0 & 0-->1\\n\\nFor reversing the array  we use **2-pointer apparoch**  where we keep a low and high pointer at two ends of the array and start swapping both the pointer till (low<high) and increase the low pointer by 1 (i.e. low+=1) and reduce the high pointer by 1 (i.e. high-=1) \\nNow the swap function without using temporary varibale we have 3 common approaches :\\n1.    `x = x + y;\\n        y = x - y;\\n        x = x - y;`\\n\\t\\t\\n2.    `x = x * y; \\n        y = x / y; \\n        x = x / y; ` \\n\\t\\t**2nd approach cannot be performed as we are dealing with 1 & 0 and we might end up getting                    ArithmeticException**\\n\\t3.  Using ***Bitwise XOR*** operator which simply does the following operation **(1^1=0 , 0^0=0 , 1^0=1 , 0^1=1)**.\\n\\t\\t Eg. Code to swap x=5 i.e. (0101) and y=10 i.e. (1010)\\n\\t\\t\\t`x = x ^ y;`     x now becomes 15 (1111)\\n\\t\\t\\t`y = x ^ y;`     y becomes 5 (0101)\\n\\t\\t\\t`x = x ^ y;`   x becomes 10 (1010)\\n\\t\\t\\nAfter reversing the array we have to flip 1--->0  &  0 --->1, we do that using same bitwise XOR. \\nTo change  1-->0 and 0-->1 most elegant way is to bitwise XOR the number with 1.\\n\\t**0 ^ 1 = 1\\n\\t1 ^ 1 = 0**\\n\\n**Naive Solution :- Time complexity: O(n^3)  Space Complexity: O(n^2)**\\n```\\npublic int[][] flipAndInvertImage(int[][] image) {\\n            for(int i=0;i<image.length;i++){\\n            int low=0;\\n            int high=image[i].length-1;\\n            while(low<high){\\n            swap(image[i][low],image[i][high],image,i,low,high);\\n            low++;\\n            high--;\\n            }\\n            for(int j=0;j<image[i].length;j++){\\n                image[i][j]=image[i][j]^1;\\n            }\\n        }\\n        return image;\\n    }\\n    public static void swap(int a,int b,int image[][],int i,int low,int high){\\n        System.out.println(a+\" \"+b);\\n        a=a+b;\\n        b=a-b;\\n        a=a-b;\\n        image[i][low]=a;\\n        image[i][high]=b;\\n    }\\n```\\n\\n**Optimized Solution Time Complexity : O(n^2) Space Complexity : O(n^2)**\\n\\nHere we again use 2 pointer to check the two ends of the array whether they are same or not. If same we store the XOR at these pointer places and move the pointer respectively as mentioned above.\\n\\n```\\npublic int[][] flipAndInvertImage(int[][] image) {\\n\\t\\tint len=image.length;\\n        for(int i=0;i<len;i++){\\n            for(int j=0;j*2<image[i].length;j++){\\n                if(image[i][j]==image[i][len-j-1]){\\n                    image[i][len-j-1]^=1;\\n                    image[i][j]=image[i][len-j-1];\\n                }\\n            }\\n        }\\n        return image;\\n    }\\n```\\n\\n**Understanding the naive approach helps in breaking the problem into smaller problems which eventually helps in understanding how it can be optimized. of how code work is important\\nUpvote if  it was helpful \\uD83D\\uDC4D.**\\n\\n\\t",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int[][] flipAndInvertImage(int[][] image) {\\n            for(int i=0;i<image.length;i++){\\n            int low=0;\\n            int high=image[i].length-1;\\n            while(low<high){\\n            swap(image[i][low],image[i][high],image,i,low,high);\\n            low++;\\n            high--;\\n            }\\n            for(int j=0;j<image[i].length;j++){\\n                image[i][j]=image[i][j]^1;\\n            }\\n        }\\n        return image;\\n    }\\n    public static void swap(int a,int b,int image[][],int i,int low,int high){\\n        System.out.println(a+\" \"+b);\\n        a=a+b;\\n        b=a-b;\\n        a=a-b;\\n        image[i][low]=a;\\n        image[i][high]=b;\\n    }\\n```\n```\\npublic int[][] flipAndInvertImage(int[][] image) {\\n\\t\\tint len=image.length;\\n        for(int i=0;i<len;i++){\\n            for(int j=0;j*2<image[i].length;j++){\\n                if(image[i][j]==image[i][len-j-1]){\\n                    image[i][len-j-1]^=1;\\n                    image[i][j]=image[i][len-j-1];\\n                }\\n            }\\n        }\\n        return image;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1313425,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        for(int i = 0; i < image.size(); i++) {\\n            reverse(image[i].begin(), image[i].end());\\n            for(int j = 0; j < image[i].size(); j++) image[i][j] ^= 1;\\n        }\\n        return image;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        for(int i = 0; i < image.size(); i++) {\\n            reverse(image[i].begin(), image[i].end());\\n            for(int j = 0; j < image[i].size(); j++) image[i][j] ^= 1;\\n        }\\n        return image;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1313100,
                "title": "python-fast-and-simple-one-liner",
                "content": "Here\\'s the solution:\\n```\\nclass Solution:\\n    def flipAndInvertImage(self, image: List[List[int]]) -> List[List[int]]:\\n        return [[0 if x==1 else 1 for x in row[::-1]] for row in image]\\n```\\nExplanation:\\n`row[::-1]]` - reverses the list\\n`[0 if x==1 else 1 for x in LIST]` - changes zeros to ones and vice versa for the given LIST. You could also use `1-x` or `1^x`, which would give the same result.",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def flipAndInvertImage(self, image: List[List[int]]) -> List[List[int]]:\\n        return [[0 if x==1 else 1 for x in row[::-1]] for row in image]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1287794,
                "title": "python3-96-time-one-liner-with-list-comprehension-explained",
                "content": "First thing is to reverse each item in image with this simple list comprehension:\\n`flipped = [item[::-1] for item in image]` where [::-1] reverse the list\\n\\nThen one can use a short if for each item inside the image with\\n`[0 if n else 1 for n in i]`\\nThis work because n can be only 1 or 0 so it can be use instead of True or False\\n\\nThis list have to be inserted inside another list comprehension who cycle trought all list in image:\\n`inverted = [[0 if n else 1 for n in i] for i in flipped]`\\n\\nThen all this list can be joined togheder in this way:\\n\\n```\\nclass Solution:\\n    def flipAndInvertImage(self, image: List[List[int]]) -> List[List[int]]:\\n        \\n        return [[0 if n else 1 for n in i] for i in [item[::-1] for item in image]]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def flipAndInvertImage(self, image: List[List[int]]) -> List[List[int]]:\\n        \\n        return [[0 if n else 1 for n in i] for i in [item[::-1] for item in image]]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1257679,
                "title": "java-solution-0ms-runtime",
                "content": "```\\nclass Solution {\\n    public int[][] flipAndInvertImage(int[][] image) {\\n        int[][] ar = new int[image.length][image.length];\\n        for(int i=0; i<image.length; i++) {\\n            int[]temp_ar = new int[image.length];\\n            for(int j=image.length-1,k=0; j>=0; j--) {      //flipping and reversing at the same time\\n                if(image[i][j]==0) {\\n                    temp_ar[k] = 1;\\n                }\\n                k++;\\n            }\\n            ar[i] = temp_ar;\\n        }\\n        return ar;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] flipAndInvertImage(int[][] image) {\\n        int[][] ar = new int[image.length][image.length];\\n        for(int i=0; i<image.length; i++) {\\n            int[]temp_ar = new int[image.length];\\n            for(int j=image.length-1,k=0; j>=0; j--) {      //flipping and reversing at the same time\\n                if(image[i][j]==0) {\\n                    temp_ar[k] = 1;\\n                }\\n                k++;\\n            }\\n            ar[i] = temp_ar;\\n        }\\n        return ar;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1060969,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int[][] flipAndInvertImage(int[][] A) {\\n        for(int[] arr:A)\\n        {\\n            int j = 0;\\n            int i = arr.length-1;\\n            while(j<i)\\n            {\\n                int temp = arr[j];\\n                arr[j] = arr[i];\\n                arr[i] = temp;\\n                i--;\\n                j++;\\n            }\\n        }\\n        \\n        for(int[] arr:A)\\n        {\\n            for(int i=0;i<arr.length;i++)\\n            {\\n                if(arr[i]==1)\\n                    arr[i] = 0;\\n                else\\n                    arr[i] = 1;\\n            }\\n        }\\n        return A;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[][] flipAndInvertImage(int[][] A) {\\n        for(int[] arr:A)\\n        {\\n            int j = 0;\\n            int i = arr.length-1;\\n            while(j<i)\\n            {\\n                int temp = arr[j];\\n                arr[j] = arr[i];\\n                arr[i] = temp;\\n                i--;\\n                j++;\\n            }\\n        }\\n        \\n        for(int[] arr:A)\\n        {\\n            for(int i=0;i<arr.length;i++)\\n            {\\n                if(arr[i]==1)\\n                    arr[i] = 0;\\n                else\\n                    arr[i] = 1;\\n            }\\n        }\\n        return A;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 930883,
                "title": "efficient-scala-solution",
                "content": "```scala\\ndef flipAndInvertImage(A: Array[Array[Int]]): Array[Array[Int]] = \\n  A.map(_.view.map(_ ^ 1).reverse.toArray)\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```scala\\ndef flipAndInvertImage(A: Array[Array[Int]]): Array[Array[Int]] = \\n  A.map(_.view.map(_ ^ 1).reverse.toArray)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 930518,
                "title": "python",
                "content": "```\\nclass Solution:\\n    def flipAndInvertImage(self, A: List[List[int]]) -> List[List[int]]:\\n        return [[1-e for e in reversed(row)] for row in A]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def flipAndInvertImage(self, A: List[List[int]]) -> List[List[int]]:\\n        return [[1-e for e in reversed(row)] for row in A]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 835269,
                "title": "c-simple-and-clean",
                "content": "Inverse only if values on both ends of the row are same:\\n\\n```\\npublic class Solution {\\n    public int[][] FlipAndInvertImage(int[][] A) {\\n        foreach(int[] row in A)\\n        {\\n            int i = 0, j = row.Length-1;\\n            while(i <= j)\\n            {\\n                if(row[i] == row[j])\\n                    row[i] = row[j] ^=1;\\n                i++;\\n                j--;\\n            }\\n        }\\n        return A;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int[][] FlipAndInvertImage(int[][] A) {\\n        foreach(int[] row in A)\\n        {\\n            int i = 0, j = row.Length-1;\\n            while(i <= j)\\n            {\\n                if(row[i] == row[j])\\n                    row[i] = row[j] ^=1;\\n                i++;\\n                j--;\\n            }\\n        }\\n        return A;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 650612,
                "title": "java-0ms-faster-than-100-00-of-java-o-m-n-simple-code-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int[][] flipAndInvertImage(int[][] A) {\\n        int[][] result = new int[A.length][A.length];\\n        for (int i = 0; i < A.length; i++) {\\n            int j = 0;\\n            int k = A.length - 1;\\n            while (j < A.length && k >= 0) {\\n                result[i][j] = A[i][k] == 0 ? 1 : 0;\\n                j++;\\n                k--;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[][] flipAndInvertImage(int[][] A) {\\n        int[][] result = new int[A.length][A.length];\\n        for (int i = 0; i < A.length; i++) {\\n            int j = 0;\\n            int k = A.length - 1;\\n            while (j < A.length && k >= 0) {\\n                result[i][j] = A[i][k] == 0 ? 1 : 0;\\n                j++;\\n                k--;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 638219,
                "title": "javascript-one-liners",
                "content": "```\\n// One-Liners\\nconst flipAndInvertImage = A => A.map(arr => arr.reverse().map(num => num === 0 ? 1 : 0));\\n\\n// Faster\\nconst flipAndInvertImage = A => {\\n  for (arr of A) {\\n    let x = Math.round(arr.length / 2)\\n    for (i = 0 ; i < x; i++) {\\n      let y = arr[i] === 0 ? 1 : 0;\\n      arr[i] = arr[arr.length - 1 - i] === 0 ? 1 : 0;\\n      arr[arr.length - 1 - i] = y;\\n    }\\n  }\\n  return A;\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/metha/image_1589774165.png)\\n\\n\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n// One-Liners\\nconst flipAndInvertImage = A => A.map(arr => arr.reverse().map(num => num === 0 ? 1 : 0));\\n\\n// Faster\\nconst flipAndInvertImage = A => {\\n  for (arr of A) {\\n    let x = Math.round(arr.length / 2)\\n    for (i = 0 ; i < x; i++) {\\n      let y = arr[i] === 0 ? 1 : 0;\\n      arr[i] = arr[arr.length - 1 - i] === 0 ? 1 : 0;\\n      arr[arr.length - 1 - i] = y;\\n    }\\n  }\\n  return A;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 568803,
                "title": "python3-solution-beats-99",
                "content": "Notice:\\n1. Reverse the list inside by list[::-1] than traverse it is much faster than traverse the list reversely by using reverse index straightforward in this question\\n2. Bitwise method is faster than decimal computation in most cases\\n\\nCode:\\n\\n```\\nclass Solution:\\n    def flipAndInvertImage(self, A):\\n        ans = []\\n        for item in A:\\n            inside = []\\n            item = item[::-1]\\n            for digit in item:\\n\\t\\t\\t\\t# bitwise method ,equal to inside.append(1 - digit) in this problem\\n                inside.append(digit ^ 1)\\n            ans.append(inside)\\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def flipAndInvertImage(self, A):\\n        ans = []\\n        for item in A:\\n            inside = []\\n            item = item[::-1]\\n            for digit in item:\\n\\t\\t\\t\\t# bitwise method ,equal to inside.append(1 - digit) in this problem\\n                inside.append(digit ^ 1)\\n            ans.append(inside)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 508595,
                "title": "python-oneliner-fast-90-and-easy-to-understand",
                "content": "While it\\'s only a single line of code, logically it can be divided into 3 tasks:\\n\\n1. \" ... for l in A\" - this part reads matrix X line by line\\n2. \" ... for i in l[::-1]\" - this part return numbers in a line in reverse order\\n3. \" ... int (not i) \" - this part swaps 0s and 1s\\n\\nThe [ [ ... ] ... ] structure is used to form a return 2d matrix.\\n\\nThis is pretty much it.\\n\\n```\\nclass Solution(object):\\n    def flipAndInvertImage(self, A):\\n        return [ [ int (not i) for i in l[::-1] ] for l in A ]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def flipAndInvertImage(self, A):\\n        return [ [ int (not i) for i in l[::-1] ] for l in A ]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 448725,
                "title": "python-using-list-comprehensions",
                "content": "```\\nclass Solution:\\n    def flipAndInvertImage(self, A: List[List[int]]) -> List[List[int]]:\\n        rev = [row[::-1] for row in A]\\n        inv = [[int(not x) for x in row] for row in rev]\\n        return inv\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def flipAndInvertImage(self, A: List[List[int]]) -> List[List[int]]:\\n        rev = [row[::-1] for row in A]\\n        inv = [[int(not x) for x in row] for row in rev]\\n        return inv\\n```",
                "codeTag": "Java"
            },
            {
                "id": 425928,
                "title": "simple-and-elegant-java-solution",
                "content": "##### Refresher\\n##### Bitwise Operations\\n* 1 ^ 1 = 0\\n* 0 ^ 1 = 1\\n```java\\n    public int[][] flipAndInvertImage(int[][] A) {\\n        // base case \\n        if(A == null || A[0].length != A.length) return null;\\n        \\n        int len = A.length;\\n        int b = A[0].length;\\n        \\n        // iterate through all the rows\\n        for(int i=0; i<len; i++) {\\n            // iterate only half through the columns as the remainder will undo what \\n\\t\\t\\t// we did and return back the original input with inverted values\\n            for(int j=0; j<b/2; j++) {\\n                int temp = A[i][b-j-1];\\n\\t\\t\\t\\t// apply bitwise operation to invert the values\\n                A[i][b-j-1] = A[i][j] ^ 1;\\n                A[i][j] = temp ^ 1;\\n            }\\n             \\n            // if the matrix is odd in length then we\\'d skip the middle element as per the above logic,\\n\\t\\t\\t// so inverting the value explicitly\\n            if(len%2 == 1) {\\n                A[i][len/2] = A[i][len/2] ^ 1;\\n            }\\n        }\\n        \\n        return A;\\n    }\\n```\\n#### Complexity Analysis\\n* Time Complexity: O(m * n), where m is the no of columns and n is the number of rows\\n* Space Complexity: O(m * n)",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Matrix"
                ],
                "code": "```java\\n    public int[][] flipAndInvertImage(int[][] A) {\\n        // base case \\n        if(A == null || A[0].length != A.length) return null;\\n        \\n        int len = A.length;\\n        int b = A[0].length;\\n        \\n        // iterate through all the rows\\n        for(int i=0; i<len; i++) {\\n            // iterate only half through the columns as the remainder will undo what \\n\\t\\t\\t// we did and return back the original input with inverted values\\n            for(int j=0; j<b/2; j++) {\\n                int temp = A[i][b-j-1];\\n\\t\\t\\t\\t// apply bitwise operation to invert the values\\n                A[i][b-j-1] = A[i][j] ^ 1;\\n                A[i][j] = temp ^ 1;\\n            }\\n             \\n            // if the matrix is odd in length then we\\'d skip the middle element as per the above logic,\\n\\t\\t\\t// so inverting the value explicitly\\n            if(len%2 == 1) {\\n                A[i][len/2] = A[i][len/2] ^ 1;\\n            }\\n        }\\n        \\n        return A;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 424808,
                "title": "very-clean-python-solution",
                "content": "```\\ndef flipAndInvertImage(self, A: List[List[int]]) -> List[List[int]]:\\n\\treturn [[0 if x else 1 for x in reversed(row)] for row in A]\\n```",
                "solutionTags": [],
                "code": "```\\ndef flipAndInvertImage(self, A: List[List[int]]) -> List[List[int]]:\\n\\treturn [[0 if x else 1 for x in reversed(row)] for row in A]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 418184,
                "title": "python-1-line",
                "content": "Merely a good problem to practice list comprehension\\n\\n```\\nreturn [[1-x for x in row[::-1] ] for row in A]\\n```",
                "solutionTags": [],
                "code": "```\\nreturn [[1-x for x in row[::-1] ] for row in A]\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 358992,
                "title": "java-one-pass-beats-100",
                "content": "While we can do it in-place, it will require some extra work for exchanging elements. Actually faster will be to create new matrix directly with correct values. Also usually resulting structure doesn\\'t count as an extra space.\\n\\n```\\n    public int[][] flipAndInvertImage(int[][] A) {\\n        int rows = A.length;\\n        int cols = A[0].length;\\n        \\n        int[][] res = new int[rows][cols];\\n        \\n        for (int r = 0; r < rows; r++) {\\n            for (int c = 0; c < cols; c++ ) {\\n                res[r][cols - 1 - c] = A[r][c] == 1 ? 0 : 1;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    public int[][] flipAndInvertImage(int[][] A) {\\n        int rows = A.length;\\n        int cols = A[0].length;\\n        \\n        int[][] res = new int[rows][cols];\\n        \\n        for (int r = 0; r < rows; r++) {\\n            for (int c = 0; c < cols; c++ ) {\\n                res[r][cols - 1 - c] = A[r][c] == 1 ? 0 : 1;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1566528,
                "content": [
                    {
                        "username": "mirand",
                        "content": "Hello, Why is there this much parameters for C implementation? Isn\\'t the matrix always square, so that the parameter should only be (int** A, int ARowSize) ? Thanks for your help"
                    },
                    {
                        "username": "Anurag8305",
                        "content": "No matrix is not always square. Sometimes you may see matrix of n*m size also."
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "A normal problem of matrix .. Just to keep in mind while inserting elements in the resultant matrix, at first we need to iterate each row of the given matrix in reverse direction..Next step is to change every position value.. i.e. change all 1\\'s to 0\\'s and 0\\'s to 1\\'s.. For more information please have a look at my solution posted in the solution tab --> "
                    },
                    {
                        "username": "leetcode89",
                        "content": "I have no idea why I can\\'t understand this problem and its under easy category.Can some one help me out in understanding?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem essentially has two parts:\\n\\n1. Flip the Image Horizontally: To flip an image horizontally means to reverse the order of elements in each row. For example, if a row in the matrix is [1, 0, 1], flipping this row would result in [1, 0, 1].\\n\\n2. Invert the Image: After flipping each row, you need to invert each element in each row, which simply means changing every 1 to 0 and every 0 to 1. For example, if a flipped row is [1, 0, 1], inverting this row would result in [0, 1, 0].\\n\\nLet\\'s take an example from the problem to understand this better:\\n\\nInput: image = [[1,1,0],[1,0,1],[0,0,0]]\\nOutput: [[1,0,0],[0,1,0],[1,1,1]]\\n\\nHere\\'s what happens step-by-step:\\n\\n- First, each row is reversed:\\n  - [1,1,0] becomes [0,1,1]\\n  - [1,0,1] becomes [1,0,1]\\n  - [0,0,0] becomes [0,0,0]\\n\\n- Then, each element in each row is inverted:\\n  - [0,1,1] becomes [1,0,0]\\n  - [1,0,1] becomes [0,1,0]\\n  - [0,0,0] becomes [1,1,1]\\n\\nSo, the final output is [[1,0,0],[0,1,0],[1,1,1]], which matches the expected output.\\n\\nThe challenge lies in implementing these steps efficiently in code. The task requires understanding of array manipulation and binary number manipulation (since we\\'re just dealing with 0s and 1s)."
                    },
                    {
                        "username": "Anurag8305",
                        "content": "Try using this approach.\\n1. first reverse the row value of each row.\\n2. then replace the 0\\'s with 1\\'s and vice-versa."
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "In simple terms, just consider the given 2D array as a matrix. Now perform 2 operations ->\\nOp 1: Invert each row ( i.e if a row has 101001 then do it as 100101)\\nOp 2 : Flip the bits in each row..i.e. make the 0\\'s in each row as 1 and 1\\'s as 0...."
                    },
                    {
                        "username": "mochiball",
                        "content": "Tip: No need to use extra space. Just perform the operations on the input image and return it "
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "yes\\n"
                    },
                    {
                        "username": "JavithSadhamHussain",
                        "content": "//Flippng of an 1-D array \n`\nfor(int left=0, right=array.length-1; left<=right; left++, right--)\n            {\n                int temp = array[left];\n                array[left] = array[right];\n                array[right] = temp;\n            }`\n\n"
                    },
                    {
                        "username": "sajidali56867",
                        "content": "hello it\\'s my first  comment in discussion  rather than taking a new array for result  , try to change the image row by reversing it "
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "    ```def flipAndInvertImage(self, image: List[List[int]]) -> List[List[int]]:\\n        t1 = [i[::-1] for i in image]\\n        for i in range(len(t1)):\\n            for j in range(len(t1[i])):\\n                if t1[i][j] ==0:\\n                    t1[i][j] = 1\\n                else:\\n                    t1[i][j] = 0\\n        return t1```"
                    },
                    {
                        "username": "AasthaSach29",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        \\n        for(int i=0;i<image.size();i++){\\n            for(int j=0;j<image[i].size()/2;j++){\\n                int t=(image[i].size())-j;\\n                swap(image[i][j],image[i][t]);\\n                if(image[i][j]==0){\\n                    image[i][j]=1;\\n                }\\n                else{\\n                    image[i][j]=0;\\n                }\\n             }\\n            \\n        }\\n        return image;\\n         \\n    }\\n};\\n\\n\\nWhy there is Runtime Error in this code??"
                    },
                    {
                        "username": "quarkyy99",
                        "content": "because of arrayindex out of bounds. when you initatize t.in first iteration t is equal to length of array which is 1 index ahead."
                    },
                    {
                        "username": "20euec070",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        int n=image.size();\\n       // int m=image[0].size();\\n        vector<vector<int>> v;\\n        for(int i=0;i<n;i++){\\n            int k=0;\\n            for(int j=n-1;j>=0;j--){\\n                if(image[i][j]==1){\\n                v[i][k]=0;\\n                k++;}\\n                else{\\n                v[i][k]=1;\\n                k++;}\\n            }\\n        }\\n        return v;\\n        \\n    }\\n};\\n\\n\\nwhat\\'s the mistake in my code?(error int 9th line)"
                    },
                    {
                        "username": "bparanj",
                        "content": "The error in your code is because you are trying to access `v[i][k]` when it has not yet been initialized.\\n\\nThe `vector<vector<int>> v` is currently empty and has no elements. You can\\'t access `v[i][k]` directly without either initializing the size of `v` with the same size as `image` or using the `push_back()` function to add elements.\\n\\nHere\\'s how you can modify your code to fix the error. Notice how we use `push_back` to add elements to `v`:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        int n = image.size();\\n        vector<vector<int>> v;\\n\\n        for(int i = 0; i < n; i++){\\n            vector<int> row;\\n            for(int j = n - 1; j >= 0; j--){\\n                if(image[i][j] == 1){\\n                    row.push_back(0);\\n                } else {\\n                    row.push_back(1);\\n                }\\n            }\\n            v.push_back(row);\\n        }\\n        return v;\\n    }\\n};\\n```\\n\\nThis modified version of your code works as follows: for each row, we create a new empty vector `row`. We populate `row` by iterating over the corresponding row in `image` in reverse order, pushing `0` if the original number was `1`, and `1` otherwise. After we\\'re done with a row, we add it to the `v` vector with `v.push_back(row)`."
                    },
                    {
                        "username": "1rn21is163",
                        "content": "i also have same doubt"
                    },
                    {
                        "username": "himanshubanerji",
                        "content": "If I\\'m coding in c++ can I use stl function for partially solving these questions ? Like use reverse functions to horizontally flip ?? \\n\\nplease help as I\\'m really confused if this is a good practice or not "
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "[@Himanshu Banerji](/himanshubanerji) In general it is recommended to avoid in-built functions .. That will help to build the logic, else if someone is using in-built functions directly then the thinking ability and the logic building skills won't develop."
                    },
                    {
                        "username": "himanshubanerji",
                        "content": "[@Ritabrata_1080](/Ritabrata_1080) Can u tell like in general is is recommended practise while using it or not?\\n"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "Sure you can. But also make sure to check out other solutions without using STL."
                    }
                ]
            },
            {
                "id": 1671031,
                "content": [
                    {
                        "username": "mirand",
                        "content": "Hello, Why is there this much parameters for C implementation? Isn\\'t the matrix always square, so that the parameter should only be (int** A, int ARowSize) ? Thanks for your help"
                    },
                    {
                        "username": "Anurag8305",
                        "content": "No matrix is not always square. Sometimes you may see matrix of n*m size also."
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "A normal problem of matrix .. Just to keep in mind while inserting elements in the resultant matrix, at first we need to iterate each row of the given matrix in reverse direction..Next step is to change every position value.. i.e. change all 1\\'s to 0\\'s and 0\\'s to 1\\'s.. For more information please have a look at my solution posted in the solution tab --> "
                    },
                    {
                        "username": "leetcode89",
                        "content": "I have no idea why I can\\'t understand this problem and its under easy category.Can some one help me out in understanding?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem essentially has two parts:\\n\\n1. Flip the Image Horizontally: To flip an image horizontally means to reverse the order of elements in each row. For example, if a row in the matrix is [1, 0, 1], flipping this row would result in [1, 0, 1].\\n\\n2. Invert the Image: After flipping each row, you need to invert each element in each row, which simply means changing every 1 to 0 and every 0 to 1. For example, if a flipped row is [1, 0, 1], inverting this row would result in [0, 1, 0].\\n\\nLet\\'s take an example from the problem to understand this better:\\n\\nInput: image = [[1,1,0],[1,0,1],[0,0,0]]\\nOutput: [[1,0,0],[0,1,0],[1,1,1]]\\n\\nHere\\'s what happens step-by-step:\\n\\n- First, each row is reversed:\\n  - [1,1,0] becomes [0,1,1]\\n  - [1,0,1] becomes [1,0,1]\\n  - [0,0,0] becomes [0,0,0]\\n\\n- Then, each element in each row is inverted:\\n  - [0,1,1] becomes [1,0,0]\\n  - [1,0,1] becomes [0,1,0]\\n  - [0,0,0] becomes [1,1,1]\\n\\nSo, the final output is [[1,0,0],[0,1,0],[1,1,1]], which matches the expected output.\\n\\nThe challenge lies in implementing these steps efficiently in code. The task requires understanding of array manipulation and binary number manipulation (since we\\'re just dealing with 0s and 1s)."
                    },
                    {
                        "username": "Anurag8305",
                        "content": "Try using this approach.\\n1. first reverse the row value of each row.\\n2. then replace the 0\\'s with 1\\'s and vice-versa."
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "In simple terms, just consider the given 2D array as a matrix. Now perform 2 operations ->\\nOp 1: Invert each row ( i.e if a row has 101001 then do it as 100101)\\nOp 2 : Flip the bits in each row..i.e. make the 0\\'s in each row as 1 and 1\\'s as 0...."
                    },
                    {
                        "username": "mochiball",
                        "content": "Tip: No need to use extra space. Just perform the operations on the input image and return it "
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "yes\\n"
                    },
                    {
                        "username": "JavithSadhamHussain",
                        "content": "//Flippng of an 1-D array \n`\nfor(int left=0, right=array.length-1; left<=right; left++, right--)\n            {\n                int temp = array[left];\n                array[left] = array[right];\n                array[right] = temp;\n            }`\n\n"
                    },
                    {
                        "username": "sajidali56867",
                        "content": "hello it\\'s my first  comment in discussion  rather than taking a new array for result  , try to change the image row by reversing it "
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "    ```def flipAndInvertImage(self, image: List[List[int]]) -> List[List[int]]:\\n        t1 = [i[::-1] for i in image]\\n        for i in range(len(t1)):\\n            for j in range(len(t1[i])):\\n                if t1[i][j] ==0:\\n                    t1[i][j] = 1\\n                else:\\n                    t1[i][j] = 0\\n        return t1```"
                    },
                    {
                        "username": "AasthaSach29",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        \\n        for(int i=0;i<image.size();i++){\\n            for(int j=0;j<image[i].size()/2;j++){\\n                int t=(image[i].size())-j;\\n                swap(image[i][j],image[i][t]);\\n                if(image[i][j]==0){\\n                    image[i][j]=1;\\n                }\\n                else{\\n                    image[i][j]=0;\\n                }\\n             }\\n            \\n        }\\n        return image;\\n         \\n    }\\n};\\n\\n\\nWhy there is Runtime Error in this code??"
                    },
                    {
                        "username": "quarkyy99",
                        "content": "because of arrayindex out of bounds. when you initatize t.in first iteration t is equal to length of array which is 1 index ahead."
                    },
                    {
                        "username": "20euec070",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        int n=image.size();\\n       // int m=image[0].size();\\n        vector<vector<int>> v;\\n        for(int i=0;i<n;i++){\\n            int k=0;\\n            for(int j=n-1;j>=0;j--){\\n                if(image[i][j]==1){\\n                v[i][k]=0;\\n                k++;}\\n                else{\\n                v[i][k]=1;\\n                k++;}\\n            }\\n        }\\n        return v;\\n        \\n    }\\n};\\n\\n\\nwhat\\'s the mistake in my code?(error int 9th line)"
                    },
                    {
                        "username": "bparanj",
                        "content": "The error in your code is because you are trying to access `v[i][k]` when it has not yet been initialized.\\n\\nThe `vector<vector<int>> v` is currently empty and has no elements. You can\\'t access `v[i][k]` directly without either initializing the size of `v` with the same size as `image` or using the `push_back()` function to add elements.\\n\\nHere\\'s how you can modify your code to fix the error. Notice how we use `push_back` to add elements to `v`:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        int n = image.size();\\n        vector<vector<int>> v;\\n\\n        for(int i = 0; i < n; i++){\\n            vector<int> row;\\n            for(int j = n - 1; j >= 0; j--){\\n                if(image[i][j] == 1){\\n                    row.push_back(0);\\n                } else {\\n                    row.push_back(1);\\n                }\\n            }\\n            v.push_back(row);\\n        }\\n        return v;\\n    }\\n};\\n```\\n\\nThis modified version of your code works as follows: for each row, we create a new empty vector `row`. We populate `row` by iterating over the corresponding row in `image` in reverse order, pushing `0` if the original number was `1`, and `1` otherwise. After we\\'re done with a row, we add it to the `v` vector with `v.push_back(row)`."
                    },
                    {
                        "username": "1rn21is163",
                        "content": "i also have same doubt"
                    },
                    {
                        "username": "himanshubanerji",
                        "content": "If I\\'m coding in c++ can I use stl function for partially solving these questions ? Like use reverse functions to horizontally flip ?? \\n\\nplease help as I\\'m really confused if this is a good practice or not "
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "[@Himanshu Banerji](/himanshubanerji) In general it is recommended to avoid in-built functions .. That will help to build the logic, else if someone is using in-built functions directly then the thinking ability and the logic building skills won't develop."
                    },
                    {
                        "username": "himanshubanerji",
                        "content": "[@Ritabrata_1080](/Ritabrata_1080) Can u tell like in general is is recommended practise while using it or not?\\n"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "Sure you can. But also make sure to check out other solutions without using STL."
                    }
                ]
            },
            {
                "id": 1572003,
                "content": [
                    {
                        "username": "mirand",
                        "content": "Hello, Why is there this much parameters for C implementation? Isn\\'t the matrix always square, so that the parameter should only be (int** A, int ARowSize) ? Thanks for your help"
                    },
                    {
                        "username": "Anurag8305",
                        "content": "No matrix is not always square. Sometimes you may see matrix of n*m size also."
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "A normal problem of matrix .. Just to keep in mind while inserting elements in the resultant matrix, at first we need to iterate each row of the given matrix in reverse direction..Next step is to change every position value.. i.e. change all 1\\'s to 0\\'s and 0\\'s to 1\\'s.. For more information please have a look at my solution posted in the solution tab --> "
                    },
                    {
                        "username": "leetcode89",
                        "content": "I have no idea why I can\\'t understand this problem and its under easy category.Can some one help me out in understanding?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem essentially has two parts:\\n\\n1. Flip the Image Horizontally: To flip an image horizontally means to reverse the order of elements in each row. For example, if a row in the matrix is [1, 0, 1], flipping this row would result in [1, 0, 1].\\n\\n2. Invert the Image: After flipping each row, you need to invert each element in each row, which simply means changing every 1 to 0 and every 0 to 1. For example, if a flipped row is [1, 0, 1], inverting this row would result in [0, 1, 0].\\n\\nLet\\'s take an example from the problem to understand this better:\\n\\nInput: image = [[1,1,0],[1,0,1],[0,0,0]]\\nOutput: [[1,0,0],[0,1,0],[1,1,1]]\\n\\nHere\\'s what happens step-by-step:\\n\\n- First, each row is reversed:\\n  - [1,1,0] becomes [0,1,1]\\n  - [1,0,1] becomes [1,0,1]\\n  - [0,0,0] becomes [0,0,0]\\n\\n- Then, each element in each row is inverted:\\n  - [0,1,1] becomes [1,0,0]\\n  - [1,0,1] becomes [0,1,0]\\n  - [0,0,0] becomes [1,1,1]\\n\\nSo, the final output is [[1,0,0],[0,1,0],[1,1,1]], which matches the expected output.\\n\\nThe challenge lies in implementing these steps efficiently in code. The task requires understanding of array manipulation and binary number manipulation (since we\\'re just dealing with 0s and 1s)."
                    },
                    {
                        "username": "Anurag8305",
                        "content": "Try using this approach.\\n1. first reverse the row value of each row.\\n2. then replace the 0\\'s with 1\\'s and vice-versa."
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "In simple terms, just consider the given 2D array as a matrix. Now perform 2 operations ->\\nOp 1: Invert each row ( i.e if a row has 101001 then do it as 100101)\\nOp 2 : Flip the bits in each row..i.e. make the 0\\'s in each row as 1 and 1\\'s as 0...."
                    },
                    {
                        "username": "mochiball",
                        "content": "Tip: No need to use extra space. Just perform the operations on the input image and return it "
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "yes\\n"
                    },
                    {
                        "username": "JavithSadhamHussain",
                        "content": "//Flippng of an 1-D array \n`\nfor(int left=0, right=array.length-1; left<=right; left++, right--)\n            {\n                int temp = array[left];\n                array[left] = array[right];\n                array[right] = temp;\n            }`\n\n"
                    },
                    {
                        "username": "sajidali56867",
                        "content": "hello it\\'s my first  comment in discussion  rather than taking a new array for result  , try to change the image row by reversing it "
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "    ```def flipAndInvertImage(self, image: List[List[int]]) -> List[List[int]]:\\n        t1 = [i[::-1] for i in image]\\n        for i in range(len(t1)):\\n            for j in range(len(t1[i])):\\n                if t1[i][j] ==0:\\n                    t1[i][j] = 1\\n                else:\\n                    t1[i][j] = 0\\n        return t1```"
                    },
                    {
                        "username": "AasthaSach29",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        \\n        for(int i=0;i<image.size();i++){\\n            for(int j=0;j<image[i].size()/2;j++){\\n                int t=(image[i].size())-j;\\n                swap(image[i][j],image[i][t]);\\n                if(image[i][j]==0){\\n                    image[i][j]=1;\\n                }\\n                else{\\n                    image[i][j]=0;\\n                }\\n             }\\n            \\n        }\\n        return image;\\n         \\n    }\\n};\\n\\n\\nWhy there is Runtime Error in this code??"
                    },
                    {
                        "username": "quarkyy99",
                        "content": "because of arrayindex out of bounds. when you initatize t.in first iteration t is equal to length of array which is 1 index ahead."
                    },
                    {
                        "username": "20euec070",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        int n=image.size();\\n       // int m=image[0].size();\\n        vector<vector<int>> v;\\n        for(int i=0;i<n;i++){\\n            int k=0;\\n            for(int j=n-1;j>=0;j--){\\n                if(image[i][j]==1){\\n                v[i][k]=0;\\n                k++;}\\n                else{\\n                v[i][k]=1;\\n                k++;}\\n            }\\n        }\\n        return v;\\n        \\n    }\\n};\\n\\n\\nwhat\\'s the mistake in my code?(error int 9th line)"
                    },
                    {
                        "username": "bparanj",
                        "content": "The error in your code is because you are trying to access `v[i][k]` when it has not yet been initialized.\\n\\nThe `vector<vector<int>> v` is currently empty and has no elements. You can\\'t access `v[i][k]` directly without either initializing the size of `v` with the same size as `image` or using the `push_back()` function to add elements.\\n\\nHere\\'s how you can modify your code to fix the error. Notice how we use `push_back` to add elements to `v`:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        int n = image.size();\\n        vector<vector<int>> v;\\n\\n        for(int i = 0; i < n; i++){\\n            vector<int> row;\\n            for(int j = n - 1; j >= 0; j--){\\n                if(image[i][j] == 1){\\n                    row.push_back(0);\\n                } else {\\n                    row.push_back(1);\\n                }\\n            }\\n            v.push_back(row);\\n        }\\n        return v;\\n    }\\n};\\n```\\n\\nThis modified version of your code works as follows: for each row, we create a new empty vector `row`. We populate `row` by iterating over the corresponding row in `image` in reverse order, pushing `0` if the original number was `1`, and `1` otherwise. After we\\'re done with a row, we add it to the `v` vector with `v.push_back(row)`."
                    },
                    {
                        "username": "1rn21is163",
                        "content": "i also have same doubt"
                    },
                    {
                        "username": "himanshubanerji",
                        "content": "If I\\'m coding in c++ can I use stl function for partially solving these questions ? Like use reverse functions to horizontally flip ?? \\n\\nplease help as I\\'m really confused if this is a good practice or not "
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "[@Himanshu Banerji](/himanshubanerji) In general it is recommended to avoid in-built functions .. That will help to build the logic, else if someone is using in-built functions directly then the thinking ability and the logic building skills won't develop."
                    },
                    {
                        "username": "himanshubanerji",
                        "content": "[@Ritabrata_1080](/Ritabrata_1080) Can u tell like in general is is recommended practise while using it or not?\\n"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "Sure you can. But also make sure to check out other solutions without using STL."
                    }
                ]
            },
            {
                "id": 1984748,
                "content": [
                    {
                        "username": "mirand",
                        "content": "Hello, Why is there this much parameters for C implementation? Isn\\'t the matrix always square, so that the parameter should only be (int** A, int ARowSize) ? Thanks for your help"
                    },
                    {
                        "username": "Anurag8305",
                        "content": "No matrix is not always square. Sometimes you may see matrix of n*m size also."
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "A normal problem of matrix .. Just to keep in mind while inserting elements in the resultant matrix, at first we need to iterate each row of the given matrix in reverse direction..Next step is to change every position value.. i.e. change all 1\\'s to 0\\'s and 0\\'s to 1\\'s.. For more information please have a look at my solution posted in the solution tab --> "
                    },
                    {
                        "username": "leetcode89",
                        "content": "I have no idea why I can\\'t understand this problem and its under easy category.Can some one help me out in understanding?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem essentially has two parts:\\n\\n1. Flip the Image Horizontally: To flip an image horizontally means to reverse the order of elements in each row. For example, if a row in the matrix is [1, 0, 1], flipping this row would result in [1, 0, 1].\\n\\n2. Invert the Image: After flipping each row, you need to invert each element in each row, which simply means changing every 1 to 0 and every 0 to 1. For example, if a flipped row is [1, 0, 1], inverting this row would result in [0, 1, 0].\\n\\nLet\\'s take an example from the problem to understand this better:\\n\\nInput: image = [[1,1,0],[1,0,1],[0,0,0]]\\nOutput: [[1,0,0],[0,1,0],[1,1,1]]\\n\\nHere\\'s what happens step-by-step:\\n\\n- First, each row is reversed:\\n  - [1,1,0] becomes [0,1,1]\\n  - [1,0,1] becomes [1,0,1]\\n  - [0,0,0] becomes [0,0,0]\\n\\n- Then, each element in each row is inverted:\\n  - [0,1,1] becomes [1,0,0]\\n  - [1,0,1] becomes [0,1,0]\\n  - [0,0,0] becomes [1,1,1]\\n\\nSo, the final output is [[1,0,0],[0,1,0],[1,1,1]], which matches the expected output.\\n\\nThe challenge lies in implementing these steps efficiently in code. The task requires understanding of array manipulation and binary number manipulation (since we\\'re just dealing with 0s and 1s)."
                    },
                    {
                        "username": "Anurag8305",
                        "content": "Try using this approach.\\n1. first reverse the row value of each row.\\n2. then replace the 0\\'s with 1\\'s and vice-versa."
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "In simple terms, just consider the given 2D array as a matrix. Now perform 2 operations ->\\nOp 1: Invert each row ( i.e if a row has 101001 then do it as 100101)\\nOp 2 : Flip the bits in each row..i.e. make the 0\\'s in each row as 1 and 1\\'s as 0...."
                    },
                    {
                        "username": "mochiball",
                        "content": "Tip: No need to use extra space. Just perform the operations on the input image and return it "
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "yes\\n"
                    },
                    {
                        "username": "JavithSadhamHussain",
                        "content": "//Flippng of an 1-D array \n`\nfor(int left=0, right=array.length-1; left<=right; left++, right--)\n            {\n                int temp = array[left];\n                array[left] = array[right];\n                array[right] = temp;\n            }`\n\n"
                    },
                    {
                        "username": "sajidali56867",
                        "content": "hello it\\'s my first  comment in discussion  rather than taking a new array for result  , try to change the image row by reversing it "
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "    ```def flipAndInvertImage(self, image: List[List[int]]) -> List[List[int]]:\\n        t1 = [i[::-1] for i in image]\\n        for i in range(len(t1)):\\n            for j in range(len(t1[i])):\\n                if t1[i][j] ==0:\\n                    t1[i][j] = 1\\n                else:\\n                    t1[i][j] = 0\\n        return t1```"
                    },
                    {
                        "username": "AasthaSach29",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        \\n        for(int i=0;i<image.size();i++){\\n            for(int j=0;j<image[i].size()/2;j++){\\n                int t=(image[i].size())-j;\\n                swap(image[i][j],image[i][t]);\\n                if(image[i][j]==0){\\n                    image[i][j]=1;\\n                }\\n                else{\\n                    image[i][j]=0;\\n                }\\n             }\\n            \\n        }\\n        return image;\\n         \\n    }\\n};\\n\\n\\nWhy there is Runtime Error in this code??"
                    },
                    {
                        "username": "quarkyy99",
                        "content": "because of arrayindex out of bounds. when you initatize t.in first iteration t is equal to length of array which is 1 index ahead."
                    },
                    {
                        "username": "20euec070",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        int n=image.size();\\n       // int m=image[0].size();\\n        vector<vector<int>> v;\\n        for(int i=0;i<n;i++){\\n            int k=0;\\n            for(int j=n-1;j>=0;j--){\\n                if(image[i][j]==1){\\n                v[i][k]=0;\\n                k++;}\\n                else{\\n                v[i][k]=1;\\n                k++;}\\n            }\\n        }\\n        return v;\\n        \\n    }\\n};\\n\\n\\nwhat\\'s the mistake in my code?(error int 9th line)"
                    },
                    {
                        "username": "bparanj",
                        "content": "The error in your code is because you are trying to access `v[i][k]` when it has not yet been initialized.\\n\\nThe `vector<vector<int>> v` is currently empty and has no elements. You can\\'t access `v[i][k]` directly without either initializing the size of `v` with the same size as `image` or using the `push_back()` function to add elements.\\n\\nHere\\'s how you can modify your code to fix the error. Notice how we use `push_back` to add elements to `v`:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        int n = image.size();\\n        vector<vector<int>> v;\\n\\n        for(int i = 0; i < n; i++){\\n            vector<int> row;\\n            for(int j = n - 1; j >= 0; j--){\\n                if(image[i][j] == 1){\\n                    row.push_back(0);\\n                } else {\\n                    row.push_back(1);\\n                }\\n            }\\n            v.push_back(row);\\n        }\\n        return v;\\n    }\\n};\\n```\\n\\nThis modified version of your code works as follows: for each row, we create a new empty vector `row`. We populate `row` by iterating over the corresponding row in `image` in reverse order, pushing `0` if the original number was `1`, and `1` otherwise. After we\\'re done with a row, we add it to the `v` vector with `v.push_back(row)`."
                    },
                    {
                        "username": "1rn21is163",
                        "content": "i also have same doubt"
                    },
                    {
                        "username": "himanshubanerji",
                        "content": "If I\\'m coding in c++ can I use stl function for partially solving these questions ? Like use reverse functions to horizontally flip ?? \\n\\nplease help as I\\'m really confused if this is a good practice or not "
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "[@Himanshu Banerji](/himanshubanerji) In general it is recommended to avoid in-built functions .. That will help to build the logic, else if someone is using in-built functions directly then the thinking ability and the logic building skills won't develop."
                    },
                    {
                        "username": "himanshubanerji",
                        "content": "[@Ritabrata_1080](/Ritabrata_1080) Can u tell like in general is is recommended practise while using it or not?\\n"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "Sure you can. But also make sure to check out other solutions without using STL."
                    }
                ]
            },
            {
                "id": 1710712,
                "content": [
                    {
                        "username": "mirand",
                        "content": "Hello, Why is there this much parameters for C implementation? Isn\\'t the matrix always square, so that the parameter should only be (int** A, int ARowSize) ? Thanks for your help"
                    },
                    {
                        "username": "Anurag8305",
                        "content": "No matrix is not always square. Sometimes you may see matrix of n*m size also."
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "A normal problem of matrix .. Just to keep in mind while inserting elements in the resultant matrix, at first we need to iterate each row of the given matrix in reverse direction..Next step is to change every position value.. i.e. change all 1\\'s to 0\\'s and 0\\'s to 1\\'s.. For more information please have a look at my solution posted in the solution tab --> "
                    },
                    {
                        "username": "leetcode89",
                        "content": "I have no idea why I can\\'t understand this problem and its under easy category.Can some one help me out in understanding?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem essentially has two parts:\\n\\n1. Flip the Image Horizontally: To flip an image horizontally means to reverse the order of elements in each row. For example, if a row in the matrix is [1, 0, 1], flipping this row would result in [1, 0, 1].\\n\\n2. Invert the Image: After flipping each row, you need to invert each element in each row, which simply means changing every 1 to 0 and every 0 to 1. For example, if a flipped row is [1, 0, 1], inverting this row would result in [0, 1, 0].\\n\\nLet\\'s take an example from the problem to understand this better:\\n\\nInput: image = [[1,1,0],[1,0,1],[0,0,0]]\\nOutput: [[1,0,0],[0,1,0],[1,1,1]]\\n\\nHere\\'s what happens step-by-step:\\n\\n- First, each row is reversed:\\n  - [1,1,0] becomes [0,1,1]\\n  - [1,0,1] becomes [1,0,1]\\n  - [0,0,0] becomes [0,0,0]\\n\\n- Then, each element in each row is inverted:\\n  - [0,1,1] becomes [1,0,0]\\n  - [1,0,1] becomes [0,1,0]\\n  - [0,0,0] becomes [1,1,1]\\n\\nSo, the final output is [[1,0,0],[0,1,0],[1,1,1]], which matches the expected output.\\n\\nThe challenge lies in implementing these steps efficiently in code. The task requires understanding of array manipulation and binary number manipulation (since we\\'re just dealing with 0s and 1s)."
                    },
                    {
                        "username": "Anurag8305",
                        "content": "Try using this approach.\\n1. first reverse the row value of each row.\\n2. then replace the 0\\'s with 1\\'s and vice-versa."
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "In simple terms, just consider the given 2D array as a matrix. Now perform 2 operations ->\\nOp 1: Invert each row ( i.e if a row has 101001 then do it as 100101)\\nOp 2 : Flip the bits in each row..i.e. make the 0\\'s in each row as 1 and 1\\'s as 0...."
                    },
                    {
                        "username": "mochiball",
                        "content": "Tip: No need to use extra space. Just perform the operations on the input image and return it "
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "yes\\n"
                    },
                    {
                        "username": "JavithSadhamHussain",
                        "content": "//Flippng of an 1-D array \n`\nfor(int left=0, right=array.length-1; left<=right; left++, right--)\n            {\n                int temp = array[left];\n                array[left] = array[right];\n                array[right] = temp;\n            }`\n\n"
                    },
                    {
                        "username": "sajidali56867",
                        "content": "hello it\\'s my first  comment in discussion  rather than taking a new array for result  , try to change the image row by reversing it "
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "    ```def flipAndInvertImage(self, image: List[List[int]]) -> List[List[int]]:\\n        t1 = [i[::-1] for i in image]\\n        for i in range(len(t1)):\\n            for j in range(len(t1[i])):\\n                if t1[i][j] ==0:\\n                    t1[i][j] = 1\\n                else:\\n                    t1[i][j] = 0\\n        return t1```"
                    },
                    {
                        "username": "AasthaSach29",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        \\n        for(int i=0;i<image.size();i++){\\n            for(int j=0;j<image[i].size()/2;j++){\\n                int t=(image[i].size())-j;\\n                swap(image[i][j],image[i][t]);\\n                if(image[i][j]==0){\\n                    image[i][j]=1;\\n                }\\n                else{\\n                    image[i][j]=0;\\n                }\\n             }\\n            \\n        }\\n        return image;\\n         \\n    }\\n};\\n\\n\\nWhy there is Runtime Error in this code??"
                    },
                    {
                        "username": "quarkyy99",
                        "content": "because of arrayindex out of bounds. when you initatize t.in first iteration t is equal to length of array which is 1 index ahead."
                    },
                    {
                        "username": "20euec070",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        int n=image.size();\\n       // int m=image[0].size();\\n        vector<vector<int>> v;\\n        for(int i=0;i<n;i++){\\n            int k=0;\\n            for(int j=n-1;j>=0;j--){\\n                if(image[i][j]==1){\\n                v[i][k]=0;\\n                k++;}\\n                else{\\n                v[i][k]=1;\\n                k++;}\\n            }\\n        }\\n        return v;\\n        \\n    }\\n};\\n\\n\\nwhat\\'s the mistake in my code?(error int 9th line)"
                    },
                    {
                        "username": "bparanj",
                        "content": "The error in your code is because you are trying to access `v[i][k]` when it has not yet been initialized.\\n\\nThe `vector<vector<int>> v` is currently empty and has no elements. You can\\'t access `v[i][k]` directly without either initializing the size of `v` with the same size as `image` or using the `push_back()` function to add elements.\\n\\nHere\\'s how you can modify your code to fix the error. Notice how we use `push_back` to add elements to `v`:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        int n = image.size();\\n        vector<vector<int>> v;\\n\\n        for(int i = 0; i < n; i++){\\n            vector<int> row;\\n            for(int j = n - 1; j >= 0; j--){\\n                if(image[i][j] == 1){\\n                    row.push_back(0);\\n                } else {\\n                    row.push_back(1);\\n                }\\n            }\\n            v.push_back(row);\\n        }\\n        return v;\\n    }\\n};\\n```\\n\\nThis modified version of your code works as follows: for each row, we create a new empty vector `row`. We populate `row` by iterating over the corresponding row in `image` in reverse order, pushing `0` if the original number was `1`, and `1` otherwise. After we\\'re done with a row, we add it to the `v` vector with `v.push_back(row)`."
                    },
                    {
                        "username": "1rn21is163",
                        "content": "i also have same doubt"
                    },
                    {
                        "username": "himanshubanerji",
                        "content": "If I\\'m coding in c++ can I use stl function for partially solving these questions ? Like use reverse functions to horizontally flip ?? \\n\\nplease help as I\\'m really confused if this is a good practice or not "
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "[@Himanshu Banerji](/himanshubanerji) In general it is recommended to avoid in-built functions .. That will help to build the logic, else if someone is using in-built functions directly then the thinking ability and the logic building skills won't develop."
                    },
                    {
                        "username": "himanshubanerji",
                        "content": "[@Ritabrata_1080](/Ritabrata_1080) Can u tell like in general is is recommended practise while using it or not?\\n"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "Sure you can. But also make sure to check out other solutions without using STL."
                    }
                ]
            },
            {
                "id": 1916702,
                "content": [
                    {
                        "username": "mirand",
                        "content": "Hello, Why is there this much parameters for C implementation? Isn\\'t the matrix always square, so that the parameter should only be (int** A, int ARowSize) ? Thanks for your help"
                    },
                    {
                        "username": "Anurag8305",
                        "content": "No matrix is not always square. Sometimes you may see matrix of n*m size also."
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "A normal problem of matrix .. Just to keep in mind while inserting elements in the resultant matrix, at first we need to iterate each row of the given matrix in reverse direction..Next step is to change every position value.. i.e. change all 1\\'s to 0\\'s and 0\\'s to 1\\'s.. For more information please have a look at my solution posted in the solution tab --> "
                    },
                    {
                        "username": "leetcode89",
                        "content": "I have no idea why I can\\'t understand this problem and its under easy category.Can some one help me out in understanding?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem essentially has two parts:\\n\\n1. Flip the Image Horizontally: To flip an image horizontally means to reverse the order of elements in each row. For example, if a row in the matrix is [1, 0, 1], flipping this row would result in [1, 0, 1].\\n\\n2. Invert the Image: After flipping each row, you need to invert each element in each row, which simply means changing every 1 to 0 and every 0 to 1. For example, if a flipped row is [1, 0, 1], inverting this row would result in [0, 1, 0].\\n\\nLet\\'s take an example from the problem to understand this better:\\n\\nInput: image = [[1,1,0],[1,0,1],[0,0,0]]\\nOutput: [[1,0,0],[0,1,0],[1,1,1]]\\n\\nHere\\'s what happens step-by-step:\\n\\n- First, each row is reversed:\\n  - [1,1,0] becomes [0,1,1]\\n  - [1,0,1] becomes [1,0,1]\\n  - [0,0,0] becomes [0,0,0]\\n\\n- Then, each element in each row is inverted:\\n  - [0,1,1] becomes [1,0,0]\\n  - [1,0,1] becomes [0,1,0]\\n  - [0,0,0] becomes [1,1,1]\\n\\nSo, the final output is [[1,0,0],[0,1,0],[1,1,1]], which matches the expected output.\\n\\nThe challenge lies in implementing these steps efficiently in code. The task requires understanding of array manipulation and binary number manipulation (since we\\'re just dealing with 0s and 1s)."
                    },
                    {
                        "username": "Anurag8305",
                        "content": "Try using this approach.\\n1. first reverse the row value of each row.\\n2. then replace the 0\\'s with 1\\'s and vice-versa."
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "In simple terms, just consider the given 2D array as a matrix. Now perform 2 operations ->\\nOp 1: Invert each row ( i.e if a row has 101001 then do it as 100101)\\nOp 2 : Flip the bits in each row..i.e. make the 0\\'s in each row as 1 and 1\\'s as 0...."
                    },
                    {
                        "username": "mochiball",
                        "content": "Tip: No need to use extra space. Just perform the operations on the input image and return it "
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "yes\\n"
                    },
                    {
                        "username": "JavithSadhamHussain",
                        "content": "//Flippng of an 1-D array \n`\nfor(int left=0, right=array.length-1; left<=right; left++, right--)\n            {\n                int temp = array[left];\n                array[left] = array[right];\n                array[right] = temp;\n            }`\n\n"
                    },
                    {
                        "username": "sajidali56867",
                        "content": "hello it\\'s my first  comment in discussion  rather than taking a new array for result  , try to change the image row by reversing it "
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "    ```def flipAndInvertImage(self, image: List[List[int]]) -> List[List[int]]:\\n        t1 = [i[::-1] for i in image]\\n        for i in range(len(t1)):\\n            for j in range(len(t1[i])):\\n                if t1[i][j] ==0:\\n                    t1[i][j] = 1\\n                else:\\n                    t1[i][j] = 0\\n        return t1```"
                    },
                    {
                        "username": "AasthaSach29",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        \\n        for(int i=0;i<image.size();i++){\\n            for(int j=0;j<image[i].size()/2;j++){\\n                int t=(image[i].size())-j;\\n                swap(image[i][j],image[i][t]);\\n                if(image[i][j]==0){\\n                    image[i][j]=1;\\n                }\\n                else{\\n                    image[i][j]=0;\\n                }\\n             }\\n            \\n        }\\n        return image;\\n         \\n    }\\n};\\n\\n\\nWhy there is Runtime Error in this code??"
                    },
                    {
                        "username": "quarkyy99",
                        "content": "because of arrayindex out of bounds. when you initatize t.in first iteration t is equal to length of array which is 1 index ahead."
                    },
                    {
                        "username": "20euec070",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        int n=image.size();\\n       // int m=image[0].size();\\n        vector<vector<int>> v;\\n        for(int i=0;i<n;i++){\\n            int k=0;\\n            for(int j=n-1;j>=0;j--){\\n                if(image[i][j]==1){\\n                v[i][k]=0;\\n                k++;}\\n                else{\\n                v[i][k]=1;\\n                k++;}\\n            }\\n        }\\n        return v;\\n        \\n    }\\n};\\n\\n\\nwhat\\'s the mistake in my code?(error int 9th line)"
                    },
                    {
                        "username": "bparanj",
                        "content": "The error in your code is because you are trying to access `v[i][k]` when it has not yet been initialized.\\n\\nThe `vector<vector<int>> v` is currently empty and has no elements. You can\\'t access `v[i][k]` directly without either initializing the size of `v` with the same size as `image` or using the `push_back()` function to add elements.\\n\\nHere\\'s how you can modify your code to fix the error. Notice how we use `push_back` to add elements to `v`:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        int n = image.size();\\n        vector<vector<int>> v;\\n\\n        for(int i = 0; i < n; i++){\\n            vector<int> row;\\n            for(int j = n - 1; j >= 0; j--){\\n                if(image[i][j] == 1){\\n                    row.push_back(0);\\n                } else {\\n                    row.push_back(1);\\n                }\\n            }\\n            v.push_back(row);\\n        }\\n        return v;\\n    }\\n};\\n```\\n\\nThis modified version of your code works as follows: for each row, we create a new empty vector `row`. We populate `row` by iterating over the corresponding row in `image` in reverse order, pushing `0` if the original number was `1`, and `1` otherwise. After we\\'re done with a row, we add it to the `v` vector with `v.push_back(row)`."
                    },
                    {
                        "username": "1rn21is163",
                        "content": "i also have same doubt"
                    },
                    {
                        "username": "himanshubanerji",
                        "content": "If I\\'m coding in c++ can I use stl function for partially solving these questions ? Like use reverse functions to horizontally flip ?? \\n\\nplease help as I\\'m really confused if this is a good practice or not "
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "[@Himanshu Banerji](/himanshubanerji) In general it is recommended to avoid in-built functions .. That will help to build the logic, else if someone is using in-built functions directly then the thinking ability and the logic building skills won't develop."
                    },
                    {
                        "username": "himanshubanerji",
                        "content": "[@Ritabrata_1080](/Ritabrata_1080) Can u tell like in general is is recommended practise while using it or not?\\n"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "Sure you can. But also make sure to check out other solutions without using STL."
                    }
                ]
            },
            {
                "id": 1844702,
                "content": [
                    {
                        "username": "mirand",
                        "content": "Hello, Why is there this much parameters for C implementation? Isn\\'t the matrix always square, so that the parameter should only be (int** A, int ARowSize) ? Thanks for your help"
                    },
                    {
                        "username": "Anurag8305",
                        "content": "No matrix is not always square. Sometimes you may see matrix of n*m size also."
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "A normal problem of matrix .. Just to keep in mind while inserting elements in the resultant matrix, at first we need to iterate each row of the given matrix in reverse direction..Next step is to change every position value.. i.e. change all 1\\'s to 0\\'s and 0\\'s to 1\\'s.. For more information please have a look at my solution posted in the solution tab --> "
                    },
                    {
                        "username": "leetcode89",
                        "content": "I have no idea why I can\\'t understand this problem and its under easy category.Can some one help me out in understanding?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem essentially has two parts:\\n\\n1. Flip the Image Horizontally: To flip an image horizontally means to reverse the order of elements in each row. For example, if a row in the matrix is [1, 0, 1], flipping this row would result in [1, 0, 1].\\n\\n2. Invert the Image: After flipping each row, you need to invert each element in each row, which simply means changing every 1 to 0 and every 0 to 1. For example, if a flipped row is [1, 0, 1], inverting this row would result in [0, 1, 0].\\n\\nLet\\'s take an example from the problem to understand this better:\\n\\nInput: image = [[1,1,0],[1,0,1],[0,0,0]]\\nOutput: [[1,0,0],[0,1,0],[1,1,1]]\\n\\nHere\\'s what happens step-by-step:\\n\\n- First, each row is reversed:\\n  - [1,1,0] becomes [0,1,1]\\n  - [1,0,1] becomes [1,0,1]\\n  - [0,0,0] becomes [0,0,0]\\n\\n- Then, each element in each row is inverted:\\n  - [0,1,1] becomes [1,0,0]\\n  - [1,0,1] becomes [0,1,0]\\n  - [0,0,0] becomes [1,1,1]\\n\\nSo, the final output is [[1,0,0],[0,1,0],[1,1,1]], which matches the expected output.\\n\\nThe challenge lies in implementing these steps efficiently in code. The task requires understanding of array manipulation and binary number manipulation (since we\\'re just dealing with 0s and 1s)."
                    },
                    {
                        "username": "Anurag8305",
                        "content": "Try using this approach.\\n1. first reverse the row value of each row.\\n2. then replace the 0\\'s with 1\\'s and vice-versa."
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "In simple terms, just consider the given 2D array as a matrix. Now perform 2 operations ->\\nOp 1: Invert each row ( i.e if a row has 101001 then do it as 100101)\\nOp 2 : Flip the bits in each row..i.e. make the 0\\'s in each row as 1 and 1\\'s as 0...."
                    },
                    {
                        "username": "mochiball",
                        "content": "Tip: No need to use extra space. Just perform the operations on the input image and return it "
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "yes\\n"
                    },
                    {
                        "username": "JavithSadhamHussain",
                        "content": "//Flippng of an 1-D array \n`\nfor(int left=0, right=array.length-1; left<=right; left++, right--)\n            {\n                int temp = array[left];\n                array[left] = array[right];\n                array[right] = temp;\n            }`\n\n"
                    },
                    {
                        "username": "sajidali56867",
                        "content": "hello it\\'s my first  comment in discussion  rather than taking a new array for result  , try to change the image row by reversing it "
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "    ```def flipAndInvertImage(self, image: List[List[int]]) -> List[List[int]]:\\n        t1 = [i[::-1] for i in image]\\n        for i in range(len(t1)):\\n            for j in range(len(t1[i])):\\n                if t1[i][j] ==0:\\n                    t1[i][j] = 1\\n                else:\\n                    t1[i][j] = 0\\n        return t1```"
                    },
                    {
                        "username": "AasthaSach29",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        \\n        for(int i=0;i<image.size();i++){\\n            for(int j=0;j<image[i].size()/2;j++){\\n                int t=(image[i].size())-j;\\n                swap(image[i][j],image[i][t]);\\n                if(image[i][j]==0){\\n                    image[i][j]=1;\\n                }\\n                else{\\n                    image[i][j]=0;\\n                }\\n             }\\n            \\n        }\\n        return image;\\n         \\n    }\\n};\\n\\n\\nWhy there is Runtime Error in this code??"
                    },
                    {
                        "username": "quarkyy99",
                        "content": "because of arrayindex out of bounds. when you initatize t.in first iteration t is equal to length of array which is 1 index ahead."
                    },
                    {
                        "username": "20euec070",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        int n=image.size();\\n       // int m=image[0].size();\\n        vector<vector<int>> v;\\n        for(int i=0;i<n;i++){\\n            int k=0;\\n            for(int j=n-1;j>=0;j--){\\n                if(image[i][j]==1){\\n                v[i][k]=0;\\n                k++;}\\n                else{\\n                v[i][k]=1;\\n                k++;}\\n            }\\n        }\\n        return v;\\n        \\n    }\\n};\\n\\n\\nwhat\\'s the mistake in my code?(error int 9th line)"
                    },
                    {
                        "username": "bparanj",
                        "content": "The error in your code is because you are trying to access `v[i][k]` when it has not yet been initialized.\\n\\nThe `vector<vector<int>> v` is currently empty and has no elements. You can\\'t access `v[i][k]` directly without either initializing the size of `v` with the same size as `image` or using the `push_back()` function to add elements.\\n\\nHere\\'s how you can modify your code to fix the error. Notice how we use `push_back` to add elements to `v`:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        int n = image.size();\\n        vector<vector<int>> v;\\n\\n        for(int i = 0; i < n; i++){\\n            vector<int> row;\\n            for(int j = n - 1; j >= 0; j--){\\n                if(image[i][j] == 1){\\n                    row.push_back(0);\\n                } else {\\n                    row.push_back(1);\\n                }\\n            }\\n            v.push_back(row);\\n        }\\n        return v;\\n    }\\n};\\n```\\n\\nThis modified version of your code works as follows: for each row, we create a new empty vector `row`. We populate `row` by iterating over the corresponding row in `image` in reverse order, pushing `0` if the original number was `1`, and `1` otherwise. After we\\'re done with a row, we add it to the `v` vector with `v.push_back(row)`."
                    },
                    {
                        "username": "1rn21is163",
                        "content": "i also have same doubt"
                    },
                    {
                        "username": "himanshubanerji",
                        "content": "If I\\'m coding in c++ can I use stl function for partially solving these questions ? Like use reverse functions to horizontally flip ?? \\n\\nplease help as I\\'m really confused if this is a good practice or not "
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "[@Himanshu Banerji](/himanshubanerji) In general it is recommended to avoid in-built functions .. That will help to build the logic, else if someone is using in-built functions directly then the thinking ability and the logic building skills won't develop."
                    },
                    {
                        "username": "himanshubanerji",
                        "content": "[@Ritabrata_1080](/Ritabrata_1080) Can u tell like in general is is recommended practise while using it or not?\\n"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "Sure you can. But also make sure to check out other solutions without using STL."
                    }
                ]
            },
            {
                "id": 1787276,
                "content": [
                    {
                        "username": "mirand",
                        "content": "Hello, Why is there this much parameters for C implementation? Isn\\'t the matrix always square, so that the parameter should only be (int** A, int ARowSize) ? Thanks for your help"
                    },
                    {
                        "username": "Anurag8305",
                        "content": "No matrix is not always square. Sometimes you may see matrix of n*m size also."
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "A normal problem of matrix .. Just to keep in mind while inserting elements in the resultant matrix, at first we need to iterate each row of the given matrix in reverse direction..Next step is to change every position value.. i.e. change all 1\\'s to 0\\'s and 0\\'s to 1\\'s.. For more information please have a look at my solution posted in the solution tab --> "
                    },
                    {
                        "username": "leetcode89",
                        "content": "I have no idea why I can\\'t understand this problem and its under easy category.Can some one help me out in understanding?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem essentially has two parts:\\n\\n1. Flip the Image Horizontally: To flip an image horizontally means to reverse the order of elements in each row. For example, if a row in the matrix is [1, 0, 1], flipping this row would result in [1, 0, 1].\\n\\n2. Invert the Image: After flipping each row, you need to invert each element in each row, which simply means changing every 1 to 0 and every 0 to 1. For example, if a flipped row is [1, 0, 1], inverting this row would result in [0, 1, 0].\\n\\nLet\\'s take an example from the problem to understand this better:\\n\\nInput: image = [[1,1,0],[1,0,1],[0,0,0]]\\nOutput: [[1,0,0],[0,1,0],[1,1,1]]\\n\\nHere\\'s what happens step-by-step:\\n\\n- First, each row is reversed:\\n  - [1,1,0] becomes [0,1,1]\\n  - [1,0,1] becomes [1,0,1]\\n  - [0,0,0] becomes [0,0,0]\\n\\n- Then, each element in each row is inverted:\\n  - [0,1,1] becomes [1,0,0]\\n  - [1,0,1] becomes [0,1,0]\\n  - [0,0,0] becomes [1,1,1]\\n\\nSo, the final output is [[1,0,0],[0,1,0],[1,1,1]], which matches the expected output.\\n\\nThe challenge lies in implementing these steps efficiently in code. The task requires understanding of array manipulation and binary number manipulation (since we\\'re just dealing with 0s and 1s)."
                    },
                    {
                        "username": "Anurag8305",
                        "content": "Try using this approach.\\n1. first reverse the row value of each row.\\n2. then replace the 0\\'s with 1\\'s and vice-versa."
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "In simple terms, just consider the given 2D array as a matrix. Now perform 2 operations ->\\nOp 1: Invert each row ( i.e if a row has 101001 then do it as 100101)\\nOp 2 : Flip the bits in each row..i.e. make the 0\\'s in each row as 1 and 1\\'s as 0...."
                    },
                    {
                        "username": "mochiball",
                        "content": "Tip: No need to use extra space. Just perform the operations on the input image and return it "
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "yes\\n"
                    },
                    {
                        "username": "JavithSadhamHussain",
                        "content": "//Flippng of an 1-D array \n`\nfor(int left=0, right=array.length-1; left<=right; left++, right--)\n            {\n                int temp = array[left];\n                array[left] = array[right];\n                array[right] = temp;\n            }`\n\n"
                    },
                    {
                        "username": "sajidali56867",
                        "content": "hello it\\'s my first  comment in discussion  rather than taking a new array for result  , try to change the image row by reversing it "
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "    ```def flipAndInvertImage(self, image: List[List[int]]) -> List[List[int]]:\\n        t1 = [i[::-1] for i in image]\\n        for i in range(len(t1)):\\n            for j in range(len(t1[i])):\\n                if t1[i][j] ==0:\\n                    t1[i][j] = 1\\n                else:\\n                    t1[i][j] = 0\\n        return t1```"
                    },
                    {
                        "username": "AasthaSach29",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        \\n        for(int i=0;i<image.size();i++){\\n            for(int j=0;j<image[i].size()/2;j++){\\n                int t=(image[i].size())-j;\\n                swap(image[i][j],image[i][t]);\\n                if(image[i][j]==0){\\n                    image[i][j]=1;\\n                }\\n                else{\\n                    image[i][j]=0;\\n                }\\n             }\\n            \\n        }\\n        return image;\\n         \\n    }\\n};\\n\\n\\nWhy there is Runtime Error in this code??"
                    },
                    {
                        "username": "quarkyy99",
                        "content": "because of arrayindex out of bounds. when you initatize t.in first iteration t is equal to length of array which is 1 index ahead."
                    },
                    {
                        "username": "20euec070",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        int n=image.size();\\n       // int m=image[0].size();\\n        vector<vector<int>> v;\\n        for(int i=0;i<n;i++){\\n            int k=0;\\n            for(int j=n-1;j>=0;j--){\\n                if(image[i][j]==1){\\n                v[i][k]=0;\\n                k++;}\\n                else{\\n                v[i][k]=1;\\n                k++;}\\n            }\\n        }\\n        return v;\\n        \\n    }\\n};\\n\\n\\nwhat\\'s the mistake in my code?(error int 9th line)"
                    },
                    {
                        "username": "bparanj",
                        "content": "The error in your code is because you are trying to access `v[i][k]` when it has not yet been initialized.\\n\\nThe `vector<vector<int>> v` is currently empty and has no elements. You can\\'t access `v[i][k]` directly without either initializing the size of `v` with the same size as `image` or using the `push_back()` function to add elements.\\n\\nHere\\'s how you can modify your code to fix the error. Notice how we use `push_back` to add elements to `v`:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        int n = image.size();\\n        vector<vector<int>> v;\\n\\n        for(int i = 0; i < n; i++){\\n            vector<int> row;\\n            for(int j = n - 1; j >= 0; j--){\\n                if(image[i][j] == 1){\\n                    row.push_back(0);\\n                } else {\\n                    row.push_back(1);\\n                }\\n            }\\n            v.push_back(row);\\n        }\\n        return v;\\n    }\\n};\\n```\\n\\nThis modified version of your code works as follows: for each row, we create a new empty vector `row`. We populate `row` by iterating over the corresponding row in `image` in reverse order, pushing `0` if the original number was `1`, and `1` otherwise. After we\\'re done with a row, we add it to the `v` vector with `v.push_back(row)`."
                    },
                    {
                        "username": "1rn21is163",
                        "content": "i also have same doubt"
                    },
                    {
                        "username": "himanshubanerji",
                        "content": "If I\\'m coding in c++ can I use stl function for partially solving these questions ? Like use reverse functions to horizontally flip ?? \\n\\nplease help as I\\'m really confused if this is a good practice or not "
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "[@Himanshu Banerji](/himanshubanerji) In general it is recommended to avoid in-built functions .. That will help to build the logic, else if someone is using in-built functions directly then the thinking ability and the logic building skills won't develop."
                    },
                    {
                        "username": "himanshubanerji",
                        "content": "[@Ritabrata_1080](/Ritabrata_1080) Can u tell like in general is is recommended practise while using it or not?\\n"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "Sure you can. But also make sure to check out other solutions without using STL."
                    }
                ]
            },
            {
                "id": 1743797,
                "content": [
                    {
                        "username": "mirand",
                        "content": "Hello, Why is there this much parameters for C implementation? Isn\\'t the matrix always square, so that the parameter should only be (int** A, int ARowSize) ? Thanks for your help"
                    },
                    {
                        "username": "Anurag8305",
                        "content": "No matrix is not always square. Sometimes you may see matrix of n*m size also."
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "A normal problem of matrix .. Just to keep in mind while inserting elements in the resultant matrix, at first we need to iterate each row of the given matrix in reverse direction..Next step is to change every position value.. i.e. change all 1\\'s to 0\\'s and 0\\'s to 1\\'s.. For more information please have a look at my solution posted in the solution tab --> "
                    },
                    {
                        "username": "leetcode89",
                        "content": "I have no idea why I can\\'t understand this problem and its under easy category.Can some one help me out in understanding?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem essentially has two parts:\\n\\n1. Flip the Image Horizontally: To flip an image horizontally means to reverse the order of elements in each row. For example, if a row in the matrix is [1, 0, 1], flipping this row would result in [1, 0, 1].\\n\\n2. Invert the Image: After flipping each row, you need to invert each element in each row, which simply means changing every 1 to 0 and every 0 to 1. For example, if a flipped row is [1, 0, 1], inverting this row would result in [0, 1, 0].\\n\\nLet\\'s take an example from the problem to understand this better:\\n\\nInput: image = [[1,1,0],[1,0,1],[0,0,0]]\\nOutput: [[1,0,0],[0,1,0],[1,1,1]]\\n\\nHere\\'s what happens step-by-step:\\n\\n- First, each row is reversed:\\n  - [1,1,0] becomes [0,1,1]\\n  - [1,0,1] becomes [1,0,1]\\n  - [0,0,0] becomes [0,0,0]\\n\\n- Then, each element in each row is inverted:\\n  - [0,1,1] becomes [1,0,0]\\n  - [1,0,1] becomes [0,1,0]\\n  - [0,0,0] becomes [1,1,1]\\n\\nSo, the final output is [[1,0,0],[0,1,0],[1,1,1]], which matches the expected output.\\n\\nThe challenge lies in implementing these steps efficiently in code. The task requires understanding of array manipulation and binary number manipulation (since we\\'re just dealing with 0s and 1s)."
                    },
                    {
                        "username": "Anurag8305",
                        "content": "Try using this approach.\\n1. first reverse the row value of each row.\\n2. then replace the 0\\'s with 1\\'s and vice-versa."
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "In simple terms, just consider the given 2D array as a matrix. Now perform 2 operations ->\\nOp 1: Invert each row ( i.e if a row has 101001 then do it as 100101)\\nOp 2 : Flip the bits in each row..i.e. make the 0\\'s in each row as 1 and 1\\'s as 0...."
                    },
                    {
                        "username": "mochiball",
                        "content": "Tip: No need to use extra space. Just perform the operations on the input image and return it "
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "yes\\n"
                    },
                    {
                        "username": "JavithSadhamHussain",
                        "content": "//Flippng of an 1-D array \n`\nfor(int left=0, right=array.length-1; left<=right; left++, right--)\n            {\n                int temp = array[left];\n                array[left] = array[right];\n                array[right] = temp;\n            }`\n\n"
                    },
                    {
                        "username": "sajidali56867",
                        "content": "hello it\\'s my first  comment in discussion  rather than taking a new array for result  , try to change the image row by reversing it "
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "    ```def flipAndInvertImage(self, image: List[List[int]]) -> List[List[int]]:\\n        t1 = [i[::-1] for i in image]\\n        for i in range(len(t1)):\\n            for j in range(len(t1[i])):\\n                if t1[i][j] ==0:\\n                    t1[i][j] = 1\\n                else:\\n                    t1[i][j] = 0\\n        return t1```"
                    },
                    {
                        "username": "AasthaSach29",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        \\n        for(int i=0;i<image.size();i++){\\n            for(int j=0;j<image[i].size()/2;j++){\\n                int t=(image[i].size())-j;\\n                swap(image[i][j],image[i][t]);\\n                if(image[i][j]==0){\\n                    image[i][j]=1;\\n                }\\n                else{\\n                    image[i][j]=0;\\n                }\\n             }\\n            \\n        }\\n        return image;\\n         \\n    }\\n};\\n\\n\\nWhy there is Runtime Error in this code??"
                    },
                    {
                        "username": "quarkyy99",
                        "content": "because of arrayindex out of bounds. when you initatize t.in first iteration t is equal to length of array which is 1 index ahead."
                    },
                    {
                        "username": "20euec070",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        int n=image.size();\\n       // int m=image[0].size();\\n        vector<vector<int>> v;\\n        for(int i=0;i<n;i++){\\n            int k=0;\\n            for(int j=n-1;j>=0;j--){\\n                if(image[i][j]==1){\\n                v[i][k]=0;\\n                k++;}\\n                else{\\n                v[i][k]=1;\\n                k++;}\\n            }\\n        }\\n        return v;\\n        \\n    }\\n};\\n\\n\\nwhat\\'s the mistake in my code?(error int 9th line)"
                    },
                    {
                        "username": "bparanj",
                        "content": "The error in your code is because you are trying to access `v[i][k]` when it has not yet been initialized.\\n\\nThe `vector<vector<int>> v` is currently empty and has no elements. You can\\'t access `v[i][k]` directly without either initializing the size of `v` with the same size as `image` or using the `push_back()` function to add elements.\\n\\nHere\\'s how you can modify your code to fix the error. Notice how we use `push_back` to add elements to `v`:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        int n = image.size();\\n        vector<vector<int>> v;\\n\\n        for(int i = 0; i < n; i++){\\n            vector<int> row;\\n            for(int j = n - 1; j >= 0; j--){\\n                if(image[i][j] == 1){\\n                    row.push_back(0);\\n                } else {\\n                    row.push_back(1);\\n                }\\n            }\\n            v.push_back(row);\\n        }\\n        return v;\\n    }\\n};\\n```\\n\\nThis modified version of your code works as follows: for each row, we create a new empty vector `row`. We populate `row` by iterating over the corresponding row in `image` in reverse order, pushing `0` if the original number was `1`, and `1` otherwise. After we\\'re done with a row, we add it to the `v` vector with `v.push_back(row)`."
                    },
                    {
                        "username": "1rn21is163",
                        "content": "i also have same doubt"
                    },
                    {
                        "username": "himanshubanerji",
                        "content": "If I\\'m coding in c++ can I use stl function for partially solving these questions ? Like use reverse functions to horizontally flip ?? \\n\\nplease help as I\\'m really confused if this is a good practice or not "
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "[@Himanshu Banerji](/himanshubanerji) In general it is recommended to avoid in-built functions .. That will help to build the logic, else if someone is using in-built functions directly then the thinking ability and the logic building skills won't develop."
                    },
                    {
                        "username": "himanshubanerji",
                        "content": "[@Ritabrata_1080](/Ritabrata_1080) Can u tell like in general is is recommended practise while using it or not?\\n"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "Sure you can. But also make sure to check out other solutions without using STL."
                    }
                ]
            },
            {
                "id": 1740762,
                "content": [
                    {
                        "username": "mirand",
                        "content": "Hello, Why is there this much parameters for C implementation? Isn\\'t the matrix always square, so that the parameter should only be (int** A, int ARowSize) ? Thanks for your help"
                    },
                    {
                        "username": "Anurag8305",
                        "content": "No matrix is not always square. Sometimes you may see matrix of n*m size also."
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "A normal problem of matrix .. Just to keep in mind while inserting elements in the resultant matrix, at first we need to iterate each row of the given matrix in reverse direction..Next step is to change every position value.. i.e. change all 1\\'s to 0\\'s and 0\\'s to 1\\'s.. For more information please have a look at my solution posted in the solution tab --> "
                    },
                    {
                        "username": "leetcode89",
                        "content": "I have no idea why I can\\'t understand this problem and its under easy category.Can some one help me out in understanding?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem essentially has two parts:\\n\\n1. Flip the Image Horizontally: To flip an image horizontally means to reverse the order of elements in each row. For example, if a row in the matrix is [1, 0, 1], flipping this row would result in [1, 0, 1].\\n\\n2. Invert the Image: After flipping each row, you need to invert each element in each row, which simply means changing every 1 to 0 and every 0 to 1. For example, if a flipped row is [1, 0, 1], inverting this row would result in [0, 1, 0].\\n\\nLet\\'s take an example from the problem to understand this better:\\n\\nInput: image = [[1,1,0],[1,0,1],[0,0,0]]\\nOutput: [[1,0,0],[0,1,0],[1,1,1]]\\n\\nHere\\'s what happens step-by-step:\\n\\n- First, each row is reversed:\\n  - [1,1,0] becomes [0,1,1]\\n  - [1,0,1] becomes [1,0,1]\\n  - [0,0,0] becomes [0,0,0]\\n\\n- Then, each element in each row is inverted:\\n  - [0,1,1] becomes [1,0,0]\\n  - [1,0,1] becomes [0,1,0]\\n  - [0,0,0] becomes [1,1,1]\\n\\nSo, the final output is [[1,0,0],[0,1,0],[1,1,1]], which matches the expected output.\\n\\nThe challenge lies in implementing these steps efficiently in code. The task requires understanding of array manipulation and binary number manipulation (since we\\'re just dealing with 0s and 1s)."
                    },
                    {
                        "username": "Anurag8305",
                        "content": "Try using this approach.\\n1. first reverse the row value of each row.\\n2. then replace the 0\\'s with 1\\'s and vice-versa."
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "In simple terms, just consider the given 2D array as a matrix. Now perform 2 operations ->\\nOp 1: Invert each row ( i.e if a row has 101001 then do it as 100101)\\nOp 2 : Flip the bits in each row..i.e. make the 0\\'s in each row as 1 and 1\\'s as 0...."
                    },
                    {
                        "username": "mochiball",
                        "content": "Tip: No need to use extra space. Just perform the operations on the input image and return it "
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "yes\\n"
                    },
                    {
                        "username": "JavithSadhamHussain",
                        "content": "//Flippng of an 1-D array \n`\nfor(int left=0, right=array.length-1; left<=right; left++, right--)\n            {\n                int temp = array[left];\n                array[left] = array[right];\n                array[right] = temp;\n            }`\n\n"
                    },
                    {
                        "username": "sajidali56867",
                        "content": "hello it\\'s my first  comment in discussion  rather than taking a new array for result  , try to change the image row by reversing it "
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "    ```def flipAndInvertImage(self, image: List[List[int]]) -> List[List[int]]:\\n        t1 = [i[::-1] for i in image]\\n        for i in range(len(t1)):\\n            for j in range(len(t1[i])):\\n                if t1[i][j] ==0:\\n                    t1[i][j] = 1\\n                else:\\n                    t1[i][j] = 0\\n        return t1```"
                    },
                    {
                        "username": "AasthaSach29",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        \\n        for(int i=0;i<image.size();i++){\\n            for(int j=0;j<image[i].size()/2;j++){\\n                int t=(image[i].size())-j;\\n                swap(image[i][j],image[i][t]);\\n                if(image[i][j]==0){\\n                    image[i][j]=1;\\n                }\\n                else{\\n                    image[i][j]=0;\\n                }\\n             }\\n            \\n        }\\n        return image;\\n         \\n    }\\n};\\n\\n\\nWhy there is Runtime Error in this code??"
                    },
                    {
                        "username": "quarkyy99",
                        "content": "because of arrayindex out of bounds. when you initatize t.in first iteration t is equal to length of array which is 1 index ahead."
                    },
                    {
                        "username": "20euec070",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        int n=image.size();\\n       // int m=image[0].size();\\n        vector<vector<int>> v;\\n        for(int i=0;i<n;i++){\\n            int k=0;\\n            for(int j=n-1;j>=0;j--){\\n                if(image[i][j]==1){\\n                v[i][k]=0;\\n                k++;}\\n                else{\\n                v[i][k]=1;\\n                k++;}\\n            }\\n        }\\n        return v;\\n        \\n    }\\n};\\n\\n\\nwhat\\'s the mistake in my code?(error int 9th line)"
                    },
                    {
                        "username": "bparanj",
                        "content": "The error in your code is because you are trying to access `v[i][k]` when it has not yet been initialized.\\n\\nThe `vector<vector<int>> v` is currently empty and has no elements. You can\\'t access `v[i][k]` directly without either initializing the size of `v` with the same size as `image` or using the `push_back()` function to add elements.\\n\\nHere\\'s how you can modify your code to fix the error. Notice how we use `push_back` to add elements to `v`:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        int n = image.size();\\n        vector<vector<int>> v;\\n\\n        for(int i = 0; i < n; i++){\\n            vector<int> row;\\n            for(int j = n - 1; j >= 0; j--){\\n                if(image[i][j] == 1){\\n                    row.push_back(0);\\n                } else {\\n                    row.push_back(1);\\n                }\\n            }\\n            v.push_back(row);\\n        }\\n        return v;\\n    }\\n};\\n```\\n\\nThis modified version of your code works as follows: for each row, we create a new empty vector `row`. We populate `row` by iterating over the corresponding row in `image` in reverse order, pushing `0` if the original number was `1`, and `1` otherwise. After we\\'re done with a row, we add it to the `v` vector with `v.push_back(row)`."
                    },
                    {
                        "username": "1rn21is163",
                        "content": "i also have same doubt"
                    },
                    {
                        "username": "himanshubanerji",
                        "content": "If I\\'m coding in c++ can I use stl function for partially solving these questions ? Like use reverse functions to horizontally flip ?? \\n\\nplease help as I\\'m really confused if this is a good practice or not "
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "[@Himanshu Banerji](/himanshubanerji) In general it is recommended to avoid in-built functions .. That will help to build the logic, else if someone is using in-built functions directly then the thinking ability and the logic building skills won't develop."
                    },
                    {
                        "username": "himanshubanerji",
                        "content": "[@Ritabrata_1080](/Ritabrata_1080) Can u tell like in general is is recommended practise while using it or not?\\n"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "Sure you can. But also make sure to check out other solutions without using STL."
                    }
                ]
            },
            {
                "id": 1566528,
                "content": [
                    {
                        "username": "mirand",
                        "content": "Hello, Why is there this much parameters for C implementation? Isn\\'t the matrix always square, so that the parameter should only be (int** A, int ARowSize) ? Thanks for your help"
                    },
                    {
                        "username": "Anurag8305",
                        "content": "No matrix is not always square. Sometimes you may see matrix of n*m size also."
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "A normal problem of matrix .. Just to keep in mind while inserting elements in the resultant matrix, at first we need to iterate each row of the given matrix in reverse direction..Next step is to change every position value.. i.e. change all 1\\'s to 0\\'s and 0\\'s to 1\\'s.. For more information please have a look at my solution posted in the solution tab --> "
                    },
                    {
                        "username": "leetcode89",
                        "content": "I have no idea why I can\\'t understand this problem and its under easy category.Can some one help me out in understanding?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem essentially has two parts:\\n\\n1. Flip the Image Horizontally: To flip an image horizontally means to reverse the order of elements in each row. For example, if a row in the matrix is [1, 0, 1], flipping this row would result in [1, 0, 1].\\n\\n2. Invert the Image: After flipping each row, you need to invert each element in each row, which simply means changing every 1 to 0 and every 0 to 1. For example, if a flipped row is [1, 0, 1], inverting this row would result in [0, 1, 0].\\n\\nLet\\'s take an example from the problem to understand this better:\\n\\nInput: image = [[1,1,0],[1,0,1],[0,0,0]]\\nOutput: [[1,0,0],[0,1,0],[1,1,1]]\\n\\nHere\\'s what happens step-by-step:\\n\\n- First, each row is reversed:\\n  - [1,1,0] becomes [0,1,1]\\n  - [1,0,1] becomes [1,0,1]\\n  - [0,0,0] becomes [0,0,0]\\n\\n- Then, each element in each row is inverted:\\n  - [0,1,1] becomes [1,0,0]\\n  - [1,0,1] becomes [0,1,0]\\n  - [0,0,0] becomes [1,1,1]\\n\\nSo, the final output is [[1,0,0],[0,1,0],[1,1,1]], which matches the expected output.\\n\\nThe challenge lies in implementing these steps efficiently in code. The task requires understanding of array manipulation and binary number manipulation (since we\\'re just dealing with 0s and 1s)."
                    },
                    {
                        "username": "Anurag8305",
                        "content": "Try using this approach.\\n1. first reverse the row value of each row.\\n2. then replace the 0\\'s with 1\\'s and vice-versa."
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "In simple terms, just consider the given 2D array as a matrix. Now perform 2 operations ->\\nOp 1: Invert each row ( i.e if a row has 101001 then do it as 100101)\\nOp 2 : Flip the bits in each row..i.e. make the 0\\'s in each row as 1 and 1\\'s as 0...."
                    },
                    {
                        "username": "mochiball",
                        "content": "Tip: No need to use extra space. Just perform the operations on the input image and return it "
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "yes\\n"
                    },
                    {
                        "username": "JavithSadhamHussain",
                        "content": "//Flippng of an 1-D array \n`\nfor(int left=0, right=array.length-1; left<=right; left++, right--)\n            {\n                int temp = array[left];\n                array[left] = array[right];\n                array[right] = temp;\n            }`\n\n"
                    },
                    {
                        "username": "sajidali56867",
                        "content": "hello it\\'s my first  comment in discussion  rather than taking a new array for result  , try to change the image row by reversing it "
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "    ```def flipAndInvertImage(self, image: List[List[int]]) -> List[List[int]]:\\n        t1 = [i[::-1] for i in image]\\n        for i in range(len(t1)):\\n            for j in range(len(t1[i])):\\n                if t1[i][j] ==0:\\n                    t1[i][j] = 1\\n                else:\\n                    t1[i][j] = 0\\n        return t1```"
                    },
                    {
                        "username": "AasthaSach29",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        \\n        for(int i=0;i<image.size();i++){\\n            for(int j=0;j<image[i].size()/2;j++){\\n                int t=(image[i].size())-j;\\n                swap(image[i][j],image[i][t]);\\n                if(image[i][j]==0){\\n                    image[i][j]=1;\\n                }\\n                else{\\n                    image[i][j]=0;\\n                }\\n             }\\n            \\n        }\\n        return image;\\n         \\n    }\\n};\\n\\n\\nWhy there is Runtime Error in this code??"
                    },
                    {
                        "username": "quarkyy99",
                        "content": "because of arrayindex out of bounds. when you initatize t.in first iteration t is equal to length of array which is 1 index ahead."
                    },
                    {
                        "username": "20euec070",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        int n=image.size();\\n       // int m=image[0].size();\\n        vector<vector<int>> v;\\n        for(int i=0;i<n;i++){\\n            int k=0;\\n            for(int j=n-1;j>=0;j--){\\n                if(image[i][j]==1){\\n                v[i][k]=0;\\n                k++;}\\n                else{\\n                v[i][k]=1;\\n                k++;}\\n            }\\n        }\\n        return v;\\n        \\n    }\\n};\\n\\n\\nwhat\\'s the mistake in my code?(error int 9th line)"
                    },
                    {
                        "username": "bparanj",
                        "content": "The error in your code is because you are trying to access `v[i][k]` when it has not yet been initialized.\\n\\nThe `vector<vector<int>> v` is currently empty and has no elements. You can\\'t access `v[i][k]` directly without either initializing the size of `v` with the same size as `image` or using the `push_back()` function to add elements.\\n\\nHere\\'s how you can modify your code to fix the error. Notice how we use `push_back` to add elements to `v`:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        int n = image.size();\\n        vector<vector<int>> v;\\n\\n        for(int i = 0; i < n; i++){\\n            vector<int> row;\\n            for(int j = n - 1; j >= 0; j--){\\n                if(image[i][j] == 1){\\n                    row.push_back(0);\\n                } else {\\n                    row.push_back(1);\\n                }\\n            }\\n            v.push_back(row);\\n        }\\n        return v;\\n    }\\n};\\n```\\n\\nThis modified version of your code works as follows: for each row, we create a new empty vector `row`. We populate `row` by iterating over the corresponding row in `image` in reverse order, pushing `0` if the original number was `1`, and `1` otherwise. After we\\'re done with a row, we add it to the `v` vector with `v.push_back(row)`."
                    },
                    {
                        "username": "1rn21is163",
                        "content": "i also have same doubt"
                    },
                    {
                        "username": "himanshubanerji",
                        "content": "If I\\'m coding in c++ can I use stl function for partially solving these questions ? Like use reverse functions to horizontally flip ?? \\n\\nplease help as I\\'m really confused if this is a good practice or not "
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "[@Himanshu Banerji](/himanshubanerji) In general it is recommended to avoid in-built functions .. That will help to build the logic, else if someone is using in-built functions directly then the thinking ability and the logic building skills won't develop."
                    },
                    {
                        "username": "himanshubanerji",
                        "content": "[@Ritabrata_1080](/Ritabrata_1080) Can u tell like in general is is recommended practise while using it or not?\\n"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "Sure you can. But also make sure to check out other solutions without using STL."
                    }
                ]
            },
            {
                "id": 1671031,
                "content": [
                    {
                        "username": "mirand",
                        "content": "Hello, Why is there this much parameters for C implementation? Isn\\'t the matrix always square, so that the parameter should only be (int** A, int ARowSize) ? Thanks for your help"
                    },
                    {
                        "username": "Anurag8305",
                        "content": "No matrix is not always square. Sometimes you may see matrix of n*m size also."
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "A normal problem of matrix .. Just to keep in mind while inserting elements in the resultant matrix, at first we need to iterate each row of the given matrix in reverse direction..Next step is to change every position value.. i.e. change all 1\\'s to 0\\'s and 0\\'s to 1\\'s.. For more information please have a look at my solution posted in the solution tab --> "
                    },
                    {
                        "username": "leetcode89",
                        "content": "I have no idea why I can\\'t understand this problem and its under easy category.Can some one help me out in understanding?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem essentially has two parts:\\n\\n1. Flip the Image Horizontally: To flip an image horizontally means to reverse the order of elements in each row. For example, if a row in the matrix is [1, 0, 1], flipping this row would result in [1, 0, 1].\\n\\n2. Invert the Image: After flipping each row, you need to invert each element in each row, which simply means changing every 1 to 0 and every 0 to 1. For example, if a flipped row is [1, 0, 1], inverting this row would result in [0, 1, 0].\\n\\nLet\\'s take an example from the problem to understand this better:\\n\\nInput: image = [[1,1,0],[1,0,1],[0,0,0]]\\nOutput: [[1,0,0],[0,1,0],[1,1,1]]\\n\\nHere\\'s what happens step-by-step:\\n\\n- First, each row is reversed:\\n  - [1,1,0] becomes [0,1,1]\\n  - [1,0,1] becomes [1,0,1]\\n  - [0,0,0] becomes [0,0,0]\\n\\n- Then, each element in each row is inverted:\\n  - [0,1,1] becomes [1,0,0]\\n  - [1,0,1] becomes [0,1,0]\\n  - [0,0,0] becomes [1,1,1]\\n\\nSo, the final output is [[1,0,0],[0,1,0],[1,1,1]], which matches the expected output.\\n\\nThe challenge lies in implementing these steps efficiently in code. The task requires understanding of array manipulation and binary number manipulation (since we\\'re just dealing with 0s and 1s)."
                    },
                    {
                        "username": "Anurag8305",
                        "content": "Try using this approach.\\n1. first reverse the row value of each row.\\n2. then replace the 0\\'s with 1\\'s and vice-versa."
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "In simple terms, just consider the given 2D array as a matrix. Now perform 2 operations ->\\nOp 1: Invert each row ( i.e if a row has 101001 then do it as 100101)\\nOp 2 : Flip the bits in each row..i.e. make the 0\\'s in each row as 1 and 1\\'s as 0...."
                    },
                    {
                        "username": "mochiball",
                        "content": "Tip: No need to use extra space. Just perform the operations on the input image and return it "
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "yes\\n"
                    },
                    {
                        "username": "JavithSadhamHussain",
                        "content": "//Flippng of an 1-D array \n`\nfor(int left=0, right=array.length-1; left<=right; left++, right--)\n            {\n                int temp = array[left];\n                array[left] = array[right];\n                array[right] = temp;\n            }`\n\n"
                    },
                    {
                        "username": "sajidali56867",
                        "content": "hello it\\'s my first  comment in discussion  rather than taking a new array for result  , try to change the image row by reversing it "
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "    ```def flipAndInvertImage(self, image: List[List[int]]) -> List[List[int]]:\\n        t1 = [i[::-1] for i in image]\\n        for i in range(len(t1)):\\n            for j in range(len(t1[i])):\\n                if t1[i][j] ==0:\\n                    t1[i][j] = 1\\n                else:\\n                    t1[i][j] = 0\\n        return t1```"
                    },
                    {
                        "username": "AasthaSach29",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        \\n        for(int i=0;i<image.size();i++){\\n            for(int j=0;j<image[i].size()/2;j++){\\n                int t=(image[i].size())-j;\\n                swap(image[i][j],image[i][t]);\\n                if(image[i][j]==0){\\n                    image[i][j]=1;\\n                }\\n                else{\\n                    image[i][j]=0;\\n                }\\n             }\\n            \\n        }\\n        return image;\\n         \\n    }\\n};\\n\\n\\nWhy there is Runtime Error in this code??"
                    },
                    {
                        "username": "quarkyy99",
                        "content": "because of arrayindex out of bounds. when you initatize t.in first iteration t is equal to length of array which is 1 index ahead."
                    },
                    {
                        "username": "20euec070",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        int n=image.size();\\n       // int m=image[0].size();\\n        vector<vector<int>> v;\\n        for(int i=0;i<n;i++){\\n            int k=0;\\n            for(int j=n-1;j>=0;j--){\\n                if(image[i][j]==1){\\n                v[i][k]=0;\\n                k++;}\\n                else{\\n                v[i][k]=1;\\n                k++;}\\n            }\\n        }\\n        return v;\\n        \\n    }\\n};\\n\\n\\nwhat\\'s the mistake in my code?(error int 9th line)"
                    },
                    {
                        "username": "bparanj",
                        "content": "The error in your code is because you are trying to access `v[i][k]` when it has not yet been initialized.\\n\\nThe `vector<vector<int>> v` is currently empty and has no elements. You can\\'t access `v[i][k]` directly without either initializing the size of `v` with the same size as `image` or using the `push_back()` function to add elements.\\n\\nHere\\'s how you can modify your code to fix the error. Notice how we use `push_back` to add elements to `v`:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        int n = image.size();\\n        vector<vector<int>> v;\\n\\n        for(int i = 0; i < n; i++){\\n            vector<int> row;\\n            for(int j = n - 1; j >= 0; j--){\\n                if(image[i][j] == 1){\\n                    row.push_back(0);\\n                } else {\\n                    row.push_back(1);\\n                }\\n            }\\n            v.push_back(row);\\n        }\\n        return v;\\n    }\\n};\\n```\\n\\nThis modified version of your code works as follows: for each row, we create a new empty vector `row`. We populate `row` by iterating over the corresponding row in `image` in reverse order, pushing `0` if the original number was `1`, and `1` otherwise. After we\\'re done with a row, we add it to the `v` vector with `v.push_back(row)`."
                    },
                    {
                        "username": "1rn21is163",
                        "content": "i also have same doubt"
                    },
                    {
                        "username": "himanshubanerji",
                        "content": "If I\\'m coding in c++ can I use stl function for partially solving these questions ? Like use reverse functions to horizontally flip ?? \\n\\nplease help as I\\'m really confused if this is a good practice or not "
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "[@Himanshu Banerji](/himanshubanerji) In general it is recommended to avoid in-built functions .. That will help to build the logic, else if someone is using in-built functions directly then the thinking ability and the logic building skills won't develop."
                    },
                    {
                        "username": "himanshubanerji",
                        "content": "[@Ritabrata_1080](/Ritabrata_1080) Can u tell like in general is is recommended practise while using it or not?\\n"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "Sure you can. But also make sure to check out other solutions without using STL."
                    }
                ]
            },
            {
                "id": 1572003,
                "content": [
                    {
                        "username": "mirand",
                        "content": "Hello, Why is there this much parameters for C implementation? Isn\\'t the matrix always square, so that the parameter should only be (int** A, int ARowSize) ? Thanks for your help"
                    },
                    {
                        "username": "Anurag8305",
                        "content": "No matrix is not always square. Sometimes you may see matrix of n*m size also."
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "A normal problem of matrix .. Just to keep in mind while inserting elements in the resultant matrix, at first we need to iterate each row of the given matrix in reverse direction..Next step is to change every position value.. i.e. change all 1\\'s to 0\\'s and 0\\'s to 1\\'s.. For more information please have a look at my solution posted in the solution tab --> "
                    },
                    {
                        "username": "leetcode89",
                        "content": "I have no idea why I can\\'t understand this problem and its under easy category.Can some one help me out in understanding?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem essentially has two parts:\\n\\n1. Flip the Image Horizontally: To flip an image horizontally means to reverse the order of elements in each row. For example, if a row in the matrix is [1, 0, 1], flipping this row would result in [1, 0, 1].\\n\\n2. Invert the Image: After flipping each row, you need to invert each element in each row, which simply means changing every 1 to 0 and every 0 to 1. For example, if a flipped row is [1, 0, 1], inverting this row would result in [0, 1, 0].\\n\\nLet\\'s take an example from the problem to understand this better:\\n\\nInput: image = [[1,1,0],[1,0,1],[0,0,0]]\\nOutput: [[1,0,0],[0,1,0],[1,1,1]]\\n\\nHere\\'s what happens step-by-step:\\n\\n- First, each row is reversed:\\n  - [1,1,0] becomes [0,1,1]\\n  - [1,0,1] becomes [1,0,1]\\n  - [0,0,0] becomes [0,0,0]\\n\\n- Then, each element in each row is inverted:\\n  - [0,1,1] becomes [1,0,0]\\n  - [1,0,1] becomes [0,1,0]\\n  - [0,0,0] becomes [1,1,1]\\n\\nSo, the final output is [[1,0,0],[0,1,0],[1,1,1]], which matches the expected output.\\n\\nThe challenge lies in implementing these steps efficiently in code. The task requires understanding of array manipulation and binary number manipulation (since we\\'re just dealing with 0s and 1s)."
                    },
                    {
                        "username": "Anurag8305",
                        "content": "Try using this approach.\\n1. first reverse the row value of each row.\\n2. then replace the 0\\'s with 1\\'s and vice-versa."
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "In simple terms, just consider the given 2D array as a matrix. Now perform 2 operations ->\\nOp 1: Invert each row ( i.e if a row has 101001 then do it as 100101)\\nOp 2 : Flip the bits in each row..i.e. make the 0\\'s in each row as 1 and 1\\'s as 0...."
                    },
                    {
                        "username": "mochiball",
                        "content": "Tip: No need to use extra space. Just perform the operations on the input image and return it "
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "yes\\n"
                    },
                    {
                        "username": "JavithSadhamHussain",
                        "content": "//Flippng of an 1-D array \n`\nfor(int left=0, right=array.length-1; left<=right; left++, right--)\n            {\n                int temp = array[left];\n                array[left] = array[right];\n                array[right] = temp;\n            }`\n\n"
                    },
                    {
                        "username": "sajidali56867",
                        "content": "hello it\\'s my first  comment in discussion  rather than taking a new array for result  , try to change the image row by reversing it "
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "    ```def flipAndInvertImage(self, image: List[List[int]]) -> List[List[int]]:\\n        t1 = [i[::-1] for i in image]\\n        for i in range(len(t1)):\\n            for j in range(len(t1[i])):\\n                if t1[i][j] ==0:\\n                    t1[i][j] = 1\\n                else:\\n                    t1[i][j] = 0\\n        return t1```"
                    },
                    {
                        "username": "AasthaSach29",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        \\n        for(int i=0;i<image.size();i++){\\n            for(int j=0;j<image[i].size()/2;j++){\\n                int t=(image[i].size())-j;\\n                swap(image[i][j],image[i][t]);\\n                if(image[i][j]==0){\\n                    image[i][j]=1;\\n                }\\n                else{\\n                    image[i][j]=0;\\n                }\\n             }\\n            \\n        }\\n        return image;\\n         \\n    }\\n};\\n\\n\\nWhy there is Runtime Error in this code??"
                    },
                    {
                        "username": "quarkyy99",
                        "content": "because of arrayindex out of bounds. when you initatize t.in first iteration t is equal to length of array which is 1 index ahead."
                    },
                    {
                        "username": "20euec070",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        int n=image.size();\\n       // int m=image[0].size();\\n        vector<vector<int>> v;\\n        for(int i=0;i<n;i++){\\n            int k=0;\\n            for(int j=n-1;j>=0;j--){\\n                if(image[i][j]==1){\\n                v[i][k]=0;\\n                k++;}\\n                else{\\n                v[i][k]=1;\\n                k++;}\\n            }\\n        }\\n        return v;\\n        \\n    }\\n};\\n\\n\\nwhat\\'s the mistake in my code?(error int 9th line)"
                    },
                    {
                        "username": "bparanj",
                        "content": "The error in your code is because you are trying to access `v[i][k]` when it has not yet been initialized.\\n\\nThe `vector<vector<int>> v` is currently empty and has no elements. You can\\'t access `v[i][k]` directly without either initializing the size of `v` with the same size as `image` or using the `push_back()` function to add elements.\\n\\nHere\\'s how you can modify your code to fix the error. Notice how we use `push_back` to add elements to `v`:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        int n = image.size();\\n        vector<vector<int>> v;\\n\\n        for(int i = 0; i < n; i++){\\n            vector<int> row;\\n            for(int j = n - 1; j >= 0; j--){\\n                if(image[i][j] == 1){\\n                    row.push_back(0);\\n                } else {\\n                    row.push_back(1);\\n                }\\n            }\\n            v.push_back(row);\\n        }\\n        return v;\\n    }\\n};\\n```\\n\\nThis modified version of your code works as follows: for each row, we create a new empty vector `row`. We populate `row` by iterating over the corresponding row in `image` in reverse order, pushing `0` if the original number was `1`, and `1` otherwise. After we\\'re done with a row, we add it to the `v` vector with `v.push_back(row)`."
                    },
                    {
                        "username": "1rn21is163",
                        "content": "i also have same doubt"
                    },
                    {
                        "username": "himanshubanerji",
                        "content": "If I\\'m coding in c++ can I use stl function for partially solving these questions ? Like use reverse functions to horizontally flip ?? \\n\\nplease help as I\\'m really confused if this is a good practice or not "
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "[@Himanshu Banerji](/himanshubanerji) In general it is recommended to avoid in-built functions .. That will help to build the logic, else if someone is using in-built functions directly then the thinking ability and the logic building skills won't develop."
                    },
                    {
                        "username": "himanshubanerji",
                        "content": "[@Ritabrata_1080](/Ritabrata_1080) Can u tell like in general is is recommended practise while using it or not?\\n"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "Sure you can. But also make sure to check out other solutions without using STL."
                    }
                ]
            },
            {
                "id": 1984748,
                "content": [
                    {
                        "username": "mirand",
                        "content": "Hello, Why is there this much parameters for C implementation? Isn\\'t the matrix always square, so that the parameter should only be (int** A, int ARowSize) ? Thanks for your help"
                    },
                    {
                        "username": "Anurag8305",
                        "content": "No matrix is not always square. Sometimes you may see matrix of n*m size also."
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "A normal problem of matrix .. Just to keep in mind while inserting elements in the resultant matrix, at first we need to iterate each row of the given matrix in reverse direction..Next step is to change every position value.. i.e. change all 1\\'s to 0\\'s and 0\\'s to 1\\'s.. For more information please have a look at my solution posted in the solution tab --> "
                    },
                    {
                        "username": "leetcode89",
                        "content": "I have no idea why I can\\'t understand this problem and its under easy category.Can some one help me out in understanding?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem essentially has two parts:\\n\\n1. Flip the Image Horizontally: To flip an image horizontally means to reverse the order of elements in each row. For example, if a row in the matrix is [1, 0, 1], flipping this row would result in [1, 0, 1].\\n\\n2. Invert the Image: After flipping each row, you need to invert each element in each row, which simply means changing every 1 to 0 and every 0 to 1. For example, if a flipped row is [1, 0, 1], inverting this row would result in [0, 1, 0].\\n\\nLet\\'s take an example from the problem to understand this better:\\n\\nInput: image = [[1,1,0],[1,0,1],[0,0,0]]\\nOutput: [[1,0,0],[0,1,0],[1,1,1]]\\n\\nHere\\'s what happens step-by-step:\\n\\n- First, each row is reversed:\\n  - [1,1,0] becomes [0,1,1]\\n  - [1,0,1] becomes [1,0,1]\\n  - [0,0,0] becomes [0,0,0]\\n\\n- Then, each element in each row is inverted:\\n  - [0,1,1] becomes [1,0,0]\\n  - [1,0,1] becomes [0,1,0]\\n  - [0,0,0] becomes [1,1,1]\\n\\nSo, the final output is [[1,0,0],[0,1,0],[1,1,1]], which matches the expected output.\\n\\nThe challenge lies in implementing these steps efficiently in code. The task requires understanding of array manipulation and binary number manipulation (since we\\'re just dealing with 0s and 1s)."
                    },
                    {
                        "username": "Anurag8305",
                        "content": "Try using this approach.\\n1. first reverse the row value of each row.\\n2. then replace the 0\\'s with 1\\'s and vice-versa."
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "In simple terms, just consider the given 2D array as a matrix. Now perform 2 operations ->\\nOp 1: Invert each row ( i.e if a row has 101001 then do it as 100101)\\nOp 2 : Flip the bits in each row..i.e. make the 0\\'s in each row as 1 and 1\\'s as 0...."
                    },
                    {
                        "username": "mochiball",
                        "content": "Tip: No need to use extra space. Just perform the operations on the input image and return it "
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "yes\\n"
                    },
                    {
                        "username": "JavithSadhamHussain",
                        "content": "//Flippng of an 1-D array \n`\nfor(int left=0, right=array.length-1; left<=right; left++, right--)\n            {\n                int temp = array[left];\n                array[left] = array[right];\n                array[right] = temp;\n            }`\n\n"
                    },
                    {
                        "username": "sajidali56867",
                        "content": "hello it\\'s my first  comment in discussion  rather than taking a new array for result  , try to change the image row by reversing it "
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "    ```def flipAndInvertImage(self, image: List[List[int]]) -> List[List[int]]:\\n        t1 = [i[::-1] for i in image]\\n        for i in range(len(t1)):\\n            for j in range(len(t1[i])):\\n                if t1[i][j] ==0:\\n                    t1[i][j] = 1\\n                else:\\n                    t1[i][j] = 0\\n        return t1```"
                    },
                    {
                        "username": "AasthaSach29",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        \\n        for(int i=0;i<image.size();i++){\\n            for(int j=0;j<image[i].size()/2;j++){\\n                int t=(image[i].size())-j;\\n                swap(image[i][j],image[i][t]);\\n                if(image[i][j]==0){\\n                    image[i][j]=1;\\n                }\\n                else{\\n                    image[i][j]=0;\\n                }\\n             }\\n            \\n        }\\n        return image;\\n         \\n    }\\n};\\n\\n\\nWhy there is Runtime Error in this code??"
                    },
                    {
                        "username": "quarkyy99",
                        "content": "because of arrayindex out of bounds. when you initatize t.in first iteration t is equal to length of array which is 1 index ahead."
                    },
                    {
                        "username": "20euec070",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        int n=image.size();\\n       // int m=image[0].size();\\n        vector<vector<int>> v;\\n        for(int i=0;i<n;i++){\\n            int k=0;\\n            for(int j=n-1;j>=0;j--){\\n                if(image[i][j]==1){\\n                v[i][k]=0;\\n                k++;}\\n                else{\\n                v[i][k]=1;\\n                k++;}\\n            }\\n        }\\n        return v;\\n        \\n    }\\n};\\n\\n\\nwhat\\'s the mistake in my code?(error int 9th line)"
                    },
                    {
                        "username": "bparanj",
                        "content": "The error in your code is because you are trying to access `v[i][k]` when it has not yet been initialized.\\n\\nThe `vector<vector<int>> v` is currently empty and has no elements. You can\\'t access `v[i][k]` directly without either initializing the size of `v` with the same size as `image` or using the `push_back()` function to add elements.\\n\\nHere\\'s how you can modify your code to fix the error. Notice how we use `push_back` to add elements to `v`:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        int n = image.size();\\n        vector<vector<int>> v;\\n\\n        for(int i = 0; i < n; i++){\\n            vector<int> row;\\n            for(int j = n - 1; j >= 0; j--){\\n                if(image[i][j] == 1){\\n                    row.push_back(0);\\n                } else {\\n                    row.push_back(1);\\n                }\\n            }\\n            v.push_back(row);\\n        }\\n        return v;\\n    }\\n};\\n```\\n\\nThis modified version of your code works as follows: for each row, we create a new empty vector `row`. We populate `row` by iterating over the corresponding row in `image` in reverse order, pushing `0` if the original number was `1`, and `1` otherwise. After we\\'re done with a row, we add it to the `v` vector with `v.push_back(row)`."
                    },
                    {
                        "username": "1rn21is163",
                        "content": "i also have same doubt"
                    },
                    {
                        "username": "himanshubanerji",
                        "content": "If I\\'m coding in c++ can I use stl function for partially solving these questions ? Like use reverse functions to horizontally flip ?? \\n\\nplease help as I\\'m really confused if this is a good practice or not "
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "[@Himanshu Banerji](/himanshubanerji) In general it is recommended to avoid in-built functions .. That will help to build the logic, else if someone is using in-built functions directly then the thinking ability and the logic building skills won't develop."
                    },
                    {
                        "username": "himanshubanerji",
                        "content": "[@Ritabrata_1080](/Ritabrata_1080) Can u tell like in general is is recommended practise while using it or not?\\n"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "Sure you can. But also make sure to check out other solutions without using STL."
                    }
                ]
            },
            {
                "id": 1710712,
                "content": [
                    {
                        "username": "mirand",
                        "content": "Hello, Why is there this much parameters for C implementation? Isn\\'t the matrix always square, so that the parameter should only be (int** A, int ARowSize) ? Thanks for your help"
                    },
                    {
                        "username": "Anurag8305",
                        "content": "No matrix is not always square. Sometimes you may see matrix of n*m size also."
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "A normal problem of matrix .. Just to keep in mind while inserting elements in the resultant matrix, at first we need to iterate each row of the given matrix in reverse direction..Next step is to change every position value.. i.e. change all 1\\'s to 0\\'s and 0\\'s to 1\\'s.. For more information please have a look at my solution posted in the solution tab --> "
                    },
                    {
                        "username": "leetcode89",
                        "content": "I have no idea why I can\\'t understand this problem and its under easy category.Can some one help me out in understanding?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem essentially has two parts:\\n\\n1. Flip the Image Horizontally: To flip an image horizontally means to reverse the order of elements in each row. For example, if a row in the matrix is [1, 0, 1], flipping this row would result in [1, 0, 1].\\n\\n2. Invert the Image: After flipping each row, you need to invert each element in each row, which simply means changing every 1 to 0 and every 0 to 1. For example, if a flipped row is [1, 0, 1], inverting this row would result in [0, 1, 0].\\n\\nLet\\'s take an example from the problem to understand this better:\\n\\nInput: image = [[1,1,0],[1,0,1],[0,0,0]]\\nOutput: [[1,0,0],[0,1,0],[1,1,1]]\\n\\nHere\\'s what happens step-by-step:\\n\\n- First, each row is reversed:\\n  - [1,1,0] becomes [0,1,1]\\n  - [1,0,1] becomes [1,0,1]\\n  - [0,0,0] becomes [0,0,0]\\n\\n- Then, each element in each row is inverted:\\n  - [0,1,1] becomes [1,0,0]\\n  - [1,0,1] becomes [0,1,0]\\n  - [0,0,0] becomes [1,1,1]\\n\\nSo, the final output is [[1,0,0],[0,1,0],[1,1,1]], which matches the expected output.\\n\\nThe challenge lies in implementing these steps efficiently in code. The task requires understanding of array manipulation and binary number manipulation (since we\\'re just dealing with 0s and 1s)."
                    },
                    {
                        "username": "Anurag8305",
                        "content": "Try using this approach.\\n1. first reverse the row value of each row.\\n2. then replace the 0\\'s with 1\\'s and vice-versa."
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "In simple terms, just consider the given 2D array as a matrix. Now perform 2 operations ->\\nOp 1: Invert each row ( i.e if a row has 101001 then do it as 100101)\\nOp 2 : Flip the bits in each row..i.e. make the 0\\'s in each row as 1 and 1\\'s as 0...."
                    },
                    {
                        "username": "mochiball",
                        "content": "Tip: No need to use extra space. Just perform the operations on the input image and return it "
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "yes\\n"
                    },
                    {
                        "username": "JavithSadhamHussain",
                        "content": "//Flippng of an 1-D array \n`\nfor(int left=0, right=array.length-1; left<=right; left++, right--)\n            {\n                int temp = array[left];\n                array[left] = array[right];\n                array[right] = temp;\n            }`\n\n"
                    },
                    {
                        "username": "sajidali56867",
                        "content": "hello it\\'s my first  comment in discussion  rather than taking a new array for result  , try to change the image row by reversing it "
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "    ```def flipAndInvertImage(self, image: List[List[int]]) -> List[List[int]]:\\n        t1 = [i[::-1] for i in image]\\n        for i in range(len(t1)):\\n            for j in range(len(t1[i])):\\n                if t1[i][j] ==0:\\n                    t1[i][j] = 1\\n                else:\\n                    t1[i][j] = 0\\n        return t1```"
                    },
                    {
                        "username": "AasthaSach29",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        \\n        for(int i=0;i<image.size();i++){\\n            for(int j=0;j<image[i].size()/2;j++){\\n                int t=(image[i].size())-j;\\n                swap(image[i][j],image[i][t]);\\n                if(image[i][j]==0){\\n                    image[i][j]=1;\\n                }\\n                else{\\n                    image[i][j]=0;\\n                }\\n             }\\n            \\n        }\\n        return image;\\n         \\n    }\\n};\\n\\n\\nWhy there is Runtime Error in this code??"
                    },
                    {
                        "username": "quarkyy99",
                        "content": "because of arrayindex out of bounds. when you initatize t.in first iteration t is equal to length of array which is 1 index ahead."
                    },
                    {
                        "username": "20euec070",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        int n=image.size();\\n       // int m=image[0].size();\\n        vector<vector<int>> v;\\n        for(int i=0;i<n;i++){\\n            int k=0;\\n            for(int j=n-1;j>=0;j--){\\n                if(image[i][j]==1){\\n                v[i][k]=0;\\n                k++;}\\n                else{\\n                v[i][k]=1;\\n                k++;}\\n            }\\n        }\\n        return v;\\n        \\n    }\\n};\\n\\n\\nwhat\\'s the mistake in my code?(error int 9th line)"
                    },
                    {
                        "username": "bparanj",
                        "content": "The error in your code is because you are trying to access `v[i][k]` when it has not yet been initialized.\\n\\nThe `vector<vector<int>> v` is currently empty and has no elements. You can\\'t access `v[i][k]` directly without either initializing the size of `v` with the same size as `image` or using the `push_back()` function to add elements.\\n\\nHere\\'s how you can modify your code to fix the error. Notice how we use `push_back` to add elements to `v`:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        int n = image.size();\\n        vector<vector<int>> v;\\n\\n        for(int i = 0; i < n; i++){\\n            vector<int> row;\\n            for(int j = n - 1; j >= 0; j--){\\n                if(image[i][j] == 1){\\n                    row.push_back(0);\\n                } else {\\n                    row.push_back(1);\\n                }\\n            }\\n            v.push_back(row);\\n        }\\n        return v;\\n    }\\n};\\n```\\n\\nThis modified version of your code works as follows: for each row, we create a new empty vector `row`. We populate `row` by iterating over the corresponding row in `image` in reverse order, pushing `0` if the original number was `1`, and `1` otherwise. After we\\'re done with a row, we add it to the `v` vector with `v.push_back(row)`."
                    },
                    {
                        "username": "1rn21is163",
                        "content": "i also have same doubt"
                    },
                    {
                        "username": "himanshubanerji",
                        "content": "If I\\'m coding in c++ can I use stl function for partially solving these questions ? Like use reverse functions to horizontally flip ?? \\n\\nplease help as I\\'m really confused if this is a good practice or not "
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "[@Himanshu Banerji](/himanshubanerji) In general it is recommended to avoid in-built functions .. That will help to build the logic, else if someone is using in-built functions directly then the thinking ability and the logic building skills won't develop."
                    },
                    {
                        "username": "himanshubanerji",
                        "content": "[@Ritabrata_1080](/Ritabrata_1080) Can u tell like in general is is recommended practise while using it or not?\\n"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "Sure you can. But also make sure to check out other solutions without using STL."
                    }
                ]
            },
            {
                "id": 1916702,
                "content": [
                    {
                        "username": "mirand",
                        "content": "Hello, Why is there this much parameters for C implementation? Isn\\'t the matrix always square, so that the parameter should only be (int** A, int ARowSize) ? Thanks for your help"
                    },
                    {
                        "username": "Anurag8305",
                        "content": "No matrix is not always square. Sometimes you may see matrix of n*m size also."
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "A normal problem of matrix .. Just to keep in mind while inserting elements in the resultant matrix, at first we need to iterate each row of the given matrix in reverse direction..Next step is to change every position value.. i.e. change all 1\\'s to 0\\'s and 0\\'s to 1\\'s.. For more information please have a look at my solution posted in the solution tab --> "
                    },
                    {
                        "username": "leetcode89",
                        "content": "I have no idea why I can\\'t understand this problem and its under easy category.Can some one help me out in understanding?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem essentially has two parts:\\n\\n1. Flip the Image Horizontally: To flip an image horizontally means to reverse the order of elements in each row. For example, if a row in the matrix is [1, 0, 1], flipping this row would result in [1, 0, 1].\\n\\n2. Invert the Image: After flipping each row, you need to invert each element in each row, which simply means changing every 1 to 0 and every 0 to 1. For example, if a flipped row is [1, 0, 1], inverting this row would result in [0, 1, 0].\\n\\nLet\\'s take an example from the problem to understand this better:\\n\\nInput: image = [[1,1,0],[1,0,1],[0,0,0]]\\nOutput: [[1,0,0],[0,1,0],[1,1,1]]\\n\\nHere\\'s what happens step-by-step:\\n\\n- First, each row is reversed:\\n  - [1,1,0] becomes [0,1,1]\\n  - [1,0,1] becomes [1,0,1]\\n  - [0,0,0] becomes [0,0,0]\\n\\n- Then, each element in each row is inverted:\\n  - [0,1,1] becomes [1,0,0]\\n  - [1,0,1] becomes [0,1,0]\\n  - [0,0,0] becomes [1,1,1]\\n\\nSo, the final output is [[1,0,0],[0,1,0],[1,1,1]], which matches the expected output.\\n\\nThe challenge lies in implementing these steps efficiently in code. The task requires understanding of array manipulation and binary number manipulation (since we\\'re just dealing with 0s and 1s)."
                    },
                    {
                        "username": "Anurag8305",
                        "content": "Try using this approach.\\n1. first reverse the row value of each row.\\n2. then replace the 0\\'s with 1\\'s and vice-versa."
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "In simple terms, just consider the given 2D array as a matrix. Now perform 2 operations ->\\nOp 1: Invert each row ( i.e if a row has 101001 then do it as 100101)\\nOp 2 : Flip the bits in each row..i.e. make the 0\\'s in each row as 1 and 1\\'s as 0...."
                    },
                    {
                        "username": "mochiball",
                        "content": "Tip: No need to use extra space. Just perform the operations on the input image and return it "
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "yes\\n"
                    },
                    {
                        "username": "JavithSadhamHussain",
                        "content": "//Flippng of an 1-D array \n`\nfor(int left=0, right=array.length-1; left<=right; left++, right--)\n            {\n                int temp = array[left];\n                array[left] = array[right];\n                array[right] = temp;\n            }`\n\n"
                    },
                    {
                        "username": "sajidali56867",
                        "content": "hello it\\'s my first  comment in discussion  rather than taking a new array for result  , try to change the image row by reversing it "
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "    ```def flipAndInvertImage(self, image: List[List[int]]) -> List[List[int]]:\\n        t1 = [i[::-1] for i in image]\\n        for i in range(len(t1)):\\n            for j in range(len(t1[i])):\\n                if t1[i][j] ==0:\\n                    t1[i][j] = 1\\n                else:\\n                    t1[i][j] = 0\\n        return t1```"
                    },
                    {
                        "username": "AasthaSach29",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        \\n        for(int i=0;i<image.size();i++){\\n            for(int j=0;j<image[i].size()/2;j++){\\n                int t=(image[i].size())-j;\\n                swap(image[i][j],image[i][t]);\\n                if(image[i][j]==0){\\n                    image[i][j]=1;\\n                }\\n                else{\\n                    image[i][j]=0;\\n                }\\n             }\\n            \\n        }\\n        return image;\\n         \\n    }\\n};\\n\\n\\nWhy there is Runtime Error in this code??"
                    },
                    {
                        "username": "quarkyy99",
                        "content": "because of arrayindex out of bounds. when you initatize t.in first iteration t is equal to length of array which is 1 index ahead."
                    },
                    {
                        "username": "20euec070",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        int n=image.size();\\n       // int m=image[0].size();\\n        vector<vector<int>> v;\\n        for(int i=0;i<n;i++){\\n            int k=0;\\n            for(int j=n-1;j>=0;j--){\\n                if(image[i][j]==1){\\n                v[i][k]=0;\\n                k++;}\\n                else{\\n                v[i][k]=1;\\n                k++;}\\n            }\\n        }\\n        return v;\\n        \\n    }\\n};\\n\\n\\nwhat\\'s the mistake in my code?(error int 9th line)"
                    },
                    {
                        "username": "bparanj",
                        "content": "The error in your code is because you are trying to access `v[i][k]` when it has not yet been initialized.\\n\\nThe `vector<vector<int>> v` is currently empty and has no elements. You can\\'t access `v[i][k]` directly without either initializing the size of `v` with the same size as `image` or using the `push_back()` function to add elements.\\n\\nHere\\'s how you can modify your code to fix the error. Notice how we use `push_back` to add elements to `v`:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        int n = image.size();\\n        vector<vector<int>> v;\\n\\n        for(int i = 0; i < n; i++){\\n            vector<int> row;\\n            for(int j = n - 1; j >= 0; j--){\\n                if(image[i][j] == 1){\\n                    row.push_back(0);\\n                } else {\\n                    row.push_back(1);\\n                }\\n            }\\n            v.push_back(row);\\n        }\\n        return v;\\n    }\\n};\\n```\\n\\nThis modified version of your code works as follows: for each row, we create a new empty vector `row`. We populate `row` by iterating over the corresponding row in `image` in reverse order, pushing `0` if the original number was `1`, and `1` otherwise. After we\\'re done with a row, we add it to the `v` vector with `v.push_back(row)`."
                    },
                    {
                        "username": "1rn21is163",
                        "content": "i also have same doubt"
                    },
                    {
                        "username": "himanshubanerji",
                        "content": "If I\\'m coding in c++ can I use stl function for partially solving these questions ? Like use reverse functions to horizontally flip ?? \\n\\nplease help as I\\'m really confused if this is a good practice or not "
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "[@Himanshu Banerji](/himanshubanerji) In general it is recommended to avoid in-built functions .. That will help to build the logic, else if someone is using in-built functions directly then the thinking ability and the logic building skills won't develop."
                    },
                    {
                        "username": "himanshubanerji",
                        "content": "[@Ritabrata_1080](/Ritabrata_1080) Can u tell like in general is is recommended practise while using it or not?\\n"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "Sure you can. But also make sure to check out other solutions without using STL."
                    }
                ]
            },
            {
                "id": 1844702,
                "content": [
                    {
                        "username": "mirand",
                        "content": "Hello, Why is there this much parameters for C implementation? Isn\\'t the matrix always square, so that the parameter should only be (int** A, int ARowSize) ? Thanks for your help"
                    },
                    {
                        "username": "Anurag8305",
                        "content": "No matrix is not always square. Sometimes you may see matrix of n*m size also."
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "A normal problem of matrix .. Just to keep in mind while inserting elements in the resultant matrix, at first we need to iterate each row of the given matrix in reverse direction..Next step is to change every position value.. i.e. change all 1\\'s to 0\\'s and 0\\'s to 1\\'s.. For more information please have a look at my solution posted in the solution tab --> "
                    },
                    {
                        "username": "leetcode89",
                        "content": "I have no idea why I can\\'t understand this problem and its under easy category.Can some one help me out in understanding?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem essentially has two parts:\\n\\n1. Flip the Image Horizontally: To flip an image horizontally means to reverse the order of elements in each row. For example, if a row in the matrix is [1, 0, 1], flipping this row would result in [1, 0, 1].\\n\\n2. Invert the Image: After flipping each row, you need to invert each element in each row, which simply means changing every 1 to 0 and every 0 to 1. For example, if a flipped row is [1, 0, 1], inverting this row would result in [0, 1, 0].\\n\\nLet\\'s take an example from the problem to understand this better:\\n\\nInput: image = [[1,1,0],[1,0,1],[0,0,0]]\\nOutput: [[1,0,0],[0,1,0],[1,1,1]]\\n\\nHere\\'s what happens step-by-step:\\n\\n- First, each row is reversed:\\n  - [1,1,0] becomes [0,1,1]\\n  - [1,0,1] becomes [1,0,1]\\n  - [0,0,0] becomes [0,0,0]\\n\\n- Then, each element in each row is inverted:\\n  - [0,1,1] becomes [1,0,0]\\n  - [1,0,1] becomes [0,1,0]\\n  - [0,0,0] becomes [1,1,1]\\n\\nSo, the final output is [[1,0,0],[0,1,0],[1,1,1]], which matches the expected output.\\n\\nThe challenge lies in implementing these steps efficiently in code. The task requires understanding of array manipulation and binary number manipulation (since we\\'re just dealing with 0s and 1s)."
                    },
                    {
                        "username": "Anurag8305",
                        "content": "Try using this approach.\\n1. first reverse the row value of each row.\\n2. then replace the 0\\'s with 1\\'s and vice-versa."
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "In simple terms, just consider the given 2D array as a matrix. Now perform 2 operations ->\\nOp 1: Invert each row ( i.e if a row has 101001 then do it as 100101)\\nOp 2 : Flip the bits in each row..i.e. make the 0\\'s in each row as 1 and 1\\'s as 0...."
                    },
                    {
                        "username": "mochiball",
                        "content": "Tip: No need to use extra space. Just perform the operations on the input image and return it "
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "yes\\n"
                    },
                    {
                        "username": "JavithSadhamHussain",
                        "content": "//Flippng of an 1-D array \n`\nfor(int left=0, right=array.length-1; left<=right; left++, right--)\n            {\n                int temp = array[left];\n                array[left] = array[right];\n                array[right] = temp;\n            }`\n\n"
                    },
                    {
                        "username": "sajidali56867",
                        "content": "hello it\\'s my first  comment in discussion  rather than taking a new array for result  , try to change the image row by reversing it "
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "    ```def flipAndInvertImage(self, image: List[List[int]]) -> List[List[int]]:\\n        t1 = [i[::-1] for i in image]\\n        for i in range(len(t1)):\\n            for j in range(len(t1[i])):\\n                if t1[i][j] ==0:\\n                    t1[i][j] = 1\\n                else:\\n                    t1[i][j] = 0\\n        return t1```"
                    },
                    {
                        "username": "AasthaSach29",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        \\n        for(int i=0;i<image.size();i++){\\n            for(int j=0;j<image[i].size()/2;j++){\\n                int t=(image[i].size())-j;\\n                swap(image[i][j],image[i][t]);\\n                if(image[i][j]==0){\\n                    image[i][j]=1;\\n                }\\n                else{\\n                    image[i][j]=0;\\n                }\\n             }\\n            \\n        }\\n        return image;\\n         \\n    }\\n};\\n\\n\\nWhy there is Runtime Error in this code??"
                    },
                    {
                        "username": "quarkyy99",
                        "content": "because of arrayindex out of bounds. when you initatize t.in first iteration t is equal to length of array which is 1 index ahead."
                    },
                    {
                        "username": "20euec070",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        int n=image.size();\\n       // int m=image[0].size();\\n        vector<vector<int>> v;\\n        for(int i=0;i<n;i++){\\n            int k=0;\\n            for(int j=n-1;j>=0;j--){\\n                if(image[i][j]==1){\\n                v[i][k]=0;\\n                k++;}\\n                else{\\n                v[i][k]=1;\\n                k++;}\\n            }\\n        }\\n        return v;\\n        \\n    }\\n};\\n\\n\\nwhat\\'s the mistake in my code?(error int 9th line)"
                    },
                    {
                        "username": "bparanj",
                        "content": "The error in your code is because you are trying to access `v[i][k]` when it has not yet been initialized.\\n\\nThe `vector<vector<int>> v` is currently empty and has no elements. You can\\'t access `v[i][k]` directly without either initializing the size of `v` with the same size as `image` or using the `push_back()` function to add elements.\\n\\nHere\\'s how you can modify your code to fix the error. Notice how we use `push_back` to add elements to `v`:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        int n = image.size();\\n        vector<vector<int>> v;\\n\\n        for(int i = 0; i < n; i++){\\n            vector<int> row;\\n            for(int j = n - 1; j >= 0; j--){\\n                if(image[i][j] == 1){\\n                    row.push_back(0);\\n                } else {\\n                    row.push_back(1);\\n                }\\n            }\\n            v.push_back(row);\\n        }\\n        return v;\\n    }\\n};\\n```\\n\\nThis modified version of your code works as follows: for each row, we create a new empty vector `row`. We populate `row` by iterating over the corresponding row in `image` in reverse order, pushing `0` if the original number was `1`, and `1` otherwise. After we\\'re done with a row, we add it to the `v` vector with `v.push_back(row)`."
                    },
                    {
                        "username": "1rn21is163",
                        "content": "i also have same doubt"
                    },
                    {
                        "username": "himanshubanerji",
                        "content": "If I\\'m coding in c++ can I use stl function for partially solving these questions ? Like use reverse functions to horizontally flip ?? \\n\\nplease help as I\\'m really confused if this is a good practice or not "
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "[@Himanshu Banerji](/himanshubanerji) In general it is recommended to avoid in-built functions .. That will help to build the logic, else if someone is using in-built functions directly then the thinking ability and the logic building skills won't develop."
                    },
                    {
                        "username": "himanshubanerji",
                        "content": "[@Ritabrata_1080](/Ritabrata_1080) Can u tell like in general is is recommended practise while using it or not?\\n"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "Sure you can. But also make sure to check out other solutions without using STL."
                    }
                ]
            },
            {
                "id": 1787276,
                "content": [
                    {
                        "username": "mirand",
                        "content": "Hello, Why is there this much parameters for C implementation? Isn\\'t the matrix always square, so that the parameter should only be (int** A, int ARowSize) ? Thanks for your help"
                    },
                    {
                        "username": "Anurag8305",
                        "content": "No matrix is not always square. Sometimes you may see matrix of n*m size also."
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "A normal problem of matrix .. Just to keep in mind while inserting elements in the resultant matrix, at first we need to iterate each row of the given matrix in reverse direction..Next step is to change every position value.. i.e. change all 1\\'s to 0\\'s and 0\\'s to 1\\'s.. For more information please have a look at my solution posted in the solution tab --> "
                    },
                    {
                        "username": "leetcode89",
                        "content": "I have no idea why I can\\'t understand this problem and its under easy category.Can some one help me out in understanding?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem essentially has two parts:\\n\\n1. Flip the Image Horizontally: To flip an image horizontally means to reverse the order of elements in each row. For example, if a row in the matrix is [1, 0, 1], flipping this row would result in [1, 0, 1].\\n\\n2. Invert the Image: After flipping each row, you need to invert each element in each row, which simply means changing every 1 to 0 and every 0 to 1. For example, if a flipped row is [1, 0, 1], inverting this row would result in [0, 1, 0].\\n\\nLet\\'s take an example from the problem to understand this better:\\n\\nInput: image = [[1,1,0],[1,0,1],[0,0,0]]\\nOutput: [[1,0,0],[0,1,0],[1,1,1]]\\n\\nHere\\'s what happens step-by-step:\\n\\n- First, each row is reversed:\\n  - [1,1,0] becomes [0,1,1]\\n  - [1,0,1] becomes [1,0,1]\\n  - [0,0,0] becomes [0,0,0]\\n\\n- Then, each element in each row is inverted:\\n  - [0,1,1] becomes [1,0,0]\\n  - [1,0,1] becomes [0,1,0]\\n  - [0,0,0] becomes [1,1,1]\\n\\nSo, the final output is [[1,0,0],[0,1,0],[1,1,1]], which matches the expected output.\\n\\nThe challenge lies in implementing these steps efficiently in code. The task requires understanding of array manipulation and binary number manipulation (since we\\'re just dealing with 0s and 1s)."
                    },
                    {
                        "username": "Anurag8305",
                        "content": "Try using this approach.\\n1. first reverse the row value of each row.\\n2. then replace the 0\\'s with 1\\'s and vice-versa."
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "In simple terms, just consider the given 2D array as a matrix. Now perform 2 operations ->\\nOp 1: Invert each row ( i.e if a row has 101001 then do it as 100101)\\nOp 2 : Flip the bits in each row..i.e. make the 0\\'s in each row as 1 and 1\\'s as 0...."
                    },
                    {
                        "username": "mochiball",
                        "content": "Tip: No need to use extra space. Just perform the operations on the input image and return it "
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "yes\\n"
                    },
                    {
                        "username": "JavithSadhamHussain",
                        "content": "//Flippng of an 1-D array \n`\nfor(int left=0, right=array.length-1; left<=right; left++, right--)\n            {\n                int temp = array[left];\n                array[left] = array[right];\n                array[right] = temp;\n            }`\n\n"
                    },
                    {
                        "username": "sajidali56867",
                        "content": "hello it\\'s my first  comment in discussion  rather than taking a new array for result  , try to change the image row by reversing it "
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "    ```def flipAndInvertImage(self, image: List[List[int]]) -> List[List[int]]:\\n        t1 = [i[::-1] for i in image]\\n        for i in range(len(t1)):\\n            for j in range(len(t1[i])):\\n                if t1[i][j] ==0:\\n                    t1[i][j] = 1\\n                else:\\n                    t1[i][j] = 0\\n        return t1```"
                    },
                    {
                        "username": "AasthaSach29",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        \\n        for(int i=0;i<image.size();i++){\\n            for(int j=0;j<image[i].size()/2;j++){\\n                int t=(image[i].size())-j;\\n                swap(image[i][j],image[i][t]);\\n                if(image[i][j]==0){\\n                    image[i][j]=1;\\n                }\\n                else{\\n                    image[i][j]=0;\\n                }\\n             }\\n            \\n        }\\n        return image;\\n         \\n    }\\n};\\n\\n\\nWhy there is Runtime Error in this code??"
                    },
                    {
                        "username": "quarkyy99",
                        "content": "because of arrayindex out of bounds. when you initatize t.in first iteration t is equal to length of array which is 1 index ahead."
                    },
                    {
                        "username": "20euec070",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        int n=image.size();\\n       // int m=image[0].size();\\n        vector<vector<int>> v;\\n        for(int i=0;i<n;i++){\\n            int k=0;\\n            for(int j=n-1;j>=0;j--){\\n                if(image[i][j]==1){\\n                v[i][k]=0;\\n                k++;}\\n                else{\\n                v[i][k]=1;\\n                k++;}\\n            }\\n        }\\n        return v;\\n        \\n    }\\n};\\n\\n\\nwhat\\'s the mistake in my code?(error int 9th line)"
                    },
                    {
                        "username": "bparanj",
                        "content": "The error in your code is because you are trying to access `v[i][k]` when it has not yet been initialized.\\n\\nThe `vector<vector<int>> v` is currently empty and has no elements. You can\\'t access `v[i][k]` directly without either initializing the size of `v` with the same size as `image` or using the `push_back()` function to add elements.\\n\\nHere\\'s how you can modify your code to fix the error. Notice how we use `push_back` to add elements to `v`:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        int n = image.size();\\n        vector<vector<int>> v;\\n\\n        for(int i = 0; i < n; i++){\\n            vector<int> row;\\n            for(int j = n - 1; j >= 0; j--){\\n                if(image[i][j] == 1){\\n                    row.push_back(0);\\n                } else {\\n                    row.push_back(1);\\n                }\\n            }\\n            v.push_back(row);\\n        }\\n        return v;\\n    }\\n};\\n```\\n\\nThis modified version of your code works as follows: for each row, we create a new empty vector `row`. We populate `row` by iterating over the corresponding row in `image` in reverse order, pushing `0` if the original number was `1`, and `1` otherwise. After we\\'re done with a row, we add it to the `v` vector with `v.push_back(row)`."
                    },
                    {
                        "username": "1rn21is163",
                        "content": "i also have same doubt"
                    },
                    {
                        "username": "himanshubanerji",
                        "content": "If I\\'m coding in c++ can I use stl function for partially solving these questions ? Like use reverse functions to horizontally flip ?? \\n\\nplease help as I\\'m really confused if this is a good practice or not "
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "[@Himanshu Banerji](/himanshubanerji) In general it is recommended to avoid in-built functions .. That will help to build the logic, else if someone is using in-built functions directly then the thinking ability and the logic building skills won't develop."
                    },
                    {
                        "username": "himanshubanerji",
                        "content": "[@Ritabrata_1080](/Ritabrata_1080) Can u tell like in general is is recommended practise while using it or not?\\n"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "Sure you can. But also make sure to check out other solutions without using STL."
                    }
                ]
            },
            {
                "id": 1743797,
                "content": [
                    {
                        "username": "mirand",
                        "content": "Hello, Why is there this much parameters for C implementation? Isn\\'t the matrix always square, so that the parameter should only be (int** A, int ARowSize) ? Thanks for your help"
                    },
                    {
                        "username": "Anurag8305",
                        "content": "No matrix is not always square. Sometimes you may see matrix of n*m size also."
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "A normal problem of matrix .. Just to keep in mind while inserting elements in the resultant matrix, at first we need to iterate each row of the given matrix in reverse direction..Next step is to change every position value.. i.e. change all 1\\'s to 0\\'s and 0\\'s to 1\\'s.. For more information please have a look at my solution posted in the solution tab --> "
                    },
                    {
                        "username": "leetcode89",
                        "content": "I have no idea why I can\\'t understand this problem and its under easy category.Can some one help me out in understanding?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem essentially has two parts:\\n\\n1. Flip the Image Horizontally: To flip an image horizontally means to reverse the order of elements in each row. For example, if a row in the matrix is [1, 0, 1], flipping this row would result in [1, 0, 1].\\n\\n2. Invert the Image: After flipping each row, you need to invert each element in each row, which simply means changing every 1 to 0 and every 0 to 1. For example, if a flipped row is [1, 0, 1], inverting this row would result in [0, 1, 0].\\n\\nLet\\'s take an example from the problem to understand this better:\\n\\nInput: image = [[1,1,0],[1,0,1],[0,0,0]]\\nOutput: [[1,0,0],[0,1,0],[1,1,1]]\\n\\nHere\\'s what happens step-by-step:\\n\\n- First, each row is reversed:\\n  - [1,1,0] becomes [0,1,1]\\n  - [1,0,1] becomes [1,0,1]\\n  - [0,0,0] becomes [0,0,0]\\n\\n- Then, each element in each row is inverted:\\n  - [0,1,1] becomes [1,0,0]\\n  - [1,0,1] becomes [0,1,0]\\n  - [0,0,0] becomes [1,1,1]\\n\\nSo, the final output is [[1,0,0],[0,1,0],[1,1,1]], which matches the expected output.\\n\\nThe challenge lies in implementing these steps efficiently in code. The task requires understanding of array manipulation and binary number manipulation (since we\\'re just dealing with 0s and 1s)."
                    },
                    {
                        "username": "Anurag8305",
                        "content": "Try using this approach.\\n1. first reverse the row value of each row.\\n2. then replace the 0\\'s with 1\\'s and vice-versa."
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "In simple terms, just consider the given 2D array as a matrix. Now perform 2 operations ->\\nOp 1: Invert each row ( i.e if a row has 101001 then do it as 100101)\\nOp 2 : Flip the bits in each row..i.e. make the 0\\'s in each row as 1 and 1\\'s as 0...."
                    },
                    {
                        "username": "mochiball",
                        "content": "Tip: No need to use extra space. Just perform the operations on the input image and return it "
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "yes\\n"
                    },
                    {
                        "username": "JavithSadhamHussain",
                        "content": "//Flippng of an 1-D array \n`\nfor(int left=0, right=array.length-1; left<=right; left++, right--)\n            {\n                int temp = array[left];\n                array[left] = array[right];\n                array[right] = temp;\n            }`\n\n"
                    },
                    {
                        "username": "sajidali56867",
                        "content": "hello it\\'s my first  comment in discussion  rather than taking a new array for result  , try to change the image row by reversing it "
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "    ```def flipAndInvertImage(self, image: List[List[int]]) -> List[List[int]]:\\n        t1 = [i[::-1] for i in image]\\n        for i in range(len(t1)):\\n            for j in range(len(t1[i])):\\n                if t1[i][j] ==0:\\n                    t1[i][j] = 1\\n                else:\\n                    t1[i][j] = 0\\n        return t1```"
                    },
                    {
                        "username": "AasthaSach29",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        \\n        for(int i=0;i<image.size();i++){\\n            for(int j=0;j<image[i].size()/2;j++){\\n                int t=(image[i].size())-j;\\n                swap(image[i][j],image[i][t]);\\n                if(image[i][j]==0){\\n                    image[i][j]=1;\\n                }\\n                else{\\n                    image[i][j]=0;\\n                }\\n             }\\n            \\n        }\\n        return image;\\n         \\n    }\\n};\\n\\n\\nWhy there is Runtime Error in this code??"
                    },
                    {
                        "username": "quarkyy99",
                        "content": "because of arrayindex out of bounds. when you initatize t.in first iteration t is equal to length of array which is 1 index ahead."
                    },
                    {
                        "username": "20euec070",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        int n=image.size();\\n       // int m=image[0].size();\\n        vector<vector<int>> v;\\n        for(int i=0;i<n;i++){\\n            int k=0;\\n            for(int j=n-1;j>=0;j--){\\n                if(image[i][j]==1){\\n                v[i][k]=0;\\n                k++;}\\n                else{\\n                v[i][k]=1;\\n                k++;}\\n            }\\n        }\\n        return v;\\n        \\n    }\\n};\\n\\n\\nwhat\\'s the mistake in my code?(error int 9th line)"
                    },
                    {
                        "username": "bparanj",
                        "content": "The error in your code is because you are trying to access `v[i][k]` when it has not yet been initialized.\\n\\nThe `vector<vector<int>> v` is currently empty and has no elements. You can\\'t access `v[i][k]` directly without either initializing the size of `v` with the same size as `image` or using the `push_back()` function to add elements.\\n\\nHere\\'s how you can modify your code to fix the error. Notice how we use `push_back` to add elements to `v`:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        int n = image.size();\\n        vector<vector<int>> v;\\n\\n        for(int i = 0; i < n; i++){\\n            vector<int> row;\\n            for(int j = n - 1; j >= 0; j--){\\n                if(image[i][j] == 1){\\n                    row.push_back(0);\\n                } else {\\n                    row.push_back(1);\\n                }\\n            }\\n            v.push_back(row);\\n        }\\n        return v;\\n    }\\n};\\n```\\n\\nThis modified version of your code works as follows: for each row, we create a new empty vector `row`. We populate `row` by iterating over the corresponding row in `image` in reverse order, pushing `0` if the original number was `1`, and `1` otherwise. After we\\'re done with a row, we add it to the `v` vector with `v.push_back(row)`."
                    },
                    {
                        "username": "1rn21is163",
                        "content": "i also have same doubt"
                    },
                    {
                        "username": "himanshubanerji",
                        "content": "If I\\'m coding in c++ can I use stl function for partially solving these questions ? Like use reverse functions to horizontally flip ?? \\n\\nplease help as I\\'m really confused if this is a good practice or not "
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "[@Himanshu Banerji](/himanshubanerji) In general it is recommended to avoid in-built functions .. That will help to build the logic, else if someone is using in-built functions directly then the thinking ability and the logic building skills won't develop."
                    },
                    {
                        "username": "himanshubanerji",
                        "content": "[@Ritabrata_1080](/Ritabrata_1080) Can u tell like in general is is recommended practise while using it or not?\\n"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "Sure you can. But also make sure to check out other solutions without using STL."
                    }
                ]
            },
            {
                "id": 1740762,
                "content": [
                    {
                        "username": "mirand",
                        "content": "Hello, Why is there this much parameters for C implementation? Isn\\'t the matrix always square, so that the parameter should only be (int** A, int ARowSize) ? Thanks for your help"
                    },
                    {
                        "username": "Anurag8305",
                        "content": "No matrix is not always square. Sometimes you may see matrix of n*m size also."
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "A normal problem of matrix .. Just to keep in mind while inserting elements in the resultant matrix, at first we need to iterate each row of the given matrix in reverse direction..Next step is to change every position value.. i.e. change all 1\\'s to 0\\'s and 0\\'s to 1\\'s.. For more information please have a look at my solution posted in the solution tab --> "
                    },
                    {
                        "username": "leetcode89",
                        "content": "I have no idea why I can\\'t understand this problem and its under easy category.Can some one help me out in understanding?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem essentially has two parts:\\n\\n1. Flip the Image Horizontally: To flip an image horizontally means to reverse the order of elements in each row. For example, if a row in the matrix is [1, 0, 1], flipping this row would result in [1, 0, 1].\\n\\n2. Invert the Image: After flipping each row, you need to invert each element in each row, which simply means changing every 1 to 0 and every 0 to 1. For example, if a flipped row is [1, 0, 1], inverting this row would result in [0, 1, 0].\\n\\nLet\\'s take an example from the problem to understand this better:\\n\\nInput: image = [[1,1,0],[1,0,1],[0,0,0]]\\nOutput: [[1,0,0],[0,1,0],[1,1,1]]\\n\\nHere\\'s what happens step-by-step:\\n\\n- First, each row is reversed:\\n  - [1,1,0] becomes [0,1,1]\\n  - [1,0,1] becomes [1,0,1]\\n  - [0,0,0] becomes [0,0,0]\\n\\n- Then, each element in each row is inverted:\\n  - [0,1,1] becomes [1,0,0]\\n  - [1,0,1] becomes [0,1,0]\\n  - [0,0,0] becomes [1,1,1]\\n\\nSo, the final output is [[1,0,0],[0,1,0],[1,1,1]], which matches the expected output.\\n\\nThe challenge lies in implementing these steps efficiently in code. The task requires understanding of array manipulation and binary number manipulation (since we\\'re just dealing with 0s and 1s)."
                    },
                    {
                        "username": "Anurag8305",
                        "content": "Try using this approach.\\n1. first reverse the row value of each row.\\n2. then replace the 0\\'s with 1\\'s and vice-versa."
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "In simple terms, just consider the given 2D array as a matrix. Now perform 2 operations ->\\nOp 1: Invert each row ( i.e if a row has 101001 then do it as 100101)\\nOp 2 : Flip the bits in each row..i.e. make the 0\\'s in each row as 1 and 1\\'s as 0...."
                    },
                    {
                        "username": "mochiball",
                        "content": "Tip: No need to use extra space. Just perform the operations on the input image and return it "
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "yes\\n"
                    },
                    {
                        "username": "JavithSadhamHussain",
                        "content": "//Flippng of an 1-D array \n`\nfor(int left=0, right=array.length-1; left<=right; left++, right--)\n            {\n                int temp = array[left];\n                array[left] = array[right];\n                array[right] = temp;\n            }`\n\n"
                    },
                    {
                        "username": "sajidali56867",
                        "content": "hello it\\'s my first  comment in discussion  rather than taking a new array for result  , try to change the image row by reversing it "
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "    ```def flipAndInvertImage(self, image: List[List[int]]) -> List[List[int]]:\\n        t1 = [i[::-1] for i in image]\\n        for i in range(len(t1)):\\n            for j in range(len(t1[i])):\\n                if t1[i][j] ==0:\\n                    t1[i][j] = 1\\n                else:\\n                    t1[i][j] = 0\\n        return t1```"
                    },
                    {
                        "username": "AasthaSach29",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        \\n        for(int i=0;i<image.size();i++){\\n            for(int j=0;j<image[i].size()/2;j++){\\n                int t=(image[i].size())-j;\\n                swap(image[i][j],image[i][t]);\\n                if(image[i][j]==0){\\n                    image[i][j]=1;\\n                }\\n                else{\\n                    image[i][j]=0;\\n                }\\n             }\\n            \\n        }\\n        return image;\\n         \\n    }\\n};\\n\\n\\nWhy there is Runtime Error in this code??"
                    },
                    {
                        "username": "quarkyy99",
                        "content": "because of arrayindex out of bounds. when you initatize t.in first iteration t is equal to length of array which is 1 index ahead."
                    },
                    {
                        "username": "20euec070",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        int n=image.size();\\n       // int m=image[0].size();\\n        vector<vector<int>> v;\\n        for(int i=0;i<n;i++){\\n            int k=0;\\n            for(int j=n-1;j>=0;j--){\\n                if(image[i][j]==1){\\n                v[i][k]=0;\\n                k++;}\\n                else{\\n                v[i][k]=1;\\n                k++;}\\n            }\\n        }\\n        return v;\\n        \\n    }\\n};\\n\\n\\nwhat\\'s the mistake in my code?(error int 9th line)"
                    },
                    {
                        "username": "bparanj",
                        "content": "The error in your code is because you are trying to access `v[i][k]` when it has not yet been initialized.\\n\\nThe `vector<vector<int>> v` is currently empty and has no elements. You can\\'t access `v[i][k]` directly without either initializing the size of `v` with the same size as `image` or using the `push_back()` function to add elements.\\n\\nHere\\'s how you can modify your code to fix the error. Notice how we use `push_back` to add elements to `v`:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\\n        int n = image.size();\\n        vector<vector<int>> v;\\n\\n        for(int i = 0; i < n; i++){\\n            vector<int> row;\\n            for(int j = n - 1; j >= 0; j--){\\n                if(image[i][j] == 1){\\n                    row.push_back(0);\\n                } else {\\n                    row.push_back(1);\\n                }\\n            }\\n            v.push_back(row);\\n        }\\n        return v;\\n    }\\n};\\n```\\n\\nThis modified version of your code works as follows: for each row, we create a new empty vector `row`. We populate `row` by iterating over the corresponding row in `image` in reverse order, pushing `0` if the original number was `1`, and `1` otherwise. After we\\'re done with a row, we add it to the `v` vector with `v.push_back(row)`."
                    },
                    {
                        "username": "1rn21is163",
                        "content": "i also have same doubt"
                    },
                    {
                        "username": "himanshubanerji",
                        "content": "If I\\'m coding in c++ can I use stl function for partially solving these questions ? Like use reverse functions to horizontally flip ?? \\n\\nplease help as I\\'m really confused if this is a good practice or not "
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "[@Himanshu Banerji](/himanshubanerji) In general it is recommended to avoid in-built functions .. That will help to build the logic, else if someone is using in-built functions directly then the thinking ability and the logic building skills won't develop."
                    },
                    {
                        "username": "himanshubanerji",
                        "content": "[@Ritabrata_1080](/Ritabrata_1080) Can u tell like in general is is recommended practise while using it or not?\\n"
                    },
                    {
                        "username": "Ritabrata_1080",
                        "content": "Sure you can. But also make sure to check out other solutions without using STL."
                    }
                ]
            }
        ]
    },
    {
        "title": "Minimum Moves to Reach Target with Rotations",
        "question_content": "<p>In an&nbsp;<code>n*n</code>&nbsp;grid, there is a snake that spans 2 cells and starts moving from the top left corner at <code>(0, 0)</code> and <code>(0, 1)</code>. The grid has empty cells represented by zeros and blocked cells represented by ones. The snake wants to reach the lower right corner at&nbsp;<code>(n-1, n-2)</code>&nbsp;and&nbsp;<code>(n-1, n-1)</code>.</p>\n\n<p>In one move the snake can:</p>\n\n<ul>\n\t<li>Move one cell to the right&nbsp;if there are no blocked cells there. This move keeps the horizontal/vertical position of the snake as it is.</li>\n\t<li>Move down one cell&nbsp;if there are no blocked cells there. This move keeps the horizontal/vertical position of the snake as it is.</li>\n\t<li>Rotate clockwise if it&#39;s in a horizontal position and the two cells under it are both empty. In that case the snake moves from&nbsp;<code>(r, c)</code>&nbsp;and&nbsp;<code>(r, c+1)</code>&nbsp;to&nbsp;<code>(r, c)</code>&nbsp;and&nbsp;<code>(r+1, c)</code>.<br />\n\t<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/09/24/image-2.png\" style=\"width: 300px; height: 134px;\" /></li>\n\t<li>Rotate counterclockwise&nbsp;if it&#39;s in a vertical position and the two cells to its right are both empty. In that case the snake moves from&nbsp;<code>(r, c)</code>&nbsp;and&nbsp;<code>(r+1, c)</code>&nbsp;to&nbsp;<code>(r, c)</code>&nbsp;and&nbsp;<code>(r, c+1)</code>.<br />\n\t<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/09/24/image-1.png\" style=\"width: 300px; height: 121px;\" /></li>\n</ul>\n\n<p>Return the minimum number of moves to reach the target.</p>\n\n<p>If there is no way to reach the target, return&nbsp;<code>-1</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/09/24/image.png\" style=\"width: 400px; height: 439px;\" /></strong></p>\n\n<pre>\n<strong>Input:</strong> grid = [[0,0,0,0,0,1],\n               [1,1,0,0,1,0],\n&nbsp;              [0,0,0,0,1,1],\n&nbsp;              [0,0,1,0,1,0],\n&nbsp;              [0,1,1,0,0,0],\n&nbsp;              [0,1,1,0,0,0]]\n<strong>Output:</strong> 11\n<strong>Explanation:\n</strong>One possible solution is [right, right, rotate clockwise, right, down, down, down, down, rotate counterclockwise, right, down].\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> grid = [[0,0,1,1,1,1],\n&nbsp;              [0,0,0,0,1,1],\n&nbsp;              [1,1,0,0,0,1],\n&nbsp;              [1,1,1,0,0,1],\n&nbsp;              [1,1,1,0,0,1],\n&nbsp;              [1,1,1,0,0,0]]\n<strong>Output:</strong> 9\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= n &lt;= 100</code></li>\n\t<li><code>0 &lt;= grid[i][j] &lt;= 1</code></li>\n\t<li>It is guaranteed that the snake starts at empty cells.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 392940,
                "title": "python-level-by-level-bfs-solution-similar-problems-listed",
                "content": "Level-by-level BFS visit can be used to solve a lot of problems of finding discrete shortest distance.\\nPlease see and vote for my solutions for these similar problems\\n[102. Binary Tree Level Order Traversal](https://leetcode.com/problems/binary-tree-level-order-traversal/discuss/1651394/Python-level-by-level-BFS-Solution)\\n[127. Word Ladder](https://leetcode.com/problems/word-ladder/discuss/352659/Simple-Python-BFS-solution)\\n[126. Word Ladder II](https://leetcode.com/problems/word-ladder-ii/discuss/352661/Simple-Python-BFS-solution)\\n[301. Remove Invalid Parentheses](https://leetcode.com/problems/remove-invalid-parentheses/discuss/327481/Python-DFS-solution-with-pruning-(28-ms-beat-99.56)-%2B-BFS-solution)\\n[317. Shortest Distance from All Buildings](https://leetcode.com/problems/shortest-distance-from-all-buildings/discuss/331983/Python-BFS-solution-(52-ms-beat-98.27))\\n[529. Minesweeper](https://leetcode.com/problems/minesweeper/discuss/1651414/python-level-by-level-bfs-solution)\\n[773. Sliding Puzzle](https://leetcode.com/problems/sliding-puzzle/discuss/412586/Standard-Python-BFS-solution-(level-by-level-traversal))\\n[815. Bus Routes](https://leetcode.com/problems/bus-routes/discuss/1651399/Python-Level-by-level-BFS-solution)\\n[854. K-Similar Strings](https://leetcode.com/problems/k-similar-strings/discuss/420506/Python-BFS-solution)\\n[864. Shortest Path to Get All Keys](https://leetcode.com/problems/shortest-path-to-get-all-keys/discuss/364604/Simple-Python-BFS-Solution-(292-ms-beat-97.78))\\n[1091. Shortest Path in Binary Matrix](https://leetcode.com/problems/shortest-path-in-binary-matrix/discuss/313229/Python-BFS-solution)\\n[1210. Minimum Moves to Reach Target with Rotations](https://leetcode.com/problems/minimum-moves-to-reach-target-with-rotations/discuss/392940/Standard-Python-BFS-solution)\\n[1263. Minimum Moves to Move a Box to Their Target Location](https://leetcode.com/problems/minimum-moves-to-move-a-box-to-their-target-location/discuss/431138/Python-straightforward-BFS-solution)\\n[1293. Shortest Path in a Grid with Obstacles Elimination](https://leetcode.com/problems/shortest-path-in-a-grid-with-obstacles-elimination/discuss/1651383/Python-level-by-level-BFS-Solution)\\n\\n\\n```\\n    def minimumMoves(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n        start = (0, 0, 0, 1)\\n        end = (n - 1, n - 2, n - 1, n - 1)\\n        curr_level = {start}\\n        moves = 0\\n        visited = set()\\n        while curr_level:\\n            if end in curr_level:\\n                return moves\\n            next_level = set()\\n            for pos in curr_level:\\n                visited.add(pos)\\n                r1, c1, r2, c2 = pos\\n                if c1 + 1 < n and grid[r1][c1+1] == 0 and c2 + 1 < n and grid[r2][c2+1] == 0:\\n                    if (r1, c1 + 1, r2, c2 + 1) not in visited:\\n                        next_level.add((r1, c1 + 1, r2, c2 + 1))\\n                if r1 + 1 < n and grid[r1+1][c1] == 0 and r2 + 1 < n and grid[r2+1][c2] == 0:\\n                    if (r1 + 1, c1, r2 + 1, c1) not in visited:\\n                        next_level.add((r1 + 1, c1, r2 + 1, c2))\\n                if r1 == r2 and c2 == c1 + 1 and r1 + 1 < n and grid[r1+1][c1] + grid[r1+1][c1+1] == 0 :\\n                    if (r1, c1, r1 + 1, c1) not in visited:\\n                        next_level.add((r1, c1, r1 + 1, c1))\\n                if c1 == c2 and r2 == r1 + 1 and c1 + 1 < n and grid[r1][c1+1] + grid[r1+1][c1+1] == 0:\\n                    if (r1, c1, r1, c1 + 1) not in visited:\\n                        next_level.add((r1, c1, r1, c1 + 1))\\n            curr_level = next_level\\n            moves += 1\\n        return -1\\n```",
                "solutionTags": [],
                "code": "```\\n    def minimumMoves(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n        start = (0, 0, 0, 1)\\n        end = (n - 1, n - 2, n - 1, n - 1)\\n        curr_level = {start}\\n        moves = 0\\n        visited = set()\\n        while curr_level:\\n            if end in curr_level:\\n                return moves\\n            next_level = set()\\n            for pos in curr_level:\\n                visited.add(pos)\\n                r1, c1, r2, c2 = pos\\n                if c1 + 1 < n and grid[r1][c1+1] == 0 and c2 + 1 < n and grid[r2][c2+1] == 0:\\n                    if (r1, c1 + 1, r2, c2 + 1) not in visited:\\n                        next_level.add((r1, c1 + 1, r2, c2 + 1))\\n                if r1 + 1 < n and grid[r1+1][c1] == 0 and r2 + 1 < n and grid[r2+1][c2] == 0:\\n                    if (r1 + 1, c1, r2 + 1, c1) not in visited:\\n                        next_level.add((r1 + 1, c1, r2 + 1, c2))\\n                if r1 == r2 and c2 == c1 + 1 and r1 + 1 < n and grid[r1+1][c1] + grid[r1+1][c1+1] == 0 :\\n                    if (r1, c1, r1 + 1, c1) not in visited:\\n                        next_level.add((r1, c1, r1 + 1, c1))\\n                if c1 == c2 and r2 == r1 + 1 and c1 + 1 < n and grid[r1][c1+1] + grid[r1+1][c1+1] == 0:\\n                    if (r1, c1, r1, c1 + 1) not in visited:\\n                        next_level.add((r1, c1, r1, c1 + 1))\\n            curr_level = next_level\\n            moves += 1\\n        return -1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 393511,
                "title": "java-python-3-25-and-17-liner-clean-bfs-codes-w-brief-explanation-and-analysis",
                "content": "1. Use the coordinate of the snake tail (up/left part), `r, c`, and the row difference between head and tail, `dr`, to describe the position of the snake. Obviously, `dr = 0` and `dr = 1` indicate that the snake is in `horizontal` and `vertical` positions, respectively;\\n2. Use a Queue and a HashSet to perform BFS traversal and prune duplicates;\\n3. In order to create hash for HashSet, use `r + \",\" + c + \",\" + dr` to encode snake position.\\n\\n\\n```java\\n    public int minimumMoves(int[][] g) {\\n        int n = g.length;\\n        int[] start = {0, 0, 0, 0}, target = {n - 1, n - 2, 0};\\n        Queue<int[]> q = new LinkedList<>();\\n        q.offer(start);\\n        Set<String> seen = new HashSet<>();\\n        while (!q.isEmpty()) {\\n            int[] pos = q.poll();\\n            int r = pos[0], c = pos[1], dr = pos[2], steps = pos[3];        // snake tail row, column, row difference, steps.\\n            if (Arrays.equals(Arrays.copyOf(pos, 3), target))               // reach target.\\n                return steps;\\n            if (seen.add(r + \",\" + c + \",\" + dr)) {                         // prune duplicates.\\n                if (dr == 0) {                                              // horizontal position.\\n                    if (r + 1 < n && g[r + 1][c] + g[r + 1][c + 1] == 0)    // the two cells below are empty: down and colock-wise rotation.\\n                        q.addAll(Arrays.asList(new int[]{r + 1, c, 0, steps + 1}, new int[]{r, c, 1, steps + 1}));\\n                    if (c + 2 < n && g[r][c + 2] == 0)                      // the right cell is empty.\\n                        q.offer(new int[]{r, c + 1, 0, steps + 1});         // right.\\n                }else {                                                     // vertical position.\\n                    if (c + 1 < n && g[r][c + 1] + g[r + 1][c + 1] == 0)    // the two cells right are empty: right and counterclock-wise rotation.\\n                        q.addAll(Arrays.asList(new int[]{r, c + 1, 1, steps + 1}, new int[]{r, c, 0, steps + 1}));\\n                    if (r + 2 < n && g[r + 2][c] == 0)                      // the below cell is empty.\\n                        q.offer(new int[]{r + 1, c, 1, steps + 1});         // down.\\n                }                    \\n            }\\n        }\\n        return -1;\\n    }\\n```\\n```python\\n    def minimumMoves(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n        q, seen, target = [(0, 0, 0, 0)], set(), (n - 1, n - 2, 0)              # row, column, row difference.\\n        for r, c, dr, steps in q:\\n            if (r, c, dr) == target: return steps                               # reach target.\\n            if (r, c, dr) not in seen:                                          # prune duplicates.\\n                seen.add((r, c, dr))\\n                if dr:                                                          # vertical position. \\n                    if c + 1 < n and grid[r][c + 1] + grid[r + 1][c + 1] == 0:  # the two cells right are emtpty.\\n                        q += [(r, c + 1, 1, steps + 1), (r, c, 0, steps + 1)]   # right and counter-colock-wise rotate.\\n                    if r + 2 < n and grid[r + 2][c] == 0:                       # the below cell is empty.\\n                        q += [(r + 1, c, 1, steps + 1)]                         # down.\\n                else:                                                           # horizontal position\\n                    if r + 1 < n and grid[r + 1][c] + grid[r + 1][c + 1] == 0:  # the two cells below are empty.\\n                        q += [(r + 1, c, 0, steps + 1), (r, c, 1, steps + 1)]   # down and colock-wise rotate.\\n                    if c + 2 < n and grid[r][c + 2] == 0:                       # right cell is empty.\\n                        q += [(r, c + 1, 0, steps + 1)]                         # right.\\n        return -1\\n```\\n\\n\\n\\n**Analysis:**\\n\\nFor each cell, the snake tail corresponds to at most 4 positions. Therefore,\\n\\nTime & space: `O(n ^ 2)`, where `n = grid.length`.\\n\\n----\\nBelow is the **old post content**:\\n\\nQ: why the 23rd test case expects -1, NOT 29?\\n\\nPlease give me a hand to explain why the 23rd test case expects `-1`, NOT `29`? I use `a-za-c` to indicate the snake path.\\n```\\n[[0,0,1,0,0,0,0,0,0,0,0,0,0,0,0],\\n [0,1,0,1,1,0,0,1,0,0,0,0,1,0,0],\\n [0,1,0,0,0,0,1,0,0,1,0,0,0,0,0],\\n [0,0,0,0,0,0,1,0,0,0,0,0,0,0,0],\\n [0,0,0,0,0,0,1,1,0,0,0,0,0,0,0],\\n [0,0,0,0,0,0,0,0,0,1,0,1,0,0,0],\\n [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\\n [0,0,0,1,0,1,0,0,1,0,0,0,1,0,0],\\n [0,0,0,0,1,0,0,0,0,0,0,0,0,1,0],\\n [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\\n [0,0,0,1,0,0,0,0,0,0,0,0,0,0,0],\\n [1,0,1,1,0,0,0,0,0,0,0,0,0,0,0],\\n [0,0,0,0,0,0,0,0,0,0,0,0,0,1,0],\\n [1,0,0,0,0,0,1,0,0,0,1,0,0,0,1],\\n [0,0,1,0,1,0,0,0,0,0,0,0,0,0,0]]\\n\\n[[0,0,1,0,0,0,0,0,0,0,0,0,0,0,0],\\n [a,1,0,1,1,0,0,1,0,0,0,0,1,0,0],\\n [b,1,0,0,0,0,1,0,0,1,0,0,0,0,0],\\n [c,0,0,0,0,0,1,0,0,0,0,0,0,0,0],\\n [d,0,0,0,0,0,1,1,0,0,0,0,0,0,0],\\n [e,0,0,0,0,0,0,0,0,1,0,1,0,0,0],\\n [f,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\\n [g,0,0,1,0,1,0,0,1,0,0,0,1,0,0],\\n [h,0,0,0,1,0,0,0,0,0,0,0,0,1,0],\\n [i,k,0,0,0,0,0,0,0,0,0,0,0,0,0],\\n [j,k,0,1,0,0,0,0,0,0,0,0,0,0,0],\\n [1,l,1,1,0,0,0,0,0,0,0,0,0,0,0],\\n [0,m,O,p,q,r,s,t,u,v,0,0,0,1,0],\\n [1,n,O,p,0,0,1,0,w,w,1,0,0,0,1],\\n [0,0,1,0,1,0,0,0,x,x,y,z,a,b,c]]\\n```\\ncredit to **@QuentinHe** and **@chuckdchen**\\nA: \\nIt will fail on the first step. the snake is cornered by the two `1s` on the right and bottom `[0,3]` and `[1,1]`, you can\\'t rotate when `[1,1]` is a blocker.",
                "solutionTags": [],
                "code": "```java\\n    public int minimumMoves(int[][] g) {\\n        int n = g.length;\\n        int[] start = {0, 0, 0, 0}, target = {n - 1, n - 2, 0};\\n        Queue<int[]> q = new LinkedList<>();\\n        q.offer(start);\\n        Set<String> seen = new HashSet<>();\\n        while (!q.isEmpty()) {\\n            int[] pos = q.poll();\\n            int r = pos[0], c = pos[1], dr = pos[2], steps = pos[3];        // snake tail row, column, row difference, steps.\\n            if (Arrays.equals(Arrays.copyOf(pos, 3), target))               // reach target.\\n                return steps;\\n            if (seen.add(r + \",\" + c + \",\" + dr)) {                         // prune duplicates.\\n                if (dr == 0) {                                              // horizontal position.\\n                    if (r + 1 < n && g[r + 1][c] + g[r + 1][c + 1] == 0)    // the two cells below are empty: down and colock-wise rotation.\\n                        q.addAll(Arrays.asList(new int[]{r + 1, c, 0, steps + 1}, new int[]{r, c, 1, steps + 1}));\\n                    if (c + 2 < n && g[r][c + 2] == 0)                      // the right cell is empty.\\n                        q.offer(new int[]{r, c + 1, 0, steps + 1});         // right.\\n                }else {                                                     // vertical position.\\n                    if (c + 1 < n && g[r][c + 1] + g[r + 1][c + 1] == 0)    // the two cells right are empty: right and counterclock-wise rotation.\\n                        q.addAll(Arrays.asList(new int[]{r, c + 1, 1, steps + 1}, new int[]{r, c, 0, steps + 1}));\\n                    if (r + 2 < n && g[r + 2][c] == 0)                      // the below cell is empty.\\n                        q.offer(new int[]{r + 1, c, 1, steps + 1});         // down.\\n                }                    \\n            }\\n        }\\n        return -1;\\n    }\\n```\n```python\\n    def minimumMoves(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n        q, seen, target = [(0, 0, 0, 0)], set(), (n - 1, n - 2, 0)              # row, column, row difference.\\n        for r, c, dr, steps in q:\\n            if (r, c, dr) == target: return steps                               # reach target.\\n            if (r, c, dr) not in seen:                                          # prune duplicates.\\n                seen.add((r, c, dr))\\n                if dr:                                                          # vertical position. \\n                    if c + 1 < n and grid[r][c + 1] + grid[r + 1][c + 1] == 0:  # the two cells right are emtpty.\\n                        q += [(r, c + 1, 1, steps + 1), (r, c, 0, steps + 1)]   # right and counter-colock-wise rotate.\\n                    if r + 2 < n and grid[r + 2][c] == 0:                       # the below cell is empty.\\n                        q += [(r + 1, c, 1, steps + 1)]                         # down.\\n                else:                                                           # horizontal position\\n                    if r + 1 < n and grid[r + 1][c] + grid[r + 1][c + 1] == 0:  # the two cells below are empty.\\n                        q += [(r + 1, c, 0, steps + 1), (r, c, 1, steps + 1)]   # down and colock-wise rotate.\\n                    if c + 2 < n and grid[r][c + 2] == 0:                       # right cell is empty.\\n                        q += [(r, c + 1, 0, steps + 1)]                         # right.\\n        return -1\\n```\n```\\n[[0,0,1,0,0,0,0,0,0,0,0,0,0,0,0],\\n [0,1,0,1,1,0,0,1,0,0,0,0,1,0,0],\\n [0,1,0,0,0,0,1,0,0,1,0,0,0,0,0],\\n [0,0,0,0,0,0,1,0,0,0,0,0,0,0,0],\\n [0,0,0,0,0,0,1,1,0,0,0,0,0,0,0],\\n [0,0,0,0,0,0,0,0,0,1,0,1,0,0,0],\\n [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\\n [0,0,0,1,0,1,0,0,1,0,0,0,1,0,0],\\n [0,0,0,0,1,0,0,0,0,0,0,0,0,1,0],\\n [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\\n [0,0,0,1,0,0,0,0,0,0,0,0,0,0,0],\\n [1,0,1,1,0,0,0,0,0,0,0,0,0,0,0],\\n [0,0,0,0,0,0,0,0,0,0,0,0,0,1,0],\\n [1,0,0,0,0,0,1,0,0,0,1,0,0,0,1],\\n [0,0,1,0,1,0,0,0,0,0,0,0,0,0,0]]\\n\\n[[0,0,1,0,0,0,0,0,0,0,0,0,0,0,0],\\n [a,1,0,1,1,0,0,1,0,0,0,0,1,0,0],\\n [b,1,0,0,0,0,1,0,0,1,0,0,0,0,0],\\n [c,0,0,0,0,0,1,0,0,0,0,0,0,0,0],\\n [d,0,0,0,0,0,1,1,0,0,0,0,0,0,0],\\n [e,0,0,0,0,0,0,0,0,1,0,1,0,0,0],\\n [f,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\\n [g,0,0,1,0,1,0,0,1,0,0,0,1,0,0],\\n [h,0,0,0,1,0,0,0,0,0,0,0,0,1,0],\\n [i,k,0,0,0,0,0,0,0,0,0,0,0,0,0],\\n [j,k,0,1,0,0,0,0,0,0,0,0,0,0,0],\\n [1,l,1,1,0,0,0,0,0,0,0,0,0,0,0],\\n [0,m,O,p,q,r,s,t,u,v,0,0,0,1,0],\\n [1,n,O,p,0,0,1,0,w,w,1,0,0,0,1],\\n [0,0,1,0,1,0,0,0,x,x,y,z,a,b,c]]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 392872,
                "title": "c-bfs",
                "content": "# Intuition\\nThis looks like BFS problem, where horizontal and vertical paths are independent (but can be transitioned to and from). So, we need to track \\'visited\\' state independently for horizontal and vertical orientations.\\n# Modified BFS\\nThis type of problems is not hard, but it could be trickly to get the code right. I created three helper functions to make it a bit easier.\\n\\n1. Use a queue to store the tail coordinates and orientation.\\n2. For every element in the queue, check the visited flag and move up, down or rotate, if possible.\\n> Here, I am using second and third bit (2 and 4) to track the state directly in the grid.\\n3. Return the number of steps in BFS if we reach the target; otherwise return ```-1```\\n```\\nbool canRotate(vector<vector<int>>& g, int i, int j) {\\n  return i < g.size() - 1 && j < g[i].size() - 1\\n    && (g[i + 1][j] & 1) == 0 && (g[i][j + 1] & 1) == 0 && (g[i + 1][j + 1] & 1) == 0;\\n}\\nbool canGoDown(vector<vector<int>>& g, int i, int j, bool vertical) {\\n  if (vertical) return i < g.size() - 2 && (g[i + 2][j] & 1) == 0;\\n  return i < g.size() - 1 && (g[i + 1][j] & 1) == 0 && (g[i + 1][j + 1] & 1) == 0;\\n}\\nbool canGoRight(vector<vector<int>>& g, int i, int j, bool vertical) {\\n  if (!vertical) return j < g[i].size() - 2 && (g[i][j + 2] & 1) == 0;\\n  return j < g[i].size() - 1 && (g[i][j + 1] & 1) == 0 && (g[i + 1][j + 1] & 1) == 0;\\n}\\nint minimumMoves(vector<vector<int>>& grid, int steps = 0) {\\n  queue<array<int, 3>> q1, q2;\\n  q1.push({ 0, 0, false }); // not vertical.\\n  while (!q1.empty()) {\\n    while (!q1.empty()) {\\n      auto& a = q1.front();\\n      if (a[0] == grid.size() - 1 && a[1] == grid[a[0]].size() - 2) return steps;\\n      if ((grid[a[0]][a[1]] & (a[2] ? 2 : 4)) == 0) {\\n        grid[a[0]][a[1]] = grid[a[0]][a[1]] | (a[2] ? 2 : 4);\\n        if (canGoDown(grid, a[0], a[1], a[2])) q2.push({ a[0] + 1, a[1], a[2] });\\n        if (canGoRight(grid, a[0], a[1], a[2])) q2.push({ a[0], a[1] + 1, a[2] });\\n        if (canRotate(grid, a[0], a[1])) q2.push({ a[0], a[1], a[2] ? false : true });\\n      }\\n      q1.pop();\\n    }\\n    ++steps;\\n    swap(q1, q2);\\n  }\\n  return -1;\\n}\\n```",
                "solutionTags": [],
                "code": "```-1```\n```\\nbool canRotate(vector<vector<int>>& g, int i, int j) {\\n  return i < g.size() - 1 && j < g[i].size() - 1\\n    && (g[i + 1][j] & 1) == 0 && (g[i][j + 1] & 1) == 0 && (g[i + 1][j + 1] & 1) == 0;\\n}\\nbool canGoDown(vector<vector<int>>& g, int i, int j, bool vertical) {\\n  if (vertical) return i < g.size() - 2 && (g[i + 2][j] & 1) == 0;\\n  return i < g.size() - 1 && (g[i + 1][j] & 1) == 0 && (g[i + 1][j + 1] & 1) == 0;\\n}\\nbool canGoRight(vector<vector<int>>& g, int i, int j, bool vertical) {\\n  if (!vertical) return j < g[i].size() - 2 && (g[i][j + 2] & 1) == 0;\\n  return j < g[i].size() - 1 && (g[i][j + 1] & 1) == 0 && (g[i + 1][j + 1] & 1) == 0;\\n}\\nint minimumMoves(vector<vector<int>>& grid, int steps = 0) {\\n  queue<array<int, 3>> q1, q2;\\n  q1.push({ 0, 0, false }); // not vertical.\\n  while (!q1.empty()) {\\n    while (!q1.empty()) {\\n      auto& a = q1.front();\\n      if (a[0] == grid.size() - 1 && a[1] == grid[a[0]].size() - 2) return steps;\\n      if ((grid[a[0]][a[1]] & (a[2] ? 2 : 4)) == 0) {\\n        grid[a[0]][a[1]] = grid[a[0]][a[1]] | (a[2] ? 2 : 4);\\n        if (canGoDown(grid, a[0], a[1], a[2])) q2.push({ a[0] + 1, a[1], a[2] });\\n        if (canGoRight(grid, a[0], a[1], a[2])) q2.push({ a[0], a[1] + 1, a[2] });\\n        if (canRotate(grid, a[0], a[1])) q2.push({ a[0], a[1], a[2] ? false : true });\\n      }\\n      q1.pop();\\n    }\\n    ++steps;\\n    swap(q1, q2);\\n  }\\n  return -1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 393791,
                "title": "c-short-bfs-no-brainer-version",
                "content": "**Observation**\\nThe two parts of the snake (head and tail) together define it\\'s position and thus we need to BFS keeping that in mind.\\n\\n**Solution**\\nSince this is a no brainer version, we keep track of visited nodes just as regular BFS keeping in mind that 1 node is defined by the 2 positions (Snake\\'s head and snake\\'s tail).\\nSince C++ doesn\\'t provide a hash function for a vector by default we can use `set<vector<int>>` (This increases the time complexity) as our way to keep track of visited nodes.\\nWe can now run a simle BFS using `queue<vector<int>>` and iterate on all possible neighbours for that node by adding them to the queue and keep repeating until we find the target or the queue gets empty.\\n```c++\\nclass Solution {\\npublic:\\n    set<vector<int>> visited;\\n    queue<vector<int>> q;\\n    void commonMoves(vector<vector<int>>& grid,vector<int> &pos)\\n    {\\n        if(pos[3]+1<grid.size()&&!grid[pos[2]][pos[3]+1]&&!grid[pos[0]][pos[1]+1]&&!visited.count({pos[0],pos[1]+1,pos[2],pos[3]+1}))     //Move right\\n            visited.insert({pos[0],pos[1]+1,pos[2],pos[3]+1}),q.push({pos[0],pos[1]+1,pos[2],pos[3]+1});\\n        if(pos[2]+1<grid.size()&&!grid[pos[2]+1][pos[3]]&&!grid[pos[0]+1][pos[1]]&&!visited.count({pos[0]+1,pos[1],pos[2]+1,pos[3]}))       //Move down\\n            visited.insert({pos[0]+1,pos[1],pos[2]+1,pos[3]}),q.push({pos[0]+1,pos[1],pos[2]+1,pos[3]});\\n    }\\n    void horizontal(vector<vector<int>>& grid,vector<int> &pos)\\n    {\\n        if(pos[0]+1<grid.size()&&!grid[pos[0]+1][pos[1]]&&!grid[pos[2]+1][pos[3]]&&!visited.count({pos[0],pos[1],pos[0]+1,pos[1]}))         //Rotate clockwise\\n            visited.insert({pos[0],pos[1],pos[0]+1,pos[1]}),q.push({pos[0],pos[1],pos[0]+1,pos[1]});\\n    }\\n    void vertical(vector<vector<int>>& grid,vector<int> &pos)\\n    {\\n        if(pos[1]+1<grid.size()&&!grid[pos[0]][pos[1]+1]&&!grid[pos[2]][pos[3]+1]&&!visited.count({pos[0],pos[1],pos[0],pos[1]+1}))      //Rotate counter-clockwise\\n            visited.insert({pos[0],pos[1],pos[0],pos[1]+1}),q.push({pos[0],pos[1],pos[0],pos[1]+1});\\n    }\\n    int minimumMoves(vector<vector<int>>& grid) \\n    {\\n        vector<int> target={grid.size()-1,grid.size()-2,grid.size()-1,grid.size()-1}; \\n        q.push({0,0,0,1});\\n        visited.insert({0,0,0,1});\\n        int size,moves=0;\\n        while(!q.empty())\\n        {\\n            size=q.size();\\n            while(size--)\\n            {\\n                if(q.front()==target)                             //Reached target\\n                    return moves;\\n                if(q.front()[0]==q.front()[2])                 //When snake is horizontal\\n                    horizontal(grid,q.front());\\n                else                                                   //When snake is vertical\\n                    vertical(grid,q.front());\\n\\t\\tcommonMoves(grid,q.front());                 //Common moves (Right and down)\\n                q.pop();\\n            }\\n            moves++;\\n        }\\n        return -1;\\n    }\\n};\\n```\\n**Note**\\nTo further reduce the time complexity, we can use an `unordered_set` with a custom implementation of hash function for a vector, this would reduce complexity of adding and searching on `visited` nodes from O(nlogn) to O(n).",
                "solutionTags": [],
                "code": "```c++\\nclass Solution {\\npublic:\\n    set<vector<int>> visited;\\n    queue<vector<int>> q;\\n    void commonMoves(vector<vector<int>>& grid,vector<int> &pos)\\n    {\\n        if(pos[3]+1<grid.size()&&!grid[pos[2]][pos[3]+1]&&!grid[pos[0]][pos[1]+1]&&!visited.count({pos[0],pos[1]+1,pos[2],pos[3]+1}))     //Move right\\n            visited.insert({pos[0],pos[1]+1,pos[2],pos[3]+1}),q.push({pos[0],pos[1]+1,pos[2],pos[3]+1});\\n        if(pos[2]+1<grid.size()&&!grid[pos[2]+1][pos[3]]&&!grid[pos[0]+1][pos[1]]&&!visited.count({pos[0]+1,pos[1],pos[2]+1,pos[3]}))       //Move down\\n            visited.insert({pos[0]+1,pos[1],pos[2]+1,pos[3]}),q.push({pos[0]+1,pos[1],pos[2]+1,pos[3]});\\n    }\\n    void horizontal(vector<vector<int>>& grid,vector<int> &pos)\\n    {\\n        if(pos[0]+1<grid.size()&&!grid[pos[0]+1][pos[1]]&&!grid[pos[2]+1][pos[3]]&&!visited.count({pos[0],pos[1],pos[0]+1,pos[1]}))         //Rotate clockwise\\n            visited.insert({pos[0],pos[1],pos[0]+1,pos[1]}),q.push({pos[0],pos[1],pos[0]+1,pos[1]});\\n    }\\n    void vertical(vector<vector<int>>& grid,vector<int> &pos)\\n    {\\n        if(pos[1]+1<grid.size()&&!grid[pos[0]][pos[1]+1]&&!grid[pos[2]][pos[3]+1]&&!visited.count({pos[0],pos[1],pos[0],pos[1]+1}))      //Rotate counter-clockwise\\n            visited.insert({pos[0],pos[1],pos[0],pos[1]+1}),q.push({pos[0],pos[1],pos[0],pos[1]+1});\\n    }\\n    int minimumMoves(vector<vector<int>>& grid) \\n    {\\n        vector<int> target={grid.size()-1,grid.size()-2,grid.size()-1,grid.size()-1}; \\n        q.push({0,0,0,1});\\n        visited.insert({0,0,0,1});\\n        int size,moves=0;\\n        while(!q.empty())\\n        {\\n            size=q.size();\\n            while(size--)\\n            {\\n                if(q.front()==target)                             //Reached target\\n                    return moves;\\n                if(q.front()[0]==q.front()[2])                 //When snake is horizontal\\n                    horizontal(grid,q.front());\\n                else                                                   //When snake is vertical\\n                    vertical(grid,q.front());\\n\\t\\tcommonMoves(grid,q.front());                 //Common moves (Right and down)\\n                q.pop();\\n            }\\n            moves++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 392904,
                "title": "java-bfs-solution-very-clean-code-easy-to-understand",
                "content": "```java\\npublic class Solution {\\n    public int minimumMoves(int[][] grid) {\\n        int n = grid.length;\\n        SnakePos src = new SnakePos(new Cell(0, 0), new Cell(0, 1));\\n        SnakePos dst = new SnakePos(new Cell(n - 1, n - 2), new Cell(n - 1, n - 1));\\n\\n        HashSet<String> visited = new HashSet<>();\\n        Queue<SnakePos> queue = new LinkedList<>();\\n        queue.add(src);\\n        visited.add(src.getKey());\\n\\n        ArrayList<SnakePos> nextMoves = new ArrayList<>(4);\\n        int steps = 0;\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            for (int i = 0; i < size; i++) {\\n                SnakePos top = queue.remove();\\n                if (top.equals(dst))\\n                    return steps;\\n\\n                nextMoves.clear();\\n                nextMoves.add(tryMoveRight(top, grid));\\n                nextMoves.add(tryMoveDown(top, grid));\\n                nextMoves.add(tryMoveClockwise(top, grid));\\n                nextMoves.add(tryMoveCounterClockwise(top, grid));\\n\\n                for (SnakePos next : nextMoves) {\\n                    if (next != null && !visited.contains(next.getKey())) {\\n                        visited.add(next.getKey());\\n                        queue.add(next);\\n                    }\\n                }\\n            }\\n            steps++;\\n        }\\n\\n        return -1;\\n    }\\n\\n    SnakePos tryMoveRight(SnakePos curr, int[][] grid) {\\n        SnakePos next = new SnakePos(\\n                new Cell(curr.cell1.r, curr.cell1.c + 1),\\n                new Cell(curr.cell2.r, curr.cell2.c + 1)\\n        );\\n        if (valid(next, grid))\\n            return next;\\n        return null;\\n    }\\n\\n    SnakePos tryMoveDown(SnakePos curr, int[][] grid) {\\n        SnakePos next = new SnakePos(\\n                new Cell(curr.cell1.r + 1, curr.cell1.c),\\n                new Cell(curr.cell2.r + 1, curr.cell2.c)\\n        );\\n        if (valid(next, grid))\\n            return next;\\n        return null;\\n    }\\n\\n    SnakePos tryMoveClockwise(SnakePos curr, int[][] grid) {\\n        if (curr.cell1.r == curr.cell2.r) {\\n            SnakePos next = new SnakePos(\\n                    new Cell(curr.cell1.r, curr.cell1.c),\\n                    new Cell(curr.cell2.r + 1, curr.cell2.c - 1)\\n            );\\n            if (valid(next.cell2, grid)\\n                    && valid(new Cell(curr.cell1.r + 1, curr.cell1.c + 1), grid)) {\\n                return next;\\n            }\\n        }\\n        return null;\\n    }\\n\\n    SnakePos tryMoveCounterClockwise(SnakePos curr, int[][] grid) {\\n        if (curr.cell1.c == curr.cell2.c) {\\n            SnakePos next = new SnakePos(\\n                    new Cell(curr.cell1.r, curr.cell1.c),\\n                    new Cell(curr.cell2.r - 1, curr.cell2.c + 1)\\n            );\\n            if (valid(next.cell2, grid)\\n                    && valid(new Cell(curr.cell1.r + 1, curr.cell1.c + 1), grid)) {\\n                return next;\\n            }\\n        }\\n        return null;\\n    }\\n\\n    boolean valid(int r, int c, int[][] grid) {\\n        int n = grid.length;\\n        return r >= 0 && r < n && c >= 0 && c < n && grid[r][c] == 0;\\n    }\\n\\n    boolean valid(Cell cell, int[][] grid) {\\n        return valid(cell.r, cell.c, grid);\\n    }\\n\\n    boolean valid(SnakePos snakePos, int[][] grid) {\\n        return valid(snakePos.cell1, grid) && valid(snakePos.cell2, grid);\\n    }\\n\\n    // For testing and debug on IDE purpose\\n    public static void main(String[] args) {\\n        int[][] grid = {\\n                {0, 0, 0, 0, 0, 1},\\n                {1, 1, 0, 0, 1, 0},\\n                {0, 0, 0, 0, 1, 1},\\n                {0, 0, 1, 0, 1, 0},\\n                {0, 1, 1, 0, 0, 0},\\n                {0, 1, 1, 0, 0, 0}\\n        };\\n\\n        Solution sol = new Solution();\\n        System.out.println(sol.minimumMoves(grid));\\n    }\\n}\\n\\nclass Cell {\\n    int r, c;\\n\\n    public Cell(int r, int c) {\\n        this.r = r;\\n        this.c = c;\\n    }\\n\\n    public String getKey() {\\n        return r + \",\" + c;\\n    }\\n\\n    @Override\\n    public boolean equals(Object obj) {\\n        Cell cell = (Cell) obj;\\n        return r == cell.r && c == cell.c;\\n    }\\n}\\n\\nclass SnakePos {\\n    Cell cell1, cell2;\\n\\n    public SnakePos(Cell cell1, Cell cell2) {\\n        this.cell1 = cell1;\\n        this.cell2 = cell2;\\n    }\\n\\n    public String getKey() {\\n        return cell1.getKey() + \":\" + cell2.getKey();\\n    }\\n\\n    @Override\\n    public boolean equals(Object obj) {\\n        SnakePos snakePos = (SnakePos) obj;\\n        return snakePos.cell1.equals(cell1) && snakePos.cell2.equals(cell2);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```java\\npublic class Solution {\\n    public int minimumMoves(int[][] grid) {\\n        int n = grid.length;\\n        SnakePos src = new SnakePos(new Cell(0, 0), new Cell(0, 1));\\n        SnakePos dst = new SnakePos(new Cell(n - 1, n - 2), new Cell(n - 1, n - 1));\\n\\n        HashSet<String> visited = new HashSet<>();\\n        Queue<SnakePos> queue = new LinkedList<>();\\n        queue.add(src);\\n        visited.add(src.getKey());\\n\\n        ArrayList<SnakePos> nextMoves = new ArrayList<>(4);\\n        int steps = 0;\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            for (int i = 0; i < size; i++) {\\n                SnakePos top = queue.remove();\\n                if (top.equals(dst))\\n                    return steps;\\n\\n                nextMoves.clear();\\n                nextMoves.add(tryMoveRight(top, grid));\\n                nextMoves.add(tryMoveDown(top, grid));\\n                nextMoves.add(tryMoveClockwise(top, grid));\\n                nextMoves.add(tryMoveCounterClockwise(top, grid));\\n\\n                for (SnakePos next : nextMoves) {\\n                    if (next != null && !visited.contains(next.getKey())) {\\n                        visited.add(next.getKey());\\n                        queue.add(next);\\n                    }\\n                }\\n            }\\n            steps++;\\n        }\\n\\n        return -1;\\n    }\\n\\n    SnakePos tryMoveRight(SnakePos curr, int[][] grid) {\\n        SnakePos next = new SnakePos(\\n                new Cell(curr.cell1.r, curr.cell1.c + 1),\\n                new Cell(curr.cell2.r, curr.cell2.c + 1)\\n        );\\n        if (valid(next, grid))\\n            return next;\\n        return null;\\n    }\\n\\n    SnakePos tryMoveDown(SnakePos curr, int[][] grid) {\\n        SnakePos next = new SnakePos(\\n                new Cell(curr.cell1.r + 1, curr.cell1.c),\\n                new Cell(curr.cell2.r + 1, curr.cell2.c)\\n        );\\n        if (valid(next, grid))\\n            return next;\\n        return null;\\n    }\\n\\n    SnakePos tryMoveClockwise(SnakePos curr, int[][] grid) {\\n        if (curr.cell1.r == curr.cell2.r) {\\n            SnakePos next = new SnakePos(\\n                    new Cell(curr.cell1.r, curr.cell1.c),\\n                    new Cell(curr.cell2.r + 1, curr.cell2.c - 1)\\n            );\\n            if (valid(next.cell2, grid)\\n                    && valid(new Cell(curr.cell1.r + 1, curr.cell1.c + 1), grid)) {\\n                return next;\\n            }\\n        }\\n        return null;\\n    }\\n\\n    SnakePos tryMoveCounterClockwise(SnakePos curr, int[][] grid) {\\n        if (curr.cell1.c == curr.cell2.c) {\\n            SnakePos next = new SnakePos(\\n                    new Cell(curr.cell1.r, curr.cell1.c),\\n                    new Cell(curr.cell2.r - 1, curr.cell2.c + 1)\\n            );\\n            if (valid(next.cell2, grid)\\n                    && valid(new Cell(curr.cell1.r + 1, curr.cell1.c + 1), grid)) {\\n                return next;\\n            }\\n        }\\n        return null;\\n    }\\n\\n    boolean valid(int r, int c, int[][] grid) {\\n        int n = grid.length;\\n        return r >= 0 && r < n && c >= 0 && c < n && grid[r][c] == 0;\\n    }\\n\\n    boolean valid(Cell cell, int[][] grid) {\\n        return valid(cell.r, cell.c, grid);\\n    }\\n\\n    boolean valid(SnakePos snakePos, int[][] grid) {\\n        return valid(snakePos.cell1, grid) && valid(snakePos.cell2, grid);\\n    }\\n\\n    // For testing and debug on IDE purpose\\n    public static void main(String[] args) {\\n        int[][] grid = {\\n                {0, 0, 0, 0, 0, 1},\\n                {1, 1, 0, 0, 1, 0},\\n                {0, 0, 0, 0, 1, 1},\\n                {0, 0, 1, 0, 1, 0},\\n                {0, 1, 1, 0, 0, 0},\\n                {0, 1, 1, 0, 0, 0}\\n        };\\n\\n        Solution sol = new Solution();\\n        System.out.println(sol.minimumMoves(grid));\\n    }\\n}\\n\\nclass Cell {\\n    int r, c;\\n\\n    public Cell(int r, int c) {\\n        this.r = r;\\n        this.c = c;\\n    }\\n\\n    public String getKey() {\\n        return r + \",\" + c;\\n    }\\n\\n    @Override\\n    public boolean equals(Object obj) {\\n        Cell cell = (Cell) obj;\\n        return r == cell.r && c == cell.c;\\n    }\\n}\\n\\nclass SnakePos {\\n    Cell cell1, cell2;\\n\\n    public SnakePos(Cell cell1, Cell cell2) {\\n        this.cell1 = cell1;\\n        this.cell2 = cell2;\\n    }\\n\\n    public String getKey() {\\n        return cell1.getKey() + \":\" + cell2.getKey();\\n    }\\n\\n    @Override\\n    public boolean equals(Object obj) {\\n        SnakePos snakePos = (SnakePos) obj;\\n        return snakePos.cell1.equals(cell1) && snakePos.cell2.equals(cell2);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 393459,
                "title": "java-short-and-easy-to-understand-bfs",
                "content": "We can treat the grid as 1d array and use the position as the identifiers. Introduce a hashset to check if the snake span is visisted with the format of `first-second`. The position of first and second cell of the span is x1, y1 and x2, y2 respectively. The move them as needed just like regular BFS.\\n\\ne.g. The positions of the grid in the example are 0 - 35, we add the span [0, 1] to queue, then move the snake right by one step to [1,2], then further right to [2, 3], now rotates clockwise to be [2, 2 + n] which is [2, 8]. At this point, the coordinates of the span is (0,2) (1,2) and the snake is heading down. Now move the snake to the right as a whole to [2 +1, 8 +1] which is [3, 9]. Then move down four times till the bottom of the grid to [27, 33]. Now the snake\\'s coordinates is (27 / n = **4**, 27 % n = **3**) and (33 / n = **5**, 33 % n = **3**). rotate counter clockwise to [27, 27 +1], to the right [27 + 1, 28 +1], finally going down to [28 + n, 29 +n] which is [34, 35].\\n\\n```\\nclass Solution {\\n    public int minimumMoves(int[][] grid) {\\n        int n = grid.length, moves = 0;\\n        Queue<int[]> q = new LinkedList<>();\\n        Set<String> seen = new HashSet<>();\\n        q.offer(new int[] {0, 1});\\n        seen.add(\"0-1\");\\n        \\n        while (!q.isEmpty()) {\\n            int size = q.size();\\n            for (int i = 0; i < size; i++) {\\n                int[] span = q.poll();\\n                int first = span[0], second = span[1], x1 = first / n, y1 = first % n, x2 = second / n, y2 = second % n;\\n                if (x1 == n - 1 && y1 == n - 2 && x2 == n - 1 && y2 == n - 1) return moves;\\n                \\n                if (x1 == x2) { // horizontal\\n                    if (y2 + 1 < n && grid[x2][y2 + 1] == 0) move(q, second, second + 1, seen); // right\\n                    if (x2 + 1 < n && grid[x1 + 1][y1] == 0 && grid[x2 + 1][y2] == 0) {\\n                        move(q, first + n, second + n, seen); // down\\n                        move(q, first, first + n, seen); // clockwise\\n                    }\\n                } \\n                \\n                if (y1 == y2) { // vertical\\n                    if (x2 + 1 < n && grid[x2 + 1][y2] == 0) move(q, second, second + n, seen); // down\\n                    if (y2 + 1 < n && grid[x1][y1 + 1] == 0 && grid[x2][y2 + 1] == 0) {\\n                        move(q, first + 1, second + 1, seen); // right\\n                        move(q, first, first + 1, seen); // counter clockwise\\n                    }\\n                } \\n            }\\n            moves++;\\n        }\\n        return -1;\\n    }\\n    \\n    private void move(Queue<int[]> q, int first, int second, Set<String> seen) {\\n        if (!seen.contains(first + \"-\" + second)) {\\n            q.offer(new int[] { first, second });\\n            seen.add(first + \"-\" + second);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minimumMoves(int[][] grid) {\\n        int n = grid.length, moves = 0;\\n        Queue<int[]> q = new LinkedList<>();\\n        Set<String> seen = new HashSet<>();\\n        q.offer(new int[] {0, 1});\\n        seen.add(\"0-1\");\\n        \\n        while (!q.isEmpty()) {\\n            int size = q.size();\\n            for (int i = 0; i < size; i++) {\\n                int[] span = q.poll();\\n                int first = span[0], second = span[1], x1 = first / n, y1 = first % n, x2 = second / n, y2 = second % n;\\n                if (x1 == n - 1 && y1 == n - 2 && x2 == n - 1 && y2 == n - 1) return moves;\\n                \\n                if (x1 == x2) { // horizontal\\n                    if (y2 + 1 < n && grid[x2][y2 + 1] == 0) move(q, second, second + 1, seen); // right\\n                    if (x2 + 1 < n && grid[x1 + 1][y1] == 0 && grid[x2 + 1][y2] == 0) {\\n                        move(q, first + n, second + n, seen); // down\\n                        move(q, first, first + n, seen); // clockwise\\n                    }\\n                } \\n                \\n                if (y1 == y2) { // vertical\\n                    if (x2 + 1 < n && grid[x2 + 1][y2] == 0) move(q, second, second + n, seen); // down\\n                    if (y2 + 1 < n && grid[x1][y1 + 1] == 0 && grid[x2][y2 + 1] == 0) {\\n                        move(q, first + 1, second + 1, seen); // right\\n                        move(q, first, first + 1, seen); // counter clockwise\\n                    }\\n                } \\n            }\\n            moves++;\\n        }\\n        return -1;\\n    }\\n    \\n    private void move(Queue<int[]> q, int first, int second, Set<String> seen) {\\n        if (!seen.contains(first + \"-\" + second)) {\\n            q.offer(new int[] { first, second });\\n            seen.add(first + \"-\" + second);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 393042,
                "title": "python-3-bfs-dfs-and-dp-with-explanation-beats-100-00",
                "content": "(Note to Reader: It will be helpful to have the code at the bottom visible separately on your screen while reading this explanation)\\n\\n_**BFS Explanation:**_\\n\\nThis program uses a BFS approach starting out from the top left corner. The program starts by saving the first position of the snake into list S. You do not need to know three pieces of information to know precisely where the snake is. From the three pieces of information (location of the snake\\'s head, location of the snake\\'s tail, and its orientation), you really only need to know two pieces of information. In this porgram, we only look at the position of the snake\\'s tail and its orientation (horizontal = \\'h\\', or vertical = \\'v\\').\\n\\nThe program starts by finding the size of the square grid and stores the value as N which is important because we do not want the snake to go out of bounds. The starting location of the snake is put inside the list S. The snake\\'s tail starts at (0,0) and its orientation is horizontal. Thus S contains the tuple (0,0,\\'h\\'). T is initialized as an empty list. In each iteration of the while loop, T will contain the new positions that the snake can go to based on the entire set of current positions it is at, which is stored in S. So the list S contains all of the snakes current positions after c moves and the list T will contain all of the snakes permissible positions after c + 1 moves. The variable c is the number of moves the snake has made thus far and c is initialized to 0 since the snake has not moved yet. The set V is a set which will contain all the previously visited positions of the snake, where the positions are encoded into tuples of length 3.\\n\\nThe while loop will continue as long as there are new positions for the snake to go and the snake has not reached its destination. Note that the destination position is (N-1,N-2,\\'h\\') as given in the problem description. If there are no new positions for the snake to go and the destination has not been reached, the while loop will end and -1 is returned. The for loop iterates through every current position of the snake which is in the list S. Remember that in a BFS search you expand outward from the starting point. So you can imagine that S contains the outer expanding front of all the places that the snake could have gotten to after c moves. As the for loop iterates through S, if it finds a point in S that the snake has already visited, that point is ignored as there is no point in going in that direction again. This step is essential as otherwise the snake could potentially go in circles. An example of this is that the snake can just go clockwise, counter clockwise, clockwise, counter clockwise, over and over and over. This will cause an exponential increase in the size of S which can slow things down tremendously.\\n\\nProvided that the position we are currently analyzing in S has not been visited, the program continues onto the next line. This position tuple is stored in _i_ from the for loop. If the position tuple _i_ equals the destination tuple, the program returns c. Since we want the shortest path, there is no point in searching after the first path to the destination is reached as it can only have a larger c. For ease of coding, the row and column positions of the snake\\'s tail are called _a_ and _b_ respectively and the orientation is stored as the letter _o_. We also add the position tuple to the set of visited tuples so that we do not visit it again in the future.\\n\\nThe next part of the code looks at where the snake can move given its current location. The first if statement examines the possible next moves if the snake is currently in a horizontal position. Recall that (a,b) is the location of the snake\\'s tail. The next if statement (inside the first one) sees if the snake can move to the right horizontally. This requires checking to make sure that the snake\\'s head isn\\'t at the right edge of the grid and that there is an open space ahead of the snake\\'s head. If both conditions hold, the new location of the snake\\'s tail is added to T. Recall that T is the list of all the new potential locations that the snake can go to in move c + 1. The next if statement checks to see if there are a horizontal pair of zeros directly under the horizontally oriented snake and that the snake is not on the bottom edge of the grid. If these conditions hold then the snake has two permissible moves. It can move down, maintaining its horizontal position, or it can rotate clockwise. These lead to two new positions which are added to the growing list T. Note that when the snake rotates, its orientation changes.\\n\\nThe next if statement examines the possible next moves if the snake is currently in a vertical position. In a similar fashion it checks to see if the snake is at the right or bottom edge of the grid or if there are open spaces for it to move. If there are, it will add the new locations to T.\\n\\nAfter all of the new potential locations have been added to T, the list S is overwritten by the list T and list T is emptied. The count of the number of moves, stored in c, is increased by 1. The while loop then continues with a new list S to iterate through in the for loop. If during a for loop, as the program iterates through S, not a single new permissible position can be found, then nothing will be appended to the empty list T. If T stays empty, then S will be overwritten by it and the while loop which only runs if S is nonempty will stop and -1 will be returned.\\n\\n_**BFS Code:**_ (beats 100.00%) ( 270 ms )\\n```\\nclass Solution:\\n    def minimumMoves(self, G: List[List[int]]) -> int:\\n    \\tN, S, T, V, c = len(G), [(0, 0, \\'h\\')], [], set(), 0\\n    \\twhile S:\\n    \\t\\tfor i in S:\\n    \\t\\t\\tif i in V: continue\\n    \\t\\t\\tif i == (N-1, N-2, \\'h\\'): return c\\n    \\t\\t\\t(a, b, o), _ = i, V.add(i)\\n\\t    \\t\\tif o == \\'h\\':\\n    \\t\\t\\t\\tif b + 2 != N and G[a][b+2] == 0: T.append((a, b+1, o))\\n    \\t\\t\\t\\tif a + 1 != N and G[a+1][b] == 0 and G[a+1][b+1] == 0: T.append((a+1, b, o)), T.append((a, b, \\'v\\'))\\n    \\t\\t\\telif o == \\'v\\':\\n    \\t\\t\\t\\tif a + 2 != N and G[a+2][b] == 0: T.append((a+1, b, o))\\n    \\t\\t\\t\\tif b + 1 != N and G[a][b+1] == 0 and G[a+1][b+1] == 0: T.append((a, b+1, o)), T.append((a, b, \\'h\\'))\\n    \\t\\tS, T, c = T, [], c + 1\\n    \\treturn -1\\n\\t\\t\\n\\t\\t\\n\\t\\t\\n\\t\\t\\n```\\n_**DFS Code:**_ (Time Limit Exceeded on Test Case 12 / 42 ) (A 20 x 20 Grid takes too long with DFS)\\n```\\nclass Solution:\\n    def minimumMoves(self, G: List[List[int]]) -> int:\\n    \\tN, V, M, self.t, self.m = len(G), set(), collections.defaultdict(int), 0, math.inf\\n    \\tprint(N)\\n    \\tdef dfs(a,b,o):\\n    \\t\\tif (a,b,o) in V or M[(a,b,o)] == 2 or self.t > self.m: return\\n    \\t\\tif (a,b,o) == (N-1,N-2,\\'h\\'):\\n    \\t\\t\\tself.m = min(self.m,self.t)\\n    \\t\\t\\tfor i in V: M[i] = 1\\n    \\t\\t\\treturn\\n    \\t\\tself.t, _ = self.t + 1, V.add((a,b,o))\\n    \\t\\tif o == \\'h\\':\\n    \\t\\t\\tif b + 2 != N and G[a][b+2] == 0: dfs(a, b+1, o)\\n    \\t\\t\\tif a + 1 != N and G[a+1][b] == 0 and G[a+1][b+1] == 0: dfs(a+1, b, o), dfs(a, b, \\'v\\')\\n    \\t\\telif o == \\'v\\':\\n    \\t\\t\\tif a + 2 != N and G[a+2][b] == 0: dfs(a+1, b, o)\\n    \\t\\t\\tif b + 1 != N and G[a][b+1] == 0 and G[a+1][b+1] == 0: dfs(a, b+1, o), dfs(a, b, \\'h\\')\\n    \\t\\tif M[(a,b,o)] == 0: M[(a,b,o)] = 2\\n    \\t\\tself.t, _ = self.t - 1, V.remove((a,b,o))\\n    \\tdfs(0,0,\\'h\\')\\n    \\treturn -1 if self.m == math.inf else self.m\\n\\n\\n```\\n_**DP Code:**_ (beats ~50%) ( 420 ms )\\n```\\nclass Solution:\\n    def minimumMoves(self, G: List[List[int]]) -> int:\\n    \\tN, I, DP = len(G)-1, math.inf, [[math.inf]*2 for i in range(len(G)+1)]\\n    \\tDP[N-1][0] = I if 1 in [G[N][N],G[N][N-1]] else 0\\n    \\tfor j in range(N-2,-1,-1): DP[j][0] = (DP[j+1][0] + 1) if G[N][j] == 0 else I\\n    \\tfor i,j in itertools.product(range(N-1,-1,-1),range(N,-1,-1)):\\n    \\t\\tn = [G[i][j],G[i][min(j+1,N)],G[min(i+1,N)][j],G[min(i+1,N)][min(j+1,N)]]\\n    \\t\\tDP[j][0], DP[j][1] = min(1+DP[j+1][0],1+DP[j][0]), min(1+DP[j+1][1],1+DP[j][1])\\n    \\t\\tif 1 not in n: DP[j][0], DP[j][1] = min(DP[j][0],2+DP[j+1][1],1+DP[j][1]), min(DP[j][1],2+DP[j+1][0],1+DP[j][0])\\n    \\t\\tif 1 in [n[0],n[1]]: DP[j][0] = I\\n    \\t\\tif 1 in [n[0],n[2]]: DP[j][1] = I\\n    \\treturn -1 if DP[0][0] == I else DP[0][0]\\n\\t\\t\\n\\t\\t\\n\\t\\t\\n- Junaid Mansuri\\n(LeetCode ID)@hotmail.com",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def minimumMoves(self, G: List[List[int]]) -> int:\\n    \\tN, S, T, V, c = len(G), [(0, 0, \\'h\\')], [], set(), 0\\n    \\twhile S:\\n    \\t\\tfor i in S:\\n    \\t\\t\\tif i in V: continue\\n    \\t\\t\\tif i == (N-1, N-2, \\'h\\'): return c\\n    \\t\\t\\t(a, b, o), _ = i, V.add(i)\\n\\t    \\t\\tif o == \\'h\\':\\n    \\t\\t\\t\\tif b + 2 != N and G[a][b+2] == 0: T.append((a, b+1, o))\\n    \\t\\t\\t\\tif a + 1 != N and G[a+1][b] == 0 and G[a+1][b+1] == 0: T.append((a+1, b, o)), T.append((a, b, \\'v\\'))\\n    \\t\\t\\telif o == \\'v\\':\\n    \\t\\t\\t\\tif a + 2 != N and G[a+2][b] == 0: T.append((a+1, b, o))\\n    \\t\\t\\t\\tif b + 1 != N and G[a][b+1] == 0 and G[a+1][b+1] == 0: T.append((a, b+1, o)), T.append((a, b, \\'h\\'))\\n    \\t\\tS, T, c = T, [], c + 1\\n    \\treturn -1\\n\\t\\t\\n\\t\\t\\n\\t\\t\\n\\t\\t\\n```\n```\\nclass Solution:\\n    def minimumMoves(self, G: List[List[int]]) -> int:\\n    \\tN, V, M, self.t, self.m = len(G), set(), collections.defaultdict(int), 0, math.inf\\n    \\tprint(N)\\n    \\tdef dfs(a,b,o):\\n    \\t\\tif (a,b,o) in V or M[(a,b,o)] == 2 or self.t > self.m: return\\n    \\t\\tif (a,b,o) == (N-1,N-2,\\'h\\'):\\n    \\t\\t\\tself.m = min(self.m,self.t)\\n    \\t\\t\\tfor i in V: M[i] = 1\\n    \\t\\t\\treturn\\n    \\t\\tself.t, _ = self.t + 1, V.add((a,b,o))\\n    \\t\\tif o == \\'h\\':\\n    \\t\\t\\tif b + 2 != N and G[a][b+2] == 0: dfs(a, b+1, o)\\n    \\t\\t\\tif a + 1 != N and G[a+1][b] == 0 and G[a+1][b+1] == 0: dfs(a+1, b, o), dfs(a, b, \\'v\\')\\n    \\t\\telif o == \\'v\\':\\n    \\t\\t\\tif a + 2 != N and G[a+2][b] == 0: dfs(a+1, b, o)\\n    \\t\\t\\tif b + 1 != N and G[a][b+1] == 0 and G[a+1][b+1] == 0: dfs(a, b+1, o), dfs(a, b, \\'h\\')\\n    \\t\\tif M[(a,b,o)] == 0: M[(a,b,o)] = 2\\n    \\t\\tself.t, _ = self.t - 1, V.remove((a,b,o))\\n    \\tdfs(0,0,\\'h\\')\\n    \\treturn -1 if self.m == math.inf else self.m\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1247505,
                "title": "java-dynamic-programing-13-ms-faster-than-95",
                "content": "Here I use a 3-dimension dp table to solve the problem, \\nI regard the position of snake as \"HEAD\" and \"DIRECTION\" (0 as left-right and 1 as up-down)\\nFor the status of snake (i,j,k),\\nThe status transforming formular can be written below:\\ndp[i][j][k] = Math.min(dp[i-1][j][k],dp[i][k-1][k],dp[i][j][k^1])------left,up,and rotate\\nThe base cases can be a little complicated.\\n\\n```\\nClass Solution {\\n    public int minimumMoves(int[][] grid) {\\n        int n = grid.length;\\n        int[][][] dp = new int[n][n][2];\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                for(int k=0;k<2;k++){\\n                    if(i==0&&j==0&&k==0)\\n                        dp[i][j][k]=0;\\n                    else if(grid[i][j]==1)\\n                        dp[i][j][k]=Integer.MAX_VALUE;\\n                    else if(k==0&&(j+1>=n||grid[i][j+1]==1))\\n                        dp[i][j][k]=Integer.MAX_VALUE;\\n                    else if(k==1&&(i+1>=n||grid[i+1][j]==1))\\n                        dp[i][j][k]=Integer.MAX_VALUE;\\n                    else{\\n                        int choice1 = i-1>=0? dp[i-1][j][k]:Integer.MAX_VALUE;//go down\\n                        int choice2 = j-1>=0? dp[i][j-1][k]:Integer.MAX_VALUE;//go right\\n                        int tempMinChoice = Math.min(choice1,choice2);\\n                        dp[i][j][k] = tempMinChoice==Integer.MAX_VALUE? tempMinChoice:(tempMinChoice+1);\\n                    }\\n                }\\n                //rotate\\n                if(i+1<n&&j+1<n&&grid[i][j+1]!=1&&grid[i+1][j+1]!=1&&dp[i][j][1]!=Integer.MAX_VALUE&&dp[i][j][0]>dp[i][j][1]+1) \\n                    dp[i][j][0]=dp[i][j][1]+1;\\n                if(i+1<n&&j+1<n&&grid[i+1][j]!=1&&grid[i+1][j+1]!=1&&dp[i][j][0]!=Integer.MAX_VALUE&&dp[i][j][1]>dp[i][j][0]+1) \\n                    dp[i][j][1]=dp[i][j][0]+1;\\n            }\\n        }\\n        return dp[n-1][n-2][0]==Integer.MAX_VALUE? -1:dp[n-1][n-2][0];\\n    }\\n}\\n```\\nVote if it helps you :) Thx",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nClass Solution {\\n    public int minimumMoves(int[][] grid) {\\n        int n = grid.length;\\n        int[][][] dp = new int[n][n][2];\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                for(int k=0;k<2;k++){\\n                    if(i==0&&j==0&&k==0)\\n                        dp[i][j][k]=0;\\n                    else if(grid[i][j]==1)\\n                        dp[i][j][k]=Integer.MAX_VALUE;\\n                    else if(k==0&&(j+1>=n||grid[i][j+1]==1))\\n                        dp[i][j][k]=Integer.MAX_VALUE;\\n                    else if(k==1&&(i+1>=n||grid[i+1][j]==1))\\n                        dp[i][j][k]=Integer.MAX_VALUE;\\n                    else{\\n                        int choice1 = i-1>=0? dp[i-1][j][k]:Integer.MAX_VALUE;//go down\\n                        int choice2 = j-1>=0? dp[i][j-1][k]:Integer.MAX_VALUE;//go right\\n                        int tempMinChoice = Math.min(choice1,choice2);\\n                        dp[i][j][k] = tempMinChoice==Integer.MAX_VALUE? tempMinChoice:(tempMinChoice+1);\\n                    }\\n                }\\n                //rotate\\n                if(i+1<n&&j+1<n&&grid[i][j+1]!=1&&grid[i+1][j+1]!=1&&dp[i][j][1]!=Integer.MAX_VALUE&&dp[i][j][0]>dp[i][j][1]+1) \\n                    dp[i][j][0]=dp[i][j][1]+1;\\n                if(i+1<n&&j+1<n&&grid[i+1][j]!=1&&grid[i+1][j+1]!=1&&dp[i][j][0]!=Integer.MAX_VALUE&&dp[i][j][1]>dp[i][j][0]+1) \\n                    dp[i][j][1]=dp[i][j][0]+1;\\n            }\\n        }\\n        return dp[n-1][n-2][0]==Integer.MAX_VALUE? -1:dp[n-1][n-2][0];\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1220110,
                "title": "easy-bfs-c",
                "content": "We can solve this problem using bfs. In queue of bfs we store 3 things. Snake\\'s x coordinate,Snake\\'s y coordinate and the direction(true for horizontal, false for vertical). We don\\'t need to store head of snake as we can easily find it if we are given these 3 variables.\\n\\nWe also maintain a visited set of same 3 things(x,y,direction) which will tell us if we have visited the orientation or not. If we have already visited we simply return.\\n\\nInititally the snake\\'s tail is at (0,0) and direction is horizontal so we push (0,0,true) to our queue.\\nThen we follow simple bfs and check if we can visit left,right or rotate it and if yes we push it to the queue.\\n\\nWe need to use two loops for bfs as the inner loop is providing us options in which we can move but eventually we are going to move in just one direction so we have to count whole inner loop once only.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int n;\\n    set<vector<int>> visited;\\n    bool candown(vector<vector<int>>& grid,int x,int y,bool hor){\\n        if(!hor){\\n            if(x+2<n && grid[x+1][y]==0 && grid[x+2][y]==0 && !visited.count({x+1,y,hor})){\\n                return true;\\n            }\\n        }else{\\n            if(x+1<n && y+1<n && grid[x+1][y]==0 && grid[x+1][y+1]==0 && !visited.count({x+1,y,hor})){\\n                return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    \\n    bool canright(vector<vector<int>>& grid,int x,int y,bool hor){\\n        if(hor){\\n            if(y+2<n && grid[x][y+1]==0 && grid[x][y+2]==0 && !visited.count({x,y+1,hor})){\\n                return true;\\n            }\\n        }else{\\n            if(y+1<n && x+1<n && grid[x][y+1]==0 && grid[x+1][y+1]==0 && !visited.count({x,y+1,hor})){\\n                return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    \\n    bool canrot(vector<vector<int>>& grid,int x,int y,bool hor){\\n        if(hor){\\n            if(y+1<n && x+1<n && grid[x+1][y]==0 && grid[x+1][y+1]==0 && !visited.count({x,y,!hor})){\\n                return true;\\n            }\\n        }else{\\n            if(x+1<n && y+1<n && grid[x][y+1]==0 &&grid[x+1][y+1]==0 && !visited.count({x,y,!hor})){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    int minimumMoves(vector<vector<int>>& grid) {\\n        queue<array<int, 3>> q;\\n        q.push({0,0,true});\\n        int ans=0;\\n        n=grid.size();\\n        while(!q.empty()){\\n            int size=q.size();\\n            while(size--){\\n                auto a=q.front();\\n                q.pop();\\n                if(visited.count({a[0],a[1],a[2]})){\\n                    continue;\\n                }\\n                visited.insert({a[0],a[1],a[2]});\\n                int x=a[0];\\n                int y=a[1];\\n                if(x==n-1 && y==n-2 && a[2]==1){\\n                    return ans;\\n                }\\n                if(candown(grid,x,y,a[2])){\\n                    q.push({x+1,y,a[2]});\\n                }\\n                if(canrot(grid,x,y,a[2])){\\n                    q.push({x,y,!a[2]});\\n                }\\n                if(canright(grid,x,y,a[2])){\\n                    q.push({x,y+1,a[2]});\\n                }\\n            }\\n            ans++;\\n        }\\n        return -1;\\n    }\\n};\\n```\\n**Please upvote if you liked the solution.**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int n;\\n    set<vector<int>> visited;\\n    bool candown(vector<vector<int>>& grid,int x,int y,bool hor){\\n        if(!hor){\\n            if(x+2<n && grid[x+1][y]==0 && grid[x+2][y]==0 && !visited.count({x+1,y,hor})){\\n                return true;\\n            }\\n        }else{\\n            if(x+1<n && y+1<n && grid[x+1][y]==0 && grid[x+1][y+1]==0 && !visited.count({x+1,y,hor})){\\n                return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    \\n    bool canright(vector<vector<int>>& grid,int x,int y,bool hor){\\n        if(hor){\\n            if(y+2<n && grid[x][y+1]==0 && grid[x][y+2]==0 && !visited.count({x,y+1,hor})){\\n                return true;\\n            }\\n        }else{\\n            if(y+1<n && x+1<n && grid[x][y+1]==0 && grid[x+1][y+1]==0 && !visited.count({x,y+1,hor})){\\n                return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    \\n    bool canrot(vector<vector<int>>& grid,int x,int y,bool hor){\\n        if(hor){\\n            if(y+1<n && x+1<n && grid[x+1][y]==0 && grid[x+1][y+1]==0 && !visited.count({x,y,!hor})){\\n                return true;\\n            }\\n        }else{\\n            if(x+1<n && y+1<n && grid[x][y+1]==0 &&grid[x+1][y+1]==0 && !visited.count({x,y,!hor})){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    int minimumMoves(vector<vector<int>>& grid) {\\n        queue<array<int, 3>> q;\\n        q.push({0,0,true});\\n        int ans=0;\\n        n=grid.size();\\n        while(!q.empty()){\\n            int size=q.size();\\n            while(size--){\\n                auto a=q.front();\\n                q.pop();\\n                if(visited.count({a[0],a[1],a[2]})){\\n                    continue;\\n                }\\n                visited.insert({a[0],a[1],a[2]});\\n                int x=a[0];\\n                int y=a[1];\\n                if(x==n-1 && y==n-2 && a[2]==1){\\n                    return ans;\\n                }\\n                if(candown(grid,x,y,a[2])){\\n                    q.push({x+1,y,a[2]});\\n                }\\n                if(canrot(grid,x,y,a[2])){\\n                    q.push({x,y,!a[2]});\\n                }\\n                if(canright(grid,x,y,a[2])){\\n                    q.push({x,y+1,a[2]});\\n                }\\n            }\\n            ans++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 393922,
                "title": "java-dp-memorization-search-11ms",
                "content": "* horizontal direction: dp[x][y][0] means the min move times when the snake tail is at (x, y) and its direction is horizontal.\\n * vertical direction: dp[x][y][1] means the min move times when the snake tail is at (x, y) and its direction is vertical.\\n\\n**state transfer:**\\n\\n1.  for horizontal direction, the snake can move right, move down or rotate clock-wise\\n\\n\\t* \\t right:               precondition -> grid[x][y+2]=0\\n\\t*   down:                precondition -> grid[x+1][y]=0 & grid[x+1][y+1]=0\\n\\t*  rotate clock-wise:   precondition -> grid[x+1][y]=0 & grid[x+1][y+1]=0\\n\\t\\n\\t**if all satisfy these three conditions\\n    dp[x][y][0] = Math.min(dp[x+1][y][0], dp[x+1][y][0], dp[x][y][1]) + 1**\\n\\n2. for vertical direction, the snake can move right, move down or rotate counterclockwise\\n\\n\\t *  down: precondition -> grid[x+2][y]=0\\n\\t *  right: precondition -> grid[x][y+1]=0 & grid[x+1][y+1]=0\\n\\t * rotate counterclockwise -> grid[x][y+1]=0 & grid[x+1][y+1]=0\\n\\t \\n\\t**if all satisfy these three conditions\\n\\tdp[x][y][1] = Math.min(dp[x+1][y][1], dp[x][y+1][1], dp[x][y][0])+1**\\n\\n**attention**: to prevent same position go repeated rotate clockwise or counterclockwise, need set visited symbol.\\n\\n```\\nprivate int search(int[][] grid, int x, int y, boolean isH, Integer[][][] mem, boolean[][][] vis) {\\n\\t\\t// invalid state\\n        if (x < 0 || y < 0 || x >= m || y >= n) return Integer.MAX_VALUE;\\n        if (isH && y >= n-1) return Integer.MAX_VALUE;\\n        if (!isH && x >= m-1) return Integer.MAX_VALUE;\\n        // reach the aim ending point.\\n        if (isH && x==m-1 && y==n-2) return 0;\\n\\t\\t// caculated\\n        if (mem[x][y][isH ? 0 : 1] != null) {\\n            return mem[x][y][isH ? 0 : 1];\\n        }\\n\\t\\t// has been visited, this means this state is caculating\\n        if (vis[x][y][isH ? 0: 1]) return Integer.MAX_VALUE;\\n        // set visit symbol\\n        vis[x][y][isH ? 0: 1] = true;\\n        int ans = Integer.MAX_VALUE;\\n        // horizontal\\n        if (isH) {\\n            // right\\n            if (y+2 < n && grid[x][y+2]==0) {\\n                ans = Math.min(ans, search(grid, x, y+1, isH, mem, vis));\\n            }\\n            // down and rotate clock-wise\\n            if (x+1 < m && grid[x+1][y]==0 && grid[x+1][y+1]==0) {\\n                int way1 = search(grid, x+1, y, isH, mem, vis);   // down\\n                int way2 = search(grid, x, y, !isH, mem, vis); // rotate clockwise\\n                ans = Math.min(ans, Math.min(way1, way2));\\n            }\\n        } else {\\n            // down\\n            if (x+2 < m && grid[x+2][y] == 0) {\\n                ans = Math.min(ans, search(grid, x+1, y, isH, mem, vis));\\n            }\\n            // right or rotate counterclockwise\\n            if (y+1 < n && grid[x][y+1]==0 && grid[x+1][y+1]==0) {\\n                int way1 = search(grid, x, y+1, isH, mem, vis); // right\\n                int way2 = search(grid, x, y, !isH, mem, vis); // rotate counterclockwise\\n                ans = Math.min(ans, Math.min(way1, way2));\\n            }\\n        }\\n\\t\\t// ans= Integer.MAX_VALUE means no solution to move to aim ending.\\n        if (ans < Integer.MAX_VALUE) {\\n            ans += 1;\\n        }\\n        mem[x][y][isH ? 0:1] = ans;\\n        return ans;\\n    }\\n    public int minimumMoves(int[][] grid) {\\n        if ((m=grid.length)<=1 || (n=grid[0].length)<=1) return -1;\\n        Integer[][][] mem = new Integer[m][n][2];\\n        boolean[][][] vis = new boolean[m][n][2];\\n        if (grid[0][0]==1 || grid[0][1] == 1) {\\n            return -1;\\n        }\\n        int ans = search(grid, 0, 0, true, mem, vis);\\n        return ans==Integer.MAX_VALUE ? -1: ans;\\n\\n    }\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nprivate int search(int[][] grid, int x, int y, boolean isH, Integer[][][] mem, boolean[][][] vis) {\\n\\t\\t// invalid state\\n        if (x < 0 || y < 0 || x >= m || y >= n) return Integer.MAX_VALUE;\\n        if (isH && y >= n-1) return Integer.MAX_VALUE;\\n        if (!isH && x >= m-1) return Integer.MAX_VALUE;\\n        // reach the aim ending point.\\n        if (isH && x==m-1 && y==n-2) return 0;\\n\\t\\t// caculated\\n        if (mem[x][y][isH ? 0 : 1] != null) {\\n            return mem[x][y][isH ? 0 : 1];\\n        }\\n\\t\\t// has been visited, this means this state is caculating\\n        if (vis[x][y][isH ? 0: 1]) return Integer.MAX_VALUE;\\n        // set visit symbol\\n        vis[x][y][isH ? 0: 1] = true;\\n        int ans = Integer.MAX_VALUE;\\n        // horizontal\\n        if (isH) {\\n            // right\\n            if (y+2 < n && grid[x][y+2]==0) {\\n                ans = Math.min(ans, search(grid, x, y+1, isH, mem, vis));\\n            }\\n            // down and rotate clock-wise\\n            if (x+1 < m && grid[x+1][y]==0 && grid[x+1][y+1]==0) {\\n                int way1 = search(grid, x+1, y, isH, mem, vis);   // down\\n                int way2 = search(grid, x, y, !isH, mem, vis); // rotate clockwise\\n                ans = Math.min(ans, Math.min(way1, way2));\\n            }\\n        } else {\\n            // down\\n            if (x+2 < m && grid[x+2][y] == 0) {\\n                ans = Math.min(ans, search(grid, x+1, y, isH, mem, vis));\\n            }\\n            // right or rotate counterclockwise\\n            if (y+1 < n && grid[x][y+1]==0 && grid[x+1][y+1]==0) {\\n                int way1 = search(grid, x, y+1, isH, mem, vis); // right\\n                int way2 = search(grid, x, y, !isH, mem, vis); // rotate counterclockwise\\n                ans = Math.min(ans, Math.min(way1, way2));\\n            }\\n        }\\n\\t\\t// ans= Integer.MAX_VALUE means no solution to move to aim ending.\\n        if (ans < Integer.MAX_VALUE) {\\n            ans += 1;\\n        }\\n        mem[x][y][isH ? 0:1] = ans;\\n        return ans;\\n    }\\n    public int minimumMoves(int[][] grid) {\\n        if ((m=grid.length)<=1 || (n=grid[0].length)<=1) return -1;\\n        Integer[][][] mem = new Integer[m][n][2];\\n        boolean[][][] vis = new boolean[m][n][2];\\n        if (grid[0][0]==1 || grid[0][1] == 1) {\\n            return -1;\\n        }\\n        int ans = search(grid, 0, 0, true, mem, vis);\\n        return ans==Integer.MAX_VALUE ? -1: ans;\\n\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 392865,
                "title": "python-bfs-solution-with-explaination",
                "content": "hx and hy refer to x and y of the head, tx and ty refer to x and y of the tail. For each move, we check if the two blocks under the snake are available (if the snake is in vertical direction, then the block under the tail is always available). If so, we can choose either to rotate in clockwise direction, or to move downward for one cell. Similarly, we check the two cells to the right of the snake, and let the snake rotate counterclockwise or move rightward.\\n\\nNote: the tuple in seen represents the postion of (x of the snake head, y of the snake head, x of the snake tail, y of the snake tail). Once the snake has already reach a position, it is not necessary for the snake to visit it again. Maybe bits manipulation could save more space for my solution.\\n```\\nclass Solution:\\n    def minimumMoves(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n        q = collections.deque([(0,0,1,0,0)])\\n        seen = {(0,1,0,0)}\\n        while q:\\n            t, hx, hy, tx, ty = q.popleft()\\n            if hx == hy == tx == n - 1 and ty == n - 2:\\n                return t\\n            #Check the ceils under the snake\\n            if hx + 1 < n and not grid[hx + 1][hy] and not grid[tx + 1][ty]:\\n                #try to move downward\\n                if (hx + 1, hy, tx + 1, ty) not in seen:\\n                    q += (t + 1, hx + 1, hy, tx + 1, ty),\\n                    seen.add((hx + 1, hy, tx + 1, ty))\\n                #try to rotate clockwise\\n                if tx == hx and (tx + 1, ty, tx, ty) not in seen:\\n                    q += (t + 1, tx + 1, ty, tx, ty),\\n                    seen.add((tx + 1, ty, tx, ty))\\n            #Check the ceils to the right\\n            if hy + 1 < n and not grid[hx][hy + 1] and not grid[tx][1 + ty]:\\n                #try to move rightward\\n                if (hx, 1 + hy, tx, 1 + ty) not in seen:\\n                    q +=(t + 1, hx, 1 + hy, tx, 1 + ty),\\n                    seen.add((hx, hy + 1, tx, 1 + ty))\\n                #try to rotate counterclockwise\\n                if ty == hy and (tx, ty + 1, tx, ty) not in seen:\\n                    q += (t + 1, tx, ty + 1, tx, ty),\\n                    seen.add((tx, 1 + ty, tx, ty))\\n        return -1",
                "solutionTags": [],
                "code": "class Solution:\\n    def minimumMoves(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n        q = collections.deque([(0,0,1,0,0)])\\n        seen = {(0,1,0,0)}",
                "codeTag": "Java"
            },
            {
                "id": 696488,
                "title": "test-through-39-and-the-follow-one-wrong-answer-and-i-find-it-can-make-it",
                "content": "input:\\n[[0,0,1,0,0,0,0,0,0,0,0,0,0,0,0],[0,1,0,1,1,0,0,1,0,0,0,0,1,0,0],[0,1,0,0,0,0,1,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,1,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,1,1,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,1,0,1,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,1,0,1,0,0,1,0,0,0,1,0,0],[0,0,0,0,1,0,0,0,0,0,0,0,0,1,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,1,0,0,0,0,0,0,0,0,0,0,0],[1,0,1,1,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,1,0],[1,0,0,0,0,0,1,0,0,0,1,0,0,0,1],[0,0,1,0,1,0,0,0,0,0,0,0,0,0,0]]\\n0,0,1,0,0,0,0,0,0,0,0,0,0,0,0\\n0,1,0,1,1,0,0,1,0,0,0,0,1,0,0\\n0,1,0,0,0,0,1,0,0,1,0,0,0,0,0\\n0,0,0,0,0,0,1,0,0,0,0,0,0,0,0\\n0,0,0,0,0,0,1,1,0,0,0,0,0,0,0\\n0,0,0,0,0,0,0,0,0,1,0,1,0,0,0\\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0\\n0,0,0,1,0,1,0,0,1,0,0,0,1,0,0\\n0,0,0,0,1,0,0,0,0,0,0,0,0,1,0\\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0\\n0,0,0,1,0,0,0,0,0,0,0,0,0,0,0\\n1,0,1,1,0,0,0,0,0,0,0,0,0,0,0\\n0,0,0,0,0,0,0,0,0,0,0,0,0,1,0\\n1,0,0,0,0,0,1,0,0,0,1,0,0,0,1\\n0,0,1,0,1,0,0,0,0,0,0,0,0,0,0\\nmy code is as follow:\\nclass Solution {\\npublic:\\n    int minimumMoves(std::vector<std::vector<int>> const & grid) {\\n        int rowSize = grid.size();\\n        if (0 == rowSize) {\\n            return 0;\\n        }\\n\\n        int colSize = grid[0].size();\\n        if (0 == colSize) {\\n            return 0;\\n        }\\n\\n        std::unordered_map<int, int> visited;\\n        std::queue<int> todo;\\n        int code = encode(0, 1, 0, 0);\\n        todo.emplace(code);\\n        visited[code] = 0;\\n        int res = INT_MAX;\\n        while (todo.size()) {\\n            int cur = todo.front(); todo.pop();\\n            if (visited[cur] > res) {\\n                continue;\\n            }\\n            int headRow = 0, headCol = 0, endRow = 0, endCol = 0;\\n            decode(cur, headRow, headCol, endRow, endCol);\\n            if (headRow == rowSize - 1 && headCol == colSize - 1 &&\\n                    endRow == headRow && endCol == headCol - 1) {\\n                res = std::min(res, visited[cur]);\\n            }\\n            if (canRight(grid, headRow, headCol, endRow, endCol)) {\\n                int newCode = encode(headRow, headCol, endRow, endCol);\\n                if (visited.find(newCode) == visited.end() || visited[newCode] > visited[cur] + 1) {\\n                    todo.emplace(newCode);\\n                    visited[newCode] = visited[cur] + 1;\\n                }\\n            }\\n\\n            decode(cur, headRow, headCol, endRow, endCol);\\n            if (canDown(grid, headRow, headCol, endRow, endCol)) {\\n                int newCode = encode(headRow, headCol, endRow, endCol);\\n                if (visited.find(newCode) == visited.end() || visited[newCode] > visited[cur] + 1) {\\n                    todo.emplace(newCode);\\n                    visited[newCode] = visited[cur] + 1;\\n                }\\n            }\\n\\n            decode(cur, headRow, headCol, endRow, endCol);\\n            if (canClockWise(grid, headRow, headCol, endRow, endCol)) {\\n                int newCode = encode(headRow, headCol, endRow, endCol);\\n                if (visited.find(newCode) == visited.end() || visited[newCode] > visited[cur] + 1) {\\n                    todo.emplace(newCode);\\n                    visited[newCode] = visited[cur] + 1;\\n                }\\n            }\\n\\n            decode(cur, headRow, headCol, endRow, endCol);\\n            if (canCounterClockWise(grid, headRow, headCol, endRow, endCol)) {\\n                int newCode = encode(headRow, headCol, endRow, endCol);\\n                if (visited.find(newCode) == visited.end() || visited[newCode] > visited[cur] + 1) {\\n                    todo.emplace(newCode);\\n                    visited[newCode] = visited[cur] + 1;\\n                }\\n            }\\n        }\\n        return INT_MAX == res ? -1 : res;\\n    }\\nprivate:\\n    int encode(int headRow, int headCol, int endRow, int endCol) {\\n        return (headRow << 24) | (headCol << 16) | (endRow << 8) | (endCol);\\n    }\\n\\n    void decode(int res, int & headRow, int & headCol, int & endRow, int & endCol) {\\n        headRow = (res >> 24) & 0xFF;\\n        headCol = (res >> 16) & 0xFF;\\n        endRow = (res >> 8) & 0xFF;\\n        endCol = res & 0xFF;\\n    }\\n\\n    bool canRight(std::vector<std::vector<int>> const & grid,\\n            int & headRow, int & headCol, int & endRow, int & endCol) {\\n        int newHeadCol = headCol + 1;\\n        if (newHeadCol >= grid[headRow].size() || 1 == grid[headRow][newHeadCol]) {\\n            return false;\\n        }\\n        int newEndCol = newHeadCol;\\n        if (headCol == endCol) {\\n            if (1 == grid[endRow][newEndCol]) {\\n                return false;\\n            }\\n        } else {\\n            newEndCol = headCol;\\n        }\\n        headCol = newHeadCol;\\n        endCol = newEndCol;\\n        return true;\\n    }\\n\\n    bool canDown(std::vector<std::vector<int>> const & grid,\\n            int & headRow, int & headCol, int & endRow, int & endCol) {\\n        int newHeadRow = headRow + 1;\\n        if (newHeadRow >= grid.size() || 1 == grid[newHeadRow][headCol]) {\\n            return false;\\n        }\\n        int newEndRow = newHeadRow;\\n        if (headRow == endRow) {\\n            if (1 == grid[newEndRow][endCol]) {\\n                return false;\\n            }\\n        } else {\\n            newEndRow = headRow;\\n        }\\n        headRow = newHeadRow;\\n        endRow = newEndRow;\\n        return true;\\n    }\\n\\n    bool canClockWise(std::vector<std::vector<int>> const & grid,\\n            int & headRow, int & headCol, int & endRow, int & endCol) {\\n        if (headRow != endRow) {\\n            return false;\\n        }\\n        int newHeadRow = endRow + 1;\\n        if (newHeadRow >= grid.size() || 1 == grid[newHeadRow][endCol]) {\\n            return false;\\n        }\\n        headRow = newHeadRow;\\n        headCol = endCol;\\n        return true;\\n    }\\n\\n    bool canCounterClockWise(std::vector<std::vector<int>> const & grid,\\n            int & headRow, int & headCol, int & endRow, int & endCol) {\\n        if (headCol != endCol) {\\n            return false;\\n        }\\n        int newHeadCol = endCol + 1;\\n        if (newHeadCol >= grid[endRow].size() || 1 == grid[endRow][newHeadCol]) {\\n            return false;\\n        }\\n        headRow = endRow;\\n        headCol = newHeadCol;\\n        return true;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int minimumMoves(std::vector<std::vector<int>> const & grid) {\\n        int rowSize = grid.size();\\n        if (0 == rowSize) {\\n            return 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 393145,
                "title": "javascript-easy-to-understand-bfs-128ms",
                "content": "Since we need to find out the minimum steps from one fixed point to another fixed point. The straight forward solution to do this is BFS.\\n\\n- Maintain a `visited` set to prevent endless loop\\n- Use `x`, `y` and `status` to identifies a status uniquely\\n- Traversal all possible status for current step and get the possible status for next step\\n- Finally get the answer\\n\\n```js\\nconst minimumMoves = grid => {\\n  const visited = new Set();\\n  const n = grid.length;\\n  let queue = [[0, 0, \"h\"]];\\n  let step = 0;\\n  while (queue.length) {\\n    let next = [];\\n    for (let i = 0; i < queue.length; ++i) {\\n      const key = queue[i].join(\"-\");\\n      if (visited.has(key)) continue;\\n      visited.add(key);\\n      const [x, y, status] = queue[i];\\n      if (x === n - 1 && y === n - 2 && status === \"h\") return step;\\n      if (status === \"h\") {\\n        x + 1 < n && grid[x + 1][y] === 0 && grid[x + 1][y + 1] === 0 && next.push([x, y, \"v\"]) && next.push([x + 1, y, \"h\"]);\\n        y + 2 < n && grid[x][y + 2] === 0 && next.push([x, y + 1, \"h\"]);\\n      } else {\\n        y + 1 < n && grid[x][y + 1] === 0 && grid[x + 1][y + 1] === 0 && next.push([x, y, \"h\"]) && next.push([x, y + 1, \"v\"]);\\n        x + 2 < n && grid[x + 2][y] === 0 && next.push([x + 1, y, \"v\"]);\\n      }\\n    }\\n    ++step;\\n    queue = next;\\n  }\\n  return -1;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nconst minimumMoves = grid => {\\n  const visited = new Set();\\n  const n = grid.length;\\n  let queue = [[0, 0, \"h\"]];\\n  let step = 0;\\n  while (queue.length) {\\n    let next = [];\\n    for (let i = 0; i < queue.length; ++i) {\\n      const key = queue[i].join(\"-\");\\n      if (visited.has(key)) continue;\\n      visited.add(key);\\n      const [x, y, status] = queue[i];\\n      if (x === n - 1 && y === n - 2 && status === \"h\") return step;\\n      if (status === \"h\") {\\n        x + 1 < n && grid[x + 1][y] === 0 && grid[x + 1][y + 1] === 0 && next.push([x, y, \"v\"]) && next.push([x + 1, y, \"h\"]);\\n        y + 2 < n && grid[x][y + 2] === 0 && next.push([x, y + 1, \"h\"]);\\n      } else {\\n        y + 1 < n && grid[x][y + 1] === 0 && grid[x + 1][y + 1] === 0 && next.push([x, y, \"h\"]) && next.push([x, y + 1, \"v\"]);\\n        x + 2 < n && grid[x + 2][y] === 0 && next.push([x + 1, y, \"v\"]);\\n      }\\n    }\\n    ++step;\\n    queue = next;\\n  }\\n  return -1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2616203,
                "title": "c-bfs-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumMoves(vector<vector<int>>&grid){\\n        int n=grid.size(),ans=0;\\n        map<pair<int,pair<int,int>>,int>mp;\\n        queue<pair<int,pair<int,int>>>q;\\n        \\n        q.push({0,{0,1}});\\n        mp[{0,{0,1}}]++;\\n        int i=0;\\n        while(q.size()>0){\\n            int m=q.size();\\n            while(m--)\\n            {\\n                int x=q.front().second.first,y=q.front().second.second,pos=q.front().first;\\n                q.pop();\\n                if(x==n-1 && y==n-1 && pos==0)return ans;\\n                if(pos==0)\\n                {\\n                    if(y+1<n && grid[x][y+1]==0 && mp.find({0,{x,y+1}})==mp.end()){\\n                        q.push({0,{x,y+1}});\\n                        mp[{0,{x,y+1}}]++;\\n                    }\\n                    if(x+1<n && grid[x+1][y]==0 && grid[x+1][y-1]==0 && mp.find({0,{x+1,y}})==mp.end()){\\n                        q.push({0,{x+1,y}});\\n                        mp[{0,{x+1,y}}]++;\\n                    }\\n                    if(x+1<n && grid[x+1][y]==0 && grid[x+1][y-1]==0 && mp.find({1,{x+1,y-1}})==mp.end()){\\n                        q.push({1,{x+1,y-1}});\\n                        mp[{1,{x+1,y-1}}]++;\\n                    }\\n                }else{\\n                    if(x+1<n && grid[x+1][y]==0 && mp.find({1,{x+1,y}})==mp.end()){\\n                        q.push({1,{x+1,y}});\\n                        mp[{1,{x+1,y}}]++;\\n                    }\\n                    if(y+1<n && grid[x][y+1]==0 && grid[x-1][y+1]==0 && mp.find({1,{x,y+1}})==mp.end()){\\n                         q.push({1,{x,y+1}});\\n                         mp[{1,{x,y+1}}]++;\\n                    }\\n                    if(y+1<n && grid[x][y+1]==0 && grid[x-1][y+1]==0 && mp.find({0,{x-1,y+1}})==mp.end()){\\n                         q.push({0,{x-1,y+1}});\\n                         mp[{0,{x-1,y+1}}]++;\\n                    }\\n                }\\n            }\\n            ans++;\\n        }\\n        return -1;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int minimumMoves(vector<vector<int>>&grid){\\n        int n=grid.size(),ans=0;\\n        map<pair<int,pair<int,int>>,int>mp;\\n        queue<pair<int,pair<int,int>>>q;\\n        \\n        q.push({0,{0,1}",
                "codeTag": "Java"
            },
            {
                "id": 1134913,
                "title": "python3-dijkstra-s-algo",
                "content": "\\n```\\nclass Solution:\\n    def minimumMoves(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n        dist = {(0, 0, 0, 1): 0}\\n        pq = [(0, 0, 0, 0, 1)]\\n        while pq: \\n            x, i, j, ii, jj = heappop(pq)\\n            if i == n-1 and j == n-2 and ii == n-1 and jj == n-1: return x\\n            if ii+1 < n and grid[i+1][j] == grid[ii+1][jj] == 0 and x+1 < dist.get((i+1, j, ii+1, jj), inf): \\n                heappush(pq, (x+1, i+1, j, ii+1, jj))\\n                dist[i+1, j, ii+1, jj] = x + 1\\n            if jj+1 < n and grid[i][j+1] == grid[ii][jj+1] == 0 and x+1 < dist.get((i, j+1, ii, jj+1), inf): \\n                heappush(pq, (x+1, i, j+1, ii, jj+1))\\n                dist[i, j+1, ii, jj+1] = x + 1\\n            if i == ii and ii+1 < n and grid[i+1][j] == grid[i+1][jj] == 0 and x+1 < dist.get((i, j, i+1, j), inf): \\n                heappush(pq, (x+1, i, j, i+1, j))\\n                dist[i, j, i+1, j] = x + 1\\n            if j == jj and jj+1 < n and grid[i][j+1] == grid[ii][j+1] == 0 and x+1 < dist.get((i, j, i, j+1), inf): \\n                heappush(pq, (x+1, i, j, i, j+1))\\n                dist[i, j, i, j+1] = x + 1\\n        return -1 \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumMoves(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n        dist = {(0, 0, 0, 1): 0}\\n        pq = [(0, 0, 0, 0, 1)]\\n        while pq: \\n            x, i, j, ii, jj = heappop(pq)\\n            if i == n-1 and j == n-2 and ii == n-1 and jj == n-1: return x\\n            if ii+1 < n and grid[i+1][j] == grid[ii+1][jj] == 0 and x+1 < dist.get((i+1, j, ii+1, jj), inf): \\n                heappush(pq, (x+1, i+1, j, ii+1, jj))\\n                dist[i+1, j, ii+1, jj] = x + 1\\n            if jj+1 < n and grid[i][j+1] == grid[ii][jj+1] == 0 and x+1 < dist.get((i, j+1, ii, jj+1), inf): \\n                heappush(pq, (x+1, i, j+1, ii, jj+1))\\n                dist[i, j+1, ii, jj+1] = x + 1\\n            if i == ii and ii+1 < n and grid[i+1][j] == grid[i+1][jj] == 0 and x+1 < dist.get((i, j, i+1, j), inf): \\n                heappush(pq, (x+1, i, j, i+1, j))\\n                dist[i, j, i+1, j] = x + 1\\n            if j == jj and jj+1 < n and grid[i][j+1] == grid[ii][j+1] == 0 and x+1 < dist.get((i, j, i, j+1), inf): \\n                heappush(pq, (x+1, i, j, i, j+1))\\n                dist[i, j, i, j+1] = x + 1\\n        return -1 \\n```",
                "codeTag": "Java"
            },
            {
                "id": 741472,
                "title": "java-bfs",
                "content": "```\\n    public int minimumMoves(int[][] g) {\\n        int n = g.length, step = 0;\\n        Set<Integer> vs = new HashSet<>();\\n        Queue<int[]> q = new LinkedList<>();\\n        if (g[0][0] == 1 || g[0][1] == 1) return -1;\\n        q.offer(new int[]{0, 1, 0});\\n        vs.add(2);\\n        int[][] dir = new int[][]{{0, 1}, {1, 0}};\\n        while (!q.isEmpty()) {\\n            for (int i = 0, len = q.size(); i < len; i++) {\\n                int[] curr = q.poll();\\n                if (curr[0] == n - 1 && curr[1] == n - 1 && curr[2] == 0) return step;\\n                int r = curr[0] + dir[curr[2]][0], c = curr[1] + dir[curr[2]][1], hash = (r * n + c) * 2 + curr[2];\\n                if (r < n && c < n && g[r][c] == 0 && !vs.contains(hash)) {\\n                    vs.add(hash);\\n                    q.offer(new int[]{r, c, curr[2]});\\n                }\\n                if (curr[2] == 0 && curr[1] > 0) {\\n                    r = curr[0] + 1; c = curr[1] - 1; hash = (r * n + c) * 2 + 1;\\n                    if (r < n && g[r][curr[1]] == 0 && g[r][c] == 0) {\\n                        if (!vs.contains(hash)) {\\n                            vs.add(hash);\\n                            q.offer(new int[]{r, c, 1});\\n                        }\\n                        hash = (r * n + ++c) * 2 + 0;\\n                        if (!vs.contains(hash)) {\\n                            vs.add(hash);\\n                            q.offer(new int[]{r, c, 0});\\n                        }\\n                    }\\n                }\\n                if (curr[2] == 1 && curr[0] > 0) {\\n                    r = curr[0] - 1; c = curr[1] + 1; hash = (r * n + c) * 2 + 0;\\n                    if (c < n && g[curr[0]][c] == 0 && g[r][c] == 0 ) {\\n                        if (!vs.contains(hash)){\\n                            vs.add(hash);\\n                            q.offer(new int[]{r, c, 0});\\n                        }\\n                        hash = (++r * n + c) * 2 + 1;\\n                        if (!vs.contains(hash)) {\\n                            vs.add(hash);\\n                            q.offer(new int[]{r, c, 1});\\n                        }\\n                    }\\n                }\\n            }\\n            step++;\\n        }\\n        return -1;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int minimumMoves(int[][] g) {\\n        int n = g.length, step = 0;\\n        Set<Integer> vs = new HashSet<>();\\n        Queue<int[]> q = new LinkedList<>();\\n        if (g[0][0] == 1 || g[0][1] == 1) return -1;\\n        q.offer(new int[]{0, 1, 0});\\n        vs.add(2);\\n        int[][] dir = new int[][]{{0, 1}, {1, 0}};\\n        while (!q.isEmpty()) {\\n            for (int i = 0, len = q.size(); i < len; i++) {\\n                int[] curr = q.poll();\\n                if (curr[0] == n - 1 && curr[1] == n - 1 && curr[2] == 0) return step;\\n                int r = curr[0] + dir[curr[2]][0], c = curr[1] + dir[curr[2]][1], hash = (r * n + c) * 2 + curr[2];\\n                if (r < n && c < n && g[r][c] == 0 && !vs.contains(hash)) {\\n                    vs.add(hash);\\n                    q.offer(new int[]{r, c, curr[2]});\\n                }\\n                if (curr[2] == 0 && curr[1] > 0) {\\n                    r = curr[0] + 1; c = curr[1] - 1; hash = (r * n + c) * 2 + 1;\\n                    if (r < n && g[r][curr[1]] == 0 && g[r][c] == 0) {\\n                        if (!vs.contains(hash)) {\\n                            vs.add(hash);\\n                            q.offer(new int[]{r, c, 1});\\n                        }\\n                        hash = (r * n + ++c) * 2 + 0;\\n                        if (!vs.contains(hash)) {\\n                            vs.add(hash);\\n                            q.offer(new int[]{r, c, 0});\\n                        }\\n                    }\\n                }\\n                if (curr[2] == 1 && curr[0] > 0) {\\n                    r = curr[0] - 1; c = curr[1] + 1; hash = (r * n + c) * 2 + 0;\\n                    if (c < n && g[curr[0]][c] == 0 && g[r][c] == 0 ) {\\n                        if (!vs.contains(hash)){\\n                            vs.add(hash);\\n                            q.offer(new int[]{r, c, 0});\\n                        }\\n                        hash = (++r * n + c) * 2 + 1;\\n                        if (!vs.contains(hash)) {\\n                            vs.add(hash);\\n                            q.offer(new int[]{r, c, 1});\\n                        }\\n                    }\\n                }\\n            }\\n            step++;\\n        }\\n        return -1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 457270,
                "title": "c-bfs-50-runtime-100-memory",
                "content": "BFS, tries for all possible states, tracks which ones have been visited with State\\'s id so we don\\'t visit those again\\n\\n\\n\\'\\'\\'\\nclass Solution {\\n    public:\\n        int N;\\n    const int dir[4][2] = { {-1, 0 }, { 0, 1 }, { 1, 0 }, { 0, -1 } };\\n    struct State {\\n        int r, c, d, moves, id;\\n        State(int r, int c, int d, int moves): r(r), c(c), d(d), moves(moves), id(r * 10000 + c * 100 + d) {}\\n    };\\n\\n    int minimumMoves(vector < vector < int >> & grid) {\\n        N = grid.size();\\n        int res = INT_MAX;\\n        queue < State > que;\\n        unordered_set < int > vis;\\n        que.push(State(0, 0, 1, 0)); //original state\\n        while (!que.empty()) {\\n            State curr = que.front();\\n            que.pop();\\n            int d = curr.d, tr = curr.r, tc = curr.c, hr = tr + dir[d][0], hc = tc + dir[d][1];\\n            if (out(tr) || out(tc) || out(hr) || out(hc) || grid[hr][hc] == 1 || grid[tr][tc] == 1 || vis.count(curr.id)) continue; //bad conditions\\n            if (reachEnd(curr)) { //yay!\\n                res = min(res, curr.moves);\\n                continue;\\n            }\\n            vis.insert(curr.id);\\n            que.push(State(tr, tc + 1, d, curr.moves + 1)); //shift right\\n            que.push(State(tr + 1, tc, d, curr.moves + 1)); //shift down\\n            if (tr == hr && tr != N - 1 && grid[tr + 1][tc] == 0 && grid[hr + 1][hc] == 0) que.push(State(tr, tc, (d + 1) % 4, curr.moves +\\n            1)); //horizontal? inbound? both cells below are 0? then rotate clockwise\\n            if (tc == hc && tc != N - 1 && grid[tr][tc + 1] == 0 && grid[hr][hc + 1] == 0) que.push(State(tr, tc, (d + 3) % 4, curr.moves +\\n            1)); //vertical? inbound? both cells right are 0? rotate ccw\\n        }\\n        return res == INT_MAX ? -1 : res; //we were never able to reach the end\\n    }\\n\\n    bool out(int curr) {\\n        return curr < 0 || curr >= N;\\n    }\\n\\n    bool reachEnd(State curr) {\\n        int tr = curr.r, tc = curr.c, hr = tr + dir[curr.d][0], hc = tc + dir[curr.d][1];\\n        return tr == N - 1 && hr == N - 1 && hc == N - 1 && tc == N - 2;\\n    }\\n\\n\\n};\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int N;\\n    const int dir[4][2] = { {-1, 0 }",
                "codeTag": "Java"
            },
            {
                "id": 393584,
                "title": "java-organized-bfs-solution-beats-100-both-time-and-space-complexity",
                "content": "Create a class to represent the Position of the snake and the number of moves it took to reach that Position.\\n\\nTraverse BFS to traverse the closest positions FIRST, and saving the already traversed Positions in a Visited Set to avoid traversing them again. This works because the first traversal of a Position WILL be the SHORTEST since we\\'re using BFS.\\n\\nFor each iteration, check to see if position has reached the target, if true, then return the saved number of Moves. No need to explore more paths since with the given number of moves (Right, Down, CounterClockwise, Clockwise) with no repeated positions allowed, if the snake reaches the end, it will always be in the same number of moves.\\nE.g: If the Snake reaches the end in 11 moves, it won\\'t be able to reach the end in more or less moves if another solution exists.\\n\\n```\\nclass Position {\\n    int x1 = 0;\\n    int y1 = 0;\\n    int x2 = 0;\\n    int y2 = 0;\\n    int moves;\\n    // (x1, y1) is front\\n    // (x2, y2) is behind\\n    public Position(int x1, int y1, int x2, int y2) {\\n        this.x1 = x1;\\n        this.x2 = x2;\\n        this.y1 = y1;\\n        this.y2 = y2;\\n        this.moves = 0;\\n    }\\n    \\n    public Position(int x1, int y1, int x2, int y2, int moves) {\\n        this.x1 = x1;\\n        this.x2 = x2;\\n        this.y1 = y1;\\n        this.y2 = y2;\\n        this.moves = moves;\\n    }\\n    \\n    // Used to compare Positions within Set to avoid duplicates\\n    @Override \\n    public boolean equals(Object o) {\\n        if (this == o) return true;\\n        if (o == null) return false;\\n        if (!(o instanceof Position)) {\\n            return false;\\n        }\\n        Position p = (Position) o;\\n        return (p.x1 == this.x1 && p.y1 == this.y1\\n           && p.x2 == this.x2 && p.y2 == this.y2);\\n    }\\n    @Override\\n    public int hashCode() {\\n        int result = 17;\\n        result = 31 * result + this.x1;\\n        result = 31 * result + this.x2;\\n        result = 31 * result + this.y1;\\n        result = 31 * result + this.y2;\\n        return result;\\n        \\n    }\\n}\\npublic class Solution {\\n    private int n;\\n    private Set<Position> visited;\\n    public int minimumMoves(int[][] grid) {\\n        if (grid == null || grid.length == 0 || grid[0].length == 0) return -1;\\n        \\n        // Initializing variables, setup \\n        n = grid.length;\\n        visited = new HashSet<Position>();\\n        Position position = new Position(0, 1, 0, 0);\\n        Queue<Position> q = new LinkedList<>();\\n        \\n        q.offer(position);\\n        if (!validateValidP(grid, position)) {\\n            return -1;\\n        }\\n        \\n        // BFS\\n        while (!q.isEmpty()) {\\n            Position cur = q.poll();\\n            Position right = moveRight(grid, cur, cur.moves);\\n            Position down = moveDown(grid, cur, cur.moves);\\n            Position clock = moveClock(grid, cur, cur.moves);\\n            Position counterClock = moveCounterClock(grid, cur, cur.moves);\\n            if (validateWin(cur)) {\\n                return cur.moves;\\n            }\\n            if (right != null) {\\n                q.offer(right);\\n            }\\n            if (down != null) {\\n                q.offer(down);\\n            }\\n            if (clock != null) {\\n                q.offer(clock);\\n            }\\n            if (counterClock != null) {\\n                q.offer(counterClock);\\n            }\\n        }\\n        return -1;\\n        \\n    }\\n    private Position moveRight(int[][] grid, Position p, int moves) {\\n        Position rightP = new Position(p.x1, p.y1 + 1, p.x2, p.y2 + 1, moves + 1);\\n        if (validateValidP(grid, rightP)) {\\n            return rightP;\\n        }\\n        return null;\\n    }\\n    private Position moveDown(int[][] grid, Position p, int moves) {\\n        Position downP = new Position(p.x1 + 1, p.y1, p.x2 + 1, p.y2, moves + 1);\\n        if (validateValidP(grid, downP)) {\\n            return downP;\\n        }\\n        return null;\\n    }\\n    private Position moveClock(int[][] grid, Position p, int moves) {\\n        // Not horizontal\\n        if (p.y1 != p.y2 + 1) {\\n            return null;\\n        }\\n        if (p.x1 + 1 >= n || grid[p.x1 + 1][p.y1] == 1 || p.x2 + 1 >= n || grid[p.x2 + 1][p.y2] == 1) {\\n            return null; // Blocker\\n        }\\n        Position clockP = new Position(p.x1 + 1, p.y1 - 1, p.x2, p.y2, moves + 1);\\n        // Cannot move back to same position in next position\\n        if (validateValidP(grid, clockP)) {\\n            return clockP;\\n        }\\n        return null;\\n    }\\n    private Position moveCounterClock(int[][] grid, Position p, int moves) {\\n        // Not Vertical\\n        if (p.x1 != p.x2 + 1) {\\n            return null;\\n        }\\n        if (p.y1 + 1 >= n || grid[p.x1][p.y1 + 1] == 1 || p.y2 + 1 >= n || grid[p.x2][p.y2 + 1] == 1) {\\n            return null; // Blocker\\n        }\\n        Position counterClockP = new Position(p.x1 - 1, p.y1 + 1, p.x2, p.y2, moves + 1);\\n        if (validateValidP(grid, counterClockP)) {\\n            return counterClockP;\\n        }\\n        return null;\\n    }\\n    private boolean validateWin(Position p) {\\n        if (p.x1 == n - 1 && p.y1 == n - 1\\n            && p.x2 == n - 1 && p.y2 == n - 2) {\\n            return true;\\n        }\\n        return false;\\n    }\\n    private boolean validateValidP(int[][] grid, Position p) {\\n        if (p.x1 < 0 || p.x1 >= n \\n            || p.x2 < 0 || p.x2 >= n\\n           || p.y1 < 0 || p.y1 >= n\\n            || p.y2 < 0 || p.y2 >= n) {\\n            return false;\\n        }\\n        if (grid[p.x1][p.y1] == 1 || grid[p.x2][p.y2] == 1) {\\n            return false;\\n        }\\n        return visited.add(p);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Position {\\n    int x1 = 0;\\n    int y1 = 0;\\n    int x2 = 0;\\n    int y2 = 0;\\n    int moves;\\n    // (x1, y1) is front\\n    // (x2, y2) is behind\\n    public Position(int x1, int y1, int x2, int y2) {\\n        this.x1 = x1;\\n        this.x2 = x2;\\n        this.y1 = y1;\\n        this.y2 = y2;\\n        this.moves = 0;\\n    }\\n    \\n    public Position(int x1, int y1, int x2, int y2, int moves) {\\n        this.x1 = x1;\\n        this.x2 = x2;\\n        this.y1 = y1;\\n        this.y2 = y2;\\n        this.moves = moves;\\n    }\\n    \\n    // Used to compare Positions within Set to avoid duplicates\\n    @Override \\n    public boolean equals(Object o) {\\n        if (this == o) return true;\\n        if (o == null) return false;\\n        if (!(o instanceof Position)) {\\n            return false;\\n        }\\n        Position p = (Position) o;\\n        return (p.x1 == this.x1 && p.y1 == this.y1\\n           && p.x2 == this.x2 && p.y2 == this.y2);\\n    }\\n    @Override\\n    public int hashCode() {\\n        int result = 17;\\n        result = 31 * result + this.x1;\\n        result = 31 * result + this.x2;\\n        result = 31 * result + this.y1;\\n        result = 31 * result + this.y2;\\n        return result;\\n        \\n    }\\n}\\npublic class Solution {\\n    private int n;\\n    private Set<Position> visited;\\n    public int minimumMoves(int[][] grid) {\\n        if (grid == null || grid.length == 0 || grid[0].length == 0) return -1;\\n        \\n        // Initializing variables, setup \\n        n = grid.length;\\n        visited = new HashSet<Position>();\\n        Position position = new Position(0, 1, 0, 0);\\n        Queue<Position> q = new LinkedList<>();\\n        \\n        q.offer(position);\\n        if (!validateValidP(grid, position)) {\\n            return -1;\\n        }\\n        \\n        // BFS\\n        while (!q.isEmpty()) {\\n            Position cur = q.poll();\\n            Position right = moveRight(grid, cur, cur.moves);\\n            Position down = moveDown(grid, cur, cur.moves);\\n            Position clock = moveClock(grid, cur, cur.moves);\\n            Position counterClock = moveCounterClock(grid, cur, cur.moves);\\n            if (validateWin(cur)) {\\n                return cur.moves;\\n            }\\n            if (right != null) {\\n                q.offer(right);\\n            }\\n            if (down != null) {\\n                q.offer(down);\\n            }\\n            if (clock != null) {\\n                q.offer(clock);\\n            }\\n            if (counterClock != null) {\\n                q.offer(counterClock);\\n            }\\n        }\\n        return -1;\\n        \\n    }\\n    private Position moveRight(int[][] grid, Position p, int moves) {\\n        Position rightP = new Position(p.x1, p.y1 + 1, p.x2, p.y2 + 1, moves + 1);\\n        if (validateValidP(grid, rightP)) {\\n            return rightP;\\n        }\\n        return null;\\n    }\\n    private Position moveDown(int[][] grid, Position p, int moves) {\\n        Position downP = new Position(p.x1 + 1, p.y1, p.x2 + 1, p.y2, moves + 1);\\n        if (validateValidP(grid, downP)) {\\n            return downP;\\n        }\\n        return null;\\n    }\\n    private Position moveClock(int[][] grid, Position p, int moves) {\\n        // Not horizontal\\n        if (p.y1 != p.y2 + 1) {\\n            return null;\\n        }\\n        if (p.x1 + 1 >= n || grid[p.x1 + 1][p.y1] == 1 || p.x2 + 1 >= n || grid[p.x2 + 1][p.y2] == 1) {\\n            return null; // Blocker\\n        }\\n        Position clockP = new Position(p.x1 + 1, p.y1 - 1, p.x2, p.y2, moves + 1);\\n        // Cannot move back to same position in next position\\n        if (validateValidP(grid, clockP)) {\\n            return clockP;\\n        }\\n        return null;\\n    }\\n    private Position moveCounterClock(int[][] grid, Position p, int moves) {\\n        // Not Vertical\\n        if (p.x1 != p.x2 + 1) {\\n            return null;\\n        }\\n        if (p.y1 + 1 >= n || grid[p.x1][p.y1 + 1] == 1 || p.y2 + 1 >= n || grid[p.x2][p.y2 + 1] == 1) {\\n            return null; // Blocker\\n        }\\n        Position counterClockP = new Position(p.x1 - 1, p.y1 + 1, p.x2, p.y2, moves + 1);\\n        if (validateValidP(grid, counterClockP)) {\\n            return counterClockP;\\n        }\\n        return null;\\n    }\\n    private boolean validateWin(Position p) {\\n        if (p.x1 == n - 1 && p.y1 == n - 1\\n            && p.x2 == n - 1 && p.y2 == n - 2) {\\n            return true;\\n        }\\n        return false;\\n    }\\n    private boolean validateValidP(int[][] grid, Position p) {\\n        if (p.x1 < 0 || p.x1 >= n \\n            || p.x2 < 0 || p.x2 >= n\\n           || p.y1 < 0 || p.y1 >= n\\n            || p.y2 < 0 || p.y2 >= n) {\\n            return false;\\n        }\\n        if (grid[p.x1][p.y1] == 1 || grid[p.x2][p.y2] == 1) {\\n            return false;\\n        }\\n        return visited.add(p);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 393176,
                "title": "java-19ms-concise-bfs-solution-with-explanation-please-comment-if-you-see-things-can-improve",
                "content": "```\\nclass Solution {\\n    public int minimumMoves(int[][] grid) {\\n        if(grid == null || grid.length < 1 || grid[0].length < 2) {\\n            return -1;\\n        } \\n        \\n        int n = grid.length, moves = 0;\\n        if(grid[n - 1][n-2] == 1 || grid[n-1][n-1] == 1) {\\n            return -1;\\n        }\\n        \\n        boolean[][][] visited = new boolean[n][n][2];                 // location of the tail and two directions\\n        Deque<Position> frontier = new LinkedList<Position>(), newFrontier = null;\\n        Position target = new Position(n - 1, n - 2, 0), newP = null;\\n        frontier.add(new Position(0, 0, 0));\\n        visited[0][0][0] = true;\\n        while(frontier.size() > 0) {\\n           ++moves;\\n            newFrontier = new LinkedList<Position>();\\n            for(Position cur : frontier) {\\n                /// scenairo one moving along the snake\\n                int newHeadX = cur.tailX + 2 * dirs[cur.direction][0];\\n                int newHeadY = cur.tailY + 2 * dirs[cur.direction][1]; \\n                if(newHeadX < n && newHeadY < n && grid[newHeadX][newHeadY] == 0) {\\n                    newP = new Position(cur.tailX + dirs[cur.direction][0], cur.tailY + dirs[cur.direction][1], cur.direction);\\n                    if(!visited[newP.tailX][newP.tailY][newP.direction]) {\\n                        visited[newP.tailX][newP.tailY][newP.direction] = true;\\n                        newFrontier.add(newP);\\n                    }\\n                }\\n                \\n                // scneario two rotate or moving perpendicular\\n                int oDirec = 1 - cur.direction;   // 1 -> 0 or 0 - > 1\\n                newHeadX = cur.tailX + dirs[oDirec][0];\\n                newHeadY = cur.tailY + dirs[oDirec][1];\\n                if(newHeadX < n && newHeadY < n) {\\n                    if(grid[newHeadX][newHeadY] == 0\\n                       && grid[newHeadX + dirs[cur.direction][0]][newHeadY + dirs[cur.direction][1]] == 0) {\\n                        // rotation\\n                        newP = new Position(cur.tailX, cur.tailY, oDirec);\\n                        if(!visited[newP.tailX][newP.tailY][newP.direction]) {\\n                            visited[newP.tailX][newP.tailY][newP.direction] = true;\\n                            newFrontier.add(newP);\\n                        }\\n                        \\n                        // moving the entire stack perpendicular to its direction\\n                        newP = new Position(newHeadX, newHeadY, cur.direction);\\n                        if(!visited[newP.tailX][newP.tailY][newP.direction]) {\\n                            visited[newP.tailX][newP.tailY][newP.direction] = true;\\n                            newFrontier.add(newP);\\n                        }\\n                    }\\n                }\\n            }\\n            \\n            if(visited[target.tailX][target.tailY][target.direction]) {\\n                return moves;    \\n            }\\n            \\n            frontier = newFrontier;\\n        }\\n        \\n        return -1;\\n    }\\n    \\n    private int[][] dirs = new int[][] {{0,1}, {1,0}};\\n    public class Position {\\n        public int tailX;\\n        public int tailY;\\n        public int direction;\\n        \\n        public Position(int x, int y, int direction) {\\n            this.tailX = x;\\n            this.tailY = y;\\n            this.direction = direction;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minimumMoves(int[][] grid) {\\n        if(grid == null || grid.length < 1 || grid[0].length < 2) {\\n            return -1;\\n        } \\n        \\n        int n = grid.length, moves = 0;\\n        if(grid[n - 1][n-2] == 1 || grid[n-1][n-1] == 1) {\\n            return -1;\\n        }\\n        \\n        boolean[][][] visited = new boolean[n][n][2];                 // location of the tail and two directions\\n        Deque<Position> frontier = new LinkedList<Position>(), newFrontier = null;\\n        Position target = new Position(n - 1, n - 2, 0), newP = null;\\n        frontier.add(new Position(0, 0, 0));\\n        visited[0][0][0] = true;\\n        while(frontier.size() > 0) {\\n           ++moves;\\n            newFrontier = new LinkedList<Position>();\\n            for(Position cur : frontier) {\\n                /// scenairo one moving along the snake\\n                int newHeadX = cur.tailX + 2 * dirs[cur.direction][0];\\n                int newHeadY = cur.tailY + 2 * dirs[cur.direction][1]; \\n                if(newHeadX < n && newHeadY < n && grid[newHeadX][newHeadY] == 0) {\\n                    newP = new Position(cur.tailX + dirs[cur.direction][0], cur.tailY + dirs[cur.direction][1], cur.direction);\\n                    if(!visited[newP.tailX][newP.tailY][newP.direction]) {\\n                        visited[newP.tailX][newP.tailY][newP.direction] = true;\\n                        newFrontier.add(newP);\\n                    }\\n                }\\n                \\n                // scneario two rotate or moving perpendicular\\n                int oDirec = 1 - cur.direction;   // 1 -> 0 or 0 - > 1\\n                newHeadX = cur.tailX + dirs[oDirec][0];\\n                newHeadY = cur.tailY + dirs[oDirec][1];\\n                if(newHeadX < n && newHeadY < n) {\\n                    if(grid[newHeadX][newHeadY] == 0\\n                       && grid[newHeadX + dirs[cur.direction][0]][newHeadY + dirs[cur.direction][1]] == 0) {\\n                        // rotation\\n                        newP = new Position(cur.tailX, cur.tailY, oDirec);\\n                        if(!visited[newP.tailX][newP.tailY][newP.direction]) {\\n                            visited[newP.tailX][newP.tailY][newP.direction] = true;\\n                            newFrontier.add(newP);\\n                        }\\n                        \\n                        // moving the entire stack perpendicular to its direction\\n                        newP = new Position(newHeadX, newHeadY, cur.direction);\\n                        if(!visited[newP.tailX][newP.tailY][newP.direction]) {\\n                            visited[newP.tailX][newP.tailY][newP.direction] = true;\\n                            newFrontier.add(newP);\\n                        }\\n                    }\\n                }\\n            }\\n            \\n            if(visited[target.tailX][target.tailY][target.direction]) {\\n                return moves;    \\n            }\\n            \\n            frontier = newFrontier;\\n        }\\n        \\n        return -1;\\n    }\\n    \\n    private int[][] dirs = new int[][] {{0,1}, {1,0}};\\n    public class Position {\\n        public int tailX;\\n        public int tailY;\\n        public int direction;\\n        \\n        public Position(int x, int y, int direction) {\\n            this.tailX = x;\\n            this.tailY = y;\\n            this.direction = direction;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 393082,
                "title": "java-concise-bfs-solution-with-comments",
                "content": "```Java\\nclass Solution {\\n    public int minimumMoves(int[][] grid) {\\n        int n = grid.length;\\n        int res = 0;\\n        int[][] start = {{0, 0}, {0, 1}};\\n        Queue<int[][]> q = new LinkedList<>();\\n        Set<String> visited = new HashSet<>();\\n        q.add(start);\\n        visited.add(toString(start));\\n        while (!q.isEmpty()) {\\n            for (int size = q.size(); size > 0; size--) {\\n                int[][] cur = q.poll();\\n                if (cur[0][0] == n - 1 && cur[0][1] == n - 2 && cur[1][0] == n - 1 && cur[1][1] == n - 1) return res;\\n                int[] tail = cur[0], head = cur[1];\\n                int x = tail[0], y = tail[1];\\n                if (tail[0] == head[0]) { // horizontal\\n                    if (x < n - 1 && grid[x+1][y] == 0 && grid[x+1][y+1] == 0) {\\n                        int[][] down = {{x + 1, y}, {x + 1, y + 1}}; // down\\n                        int[][] turn = {{x, y}, {x + 1, y}}; // clockwise\\n                        if (visited.add(toString(down))) q.offer(down);\\n                        if (visited.add(toString(turn))) q.offer(turn);\\n                    }\\n                    if (y + 2 < n && grid[x][y+2] == 0) {\\n                        int[][] right = {{x, y + 1}, {x, y + 2}}; // right\\n                        if (visited.add(toString(right))) q.offer(right);\\n                    } \\n                } else { // vertical\\n                    if (y < n - 1 && grid[x][y+1] == 0 && grid[x+1][y+1] == 0) {\\n                        int[][] right = {{x, y + 1}, {x + 1, y + 1}}; // right\\n                        int[][] turn = {{x,y}, {x, y + 1}}; // counterclockwise\\n                        if (visited.add(toString(right))) q.offer(right);\\n                        if (visited.add(toString(turn))) q.offer(turn);\\n                    }\\n                    \\n                    if (x + 2 < n && grid[x+2][y] == 0) {\\n                        int[][] down = {{x+1, y}, {x+2, y}}; // down\\n                        if (visited.add(toString(down))) q.offer(down);\\n                    }\\n                }\\n            }\\n            res++;\\n        }\\n        return -1;\\n    }\\n    \\n    private String toString(int[][] pos) {\\n        return pos[0][0] + \":\" + pos[0][1] + \":\" + pos[1][0] + \":\" + pos[1][1];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```Java\\nclass Solution {\\n    public int minimumMoves(int[][] grid) {\\n        int n = grid.length;\\n        int res = 0;\\n        int[][] start = {{0, 0}, {0, 1}};\\n        Queue<int[][]> q = new LinkedList<>();\\n        Set<String> visited = new HashSet<>();\\n        q.add(start);\\n        visited.add(toString(start));\\n        while (!q.isEmpty()) {\\n            for (int size = q.size(); size > 0; size--) {\\n                int[][] cur = q.poll();\\n                if (cur[0][0] == n - 1 && cur[0][1] == n - 2 && cur[1][0] == n - 1 && cur[1][1] == n - 1) return res;\\n                int[] tail = cur[0], head = cur[1];\\n                int x = tail[0], y = tail[1];\\n                if (tail[0] == head[0]) { // horizontal\\n                    if (x < n - 1 && grid[x+1][y] == 0 && grid[x+1][y+1] == 0) {\\n                        int[][] down = {{x + 1, y}, {x + 1, y + 1}}; // down\\n                        int[][] turn = {{x, y}, {x + 1, y}}; // clockwise\\n                        if (visited.add(toString(down))) q.offer(down);\\n                        if (visited.add(toString(turn))) q.offer(turn);\\n                    }\\n                    if (y + 2 < n && grid[x][y+2] == 0) {\\n                        int[][] right = {{x, y + 1}, {x, y + 2}}; // right\\n                        if (visited.add(toString(right))) q.offer(right);\\n                    } \\n                } else { // vertical\\n                    if (y < n - 1 && grid[x][y+1] == 0 && grid[x+1][y+1] == 0) {\\n                        int[][] right = {{x, y + 1}, {x + 1, y + 1}}; // right\\n                        int[][] turn = {{x,y}, {x, y + 1}}; // counterclockwise\\n                        if (visited.add(toString(right))) q.offer(right);\\n                        if (visited.add(toString(turn))) q.offer(turn);\\n                    }\\n                    \\n                    if (x + 2 < n && grid[x+2][y] == 0) {\\n                        int[][] down = {{x+1, y}, {x+2, y}}; // down\\n                        if (visited.add(toString(down))) q.offer(down);\\n                    }\\n                }\\n            }\\n            res++;\\n        }\\n        return -1;\\n    }\\n    \\n    private String toString(int[][] pos) {\\n        return pos[0][0] + \":\" + pos[0][1] + \":\" + pos[1][0] + \":\" + pos[1][1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 393032,
                "title": "java-bfs-with-snake-class-easy-to-understand",
                "content": "The idea is to use BFS to find the shortest path to the destination. \\n\\nWe traverse all snake position (stored in the queue with recorded size) after each step. For each possible snake position, we could try 4 moves, right, down, clockwise, counter clockwise in the next move. If the next move is valid, we add it to the queue.\\n\\nif the destination (note: must be horizontal position) is found during the traversal, return the step. If the destination is not found and the queue is empty (no more possible snake position), it means that the destination is not reachable therefore return false.\\n\\n`Snake` class is declared to store the position (horizontal/vertical) , the head position, and an id (avoid duplicate snake added to the queue).\\n\\nWe reocrd the snake id to dedupe the snake position we have visited in the previous steps (less steps, shorter path). \\n\\n\\xB7\\xB7\\xB7\\n\\n\\tclass Solution {\\n\\t\\tpublic int minimumMoves(int[][] grid) {\\n\\t\\t\\tint rowCnt = grid.length, colCnt = grid[0].length;\\n\\t\\t\\tint[] des = {rowCnt - 1, colCnt - 1};\\n\\t\\t\\tQueue<Snake> level = new LinkedList<>();\\n\\t\\t\\tSnake origin = new Snake(true, new int[] {0, 1});\\n\\t\\t\\tSet<String> visited = new HashSet<>();\\n\\t\\t\\tlevel.offer(origin);\\n\\t\\t\\tvisited.add(origin.id);\\n\\t\\t\\tint step = -1;\\n\\n\\t\\t\\twhile (!level.isEmpty()) {\\n\\t\\t\\t\\t// record the current queue size, these are all possible snake positions after \"step\" steps. We reocrd the size here because we could add more snake positions into the queue during iterations.\\n\\t\\t\\t\\tint size = level.size();\\n\\t\\t\\t\\tfor (int i = 0; i < size; i++) {  \\n\\t\\t\\t\\t\\tSnake curr = level.poll();\\n\\t\\t\\t\\t\\tif (curr.isHor && curr.headPos[0] == des[0] && curr.headPos[1] == des[1]) {\\n\\t\\t\\t\\t\\t\\treturn step + 1;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tSnake r = moveRight(curr, grid);\\n\\t\\t\\t\\t\\tSnake d = moveDown(curr, grid);\\n\\t\\t\\t\\t\\tSnake c = moveClock(curr, grid);\\n\\t\\t\\t\\t\\tSnake cc = moveCounter(curr, grid);\\n\\t\\t\\t\\t\\tif (!visited.contains(r.id) && r.headPos[0] != -1) {\\n\\t\\t\\t\\t\\t\\tlevel.offer(r);\\n\\t\\t\\t\\t\\t\\tvisited.add(r.id);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif (!visited.contains(d.id) && d.headPos[0] != -1) {\\n\\t\\t\\t\\t\\t\\tlevel.offer(d);\\n\\t\\t\\t\\t\\t\\tvisited.add(d.id);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif (!visited.contains(c.id) && c.headPos[0] != -1) {\\n\\t\\t\\t\\t\\t\\tlevel.offer(c);\\n\\t\\t\\t\\t\\t\\tvisited.add(c.id);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif (!visited.contains(cc.id) && cc.headPos[0] != -1) {\\n\\t\\t\\t\\t\\t\\tlevel.offer(cc);\\n\\t\\t\\t\\t\\t\\tvisited.add(cc.id);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tstep++;\\n\\t\\t\\t}\\n\\t\\t\\treturn -1;\\n\\t\\t}\\n\\n\\t\\tprivate Snake moveRight(Snake s, int[][] grid) {\\n\\t\\t\\tSnake success = new Snake(s.isHor, new int[] {s.headPos[0], s.headPos[1] + 1});\\n\\t\\t\\tif (isValid(success, grid)) {\\n\\t\\t\\t\\tif (s.isHor && grid[s.headPos[0]][s.headPos[1] + 1] == 0) {\\n\\t\\t\\t\\t\\treturn success;\\n\\t\\t\\t\\t} else if (!s.isHor\\n\\t\\t\\t\\t   && grid[s.headPos[0]][s.headPos[1] + 1] == 0\\n\\t\\t\\t\\t   && grid[s.headPos[0] - 1][s.headPos[1] + 1] == 0) {\\n\\t\\t\\t\\t\\treturn success;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn new Snake(s.isHor, new int[] {-1, -1}); \\n\\t\\t}\\n\\n\\t\\tprivate Snake moveDown(Snake s, int[][] grid) {\\n\\t\\t\\tSnake success = new Snake(s.isHor, new int[] {s.headPos[0] + 1, s.headPos[1]});\\n\\t\\t\\tif (isValid(success, grid)) {\\n\\t\\t\\t\\tif (!s.isHor\\n\\t\\t\\t\\t   && grid[s.headPos[0] + 1][s.headPos[1]] == 0) {\\n\\t\\t\\t\\t\\treturn success;\\n\\t\\t\\t\\t} else if (s.isHor\\n\\t\\t\\t\\t   && grid[s.headPos[0] + 1][s.headPos[1]] == 0\\n\\t\\t\\t\\t   && grid[s.headPos[0] + 1][s.headPos[1] - 1] == 0) {\\n\\t\\t\\t\\t\\treturn success;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn new Snake(s.isHor, new int[] {-1, -1}); \\n\\t\\t}\\n\\n\\t\\tprivate Snake moveClock(Snake s, int[][] grid) {\\n\\t\\t\\tSnake success = new Snake(!s.isHor, new int[] {s.headPos[0] + 1, s.headPos[1] - 1});\\n\\t\\t\\tif (isValid(success, grid)) {\\n\\t\\t\\t\\tif (s.isHor && grid[s.headPos[0] + 1][s.headPos[1]] == 0\\n\\t\\t\\t\\t   && grid[s.headPos[0] + 1][s.headPos[1] - 1] == 0) {\\n\\t\\t\\t\\t\\treturn success;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn new Snake(s.isHor, new int[] {-1, -1});  \\n\\t\\t}\\n\\n\\t\\tprivate Snake moveCounter(Snake s, int[][] grid) {\\n\\t\\t\\tSnake success = new Snake(!s.isHor, new int[] {s.headPos[0] - 1, s.headPos[1] + 1});\\n\\t\\t\\tif (isValid(success, grid)) { \\n\\t\\t\\t\\tif (!s.isHor\\n\\t\\t\\t\\t   && grid[s.headPos[0] - 1][s.headPos[1] + 1] == 0\\n\\t\\t\\t\\t   && grid[s.headPos[0]][s.headPos[1] + 1] == 0) {\\n\\t\\t\\t\\t\\treturn success;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn new Snake(s.isHor, new int[] {-1, -1}); \\n\\t\\t}\\n\\n\\t\\tprivate boolean isValid(Snake s, int[][] grid) {\\n\\t\\t\\tif (s.headPos[0] >= 0 && s.headPos[0] < grid.length \\n\\t\\t\\t\\t&& s.headPos[1] >= 0 && s.headPos[1] < grid[0].length) {\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t}\\n\\n\\tclass Snake {\\n\\t\\tboolean isHor;\\n\\t\\tint[] headPos;\\n\\t\\tString id;\\n\\n\\t\\tpublic Snake(boolean isHor, int[] headPos) {\\n\\t\\t\\tthis.isHor = isHor;\\n\\t\\t\\tthis.headPos = headPos;\\n\\t\\t\\tthis.id = isHor + \"_\" + headPos[0] + \"_\" + headPos[1];\\n\\t\\t}\\n\\t}\\n\\t\\n\\xB7\\xB7\\xB7",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tpublic int minimumMoves(int[][] grid) {\\n\\t\\t\\tint rowCnt = grid.length, colCnt = grid[0].length;\\n\\t\\t\\tint[] des = {rowCnt - 1, colCnt - 1}",
                "codeTag": "Java"
            },
            {
                "id": 392942,
                "title": "python-concise-bfs",
                "content": "```\\n    def minimumMoves(self, grid: List[List[int]]) -> int:\\n        cur,cnt, n, seen = [(0,0,0)], 0 , len(grid),set([(0,0,0)])      #(tail_row,tail_col,horizontal_or_verticle)\\n        while cur and (n-1,n-2,0) not in cur:\\n            cnt,tmp = cnt+1, []\\n            for x,y,dx in cur:\\n                if dx==0:\\n                    if y+2 < n and grid[x][y+2] == 0: tmp += [(x,y+1,dx)]\\n                    if x+1 < n and (grid[x+1][y] + grid[x+1][y+1]) == 0: tmp += [(x,y,1),(x+1,y,0)]\\n                else:\\n                    if x+2 < n and grid[x+2][y] == 0: tmp += [(x+1,y,dx)]\\n                    if y+1 < n and (grid[x][y+1] + grid[x+1][y+1]) == 0: tmp += [(x,y,0),(x,y+1,1)]\\n            cur = set(tmp) - seen\\n            seen |= cur\\n        return cnt if cur else -1\\n```",
                "solutionTags": [],
                "code": "```\\n    def minimumMoves(self, grid: List[List[int]]) -> int:\\n        cur,cnt, n, seen = [(0,0,0)], 0 , len(grid),set([(0,0,0)])      #(tail_row,tail_col,horizontal_or_verticle)\\n        while cur and (n-1,n-2,0) not in cur:\\n            cnt,tmp = cnt+1, []\\n            for x,y,dx in cur:\\n                if dx==0:\\n                    if y+2 < n and grid[x][y+2] == 0: tmp += [(x,y+1,dx)]\\n                    if x+1 < n and (grid[x+1][y] + grid[x+1][y+1]) == 0: tmp += [(x,y,1),(x+1,y,0)]\\n                else:\\n                    if x+2 < n and grid[x+2][y] == 0: tmp += [(x+1,y,dx)]\\n                    if y+1 < n and (grid[x][y+1] + grid[x+1][y+1]) == 0: tmp += [(x,y,0),(x,y+1,1)]\\n            cur = set(tmp) - seen\\n            seen |= cur\\n        return cnt if cur else -1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 392932,
                "title": "python-dp-solution",
                "content": "dp[i][j][k]: minimum moves make snake tail to grid[i][j], where k = 0 means horizontal and k = 1 means vertical\\n\\n```\\ndef minimumMoves(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        n = len(grid)\\n        if grid[-1][-1] == 1:\\n            return -1\\n        dp = [[[float(\\'inf\\'), float(\\'inf\\')] for i in xrange(n)] for j in xrange(n)]\\n        dp[0][0][0] = 0\\n        for j in xrange(1, n - 1):\\n            if grid[0][j + 1] == 0:\\n                dp[0][j][0] = dp[0][j - 1][0] + 1\\n            else:\\n                break\\n        for i in xrange(n):\\n            for j in xrange(n):\\n                if j < n - 1 and grid[i][j + 1] == 0:\\n                    dp[i][j][0] = min(dp[i][j][0], dp[i][j - 1][0] + 1)\\n                    if grid[i][j] == 0:\\n                        dp[i][j][0] = min(dp[i][j][0],dp[i - 1][j][0] + 1)\\n                if i < n - 1 and grid[i + 1][j] == 0:\\n                    dp[i][j][1] = min(dp[i][j][1], dp[i - 1][j][1] + 1)\\n                    if grid[i][j] == 0:\\n                        dp[i][j][1] = min(dp[i][j][1], dp[i][j - 1][1] + 1)\\n                if i < n - 1 and j < n - 1 and grid[i][j + 1] == grid[i + 1][j] == grid[i + 1][j + 1] == 0:\\n                    dp[i][j][0], dp[i][j][1] = min(dp[i][j][0], dp[i][j][1] + 1), min(dp[i][j][1], dp[i][j][0] + 1)\\n        return dp[n - 1][n - 2][0] if dp[n - 1][n - 2][0] < float(\\'inf\\') else -1\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\ndef minimumMoves(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        n = len(grid)\\n        if grid[-1][-1] == 1:\\n            return -1\\n        dp = [[[float(\\'inf\\'), float(\\'inf\\')] for i in xrange(n)] for j in xrange(n)]\\n        dp[0][0][0] = 0\\n        for j in xrange(1, n - 1):\\n            if grid[0][j + 1] == 0:\\n                dp[0][j][0] = dp[0][j - 1][0] + 1\\n            else:\\n                break\\n        for i in xrange(n):\\n            for j in xrange(n):\\n                if j < n - 1 and grid[i][j + 1] == 0:\\n                    dp[i][j][0] = min(dp[i][j][0], dp[i][j - 1][0] + 1)\\n                    if grid[i][j] == 0:\\n                        dp[i][j][0] = min(dp[i][j][0],dp[i - 1][j][0] + 1)\\n                if i < n - 1 and grid[i + 1][j] == 0:\\n                    dp[i][j][1] = min(dp[i][j][1], dp[i - 1][j][1] + 1)\\n                    if grid[i][j] == 0:\\n                        dp[i][j][1] = min(dp[i][j][1], dp[i][j - 1][1] + 1)\\n                if i < n - 1 and j < n - 1 and grid[i][j + 1] == grid[i + 1][j] == grid[i + 1][j + 1] == 0:\\n                    dp[i][j][0], dp[i][j][1] = min(dp[i][j][0], dp[i][j][1] + 1), min(dp[i][j][1], dp[i][j][0] + 1)\\n        return dp[n - 1][n - 2][0] if dp[n - 1][n - 2][0] < float(\\'inf\\') else -1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3973547,
                "title": "breadth-first-search-o-n-m-faster-than-50-clean-java-code",
                "content": "# Complexity\\n- Time complexity: $$O(n*m)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n*m)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass State {\\n    int x;\\n    int y;\\n    int other_x;\\n    int other_y;\\n    boolean isHorizontal;\\n\\n    public State(int x, int y, boolean isHorizontal) {\\n        this.x = x;\\n        this.y = y;\\n        this.isHorizontal = isHorizontal;\\n        int[] otherCell = getOtherCell();\\n        other_x = otherCell[0];\\n        other_y = otherCell[1];\\n    }\\n\\n    public int[] getOtherCell() {\\n        if (isHorizontal) return new int[] {x, y + 1};\\n        else return new int[] {x + 1, y};\\n    }\\n\\n    public State rotate() {\\n        return new State(x, y, !isHorizontal);\\n    }\\n}\\n\\nclass Solution {\\n    private final List<Integer[]> directions = List.of(\\n            new Integer[]{0, 1},\\n            new Integer[]{1, 0}\\n    );\\n    private final Queue<State> queue = new ArrayDeque<>();\\n    private boolean[][][] visited;\\n\\n    public int minimumMoves(int[][] grid) {\\n        queue.add(new State(0, 0, true));\\n        visited = new boolean[grid.length][grid[0].length][2];\\n        int steps = 0;\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            for (int count = 0; count < size; count++) {\\n                State curr = queue.remove();\\n                if (isTarget(curr, grid)) return steps;\\n                int i = curr.x, j = curr.y, k = curr.isHorizontal ? 0 : 1;\\n                if (visited[i][j][k]) continue;\\n                visited[i][j][k] = true;\\n                for (Integer[] direction: directions) {\\n                    State newState = new State(i + direction[0], j + direction[1], curr.isHorizontal);\\n                    addCell(newState, grid);\\n                }\\n                State rotated = curr.rotate();\\n                if (isValidPivot(rotated, grid))\\n                    addCell(rotated, grid);\\n            }\\n            steps++;\\n        }\\n        return -1;\\n    }\\n\\n    private boolean isTarget(State curr, int[][] grid) {\\n        return curr.x == grid.length - 1 && curr.y == grid[0].length - 2 && curr.isHorizontal;\\n    }\\n\\n    private void addCell(State state, int[][] grid) {\\n        int k = state.isHorizontal ? 0 : 1;\\n        if (isValidCell(state.x, state.y, grid) && isValidCell(state.other_x, state.other_y, grid) &&\\n                !visited[state.x][state.y][k]) {\\n            queue.add(state);\\n        }\\n    }\\n\\n    private boolean isValidCell(int x, int y, int[][] grid) {\\n        return isValidCoordinates(x, y, grid) && grid[x][y] != 1;\\n    }\\n\\n    private boolean isValidCoordinates(int i, int j, int[][] grid) {\\n        return i >= 0 && i < grid.length && j >= 0 && j < grid[0].length;\\n    }\\n\\n    private boolean isValidPivot(State state, int[][] grid) {\\n        int x = state.x + 1, y = state.y + 1;\\n        return isValidCoordinates(x, y, grid) && grid[x][y] != 1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass State {\\n    int x;\\n    int y;\\n    int other_x;\\n    int other_y;\\n    boolean isHorizontal;\\n\\n    public State(int x, int y, boolean isHorizontal) {\\n        this.x = x;\\n        this.y = y;\\n        this.isHorizontal = isHorizontal;\\n        int[] otherCell = getOtherCell();\\n        other_x = otherCell[0];\\n        other_y = otherCell[1];\\n    }\\n\\n    public int[] getOtherCell() {\\n        if (isHorizontal) return new int[] {x, y + 1};\\n        else return new int[] {x + 1, y};\\n    }\\n\\n    public State rotate() {\\n        return new State(x, y, !isHorizontal);\\n    }\\n}\\n\\nclass Solution {\\n    private final List<Integer[]> directions = List.of(\\n            new Integer[]{0, 1},\\n            new Integer[]{1, 0}\\n    );\\n    private final Queue<State> queue = new ArrayDeque<>();\\n    private boolean[][][] visited;\\n\\n    public int minimumMoves(int[][] grid) {\\n        queue.add(new State(0, 0, true));\\n        visited = new boolean[grid.length][grid[0].length][2];\\n        int steps = 0;\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            for (int count = 0; count < size; count++) {\\n                State curr = queue.remove();\\n                if (isTarget(curr, grid)) return steps;\\n                int i = curr.x, j = curr.y, k = curr.isHorizontal ? 0 : 1;\\n                if (visited[i][j][k]) continue;\\n                visited[i][j][k] = true;\\n                for (Integer[] direction: directions) {\\n                    State newState = new State(i + direction[0], j + direction[1], curr.isHorizontal);\\n                    addCell(newState, grid);\\n                }\\n                State rotated = curr.rotate();\\n                if (isValidPivot(rotated, grid))\\n                    addCell(rotated, grid);\\n            }\\n            steps++;\\n        }\\n        return -1;\\n    }\\n\\n    private boolean isTarget(State curr, int[][] grid) {\\n        return curr.x == grid.length - 1 && curr.y == grid[0].length - 2 && curr.isHorizontal;\\n    }\\n\\n    private void addCell(State state, int[][] grid) {\\n        int k = state.isHorizontal ? 0 : 1;\\n        if (isValidCell(state.x, state.y, grid) && isValidCell(state.other_x, state.other_y, grid) &&\\n                !visited[state.x][state.y][k]) {\\n            queue.add(state);\\n        }\\n    }\\n\\n    private boolean isValidCell(int x, int y, int[][] grid) {\\n        return isValidCoordinates(x, y, grid) && grid[x][y] != 1;\\n    }\\n\\n    private boolean isValidCoordinates(int i, int j, int[][] grid) {\\n        return i >= 0 && i < grid.length && j >= 0 && j < grid[0].length;\\n    }\\n\\n    private boolean isValidPivot(State state, int[][] grid) {\\n        int x = state.x + 1, y = state.y + 1;\\n        return isValidCoordinates(x, y, grid) && grid[x][y] != 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3012925,
                "title": "python-bfs",
                "content": "deque is defined as follows- \\n(snake head x corrdinate, snake head y corrdinate, direction, iteration number)\\nTime Complexity - O(n^2)\\n\\n```\\nclass Solution:\\n    def minimumMoves(self, grid: List[List[int]]) -> int:\\n        n=len(grid)\\n        seen=set()\\n        dq=deque()\\n        dq.append((0,1,\"r\",0))\\n        seen.add((0,1,\"r\"))\\n        while dq:\\n            i,j,pos,val=dq.popleft()\\n            if i==n-1 and j==n-1 and pos==\"r\": return val \\n            #move right\\n            if j+1<n and grid[i][j+1]==0 and (i,j+1,pos) not in seen:\\n                if pos==\"r\" or pos==\"d\" and grid[i-1][j+1]==0:\\n                    dq.append((i,j+1,pos,val+1))\\n                    seen.add((i,j+1,pos))\\n            #move down\\n            if i+1<n and grid[i+1][j]==0 and (i+1,j,pos) not in seen:\\n                if pos==\"d\" or pos==\"r\" and grid[i+1][j-1]==0:\\n                    dq.append((i+1,j,pos,val+1))\\n                    seen.add((i+1,j,pos))\\n            #change dir to down if curr is right\\n            if pos==\"r\" and j-1>=0 and i+1<n and grid[i+1][j]==grid[i+1][j-1]==0 and (i+1,j-1,\"d\") not in seen:\\n                dq.append((i+1,j-1,\"d\",val+1))\\n                seen.add((i+1,j-1,\"d\"))\\n            #change dir to right if curr is down\\n            if pos==\"d\" and i-1>=0 and j+1<n and grid[i-1][j+1]==grid[i][j+1]==0 and (i-1,j+1,\"r\") not in seen:\\n                dq.append((i-1,j+1,\"r\",val+1))\\n                seen.add((i-1,j+1,\"r\"))\\n        return -1\\n```",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def minimumMoves(self, grid: List[List[int]]) -> int:\\n        n=len(grid)\\n        seen=set()\\n        dq=deque()\\n        dq.append((0,1,\"r\",0))\\n        seen.add((0,1,\"r\"))\\n        while dq:\\n            i,j,pos,val=dq.popleft()\\n            if i==n-1 and j==n-1 and pos==\"r\": return val \\n            #move right\\n            if j+1<n and grid[i][j+1]==0 and (i,j+1,pos) not in seen:\\n                if pos==\"r\" or pos==\"d\" and grid[i-1][j+1]==0:\\n                    dq.append((i,j+1,pos,val+1))\\n                    seen.add((i,j+1,pos))\\n            #move down\\n            if i+1<n and grid[i+1][j]==0 and (i+1,j,pos) not in seen:\\n                if pos==\"d\" or pos==\"r\" and grid[i+1][j-1]==0:\\n                    dq.append((i+1,j,pos,val+1))\\n                    seen.add((i+1,j,pos))\\n            #change dir to down if curr is right\\n            if pos==\"r\" and j-1>=0 and i+1<n and grid[i+1][j]==grid[i+1][j-1]==0 and (i+1,j-1,\"d\") not in seen:\\n                dq.append((i+1,j-1,\"d\",val+1))\\n                seen.add((i+1,j-1,\"d\"))\\n            #change dir to right if curr is down\\n            if pos==\"d\" and i-1>=0 and j+1<n and grid[i-1][j+1]==grid[i][j+1]==0 and (i-1,j+1,\"r\") not in seen:\\n                dq.append((i-1,j+1,\"r\",val+1))\\n                seen.add((i-1,j+1,\"r\"))\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2517340,
                "title": "java-bfs-soln",
                "content": "The main intution of the question is to store the cordinates of tail of the snake and position and travel according to it.\\nAs we have to find the minimum setps BFS is the first thing that comes to mind.\\nSo here is its implementaion - \\n```\\nclass Solution {\\n    \\n    public class Pair{\\n        int x;\\n        int y;\\n        int pos;\\n        int st;\\n        \\n        Pair(int x, int y, int pos, int st){\\n            this.x = x;\\n            this.y = y;\\n            this.pos = pos;\\n            this.st = st;\\n        }\\n    }\\n    \\n    public void Add_Neighbours(int[][] grid, Queue<Pair> Q, Pair rem){\\n        \\n        int n = grid.length;\\n        int pos = rem.pos;\\n        int x = rem.x;\\n        int y = rem.y;\\n        \\n        if(pos == 0){\\n            if(y + 2 < n && grid[x][y + 2] == 0){\\n                Q.add(new Pair(x , y + 1, pos, rem.st + 1));\\n            }\\n            if(x + 1 < n && grid[x + 1][y]  == 0 && grid[x + 1][y + 1] == 0){\\n                Q.add(new Pair(x + 1, y, pos, rem.st + 1));\\n                Q.add(new Pair(x, y, 1, rem.st + 1));\\n            }\\n        }\\n        else{\\n            if(y + 1 < n && grid[x][y + 1] == 0 && grid[x + 1][y + 1] == 0){\\n                Q.add(new Pair(x, y + 1, pos, rem.st + 1));\\n                Q.add(new Pair(x, y, 0, rem.st + 1));\\n            }\\n            \\n            if(x + 2 < n && grid[x + 2][y] == 0){\\n                Q.add(new Pair(x + 1, y, pos, rem.st + 1));\\n            }\\n        }\\n    }\\n    \\n    public int minimumMoves(int[][] grid) {\\n        \\n        int n = grid.length;\\n        \\n        Queue<Pair> Q = new LinkedList();\\n        boolean[][][] visited = new boolean[n][n][2];\\n        \\n        Q.add(new Pair(0, 0, 0, 0));\\n        \\n        while(Q.size() > 0){    \\n            Pair rem = Q.remove();\\n            \\n            if(visited[rem.x][rem.y][rem.pos] == true)   continue;\\n            \\n            visited[rem.x][rem.y][rem.pos] = true;\\n            \\n            if(rem.x == n - 1 && rem.y == n - 2 && rem.pos == 0)    return rem.st;\\n            \\n            Add_Neighbours(grid, Q, rem);\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public class Pair{\\n        int x;\\n        int y;\\n        int pos;\\n        int st;\\n        \\n        Pair(int x, int y, int pos, int st){\\n            this.x = x;\\n            this.y = y;\\n            this.pos = pos;\\n            this.st = st;\\n        }\\n    }\\n    \\n    public void Add_Neighbours(int[][] grid, Queue<Pair> Q, Pair rem){\\n        \\n        int n = grid.length;\\n        int pos = rem.pos;\\n        int x = rem.x;\\n        int y = rem.y;\\n        \\n        if(pos == 0){\\n            if(y + 2 < n && grid[x][y + 2] == 0){\\n                Q.add(new Pair(x , y + 1, pos, rem.st + 1));\\n            }\\n            if(x + 1 < n && grid[x + 1][y]  == 0 && grid[x + 1][y + 1] == 0){\\n                Q.add(new Pair(x + 1, y, pos, rem.st + 1));\\n                Q.add(new Pair(x, y, 1, rem.st + 1));\\n            }\\n        }\\n        else{\\n            if(y + 1 < n && grid[x][y + 1] == 0 && grid[x + 1][y + 1] == 0){\\n                Q.add(new Pair(x, y + 1, pos, rem.st + 1));\\n                Q.add(new Pair(x, y, 0, rem.st + 1));\\n            }\\n            \\n            if(x + 2 < n && grid[x + 2][y] == 0){\\n                Q.add(new Pair(x + 1, y, pos, rem.st + 1));\\n            }\\n        }\\n    }\\n    \\n    public int minimumMoves(int[][] grid) {\\n        \\n        int n = grid.length;\\n        \\n        Queue<Pair> Q = new LinkedList();\\n        boolean[][][] visited = new boolean[n][n][2];\\n        \\n        Q.add(new Pair(0, 0, 0, 0));\\n        \\n        while(Q.size() > 0){    \\n            Pair rem = Q.remove();\\n            \\n            if(visited[rem.x][rem.y][rem.pos] == true)   continue;\\n            \\n            visited[rem.x][rem.y][rem.pos] = true;\\n            \\n            if(rem.x == n - 1 && rem.y == n - 2 && rem.pos == 0)    return rem.st;\\n            \\n            Add_Neighbours(grid, Q, rem);\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2137776,
                "title": "c-simple-bfs-state-management-clean-concise",
                "content": "```\\nclass Solution {\\npublic:\\n    int n;\\n    queue<vector<int>> q;\\n    \\n    void down(vector<vector<int>>& g, vector<int>& A){\\n        int r1 = A[0], c1 = A[1], r2 = A[2], c2 = A[3];\\n        if(r1 < n - 1 && !g[r1 + 1][c1] && r2 < n - 1 && !g[r2 + 1][c2])\\n            q.push({r1 + 1, c1, r2 + 1, c2});\\n    }\\n    void right(vector<vector<int>>& g, vector<int>& A){\\n        int r1 = A[0], c1 = A[1], r2 = A[2], c2 = A[3];\\n        if(c1 < n - 1 && !g[r1][c1 + 1] && c2 < n - 1 && !g[r2][c2 + 1])\\n            q.push({r1, c1 + 1, r2, c2 + 1});\\n    }\\n    \\n    void clockwise(vector<vector<int>>& g, vector<int>& A){\\n        int r1 = A[0], c1 = A[1], r2 = A[2], c2 = A[3];\\n        if(r1 != r2) return;\\n        if(r1 < n - 1 && !g[r1 + 1][c1] && !g[r1 + 1][c2])\\n            q.push({r1, c1, r1 + 1, c1});\\n    }\\n    void counterClockwise(vector<vector<int>>& g, vector<int>& A){\\n        int r1 = A[0], c1 = A[1], r2 = A[2], c2 = A[3];\\n        if(c1 != c2) return;\\n        if(c1 < n - 1 && !g[r1][c1 + 1] && !g[r2][c1 + 1])\\n            q.push({r1, c1, r1, c1 + 1});\\n    }\\n    set<vector<int>> set;\\n    \\n    int minimumMoves(vector<vector<int>>& g) {\\n        n = g.size();\\n        q.push({0, 0, 0, 1});\\n        int level = 0;\\n        while(!q.empty()){\\n            int sz = q.size();\\n            for(int i = 0; i < sz; i++){\\n                auto A = q.front();\\n                q.pop();\\n                if(set.find(A) != set.end()) continue;\\n                set.insert(A);\\n                int r1 = A[0], c1 = A[1], r2 = A[2], c2 = A[3];\\n                if(r1 == n - 1 && c1 == n - 2 && r2 == n - 1 && c2 == n - 1)    return level;\\n                down(g, A); right(g, A);\\n                clockwise(g, A); counterClockwise(g, A);\\n            }\\n            level++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n;\\n    queue<vector<int>> q;\\n    \\n    void down(vector<vector<int>>& g, vector<int>& A){\\n        int r1 = A[0], c1 = A[1], r2 = A[2], c2 = A[3];\\n        if(r1 < n - 1 && !g[r1 + 1][c1] && r2 < n - 1 && !g[r2 + 1][c2])\\n            q.push({r1 + 1, c1, r2 + 1, c2});\\n    }\\n    void right(vector<vector<int>>& g, vector<int>& A){\\n        int r1 = A[0], c1 = A[1], r2 = A[2], c2 = A[3];\\n        if(c1 < n - 1 && !g[r1][c1 + 1] && c2 < n - 1 && !g[r2][c2 + 1])\\n            q.push({r1, c1 + 1, r2, c2 + 1});\\n    }\\n    \\n    void clockwise(vector<vector<int>>& g, vector<int>& A){\\n        int r1 = A[0], c1 = A[1], r2 = A[2], c2 = A[3];\\n        if(r1 != r2) return;\\n        if(r1 < n - 1 && !g[r1 + 1][c1] && !g[r1 + 1][c2])\\n            q.push({r1, c1, r1 + 1, c1});\\n    }\\n    void counterClockwise(vector<vector<int>>& g, vector<int>& A){\\n        int r1 = A[0], c1 = A[1], r2 = A[2], c2 = A[3];\\n        if(c1 != c2) return;\\n        if(c1 < n - 1 && !g[r1][c1 + 1] && !g[r2][c1 + 1])\\n            q.push({r1, c1, r1, c1 + 1});\\n    }\\n    set<vector<int>> set;\\n    \\n    int minimumMoves(vector<vector<int>>& g) {\\n        n = g.size();\\n        q.push({0, 0, 0, 1});\\n        int level = 0;\\n        while(!q.empty()){\\n            int sz = q.size();\\n            for(int i = 0; i < sz; i++){\\n                auto A = q.front();\\n                q.pop();\\n                if(set.find(A) != set.end()) continue;\\n                set.insert(A);\\n                int r1 = A[0], c1 = A[1], r2 = A[2], c2 = A[3];\\n                if(r1 == n - 1 && c1 == n - 2 && r2 == n - 1 && c2 == n - 1)    return level;\\n                down(g, A); right(g, A);\\n                clockwise(g, A); counterClockwise(g, A);\\n            }\\n            level++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1964865,
                "title": "c-beats-100-00-memory-speed-0ms-april-2022",
                "content": "\\n\\tclass Solution {\\n\\n    public:\\n    \\n    int n;\\n    set<vector<int>> visited;\\n    bool candown(vector<vector<int>>& grid,int x,int y,bool hor){\\n        if(!hor){\\n            if(x+2<n && grid[x+1][y]==0 && grid[x+2][y]==0 && !visited.count({x+1,y,hor})){\\n                return true;\\n            }\\n        }else{\\n            if(x+1<n && y+1<n && grid[x+1][y]==0 && grid[x+1][y+1]==0 && !visited.count({x+1,y,hor})){\\n                return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    \\n    bool canright(vector<vector<int>>& grid,int x,int y,bool hor){\\n        if(hor){\\n            if(y+2<n && grid[x][y+1]==0 && grid[x][y+2]==0 && !visited.count({x,y+1,hor})){\\n                return true;\\n            }\\n        }else{\\n            if(y+1<n && x+1<n && grid[x][y+1]==0 && grid[x+1][y+1]==0 && !visited.count({x,y+1,hor})){\\n                return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    \\n    bool canrot(vector<vector<int>>& grid,int x,int y,bool hor){\\n        if(hor){\\n            if(y+1<n && x+1<n && grid[x+1][y]==0 && grid[x+1][y+1]==0 && !visited.count({x,y,!hor})){\\n                return true;\\n            }\\n        }else{\\n            if(x+1<n && y+1<n && grid[x][y+1]==0 &&grid[x+1][y+1]==0 && !visited.count({x,y,!hor})){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    int minimumMoves(vector<vector<int>>& grid) {\\n        queue<array<int, 3>> q;\\n        q.push({0,0,true});\\n        int ans=0;\\n        n=grid.size();\\n        while(!q.empty()){\\n            int size=q.size();\\n            while(size--){\\n                auto a=q.front();\\n                q.pop();\\n                if(visited.count({a[0],a[1],a[2]})){\\n                    continue;\\n                }\\n                visited.insert({a[0],a[1],a[2]});\\n                int x=a[0];\\n                int y=a[1];\\n                if(x==n-1 && y==n-2 && a[2]==1){\\n                    return ans;\\n                }\\n                if(candown(grid,x,y,a[2])){\\n                    q.push({x+1,y,a[2]});\\n                }\\n                if(canrot(grid,x,y,a[2])){\\n                    q.push({x,y,!a[2]});\\n                }\\n                if(canright(grid,x,y,a[2])){\\n                    q.push({x,y+1,a[2]});\\n                }\\n            }\\n            ans++;\\n        }\\n        return -1;\\n    }\\n\\t};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\n    public:\\n    \\n    int n;\\n    set<vector<int>> visited;\\n    bool candown(vector<vector<int>>& grid,int x,int y,bool hor){\\n        if(!hor){\\n            if(x+2<n && grid[x+1][y]==0 && grid[x+2][y]==0 && !visited.count({x+1,y,hor}",
                "codeTag": "Java"
            },
            {
                "id": 1863160,
                "title": "c-bfs",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumMoves(vector<vector<int>>& nums) {\\n        map<tuple<int,int,int>,int> mp;  // tuple stores 3 parameter\\n                                         // {row of head of snake, col of head of snake, alignment of snake}\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t // alignment = 0 mean horizontal, alignment = 1 means vertical\\n        queue<vector<int>> q;  //stores {row of head of snake, col of head of snake, alignment of snake}\\n        q.push({0,1,0}); mp[{0,1,0}]++;\\n        int l = 0,n=nums.size();\\n        while(!q.empty()){\\n            int s = q.size();\\n            while(s--){\\n                vector<int> t = q.front(); q.pop();\\n                int i = t[0], j =t[1];\\n                if(i==n-1 && j==n-1 && t[2]==0) return l; // check the destination, and return currenet level if found\\n                if(t[2]==0){  // if direction is horizontal\\n                    if(j+1<n && nums[i][j+1]==0 && mp.find({i,j+1,0})==mp.end()){ // check if it can move to right \\n                        mp[{i,j+1,0}]++; q.push({i,j+1,0});\\n                    }\\n                    if(i+1<n && nums[i+1][j]==0 && nums[i+1][j-1]==0){\\n                        if(mp.find({i+1,j,0})==mp.end()){  // check if it can move to down \\n                           mp[{i+1,j,0}]++; q.push({i+1,j,0}); \\n                        }\\n                        if(mp.find({i+1,j-1,1})==mp.end()){   // check if it can rotate clockwise \\n                            mp[{i+1,j-1,1}]++; q.push({i+1,j-1,1}); \\n                        }\\n                    }\\n                }\\n                else{    // if direction is vertical \\n                    if(i+1<n && nums[i+1][j]==0 && mp.find({i+1,j,1})==mp.end()) {  // check if it can move to down \\n                        mp[{i+1,j,1}]++; q.push({i+1,j,1});\\n                    }\\n                    if(j+1<n && nums[i][j+1]==0 && nums[i-1][j+1]==0){\\n                        if(mp.find({i,j+1,1})==mp.end()){   // check if it can move to right \\n                            mp[{i,j+1,1}]++; q.push({i,j+1,1});\\n                        }\\n                        if(mp.find({i-1,j+1,0})==mp.end()){   // check if it can rotate anticlockwise\\n                            mp[{i-1,j+1,0}]++; q.push({i-1,j+1,0});\\n                        }\\n                    } \\n                }\\n            }\\n            l++;\\n        }\\n        return -1;\\n    }\\n};\\n```\\n**Upvote if it helps**",
                "solutionTags": [
                    "C",
                    "Shortest Path"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumMoves(vector<vector<int>>& nums) {\\n        map<tuple<int,int,int>,int> mp;  // tuple stores 3 parameter\\n                                         // {row of head of snake, col of head of snake, alignment of snake}\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t // alignment = 0 mean horizontal, alignment = 1 means vertical\\n        queue<vector<int>> q;  //stores {row of head of snake, col of head of snake, alignment of snake}\\n        q.push({0,1,0}); mp[{0,1,0}]++;\\n        int l = 0,n=nums.size();\\n        while(!q.empty()){\\n            int s = q.size();\\n            while(s--){\\n                vector<int> t = q.front(); q.pop();\\n                int i = t[0], j =t[1];\\n                if(i==n-1 && j==n-1 && t[2]==0) return l; // check the destination, and return currenet level if found\\n                if(t[2]==0){  // if direction is horizontal\\n                    if(j+1<n && nums[i][j+1]==0 && mp.find({i,j+1,0})==mp.end()){ // check if it can move to right \\n                        mp[{i,j+1,0}]++; q.push({i,j+1,0});\\n                    }\\n                    if(i+1<n && nums[i+1][j]==0 && nums[i+1][j-1]==0){\\n                        if(mp.find({i+1,j,0})==mp.end()){  // check if it can move to down \\n                           mp[{i+1,j,0}]++; q.push({i+1,j,0}); \\n                        }\\n                        if(mp.find({i+1,j-1,1})==mp.end()){   // check if it can rotate clockwise \\n                            mp[{i+1,j-1,1}]++; q.push({i+1,j-1,1}); \\n                        }\\n                    }\\n                }\\n                else{    // if direction is vertical \\n                    if(i+1<n && nums[i+1][j]==0 && mp.find({i+1,j,1})==mp.end()) {  // check if it can move to down \\n                        mp[{i+1,j,1}]++; q.push({i+1,j,1});\\n                    }\\n                    if(j+1<n && nums[i][j+1]==0 && nums[i-1][j+1]==0){\\n                        if(mp.find({i,j+1,1})==mp.end()){   // check if it can move to right \\n                            mp[{i,j+1,1}]++; q.push({i,j+1,1});\\n                        }\\n                        if(mp.find({i-1,j+1,0})==mp.end()){   // check if it can rotate anticlockwise\\n                            mp[{i-1,j+1,0}]++; q.push({i-1,j+1,0});\\n                        }\\n                    } \\n                }\\n            }\\n            l++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1227484,
                "title": "c-bfs",
                "content": "```\\nclass Solution {\\npublic:\\n    int n;\\n    bool valid(int i,int j)\\n    {\\n        if(i<0 || j<0 || i>=n || j>=n)\\n            return false;\\n        return true;\\n    }\\n    int minimumMoves(vector<vector<int>>& grid) \\n    {\\n        int state=0;  //Horizontal-0    Vertical-1\\n        n=grid.size();\\n        queue<vector<int>>q;\\n        vector<vector<bool>>vish(n,vector<bool>(n,false)),visv(n,vector<bool>(n,false));\\n        \\n        q.push({0,1,state});\\n        vish[0][1]=true;\\n        int res=0;\\n        while(!q.empty())\\n        {\\n            int size=q.size();\\n            while(size--)\\n            {\\n                int i=q.front()[0],j=q.front()[1],state=q.front()[2];\\n                q.pop();\\n                if(i==n-1 && j==n-1 && state==0)\\n                    return res;\\n                if(state==0)\\n                {\\n                    int x=i,y=j+1;\\n                    if(valid(x,y) && grid[x][y]==0 && !vish[x][y])  //Right\\n                    {\\n                        q.push({x,y,0});\\n                        vish[x][y]=true;\\n                    }\\n                    \\n                    int x1=i+1,y1=j-1,x2=i+1,y2=j;\\n                    if(valid(x1,y1) && valid(x2,y2) && grid[x1][y1]==0 && grid[x2][y2]==0 && !vish[x2][y2])  //Down\\n                    {\\n                        q.push({x2,y2,0});\\n                        vish[x2][y2]=true;\\n                    }\\n                    \\n                    x=i+1,y=j-1;\\n                    if(valid(x,y) && valid(x,y+1) && grid[x][y]==0 && grid[x][y+1]==0 && !visv[x][y])  // Rotate clockwise\\n                    {\\n                        q.push({x,y,1});\\n                        visv[x][y]=true;\\n                    }\\n                }\\n                else\\n                {\\n                    int x1=i-1,y1=j+1,x2=i,y2=j+1;\\n                    if(valid(x1,y1) && valid(x2,y2) && grid[x1][y1]==0 && grid[x2][y2]==0 && !visv[x2][y2])  //Right\\n                    {\\n                        q.push({x2,y2,1});\\n                        visv[x2][y2]=true;\\n                    }\\n                    \\n                    int x=i+1,y=j;\\n                    if(valid(x,y) && grid[x][y]==0 && !visv[x][y])  //Down\\n                    {\\n                        visv[x][y]=true;\\n                        q.push({x,y,1});\\n                    }\\n                    \\n                    x=i-1,y=j+1;\\n                    if(valid(x,y) && valid(x+1,y) && grid[x][y]==0 && grid[x+1][y]==0 && !vish[x][y])  // Rotate anticlockwise\\n                    {\\n                        q.push({x,y,0});\\n                        vish[x][y]=true;\\n                    }\\n                }\\n            }\\n            res++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int n;\\n    bool valid(int i,int j)\\n    {\\n        if(i<0 || j<0 || i>=n || j>=n)\\n            return false;\\n        return true;\\n    }\\n    int minimumMoves(vector<vector<int>>& grid) \\n    {\\n        int state=0;  //Horizontal-0    Vertical-1\\n        n=grid.size();\\n        queue<vector<int>>q;\\n        vector<vector<bool>>vish(n,vector<bool>(n,false)),visv(n,vector<bool>(n,false));\\n        \\n        q.push({0,1,state});\\n        vish[0][1]=true;\\n        int res=0;\\n        while(!q.empty())\\n        {\\n            int size=q.size();\\n            while(size--)\\n            {\\n                int i=q.front()[0],j=q.front()[1],state=q.front()[2];\\n                q.pop();\\n                if(i==n-1 && j==n-1 && state==0)\\n                    return res;\\n                if(state==0)\\n                {\\n                    int x=i,y=j+1;\\n                    if(valid(x,y) && grid[x][y]==0 && !vish[x][y])  //Right\\n                    {\\n                        q.push({x,y,0});\\n                        vish[x][y]=true;\\n                    }\\n                    \\n                    int x1=i+1,y1=j-1,x2=i+1,y2=j;\\n                    if(valid(x1,y1) && valid(x2,y2) && grid[x1][y1]==0 && grid[x2][y2]==0 && !vish[x2][y2])  //Down\\n                    {\\n                        q.push({x2,y2,0});\\n                        vish[x2][y2]=true;\\n                    }\\n                    \\n                    x=i+1,y=j-1;\\n                    if(valid(x,y) && valid(x,y+1) && grid[x][y]==0 && grid[x][y+1]==0 && !visv[x][y])  // Rotate clockwise\\n                    {\\n                        q.push({x,y,1});\\n                        visv[x][y]=true;\\n                    }\\n                }\\n                else\\n                {\\n                    int x1=i-1,y1=j+1,x2=i,y2=j+1;\\n                    if(valid(x1,y1) && valid(x2,y2) && grid[x1][y1]==0 && grid[x2][y2]==0 && !visv[x2][y2])  //Right\\n                    {\\n                        q.push({x2,y2,1});\\n                        visv[x2][y2]=true;\\n                    }\\n                    \\n                    int x=i+1,y=j;\\n                    if(valid(x,y) && grid[x][y]==0 && !visv[x][y])  //Down\\n                    {\\n                        visv[x][y]=true;\\n                        q.push({x,y,1});\\n                    }\\n                    \\n                    x=i-1,y=j+1;\\n                    if(valid(x,y) && valid(x+1,y) && grid[x][y]==0 && grid[x+1][y]==0 && !vish[x][y])  // Rotate anticlockwise\\n                    {\\n                        q.push({x,y,0});\\n                        vish[x][y]=true;\\n                    }\\n                }\\n            }\\n            res++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 901062,
                "title": "kotlin-bfs-fun-game-isn-t-it",
                "content": "The idea was \"stolen\" from [this post](https://leetcode.com/problems/minimum-moves-to-reach-target-with-rotations/discuss/393511/JavaPython-3-25-and-17-liner-clean-BFS-codes-w-brief-explanation-and-analysis.) by @rock. I just made limited modifications with some comments and constants.\\n\\nTo whom this might concern:\\nI spent about one hour figuring out why my solution was wrong, only to find that the rotation operation requires <b>2 empty cells</b> in the corresponding positions, instead of 1.\\n\\nSolution - [github](https://github.com/An7One/leetcode-solutions-kotlin-an7one/tree/main/src/main/kotlin/com/an7one/leetcode/lvl4/lc1210)\\n\\n<b>Problem List</b>\\n#BFS - [github](https://github.com/An7One/leetcode-problems-by-tag-an7one/tree/main/txt/by_algorithm/search/breath_first_search)\\n\\n```\\n/**\\n * @author: Leon\\n * https://leetcode.com/problems/minimum-moves-to-reach-target-with-rotations/\\n *\\n * Time Complexity:     O(`n` ^ 2)\\n * Space Complexity:    O(`n` ^ 2)\\n *\\n * Reference:\\n * https://leetcode.com/problems/minimum-moves-to-reach-target-with-rotations/discuss/393511/JavaPython-3-25-and-17-liner-clean-BFS-codes-w-brief-explanation-and-analysis.\\n */\\nclass Solution {\\n    private companion object {\\n        private const val EMPTY = 0\\n\\n        // not used\\n        // private const val BLOCKED = 1\\n    }\\n\\n    fun minimumMoves(grid: Array<IntArray>): Int {\\n        val n = grid.size\\n\\n        val start = State(0, 0, Facing.RIGHT)\\n        val target = State(n - 1, n - 2, Facing.RIGHT)\\n\\n        // to keep track of the tail of the snake,\\n        // so it is required to check 2 steps in the front, to move towards the facing direction\\n        val queue = ArrayDeque<State>().also{\\n            it.addLast(start)\\n        }\\n\\n        val seen = HashSet<String>()\\n\\n        var steps = 0\\n\\n        while (queue.isNotEmpty()) {\\n            val size = queue.size\\n\\n            for (sz in 0 until size) {\\n                val cur = queue.removeFirst()\\n                if (cur == target) return steps\\n\\n                val row = cur.row\\n                val col = cur.col\\n                val dir = cur.dir\\n\\n                if (!seen.add(cur.toHash())) continue\\n\\n                if (dir == Facing.RIGHT) { // facing right\\n                    if (row + 1 < n && grid[row + 1][col] == EMPTY && grid[row + 1][col + 1] == EMPTY) { // to check if both cells down are available (while facing right)\\n                        queue.offer(State(row, col, Facing.DOWN)) // to rotate clockwise (while facing right)\\n                        queue.offer(State(row + 1, col, Facing.RIGHT)) // to move down (while facing right)\\n                    }\\n\\n                    if (col + 2 < n && grid[row][col + 2] == EMPTY) { // to check if the cell in front of the snake head is available (while facing right)\\n                        queue.offer(State(row, col + 1, Facing.RIGHT)) // to move right (while facing right)\\n                    }\\n\\n                }\\n\\n                if (dir == Facing.DOWN) { // facing down\\n                    if (col + 1 < n && grid[row][col + 1] == EMPTY && grid[row + 1][col + 1] == EMPTY) { // to check if both cells right are available (while facing down)\\n                        queue.offer(State(row, col, Facing.RIGHT)) // to rotate anti-clockwise (while facing down)\\n                        queue.offer(State(row, col + 1, Facing.DOWN)) // to move right (while facing down)\\n                    }\\n\\n                    if (row + 2 < n && grid[row + 2][col] == EMPTY) { // to check if the cell in front of the snake head is available (while facing down)\\n                        queue.offer(State(row + 1, col, Facing.DOWN)) // to move down (while facing down)\\n                    }\\n                }\\n            }\\n\\n            ++steps\\n        }\\n\\n        return -1\\n    }\\n\\n    private data class State(val row: Int, val col: Int, val dir: Facing) {\\n\\n        fun toHash(): String = \"$row#$col#$dir\"\\n\\n        override fun equals(other: Any?) = (other is State) && row == other.row && col == other.col && dir == other.dir\\n\\n        override fun hashCode(): Int {\\n            return super.hashCode()\\n        }\\n    }\\n\\n    private enum class Facing {\\n        DOWN, RIGHT\\n    }\\n}\\n```\\n\\nWhat a @rock!\\nWhat a fun game!\\nWhat a practice for BFS!\\n\\nI love algorithm!\\nI love Kotlin!",
                "solutionTags": [
                    "Kotlin",
                    "Breadth-First Search"
                ],
                "code": "```\\n/**\\n * @author: Leon\\n * https://leetcode.com/problems/minimum-moves-to-reach-target-with-rotations/\\n *\\n * Time Complexity:     O(`n` ^ 2)\\n * Space Complexity:    O(`n` ^ 2)\\n *\\n * Reference:\\n * https://leetcode.com/problems/minimum-moves-to-reach-target-with-rotations/discuss/393511/JavaPython-3-25-and-17-liner-clean-BFS-codes-w-brief-explanation-and-analysis.\\n */\\nclass Solution {\\n    private companion object {\\n        private const val EMPTY = 0\\n\\n        // not used\\n        // private const val BLOCKED = 1\\n    }\\n\\n    fun minimumMoves(grid: Array<IntArray>): Int {\\n        val n = grid.size\\n\\n        val start = State(0, 0, Facing.RIGHT)\\n        val target = State(n - 1, n - 2, Facing.RIGHT)\\n\\n        // to keep track of the tail of the snake,\\n        // so it is required to check 2 steps in the front, to move towards the facing direction\\n        val queue = ArrayDeque<State>().also{\\n            it.addLast(start)\\n        }\\n\\n        val seen = HashSet<String>()\\n\\n        var steps = 0\\n\\n        while (queue.isNotEmpty()) {\\n            val size = queue.size\\n\\n            for (sz in 0 until size) {\\n                val cur = queue.removeFirst()\\n                if (cur == target) return steps\\n\\n                val row = cur.row\\n                val col = cur.col\\n                val dir = cur.dir\\n\\n                if (!seen.add(cur.toHash())) continue\\n\\n                if (dir == Facing.RIGHT) { // facing right\\n                    if (row + 1 < n && grid[row + 1][col] == EMPTY && grid[row + 1][col + 1] == EMPTY) { // to check if both cells down are available (while facing right)\\n                        queue.offer(State(row, col, Facing.DOWN)) // to rotate clockwise (while facing right)\\n                        queue.offer(State(row + 1, col, Facing.RIGHT)) // to move down (while facing right)\\n                    }\\n\\n                    if (col + 2 < n && grid[row][col + 2] == EMPTY) { // to check if the cell in front of the snake head is available (while facing right)\\n                        queue.offer(State(row, col + 1, Facing.RIGHT)) // to move right (while facing right)\\n                    }\\n\\n                }\\n\\n                if (dir == Facing.DOWN) { // facing down\\n                    if (col + 1 < n && grid[row][col + 1] == EMPTY && grid[row + 1][col + 1] == EMPTY) { // to check if both cells right are available (while facing down)\\n                        queue.offer(State(row, col, Facing.RIGHT)) // to rotate anti-clockwise (while facing down)\\n                        queue.offer(State(row, col + 1, Facing.DOWN)) // to move right (while facing down)\\n                    }\\n\\n                    if (row + 2 < n && grid[row + 2][col] == EMPTY) { // to check if the cell in front of the snake head is available (while facing down)\\n                        queue.offer(State(row + 1, col, Facing.DOWN)) // to move down (while facing down)\\n                    }\\n                }\\n            }\\n\\n            ++steps\\n        }\\n\\n        return -1\\n    }\\n\\n    private data class State(val row: Int, val col: Int, val dir: Facing) {\\n\\n        fun toHash(): String = \"$row#$col#$dir\"\\n\\n        override fun equals(other: Any?) = (other is State) && row == other.row && col == other.col && dir == other.dir\\n\\n        override fun hashCode(): Int {\\n            return super.hashCode()\\n        }\\n    }\\n\\n    private enum class Facing {\\n        DOWN, RIGHT\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 875906,
                "title": "rust-translated-8ms-100",
                "content": "```rust\\nimpl Solution {\\n    pub fn minimum_moves(mut grid: Vec<Vec<i32>>) -> i32 {\\n        use std::collections::VecDeque;\\n\\n        fn can_rotate(g: &[Vec<i32>], r: i32, c: i32) -> bool {\\n            r < g.len() as i32 - 1\\n                && c < g[0].len() as i32 - 1\\n                && (g[r as usize + 1][c as usize] & 1) == 0\\n                && (g[r as usize][c as usize + 1] & 1) == 0\\n                && (g[r as usize + 1][c as usize + 1] & 1) == 0\\n        }\\n\\n        fn can_go_down(g: &[Vec<i32>], r: i32, c: i32, vertical: bool) -> bool {\\n            if vertical {\\n                r < g.len() as i32 - 2 && (g[r as usize + 2][c as usize] & 1) == 0\\n            } else {\\n                r < g.len() as i32 - 1\\n                    && (g[r as usize + 1][c as usize] & 1) == 0\\n                    && (g[r as usize + 1][c as usize + 1] & 1) == 0\\n            }\\n        }\\n\\n        fn can_go_right(g: &[Vec<i32>], r: i32, c: i32, vertical: bool) -> bool {\\n            if !vertical {\\n                c < g[0].len() as i32 - 2 && (g[r as usize][c as usize + 2] & 1) == 0\\n            } else {\\n                c < g[0].len() as i32 - 1\\n                    && (g[r as usize][c as usize + 1] & 1) == 0\\n                    && (g[r as usize + 1][c as usize + 1] & 1) == 0\\n            }\\n        }\\n\\n        let mut steps = 0;\\n        let mut q = VecDeque::<(i32, i32, bool)>::new();\\n        q.push_back((0, 0, false));\\n        while !q.is_empty() {\\n            let size = q.len();\\n            for _ in 0..size {\\n                let (r, c, vertical) = q.pop_front().unwrap();\\n                if r == grid.len() as i32 - 1 && c == grid[0].len() as i32 - 2 {\\n                    return steps;\\n                }\\n                if grid[r as usize][c as usize] & (if vertical { 2 } else { 4 }) == 0 {\\n                    grid[r as usize][c as usize] |= if vertical { 2 } else { 4 };\\n                    if can_go_down(&grid, r, c, vertical) {\\n                        q.push_back((r + 1, c, vertical));\\n                    }\\n                    if can_go_right(&grid, r, c, vertical) {\\n                        q.push_back((r, c + 1, vertical));\\n                    }\\n                    if can_rotate(&grid, r, c) {\\n                        q.push_back((r, c, !vertical));\\n                    }\\n                }\\n            }\\n            steps += 1;\\n        }\\n        -1\\n    }\\n}\\n\\n#[cfg(test)]\\nmod tests {\\n    use super::*;\\n\\n    #[test]\\n    fn test_minimum_moves() {\\n        assert_eq!(\\n            Solution::minimum_moves(vec![\\n                vec![0, 0, 0, 0, 0, 1],\\n                vec![1, 1, 0, 0, 1, 0],\\n                vec![0, 0, 0, 0, 1, 1],\\n                vec![0, 0, 1, 0, 1, 0],\\n                vec![0, 1, 1, 0, 0, 0],\\n                vec![0, 1, 1, 0, 0, 0]\\n            ]),\\n            11\\n        );\\n    }\\n\\n    #[test]\\n    fn test_minimum_moves_02() {\\n        assert_eq!(\\n            Solution::minimum_moves(vec![\\n                vec![0, 0, 1, 1, 1, 1],\\n                vec![0, 0, 0, 0, 1, 1],\\n                vec![1, 1, 0, 0, 0, 1],\\n                vec![1, 1, 1, 0, 0, 1],\\n                vec![1, 1, 1, 0, 0, 1],\\n                vec![1, 1, 1, 0, 0, 0]\\n            ]),\\n            9\\n        );\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```rust\\nimpl Solution {\\n    pub fn minimum_moves(mut grid: Vec<Vec<i32>>) -> i32 {\\n        use std::collections::VecDeque;\\n\\n        fn can_rotate(g: &[Vec<i32>], r: i32, c: i32) -> bool {\\n            r < g.len() as i32 - 1\\n                && c < g[0].len() as i32 - 1\\n                && (g[r as usize + 1][c as usize] & 1) == 0\\n                && (g[r as usize][c as usize + 1] & 1) == 0\\n                && (g[r as usize + 1][c as usize + 1] & 1) == 0\\n        }\\n\\n        fn can_go_down(g: &[Vec<i32>], r: i32, c: i32, vertical: bool) -> bool {\\n            if vertical {\\n                r < g.len() as i32 - 2 && (g[r as usize + 2][c as usize] & 1) == 0\\n            } else {\\n                r < g.len() as i32 - 1\\n                    && (g[r as usize + 1][c as usize] & 1) == 0\\n                    && (g[r as usize + 1][c as usize + 1] & 1) == 0\\n            }\\n        }\\n\\n        fn can_go_right(g: &[Vec<i32>], r: i32, c: i32, vertical: bool) -> bool {\\n            if !vertical {\\n                c < g[0].len() as i32 - 2 && (g[r as usize][c as usize + 2] & 1) == 0\\n            } else {\\n                c < g[0].len() as i32 - 1\\n                    && (g[r as usize][c as usize + 1] & 1) == 0\\n                    && (g[r as usize + 1][c as usize + 1] & 1) == 0\\n            }\\n        }\\n\\n        let mut steps = 0;\\n        let mut q = VecDeque::<(i32, i32, bool)>::new();\\n        q.push_back((0, 0, false));\\n        while !q.is_empty() {\\n            let size = q.len();\\n            for _ in 0..size {\\n                let (r, c, vertical) = q.pop_front().unwrap();\\n                if r == grid.len() as i32 - 1 && c == grid[0].len() as i32 - 2 {\\n                    return steps;\\n                }\\n                if grid[r as usize][c as usize] & (if vertical { 2 } else { 4 }) == 0 {\\n                    grid[r as usize][c as usize] |= if vertical { 2 } else { 4 };\\n                    if can_go_down(&grid, r, c, vertical) {\\n                        q.push_back((r + 1, c, vertical));\\n                    }\\n                    if can_go_right(&grid, r, c, vertical) {\\n                        q.push_back((r, c + 1, vertical));\\n                    }\\n                    if can_rotate(&grid, r, c) {\\n                        q.push_back((r, c, !vertical));\\n                    }\\n                }\\n            }\\n            steps += 1;\\n        }\\n        -1\\n    }\\n}\\n\\n#[cfg(test)]\\nmod tests {\\n    use super::*;\\n\\n    #[test]\\n    fn test_minimum_moves() {\\n        assert_eq!(\\n            Solution::minimum_moves(vec![\\n                vec![0, 0, 0, 0, 0, 1],\\n                vec![1, 1, 0, 0, 1, 0],\\n                vec![0, 0, 0, 0, 1, 1],\\n                vec![0, 0, 1, 0, 1, 0],\\n                vec![0, 1, 1, 0, 0, 0],\\n                vec![0, 1, 1, 0, 0, 0]\\n            ]),\\n            11\\n        );\\n    }\\n\\n    #[test]\\n    fn test_minimum_moves_02() {\\n        assert_eq!(\\n            Solution::minimum_moves(vec![\\n                vec![0, 0, 1, 1, 1, 1],\\n                vec![0, 0, 0, 0, 1, 1],\\n                vec![1, 1, 0, 0, 0, 1],\\n                vec![1, 1, 1, 0, 0, 1],\\n                vec![1, 1, 1, 0, 0, 1],\\n                vec![1, 1, 1, 0, 0, 0]\\n            ]),\\n            9\\n        );\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 788678,
                "title": "c-dp-with-speed-99-memory-91",
                "content": "Top-down dynamic programming. `dp[i][j]` is a `pair<int, int>` where `dp[i][j].first` is the minimum moves from starting point to (i, j) with head in (i, j) and tail in (i, j-1) (horizontal), and `dp[i][j].second` is the minimum moves from starting point to (i, j) with head in (i, j) and tail in (i-1, j) (vertical). If it\\'s impossible for the snake to be in that position, set the value to be `-1`. For either horizontal or vertical position, there\\'re 3 ways for the snake to move from last position to new positon: move down, move right, rotate. Calculate the minimum move for each way and store the smallest one in `dp[i][j]`.\\n\\n```\\nclass Solution {\\npublic:\\n    int minimumMoves(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        vector<vector<pair<int, int>>> dp(n, vector<pair<int,int>>(n));\\n        int ho, ho1, ho2, ho3, ve, ve1, ve2, ve3;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (i == 0 && j <= 1) dp[i][j] = {0, -1};\\n                else if (grid[i][j] == 1) dp[i][j] = {-1, -1};\\n                else if (i == 0) {\\n                    if (dp[i][j-1].first==-1) dp[i][j] = {-1, -1};\\n                    else dp[i][j] = {dp[i][j-1].first+1, -1};\\n                }\\n                else if (i == 1 && j == 0) {\\n                    if (grid[1][1] == 1) dp[i][j] = {-1, -1};\\n                    else dp[i][j] = {-1,1};\\n                }\\n                else if (j == 0) {\\n                    if (dp[i-1][j].second==-1) dp[i][j] = {-1, -1};\\n                    else dp[i][j] = {-1, dp[i-1][j].second+1};\\n                }\\n                else {\\n                    ho1 = dp[i][j-1].first==-1?-1:dp[i][j-1].first+1;\\n                    ho2 = (dp[i-1][j].first==-1||grid[i][j-1]==1)?-1:dp[i-1][j].first+1;\\n                    if (i==n-1 || grid[i+1][j]==1 || grid[i+1][j-1]==1 || dp[i][j-1].second == -1) ho3 = -1;\\n                    else ho3 = dp[i][j-1].second + 2;\\n                    if (ho1 == -1 && ho2 == -1) ho = ho3;\\n                    else if (ho1 == -1) ho = ho2;\\n                    else if (ho2 == -1) ho = ho1;\\n                    else ho = min(ho1, ho2);\\n                    if (grid[i-1][j] == 1) ve = -1;\\n                    else {\\n                        ve1 = dp[i-1][j].second==-1?-1:dp[i-1][j].second+1;\\n                        if (j == n-1 || grid[i][j+1]==1||dp[i-1][j+1].first==-1) ve2 = -1;\\n                        else ve2 = dp[i-1][j+1].first+1;\\n                        ve3 = dp[i][j-1].second== -1?-1:dp[i][j-1].second+1;\\n                        if (ve1 == -1 && ve3 == -1) ve = ve2;\\n                        else if (ve1 == -1) ve = ve3;\\n                        else if (ve3 == -1) ve = ve1;\\n                        else ve = min(ve1, ve3);\\n                    }\\n                    dp[i][j] = {ho, ve};\\n                }\\n            }\\n        }\\n        return dp[n-1][n-1].first;\\n    }\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/5c882116-21d5-4323-861e-0f0ad9f2907c_1597283162.628977.png)\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumMoves(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        vector<vector<pair<int, int>>> dp(n, vector<pair<int,int>>(n));\\n        int ho, ho1, ho2, ho3, ve, ve1, ve2, ve3;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (i == 0 && j <= 1) dp[i][j] = {0, -1};\\n                else if (grid[i][j] == 1) dp[i][j] = {-1, -1};\\n                else if (i == 0) {\\n                    if (dp[i][j-1].first==-1) dp[i][j] = {-1, -1};\\n                    else dp[i][j] = {dp[i][j-1].first+1, -1};\\n                }\\n                else if (i == 1 && j == 0) {\\n                    if (grid[1][1] == 1) dp[i][j] = {-1, -1};\\n                    else dp[i][j] = {-1,1};\\n                }\\n                else if (j == 0) {\\n                    if (dp[i-1][j].second==-1) dp[i][j] = {-1, -1};\\n                    else dp[i][j] = {-1, dp[i-1][j].second+1};\\n                }\\n                else {\\n                    ho1 = dp[i][j-1].first==-1?-1:dp[i][j-1].first+1;\\n                    ho2 = (dp[i-1][j].first==-1||grid[i][j-1]==1)?-1:dp[i-1][j].first+1;\\n                    if (i==n-1 || grid[i+1][j]==1 || grid[i+1][j-1]==1 || dp[i][j-1].second == -1) ho3 = -1;\\n                    else ho3 = dp[i][j-1].second + 2;\\n                    if (ho1 == -1 && ho2 == -1) ho = ho3;\\n                    else if (ho1 == -1) ho = ho2;\\n                    else if (ho2 == -1) ho = ho1;\\n                    else ho = min(ho1, ho2);\\n                    if (grid[i-1][j] == 1) ve = -1;\\n                    else {\\n                        ve1 = dp[i-1][j].second==-1?-1:dp[i-1][j].second+1;\\n                        if (j == n-1 || grid[i][j+1]==1||dp[i-1][j+1].first==-1) ve2 = -1;\\n                        else ve2 = dp[i-1][j+1].first+1;\\n                        ve3 = dp[i][j-1].second== -1?-1:dp[i][j-1].second+1;\\n                        if (ve1 == -1 && ve3 == -1) ve = ve2;\\n                        else if (ve1 == -1) ve = ve3;\\n                        else if (ve3 == -1) ve = ve1;\\n                        else ve = min(ve1, ve3);\\n                    }\\n                    dp[i][j] = {ho, ve};\\n                }\\n            }\\n        }\\n        return dp[n-1][n-1].first;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 736930,
                "title": "python-bfs-annotated",
                "content": "**Legend:**\\nr, c : current row/column\\nR, C : number of rows/columns in grid\\nd : the distance the snake has traveled\\nq : queue that stores (distance traveled to current position (d), current row (r), curren column (c), orientation (o))\\no : orientation (0 is horizontal and 1 is vertical) - please forgive the use of o as a variable name\\n\\n**Notes:**\\nNothing too out of the oridnary here as far as BFS goes.  The exception being that visited contains two dictionaries.  \\n\\nBoth dictionaries keep track of how far the snake traveled (d) to get to the location (r,c).  However, the first one only records when the snake is in the horizontal position, and the second one only records when the snake is in the vertical position.  \\n\\nBecause the snake must reach the finish in the horizontal position, we check visited[0][target] to see if the snake made it to the finish, and how many \"steps\" it took.\\n\\n```python\\nclass Solution:\\n    def minimumMoves(self, grid: List[List[int]]) -> int:\\n        \\n        self.grid = grid\\n        self.R, self.C = len(grid), len(grid[0])\\n        target = (self.R-1, self.C-1)\\n        \\n        q = [(0,0,1,0)]           #(distance traveled, row, column, orientation)\\n        visited = [{(0,1): 0},{}] #visited in horizontal state, visited in vertical state\\n        \\n        while q:\\n            \\n            d, r, c, o = heapq.heappop(q)\\n            \\n            #Check if snake can shift down, shift right, or rotate\\n            shift_d, shift_r, rot = self.shift_down(r,c,o), self.shift_right(r,c,o), self.rotate(r,c,o)\\n            \\n            #increment distance traveled by 1\\n            d += 1\\n            \\n            #Update the queue and visited after the snake has shifted down, right, or rotated\\n            if shift_d:\\n                i,j = shift_d\\n                if d < visited[o].get((i,j),float(\\'inf\\')):\\n                    visited[o][(i,j)] = d\\n                    heapq.heappush(q,(d,i,j,o))\\n                    \\n            if shift_r:\\n                i,j = shift_r\\n                if d < visited[o].get((i,j),float(\\'inf\\')):\\n                    visited[o][(i,j)] = d\\n                    heapq.heappush(q,(d,i,j,o))\\n                    \\n            if rot:\\n                i,j = rot\\n                if d < visited[1-o].get((i,j),float(\\'inf\\')):\\n                    visited[1-o][(i,j)] = d\\n                    heapq.heappush(q,(d,i,j,1-o))\\n            \\n        return visited[0].get(target,-1)\\n    \\n    \\n    def shift_right(self, r, c, orient):\\n        \\'\\'\\'returns False if snake cannot move to the right, otherwise returns new head position\\'\\'\\'\\n        if (orient == 0) and ((c == self.C-1) or self.grid[r][c+1]): return False\\n        if (orient == 1) and ((c == self.C-1) or self.grid[r][c+1] or self.grid[r-1][c+1]): return False\\n        return (r, c+1)\\n\\n    def shift_down(self, r, c, orient):\\n        \\'\\'\\'returns False if snake cannot move downwards, otherwise returns new head position\\'\\'\\'\\n        if (orient == 1) and ((r == self.R-1) or self.grid[r+1][c]): return False\\n        if (orient == 0) and ((r == self.R-1) or self.grid[r+1][c] or self.grid[r+1][c-1]): return False\\n        return (r+1, c)\\n    \\n    def rotate(self, r, c, orient):\\n        \\'\\'\\'returns False if the snake is blocked from rotating, otherwise returns new head position (r,c)\\'\\'\\'\\n        #horizontal to vertical CW rotation\\n        if (orient == 0) and ((r == self.R-1) or self.grid[r+1][c] or self.grid[r+1][c-1]): return False\\n        if (orient == 0): return (r+1,c-1)\\n        \\n        #vertical to horizontal CCW rotation\\n        if (c == self.C-1) or self.grid[r][c+1] or self.grid[r-1][c+1]: return False\\n        return (r-1,c+1) \\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```python\\nclass Solution:\\n    def minimumMoves(self, grid: List[List[int]]) -> int:\\n        \\n        self.grid = grid\\n        self.R, self.C = len(grid), len(grid[0])\\n        target = (self.R-1, self.C-1)\\n        \\n        q = [(0,0,1,0)]           #(distance traveled, row, column, orientation)\\n        visited = [{(0,1): 0},{}] #visited in horizontal state, visited in vertical state\\n        \\n        while q:\\n            \\n            d, r, c, o = heapq.heappop(q)\\n            \\n            #Check if snake can shift down, shift right, or rotate\\n            shift_d, shift_r, rot = self.shift_down(r,c,o), self.shift_right(r,c,o), self.rotate(r,c,o)\\n            \\n            #increment distance traveled by 1\\n            d += 1\\n            \\n            #Update the queue and visited after the snake has shifted down, right, or rotated\\n            if shift_d:\\n                i,j = shift_d\\n                if d < visited[o].get((i,j),float(\\'inf\\')):\\n                    visited[o][(i,j)] = d\\n                    heapq.heappush(q,(d,i,j,o))\\n                    \\n            if shift_r:\\n                i,j = shift_r\\n                if d < visited[o].get((i,j),float(\\'inf\\')):\\n                    visited[o][(i,j)] = d\\n                    heapq.heappush(q,(d,i,j,o))\\n                    \\n            if rot:\\n                i,j = rot\\n                if d < visited[1-o].get((i,j),float(\\'inf\\')):\\n                    visited[1-o][(i,j)] = d\\n                    heapq.heappush(q,(d,i,j,1-o))\\n            \\n        return visited[0].get(target,-1)\\n    \\n    \\n    def shift_right(self, r, c, orient):\\n        \\'\\'\\'returns False if snake cannot move to the right, otherwise returns new head position\\'\\'\\'\\n        if (orient == 0) and ((c == self.C-1) or self.grid[r][c+1]): return False\\n        if (orient == 1) and ((c == self.C-1) or self.grid[r][c+1] or self.grid[r-1][c+1]): return False\\n        return (r, c+1)\\n\\n    def shift_down(self, r, c, orient):\\n        \\'\\'\\'returns False if snake cannot move downwards, otherwise returns new head position\\'\\'\\'\\n        if (orient == 1) and ((r == self.R-1) or self.grid[r+1][c]): return False\\n        if (orient == 0) and ((r == self.R-1) or self.grid[r+1][c] or self.grid[r+1][c-1]): return False\\n        return (r+1, c)\\n    \\n    def rotate(self, r, c, orient):\\n        \\'\\'\\'returns False if the snake is blocked from rotating, otherwise returns new head position (r,c)\\'\\'\\'\\n        #horizontal to vertical CW rotation\\n        if (orient == 0) and ((r == self.R-1) or self.grid[r+1][c] or self.grid[r+1][c-1]): return False\\n        if (orient == 0): return (r+1,c-1)\\n        \\n        #vertical to horizontal CCW rotation\\n        if (c == self.C-1) or self.grid[r][c+1] or self.grid[r-1][c+1]: return False\\n        return (r-1,c+1) \\n```",
                "codeTag": "Java"
            },
            {
                "id": 469631,
                "title": "c-beat-100",
                "content": "```\\npublic class Solution {\\n    public int MinimumMoves(int[][] grid) {\\n        \\n        Queue<int> q = new Queue<int>();\\n        Queue<bool> pos = new Queue<bool>();\\n        \\n        HashSet<int> v = new HashSet<int>();\\n        HashSet<int> h = new HashSet<int>();\\n        \\n        int n = grid.Length;\\n        int start = n * 0 + 1;\\n        \\n        // horizontal = true / vertical = false\\n        q.Enqueue(start);\\n        pos.Enqueue(true);\\n        \\n        int[] rows = new int[4] { 0, -1, 0, 1 };\\n        int[] cols = new int[4] { -1, 0, 1, 0 };\\n        \\n        int move = 0;\\n        while(q.Count() > 0)\\n        {\\n            int count = q.Count();\\n            for (int i = 0; i < count; i++)\\n            {\\n                int num = q.Dequeue();\\n                bool d = pos.Dequeue();\\n                int r = num / n;\\n                int c = num % n;\\n                \\n                if (r == n -1 && c == n - 1 && d == true)\\n                {\\n                    return move;\\n                }\\n                \\n                if (d == true) // horizontal\\n                {\\n                    if (c < n - 1 && grid[r][c + 1] == 0 && !h.Contains(r * n + c + 1))\\n                    {\\n                        q.Enqueue(r * n + c + 1);\\n                        pos.Enqueue(true);\\n                        h.Add(r * n + c + 1);\\n                    }\\n                    \\n                    if (r < n - 1 && grid[r + 1][c] == 0 && grid[r + 1][c - 1] == 0 && !h.Contains((r + 1) * n + c))\\n                    {\\n                        q.Enqueue((r + 1) * n + c);\\n                        pos.Enqueue(true);\\n                        h.Add((r + 1) * n + c);\\n                    }\\n                    \\n                    if (r < n - 1 && grid[r + 1][c] == 0 && grid[r + 1][c - 1] == 0 && !v.Contains((r + 1) * n + c - 1))\\n                    {\\n                        q.Enqueue((r + 1) * n + c - 1);\\n                        pos.Enqueue(false);\\n                        v.Add((r + 1) * n + c - 1);\\n                    }\\n                }\\n                else\\n                {\\n                    if (c < n - 1 && grid[r - 1][c + 1] == 0 && grid[r][c + 1] == 0 && !v.Contains(r * n + c + 1))\\n                    {\\n                        q.Enqueue(r * n + c + 1);\\n                        pos.Enqueue(false);\\n                        v.Add(r * n + c + 1);\\n                    }\\n                    \\n                    if (r < n - 1 && grid[r + 1][c] == 0 && !v.Contains((r + 1) * n + c))\\n                    {\\n                        q.Enqueue((r + 1) * n + c);\\n                        pos.Enqueue(false);\\n                        v.Add((r + 1) * n + c);\\n                    }\\n                    \\n                    if (c < n - 1 && grid[r - 1][c + 1] == 0 && grid[r][c + 1] == 0 && !h.Contains((r - 1) * n + c + 1))\\n                    {\\n                        q.Enqueue((r - 1) * n + c + 1);\\n                        pos.Enqueue(true);\\n                        h.Add((r - 1) * n + c + 1);\\n                    }\\n                }\\n            }\\n            \\n            move++;\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int MinimumMoves(int[][] grid) {\\n        \\n        Queue<int> q = new Queue<int>();\\n        Queue<bool> pos = new Queue<bool>();\\n        \\n        HashSet<int> v = new HashSet<int>();\\n        HashSet<int> h = new HashSet<int>();\\n        \\n        int n = grid.Length;\\n        int start = n * 0 + 1;\\n        \\n        // horizontal = true / vertical = false\\n        q.Enqueue(start);\\n        pos.Enqueue(true);\\n        \\n        int[] rows = new int[4] { 0, -1, 0, 1 };\\n        int[] cols = new int[4] { -1, 0, 1, 0 };\\n        \\n        int move = 0;\\n        while(q.Count() > 0)\\n        {\\n            int count = q.Count();\\n            for (int i = 0; i < count; i++)\\n            {\\n                int num = q.Dequeue();\\n                bool d = pos.Dequeue();\\n                int r = num / n;\\n                int c = num % n;\\n                \\n                if (r == n -1 && c == n - 1 && d == true)\\n                {\\n                    return move;\\n                }\\n                \\n                if (d == true) // horizontal\\n                {\\n                    if (c < n - 1 && grid[r][c + 1] == 0 && !h.Contains(r * n + c + 1))\\n                    {\\n                        q.Enqueue(r * n + c + 1);\\n                        pos.Enqueue(true);\\n                        h.Add(r * n + c + 1);\\n                    }\\n                    \\n                    if (r < n - 1 && grid[r + 1][c] == 0 && grid[r + 1][c - 1] == 0 && !h.Contains((r + 1) * n + c))\\n                    {\\n                        q.Enqueue((r + 1) * n + c);\\n                        pos.Enqueue(true);\\n                        h.Add((r + 1) * n + c);\\n                    }\\n                    \\n                    if (r < n - 1 && grid[r + 1][c] == 0 && grid[r + 1][c - 1] == 0 && !v.Contains((r + 1) * n + c - 1))\\n                    {\\n                        q.Enqueue((r + 1) * n + c - 1);\\n                        pos.Enqueue(false);\\n                        v.Add((r + 1) * n + c - 1);\\n                    }\\n                }\\n                else\\n                {\\n                    if (c < n - 1 && grid[r - 1][c + 1] == 0 && grid[r][c + 1] == 0 && !v.Contains(r * n + c + 1))\\n                    {\\n                        q.Enqueue(r * n + c + 1);\\n                        pos.Enqueue(false);\\n                        v.Add(r * n + c + 1);\\n                    }\\n                    \\n                    if (r < n - 1 && grid[r + 1][c] == 0 && !v.Contains((r + 1) * n + c))\\n                    {\\n                        q.Enqueue((r + 1) * n + c);\\n                        pos.Enqueue(false);\\n                        v.Add((r + 1) * n + c);\\n                    }\\n                    \\n                    if (c < n - 1 && grid[r - 1][c + 1] == 0 && grid[r][c + 1] == 0 && !h.Contains((r - 1) * n + c + 1))\\n                    {\\n                        q.Enqueue((r - 1) * n + c + 1);\\n                        pos.Enqueue(true);\\n                        h.Add((r - 1) * n + c + 1);\\n                    }\\n                }\\n            }\\n            \\n            move++;\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 449888,
                "title": "c-solution",
                "content": "```\\npublic class Solution \\n{\\n    public int MinimumMoves(int[][] grid) \\n    {\\n        int r = grid.Length, c = grid[0].Length;\\n        var queue = new Queue<int[]>();\\n        queue.Enqueue(new int[] {0, 0, 0});\\n        var visited = new bool[r,c,2];\\n        visited[0, 0, 0] = true;\\n        int depth = 0;\\n        while(queue.Count != 0)\\n        {\\n            var count = queue.Count();\\n            while(count-- != 0)\\n            {\\n                var curr = queue.Dequeue();\\n                int x = curr[0], y = curr[1], dir = curr[2];\\n                if((x == r - 1 && y == c - 2 && dir == 0))\\n                    return depth;\\n                List<int[]> next = new List<int[]>();\\n                if(dir == 0)\\n                {\\n                    if(y + 2 < c && grid[x][y + 2] == 0)\\n                        next.Add(new[] {x, y + 1, 0});\\n                    if(x + 1 < r && grid[x + 1][y] == 0 && grid[x + 1][y + 1] == 0)\\n                    {\\n                        next.Add(new[] {x, y, 1});\\n                        next.Add(new[] {x + 1, y, 0});\\n                    }\\n                }\\n                else\\n                {\\n                    if(x + 2 < r && grid[x + 2][y] == 0)\\n                        next.Add(new[] {x + 1, y, 1});\\n                    if(y + 1 < c && grid[x][y + 1] == 0 && grid[x + 1][y + 1] == 0)\\n                    {\\n                        next.Add(new[] {x, y, 0});\\n                        next.Add(new[] {x, y + 1, 1});\\n                    }\\n                }\\n                    \\n                foreach(var n in next)\\n                {\\n                    if(!visited[n[0], n[1], n[2]])\\n                    {\\n                        visited[n[0], n[1], n[2]] = true;\\n                        queue.Enqueue(n);\\n                    }\\n                }\\n            }\\n            \\n            depth++;\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution \\n{\\n    public int MinimumMoves(int[][] grid) \\n    {\\n        int r = grid.Length, c = grid[0].Length;\\n        var queue = new Queue<int[]>();\\n        queue.Enqueue(new int[] {0, 0, 0});\\n        var visited = new bool[r,c,2];\\n        visited[0, 0, 0] = true;\\n        int depth = 0;\\n        while(queue.Count != 0)\\n        {\\n            var count = queue.Count();\\n            while(count-- != 0)\\n            {\\n                var curr = queue.Dequeue();\\n                int x = curr[0], y = curr[1], dir = curr[2];\\n                if((x == r - 1 && y == c - 2 && dir == 0))\\n                    return depth;\\n                List<int[]> next = new List<int[]>();\\n                if(dir == 0)\\n                {\\n                    if(y + 2 < c && grid[x][y + 2] == 0)\\n                        next.Add(new[] {x, y + 1, 0});\\n                    if(x + 1 < r && grid[x + 1][y] == 0 && grid[x + 1][y + 1] == 0)\\n                    {\\n                        next.Add(new[] {x, y, 1});\\n                        next.Add(new[] {x + 1, y, 0});\\n                    }\\n                }\\n                else\\n                {\\n                    if(x + 2 < r && grid[x + 2][y] == 0)\\n                        next.Add(new[] {x + 1, y, 1});\\n                    if(y + 1 < c && grid[x][y + 1] == 0 && grid[x + 1][y + 1] == 0)\\n                    {\\n                        next.Add(new[] {x, y, 0});\\n                        next.Add(new[] {x, y + 1, 1});\\n                    }\\n                }\\n                    \\n                foreach(var n in next)\\n                {\\n                    if(!visited[n[0], n[1], n[2]])\\n                    {\\n                        visited[n[0], n[1], n[2]] = true;\\n                        queue.Enqueue(n);\\n                    }\\n                }\\n            }\\n            \\n            depth++;\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 410716,
                "title": "python-bfs-solution",
                "content": "\\n```\\nfrom collections import deque\\n\\nclass Snake(object):\\n    def __init__(self, x = 0, y = 0 , orientation=0):\\n        self.x = x\\n        self.y = y\\n        self.orientation = orientation\\n        self.num_moves = 0\\n        self.prev_move = \\'\\'\\n        self.visited = {(0,0,0)}\\n        \\n    def move(self, move):\\n        if move == \\'r\\':\\n            self.y += 1\\n        elif move == \\'d\\':\\n            self.x += 1\\n        elif move == \\'cw\\':\\n            self.orientation = 1\\n        elif move == \\'ccw\\':\\n            self.orientation = 0\\n        else:\\n            assert 0, \"Undefined move\"\\n        \\n        if (self.x, self.y, self.orientation) in self.visited:\\n            return 1\\n        \\n        self.visited.add((self.x, self.y, self.orientation))\\n        \\n        self.num_moves += 1\\n            \\n    def is_target(self, n):\\n        if self.x == n-1 and self.y == n - 2 and self.orientation == 0:\\n            return True\\n        return False\\n    \\n    def get_info(self):\\n        return (self.x, self.y, self.orientation, self.num_moves, self.visited)\\n\\n    def set_info(self, info):\\n        self.x, self.y, self.orientation, self.num_moves, self.visited = info\\n        \\n    \\n\\nclass Solution(object):\\n    def minimumMoves(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        self.grid = grid\\n        self.n = len(grid)\\n        \\n        # moves = [\\'r\\', \\'d\\', \\'cw\\', \\'ccw\\']   \\n        snake = Snake()\\n        \\n        m = self._get_allowed_moves(snake)\\n        q = deque(m)\\n        qinf = deque([snake.get_info()]*len(m))\\n\\n        while q:\\n            m = q.popleft()\\n            info = qinf.popleft()\\n            snake.set_info(info)\\n            visited = snake.move(m)\\n            if visited: continue\\n\\n            m = self._get_allowed_moves(snake)\\n            q.extend(m)\\n            qinf.extend([snake.get_info()]*len(m))\\n            \\n            if snake.is_target(self.n):\\n                return snake.num_moves\\n\\n        return -1\\n            \\n        \\n    def _get_allowed_moves(self, snake):\\n        allowed_move = []\\n        \\n        if snake.orientation==0:\\n            if snake.y+2<self.n and self.grid[snake.x][snake.y+2]==0:\\n                allowed_move.append(\\'r\\')\\n            if snake.x+1<self.n and self.grid[snake.x+1][snake.y]==0 and self.grid[snake.x+1][snake.y+1]==0:\\n                allowed_move.append(\\'d\\')\\n                allowed_move.append(\\'cw\\')\\n                \\n        if snake.orientation==1:\\n            if snake.y+1<self.n and self.grid[snake.x][snake.y+1]==0 and self.grid[snake.x+1][snake.y+1]==0:\\n                allowed_move.append(\\'r\\')\\n                allowed_move.append(\\'ccw\\')\\n            if snake.x+2<self.n and self.grid[snake.x+2][snake.y]==0:\\n                allowed_move.append(\\'d\\')\\n                \\n        return allowed_move\\n\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import deque\\n\\nclass Snake(object):\\n    def __init__(self, x = 0, y = 0 , orientation=0):\\n        self.x = x\\n        self.y = y\\n        self.orientation = orientation\\n        self.num_moves = 0\\n        self.prev_move = \\'\\'\\n        self.visited = {(0,0,0)}\\n        \\n    def move(self, move):\\n        if move == \\'r\\':\\n            self.y += 1\\n        elif move == \\'d\\':\\n            self.x += 1\\n        elif move == \\'cw\\':\\n            self.orientation = 1\\n        elif move == \\'ccw\\':\\n            self.orientation = 0\\n        else:\\n            assert 0, \"Undefined move\"\\n        \\n        if (self.x, self.y, self.orientation) in self.visited:\\n            return 1\\n        \\n        self.visited.add((self.x, self.y, self.orientation))\\n        \\n        self.num_moves += 1\\n            \\n    def is_target(self, n):\\n        if self.x == n-1 and self.y == n - 2 and self.orientation == 0:\\n            return True\\n        return False\\n    \\n    def get_info(self):\\n        return (self.x, self.y, self.orientation, self.num_moves, self.visited)\\n\\n    def set_info(self, info):\\n        self.x, self.y, self.orientation, self.num_moves, self.visited = info\\n        \\n    \\n\\nclass Solution(object):\\n    def minimumMoves(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        self.grid = grid\\n        self.n = len(grid)\\n        \\n        # moves = [\\'r\\', \\'d\\', \\'cw\\', \\'ccw\\']   \\n        snake = Snake()\\n        \\n        m = self._get_allowed_moves(snake)\\n        q = deque(m)\\n        qinf = deque([snake.get_info()]*len(m))\\n\\n        while q:\\n            m = q.popleft()\\n            info = qinf.popleft()\\n            snake.set_info(info)\\n            visited = snake.move(m)\\n            if visited: continue\\n\\n            m = self._get_allowed_moves(snake)\\n            q.extend(m)\\n            qinf.extend([snake.get_info()]*len(m))\\n            \\n            if snake.is_target(self.n):\\n                return snake.num_moves\\n\\n        return -1\\n            \\n        \\n    def _get_allowed_moves(self, snake):\\n        allowed_move = []\\n        \\n        if snake.orientation==0:\\n            if snake.y+2<self.n and self.grid[snake.x][snake.y+2]==0:\\n                allowed_move.append(\\'r\\')\\n            if snake.x+1<self.n and self.grid[snake.x+1][snake.y]==0 and self.grid[snake.x+1][snake.y+1]==0:\\n                allowed_move.append(\\'d\\')\\n                allowed_move.append(\\'cw\\')\\n                \\n        if snake.orientation==1:\\n            if snake.y+1<self.n and self.grid[snake.x][snake.y+1]==0 and self.grid[snake.x+1][snake.y+1]==0:\\n                allowed_move.append(\\'r\\')\\n                allowed_move.append(\\'ccw\\')\\n            if snake.x+2<self.n and self.grid[snake.x+2][snake.y]==0:\\n                allowed_move.append(\\'d\\')\\n                \\n        return allowed_move\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 394602,
                "title": "java-concise-dfs-with-explanation-8-ms-beats-99-runtime-and-100-memory",
                "content": "The idea is to use two memoization and visited tables - one each for horizontal and vertical position of the snake.\\n\\n```\\n\\tpublic int minimumMoves(int[][] grid) {\\n        if(grid == null) return -1;\\n        int n = grid.length;\\n        int result = minimumMoves(0, 0, 0, 1, grid, new int[n][n][2], new boolean[n][n][2]);\\n        return (result == Integer.MAX_VALUE) ? -1 : result;\\n    }\\n    \\n    private int minimumMoves(int x1, int y1, int x2, int y2, int[][] grid, int[][][] memo, boolean[][][] visited){\\n        int n = grid.length;\\n\\t\\t/*return error if this position is invalid*/\\n        if(x1 >= n || x2 >= n || y1 >= n || y2 >= n || grid[x1][y1] == 1 || grid[x2][y2] == 1) return Integer.MAX_VALUE;\\n        if(x1 == n-1 && y1 == n-2 && x2 == n-1 && y2 == n-1) return 0; //return 0 if we reached target\\n        \\n        int index = (x1 == x2) ? 0 : 1; //determine the index of memo or visited table to look into\\n        if(memo[x1][y1][index] != 0) return memo[x1][y1][index]; //if memo already contains valid value, return it\\n        if(visited[x1][y1][index]) return Integer.MAX_VALUE; //else it is already visited, we did not find any valid path from this position\\n        \\n        visited[x1][y1][index] = true;        \\n        int result = Integer.MAX_VALUE;\\n        \\n\\t\\t/*Determine the number of minimum moves from this position depending on whether it is vertical or horizontal*/\\n\\t\\t//horizontal\\n        if(x1 == x2){\\n            result = Math.min(result, minimumMoves(x2, y2, x2, y2+1, grid, memo, visited)); //right\\n            result = Math.min(result, minimumMoves(x1+1, y1, x2+1, y2, grid, memo, visited)); //down\\n            if(x1+1 < n && y1+1 < n && grid[x1+1][y1+1] == 0){\\n                result = Math.min(result, minimumMoves(x1, y1, x1+1, y1, grid, memo, visited)); //rotation\\n            }\\n        }\\n\\t\\t//vertical\\n        else{\\n            result = Math.min(result, minimumMoves(x2, y2, x2+1, y2, grid, memo, visited)); //down\\n            result = Math.min(result, minimumMoves(x1, y1+1, x2, y2+1, grid, memo, visited)); //right\\n            if(x1+1 < n && y1+1 < n && grid[x1+1][y1+1] == 0){\\n                result = Math.min(result, minimumMoves(x1, y1, x1, y1+1, grid, memo, visited)); //rotation\\n            }\\n        }\\n        \\n        if(result < Integer.MAX_VALUE) result++; //increment the result as we need to consider a move from current position\\n        memo[x1][y1][index] = result; //store the result in the appropriate memo table\\n        return result;\\n    }",
                "solutionTags": [],
                "code": "The idea is to use two memoization and visited tables - one each for horizontal and vertical position of the snake.\\n\\n```\\n\\tpublic int minimumMoves(int[][] grid) {\\n        if(grid == null) return -1;\\n        int n = grid.length;\\n        int result = minimumMoves(0, 0, 0, 1, grid, new int[n][n][2], new boolean[n][n][2]);\\n        return (result == Integer.MAX_VALUE) ? -1 : result;\\n    }\\n    \\n    private int minimumMoves(int x1, int y1, int x2, int y2, int[][] grid, int[][][] memo, boolean[][][] visited){\\n        int n = grid.length;\\n\\t\\t/*return error if this position is invalid*/\\n        if(x1 >= n || x2 >= n || y1 >= n || y2 >= n || grid[x1][y1] == 1 || grid[x2][y2] == 1) return Integer.MAX_VALUE;\\n        if(x1 == n-1 && y1 == n-2 && x2 == n-1 && y2 == n-1) return 0; //return 0 if we reached target\\n        \\n        int index = (x1 == x2) ? 0 : 1; //determine the index of memo or visited table to look into\\n        if(memo[x1][y1][index] != 0) return memo[x1][y1][index]; //if memo already contains valid value, return it\\n        if(visited[x1][y1][index]) return Integer.MAX_VALUE; //else it is already visited, we did not find any valid path from this position\\n        \\n        visited[x1][y1][index] = true;        \\n        int result = Integer.MAX_VALUE;\\n        \\n\\t\\t/*Determine the number of minimum moves from this position depending on whether it is vertical or horizontal*/\\n\\t\\t//horizontal\\n        if(x1 == x2){\\n            result = Math.min(result, minimumMoves(x2, y2, x2, y2+1, grid, memo, visited)); //right\\n            result = Math.min(result, minimumMoves(x1+1, y1, x2+1, y2, grid, memo, visited)); //down\\n            if(x1+1 < n && y1+1 < n && grid[x1+1][y1+1] == 0){\\n                result = Math.min(result, minimumMoves(x1, y1, x1+1, y1, grid, memo, visited)); //rotation\\n            }\\n        }\\n\\t\\t//vertical\\n        else{\\n            result = Math.min(result, minimumMoves(x2, y2, x2+1, y2, grid, memo, visited)); //down\\n            result = Math.min(result, minimumMoves(x1, y1+1, x2, y2+1, grid, memo, visited)); //right\\n            if(x1+1 < n && y1+1 < n && grid[x1+1][y1+1] == 0){\\n                result = Math.min(result, minimumMoves(x1, y1, x1, y1+1, grid, memo, visited)); //rotation\\n            }\\n        }\\n        \\n        if(result < Integer.MAX_VALUE) result++; //increment the result as we need to consider a move from current position\\n        memo[x1][y1][index] = result; //store the result in the appropriate memo table\\n        return result;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 394159,
                "title": "java-bfs-brute-force-solution",
                "content": "```\\nclass Solution {\\n    public int minimumMoves(int[][] grid) {\\n        int n = grid.length;\\n        if(n == 0) return -1;\\n        Queue<int[]> q = new LinkedList<>();\\n        q.add(new int[]{0, 0, 0, 1});\\n        Set<String> visited = new HashSet<>();\\n        visited.add(\"0,0,0,1\");\\n        int count = 0;\\n        while(!q.isEmpty()) {\\n            int size = q.size();\\n            for(int i = 0; i < size; i++) {\\n\\t\\t\\t\\t//curr[0] is the row of first cell, curr[1] is the col of the first cell;\\n\\t\\t\\t\\t//curr[2] is the row of the second cell, curr[3] is the col of the second cell.\\n                int[] curr = q.poll();\\n                if(curr[0] == n - 1 && curr[1] == n - 2 && curr[2] == n - 1 && curr[3] == n - 1) {\\n                    return count;\\n                }\\n                //be horizontal and move right.\\n                if(isHorizontal(curr) && curr[3] < n - 1 && grid[curr[0]][curr[3] + 1] == 0) {\\n                    int r1 = curr[2], c1 = curr[3], r2 = r1, c2 = c1 + 1;\\n                    String key = r1 + \",\" + c1 + \",\" + r2 + \",\" + c2;\\n                    if(!visited.contains(key)) {\\n                        visited.add(key);\\n                        q.add(new int[]{r1, c1, r2, c2});\\n                    }\\n                }\\n                //be vertical and move down.\\n                if(isVertical(curr) && curr[2] < n - 1 && grid[curr[2] + 1][curr[3]] == 0) {\\n                    int r1 = curr[2], c1 = curr[3], r2 = r1 + 1, c2 = c1;\\n                    String key = r1 + \",\" + c1 + \",\" + r2 + \",\" + c2;\\n                    if(!visited.contains(key)) {\\n                        visited.add(key);\\n                        q.add(new int[]{r1, c1, r2, c2});\\n                    }\\n                }\\n                //be horizontal and rotate clockwise.\\n                if(isHorizontal(curr) && curr[0] < n - 1 && grid[curr[0] + 1][curr[1]] == 0 && grid[curr[0] + 1][curr[3]] == 0) {\\n                    int r1 = curr[0], c1 = curr[1], r2 = curr[2] + 1, c2 = c1;\\n                    String key = r1 + \",\" + c1 + \",\" + r2 + \",\" + c2;\\n                    if(!visited.contains(key)) {\\n                        visited.add(key);\\n                        q.add(new int[]{r1, c1, r2, c2});\\n                    }\\n                }\\n                //be vertical and rotate counterclockwise.\\n                if(isVertical(curr) && curr[1] < n - 1 && grid[curr[0]][curr[1] + 1] == 0 && grid[curr[2]][curr[1] + 1] == 0) {\\n                    int r1 = curr[0], c1 = curr[1], r2 = r1, c2 = curr[3] + 1;\\n                    String key = r1 + \",\" + c1 + \",\" + r2 + \",\" + c2;\\n                    if(!visited.contains(key)) {\\n                        visited.add(key);\\n                        q.add(new int[]{r1, c1, r2, c2});\\n                    }\\n                }\\n                //be horizontal and move down.\\n                if(isHorizontal(curr) && curr[0] < n - 1 && grid[curr[0] + 1][curr[1]] == 0 && grid[curr[0] + 1][curr[3]] == 0) {\\n                    int r1 = curr[0] + 1, c1 = curr[1], r2 = curr[2] + 1, c2 = curr[3];\\n                    String key = r1 + \",\" + c1 + \",\" + r2 + \",\" + c2;\\n                    if(!visited.contains(key)) {\\n                        visited.add(key);\\n                        q.add(new int[]{r1, c1, r2, c2});\\n                    }\\n                }\\n                //be vertical and move right.\\n                if(isVertical(curr) && curr[1] < n - 1 && grid[curr[0]][curr[1] + 1] == 0 && grid[curr[2]][curr[1] + 1] == 0) {\\n                    int r1 = curr[0], c1 = curr[1] + 1, r2 = curr[2], c2 = curr[3] + 1;\\n                    String key = r1 + \",\" + c1 + \",\" + r2 + \",\" + c2;\\n                    if(!visited.contains(key)) {\\n                        visited.add(key);\\n                        q.add(new int[]{r1, c1, r2, c2});\\n                    }\\n                }\\n            }\\n            count++;\\n        }\\n        return -1;\\n    }\\n    \\n    public boolean isHorizontal(int[] loc) {\\n        return loc[0] == loc[2];\\n    }\\n    public boolean isVertical(int[] loc) {\\n        return loc[1] == loc[3];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minimumMoves(int[][] grid) {\\n        int n = grid.length;\\n        if(n == 0) return -1;\\n        Queue<int[]> q = new LinkedList<>();\\n        q.add(new int[]{0, 0, 0, 1});\\n        Set<String> visited = new HashSet<>();\\n        visited.add(\"0,0,0,1\");\\n        int count = 0;\\n        while(!q.isEmpty()) {\\n            int size = q.size();\\n            for(int i = 0; i < size; i++) {\\n\\t\\t\\t\\t//curr[0] is the row of first cell, curr[1] is the col of the first cell;\\n\\t\\t\\t\\t//curr[2] is the row of the second cell, curr[3] is the col of the second cell.\\n                int[] curr = q.poll();\\n                if(curr[0] == n - 1 && curr[1] == n - 2 && curr[2] == n - 1 && curr[3] == n - 1) {\\n                    return count;\\n                }\\n                //be horizontal and move right.\\n                if(isHorizontal(curr) && curr[3] < n - 1 && grid[curr[0]][curr[3] + 1] == 0) {\\n                    int r1 = curr[2], c1 = curr[3], r2 = r1, c2 = c1 + 1;\\n                    String key = r1 + \",\" + c1 + \",\" + r2 + \",\" + c2;\\n                    if(!visited.contains(key)) {\\n                        visited.add(key);\\n                        q.add(new int[]{r1, c1, r2, c2});\\n                    }\\n                }\\n                //be vertical and move down.\\n                if(isVertical(curr) && curr[2] < n - 1 && grid[curr[2] + 1][curr[3]] == 0) {\\n                    int r1 = curr[2], c1 = curr[3], r2 = r1 + 1, c2 = c1;\\n                    String key = r1 + \",\" + c1 + \",\" + r2 + \",\" + c2;\\n                    if(!visited.contains(key)) {\\n                        visited.add(key);\\n                        q.add(new int[]{r1, c1, r2, c2});\\n                    }\\n                }\\n                //be horizontal and rotate clockwise.\\n                if(isHorizontal(curr) && curr[0] < n - 1 && grid[curr[0] + 1][curr[1]] == 0 && grid[curr[0] + 1][curr[3]] == 0) {\\n                    int r1 = curr[0], c1 = curr[1], r2 = curr[2] + 1, c2 = c1;\\n                    String key = r1 + \",\" + c1 + \",\" + r2 + \",\" + c2;\\n                    if(!visited.contains(key)) {\\n                        visited.add(key);\\n                        q.add(new int[]{r1, c1, r2, c2});\\n                    }\\n                }\\n                //be vertical and rotate counterclockwise.\\n                if(isVertical(curr) && curr[1] < n - 1 && grid[curr[0]][curr[1] + 1] == 0 && grid[curr[2]][curr[1] + 1] == 0) {\\n                    int r1 = curr[0], c1 = curr[1], r2 = r1, c2 = curr[3] + 1;\\n                    String key = r1 + \",\" + c1 + \",\" + r2 + \",\" + c2;\\n                    if(!visited.contains(key)) {\\n                        visited.add(key);\\n                        q.add(new int[]{r1, c1, r2, c2});\\n                    }\\n                }\\n                //be horizontal and move down.\\n                if(isHorizontal(curr) && curr[0] < n - 1 && grid[curr[0] + 1][curr[1]] == 0 && grid[curr[0] + 1][curr[3]] == 0) {\\n                    int r1 = curr[0] + 1, c1 = curr[1], r2 = curr[2] + 1, c2 = curr[3];\\n                    String key = r1 + \",\" + c1 + \",\" + r2 + \",\" + c2;\\n                    if(!visited.contains(key)) {\\n                        visited.add(key);\\n                        q.add(new int[]{r1, c1, r2, c2});\\n                    }\\n                }\\n                //be vertical and move right.\\n                if(isVertical(curr) && curr[1] < n - 1 && grid[curr[0]][curr[1] + 1] == 0 && grid[curr[2]][curr[1] + 1] == 0) {\\n                    int r1 = curr[0], c1 = curr[1] + 1, r2 = curr[2], c2 = curr[3] + 1;\\n                    String key = r1 + \",\" + c1 + \",\" + r2 + \",\" + c2;\\n                    if(!visited.contains(key)) {\\n                        visited.add(key);\\n                        q.add(new int[]{r1, c1, r2, c2});\\n                    }\\n                }\\n            }\\n            count++;\\n        }\\n        return -1;\\n    }\\n    \\n    public boolean isHorizontal(int[] loc) {\\n        return loc[0] == loc[2];\\n    }\\n    public boolean isVertical(int[] loc) {\\n        return loc[1] == loc[3];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 394020,
                "title": "java-easy-readable-bfs-solution",
                "content": "It\\'s common to use BFS to find a shortest path, the difference is the rule of how to expand each step to a new one.\\n```\\npublic int minimumMoves(int[][] grid) {\\n        int n = grid.length;\\n        if (grid[n - 1][n - 2] != 0 || grid[n - 1][n - 1] != 0) {\\n            return -1;\\n        }\\n        int step = 0;\\n        int[] start = new int[]{0, 0, 0, 1};\\n        Queue<int[]> q = new LinkedList<>();\\n        q.offer(start);\\n        Set<String> visited = new HashSet<>();\\n        visited.add(pos2Str(start));\\n\\n        while (!q.isEmpty()) {\\n            for (int cnt = q.size(); cnt > 0; cnt--) {\\n                int[] cur = q.poll();\\n                if (cur[0] == n - 1 && cur[1] == n - 2 && cur[2] == n - 1 && cur[3] == n - 1) {\\n                    return step;\\n                }\\n                // expand\\n                List<int[]> nextList = expand(grid, cur);\\n                for (int[] next : nextList) {\\n                    String posStr = pos2Str(next);\\n                    if (!visited.contains(posStr)) {\\n                        visited.add(posStr);\\n                        q.offer(next);\\n                    }\\n                }\\n            }\\n            step++;\\n        }\\n        return -1;\\n    }\\n\\n    private List<int[]> expand(int[][] grid, int[] cur) {\\n        List<int[]> result = new ArrayList<>();\\n        int n = grid.length;\\n\\n        int[] next;\\n        if (cur[0] == cur[2]) {  // cur horizon\\n            // right\\n            if (cur[3] + 1 < n && grid[cur[0]][cur[3] + 1] == 0) {\\n                next = new int[]{cur[0], cur[1] + 1, cur[0], cur[3] + 1};\\n                result.add(next);\\n            }\\n\\n            if (cur[0] + 1 < n && grid[cur[0] + 1][cur[1]] == 0 && grid[cur[0] + 1][cur[3]] == 0) {\\n                // down\\n                next = new int[]{cur[0] + 1, cur[1], cur[0] + 1, cur[3]};\\n                result.add(next);\\n                // clock wise\\n                next = new int[]{cur[0], cur[1], cur[0] + 1, cur[1]};\\n                result.add(next);\\n            }\\n        } else { // vertical\\n            if (cur[1] + 1 < n && grid[cur[0]][cur[1] + 1] == 0 && grid[cur[2]][cur[1] + 1] == 0) {\\n                // right\\n                next = new int[]{cur[0], cur[1] + 1, cur[2], cur[1] + 1};\\n                result.add(next);\\n                //counterclockwise\\n                next = new int[]{cur[0], cur[1], cur[0], cur[1] + 1};\\n                result.add(next);\\n            }\\n            // down\\n            if (cur[2] + 1 < n && grid[cur[2] + 1][cur[1]] == 0) {\\n                next = new int[]{cur[0] + 1, cur[1], cur[2] + 1, cur[1]};\\n                result.add(next);\\n            }\\n        }\\n        return result;\\n    }\\n\\n    private String pos2Str(int[] pos) {\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i < pos.length; i++) {\\n            sb.append(pos[i]);\\n            sb.append(\\'@\\');\\n        }\\n        return sb.toString();\\n    }",
                "solutionTags": [],
                "code": "It\\'s common to use BFS to find a shortest path, the difference is the rule of how to expand each step to a new one.\\n```\\npublic int minimumMoves(int[][] grid) {\\n        int n = grid.length;\\n        if (grid[n - 1][n - 2] != 0 || grid[n - 1][n - 1] != 0) {\\n            return -1;\\n        }\\n        int step = 0;\\n        int[] start = new int[]{0, 0, 0, 1};\\n        Queue<int[]> q = new LinkedList<>();\\n        q.offer(start);\\n        Set<String> visited = new HashSet<>();\\n        visited.add(pos2Str(start));\\n\\n        while (!q.isEmpty()) {\\n            for (int cnt = q.size(); cnt > 0; cnt--) {\\n                int[] cur = q.poll();\\n                if (cur[0] == n - 1 && cur[1] == n - 2 && cur[2] == n - 1 && cur[3] == n - 1) {\\n                    return step;\\n                }\\n                // expand\\n                List<int[]> nextList = expand(grid, cur);\\n                for (int[] next : nextList) {\\n                    String posStr = pos2Str(next);\\n                    if (!visited.contains(posStr)) {\\n                        visited.add(posStr);\\n                        q.offer(next);\\n                    }\\n                }\\n            }\\n            step++;\\n        }\\n        return -1;\\n    }\\n\\n    private List<int[]> expand(int[][] grid, int[] cur) {\\n        List<int[]> result = new ArrayList<>();\\n        int n = grid.length;\\n\\n        int[] next;\\n        if (cur[0] == cur[2]) {  // cur horizon\\n            // right\\n            if (cur[3] + 1 < n && grid[cur[0]][cur[3] + 1] == 0) {\\n                next = new int[]{cur[0], cur[1] + 1, cur[0], cur[3] + 1};\\n                result.add(next);\\n            }\\n\\n            if (cur[0] + 1 < n && grid[cur[0] + 1][cur[1]] == 0 && grid[cur[0] + 1][cur[3]] == 0) {\\n                // down\\n                next = new int[]{cur[0] + 1, cur[1], cur[0] + 1, cur[3]};\\n                result.add(next);\\n                // clock wise\\n                next = new int[]{cur[0], cur[1], cur[0] + 1, cur[1]};\\n                result.add(next);\\n            }\\n        } else { // vertical\\n            if (cur[1] + 1 < n && grid[cur[0]][cur[1] + 1] == 0 && grid[cur[2]][cur[1] + 1] == 0) {\\n                // right\\n                next = new int[]{cur[0], cur[1] + 1, cur[2], cur[1] + 1};\\n                result.add(next);\\n                //counterclockwise\\n                next = new int[]{cur[0], cur[1], cur[0], cur[1] + 1};\\n                result.add(next);\\n            }\\n            // down\\n            if (cur[2] + 1 < n && grid[cur[2] + 1][cur[1]] == 0) {\\n                next = new int[]{cur[0] + 1, cur[1], cur[2] + 1, cur[1]};\\n                result.add(next);\\n            }\\n        }\\n        return result;\\n    }\\n\\n    private String pos2Str(int[] pos) {\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i < pos.length; i++) {\\n            sb.append(pos[i]);\\n            sb.append(\\'@\\');\\n        }\\n        return sb.toString();\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 393743,
                "title": "java-bfs-beats-100-and-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int minimumMoves(int[][] grid) {\\n        int n = grid[0].length;\\n        Queue<head> q = new LinkedList<>();\\n        Set<String> visited = new HashSet<>();\\n        head start = new head(0,1,0);\\n        q.add(start);\\n        q.add(null);\\n        int moves = 0;\\n        \\n        while(!q.isEmpty()){\\n          head temp = q.poll();\\n            if(temp == null){\\n              if(!q.isEmpty()){\\n                  q.add(null);\\n              }\\n              moves++;\\n            } else {\\n            \\n            int x = temp.headx;\\n            int y = temp.heady;\\n            int status = temp.status;\\n            String currKey = x + \":\"+y+\":\"+status;\\n            if(visited.contains(currKey)){\\n                continue;\\n            }\\n            visited.add(currKey);\\n            if(x == n-1 && y == n-1 && status == 0){\\n                return moves;\\n            }\\n            //r\\n            if(y+1 < n  && grid[x][y+1] == 0 && grid[x-status][y+1] == 0){\\n                q.add(new head(x,y+1,status));\\n            }\\n            //d\\n            if(isDownPossible(x,y,status,grid)){\\n                q.add(new head(x+1,y,status));\\n            }\\n            // rotate\\n            if(status == 0 && x+1 < n && grid[x+1][y-1] == 0 && grid[x+1][y] == 0 ){\\n                  q.add(new head(x+1,y-1,1));\\n            }\\n            // counter \\n            if(status == 1 && y+1 < n && grid[x][y+1] == 0 && grid[x-1][y+1] == 0){\\n                  q.add(new head(x-1,y+1,0));\\n            }\\n        }\\n            \\n        }\\n        \\n        return -1;\\n        \\n    }\\n    \\n    private boolean isDownPossible(int x , int y, int status, int[][] grid){\\n       \\n        int n = grid[0].length;\\n        if(x + 1 < n){\\n            if(status ==0){\\n                if(grid[x+1][y-1] == 0 && grid[x+1][y] == 0){\\n                    return true;\\n                }\\n            }else{\\n                if(grid[x+1][y] == 0 ) {\\n                    return true;\\n                }\\n            }\\n         }\\n        return false;\\n    }\\n    \\n    class head {\\n        int headx ;\\n        int heady;\\n        int status;\\n        public head(int x, int y, int status){\\n            this.headx =x;\\n            this.heady = y;\\n            this.status = status;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minimumMoves(int[][] grid) {\\n        int n = grid[0].length;\\n        Queue<head> q = new LinkedList<>();\\n        Set<String> visited = new HashSet<>();\\n        head start = new head(0,1,0);\\n        q.add(start);\\n        q.add(null);\\n        int moves = 0;\\n        \\n        while(!q.isEmpty()){\\n          head temp = q.poll();\\n            if(temp == null){\\n              if(!q.isEmpty()){\\n                  q.add(null);\\n              }\\n              moves++;\\n            } else {\\n            \\n            int x = temp.headx;\\n            int y = temp.heady;\\n            int status = temp.status;\\n            String currKey = x + \":\"+y+\":\"+status;\\n            if(visited.contains(currKey)){\\n                continue;\\n            }\\n            visited.add(currKey);\\n            if(x == n-1 && y == n-1 && status == 0){\\n                return moves;\\n            }\\n            //r\\n            if(y+1 < n  && grid[x][y+1] == 0 && grid[x-status][y+1] == 0){\\n                q.add(new head(x,y+1,status));\\n            }\\n            //d\\n            if(isDownPossible(x,y,status,grid)){\\n                q.add(new head(x+1,y,status));\\n            }\\n            // rotate\\n            if(status == 0 && x+1 < n && grid[x+1][y-1] == 0 && grid[x+1][y] == 0 ){\\n                  q.add(new head(x+1,y-1,1));\\n            }\\n            // counter \\n            if(status == 1 && y+1 < n && grid[x][y+1] == 0 && grid[x-1][y+1] == 0){\\n                  q.add(new head(x-1,y+1,0));\\n            }\\n        }\\n            \\n        }\\n        \\n        return -1;\\n        \\n    }\\n    \\n    private boolean isDownPossible(int x , int y, int status, int[][] grid){\\n       \\n        int n = grid[0].length;\\n        if(x + 1 < n){\\n            if(status ==0){\\n                if(grid[x+1][y-1] == 0 && grid[x+1][y] == 0){\\n                    return true;\\n                }\\n            }else{\\n                if(grid[x+1][y] == 0 ) {\\n                    return true;\\n                }\\n            }\\n         }\\n        return false;\\n    }\\n    \\n    class head {\\n        int headx ;\\n        int heady;\\n        int status;\\n        public head(int x, int y, int status){\\n            this.headx =x;\\n            this.heady = y;\\n            this.status = status;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 393614,
                "title": "45-lines-java-with-dp-and-explaination-faster-than-100-100",
                "content": "* dp[i][j][0] means the minimum step to move to (i,j) and the snake is horizontal now.\\n* dp[i][j][1] means the minimum step to move to (i,j) and the snake is vertical now.\\n\\nstate transfer function: \\n* dp[i][j][0] = Min(dp[i-1][j][0], dp[i][j-1][0], dp[i+1][j-1][1]) + 1 // down, right, counterclockwise\\n* dp[i][j][1] = Min(dp[i-1][j][1], dp[i][j-1][1], dp[i-1][j+1][0]) + 1 // down, right, clockwise\\n\\nPlease note each operation needs to check some limitations carefully.\\n\\n```\\nclass Solution {\\n    public int minimumMoves(int[][] grid) {\\n        int n = grid.length;\\n        int[][][] dp = new int[n][n][2];\\n        // initial\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<n; j++){\\n                dp[i][j][0] = dp[i][j][1] = Integer.MAX_VALUE;\\n            }\\n        }\\n        // base case\\n        dp[0][1][0] = 0;\\n        if(grid[1][0] == 0 && grid[1][1] == 0) dp[1][0][1] = 1;\\n        for(int i=2; i<n; i++){\\n            if(grid[0][i] == 0 && dp[0][i-1][0] != Integer.MAX_VALUE) dp[0][i][0] = dp[0][i-1][0] + 1;\\n            if(grid[i][0] == 0 && dp[i-1][0][1] != Integer.MAX_VALUE) dp[i][0][1] = dp[i-1][0][1] + 1;\\n        }\\n        \\n        // start dp, k is the length of diagonal line from bottom left to upper right\\n        for(int k=2; k<=2*n-2; k++){\\n            for(int j=k<=n-1? 1: k-n+1; j<n && j<k; j++){\\n                int i = k-j;\\n                // when the snake is horizontal with head at (i,j)\\n                if(grid[i][j] == 0 && grid[i][j-1] == 0){\\n                    dp[i][j][0] = Math.min(dp[i][j-1][0], dp[i-1][j][0]);\\n                    if(i<n-1 && grid[i+1][j] == 0) dp[i][j][0] = Math.min(dp[i][j][0], dp[i+1][j-1][1]);\\n                    // If it\\'s possible to move to (i,j) with horizontal body\\n                    if(dp[i][j][0] != Integer.MAX_VALUE){\\n                        dp[i][j][0] += 1;\\n                        if(i<n-1 && grid[i+1][j] == 0 && grid[i+1][j-1] == 0){\\n                            dp[i+1][j-1][1] = Math.min(dp[i][j][0]+1, dp[i+1][j-1][1]);\\n                        }\\n                    }\\n                }\\n                // when the snake is vertical with head at (i,j)\\n                if(grid[i][j] == 0 && grid[i-1][j] == 0){\\n                    dp[i][j][1] = Math.min(dp[i-1][j][1], dp[i][j-1][1]);\\n                    if(j<n-1 && grid[i][j+1] == 0) dp[i][j][1] = Math.min(dp[i][j][1], dp[i-1][j+1][0]);\\n                    // If it\\'s possible to move to (i,j) with vertical body\\n                    if(dp[i][j][1] != Integer.MAX_VALUE){\\n                        dp[i][j][1] += 1;\\n                        if(j<n-1 && grid[i][j+1] == 0 && grid[i-1][j+1] == 0){\\n                            dp[i-1][j+1][0] = Math.min(dp[i][j][1]+1, dp[i-1][j+1][0]);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\n        return dp[n-1][n-1][0] == Integer.MAX_VALUE? -1: dp[n-1][n-1][0];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minimumMoves(int[][] grid) {\\n        int n = grid.length;\\n        int[][][] dp = new int[n][n][2];\\n        // initial\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<n; j++){\\n                dp[i][j][0] = dp[i][j][1] = Integer.MAX_VALUE;\\n            }\\n        }\\n        // base case\\n        dp[0][1][0] = 0;\\n        if(grid[1][0] == 0 && grid[1][1] == 0) dp[1][0][1] = 1;\\n        for(int i=2; i<n; i++){\\n            if(grid[0][i] == 0 && dp[0][i-1][0] != Integer.MAX_VALUE) dp[0][i][0] = dp[0][i-1][0] + 1;\\n            if(grid[i][0] == 0 && dp[i-1][0][1] != Integer.MAX_VALUE) dp[i][0][1] = dp[i-1][0][1] + 1;\\n        }\\n        \\n        // start dp, k is the length of diagonal line from bottom left to upper right\\n        for(int k=2; k<=2*n-2; k++){\\n            for(int j=k<=n-1? 1: k-n+1; j<n && j<k; j++){\\n                int i = k-j;\\n                // when the snake is horizontal with head at (i,j)\\n                if(grid[i][j] == 0 && grid[i][j-1] == 0){\\n                    dp[i][j][0] = Math.min(dp[i][j-1][0], dp[i-1][j][0]);\\n                    if(i<n-1 && grid[i+1][j] == 0) dp[i][j][0] = Math.min(dp[i][j][0], dp[i+1][j-1][1]);\\n                    // If it\\'s possible to move to (i,j) with horizontal body\\n                    if(dp[i][j][0] != Integer.MAX_VALUE){\\n                        dp[i][j][0] += 1;\\n                        if(i<n-1 && grid[i+1][j] == 0 && grid[i+1][j-1] == 0){\\n                            dp[i+1][j-1][1] = Math.min(dp[i][j][0]+1, dp[i+1][j-1][1]);\\n                        }\\n                    }\\n                }\\n                // when the snake is vertical with head at (i,j)\\n                if(grid[i][j] == 0 && grid[i-1][j] == 0){\\n                    dp[i][j][1] = Math.min(dp[i-1][j][1], dp[i][j-1][1]);\\n                    if(j<n-1 && grid[i][j+1] == 0) dp[i][j][1] = Math.min(dp[i][j][1], dp[i-1][j+1][0]);\\n                    // If it\\'s possible to move to (i,j) with vertical body\\n                    if(dp[i][j][1] != Integer.MAX_VALUE){\\n                        dp[i][j][1] += 1;\\n                        if(j<n-1 && grid[i][j+1] == 0 && grid[i-1][j+1] == 0){\\n                            dp[i-1][j+1][0] = Math.min(dp[i][j][1]+1, dp[i-1][j+1][0]);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\n        return dp[n-1][n-1][0] == Integer.MAX_VALUE? -1: dp[n-1][n-1][0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 393581,
                "title": "c-bfs-hash",
                "content": "```\\npublic class Solution {\\n    \\n    public class Snake\\n    {\\n        const int MAX = 10000;\\n        \\n        public static int n;\\n        \\n        public Pos head;\\n        public Pos tail;\\n        \\n        public Snake()\\n        {\\n            head = new Pos();\\n            tail = new Pos();\\n        }\\n        \\n        public void SetHead(int r, int c)\\n        {\\n            head.row = r;\\n            head.col = c;\\n        }\\n        \\n        public void SetTail(int r, int c)\\n        {\\n            tail.row = r;\\n            tail.col = c;\\n        }\\n        \\n        public int HashValue\\n        {\\n            get\\n            {\\n                return tail.row*n + tail.col + (head.row*n + head.col)*MAX;\\n            }\\n        }\\n        \\n        public bool IsDes()\\n        {\\n            return (head.row == n-1 && head.col == n-1 && tail.row == n-1 && tail.col == n-2)\\n                || (head.row == n-1 && head.col == n-2 && tail.row == n-1 && tail.col == n-1);\\n        }\\n        \\n        public bool IsVertical()\\n        {\\n            return head.col == tail.col;\\n        }\\n    }\\n    \\n    public class Pos\\n    {\\n        public int row;\\n        public int col;\\n    }\\n    \\n    //bfs\\n    public int MinimumMoves(int[][] grid) {\\n        \\n        int n = grid.Length;\\n        Snake.n = grid.Length;\\n        \\n        Queue<Snake> queue = new Queue<Snake>();\\n        HashSet<int> hs = new HashSet<int>();\\n        \\n        Snake snake = new Snake();\\n        snake.SetHead(0, 1);\\n        snake.SetTail(0, 0);\\n        \\n        hs.Add(snake.HashValue);\\n        queue.Enqueue(snake);\\n        \\n        int res = 0;\\n        \\n        while(queue.Count > 0)\\n        {\\n            int cnt = queue.Count;\\n            \\n            for(int i=0; i<cnt; i++)\\n            {\\n                Snake cur = queue.Dequeue();\\n                \\n                if(cur.IsDes())\\n                {\\n                    return res;\\n                }\\n                \\n                //right\\n                if(cur.head.col + 1 < n && cur.tail.col + 1 < n \\n                   && grid[cur.head.row][cur.head.col + 1] == 0 \\n                   && grid[cur.tail.row][cur.tail.col + 1] == 0)\\n                {\\n                    Snake next = new Snake();\\n                    next.SetHead(cur.head.row, cur.head.col + 1);\\n                    next.SetTail(cur.tail.row, cur.tail.col + 1);\\n                    \\n                    if(!hs.Contains(next.HashValue))\\n                    {\\n                        hs.Add(next.HashValue);\\n                        queue.Enqueue(next);\\n                    }\\n                }\\n                \\n                //down\\n                if(cur.head.row + 1 < n && cur.tail.row + 1 < n \\n                   && grid[cur.head.row + 1][cur.head.col] == 0 \\n                   && grid[cur.tail.row + 1][cur.tail.col] == 0)\\n                {\\n                    Snake next = new Snake();\\n                    next.SetHead(cur.head.row + 1, cur.head.col);\\n                    next.SetTail(cur.tail.row + 1, cur.tail.col);\\n                    \\n                    if(!hs.Contains(next.HashValue))\\n                    {\\n                        hs.Add(next.HashValue);\\n                        queue.Enqueue(next);\\n                    }\\n                }\\n                \\n                //clockwise\\n                if(!cur.IsVertical() && cur.head.row + 1 < n\\n                   && grid[cur.head.row + 1][cur.head.col] == 0 \\n                   && grid[cur.tail.row + 1][cur.tail.col] == 0)\\n                {\\n                    Snake next = new Snake();\\n                    next.SetHead(cur.head.row + 1, cur.head.col - 1);\\n                    next.SetTail(cur.tail.row, cur.tail.col);\\n                    \\n                    if(!hs.Contains(next.HashValue))\\n                    {\\n                        hs.Add(next.HashValue);\\n                        queue.Enqueue(next);\\n                    }\\n                }\\n                \\n                //counterclockwise\\n                if(cur.IsVertical() && cur.head.col + 1 < n\\n                   && grid[cur.head.row][cur.head.col + 1] == 0 \\n                   && grid[cur.tail.row][cur.tail.col + 1] == 0)\\n                {\\n                    Snake next = new Snake();\\n                    next.SetHead(cur.head.row - 1, cur.head.col + 1);\\n                    next.SetTail(cur.tail.row, cur.tail.col);\\n                    \\n                    if(!hs.Contains(next.HashValue))\\n                    {\\n                        hs.Add(next.HashValue);\\n                        queue.Enqueue(next);\\n                    }\\n                }\\n            }\\n            \\n            res++;\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    \\n    public class Snake\\n    {\\n        const int MAX = 10000;\\n        \\n        public static int n;\\n        \\n        public Pos head;\\n        public Pos tail;\\n        \\n        public Snake()\\n        {\\n            head = new Pos();\\n            tail = new Pos();\\n        }\\n        \\n        public void SetHead(int r, int c)\\n        {\\n            head.row = r;\\n            head.col = c;\\n        }\\n        \\n        public void SetTail(int r, int c)\\n        {\\n            tail.row = r;\\n            tail.col = c;\\n        }\\n        \\n        public int HashValue\\n        {\\n            get\\n            {\\n                return tail.row*n + tail.col + (head.row*n + head.col)*MAX;\\n            }\\n        }\\n        \\n        public bool IsDes()\\n        {\\n            return (head.row == n-1 && head.col == n-1 && tail.row == n-1 && tail.col == n-2)\\n                || (head.row == n-1 && head.col == n-2 && tail.row == n-1 && tail.col == n-1);\\n        }\\n        \\n        public bool IsVertical()\\n        {\\n            return head.col == tail.col;\\n        }\\n    }\\n    \\n    public class Pos\\n    {\\n        public int row;\\n        public int col;\\n    }\\n    \\n    //bfs\\n    public int MinimumMoves(int[][] grid) {\\n        \\n        int n = grid.Length;\\n        Snake.n = grid.Length;\\n        \\n        Queue<Snake> queue = new Queue<Snake>();\\n        HashSet<int> hs = new HashSet<int>();\\n        \\n        Snake snake = new Snake();\\n        snake.SetHead(0, 1);\\n        snake.SetTail(0, 0);\\n        \\n        hs.Add(snake.HashValue);\\n        queue.Enqueue(snake);\\n        \\n        int res = 0;\\n        \\n        while(queue.Count > 0)\\n        {\\n            int cnt = queue.Count;\\n            \\n            for(int i=0; i<cnt; i++)\\n            {\\n                Snake cur = queue.Dequeue();\\n                \\n                if(cur.IsDes())\\n                {\\n                    return res;\\n                }\\n                \\n                //right\\n                if(cur.head.col + 1 < n && cur.tail.col + 1 < n \\n                   && grid[cur.head.row][cur.head.col + 1] == 0 \\n                   && grid[cur.tail.row][cur.tail.col + 1] == 0)\\n                {\\n                    Snake next = new Snake();\\n                    next.SetHead(cur.head.row, cur.head.col + 1);\\n                    next.SetTail(cur.tail.row, cur.tail.col + 1);\\n                    \\n                    if(!hs.Contains(next.HashValue))\\n                    {\\n                        hs.Add(next.HashValue);\\n                        queue.Enqueue(next);\\n                    }\\n                }\\n                \\n                //down\\n                if(cur.head.row + 1 < n && cur.tail.row + 1 < n \\n                   && grid[cur.head.row + 1][cur.head.col] == 0 \\n                   && grid[cur.tail.row + 1][cur.tail.col] == 0)\\n                {\\n                    Snake next = new Snake();\\n                    next.SetHead(cur.head.row + 1, cur.head.col);\\n                    next.SetTail(cur.tail.row + 1, cur.tail.col);\\n                    \\n                    if(!hs.Contains(next.HashValue))\\n                    {\\n                        hs.Add(next.HashValue);\\n                        queue.Enqueue(next);\\n                    }\\n                }\\n                \\n                //clockwise\\n                if(!cur.IsVertical() && cur.head.row + 1 < n\\n                   && grid[cur.head.row + 1][cur.head.col] == 0 \\n                   && grid[cur.tail.row + 1][cur.tail.col] == 0)\\n                {\\n                    Snake next = new Snake();\\n                    next.SetHead(cur.head.row + 1, cur.head.col - 1);\\n                    next.SetTail(cur.tail.row, cur.tail.col);\\n                    \\n                    if(!hs.Contains(next.HashValue))\\n                    {\\n                        hs.Add(next.HashValue);\\n                        queue.Enqueue(next);\\n                    }\\n                }\\n                \\n                //counterclockwise\\n                if(cur.IsVertical() && cur.head.col + 1 < n\\n                   && grid[cur.head.row][cur.head.col + 1] == 0 \\n                   && grid[cur.tail.row][cur.tail.col + 1] == 0)\\n                {\\n                    Snake next = new Snake();\\n                    next.SetHead(cur.head.row - 1, cur.head.col + 1);\\n                    next.SetTail(cur.tail.row, cur.tail.col);\\n                    \\n                    if(!hs.Contains(next.HashValue))\\n                    {\\n                        hs.Add(next.HashValue);\\n                        queue.Enqueue(next);\\n                    }\\n                }\\n            }\\n            \\n            res++;\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 393453,
                "title": "java-concise-bfs-solution-take-snake-positions-as-a-node",
                "content": "When it comes to minimum moves, it is not hard to think about using BFS. If we take this as a search problem in a graph, the key is the defintion of nodes and edges in the graph . In this case, we can take snake\\'s position(as the snake is taking two positions in the grid, we should use two locations) as a node, and a move(RIGHT, DOWN, ROTATE CLOCKWISE, ROTATE ANTI-CLOCKWISE) as an edge, then we can proceed with BFS.\\n\\n\\n```\\nclass Solution {\\n    public int minimumMoves(int[][] grid) {\\n        // r1-c1-r2-c2 as a node\\n        Set<String> visited = new HashSet<>();\\n        Queue<int[]> queue = new LinkedList<>();\\n        int[][] moves = {{0, 1, 0, 1}, {1, 0, 1, 0}, {0, 0, 1, -1}, {0, 0, -1, 1}};\\n        \\n        int n = grid.length;\\n        int steps = 0;\\n        \\n        queue.add(new int[] {0, 0, 0, 1});\\n        visited.add(\"0-0-0-1\");\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            \\n            steps++;\\n            for (int k = 0; k < size; k++) {\\n                int[] node = queue.poll();\\n                \\n                // moves;\\n                for (int i = 0; i < moves.length; i++) {\\n                    int r1 = node[0] + moves[i][0], c1 = node[1] + moves[i][1];\\n                    int r2 = node[2] + moves[i][2], c2 = node[3] + moves[i][3];\\n                    String id = r1 + \"-\" + c1 + \"-\" + r2 + \"-\" + c2;\\n                    \\n                    if (!isValid(r1, c1, grid) || !isValid(r2, c2, grid)) {\\n                        continue;\\n                    } else if (r1 == n - 1 && c1 == n - 2 && r2 == n - 1 && c2 == n - 1) {\\n                        return steps;\\n                    } else if (!visited.contains(id)) {\\n                        if (i < 2 || (isH(node) && i == 2 || !isH(node) && i == 3) && isValid(r1 + 1, c1 + 1, grid)) {\\n                            visited.add(id);\\n                            queue.add(new int[] {r1, c1, r2, c2});    \\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n    \\n    boolean isH(int[] node) {\\n        return node[0] == node[2];\\n    }\\n    \\n    boolean isValid(int r, int c, int[][] grid) {\\n        int n = grid.length;\\n        \\n        return r >= 0 && c >= 0 && r < n && c < n && grid[r][c] == 0;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minimumMoves(int[][] grid) {\\n        // r1-c1-r2-c2 as a node\\n        Set<String> visited = new HashSet<>();\\n        Queue<int[]> queue = new LinkedList<>();\\n        int[][] moves = {{0, 1, 0, 1}, {1, 0, 1, 0}, {0, 0, 1, -1}, {0, 0, -1, 1}};\\n        \\n        int n = grid.length;\\n        int steps = 0;\\n        \\n        queue.add(new int[] {0, 0, 0, 1});\\n        visited.add(\"0-0-0-1\");\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            \\n            steps++;\\n            for (int k = 0; k < size; k++) {\\n                int[] node = queue.poll();\\n                \\n                // moves;\\n                for (int i = 0; i < moves.length; i++) {\\n                    int r1 = node[0] + moves[i][0], c1 = node[1] + moves[i][1];\\n                    int r2 = node[2] + moves[i][2], c2 = node[3] + moves[i][3];\\n                    String id = r1 + \"-\" + c1 + \"-\" + r2 + \"-\" + c2;\\n                    \\n                    if (!isValid(r1, c1, grid) || !isValid(r2, c2, grid)) {\\n                        continue;\\n                    } else if (r1 == n - 1 && c1 == n - 2 && r2 == n - 1 && c2 == n - 1) {\\n                        return steps;\\n                    } else if (!visited.contains(id)) {\\n                        if (i < 2 || (isH(node) && i == 2 || !isH(node) && i == 3) && isValid(r1 + 1, c1 + 1, grid)) {\\n                            visited.add(id);\\n                            queue.add(new int[] {r1, c1, r2, c2});    \\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n    \\n    boolean isH(int[] node) {\\n        return node[0] == node[2];\\n    }\\n    \\n    boolean isValid(int r, int c, int[][] grid) {\\n        int n = grid.length;\\n        \\n        return r >= 0 && c >= 0 && r < n && c < n && grid[r][c] == 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 393163,
                "title": "python-bfs-extended-with-comments",
                "content": "**Approach**\\n1) use a named tuple Part to keep track of tail and head\\n2) use a named tuple Snake to keep track of the whole body\\n3) calculate finish snake state\\n4) enqueue initial snake state\\n5) use BFS to traverse the board and get to the end in as few steps as possible\\n\\n**Complexity analysis**\\ntime: O(V + E)\\nspace: O(V + E)\\n\\n```python\\nPart = collections.namedtuple(\\'Part\\', \\'ri ci\\')\\nSnake = collections.namedtuple(\\'Snake\\', \\'tail head\\')\\n\\nclass Solution:\\n    def minimumMoves(self, grid: List[List[int]]) -> int:\\n        def moves(tail, head):\\n            ok = 0 # it\\'s unblocked\\n            is_horiz = tail.ri == head.ri\\n            \\n            # currently horizontal\\n            if is_horiz and head.ci < N-1 and grid[head.ri][head.ci+1] == ok:\\n\\t\\t\\t  # move right\\n                yield Snake(Part(tail.ri, tail.ci+1), Part(head.ri, head.ci+1))\\n                \\n            #  currently horizontal, can move two ways\\n            if is_horiz and head.ri + 1 < N and grid[head.ri+1][head.ci] == ok and grid[tail.ri+1][tail.ci] == ok:\\n                # move down\\n                yield Snake(Part(tail.ri+1, tail.ci), Part(head.ri+1, head.ci)) \\n                # rotate clockwise\\n                yield Snake(tail, Part(tail.ri+1, tail.ci))\\n\\n            # currently vertical, can move two ways\\n            if not is_horiz and tail.ci + 1 < N and grid[tail.ri][tail.ci+1] == ok and grid[head.ri][head.ci+1] == ok:\\n                # move right\\n                yield Snake(Part(tail.ri, tail.ci+1), Part(head.ri, head.ci+1))\\n                # rotate counter-clockwise\\n                yield Snake(tail, Part(tail.ri, tail.ci+1))\\n                \\n            # currently vertical\\n            if not is_horiz and head.ri+1 < N and grid[head.ri+1][head.ci] == ok:\\n\\t\\t\\t\\t# move down\\n                yield Snake(Part(tail.ri+1, tail.ci), Part(head.ri+1, head.ci))\\n                    \\n            \\n            \\n        N = len(grid)\\n        visited = set()\\n        finish = Snake(Part(N-1, N-2), Part(N-1, N-1))\\n        snake = Snake(Part(0, 0), Part(0, 1))\\n        item = (snake, 0) # keep track of snake position and number of moves so far\\n        q = collections.deque([item])\\n        \\n        while q:\\n            snake, count = q.popleft()\\n            \\n            for snake2 in moves(*snake):\\n\\t\\t\\t\\t# early exit\\n                if snake2 == finish:\\n                    return count + 1\\n                \\n                if snake2 not in visited:\\n                    visited.add(snake2)\\n                    item = (snake2, count+1)\\n                    q.append(item)\\n                    \\n        return -1\\n```",
                "solutionTags": [],
                "code": "```python\\nPart = collections.namedtuple(\\'Part\\', \\'ri ci\\')\\nSnake = collections.namedtuple(\\'Snake\\', \\'tail head\\')\\n\\nclass Solution:\\n    def minimumMoves(self, grid: List[List[int]]) -> int:\\n        def moves(tail, head):\\n            ok = 0 # it\\'s unblocked\\n            is_horiz = tail.ri == head.ri\\n            \\n            # currently horizontal\\n            if is_horiz and head.ci < N-1 and grid[head.ri][head.ci+1] == ok:\\n\\t\\t\\t  # move right\\n                yield Snake(Part(tail.ri, tail.ci+1), Part(head.ri, head.ci+1))\\n                \\n            #  currently horizontal, can move two ways\\n            if is_horiz and head.ri + 1 < N and grid[head.ri+1][head.ci] == ok and grid[tail.ri+1][tail.ci] == ok:\\n                # move down\\n                yield Snake(Part(tail.ri+1, tail.ci), Part(head.ri+1, head.ci)) \\n                # rotate clockwise\\n                yield Snake(tail, Part(tail.ri+1, tail.ci))\\n\\n            # currently vertical, can move two ways\\n            if not is_horiz and tail.ci + 1 < N and grid[tail.ri][tail.ci+1] == ok and grid[head.ri][head.ci+1] == ok:\\n                # move right\\n                yield Snake(Part(tail.ri, tail.ci+1), Part(head.ri, head.ci+1))\\n                # rotate counter-clockwise\\n                yield Snake(tail, Part(tail.ri, tail.ci+1))\\n                \\n            # currently vertical\\n            if not is_horiz and head.ri+1 < N and grid[head.ri+1][head.ci] == ok:\\n\\t\\t\\t\\t# move down\\n                yield Snake(Part(tail.ri+1, tail.ci), Part(head.ri+1, head.ci))\\n                    \\n            \\n            \\n        N = len(grid)\\n        visited = set()\\n        finish = Snake(Part(N-1, N-2), Part(N-1, N-1))\\n        snake = Snake(Part(0, 0), Part(0, 1))\\n        item = (snake, 0) # keep track of snake position and number of moves so far\\n        q = collections.deque([item])\\n        \\n        while q:\\n            snake, count = q.popleft()\\n            \\n            for snake2 in moves(*snake):\\n\\t\\t\\t\\t# early exit\\n                if snake2 == finish:\\n                    return count + 1\\n                \\n                if snake2 not in visited:\\n                    visited.add(snake2)\\n                    item = (snake2, count+1)\\n                    q.append(item)\\n                    \\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 392975,
                "title": "simple-dijkstra-solution-c",
                "content": "Simple dijkstra Algorithm C++\\n\\n```\\nclass Solution {\\npublic:\\n    int minimumMoves(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        map<pair<pair<int,int>,pair<int,int>>,int>vis;            //marks all visited states\\n        set<pair<int,pair<pair<int,int>,pair<int,int>>>>q;              // works as priority queue first element is cost \\n        q.insert({0,{{0,0},{0,1}}});\\n        while(!q.empty()){\\n            auto it=q.begin();\\n            int x1=it->second.first.first;\\n            int y1=it->second.first.second;\\n            int x2=it->second.second.first;\\n            int y2=it->second.second.second;\\n            int cost=it->first;\\n            if(x1==n-1 && y1==n-2 && x2==n-1 && y2==n-1){                 //goal found\\n                return cost;\\n            }\\n            if(vis[{{x1,y1},{x2,y2}}]==0){   //check if already visited\\n                if(y1+1<n && y2+1<n && grid[x1][y1+1]!=1 && grid[x2][y2+1]!=1){        //can go down\\n                    q.insert({cost+1,{{x1,y1+1},{x2,y2+1}}});\\n                }\\n                if(x1+1<n && x2+1<n && grid[x1+1][y1]!=1 && grid[x2+1][y2]!=1){        //can go right\\n                    q.insert({cost+1,{{x1+1,y1},{x2+1,y2}}});\\n                }\\n                if(x1==x2 && x1+1<n && y1+1<n && x2+1<n && y2-1>=0 && grid[x2+1][y2-1]!=1 && grid[x1+1][y1+1]!=1){    //can rotate clockwise\\n                    q.insert({cost+1,{{x1,y1},{x2+1,y2-1}}});\\n                }\\n                if(y1==y2 && x1+1<n && y1+1<n && x2-1>=0 && y2+1<n && grid[x2-1][y2+1]!=1 && grid[x1+1][y1+1]!=1){    //can rotate anticlockwise\\n                    q.insert({cost+1,{{x1,y1},{x2-1,y2+1}}});\\n                }\\n                vis[{{x1,y1},{x2,y2}}]=1;          //mark state as visited\\n            }\\n            q.erase(it);\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumMoves(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        map<pair<pair<int,int>,pair<int,int>>,int>vis;            //marks all visited states\\n        set<pair<int,pair<pair<int,int>,pair<int,int>>>>q;              // works as priority queue first element is cost \\n        q.insert({0,{{0,0},{0,1}}});\\n        while(!q.empty()){\\n            auto it=q.begin();\\n            int x1=it->second.first.first;\\n            int y1=it->second.first.second;\\n            int x2=it->second.second.first;\\n            int y2=it->second.second.second;\\n            int cost=it->first;\\n            if(x1==n-1 && y1==n-2 && x2==n-1 && y2==n-1){                 //goal found\\n                return cost;\\n            }\\n            if(vis[{{x1,y1},{x2,y2}}]==0){   //check if already visited\\n                if(y1+1<n && y2+1<n && grid[x1][y1+1]!=1 && grid[x2][y2+1]!=1){        //can go down\\n                    q.insert({cost+1,{{x1,y1+1},{x2,y2+1}}});\\n                }\\n                if(x1+1<n && x2+1<n && grid[x1+1][y1]!=1 && grid[x2+1][y2]!=1){        //can go right\\n                    q.insert({cost+1,{{x1+1,y1},{x2+1,y2}}});\\n                }\\n                if(x1==x2 && x1+1<n && y1+1<n && x2+1<n && y2-1>=0 && grid[x2+1][y2-1]!=1 && grid[x1+1][y1+1]!=1){    //can rotate clockwise\\n                    q.insert({cost+1,{{x1,y1},{x2+1,y2-1}}});\\n                }\\n                if(y1==y2 && x1+1<n && y1+1<n && x2-1>=0 && y2+1<n && grid[x2-1][y2+1]!=1 && grid[x1+1][y1+1]!=1){    //can rotate anticlockwise\\n                    q.insert({cost+1,{{x1,y1},{x2-1,y2+1}}});\\n                }\\n                vis[{{x1,y1},{x2,y2}}]=1;          //mark state as visited\\n            }\\n            q.erase(it);\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 392885,
                "title": "not-sure-why-i-m-getting-this-found-my-mistake",
                "content": "Update:\\nFirst move of rotating is not allowed becasue (1,1) is not empty.  I didn\\'t read the rotation carefully.\\n\\n---\\nMy program says that the sname makes it to the end in 29 moves but the answer is -1.  When I tried check it out visual, it makes sense that the snake can make it to the end.  Could anyone help me with this test case? \\n```\\n[[0,0,1,0,0,0,0,0,0,0,0,0,0,0,0],\\n [0,1,0,1,1,0,0,1,0,0,0,0,1,0,0],\\n [0,1,0,0,0,0,1,0,0,1,0,0,0,0,0],\\n [0,0,0,0,0,0,1,0,0,0,0,0,0,0,0],\\n [0,0,0,0,0,0,1,1,0,0,0,0,0,0,0],\\n [0,0,0,0,0,0,0,0,0,1,0,1,0,0,0],\\n [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\\n [0,0,0,1,0,1,0,0,1,0,0,0,1,0,0],\\n [0,0,0,0,1,0,0,0,0,0,0,0,0,1,0],\\n [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\\n [0,0,0,1,0,0,0,0,0,0,0,0,0,0,0],\\n [1,0,1,1,0,0,0,0,0,0,0,0,0,0,0],\\n [0,0,0,0,0,0,0,0,0,0,0,0,0,1,0],\\n [1,0,0,0,0,0,1,0,0,0,1,0,0,0,1],\\n [0,0,1,0,1,0,0,0,0,0,0,0,0,0,0]]\\n \\n```\\n\\nI\\'ve attached my BFS search:\\n```\\n0\\n[0, 0, 0, 1]\\n1\\n[0, 0, 1, 0]\\n2\\n[1, 0, 2, 0]\\n3\\n[2, 0, 3, 0]\\n4\\n[3, 0, 4, 0]\\n5\\n[3, 1, 4, 1]\\n[4, 0, 5, 0]\\n[3, 0, 3, 1]\\n6\\n[3, 2, 4, 2]\\n[4, 1, 5, 1]\\n[3, 1, 3, 2]\\n[5, 0, 6, 0]\\n[4, 0, 4, 1]\\n7\\n[3, 3, 4, 3]\\n[4, 2, 5, 2]\\n[3, 2, 3, 3]\\n[5, 1, 6, 1]\\n[4, 1, 4, 2]\\n[6, 0, 7, 0]\\n[5, 0, 5, 1]\\n8\\n[3, 4, 4, 4]\\n[4, 3, 5, 3]\\n[3, 3, 3, 4]\\n[5, 2, 6, 2]\\n[4, 2, 4, 3]\\n[6, 1, 7, 1]\\n[5, 1, 5, 2]\\n[7, 0, 8, 0]\\n[6, 0, 6, 1]\\n9\\n[3, 5, 4, 5]\\n[4, 4, 5, 4]\\n[3, 4, 3, 5]\\n[5, 3, 6, 3]\\n[4, 3, 4, 4]\\n[6, 2, 7, 2]\\n[5, 2, 5, 3]\\n[7, 1, 8, 1]\\n[6, 1, 6, 2]\\n[8, 0, 9, 0]\\n[7, 0, 7, 1]\\n10\\n[4, 5, 5, 5]\\n[5, 4, 6, 4]\\n[4, 4, 4, 5]\\n[5, 3, 5, 4]\\n[7, 2, 8, 2]\\n[6, 2, 6, 3]\\n[8, 1, 9, 1]\\n[7, 1, 7, 2]\\n[9, 0, 10, 0]\\n[8, 0, 8, 1]\\n11\\n[5, 5, 6, 5]\\n[6, 4, 7, 4]\\n[5, 4, 5, 5]\\n[6, 3, 6, 4]\\n[8, 2, 9, 2]\\n[9, 1, 10, 1]\\n[8, 1, 8, 2]\\n[9, 0, 9, 1]\\n12\\n[5, 6, 6, 6]\\n[5, 5, 5, 6]\\n[6, 4, 6, 5]\\n[8, 3, 9, 3]\\n[9, 2, 10, 2]\\n[8, 2, 8, 3]\\n[10, 1, 11, 1]\\n[9, 1, 9, 2]\\n[10, 0, 10, 1]\\n13\\n[5, 7, 6, 7]\\n[6, 6, 7, 6]\\n[5, 6, 5, 7]\\n[6, 5, 6, 6]\\n[9, 2, 9, 3]\\n[11, 1, 12, 1]\\n[10, 1, 10, 2]\\n14\\n[5, 8, 6, 8]\\n[6, 7, 7, 7]\\n[5, 7, 5, 8]\\n[7, 6, 8, 6]\\n[6, 6, 6, 7]\\n[9, 3, 9, 4]\\n[12, 1, 13, 1]\\n15\\n[7, 7, 8, 7]\\n[6, 7, 6, 8]\\n[8, 6, 9, 6]\\n[7, 6, 7, 7]\\n[9, 4, 9, 5]\\n[12, 2, 13, 2]\\n[13, 1, 14, 1]\\n[12, 1, 12, 2]\\n16\\n[8, 7, 9, 7]\\n[6, 8, 6, 9]\\n[9, 6, 10, 6]\\n[8, 6, 8, 7]\\n[9, 5, 9, 6]\\n[10, 4, 10, 5]\\n[9, 4, 10, 4]\\n[12, 3, 13, 3]\\n[12, 2, 12, 3]\\n[13, 1, 13, 2]\\n17\\n[8, 8, 9, 8]\\n[9, 7, 10, 7]\\n[8, 7, 8, 8]\\n[6, 9, 6, 10]\\n[10, 6, 11, 6]\\n[9, 6, 9, 7]\\n[10, 5, 10, 6]\\n[9, 5, 10, 5]\\n[11, 4, 11, 5]\\n[10, 4, 11, 4]\\n[12, 4, 13, 4]\\n[13, 3, 14, 3]\\n[12, 3, 12, 4]\\n[13, 2, 13, 3]\\n18\\n[8, 9, 9, 9]\\n[9, 8, 10, 8]\\n[8, 8, 8, 9]\\n[10, 7, 11, 7]\\n[9, 7, 9, 8]\\n[6, 10, 6, 11]\\n[7, 9, 7, 10]\\n[6, 9, 7, 9]\\n[11, 6, 12, 6]\\n[10, 6, 10, 7]\\n[11, 5, 11, 6]\\n[10, 5, 11, 5]\\n[12, 4, 12, 5]\\n[11, 4, 12, 4]\\n[12, 5, 13, 5]\\n[13, 3, 13, 4]\\n19\\n[8, 10, 9, 10]\\n[9, 9, 10, 9]\\n[8, 9, 8, 10]\\n[10, 8, 11, 8]\\n[9, 8, 9, 9]\\n[11, 7, 12, 7]\\n[10, 7, 10, 8]\\n[6, 11, 6, 12]\\n[7, 10, 7, 11]\\n[6, 10, 7, 10]\\n[7, 9, 8, 9]\\n[11, 6, 11, 7]\\n[12, 5, 12, 6]\\n[11, 5, 12, 5]\\n[13, 4, 13, 5]\\n[13, 5, 14, 5]\\n20\\n[8, 11, 9, 11]\\n[9, 10, 10, 10]\\n[8, 10, 8, 11]\\n[10, 9, 11, 9]\\n[9, 9, 9, 10]\\n[11, 8, 12, 8]\\n[10, 8, 10, 9]\\n[12, 7, 13, 7]\\n[11, 7, 11, 8]\\n[6, 12, 6, 13]\\n[6, 11, 7, 11]\\n[7, 10, 8, 10]\\n[12, 6, 12, 7]\\n21\\n[8, 12, 9, 12]\\n[9, 11, 10, 11]\\n[8, 11, 8, 12]\\n[10, 10, 11, 10]\\n[9, 10, 9, 11]\\n[11, 9, 12, 9]\\n[10, 9, 10, 10]\\n[12, 8, 13, 8]\\n[11, 8, 11, 9]\\n[13, 7, 14, 7]\\n[12, 7, 12, 8]\\n[6, 13, 6, 14]\\n[7, 11, 8, 11]\\n22\\n[9, 12, 10, 12]\\n[10, 11, 11, 11]\\n[9, 11, 9, 12]\\n[11, 10, 12, 10]\\n[10, 10, 10, 11]\\n[12, 9, 13, 9]\\n[11, 9, 11, 10]\\n[13, 8, 14, 8]\\n[12, 8, 12, 9]\\n[13, 7, 13, 8]\\n[7, 13, 7, 14]\\n[6, 13, 7, 13]\\n23\\n[9, 13, 10, 13]\\n[10, 12, 11, 12]\\n[9, 12, 9, 13]\\n[11, 11, 12, 11]\\n[10, 11, 10, 12]\\n[11, 10, 11, 11]\\n[13, 9, 14, 9]\\n[12, 9, 12, 10]\\n[13, 8, 13, 9]\\n[14, 7, 14, 8]\\n[6, 14, 7, 14]\\n24\\n[9, 14, 10, 14]\\n[10, 13, 11, 13]\\n[9, 13, 9, 14]\\n[11, 12, 12, 12]\\n[10, 12, 10, 13]\\n[12, 11, 13, 11]\\n[11, 11, 11, 12]\\n[12, 10, 12, 11]\\n[14, 8, 14, 9]\\n[7, 14, 8, 14]\\n25\\n[10, 14, 11, 14]\\n[10, 13, 10, 14]\\n[12, 12, 13, 12]\\n[11, 12, 11, 13]\\n[13, 11, 14, 11]\\n[12, 11, 12, 12]\\n[14, 9, 14, 10]\\n[8, 14, 9, 14]\\n26\\n[11, 14, 12, 14]\\n[11, 13, 11, 14]\\n[13, 12, 14, 12]\\n[13, 11, 13, 12]\\n[14, 10, 14, 11]\\n27\\n[13, 13, 14, 13]\\n[13, 12, 13, 13]\\n[14, 11, 14, 12]\\n28\\n[14, 12, 14, 13]\\n29\\n[14, 13, 14, 14]\\n29\\n```",
                "solutionTags": [],
                "code": "```\\n[[0,0,1,0,0,0,0,0,0,0,0,0,0,0,0],\\n [0,1,0,1,1,0,0,1,0,0,0,0,1,0,0],\\n [0,1,0,0,0,0,1,0,0,1,0,0,0,0,0],\\n [0,0,0,0,0,0,1,0,0,0,0,0,0,0,0],\\n [0,0,0,0,0,0,1,1,0,0,0,0,0,0,0],\\n [0,0,0,0,0,0,0,0,0,1,0,1,0,0,0],\\n [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\\n [0,0,0,1,0,1,0,0,1,0,0,0,1,0,0],\\n [0,0,0,0,1,0,0,0,0,0,0,0,0,1,0],\\n [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\\n [0,0,0,1,0,0,0,0,0,0,0,0,0,0,0],\\n [1,0,1,1,0,0,0,0,0,0,0,0,0,0,0],\\n [0,0,0,0,0,0,0,0,0,0,0,0,0,1,0],\\n [1,0,0,0,0,0,1,0,0,0,1,0,0,0,1],\\n [0,0,1,0,1,0,0,0,0,0,0,0,0,0,0]]\\n \\n```\n```\\n0\\n[0, 0, 0, 1]\\n1\\n[0, 0, 1, 0]\\n2\\n[1, 0, 2, 0]\\n3\\n[2, 0, 3, 0]\\n4\\n[3, 0, 4, 0]\\n5\\n[3, 1, 4, 1]\\n[4, 0, 5, 0]\\n[3, 0, 3, 1]\\n6\\n[3, 2, 4, 2]\\n[4, 1, 5, 1]\\n[3, 1, 3, 2]\\n[5, 0, 6, 0]\\n[4, 0, 4, 1]\\n7\\n[3, 3, 4, 3]\\n[4, 2, 5, 2]\\n[3, 2, 3, 3]\\n[5, 1, 6, 1]\\n[4, 1, 4, 2]\\n[6, 0, 7, 0]\\n[5, 0, 5, 1]\\n8\\n[3, 4, 4, 4]\\n[4, 3, 5, 3]\\n[3, 3, 3, 4]\\n[5, 2, 6, 2]\\n[4, 2, 4, 3]\\n[6, 1, 7, 1]\\n[5, 1, 5, 2]\\n[7, 0, 8, 0]\\n[6, 0, 6, 1]\\n9\\n[3, 5, 4, 5]\\n[4, 4, 5, 4]\\n[3, 4, 3, 5]\\n[5, 3, 6, 3]\\n[4, 3, 4, 4]\\n[6, 2, 7, 2]\\n[5, 2, 5, 3]\\n[7, 1, 8, 1]\\n[6, 1, 6, 2]\\n[8, 0, 9, 0]\\n[7, 0, 7, 1]\\n10\\n[4, 5, 5, 5]\\n[5, 4, 6, 4]\\n[4, 4, 4, 5]\\n[5, 3, 5, 4]\\n[7, 2, 8, 2]\\n[6, 2, 6, 3]\\n[8, 1, 9, 1]\\n[7, 1, 7, 2]\\n[9, 0, 10, 0]\\n[8, 0, 8, 1]\\n11\\n[5, 5, 6, 5]\\n[6, 4, 7, 4]\\n[5, 4, 5, 5]\\n[6, 3, 6, 4]\\n[8, 2, 9, 2]\\n[9, 1, 10, 1]\\n[8, 1, 8, 2]\\n[9, 0, 9, 1]\\n12\\n[5, 6, 6, 6]\\n[5, 5, 5, 6]\\n[6, 4, 6, 5]\\n[8, 3, 9, 3]\\n[9, 2, 10, 2]\\n[8, 2, 8, 3]\\n[10, 1, 11, 1]\\n[9, 1, 9, 2]\\n[10, 0, 10, 1]\\n13\\n[5, 7, 6, 7]\\n[6, 6, 7, 6]\\n[5, 6, 5, 7]\\n[6, 5, 6, 6]\\n[9, 2, 9, 3]\\n[11, 1, 12, 1]\\n[10, 1, 10, 2]\\n14\\n[5, 8, 6, 8]\\n[6, 7, 7, 7]\\n[5, 7, 5, 8]\\n[7, 6, 8, 6]\\n[6, 6, 6, 7]\\n[9, 3, 9, 4]\\n[12, 1, 13, 1]\\n15\\n[7, 7, 8, 7]\\n[6, 7, 6, 8]\\n[8, 6, 9, 6]\\n[7, 6, 7, 7]\\n[9, 4, 9, 5]\\n[12, 2, 13, 2]\\n[13, 1, 14, 1]\\n[12, 1, 12, 2]\\n16\\n[8, 7, 9, 7]\\n[6, 8, 6, 9]\\n[9, 6, 10, 6]\\n[8, 6, 8, 7]\\n[9, 5, 9, 6]\\n[10, 4, 10, 5]\\n[9, 4, 10, 4]\\n[12, 3, 13, 3]\\n[12, 2, 12, 3]\\n[13, 1, 13, 2]\\n17\\n[8, 8, 9, 8]\\n[9, 7, 10, 7]\\n[8, 7, 8, 8]\\n[6, 9, 6, 10]\\n[10, 6, 11, 6]\\n[9, 6, 9, 7]\\n[10, 5, 10, 6]\\n[9, 5, 10, 5]\\n[11, 4, 11, 5]\\n[10, 4, 11, 4]\\n[12, 4, 13, 4]\\n[13, 3, 14, 3]\\n[12, 3, 12, 4]\\n[13, 2, 13, 3]\\n18\\n[8, 9, 9, 9]\\n[9, 8, 10, 8]\\n[8, 8, 8, 9]\\n[10, 7, 11, 7]\\n[9, 7, 9, 8]\\n[6, 10, 6, 11]\\n[7, 9, 7, 10]\\n[6, 9, 7, 9]\\n[11, 6, 12, 6]\\n[10, 6, 10, 7]\\n[11, 5, 11, 6]\\n[10, 5, 11, 5]\\n[12, 4, 12, 5]\\n[11, 4, 12, 4]\\n[12, 5, 13, 5]\\n[13, 3, 13, 4]\\n19\\n[8, 10, 9, 10]\\n[9, 9, 10, 9]\\n[8, 9, 8, 10]\\n[10, 8, 11, 8]\\n[9, 8, 9, 9]\\n[11, 7, 12, 7]\\n[10, 7, 10, 8]\\n[6, 11, 6, 12]\\n[7, 10, 7, 11]\\n[6, 10, 7, 10]\\n[7, 9, 8, 9]\\n[11, 6, 11, 7]\\n[12, 5, 12, 6]\\n[11, 5, 12, 5]\\n[13, 4, 13, 5]\\n[13, 5, 14, 5]\\n20\\n[8, 11, 9, 11]\\n[9, 10, 10, 10]\\n[8, 10, 8, 11]\\n[10, 9, 11, 9]\\n[9, 9, 9, 10]\\n[11, 8, 12, 8]\\n[10, 8, 10, 9]\\n[12, 7, 13, 7]\\n[11, 7, 11, 8]\\n[6, 12, 6, 13]\\n[6, 11, 7, 11]\\n[7, 10, 8, 10]\\n[12, 6, 12, 7]\\n21\\n[8, 12, 9, 12]\\n[9, 11, 10, 11]\\n[8, 11, 8, 12]\\n[10, 10, 11, 10]\\n[9, 10, 9, 11]\\n[11, 9, 12, 9]\\n[10, 9, 10, 10]\\n[12, 8, 13, 8]\\n[11, 8, 11, 9]\\n[13, 7, 14, 7]\\n[12, 7, 12, 8]\\n[6, 13, 6, 14]\\n[7, 11, 8, 11]\\n22\\n[9, 12, 10, 12]\\n[10, 11, 11, 11]\\n[9, 11, 9, 12]\\n[11, 10, 12, 10]\\n[10, 10, 10, 11]\\n[12, 9, 13, 9]\\n[11, 9, 11, 10]\\n[13, 8, 14, 8]\\n[12, 8, 12, 9]\\n[13, 7, 13, 8]\\n[7, 13, 7, 14]\\n[6, 13, 7, 13]\\n23\\n[9, 13, 10, 13]\\n[10, 12, 11, 12]\\n[9, 12, 9, 13]\\n[11, 11, 12, 11]\\n[10, 11, 10, 12]\\n[11, 10, 11, 11]\\n[13, 9, 14, 9]\\n[12, 9, 12, 10]\\n[13, 8, 13, 9]\\n[14, 7, 14, 8]\\n[6, 14, 7, 14]\\n24\\n[9, 14, 10, 14]\\n[10, 13, 11, 13]\\n[9, 13, 9, 14]\\n[11, 12, 12, 12]\\n[10, 12, 10, 13]\\n[12, 11, 13, 11]\\n[11, 11, 11, 12]\\n[12, 10, 12, 11]\\n[14, 8, 14, 9]\\n[7, 14, 8, 14]\\n25\\n[10, 14, 11, 14]\\n[10, 13, 10, 14]\\n[12, 12, 13, 12]\\n[11, 12, 11, 13]\\n[13, 11, 14, 11]\\n[12, 11, 12, 12]\\n[14, 9, 14, 10]\\n[8, 14, 9, 14]\\n26\\n[11, 14, 12, 14]\\n[11, 13, 11, 14]\\n[13, 12, 14, 12]\\n[13, 11, 13, 12]\\n[14, 10, 14, 11]\\n27\\n[13, 13, 14, 13]\\n[13, 12, 13, 13]\\n[14, 11, 14, 12]\\n28\\n[14, 12, 14, 13]\\n29\\n[14, 13, 14, 14]\\n29\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 392828,
                "title": "java-bfs-solution",
                "content": "int[4] to record snake position\\nv1[][] record visited horizontal positions\\nv2[][] record visited vertical positions\\n```\\nclass Solution {\\n    public int minimumMoves(int[][] grid) {\\n        int ind = 0;\\n        int n = grid.length;\\n        int[][] v1 = new int[n][n];\\n        int[][] v2 = new int[n][n];\\n        if (grid[0][0] == 1 || grid[0][1] == 1) return -1;\\n        int[] s = new int[]{0, 0, 0, 1};\\n        Deque<int[]> queue = new ArrayDeque<>();\\n        queue.offerLast(s);\\n        while (queue.size() > 0) {\\n            ind++;\\n            System.out.println(ind);\\n            int k = queue.size();\\n            for (int i = 0; i < k; i++) {\\n                int[] temp = queue.pollFirst();\\n                if (temp[3] > temp[1]) {\\n                    if (temp[3] == n - 1 && temp[2] == n - 1) return ind - 1;\\n                    if ((temp[3] + 1 < n) && grid[temp[0]][temp[3] + 1] != 1) {\\n                        if (v1[temp[0]][temp[3]] != 1)\\n                        queue.offerLast(new int[]{temp[0], temp[3], temp[0], temp[3] + 1});\\n                        v1[temp[0]][temp[3]] = 1;\\n                    }\\n                    if ((temp[0] + 1 < n) && grid[temp[0] + 1][temp[1]] != 1 && grid[temp[0] + 1][temp[3]] != 1) {\\n                        if (v2[temp[0]][temp[1]] != 1)\\n                        queue.offerLast(new int[]{temp[0], temp[1], temp[0] + 1, temp[1]});\\n                        v2[temp[0]][temp[1]] = 1;\\n                    }\\n                    \\n                    if ((temp[0] + 1 < n) && grid[temp[0] + 1][temp[1]] != 1  && grid[temp[0] + 1][temp[3]] != 1) {\\n                        if (v1[temp[0] + 1][temp[1]] != 1)\\n                        queue.offerLast(new int[]{temp[0] + 1, temp[1], temp[0] + 1, temp[3]});\\n                        v1[temp[0] + 1][temp[1]] = 1;\\n                    }\\n                }\\n                else if (temp[2] > temp[0]) {\\n                    if ((temp[2] + 1 < n) && grid[temp[2] + 1][temp[1]] != 1) {\\n                        if (v2[temp[2]][temp[3]] != 1)\\n                        queue.offerLast(new int[]{temp[2], temp[3], temp[2] + 1, temp[3]});\\n                        v2[temp[2]][temp[3]] = 1;\\n                    }\\n                    \\n                    if ((temp[1] + 1 < n) && grid[temp[0]][temp[1] + 1] != 1 && grid[temp[2]][temp[1] + 1] != 1) {\\n                        if (v1[temp[0]][temp[1]] != 1)\\n                        queue.offerLast(new int[]{temp[0], temp[1], temp[0], temp[1] + 1});\\n                        v1[temp[0]][temp[1]] = 1;\\n                    }\\n                    \\n                    if ((temp[1] + 1 < n) && grid[temp[0]][temp[1] + 1] != 1 && grid[temp[2]][temp[3] + 1] != 1) {\\n                        if (v2[temp[0]][temp[1] + 1] != 1)\\n                        queue.offerLast(new int[]{temp[0], temp[1] + 1, temp[2], temp[3] + 1});\\n                        v2[temp[0]][temp[1] + 1] = 1;\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minimumMoves(int[][] grid) {\\n        int ind = 0;\\n        int n = grid.length;\\n        int[][] v1 = new int[n][n];\\n        int[][] v2 = new int[n][n];\\n        if (grid[0][0] == 1 || grid[0][1] == 1) return -1;\\n        int[] s = new int[]{0, 0, 0, 1};\\n        Deque<int[]> queue = new ArrayDeque<>();\\n        queue.offerLast(s);\\n        while (queue.size() > 0) {\\n            ind++;\\n            System.out.println(ind);\\n            int k = queue.size();\\n            for (int i = 0; i < k; i++) {\\n                int[] temp = queue.pollFirst();\\n                if (temp[3] > temp[1]) {\\n                    if (temp[3] == n - 1 && temp[2] == n - 1) return ind - 1;\\n                    if ((temp[3] + 1 < n) && grid[temp[0]][temp[3] + 1] != 1) {\\n                        if (v1[temp[0]][temp[3]] != 1)\\n                        queue.offerLast(new int[]{temp[0], temp[3], temp[0], temp[3] + 1});\\n                        v1[temp[0]][temp[3]] = 1;\\n                    }\\n                    if ((temp[0] + 1 < n) && grid[temp[0] + 1][temp[1]] != 1 && grid[temp[0] + 1][temp[3]] != 1) {\\n                        if (v2[temp[0]][temp[1]] != 1)\\n                        queue.offerLast(new int[]{temp[0], temp[1], temp[0] + 1, temp[1]});\\n                        v2[temp[0]][temp[1]] = 1;\\n                    }\\n                    \\n                    if ((temp[0] + 1 < n) && grid[temp[0] + 1][temp[1]] != 1  && grid[temp[0] + 1][temp[3]] != 1) {\\n                        if (v1[temp[0] + 1][temp[1]] != 1)\\n                        queue.offerLast(new int[]{temp[0] + 1, temp[1], temp[0] + 1, temp[3]});\\n                        v1[temp[0] + 1][temp[1]] = 1;\\n                    }\\n                }\\n                else if (temp[2] > temp[0]) {\\n                    if ((temp[2] + 1 < n) && grid[temp[2] + 1][temp[1]] != 1) {\\n                        if (v2[temp[2]][temp[3]] != 1)\\n                        queue.offerLast(new int[]{temp[2], temp[3], temp[2] + 1, temp[3]});\\n                        v2[temp[2]][temp[3]] = 1;\\n                    }\\n                    \\n                    if ((temp[1] + 1 < n) && grid[temp[0]][temp[1] + 1] != 1 && grid[temp[2]][temp[1] + 1] != 1) {\\n                        if (v1[temp[0]][temp[1]] != 1)\\n                        queue.offerLast(new int[]{temp[0], temp[1], temp[0], temp[1] + 1});\\n                        v1[temp[0]][temp[1]] = 1;\\n                    }\\n                    \\n                    if ((temp[1] + 1 < n) && grid[temp[0]][temp[1] + 1] != 1 && grid[temp[2]][temp[3] + 1] != 1) {\\n                        if (v2[temp[0]][temp[1] + 1] != 1)\\n                        queue.offerLast(new int[]{temp[0], temp[1] + 1, temp[2], temp[3] + 1});\\n                        v2[temp[0]][temp[1] + 1] = 1;\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4023595,
                "title": "best-solution-bfs-easy-to-understand",
                "content": "# Complexity\\n- Time complexity: $$O(n^2)$$ \\n\\n- Space complexity: $$O(n^2)$$ \\n\\n```\\nTerminology used in Code :-\\ntr    -> tailRow\\ntc    -> tailCol\\nhr    -> headRow\\nhc    -> headCol\\nnewTr -> new tailRow\\nnewTc -> new tailCol\\nnewHr -> new headRow\\nnewHc -> new headCol\\n```\\n# Code\\n```\\nclass Solution {\\n   bool isValid(int tr, int tc, int hr, int hc, vector<vector<int>>& grid)\\n   {\\n      int n = grid.size();\\n      return tr < n && tc < n && hr < n && hc < n && grid[tr][tc] == 0 && grid[hr][hc] == 0;\\n   }\\n public:\\n    int minimumMoves(vector<vector<int>>& grid) {\\n        unordered_map<string,bool> vis;\\n        int n = grid.size(), moves = 0;\\n        queue<vector<int>> q;\\n\\n        q.push({0,0,1});\\n        while(!q.empty())\\n        {\\n           int size = q.size();\\n           while(size--)\\n           {\\n               auto curr = q.front(); \\n                q.pop();\\n\\n              int tr = curr[0], tc = curr[1], isHorizontal = curr[2], hr, hc;\\n              string state = to_string(tr) + \\'$\\' + to_string(tc) + \\'$\\' + to_string(isHorizontal);\\n              if(vis[state]) continue; //do not visit already visited states\\n              vis[state] = true;\\n\\n              if(tr == n-1 && tc == n-2 && isHorizontal) //termination condition\\n               return moves;\\n\\n               int newTr,newTc,newHr,newHc;\\n                if(isHorizontal == 1)\\n                {\\n                //CASE 1: move right\\n                newTr = tr, newTc = tc, newHr = tr, newHc = tc + 2;\\n                if(isValid(newTr,newTc,newHr,newHc,grid)) \\n                  q.push({tr,tc+1,1}); \\n\\n                //CASE 2: move down \\n                newTr = tr+1, newTc = tc, newHr = tr+1, newHc = tc+1;\\n                if(isValid(newTr,newTc,newHr,newHc,grid)) \\n                 q.push({tr+1,tc,1});\\n\\n                //CASE 3: rotate clock-wiae\\n                newTr = tr, newTc = tc, newHr = tr+1, newHc = tc;\\n                if(isValid(newTr,newTc,newHr,newHc,grid) && grid[tr+1][tc+1] == 0) \\n                   q.push({tr,tc,0}); \\n                }\\n               else\\n               {//CASE 1: move right\\n                newTr = tr, newTc = tc+1, newHr = tr+1, newHc = tc+1;\\n                if(isValid(newTr,newTc,newHr,newHc,grid)) \\n                 q.push({tr,tc+1,0}); \\n\\n                //CASE 2: move down\\n                newTr = tr+1, newTc = tc, newHr = tr+2, newHc = tc;\\n                if(isValid(newTr,newTc,newHr,newHc,grid)) \\n                 q.push({tr+1,tc,0}); \\n\\n                //CASE 3: move anti clock-wise\\n                newTr = tr, newTc = tc, newHr = tr, newHc = tc+1;\\n                if(isValid(newTr,newTc,newHr,newHc,grid) && grid[tr+1][tc+1] == 0)  \\n                   q.push({tr,tc,1});  \\n               }    \\n            }\\n         moves++;\\n        }\\n    return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\nTerminology used in Code :-\\ntr    -> tailRow\\ntc    -> tailCol\\nhr    -> headRow\\nhc    -> headCol\\nnewTr -> new tailRow\\nnewTc -> new tailCol\\nnewHr -> new headRow\\nnewHc -> new headCol\\n```\n```\\nclass Solution {\\n   bool isValid(int tr, int tc, int hr, int hc, vector<vector<int>>& grid)\\n   {\\n      int n = grid.size();\\n      return tr < n && tc < n && hr < n && hc < n && grid[tr][tc] == 0 && grid[hr][hc] == 0;\\n   }\\n public:\\n    int minimumMoves(vector<vector<int>>& grid) {\\n        unordered_map<string,bool> vis;\\n        int n = grid.size(), moves = 0;\\n        queue<vector<int>> q;\\n\\n        q.push({0,0,1});\\n        while(!q.empty())\\n        {\\n           int size = q.size();\\n           while(size--)\\n           {\\n               auto curr = q.front(); \\n                q.pop();\\n\\n              int tr = curr[0], tc = curr[1], isHorizontal = curr[2], hr, hc;\\n              string state = to_string(tr) + \\'$\\' + to_string(tc) + \\'$\\' + to_string(isHorizontal);\\n              if(vis[state]) continue; //do not visit already visited states\\n              vis[state] = true;\\n\\n              if(tr == n-1 && tc == n-2 && isHorizontal) //termination condition\\n               return moves;\\n\\n               int newTr,newTc,newHr,newHc;\\n                if(isHorizontal == 1)\\n                {\\n                //CASE 1: move right\\n                newTr = tr, newTc = tc, newHr = tr, newHc = tc + 2;\\n                if(isValid(newTr,newTc,newHr,newHc,grid)) \\n                  q.push({tr,tc+1,1}); \\n\\n                //CASE 2: move down \\n                newTr = tr+1, newTc = tc, newHr = tr+1, newHc = tc+1;\\n                if(isValid(newTr,newTc,newHr,newHc,grid)) \\n                 q.push({tr+1,tc,1});\\n\\n                //CASE 3: rotate clock-wiae\\n                newTr = tr, newTc = tc, newHr = tr+1, newHc = tc;\\n                if(isValid(newTr,newTc,newHr,newHc,grid) && grid[tr+1][tc+1] == 0) \\n                   q.push({tr,tc,0}); \\n                }\\n               else\\n               {//CASE 1: move right\\n                newTr = tr, newTc = tc+1, newHr = tr+1, newHc = tc+1;\\n                if(isValid(newTr,newTc,newHr,newHc,grid)) \\n                 q.push({tr,tc+1,0}); \\n\\n                //CASE 2: move down\\n                newTr = tr+1, newTc = tc, newHr = tr+2, newHc = tc;\\n                if(isValid(newTr,newTc,newHr,newHc,grid)) \\n                 q.push({tr+1,tc,0}); \\n\\n                //CASE 3: move anti clock-wise\\n                newTr = tr, newTc = tc, newHr = tr, newHc = tc+1;\\n                if(isValid(newTr,newTc,newHr,newHc,grid) && grid[tr+1][tc+1] == 0)  \\n                   q.push({tr,tc,1});  \\n               }    \\n            }\\n         moves++;\\n        }\\n    return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3974560,
                "title": "3d-dp-solution-python",
                "content": "# Intuition\\n    please use bfs approach,my solution works but not optimize.\\n\\n# Code\\n```\\nclass Solution:\\n\\n    def check(self,dp,grid,i,j,k,n):\\n        if(i==n-1 and j==n-1 and k==0):return 0\\n        if(min(i,j)<0 or max(i,j)>=n or grid[i][j]==1 or grid[i][j]==-1):return n*n\\n        # print(i,j,k,dp[i][j][k],\"------\")\\n        if(dp[i][j][k]!=-1):return dp[i][j][k]\\n        ans=n*n\\n        pre=grid[i][j]\\n        grid[i][j]=-1\\n        if(k==0):\\n            if(i+1<n and grid[i+1][j-1]!=1 and grid[i+1][j]!=1):\\n                ans=min(ans,self.check(dp,grid,i+1,j,k,n)+1)\\n                ans=min(ans,self.check(dp,grid,i+1,j-1,k^1,n)+1)\\n            ans=min(ans,self.check(dp,grid,i,j+1,k,n)+1)\\n        else:\\n            ans=min(ans,self.check(dp,grid,i+1,j,k,n)+1)\\n            if(j+1<n and grid[i-1][j+1]!=1 and  grid[i][j+1]!=1):\\n                ans=min(ans,self.check(dp,grid,i,j+1,k,n)+1)\\n                ans=min(ans,self.check(dp,grid,i-1,j+1,k^1,n)+1)\\n        dp[i][j][k]=ans\\n        grid[i][j]=pre\\n        # print(i,j,k,dp[i][j][k])\\n        return dp[i][j][k]\\n\\n    def minimumMoves(self, grid: List[List[int]]) -> int:\\n        n=len(grid)\\n        dp=[[[-1 for k in range(2)] for i in range(n)] for j in range(n)]\\n        ans=self.check(dp,grid,0,1,0,n)\\n        if(ans>=n*n):return -1\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Dynamic Programming",
                    "Matrix"
                ],
                "code": "```\\nclass Solution:\\n\\n    def check(self,dp,grid,i,j,k,n):\\n        if(i==n-1 and j==n-1 and k==0):return 0\\n        if(min(i,j)<0 or max(i,j)>=n or grid[i][j]==1 or grid[i][j]==-1):return n*n\\n        # print(i,j,k,dp[i][j][k],\"------\")\\n        if(dp[i][j][k]!=-1):return dp[i][j][k]\\n        ans=n*n\\n        pre=grid[i][j]\\n        grid[i][j]=-1\\n        if(k==0):\\n            if(i+1<n and grid[i+1][j-1]!=1 and grid[i+1][j]!=1):\\n                ans=min(ans,self.check(dp,grid,i+1,j,k,n)+1)\\n                ans=min(ans,self.check(dp,grid,i+1,j-1,k^1,n)+1)\\n            ans=min(ans,self.check(dp,grid,i,j+1,k,n)+1)\\n        else:\\n            ans=min(ans,self.check(dp,grid,i+1,j,k,n)+1)\\n            if(j+1<n and grid[i-1][j+1]!=1 and  grid[i][j+1]!=1):\\n                ans=min(ans,self.check(dp,grid,i,j+1,k,n)+1)\\n                ans=min(ans,self.check(dp,grid,i-1,j+1,k^1,n)+1)\\n        dp[i][j][k]=ans\\n        grid[i][j]=pre\\n        # print(i,j,k,dp[i][j][k])\\n        return dp[i][j][k]\\n\\n    def minimumMoves(self, grid: List[List[int]]) -> int:\\n        n=len(grid)\\n        dp=[[[-1 for k in range(2)] for i in range(n)] for j in range(n)]\\n        ans=self.check(dp,grid,0,1,0,n)\\n        if(ans>=n*n):return -1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3925656,
                "title": "c-dfs-memo-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIt\\'s *generally* better to use BFS for search problems like this. However, given the constraints for this problem, DFS+memo is more than adequate; in fact it is both simpler and faster.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nDFS with two 2D arrays for memoization: `hmemo` for when we\\'re horizontal, and `vmemo` for when we\\'re vertical. While we\\'re running DFS on a point, we can set its memo to `INT_MAX-1` so the code will short-circuit if we attempt anything that could cause a cycle. I also return `INT_MAX-1` if the target is unreachable. (`INT_MAX-1` avoids overflow when doing `1+dfs(...)`).\\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$, 17ms beats 100% apparently!\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n^2)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int n;\\n    vector<vector<int>> hmemo, vmemo;\\n    vector<vector<int>> *gridp;\\n\\n    int dfs(bool h, int r, int c) {\\n        vector<vector<int>> & grid = *gridp;\\n        if (h && r == n-1 && c == n-2)\\n            return 0;\\n        int res = INT_MAX-1;\\n        if (h) {\\n            if (hmemo[r][c] > 0) {\\n                return hmemo[r][c];\\n            }\\n            hmemo[r][c] = INT_MAX-1;\\n            if (c+2 < n && grid[r][c+2] == 0) {\\n                // move right\\n                res = min(res, 1+dfs(true, r, c+1));\\n            }\\n            if (r+1 < n && grid[r+1][c] == 0 && grid[r+1][c+1] == 0) {\\n                // move down\\n                res = min(res, 1+dfs(true, r+1, c));\\n                // rotate clockwise\\n                res = min(res, 1+dfs(false, r, c));\\n            }\\n            hmemo[r][c] = res;\\n            return res;\\n        } else {\\n            if (vmemo[r][c] > 0) {\\n                return vmemo[r][c];\\n            }\\n            vmemo[r][c] = INT_MAX-1;\\n            if (r+2 < n && grid[r+2][c] == 0) {\\n                // move down\\n                res = min(res, 1+dfs(false, r+1, c));\\n            }\\n            if (c+1 < n && grid[r][c+1] == 0 && grid[r+1][c+1] == 0) {\\n                // move right\\n                res = min(res, 1+dfs(false, r, c+1));\\n                // rotate counterclockwise\\n                res = min(res, 1+dfs(true, r, c));\\n            }\\n            vmemo[r][c] = res;\\n            return res;\\n        }\\n    }\\n\\npublic:\\n    int minimumMoves(vector<vector<int>>& grid) {\\n        this->gridp = &grid;\\n        n = grid.size();\\n        hmemo = vector<vector<int>>(n, vector<int>(n, -1));\\n        vmemo = vector<vector<int>>(n, vector<int>(n, -1));\\n        int res = dfs(true, 0, 0);\\n        return res < INT_MAX-1 ? res : -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    int n;\\n    vector<vector<int>> hmemo, vmemo;\\n    vector<vector<int>> *gridp;\\n\\n    int dfs(bool h, int r, int c) {\\n        vector<vector<int>> & grid = *gridp;\\n        if (h && r == n-1 && c == n-2)\\n            return 0;\\n        int res = INT_MAX-1;\\n        if (h) {\\n            if (hmemo[r][c] > 0) {\\n                return hmemo[r][c];\\n            }\\n            hmemo[r][c] = INT_MAX-1;\\n            if (c+2 < n && grid[r][c+2] == 0) {\\n                // move right\\n                res = min(res, 1+dfs(true, r, c+1));\\n            }\\n            if (r+1 < n && grid[r+1][c] == 0 && grid[r+1][c+1] == 0) {\\n                // move down\\n                res = min(res, 1+dfs(true, r+1, c));\\n                // rotate clockwise\\n                res = min(res, 1+dfs(false, r, c));\\n            }\\n            hmemo[r][c] = res;\\n            return res;\\n        } else {\\n            if (vmemo[r][c] > 0) {\\n                return vmemo[r][c];\\n            }\\n            vmemo[r][c] = INT_MAX-1;\\n            if (r+2 < n && grid[r+2][c] == 0) {\\n                // move down\\n                res = min(res, 1+dfs(false, r+1, c));\\n            }\\n            if (c+1 < n && grid[r][c+1] == 0 && grid[r+1][c+1] == 0) {\\n                // move right\\n                res = min(res, 1+dfs(false, r, c+1));\\n                // rotate counterclockwise\\n                res = min(res, 1+dfs(true, r, c));\\n            }\\n            vmemo[r][c] = res;\\n            return res;\\n        }\\n    }\\n\\npublic:\\n    int minimumMoves(vector<vector<int>>& grid) {\\n        this->gridp = &grid;\\n        n = grid.size();\\n        hmemo = vector<vector<int>>(n, vector<int>(n, -1));\\n        vmemo = vector<vector<int>>(n, vector<int>(n, -1));\\n        int res = dfs(true, 0, 0);\\n        return res < INT_MAX-1 ? res : -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3735145,
                "title": "super-fast-and-readable-python-solution-using-breadth-first-search",
                "content": "# Intuition\\nThis looks like a variation of the basic path planning problem where we must navigate a grid with obstacles. These are classically solved with breadth first search BFS as BFS reveals the shortest path to a node the very first time you reach it.\\n\\nThe twist here is that we have a snake that takes up two squares instead of the usual one. This slightly complicates the graph representation of the problem.\\n\\n# Approach\\nWe create a graph as follows:\\n* A vertex V is a triple of the form (row, column, orientation) where orientation is 0 if the snake is horizontal and 1 if the snake is vertical. As an example (3, 5, 0) means that the snake is taking up grid positions (3, 5) and (3, 6) and (3, 5, 1) means that the snake is taking up grid positions (3, 5) and (4, 5).\\n* A directed edge exists between two vertices V1 and V2 if it is possible to go from V1 to V2 with a single move (right, down, clockwise rotation, or counter-clockwise rotation).\\n* The resulting graph G can be more easily represented by its two subgraphs GH and GV with each consisting of horizontally- and vertically-oriented vertices. We create two matrices Hnodes and Vnodes to store the minimum distance to each node. A sentinel value of infinity (inf) is used to represent nodes that have not been reached yet. If a node remains infinity after the algorithm terminates, then it is unreachable via the allowed moves.\\n* Now apply a BFS traversal of G using a queue.\\n\\nNote that as of this writing, this solution was the fastest running submission and also the submission using the least memory.\\n\\n\\n# Complexity\\n- Time complexity:\\n$O(n^2)$ where $n$ is the length of the side of the square grid. Note that general BFS can be much slower, especially for densely connected graphs; however, we take advantage of the fact the local connectedness topology.\\n\\n- Space complexity:\\n$O(n^2)$ from the matrices we used to store distances.\\n\\n# Code\\n```\\nfrom collections import deque\\n\\nclass Solution:\\n    def minimumMoves(self, grid: List[List[int]]) -> int:\\n        inf = 10000\\n        N = len(grid)\\n        Hnodes = [[inf for col in range(N-1)] for row in range(N)]\\n        Vnodes = [[inf for col in range(N)] for row in range(N-1)]\\n        nodeQueue = deque()\\n\\n        # Starting position\\n        Hnodes[0][0] = 0\\n        nodeQueue.append((0, 0, 0)) # row, col, orientation\\n\\n        while len(nodeQueue) > 0:\\n            node = nodeQueue.popleft()\\n            row = node[0]\\n            col = node[1]\\n            orientation = node[2]\\n            # horizontal case\\n            if orientation == 0:\\n                minMoves = Hnodes[row][col]\\n                # move right case\\n                if col + 2 < N and grid[row][col + 2] == 0 and Hnodes[row][col + 1] == inf:\\n                    Hnodes[row][col + 1] = minMoves + 1\\n                    nodeQueue.append((row, col + 1, 0))\\n                # move down case or rotate clockwise case\\n                if row + 1 < N and grid[row + 1][col] == 0 and grid[row + 1][col + 1] == 0:\\n                    # move down\\n                    if Hnodes[row + 1][col] == inf:\\n                        Hnodes[row + 1][col] = minMoves + 1\\n                        nodeQueue.append((row + 1, col, 0))\\n                    # rotate clockwise\\n                    if Vnodes[row][col] == inf:\\n                        Vnodes[row][col] = minMoves + 1\\n                        nodeQueue.append((row, col, 1))\\n            # vertical case\\n            else:\\n                minMoves = Vnodes[row][col]\\n                # move down case\\n                if row + 2 < N and grid[row + 2][col] == 0 and Vnodes[row + 1][col] == inf:\\n                    Vnodes[row + 1][col] = minMoves + 1\\n                    nodeQueue.append((row + 1, col, 1))\\n                # move right or rotate counter clockwise case\\n                if col + 1 < N and grid[row][col + 1] == 0 and grid[row + 1][col + 1] == 0:\\n                    # move right\\n                    if Vnodes[row][col + 1] == inf:\\n                        Vnodes[row][col + 1] = minMoves + 1\\n                        nodeQueue.append((row, col + 1, 1))\\n                    # rotate counter clockwise\\n                    if Hnodes[row][col] == inf:\\n                        Hnodes[row][col] = minMoves + 1\\n                        nodeQueue.append((row, col, 0))\\n\\n        minDist = Hnodes[N - 1][N - 2]\\n        return minDist if minDist < inf else -1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import deque\\n\\nclass Solution:\\n    def minimumMoves(self, grid: List[List[int]]) -> int:\\n        inf = 10000\\n        N = len(grid)\\n        Hnodes = [[inf for col in range(N-1)] for row in range(N)]\\n        Vnodes = [[inf for col in range(N)] for row in range(N-1)]\\n        nodeQueue = deque()\\n\\n        # Starting position\\n        Hnodes[0][0] = 0\\n        nodeQueue.append((0, 0, 0)) # row, col, orientation\\n\\n        while len(nodeQueue) > 0:\\n            node = nodeQueue.popleft()\\n            row = node[0]\\n            col = node[1]\\n            orientation = node[2]\\n            # horizontal case\\n            if orientation == 0:\\n                minMoves = Hnodes[row][col]\\n                # move right case\\n                if col + 2 < N and grid[row][col + 2] == 0 and Hnodes[row][col + 1] == inf:\\n                    Hnodes[row][col + 1] = minMoves + 1\\n                    nodeQueue.append((row, col + 1, 0))\\n                # move down case or rotate clockwise case\\n                if row + 1 < N and grid[row + 1][col] == 0 and grid[row + 1][col + 1] == 0:\\n                    # move down\\n                    if Hnodes[row + 1][col] == inf:\\n                        Hnodes[row + 1][col] = minMoves + 1\\n                        nodeQueue.append((row + 1, col, 0))\\n                    # rotate clockwise\\n                    if Vnodes[row][col] == inf:\\n                        Vnodes[row][col] = minMoves + 1\\n                        nodeQueue.append((row, col, 1))\\n            # vertical case\\n            else:\\n                minMoves = Vnodes[row][col]\\n                # move down case\\n                if row + 2 < N and grid[row + 2][col] == 0 and Vnodes[row + 1][col] == inf:\\n                    Vnodes[row + 1][col] = minMoves + 1\\n                    nodeQueue.append((row + 1, col, 1))\\n                # move right or rotate counter clockwise case\\n                if col + 1 < N and grid[row][col + 1] == 0 and grid[row + 1][col + 1] == 0:\\n                    # move right\\n                    if Vnodes[row][col + 1] == inf:\\n                        Vnodes[row][col + 1] = minMoves + 1\\n                        nodeQueue.append((row, col + 1, 1))\\n                    # rotate counter clockwise\\n                    if Hnodes[row][col] == inf:\\n                        Hnodes[row][col] = minMoves + 1\\n                        nodeQueue.append((row, col, 0))\\n\\n        minDist = Hnodes[N - 1][N - 2]\\n        return minDist if minDist < inf else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3686930,
                "title": "very-simple-solution-using-bfs-in-c",
                "content": "# Intuition\\n  The problem is really easy if you can walk yourself through example test case 1 and example test case 2. Just follow how you can travel right, right, counter clockwise like the way example explains, and you will understand the problem.\\n\\n# Approach\\n Breadth first search\\n\\n# Complexity\\n- Time complexity:\\n  O(NxM)\\n\\n- Space complexity:\\n  O(NxM)\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MinimumMoves(int[][] grid) {\\n        //the problem is easy if we can understand how\\n        //the snakes position changes in each//\\n        //right, down, and rotate moves\\n        int n = grid.Length;\\n        Queue<(int r1, int c1, int r2, int c2, int move)> q = \\n        new Queue<(int,int,int,int,int)>();\\n        q.Enqueue((0,0,0,1,0));\\n        HashSet<string> map = new HashSet<string>();\\n        while(q.Count > 0){\\n            int r1 = q.Peek().r1;\\n            int c1 = q.Peek().c1;\\n            int r2 = q.Peek().r2;\\n            int c2 = q.Peek().c2;\\n            int move = q.Peek().move;\\n            if(r1 == n-1 && c1 == n-2 && r2 ==n-1 && c2 == n-1) {\\n                return move;\\n            }\\n\\n            q.Dequeue();\\n            string key = \"R1C1-\"+r1+\"-\"+c1+\"-R2C2-\"+r2+\"-\"+c2;\\n            if(map.Contains(key)) continue;\\n            map.Add(key);\\n            //when snake is flat or in right position\\n            if(r1 == r2){\\n                if(c2+1 < n && c1+1 < n &&  grid[r1][c1+1]== 0 &&grid[r2][c2+1] == 0){\\n                    q.Enqueue((r1,c1+1,r2, c2+1,move+1));\\n                }\\n                //check down position\\n                if(r1+1 < n && r2+1 < n && grid[r1+1][c1] == 0 && grid[r2+1][c2] == 0){\\n                    q.Enqueue((r1+1, c1, r2+1, c2, move+1));\\n                    //we can also do rotate clockwise - intuition careful observation from example 1 test case\\n                    q.Enqueue((r1, c1, r2+1, c1, move+1));\\n                }\\n            }\\n            //when snake is in vertical position\\n            if(c1 == c2){\\n                if(c2+1 < n && c1+1 < n &&  grid[r1][c1+1]== 0 && grid[r2][c2+1] == 0){\\n                    q.Enqueue((r1,c1+1,r2, c2+1,move+1));\\n                    //this is rotate counter clockwise\\n                    q.Enqueue((r1,c1, r1, c2+1,move+1));\\n                }\\n                //check down position\\n                if(r1+1 < n && r2+1 < n && grid[r1+1][c1] == 0 && grid[r2+1][c2] == 0){\\n                    q.Enqueue((r1+1, c1, r2+1, c2, move+1));\\n                }                \\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Breadth-First Search"
                ],
                "code": "```\\npublic class Solution {\\n    public int MinimumMoves(int[][] grid) {\\n        //the problem is easy if we can understand how\\n        //the snakes position changes in each//\\n        //right, down, and rotate moves\\n        int n = grid.Length;\\n        Queue<(int r1, int c1, int r2, int c2, int move)> q = \\n        new Queue<(int,int,int,int,int)>();\\n        q.Enqueue((0,0,0,1,0));\\n        HashSet<string> map = new HashSet<string>();\\n        while(q.Count > 0){\\n            int r1 = q.Peek().r1;\\n            int c1 = q.Peek().c1;\\n            int r2 = q.Peek().r2;\\n            int c2 = q.Peek().c2;\\n            int move = q.Peek().move;\\n            if(r1 == n-1 && c1 == n-2 && r2 ==n-1 && c2 == n-1) {\\n                return move;\\n            }\\n\\n            q.Dequeue();\\n            string key = \"R1C1-\"+r1+\"-\"+c1+\"-R2C2-\"+r2+\"-\"+c2;\\n            if(map.Contains(key)) continue;\\n            map.Add(key);\\n            //when snake is flat or in right position\\n            if(r1 == r2){\\n                if(c2+1 < n && c1+1 < n &&  grid[r1][c1+1]== 0 &&grid[r2][c2+1] == 0){\\n                    q.Enqueue((r1,c1+1,r2, c2+1,move+1));\\n                }\\n                //check down position\\n                if(r1+1 < n && r2+1 < n && grid[r1+1][c1] == 0 && grid[r2+1][c2] == 0){\\n                    q.Enqueue((r1+1, c1, r2+1, c2, move+1));\\n                    //we can also do rotate clockwise - intuition careful observation from example 1 test case\\n                    q.Enqueue((r1, c1, r2+1, c1, move+1));\\n                }\\n            }\\n            //when snake is in vertical position\\n            if(c1 == c2){\\n                if(c2+1 < n && c1+1 < n &&  grid[r1][c1+1]== 0 && grid[r2][c2+1] == 0){\\n                    q.Enqueue((r1,c1+1,r2, c2+1,move+1));\\n                    //this is rotate counter clockwise\\n                    q.Enqueue((r1,c1, r1, c2+1,move+1));\\n                }\\n                //check down position\\n                if(r1+1 < n && r2+1 < n && grid[r1+1][c1] == 0 && grid[r2+1][c2] == 0){\\n                    q.Enqueue((r1+1, c1, r2+1, c2, move+1));\\n                }                \\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3513592,
                "title": "c-simple-bfs",
                "content": "# Approach\\nUsual BFS where graph vertices are described by the following struct\\n```\\nstruct Position {\\n    vector<int> a; //tail of the snake\\n    vector<int> b; //head\\n}\\n``` \\nTo keep track of visited vertices, use a hash function.\\n\\n# Complexity\\n- Time complexity: $$O(nm)$$\\n\\n- Space complexity: $$O(nm)$$\\n\\n# Code\\n```\\nusing lli = long long int;\\nconst lli base = 101;\\nconst lli mod = 1e9+7;\\n\\nstruct Position {\\n    vector<int> a;\\n    vector<int> b;\\n};\\n\\nbool ver(Position& pos) {\\n    return (pos.b[0]-pos.a[0] == 1);\\n}\\n\\nbool hor(Position& pos) {\\n    return (pos.b[1]-pos.a[1] == 1);\\n}\\n\\nlli myhash(Position& pos) {\\n    lli k = 1;\\n    lli h = 0;\\n    for (int x : pos.a) {\\n        h = (h + k*((lli)x))%mod;\\n        k = (k*base)%mod;\\n    }\\n    for (int x : pos.b) {\\n        h = (h + k*((lli)x))%mod;\\n        k = (k*base)%mod;\\n    }\\n    return h; \\n}\\n\\n\\nclass Solution {\\npublic:\\n    int minimumMoves(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        function<vector<Position>(Position&)> neighbors = [&](Position& pos) -> vector<Position> {\\n            vector<Position> res;\\n            Position down = pos;\\n            down.a[0]++;\\n            down.b[0]++;\\n            if (down.a[0] < m && down.b[0] < m && grid[down.a[0]][down.a[1]] == 0 && grid[down.b[0]][down.b[1]] == 0) {\\n                res.push_back(down);\\n                if (hor(pos)) res.push_back({pos.a, {pos.a[0]+1, pos.a[1]}}); \\n            }\\n            Position right = pos;\\n            right.a[1]++;\\n            right.b[1]++; \\n            if (right.a[1] < n && right.b[1] < n && grid[right.a[0]][right.a[1]] == 0 && grid[right.b[0]][right.b[1]] == 0) {\\n                res.push_back(right);\\n                if (ver(pos)) res.push_back({pos.a, {pos.a[0], pos.a[1]+1}}); \\n            }\\n            return res;\\n        };\\n        unordered_map<lli,int> dist;\\n        deque<Position> q(1, {{0,0},{0,1}});\\n        dist[myhash(q[0])] = 0; \\n        while(!q.empty()) {\\n            Position pos = q[0];\\n            lli curh = myhash(q[0]); \\n            q.pop_front();\\n            vector<Position> ngh = neighbors(pos);\\n            for (Position& nxt : ngh) {\\n                lli h = myhash(nxt);\\n                if (dist.find(h) == dist.end()) {\\n                    dist[h] = dist[curh]+1;\\n                    q.push_back(nxt); \\n                }\\n            }\\n        }\\n        Position t = {{n-1, n-2}, {n-1, n-1}}; \\n        lli th = myhash(t);\\n        if (dist.find(th) == dist.end()) return -1;\\n        return dist[th]; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nstruct Position {\\n    vector<int> a; //tail of the snake\\n    vector<int> b; //head\\n}\\n```\n```\\nusing lli = long long int;\\nconst lli base = 101;\\nconst lli mod = 1e9+7;\\n\\nstruct Position {\\n    vector<int> a;\\n    vector<int> b;\\n};\\n\\nbool ver(Position& pos) {\\n    return (pos.b[0]-pos.a[0] == 1);\\n}\\n\\nbool hor(Position& pos) {\\n    return (pos.b[1]-pos.a[1] == 1);\\n}\\n\\nlli myhash(Position& pos) {\\n    lli k = 1;\\n    lli h = 0;\\n    for (int x : pos.a) {\\n        h = (h + k*((lli)x))%mod;\\n        k = (k*base)%mod;\\n    }\\n    for (int x : pos.b) {\\n        h = (h + k*((lli)x))%mod;\\n        k = (k*base)%mod;\\n    }\\n    return h; \\n}\\n\\n\\nclass Solution {\\npublic:\\n    int minimumMoves(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        function<vector<Position>(Position&)> neighbors = [&](Position& pos) -> vector<Position> {\\n            vector<Position> res;\\n            Position down = pos;\\n            down.a[0]++;\\n            down.b[0]++;\\n            if (down.a[0] < m && down.b[0] < m && grid[down.a[0]][down.a[1]] == 0 && grid[down.b[0]][down.b[1]] == 0) {\\n                res.push_back(down);\\n                if (hor(pos)) res.push_back({pos.a, {pos.a[0]+1, pos.a[1]}}); \\n            }\\n            Position right = pos;\\n            right.a[1]++;\\n            right.b[1]++; \\n            if (right.a[1] < n && right.b[1] < n && grid[right.a[0]][right.a[1]] == 0 && grid[right.b[0]][right.b[1]] == 0) {\\n                res.push_back(right);\\n                if (ver(pos)) res.push_back({pos.a, {pos.a[0], pos.a[1]+1}}); \\n            }\\n            return res;\\n        };\\n        unordered_map<lli,int> dist;\\n        deque<Position> q(1, {{0,0},{0,1}});\\n        dist[myhash(q[0])] = 0; \\n        while(!q.empty()) {\\n            Position pos = q[0];\\n            lli curh = myhash(q[0]); \\n            q.pop_front();\\n            vector<Position> ngh = neighbors(pos);\\n            for (Position& nxt : ngh) {\\n                lli h = myhash(nxt);\\n                if (dist.find(h) == dist.end()) {\\n                    dist[h] = dist[curh]+1;\\n                    q.push_back(nxt); \\n                }\\n            }\\n        }\\n        Position t = {{n-1, n-2}, {n-1, n-1}}; \\n        lli th = myhash(t);\\n        if (dist.find(th) == dist.end()) return -1;\\n        return dist[th]; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3452663,
                "title": "easy-to-understand-faster-simple-python-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def minimumMoves(self, G: List[List[int]]) -> int:\\n    \\tN, I, DP = len(G)-1, math.inf, [[math.inf]*2 for i in range(len(G)+1)]\\n    \\tDP[N-1][0] = I if 1 in [G[N][N],G[N][N-1]] else 0\\n    \\tfor j in range(N-2,-1,-1): DP[j][0] = (DP[j+1][0] + 1) if G[N][j] == 0 else I\\n    \\tfor i,j in itertools.product(range(N-1,-1,-1),range(N,-1,-1)):\\n    \\t\\tn = [G[i][j],G[i][min(j+1,N)],G[min(i+1,N)][j],G[min(i+1,N)][min(j+1,N)]]\\n    \\t\\tDP[j][0], DP[j][1] = min(1+DP[j+1][0],1+DP[j][0]), min(1+DP[j+1][1],1+DP[j][1])\\n    \\t\\tif 1 not in n: DP[j][0], DP[j][1] = min(DP[j][0],2+DP[j+1][1],1+DP[j][1]), min(DP[j][1],2+DP[j+1][0],1+DP[j][0])\\n    \\t\\tif 1 in [n[0],n[1]]: DP[j][0] = I\\n    \\t\\tif 1 in [n[0],n[2]]: DP[j][1] = I\\n    \\treturn -1 if DP[0][0] == I else DP[0][0]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumMoves(self, G: List[List[int]]) -> int:\\n    \\tN, I, DP = len(G)-1, math.inf, [[math.inf]*2 for i in range(len(G)+1)]\\n    \\tDP[N-1][0] = I if 1 in [G[N][N],G[N][N-1]] else 0\\n    \\tfor j in range(N-2,-1,-1): DP[j][0] = (DP[j+1][0] + 1) if G[N][j] == 0 else I\\n    \\tfor i,j in itertools.product(range(N-1,-1,-1),range(N,-1,-1)):\\n    \\t\\tn = [G[i][j],G[i][min(j+1,N)],G[min(i+1,N)][j],G[min(i+1,N)][min(j+1,N)]]\\n    \\t\\tDP[j][0], DP[j][1] = min(1+DP[j+1][0],1+DP[j][0]), min(1+DP[j+1][1],1+DP[j][1])\\n    \\t\\tif 1 not in n: DP[j][0], DP[j][1] = min(DP[j][0],2+DP[j+1][1],1+DP[j][1]), min(DP[j][1],2+DP[j+1][0],1+DP[j][0])\\n    \\t\\tif 1 in [n[0],n[1]]: DP[j][0] = I\\n    \\t\\tif 1 in [n[0],n[2]]: DP[j][1] = I\\n    \\treturn -1 if DP[0][0] == I else DP[0][0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3389753,
                "title": "time-o-n2-o-n2-space-o-n2-o-n2",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfrom enum import IntEnum\\n\\n\\nclass Pos(IntEnum):\\n  kHorizontal = 0\\n  kVertical = 1\\n\\n\\nclass Solution:\\n  def minimumMoves(self, grid: List[List[int]]) -> int:\\n    n = len(grid)\\n    ans = 0\\n    # State of (x, y, pos)\\n    # Pos := 0 (horizontal) // 1 (vertical)\\n    q = collections.deque([(0, 0, Pos.kHorizontal)])\\n    seen = {(0, 0, Pos.kHorizontal)}\\n\\n    def canMoveRight(x: int, y: int, pos: Pos) -> bool:\\n      if pos == Pos.kHorizontal:\\n        return y + 2 < n and not grid[x][y + 2]\\n      return y + 1 < n and not grid[x][y + 1] and not grid[x + 1][y + 1]\\n\\n    def canMoveDown(x: int, y: int, pos: Pos) -> bool:\\n      if pos == Pos.kVertical:\\n        return x + 2 < n and not grid[x + 2][y]\\n      return x + 1 < n and not grid[x + 1][y] and not grid[x + 1][y + 1]\\n\\n    def canRotateClockwise(x: int, y: int, pos: Pos) -> bool:\\n      return pos == Pos.kHorizontal and x + 1 < n and \\\\\\n          not grid[x + 1][y + 1] and not grid[x + 1][y]\\n\\n    def canRotateCounterclockwise(x: int, y: int, pos: Pos) -> bool:\\n      return pos == Pos.kVertical and y + 1 < n and \\\\\\n          not grid[x + 1][y + 1] and not grid[x][y + 1]\\n\\n    while q:\\n      for _ in range(len(q)):\\n        x, y, pos = q.popleft()\\n        if x == n - 1 and y == n - 2 and pos == Pos.kHorizontal:\\n          return ans\\n        if canMoveRight(x, y, pos) and (x, y + 1, pos) not in seen:\\n          q.append((x, y + 1, pos))\\n          seen.add((x, y + 1, pos))\\n        if canMoveDown(x, y, pos) and (x + 1, y, pos) not in seen:\\n          q.append((x + 1, y, pos))\\n          seen.add((x + 1, y, pos))\\n        newPos = Pos.kVertical if pos == Pos.kHorizontal else Pos.kHorizontal\\n        if (canRotateClockwise(x, y, pos) or canRotateCounterclockwise(x, y, pos)) and \\\\\\n                (x, y, newPos) not in seen:\\n          q.append((x, y, newPos))\\n          seen.add((x, y, newPos))\\n      ans += 1\\n\\n    return -1\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom enum import IntEnum\\n\\n\\nclass Pos(IntEnum):\\n  kHorizontal = 0\\n  kVertical = 1\\n\\n\\nclass Solution:\\n  def minimumMoves(self, grid: List[List[int]]) -> int:\\n    n = len(grid)\\n    ans = 0\\n    # State of (x, y, pos)\\n    # Pos := 0 (horizontal) // 1 (vertical)\\n    q = collections.deque([(0, 0, Pos.kHorizontal)])\\n    seen = {(0, 0, Pos.kHorizontal)}\\n\\n    def canMoveRight(x: int, y: int, pos: Pos) -> bool:\\n      if pos == Pos.kHorizontal:\\n        return y + 2 < n and not grid[x][y + 2]\\n      return y + 1 < n and not grid[x][y + 1] and not grid[x + 1][y + 1]\\n\\n    def canMoveDown(x: int, y: int, pos: Pos) -> bool:\\n      if pos == Pos.kVertical:\\n        return x + 2 < n and not grid[x + 2][y]\\n      return x + 1 < n and not grid[x + 1][y] and not grid[x + 1][y + 1]\\n\\n    def canRotateClockwise(x: int, y: int, pos: Pos) -> bool:\\n      return pos == Pos.kHorizontal and x + 1 < n and \\\\\\n          not grid[x + 1][y + 1] and not grid[x + 1][y]\\n\\n    def canRotateCounterclockwise(x: int, y: int, pos: Pos) -> bool:\\n      return pos == Pos.kVertical and y + 1 < n and \\\\\\n          not grid[x + 1][y + 1] and not grid[x][y + 1]\\n\\n    while q:\\n      for _ in range(len(q)):\\n        x, y, pos = q.popleft()\\n        if x == n - 1 and y == n - 2 and pos == Pos.kHorizontal:\\n          return ans\\n        if canMoveRight(x, y, pos) and (x, y + 1, pos) not in seen:\\n          q.append((x, y + 1, pos))\\n          seen.add((x, y + 1, pos))\\n        if canMoveDown(x, y, pos) and (x + 1, y, pos) not in seen:\\n          q.append((x + 1, y, pos))\\n          seen.add((x + 1, y, pos))\\n        newPos = Pos.kVertical if pos == Pos.kHorizontal else Pos.kHorizontal\\n        if (canRotateClockwise(x, y, pos) or canRotateCounterclockwise(x, y, pos)) and \\\\\\n                (x, y, newPos) not in seen:\\n          q.append((x, y, newPos))\\n          seen.add((x, y, newPos))\\n      ans += 1\\n\\n    return -1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3281652,
                "title": "python-simple-dijkstra-s-algorithm",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumMoves(self, grid):\\n        n = len(grid)\\n        dict1, stack = {(0,0,0,1):0}, [(0,0,0,0,1)]\\n\\n        while stack:\\n            steps,i,j,ii,jj = heappop(stack)\\n            if i == n-1 and j == n-2 and ii == n-1 and jj == n-1: return steps\\n            if ii+1 < n and grid[i+1][j] == grid[ii+1][jj] == 0 and steps + 1 < dict1.get((i+1,j,ii+1,jj),float(\"inf\")):\\n                heappush(stack,(steps+1,i+1,j,ii+1,jj))\\n                dict1[(i+1,j,ii+1,jj)] = steps + 1\\n            if jj+1 < n and grid[i][j+1] == grid[ii][jj+1] == 0 and steps + 1 < dict1.get((i,j+1,ii,jj+1),float(\"inf\")):\\n                heappush(stack,(steps+1,i,j+1,ii,jj+1))\\n                dict1[(i,j+1,ii,jj+1)] = steps + 1\\n            if i == ii and ii+1 < n and grid[i+1][j] == grid[i+1][jj] == 0 and steps + 1 < dict1.get((i,j,i+1,j),float(\"inf\")):\\n                heappush(stack,(steps+1,i,j,i+1,j))\\n                dict1[(i,j,i+1,j)] = steps + 1\\n            if j == jj and jj+1 < n and grid[i][j+1] == grid[ii][jj+1] == 0 and steps + 1 < dict1.get((i,j,i,j+1),float(\"inf\")):\\n                heappush(stack,(steps+1,i,j,i,j+1))\\n                dict1[(i,j,i,j+1)] = steps + 1\\n\\n        return -1\\n            \\n\\n\\n\\n\\n\\n\\n\\n        \\n\\n\\n\\n\\n        \\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumMoves(self, grid):\\n        n = len(grid)\\n        dict1, stack = {(0,0,0,1):0}, [(0,0,0,0,1)]\\n\\n        while stack:\\n            steps,i,j,ii,jj = heappop(stack)\\n            if i == n-1 and j == n-2 and ii == n-1 and jj == n-1: return steps\\n            if ii+1 < n and grid[i+1][j] == grid[ii+1][jj] == 0 and steps + 1 < dict1.get((i+1,j,ii+1,jj),float(\"inf\")):\\n                heappush(stack,(steps+1,i+1,j,ii+1,jj))\\n                dict1[(i+1,j,ii+1,jj)] = steps + 1\\n            if jj+1 < n and grid[i][j+1] == grid[ii][jj+1] == 0 and steps + 1 < dict1.get((i,j+1,ii,jj+1),float(\"inf\")):\\n                heappush(stack,(steps+1,i,j+1,ii,jj+1))\\n                dict1[(i,j+1,ii,jj+1)] = steps + 1\\n            if i == ii and ii+1 < n and grid[i+1][j] == grid[i+1][jj] == 0 and steps + 1 < dict1.get((i,j,i+1,j),float(\"inf\")):\\n                heappush(stack,(steps+1,i,j,i+1,j))\\n                dict1[(i,j,i+1,j)] = steps + 1\\n            if j == jj and jj+1 < n and grid[i][j+1] == grid[ii][jj+1] == 0 and steps + 1 < dict1.get((i,j,i,j+1),float(\"inf\")):\\n                heappush(stack,(steps+1,i,j,i,j+1))\\n                dict1[(i,j,i,j+1)] = steps + 1\\n\\n        return -1\\n            \\n\\n\\n\\n\\n\\n\\n\\n        \\n\\n\\n\\n\\n        \\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3130672,
                "title": "java-ez-2-understand",
                "content": "```\\nclass Solution {\\n    public int minimumMoves(int[][] grid) {\\n        int n=grid.length;\\n        Queue<State> queue=new LinkedList<>();\\n        boolean vis[][][]=new boolean[n+1][n+1][2];\\n        //1 hori\\n        //0 vert\\n        State strt=new State(0,1,1),end=new State(n-1,n-1,1);\\n        queue.add(strt);\\n        int level=0;\\n        while(queue.size()!=0){\\n            int len=queue.size();\\n            while(len-->0){\\n                State temp=queue.remove();\\n                int i=temp.r,j=temp.c;\\n               // System.out.print(i+\" \"+j+\" \"+temp.ori+\" level \"+level);\\n                if(temp.r==end.r && temp.c==end.c && temp.ori==end.ori)\\n                    return level;\\n                if(temp.ori==1){\\n                    //rotate\\n                    if(i+1<n && j-1>=0 && grid[i+1][j]==0 && grid[i+1][j-1]==0 && !vis[i+1][j-1][0]){\\n                        queue.add(new State(i+1,j-1,0));\\n                        vis[i+1][j-1][0]=true;\\n                    }\\n                    //right\\n                    if(j+1<n && !vis[i][j+1][temp.ori] && grid[i][j+1]==0){\\n                        queue.add(new State(i,j+1,1));\\n                        vis[i][j+1][1]=true;\\n                    }\\n                    //down\\n                    if(j-1>=0 && i+1<n && grid[i+1][j]==0 && grid[i+1][j-1]==0 && !vis[i+1][j][1]){\\n                        queue.add(new State(i+1,j,1));\\n                        vis[i+1][j][1]=true;\\n                    }\\n                    \\n                }else{\\n                    //rotate\\n                     if(i-1>=0 && j+1<n && grid[i-1][j+1]==0 && grid[i][j+1]==0 && !vis[i-1][j+1][1]){\\n                        queue.add(new State(i-1,j+1,1));\\n                         vis[i-1][j+1][1]=true;\\n                     }\\n                     //down\\n                     if(i+1<n && !vis[i+1][j][temp.ori] && grid[i+1][j]==0){\\n                         queue.add(new State(i+1,j,0));\\n                         vis[i+1][j][0]=true;\\n                     }\\n                    //right\\n                    if(j+1<n && i-1>=0 && grid[i-1][j+1]==0 && grid[i][j+1]==0 && !vis[i][j+1][temp.ori]){\\n                        queue.add(new State(i,j+1,temp.ori));\\n                        vis[i][j+1][temp.ori]=true;\\n                    }\\n                }\\n            }\\n            //System.out.println();\\n            level++;\\n        }\\n        return -1;\\n        \\n    }\\n    class State{\\n        int r;\\n        int c;\\n        int ori;\\n        State(int r,int c,int ori){\\n            this.r=r;\\n            this.c=c;\\n            this.ori=ori;\\n        }\\n    }\\n}```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumMoves(int[][] grid) {\\n        int n=grid.length;\\n        Queue<State> queue=new LinkedList<>();\\n        boolean vis[][][]=new boolean[n+1][n+1][2];\\n        //1 hori\\n        //0 vert\\n        State strt=new State(0,1,1),end=new State(n-1,n-1,1);\\n        queue.add(strt);\\n        int level=0;\\n        while(queue.size()!=0){\\n            int len=queue.size();\\n            while(len-->0){\\n                State temp=queue.remove();\\n                int i=temp.r,j=temp.c;\\n               // System.out.print(i+\" \"+j+\" \"+temp.ori+\" level \"+level);\\n                if(temp.r==end.r && temp.c==end.c && temp.ori==end.ori)\\n                    return level;\\n                if(temp.ori==1){\\n                    //rotate\\n                    if(i+1<n && j-1>=0 && grid[i+1][j]==0 && grid[i+1][j-1]==0 && !vis[i+1][j-1][0]){\\n                        queue.add(new State(i+1,j-1,0));\\n                        vis[i+1][j-1][0]=true;\\n                    }\\n                    //right\\n                    if(j+1<n && !vis[i][j+1][temp.ori] && grid[i][j+1]==0){\\n                        queue.add(new State(i,j+1,1));\\n                        vis[i][j+1][1]=true;\\n                    }\\n                    //down\\n                    if(j-1>=0 && i+1<n && grid[i+1][j]==0 && grid[i+1][j-1]==0 && !vis[i+1][j][1]){\\n                        queue.add(new State(i+1,j,1));\\n                        vis[i+1][j][1]=true;\\n                    }\\n                    \\n                }else{\\n                    //rotate\\n                     if(i-1>=0 && j+1<n && grid[i-1][j+1]==0 && grid[i][j+1]==0 && !vis[i-1][j+1][1]){\\n                        queue.add(new State(i-1,j+1,1));\\n                         vis[i-1][j+1][1]=true;\\n                     }\\n                     //down\\n                     if(i+1<n && !vis[i+1][j][temp.ori] && grid[i+1][j]==0){\\n                         queue.add(new State(i+1,j,0));\\n                         vis[i+1][j][0]=true;\\n                     }\\n                    //right\\n                    if(j+1<n && i-1>=0 && grid[i-1][j+1]==0 && grid[i][j+1]==0 && !vis[i][j+1][temp.ori]){\\n                        queue.add(new State(i,j+1,temp.ori));\\n                        vis[i][j+1][temp.ori]=true;\\n                    }\\n                }\\n            }\\n            //System.out.println();\\n            level++;\\n        }\\n        return -1;\\n        \\n    }\\n    class State{\\n        int r;\\n        int c;\\n        int ori;\\n        State(int r,int c,int ori){\\n            this.r=r;\\n            this.c=c;\\n            this.ori=ori;\\n        }\\n    }\\n}```",
                "codeTag": "Java"
            },
            {
                "id": 3067724,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn minimum_moves(grid: Vec<Vec<i32>>) -> i32 {\\n        use std::collections::{HashMap, VecDeque};\\n        let n = grid.len();\\n        let mut ans = 0;\\n        let mut mp = HashMap::<(i32, (i32, i32)), i32>::new();\\n        let mut q = VecDeque::new();\\n        q.push_back((0, (0, 1)));\\n        mp.insert((0, (0, 1)), 1);\\n        while !q.is_empty() {\\n            let mut m = q.len();\\n            while m > 0 {\\n                let (pos, (x, y)) = q.pop_front().unwrap();\\n                if x == (n - 1) as i32 && y == (n - 1) as i32 && pos == 0 {\\n                    return ans;\\n                }\\n                if pos == 0 {\\n                    if y + 1 < n as i32 && grid[x as usize][y as usize + 1] == 0 && mp.get(&(0, (x, y + 1))).is_none() {\\n                        q.push_back((0, (x, y + 1)));\\n                        mp.insert((0, (x, y + 1)), 1);\\n                    }\\n                    if x + 1 < n as i32\\n                        && grid[x as usize + 1][y as usize] == 0\\n                        && grid[x as usize + 1][y as usize - 1] == 0\\n                        && mp.get(&(0, (x + 1, y))).is_none()\\n                    {\\n                        q.push_back((0, (x + 1, y)));\\n                        mp.insert((0, (x + 1, y)), 1);\\n                    }\\n                    if x + 1 < n as i32\\n                        && grid[x as usize + 1][y as usize] == 0\\n                        && grid[x as usize + 1][y as usize - 1] == 0\\n                        && mp.get(&(1, (x + 1, y - 1))).is_none()\\n                    {\\n                        q.push_back((1, (x + 1, y - 1)));\\n                        mp.insert((1, (x + 1, y - 1)), 1);\\n                    }\\n                } else {\\n                    if x + 1 < n as i32 && grid[x as usize + 1][y as usize] == 0 && mp.get(&(1, (x + 1, y))).is_none() {\\n                        q.push_back((1, (x + 1, y)));\\n                        mp.insert((1, (x + 1, y)), 1);\\n                    }\\n                    if y + 1 < n as i32\\n                        && grid[x as usize][y as usize + 1] == 0\\n                        && grid[x as usize - 1][y as usize + 1] == 0\\n                        && mp.get(&(1, (x, y + 1))).is_none()\\n                    {\\n                        q.push_back((1, (x, y + 1)));\\n                        mp.insert((1, (x, y + 1)), 1);\\n                    }\\n                    if y + 1 < n as i32\\n                        && grid[x as usize][y as usize + 1] == 0\\n                        && grid[x as usize - 1][y as usize + 1] == 0\\n                        && mp.get(&(0, (x - 1, y + 1))).is_none()\\n                    {\\n                        q.push_back((0, (x - 1, y + 1)));\\n                        mp.insert((0, (x - 1, y + 1)), 1);\\n                    }\\n                }\\n                m -= 1;\\n            }\\n            ans += 1;\\n        }\\n        -1\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn minimum_moves(grid: Vec<Vec<i32>>) -> i32 {\\n        use std::collections::{HashMap, VecDeque};\\n        let n = grid.len();\\n        let mut ans = 0;\\n        let mut mp = HashMap::<(i32, (i32, i32)), i32>::new();\\n        let mut q = VecDeque::new();\\n        q.push_back((0, (0, 1)));\\n        mp.insert((0, (0, 1)), 1);\\n        while !q.is_empty() {\\n            let mut m = q.len();\\n            while m > 0 {\\n                let (pos, (x, y)) = q.pop_front().unwrap();\\n                if x == (n - 1) as i32 && y == (n - 1) as i32 && pos == 0 {\\n                    return ans;\\n                }\\n                if pos == 0 {\\n                    if y + 1 < n as i32 && grid[x as usize][y as usize + 1] == 0 && mp.get(&(0, (x, y + 1))).is_none() {\\n                        q.push_back((0, (x, y + 1)));\\n                        mp.insert((0, (x, y + 1)), 1);\\n                    }\\n                    if x + 1 < n as i32\\n                        && grid[x as usize + 1][y as usize] == 0\\n                        && grid[x as usize + 1][y as usize - 1] == 0\\n                        && mp.get(&(0, (x + 1, y))).is_none()\\n                    {\\n                        q.push_back((0, (x + 1, y)));\\n                        mp.insert((0, (x + 1, y)), 1);\\n                    }\\n                    if x + 1 < n as i32\\n                        && grid[x as usize + 1][y as usize] == 0\\n                        && grid[x as usize + 1][y as usize - 1] == 0\\n                        && mp.get(&(1, (x + 1, y - 1))).is_none()\\n                    {\\n                        q.push_back((1, (x + 1, y - 1)));\\n                        mp.insert((1, (x + 1, y - 1)), 1);\\n                    }\\n                } else {\\n                    if x + 1 < n as i32 && grid[x as usize + 1][y as usize] == 0 && mp.get(&(1, (x + 1, y))).is_none() {\\n                        q.push_back((1, (x + 1, y)));\\n                        mp.insert((1, (x + 1, y)), 1);\\n                    }\\n                    if y + 1 < n as i32\\n                        && grid[x as usize][y as usize + 1] == 0\\n                        && grid[x as usize - 1][y as usize + 1] == 0\\n                        && mp.get(&(1, (x, y + 1))).is_none()\\n                    {\\n                        q.push_back((1, (x, y + 1)));\\n                        mp.insert((1, (x, y + 1)), 1);\\n                    }\\n                    if y + 1 < n as i32\\n                        && grid[x as usize][y as usize + 1] == 0\\n                        && grid[x as usize - 1][y as usize + 1] == 0\\n                        && mp.get(&(0, (x - 1, y + 1))).is_none()\\n                    {\\n                        q.push_back((0, (x - 1, y + 1)));\\n                        mp.insert((0, (x - 1, y + 1)), 1);\\n                    }\\n                }\\n                m -= 1;\\n            }\\n            ans += 1;\\n        }\\n        -1\\n    }\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3062624,
                "title": "multi-source-bfs-c-simple-clean-short-fast",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    #define ll long long\\n\\n    vector<vector<ll>>dx={{0,1},{0,-1},{0,0},{1,1}},dy={{0,-1},{0,1},{1,1},{0,0}};\\n\\n    bool issafe(ll a,ll b,ll c,ll d,ll n,ll m,vector<vector<int>>&grid){\\n        return a>=0 && a<n && b>=0 && b<n && c>=0 && c<m && d>=0 && d<m && grid[a][c]==0 && grid[b][d]==0;\\n    }\\n    \\n    int minimumMoves(vector<vector<int>>& grid) {\\n        ll n=grid.size(),m=grid[0].size(),dist=0;\\n        queue<vector<ll>>q;q.push({0,0,0,1});\\n        vector<vector<vector<bool>>>visited(n,vector<vector<bool>>(n,vector<bool>(2,false)));\\n        while(!q.empty()){\\n            ll size=q.size();\\n            while(size--){\\n                auto temp=q.front();q.pop();\\n                if(visited[temp[2]][temp[3]][(temp[2]==temp[0]?0:1)]==true){\\n                    continue;\\n                }\\n                if(temp[0]==n-1 && temp[1]==m-2 && temp[2]==n-1 && temp[3]==m-1){\\n                    return dist;\\n                }    \\n                for(ll i=0;i<4;i++){\\n                    if((temp[0]==temp[2] && i==1) || (temp[1]==temp[3] && i==0)){\\n                        continue;\\n                    }\\n                    ll x1=temp[0]+dx[i][0],x2=temp[2]+dx[i][1],y1=temp[1]+dy[i][0],y2=temp[3]+dy[i][1];\\n                    if(issafe(x1,x2,y1,y2,n,m,grid) && visited[x2][y2][(x2==x1?0:1)]==false){\\n                        if(i<=1){\\n                            if(grid[temp[0]+1][temp[1]+1]==1){\\n                                continue;\\n                            }\\n                        }\\n                        q.push({x1,y1,x2,y2});\\n                    }\\n                }\\n                visited[temp[2]][temp[3]][(temp[2]==temp[0]?0:1)]=true;\\n            }\\n            dist++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    #define ll long long\\n\\n    vector<vector<ll>>dx={{0,1},{0,-1},{0,0},{1,1}},dy={{0,-1},{0,1},{1,1},{0,0}};\\n\\n    bool issafe(ll a,ll b,ll c,ll d,ll n,ll m,vector<vector<int>>&grid){\\n        return a>=0 && a<n && b>=0 && b<n && c>=0 && c<m && d>=0 && d<m && grid[a][c]==0 && grid[b][d]==0;\\n    }\\n    \\n    int minimumMoves(vector<vector<int>>& grid) {\\n        ll n=grid.size(),m=grid[0].size(),dist=0;\\n        queue<vector<ll>>q;q.push({0,0,0,1});\\n        vector<vector<vector<bool>>>visited(n,vector<vector<bool>>(n,vector<bool>(2,false)));\\n        while(!q.empty()){\\n            ll size=q.size();\\n            while(size--){\\n                auto temp=q.front();q.pop();\\n                if(visited[temp[2]][temp[3]][(temp[2]==temp[0]?0:1)]==true){\\n                    continue;\\n                }\\n                if(temp[0]==n-1 && temp[1]==m-2 && temp[2]==n-1 && temp[3]==m-1){\\n                    return dist;\\n                }    \\n                for(ll i=0;i<4;i++){\\n                    if((temp[0]==temp[2] && i==1) || (temp[1]==temp[3] && i==0)){\\n                        continue;\\n                    }\\n                    ll x1=temp[0]+dx[i][0],x2=temp[2]+dx[i][1],y1=temp[1]+dy[i][0],y2=temp[3]+dy[i][1];\\n                    if(issafe(x1,x2,y1,y2,n,m,grid) && visited[x2][y2][(x2==x1?0:1)]==false){\\n                        if(i<=1){\\n                            if(grid[temp[0]+1][temp[1]+1]==1){\\n                                continue;\\n                            }\\n                        }\\n                        q.push({x1,y1,x2,y2});\\n                    }\\n                }\\n                visited[temp[2]][temp[3]][(temp[2]==temp[0]?0:1)]=true;\\n            }\\n            dist++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2928090,
                "title": "python-straight-bfs-solution-easy-to-understand",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nJust have right, down, clockwise and counter-clockwise as directions in the direction array and run a BFS\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumMoves(self, grid: List[List[int]]) -> int:\\n        side, queue = len(grid), deque([[(0, 0), (0, 1), 0]])\\n        visited = {((0, 0), (0, 1))}\\n        directions = [[(0, 1), (0, 1)], [(1, 0), (1, 0)], \\n                      [(0, 0), (1, -1)], [(0, 0), (-1, 1)]]\\n\\n        def validate(row1: int, col1: int, row2: int, col2: int, dirIndex: int) -> bool:\\n            if not (0 <= row1 < side and 0 <= col1 < side and 0 <= row2 < side and 0 <= col2 < side):\\n                return False\\n            if grid[row1][col1] != 0 or grid[row2][col2] != 0:\\n                return False\\n            if dirIndex >= 2:  # Edge Case 1\\n                if grid[row1 + 1][col1 + 1] == 1:\\n                    return False\\n            return True\\n        \\n        while queue:\\n            (row1, col1), (row2, col2), step = queue.popleft()\\n            if row1 == side - 1 and col1 == side - 2 and row2 == side - 1 and col2 == side - 1:\\n                return step\\n            for dirIndex in range(len(directions)):\\n                if dirIndex == 2:\\n                    if row1 != row2:\\n                        continue\\n                if dirIndex == 3:\\n                    if col1 != col2:\\n                        continue\\n                (drow1, dcol1), (drow2, dcol2) = directions[dirIndex]\\n                newRow1, newCol1 = row1 + drow1, col1 + dcol1\\n                newRow2, newCol2 = row2 + drow2, col2 + dcol2\\n                if validate(newRow1, newCol1, newRow2, newCol2, dirIndex) and ((newRow1, newCol1), (newRow2, newCol2)) not in visited:\\n                    visited.add(((newRow1, newCol1), (newRow2, newCol2)))\\n                    queue.append(((newRow1, newCol1), (newRow2, newCol2), step + 1))\\n        return -1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Breadth-First Search",
                    "Matrix"
                ],
                "code": "```\\nclass Solution:\\n    def minimumMoves(self, grid: List[List[int]]) -> int:\\n        side, queue = len(grid), deque([[(0, 0), (0, 1), 0]])\\n        visited = {((0, 0), (0, 1))}\\n        directions = [[(0, 1), (0, 1)], [(1, 0), (1, 0)], \\n                      [(0, 0), (1, -1)], [(0, 0), (-1, 1)]]\\n\\n        def validate(row1: int, col1: int, row2: int, col2: int, dirIndex: int) -> bool:\\n            if not (0 <= row1 < side and 0 <= col1 < side and 0 <= row2 < side and 0 <= col2 < side):\\n                return False\\n            if grid[row1][col1] != 0 or grid[row2][col2] != 0:\\n                return False\\n            if dirIndex >= 2:  # Edge Case 1\\n                if grid[row1 + 1][col1 + 1] == 1:\\n                    return False\\n            return True\\n        \\n        while queue:\\n            (row1, col1), (row2, col2), step = queue.popleft()\\n            if row1 == side - 1 and col1 == side - 2 and row2 == side - 1 and col2 == side - 1:\\n                return step\\n            for dirIndex in range(len(directions)):\\n                if dirIndex == 2:\\n                    if row1 != row2:\\n                        continue\\n                if dirIndex == 3:\\n                    if col1 != col2:\\n                        continue\\n                (drow1, dcol1), (drow2, dcol2) = directions[dirIndex]\\n                newRow1, newCol1 = row1 + drow1, col1 + dcol1\\n                newRow2, newCol2 = row2 + drow2, col2 + dcol2\\n                if validate(newRow1, newCol1, newRow2, newCol2, dirIndex) and ((newRow1, newCol1), (newRow2, newCol2)) not in visited:\\n                    visited.add(((newRow1, newCol1), (newRow2, newCol2)))\\n                    queue.append(((newRow1, newCol1), (newRow2, newCol2), step + 1))\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2856122,
                "title": "bfs-using-direction-array-clean-code",
                "content": "```\\n\\nclass Solution:\\n    def minimumMoves(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n        queue = deque([[(0, 0), (0, 1), 0]])\\n        visited = {((0, 0), (0, 1))}\\n        directions = [[(0, 1), (0, 1)], \\n                      [(1, 0), (1, 0)], \\n                      [(0, 0), (1, -1)], \\n                      [(0, 0), (-1, 1)]]\\n\\n        def validate(i1, j1, i2, j2, index):\\n            if not (0 <= i1 < n and 0 <= j1 < n and 0 <= i2 < n and 0 <= j2 < n):\\n                return False\\n            \\n            if grid[i1][j1] != 0 or grid[i2][j2] != 0:\\n                return False\\n            \\n            if index >= 2:  # Edge Case 1\\n                if grid[i1+1][j1+1] == 1:\\n                    return False\\n            \\n            return True\\n\\n        \\n        while queue:\\n            \\n            c1, c2, step = queue.popleft()\\n            i1, j1 = c1\\n            i2, j2 = c2\\n\\n            if i1 == n-1 and j1 == n-2 and i2 == n-1 and j2 == n-1:\\n                return step\\n\\n            for index in range(len(directions)):\\n                if index == 2:\\n                    if i1 != i2:\\n                        continue\\n                if index == 3:\\n                    if j1 != j2:\\n                        continue\\n                c1_drn, c2_drn = directions[index]\\n                i1_drn, j1_drn = c1_drn\\n                i2_drn, j2_drn = c2_drn\\n\\n                new_i1 = i1+i1_drn\\n                new_j1 = j1+j1_drn\\n\\n                new_i2 = i2+i2_drn\\n                new_j2 = j2+j2_drn\\n                if validate(new_i1, new_j1, new_i2, new_j2, index) and ((new_i1, new_j1), (new_i2, new_j2)) not in visited:\\n                    visited.add(((new_i1, new_j1), (new_i2, new_j2)))\\n                    # print(step, ((new_i1, new_j1), (new_i2, new_j2), step+1))\\n                    queue.append(((new_i1, new_j1), (new_i2, new_j2), step+1))\\n\\n        return -1\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Breadth-First Search"
                ],
                "code": "```\\n\\nclass Solution:\\n    def minimumMoves(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n        queue = deque([[(0, 0), (0, 1), 0]])\\n        visited = {((0, 0), (0, 1))}\\n        directions = [[(0, 1), (0, 1)], \\n                      [(1, 0), (1, 0)], \\n                      [(0, 0), (1, -1)], \\n                      [(0, 0), (-1, 1)]]\\n\\n        def validate(i1, j1, i2, j2, index):\\n            if not (0 <= i1 < n and 0 <= j1 < n and 0 <= i2 < n and 0 <= j2 < n):\\n                return False\\n            \\n            if grid[i1][j1] != 0 or grid[i2][j2] != 0:\\n                return False\\n            \\n            if index >= 2:  # Edge Case 1\\n                if grid[i1+1][j1+1] == 1:\\n                    return False\\n            \\n            return True\\n\\n        \\n        while queue:\\n            \\n            c1, c2, step = queue.popleft()\\n            i1, j1 = c1\\n            i2, j2 = c2\\n\\n            if i1 == n-1 and j1 == n-2 and i2 == n-1 and j2 == n-1:\\n                return step\\n\\n            for index in range(len(directions)):\\n                if index == 2:\\n                    if i1 != i2:\\n                        continue\\n                if index == 3:\\n                    if j1 != j2:\\n                        continue\\n                c1_drn, c2_drn = directions[index]\\n                i1_drn, j1_drn = c1_drn\\n                i2_drn, j2_drn = c2_drn\\n\\n                new_i1 = i1+i1_drn\\n                new_j1 = j1+j1_drn\\n\\n                new_i2 = i2+i2_drn\\n                new_j2 = j2+j2_drn\\n                if validate(new_i1, new_j1, new_i2, new_j2, index) and ((new_i1, new_j1), (new_i2, new_j2)) not in visited:\\n                    visited.add(((new_i1, new_j1), (new_i2, new_j2)))\\n                    # print(step, ((new_i1, new_j1), (new_i2, new_j2), step+1))\\n                    queue.append(((new_i1, new_j1), (new_i2, new_j2), step+1))\\n\\n        return -1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2759889,
                "title": "bfs-memoization",
                "content": "```\\nclass Solution {\\n    public int minimumMoves(int[][] grid) {\\n        Queue<int[]> q=new LinkedList<>();\\n        q.add(new int[]{0,0,0,1,0,0});\\n        int n=grid.length;\\n        boolean[][][] vis=new boolean[n][n][2];\\n        while(!q.isEmpty()){\\n            int[] cur=q.remove();\\n            int position=cur[4];\\n            // System.out.println(cur[0]+\",\"+cur[1]+\" | \"+cur[2]+\",\"+cur[3]+\" \"+(position==0?\"horizontal\":\"vertical\"));\\n            if(vis[cur[2]][cur[3]][position]){\\n                continue;\\n            }\\n            // System.out.println(cur[0]+\",\"+cur[1]+\" | \"+cur[2]+\",\"+cur[3]);\\n            vis[cur[2]][cur[3]][position]=true;\\n            if(cur[0]==n-1 && cur[1]==n-2 && cur[2]==n-1 && cur[3]==n-1){\\n                return cur[5];\\n            }\\n            //horizontal\\n            if(position==0){\\n                if(cur[2]+1<n && grid[cur[2]+1][cur[3]-1]+grid[cur[2]+1][cur[3]]==0){\\n                    q.add(new int[]{cur[0],cur[1],cur[2]+1,cur[3]-1,(position+1)%2,cur[5]+1});\\n                }\\n                if(cur[3]+1<n && grid[cur[2]][cur[3]+1]==0){\\n                    q.add(new int[]{cur[2],cur[3],cur[2],cur[3]+1,position,cur[5]+1});\\n                }\\n                if(cur[0]+1<n && cur[2]+1<n && grid[cur[0]+1][cur[1]]+grid[cur[2]+1][cur[3]]==0){\\n                    q.add(new int[]{cur[0]+1,cur[1],cur[2]+1,cur[3],position,cur[5]+1});\\n                }\\n            }\\n            //vertical\\n            else{\\n                if(cur[3]+1<n && grid[cur[2]-1][cur[3]+1]+grid[cur[2]][cur[3]+1]==0){\\n                    q.add(new int[]{cur[0],cur[1],cur[2]-1,cur[3]+1,(position+1)%2,cur[5]+1});\\n                }\\n                if(cur[2]+1<n && grid[cur[2]+1][cur[3]]==0){\\n                    q.add(new int[]{cur[2],cur[3],cur[2]+1,cur[3],position,cur[5]+1});\\n                }\\n                if(cur[1]+1<n && cur[3]+1<n && grid[cur[0]][cur[1]+1]+grid[cur[2]][cur[3]+1]==0){\\n                    q.add(new int[]{cur[0],cur[1]+1,cur[2],cur[3]+1,position,cur[5]+1});\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n    boolean isValid(int[] cur, int n){\\n        return cur[0]<n && cur[2]<n && cur[1]<n && cur[3]<n;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumMoves(int[][] grid) {\\n        Queue<int[]> q=new LinkedList<>();\\n        q.add(new int[]{0,0,0,1,0,0});\\n        int n=grid.length;\\n        boolean[][][] vis=new boolean[n][n][2];\\n        while(!q.isEmpty()){\\n            int[] cur=q.remove();\\n            int position=cur[4];\\n            // System.out.println(cur[0]+\",\"+cur[1]+\" | \"+cur[2]+\",\"+cur[3]+\" \"+(position==0?\"horizontal\":\"vertical\"));\\n            if(vis[cur[2]][cur[3]][position]){\\n                continue;\\n            }\\n            // System.out.println(cur[0]+\",\"+cur[1]+\" | \"+cur[2]+\",\"+cur[3]);\\n            vis[cur[2]][cur[3]][position]=true;\\n            if(cur[0]==n-1 && cur[1]==n-2 && cur[2]==n-1 && cur[3]==n-1){\\n                return cur[5];\\n            }\\n            //horizontal\\n            if(position==0){\\n                if(cur[2]+1<n && grid[cur[2]+1][cur[3]-1]+grid[cur[2]+1][cur[3]]==0){\\n                    q.add(new int[]{cur[0],cur[1],cur[2]+1,cur[3]-1,(position+1)%2,cur[5]+1});\\n                }\\n                if(cur[3]+1<n && grid[cur[2]][cur[3]+1]==0){\\n                    q.add(new int[]{cur[2],cur[3],cur[2],cur[3]+1,position,cur[5]+1});\\n                }\\n                if(cur[0]+1<n && cur[2]+1<n && grid[cur[0]+1][cur[1]]+grid[cur[2]+1][cur[3]]==0){\\n                    q.add(new int[]{cur[0]+1,cur[1],cur[2]+1,cur[3],position,cur[5]+1});\\n                }\\n            }\\n            //vertical\\n            else{\\n                if(cur[3]+1<n && grid[cur[2]-1][cur[3]+1]+grid[cur[2]][cur[3]+1]==0){\\n                    q.add(new int[]{cur[0],cur[1],cur[2]-1,cur[3]+1,(position+1)%2,cur[5]+1});\\n                }\\n                if(cur[2]+1<n && grid[cur[2]+1][cur[3]]==0){\\n                    q.add(new int[]{cur[2],cur[3],cur[2]+1,cur[3],position,cur[5]+1});\\n                }\\n                if(cur[1]+1<n && cur[3]+1<n && grid[cur[0]][cur[1]+1]+grid[cur[2]][cur[3]+1]==0){\\n                    q.add(new int[]{cur[0],cur[1]+1,cur[2],cur[3]+1,position,cur[5]+1});\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n    boolean isValid(int[] cur, int n){\\n        return cur[0]<n && cur[2]<n && cur[1]<n && cur[3]<n;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2720413,
                "title": "python-dp-solution-intuitive-with-comments",
                "content": "```python\\nclass Solution:\\n    def minimumMoves(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        \\n        dp = [[[114514, 114514] for i in range(n)] for j in range(m)]\\n        # dp[i][j][0]: the number of minimum moves that the snake\\'s tail can reach (i, j) and positioned horizontally\\n        # dp[i][j][1]: the number of minimum moves that the snake\\'s tail can reach (i, j) and positioned vertically\\n        \\n        dp[0][0][0] = 0\\n        for i in range(m):\\n            for j in range(n):\\n                # dp[i][j][0] = min(dp[i][j - 1][0], dp[i - 1][j][0], dp[i][j][1]) + 1\\n                # dp[i][j][1] = min(dp[i][j - 1][1], dp[i - 1][j][1], dp[i][j][0]) + 1\\n                \\n                hori = [] # tail horizontally placed in (i, j)\\n                if j < n - 1 and j > 0 and grid[i][j] != 1 and grid[i][j + 1] != 1: # moved right to (i, j)\\n                    hori.append(dp[i][j - 1][0])\\n                if j < n - 1 and i > 0 and grid[i][j] != 1 and grid[i][j + 1] != 1: # moved down to (i, j)\\n                    hori.append(dp[i - 1][j][0])\\n                if j < n - 1 and i < m - 1 and grid[i][j] != 1 and grid[i][j + 1] != 1 and grid[i + 1][j + 1] != 1: # rotate counterclockwise\\n                    hori.append(dp[i][j][1])\\n                if hori:\\n                    dp[i][j][0] = min(hori + [dp[i][j][0]]) + 1\\n                    \\n                vert = [] # tail vertically placed in (i, j)\\n                if i < m - 1 and j > 0 and grid[i][j] != 1 and grid[i + 1][j] != 1: # moved right to (i, j)\\n                    vert.append(dp[i][j - 1][1])\\n                if i < m - 1 and i > 0 and grid[i][j] != 1 and grid[i + 1][j] != 1: # moved down to (i, j)\\n                    hori.append(dp[i - 1][j][0])\\n                    vert.append(dp[i - 1][j][1])\\n                if i < m - 1 and j < n - 1 and grid[i][j] != 1 and grid[i + 1][j] != 1 and grid[i + 1][j + 1] != 1: # rotate clockwise\\n                    vert.append(dp[i][j][0])\\n                if vert:\\n                    dp[i][j][1] = min(vert + [dp[i][j][1]]) + 1\\n                    \\n                if j < n - 1 and i < m - 1 and grid[i][j] != 1 and grid[i][j + 1] != 1 and grid[i + 1][j + 1] != 1: # update dp[i][j][0] again after dp[i][j][1] has changed\\n                    dp[i][j][0] = min(dp[i][j][0], dp[i][j][1] + 1)\\n                    \\n        return -1 if dp[-1][-2][0] >= 114514 else dp[-1][-2][0] - dp[0][0][0]\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```python\\nclass Solution:\\n    def minimumMoves(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        \\n        dp = [[[114514, 114514] for i in range(n)] for j in range(m)]\\n        # dp[i][j][0]: the number of minimum moves that the snake\\'s tail can reach (i, j) and positioned horizontally\\n        # dp[i][j][1]: the number of minimum moves that the snake\\'s tail can reach (i, j) and positioned vertically\\n        \\n        dp[0][0][0] = 0\\n        for i in range(m):\\n            for j in range(n):\\n                # dp[i][j][0] = min(dp[i][j - 1][0], dp[i - 1][j][0], dp[i][j][1]) + 1\\n                # dp[i][j][1] = min(dp[i][j - 1][1], dp[i - 1][j][1], dp[i][j][0]) + 1\\n                \\n                hori = [] # tail horizontally placed in (i, j)\\n                if j < n - 1 and j > 0 and grid[i][j] != 1 and grid[i][j + 1] != 1: # moved right to (i, j)\\n                    hori.append(dp[i][j - 1][0])\\n                if j < n - 1 and i > 0 and grid[i][j] != 1 and grid[i][j + 1] != 1: # moved down to (i, j)\\n                    hori.append(dp[i - 1][j][0])\\n                if j < n - 1 and i < m - 1 and grid[i][j] != 1 and grid[i][j + 1] != 1 and grid[i + 1][j + 1] != 1: # rotate counterclockwise\\n                    hori.append(dp[i][j][1])\\n                if hori:\\n                    dp[i][j][0] = min(hori + [dp[i][j][0]]) + 1\\n                    \\n                vert = [] # tail vertically placed in (i, j)\\n                if i < m - 1 and j > 0 and grid[i][j] != 1 and grid[i + 1][j] != 1: # moved right to (i, j)\\n                    vert.append(dp[i][j - 1][1])\\n                if i < m - 1 and i > 0 and grid[i][j] != 1 and grid[i + 1][j] != 1: # moved down to (i, j)\\n                    hori.append(dp[i - 1][j][0])\\n                    vert.append(dp[i - 1][j][1])\\n                if i < m - 1 and j < n - 1 and grid[i][j] != 1 and grid[i + 1][j] != 1 and grid[i + 1][j + 1] != 1: # rotate clockwise\\n                    vert.append(dp[i][j][0])\\n                if vert:\\n                    dp[i][j][1] = min(vert + [dp[i][j][1]]) + 1\\n                    \\n                if j < n - 1 and i < m - 1 and grid[i][j] != 1 and grid[i][j + 1] != 1 and grid[i + 1][j + 1] != 1: # update dp[i][j][0] again after dp[i][j][1] has changed\\n                    dp[i][j][0] = min(dp[i][j][0], dp[i][j][1] + 1)\\n                    \\n        return -1 if dp[-1][-2][0] >= 114514 else dp[-1][-2][0] - dp[0][0][0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2478930,
                "title": "bfs-c-superfast-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumMoves(vector<vector<int>>&grid){\\n        int n=grid.size(),ans=0;\\n        map<pair<int,pair<int,int>>,int>mp;\\n        queue<pair<int,pair<int,int>>>q;\\n        \\n        q.push({0,{0,1}});\\n        mp[{0,{0,1}}]++;\\n        int i=0;\\n        while(q.size()>0){\\n            int m=q.size();\\n            while(m--)\\n            {\\n                int x=q.front().second.first,y=q.front().second.second,pos=q.front().first;\\n                q.pop();\\n                if(x==n-1 && y==n-1 && pos==0)return ans;\\n                if(pos==0)\\n                {\\n                    if(y+1<n && grid[x][y+1]==0 && mp.find({0,{x,y+1}})==mp.end()){\\n                        q.push({0,{x,y+1}});\\n                        mp[{0,{x,y+1}}]++;\\n                    }\\n                    if(x+1<n && grid[x+1][y]==0 && grid[x+1][y-1]==0 && mp.find({0,{x+1,y}})==mp.end()){\\n                        q.push({0,{x+1,y}});\\n                        mp[{0,{x+1,y}}]++;\\n                    }\\n                    if(x+1<n && grid[x+1][y]==0 && grid[x+1][y-1]==0 && mp.find({1,{x+1,y-1}})==mp.end()){\\n                        q.push({1,{x+1,y-1}});\\n                        mp[{1,{x+1,y-1}}]++;\\n                    }\\n                }else{\\n                    if(x+1<n && grid[x+1][y]==0 && mp.find({1,{x+1,y}})==mp.end()){\\n                        q.push({1,{x+1,y}});\\n                        mp[{1,{x+1,y}}]++;\\n                    }\\n                    if(y+1<n && grid[x][y+1]==0 && grid[x-1][y+1]==0 && mp.find({1,{x,y+1}})==mp.end()){\\n                         q.push({1,{x,y+1}});\\n                         mp[{1,{x,y+1}}]++;\\n                    }\\n                    if(y+1<n && grid[x][y+1]==0 && grid[x-1][y+1]==0 && mp.find({0,{x-1,y+1}})==mp.end()){\\n                         q.push({0,{x-1,y+1}});\\n                         mp[{0,{x-1,y+1}}]++;\\n                    }\\n                }\\n            }\\n            ans++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumMoves(vector<vector<int>>&grid){\\n        int n=grid.size(),ans=0;\\n        map<pair<int,pair<int,int>>,int>mp;\\n        queue<pair<int,pair<int,int>>>q;\\n        \\n        q.push({0,{0,1}});\\n        mp[{0,{0,1}}]++;\\n        int i=0;\\n        while(q.size()>0){\\n            int m=q.size();\\n            while(m--)\\n            {\\n                int x=q.front().second.first,y=q.front().second.second,pos=q.front().first;\\n                q.pop();\\n                if(x==n-1 && y==n-1 && pos==0)return ans;\\n                if(pos==0)\\n                {\\n                    if(y+1<n && grid[x][y+1]==0 && mp.find({0,{x,y+1}})==mp.end()){\\n                        q.push({0,{x,y+1}});\\n                        mp[{0,{x,y+1}}]++;\\n                    }\\n                    if(x+1<n && grid[x+1][y]==0 && grid[x+1][y-1]==0 && mp.find({0,{x+1,y}})==mp.end()){\\n                        q.push({0,{x+1,y}});\\n                        mp[{0,{x+1,y}}]++;\\n                    }\\n                    if(x+1<n && grid[x+1][y]==0 && grid[x+1][y-1]==0 && mp.find({1,{x+1,y-1}})==mp.end()){\\n                        q.push({1,{x+1,y-1}});\\n                        mp[{1,{x+1,y-1}}]++;\\n                    }\\n                }else{\\n                    if(x+1<n && grid[x+1][y]==0 && mp.find({1,{x+1,y}})==mp.end()){\\n                        q.push({1,{x+1,y}});\\n                        mp[{1,{x+1,y}}]++;\\n                    }\\n                    if(y+1<n && grid[x][y+1]==0 && grid[x-1][y+1]==0 && mp.find({1,{x,y+1}})==mp.end()){\\n                         q.push({1,{x,y+1}});\\n                         mp[{1,{x,y+1}}]++;\\n                    }\\n                    if(y+1<n && grid[x][y+1]==0 && grid[x-1][y+1]==0 && mp.find({0,{x-1,y+1}})==mp.end()){\\n                         q.push({0,{x-1,y+1}});\\n                         mp[{0,{x-1,y+1}}]++;\\n                    }\\n                }\\n            }\\n            ans++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2478923,
                "title": "dfs-c-superfast-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    map<pair<int,pair<int,int>>,int>mp;\\n    int dp[101][101][3];\\n    int solve(vector<vector<int>>&grid,int n,int m,int i,int j,int pos){\\n        if(i>=n || j>=m)return INT_MAX;\\n\\t\\t//f i ans j are at right bottom end and rotaion is 0 then we return \\n        if(i==n-1 && j==n-1 && pos==0)return 0;\\n        int ans=INT_MAX,first=i,second=j;\\n        \\n        if(dp[i][j][pos]!=-1)return dp[i][j][pos];\\n        if(pos==0){\\n            if(j+1<m && grid[i][j+1]==0 && mp.find({0,{i,j+1}})==mp.end()){\\n\\t\\t\\t//to avoid runtime erroe vis the same node again\\n                mp[{0,{i,j+1}}]++;\\n                int c=solve(grid,n,m,i,j+1,pos);\\n\\t\\t\\t\\t//backtrack\\n                mp.erase({0,{i,j+1}});\\n                if(c!=INT_MAX)ans=min(ans,1+c);\\n            }\\n            if(i+1<n && grid[i+1][j]==0 && grid[i+1][j-1]==0 && mp.find({0,{i+1,j}})==mp.end()){\\n                mp[{0,{i+1,j}}]++;\\n                int e=solve(grid,n,m,i+1,j,pos);\\n                mp.erase({0,{i+1,j}});\\n                if(e!=INT_MAX)ans=min(ans,1+e);\\n            }\\n            if(i+1<n && grid[i+1][j]==0 && grid[i+1][j-1]==0 && mp.find({1,{i+1,j-1}})==mp.end()){\\n                mp[{1,{i+1,j-1}}]++;\\n                int e=solve(grid,n,m,i+1,j-1,1);\\n                mp.erase({1,{i+1,j-1}});\\n                if(e!=INT_MAX)ans=min(ans,1+e);\\n            }\\n        }else{\\n            if(i+1<n && grid[i+1][j]==0 && mp.find({1,{i+1,j}})==mp.end()){\\n                mp[{1,{i+1,j}}]++;\\n                int e=solve(grid,n,m,i+1,j,1);\\n                mp.erase({1,{i+1,j}});\\n                if(e!=INT_MAX)ans=min(ans,1+e);\\n            }\\n            if(j+1<n && grid[i][j+1]==0 && grid[i-1][j+1]==0 && mp.find({1,{i,j+1}})==mp.end()){\\n                mp[{1,{i,j+1}}]++;\\n                int e=solve(grid,n,m,i,j+1,1);\\n                mp.erase({1,{i,j+1}});\\n                if(e!=INT_MAX)ans=min(ans,1+e);\\n            }\\n            if(j+1<n && grid[i][j+1]==0 && grid[i-1][j+1]==0 && mp.find({0,{i-1,j+1}})==mp.end()){\\n                mp[{0,{i-1,j+1}}]++;\\n                int e=solve(grid,n,m,i-1,j+1,0);\\n                mp.erase({0,{i-1,j+1}});\\n                if(e!=INT_MAX)ans=min(ans,1+e);\\n            }\\n        }\\n        return dp[i][j][pos]=ans;\\n    }\\n    int minimumMoves(vector<vector<int>>&grid){\\n        memset(dp,-1,sizeof(dp));\\n        int ans=solve(grid,grid.size(),grid[0].size(),0,1,0);\\n        return ans==INT_MAX?-1:ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    map<pair<int,pair<int,int>>,int>mp;\\n    int dp[101][101][3];\\n    int solve(vector<vector<int>>&grid,int n,int m,int i,int j,int pos){\\n        if(i>=n || j>=m)return INT_MAX;\\n\\t\\t//f i ans j are at right bottom end and rotaion is 0 then we return \\n        if(i==n-1 && j==n-1 && pos==0)return 0;\\n        int ans=INT_MAX,first=i,second=j;\\n        \\n        if(dp[i][j][pos]!=-1)return dp[i][j][pos];\\n        if(pos==0){\\n            if(j+1<m && grid[i][j+1]==0 && mp.find({0,{i,j+1}})==mp.end()){\\n\\t\\t\\t//to avoid runtime erroe vis the same node again\\n                mp[{0,{i,j+1}}]++;\\n                int c=solve(grid,n,m,i,j+1,pos);\\n\\t\\t\\t\\t//backtrack\\n                mp.erase({0,{i,j+1}});\\n                if(c!=INT_MAX)ans=min(ans,1+c);\\n            }\\n            if(i+1<n && grid[i+1][j]==0 && grid[i+1][j-1]==0 && mp.find({0,{i+1,j}})==mp.end()){\\n                mp[{0,{i+1,j}}]++;\\n                int e=solve(grid,n,m,i+1,j,pos);\\n                mp.erase({0,{i+1,j}});\\n                if(e!=INT_MAX)ans=min(ans,1+e);\\n            }\\n            if(i+1<n && grid[i+1][j]==0 && grid[i+1][j-1]==0 && mp.find({1,{i+1,j-1}})==mp.end()){\\n                mp[{1,{i+1,j-1}}]++;\\n                int e=solve(grid,n,m,i+1,j-1,1);\\n                mp.erase({1,{i+1,j-1}});\\n                if(e!=INT_MAX)ans=min(ans,1+e);\\n            }\\n        }else{\\n            if(i+1<n && grid[i+1][j]==0 && mp.find({1,{i+1,j}})==mp.end()){\\n                mp[{1,{i+1,j}}]++;\\n                int e=solve(grid,n,m,i+1,j,1);\\n                mp.erase({1,{i+1,j}});\\n                if(e!=INT_MAX)ans=min(ans,1+e);\\n            }\\n            if(j+1<n && grid[i][j+1]==0 && grid[i-1][j+1]==0 && mp.find({1,{i,j+1}})==mp.end()){\\n                mp[{1,{i,j+1}}]++;\\n                int e=solve(grid,n,m,i,j+1,1);\\n                mp.erase({1,{i,j+1}});\\n                if(e!=INT_MAX)ans=min(ans,1+e);\\n            }\\n            if(j+1<n && grid[i][j+1]==0 && grid[i-1][j+1]==0 && mp.find({0,{i-1,j+1}})==mp.end()){\\n                mp[{0,{i-1,j+1}}]++;\\n                int e=solve(grid,n,m,i-1,j+1,0);\\n                mp.erase({0,{i-1,j+1}});\\n                if(e!=INT_MAX)ans=min(ans,1+e);\\n            }\\n        }\\n        return dp[i][j][pos]=ans;\\n    }\\n    int minimumMoves(vector<vector<int>>&grid){\\n        memset(dp,-1,sizeof(dp));\\n        int ans=solve(grid,grid.size(),grid[0].size(),0,1,0);\\n        return ans==INT_MAX?-1:ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2469360,
                "title": "swift-solution",
                "content": "```\\nClass Solution {\\n    func minimumMoves(_ grid: [[Int]]) -> Int {\\n        let n = grid.count\\n        var dp = Array(repeating: Array(repeating: Array(repeating: 0, count: 2), count: n), count: n)\\n        \\n        for i in 0..<n {\\n            for j in 0..<n {\\n                for k in 0..<2 {\\n                    if i == 0 && j == 0 && k == 0 {\\n                        dp[i][j][k] = 0\\n                    } else if grid[i][j] == 1 {\\n                        dp[i][j][k] = Int.max\\n                    } else if k == 0 && (j + 1 >= n || grid[i][j + 1] == 1) {\\n                        dp[i][j][k] = Int.max\\n                    } else if k == 1 && (i + 1 >= n || grid[i + 1][j] == 1) {\\n                        dp[i][j][k] = Int.max\\n                    } else {\\n                        let choice1 = i - 1 >= 0 ? dp[i - 1][j][k] : Int.max\\n                        let choice2 = j - 1 >= 0 ? dp[i][j - 1][k] : Int.max\\n                        let tempMinChoice = min(choice1, choice2)\\n                        dp[i][j][k] = tempMinChoice == Int.max ? tempMinChoice : (tempMinChoice + 1)\\n                    }\\n                }\\n                //rotate\\n                if i + 1 < n && j + 1 < n && grid[i][j + 1] != 1 && grid[i + 1][j + 1] != 1 && dp[i][j][1] != Int.max && dp[i][j][0] > dp[i][j][1] + 1 {\\n                    dp[i][j][0] = dp[i][j][1] + 1\\n                }\\n                if i + 1 < n && j + 1 < n && grid[i + 1][j] != 1 && grid[i + 1][j + 1] != 1 && dp[i][j][0] != Int.max && dp[i][j][1] > dp[i][j][0] + 1 {\\n                    dp[i][j][1] = dp[i][j][0] + 1\\n                }\\n            }\\n        }\\n        return dp[n - 1][n - 2][0] == Int.max ? -1 : dp[n - 1][n - 2][0]\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nClass Solution {\\n    func minimumMoves(_ grid: [[Int]]) -> Int {\\n        let n = grid.count\\n        var dp = Array(repeating: Array(repeating: Array(repeating: 0, count: 2), count: n), count: n)\\n        \\n        for i in 0..<n {\\n            for j in 0..<n {\\n                for k in 0..<2 {\\n                    if i == 0 && j == 0 && k == 0 {\\n                        dp[i][j][k] = 0\\n                    } else if grid[i][j] == 1 {\\n                        dp[i][j][k] = Int.max\\n                    } else if k == 0 && (j + 1 >= n || grid[i][j + 1] == 1) {\\n                        dp[i][j][k] = Int.max\\n                    } else if k == 1 && (i + 1 >= n || grid[i + 1][j] == 1) {\\n                        dp[i][j][k] = Int.max\\n                    } else {\\n                        let choice1 = i - 1 >= 0 ? dp[i - 1][j][k] : Int.max\\n                        let choice2 = j - 1 >= 0 ? dp[i][j - 1][k] : Int.max\\n                        let tempMinChoice = min(choice1, choice2)\\n                        dp[i][j][k] = tempMinChoice == Int.max ? tempMinChoice : (tempMinChoice + 1)\\n                    }\\n                }\\n                //rotate\\n                if i + 1 < n && j + 1 < n && grid[i][j + 1] != 1 && grid[i + 1][j + 1] != 1 && dp[i][j][1] != Int.max && dp[i][j][0] > dp[i][j][1] + 1 {\\n                    dp[i][j][0] = dp[i][j][1] + 1\\n                }\\n                if i + 1 < n && j + 1 < n && grid[i + 1][j] != 1 && grid[i + 1][j + 1] != 1 && dp[i][j][0] != Int.max && dp[i][j][1] > dp[i][j][0] + 1 {\\n                    dp[i][j][1] = dp[i][j][0] + 1\\n                }\\n            }\\n        }\\n        return dp[n - 1][n - 2][0] == Int.max ? -1 : dp[n - 1][n - 2][0]\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2318417,
                "title": "python-simple",
                "content": "```\\nclass Solution:\\n    def minimumMoves(self, grid: List[List[int]]) -> int:\\n        q=deque([([0,1],0,0)])\\n        def inb(p):return p[0]>=0 and p[0]<len(grid) and p[1]>=0 and p[1]<len(grid[0]) and grid[p[0]][p[1]]==0\\n        u=set()\\n        while q:\\n            p,v,c=q.popleft()\\n            if p[0]==len(grid)-1 and p[1]==len(grid[0])-1 and v==0:return c\\n            k=(p[0],p[1],v)\\n            if k in u:continue\\n            u.add(k)\\n            if v==0:\\n                pn=[p[0],p[1]+1]\\n                if inb(pn):q.append((pn,v,c+1))\\n                pn=[p[0]+1,p[1]]\\n                if inb(pn) and inb([p[0]+1,p[1]-1]):q.append((pn,v,c+1))\\n                pn=[p[0]+1,p[1]-1]\\n                if inb(pn) and inb([p[0]+1,p[1]]):q.append((pn,1,c+1))\\n            elif v==1:\\n                pn=[p[0]+1,p[1]]\\n                if inb(pn) and grid[pn[0]][pn[1]]!=1:q.append((pn,v,c+1))\\n                pn=[p[0],p[1]+1]\\n                if inb(pn) and inb([p[0]-1,p[1]+1]):q.append((pn,v,c+1))\\n                pn=[p[0]-1,p[1]+1]\\n                if inb(pn) and inb([p[0],p[1]+1]):q.append((pn,0,c+1))\\n        return -1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumMoves(self, grid: List[List[int]]) -> int:\\n        q=deque([([0,1],0,0)])\\n        def inb(p):return p[0]>=0 and p[0]<len(grid) and p[1]>=0 and p[1]<len(grid[0]) and grid[p[0]][p[1]]==0\\n        u=set()\\n        while q:\\n            p,v,c=q.popleft()\\n            if p[0]==len(grid)-1 and p[1]==len(grid[0])-1 and v==0:return c\\n            k=(p[0],p[1],v)\\n            if k in u:continue\\n            u.add(k)\\n            if v==0:\\n                pn=[p[0],p[1]+1]\\n                if inb(pn):q.append((pn,v,c+1))\\n                pn=[p[0]+1,p[1]]\\n                if inb(pn) and inb([p[0]+1,p[1]-1]):q.append((pn,v,c+1))\\n                pn=[p[0]+1,p[1]-1]\\n                if inb(pn) and inb([p[0]+1,p[1]]):q.append((pn,1,c+1))\\n            elif v==1:\\n                pn=[p[0]+1,p[1]]\\n                if inb(pn) and grid[pn[0]][pn[1]]!=1:q.append((pn,v,c+1))\\n                pn=[p[0],p[1]+1]\\n                if inb(pn) and inb([p[0]-1,p[1]+1]):q.append((pn,v,c+1))\\n                pn=[p[0]-1,p[1]+1]\\n                if inb(pn) and inb([p[0],p[1]+1]):q.append((pn,0,c+1))\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2317313,
                "title": "python-100-fastest-sol-bfs-hashmap-fully-explained",
                "content": "# Runtime: 233 ms, faster than 100.00% of Python3 online submissions for Minimum Moves to Reach Target with Rotations.\\n# Memory Usage: 16 MB, less than 56.06% of Python3 online submissions for Minimum Moves to Reach Target with Rotations.\\n\\n# EXPLANATION\\nThe idea is very simple \\nKeep track of the cell of head of the snake as well as the direction head is facing\\n\\n\\nWhen snake is positioned horizontally:\\n1. we can move right\\n2. we can move down\\n3. make snake vertical\\n\\nWhen snake is positioned vertically:\\n1. we can move right\\n2. we can move down\\n3. make snake vertical\\n\\n\\nSince there can be multiple solutions possible and we need solution with minimum numbers of steps we use BFS\\n\\nOnce a cell is visited in a direction we don\\'t visit the cell in the same direction again to avoid \\nrepeatition\\n# CODE\\n```\\nclass Solution:\\n    def minimumMoves(self, grid: List[List[int]]) -> int:\\n        queue , vis , n = [(0,1,0,0)] , {} , len(grid)\\n        while queue:\\n            x,y,pos,moves = queue.pop(0)\\n            if x == y == n-1 and pos == 0: return moves\\n            if pos == 0:\\n                if y + 1 < n and grid[x][y+1] == 0 and (x,y+1,0) not in vis:\\n                    vis[(x,y+1,0)] = True\\n                    queue.append((x,y+1,0,moves+1))\\n                \\n                if x + 1 < n and grid[x+1][y-1] == 0 and grid[x+1][y] == 0:\\n                    if (x+1,y-1,1) not in vis:\\n                        vis[(x+1,y-1,1)] = True\\n                        queue.append((x+1,y-1,1,moves+1))\\n                    if (x+1,y,0) not in vis:\\n                        vis[(x+1,y,0)] = True\\n                        queue.append((x+1,y,0,moves+1))\\n            else:\\n                if x + 1 < n and grid[x+1][y] == 0 and (x+1,y,1) not in vis:\\n                    vis[(x+1,y,1)] = True\\n                    queue.append((x+1,y,1,moves+1))\\n                if y + 1 < n and grid[x-1][y+1] == grid[x][y+1] == 0:\\n                    if (x-1,y+1,0) not in vis:\\n                        vis[(x-1,y+1,0)] = True\\n                        queue.append((x-1,y+1,0,moves+1))\\n                    if (x,y+1,1) not in vis:\\n                        vis[(x,y+1,1)] = True\\n                        queue.append((x,y+1,1,moves+1))\\n        return -1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def minimumMoves(self, grid: List[List[int]]) -> int:\\n        queue , vis , n = [(0,1,0,0)] , {} , len(grid)\\n        while queue:\\n            x,y,pos,moves = queue.pop(0)\\n            if x == y == n-1 and pos == 0: return moves\\n            if pos == 0:\\n                if y + 1 < n and grid[x][y+1] == 0 and (x,y+1,0) not in vis:\\n                    vis[(x,y+1,0)] = True\\n                    queue.append((x,y+1,0,moves+1))\\n                \\n                if x + 1 < n and grid[x+1][y-1] == 0 and grid[x+1][y] == 0:\\n                    if (x+1,y-1,1) not in vis:\\n                        vis[(x+1,y-1,1)] = True\\n                        queue.append((x+1,y-1,1,moves+1))\\n                    if (x+1,y,0) not in vis:\\n                        vis[(x+1,y,0)] = True\\n                        queue.append((x+1,y,0,moves+1))\\n            else:\\n                if x + 1 < n and grid[x+1][y] == 0 and (x+1,y,1) not in vis:\\n                    vis[(x+1,y,1)] = True\\n                    queue.append((x+1,y,1,moves+1))\\n                if y + 1 < n and grid[x-1][y+1] == grid[x][y+1] == 0:\\n                    if (x-1,y+1,0) not in vis:\\n                        vis[(x-1,y+1,0)] = True\\n                        queue.append((x-1,y+1,0,moves+1))\\n                    if (x,y+1,1) not in vis:\\n                        vis[(x,y+1,1)] = True\\n                        queue.append((x,y+1,1,moves+1))\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2161680,
                "title": "java-dp-beats-100",
                "content": "```\\npublic int minimumMoves(int[][] grid) {\\n\\tint n = grid.length;\\n\\tint[][][] dp = new int[n+1][n+1][2];\\n\\t//[i,j,0]=> horizontal\\n\\t//[i,j,1]=> vertical\\n\\tfor(int i = 0; i <= n; i++){\\n\\t\\tfor(int j = 0; j <= n; j++){\\n\\t\\t\\tdp[i][j][0] = Integer.MAX_VALUE/2;\\n\\t\\t\\tdp[i][j][1] = Integer.MAX_VALUE/2;\\n\\t\\t}\\n\\t}\\n\\t//to make the initial position dp[1][1][0] as 0;\\n\\tdp[0][1][0] = -1;\\n\\tdp[1][0][0] = -1;\\n\\n\\tfor(int i = 1; i <= n; i++){\\n\\t\\tfor(int j = 1; j <= n; j++){\\n\\t\\t\\tboolean possibleFromRotate = false;\\n\\t\\t\\tboolean possibleFromAntiRotate = false;\\n\\t\\t\\t//could be from left\\n\\t\\t\\tif(grid[i-1][j-1] == 0 && j < n && grid[i-1][j] == 0){\\n\\t\\t\\t\\tdp[i][j][0] = Math.min(dp[i][j-1][0], dp[i-1][j][0]) + 1;\\n\\t\\t\\t\\tpossibleFromAntiRotate = true;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif(grid[i-1][j-1] == 0 && i < n && grid[i][j-1] == 0){\\n\\t\\t\\t\\tdp[i][j][1] = Math.min(dp[i-1][j][1], dp[i][j-1][1]) + 1;\\n\\t\\t\\t\\tpossibleFromRotate = true;\\n\\t\\t\\t}\\n\\t\\t\\t//could be from anti-rotate\\n\\t\\t\\tif(possibleFromAntiRotate && i<n && grid[i][j] == 0){\\n\\t\\t\\t\\tdp[i][j][0] = Math.min(dp[i][j][0], dp[i][j][1]+1);\\n\\t\\t\\t}\\n\\t\\t\\t//could be from rotate\\n\\t\\t\\tif(possibleFromRotate && j<n && grid[i][j] == 0){\\n\\t\\t\\t\\tdp[i][j][1] = Math.min(dp[i][j][1], dp[i][j][0]+1);\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\t}\\n\\n\\treturn (dp[n][n-1][0] >= (Integer.MAX_VALUE/2)) ? -1 : dp[n][n-1][0];       \\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\npublic int minimumMoves(int[][] grid) {\\n\\tint n = grid.length;\\n\\tint[][][] dp = new int[n+1][n+1][2];\\n\\t//[i,j,0]=> horizontal\\n\\t//[i,j,1]=> vertical\\n\\tfor(int i = 0; i <= n; i++){\\n\\t\\tfor(int j = 0; j <= n; j++){\\n\\t\\t\\tdp[i][j][0] = Integer.MAX_VALUE/2;\\n\\t\\t\\tdp[i][j][1] = Integer.MAX_VALUE/2;\\n\\t\\t}\\n\\t}\\n\\t//to make the initial position dp[1][1][0] as 0;\\n\\tdp[0][1][0] = -1;\\n\\tdp[1][0][0] = -1;\\n\\n\\tfor(int i = 1; i <= n; i++){\\n\\t\\tfor(int j = 1; j <= n; j++){\\n\\t\\t\\tboolean possibleFromRotate = false;\\n\\t\\t\\tboolean possibleFromAntiRotate = false;\\n\\t\\t\\t//could be from left\\n\\t\\t\\tif(grid[i-1][j-1] == 0 && j < n && grid[i-1][j] == 0){\\n\\t\\t\\t\\tdp[i][j][0] = Math.min(dp[i][j-1][0], dp[i-1][j][0]) + 1;\\n\\t\\t\\t\\tpossibleFromAntiRotate = true;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif(grid[i-1][j-1] == 0 && i < n && grid[i][j-1] == 0){\\n\\t\\t\\t\\tdp[i][j][1] = Math.min(dp[i-1][j][1], dp[i][j-1][1]) + 1;\\n\\t\\t\\t\\tpossibleFromRotate = true;\\n\\t\\t\\t}\\n\\t\\t\\t//could be from anti-rotate\\n\\t\\t\\tif(possibleFromAntiRotate && i<n && grid[i][j] == 0){\\n\\t\\t\\t\\tdp[i][j][0] = Math.min(dp[i][j][0], dp[i][j][1]+1);\\n\\t\\t\\t}\\n\\t\\t\\t//could be from rotate\\n\\t\\t\\tif(possibleFromRotate && j<n && grid[i][j] == 0){\\n\\t\\t\\t\\tdp[i][j][1] = Math.min(dp[i][j][1], dp[i][j][0]+1);\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\t}\\n\\n\\treturn (dp[n][n-1][0] >= (Integer.MAX_VALUE/2)) ? -1 : dp[n][n-1][0];       \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2081462,
                "title": "java-bfs-easy-to-understand",
                "content": "```\\nclass Solution {\\n    int n;\\n    public int minimumMoves(int[][] grid) {\\n        n = grid.length; \\n        boolean[][][] visited = new boolean[n][n][2];//[x][y][0]: right, [x][y][1] : down\\n        Queue<int[]> queue = new LinkedList<>();\\n        queue.add(new int[]{0,0,0,1});\\n        visited[0][0][0] = true;\\n        int moves = 0;\\n        while(!queue.isEmpty()) {\\n            int size = queue.size();\\n            while(size -- > 0) {\\n                int[] cur = queue.poll();\\n                if (cur[0] == n - 1 && cur[1] == n - 2 && cur[2] == n - 1 && cur[3] == n - 1) {\\n                    return moves;\\n                }\\n                //next moves\\n                // rule move #1\\n                int a = cur[0], b = cur[1] + 1, c = cur[2], d = cur[3] + 1;\\n                if (isValid(a, b) && grid[a][b] == 0 && isValid(c,d) && grid[c][d] == 0) {\\n                    if (a == c) {// horizontial\\n                        if (!visited[a][b][0]) {\\n                            queue.add(new int[]{a, b, c, d});\\n                            visited[a][b][0] = true;\\n                        }\\n                    } else { // vertial\\n                        if (!visited[a][b][1]) {\\n                            queue.add(new int[]{a, b, c, d});\\n                            visited[a][b][1] = true;\\n                        }\\n                    }\\n                }\\n                // rule move #2\\n                a = cur[0] + 1; b = cur[1]; c = cur[2] + 1; d = cur[3];\\n                if (isValid(a, b) && grid[a][b] == 0 && isValid(c,d) && grid[c][d] == 0) {\\n                    if (a == c) {// horizontial\\n                        if (!visited[a][b][0]) {\\n                            queue.add(new int[]{a, b, c, d});\\n                            visited[a][b][0] = true;\\n                        }\\n                    } else { // vertial\\n                        if (!visited[a][b][1]) {\\n                            queue.add(new int[]{a, b, c, d});\\n                            visited[a][b][1] = true;\\n                        }\\n                    }\\n                }\\n                // rule move #3\\n                if (cur[0] == cur[2]) { // horizontial\\n                    if (isValid(cur[0] + 1, cur[1]) && isValid(cur[2] + 1, cur[3]) && grid[cur[0] + 1][cur[1]] == 0 && grid[cur[2] + 1][cur[3]] == 0) {\\n                        a = cur[0]; b = cur[1]; c = cur[0] + 1; d = cur[1];\\n                        if (!visited[a][b][1]) {\\n                            queue.add(new int[]{a, b, c, d});\\n                            visited[a][b][0] = true;\\n                        }\\n                    }\\n                } else { // vertial\\n                    if (isValid(cur[0], cur[1] + 1) && isValid(cur[2], cur[3] + 1) && grid[cur[0]][cur[1] + 1] == 0 && grid[cur[2]][cur[3] + 1] == 0) {\\n                        a = cur[0]; b = cur[1]; c = cur[0]; d = cur[1] + 1;\\n                        if (!visited[a][b][0]) {\\n                            queue.add(new int[]{a, b, c, d});\\n                            visited[a][b][0] = true;\\n                        }\\n                    }\\n                }\\n            }\\n            \\n            moves ++;\\n        }\\n        \\n        return -1;\\n    }\\n    \\n    boolean isValid(int x, int y) {\\n        if (x >= 0 && x < n && y >= 0 && y < n) {\\n            return true;\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int n;\\n    public int minimumMoves(int[][] grid) {\\n        n = grid.length; \\n        boolean[][][] visited = new boolean[n][n][2];//[x][y][0]: right, [x][y][1] : down\\n        Queue<int[]> queue = new LinkedList<>();\\n        queue.add(new int[]{0,0,0,1});\\n        visited[0][0][0] = true;\\n        int moves = 0;\\n        while(!queue.isEmpty()) {\\n            int size = queue.size();\\n            while(size -- > 0) {\\n                int[] cur = queue.poll();\\n                if (cur[0] == n - 1 && cur[1] == n - 2 && cur[2] == n - 1 && cur[3] == n - 1) {\\n                    return moves;\\n                }\\n                //next moves\\n                // rule move #1\\n                int a = cur[0], b = cur[1] + 1, c = cur[2], d = cur[3] + 1;\\n                if (isValid(a, b) && grid[a][b] == 0 && isValid(c,d) && grid[c][d] == 0) {\\n                    if (a == c) {// horizontial\\n                        if (!visited[a][b][0]) {\\n                            queue.add(new int[]{a, b, c, d});\\n                            visited[a][b][0] = true;\\n                        }\\n                    } else { // vertial\\n                        if (!visited[a][b][1]) {\\n                            queue.add(new int[]{a, b, c, d});\\n                            visited[a][b][1] = true;\\n                        }\\n                    }\\n                }\\n                // rule move #2\\n                a = cur[0] + 1; b = cur[1]; c = cur[2] + 1; d = cur[3];\\n                if (isValid(a, b) && grid[a][b] == 0 && isValid(c,d) && grid[c][d] == 0) {\\n                    if (a == c) {// horizontial\\n                        if (!visited[a][b][0]) {\\n                            queue.add(new int[]{a, b, c, d});\\n                            visited[a][b][0] = true;\\n                        }\\n                    } else { // vertial\\n                        if (!visited[a][b][1]) {\\n                            queue.add(new int[]{a, b, c, d});\\n                            visited[a][b][1] = true;\\n                        }\\n                    }\\n                }\\n                // rule move #3\\n                if (cur[0] == cur[2]) { // horizontial\\n                    if (isValid(cur[0] + 1, cur[1]) && isValid(cur[2] + 1, cur[3]) && grid[cur[0] + 1][cur[1]] == 0 && grid[cur[2] + 1][cur[3]] == 0) {\\n                        a = cur[0]; b = cur[1]; c = cur[0] + 1; d = cur[1];\\n                        if (!visited[a][b][1]) {\\n                            queue.add(new int[]{a, b, c, d});\\n                            visited[a][b][0] = true;\\n                        }\\n                    }\\n                } else { // vertial\\n                    if (isValid(cur[0], cur[1] + 1) && isValid(cur[2], cur[3] + 1) && grid[cur[0]][cur[1] + 1] == 0 && grid[cur[2]][cur[3] + 1] == 0) {\\n                        a = cur[0]; b = cur[1]; c = cur[0]; d = cur[1] + 1;\\n                        if (!visited[a][b][0]) {\\n                            queue.add(new int[]{a, b, c, d});\\n                            visited[a][b][0] = true;\\n                        }\\n                    }\\n                }\\n            }\\n            \\n            moves ++;\\n        }\\n        \\n        return -1;\\n    }\\n    \\n    boolean isValid(int x, int y) {\\n        if (x >= 0 && x < n && y >= 0 && y < n) {\\n            return true;\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2007905,
                "title": "javascript-bfs",
                "content": "**Format 1**\\n```\\nvar minimumMoves = function(grid) {\\n    let queue = [{ head: [0, 0], tail: [0, -1], isHorizontal: true }], steps = 0;\\n    const visited = new Set([\"0,0,0,-1\"]);\\n    const n = grid.length;\\n    const finalPosition = `${n - 1},${n - 1},${n - 1},${n - 2}`;\\n    const dirs = [\\n        { headMove: [0, 1], tailMove: [0, 1], extraCheckForHead: [] },\\n        { headMove: [1, 0], tailMove: [1 ,0], extraCheckForHead: [] },\\n        { headMove: [1, -1], tailMove: [0, 0], extraCheckForHead: [[1, 0]], isRotate: true, horizontal: true },\\n        { headMove: [-1, 1], tailMove: [0, 0], extraCheckForHead: [[0, 1]], isRotate: true, horizontal: false }\\n    ];\\n\\n    while (queue.length > 0) {\\n        const nextPositions = [];\\n\\n        for (const { head, tail, isHorizontal } of queue) {\\n            for (const { headMove, tailMove, extraCheckForHead, isRotate, horizontal } of dirs) {\\n                if (horizontal !== undefined && isHorizontal !== horizontal)\\n                    continue;\\n\\n                const nextHeadX = head[0] + headMove[0], nextHeadY = head[1] + headMove[1];\\n                const nextTailX = tail[0] + tailMove[0], nextTailY = tail[1] + tailMove[1];\\n                const hashCode = `${nextHeadX},${nextHeadY},${nextTailX},${nextTailY}`;\\n\\n                if (hashCode === finalPosition)\\n                    return steps;\\n\\n                if (\\n                    grid[nextHeadX] && grid[nextHeadX][nextHeadY] == 0 &&\\n                    grid[nextTailX] && grid[nextTailX][nextTailY] == 0 &&\\n                    !visited.has(hashCode) && \\n                    extraCheckForHead.every(([xDir, yDir]) =>\\n                        grid[xDir + head[0]] && grid[xDir + head[0]][yDir + head[1]] == 0)\\n                ) {\\n                    nextPositions.push({\\n                        head: [nextHeadX, nextHeadY],\\n                        tail: [nextTailX, nextTailY],\\n                        isHorizontal: isRotate ? !isHorizontal : isHorizontal\\n                    })\\n                    visited.add(hashCode);                    \\n                }\\n            }\\n        }\\n\\n        steps++;\\n        queue = nextPositions;\\n    }\\n    \\n    return -1;\\n};\\n```\\n**Format 2**\\n```\\nvar minimumMoves = function(grid) {\\n    let queue = [{ tail: [0, 0], isHorizontal: true }], steps = 0;\\n    const visited = new Set([\"0,0,true\"]);\\n    const n = grid.length;\\n\\n    const rotate = (tail, isHorizontal, nextPositions) => {\\n        const nextHeadX = isHorizontal ? tail[0] + 1 : tail[0];\\n        const nextHeadY = isHorizontal ? tail[1] : tail[1] + 1;\\n        const hashCode = `${tail[0]},${tail[1]},${!isHorizontal}`;\\n\\n        if (\\n            grid[tail[0] + 1] && grid[tail[0] + 1][tail[1] + 1] == 0 &&\\n            grid[nextHeadX] && grid[nextHeadX][nextHeadY] == 0 &&\\n            !visited.has(hashCode)\\n        ) {\\n            visited.add(hashCode);\\n            nextPositions.push({ tail, isHorizontal: !isHorizontal });\\n        }\\n    };\\n    \\n    const downMove = (tail, isHorizontal, nextPositions) => {\\n        const nextHeadX = isHorizontal ? tail[0] + 1 : tail[0] + 2;\\n        const nextHeadY = isHorizontal ? tail[1] + 1 : tail[1];\\n        const nextTailX = tail[0] + 1, nextTailY = tail[1];\\n        const hashCode = `${nextTailX},${nextTailY},${isHorizontal}`;\\n\\n        if (\\n            grid[nextTailX] && grid[nextTailX][nextTailY] == 0 && \\n            grid[nextHeadX] && grid[nextHeadX][nextHeadY] == 0 &&\\n            !visited.has(hashCode)\\n        ) {\\n            visited.add(hashCode);\\n            nextPositions.push({ tail: [nextTailX, nextTailY], isHorizontal });\\n        }\\n    };\\n    \\n    const rightMove = (tail, isHorizontal, nextPositions) => {\\n        const nextHeadX = isHorizontal ? tail[0] : tail[0] + 1;\\n        const nextHeadY = isHorizontal ? tail[1] + 2 : tail[1] + 1;\\n        const nextTailX = tail[0], nextTailY = tail[1] + 1;\\n        const hashCode = `${nextTailX},${nextTailY},${isHorizontal}`;\\n\\n        if (\\n            grid[nextTailX] && grid[nextTailX][nextTailY] == 0 &&\\n            grid[nextHeadX] && grid[nextHeadX][nextHeadY] == 0 &&\\n            !visited.has(hashCode)\\n        ) {\\n            visited.add(hashCode);\\n            nextPositions.push({ tail: [nextTailX, nextTailY], isHorizontal });\\n        }\\n    };\\n\\n    while (queue.length > 0) {\\n        const nextPositions = [];\\n\\n        for (const { tail, isHorizontal } of queue) {\\n            if (tail[0] === n - 1 && tail[1] === n - 2)\\n                return steps;\\n\\n            rightMove(tail, isHorizontal, nextPositions), \\n            downMove(tail, isHorizontal, nextPositions), \\n            rotate(tail, isHorizontal, nextPositions)\\n        }\\n       \\n        steps++;\\n        queue = nextPositions;\\n    }\\n    \\n    return -1;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar minimumMoves = function(grid) {\\n    let queue = [{ head: [0, 0], tail: [0, -1], isHorizontal: true }], steps = 0;\\n    const visited = new Set([\"0,0,0,-1\"]);\\n    const n = grid.length;\\n    const finalPosition = `${n - 1},${n - 1},${n - 1},${n - 2}`;\\n    const dirs = [\\n        { headMove: [0, 1], tailMove: [0, 1], extraCheckForHead: [] },\\n        { headMove: [1, 0], tailMove: [1 ,0], extraCheckForHead: [] },\\n        { headMove: [1, -1], tailMove: [0, 0], extraCheckForHead: [[1, 0]], isRotate: true, horizontal: true },\\n        { headMove: [-1, 1], tailMove: [0, 0], extraCheckForHead: [[0, 1]], isRotate: true, horizontal: false }\\n    ];\\n\\n    while (queue.length > 0) {\\n        const nextPositions = [];\\n\\n        for (const { head, tail, isHorizontal } of queue) {\\n            for (const { headMove, tailMove, extraCheckForHead, isRotate, horizontal } of dirs) {\\n                if (horizontal !== undefined && isHorizontal !== horizontal)\\n                    continue;\\n\\n                const nextHeadX = head[0] + headMove[0], nextHeadY = head[1] + headMove[1];\\n                const nextTailX = tail[0] + tailMove[0], nextTailY = tail[1] + tailMove[1];\\n                const hashCode = `${nextHeadX},${nextHeadY},${nextTailX},${nextTailY}`;\\n\\n                if (hashCode === finalPosition)\\n                    return steps;\\n\\n                if (\\n                    grid[nextHeadX] && grid[nextHeadX][nextHeadY] == 0 &&\\n                    grid[nextTailX] && grid[nextTailX][nextTailY] == 0 &&\\n                    !visited.has(hashCode) && \\n                    extraCheckForHead.every(([xDir, yDir]) =>\\n                        grid[xDir + head[0]] && grid[xDir + head[0]][yDir + head[1]] == 0)\\n                ) {\\n                    nextPositions.push({\\n                        head: [nextHeadX, nextHeadY],\\n                        tail: [nextTailX, nextTailY],\\n                        isHorizontal: isRotate ? !isHorizontal : isHorizontal\\n                    })\\n                    visited.add(hashCode);                    \\n                }\\n            }\\n        }\\n\\n        steps++;\\n        queue = nextPositions;\\n    }\\n    \\n    return -1;\\n};\\n```\n```\\nvar minimumMoves = function(grid) {\\n    let queue = [{ tail: [0, 0], isHorizontal: true }], steps = 0;\\n    const visited = new Set([\"0,0,true\"]);\\n    const n = grid.length;\\n\\n    const rotate = (tail, isHorizontal, nextPositions) => {\\n        const nextHeadX = isHorizontal ? tail[0] + 1 : tail[0];\\n        const nextHeadY = isHorizontal ? tail[1] : tail[1] + 1;\\n        const hashCode = `${tail[0]},${tail[1]},${!isHorizontal}`;\\n\\n        if (\\n            grid[tail[0] + 1] && grid[tail[0] + 1][tail[1] + 1] == 0 &&\\n            grid[nextHeadX] && grid[nextHeadX][nextHeadY] == 0 &&\\n            !visited.has(hashCode)\\n        ) {\\n            visited.add(hashCode);\\n            nextPositions.push({ tail, isHorizontal: !isHorizontal });\\n        }\\n    };\\n    \\n    const downMove = (tail, isHorizontal, nextPositions) => {\\n        const nextHeadX = isHorizontal ? tail[0] + 1 : tail[0] + 2;\\n        const nextHeadY = isHorizontal ? tail[1] + 1 : tail[1];\\n        const nextTailX = tail[0] + 1, nextTailY = tail[1];\\n        const hashCode = `${nextTailX},${nextTailY},${isHorizontal}`;\\n\\n        if (\\n            grid[nextTailX] && grid[nextTailX][nextTailY] == 0 && \\n            grid[nextHeadX] && grid[nextHeadX][nextHeadY] == 0 &&\\n            !visited.has(hashCode)\\n        ) {\\n            visited.add(hashCode);\\n            nextPositions.push({ tail: [nextTailX, nextTailY], isHorizontal });\\n        }\\n    };\\n    \\n    const rightMove = (tail, isHorizontal, nextPositions) => {\\n        const nextHeadX = isHorizontal ? tail[0] : tail[0] + 1;\\n        const nextHeadY = isHorizontal ? tail[1] + 2 : tail[1] + 1;\\n        const nextTailX = tail[0], nextTailY = tail[1] + 1;\\n        const hashCode = `${nextTailX},${nextTailY},${isHorizontal}`;\\n\\n        if (\\n            grid[nextTailX] && grid[nextTailX][nextTailY] == 0 &&\\n            grid[nextHeadX] && grid[nextHeadX][nextHeadY] == 0 &&\\n            !visited.has(hashCode)\\n        ) {\\n            visited.add(hashCode);\\n            nextPositions.push({ tail: [nextTailX, nextTailY], isHorizontal });\\n        }\\n    };\\n\\n    while (queue.length > 0) {\\n        const nextPositions = [];\\n\\n        for (const { tail, isHorizontal } of queue) {\\n            if (tail[0] === n - 1 && tail[1] === n - 2)\\n                return steps;\\n\\n            rightMove(tail, isHorizontal, nextPositions), \\n            downMove(tail, isHorizontal, nextPositions), \\n            rotate(tail, isHorizontal, nextPositions)\\n        }\\n       \\n        steps++;\\n        queue = nextPositions;\\n    }\\n    \\n    return -1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1877807,
                "title": "js-bfs",
                "content": "```\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\nvar minimumMoves = function (grid) {\\n\\tconst bfs = [[0, 1, 0], null],\\n\\t\\tn = grid.length,\\n\\t\\tdir = [\\n\\t\\t\\t[\\n\\t\\t\\t\\t//horizantal\\n\\t\\t\\t\\t[0, 1, 1], //right => h\\n\\t\\t\\t\\t[1, -1, 3], //rotate clockwise => v\\n\\t\\t\\t\\t[1, 0, 5], //jump down i j-1 => h\\n\\t\\t\\t],\\n\\t\\t\\t[\\n\\t\\t\\t\\t//vertical\\n\\t\\t\\t\\t[1, 0, 2], //down => v\\n\\t\\t\\t\\t[-1, 1, 4], //rotate counter clockwise => h\\n\\t\\t\\t\\t[0, 1, 6], //jump right i-1 j => v\\n\\t\\t\\t],\\n\\t\\t],\\n\\t\\thor = [1, 4, 5],\\n\\t\\tvisited = {},\\n\\t\\tcanVisit = (i, j, dir) =>\\n\\t\\t\\tdir < 3\\n\\t\\t\\t\\t? true\\n\\t\\t\\t\\t: dir === 3\\n\\t\\t\\t\\t? j + 1 !== n && !grid[i][j + 1]\\n\\t\\t\\t\\t: dir === 4\\n\\t\\t\\t\\t? i + 1 !== n && !grid[i + 1][j]\\n\\t\\t\\t\\t: dir === 5\\n\\t\\t\\t\\t? j && !grid[i][j - 1]\\n\\t\\t\\t\\t: i && !grid[i - 1][j],\\n\\t\\tvisit = (i, j, d) => {\\n\\t\\t\\tconst isVer = hor.includes(d) ? 0 : 1;\\n\\t\\t\\tconst key = i + \",\" + j + \",\" + isVer;\\n\\t\\t\\tif (\\n\\t\\t\\t\\ti === n ||\\n\\t\\t\\t\\tj === n ||\\n\\t\\t\\t\\ti === -1 ||\\n\\t\\t\\t\\tj === -1 ||\\n\\t\\t\\t\\tvisited[key] ||\\n\\t\\t\\t\\tgrid[i][j] ||\\n\\t\\t\\t\\t!canVisit(i, j, d)\\n\\t\\t\\t)\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\tvisited[key] = true;\\n\\t\\t\\tbfs.push([i, j, isVer]);\\n\\t\\t\\treturn i === n - 1 && j === n - 1 && !isVer;\\n\\t\\t};\\n\\tlet dist = 1, i = -1;\\n\\tvisited[\"0,1,0\"] = true;\\n\\t\\n\\twhile (++i < bfs.length) {\\n\\t\\tif (!bfs[i]) {\\n\\t\\t\\tdist++;\\n\\t\\t\\tif (i + 1 < bfs.length) bfs.push(null);\\n\\t\\t\\tcontinue;\\n\\t\\t}\\n\\t\\tfor (const [x, y, d] of dir[bfs[i][2]])\\n\\t\\t\\tif (visit(bfs[i][0] + x, bfs[i][1] + y, d)) \\n\\t\\t\\t\\treturn dist;\\n\\t}\\n\\t\\n\\treturn -1;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Breadth-First Search"
                ],
                "code": "```\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\nvar minimumMoves = function (grid) {\\n\\tconst bfs = [[0, 1, 0], null],\\n\\t\\tn = grid.length,\\n\\t\\tdir = [\\n\\t\\t\\t[\\n\\t\\t\\t\\t//horizantal\\n\\t\\t\\t\\t[0, 1, 1], //right => h\\n\\t\\t\\t\\t[1, -1, 3], //rotate clockwise => v\\n\\t\\t\\t\\t[1, 0, 5], //jump down i j-1 => h\\n\\t\\t\\t],\\n\\t\\t\\t[\\n\\t\\t\\t\\t//vertical\\n\\t\\t\\t\\t[1, 0, 2], //down => v\\n\\t\\t\\t\\t[-1, 1, 4], //rotate counter clockwise => h\\n\\t\\t\\t\\t[0, 1, 6], //jump right i-1 j => v\\n\\t\\t\\t],\\n\\t\\t],\\n\\t\\thor = [1, 4, 5],\\n\\t\\tvisited = {},\\n\\t\\tcanVisit = (i, j, dir) =>\\n\\t\\t\\tdir < 3\\n\\t\\t\\t\\t? true\\n\\t\\t\\t\\t: dir === 3\\n\\t\\t\\t\\t? j + 1 !== n && !grid[i][j + 1]\\n\\t\\t\\t\\t: dir === 4\\n\\t\\t\\t\\t? i + 1 !== n && !grid[i + 1][j]\\n\\t\\t\\t\\t: dir === 5\\n\\t\\t\\t\\t? j && !grid[i][j - 1]\\n\\t\\t\\t\\t: i && !grid[i - 1][j],\\n\\t\\tvisit = (i, j, d) => {\\n\\t\\t\\tconst isVer = hor.includes(d) ? 0 : 1;\\n\\t\\t\\tconst key = i + \",\" + j + \",\" + isVer;\\n\\t\\t\\tif (\\n\\t\\t\\t\\ti === n ||\\n\\t\\t\\t\\tj === n ||\\n\\t\\t\\t\\ti === -1 ||\\n\\t\\t\\t\\tj === -1 ||\\n\\t\\t\\t\\tvisited[key] ||\\n\\t\\t\\t\\tgrid[i][j] ||\\n\\t\\t\\t\\t!canVisit(i, j, d)\\n\\t\\t\\t)\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\tvisited[key] = true;\\n\\t\\t\\tbfs.push([i, j, isVer]);\\n\\t\\t\\treturn i === n - 1 && j === n - 1 && !isVer;\\n\\t\\t};\\n\\tlet dist = 1, i = -1;\\n\\tvisited[\"0,1,0\"] = true;\\n\\t\\n\\twhile (++i < bfs.length) {\\n\\t\\tif (!bfs[i]) {\\n\\t\\t\\tdist++;\\n\\t\\t\\tif (i + 1 < bfs.length) bfs.push(null);\\n\\t\\t\\tcontinue;\\n\\t\\t}\\n\\t\\tfor (const [x, y, d] of dir[bfs[i][2]])\\n\\t\\t\\tif (visit(bfs[i][0] + x, bfs[i][1] + y, d)) \\n\\t\\t\\t\\treturn dist;\\n\\t}\\n\\t\\n\\treturn -1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1836261,
                "title": "golang-bfs-solution",
                "content": "```go\\nconst (\\n\\thorizontal = 1\\n\\tvertical   = 2\\n)\\n\\nfunc minimumMoves(grid [][]int) int {\\n\\t// [rowOfTail, colOfTail, direction]\\n\\tcurrent := [3]int{0, 0, horizontal}\\n\\ttarget := [3]int{len(grid) - 1, len(grid) - 2, horizontal}\\n\\tfootprint := map[[3]int]bool{current: true}\\n\\treturn bfs(grid, footprint, [][3]int{current}, target)\\n}\\n\\nfunc bfs(grid [][]int, footprint map[[3]int]bool, current [][3]int, target [3]int) int {\\n\\tstep := 0\\n\\tfor len(current) != 0 {\\n\\t\\tnext := make([][3]int, 0, len(current))\\n\\t\\tstep++\\n\\t\\tfor _, v := range current {\\n\\t\\t\\trowTail, colTail, direction := v[0], v[1], v[2]\\n\\t\\t\\tif direction == horizontal {\\n\\t\\t\\t\\tnextRight := [3]int{rowTail, colTail + 1, direction}\\n\\t\\t\\t\\t// col of head will be colTail+2\\n\\t\\t\\t\\tif colTail+2 < len(grid) && grid[rowTail][colTail+2] == 0 && footprint[nextRight] == false {\\n\\t\\t\\t\\t\\tfootprint[nextRight] = true\\n\\t\\t\\t\\t\\tnext = append(next, nextRight)\\n\\t\\t\\t\\t\\tif nextRight == target {\\n\\t\\t\\t\\t\\t\\treturn step\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tnextDown := [3]int{rowTail + 1, colTail, direction}\\n\\t\\t\\t\\tif rowTail+1 < len(grid) && grid[rowTail+1][colTail]+grid[rowTail+1][colTail+1] == 0 && footprint[nextDown] == false {\\n\\t\\t\\t\\t\\tfootprint[nextDown] = true\\n\\t\\t\\t\\t\\tnext = append(next, nextDown)\\n\\t\\t\\t\\t\\tif nextDown == target {\\n\\t\\t\\t\\t\\t\\treturn step\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t// change direction\\n\\t\\t\\t\\tnextTurn := [3]int{rowTail, colTail, vertical}\\n\\t\\t\\t\\tif rowTail+1 < len(grid) && grid[rowTail+1][colTail]+grid[rowTail+1][colTail+1] == 0 && footprint[nextTurn] == false {\\n\\t\\t\\t\\t\\tfootprint[nextTurn] = true\\n\\t\\t\\t\\t\\tnext = append(next, nextTurn)\\n\\t\\t\\t\\t\\tif nextTurn == target {\\n\\t\\t\\t\\t\\t\\treturn step\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tnextDown := [3]int{rowTail + 1, colTail, direction}\\n\\t\\t\\t\\tif rowTail+2 < len(grid) && grid[rowTail+2][colTail] == 0 && footprint[nextDown] == false {\\n\\t\\t\\t\\t\\tfootprint[nextDown] = true\\n\\t\\t\\t\\t\\tnext = append(next, nextDown)\\n\\t\\t\\t\\t\\tif nextDown == target {\\n\\t\\t\\t\\t\\t\\treturn step\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tnextRight := [3]int{rowTail, colTail + 1, direction}\\n\\t\\t\\t\\tif colTail+1 < len(grid) && grid[rowTail][colTail+1]+grid[rowTail+1][colTail+1] == 0 && footprint[nextRight] == false {\\n\\t\\t\\t\\t\\tfootprint[nextRight] = true\\n\\t\\t\\t\\t\\tnext = append(next, nextRight)\\n\\t\\t\\t\\t\\tif nextRight == target {\\n\\t\\t\\t\\t\\t\\treturn step\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tnextTurn := [3]int{rowTail, colTail, horizontal}\\n\\t\\t\\t\\tif colTail+1 < len(grid) && grid[rowTail][colTail+1]+grid[rowTail+1][colTail+1] == 0 && footprint[nextTurn] == false {\\n\\t\\t\\t\\t\\tfootprint[nextTurn] = true\\n\\t\\t\\t\\t\\tnext = append(next, nextTurn)\\n\\t\\t\\t\\t\\tif nextTurn == target {\\n\\t\\t\\t\\t\\t\\treturn step\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tcurrent = next\\n\\t}\\n\\treturn -1\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Breadth-First Search"
                ],
                "code": "```go\\nconst (\\n\\thorizontal = 1\\n\\tvertical   = 2\\n)\\n\\nfunc minimumMoves(grid [][]int) int {\\n\\t// [rowOfTail, colOfTail, direction]\\n\\tcurrent := [3]int{0, 0, horizontal}\\n\\ttarget := [3]int{len(grid) - 1, len(grid) - 2, horizontal}\\n\\tfootprint := map[[3]int]bool{current: true}\\n\\treturn bfs(grid, footprint, [][3]int{current}, target)\\n}\\n\\nfunc bfs(grid [][]int, footprint map[[3]int]bool, current [][3]int, target [3]int) int {\\n\\tstep := 0\\n\\tfor len(current) != 0 {\\n\\t\\tnext := make([][3]int, 0, len(current))\\n\\t\\tstep++\\n\\t\\tfor _, v := range current {\\n\\t\\t\\trowTail, colTail, direction := v[0], v[1], v[2]\\n\\t\\t\\tif direction == horizontal {\\n\\t\\t\\t\\tnextRight := [3]int{rowTail, colTail + 1, direction}\\n\\t\\t\\t\\t// col of head will be colTail+2\\n\\t\\t\\t\\tif colTail+2 < len(grid) && grid[rowTail][colTail+2] == 0 && footprint[nextRight] == false {\\n\\t\\t\\t\\t\\tfootprint[nextRight] = true\\n\\t\\t\\t\\t\\tnext = append(next, nextRight)\\n\\t\\t\\t\\t\\tif nextRight == target {\\n\\t\\t\\t\\t\\t\\treturn step\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tnextDown := [3]int{rowTail + 1, colTail, direction}\\n\\t\\t\\t\\tif rowTail+1 < len(grid) && grid[rowTail+1][colTail]+grid[rowTail+1][colTail+1] == 0 && footprint[nextDown] == false {\\n\\t\\t\\t\\t\\tfootprint[nextDown] = true\\n\\t\\t\\t\\t\\tnext = append(next, nextDown)\\n\\t\\t\\t\\t\\tif nextDown == target {\\n\\t\\t\\t\\t\\t\\treturn step\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t// change direction\\n\\t\\t\\t\\tnextTurn := [3]int{rowTail, colTail, vertical}\\n\\t\\t\\t\\tif rowTail+1 < len(grid) && grid[rowTail+1][colTail]+grid[rowTail+1][colTail+1] == 0 && footprint[nextTurn] == false {\\n\\t\\t\\t\\t\\tfootprint[nextTurn] = true\\n\\t\\t\\t\\t\\tnext = append(next, nextTurn)\\n\\t\\t\\t\\t\\tif nextTurn == target {\\n\\t\\t\\t\\t\\t\\treturn step\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tnextDown := [3]int{rowTail + 1, colTail, direction}\\n\\t\\t\\t\\tif rowTail+2 < len(grid) && grid[rowTail+2][colTail] == 0 && footprint[nextDown] == false {\\n\\t\\t\\t\\t\\tfootprint[nextDown] = true\\n\\t\\t\\t\\t\\tnext = append(next, nextDown)\\n\\t\\t\\t\\t\\tif nextDown == target {\\n\\t\\t\\t\\t\\t\\treturn step\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tnextRight := [3]int{rowTail, colTail + 1, direction}\\n\\t\\t\\t\\tif colTail+1 < len(grid) && grid[rowTail][colTail+1]+grid[rowTail+1][colTail+1] == 0 && footprint[nextRight] == false {\\n\\t\\t\\t\\t\\tfootprint[nextRight] = true\\n\\t\\t\\t\\t\\tnext = append(next, nextRight)\\n\\t\\t\\t\\t\\tif nextRight == target {\\n\\t\\t\\t\\t\\t\\treturn step\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tnextTurn := [3]int{rowTail, colTail, horizontal}\\n\\t\\t\\t\\tif colTail+1 < len(grid) && grid[rowTail][colTail+1]+grid[rowTail+1][colTail+1] == 0 && footprint[nextTurn] == false {\\n\\t\\t\\t\\t\\tfootprint[nextTurn] = true\\n\\t\\t\\t\\t\\tnext = append(next, nextTurn)\\n\\t\\t\\t\\t\\tif nextTurn == target {\\n\\t\\t\\t\\t\\t\\treturn step\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tcurrent = next\\n\\t}\\n\\treturn -1\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1821124,
                "title": "c-bfs-o-n2",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int minimumMoves(vector<vector<int>>& grid) {\\n    \\n        int n=grid.size();\\n\\n        queue<array<int,4>> q;\\n        \\n        q.push({0,0,0,1});\\n        \\n        int ans=0;\\n        \\n        set<array<int,4>> st;\\n        \\n        st.insert({0,0,0,1});\\n        \\n        while(!q.empty()){\\n            \\n        \\n            int sz=q.size();\\n            \\n            while(sz--){\\n                array<int,4> ar=q.front();\\n                \\n                q.pop();\\n                \\n                if(ar[0]==n-1 and ar[1]==n-2 and ar[2]==n-1 and ar[3]==n-1)\\n                    return ans;\\n                \\n                if(ar[1]!=ar[3]){\\n                    if(ar[3]+1<n and grid[ar[2]][ar[3]+1]==0 and !st.count({ar[0],ar[1]+1,ar[2],ar[3]+1}))\\n                    {\\n                        q.push({ar[0],ar[1]+1,ar[2],ar[3]+1});\\n                        st.insert({ar[0],ar[1]+1,ar[2],ar[3]+1});\\n                    }\\n                    \\n                    if(ar[0]+1<n and grid[ar[0]+1][ar[1]]==0 and grid[ar[2]+1][ar[3]]==0 and !st.count({ar[0]+1,ar[1],ar[2]+1,ar[3]}))\\n                    {\\n                        q.push({ar[0]+1,ar[1],ar[2]+1,ar[3]});\\n                        st.insert({ar[0]+1,ar[1],ar[2]+1,ar[3]});\\n                    }\\n                    \\n                    if(ar[0]+1<n and grid[ar[0]+1][ar[1]]==0  and grid[ar[0]+1][ar[3]]==0 and !st.count({ar[0],ar[1],ar[0]+1,ar[1]}))\\n                    {\\n                        q.push({ar[0],ar[1],ar[0]+1,ar[1]});\\n                        st.insert({ar[0],ar[1],ar[0]+1,ar[1]});\\n                    }\\n                }\\n                else{\\n                    if(ar[2]+1<n and grid[ar[2]+1][ar[3]]==0 and !st.count({ar[2],ar[3],ar[2]+1,ar[3]}))\\n                    {\\n                        q.push({ar[2],ar[3],ar[2]+1,ar[3]});\\n                        st.insert({ar[2],ar[3],ar[2]+1,ar[3]});\\n                    }\\n                    \\n                    if(ar[1]+1<n and grid[ar[0]][ar[1]+1]==0 and grid[ar[2]][ar[3]+1]==0 and !st.count({ar[0],ar[1]+1,ar[2],ar[3]+1}))\\n                    {\\n                        q.push({ar[0],ar[1]+1,ar[2],ar[3]+1});\\n                        st.insert({ar[0],ar[1]+1,ar[2],ar[3]+1});\\n                    }\\n                    \\n                    if(ar[1]+1<n and grid[ar[0]][ar[1]+1]==0 and grid[ar[2]][ar[1]+1]==0 and !st.count({ar[0],ar[1],ar[0],ar[1]+1}))\\n                    {\\n                        q.push({ar[0],ar[1],ar[0],ar[1]+1});\\n                        st.insert({ar[0],ar[1],ar[0],ar[1]+1});\\n                    }\\n                }\\n                \\n            }\\n            ans++;\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int minimumMoves(vector<vector<int>>& grid) {\\n    \\n        int n=grid.size();\\n\\n        queue<array<int,4>> q;\\n        \\n        q.push({0,0,0,1});\\n        \\n        int ans=0;\\n        \\n        set<array<int,4>> st;\\n        \\n        st.insert({0,0,0,1});\\n        \\n        while(!q.empty()){\\n            \\n        \\n            int sz=q.size();\\n            \\n            while(sz--){\\n                array<int,4> ar=q.front();\\n                \\n                q.pop();\\n                \\n                if(ar[0]==n-1 and ar[1]==n-2 and ar[2]==n-1 and ar[3]==n-1)\\n                    return ans;\\n                \\n                if(ar[1]!=ar[3]){\\n                    if(ar[3]+1<n and grid[ar[2]][ar[3]+1]==0 and !st.count({ar[0],ar[1]+1,ar[2],ar[3]+1}))\\n                    {\\n                        q.push({ar[0],ar[1]+1,ar[2],ar[3]+1});\\n                        st.insert({ar[0],ar[1]+1,ar[2],ar[3]+1});\\n                    }\\n                    \\n                    if(ar[0]+1<n and grid[ar[0]+1][ar[1]]==0 and grid[ar[2]+1][ar[3]]==0 and !st.count({ar[0]+1,ar[1],ar[2]+1,ar[3]}))\\n                    {\\n                        q.push({ar[0]+1,ar[1],ar[2]+1,ar[3]});\\n                        st.insert({ar[0]+1,ar[1],ar[2]+1,ar[3]});\\n                    }\\n                    \\n                    if(ar[0]+1<n and grid[ar[0]+1][ar[1]]==0  and grid[ar[0]+1][ar[3]]==0 and !st.count({ar[0],ar[1],ar[0]+1,ar[1]}))\\n                    {\\n                        q.push({ar[0],ar[1],ar[0]+1,ar[1]});\\n                        st.insert({ar[0],ar[1],ar[0]+1,ar[1]});\\n                    }\\n                }\\n                else{\\n                    if(ar[2]+1<n and grid[ar[2]+1][ar[3]]==0 and !st.count({ar[2],ar[3],ar[2]+1,ar[3]}))\\n                    {\\n                        q.push({ar[2],ar[3],ar[2]+1,ar[3]});\\n                        st.insert({ar[2],ar[3],ar[2]+1,ar[3]});\\n                    }\\n                    \\n                    if(ar[1]+1<n and grid[ar[0]][ar[1]+1]==0 and grid[ar[2]][ar[3]+1]==0 and !st.count({ar[0],ar[1]+1,ar[2],ar[3]+1}))\\n                    {\\n                        q.push({ar[0],ar[1]+1,ar[2],ar[3]+1});\\n                        st.insert({ar[0],ar[1]+1,ar[2],ar[3]+1});\\n                    }\\n                    \\n                    if(ar[1]+1<n and grid[ar[0]][ar[1]+1]==0 and grid[ar[2]][ar[1]+1]==0 and !st.count({ar[0],ar[1],ar[0],ar[1]+1}))\\n                    {\\n                        q.push({ar[0],ar[1],ar[0],ar[1]+1});\\n                        st.insert({ar[0],ar[1],ar[0],ar[1]+1});\\n                    }\\n                }\\n                \\n            }\\n            ans++;\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1746351,
                "title": "c-bottom-up-dp-recursive-relation-explanation-o-n-2",
                "content": "**State( {i,j}, orientation)** - {i,j} is position of tail, orientation is either 0 (horizontal) or 1(vertical)\\n**T( state )** = minimum number of steps to reach the end from this state.\\n**T( state )** = min_i ( T (  state_i ) ) + 1 , where state_i is a neighbor of state\\n\\n**state( (i,j) , horizontal ) neighbors** :\\n\\t\\tstate( (i,j+1), horizontal ) *Move right horizontally*\\n\\t\\tstate( (i+1,j), horizontal ) *Move down horizontally*\\n\\t\\tstate( (i,j)    , vertical      ) *Rotate clockwise*\\n\\t\\n**state( (i,j), vertical ) neighbors** :\\n\\t\\tstate( (i+1,j), vertical ) *Move down vertically*\\n\\t\\tstate( (i,j+1), vertical ) *Move right vertically*\\n\\t\\tstate( (i,j)    , horizontal ) *Rotate counter clockwise*\\n\\n```\\nclass Solution {\\npublic:\\n    int minimumMoves(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        unsigned int d[n][n][2];\\n        for(int i=0; i<n; i++)\\n            for(int j=0; j<n; j++)\\n                for(int k=0; k<2; k++)\\n                    d[i][j][k] = INT_MAX;\\n        \\n        if(grid[n-1][n-1] == 1 || grid[n-1][n-2] == 1)\\n            return -1;\\n        \\n        d[n-1][n-2][0] = 0;\\n        \\n        for(int i = n-1; i>=0; i--){\\n            for(int j = n-1; j>=0; j--){\\n                if(grid[i][j] == 1)\\n                    continue;\\n                //Move right horizontally\\n                if(j+2 < n && grid[i][j+1] == 0 && grid[i][j+2] == 0)\\n                    d[i][j][0] = min({d[i][j][0], d[i][j+1][0] + 1, (unsigned int)INT_MAX});\\n                \\n                //Move right vertically or Move down horizontally\\n                if(i+1 < n && j+1 < n && grid[i][j+1] == 0 && grid[i+1][j] == 0 && grid[i+1][j+1] == 0){\\n                    d[i][j][1] = min({d[i][j][1], d[i][j+1][1] + 1, (unsigned int)INT_MAX});\\n                    d[i][j][0] = min({d[i][j][0], d[i+1][j][0] + 1, (unsigned int)INT_MAX});\\n                }\\n                \\n                //Move down vertically\\n                if(i+2 < n && grid[i+1][j] == 0 && grid[i+2][j] == 0)\\n                    d[i][j][1] = min({d[i][j][1], d[i+1][j][1] + 1, (unsigned int)INT_MAX});\\n                \\n                //Rotate\\n                if(i+1 < n && j+1 < n && grid[i][j+1] == 0 && grid[i+1][j] == 0 && grid[i+1][j+1] == 0){\\n                    d[i][j][0] = min({d[i][j][0],d[i][j][1] + 1, (unsigned int)INT_MAX});\\n                    d[i][j][1] = min({d[i][j][1],d[i][j][0] + 1, (unsigned int)INT_MAX});\\n                }\\n            }\\n        }\\n                \\n        if(d[0][0][0] == INT_MAX)\\n            return -1;\\n        else\\n            return d[0][0][0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumMoves(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        unsigned int d[n][n][2];\\n        for(int i=0; i<n; i++)\\n            for(int j=0; j<n; j++)\\n                for(int k=0; k<2; k++)\\n                    d[i][j][k] = INT_MAX;\\n        \\n        if(grid[n-1][n-1] == 1 || grid[n-1][n-2] == 1)\\n            return -1;\\n        \\n        d[n-1][n-2][0] = 0;\\n        \\n        for(int i = n-1; i>=0; i--){\\n            for(int j = n-1; j>=0; j--){\\n                if(grid[i][j] == 1)\\n                    continue;\\n                //Move right horizontally\\n                if(j+2 < n && grid[i][j+1] == 0 && grid[i][j+2] == 0)\\n                    d[i][j][0] = min({d[i][j][0], d[i][j+1][0] + 1, (unsigned int)INT_MAX});\\n                \\n                //Move right vertically or Move down horizontally\\n                if(i+1 < n && j+1 < n && grid[i][j+1] == 0 && grid[i+1][j] == 0 && grid[i+1][j+1] == 0){\\n                    d[i][j][1] = min({d[i][j][1], d[i][j+1][1] + 1, (unsigned int)INT_MAX});\\n                    d[i][j][0] = min({d[i][j][0], d[i+1][j][0] + 1, (unsigned int)INT_MAX});\\n                }\\n                \\n                //Move down vertically\\n                if(i+2 < n && grid[i+1][j] == 0 && grid[i+2][j] == 0)\\n                    d[i][j][1] = min({d[i][j][1], d[i+1][j][1] + 1, (unsigned int)INT_MAX});\\n                \\n                //Rotate\\n                if(i+1 < n && j+1 < n && grid[i][j+1] == 0 && grid[i+1][j] == 0 && grid[i+1][j+1] == 0){\\n                    d[i][j][0] = min({d[i][j][0],d[i][j][1] + 1, (unsigned int)INT_MAX});\\n                    d[i][j][1] = min({d[i][j][1],d[i][j][0] + 1, (unsigned int)INT_MAX});\\n                }\\n            }\\n        }\\n                \\n        if(d[0][0][0] == INT_MAX)\\n            return -1;\\n        else\\n            return d[0][0][0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1666800,
                "title": "java-bfs",
                "content": "The head of the snake is at r,c \\n\\n```\\nclass Solution {\\n    \\n    class Data {\\n\\n        int r, c;\\n        int pos;\\n        int steps;\\n\\n        public Data(int row, int col, int pos, int steps) {\\n            this.r = row;\\n            this.c = col;\\n            this.pos = pos;\\n            this.steps = steps;\\n        }\\n\\n        @Override\\n        public String toString() {\\n            return \"Data{\" +\\n                    \"r=\" + r +\\n                    \", c=\" + c +\\n                    \\'}\\';\\n        }\\n\\n        @Override\\n        public boolean equals(Object o) {\\n            if (this == o) return true;\\n            if (o == null || getClass() != o.getClass()) return false;\\n            Data data = (Data) o;\\n            return r == data.r && c == data.c && pos == data.pos;\\n        }\\n\\n        @Override\\n        public int hashCode() {\\n            return Objects.hash(r, c, pos);\\n        }\\n    }\\n\\n    private boolean inside(int row, int col, int[][] grid) {\\n        return row >= 0 && col >= 0 && row < grid.length && col < grid[row].length;\\n    }\\n\\n    public int minimumMoves(int[][] grid) {\\n        Queue<Data> queue = new LinkedList<>();\\n        int n = grid.length;\\n        queue.add(new Data(0, 1, 0, 0));\\n        HashSet<Data> visited = new HashSet<>();\\n        while (!queue.isEmpty()) {\\n            Data curr = queue.poll();\\n            if (curr.r == n - 1 && curr.c == n - 1 && curr.pos == 0) {\\n                return curr.steps;\\n            }\\n            //System.out.println(curr + \" \" + curr.pos);\\n            if (!visited.contains(curr)) {\\n                visited.add(curr);\\n                if (curr.pos == 0) {\\n                    //move right\\n                    if (inside(curr.r, curr.c + 1, grid) && grid[curr.r][curr.c + 1] == 0) {\\n                        queue.add(new Data(curr.r, curr.c + 1, curr.pos, curr.steps + 1));\\n                    }\\n                    //move down\\n                    if (inside(curr.r + 1, curr.c, grid) && inside(curr.r + 1, curr.c - 1, grid) && grid[curr.r + 1][curr.c - 1] == 0 && grid[curr.r + 1][curr.c] == 0) {\\n                        queue.add(new Data(curr.r + 1, curr.c, curr.pos, curr.steps + 1));\\n                    }\\n                    //rotate clockwise\\n                    if (inside(curr.r + 1, curr.c, grid) && inside(curr.r + 1, curr.c - 1, grid) && curr.pos == 0 && grid[curr.r + 1][curr.c] == 0 && grid[curr.r + 1][curr.c - 1] == 0) {\\n                        queue.add(new Data(curr.r + 1, curr.c - 1, 1, curr.steps + 1));\\n                    }\\n                } else if (curr.pos == 1) {\\n                    //rotate anticlockwise\\n                    if (inside(curr.r, curr.c + 1, grid) && inside(curr.r - 1, curr.c + 1, grid) && grid[curr.r][curr.c + 1] == 0 && grid[curr.r - 1][curr.c + 1] == 0) {\\n                        queue.add(new Data(curr.r - 1, curr.c + 1, 0, curr.steps + 1));\\n                    }\\n                    //move down\\n                    if (inside(curr.r + 1, curr.c, grid) && grid[curr.r + 1][curr.c] == 0) {\\n                        queue.add(new Data(curr.r + 1, curr.c, curr.pos, curr.steps + 1));\\n                    }\\n                    //move right\\n                    if (inside(curr.r, curr.c + 1, grid) && inside(curr.r - 1, curr.c + 1, grid) && grid[curr.r][curr.c + 1] == 0 && grid[curr.r - 1][curr.c + 1] == 0) {\\n                        queue.add(new Data(curr.r, curr.c + 1, curr.pos, curr.steps + 1));\\n                    }\\n                }\\n            }\\n\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    class Data {\\n\\n        int r, c;\\n        int pos;\\n        int steps;\\n\\n        public Data(int row, int col, int pos, int steps) {\\n            this.r = row;\\n            this.c = col;\\n            this.pos = pos;\\n            this.steps = steps;\\n        }\\n\\n        @Override\\n        public String toString() {\\n            return \"Data{\" +\\n                    \"r=\" + r +\\n                    \", c=\" + c +\\n                    \\'}\\';\\n        }\\n\\n        @Override\\n        public boolean equals(Object o) {\\n            if (this == o) return true;\\n            if (o == null || getClass() != o.getClass()) return false;\\n            Data data = (Data) o;\\n            return r == data.r && c == data.c && pos == data.pos;\\n        }\\n\\n        @Override\\n        public int hashCode() {\\n            return Objects.hash(r, c, pos);\\n        }\\n    }\\n\\n    private boolean inside(int row, int col, int[][] grid) {\\n        return row >= 0 && col >= 0 && row < grid.length && col < grid[row].length;\\n    }\\n\\n    public int minimumMoves(int[][] grid) {\\n        Queue<Data> queue = new LinkedList<>();\\n        int n = grid.length;\\n        queue.add(new Data(0, 1, 0, 0));\\n        HashSet<Data> visited = new HashSet<>();\\n        while (!queue.isEmpty()) {\\n            Data curr = queue.poll();\\n            if (curr.r == n - 1 && curr.c == n - 1 && curr.pos == 0) {\\n                return curr.steps;\\n            }\\n            //System.out.println(curr + \" \" + curr.pos);\\n            if (!visited.contains(curr)) {\\n                visited.add(curr);\\n                if (curr.pos == 0) {\\n                    //move right\\n                    if (inside(curr.r, curr.c + 1, grid) && grid[curr.r][curr.c + 1] == 0) {\\n                        queue.add(new Data(curr.r, curr.c + 1, curr.pos, curr.steps + 1));\\n                    }\\n                    //move down\\n                    if (inside(curr.r + 1, curr.c, grid) && inside(curr.r + 1, curr.c - 1, grid) && grid[curr.r + 1][curr.c - 1] == 0 && grid[curr.r + 1][curr.c] == 0) {\\n                        queue.add(new Data(curr.r + 1, curr.c, curr.pos, curr.steps + 1));\\n                    }\\n                    //rotate clockwise\\n                    if (inside(curr.r + 1, curr.c, grid) && inside(curr.r + 1, curr.c - 1, grid) && curr.pos == 0 && grid[curr.r + 1][curr.c] == 0 && grid[curr.r + 1][curr.c - 1] == 0) {\\n                        queue.add(new Data(curr.r + 1, curr.c - 1, 1, curr.steps + 1));\\n                    }\\n                } else if (curr.pos == 1) {\\n                    //rotate anticlockwise\\n                    if (inside(curr.r, curr.c + 1, grid) && inside(curr.r - 1, curr.c + 1, grid) && grid[curr.r][curr.c + 1] == 0 && grid[curr.r - 1][curr.c + 1] == 0) {\\n                        queue.add(new Data(curr.r - 1, curr.c + 1, 0, curr.steps + 1));\\n                    }\\n                    //move down\\n                    if (inside(curr.r + 1, curr.c, grid) && grid[curr.r + 1][curr.c] == 0) {\\n                        queue.add(new Data(curr.r + 1, curr.c, curr.pos, curr.steps + 1));\\n                    }\\n                    //move right\\n                    if (inside(curr.r, curr.c + 1, grid) && inside(curr.r - 1, curr.c + 1, grid) && grid[curr.r][curr.c + 1] == 0 && grid[curr.r - 1][curr.c + 1] == 0) {\\n                        queue.add(new Data(curr.r, curr.c + 1, curr.pos, curr.steps + 1));\\n                    }\\n                }\\n            }\\n\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1656775,
                "title": "python-bfs-template-explanation",
                "content": "* My BFS state space consists of 3 attributes - (row, col, state \\'H\\' or \\'V\\') where row and col are indices of snake head and state is the orientation of the snake, and I track distance throughtout the algo.\\n* All possible moves are listed in findNeighbors function.\\n* Let me know in the comments if you have any questions.\\n```\\nclass Solution:\\n    def minimumMoves(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n        \\n        def findNeighbors(head, state):\\n            actual = []\\n            x, y = head\\n            if state == \\'H\\':\\n                # go right when horizontal\\n                if y + 1 <= n - 1 and grid[x][y + 1] == 0:\\n                    actual.append((x, y + 1, \\'H\\'))\\n                    \\n                # go down when horizontal\\n                if x + 1 <= n - 1 and grid[x + 1][y] == 0 and grid[x + 1][y - 1] == 0:\\n                    actual.append((x + 1, y, \\'H\\'))\\n                    \\n                    # can rotate clkwise here\\n                    actual.append((x + 1, y - 1, \\'V\\'))\\n                    \\n            else:\\n                # go down when vertical\\n                if x + 1 <= n - 1 and grid[x + 1][y] == 0:\\n                    actual.append((x + 1, y, \\'V\\'))\\n                    \\n                # go right when vertical\\n                if y + 1 <= n - 1 and grid[x][y + 1] == 0 and grid[x - 1][y + 1] == 0:\\n                    actual.append((x, y + 1, \\'V\\'))\\n                    \\n                    # can rotate anti clkwise here\\n                    actual.append((x - 1, y + 1, \\'H\\'))\\n                    \\n            return actual\\n        \\n        visited = set()\\n        q = deque()\\n        q.append((0, 1, \\'H\\', 0))\\n        \\n        while q:\\n            x, y, state, dist = q.popleft()\\n            if (x, y, state) == (n - 1, n - 1, \\'H\\'):\\n                return dist\\n            \\n            if (x, y, state) in visited:\\n                continue\\n                \\n            visited.add((x, y, state))\\n            \\n            for nx, ny, ndir in findNeighbors((x, y), state):\\n                q.append((nx, ny, ndir, dist + 1))\\n                \\n        return -1",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "* My BFS state space consists of 3 attributes - (row, col, state \\'H\\' or \\'V\\') where row and col are indices of snake head and state is the orientation of the snake, and I track distance throughtout the algo.\\n* All possible moves are listed in findNeighbors function.\\n* Let me know in the comments if you have any questions.\\n```\\nclass Solution:\\n    def minimumMoves(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n        \\n        def findNeighbors(head, state):\\n            actual = []\\n            x, y = head\\n            if state == \\'H\\':\\n                # go right when horizontal\\n                if y + 1 <= n - 1 and grid[x][y + 1] == 0:\\n                    actual.append((x, y + 1, \\'H\\'))\\n                    \\n                # go down when horizontal\\n                if x + 1 <= n - 1 and grid[x + 1][y] == 0 and grid[x + 1][y - 1] == 0:\\n                    actual.append((x + 1, y, \\'H\\'))\\n                    \\n                    # can rotate clkwise here\\n                    actual.append((x + 1, y - 1, \\'V\\'))\\n                    \\n            else:\\n                # go down when vertical\\n                if x + 1 <= n - 1 and grid[x + 1][y] == 0:\\n                    actual.append((x + 1, y, \\'V\\'))\\n                    \\n                # go right when vertical\\n                if y + 1 <= n - 1 and grid[x][y + 1] == 0 and grid[x - 1][y + 1] == 0:\\n                    actual.append((x, y + 1, \\'V\\'))\\n                    \\n                    # can rotate anti clkwise here\\n                    actual.append((x - 1, y + 1, \\'H\\'))\\n                    \\n            return actual\\n        \\n        visited = set()\\n        q = deque()\\n        q.append((0, 1, \\'H\\', 0))\\n        \\n        while q:\\n            x, y, state, dist = q.popleft()\\n            if (x, y, state) == (n - 1, n - 1, \\'H\\'):\\n                return dist\\n            \\n            if (x, y, state) in visited:\\n                continue\\n                \\n            visited.add((x, y, state))\\n            \\n            for nx, ny, ndir in findNeighbors((x, y), state):\\n                q.append((nx, ny, ndir, dist + 1))\\n                \\n        return -1",
                "codeTag": "Java"
            },
            {
                "id": 1649475,
                "title": "java-bfs-with-memoization-with-explanation",
                "content": "A few nits about this problem that I found myself overlooked when solving it that led to long time of debugging:\\n1. snake needs to have its head at (n-1, n-1) in a **horizontal** position, so just landing at bottom right is not enough\\n2. when rotating clockwise or counter-clockwise, the 2 elements below/to the right of the current positions of snake need to **both** be 0\\n\\n\\nIn my algorithm I transformed the problem to be the minimal number of steps needed to have head of snake in bottom right in a horizontal position, then the idea of this algorithm is ordinary BFS: given any element in the array, check if snake can have its head in this position, and if so, depending on legit directions it can be, can be either horizontal or vertical, find all the possible next positions of head.\\n\\ncode snippet\\n```\\n\\nclass Solution {\\n    public int minimumMoves(int[][] grid) {\\n        int rows = grid.length;\\n        int columns = grid[0].length;\\n        Boolean[][] right = new Boolean[rows][columns]; // if head at (i, j) can be horizontal\\n        Boolean[][] down = new Boolean[rows][columns]; // if head at (i, j) can be vertical\\n        int[][] minMovesRight = new int[rows][columns]; // min moves ending with head at (i,j) horizontally\\n        int[][] minMovesDown = new int[rows][columns]; // min moves ending with head at (i,j) vertically\\n        Boolean[][] visited = new Boolean[rows][columns]; // if head at (i, j) is already visited of its neighbors\\n        Queue<int[]> cellsToVisit = new LinkedList<>();\\n        // initalize values\\n        for (int i = 0; i < rows; i++) {\\n            Arrays.fill(minMovesRight[i], -1);\\n            Arrays.fill(minMovesDown[i], -1);\\n            Arrays.fill(right[i], false);\\n            Arrays.fill(down[i], false);\\n            Arrays.fill(visited[i], false);\\n        }\\n\\t\\t// we know snake head is initialized horizontally in (0, 1)\\n        right[0][1] = true;\\n        minMovesRight[0][1] = 0;\\n        cellsToVisit.add(new int[]{0, 1});\\n        \\n        while (cellsToVisit.size() > 0) {\\n            int[] cell = cellsToVisit.poll();\\n            int x = cell[0];\\n            int y = cell[1];\\n            if (visited[x][y]) {\\n                continue;\\n            }\\n            visited[x][y] = true;\\n            // if head can be at (x, y) horizontally, check (x, y+1), (x+1, y-1) and (x+1, y)\\n            if (right[x][y] == true) {\\n                if (y+1 < columns && grid[x][y+1] == 0) {\\n                    right[x][y+1] = true;\\n                    cellsToVisit.add(new int[]{x, y+1});\\n                    minMovesRight[x][y+1] = minMovesRight[x][y+1] == -1\\n                            ? minMovesRight[x][y] + 1\\n                            : Math.min(minMovesRight[x][y+1], minMovesRight[x][y] + 1);\\n                }\\n                // now check if we can rotate clock-wise or downward by 1 row\\n                if (x+1 < rows && y-1 >= 0 && grid[x+1][y-1] == 0 && grid[x+1][y] == 0) {\\n                    // rotate clock-wise\\n                    down[x+1][y-1] = true;\\n                    minMovesDown[x+1][y-1] = minMovesDown[x+1][y-1] == -1\\n                        ? minMovesRight[x][y] + 1\\n                        : Math.min(minMovesDown[x+1][y-1], minMovesRight[x][y] + 1);\\n                    cellsToVisit.add(new int[]{x+1, y-1});\\n                    // move downward by 1 row\\n                    right[x+1][y] = true;\\n                    minMovesRight[x+1][y] = minMovesRight[x+1][y] == -1\\n                        ? minMovesRight[x][y] + 1\\n                        : Math.min(minMovesRight[x+1][y], minMovesRight[x][y] + 1);\\n                    cellsToVisit.add(new int[]{x+1, y});\\n                }\\n            }\\n            \\n            // if head can be at (x, y) vertically, check (x+1, y), (x-1, y+1) and (x, y+1) \\n            if (down[x][y] == true) {\\n                if (x+1 < rows && grid[x+1][y] == 0) {\\n                    down[x+1][y] = true;\\n                    minMovesDown[x+1][y] = minMovesDown[x+1][y] == -1\\n                            ? minMovesDown[x][y] + 1\\n                            : Math.min(minMovesDown[x+1][y], minMovesDown[x][y] + 1);\\n                    cellsToVisit.add(new int[]{x+1, y});\\n                }\\n                // now check if we can rotate counter-clock-wise or right-ward by 1 column\\n                if (y+1 < columns && x-1 >= 0 && grid[x-1][y+1] == 0 && grid[x][y+1] == 0) {\\n                    // rotate counter-clockwise\\n                    right[x-1][y+1] = true;\\n                    minMovesRight[x-1][y+1] = minMovesRight[x-1][y+1] == -1\\n                            ? minMovesDown[x][y] + 1\\n                            : Math.min(minMovesRight[x-1][y+1], minMovesDown[x][y] + 1);\\n                    cellsToVisit.add(new int[]{x-1, y+1});\\n                    // move right-ward by one column\\n                    down[x][y+1] = true;\\n                    minMovesDown[x][y+1] = minMovesDown[x][y+1] == -1\\n                        ? minMovesDown[x][y] + 1\\n                        : Math.min(minMovesDown[x][y+1],  minMovesDown[x][y] + 1);\\n                    cellsToVisit.add(new int[]{x, y+1});\\n                }\\n            }\\n        }\\n        \\n        // Now after traversing, return last element\\n        return minMovesRight[rows-1][columns-1];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\n    public int minimumMoves(int[][] grid) {\\n        int rows = grid.length;\\n        int columns = grid[0].length;\\n        Boolean[][] right = new Boolean[rows][columns]; // if head at (i, j) can be horizontal\\n        Boolean[][] down = new Boolean[rows][columns]; // if head at (i, j) can be vertical\\n        int[][] minMovesRight = new int[rows][columns]; // min moves ending with head at (i,j) horizontally\\n        int[][] minMovesDown = new int[rows][columns]; // min moves ending with head at (i,j) vertically\\n        Boolean[][] visited = new Boolean[rows][columns]; // if head at (i, j) is already visited of its neighbors\\n        Queue<int[]> cellsToVisit = new LinkedList<>();\\n        // initalize values\\n        for (int i = 0; i < rows; i++) {\\n            Arrays.fill(minMovesRight[i], -1);\\n            Arrays.fill(minMovesDown[i], -1);\\n            Arrays.fill(right[i], false);\\n            Arrays.fill(down[i], false);\\n            Arrays.fill(visited[i], false);\\n        }\\n\\t\\t// we know snake head is initialized horizontally in (0, 1)\\n        right[0][1] = true;\\n        minMovesRight[0][1] = 0;\\n        cellsToVisit.add(new int[]{0, 1});\\n        \\n        while (cellsToVisit.size() > 0) {\\n            int[] cell = cellsToVisit.poll();\\n            int x = cell[0];\\n            int y = cell[1];\\n            if (visited[x][y]) {\\n                continue;\\n            }\\n            visited[x][y] = true;\\n            // if head can be at (x, y) horizontally, check (x, y+1), (x+1, y-1) and (x+1, y)\\n            if (right[x][y] == true) {\\n                if (y+1 < columns && grid[x][y+1] == 0) {\\n                    right[x][y+1] = true;\\n                    cellsToVisit.add(new int[]{x, y+1});\\n                    minMovesRight[x][y+1] = minMovesRight[x][y+1] == -1\\n                            ? minMovesRight[x][y] + 1\\n                            : Math.min(minMovesRight[x][y+1], minMovesRight[x][y] + 1);\\n                }\\n                // now check if we can rotate clock-wise or downward by 1 row\\n                if (x+1 < rows && y-1 >= 0 && grid[x+1][y-1] == 0 && grid[x+1][y] == 0) {\\n                    // rotate clock-wise\\n                    down[x+1][y-1] = true;\\n                    minMovesDown[x+1][y-1] = minMovesDown[x+1][y-1] == -1\\n                        ? minMovesRight[x][y] + 1\\n                        : Math.min(minMovesDown[x+1][y-1], minMovesRight[x][y] + 1);\\n                    cellsToVisit.add(new int[]{x+1, y-1});\\n                    // move downward by 1 row\\n                    right[x+1][y] = true;\\n                    minMovesRight[x+1][y] = minMovesRight[x+1][y] == -1\\n                        ? minMovesRight[x][y] + 1\\n                        : Math.min(minMovesRight[x+1][y], minMovesRight[x][y] + 1);\\n                    cellsToVisit.add(new int[]{x+1, y});\\n                }\\n            }\\n            \\n            // if head can be at (x, y) vertically, check (x+1, y), (x-1, y+1) and (x, y+1) \\n            if (down[x][y] == true) {\\n                if (x+1 < rows && grid[x+1][y] == 0) {\\n                    down[x+1][y] = true;\\n                    minMovesDown[x+1][y] = minMovesDown[x+1][y] == -1\\n                            ? minMovesDown[x][y] + 1\\n                            : Math.min(minMovesDown[x+1][y], minMovesDown[x][y] + 1);\\n                    cellsToVisit.add(new int[]{x+1, y});\\n                }\\n                // now check if we can rotate counter-clock-wise or right-ward by 1 column\\n                if (y+1 < columns && x-1 >= 0 && grid[x-1][y+1] == 0 && grid[x][y+1] == 0) {\\n                    // rotate counter-clockwise\\n                    right[x-1][y+1] = true;\\n                    minMovesRight[x-1][y+1] = minMovesRight[x-1][y+1] == -1\\n                            ? minMovesDown[x][y] + 1\\n                            : Math.min(minMovesRight[x-1][y+1], minMovesDown[x][y] + 1);\\n                    cellsToVisit.add(new int[]{x-1, y+1});\\n                    // move right-ward by one column\\n                    down[x][y+1] = true;\\n                    minMovesDown[x][y+1] = minMovesDown[x][y+1] == -1\\n                        ? minMovesDown[x][y] + 1\\n                        : Math.min(minMovesDown[x][y+1],  minMovesDown[x][y] + 1);\\n                    cellsToVisit.add(new int[]{x, y+1});\\n                }\\n            }\\n        }\\n        \\n        // Now after traversing, return last element\\n        return minMovesRight[rows-1][columns-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1572840,
                "title": "java-bfs-dude-your-snake-can-shade-step",
                "content": "For people who are 1) struggling with the horizontal and vertical movement of the snake and 2) plays many action RPG games, your snake can shade step OR quick step its entire fuking body to its right and down cells!!!\\n\\nSay your ninjia snake is \\n\\n| 0\\n| 0\\n\\nAnd this guy can move its entire body to the right! What a lengendary snake!\\n0 |\\n0 |\\n\\nThe same thing holds for the snake\\'s horizontal position:\\n~~\\n0 0\\n\\ncan get to \\n0 0\\n~~\\n\\nFiguring out this property costs 1 hour of trial and error. Yet, figuring out the core logic to solve this problem only cost around 10 minutes: BFS shortest path finder + visited state checking. By the way, the question hands out additional candies: the implementation on visiting neighboring states, is fuking disgusting.\\n\\n```\\nclass Solution {\\n    public int minimumMoves(int[][] grid) {\\n        // BFS with visited states.\\n        int n = grid.length;\\n        // int state[i,j] means the tail of snake. \\n        // 00 means pure empty.\\n        // 01 means head pointing right is visited.\\n        // 10 means head pointing down is visited.\\n        // 11 means both dir visited.\\n        int[][] visited = new int[n][n];\\n        Queue<int[]> bq = new LinkedList<>();\\n        bq.offer(new int[]{0, 0, 1});\\n        visited[0][0] |= 1;\\n        \\n        int level = 0;\\n        while (!bq.isEmpty()) {\\n            int levelSize = bq.size();\\n            for (int l = 0; l < levelSize; l++) {\\n                int[] cur = bq.poll();\\n                int xtail = cur[0], ytail = cur[1], dir = cur[2];\\n                if (xtail == n - 1 &&\\n                    ytail == n - 2 &&\\n                    dir == 1) {\\n                    return level;\\n                }\\n                \\n                int xhead = xtail + (dir == 1 ? 0 : 1);\\n                int yhead = ytail + (dir == 1 ? 1 : 0);\\n                \\n                // Expansion\\n                // Now the disgusting begins...\\n                if (dir == 2) {\\n                    // vertical snake, if its right vertical cells\\n                    // are both empty, we do stuff.\\n                    if (ytail + 1 < n &&\\n                        grid[xtail][ytail+1] != 1 &&\\n                        grid[xtail+1][ytail+1] != 1) {\\n                        if ((visited[xtail][ytail] & 1) == 0) {\\n                            bq.offer(new int[]{xtail, ytail, 1});\\n                            visited[xtail][ytail] |= 1;    \\n                        }\\n                        \\n                        if ((visited[xtail][ytail+1] & 2) == 0) {\\n                            bq.offer(new int[]{xtail, ytail+1, 2});\\n                            visited[xtail][ytail+1] |= 2;\\n                        }\\n                    }\\n                    \\n                    // move down\\n                    if (xhead + 1 < n && \\n                        grid[xhead+1][yhead] != 1 &&\\n                        (visited[xhead][yhead] & 2) == 0) {\\n                        bq.offer(new int[]{xhead, yhead, 2});\\n                        visited[xhead][yhead] |= 2;\\n                    }\\n                } else {\\n                    // ~~ horizontal snake, if its below are \\n                    // empty cells, we do stuff.\\n                    if (xtail + 1 < n &&\\n                        grid[xtail+1][ytail] != 1 &&\\n                        grid[xtail+1][ytail+1] != 1) {\\n                        if ((visited[xtail][ytail] & 2) == 0) {\\n                            bq.offer(new int[]{xtail, ytail, 2});\\n                            visited[xtail][ytail] |= 2;    \\n                        }\\n                        \\n                        if ((visited[xtail+1][ytail] & 1) == 0) {\\n                            bq.offer(new int[]{xtail+1, ytail, 1});\\n                            visited[xtail+1][ytail] |= 1;\\n                        }\\n                    }\\n                    \\n                    // move ->\\n                    if (yhead + 1 < n &&\\n                        grid[xhead][yhead + 1] != 1 &&\\n                        (visited[xhead][yhead] & 1) == 0) {\\n                        bq.offer(new int[]{xhead, yhead, 1});\\n                        visited[xhead][yhead] |= 1;\\n                    }\\n                }\\n            }\\n            \\n            level += 1;\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```\\n\\nComplexity:\\n- Time O(2* n^2). Snake\\'s valid state can be n^2 locations, and each location has 2 directions. In BFS path finder, we will not revisit a given state if it has been reach before. We will only costing more steps when visiting the visited state, thus always leading to worse solutions in the future.\\n- Space O(n^2) the integer visited map.\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minimumMoves(int[][] grid) {\\n        // BFS with visited states.\\n        int n = grid.length;\\n        // int state[i,j] means the tail of snake. \\n        // 00 means pure empty.\\n        // 01 means head pointing right is visited.\\n        // 10 means head pointing down is visited.\\n        // 11 means both dir visited.\\n        int[][] visited = new int[n][n];\\n        Queue<int[]> bq = new LinkedList<>();\\n        bq.offer(new int[]{0, 0, 1});\\n        visited[0][0] |= 1;\\n        \\n        int level = 0;\\n        while (!bq.isEmpty()) {\\n            int levelSize = bq.size();\\n            for (int l = 0; l < levelSize; l++) {\\n                int[] cur = bq.poll();\\n                int xtail = cur[0], ytail = cur[1], dir = cur[2];\\n                if (xtail == n - 1 &&\\n                    ytail == n - 2 &&\\n                    dir == 1) {\\n                    return level;\\n                }\\n                \\n                int xhead = xtail + (dir == 1 ? 0 : 1);\\n                int yhead = ytail + (dir == 1 ? 1 : 0);\\n                \\n                // Expansion\\n                // Now the disgusting begins...\\n                if (dir == 2) {\\n                    // vertical snake, if its right vertical cells\\n                    // are both empty, we do stuff.\\n                    if (ytail + 1 < n &&\\n                        grid[xtail][ytail+1] != 1 &&\\n                        grid[xtail+1][ytail+1] != 1) {\\n                        if ((visited[xtail][ytail] & 1) == 0) {\\n                            bq.offer(new int[]{xtail, ytail, 1});\\n                            visited[xtail][ytail] |= 1;    \\n                        }\\n                        \\n                        if ((visited[xtail][ytail+1] & 2) == 0) {\\n                            bq.offer(new int[]{xtail, ytail+1, 2});\\n                            visited[xtail][ytail+1] |= 2;\\n                        }\\n                    }\\n                    \\n                    // move down\\n                    if (xhead + 1 < n && \\n                        grid[xhead+1][yhead] != 1 &&\\n                        (visited[xhead][yhead] & 2) == 0) {\\n                        bq.offer(new int[]{xhead, yhead, 2});\\n                        visited[xhead][yhead] |= 2;\\n                    }\\n                } else {\\n                    // ~~ horizontal snake, if its below are \\n                    // empty cells, we do stuff.\\n                    if (xtail + 1 < n &&\\n                        grid[xtail+1][ytail] != 1 &&\\n                        grid[xtail+1][ytail+1] != 1) {\\n                        if ((visited[xtail][ytail] & 2) == 0) {\\n                            bq.offer(new int[]{xtail, ytail, 2});\\n                            visited[xtail][ytail] |= 2;    \\n                        }\\n                        \\n                        if ((visited[xtail+1][ytail] & 1) == 0) {\\n                            bq.offer(new int[]{xtail+1, ytail, 1});\\n                            visited[xtail+1][ytail] |= 1;\\n                        }\\n                    }\\n                    \\n                    // move ->\\n                    if (yhead + 1 < n &&\\n                        grid[xhead][yhead + 1] != 1 &&\\n                        (visited[xhead][yhead] & 1) == 0) {\\n                        bq.offer(new int[]{xhead, yhead, 1});\\n                        visited[xhead][yhead] |= 1;\\n                    }\\n                }\\n            }\\n            \\n            level += 1;\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1552365,
                "title": "c-dp-solution",
                "content": "```\\n\\n        public int DpSolution(int[][] grid)\\n        {\\n            int n = grid.Length, m = grid[0].Length;\\n\\n            // \\u68C0\\u67E5\\u7EC8\\u70B9\\u662F\\u5426\\u88AB\\u963B\\u585E\\n            if (grid[n - 1][m - 1] != 0 || grid[n - 1][m - 2] != 0) return -1;\\n\\n            // \\u5B9A\\u4E49dp[\\u7B2C\\u4E00\\u4E2A\\u90E8\\u4F4D\\u4F4D\\u7F6E][\\u90E8\\u4F4D\\u65B9\\u5411\\uFF080 \\u8868\\u793A\\u6C34\\u5E73, 1 \\u8868\\u793A\\u5782\\u76F4\\uFF09] = \\u5230\\u8FBE\\u7EC8\\u70B9\\u6240\\u9700\\u7684\\u6700\\u5C0F\\n            // \\u4F8B\\uFF1A[x, x  \\uFF1A \\u8868\\u793A \\u4F4D\\u7F6E[0][0] \\u6C34\\u5E73\\u65B9\\u5411 \\n            int?[][][] dp = new int?[n][][];\\n            for (int i = 0; i < n; i++)\\n            {\\n                var arr = dp[i] = new int?[m][];\\n                for (int j = 0; j < m; j++)\\n                {\\n                    arr[j] = new int?[2];\\n                }\\n            }\\n\\n            // \\u521D\\u59CB\\u5316\\u7EC8\\u70B9\\u4E3A0\\n            dp[n - 1][m - 2][0] = 0;\\n\\n            // \\u521D\\u59CB\\u5316\\u6700\\u540E\\u4E00\\u884C\\n            for (int i = m - 3, count = 1; i >= 0; i--, count++)\\n            {\\n                // \\u6700\\u540E\\u4E00\\u884C\\u7531\\u4E8E\\u4F4D\\u7F6E\\u539F\\u56E0\\u53EA\\u80FD\\u6C34\\u5E73\\u79FB\\u52A8\\uFF0C\\u6CA1\\u6709\\u5176\\u4ED6\\u79FB\\u52A8\\u65B9\\u6848\\n                if (grid[n - 1][i] != 1)\\n                {\\n                    dp[n - 1][i][0] = count;\\n                }\\n                else\\n                {\\n                    break;\\n                }\\n            }\\n\\n            for (int i = n - 2; i >= 0; i--)\\n            {\\n                for (int j = m - 2; j >= 0; j--)\\n                {\\n                    if (grid[i][j] == 1) continue;\\n\\n                    var curr = dp[i][j];\\n                    int? horizontal = null, vertical = null;\\n\\n                    #region horizontal\\n                    // \\u6C34\\u5E73\\u79FB\\u52A8\\n                    if (grid[i][j + 1] == 0)\\n                    {\\n                        int res = int.MaxValue;\\n                        // move right\\n                        var right = dp[i][j + 1][0];\\n                        if (right.HasValue)\\n                        {\\n                            res = 1 + right.Value;\\n                        }\\n\\n                        // move bottom\\n                        var bottom = dp[i + 1][j][0];\\n                        if (bottom.HasValue)\\n                        {\\n                            res = Math.Min(res, 1 + bottom.Value);\\n                        }\\n                        if (res != int.MaxValue)\\n                        {\\n                            horizontal = curr[0] = res;\\n                        }\\n                    }\\n                    #endregion\\n\\n                    #region vertical\\n                    // \\u5782\\u76F4\\u79FB\\u52A8\\n                    if (grid[i + 1][j] == 0)\\n                    {\\n                        int res = int.MaxValue;\\n                        // move right\\n                        var right = dp[i][j + 1][1];\\n                        if (right.HasValue)\\n                        {\\n                            res = 1 + right.Value;\\n                        }\\n\\n                        // move bottom\\n                        var bottom = dp[i + 1][j][1];\\n                        if (bottom.HasValue)\\n                        {\\n                            res = Math.Min(res, 1 + bottom.Value);\\n                        }\\n                        if (res != int.MaxValue)\\n                        {\\n                            vertical = curr[1] = res;\\n                        }\\n                    }\\n                    #endregion\\n\\n                    #region rotate\\n                    // \\u66F4\\u6539\\u5360\\u4F4D\\n                    {\\n\\n                        if (grid[i + 1][j + 1] == 0)\\n                        {\\n                            if (horizontal.HasValue && !vertical.HasValue)\\n                            {\\n                                if (grid[i + 1][j] == 0)\\n                                {\\n                                    curr[1] = curr[0] + 1;\\n                                }\\n                            }\\n                            else if (!horizontal.HasValue && vertical.HasValue)\\n                            {\\n                                if (grid[i][j + 1] == 0)\\n                                {\\n                                    curr[0] = curr[1] + 1;\\n                                }\\n                            }\\n                            else if (horizontal.HasValue && vertical.HasValue)\\n                            {\\n                                curr[0] = Math.Min(curr[0].Value, vertical.Value + 1);\\n                                curr[1] = Math.Min(curr[1].Value, horizontal.Value + 1);\\n                            }\\n                        }\\n\\n                    }\\n                    #endregion\\n                }\\n            }\\n            var t = dp[0][0][0];\\n            return t.HasValue ? t.Value : -1;\\n        }\\n```",
                "solutionTags": [],
                "code": "```\\n\\n        public int DpSolution(int[][] grid)\\n        {\\n            int n = grid.Length, m = grid[0].Length;\\n\\n            // \\u68C0\\u67E5\\u7EC8\\u70B9\\u662F\\u5426\\u88AB\\u963B\\u585E\\n            if (grid[n - 1][m - 1] != 0 || grid[n - 1][m - 2] != 0) return -1;\\n\\n            // \\u5B9A\\u4E49dp[\\u7B2C\\u4E00\\u4E2A\\u90E8\\u4F4D\\u4F4D\\u7F6E][\\u90E8\\u4F4D\\u65B9\\u5411\\uFF080 \\u8868\\u793A\\u6C34\\u5E73, 1 \\u8868\\u793A\\u5782\\u76F4\\uFF09] = \\u5230\\u8FBE\\u7EC8\\u70B9\\u6240\\u9700\\u7684\\u6700\\u5C0F\\n            // \\u4F8B\\uFF1A[x, x  \\uFF1A \\u8868\\u793A \\u4F4D\\u7F6E[0][0] \\u6C34\\u5E73\\u65B9\\u5411 \\n            int?[][][] dp = new int?[n][][];\\n            for (int i = 0; i < n; i++)\\n            {\\n                var arr = dp[i] = new int?[m][];\\n                for (int j = 0; j < m; j++)\\n                {\\n                    arr[j] = new int?[2];\\n                }\\n            }\\n\\n            // \\u521D\\u59CB\\u5316\\u7EC8\\u70B9\\u4E3A0\\n            dp[n - 1][m - 2][0] = 0;\\n\\n            // \\u521D\\u59CB\\u5316\\u6700\\u540E\\u4E00\\u884C\\n            for (int i = m - 3, count = 1; i >= 0; i--, count++)\\n            {\\n                // \\u6700\\u540E\\u4E00\\u884C\\u7531\\u4E8E\\u4F4D\\u7F6E\\u539F\\u56E0\\u53EA\\u80FD\\u6C34\\u5E73\\u79FB\\u52A8\\uFF0C\\u6CA1\\u6709\\u5176\\u4ED6\\u79FB\\u52A8\\u65B9\\u6848\\n                if (grid[n - 1][i] != 1)\\n                {\\n                    dp[n - 1][i][0] = count;\\n                }\\n                else\\n                {\\n                    break;\\n                }\\n            }\\n\\n            for (int i = n - 2; i >= 0; i--)\\n            {\\n                for (int j = m - 2; j >= 0; j--)\\n                {\\n                    if (grid[i][j] == 1) continue;\\n\\n                    var curr = dp[i][j];\\n                    int? horizontal = null, vertical = null;\\n\\n                    #region horizontal\\n                    // \\u6C34\\u5E73\\u79FB\\u52A8\\n                    if (grid[i][j + 1] == 0)\\n                    {\\n                        int res = int.MaxValue;\\n                        // move right\\n                        var right = dp[i][j + 1][0];\\n                        if (right.HasValue)\\n                        {\\n                            res = 1 + right.Value;\\n                        }\\n\\n                        // move bottom\\n                        var bottom = dp[i + 1][j][0];\\n                        if (bottom.HasValue)\\n                        {\\n                            res = Math.Min(res, 1 + bottom.Value);\\n                        }\\n                        if (res != int.MaxValue)\\n                        {\\n                            horizontal = curr[0] = res;\\n                        }\\n                    }\\n                    #endregion\\n\\n                    #region vertical\\n                    // \\u5782\\u76F4\\u79FB\\u52A8\\n                    if (grid[i + 1][j] == 0)\\n                    {\\n                        int res = int.MaxValue;\\n                        // move right\\n                        var right = dp[i][j + 1][1];\\n                        if (right.HasValue)\\n                        {\\n                            res = 1 + right.Value;\\n                        }\\n\\n                        // move bottom\\n                        var bottom = dp[i + 1][j][1];\\n                        if (bottom.HasValue)\\n                        {\\n                            res = Math.Min(res, 1 + bottom.Value);\\n                        }\\n                        if (res != int.MaxValue)\\n                        {\\n                            vertical = curr[1] = res;\\n                        }\\n                    }\\n                    #endregion\\n\\n                    #region rotate\\n                    // \\u66F4\\u6539\\u5360\\u4F4D\\n                    {\\n\\n                        if (grid[i + 1][j + 1] == 0)\\n                        {\\n                            if (horizontal.HasValue && !vertical.HasValue)\\n                            {\\n                                if (grid[i + 1][j] == 0)\\n                                {\\n                                    curr[1] = curr[0] + 1;\\n                                }\\n                            }\\n                            else if (!horizontal.HasValue && vertical.HasValue)\\n                            {\\n                                if (grid[i][j + 1] == 0)\\n                                {\\n                                    curr[0] = curr[1] + 1;\\n                                }\\n                            }\\n                            else if (horizontal.HasValue && vertical.HasValue)\\n                            {\\n                                curr[0] = Math.Min(curr[0].Value, vertical.Value + 1);\\n                                curr[1] = Math.Min(curr[1].Value, horizontal.Value + 1);\\n                            }\\n                        }\\n\\n                    }\\n                    #endregion\\n                }\\n            }\\n            var t = dp[0][0][0];\\n            return t.HasValue ? t.Value : -1;\\n        }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1501836,
                "title": "c-bfs",
                "content": "```\\nclass Solution {\\n    struct snake {\\n        int r1;\\n        int c1;\\n        int r2;\\n        int c2;\\n        int step;\\n        snake(int r1_, int r2_, int c1_, int c2_, int step_) {\\n            r1 = r1_;\\n            c1 = c1_;\\n            r2 = r2_;\\n            c2 = c2_;\\n            step = step_;\\n        }\\n    };\\n    \\n    string toString(snake& s) {\\n        return to_string(s.r1) + \",\" + to_string(s.c1) + \", \" + to_string(s.r2) + \",\" + to_string(s.c2);\\n    }\\n    \\n    void maybeAddNextStep(queue<snake>& q, unordered_set<string>& visited, int r1, int r2, int c1, int c2, int step) {\\n        snake s_nxt = snake(r1, r2, c1, c2, step);\\n        string s_string = toString(s_nxt);\\n        if(!visited.count(s_string)) {\\n            visited.insert(s_string);\\n            q.push(s_nxt);\\n        }        \\n    }\\n    \\npublic:\\n    int minimumMoves(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        snake start = snake(0, 0, 0, 1, 0);\\n        unordered_set<string> visited;\\n        \\n        int step = 0;\\n        queue<snake> q;\\n        q.push(start);\\n        \\n        while(!q.empty()) {\\n            auto s = q.front();\\n            \\n            q.pop();\\n            \\n            // reach the end\\n            if(s.r1 == m-1 && s.r2 == m-1 && s.c1 == n-2 && s.c2 == n-1) {\\n                return s.step;\\n            }\\n            \\n            // down\\n            if(s.r1 + 1 < m && s.r2 + 1 < m && grid[s.r1+1][s.c1] == 0 && grid[s.r2+1][s.c2] == 0) {\\n                maybeAddNextStep(q, visited, s.r1+1, s.r2+1, s.c1, s.c2, s.step+1);\\n            }\\n            \\n            // right\\n            if(s.c1 + 1 < n && s.c2 + 1 < n && grid[s.r1][s.c1+1] == 0 && grid[s.r2][s.c2+1] == 0) {\\n                maybeAddNextStep(q, visited, s.r1, s.r2, s.c1+1, s.c2+1, s.step+1);\\n            }\\n            \\n            // clockwise\\n            if(s.c2 == s.c1 + 1 && s.r1+1 < m && grid[s.r1+1][s.c1] == 0 && grid[s.r1+1][s.c1+1] == 0) {\\n                maybeAddNextStep(q, visited, s.r1, s.r1+1, s.c1, s.c1, s.step+1);               \\n            }\\n            \\n            //counter-clockwise\\n            if(s.r2 == s.r1 + 1 && s.c1+1 < n && grid[s.r1][s.c1+1] == 0 && grid[s.r1+1][s.c1+1] == 0) {\\n                maybeAddNextStep(q, visited, s.r1, s.r1, s.c1, s.c1+1, s.step+1);            \\n            }\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    struct snake {\\n        int r1;\\n        int c1;\\n        int r2;\\n        int c2;\\n        int step;\\n        snake(int r1_, int r2_, int c1_, int c2_, int step_) {\\n            r1 = r1_;\\n            c1 = c1_;\\n            r2 = r2_;\\n            c2 = c2_;\\n            step = step_;\\n        }\\n    };\\n    \\n    string toString(snake& s) {\\n        return to_string(s.r1) + \",\" + to_string(s.c1) + \", \" + to_string(s.r2) + \",\" + to_string(s.c2);\\n    }\\n    \\n    void maybeAddNextStep(queue<snake>& q, unordered_set<string>& visited, int r1, int r2, int c1, int c2, int step) {\\n        snake s_nxt = snake(r1, r2, c1, c2, step);\\n        string s_string = toString(s_nxt);\\n        if(!visited.count(s_string)) {\\n            visited.insert(s_string);\\n            q.push(s_nxt);\\n        }        \\n    }\\n    \\npublic:\\n    int minimumMoves(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        snake start = snake(0, 0, 0, 1, 0);\\n        unordered_set<string> visited;\\n        \\n        int step = 0;\\n        queue<snake> q;\\n        q.push(start);\\n        \\n        while(!q.empty()) {\\n            auto s = q.front();\\n            \\n            q.pop();\\n            \\n            // reach the end\\n            if(s.r1 == m-1 && s.r2 == m-1 && s.c1 == n-2 && s.c2 == n-1) {\\n                return s.step;\\n            }\\n            \\n            // down\\n            if(s.r1 + 1 < m && s.r2 + 1 < m && grid[s.r1+1][s.c1] == 0 && grid[s.r2+1][s.c2] == 0) {\\n                maybeAddNextStep(q, visited, s.r1+1, s.r2+1, s.c1, s.c2, s.step+1);\\n            }\\n            \\n            // right\\n            if(s.c1 + 1 < n && s.c2 + 1 < n && grid[s.r1][s.c1+1] == 0 && grid[s.r2][s.c2+1] == 0) {\\n                maybeAddNextStep(q, visited, s.r1, s.r2, s.c1+1, s.c2+1, s.step+1);\\n            }\\n            \\n            // clockwise\\n            if(s.c2 == s.c1 + 1 && s.r1+1 < m && grid[s.r1+1][s.c1] == 0 && grid[s.r1+1][s.c1+1] == 0) {\\n                maybeAddNextStep(q, visited, s.r1, s.r1+1, s.c1, s.c1, s.step+1);               \\n            }\\n            \\n            //counter-clockwise\\n            if(s.r2 == s.r1 + 1 && s.c1+1 < n && grid[s.r1][s.c1+1] == 0 && grid[s.r1+1][s.c1+1] == 0) {\\n                maybeAddNextStep(q, visited, s.r1, s.r1, s.c1, s.c1+1, s.step+1);            \\n            }\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1454307,
                "title": "java-bfs-extremely-straightforward-and-easy-to-understand-solution-with-brief-comments",
                "content": "```\\n    public int minimumMoves(int[][] grid) {\\n        int n = grid.length;\\n        Queue<int[]> q = new LinkedList<>();\\n        boolean[][][] visited = new boolean[n][n][2];\\n        // array stores current x, y and direction with 0 means horizontal and 1 means vertical\\n        q.offer(new int[]{0, 1, 0});\\n        visited[0][1][0] = true;\\n        int res = 0;\\n        while (!q.isEmpty()) {\\n            int size = q.size();\\n            for (int i = 0; i < size; i++) {\\n                int[] cur = q.poll();\\n                \\n                // reach target\\n                if (cur[2] == 0 && cur[0] == n - 1 && cur[1] == n - 1) return res;\\n                \\n                // rotate clockwise\\n                if (cur[0] + 1 < n && cur[2] == 0 && grid[cur[0] + 1][cur[1] - 1] == 0 && grid[cur[0] + 1][cur[1]] == 0 && !visited[cur[0] + 1][cur[1] - 1][1]) {\\n                    q.offer(new int[]{cur[0] + 1, cur[1] - 1, 1});\\n                    visited[cur[0] + 1][cur[1] - 1][1] = true;\\n                }\\n           \\n                // rotate counterclockwise\\n                if (cur[1] + 1 < n && cur[2] == 1 && grid[cur[0] - 1][cur[1] + 1] == 0 && grid[cur[0]][cur[1] + 1] == 0 && !visited[cur[0] - 1][cur[1] + 1][0]) {\\n                    q.offer(new int[]{cur[0] - 1, cur[1] + 1, 0});\\n                    visited[cur[0] - 1][cur[1] + 1][0] = true;\\n                }\\n\\t\\t\\t\\t\\n                // move right horizontally\\n                if (cur[1] + 1 < n && cur[2] == 0 && grid[cur[0]][cur[1] + 1] == 0 && !visited[cur[0]][cur[1] + 1][0]) {\\n                    q.offer(new int[]{cur[0], cur[1] + 1, 0});\\n                    visited[cur[0]][cur[1] + 1][0] = true;\\n                }\\n                \\n                // move right vertically\\n                if (cur[1] + 1 < n && cur[2] == 1 && grid[cur[0]][cur[1] + 1] == 0 && grid[cur[0] - 1][cur[1] + 1] == 0 && !visited[cur[0]][cur[1] + 1][1]) {\\n                    q.offer(new int[]{cur[0], cur[1] + 1, 1});\\n                    visited[cur[0]][cur[1] + 1][1] = true;\\n                }\\n                \\n                // move down vertically\\n                if (cur[0] + 1 < n && cur[2] == 1 && grid[cur[0] + 1][cur[1]] == 0 && !visited[cur[0] + 1][cur[1]][1]) {\\n                    q.offer(new int[]{cur[0] + 1, cur[1], cur[2]});\\n                    visited[cur[0] + 1][cur[1]][1] = true;\\n                }\\n                \\n                // move down horizontally\\n                if (cur[0] + 1 < n && cur[2] == 0 && grid[cur[0] + 1][cur[1]] == 0 && grid[cur[0] + 1][cur[1] - 1] == 0 && !visited[cur[0] + 1][cur[1]][0]) {\\n                    q.offer(new int[]{cur[0] + 1, cur[1], 0});\\n                    visited[cur[0] + 1][cur[1]][0] = true;\\n                }\\n            }\\n            res++;\\n        }\\n        return -1;\\n    }",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\n    public int minimumMoves(int[][] grid) {\\n        int n = grid.length;\\n        Queue<int[]> q = new LinkedList<>();\\n        boolean[][][] visited = new boolean[n][n][2];\\n        // array stores current x, y and direction with 0 means horizontal and 1 means vertical\\n        q.offer(new int[]{0, 1, 0});\\n        visited[0][1][0] = true;\\n        int res = 0;\\n        while (!q.isEmpty()) {\\n            int size = q.size();\\n            for (int i = 0; i < size; i++) {\\n                int[] cur = q.poll();\\n                \\n                // reach target\\n                if (cur[2] == 0 && cur[0] == n - 1 && cur[1] == n - 1) return res;\\n                \\n                // rotate clockwise\\n                if (cur[0] + 1 < n && cur[2] == 0 && grid[cur[0] + 1][cur[1] - 1] == 0 && grid[cur[0] + 1][cur[1]] == 0 && !visited[cur[0] + 1][cur[1] - 1][1]) {\\n                    q.offer(new int[]{cur[0] + 1, cur[1] - 1, 1});\\n                    visited[cur[0] + 1][cur[1] - 1][1] = true;\\n                }\\n           \\n                // rotate counterclockwise\\n                if (cur[1] + 1 < n && cur[2] == 1 && grid[cur[0] - 1][cur[1] + 1] == 0 && grid[cur[0]][cur[1] + 1] == 0 && !visited[cur[0] - 1][cur[1] + 1][0]) {\\n                    q.offer(new int[]{cur[0] - 1, cur[1] + 1, 0});\\n                    visited[cur[0] - 1][cur[1] + 1][0] = true;\\n                }\\n\\t\\t\\t\\t\\n                // move right horizontally\\n                if (cur[1] + 1 < n && cur[2] == 0 && grid[cur[0]][cur[1] + 1] == 0 && !visited[cur[0]][cur[1] + 1][0]) {\\n                    q.offer(new int[]{cur[0], cur[1] + 1, 0});\\n                    visited[cur[0]][cur[1] + 1][0] = true;\\n                }\\n                \\n                // move right vertically\\n                if (cur[1] + 1 < n && cur[2] == 1 && grid[cur[0]][cur[1] + 1] == 0 && grid[cur[0] - 1][cur[1] + 1] == 0 && !visited[cur[0]][cur[1] + 1][1]) {\\n                    q.offer(new int[]{cur[0], cur[1] + 1, 1});\\n                    visited[cur[0]][cur[1] + 1][1] = true;\\n                }\\n                \\n                // move down vertically\\n                if (cur[0] + 1 < n && cur[2] == 1 && grid[cur[0] + 1][cur[1]] == 0 && !visited[cur[0] + 1][cur[1]][1]) {\\n                    q.offer(new int[]{cur[0] + 1, cur[1], cur[2]});\\n                    visited[cur[0] + 1][cur[1]][1] = true;\\n                }\\n                \\n                // move down horizontally\\n                if (cur[0] + 1 < n && cur[2] == 0 && grid[cur[0] + 1][cur[1]] == 0 && grid[cur[0] + 1][cur[1] - 1] == 0 && !visited[cur[0] + 1][cur[1]][0]) {\\n                    q.offer(new int[]{cur[0] + 1, cur[1], 0});\\n                    visited[cur[0] + 1][cur[1]][0] = true;\\n                }\\n            }\\n            res++;\\n        }\\n        return -1;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1402202,
                "title": "scala-100-100",
                "content": "```\\nimport scala.annotation.tailrec\\n\\nobject Solution {\\n  private val Empty = 0\\n\\n  def minimumMoves(grid: Array[Array[Int]]): Int = {\\n    trait Snake {\\n      def row: Int\\n\\n      def col: Int\\n\\n      final def moves: Iterable[Snake] = Iterable(moveDown, moveRight, rotate).flatten\\n\\n      protected def moveDown: Option[Snake]\\n\\n      protected def moveRight: Option[Snake]\\n\\n      protected def rotate: Option[Snake]\\n    }\\n\\n    final case class HorizontalSnake(override val row: Int, override val col: Int) extends Snake {\\n      override protected def moveDown: Option[HorizontalSnake] = {\\n        (grid.get(row + 1, col), grid.get(row + 1, col - 1)) match {\\n          case (Some(Empty), Some(Empty)) => Some(HorizontalSnake(row + 1, col))\\n          case _ => None\\n        }\\n      }\\n\\n      override protected def moveRight: Option[HorizontalSnake] = grid.get(row, col + 1) match {\\n        case Some(Empty) => Some(HorizontalSnake(row, col + 1))\\n        case _ => None\\n      }\\n\\n      override protected def rotate: Option[VerticalSnake] = {\\n        (grid.get(row + 1, col), grid.get(row + 1, col - 1)) match {\\n          case (Some(Empty), Some(Empty)) => Some(VerticalSnake(row + 1, col - 1))\\n          case _ => None\\n        }\\n      }\\n    }\\n\\n    final case class VerticalSnake(override val row: Int, override val col: Int) extends Snake {\\n      override protected def moveDown: Option[VerticalSnake] = grid.get(row + 1, col) match {\\n        case Some(Empty) => Some(VerticalSnake(row + 1, col))\\n        case _ => None\\n      }\\n\\n      override protected def moveRight: Option[VerticalSnake] = {\\n        (grid.get(row, col + 1), grid.get(row - 1, col + 1)) match {\\n          case (Some(Empty), Some(Empty)) => Some(VerticalSnake(row, col + 1))\\n          case _ => None\\n        }\\n      }\\n\\n      override protected def rotate: Option[HorizontalSnake] = {\\n        (grid.get(row, col + 1), grid.get(row - 1, col + 1)) match {\\n          case (Some(Empty), Some(Empty)) => Some(HorizontalSnake(row - 1, col + 1))\\n          case _ => None\\n        }\\n      }\\n    }\\n\\n    @tailrec\\n    def search(snakes: Set[Snake], visited: Set[Snake] = Set(), numMoves: Int = 0): Int = {\\n      if (snakes.isEmpty) {\\n        -1\\n      } else if (snakes.contains(HorizontalSnake(grid.length - 1, grid.head.length - 1))) {\\n        numMoves\\n      } else {\\n        search(snakes.flatMap(_.moves).diff(visited), visited ++ snakes, numMoves + 1)\\n      }\\n    }\\n\\n    search(Set(HorizontalSnake(0, 1)))\\n  }\\n\\n  private implicit class Rich2dArray[+A](array: Array[Array[A]]) {\\n    def get(row: Int, col: Int): Option[A] = if (array.isDefinedAt(row) && array(row).isDefinedAt(col)) {\\n      Some(array(row)(col))\\n    } else {\\n      None\\n    }\\n  }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimport scala.annotation.tailrec\\n\\nobject Solution {\\n  private val Empty = 0\\n\\n  def minimumMoves(grid: Array[Array[Int]]): Int = {\\n    trait Snake {\\n      def row: Int\\n\\n      def col: Int\\n\\n      final def moves: Iterable[Snake] = Iterable(moveDown, moveRight, rotate).flatten\\n\\n      protected def moveDown: Option[Snake]\\n\\n      protected def moveRight: Option[Snake]\\n\\n      protected def rotate: Option[Snake]\\n    }\\n\\n    final case class HorizontalSnake(override val row: Int, override val col: Int) extends Snake {\\n      override protected def moveDown: Option[HorizontalSnake] = {\\n        (grid.get(row + 1, col), grid.get(row + 1, col - 1)) match {\\n          case (Some(Empty), Some(Empty)) => Some(HorizontalSnake(row + 1, col))\\n          case _ => None\\n        }\\n      }\\n\\n      override protected def moveRight: Option[HorizontalSnake] = grid.get(row, col + 1) match {\\n        case Some(Empty) => Some(HorizontalSnake(row, col + 1))\\n        case _ => None\\n      }\\n\\n      override protected def rotate: Option[VerticalSnake] = {\\n        (grid.get(row + 1, col), grid.get(row + 1, col - 1)) match {\\n          case (Some(Empty), Some(Empty)) => Some(VerticalSnake(row + 1, col - 1))\\n          case _ => None\\n        }\\n      }\\n    }\\n\\n    final case class VerticalSnake(override val row: Int, override val col: Int) extends Snake {\\n      override protected def moveDown: Option[VerticalSnake] = grid.get(row + 1, col) match {\\n        case Some(Empty) => Some(VerticalSnake(row + 1, col))\\n        case _ => None\\n      }\\n\\n      override protected def moveRight: Option[VerticalSnake] = {\\n        (grid.get(row, col + 1), grid.get(row - 1, col + 1)) match {\\n          case (Some(Empty), Some(Empty)) => Some(VerticalSnake(row, col + 1))\\n          case _ => None\\n        }\\n      }\\n\\n      override protected def rotate: Option[HorizontalSnake] = {\\n        (grid.get(row, col + 1), grid.get(row - 1, col + 1)) match {\\n          case (Some(Empty), Some(Empty)) => Some(HorizontalSnake(row - 1, col + 1))\\n          case _ => None\\n        }\\n      }\\n    }\\n\\n    @tailrec\\n    def search(snakes: Set[Snake], visited: Set[Snake] = Set(), numMoves: Int = 0): Int = {\\n      if (snakes.isEmpty) {\\n        -1\\n      } else if (snakes.contains(HorizontalSnake(grid.length - 1, grid.head.length - 1))) {\\n        numMoves\\n      } else {\\n        search(snakes.flatMap(_.moves).diff(visited), visited ++ snakes, numMoves + 1)\\n      }\\n    }\\n\\n    search(Set(HorizontalSnake(0, 1)))\\n  }\\n\\n  private implicit class Rich2dArray[+A](array: Array[Array[A]]) {\\n    def get(row: Int, col: Int): Option[A] = if (array.isDefinedAt(row) && array(row).isDefinedAt(col)) {\\n      Some(array(row)(col))\\n    } else {\\n      None\\n    }\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1222864,
                "title": "c-bfs-solution-with-explanation",
                "content": "Remarks:\\nNice BFS problem in my opinion, though I do think the difficulty rating is too high, main reason being that it is very similar to this problem: https://leetcode.com/problems/shortest-path-with-alternating-colors/ (also an interesting BFS problem that you should checkout if you are struggling with BFS in general). \\n\\nThe idea:\\nLet us find a way to define the snake\\'s body. Notice that as long as we know the snake\\'s tail end coordinate and its orientation, we can figure out its head coordinate. Therefore, now we can just do BFS on the tail coordinate making things much easier. However, one thing to note is that there are 2 possible orientation on each coordinate, so we need to becareful to consider ALL possible paths before we discard the coordinate. \\n\\nImplementation:\\n```\\nusing P = pair<int, bool>;\\n\\nclass Solution {\\npublic:\\n    int minimumMoves(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        queue<P> q;\\n        q.push(P{ 0,  true});\\n\\n        unordered_map<int, int> seen;\\n\\n        int level = 0;\\n        while (!q.empty()) {\\n            int size = q.size();\\n            for (; size > 0; size--) {\\n                P curr = q.front();\\n                q.pop();\\n\\n                int i = curr.first / n;\\n                int j = curr.first % n;\\n\\n                //bound checkings\\n                if (i < 0 || i >= n || j < 0 || j >= n) {\\n                    continue;\\n                } \\n                else if (curr.second && (j + 1 >= n)) {\\n                    continue;\\n                }\\n                else if (!curr.second && i + 1 >= n) {\\n                    continue;\\n                }\\n\\n                //block checking \\n                if (grid[i][j] == 1) {\\n                    continue;\\n                }\\n                else if (curr.second && grid[i][j + 1] == 1) {\\n                    continue;\\n                }\\n                else if (!curr.second && grid[i + 1][j] == 1) {\\n                    continue;\\n                }\\n\\n                //dest checking\\n                if (curr.second && i == n - 1 && j + 1 == n - 1) {\\n                    return level;\\n                }\\n\\n\\n                //visited checking\\n                if (seen.find(curr.first) == seen.end()) {\\n                    seen[curr.first] = curr.second ? 1 : 0;\\n                }\\n                else if (seen[curr.first] == 2){\\n                    continue;\\n                }\\n                else if ((seen[curr.first] == 1 && !curr.second) || (seen[curr.first] == 0 && curr.second)) {\\n                    seen[curr.first] = 2;\\n                }\\n                else {\\n                    continue;\\n                }\\n\\n                //consider paths\\n                q.push(P((i + 1) * n + j, curr.second));\\n                q.push(P(i * n + (j + 1), curr.second));\\n                if (i + 1 < n && j + 1 < n && grid[i][j] == 0 && grid[i + 1][j + 1] == 0) {\\n                    q.push(P(curr.first, !curr.second));\\n                }\\n            }\\n\\n            level++;\\n        }\\n\\n        return -1;\\n    }\\n};\\n```\\nAs you can see, other than the slightly complicated `seen` checking which ensures that we don\\'t run into loops and consider all paths, it is pretty much a standard BFS search, While I could shorten the code by combining the `if` statements, I much rather expand them than suffering a minor stroke trying to decipher the `&&` and the `||`. The complexity is O(n^2). Once again, we have 2 orientations and we do `seen` check we can be sure that no coordinate will checked more than twice. Space complexity is O(n^2)",
                "solutionTags": [],
                "code": "```\\nusing P = pair<int, bool>;\\n\\nclass Solution {\\npublic:\\n    int minimumMoves(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        queue<P> q;\\n        q.push(P{ 0,  true});\\n\\n        unordered_map<int, int> seen;\\n\\n        int level = 0;\\n        while (!q.empty()) {\\n            int size = q.size();\\n            for (; size > 0; size--) {\\n                P curr = q.front();\\n                q.pop();\\n\\n                int i = curr.first / n;\\n                int j = curr.first % n;\\n\\n                //bound checkings\\n                if (i < 0 || i >= n || j < 0 || j >= n) {\\n                    continue;\\n                } \\n                else if (curr.second && (j + 1 >= n)) {\\n                    continue;\\n                }\\n                else if (!curr.second && i + 1 >= n) {\\n                    continue;\\n                }\\n\\n                //block checking \\n                if (grid[i][j] == 1) {\\n                    continue;\\n                }\\n                else if (curr.second && grid[i][j + 1] == 1) {\\n                    continue;\\n                }\\n                else if (!curr.second && grid[i + 1][j] == 1) {\\n                    continue;\\n                }\\n\\n                //dest checking\\n                if (curr.second && i == n - 1 && j + 1 == n - 1) {\\n                    return level;\\n                }\\n\\n\\n                //visited checking\\n                if (seen.find(curr.first) == seen.end()) {\\n                    seen[curr.first] = curr.second ? 1 : 0;\\n                }\\n                else if (seen[curr.first] == 2){\\n                    continue;\\n                }\\n                else if ((seen[curr.first] == 1 && !curr.second) || (seen[curr.first] == 0 && curr.second)) {\\n                    seen[curr.first] = 2;\\n                }\\n                else {\\n                    continue;\\n                }\\n\\n                //consider paths\\n                q.push(P((i + 1) * n + j, curr.second));\\n                q.push(P(i * n + (j + 1), curr.second));\\n                if (i + 1 < n && j + 1 < n && grid[i][j] == 0 && grid[i + 1][j + 1] == 0) {\\n                    q.push(P(curr.first, !curr.second));\\n                }\\n            }\\n\\n            level++;\\n        }\\n\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1191193,
                "title": "python-3-dfs",
                "content": "```python\\nclass Solution:\\n    def minimumMoves(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n        seen = defaultdict(lambda:float(\\'inf\\'))\\n        \\n        def get_next(i0, j0, i1, j1):\\n            for dx, dy in [(0,1), (1,0)]:\\n                x0, y0 = i0 + dx, j0 + dy\\n                x1, y1 = i1 + dx, j1 + dy\\n                if 0<=x0<n and 0<=y0<n and \\\\\\n                        0<=x1<n and 0<=y1<n and \\\\\\n                        grid[x0][y0] == grid[x1][y1] == 0:\\n                    yield x0, y0, x1, y1\\n                    \\n        def rotate(i0, j0, i1, j1):\\n            if i0 == i1 + 1 and j0 < n - 1:\\n                if grid[i0][j0 + 1] == grid[i1][j1 + 1] == 0:\\n                    yield i1, j1 + 1, i1, j1\\n            if j0 == j1 + 1 and i0 < n - 1:\\n                if grid[i0 + 1][j0] == grid[i1 + 1][j1] == 0:\\n                    yield i1 + 1, j1, i1, j1\\n                    \\n        def dfs(i0, j0, i1, j1, step):\\n            if step >= seen[i0, j0, i1, j1]:\\n                return\\n            seen[i0, j0, i1, j1] = step\\n            if (i0, j0, i1, j1) == (n-1, n-1, n-1, n-2):\\n                return\\n            for a,b,c,d in get_next(i0,j0,i1,j1):\\n                dfs(a, b, c, d, step + 1)\\n            for a,b,c,d in rotate(i0,j0,i1,j1):\\n                dfs(a, b, c, d, step + 1)\\n        \\n        dfs(0, 1, 0, 0, 0)\\n        return seen[n-1, n-1, n-1, n-2] if seen[n-1, n-1, n-1, n-2] < float(\\'inf\\') else -1\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def minimumMoves(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n        seen = defaultdict(lambda:float(\\'inf\\'))\\n        \\n        def get_next(i0, j0, i1, j1):\\n            for dx, dy in [(0,1), (1,0)]:\\n                x0, y0 = i0 + dx, j0 + dy\\n                x1, y1 = i1 + dx, j1 + dy\\n                if 0<=x0<n and 0<=y0<n and \\\\\\n                        0<=x1<n and 0<=y1<n and \\\\\\n                        grid[x0][y0] == grid[x1][y1] == 0:\\n                    yield x0, y0, x1, y1\\n                    \\n        def rotate(i0, j0, i1, j1):\\n            if i0 == i1 + 1 and j0 < n - 1:\\n                if grid[i0][j0 + 1] == grid[i1][j1 + 1] == 0:\\n                    yield i1, j1 + 1, i1, j1\\n            if j0 == j1 + 1 and i0 < n - 1:\\n                if grid[i0 + 1][j0] == grid[i1 + 1][j1] == 0:\\n                    yield i1 + 1, j1, i1, j1\\n                    \\n        def dfs(i0, j0, i1, j1, step):\\n            if step >= seen[i0, j0, i1, j1]:\\n                return\\n            seen[i0, j0, i1, j1] = step\\n            if (i0, j0, i1, j1) == (n-1, n-1, n-1, n-2):\\n                return\\n            for a,b,c,d in get_next(i0,j0,i1,j1):\\n                dfs(a, b, c, d, step + 1)\\n            for a,b,c,d in rotate(i0,j0,i1,j1):\\n                dfs(a, b, c, d, step + 1)\\n        \\n        dfs(0, 1, 0, 0, 0)\\n        return seen[n-1, n-1, n-1, n-2] if seen[n-1, n-1, n-1, n-2] < float(\\'inf\\') else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1176896,
                "title": "java-bfs",
                "content": "```\\nclass Solution {\\n    public int minimumMoves(int[][] grid) {\\n        // using BFS to search\\n        int n = grid.length;\\n        boolean[][][] visited = new boolean[n][n][2]; // 0: horizontal 1: vertical\\n        Queue<int[]> positions = new LinkedList<>();\\n        positions.add(new int[]{0, 0, 0});\\n        visited[0][0][0] = true;\\n        int res = -1;\\n        \\n        while (!positions.isEmpty()) {\\n            int size = positions.size();\\n            res++;\\n            while (size > 0) {\\n                int[] curr = positions.poll();\\n                int y = curr[0];\\n                int x = curr[1];\\n                int head = curr[2];\\n\\n                if (y == n - 1 && x == n - 2 && head == 0) return res;\\n                if (head == 0) { // horizontal: can move right move down or clockwise\\n                    if (x + 2 < n && grid[y][x + 2] == 0 && !visited[y][x + 1][0]) { // can move to right\\n                        positions.add(new int[]{y, x + 1, 0});\\n                        visited[y][x + 1][0] = true;\\n                    }\\n                    if (y + 1 < n && grid[y + 1][x] == 0 && grid[y + 1][x + 1] == 0) {\\n                        if (!visited[y + 1][x][0]) {\\n                            positions.add(new int[]{y + 1, x, 0});\\n                            visited[y + 1][x][0] = true;\\n                        }\\n                        if (!visited[y][x][1]) {\\n                            positions.add(new int[]{y, x, 1});\\n                            visited[y][x][1] = true;\\n                        }\\n                    }\\n                } else { // vertical: can move right, move down or counterclockwise\\n                    if (x + 1 < n && grid[y][x + 1] == 0 && grid[y + 1][x + 1] == 0) { // move to right adn counterclockwise\\n                        if (!visited[y][x + 1][1]) {\\n                            positions.add(new int[]{y, x + 1, 1});\\n                            visited[y][x + 1][1] = true;\\n                        }\\n                        if (!visited[y][x][0]) {\\n                            positions.add(new int[]{y, x, 0});\\n                            visited[y][x][0] = true;\\n                        }\\n                        \\n                    }\\n                    if (y + 2 < n && grid[y + 2][x] == 0 && !visited[y + 1][x][1]) {\\n                        positions.add(new int[]{y + 1, x, 1});\\n                        visited[y + 1][x][1] = true;\\n                    } \\n                }\\n                size--;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minimumMoves(int[][] grid) {\\n        // using BFS to search\\n        int n = grid.length;\\n        boolean[][][] visited = new boolean[n][n][2]; // 0: horizontal 1: vertical\\n        Queue<int[]> positions = new LinkedList<>();\\n        positions.add(new int[]{0, 0, 0});\\n        visited[0][0][0] = true;\\n        int res = -1;\\n        \\n        while (!positions.isEmpty()) {\\n            int size = positions.size();\\n            res++;\\n            while (size > 0) {\\n                int[] curr = positions.poll();\\n                int y = curr[0];\\n                int x = curr[1];\\n                int head = curr[2];\\n\\n                if (y == n - 1 && x == n - 2 && head == 0) return res;\\n                if (head == 0) { // horizontal: can move right move down or clockwise\\n                    if (x + 2 < n && grid[y][x + 2] == 0 && !visited[y][x + 1][0]) { // can move to right\\n                        positions.add(new int[]{y, x + 1, 0});\\n                        visited[y][x + 1][0] = true;\\n                    }\\n                    if (y + 1 < n && grid[y + 1][x] == 0 && grid[y + 1][x + 1] == 0) {\\n                        if (!visited[y + 1][x][0]) {\\n                            positions.add(new int[]{y + 1, x, 0});\\n                            visited[y + 1][x][0] = true;\\n                        }\\n                        if (!visited[y][x][1]) {\\n                            positions.add(new int[]{y, x, 1});\\n                            visited[y][x][1] = true;\\n                        }\\n                    }\\n                } else { // vertical: can move right, move down or counterclockwise\\n                    if (x + 1 < n && grid[y][x + 1] == 0 && grid[y + 1][x + 1] == 0) { // move to right adn counterclockwise\\n                        if (!visited[y][x + 1][1]) {\\n                            positions.add(new int[]{y, x + 1, 1});\\n                            visited[y][x + 1][1] = true;\\n                        }\\n                        if (!visited[y][x][0]) {\\n                            positions.add(new int[]{y, x, 0});\\n                            visited[y][x][0] = true;\\n                        }\\n                        \\n                    }\\n                    if (y + 2 < n && grid[y + 2][x] == 0 && !visited[y + 1][x][1]) {\\n                        positions.add(new int[]{y + 1, x, 1});\\n                        visited[y + 1][x][1] = true;\\n                    } \\n                }\\n                size--;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1154452,
                "title": "c-very-simple-solution-similar-to-standard-bfs-template",
                "content": "Logic:\\nThe state of snake can be defined using position of its **head** and its orientation as already stated in Hints. Therfore we can use a tuple.\\n\\n`typedef tuple<int,int,bool> state;`\\nIt represent position in form of `row,column,orientation`\\n\\nOrientation is represented as \\n* 0 - Horizontal\\n* 1 - Vertical\\n\\nHere, termination condition would be head at` n-1,n-1` cell and `orientation to be horizontal`\\n\\n\\nNow, we just need to apply modifed BFS:\\n\\n```\\nclass Solution {\\npublic:\\n    typedef tuple<int,int,bool> state;\\n    int minimumMoves(vector<vector<int>>& grid) {\\n        //0 horizontal 1 vertical\\n        int n=grid.size();\\n        queue<state> q;\\n        \\n        q.push({0,1,0});\\n        set<state> st;\\n        int ans=0;\\n        while(!q.empty()){\\n            int s = q.size();\\n            while(s--){\\n                if(st.count(q.front())){\\n                    q.pop();\\n                    continue;\\n                }\\n                st.insert(q.front());\\n                auto [x,y,o] = q.front();q.pop();\\n                if(x==n-1 && y==n-1 && o==0)return ans;\\n                if(o==0 ){\\n                    if( y+1<n && grid[x][y+1]==0)\\n                        q.push({x,y+1,0});\\n                    if( x+1<n && grid[x+1][y]==0 && grid[x+1][y-1]==0 )\\n                        q.push({x+1,y-1,1}),q.push({x+1,y,0});\\n                    \\n                }\\n                if(o==1){\\n                    if(x+1 < n && grid[x+1][y]==0)\\n                        q.push({x+1,y,1});\\n                    if(y+1<n && grid[x-1][y+1]==0 && grid[x][y+1]==0)\\n                        q.push({x-1,y+1,0}),q.push({x,y+1,1});\\n                }\\n            }\\n            ans++;\\n        }\\n        return -1;\\n    }\\n};\\n```\\n\\nNote : Once could have used unordered_set, but it requires defining of hash function for tuple.\\n\\n**x and y represent current row and colum respectively, don\\'t confuse them with x, y co-ordinates.**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    typedef tuple<int,int,bool> state;\\n    int minimumMoves(vector<vector<int>>& grid) {\\n        //0 horizontal 1 vertical\\n        int n=grid.size();\\n        queue<state> q;\\n        \\n        q.push({0,1,0});\\n        set<state> st;\\n        int ans=0;\\n        while(!q.empty()){\\n            int s = q.size();\\n            while(s--){\\n                if(st.count(q.front())){\\n                    q.pop();\\n                    continue;\\n                }\\n                st.insert(q.front());\\n                auto [x,y,o] = q.front();q.pop();\\n                if(x==n-1 && y==n-1 && o==0)return ans;\\n                if(o==0 ){\\n                    if( y+1<n && grid[x][y+1]==0)\\n                        q.push({x,y+1,0});\\n                    if( x+1<n && grid[x+1][y]==0 && grid[x+1][y-1]==0 )\\n                        q.push({x+1,y-1,1}),q.push({x+1,y,0});\\n                    \\n                }\\n                if(o==1){\\n                    if(x+1 < n && grid[x+1][y]==0)\\n                        q.push({x+1,y,1});\\n                    if(y+1<n && grid[x-1][y+1]==0 && grid[x][y+1]==0)\\n                        q.push({x-1,y+1,0}),q.push({x,y+1,1});\\n                }\\n            }\\n            ans++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1111427,
                "title": "c-dp-20ms-faster-than-98-with-detailed-comments",
                "content": "The idea is to create two DP arrays representing two different snake states at each grid point (lying horizontally or vertically) and then update these two DP arrays diagonally from top-left (i+j=0) to bottom-right (i+j = 2n-2). Space and time complexity is O(n^2).\\n\\n![image](https://assets.leetcode.com/users/images/41506e53-66d7-4b56-9f4a-32e8a0123d29_1615848861.7051756.png)\\n\\n```c++\\nclass Solution {\\npublic:\\n    int minimumMoves(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        vector<vector<int>> dph(n, vector<int>(n, INT_MAX/2)); //min moves to reach state with snake head at (i,j) and snake tail at (i,j-1) (ie, a snake lying horizontally)\\n        vector<vector<int>> dpv = dph; //min moves to reach state with snake head at (i,j) and snake tail at (i-1,j) (ie, a snake lying vertically)\\n        //0. init\\n        dph[0][1] = 0;\\n        if(!grid[1][0] && !grid[1][1]) dpv[1][0] = 1;\\n        for(int k = 2; k <= 2*n-2; k++){ //k is the wavefront, k = i+j\\n            int i_start = max(0, k - n + 1);\\n            int i_end = min(k, n-1);\\n            //1. first update dph[i][j] and dpv[i][j] (i+j == k) based on horizonal or vertical shifts, using dp[i\\'][j\\'] where i\\'+j\\'==k-1\\n            for(int i = i_start; i <= i_end; i++){\\n                int j = k - i;\\n                if(grid[i][j]) continue;\\n                //1.1. update dph\\n                if(j>0 && !grid[i][j-1]){\\n                    dph[i][j] = dph[i][j-1] + 1; //horizontal shift (right)\\n                    if(i>0) dph[i][j] = min(dph[i][j], dph[i-1][j] + 1); //vertical shift (down)\\n                }\\n                //1.2. update dpv\\n                if(i>0 && !grid[i-1][j]){\\n                    dpv[i][j] = dpv[i-1][j] + 1; //vertical shift (down)\\n                    if(j>0) dpv[i][j] = min(dpv[i][j], dpv[i][j-1] + 1); //horizontal shift (right)\\n                }\\n            }\\n            //2. Then update dph[i][j] and dpv[i][j] (i+j == k) based on rotations, using dp[i\\'][j\\'] where i\\'+j\\'==k (ie, same wavefronts)\\n            for(int i = i_start; i <= i_end; i++){\\n                int j = k - i;\\n                if(grid[i][j]) continue;\\n                if(j>0 && !grid[i][j-1] && i<n-1 && !grid[i+1][j]) dph[i][j] = min(dph[i][j], dpv[i+1][j-1] + 1);\\n                if(i>0 && !grid[i-1][j] && j<n-1 && !grid[i][j+1]) dpv[i][j] = min(dpv[i][j], dph[i-1][j+1] + 1);\\n            }\\n        }\\n        if(dph[n-1][n-1] >= INT_MAX/2) return -1;\\n        else return dph[n-1][n-1];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```c++\\nclass Solution {\\npublic:\\n    int minimumMoves(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        vector<vector<int>> dph(n, vector<int>(n, INT_MAX/2)); //min moves to reach state with snake head at (i,j) and snake tail at (i,j-1) (ie, a snake lying horizontally)\\n        vector<vector<int>> dpv = dph; //min moves to reach state with snake head at (i,j) and snake tail at (i-1,j) (ie, a snake lying vertically)\\n        //0. init\\n        dph[0][1] = 0;\\n        if(!grid[1][0] && !grid[1][1]) dpv[1][0] = 1;\\n        for(int k = 2; k <= 2*n-2; k++){ //k is the wavefront, k = i+j\\n            int i_start = max(0, k - n + 1);\\n            int i_end = min(k, n-1);\\n            //1. first update dph[i][j] and dpv[i][j] (i+j == k) based on horizonal or vertical shifts, using dp[i\\'][j\\'] where i\\'+j\\'==k-1\\n            for(int i = i_start; i <= i_end; i++){\\n                int j = k - i;\\n                if(grid[i][j]) continue;\\n                //1.1. update dph\\n                if(j>0 && !grid[i][j-1]){\\n                    dph[i][j] = dph[i][j-1] + 1; //horizontal shift (right)\\n                    if(i>0) dph[i][j] = min(dph[i][j], dph[i-1][j] + 1); //vertical shift (down)\\n                }\\n                //1.2. update dpv\\n                if(i>0 && !grid[i-1][j]){\\n                    dpv[i][j] = dpv[i-1][j] + 1; //vertical shift (down)\\n                    if(j>0) dpv[i][j] = min(dpv[i][j], dpv[i][j-1] + 1); //horizontal shift (right)\\n                }\\n            }\\n            //2. Then update dph[i][j] and dpv[i][j] (i+j == k) based on rotations, using dp[i\\'][j\\'] where i\\'+j\\'==k (ie, same wavefronts)\\n            for(int i = i_start; i <= i_end; i++){\\n                int j = k - i;\\n                if(grid[i][j]) continue;\\n                if(j>0 && !grid[i][j-1] && i<n-1 && !grid[i+1][j]) dph[i][j] = min(dph[i][j], dpv[i+1][j-1] + 1);\\n                if(i>0 && !grid[i-1][j] && j<n-1 && !grid[i][j+1]) dpv[i][j] = min(dpv[i][j], dph[i-1][j+1] + 1);\\n            }\\n        }\\n        if(dph[n-1][n-1] >= INT_MAX/2) return -1;\\n        else return dph[n-1][n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1104966,
                "title": "c-bfs-string-set",
                "content": "```\\nclass Solution {\\nprivate:\\n    vector<vector<int>> moves = {{0, 1, 0, 1}, {1, 0, 1, 0}, {0, 0, 1, -1}, {0, 0, -1, 1}};\\npublic:\\n    int minimumMoves(vector<vector<int>>& grid) {\\n        int N = grid.size();\\n        unordered_set<string> seen;\\n        queue<vector<int>> todo; // { tx, ty, hx, hy, minSteps } ~==>\\n        todo.push({0, 0, 0, 1, 0});\\n        seen.insert(\"0001\");\\n        while (!todo.empty()) {\\n            vector<int> cur = todo.front(), newCur, move;\\n            todo.pop();\\n            if (cur[0] == N - 1 && cur[1] == N - 2 && cur[2] == N - 1 && cur[3] == N - 1) {\\n                return cur[4];\\n            }\\n            for (int ithMove = 0; ithMove < moves.size(); ithMove++) {\\n                move = moves[ithMove];\\n                int tX = cur[0] + move[0], tY = cur[1] + move[1];\\n                int hX = cur[2] + move[2], hY = cur[3] + move[3];\\n                newCur = { tX, tY, hX, hY };\\n                char prevDirection = (cur[0] == cur[2] ? \\'H\\' : \\'V\\');\\n                string coor = to_string(tX) + to_string(tY) + to_string(hX) + to_string(hY);\\n                if (inside(newCur, N, ithMove, prevDirection, grid) && seen.find(coor) == seen.end()) {\\n                    todo.push({tX, tY, hX, hY, cur[4] + 1});\\n                    seen.insert(coor);\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n    \\n    bool inside(vector<int> &cur, int &N, int &move, char &prevDirection, vector<vector<int>> &grid) {\\n        // Inside check\\n        if (cur[0] < 0 || cur[0] >= N || cur[2] < 0 || cur[2] >= N ||\\n           cur[1] < 0 || cur[1] >= N || cur[3] < 0 || cur[3] >= N) {\\n            return false;\\n        }\\n        // Go once cell right, check only head part\\n        if (move == 0 && (grid[cur[0]][cur[1]] == 1 || grid[cur[2]][cur[3]] == 1)) {\\n            return false;\\n        }\\n        // Go once cell down, check both head and tail\\n        if (move == 1 && (grid[cur[0]][cur[1]] == 1 || grid[cur[2]][cur[3]] == 1)) {\\n            return false;\\n        }\\n        // Rotate clocwise if Horizontal\\n        if (move == 2 && (prevDirection == \\'V\\' || grid[cur[2]][cur[3]] == 1 || grid[cur[2]][cur[3] + 1] == 1)) {\\n            return false;\\n        }\\n        // Rotate counter-clocwise if Vertical\\n        if (move == 3 && (prevDirection == \\'H\\' || grid[cur[2]][cur[3]] == 1 || grid[cur[2] + 1][cur[3]] == 1)) {\\n            return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    vector<vector<int>> moves = {{0, 1, 0, 1}, {1, 0, 1, 0}, {0, 0, 1, -1}, {0, 0, -1, 1}};\\npublic:\\n    int minimumMoves(vector<vector<int>>& grid) {\\n        int N = grid.size();\\n        unordered_set<string> seen;\\n        queue<vector<int>> todo; // { tx, ty, hx, hy, minSteps } ~==>\\n        todo.push({0, 0, 0, 1, 0});\\n        seen.insert(\"0001\");\\n        while (!todo.empty()) {\\n            vector<int> cur = todo.front(), newCur, move;\\n            todo.pop();\\n            if (cur[0] == N - 1 && cur[1] == N - 2 && cur[2] == N - 1 && cur[3] == N - 1) {\\n                return cur[4];\\n            }\\n            for (int ithMove = 0; ithMove < moves.size(); ithMove++) {\\n                move = moves[ithMove];\\n                int tX = cur[0] + move[0], tY = cur[1] + move[1];\\n                int hX = cur[2] + move[2], hY = cur[3] + move[3];\\n                newCur = { tX, tY, hX, hY };\\n                char prevDirection = (cur[0] == cur[2] ? \\'H\\' : \\'V\\');\\n                string coor = to_string(tX) + to_string(tY) + to_string(hX) + to_string(hY);\\n                if (inside(newCur, N, ithMove, prevDirection, grid) && seen.find(coor) == seen.end()) {\\n                    todo.push({tX, tY, hX, hY, cur[4] + 1});\\n                    seen.insert(coor);\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n    \\n    bool inside(vector<int> &cur, int &N, int &move, char &prevDirection, vector<vector<int>> &grid) {\\n        // Inside check\\n        if (cur[0] < 0 || cur[0] >= N || cur[2] < 0 || cur[2] >= N ||\\n           cur[1] < 0 || cur[1] >= N || cur[3] < 0 || cur[3] >= N) {\\n            return false;\\n        }\\n        // Go once cell right, check only head part\\n        if (move == 0 && (grid[cur[0]][cur[1]] == 1 || grid[cur[2]][cur[3]] == 1)) {\\n            return false;\\n        }\\n        // Go once cell down, check both head and tail\\n        if (move == 1 && (grid[cur[0]][cur[1]] == 1 || grid[cur[2]][cur[3]] == 1)) {\\n            return false;\\n        }\\n        // Rotate clocwise if Horizontal\\n        if (move == 2 && (prevDirection == \\'V\\' || grid[cur[2]][cur[3]] == 1 || grid[cur[2]][cur[3] + 1] == 1)) {\\n            return false;\\n        }\\n        // Rotate counter-clocwise if Vertical\\n        if (move == 3 && (prevDirection == \\'H\\' || grid[cur[2]][cur[3]] == 1 || grid[cur[2] + 1][cur[3]] == 1)) {\\n            return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1104668,
                "title": "c-concise-bfs",
                "content": "```\\nclass Solution {\\nprivate:\\n    vector<vector<int>> moves = {{0, 1, 0, 1}, {1, 0, 1, 0}, {0, 0, 1, -1}, {0, 0, -1, 1}};\\npublic:\\n    int minimumMoves(vector<vector<int>>& grid) {\\n        int N = grid.size();\\n        set<vector<int>> seen;\\n        queue<vector<int>> todo; // { tx, ty, hx, hy, minSteps } ~==>\\n        todo.push({0, 0, 0, 1, 0});\\n        seen.insert({0, 0, 0, 1});\\n        while (!todo.empty()) {\\n            vector<int> cur = todo.front(), newCur, move;\\n            todo.pop();\\n            if (cur[0] == N - 1 && cur[1] == N - 2 && cur[2] == N - 1 && cur[3] == N - 1) {\\n                return cur[4];\\n            }\\n            for (int ithMove = 0; ithMove < moves.size(); ithMove++) {\\n                move = moves[ithMove];\\n                int tX = cur[0] + move[0], tY = cur[1] + move[1];\\n                int hX = cur[2] + move[2], hY = cur[3] + move[3];\\n                newCur = { tX, tY, hX, hY };\\n                char prevDirection = (cur[0] == cur[2] ? \\'H\\' : \\'V\\');\\n                if (inside(newCur, N, ithMove, prevDirection, grid) && seen.find(newCur) == seen.end()) {\\n                    todo.push({tX, tY, hX, hY, cur[4] + 1});\\n                    seen.insert(newCur);\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n    \\n    bool inside(vector<int> &cur, int &N, int &move, char &prevDirection, vector<vector<int>> &grid) {\\n        // Inside check\\n        if (cur[0] < 0 || cur[0] >= N || cur[2] < 0 || cur[2] >= N ||\\n           cur[1] < 0 || cur[1] >= N || cur[3] < 0 || cur[3] >= N) {\\n            return false;\\n        }\\n        // Go once cell right, check only head part\\n        if (move == 0 && (grid[cur[0]][cur[1]] == 1 || grid[cur[2]][cur[3]] == 1)) {\\n            return false;\\n        }\\n        // Go once cell down, check both head and tail\\n        if (move == 1 && (grid[cur[0]][cur[1]] == 1 || grid[cur[2]][cur[3]] == 1)) {\\n            return false;\\n        }\\n        // Rotate clocwise if Horizontal\\n        if (move == 2 && (prevDirection == \\'V\\' || grid[cur[2]][cur[3]] == 1 || grid[cur[2]][cur[3] + 1] == 1)) {\\n            return false;\\n        }\\n        // Rotate counter-clocwise if Vertical\\n        if (move == 3 && (prevDirection == \\'H\\' || grid[cur[2]][cur[3]] == 1 || grid[cur[2] + 1][cur[3]] == 1)) {\\n            return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    vector<vector<int>> moves = {{0, 1, 0, 1}, {1, 0, 1, 0}, {0, 0, 1, -1}, {0, 0, -1, 1}};\\npublic:\\n    int minimumMoves(vector<vector<int>>& grid) {\\n        int N = grid.size();\\n        set<vector<int>> seen;\\n        queue<vector<int>> todo; // { tx, ty, hx, hy, minSteps } ~==>\\n        todo.push({0, 0, 0, 1, 0});\\n        seen.insert({0, 0, 0, 1});\\n        while (!todo.empty()) {\\n            vector<int> cur = todo.front(), newCur, move;\\n            todo.pop();\\n            if (cur[0] == N - 1 && cur[1] == N - 2 && cur[2] == N - 1 && cur[3] == N - 1) {\\n                return cur[4];\\n            }\\n            for (int ithMove = 0; ithMove < moves.size(); ithMove++) {\\n                move = moves[ithMove];\\n                int tX = cur[0] + move[0], tY = cur[1] + move[1];\\n                int hX = cur[2] + move[2], hY = cur[3] + move[3];\\n                newCur = { tX, tY, hX, hY };\\n                char prevDirection = (cur[0] == cur[2] ? \\'H\\' : \\'V\\');\\n                if (inside(newCur, N, ithMove, prevDirection, grid) && seen.find(newCur) == seen.end()) {\\n                    todo.push({tX, tY, hX, hY, cur[4] + 1});\\n                    seen.insert(newCur);\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n    \\n    bool inside(vector<int> &cur, int &N, int &move, char &prevDirection, vector<vector<int>> &grid) {\\n        // Inside check\\n        if (cur[0] < 0 || cur[0] >= N || cur[2] < 0 || cur[2] >= N ||\\n           cur[1] < 0 || cur[1] >= N || cur[3] < 0 || cur[3] >= N) {\\n            return false;\\n        }\\n        // Go once cell right, check only head part\\n        if (move == 0 && (grid[cur[0]][cur[1]] == 1 || grid[cur[2]][cur[3]] == 1)) {\\n            return false;\\n        }\\n        // Go once cell down, check both head and tail\\n        if (move == 1 && (grid[cur[0]][cur[1]] == 1 || grid[cur[2]][cur[3]] == 1)) {\\n            return false;\\n        }\\n        // Rotate clocwise if Horizontal\\n        if (move == 2 && (prevDirection == \\'V\\' || grid[cur[2]][cur[3]] == 1 || grid[cur[2]][cur[3] + 1] == 1)) {\\n            return false;\\n        }\\n        // Rotate counter-clocwise if Vertical\\n        if (move == 3 && (prevDirection == \\'H\\' || grid[cur[2]][cur[3]] == 1 || grid[cur[2] + 1][cur[3]] == 1)) {\\n            return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1104561,
                "title": "easy-bfs",
                "content": "```\\nclass Solution {\\n    public int minimumMoves(int[][] grid) {\\n        \\n        int n = grid.length;  \\n        //boolean[][][][] visited = new boolean[n][n][n][n];\\n        Set<Position> set = new HashSet<>();\\n       \\n        Queue<Position> q = new LinkedList<>();\\n        q.offer(new Position(0,0,0,1));        \\n        int count = 0;\\n                \\n        if(grid[n-1][n-2] == 1 || grid[n-1][n-1] == 1)\\n            return -1;\\n        \\n        while(!q.isEmpty()){\\n            ++count;\\n            Queue<Position> nextq = new LinkedList<>();\\n            while(!q.isEmpty()){\\n                \\n                Position p = q.poll();\\n\\n                int r1 = p.getr1();\\n                int r2 = p.getr2();\\n                int c1 = p.getc1();\\n                int c2 = p.getc2();\\n                \\n                if(r1 == n-1 && r2 == n-1 && c1 == n-2 && c2==n-1)\\n                    return count-1;\\n                \\n                if(set.contains(p))\\n                    continue;\\n                \\n                if(c1+1 < n && grid[r1] [c1+1] != 1 && c2+1 < n && grid[r2] [c2+1] != 1)\\n                    nextq.offer(new Position(r1, c1+1, r2, c2+1));\\n                if(r1+1 < n && grid[r1+1] [c1] != 1 && r2+1 < n && grid[r2+1] [c2] != 1)\\n                    nextq.offer(new Position(r1+1, c1, r2+1, c2));\\n                \\n                if(r1 == r2 && r1+1 < n && r2+1 < n && grid[r1+1][c1] == 0 && grid[r2+1][c2] == 0 && grid[r1+1][c1] == 0)\\n                    nextq.offer(new Position(r1,c1, r1+1, c1));\\n                \\n                if(c1 == c2 && c1+1 < n && c2+1 < n && grid[r1][c1+1] == 0 && grid[r2][c1+1] == 0   && grid[r1][c1+1] == 0)\\n                    nextq.offer(new Position(r1,c1, r1, c1+1));\\n                set.add(p);\\n            }\\n            q = nextq;\\n        }\\n        return -1;\\n    }\\n    \\n    private class Position{\\n        int r1;\\n        int c1;\\n        int r2;\\n        int c2;\\n        \\n        public Position(int r1, int c1, int r2, int c2){\\n            this.r1 = r1;\\n            this.r2 = r2;\\n            this.c1 =c1;\\n            this.c2 = c2;\\n        }\\n        \\n        public int getr1(){\\n            return this.r1;\\n        }\\n        public int getr2(){\\n            return this.r2;\\n        }\\n        public int getc1(){\\n            return this.c1;\\n        }\\n        public int getc2(){\\n            return this.c2;\\n        }\\n        \\n        @Override\\n        public int hashCode() {\\n            final int prime = 31;\\n            int result = 1;\\n            result = prime * r1 + c1 + prime *r2 + c2;\\n            return result;\\n        }\\n        \\n        @Override\\n        public boolean equals(Object obj) {\\n            Position p = (Position) obj;\\n            if(this.r1 == p.getr1() && this.r2 ==p.getr2() && this.c1 == p.getc1() && this.c2==p.getc2())\\n                return true;\\n            else\\n                return false;\\n        }\\n    }    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumMoves(int[][] grid) {\\n        \\n        int n = grid.length;  \\n        //boolean[][][][] visited = new boolean[n][n][n][n];\\n        Set<Position> set = new HashSet<>();\\n       \\n        Queue<Position> q = new LinkedList<>();\\n        q.offer(new Position(0,0,0,1));        \\n        int count = 0;\\n                \\n        if(grid[n-1][n-2] == 1 || grid[n-1][n-1] == 1)\\n            return -1;\\n        \\n        while(!q.isEmpty()){\\n            ++count;\\n            Queue<Position> nextq = new LinkedList<>();\\n            while(!q.isEmpty()){\\n                \\n                Position p = q.poll();\\n\\n                int r1 = p.getr1();\\n                int r2 = p.getr2();\\n                int c1 = p.getc1();\\n                int c2 = p.getc2();\\n                \\n                if(r1 == n-1 && r2 == n-1 && c1 == n-2 && c2==n-1)\\n                    return count-1;\\n                \\n                if(set.contains(p))\\n                    continue;\\n                \\n                if(c1+1 < n && grid[r1] [c1+1] != 1 && c2+1 < n && grid[r2] [c2+1] != 1)\\n                    nextq.offer(new Position(r1, c1+1, r2, c2+1));\\n                if(r1+1 < n && grid[r1+1] [c1] != 1 && r2+1 < n && grid[r2+1] [c2] != 1)\\n                    nextq.offer(new Position(r1+1, c1, r2+1, c2));\\n                \\n                if(r1 == r2 && r1+1 < n && r2+1 < n && grid[r1+1][c1] == 0 && grid[r2+1][c2] == 0 && grid[r1+1][c1] == 0)\\n                    nextq.offer(new Position(r1,c1, r1+1, c1));\\n                \\n                if(c1 == c2 && c1+1 < n && c2+1 < n && grid[r1][c1+1] == 0 && grid[r2][c1+1] == 0   && grid[r1][c1+1] == 0)\\n                    nextq.offer(new Position(r1,c1, r1, c1+1));\\n                set.add(p);\\n            }\\n            q = nextq;\\n        }\\n        return -1;\\n    }\\n    \\n    private class Position{\\n        int r1;\\n        int c1;\\n        int r2;\\n        int c2;\\n        \\n        public Position(int r1, int c1, int r2, int c2){\\n            this.r1 = r1;\\n            this.r2 = r2;\\n            this.c1 =c1;\\n            this.c2 = c2;\\n        }\\n        \\n        public int getr1(){\\n            return this.r1;\\n        }\\n        public int getr2(){\\n            return this.r2;\\n        }\\n        public int getc1(){\\n            return this.c1;\\n        }\\n        public int getc2(){\\n            return this.c2;\\n        }\\n        \\n        @Override\\n        public int hashCode() {\\n            final int prime = 31;\\n            int result = 1;\\n            result = prime * r1 + c1 + prime *r2 + c2;\\n            return result;\\n        }\\n        \\n        @Override\\n        public boolean equals(Object obj) {\\n            Position p = (Position) obj;\\n            if(this.r1 == p.getr1() && this.r2 ==p.getr2() && this.c1 == p.getc1() && this.c2==p.getc2())\\n                return true;\\n            else\\n                return false;\\n        }\\n    }    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1078757,
                "title": "common-bfs",
                "content": "```\\nint[] d = {0,1,0};\\n    public int minimumMoves(int[][] grid) {\\n        int n = grid.length, cnt = 0;\\n        boolean dp[][][] = new boolean[n][n][2];\\n        Queue<int[]> q = new LinkedList<>();\\n        q.add(new int[]{0,1,0});\\n        dp[0][1][0] = true;\\n        while (!q.isEmpty()){\\n            int size = q.size();\\n            for (int i = 0; i < size; i++){\\n                int cur[] = q.poll(), r = cur[0], c = cur[1], dir = cur[2], tr, tc;\\n                if (r == n-1 && c == n-1 && dir == 0) return cnt;\\n                if (dir == 0){\\n                    tr = r;\\n                    tc = c-1;\\n                    if (isValid(r+1,c-1,grid) && isValid(r+1,c,grid) && !dp[r+1][c-1][1]){\\n                        q.add(new int[]{r+1,c-1,1});\\n                        dp[r+1][c-1][1] = true;\\n                    }\\n                }else{\\n                    tr = r-1;\\n                    tc = c;\\n                    if (isValid(r,c+1,grid) && isValid(r-1,c+1,grid) && !dp[r-1][c+1][0]){\\n                        q.add(new int[]{r-1,c+1,0});\\n                        dp[r-1][c+1][0] = true;\\n                    }\\n                }\\n                for (int j = 0; j < 2; j++){\\n                    int nr = r + d[j], nc = c + d[j+1], ntr = tr + d[j], ntc = tc + d[j+1];\\n                    if (isValid(nr,nc,grid) && isValid(ntr,ntc,grid) && !dp[nr][nc][dir]){\\n                        q.add(new int[]{nr,nc,dir});\\n                        dp[nr][nc][dir] = true;\\n                    } \\n                }\\n            }\\n            cnt++;\\n        }\\n        return -1;\\n    }\\n    boolean isValid(int r, int c, int[][] grid){\\n        int n = grid.length;\\n        return r < n && c < n && grid[r][c] == 0;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint[] d = {0,1,0};\\n    public int minimumMoves(int[][] grid) {\\n        int n = grid.length, cnt = 0;\\n        boolean dp[][][] = new boolean[n][n][2];\\n        Queue<int[]> q = new LinkedList<>();\\n        q.add(new int[]{0,1,0});\\n        dp[0][1][0] = true;\\n        while (!q.isEmpty()){\\n            int size = q.size();\\n            for (int i = 0; i < size; i++){\\n                int cur[] = q.poll(), r = cur[0], c = cur[1], dir = cur[2], tr, tc;\\n                if (r == n-1 && c == n-1 && dir == 0) return cnt;\\n                if (dir == 0){\\n                    tr = r;\\n                    tc = c-1;\\n                    if (isValid(r+1,c-1,grid) && isValid(r+1,c,grid) && !dp[r+1][c-1][1]){\\n                        q.add(new int[]{r+1,c-1,1});\\n                        dp[r+1][c-1][1] = true;\\n                    }\\n                }else{\\n                    tr = r-1;\\n                    tc = c;\\n                    if (isValid(r,c+1,grid) && isValid(r-1,c+1,grid) && !dp[r-1][c+1][0]){\\n                        q.add(new int[]{r-1,c+1,0});\\n                        dp[r-1][c+1][0] = true;\\n                    }\\n                }\\n                for (int j = 0; j < 2; j++){\\n                    int nr = r + d[j], nc = c + d[j+1], ntr = tr + d[j], ntc = tc + d[j+1];\\n                    if (isValid(nr,nc,grid) && isValid(ntr,ntc,grid) && !dp[nr][nc][dir]){\\n                        q.add(new int[]{nr,nc,dir});\\n                        dp[nr][nc][dir] = true;\\n                    } \\n                }\\n            }\\n            cnt++;\\n        }\\n        return -1;\\n    }\\n    boolean isValid(int r, int c, int[][] grid){\\n        int n = grid.length;\\n        return r < n && c < n && grid[r][c] == 0;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1035527,
                "title": "c-breadth-first-memoize-faster-than-100",
                "content": "```c\\n/* Approach: breadth-first search.  The first solution is the minimum number of moves.\\n * At each turn, we convert list of current positions to a new list of positions by\\n * converting a position to a new set of positions.  The new set can be empty (no\\n * moves possible) or can contain 1, 2, 3, or 4 new positions.  The game ends when\\n * a new position is at target.\\n *\\n * Keep track of which positions have been examined so as not to calculated them\\n * again and again.\\n */\\n\\n\\nenum move { MOVE_RIGHT, MOVE_DOWN, ROT_CLOCK, ROT_COUNTER, N_MOVES };\\n\\n#if UINTPTR_MAX == 18446744073709551615UL\\n#define BITS_PER_EL 6\\n#else\\n#define BITS_PER_EL 5\\n#endif\\n\\n#define DEBUG 0\\n\\nstruct pos {\\n    int     vertical;\\n    int     tail[2];        /* Position of tail, row, column */\\n};\\n\\nstruct list_of_pos {\\n    struct pos  *pos;\\n    unsigned     n_pos, n_alloced;\\n};\\n\\nstatic unsigned\\npos2flat (struct pos pos, int n)\\n{\\n    return (pos.vertical << 14) | ((unsigned char) pos.tail[0] << 7) | ((unsigned char) pos.tail[1]);\\n}\\n\\nstatic const char *const move2str[] = { \"RIGHT\", \"DOWN\", \"CLOCKWISE\", \"COUNTERCLOCKWISE\", };\\n\\nstatic void\\nmaybe_push_pos (struct list_of_pos *list, uintptr_t *examined, int n, struct pos pos,\\n                                                                            enum move move)\\n{\\n    unsigned flat_pos, set, bit;\\n    \\n    flat_pos = pos2flat(pos, n);\\n    set = flat_pos >> BITS_PER_EL;\\n    bit = flat_pos & ((1u << BITS_PER_EL) - 1);\\n    if (DEBUG)\\n        printf(\"try %s: flat: %u, set: %u, bit: %u\\\\n\", move2str[move], flat_pos, set, bit);\\n    \\n    if (examined[set] & (1ull << bit))\\n        return;\\n    \\n    if (list->n_pos >= list->n_alloced)\\n    {\\n        /* XXX we assume all allocations succeed */\\n        list->n_alloced = list->n_alloced ? list->n_alloced * 2 : 4;\\n        list->pos = realloc(list->pos, sizeof(list->pos[0]) * list->n_alloced);\\n    }\\n    list->pos[list->n_pos++] = pos;\\n    examined[set] |= 1ull << bit;\\n    if (DEBUG)\\n        printf(\"pushed %s, pos(%d,%d,%d) (flat: %u)\\\\n\", move2str[move], pos.vertical, pos.tail[0], pos.tail[1], flat_pos);\\n}\\n\\nstatic int\\nend_position (struct pos pos, int n)\\n{\\n    return !pos.vertical && pos.tail[0] == n - 1 && pos.tail[1] == n - 2;\\n}\\n\\nint minimumMoves(int** grid, int n, int* gridColSize){\\n    /* For simplicity, the bitmask is the same size for all inputs: n fits into 7 bits and\\n     * \"vertical\" property is 1 bit.\\n     */\\n    uintptr_t examined[ (1 << (1 + 7 + 7)) / sizeof(uintptr_t) / 8];\\n    struct list_of_pos lists[2], *cur_list, *next_list;\\n    int r, c, n_steps;\\n    \\n    assert(gridColSize[0] == n);\\n\\n    memset(examined, 0, sizeof(examined));\\n    memset(lists, 0, sizeof(lists));\\n    \\n    n_steps = 0;\\n    maybe_push_pos(&lists[n_steps & 1], examined, n, (struct pos) { 0, { 0, 0, }}, MOVE_RIGHT);\\n    while (lists[n_steps & 1].n_pos)\\n    {\\n        const struct pos *pos;\\n        struct pos new_pos;\\n        \\n        if (DEBUG)\\n            printf(\"steps: %d\\\\n\", n_steps);\\n        cur_list = &lists[n_steps & 1];\\n        next_list = &lists[!(n_steps & 1)];\\n        ++n_steps;\\n        for (pos = cur_list->pos; pos < cur_list->pos + cur_list->n_pos; ++pos)\\n        {\\n            if (DEBUG)\\n                printf(\"examine pos(%d,%d,%d)\\\\n\", pos->vertical, pos->tail[0], pos->tail[1]);\\n            enum move move;\\n            for (move = MOVE_RIGHT; move < N_MOVES; ++move)\\n            {\\n                switch (move)\\n                {\\n                case MOVE_RIGHT:\\n                    if (pos->vertical)\\n                    {\\n                        if (pos->tail[1] + 1 >= n\\n                            || grid[pos->tail[0] + 0][pos->tail[1] + 1]\\n                            || grid[pos->tail[0] + 1][pos->tail[1] + 1])\\n                            continue;\\n                        new_pos = (struct pos) { 1, { pos->tail[0], pos->tail[1] + 1 }};\\n                    }\\n                    else\\n                    {\\n                        if (pos->tail[1] + 2 >= n\\n                            || grid[pos->tail[0] + 0][pos->tail[1] + 2])\\n                            continue;\\n                        new_pos = (struct pos) { 0, { pos->tail[0], pos->tail[1] + 1 }};\\n                    }\\n                    break;\\n                case MOVE_DOWN:\\n                    if (pos->vertical)\\n                    {\\n                        if (pos->tail[0] + 2 >= n\\n                            || grid[pos->tail[0] + 2][pos->tail[1]])\\n                            continue;\\n                        new_pos = (struct pos) { 1, { pos->tail[0] + 1, pos->tail[1] }};\\n                    }\\n                    else\\n                    {\\n                        if (pos->tail[0] + 1 >= n\\n                            || grid[pos->tail[0] + 1][pos->tail[1] + 0]\\n                            || grid[pos->tail[0] + 1][pos->tail[1] + 1])\\n                            continue;\\n                        new_pos = (struct pos) { 0, { pos->tail[0] + 1, pos->tail[1] }};\\n                    }\\n                    break;\\n                case ROT_CLOCK:\\n                    if (pos->vertical)    \\n                        continue;\\n                    if (pos->tail[0] + 1 >= n\\n                        || grid[pos->tail[0] + 1][pos->tail[1] + 0]\\n                        || grid[pos->tail[0] + 1][pos->tail[1] + 1])\\n                        continue;\\n                    new_pos = (struct pos) { 1, { pos->tail[0], pos->tail[1] }};\\n                    break;\\n                case ROT_COUNTER:        \\n                    if (!pos->vertical)    \\n                        continue;\\n                    if (pos->tail[1] + 1 >= n\\n                        || grid[pos->tail[0] + 0][pos->tail[1] + 1]\\n                        || grid[pos->tail[0] + 1][pos->tail[1] + 1])\\n                        continue;\\n                    new_pos = (struct pos) { 0, { pos->tail[0], pos->tail[1] }};\\n                    break;\\n                }\\n                if (end_position(new_pos, n))\\n                    goto end;\\n                maybe_push_pos(next_list, examined, n, new_pos, move);\\n            }\\n        }\\n        cur_list->n_pos = 0;\\n    }\\n    n_steps = -1;   /* Failure! */\\n    \\n end:\\n    free(lists[0].pos);\\n    free(lists[1].pos);\\n    \\n    return n_steps;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```c\\n/* Approach: breadth-first search.  The first solution is the minimum number of moves.\\n * At each turn, we convert list of current positions to a new list of positions by\\n * converting a position to a new set of positions.  The new set can be empty (no\\n * moves possible) or can contain 1, 2, 3, or 4 new positions.  The game ends when\\n * a new position is at target.\\n *\\n * Keep track of which positions have been examined so as not to calculated them\\n * again and again.\\n */\\n\\n\\nenum move { MOVE_RIGHT, MOVE_DOWN, ROT_CLOCK, ROT_COUNTER, N_MOVES };\\n\\n#if UINTPTR_MAX == 18446744073709551615UL\\n#define BITS_PER_EL 6\\n#else\\n#define BITS_PER_EL 5\\n#endif\\n\\n#define DEBUG 0\\n\\nstruct pos {\\n    int     vertical;\\n    int     tail[2];        /* Position of tail, row, column */\\n};\\n\\nstruct list_of_pos {\\n    struct pos  *pos;\\n    unsigned     n_pos, n_alloced;\\n};\\n\\nstatic unsigned\\npos2flat (struct pos pos, int n)\\n{\\n    return (pos.vertical << 14) | ((unsigned char) pos.tail[0] << 7) | ((unsigned char) pos.tail[1]);\\n}\\n\\nstatic const char *const move2str[] = { \"RIGHT\", \"DOWN\", \"CLOCKWISE\", \"COUNTERCLOCKWISE\", };\\n\\nstatic void\\nmaybe_push_pos (struct list_of_pos *list, uintptr_t *examined, int n, struct pos pos,\\n                                                                            enum move move)\\n{\\n    unsigned flat_pos, set, bit;\\n    \\n    flat_pos = pos2flat(pos, n);\\n    set = flat_pos >> BITS_PER_EL;\\n    bit = flat_pos & ((1u << BITS_PER_EL) - 1);\\n    if (DEBUG)\\n        printf(\"try %s: flat: %u, set: %u, bit: %u\\\\n\", move2str[move], flat_pos, set, bit);\\n    \\n    if (examined[set] & (1ull << bit))\\n        return;\\n    \\n    if (list->n_pos >= list->n_alloced)\\n    {\\n        /* XXX we assume all allocations succeed */\\n        list->n_alloced = list->n_alloced ? list->n_alloced * 2 : 4;\\n        list->pos = realloc(list->pos, sizeof(list->pos[0]) * list->n_alloced);\\n    }\\n    list->pos[list->n_pos++] = pos;\\n    examined[set] |= 1ull << bit;\\n    if (DEBUG)\\n        printf(\"pushed %s, pos(%d,%d,%d) (flat: %u)\\\\n\", move2str[move], pos.vertical, pos.tail[0], pos.tail[1], flat_pos);\\n}\\n\\nstatic int\\nend_position (struct pos pos, int n)\\n{\\n    return !pos.vertical && pos.tail[0] == n - 1 && pos.tail[1] == n - 2;\\n}\\n\\nint minimumMoves(int** grid, int n, int* gridColSize){\\n    /* For simplicity, the bitmask is the same size for all inputs: n fits into 7 bits and\\n     * \"vertical\" property is 1 bit.\\n     */\\n    uintptr_t examined[ (1 << (1 + 7 + 7)) / sizeof(uintptr_t) / 8];\\n    struct list_of_pos lists[2], *cur_list, *next_list;\\n    int r, c, n_steps;\\n    \\n    assert(gridColSize[0] == n);\\n\\n    memset(examined, 0, sizeof(examined));\\n    memset(lists, 0, sizeof(lists));\\n    \\n    n_steps = 0;\\n    maybe_push_pos(&lists[n_steps & 1], examined, n, (struct pos) { 0, { 0, 0, }}, MOVE_RIGHT);\\n    while (lists[n_steps & 1].n_pos)\\n    {\\n        const struct pos *pos;\\n        struct pos new_pos;\\n        \\n        if (DEBUG)\\n            printf(\"steps: %d\\\\n\", n_steps);\\n        cur_list = &lists[n_steps & 1];\\n        next_list = &lists[!(n_steps & 1)];\\n        ++n_steps;\\n        for (pos = cur_list->pos; pos < cur_list->pos + cur_list->n_pos; ++pos)\\n        {\\n            if (DEBUG)\\n                printf(\"examine pos(%d,%d,%d)\\\\n\", pos->vertical, pos->tail[0], pos->tail[1]);\\n            enum move move;\\n            for (move = MOVE_RIGHT; move < N_MOVES; ++move)\\n            {\\n                switch (move)\\n                {\\n                case MOVE_RIGHT:\\n                    if (pos->vertical)\\n                    {\\n                        if (pos->tail[1] + 1 >= n\\n                            || grid[pos->tail[0] + 0][pos->tail[1] + 1]\\n                            || grid[pos->tail[0] + 1][pos->tail[1] + 1])\\n                            continue;\\n                        new_pos = (struct pos) { 1, { pos->tail[0], pos->tail[1] + 1 }};\\n                    }\\n                    else\\n                    {\\n                        if (pos->tail[1] + 2 >= n\\n                            || grid[pos->tail[0] + 0][pos->tail[1] + 2])\\n                            continue;\\n                        new_pos = (struct pos) { 0, { pos->tail[0], pos->tail[1] + 1 }};\\n                    }\\n                    break;\\n                case MOVE_DOWN:\\n                    if (pos->vertical)\\n                    {\\n                        if (pos->tail[0] + 2 >= n\\n                            || grid[pos->tail[0] + 2][pos->tail[1]])\\n                            continue;\\n                        new_pos = (struct pos) { 1, { pos->tail[0] + 1, pos->tail[1] }};\\n                    }\\n                    else\\n                    {\\n                        if (pos->tail[0] + 1 >= n\\n                            || grid[pos->tail[0] + 1][pos->tail[1] + 0]\\n                            || grid[pos->tail[0] + 1][pos->tail[1] + 1])\\n                            continue;\\n                        new_pos = (struct pos) { 0, { pos->tail[0] + 1, pos->tail[1] }};\\n                    }\\n                    break;\\n                case ROT_CLOCK:\\n                    if (pos->vertical)    \\n                        continue;\\n                    if (pos->tail[0] + 1 >= n\\n                        || grid[pos->tail[0] + 1][pos->tail[1] + 0]\\n                        || grid[pos->tail[0] + 1][pos->tail[1] + 1])\\n                        continue;\\n                    new_pos = (struct pos) { 1, { pos->tail[0], pos->tail[1] }};\\n                    break;\\n                case ROT_COUNTER:        \\n                    if (!pos->vertical)    \\n                        continue;\\n                    if (pos->tail[1] + 1 >= n\\n                        || grid[pos->tail[0] + 0][pos->tail[1] + 1]\\n                        || grid[pos->tail[0] + 1][pos->tail[1] + 1])\\n                        continue;\\n                    new_pos = (struct pos) { 0, { pos->tail[0], pos->tail[1] }};\\n                    break;\\n                }\\n                if (end_position(new_pos, n))\\n                    goto end;\\n                maybe_push_pos(next_list, examined, n, new_pos, move);\\n            }\\n        }\\n        cur_list->n_pos = 0;\\n    }\\n    n_steps = -1;   /* Failure! */\\n    \\n end:\\n    free(lists[0].pos);\\n    free(lists[1].pos);\\n    \\n    return n_steps;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 993300,
                "title": "java-dijkstra",
                "content": "Preword: this problem is very code heavy.\\n```\\nclass Solution {\\n    public int minimumMoves(int[][] grid) {\\n        int n = grid.length;\\n        int[][] pos = {{0, 0}, {0, 1}, {0}};\\n        PriorityQueue<int[][]> pq = new PriorityQueue<>((a, b) -> Integer.compare(a[2][0], b[2][0]));\\n        Set<String> visited = new HashSet<>();\\n        pq.offer(pos);\\n        visited.add(toString(pos));\\n        while (!pq.isEmpty()) {\\n            int[][] cur = pq.poll();\\n            if (cur[0][0] == n - 1 && cur[0][1] == n - 2 && cur[1][0] == n - 1 && cur[1][1] == n - 1) {\\n                return cur[2][0];\\n            }\\n            int[][] next1 = moveRight(cur, n, grid);\\n            int[][] next2 = moveDown(cur, n, grid);\\n            int[][] next3 = rotate(cur, n, grid);\\n            int[][] next4 = rotatec(cur, n, grid);\\n            if (next1 != null) {\\n                if (visited.add(toString(next1))) {\\n                    pq.offer(next1);\\n                }\\n            }\\n            if (next2 != null) {\\n                if (visited.add(toString(next2))) {\\n                    pq.offer(next2);\\n                }\\n            }\\n            if (next3 != null) {\\n                if (visited.add(toString(next3))) {\\n                    pq.offer(next3);\\n                }\\n            }\\n            if (next4 != null) {\\n                if (visited.add(toString(next4))) {\\n                    pq.offer(next4);\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n    \\n    private String toString(int[][] cur) {\\n        return cur[0][0] + \" \" + cur[0][1] + \" \" + cur[1][0] + \" \" + cur[1][1];\\n    }\\n    \\n    private int[][] clone(int[][] cur) {\\n        return new int[][]{{cur[0][0], cur[0][1]}, {cur[1][0], cur[1][1]}, {cur[2][0]}};\\n    }\\n    \\n    private int[][] moveRight(int[][] cur, int n, int[][] grid) {\\n        int[][] next = clone(cur);\\n        next[0][1]++;\\n        next[1][1]++;\\n        if (next[0][1] >= n || next[1][1] >= n) {\\n            return null;\\n        }\\n        if (grid[next[0][0]][next[0][1]] == 1) {\\n            return null;\\n        }\\n        if (grid[next[1][0]][next[1][1]] == 1) {\\n            return null;\\n        }\\n        next[2][0]++;\\n        return next;\\n    }\\n    \\n    private int[][] moveDown(int[][] cur, int n, int[][] grid) {\\n        int[][] next = clone(cur);\\n        next[0][0]++;\\n        next[1][0]++;\\n        if (next[0][0] >= n || next[1][0] >= n) {\\n            return null;\\n        }\\n        if (grid[next[0][0]][next[0][1]] == 1) {\\n            return null;\\n        }\\n        if (grid[next[1][0]][next[1][1]] == 1) {\\n            return null;\\n        }\\n        next[2][0]++;\\n        return next;\\n    }\\n    \\n    private int[][] rotate(int[][] cur, int n, int[][] grid) {\\n        int[][] next = clone(cur);\\n        if (cur[0][0] == cur[1][0] && cur[0][1] + 1 == cur[1][1]) {\\n            if (cur[0][0] + 1 >= n) {\\n                return null;\\n            }\\n            if (grid[cur[0][0] + 1][cur[0][1]] == 1) {\\n                return null;\\n            }\\n            if (grid[cur[1][0] + 1][cur[1][1]] == 1) {\\n                return null;\\n            }\\n            next[1][0]++;\\n            next[1][1]--;\\n            next[2][0]++;\\n            return next;\\n        }\\n        return null;\\n    }\\n    \\n    private int[][] rotatec(int[][] cur, int n, int[][] grid) {\\n        int[][] next = clone(cur);\\n        if (cur[0][0] + 1 == cur[1][0] && cur[0][1] == cur[1][1]) {\\n            if (cur[0][1] + 1 >= n) {\\n                return null;\\n            }\\n            if (grid[cur[0][0]][cur[0][1] + 1] == 1) {\\n                return null;\\n            }\\n            if (grid[cur[1][0]][cur[1][1] + 1] == 1) {\\n                return null;\\n            }\\n            next[1][0]--;\\n            next[1][1]++;\\n            next[2][0]++;\\n            return next;\\n        }\\n        return null;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minimumMoves(int[][] grid) {\\n        int n = grid.length;\\n        int[][] pos = {{0, 0}, {0, 1}, {0}};\\n        PriorityQueue<int[][]> pq = new PriorityQueue<>((a, b) -> Integer.compare(a[2][0], b[2][0]));\\n        Set<String> visited = new HashSet<>();\\n        pq.offer(pos);\\n        visited.add(toString(pos));\\n        while (!pq.isEmpty()) {\\n            int[][] cur = pq.poll();\\n            if (cur[0][0] == n - 1 && cur[0][1] == n - 2 && cur[1][0] == n - 1 && cur[1][1] == n - 1) {\\n                return cur[2][0];\\n            }\\n            int[][] next1 = moveRight(cur, n, grid);\\n            int[][] next2 = moveDown(cur, n, grid);\\n            int[][] next3 = rotate(cur, n, grid);\\n            int[][] next4 = rotatec(cur, n, grid);\\n            if (next1 != null) {\\n                if (visited.add(toString(next1))) {\\n                    pq.offer(next1);\\n                }\\n            }\\n            if (next2 != null) {\\n                if (visited.add(toString(next2))) {\\n                    pq.offer(next2);\\n                }\\n            }\\n            if (next3 != null) {\\n                if (visited.add(toString(next3))) {\\n                    pq.offer(next3);\\n                }\\n            }\\n            if (next4 != null) {\\n                if (visited.add(toString(next4))) {\\n                    pq.offer(next4);\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n    \\n    private String toString(int[][] cur) {\\n        return cur[0][0] + \" \" + cur[0][1] + \" \" + cur[1][0] + \" \" + cur[1][1];\\n    }\\n    \\n    private int[][] clone(int[][] cur) {\\n        return new int[][]{{cur[0][0], cur[0][1]}, {cur[1][0], cur[1][1]}, {cur[2][0]}};\\n    }\\n    \\n    private int[][] moveRight(int[][] cur, int n, int[][] grid) {\\n        int[][] next = clone(cur);\\n        next[0][1]++;\\n        next[1][1]++;\\n        if (next[0][1] >= n || next[1][1] >= n) {\\n            return null;\\n        }\\n        if (grid[next[0][0]][next[0][1]] == 1) {\\n            return null;\\n        }\\n        if (grid[next[1][0]][next[1][1]] == 1) {\\n            return null;\\n        }\\n        next[2][0]++;\\n        return next;\\n    }\\n    \\n    private int[][] moveDown(int[][] cur, int n, int[][] grid) {\\n        int[][] next = clone(cur);\\n        next[0][0]++;\\n        next[1][0]++;\\n        if (next[0][0] >= n || next[1][0] >= n) {\\n            return null;\\n        }\\n        if (grid[next[0][0]][next[0][1]] == 1) {\\n            return null;\\n        }\\n        if (grid[next[1][0]][next[1][1]] == 1) {\\n            return null;\\n        }\\n        next[2][0]++;\\n        return next;\\n    }\\n    \\n    private int[][] rotate(int[][] cur, int n, int[][] grid) {\\n        int[][] next = clone(cur);\\n        if (cur[0][0] == cur[1][0] && cur[0][1] + 1 == cur[1][1]) {\\n            if (cur[0][0] + 1 >= n) {\\n                return null;\\n            }\\n            if (grid[cur[0][0] + 1][cur[0][1]] == 1) {\\n                return null;\\n            }\\n            if (grid[cur[1][0] + 1][cur[1][1]] == 1) {\\n                return null;\\n            }\\n            next[1][0]++;\\n            next[1][1]--;\\n            next[2][0]++;\\n            return next;\\n        }\\n        return null;\\n    }\\n    \\n    private int[][] rotatec(int[][] cur, int n, int[][] grid) {\\n        int[][] next = clone(cur);\\n        if (cur[0][0] + 1 == cur[1][0] && cur[0][1] == cur[1][1]) {\\n            if (cur[0][1] + 1 >= n) {\\n                return null;\\n            }\\n            if (grid[cur[0][0]][cur[0][1] + 1] == 1) {\\n                return null;\\n            }\\n            if (grid[cur[1][0]][cur[1][1] + 1] == 1) {\\n                return null;\\n            }\\n            next[1][0]--;\\n            next[1][1]++;\\n            next[2][0]++;\\n            return next;\\n        }\\n        return null;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 948735,
                "title": "c-bfs",
                "content": "```\\npublic class Solution\\n{\\n  enum Alignment\\n  {\\n    Vertical,\\n    Horizontal\\n  }\\n\\n  class Key : IEquatable<Key>\\n  {\\n    public (int i, int j) Point { get; }\\n    public Alignment Align { get; }\\n\\n    public Key((int, int) point, Alignment align)\\n    {\\n      Point = point;\\n      Align = align;\\n    }\\n\\n    public override string ToString() => $\"{Point} {Align}\";\\n\\n    public override bool Equals(object obj) => ((Key)obj).Point == Point && ((Key)obj).Align == Align;\\n\\n    public override int GetHashCode() => HashCode.Combine(Point, Align);\\n\\n    public bool Equals(Key other) => other.Point == Point && other.Align == Align;\\n  }\\n\\n  class QueueItem\\n  {\\n    public Key Key { get; }\\n    public int Path { get; }\\n\\n    public QueueItem(Key key, int path)\\n    {\\n      Key = key;\\n      Path = path;\\n    }\\n  }\\n\\n  public int MinimumMoves(int[][] grid)\\n  {\\n    var dp = new Dictionary<Key, int>();\\n\\n    var queue = new Queue<QueueItem>();\\n    queue.Enqueue(new QueueItem(key: new Key((0, 0), Alignment.Horizontal), path: 0));\\n\\n    while (queue.Count > 0)\\n    {\\n      var item = queue.Dequeue();\\n\\n      if (item.Key.Align == Alignment.Horizontal && item.Key.Point == (grid.Length - 1, grid[0].Length - 2))\\n        return item.Path;\\n\\n      if (dp.ContainsKey(item.Key)/* && dp[item.Key] <= item.Path*/)\\n        continue;\\n\\n      dp[item.Key] = item.Path;\\n\\n      var ways = new List<QueueItem>();\\n\\n      // vertical down or right\\n      if (item.Key.Align == Alignment.Vertical)\\n      {\\n        if (item.Key.Point.i + 2 < grid.Length && \\n            grid[item.Key.Point.i + 2][item.Key.Point.j] == 0)\\n        {\\n          ways.Add(new QueueItem(\\n            new Key((item.Key.Point.i + 1, item.Key.Point.j), Alignment.Vertical), \\n            item.Path + 1));\\n        }\\n\\n        if (item.Key.Point.i + 1 < grid.Length && \\n            item.Key.Point.j + 1 < grid[0].Length &&\\n            grid[item.Key.Point.i][item.Key.Point.j + 1] == 0 &&\\n            grid[item.Key.Point.i + 1][item.Key.Point.j + 1] == 0)\\n        {\\n          ways.Add(new QueueItem(\\n            new Key((item.Key.Point.i, item.Key.Point.j + 1), Alignment.Vertical),\\n            item.Path + 1));\\n        }\\n      }\\n\\n      // horizontal down or right\\n      if (item.Key.Align == Alignment.Horizontal)\\n      {\\n        if (item.Key.Point.j + 2 < grid[0].Length &&\\n            grid[item.Key.Point.i][item.Key.Point.j + 2] == 0)\\n        {\\n          ways.Add(new QueueItem(\\n            new Key((item.Key.Point.i, item.Key.Point.j + 1), Alignment.Horizontal),\\n            item.Path + 1));\\n        }\\n\\n        if (item.Key.Point.i + 1 < grid.Length &&\\n            item.Key.Point.j + 1 < grid[0].Length &&\\n            grid[item.Key.Point.i + 1][item.Key.Point.j] == 0 &&\\n            grid[item.Key.Point.i + 1][item.Key.Point.j + 1] == 0)\\n        {\\n          ways.Add(new QueueItem(\\n            new Key((item.Key.Point.i + 1, item.Key.Point.j), Alignment.Horizontal),\\n            item.Path + 1));\\n        }\\n      }\\n\\n      // rotate to vertical\\n      if (item.Key.Align == Alignment.Horizontal)\\n      {\\n        if (item.Key.Point.i + 1 < grid.Length &&\\n            grid[item.Key.Point.i + 1][item.Key.Point.j] == 0 &&\\n            grid[item.Key.Point.i + 1][item.Key.Point.j + 1] == 0)\\n        {\\n          ways.Add(new QueueItem(\\n            new Key((item.Key.Point.i, item.Key.Point.j), Alignment.Vertical),\\n            item.Path + 1));\\n        }\\n      }\\n\\n      // rotate to horizontal\\n      if (item.Key.Align == Alignment.Vertical)\\n      {\\n        if (item.Key.Point.j + 1 < grid[0].Length &&\\n            grid[item.Key.Point.i][item.Key.Point.j + 1] == 0 &&\\n            grid[item.Key.Point.i + 1][item.Key.Point.j + 1] == 0)\\n        {\\n          ways.Add(new QueueItem(\\n            new Key((item.Key.Point.i, item.Key.Point.j), Alignment.Horizontal),\\n            item.Path + 1));\\n        }\\n      }\\n\\n      foreach (var way in ways)\\n        queue.Enqueue(way);\\n    }\\n\\n    return -1;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\npublic class Solution\\n{\\n  enum Alignment\\n  {\\n    Vertical,\\n    Horizontal\\n  }\\n\\n  class Key : IEquatable<Key>\\n  {\\n    public (int i, int j) Point { get; }\\n    public Alignment Align { get; }\\n\\n    public Key((int, int) point, Alignment align)\\n    {\\n      Point = point;\\n      Align = align;\\n    }\\n\\n    public override string ToString() => $\"{Point} {Align}\";\\n\\n    public override bool Equals(object obj) => ((Key)obj).Point == Point && ((Key)obj).Align == Align;\\n\\n    public override int GetHashCode() => HashCode.Combine(Point, Align);\\n\\n    public bool Equals(Key other) => other.Point == Point && other.Align == Align;\\n  }\\n\\n  class QueueItem\\n  {\\n    public Key Key { get; }\\n    public int Path { get; }\\n\\n    public QueueItem(Key key, int path)\\n    {\\n      Key = key;\\n      Path = path;\\n    }\\n  }\\n\\n  public int MinimumMoves(int[][] grid)\\n  {\\n    var dp = new Dictionary<Key, int>();\\n\\n    var queue = new Queue<QueueItem>();\\n    queue.Enqueue(new QueueItem(key: new Key((0, 0), Alignment.Horizontal), path: 0));\\n\\n    while (queue.Count > 0)\\n    {\\n      var item = queue.Dequeue();\\n\\n      if (item.Key.Align == Alignment.Horizontal && item.Key.Point == (grid.Length - 1, grid[0].Length - 2))\\n        return item.Path;\\n\\n      if (dp.ContainsKey(item.Key)/* && dp[item.Key] <= item.Path*/)\\n        continue;\\n\\n      dp[item.Key] = item.Path;\\n\\n      var ways = new List<QueueItem>();\\n\\n      // vertical down or right\\n      if (item.Key.Align == Alignment.Vertical)\\n      {\\n        if (item.Key.Point.i + 2 < grid.Length && \\n            grid[item.Key.Point.i + 2][item.Key.Point.j] == 0)\\n        {\\n          ways.Add(new QueueItem(\\n            new Key((item.Key.Point.i + 1, item.Key.Point.j), Alignment.Vertical), \\n            item.Path + 1));\\n        }\\n\\n        if (item.Key.Point.i + 1 < grid.Length && \\n            item.Key.Point.j + 1 < grid[0].Length &&\\n            grid[item.Key.Point.i][item.Key.Point.j + 1] == 0 &&\\n            grid[item.Key.Point.i + 1][item.Key.Point.j + 1] == 0)\\n        {\\n          ways.Add(new QueueItem(\\n            new Key((item.Key.Point.i, item.Key.Point.j + 1), Alignment.Vertical),\\n            item.Path + 1));\\n        }\\n      }\\n\\n      // horizontal down or right\\n      if (item.Key.Align == Alignment.Horizontal)\\n      {\\n        if (item.Key.Point.j + 2 < grid[0].Length &&\\n            grid[item.Key.Point.i][item.Key.Point.j + 2] == 0)\\n        {\\n          ways.Add(new QueueItem(\\n            new Key((item.Key.Point.i, item.Key.Point.j + 1), Alignment.Horizontal),\\n            item.Path + 1));\\n        }\\n\\n        if (item.Key.Point.i + 1 < grid.Length &&\\n            item.Key.Point.j + 1 < grid[0].Length &&\\n            grid[item.Key.Point.i + 1][item.Key.Point.j] == 0 &&\\n            grid[item.Key.Point.i + 1][item.Key.Point.j + 1] == 0)\\n        {\\n          ways.Add(new QueueItem(\\n            new Key((item.Key.Point.i + 1, item.Key.Point.j), Alignment.Horizontal),\\n            item.Path + 1));\\n        }\\n      }\\n\\n      // rotate to vertical\\n      if (item.Key.Align == Alignment.Horizontal)\\n      {\\n        if (item.Key.Point.i + 1 < grid.Length &&\\n            grid[item.Key.Point.i + 1][item.Key.Point.j] == 0 &&\\n            grid[item.Key.Point.i + 1][item.Key.Point.j + 1] == 0)\\n        {\\n          ways.Add(new QueueItem(\\n            new Key((item.Key.Point.i, item.Key.Point.j), Alignment.Vertical),\\n            item.Path + 1));\\n        }\\n      }\\n\\n      // rotate to horizontal\\n      if (item.Key.Align == Alignment.Vertical)\\n      {\\n        if (item.Key.Point.j + 1 < grid[0].Length &&\\n            grid[item.Key.Point.i][item.Key.Point.j + 1] == 0 &&\\n            grid[item.Key.Point.i + 1][item.Key.Point.j + 1] == 0)\\n        {\\n          ways.Add(new QueueItem(\\n            new Key((item.Key.Point.i, item.Key.Point.j), Alignment.Horizontal),\\n            item.Path + 1));\\n        }\\n      }\\n\\n      foreach (var way in ways)\\n        queue.Enqueue(way);\\n    }\\n\\n    return -1;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 937813,
                "title": "c-short-dfs-with-dp-100-time-and-99-mem",
                "content": "When we see a (likely) DP problem, we should think about what is important (quote by Erricto). The important here is the position of the snake, that is: the coordinates of the tail, and the direction. So, the state of the snake on the board can be represent with a triplet `[x,y,z]` with `[x,y]` is coordinates of the tail, and `z =  0` if horizontal and `z = 1` if vertical. When the states are well defined, we can use dfs with memorization to solve the problem easily, as all possible transitions from one state to other states is clearly defined in the description. \\n\\nOne small notes is you should not rotate two times in a row. Use a variable `rotate` to check it.\\n\\n```CPP\\nclass Solution {\\npublic:\\n    int memo[101][101][2] = {};\\n    int INF = 1e9;\\n    int dfs(vector<vector<int>>& grid, int x, int y, int z, int rotate) {\\n        const int n = grid.size();\\n        int nx = z == 0? x : x+1;\\n        int ny = z == 0? y+1 : y;\\n        if (memo[x][y][z] > 0) return memo[x][y][z];\\n        if (x >= n || y >= n || nx >= n || ny >= n) return INF;\\n        if (grid[x][y] == 1 || grid[nx][ny] == 1) return INF;\\n        if (x == n-1 && y == n-2 && z == 0) return 0;\\n        int ret = INF;\\n        // move right\\n        ret = min(ret, dfs(grid, x, y+1, z, 0));\\n        // move down\\n        ret = min(ret, dfs(grid, x+1, y, z, 0));\\n        // rotate //\\n        if (!rotate && x+1 < n && y+1 < n && grid[x+1][y+1] == 0)\\n            ret = min(ret, dfs(grid, x, y, 1^z, 1));\\n        return memo[x][y][z] = ret == INF? INF : 1+ret;\\n    }\\n    int minimumMoves(vector<vector<int>>& grid) {\\n        int x = 0, y = 0, z = 0, rotate = 0;\\n        int ret = dfs(grid,x,y,z,rotate);\\n        return ret == INF? -1 : ret;\\n    }\\n};\\n\\n/*\\nstate of the snake:\\n[x,y,z]\\n(x,y) -> coordinates of tail\\nz: direction\\n*/\\n```",
                "solutionTags": [],
                "code": "```CPP\\nclass Solution {\\npublic:\\n    int memo[101][101][2] = {};\\n    int INF = 1e9;\\n    int dfs(vector<vector<int>>& grid, int x, int y, int z, int rotate) {\\n        const int n = grid.size();\\n        int nx = z == 0? x : x+1;\\n        int ny = z == 0? y+1 : y;\\n        if (memo[x][y][z] > 0) return memo[x][y][z];\\n        if (x >= n || y >= n || nx >= n || ny >= n) return INF;\\n        if (grid[x][y] == 1 || grid[nx][ny] == 1) return INF;\\n        if (x == n-1 && y == n-2 && z == 0) return 0;\\n        int ret = INF;\\n        // move right\\n        ret = min(ret, dfs(grid, x, y+1, z, 0));\\n        // move down\\n        ret = min(ret, dfs(grid, x+1, y, z, 0));\\n        // rotate //\\n        if (!rotate && x+1 < n && y+1 < n && grid[x+1][y+1] == 0)\\n            ret = min(ret, dfs(grid, x, y, 1^z, 1));\\n        return memo[x][y][z] = ret == INF? INF : 1+ret;\\n    }\\n    int minimumMoves(vector<vector<int>>& grid) {\\n        int x = 0, y = 0, z = 0, rotate = 0;\\n        int ret = dfs(grid,x,y,z,rotate);\\n        return ret == INF? -1 : ret;\\n    }\\n};\\n\\n/*\\nstate of the snake:\\n[x,y,z]\\n(x,y) -> coordinates of tail\\nz: direction\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 925213,
                "title": "c-bfs-oo",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumMoves(vector<vector<int>>& grid) {\\n        const int n = grid.size();\\n        const vector<pair<int,int>> dirs = {{0,1}, {0,-1},{1,0},{-1,0}};\\n        auto visited = vector(n, vector(n, vector(2, false)));\\n        queue<pair<State, int>> q;\\n        q.push(pair(State(grid), 0));\\n        visited[0][0][0] = true;\\n        while(!q.empty()){\\n            auto [s, step] = q.front(); q.pop();\\n            for(auto p : s.neighbor()){\\n                if(p.i == n-1 && p.j == n-2) return step+1;\\n                if(visited[p.i][p.j][p.rotate]) continue;\\n                visited[p.i][p.j][p.rotate] = true;\\n                q.push(pair(p, step+1));\\n            }\\n        }\\n        return -1;\\n    }\\n    \\n    struct State{\\n        State(const vector<vector<int>>& grid) : g(grid), n(grid.size()){}\\n        \\n        vector<State> neighbor() const{\\n            static const vector<pair<int,int>> dirs = {{0,1}, {1,0}};\\n            vector<State> res;\\n            for(auto [di, dj]:dirs){\\n                State p = *this;\\n                p.i = i+di, p.j = j+dj;\\n                if(p.isValid()) res.push_back(p);\\n            }\\n            \\n            if(isValidToRotate()){\\n                State r = *this;\\n                r.rotate = !r.rotate;\\n                if(r.isValid()) res.push_back(r);\\n            }           \\n            return res;\\n        }\\n        \\n        bool isValid() const{\\n            int i1 = i, j1 = j+1;\\n            if(rotate) i1 = i+1, j1=j;\\n            return isValid(i, j) && isValid(i1, j1);\\n        }\\n        \\n        bool isValidToRotate() const{\\n            return isValid(i, j) && isValid(i, j+1) && isValid(i+1, j) && isValid(i+1, j+1);\\n        }\\n        \\n        bool isValid(int x, int y) const{\\n            return x>=0 && x<n && y>=0 && y<n && g[x][y] == 0;\\n        }\\n        \\n        const vector<vector<int>>& g;\\n        const int n;\\n        int i = 0;\\n        int j = 0;\\n        bool rotate = false;\\n    };\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int minimumMoves(vector<vector<int>>& grid) {\\n        const int n = grid.size();\\n        const vector<pair<int,int>> dirs = {{0,1}",
                "codeTag": "Java"
            },
            {
                "id": 920081,
                "title": "c-extension-of-normal-bfs-with-inline-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumMoves(vector<vector<int>>& gd) {\\n        int m=gd.size(), n=gd.at(0).size(), lev=0; \\n        // stores postion (x, y) and heading of the snake\\n        // heading: 0: to right, 1: to down\\n        queue<vector<int>> que; \\n        // heading vector of the snake\\n        vector<int> dx_head {0, 1};\\n        vector<int> dy_head {1, 0};   \\n        // direction of one step next motion \\n        vector<int> dx {1, 0};\\n        vector<int> dy {0, 1}; \\n\\n        // initial state \\n        que.push({0, 0, 0});     // (x, y, heading)\\n        \\n        // keep track of the visitd states\\n        bool vis[100][100][2];\\n        memset(vis, false, sizeof(vis));\\n        vis[0][0][0]=true;\\n        \\n        while(!que.empty()){\\n            int sz=que.size();\\n            for(int k=0; k<sz; k++){\\n                auto cur = que.front(); que.pop();\\n                // extract position (x, y) and heading (theta)\\n                int x=cur.at(0), y=cur.at(1), th=cur.at(2);\\n                \\n                // if reached to goal, levels of BFS done up to here \\n                if(x==m-1 && y==n-2 && th==0) return lev;\\n                \\n                for(int i=0; i<2; i++){\\n                    // compute next snake tail position\\n                    // if it is outside of the grid or collides with an obstacle, do not add to queue\\n                    int xn=x+dx.at(i);\\n                    int yn=y+dy.at(i);\\n                    if(xn<0 || yn<0 || m-1<xn || n-1<yn || gd.at(xn).at(yn)==1) continue;\\n                    \\n                    // compute next snake head position and do the same evaluation \\n                    int xnh = xn+dx_head.at(th);\\n                    int ynh = yn+dy_head.at(th); \\n                    if(xnh<0 || ynh<0 || m-1<xnh || n-1<ynh ||  gd.at(xnh).at(ynh)==1) continue;\\n                    \\n                    // if the state position and heading of the snake in grid is already added to queue, do not proceed\\n                    if(vis[xn][yn][th]) continue; \\n                    vis[xn][yn][th]=true;\\n                    que.push({xn, yn, th}); \\n                }\\n                \\n                // if rotation is feasible, rotate the snake and add to queue \\n                if( m-1<x+1 || n-1<y+1 ||\\n                   gd.at(x+1).at(y+1)==1 || gd.at(x+1).at(y)==1 || gd.at(x).at(y+1)==1) continue;\\n                int thn = th==1 ? 0 : 1;\\n                if(vis[x][y][thn]) continue; \\n                vis[x][y][thn]=true; \\n                que.push({x, y, thn});\\n            }\\n            lev++; \\n        }\\n        return -1; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumMoves(vector<vector<int>>& gd) {\\n        int m=gd.size(), n=gd.at(0).size(), lev=0; \\n        // stores postion (x, y) and heading of the snake\\n        // heading: 0: to right, 1: to down\\n        queue<vector<int>> que; \\n        // heading vector of the snake\\n        vector<int> dx_head {0, 1};\\n        vector<int> dy_head {1, 0};   \\n        // direction of one step next motion \\n        vector<int> dx {1, 0};\\n        vector<int> dy {0, 1}; \\n\\n        // initial state \\n        que.push({0, 0, 0});     // (x, y, heading)\\n        \\n        // keep track of the visitd states\\n        bool vis[100][100][2];\\n        memset(vis, false, sizeof(vis));\\n        vis[0][0][0]=true;\\n        \\n        while(!que.empty()){\\n            int sz=que.size();\\n            for(int k=0; k<sz; k++){\\n                auto cur = que.front(); que.pop();\\n                // extract position (x, y) and heading (theta)\\n                int x=cur.at(0), y=cur.at(1), th=cur.at(2);\\n                \\n                // if reached to goal, levels of BFS done up to here \\n                if(x==m-1 && y==n-2 && th==0) return lev;\\n                \\n                for(int i=0; i<2; i++){\\n                    // compute next snake tail position\\n                    // if it is outside of the grid or collides with an obstacle, do not add to queue\\n                    int xn=x+dx.at(i);\\n                    int yn=y+dy.at(i);\\n                    if(xn<0 || yn<0 || m-1<xn || n-1<yn || gd.at(xn).at(yn)==1) continue;\\n                    \\n                    // compute next snake head position and do the same evaluation \\n                    int xnh = xn+dx_head.at(th);\\n                    int ynh = yn+dy_head.at(th); \\n                    if(xnh<0 || ynh<0 || m-1<xnh || n-1<ynh ||  gd.at(xnh).at(ynh)==1) continue;\\n                    \\n                    // if the state position and heading of the snake in grid is already added to queue, do not proceed\\n                    if(vis[xn][yn][th]) continue; \\n                    vis[xn][yn][th]=true;\\n                    que.push({xn, yn, th}); \\n                }\\n                \\n                // if rotation is feasible, rotate the snake and add to queue \\n                if( m-1<x+1 || n-1<y+1 ||\\n                   gd.at(x+1).at(y+1)==1 || gd.at(x+1).at(y)==1 || gd.at(x).at(y+1)==1) continue;\\n                int thn = th==1 ? 0 : 1;\\n                if(vis[x][y][thn]) continue; \\n                vis[x][y][thn]=true; \\n                que.push({x, y, thn});\\n            }\\n            lev++; \\n        }\\n        return -1; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 884020,
                "title": "python-3-clean-bfs-beat-100",
                "content": "```\\nclass Solution:\\n    def minimumMoves(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n        end = (n-1, n-2, n-1, n-1)\\n        start = (0, 0, 0, 1)\\n        queue = [start]\\n        visited = set()\\n        count = 0\\n        while queue:\\n            newQueue = []\\n            for pos in queue:\\n                if pos in visited:\\n                    continue\\n                if pos == end:\\n                    return count\\n                visited.add(pos)\\n                x1, y1, x2, y2 = pos\\n                if x1 == x2:\\n                    #horizontal\\n                    if y2+1 < n and grid[x2][y2+1] == 0:\\n                        #right\\n                        newQueue.append((x1, y1+1, x2, y2+1))\\n                    if x1+1< n and grid[x1+1][y1] == 0 and grid[x2+1][y2] == 0:\\n                        #down\\n                        newQueue.append((x1+1, y1, x2+1, y2))\\n                        #rotate\\n                        newQueue.append((x1,y1, x2+1, y2-1))\\n                elif y1 == y2:\\n                    #vertical\\n                    if x2+1 < n and grid[x2+1][y2] == 0:\\n                        #down\\n                        newQueue.append((x1+1, y1, x2+1, y2))\\n                    if y1+1< n and grid[x1][y1+1] == 0 and grid[x2][y2+1] == 0:\\n                        #right\\n                        newQueue.append((x1, y1+1, x2, y2+1))\\n                        #rotate\\n                        newQueue.append((x1,y1, x2-1, y2+1))\\n                        \\n            count += 1\\n            queue = newQueue\\n        return -1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumMoves(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n        end = (n-1, n-2, n-1, n-1)\\n        start = (0, 0, 0, 1)\\n        queue = [start]\\n        visited = set()\\n        count = 0\\n        while queue:\\n            newQueue = []\\n            for pos in queue:\\n                if pos in visited:\\n                    continue\\n                if pos == end:\\n                    return count\\n                visited.add(pos)\\n                x1, y1, x2, y2 = pos\\n                if x1 == x2:\\n                    #horizontal\\n                    if y2+1 < n and grid[x2][y2+1] == 0:\\n                        #right\\n                        newQueue.append((x1, y1+1, x2, y2+1))\\n                    if x1+1< n and grid[x1+1][y1] == 0 and grid[x2+1][y2] == 0:\\n                        #down\\n                        newQueue.append((x1+1, y1, x2+1, y2))\\n                        #rotate\\n                        newQueue.append((x1,y1, x2+1, y2-1))\\n                elif y1 == y2:\\n                    #vertical\\n                    if x2+1 < n and grid[x2+1][y2] == 0:\\n                        #down\\n                        newQueue.append((x1+1, y1, x2+1, y2))\\n                    if y1+1< n and grid[x1][y1+1] == 0 and grid[x2][y2+1] == 0:\\n                        #right\\n                        newQueue.append((x1, y1+1, x2, y2+1))\\n                        #rotate\\n                        newQueue.append((x1,y1, x2-1, y2+1))\\n                        \\n            count += 1\\n            queue = newQueue\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 865399,
                "title": "rust",
                "content": "The idea is a simple bfs. A node is defined as the position of the snake\\'s tail and the direction of the head, in reference to the tail.\\n\\nWe then do a simple bfs with the given start and end nodes.\\n\\nI think this code is pretty idiomatic. Please add a comment if you think anything can be improved.\\n\\n```\\nuse std::collections::*;\\n\\n/// Indicates whether or not a spot in the grid is a wall.\\ntype IsWall = bool;\\n\\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\\npub struct Pos {\\n    i: usize,\\n    j: usize,\\n}\\n\\nimpl Pos {\\n    pub fn new(i: usize, j: usize) -> Pos {\\n        Pos { i, j }\\n    }\\n\\n    fn in_dir(&self, dir: HeadDir) -> Pos {\\n        match dir {\\n            HeadDir::Down => Pos::new(self.i + 1, self.j),\\n            HeadDir::Right => Pos::new(self.i, self.j + 1),\\n        }\\n    }\\n}\\n\\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\\npub enum HeadDir {\\n    Down,\\n    Right,\\n}\\n\\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\\npub struct Snake {\\n    /// The position of the snake\\'s tail.\\n    tail: Pos,\\n    /// Where the head is pointing, relative to the tail.\\n    /// E.g. if tail is at `Pos {i:0, j:0}` and head_dir is `Right`, then the head is at `Pos {i: 0, j: 1}`.\\n    head_dir: HeadDir,\\n}\\n\\nimpl Snake {\\n    pub fn new(tail: Pos, head_dir: HeadDir) -> Snake {\\n        Snake { tail, head_dir }\\n    }\\n}\\n\\nfn adj_nodes(node: Snake, grid: &Vec<Vec<IsWall>>) -> Vec<Snake> {\\n    /// Returns true if the given `pos` can be walked over on the given `grid.\\n    fn walkable(pos: Pos, grid: &Vec<Vec<IsWall>>) -> bool {\\n        pos.i < grid.len() && pos.j < grid[pos.i].len() && !grid[pos.i][pos.j]\\n    }\\n\\n    let mut adjs = Vec::with_capacity(3);\\n\\n    // Move right.\\n    adjs.push(Snake::new(node.tail.in_dir(HeadDir::Right), node.head_dir));\\n    // Move down.\\n    adjs.push(Snake::new(node.tail.in_dir(HeadDir::Down), node.head_dir));\\n\\n    // Rotate clockwise / counter-clockwise.\\n    let rotate = match node.head_dir {\\n        HeadDir::Right => Snake::new(node.tail, HeadDir::Down),\\n        HeadDir::Down => Snake::new(node.tail, HeadDir::Right),\\n    };\\n    let corner_pos = node.tail.in_dir(HeadDir::Right).in_dir(HeadDir::Down);\\n    if walkable(corner_pos, grid) {\\n        adjs.push(rotate);\\n    }\\n\\n    adjs.into_iter()\\n        .filter(|snake| {\\n            walkable(snake.tail, grid) && walkable(snake.tail.in_dir(snake.head_dir), grid)\\n        })\\n        .collect()\\n}\\n\\nfn _minimum_moves(start: Snake, end: Snake, grid: Vec<Vec<IsWall>>) -> Option<usize> {\\n    let mut q = VecDeque::new();\\n    q.push_back((start, 0));\\n    let mut in_q = HashSet::new();\\n    in_q.insert(start);\\n\\n    while let Some((node, dist)) = q.pop_front() {\\n        // println!(\"{:?} {:?} {:?}\", node, dist, q.len());\\n        if node == end {\\n            return Some(dist);\\n        }\\n\\n        for adj_node in adj_nodes(node, &grid) {\\n            if in_q.insert(adj_node) {\\n                q.push_back((adj_node, dist + 1));\\n            }\\n        }\\n    }\\n\\n    None\\n}\\n\\nfn minimum_moves(grid: Vec<Vec<i32>>) -> i32 {\\n    let grid: Vec<Vec<IsWall>> = grid\\n        .into_iter()\\n        .map(|row| row.into_iter().map(|val| val == 1).collect())\\n        .collect();\\n    let start = Snake::new(Pos::new(0, 0), HeadDir::Right);\\n    let end = Snake::new(Pos::new(grid.len() - 1, grid.len() - 2), HeadDir::Right);\\n    _minimum_moves(start, end, grid)\\n        .map(|x| x as i32)\\n        .unwrap_or(-1)\\n}\\n\\n#[cfg(test)]\\nmod test {\\n    use super::*;\\n\\n    #[test]\\n    fn test_snake_in_a_grid_1() {\\n        let grid = vec![\\n            vec![0, 0, 0, 0, 0, 1],\\n            vec![1, 1, 0, 0, 1, 0],\\n            vec![0, 0, 0, 0, 1, 1],\\n            vec![0, 0, 1, 0, 1, 0],\\n            vec![0, 1, 1, 0, 0, 0],\\n            vec![0, 1, 1, 0, 0, 0],\\n        ];\\n        assert_eq!(minimum_moves(grid), 11);\\n    }\\n\\n    #[test]\\n    fn test_snake_in_a_grid_2() {\\n        let grid = vec![\\n            vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0],\\n            vec![1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0],\\n            vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],\\n            vec![0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0],\\n            vec![0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0],\\n            vec![0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0],\\n            vec![0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0],\\n            vec![0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1],\\n            vec![0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1],\\n            vec![0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0],\\n            vec![0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0],\\n            vec![0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 0, 0],\\n            vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0],\\n            vec![0, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0],\\n            vec![0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0],\\n        ];\\n        assert_eq!(minimum_moves(grid), -1);\\n    }\\n}\\n\\n\\nimpl Solution {\\n    pub fn minimum_moves(grid: Vec<Vec<i32>>) -> i32 {\\n        minimum_moves(grid)\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nuse std::collections::*;\\n\\n/// Indicates whether or not a spot in the grid is a wall.\\ntype IsWall = bool;\\n\\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\\npub struct Pos {\\n    i: usize,\\n    j: usize,\\n}\\n\\nimpl Pos {\\n    pub fn new(i: usize, j: usize) -> Pos {\\n        Pos { i, j }\\n    }\\n\\n    fn in_dir(&self, dir: HeadDir) -> Pos {\\n        match dir {\\n            HeadDir::Down => Pos::new(self.i + 1, self.j),\\n            HeadDir::Right => Pos::new(self.i, self.j + 1),\\n        }\\n    }\\n}\\n\\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\\npub enum HeadDir {\\n    Down,\\n    Right,\\n}\\n\\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\\npub struct Snake {\\n    /// The position of the snake\\'s tail.\\n    tail: Pos,\\n    /// Where the head is pointing, relative to the tail.\\n    /// E.g. if tail is at `Pos {i:0, j:0}` and head_dir is `Right`, then the head is at `Pos {i: 0, j: 1}`.\\n    head_dir: HeadDir,\\n}\\n\\nimpl Snake {\\n    pub fn new(tail: Pos, head_dir: HeadDir) -> Snake {\\n        Snake { tail, head_dir }\\n    }\\n}\\n\\nfn adj_nodes(node: Snake, grid: &Vec<Vec<IsWall>>) -> Vec<Snake> {\\n    /// Returns true if the given `pos` can be walked over on the given `grid.\\n    fn walkable(pos: Pos, grid: &Vec<Vec<IsWall>>) -> bool {\\n        pos.i < grid.len() && pos.j < grid[pos.i].len() && !grid[pos.i][pos.j]\\n    }\\n\\n    let mut adjs = Vec::with_capacity(3);\\n\\n    // Move right.\\n    adjs.push(Snake::new(node.tail.in_dir(HeadDir::Right), node.head_dir));\\n    // Move down.\\n    adjs.push(Snake::new(node.tail.in_dir(HeadDir::Down), node.head_dir));\\n\\n    // Rotate clockwise / counter-clockwise.\\n    let rotate = match node.head_dir {\\n        HeadDir::Right => Snake::new(node.tail, HeadDir::Down),\\n        HeadDir::Down => Snake::new(node.tail, HeadDir::Right),\\n    };\\n    let corner_pos = node.tail.in_dir(HeadDir::Right).in_dir(HeadDir::Down);\\n    if walkable(corner_pos, grid) {\\n        adjs.push(rotate);\\n    }\\n\\n    adjs.into_iter()\\n        .filter(|snake| {\\n            walkable(snake.tail, grid) && walkable(snake.tail.in_dir(snake.head_dir), grid)\\n        })\\n        .collect()\\n}\\n\\nfn _minimum_moves(start: Snake, end: Snake, grid: Vec<Vec<IsWall>>) -> Option<usize> {\\n    let mut q = VecDeque::new();\\n    q.push_back((start, 0));\\n    let mut in_q = HashSet::new();\\n    in_q.insert(start);\\n\\n    while let Some((node, dist)) = q.pop_front() {\\n        // println!(\"{:?} {:?} {:?}\", node, dist, q.len());\\n        if node == end {\\n            return Some(dist);\\n        }\\n\\n        for adj_node in adj_nodes(node, &grid) {\\n            if in_q.insert(adj_node) {\\n                q.push_back((adj_node, dist + 1));\\n            }\\n        }\\n    }\\n\\n    None\\n}\\n\\nfn minimum_moves(grid: Vec<Vec<i32>>) -> i32 {\\n    let grid: Vec<Vec<IsWall>> = grid\\n        .into_iter()\\n        .map(|row| row.into_iter().map(|val| val == 1).collect())\\n        .collect();\\n    let start = Snake::new(Pos::new(0, 0), HeadDir::Right);\\n    let end = Snake::new(Pos::new(grid.len() - 1, grid.len() - 2), HeadDir::Right);\\n    _minimum_moves(start, end, grid)\\n        .map(|x| x as i32)\\n        .unwrap_or(-1)\\n}\\n\\n#[cfg(test)]\\nmod test {\\n    use super::*;\\n\\n    #[test]\\n    fn test_snake_in_a_grid_1() {\\n        let grid = vec![\\n            vec![0, 0, 0, 0, 0, 1],\\n            vec![1, 1, 0, 0, 1, 0],\\n            vec![0, 0, 0, 0, 1, 1],\\n            vec![0, 0, 1, 0, 1, 0],\\n            vec![0, 1, 1, 0, 0, 0],\\n            vec![0, 1, 1, 0, 0, 0],\\n        ];\\n        assert_eq!(minimum_moves(grid), 11);\\n    }\\n\\n    #[test]\\n    fn test_snake_in_a_grid_2() {\\n        let grid = vec![\\n            vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0],\\n            vec![1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0],\\n            vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],\\n            vec![0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0],\\n            vec![0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0],\\n            vec![0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0],\\n            vec![0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0],\\n            vec![0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1],\\n            vec![0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1],\\n            vec![0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0],\\n            vec![0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0],\\n            vec![0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 0, 0],\\n            vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0],\\n            vec![0, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0],\\n            vec![0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0],\\n        ];\\n        assert_eq!(minimum_moves(grid), -1);\\n    }\\n}\\n\\n\\nimpl Solution {\\n    pub fn minimum_moves(grid: Vec<Vec<i32>>) -> i32 {\\n        minimum_moves(grid)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 845782,
                "title": "javascript-solution-modularized",
                "content": "```\\nconst canGoRight = (grid, snakeTail) => {\\n  if (snakeTail[2] === \\'horizontal\\') { \\n    const snakeHead = [snakeTail[0], snakeTail[1] + 1];\\n    return (grid[snakeHead[0]][snakeHead[1] + 1] === 0);\\n  } else {\\n    const snakeHead = [snakeTail[0] + 1, snakeTail[1]];\\n    return (grid[snakeTail[0]][snakeTail[1] + 1] === 0 && grid[snakeHead[0]][snakeHead[1] + 1] === 0);\\n  }\\n}\\nconst canGoDown = (grid, snakeTail) => {\\n  if (snakeTail[2] === \\'horizontal\\') {\\n    const snakeHead = [snakeTail[0], snakeTail[1] + 1];\\n    return (snakeTail[0] < grid.length - 1 && grid[snakeTail[0] + 1][snakeTail[1]] === 0 && grid[snakeHead[0] + 1][snakeHead[1]] === 0);\\n  } else {\\n    const snakeHead = [snakeTail[0] + 1, snakeTail[1]];\\n    return (snakeHead[0] < grid.length - 1 && grid[snakeHead[0] + 1][snakeHead[1]] === 0\\n    );\\n  }\\n}\\nconst canRotateClockwise = (grid, snakeTail) => {\\n  if (snakeTail[2] === \\'horizontal\\') {\\n    const snakeHead = [snakeTail[0], snakeTail[1] + 1];\\n    return (snakeTail[0] < grid.length - 1 && grid[snakeTail[0] + 1][snakeTail[1]] === 0 && grid[snakeHead[0] + 1][snakeHead[1]] === 0);\\n  } else { return false; }\\n}\\nconst canRotateCounterClockwise = (grid, snakeTail) => {\\n  if (snakeTail[2] === \\'vertical\\') {\\n    const snakeHead = [snakeTail[0] + 1, snakeTail[1]];\\n    return (grid[snakeTail[0]][snakeTail[1] + 1] === 0 && grid[snakeHead[0]][snakeHead[1] + 1] === 0);\\n  } else { return false; }\\n}\\nconst minimumMoves = (grid) => {\\n  const visitedLocations = [];\\n  const choices = {\\n    current: [], \\n    next: []\\n  };\\n  choices.current.push([0, 0, \\'horizontal\\']);\\n  let totalMoves = 0;\\n  while (choices.current.length) {\\n    choices.next = [];\\n    for (let i = 0; i < choices.current.length; i++) {\\n      let ithChoiceAsPrimitive = JSON.stringify(choices.current[i]);\\n      if (!visitedLocations.includes(ithChoiceAsPrimitive)) {\\n        visitedLocations.push(ithChoiceAsPrimitive);\\n        let snakeTail = choices.current[i];\\n        if (snakeTail[0] === grid.length - 1 && snakeTail[1] === grid.length - 2 && snakeTail[2] === \\'horizontal\\') { return totalMoves; }\\n        if (canGoRight(grid, snakeTail)) { choices.next.push([snakeTail[0], snakeTail[1] + 1, snakeTail[2]]); }\\n        if (canGoDown(grid, snakeTail)) { choices.next.push([snakeTail[0] + 1, snakeTail[1], snakeTail[2]]); }\\n        if (canRotateClockwise(grid, snakeTail)) { choices.next.push([snakeTail[0], snakeTail[1], \\'vertical\\']); }\\n        if (canRotateCounterClockwise(grid, snakeTail)) { choices.next.push([snakeTail[0], snakeTail[1], \\'horizontal\\']); }\\n      }\\n    }\\n    totalMoves++;\\n    choices.current = choices.next;\\n  }\\n  return -1;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nconst canGoRight = (grid, snakeTail) => {\\n  if (snakeTail[2] === \\'horizontal\\') { \\n    const snakeHead = [snakeTail[0], snakeTail[1] + 1];\\n    return (grid[snakeHead[0]][snakeHead[1] + 1] === 0);\\n  } else {\\n    const snakeHead = [snakeTail[0] + 1, snakeTail[1]];\\n    return (grid[snakeTail[0]][snakeTail[1] + 1] === 0 && grid[snakeHead[0]][snakeHead[1] + 1] === 0);\\n  }\\n}\\nconst canGoDown = (grid, snakeTail) => {\\n  if (snakeTail[2] === \\'horizontal\\') {\\n    const snakeHead = [snakeTail[0], snakeTail[1] + 1];\\n    return (snakeTail[0] < grid.length - 1 && grid[snakeTail[0] + 1][snakeTail[1]] === 0 && grid[snakeHead[0] + 1][snakeHead[1]] === 0);\\n  } else {\\n    const snakeHead = [snakeTail[0] + 1, snakeTail[1]];\\n    return (snakeHead[0] < grid.length - 1 && grid[snakeHead[0] + 1][snakeHead[1]] === 0\\n    );\\n  }\\n}\\nconst canRotateClockwise = (grid, snakeTail) => {\\n  if (snakeTail[2] === \\'horizontal\\') {\\n    const snakeHead = [snakeTail[0], snakeTail[1] + 1];\\n    return (snakeTail[0] < grid.length - 1 && grid[snakeTail[0] + 1][snakeTail[1]] === 0 && grid[snakeHead[0] + 1][snakeHead[1]] === 0);\\n  } else { return false; }\\n}\\nconst canRotateCounterClockwise = (grid, snakeTail) => {\\n  if (snakeTail[2] === \\'vertical\\') {\\n    const snakeHead = [snakeTail[0] + 1, snakeTail[1]];\\n    return (grid[snakeTail[0]][snakeTail[1] + 1] === 0 && grid[snakeHead[0]][snakeHead[1] + 1] === 0);\\n  } else { return false; }\\n}\\nconst minimumMoves = (grid) => {\\n  const visitedLocations = [];\\n  const choices = {\\n    current: [], \\n    next: []\\n  };\\n  choices.current.push([0, 0, \\'horizontal\\']);\\n  let totalMoves = 0;\\n  while (choices.current.length) {\\n    choices.next = [];\\n    for (let i = 0; i < choices.current.length; i++) {\\n      let ithChoiceAsPrimitive = JSON.stringify(choices.current[i]);\\n      if (!visitedLocations.includes(ithChoiceAsPrimitive)) {\\n        visitedLocations.push(ithChoiceAsPrimitive);\\n        let snakeTail = choices.current[i];\\n        if (snakeTail[0] === grid.length - 1 && snakeTail[1] === grid.length - 2 && snakeTail[2] === \\'horizontal\\') { return totalMoves; }\\n        if (canGoRight(grid, snakeTail)) { choices.next.push([snakeTail[0], snakeTail[1] + 1, snakeTail[2]]); }\\n        if (canGoDown(grid, snakeTail)) { choices.next.push([snakeTail[0] + 1, snakeTail[1], snakeTail[2]]); }\\n        if (canRotateClockwise(grid, snakeTail)) { choices.next.push([snakeTail[0], snakeTail[1], \\'vertical\\']); }\\n        if (canRotateCounterClockwise(grid, snakeTail)) { choices.next.push([snakeTail[0], snakeTail[1], \\'horizontal\\']); }\\n      }\\n    }\\n    totalMoves++;\\n    choices.current = choices.next;\\n  }\\n  return -1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 799557,
                "title": "java-dfs-memo-3ms-long-code-but-easy-to-understand",
                "content": "Use two n * n matrix to track minimum steps from i, j to end when the snake is either vertical or horizontal. Both scenario check whether it can move right, move left or rotate and do dfs accordingly, and calculate minimum steps in dp. Doing backtracking in place. grid[i][j] = -1 means have been here in horizonal direction, grid[i][j] = -2 is vertical and grid[i][j] = -3 is both.\\n\\nIt would be a simpler question if it only asks whether the snake can reach the end, which doesn\\'t require memorization at all. But since it asks for the min steps, it becomes a backtracking problem.\\n\\n```\\nclass Solution {\\n    public int minimumMoves(int[][] grid) {\\n        int n = grid.length;\\n        int[][] dp1 = new int[n][n];\\n        int[][] dp2 = new int[n][n];\\n        for(int i=0;i<n;i++){\\n            Arrays.fill(dp1[i], -2);\\n            Arrays.fill(dp2[i], -2);\\n        }\\n        return dfs(grid, n, 0, 0, -1, dp1, dp2);\\n    }\\n    \\n    private int dfs(int[][] grid, int n, int i, int j, int direction, int[][] dp1, int[][] dp2){\\n        int res = Integer.MAX_VALUE;\\n        if(direction == -1){  // horizontal\\n            if(i == n - 1 && j == n - 2)  // reach target\\n                return 0;\\n            if(dp1[i][j] != -2)\\n                return dp1[i][j];\\n            if(j + 2 < n && grid[i][j+2] != 1 && grid[i][j+1] != -1 && grid[i][j+1] != -3){  // move right\\n                grid[i][j+1] -= 1;\\n                int temp = dfs(grid, n, i, j+1, -1, dp1, dp2);\\n                if(temp != -1)\\n                    res = Math.min(res, temp + 1);\\n                grid[i][j+1] += 1;\\n            }\\n            if(i < n - 1 && grid[i+1][j] != 1 && grid[i+1][j+1] != 1){\\n                if(grid[i+1][j] != -1 && grid[i+1][j] != -3){  // move down\\n                    grid[i+1][j] -= 1;\\n                    int temp = dfs(grid, n, i+1, j, -1, dp1, dp2);\\n                    if(temp != -1)\\n                        res = Math.min(res, temp + 1);\\n                    grid[i+1][j] += 1;\\n                }\\n                if(grid[i][j] != -2 && grid[i][j] != -3){  // rotate\\n                    grid[i][j] -= 2;\\n                    int temp = dfs(grid, n, i, j, -2, dp1, dp2);\\n                    if(temp != -1)\\n                        res = Math.min(res, temp + 1);\\n                    grid[i][j] += 2;\\n                }\\n            }\\n        } else {  // vertical\\n            if(dp2[i][j] != -2)\\n                return dp2[i][j];\\n            if(i + 2 < n && grid[i+2][j] != 1 && grid[i+1][j] != -2 && grid[i+1][j] != -3){ // move down\\n                grid[i+1][j] -= 2;\\n                int temp = dfs(grid, n, i+1, j, -2, dp1, dp2);\\n                if(temp != -1)\\n                    res = Math.min(res, temp + 1);\\n                grid[i+1][j] += 2;\\n            }\\n            if(j < n - 1 && grid[i][j+1] != 1 && grid[i+1][j+1] != 1){\\n                if(grid[i][j+1] != -2 && grid[i][j+1] != -3){  // move right\\n                    grid[i][j+1] -= 2;\\n                    int temp = dfs(grid, n, i, j+1, -2, dp1, dp2);\\n                    if(temp != -1)\\n                        res = Math.min(res, temp + 1);\\n                    grid[i][j+1] += 2;\\n                }\\n                if(grid[i][j] != -1 && grid[i][j] != -3){  // rotate\\n                    grid[i][j] -= 1;\\n                    int temp = dfs(grid, n, i, j, -1, dp1, dp2);\\n                    if(temp != -1)\\n                        res = Math.min(res, temp + 1);\\n                    grid[i][j] += 1;\\n                }\\n            }\\n        }\\n        res = res == Integer.MAX_VALUE ? -1 : res;\\n        if(direction == -1)\\n            dp1[i][j] = res;\\n        else\\n            dp2[i][j] = res;\\n        return res;\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minimumMoves(int[][] grid) {\\n        int n = grid.length;\\n        int[][] dp1 = new int[n][n];\\n        int[][] dp2 = new int[n][n];\\n        for(int i=0;i<n;i++){\\n            Arrays.fill(dp1[i], -2);\\n            Arrays.fill(dp2[i], -2);\\n        }\\n        return dfs(grid, n, 0, 0, -1, dp1, dp2);\\n    }\\n    \\n    private int dfs(int[][] grid, int n, int i, int j, int direction, int[][] dp1, int[][] dp2){\\n        int res = Integer.MAX_VALUE;\\n        if(direction == -1){  // horizontal\\n            if(i == n - 1 && j == n - 2)  // reach target\\n                return 0;\\n            if(dp1[i][j] != -2)\\n                return dp1[i][j];\\n            if(j + 2 < n && grid[i][j+2] != 1 && grid[i][j+1] != -1 && grid[i][j+1] != -3){  // move right\\n                grid[i][j+1] -= 1;\\n                int temp = dfs(grid, n, i, j+1, -1, dp1, dp2);\\n                if(temp != -1)\\n                    res = Math.min(res, temp + 1);\\n                grid[i][j+1] += 1;\\n            }\\n            if(i < n - 1 && grid[i+1][j] != 1 && grid[i+1][j+1] != 1){\\n                if(grid[i+1][j] != -1 && grid[i+1][j] != -3){  // move down\\n                    grid[i+1][j] -= 1;\\n                    int temp = dfs(grid, n, i+1, j, -1, dp1, dp2);\\n                    if(temp != -1)\\n                        res = Math.min(res, temp + 1);\\n                    grid[i+1][j] += 1;\\n                }\\n                if(grid[i][j] != -2 && grid[i][j] != -3){  // rotate\\n                    grid[i][j] -= 2;\\n                    int temp = dfs(grid, n, i, j, -2, dp1, dp2);\\n                    if(temp != -1)\\n                        res = Math.min(res, temp + 1);\\n                    grid[i][j] += 2;\\n                }\\n            }\\n        } else {  // vertical\\n            if(dp2[i][j] != -2)\\n                return dp2[i][j];\\n            if(i + 2 < n && grid[i+2][j] != 1 && grid[i+1][j] != -2 && grid[i+1][j] != -3){ // move down\\n                grid[i+1][j] -= 2;\\n                int temp = dfs(grid, n, i+1, j, -2, dp1, dp2);\\n                if(temp != -1)\\n                    res = Math.min(res, temp + 1);\\n                grid[i+1][j] += 2;\\n            }\\n            if(j < n - 1 && grid[i][j+1] != 1 && grid[i+1][j+1] != 1){\\n                if(grid[i][j+1] != -2 && grid[i][j+1] != -3){  // move right\\n                    grid[i][j+1] -= 2;\\n                    int temp = dfs(grid, n, i, j+1, -2, dp1, dp2);\\n                    if(temp != -1)\\n                        res = Math.min(res, temp + 1);\\n                    grid[i][j+1] += 2;\\n                }\\n                if(grid[i][j] != -1 && grid[i][j] != -3){  // rotate\\n                    grid[i][j] -= 1;\\n                    int temp = dfs(grid, n, i, j, -1, dp1, dp2);\\n                    if(temp != -1)\\n                        res = Math.min(res, temp + 1);\\n                    grid[i][j] += 1;\\n                }\\n            }\\n        }\\n        res = res == Integer.MAX_VALUE ? -1 : res;\\n        if(direction == -1)\\n            dp1[i][j] = res;\\n        else\\n            dp2[i][j] = res;\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 792222,
                "title": "java-bfs-solution-with-3-dimentional-visited-array",
                "content": "1. declare two constants `VERTICAL` and `HORIZONTAL` with values 0 and 1.\\n2. queue will take an int array, (x,y,direction)\\n3. according to the direction, we will have 6 types of actions:\\n\\t\\tfor HORIZONTAL:\\n\\t\\t\\t\\t- go HORIZONTAL next\\n\\t\\t\\t\\t- go VERTICAL next\\n\\t\\t\\t\\t- rotate clockwise\\n\\t\\tfor VERTICAL:\\n\\t\\t\\t\\t- go HORIZONTAL next\\n\\t\\t\\t\\t- go VERTICAL next\\n\\t\\t\\t\\t- rotate counterclockwise\\n4. the end condition is, direction == HORIZONTAL and we are in bottom-right cell.\\n```\\nclass Solution {\\n    private static final int VERTICAL = 0;\\n    private static final int HORIZONTAL = 1;\\n\\n    public int minimumMoves(int[][] grid) {\\n        final Queue<int[]> queue = new LinkedList<>();\\n        final boolean[][][] visited =\\n                new boolean[grid.length][grid[0].length][2];\\n        queue.offer(new int[]{0, 1, HORIZONTAL});\\n        visited[0][1][HORIZONTAL] = true;\\n        int level = 0;\\n        while (!queue.isEmpty()) {\\n            final int currentSize = queue.size();\\n            for (int size = 0; size < currentSize; size++) {\\n                final int[] current = queue.poll();\\n                if (current[0] == grid.length - 1 &&\\n                        current[1] == grid[0].length - 1 &&\\n                        current[2] == HORIZONTAL\\n                ) {\\n                    return level;\\n                }\\n                if (current[2] == HORIZONTAL) {\\n                    // go horizon next\\n                    final int nextX = current[0];\\n                    final int nextY = current[1] + 1;\\n                    if (inBound(grid, nextX, nextY) &&\\n                            !visited[nextX][nextY][HORIZONTAL] &&\\n                            grid[nextX][nextY] == 0\\n                    ) {\\n                        queue.offer(new int[]{nextX, nextY, HORIZONTAL});\\n                        visited[nextX][nextY][HORIZONTAL] = true;\\n                    }\\n                    // go VERTICAL next\\n                    final int nextX2 = current[0] + 1;\\n                    final int nextY2 = current[1];\\n                    if (inBound(grid, nextX2, nextY2) &&\\n                            !visited[nextX2][nextY2][HORIZONTAL] &&\\n                            grid[nextX2][nextY2 - 1] == 0 &&\\n                            grid[nextX2][nextY2] == 0\\n                    ) {\\n                        queue.offer(new int[]{nextX2, nextY2, HORIZONTAL});\\n                        visited[nextX2][nextY2][HORIZONTAL] = true;\\n                    }\\n                    // rotate clockwise\\n                    final int nextX3 = current[0] + 1;\\n                    final int nextY3 = current[1] - 1;\\n                    if (inBound(grid, nextX3, nextY3) &&\\n                            !visited[nextX3][nextY3][VERTICAL] &&\\n                            grid[nextX3][nextY3 + 1] == 0 &&\\n                            grid[nextX3][nextY3] == 0\\n                    ) {\\n                        queue.offer(new int[]{nextX3, nextY3, VERTICAL});\\n                        visited[nextX3][nextY3][VERTICAL] = true;\\n                    }\\n                } else {\\n                    // go horizon next\\n                    final int nextX = current[0];\\n                    final int nextY = current[1] + 1;\\n                    if (inBound(grid, nextX, nextY) &&\\n                            !visited[nextX][nextY][VERTICAL] &&\\n                            grid[nextX - 1][nextY] == 0 &&\\n                            grid[nextX][nextY] == 0\\n                    ) {\\n                        queue.offer(new int[]{nextX, nextY, VERTICAL});\\n                        visited[nextX][nextY][VERTICAL] = true;\\n                    }\\n                    // go VERTICAL next\\n                    final int nextX2 = current[0] + 1;\\n                    final int nextY2 = current[1];\\n                    if (inBound(grid, nextX2, nextY2) &&\\n                            !visited[nextX2][nextY2][VERTICAL] &&\\n                            grid[nextX2][nextY2] == 0\\n                    ) {\\n                        queue.offer(new int[]{nextX2, nextY2, VERTICAL});\\n                        visited[nextX2][nextY2][VERTICAL] = true;\\n                    }\\n                    // rotate counterclockwise\\n                    final int nextX3 = current[0] - 1;\\n                    final int nextY3 = current[1] + 1;\\n                    if (inBound(grid, nextX3, nextY3) &&\\n                            !visited[nextX3][nextY3][HORIZONTAL] &&\\n                            grid[nextX3 + 1][nextY3] == 0 &&\\n                            grid[nextX3][nextY3] == 0\\n                    ) {\\n                        queue.offer(new int[]{nextX3, nextY3, HORIZONTAL});\\n                        visited[nextX3][nextY3][HORIZONTAL] = true;\\n                    }\\n                }\\n            }\\n            ++level;\\n        }\\n        return -1;\\n    }\\n\\n    private boolean inBound(\\n            int[][] grid,\\n            int x,\\n            int y\\n    ) {\\n        return x >= 0 && y >= 0 && x < grid.length && y < grid[0].length;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    private static final int VERTICAL = 0;\\n    private static final int HORIZONTAL = 1;\\n\\n    public int minimumMoves(int[][] grid) {\\n        final Queue<int[]> queue = new LinkedList<>();\\n        final boolean[][][] visited =\\n                new boolean[grid.length][grid[0].length][2];\\n        queue.offer(new int[]{0, 1, HORIZONTAL});\\n        visited[0][1][HORIZONTAL] = true;\\n        int level = 0;\\n        while (!queue.isEmpty()) {\\n            final int currentSize = queue.size();\\n            for (int size = 0; size < currentSize; size++) {\\n                final int[] current = queue.poll();\\n                if (current[0] == grid.length - 1 &&\\n                        current[1] == grid[0].length - 1 &&\\n                        current[2] == HORIZONTAL\\n                ) {\\n                    return level;\\n                }\\n                if (current[2] == HORIZONTAL) {\\n                    // go horizon next\\n                    final int nextX = current[0];\\n                    final int nextY = current[1] + 1;\\n                    if (inBound(grid, nextX, nextY) &&\\n                            !visited[nextX][nextY][HORIZONTAL] &&\\n                            grid[nextX][nextY] == 0\\n                    ) {\\n                        queue.offer(new int[]{nextX, nextY, HORIZONTAL});\\n                        visited[nextX][nextY][HORIZONTAL] = true;\\n                    }\\n                    // go VERTICAL next\\n                    final int nextX2 = current[0] + 1;\\n                    final int nextY2 = current[1];\\n                    if (inBound(grid, nextX2, nextY2) &&\\n                            !visited[nextX2][nextY2][HORIZONTAL] &&\\n                            grid[nextX2][nextY2 - 1] == 0 &&\\n                            grid[nextX2][nextY2] == 0\\n                    ) {\\n                        queue.offer(new int[]{nextX2, nextY2, HORIZONTAL});\\n                        visited[nextX2][nextY2][HORIZONTAL] = true;\\n                    }\\n                    // rotate clockwise\\n                    final int nextX3 = current[0] + 1;\\n                    final int nextY3 = current[1] - 1;\\n                    if (inBound(grid, nextX3, nextY3) &&\\n                            !visited[nextX3][nextY3][VERTICAL] &&\\n                            grid[nextX3][nextY3 + 1] == 0 &&\\n                            grid[nextX3][nextY3] == 0\\n                    ) {\\n                        queue.offer(new int[]{nextX3, nextY3, VERTICAL});\\n                        visited[nextX3][nextY3][VERTICAL] = true;\\n                    }\\n                } else {\\n                    // go horizon next\\n                    final int nextX = current[0];\\n                    final int nextY = current[1] + 1;\\n                    if (inBound(grid, nextX, nextY) &&\\n                            !visited[nextX][nextY][VERTICAL] &&\\n                            grid[nextX - 1][nextY] == 0 &&\\n                            grid[nextX][nextY] == 0\\n                    ) {\\n                        queue.offer(new int[]{nextX, nextY, VERTICAL});\\n                        visited[nextX][nextY][VERTICAL] = true;\\n                    }\\n                    // go VERTICAL next\\n                    final int nextX2 = current[0] + 1;\\n                    final int nextY2 = current[1];\\n                    if (inBound(grid, nextX2, nextY2) &&\\n                            !visited[nextX2][nextY2][VERTICAL] &&\\n                            grid[nextX2][nextY2] == 0\\n                    ) {\\n                        queue.offer(new int[]{nextX2, nextY2, VERTICAL});\\n                        visited[nextX2][nextY2][VERTICAL] = true;\\n                    }\\n                    // rotate counterclockwise\\n                    final int nextX3 = current[0] - 1;\\n                    final int nextY3 = current[1] + 1;\\n                    if (inBound(grid, nextX3, nextY3) &&\\n                            !visited[nextX3][nextY3][HORIZONTAL] &&\\n                            grid[nextX3 + 1][nextY3] == 0 &&\\n                            grid[nextX3][nextY3] == 0\\n                    ) {\\n                        queue.offer(new int[]{nextX3, nextY3, HORIZONTAL});\\n                        visited[nextX3][nextY3][HORIZONTAL] = true;\\n                    }\\n                }\\n            }\\n            ++level;\\n        }\\n        return -1;\\n    }\\n\\n    private boolean inBound(\\n            int[][] grid,\\n            int x,\\n            int y\\n    ) {\\n        return x >= 0 && y >= 0 && x < grid.length && y < grid[0].length;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 786635,
                "title": "python-a-star-search-efficient-search-path-in-line-comments",
                "content": "```\\nimport heapq\\n\\nclass Solution:\\n  def minimumMoves(self, grid: List[List[int]]) -> int:\\n    # bfs, dfs, a-star search\\n    # A-star search with heuristic: h(Hr, Hc, Hd, Tr, Tc) = (Tr - Hr) + (Tc - Hc) + Hd\\n    # where Hr, Hc is the snake head position and Hd is the snake head direction,\\n    #  Hd == 0 when snake is horizontal, e.g., snake takes (Hr, Hc - 1), (Hr, Hc)\\n    #  Hd == 1 when snake lays vertical, e.g., snake takes (Hr - 1, Hc), (Hr, Hc)\\n    # and Tx and Ty are target position\\n    n = len(grid)\\n    if not grid[n - 1][n - 2] == grid[n - 1][n - 1] == 0:\\n      return -1\\n    # q: (e = d + h, d: moves, h: heuristic as lower bound to target, Hr, Hc, Hd)\\n    q, seen = [(2 * n - 3, 0, 2 * n - 3, 0, 1, 0)], {}\\n    while q:\\n      e, d, h, hr, hc, hd = heapq.heappop(q)\\n      if (hr, hc, hd) == (n - 1, n - 1, 0):\\n        return d\\n      if (hr, hc, hd) not in seen:\\n        seen[(hr, hc, hd)] = d\\n        # move to next w.r.t position and direction\\n        if hd == 0:\\n          # snake is horizontal (hd == 0)\\n          if hc + 1 < n and grid[hr][hc + 1] == 0 and (hr, hc + 1, hd) not in seen:\\n            # move right\\n            heapq.heappush(q, (e, d + 1, h - 1, hr, hc + 1, hd))\\n          if hr + 1 < n and grid[hr + 1][hc - 1] == grid[hr + 1][hc] == 0:\\n            if (hr + 1, hc, hd) not in seen:\\n              # move down\\n              heapq.heappush(q, (e, d + 1, h - 1, hr + 1, hc, hd))\\n            if (hr + 1, hc - 1, hd ^ 1) not in seen:\\n              # rotate clockwise\\n              heapq.heappush(q, (e + 2, d + 1, h + 1, hr + 1, hc - 1, hd ^ 1))\\n        else:\\n          # snake lays vertical (hd == 1)\\n          if hr + 1 < n and grid[hr + 1][hc] == 0 and (hr + 1, hc, hd) not in seen:\\n            # move down\\n            heapq.heappush(q, (e, d + 1, h - 1, hr + 1, hc, hd))\\n          if hc + 1 < n and grid[hr - 1][hc + 1] == grid[hr][hc + 1] == 0:\\n            if (hr, hc + 1, hd) not in seen:\\n              # move right\\n              heapq.heappush(q, (e, d + 1, h - 1, hr, hc + 1, hd))\\n            if (hr - 1, hc + 1, hd ^ 1) not in seen:\\n              # rotate counterclockwise\\n              heapq.heappush(q, (e, d + 1, h - 1, hr - 1, hc + 1, hd ^ 1))\\n    return -1\\n```",
                "solutionTags": [],
                "code": "```\\nimport heapq\\n\\nclass Solution:\\n  def minimumMoves(self, grid: List[List[int]]) -> int:\\n    # bfs, dfs, a-star search\\n    # A-star search with heuristic: h(Hr, Hc, Hd, Tr, Tc) = (Tr - Hr) + (Tc - Hc) + Hd\\n    # where Hr, Hc is the snake head position and Hd is the snake head direction,\\n    #  Hd == 0 when snake is horizontal, e.g., snake takes (Hr, Hc - 1), (Hr, Hc)\\n    #  Hd == 1 when snake lays vertical, e.g., snake takes (Hr - 1, Hc), (Hr, Hc)\\n    # and Tx and Ty are target position\\n    n = len(grid)\\n    if not grid[n - 1][n - 2] == grid[n - 1][n - 1] == 0:\\n      return -1\\n    # q: (e = d + h, d: moves, h: heuristic as lower bound to target, Hr, Hc, Hd)\\n    q, seen = [(2 * n - 3, 0, 2 * n - 3, 0, 1, 0)], {}\\n    while q:\\n      e, d, h, hr, hc, hd = heapq.heappop(q)\\n      if (hr, hc, hd) == (n - 1, n - 1, 0):\\n        return d\\n      if (hr, hc, hd) not in seen:\\n        seen[(hr, hc, hd)] = d\\n        # move to next w.r.t position and direction\\n        if hd == 0:\\n          # snake is horizontal (hd == 0)\\n          if hc + 1 < n and grid[hr][hc + 1] == 0 and (hr, hc + 1, hd) not in seen:\\n            # move right\\n            heapq.heappush(q, (e, d + 1, h - 1, hr, hc + 1, hd))\\n          if hr + 1 < n and grid[hr + 1][hc - 1] == grid[hr + 1][hc] == 0:\\n            if (hr + 1, hc, hd) not in seen:\\n              # move down\\n              heapq.heappush(q, (e, d + 1, h - 1, hr + 1, hc, hd))\\n            if (hr + 1, hc - 1, hd ^ 1) not in seen:\\n              # rotate clockwise\\n              heapq.heappush(q, (e + 2, d + 1, h + 1, hr + 1, hc - 1, hd ^ 1))\\n        else:\\n          # snake lays vertical (hd == 1)\\n          if hr + 1 < n and grid[hr + 1][hc] == 0 and (hr + 1, hc, hd) not in seen:\\n            # move down\\n            heapq.heappush(q, (e, d + 1, h - 1, hr + 1, hc, hd))\\n          if hc + 1 < n and grid[hr - 1][hc + 1] == grid[hr][hc + 1] == 0:\\n            if (hr, hc + 1, hd) not in seen:\\n              # move right\\n              heapq.heappush(q, (e, d + 1, h - 1, hr, hc + 1, hd))\\n            if (hr - 1, hc + 1, hd ^ 1) not in seen:\\n              # rotate counterclockwise\\n              heapq.heappush(q, (e, d + 1, h - 1, hr - 1, hc + 1, hd ^ 1))\\n    return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 780227,
                "title": "ruby-bfs-beat-100",
                "content": "```\\nHORIZONTAL = 0\\nVERTICAL = 1\\n# @param {Integer[][]} grid\\n# @return {Integer}\\ndef minimum_moves(grid)\\n  n, m = grid.size, grid[0].size\\n\\n  horizontal, vertical = [], []\\n  horizontal[0] = []\\n  horizontal[0][1] = 0\\n\\n  queue = Queue.new\\n  queue << [0, 1, HORIZONTAL]\\n  while !queue.empty?\\n    i, j, direction = queue.pop\\n    horizontal[i] ||= []\\n    horizontal[i+1] ||= []\\n    vertical[i] ||= []\\n    vertical[i+1] ||= []\\n\\n    if direction == HORIZONTAL \\n      if grid[i][j+1] == 0 && horizontal[i][j+1].nil?\\n        horizontal[i][j+1] = horizontal[i][j] + 1\\n        queue << [i, j+1, HORIZONTAL]\\n      end\\n\\n      if grid[i+1] && grid[i+1][j-1] == 0 && grid[i+1][j] == 0 && horizontal[i+1][j].nil?\\n        horizontal[i+1][j] = horizontal[i][j] + 1\\n        queue << [i+1, j, HORIZONTAL]\\n      end\\n\\n      if grid[i+1] && grid[i+1][j] == 0 && grid[i+1][j-1] == 0 && vertical[i+1][j-1].nil?\\n        vertical[i+1][j-1] = horizontal[i][j] + 1\\n        queue << [i+1, j-1, VERTICAL]\\n      end\\n    end\\n\\n    if direction == VERTICAL \\n      if grid[i+1] && grid[i+1][j] == 0 && vertical[i+1][j].nil?\\n        vertical[i+1][j] = vertical[i][j] + 1\\n        queue << [i+1, j, VERTICAL]\\n      end\\n\\n      if i > 0 && grid[i-1][j+1] == 0 && grid[i][j+1] == 0 && vertical[i][j+1].nil?\\n        vertical[i][j+1] = vertical[i][j] + 1\\n        queue << [i, j+1, VERTICAL]\\n      end\\n\\n      if grid[i-1] && grid[i][j+1] == 0 && grid[i-1][j+1] == 0 && horizontal[i-1][j+1].nil?\\n        horizontal[i-1][j+1] = vertical[i][j] + 1\\n        queue << [i-1, j+1, HORIZONTAL]\\n      end\\n    end\\n\\n  end\\n\\n  horizontal.dig(n-1, m-1) || -1\\nend\\n```",
                "solutionTags": [],
                "code": "```\\nHORIZONTAL = 0\\nVERTICAL = 1\\n# @param {Integer[][]} grid\\n# @return {Integer}\\ndef minimum_moves(grid)\\n  n, m = grid.size, grid[0].size\\n\\n  horizontal, vertical = [], []\\n  horizontal[0] = []\\n  horizontal[0][1] = 0\\n\\n  queue = Queue.new\\n  queue << [0, 1, HORIZONTAL]\\n  while !queue.empty?\\n    i, j, direction = queue.pop\\n    horizontal[i] ||= []\\n    horizontal[i+1] ||= []\\n    vertical[i] ||= []\\n    vertical[i+1] ||= []\\n\\n    if direction == HORIZONTAL \\n      if grid[i][j+1] == 0 && horizontal[i][j+1].nil?\\n        horizontal[i][j+1] = horizontal[i][j] + 1\\n        queue << [i, j+1, HORIZONTAL]\\n      end\\n\\n      if grid[i+1] && grid[i+1][j-1] == 0 && grid[i+1][j] == 0 && horizontal[i+1][j].nil?\\n        horizontal[i+1][j] = horizontal[i][j] + 1\\n        queue << [i+1, j, HORIZONTAL]\\n      end\\n\\n      if grid[i+1] && grid[i+1][j] == 0 && grid[i+1][j-1] == 0 && vertical[i+1][j-1].nil?\\n        vertical[i+1][j-1] = horizontal[i][j] + 1\\n        queue << [i+1, j-1, VERTICAL]\\n      end\\n    end\\n\\n    if direction == VERTICAL \\n      if grid[i+1] && grid[i+1][j] == 0 && vertical[i+1][j].nil?\\n        vertical[i+1][j] = vertical[i][j] + 1\\n        queue << [i+1, j, VERTICAL]\\n      end\\n\\n      if i > 0 && grid[i-1][j+1] == 0 && grid[i][j+1] == 0 && vertical[i][j+1].nil?\\n        vertical[i][j+1] = vertical[i][j] + 1\\n        queue << [i, j+1, VERTICAL]\\n      end\\n\\n      if grid[i-1] && grid[i][j+1] == 0 && grid[i-1][j+1] == 0 && horizontal[i-1][j+1].nil?\\n        horizontal[i-1][j+1] = vertical[i][j] + 1\\n        queue << [i-1, j+1, HORIZONTAL]\\n      end\\n    end\\n\\n  end\\n\\n  horizontal.dig(n-1, m-1) || -1\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 773127,
                "title": "python-faster-than-80-30-lines",
                "content": "```\\nclass Solution:\\n    def minimumMoves(self, x: List[List[int]]) -> int:\\n        q,v,n=[(0,0,0,0)],{(0,0,0)},len(x)\\n        while len(q)>0:\\n            i,j,di,mi=q.pop(0)\\n            if (i,j,di)==(n-1,n-2,0):return mi\\n            if di==0:\\n                if j+2<n and (i,j+1,0) not in v and x[i][j+2]!=1:\\n                    q.append((i,j+1,0,mi+1))\\n                    v.add((i,j+1,0))\\n                if i+1<n and (i+1,j,0) not in v and x[i+1][j]!=1 and x[i+1][j+1]!=1:\\n                    q.append((i+1,j,0,mi+1))\\n                    v.add((i+1,j,0))\\n            else:\\n                if i+2<n and (i+1,j,1) not in v and x[i+2][j]!=1:\\n                    q.append((i+1,j,1,mi+1))\\n                    v.add((i+1,j,1))\\n                if j+1<n and (i,j+1,1) not in v and x[i][j+1]!=1 and x[i+1][j+1]!=1:\\n                    q.append((i,j+1,1,mi+1))\\n                    v.add((i,j+1,1))\\n            if di==0:\\n                if i+1<n and (i,j,1) not in v  and x[i+1][j]!=1 and x[i+1][j+1]!=1:\\n                    q.append((i,j,1,mi+1))\\n                    v.add((i,j,1))\\n            else:\\n                if j+1<n and (i,j,0) not in v  and x[i][j+1]!=1 and x[i+1][j+1]!=1:\\n                    q.append((i,j,0,mi+1))\\n                    v.add((i,j,0))\\n        return -1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumMoves(self, x: List[List[int]]) -> int:\\n        q,v,n=[(0,0,0,0)],{(0,0,0)},len(x)\\n        while len(q)>0:\\n            i,j,di,mi=q.pop(0)\\n            if (i,j,di)==(n-1,n-2,0):return mi\\n            if di==0:\\n                if j+2<n and (i,j+1,0) not in v and x[i][j+2]!=1:\\n                    q.append((i,j+1,0,mi+1))\\n                    v.add((i,j+1,0))\\n                if i+1<n and (i+1,j,0) not in v and x[i+1][j]!=1 and x[i+1][j+1]!=1:\\n                    q.append((i+1,j,0,mi+1))\\n                    v.add((i+1,j,0))\\n            else:\\n                if i+2<n and (i+1,j,1) not in v and x[i+2][j]!=1:\\n                    q.append((i+1,j,1,mi+1))\\n                    v.add((i+1,j,1))\\n                if j+1<n and (i,j+1,1) not in v and x[i][j+1]!=1 and x[i+1][j+1]!=1:\\n                    q.append((i,j+1,1,mi+1))\\n                    v.add((i,j+1,1))\\n            if di==0:\\n                if i+1<n and (i,j,1) not in v  and x[i+1][j]!=1 and x[i+1][j+1]!=1:\\n                    q.append((i,j,1,mi+1))\\n                    v.add((i,j,1))\\n            else:\\n                if j+1<n and (i,j,0) not in v  and x[i][j+1]!=1 and x[i+1][j+1]!=1:\\n                    q.append((i,j,0,mi+1))\\n                    v.add((i,j,0))\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 752381,
                "title": "c-simple-top-down-dp",
                "content": "State:\\n( i , j , dir )  where (i,j) is current coordinate of tail and dir represents direction of head\\ndir==1 mens face is towards right\\ndir==2 means face is  downward\\n\\nTarget State-> (n-1,n-2,1)\\ndp[0][0][1] = 0   initial state\\n\\nIdea:\\nAt any state ( i, j, dir)  either we came from left or from top or we got into this via some rotation\\n\\nRotation ?\\nIf dir==1 we might have rotated anticlockwise from downward facing direction, no other rotation possible\\n\\nIf dir==2 we might have rotated clockwise from rightward facing direction, no other rotation possible\\n```\\nint dp[101][101][3],n;\\n\\n\\nint solve(vector<vector<int>> &mat,int i,int j,int dir)\\n{\\n    // invalid snake configuration or position return infinity - 1e6 here\\n    if(i<0 || i>=n || j<0 || j>=n || mat[i][j]==1) return 1e6;\\n\\t\\n    if(dir==1)\\n    {\\n\\t\\t// tail at (i,j) and head on (i,j+1)\\n\\t\\t\\n        // check if head can be possible at (i,j+1)\\n\\t\\t// if not return infinity\\n        if(j+1>=n)\\n        return 1e6;\\n        if(mat[i][j+1]==1) return 1e6;\\n    }\\n    if(dir==2) \\n    {\\n\\t\\t//tail at (i,j) and head on (i+1,j)\\n\\t\\n        // check if head can be possible at (i+1,j)\\n\\t\\t// if not return infinity\\n        if(i+1>=n)\\n        return 1e6;\\n        if(mat[i+1][j]==1) return 1e6;\\n    }\\n    \\n    if(dp[i][j][dir]!=-1) return dp[i][j][dir];\\n    \\n    // see from where can we reach current state\\n    if(dir==1)\\n    {\\n        //from left\\n        dp[i][j][dir]=1+solve(mat,i,j-1,1);\\n        //from up\\n        dp[i][j][dir]=min(dp[i][j][dir],1+solve(mat,i-1,j,1));\\n        \\n        //anticlockwised from (i,j,downward_face) to current=(i,j,rightward_face) \\n        //iff mat[i+1][j+1]==0 as given in question\\n        if(i+1<n && j+1<n && mat[i+1][j+1]==0)\\n        dp[i][j][dir]=min(dp[i][j][dir],1+solve(mat,i,j,2));\\n    }\\n    else\\n    {\\n        //from left\\n        dp[i][j][dir]=1+solve(mat,i,j-1,2);\\n        //from up\\n        dp[i][j][dir]=min(dp[i][j][dir],1+solve(mat,i-1,j,2));\\n        \\n        //clockwised from (i,j,rightward_face) to current=(i,j,downward_face) \\n        //iff mat[i+1][j+1]==0 as given in question\\n        if(i+1<n && j+1<n && mat[i+1][j+1]==0)\\n        dp[i][j][dir]=min(dp[i][j][dir],1+solve(mat,i,j,1));\\n    }\\n    \\n    return dp[i][j][dir];\\n}\\n\\nclass Solution {\\npublic:\\n    int minimumMoves(vector<vector<int>>& grid) \\n    {\\n        n=grid.size();\\n        memset(dp,-1,sizeof dp);\\n        // initially at (0,0,right_faced);\\n        dp[0][0][1]=0;\\n        int ans= solve(grid,n-1,n-2,1);\\n        //if cannt reach (n-1,n-2,1) from (0,0,1) return -1;\\n        if(ans>n*n) return -1;\\n        //otherwise return ans\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nint dp[101][101][3],n;\\n\\n\\nint solve(vector<vector<int>> &mat,int i,int j,int dir)\\n{\\n    // invalid snake configuration or position return infinity - 1e6 here\\n    if(i<0 || i>=n || j<0 || j>=n || mat[i][j]==1) return 1e6;\\n\\t\\n    if(dir==1)\\n    {\\n\\t\\t// tail at (i,j) and head on (i,j+1)\\n\\t\\t\\n        // check if head can be possible at (i,j+1)\\n\\t\\t// if not return infinity\\n        if(j+1>=n)\\n        return 1e6;\\n        if(mat[i][j+1]==1) return 1e6;\\n    }\\n    if(dir==2) \\n    {\\n\\t\\t//tail at (i,j) and head on (i+1,j)\\n\\t\\n        // check if head can be possible at (i+1,j)\\n\\t\\t// if not return infinity\\n        if(i+1>=n)\\n        return 1e6;\\n        if(mat[i+1][j]==1) return 1e6;\\n    }\\n    \\n    if(dp[i][j][dir]!=-1) return dp[i][j][dir];\\n    \\n    // see from where can we reach current state\\n    if(dir==1)\\n    {\\n        //from left\\n        dp[i][j][dir]=1+solve(mat,i,j-1,1);\\n        //from up\\n        dp[i][j][dir]=min(dp[i][j][dir],1+solve(mat,i-1,j,1));\\n        \\n        //anticlockwised from (i,j,downward_face) to current=(i,j,rightward_face) \\n        //iff mat[i+1][j+1]==0 as given in question\\n        if(i+1<n && j+1<n && mat[i+1][j+1]==0)\\n        dp[i][j][dir]=min(dp[i][j][dir],1+solve(mat,i,j,2));\\n    }\\n    else\\n    {\\n        //from left\\n        dp[i][j][dir]=1+solve(mat,i,j-1,2);\\n        //from up\\n        dp[i][j][dir]=min(dp[i][j][dir],1+solve(mat,i-1,j,2));\\n        \\n        //clockwised from (i,j,rightward_face) to current=(i,j,downward_face) \\n        //iff mat[i+1][j+1]==0 as given in question\\n        if(i+1<n && j+1<n && mat[i+1][j+1]==0)\\n        dp[i][j][dir]=min(dp[i][j][dir],1+solve(mat,i,j,1));\\n    }\\n    \\n    return dp[i][j][dir];\\n}\\n\\nclass Solution {\\npublic:\\n    int minimumMoves(vector<vector<int>>& grid) \\n    {\\n        n=grid.size();\\n        memset(dp,-1,sizeof dp);\\n        // initially at (0,0,right_faced);\\n        dp[0][0][1]=0;\\n        int ans= solve(grid,n-1,n-2,1);\\n        //if cannt reach (n-1,n-2,1) from (0,0,1) return -1;\\n        if(ans>n*n) return -1;\\n        //otherwise return ans\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 729166,
                "title": "bfs-c-solution",
                "content": "\\'\\'\\'\\nclass Solution {\\npublic:\\n    \\n    \\n    \\n    \\nunordered_set<string> visited;\\n\\n    queue<vector<int>>q;\\n    \\n    int tailI[4]={0,1,0,0};\\n    int tailJ[4]={1,0,0,0};\\n    int headI[4]={0,1,1,-1};\\n    int headJ[4]={1,0,-1,1};\\n    \\n    bool valid(int i,int j,int n){\\n        if(i>=0&&i<n&&j>=0&&j<n)return 1;\\n        else return 0;\\n        \\n    }\\n    \\n    \\n    int BFS(int n,vector<vector<int>>& grid){\\n        int steps=0;\\n        while(q.size()){\\n        int sz=q.size();\\n             \\n            \\n            \\n      for (int w=0;w<sz;w++) {     \\n          int i1=q.front()[0];\\n            int j1=q.front()[1];\\n            int i2=q.front()[2];\\n            int j2=q.front()[3];\\n            q.pop();\\n            if(i1==n-1&&j1==n-2&&i2==n-1&&j2==n-1)return steps;\\n            \\n            for (int k=0;k<4;k++){\\n                vector<int> v;\\n        \\n                int newi1=i1+tailI[k];\\n                int newj1=j1+tailJ[k];\\n                int newi2=i2+headI[k];\\n                int newj2=j2+headJ[k];\\n                           \\n                \\n                string temp=\"\";\\n                temp+=to_string(newi1);\\n                temp+=to_string(newj1);\\n                temp+=to_string(newi2);\\n                temp+=to_string(newj2);\\n                \\n                if(k==2||k==3){\\n                    \\n                    if(k==2&&(i2>i1))continue;\\n                    if(k==3&&(j2>j1))continue;\\n                    \\n                    // case of rotation\\n         if(valid(newi2,newj2,n)&&valid(newi1+1,newj1+1,n)&&valid(newi1,newj1,n)){\\n                    // this means it\\'s safe for the snake to move\\n          if(grid[newi2][newj2]==0&&grid[newi1+1][newj1+1]==0&&grid[newi1][newj1]==0){                                   if(visited.find(temp)==visited.end()){\\n         // if the ditsnace is less\\n     \\n             visited.insert(temp);\\n             \\n              q.push({newi1,newj1,newi2,newj2});\\n         \\n     }\\n         }           \\n                }\\n                }\\n                else{        \\n                if(valid(newi2,newj2,n)&&valid(newi1,newj1,n)){\\n                    // this means it\\'s safe for the snake to move\\n   if(grid[newi2][newj2]==0&&grid[newi1][newj1]==0){  if(visited.find(temp)==visited.end()){\\n         // if the ditsnace is less\\n     \\n        visited.insert(temp);\\n         \\n              q.push({newi1,newj1,newi2,newj2});\\n\\n         \\n     }}\\n                    \\n                }\\n                }    \\n                \\n                \\n            }\\n            \\n            \\n            \\n            \\n            \\n        }\\n        \\n        steps++;\\n        }\\n        \\n        return -1;\\n        \\n        \\n    }\\n    \\n    \\n    int minimumMoves(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        vector<int> v;\\n        v.push_back(0);\\n        v.push_back(0);\\n        v.push_back(0);\\n        v.push_back(1);\\n      q.push(v);  \\n     // dist[{{0,0},{0,1}}]=0;  \\n       // vis[{{0,0},{0,1}}]=1;\\n        string temp=\"\";\\n        temp+=to_string(0001);\\n        visited.insert(temp);\\n        return BFS(n,grid);\\n    }\\n};\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n    \\n    \\n    \\nunordered_set<string> visited;\\n\\n    queue<vector<int>>q;\\n    \\n    int tailI[4]={0,1,0,0}",
                "codeTag": "Java"
            },
            {
                "id": 729164,
                "title": "bfs-c-solution",
                "content": "\\'\\'\\'\\n\\nclass Solution {\\npublic:\\n    \\n    \\n    \\n    map<pair<pair<int,int>,pair<int,int>>,int> dist;\\n        map<pair<pair<int,int>,pair<int,int>>,int> vis;\\n        queue<pair<pair<int,int>,pair<int,int>>>q;\\n\\n//unordered_set<string> visited;\\n\\n    //queue<vector<int>>q;\\n    \\n    int tailI[4]={0,1,0,0};\\n    int tailJ[4]={1,0,0,0};\\n    int headI[4]={0,1,1,-1};\\n    int headJ[4]={1,0,-1,1};\\n    \\n    bool valid(int i,int j,int n){\\n        if(i>=0&&i<n&&j>=0&&j<n)return 1;\\n        else return 0;\\n        \\n    }\\n    \\n    \\n    int BFS(int n,vector<vector<int>>& grid){\\n        int steps=0;\\n        while(q.size()){\\n       \\n             \\n            \\n            \\n           \\n          int i1=q.front().first.first;\\n            int j1=q.front().first.second;\\n            int i2=q.front().second.first;\\n            int j2=q.front().second.second;\\n            q.pop();\\n             cout<<i1<<\" \"<<j1<<\"   \"<<i2<<\" \"<<j2<<\"   \"<<steps<<endl;\\n            if(i1==n-1&&j1==n-2&&i2==n-1&&j2==n-1)return dist[{{i1,j1},{i2,j2}}];\\n            \\n            for (int k=0;k<4;k++){\\n                vector<int> v;\\n        \\n                int newi1=i1+tailI[k];\\n                int newj1=j1+tailJ[k];\\n                int newi2=i2+headI[k];\\n                int newj2=j2+headJ[k];\\n                           \\n                \\n                \\n                \\n                if(k==2||k==3){\\n                    \\n                    if(k==2&&(i2>i1))continue;\\n                    if(k==3&&(j2>j1))continue;\\n                    \\n                    // case of rotation\\n         if(valid(newi2,newj2,n)&&valid(newi1+1,newj1+1,n)&&valid(newi1,newj1,n)){\\n                    // this means it\\'s safe for the snake to move\\n          if(grid[newi2][newj2]==0&&grid[newi1+1][newj1+1]==0&&grid[newi1][newj1]==0){                                   if(vis[{{newi1,newj1},{newi2,newj2}}]==0){\\n         // if the ditsnace is less\\n     \\n            vis[{{newi1,newj1},{newi2,newj2}}]=1;\\n             dist[{{newi1,newj1},{newi2,newj2}}]=dist[{{i1,j1},{i2,j2}}]+1;\\n              q.push({{newi1,newj1},{newi2,newj2}});\\n         \\n     }\\n         }           \\n                }\\n                }\\n                else{        \\n                if(valid(newi2,newj2,n)&&valid(newi1,newj1,n)){\\n                    // this means it\\'s safe for the snake to move\\n   if(grid[newi2][newj2]==0&&grid[newi1][newj1]==0){  \\n                            if(vis[{{newi1,newj1},{newi2,newj2}}]==0){\\n         // if the ditsnace is less\\n     \\n            vis[{{newi1,newj1},{newi2,newj2}}]=1;\\n             dist[{{newi1,newj1},{newi2,newj2}}]=dist[{{i1,j1},{i2,j2}}]+1;\\n              q.push({{newi1,newj1},{newi2,newj2}});\\n         \\n     }\\n                                                   }\\n                    \\n                }\\n                }    \\n                \\n                \\n            }\\n            \\n            \\n            \\n            \\n            \\n        \\n        \\n       // steps++;\\n        }\\n        \\n        return -1;\\n        \\n        \\n    }\\n    \\n    \\n    int minimumMoves(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        q.push({{0,0},{0,1}});\\n      dist[{{0,0},{0,1}}]=0;  \\n        vis[{{0,0},{0,1}}]=1;\\n       \\n        return BFS(n,grid);\\n    }\\n};\\n\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n    \\n    \\n    map<pair<pair<int,int>,pair<int,int>>,int> dist;\\n        map<pair<pair<int,int>,pair<int,int>>,int> vis;\\n        queue<pair<pair<int,int>,pair<int,int>>>q;\\n\\n//unordered_set<string> visited;\\n\\n    //queue<vector<int>>q;\\n    \\n    int tailI[4]={0,1,0,0}",
                "codeTag": "Java"
            },
            {
                "id": 718237,
                "title": "python-bfs",
                "content": "```\\nfrom collections import deque\\nclass Solution:\\n    def minimumMoves(self, grid: List[List[int]]) -> int:\\n        def add_pos(pos, seen, queue, level):\\n            if pos not in seen:\\n                seen.add(pos)\\n                queue.append([pos, level])\\n        queue = deque()\\n        pos = ((0,0),(0,1))\\n        queue.append([pos,0])\\n        seen = set([pos])\\n        n = len(grid)\\n        target = ((n-1,n-2), (n-1, n-1))\\n        while queue:\\n            position, level = queue.popleft()\\n            if position == target:\\n                return level\\n            r1,c1 = position[0]\\n            r2,c2 = position[1]\\n            seen.add(position)\\n            next_level = level+1\\n            is_horizontal = r1==r2\\n            if is_horizontal:\\n                if c2 < n-1 and grid[r2][c2+1] == 0:\\n                    add_pos(((r1,c1+1),(r2,c2+1)),seen, queue, next_level) # right\\n                if r1 < n-1 and grid[r1+1][c1] == 0 and grid[r2+1][c2]==0:\\n                    add_pos(((r1+1,c1),(r2+1,c2)),seen, queue, next_level) # down\\n                    add_pos(((r1,c1),(r2+1,c2-1)),seen, queue, next_level) # clockwise\\n            else:\\n                if c1 < n-1 and grid[r2][c2+1] == 0 and grid[r1][c1+1] == 0:\\n                    add_pos(((r1,c1+1),(r2,c2+1)),seen, queue, next_level) # right\\n                    add_pos(((r1,c1),(r2-1,c2+1)),seen, queue, next_level) # counterclockwise\\n                if r2 < n-1 and grid[r2+1][c2] == 0:\\n                    add_pos(((r1+1,c1),(r2+1,c2)),seen, queue, next_level) # down\\n        return -1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nfrom collections import deque\\nclass Solution:\\n    def minimumMoves(self, grid: List[List[int]]) -> int:\\n        def add_pos(pos, seen, queue, level):\\n            if pos not in seen:\\n                seen.add(pos)\\n                queue.append([pos, level])\\n        queue = deque()\\n        pos = ((0,0),(0,1))\\n        queue.append([pos,0])\\n        seen = set([pos])\\n        n = len(grid)\\n        target = ((n-1,n-2), (n-1, n-1))\\n        while queue:\\n            position, level = queue.popleft()\\n            if position == target:\\n                return level\\n            r1,c1 = position[0]\\n            r2,c2 = position[1]\\n            seen.add(position)\\n            next_level = level+1\\n            is_horizontal = r1==r2\\n            if is_horizontal:\\n                if c2 < n-1 and grid[r2][c2+1] == 0:\\n                    add_pos(((r1,c1+1),(r2,c2+1)),seen, queue, next_level) # right\\n                if r1 < n-1 and grid[r1+1][c1] == 0 and grid[r2+1][c2]==0:\\n                    add_pos(((r1+1,c1),(r2+1,c2)),seen, queue, next_level) # down\\n                    add_pos(((r1,c1),(r2+1,c2-1)),seen, queue, next_level) # clockwise\\n            else:\\n                if c1 < n-1 and grid[r2][c2+1] == 0 and grid[r1][c1+1] == 0:\\n                    add_pos(((r1,c1+1),(r2,c2+1)),seen, queue, next_level) # right\\n                    add_pos(((r1,c1),(r2-1,c2+1)),seen, queue, next_level) # counterclockwise\\n                if r2 < n-1 and grid[r2+1][c2] == 0:\\n                    add_pos(((r1+1,c1),(r2+1,c2)),seen, queue, next_level) # down\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 701235,
                "title": "python-dp-solution-with-explanation",
                "content": "Each time the snake is horizontal, there are 3 possibilities: moving right, moving down, rotating clockwise. If the snake is vertical, the 3 possibilities become moving right, moving down, rotating counter-clockwise. This is reminiscent of problems 63, 64, 120, 174, and 931, which suggests that we may be able to use dynamic programming to solve the problem. However, care should be taken to ensure that the snake isn\\u2019t stuck at the same place forever keeping rotating clockwise and counter-clockwise (stack overflow for recursion). So, in addition to the coordinates and orientations, we also need to keep track of whether the snake has already rotated. If it was previously rotated to the current position, we don\\u2019t want the snake to rotate again as this would cause the snake to get stuck, which will never give us the minimum moves. Here, the last parameter in dp(r, c, hor = True, rotated = False) keeps track of that. The remaining part is easy, and the only tricky thing is checking if there\\u2019s any obstacle blocking a move.\\n\\n\\n\\n```\\nclass Solution:\\n    def minimumMoves(self, grid: List[List[int]]) -> int:\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        n = len(grid)\\n        if grid[n-1][n-2] == 1 or grid[n-1][n-1] == 1: \\n            return -1\\n        \\n        cache = {(n-1, n-2, True, False): 0, (n-1, n-2, True, True): 0}\\n        \\n        def dp(r, c, hor = True, rotated = False):\\n            # Tail is at (r, c)\\n            # If hor is True: head is at (r, c+1)\\n            # if hor is False: head is at (r+1, c)\\n            tup = (r, c, hor, rotated)\\n            if tup in cache:\\n                return cache[tup]\\n            \\n            v1, v2, v3 = float(\"Inf\"), float(\"Inf\"), float(\"Inf\")\\n            if hor:\\n                # Horizontal\\n                if c + 2 < n and grid[r][c+2] == 0:\\n                    # Move right\\n                    v1 = dp(r, c+1, True, False)\\n                if r + 1 < n and c + 1 < n and grid[r+1][c] == 0 and grid[r+1][c+1] == 0:\\n                    # Move down\\n                    v2 = dp(r+1, c, True, False)\\n                    # Rotate if it hasn\\'t rotated yet\\n                    if not rotated:\\n                        v3 = dp(r, c, False, True)\\n            else:\\n                # Vertical\\n                if r+2 < n and grid[r+2][c] == 0:\\n                    # Move down\\n                    v1 = dp(r+1, c, False, False)\\n                if c + 1 < n and r + 1 < n and grid[r][c+1] == 0 and grid[r+1][c+1] == 0:\\n                    # Move right\\n                    v2 = dp(r, c+1, False, False)\\n                    # Rotate if it hasn\\'t rotated yet\\n                    if not rotated:\\n                        v3 = dp(r, c, True, True)\\n            cache[tup] = min(v1, v2, v3) + 1\\n            return cache[tup]\\n\\n        ret = dp(0, 0, True, False)\\n        return ret if ret != float(\"Inf\") else -1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumMoves(self, grid: List[List[int]]) -> int:\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        n = len(grid)\\n        if grid[n-1][n-2] == 1 or grid[n-1][n-1] == 1: \\n            return -1\\n        \\n        cache = {(n-1, n-2, True, False): 0, (n-1, n-2, True, True): 0}\\n        \\n        def dp(r, c, hor = True, rotated = False):\\n            # Tail is at (r, c)\\n            # If hor is True: head is at (r, c+1)\\n            # if hor is False: head is at (r+1, c)\\n            tup = (r, c, hor, rotated)\\n            if tup in cache:\\n                return cache[tup]\\n            \\n            v1, v2, v3 = float(\"Inf\"), float(\"Inf\"), float(\"Inf\")\\n            if hor:\\n                # Horizontal\\n                if c + 2 < n and grid[r][c+2] == 0:\\n                    # Move right\\n                    v1 = dp(r, c+1, True, False)\\n                if r + 1 < n and c + 1 < n and grid[r+1][c] == 0 and grid[r+1][c+1] == 0:\\n                    # Move down\\n                    v2 = dp(r+1, c, True, False)\\n                    # Rotate if it hasn\\'t rotated yet\\n                    if not rotated:\\n                        v3 = dp(r, c, False, True)\\n            else:\\n                # Vertical\\n                if r+2 < n and grid[r+2][c] == 0:\\n                    # Move down\\n                    v1 = dp(r+1, c, False, False)\\n                if c + 1 < n and r + 1 < n and grid[r][c+1] == 0 and grid[r+1][c+1] == 0:\\n                    # Move right\\n                    v2 = dp(r, c+1, False, False)\\n                    # Rotate if it hasn\\'t rotated yet\\n                    if not rotated:\\n                        v3 = dp(r, c, True, True)\\n            cache[tup] = min(v1, v2, v3) + 1\\n            return cache[tup]\\n\\n        ret = dp(0, 0, True, False)\\n        return ret if ret != float(\"Inf\") else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 691094,
                "title": "java-bfs-snake-class",
                "content": "```\\nclass Solution {\\n    public int minimumMoves(int[][] grid) {\\n        Queue<Snake> q = new LinkedList();\\n        q.offer(new Snake(0,1,0,0));\\n        HashSet<String> set = new HashSet();\\n        set.add(convert(0,1,0,0));\\n        int res = 0;\\n        while (!q.isEmpty()) {\\n            int size = q.size();\\n            while (size > 0) {\\n                size--;\\n                Snake curr = q.poll();\\n                if (win(curr, grid)) return res;\\n                for (Snake next: getNext(curr, grid)) {\\n                    String val = convert(next.hx, next.hy, next.tx, next.ty);\\n                    if (set.contains(val)) continue;\\n                    set.add(val);\\n                    q.offer(next);\\n                }\\n            }\\n            res++;\\n        }\\n        return -1;\\n    }\\n    \\n    public List<Snake> getNext(Snake curr, int[][] grid) {\\n        List<Snake> res = new ArrayList();\\n        // right\\n        if (valid(curr.hx,curr.hy+1, grid) && valid(curr.tx,curr.ty+1, grid)) {\\n            res.add(new Snake(curr.hx,curr.hy+1,curr.tx,curr.ty+1));\\n        }\\n        // down\\n        if (valid(curr.hx+1,curr.hy, grid) && valid(curr.tx+1,curr.ty, grid)) {\\n            res.add(new Snake(curr.hx+1,curr.hy,curr.tx+1,curr.ty));\\n        }\\n        boolean isHorizontal = curr.hx == curr.tx;\\n        if (isHorizontal) {\\n            // clockwise\\n            if (valid(curr.hx+1,curr.hy, grid) && valid(curr.tx+1,curr.ty, grid)) {\\n                res.add(new Snake(curr.hx+1,curr.hy-1,curr.tx,curr.ty));\\n            }\\n        }\\n        else {\\n            if (valid(curr.hx,curr.hy+1, grid) && valid(curr.tx,curr.ty+1, grid)) {\\n                res.add(new Snake(curr.hx-1,curr.hy+1,curr.tx,curr.ty));\\n            }\\n        }\\n        return res;\\n        \\n    }\\n    \\n    public boolean valid(int x, int y, int[][] grid) {\\n        int n = grid.length;\\n        if (x < 0 || y < 0 || x >= n || y >= n || grid[x][y] == 1) return false;\\n        return true;\\n    }\\n    \\n    public boolean win(Snake s, int[][] grid) {\\n        int n = grid.length;\\n        if (s.hx == n-1 && s.hy == n-1 && s.tx == n-1 && s.ty == n-2) {\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    public String convert(int x, int y, int z, int o) {\\n        StringBuilder sb = new StringBuilder();\\n        sb.append(x);\\n        sb.append(y);\\n        sb.append(z);\\n        sb.append(o);\\n        return sb.toString();\\n    }\\n}\\n\\npublic class Snake {\\n    public int hx;\\n    public int hy;\\n    public int tx;\\n    public int ty;\\n    \\n    public Snake(int x1, int y1, int x2, int y2) {\\n        this.hx = x1;\\n        this.hy = y1;\\n        this.tx = x2;\\n        this.ty = y2;\\n    }\\n    \\n\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minimumMoves(int[][] grid) {\\n        Queue<Snake> q = new LinkedList();\\n        q.offer(new Snake(0,1,0,0));\\n        HashSet<String> set = new HashSet();\\n        set.add(convert(0,1,0,0));\\n        int res = 0;\\n        while (!q.isEmpty()) {\\n            int size = q.size();\\n            while (size > 0) {\\n                size--;\\n                Snake curr = q.poll();\\n                if (win(curr, grid)) return res;\\n                for (Snake next: getNext(curr, grid)) {\\n                    String val = convert(next.hx, next.hy, next.tx, next.ty);\\n                    if (set.contains(val)) continue;\\n                    set.add(val);\\n                    q.offer(next);\\n                }\\n            }\\n            res++;\\n        }\\n        return -1;\\n    }\\n    \\n    public List<Snake> getNext(Snake curr, int[][] grid) {\\n        List<Snake> res = new ArrayList();\\n        // right\\n        if (valid(curr.hx,curr.hy+1, grid) && valid(curr.tx,curr.ty+1, grid)) {\\n            res.add(new Snake(curr.hx,curr.hy+1,curr.tx,curr.ty+1));\\n        }\\n        // down\\n        if (valid(curr.hx+1,curr.hy, grid) && valid(curr.tx+1,curr.ty, grid)) {\\n            res.add(new Snake(curr.hx+1,curr.hy,curr.tx+1,curr.ty));\\n        }\\n        boolean isHorizontal = curr.hx == curr.tx;\\n        if (isHorizontal) {\\n            // clockwise\\n            if (valid(curr.hx+1,curr.hy, grid) && valid(curr.tx+1,curr.ty, grid)) {\\n                res.add(new Snake(curr.hx+1,curr.hy-1,curr.tx,curr.ty));\\n            }\\n        }\\n        else {\\n            if (valid(curr.hx,curr.hy+1, grid) && valid(curr.tx,curr.ty+1, grid)) {\\n                res.add(new Snake(curr.hx-1,curr.hy+1,curr.tx,curr.ty));\\n            }\\n        }\\n        return res;\\n        \\n    }\\n    \\n    public boolean valid(int x, int y, int[][] grid) {\\n        int n = grid.length;\\n        if (x < 0 || y < 0 || x >= n || y >= n || grid[x][y] == 1) return false;\\n        return true;\\n    }\\n    \\n    public boolean win(Snake s, int[][] grid) {\\n        int n = grid.length;\\n        if (s.hx == n-1 && s.hy == n-1 && s.tx == n-1 && s.ty == n-2) {\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    public String convert(int x, int y, int z, int o) {\\n        StringBuilder sb = new StringBuilder();\\n        sb.append(x);\\n        sb.append(y);\\n        sb.append(z);\\n        sb.append(o);\\n        return sb.toString();\\n    }\\n}\\n\\npublic class Snake {\\n    public int hx;\\n    public int hy;\\n    public int tx;\\n    public int ty;\\n    \\n    public Snake(int x1, int y1, int x2, int y2) {\\n        this.hx = x1;\\n        this.hy = y1;\\n        this.tx = x2;\\n        this.ty = y2;\\n    }\\n    \\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 588286,
                "title": "java-short-code-with-explanation-line-by-line-in-comments",
                "content": "```\\nclass Solution {\\n    public boolean isValid(int i, int j, int[][] grid){\\n        if(i < 0 || j < 0 || i > grid.length-1 || j > grid.length-1 || grid[i][j] == 1) return false; \\n        return true;\\n    }\\n   \\n    public boolean isHoriz(int tx, int ty, int hx, int hy){\\n        if ((tx == hx) && (hy == ty + 1)) return true;\\n        return false;\\n    }\\n    \\n    public boolean isVert(int tx, int ty, int hx, int hy){\\n        if ((hx == tx + 1) && (hy == ty)) return true;\\n        return false;\\n    }\\n    \\n    public int minimumMoves(int[][] grid) {\\n        Queue <int []> q = new LinkedList<>();\\n        HashSet<String> visited = new HashSet<>();\\n        // pos 0 - horizontal move, pos 1 - vertical move, pos 2 - clockwise, pos 3 - counter clockwise\\n        int dir[][] = new int[][] {{0, 1, 0, 1}, {1, 0, 1, 0}, {0, 0, 1, -1}, {0, 0, -1, 1}};\\n        int n = grid.length, level = 0;\\n\\n        q.offer(new int[]{0,0,0,1});\\n        visited.add(0 + \",\" + 0 + \",\"+ 0 + \",\" + 1);\\n        \\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            for(int s = 0; s < size; s++){\\n                int [] curr = q.poll();\\n                int tx = curr[0]; //tail x- co-ordinate\\n                int ty = curr[1]; //tail y- co-ordinate\\n                int hx = curr[2]; //head x- co-ordinate\\n                int hy = curr[3]; //head y- co-ordinate\\n                if(tx == n-1 && ty == n-2 && hx == n-1 && hy == n-1) return level; //Reached target state\\n                for(int i = 0; i < 4; i++){\\n                    int ntx = tx + dir[i][0]; // next tail x- co-ordinate\\n                    int nty = ty + dir[i][1]; // next tail y- co-ordinate\\n                    int nhx = hx + dir[i][2]; // next head x- co-ordinate\\n                    int nhy = hy + dir[i][3]; // next head y- co-ordinate\\n                    //If original position is not horizontal and bottom cells are not 0, can\\'t do clockwise. So skip.\\n                    if(i==2 && (!isHoriz(tx, ty, hx, hy) || !isValid(tx+1, ty, grid) || !isValid(hx+1, hy, grid))) continue;\\n                    //If original position is not vertical and bottom cells are not 0, can\\'t do counter clockwise. So skip.\\n                    if(i==3 && (!isVert(tx, ty, hx, hy) || !isValid(tx, ty+1, grid) || !isValid(hx, hy+1, grid))) continue;\\n                    if(!isValid(ntx, nty, grid) || !isValid(nhx, nhy, grid)) continue; // just check validity of next co-ordinates\\n                    if(visited.contains(ntx + \",\" + nty + \",\" + nhx + \",\" + nhy)) continue;\\n                    q.offer(new int[] {ntx,nty,nhx,nhy});\\n                    visited.add(ntx + \",\" + nty + \",\" + nhx + \",\" + nhy);\\n                }\\n            }\\n            level++;\\n        }\\n        \\n        return -1;\\n    }    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isValid(int i, int j, int[][] grid){\\n        if(i < 0 || j < 0 || i > grid.length-1 || j > grid.length-1 || grid[i][j] == 1) return false; \\n        return true;\\n    }\\n   \\n    public boolean isHoriz(int tx, int ty, int hx, int hy){\\n        if ((tx == hx) && (hy == ty + 1)) return true;\\n        return false;\\n    }\\n    \\n    public boolean isVert(int tx, int ty, int hx, int hy){\\n        if ((hx == tx + 1) && (hy == ty)) return true;\\n        return false;\\n    }\\n    \\n    public int minimumMoves(int[][] grid) {\\n        Queue <int []> q = new LinkedList<>();\\n        HashSet<String> visited = new HashSet<>();\\n        // pos 0 - horizontal move, pos 1 - vertical move, pos 2 - clockwise, pos 3 - counter clockwise\\n        int dir[][] = new int[][] {{0, 1, 0, 1}, {1, 0, 1, 0}, {0, 0, 1, -1}, {0, 0, -1, 1}};\\n        int n = grid.length, level = 0;\\n\\n        q.offer(new int[]{0,0,0,1});\\n        visited.add(0 + \",\" + 0 + \",\"+ 0 + \",\" + 1);\\n        \\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            for(int s = 0; s < size; s++){\\n                int [] curr = q.poll();\\n                int tx = curr[0]; //tail x- co-ordinate\\n                int ty = curr[1]; //tail y- co-ordinate\\n                int hx = curr[2]; //head x- co-ordinate\\n                int hy = curr[3]; //head y- co-ordinate\\n                if(tx == n-1 && ty == n-2 && hx == n-1 && hy == n-1) return level; //Reached target state\\n                for(int i = 0; i < 4; i++){\\n                    int ntx = tx + dir[i][0]; // next tail x- co-ordinate\\n                    int nty = ty + dir[i][1]; // next tail y- co-ordinate\\n                    int nhx = hx + dir[i][2]; // next head x- co-ordinate\\n                    int nhy = hy + dir[i][3]; // next head y- co-ordinate\\n                    //If original position is not horizontal and bottom cells are not 0, can\\'t do clockwise. So skip.\\n                    if(i==2 && (!isHoriz(tx, ty, hx, hy) || !isValid(tx+1, ty, grid) || !isValid(hx+1, hy, grid))) continue;\\n                    //If original position is not vertical and bottom cells are not 0, can\\'t do counter clockwise. So skip.\\n                    if(i==3 && (!isVert(tx, ty, hx, hy) || !isValid(tx, ty+1, grid) || !isValid(hx, hy+1, grid))) continue;\\n                    if(!isValid(ntx, nty, grid) || !isValid(nhx, nhy, grid)) continue; // just check validity of next co-ordinates\\n                    if(visited.contains(ntx + \",\" + nty + \",\" + nhx + \",\" + nhy)) continue;\\n                    q.offer(new int[] {ntx,nty,nhx,nhy});\\n                    visited.add(ntx + \",\" + nty + \",\" + nhx + \",\" + nhy);\\n                }\\n            }\\n            level++;\\n        }\\n        \\n        return -1;\\n    }    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 586942,
                "title": "simple-java-bfs-solution-3d",
                "content": "```\\nclass Solution {\\n    //0-horizontal 1-vertical\\n    int[][][] dir = new int[][][]{\\n        {{0,1}, {1,0}, {1,-1}},\\n        {{0,1}, {1,0}, {-1,1}}\\n    };\\n    \\n    private boolean isValid(int[][] grid, int[] st, int action) {\\n        int x = st[0], y = st[1], d = st[2], n = grid.length;\\n        if(d == 0) {\\n            if(action == 0) return y + 1 < n && grid[x][y+1] == 0;\\n            return x + 1 < n && grid[x+1][y] == 0 && grid[x+1][y-1] == 0;\\n        } \\n        if(action == 0 || action == 2) return y + 1 < n && grid[x-1][y+1] == 0 && grid[x][y+1] == 0;\\n        return x + 1 < n && grid[x+1][y] == 0;\\n    }\\n    \\n    public int minimumMoves(int[][] grid) {\\n        int n = grid.length;\\n        boolean[][][] visited = new boolean[n][n][2];\\n        Queue<int[]> que = new LinkedList<>();\\n        que.offer(new int[]{0, 1, 0});\\n        visited[0][1][0] = true;\\n        \\n        int res = 0;\\n        while(!que.isEmpty()) {\\n            for(int size = que.size(); size > 0; size--) {\\n                int[] st = que.poll();\\n                int x = st[0], y = st[1], d = st[2];\\n                if(st[0] == n-1 && st[1] == n-1 && st[2] == 0) return res;\\n                for(int i = 0; i < 3; i++) {\\n                    if(isValid(grid, st, i)) {\\n                        int nx = x + dir[d][i][0], ny = y + dir[d][i][1], nd = i == 2 ? 1 - d : d;\\n                        if(!visited[nx][ny][nd]) {\\n                            visited[nx][ny][nd] = true;\\n                            que.offer(new int[]{nx, ny, nd});\\n                        }\\n                    }\\n                }\\n            }\\n            res++;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    //0-horizontal 1-vertical\\n    int[][][] dir = new int[][][]{\\n        {{0,1}, {1,0}, {1,-1}},\\n        {{0,1}, {1,0}, {-1,1}}\\n    };\\n    \\n    private boolean isValid(int[][] grid, int[] st, int action) {\\n        int x = st[0], y = st[1], d = st[2], n = grid.length;\\n        if(d == 0) {\\n            if(action == 0) return y + 1 < n && grid[x][y+1] == 0;\\n            return x + 1 < n && grid[x+1][y] == 0 && grid[x+1][y-1] == 0;\\n        } \\n        if(action == 0 || action == 2) return y + 1 < n && grid[x-1][y+1] == 0 && grid[x][y+1] == 0;\\n        return x + 1 < n && grid[x+1][y] == 0;\\n    }\\n    \\n    public int minimumMoves(int[][] grid) {\\n        int n = grid.length;\\n        boolean[][][] visited = new boolean[n][n][2];\\n        Queue<int[]> que = new LinkedList<>();\\n        que.offer(new int[]{0, 1, 0});\\n        visited[0][1][0] = true;\\n        \\n        int res = 0;\\n        while(!que.isEmpty()) {\\n            for(int size = que.size(); size > 0; size--) {\\n                int[] st = que.poll();\\n                int x = st[0], y = st[1], d = st[2];\\n                if(st[0] == n-1 && st[1] == n-1 && st[2] == 0) return res;\\n                for(int i = 0; i < 3; i++) {\\n                    if(isValid(grid, st, i)) {\\n                        int nx = x + dir[d][i][0], ny = y + dir[d][i][1], nd = i == 2 ? 1 - d : d;\\n                        if(!visited[nx][ny][nd]) {\\n                            visited[nx][ny][nd] = true;\\n                            que.offer(new int[]{nx, ny, nd});\\n                        }\\n                    }\\n                }\\n            }\\n            res++;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 558092,
                "title": "a-somewhat-long-winded-python-bfs-solution",
                "content": "It\\'s a straightforward breadth-first-search. The difficult part is doing the arithmetic to determine what moves the snake can make from the current possition, and where he ends up. I implemented a few helper functions so that the implementation matches the wording of the problem description as closely as possible.\\n\\n```python\\nclass Solution:\\n    \\n    def minimumMoves(self, grid: List[List[int]]) -> int:\\n        \\n        n           = len(grid)\\n        start_state = ((0, 0), (0, 1))\\n        end_state   = ((n-1, n-2), (n-1, n-1))\\n        frontier    = {start_state}\\n        visited     = {start_state}\\n        num_moves   = 0\\n        N, S, E, W  = (-1, 0), (1, 0), (0, 1), (0, -1)\\n        \\n        def add(cell1, cell2):\\n            i1, j1 = cell1\\n            i2, j2 = cell2\\n            return (i1+i2, j1+j2)\\n        \\n        def blocked(cell):\\n            i, j = cell\\n            return grid[i][j] == 1\\n        \\n        def vertical(state):\\n            tail, head = state\\n            return add(tail, S) == head\\n        \\n        def in_bounds(cell):\\n            i, j = cell\\n            return 0 <= i < n and 0 <= j < n\\n        \\n        def valid(state):\\n            tail, head = state\\n            return (\\n                    in_bounds(tail) and not blocked(tail)\\n                and in_bounds(head) and not blocked(head)\\n            )\\n        \\n        def translations(state):\\n            tail, head  = state\\n            right       = (add(tail, E), add(head, E))\\n            down        = (add(tail, S), add(head, S))\\n            return filter(valid, (right, down))\\n        \\n        def rotations(state):\\n            tail, head = state\\n            a, b    = tail,         add(tail, E)\\n            c, d    = add(tail, S), add(b, S)\\n            if in_bounds(d) and not blocked(d):\\n                rotated = (a, b) if vertical(state) else (a, c)\\n                if valid(rotated):\\n                    yield rotated\\n        \\n        def successors(state):\\n            yield from translations(state)\\n            yield from rotations(state)\\n        \\n        while frontier:\\n            if end_state in frontier:\\n                return num_moves\\n            frontier = {\\n                successor\\n                for state in frontier\\n                for successor in successors(state)\\n                if successor not in visited\\n            }\\n            visited.update(frontier)\\n            num_moves += 1\\n        \\n        return -1\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    \\n    def minimumMoves(self, grid: List[List[int]]) -> int:\\n        \\n        n           = len(grid)\\n        start_state = ((0, 0), (0, 1))\\n        end_state   = ((n-1, n-2), (n-1, n-1))\\n        frontier    = {start_state}\\n        visited     = {start_state}\\n        num_moves   = 0\\n        N, S, E, W  = (-1, 0), (1, 0), (0, 1), (0, -1)\\n        \\n        def add(cell1, cell2):\\n            i1, j1 = cell1\\n            i2, j2 = cell2\\n            return (i1+i2, j1+j2)\\n        \\n        def blocked(cell):\\n            i, j = cell\\n            return grid[i][j] == 1\\n        \\n        def vertical(state):\\n            tail, head = state\\n            return add(tail, S) == head\\n        \\n        def in_bounds(cell):\\n            i, j = cell\\n            return 0 <= i < n and 0 <= j < n\\n        \\n        def valid(state):\\n            tail, head = state\\n            return (\\n                    in_bounds(tail) and not blocked(tail)\\n                and in_bounds(head) and not blocked(head)\\n            )\\n        \\n        def translations(state):\\n            tail, head  = state\\n            right       = (add(tail, E), add(head, E))\\n            down        = (add(tail, S), add(head, S))\\n            return filter(valid, (right, down))\\n        \\n        def rotations(state):\\n            tail, head = state\\n            a, b    = tail,         add(tail, E)\\n            c, d    = add(tail, S), add(b, S)\\n            if in_bounds(d) and not blocked(d):\\n                rotated = (a, b) if vertical(state) else (a, c)\\n                if valid(rotated):\\n                    yield rotated\\n        \\n        def successors(state):\\n            yield from translations(state)\\n            yield from rotations(state)\\n        \\n        while frontier:\\n            if end_state in frontier:\\n                return num_moves\\n            frontier = {\\n                successor\\n                for state in frontier\\n                for successor in successors(state)\\n                if successor not in visited\\n            }\\n            visited.update(frontier)\\n            num_moves += 1\\n        \\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 544074,
                "title": "c-dijkstra",
                "content": "```\\n    int minimumMoves(vector<vector<int>>& grid) {\\n        int row = grid.size(), col = grid[0].size();\\n        set<vector<int>> visited{};\\n        priority_queue<vector<int>, vector<vector<int>>, greater<vector<int>>> dijkstra{};\\n        dijkstra.push({0, 0, 0, 0, 1}); // {dist, (0,0), (0, 1)}\\n        while(!dijkstra.empty()){\\n            auto curr = dijkstra.top();\\n            if(curr[1]==row-1 && curr[2]==col-2 && curr[3]==row-1 && curr[4]==col-1) return curr[0];\\n            dijkstra.pop();\\n            visited.insert(curr);\\n            // to the right\\n            vector<int> ne_pos(curr.begin()+1, curr.end());\\n            auto ne = curr, ne_po = ne_pos;\\n            ++ne_pos[1], ++ne_pos[3], ++ne[0], ++ne[2], ++ne[4];\\n            if(ne_pos[3]<col && !grid[ne_pos[0]][ne_pos[1]] && !grid[ne_pos[2]][ne_pos[3]] && !visited.count(ne_pos)){\\n                dijkstra.push(ne);\\n                visited.insert(ne_pos);\\n            }\\n            // move down\\n            ne = curr;\\n            ne_pos = ne_po;\\n            ++ne_pos[0], ++ne_pos[2], ++ne[0], ++ne[1], ++ne[3];\\n            if(ne_pos[2]<row && !grid[ne_pos[0]][ne_pos[1]] && !grid[ne_pos[2]][ne_pos[3]] && !visited.count(ne_pos)){\\n                dijkstra.push(ne);\\n                visited.insert(ne_pos);\\n            }\\n            // clockwise\\n            if(curr[1]==curr[3]){\\n                ne = curr;\\n                ne_pos = ne_po;\\n                ++ne_pos[2], --ne_pos[3], ++ne[0], ++ne[3], --ne[4];\\n                if(ne_pos[2]<row && !grid[ne_pos[2]][ne_pos[3]] && !grid[ne_pos[2]][ne_pos[3]+1] && !visited.count(ne_pos)){\\n                    dijkstra.push(ne);\\n                    visited.insert(ne_pos);\\n                }\\n            }\\n            // counterclockwise\\n            if(curr[2]==curr[4]){\\n                ne = curr;\\n                ne_pos = ne_po;\\n                --ne_pos[2], ++ne_pos[3], ++ne[0], --ne[3], ++ne[4];\\n                if(ne_pos[3]<col && !grid[ne_pos[2]][ne_pos[3]] && !grid[ne_pos[2]+1][ne_pos[3]] && !visited.count(ne_pos)){\\n                    dijkstra.push(ne);\\n                    visited.insert(ne_pos);\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    int minimumMoves(vector<vector<int>>& grid) {\\n        int row = grid.size(), col = grid[0].size();\\n        set<vector<int>> visited{};\\n        priority_queue<vector<int>, vector<vector<int>>, greater<vector<int>>> dijkstra{};\\n        dijkstra.push({0, 0, 0, 0, 1}); // {dist, (0,0), (0, 1)}\\n        while(!dijkstra.empty()){\\n            auto curr = dijkstra.top();\\n            if(curr[1]==row-1 && curr[2]==col-2 && curr[3]==row-1 && curr[4]==col-1) return curr[0];\\n            dijkstra.pop();\\n            visited.insert(curr);\\n            // to the right\\n            vector<int> ne_pos(curr.begin()+1, curr.end());\\n            auto ne = curr, ne_po = ne_pos;\\n            ++ne_pos[1], ++ne_pos[3], ++ne[0], ++ne[2], ++ne[4];\\n            if(ne_pos[3]<col && !grid[ne_pos[0]][ne_pos[1]] && !grid[ne_pos[2]][ne_pos[3]] && !visited.count(ne_pos)){\\n                dijkstra.push(ne);\\n                visited.insert(ne_pos);\\n            }\\n            // move down\\n            ne = curr;\\n            ne_pos = ne_po;\\n            ++ne_pos[0], ++ne_pos[2], ++ne[0], ++ne[1], ++ne[3];\\n            if(ne_pos[2]<row && !grid[ne_pos[0]][ne_pos[1]] && !grid[ne_pos[2]][ne_pos[3]] && !visited.count(ne_pos)){\\n                dijkstra.push(ne);\\n                visited.insert(ne_pos);\\n            }\\n            // clockwise\\n            if(curr[1]==curr[3]){\\n                ne = curr;\\n                ne_pos = ne_po;\\n                ++ne_pos[2], --ne_pos[3], ++ne[0], ++ne[3], --ne[4];\\n                if(ne_pos[2]<row && !grid[ne_pos[2]][ne_pos[3]] && !grid[ne_pos[2]][ne_pos[3]+1] && !visited.count(ne_pos)){\\n                    dijkstra.push(ne);\\n                    visited.insert(ne_pos);\\n                }\\n            }\\n            // counterclockwise\\n            if(curr[2]==curr[4]){\\n                ne = curr;\\n                ne_pos = ne_po;\\n                --ne_pos[2], ++ne_pos[3], ++ne[0], --ne[3], ++ne[4];\\n                if(ne_pos[3]<col && !grid[ne_pos[2]][ne_pos[3]] && !grid[ne_pos[2]+1][ne_pos[3]] && !visited.count(ne_pos)){\\n                    dijkstra.push(ne);\\n                    visited.insert(ne_pos);\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 533485,
                "title": "java-clean-solution-100-memory",
                "content": "```\\nclass Solution {\\n    public int minimumMoves(int[][] grid) {\\n        Set<Snake> visited = new HashSet<>();\\n        Queue<Pair> queue = new LinkedList<>();\\n        \\n        queue.add(new Pair(0, new Snake(0, 0, true)));\\n        visited.add(new Snake(0, 0, true));\\n        \\n        while (!queue.isEmpty()) {\\n            Pair current = queue.poll();\\n            Snake snake = current.snake;\\n            int moveNumber = current.moveNumber;\\n            \\n            if (isFinish(grid, snake))\\n                return moveNumber;\\n            \\n            Snake[] moves = new Snake[] {\\n                new Snake(snake.x + 1, snake.y, snake.horizontal),\\n                new Snake(snake.x, snake.y + 1, snake.horizontal),\\n                new Snake(snake.x, snake.y, false),\\n                new Snake(snake.x, snake.y, true)\\n            };\\n            \\n            for (Snake snakeMove : moves) {\\n                if (isFree(grid, snakeMove) && !visited.contains(snakeMove)) {\\n                    if (snakeMove.horizontal != snake.horizontal && grid[snake.y+1][snake.x+1] == 1)\\n                        continue;\\n                    \\n                    visited.add(snakeMove);\\n                    queue.add(new Pair(moveNumber + 1, snakeMove));\\n                }\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n    \\n    private boolean isFinish(int[][] grid, Snake snake) {\\n        return snake.horizontal && snake.y == grid.length - 1 && snake.x == grid[0].length - 2;\\n    }\\n    \\n    private boolean isFree(int[][] grid, Snake snake) {        \\n        if (snake.y < 0 || snake.y + (snake.horizontal ? 0 : 1) >= grid.length)\\n            return false;\\n        \\n        if (snake.x < 0 || snake.x + (snake.horizontal ? 1 : 0) >= grid[0].length)\\n            return false;\\n        \\n        if (grid[snake.y][snake.x] == 1)\\n            return false;\\n        \\n        if (grid[snake.y + (snake.horizontal ? 0 : 1)][snake.x + (snake.horizontal ? 1 : 0)] == 1)\\n            return false;\\n        \\n        return true;\\n    }\\n    \\n    private static class Snake {\\n        public int x;\\n        public int y;\\n        public boolean horizontal;\\n        \\n        public Snake(int x, int y, boolean horizontal) {\\n            this.x = x;\\n            this.y = y;\\n            this.horizontal = horizontal;\\n        }\\n        \\n        public boolean equals(Object o) {\\n            if (o == this)\\n                return true;\\n            \\n            if (o == null)\\n                return false;\\n            \\n            if (!(o instanceof Snake))\\n                return false;\\n            \\n            Snake snake = (Snake) o;\\n            return snake.x == x && snake.y == y && snake.horizontal == horizontal;\\n        }\\n        \\n        public int hashCode() {\\n            return Objects.hash(x, y, horizontal);\\n        }\\n        \\n        public String toString() {\\n            return \"{X=\" + x + \",Y=\" + y + \",H=\" + horizontal + \"}\";\\n        }\\n    }\\n    \\n    private static class Pair {\\n        public int moveNumber;\\n        public Snake snake;\\n        \\n        public Pair(int moveNumber, Snake snake) {\\n            this.moveNumber = moveNumber;\\n            this.snake = snake;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minimumMoves(int[][] grid) {\\n        Set<Snake> visited = new HashSet<>();\\n        Queue<Pair> queue = new LinkedList<>();\\n        \\n        queue.add(new Pair(0, new Snake(0, 0, true)));\\n        visited.add(new Snake(0, 0, true));\\n        \\n        while (!queue.isEmpty()) {\\n            Pair current = queue.poll();\\n            Snake snake = current.snake;\\n            int moveNumber = current.moveNumber;\\n            \\n            if (isFinish(grid, snake))\\n                return moveNumber;\\n            \\n            Snake[] moves = new Snake[] {\\n                new Snake(snake.x + 1, snake.y, snake.horizontal),\\n                new Snake(snake.x, snake.y + 1, snake.horizontal),\\n                new Snake(snake.x, snake.y, false),\\n                new Snake(snake.x, snake.y, true)\\n            };\\n            \\n            for (Snake snakeMove : moves) {\\n                if (isFree(grid, snakeMove) && !visited.contains(snakeMove)) {\\n                    if (snakeMove.horizontal != snake.horizontal && grid[snake.y+1][snake.x+1] == 1)\\n                        continue;\\n                    \\n                    visited.add(snakeMove);\\n                    queue.add(new Pair(moveNumber + 1, snakeMove));\\n                }\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n    \\n    private boolean isFinish(int[][] grid, Snake snake) {\\n        return snake.horizontal && snake.y == grid.length - 1 && snake.x == grid[0].length - 2;\\n    }\\n    \\n    private boolean isFree(int[][] grid, Snake snake) {        \\n        if (snake.y < 0 || snake.y + (snake.horizontal ? 0 : 1) >= grid.length)\\n            return false;\\n        \\n        if (snake.x < 0 || snake.x + (snake.horizontal ? 1 : 0) >= grid[0].length)\\n            return false;\\n        \\n        if (grid[snake.y][snake.x] == 1)\\n            return false;\\n        \\n        if (grid[snake.y + (snake.horizontal ? 0 : 1)][snake.x + (snake.horizontal ? 1 : 0)] == 1)\\n            return false;\\n        \\n        return true;\\n    }\\n    \\n    private static class Snake {\\n        public int x;\\n        public int y;\\n        public boolean horizontal;\\n        \\n        public Snake(int x, int y, boolean horizontal) {\\n            this.x = x;\\n            this.y = y;\\n            this.horizontal = horizontal;\\n        }\\n        \\n        public boolean equals(Object o) {\\n            if (o == this)\\n                return true;\\n            \\n            if (o == null)\\n                return false;\\n            \\n            if (!(o instanceof Snake))\\n                return false;\\n            \\n            Snake snake = (Snake) o;\\n            return snake.x == x && snake.y == y && snake.horizontal == horizontal;\\n        }\\n        \\n        public int hashCode() {\\n            return Objects.hash(x, y, horizontal);\\n        }\\n        \\n        public String toString() {\\n            return \"{X=\" + x + \",Y=\" + y + \",H=\" + horizontal + \"}\";\\n        }\\n    }\\n    \\n    private static class Pair {\\n        public int moveNumber;\\n        public Snake snake;\\n        \\n        public Pair(int moveNumber, Snake snake) {\\n            this.moveNumber = moveNumber;\\n            this.snake = snake;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 528333,
                "title": "javascript-bfs",
                "content": "```javascript\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\nvar minimumMoves = function(grid) {\\n    const len = grid.length;\\n    const initPosition = [0, true, 1]\\n    const visited = new Set([initPosition.join()]);\\n\\n    const queue = new Queue();\\n    initPosition.push(0);\\n    queue.enqueue(initPosition)\\n    while (!queue.isEmpty()) {\\n        let [row, isHorizontal, col, numMoves] = queue.dequeue();\\n        if (row + col === len * 2 - 2 && isHorizontal) return numMoves;\\n        numMoves++;\\n        const positions = [];\\n        if (isHorizontal) {\\n            if (grid[row][col + 1] === 0) {\\n                positions.push([row, true, col + 1])\\n            }\\n            if (row + 1 < len && grid[row + 1][col - 1] === 0 && grid[row + 1][col] === 0) {\\n                positions.push([row + 1, true, col])\\n                positions.push([row + 1, false, col - 1]);\\n            }\\n        } else {\\n            if (row + 1 < len && grid[row + 1][col] === 0) {\\n                positions.push([row + 1, false, col]);\\n            }\\n            if (row > 0 && grid[row - 1][col + 1] === 0 && grid[row][col + 1] === 0) {\\n                positions.push([row, false, col + 1]);\\n                positions.push([row - 1, true, col + 1]);\\n            }\\n        }\\n        for (let position of positions) {\\n            const str = position.join();\\n            if (visited.has(str)) continue;\\n            visited.add(str);\\n            position.push(numMoves);\\n            queue.enqueue(position);\\n        }\\n    }\\n    return -1;\\n};\\n\\nclass Queue {\\n    constructor() {\\n        this.head = { next: null };\\n        this.tail = this.head;\\n    }\\n\\n    isEmpty() {\\n        return this.head.next === null;\\n    }\\n\\n    dequeue() {\\n        const { value } = this.head.next;\\n        this.head = this.head.next;\\n        return value;\\n    }\\n\\n    enqueue(value) {\\n        this.tail.next = { value, next: null };\\n        this.tail = this.tail.next;\\n    }\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Breadth-First Search"
                ],
                "code": "```javascript\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\nvar minimumMoves = function(grid) {\\n    const len = grid.length;\\n    const initPosition = [0, true, 1]\\n    const visited = new Set([initPosition.join()]);\\n\\n    const queue = new Queue();\\n    initPosition.push(0);\\n    queue.enqueue(initPosition)\\n    while (!queue.isEmpty()) {\\n        let [row, isHorizontal, col, numMoves] = queue.dequeue();\\n        if (row + col === len * 2 - 2 && isHorizontal) return numMoves;\\n        numMoves++;\\n        const positions = [];\\n        if (isHorizontal) {\\n            if (grid[row][col + 1] === 0) {\\n                positions.push([row, true, col + 1])\\n            }\\n            if (row + 1 < len && grid[row + 1][col - 1] === 0 && grid[row + 1][col] === 0) {\\n                positions.push([row + 1, true, col])\\n                positions.push([row + 1, false, col - 1]);\\n            }\\n        } else {\\n            if (row + 1 < len && grid[row + 1][col] === 0) {\\n                positions.push([row + 1, false, col]);\\n            }\\n            if (row > 0 && grid[row - 1][col + 1] === 0 && grid[row][col + 1] === 0) {\\n                positions.push([row, false, col + 1]);\\n                positions.push([row - 1, true, col + 1]);\\n            }\\n        }\\n        for (let position of positions) {\\n            const str = position.join();\\n            if (visited.has(str)) continue;\\n            visited.add(str);\\n            position.push(numMoves);\\n            queue.enqueue(position);\\n        }\\n    }\\n    return -1;\\n};\\n\\nclass Queue {\\n    constructor() {\\n        this.head = { next: null };\\n        this.tail = this.head;\\n    }\\n\\n    isEmpty() {\\n        return this.head.next === null;\\n    }\\n\\n    dequeue() {\\n        const { value } = this.head.next;\\n        this.head = this.head.next;\\n        return value;\\n    }\\n\\n    enqueue(value) {\\n        this.tail.next = { value, next: null };\\n        this.tail = this.tail.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 511370,
                "title": "java-bfs-solution",
                "content": "```\\nclass Solution {\\n    public int minimumMoves(int[][] grid) {\\n        int n = grid.length, step = 0;\\n        if(grid[n-1][n-1] == 1 || grid[n-1][n-2] == 1) return -1;\\n        Queue<int[]> queue = new LinkedList<>();\\n        boolean[][][] visited = new boolean[n][n][2];\\n        queue.offer(new int[]{0, 0, 0});\\n        visited[0][0][0] = true;\\n        while(!queue.isEmpty()){\\n            int size = queue.size();\\n            for(int i = 0; i < size; i++){\\n                int[] cur = queue.poll();\\n                int x = cur[0], y = cur[1], state = cur[2];\\n                if(x == n - 1 && y == n - 2 && state == 0) return step;\\n                if(state == 0){\\n                    //y+2 here because the snake\\'s length is 2\\n                    if(y + 1 < n - 1 && grid[x][y+2] == 0 && !visited[x][y+1][0]){\\n                        visited[x][y+1][0] = true;\\n                        queue.offer(new int[]{x, y + 1, 0});\\n                    }\\n                    if(x + 1 < n && grid[x + 1][y] == 0 && grid[x+1][y+1]==0){\\n                        if(!visited[x+1][y][0]){\\n                            visited[x+1][y][0] = true;\\n                            queue.offer(new int[]{x+1, y, 0});\\n                        }\\n                        if(!visited[x][y][1]){\\n                            visited[x][y][1] = true;\\n                             queue.offer(new int[]{x, y, 1});\\n                        }\\n                    }\\n                }else{\\n                    //x+2 here because the snake\\'s length is 2\\n                    if(x + 1 < n - 1 && grid[x+2][y] == 0 && !visited[x+1][y][1]){\\n                        visited[x+1][y][1] = true;\\n                        queue.offer(new int[]{x+1, y, 1});\\n                    }\\n                    if(y + 1 < n && grid[x][y+1] == 0 && grid[x+1][y+1]==0){\\n                        if(!visited[x][y+1][1]){\\n                            visited[x][y+1][1] = true;\\n                            queue.offer(new int[]{x, y+1, 1});\\n                        }\\n                        if(!visited[x][y][0]){\\n                            visited[x][y][0] = true;\\n                             queue.offer(new int[]{x, y, 0});\\n                        }\\n                    }\\n                }\\n            }\\n            step++;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minimumMoves(int[][] grid) {\\n        int n = grid.length, step = 0;\\n        if(grid[n-1][n-1] == 1 || grid[n-1][n-2] == 1) return -1;\\n        Queue<int[]> queue = new LinkedList<>();\\n        boolean[][][] visited = new boolean[n][n][2];\\n        queue.offer(new int[]{0, 0, 0});\\n        visited[0][0][0] = true;\\n        while(!queue.isEmpty()){\\n            int size = queue.size();\\n            for(int i = 0; i < size; i++){\\n                int[] cur = queue.poll();\\n                int x = cur[0], y = cur[1], state = cur[2];\\n                if(x == n - 1 && y == n - 2 && state == 0) return step;\\n                if(state == 0){\\n                    //y+2 here because the snake\\'s length is 2\\n                    if(y + 1 < n - 1 && grid[x][y+2] == 0 && !visited[x][y+1][0]){\\n                        visited[x][y+1][0] = true;\\n                        queue.offer(new int[]{x, y + 1, 0});\\n                    }\\n                    if(x + 1 < n && grid[x + 1][y] == 0 && grid[x+1][y+1]==0){\\n                        if(!visited[x+1][y][0]){\\n                            visited[x+1][y][0] = true;\\n                            queue.offer(new int[]{x+1, y, 0});\\n                        }\\n                        if(!visited[x][y][1]){\\n                            visited[x][y][1] = true;\\n                             queue.offer(new int[]{x, y, 1});\\n                        }\\n                    }\\n                }else{\\n                    //x+2 here because the snake\\'s length is 2\\n                    if(x + 1 < n - 1 && grid[x+2][y] == 0 && !visited[x+1][y][1]){\\n                        visited[x+1][y][1] = true;\\n                        queue.offer(new int[]{x+1, y, 1});\\n                    }\\n                    if(y + 1 < n && grid[x][y+1] == 0 && grid[x+1][y+1]==0){\\n                        if(!visited[x][y+1][1]){\\n                            visited[x][y+1][1] = true;\\n                            queue.offer(new int[]{x, y+1, 1});\\n                        }\\n                        if(!visited[x][y][0]){\\n                            visited[x][y][0] = true;\\n                             queue.offer(new int[]{x, y, 0});\\n                        }\\n                    }\\n                }\\n            }\\n            step++;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 509805,
                "title": "i-never-seen-a-red-snake",
                "content": "This is more like a Chinese Lion Dance than a snake :)",
                "solutionTags": [],
                "code": "This is more like a Chinese Lion Dance than a snake :)",
                "codeTag": "Unknown"
            },
            {
                "id": 508727,
                "title": "this-problem-is-ambiguous",
                "content": "1. The description says inital location is [0,0] and [0,1], which sounds like the snake is initially vertical, but the diagram shows the snake is initally horizontal\\n2. Does head/tail matter? If it doesn\\'t matter, then you can do CW or CCW rotations pivot on both coordinates.",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 500477,
                "title": "clean-java-bfs-solution",
                "content": "```\\nclass Solution {\\n    \\n    private static class Pos {\\n        int hr;\\n        int hc;\\n        int tr;\\n        int tc;\\n        \\n        public Pos(int hr, int hc, int tr, int tc) {\\n            this.hr = hr;\\n            this.hc = hc;\\n            this.tr = tr;\\n            this.tc = tc;\\n        }\\n        \\n        @Override\\n        public boolean equals(Object obj) {\\n            if (obj instanceof Pos) {\\n                Pos other = (Pos)obj;\\n                return other.hr == hr && other.hc == hc && other.tr == tr && other.tc == tc;\\n            }\\n            return false;\\n        } \\n        \\n        @Override\\n        public int hashCode() {\\n            return hr * 1000000 + hc * 10000 + tr * 100 + tc;\\n        }\\n    }\\n\\n    //bfs \\n    public int minimumMoves(int[][] grid) {\\n        int n = grid.length;\\n        Pos initial = new Pos(0, 1, 0, 0);\\n        Deque<Pos> deque = new ArrayDeque<>();\\n        deque.add(initial);\\n        Set<Pos> seen = new HashSet<>();\\n        seen.add(initial);\\n        \\n        int level = 0;\\n        while (!deque.isEmpty()) {\\n            int size = deque.size();\\n            while (size-- > 0) {\\n                Pos pos = deque.poll();\\n                if (pos.hr == n - 1 && pos.hc == n - 1 && pos.tr == n - 1 && pos.tc == n - 2) {\\n                    return level;\\n                }\\n\\n                //down \\n                Pos down = new Pos(pos.hr + 1, pos.hc, pos.tr + 1, pos.tc);\\n                if (down.hr < n && down.tr < n && grid[down.hr][down.hc] == 0 && grid[down.tr][down.tc] == 0 && !seen.contains(down)) {\\n                    deque.add(down);\\n                    seen.add(down);\\n                }\\n\\n                //right\\n                Pos right = new Pos(pos.hr, pos.hc + 1, pos.tr, pos.tc + 1);\\n                if (right.hc < n && right.tc < n && grid[right.hr][right.hc] == 0 && grid[right.tr][right.tc] == 0 && !seen.contains(right)) {\\n                    deque.add(right);\\n                    seen.add(right);\\n                }\\n                \\n                //clockwise\\n                if (pos.hr == pos.tr) { //pos is horizontal\\n                    Pos turn = new Pos(pos.tr + 1, pos.tc, pos.tr, pos.tc);\\n                    if (turn.hr < n && grid[pos.hr + 1][pos.hc] == 0 && grid[pos.tr + 1][pos.tc] == 0 && !seen.contains(turn)) {\\n                        deque.add(turn);\\n                        seen.add(turn);\\n                    }\\n                }\\n\\n                //counter clockwise\\n                if (pos.hc == pos.tc) {\\n                    Pos turn = new Pos(pos.tr, pos.tc + 1, pos.tr, pos.tc);\\n                    if (turn.hc < n && grid[pos.hr][pos.hc + 1] == 0 && grid[pos.tr][pos.tc + 1] == 0 && !seen.contains(turn)) {\\n                        deque.add(turn);\\n                        seen.add(turn);\\n                    }\\n                }\\n                \\n            }\\n            level++;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    private static class Pos {\\n        int hr;\\n        int hc;\\n        int tr;\\n        int tc;\\n        \\n        public Pos(int hr, int hc, int tr, int tc) {\\n            this.hr = hr;\\n            this.hc = hc;\\n            this.tr = tr;\\n            this.tc = tc;\\n        }\\n        \\n        @Override\\n        public boolean equals(Object obj) {\\n            if (obj instanceof Pos) {\\n                Pos other = (Pos)obj;\\n                return other.hr == hr && other.hc == hc && other.tr == tr && other.tc == tc;\\n            }\\n            return false;\\n        } \\n        \\n        @Override\\n        public int hashCode() {\\n            return hr * 1000000 + hc * 10000 + tr * 100 + tc;\\n        }\\n    }\\n\\n    //bfs \\n    public int minimumMoves(int[][] grid) {\\n        int n = grid.length;\\n        Pos initial = new Pos(0, 1, 0, 0);\\n        Deque<Pos> deque = new ArrayDeque<>();\\n        deque.add(initial);\\n        Set<Pos> seen = new HashSet<>();\\n        seen.add(initial);\\n        \\n        int level = 0;\\n        while (!deque.isEmpty()) {\\n            int size = deque.size();\\n            while (size-- > 0) {\\n                Pos pos = deque.poll();\\n                if (pos.hr == n - 1 && pos.hc == n - 1 && pos.tr == n - 1 && pos.tc == n - 2) {\\n                    return level;\\n                }\\n\\n                //down \\n                Pos down = new Pos(pos.hr + 1, pos.hc, pos.tr + 1, pos.tc);\\n                if (down.hr < n && down.tr < n && grid[down.hr][down.hc] == 0 && grid[down.tr][down.tc] == 0 && !seen.contains(down)) {\\n                    deque.add(down);\\n                    seen.add(down);\\n                }\\n\\n                //right\\n                Pos right = new Pos(pos.hr, pos.hc + 1, pos.tr, pos.tc + 1);\\n                if (right.hc < n && right.tc < n && grid[right.hr][right.hc] == 0 && grid[right.tr][right.tc] == 0 && !seen.contains(right)) {\\n                    deque.add(right);\\n                    seen.add(right);\\n                }\\n                \\n                //clockwise\\n                if (pos.hr == pos.tr) { //pos is horizontal\\n                    Pos turn = new Pos(pos.tr + 1, pos.tc, pos.tr, pos.tc);\\n                    if (turn.hr < n && grid[pos.hr + 1][pos.hc] == 0 && grid[pos.tr + 1][pos.tc] == 0 && !seen.contains(turn)) {\\n                        deque.add(turn);\\n                        seen.add(turn);\\n                    }\\n                }\\n\\n                //counter clockwise\\n                if (pos.hc == pos.tc) {\\n                    Pos turn = new Pos(pos.tr, pos.tc + 1, pos.tr, pos.tc);\\n                    if (turn.hc < n && grid[pos.hr][pos.hc + 1] == 0 && grid[pos.tr][pos.tc + 1] == 0 && !seen.contains(turn)) {\\n                        deque.add(turn);\\n                        seen.add(turn);\\n                    }\\n                }\\n                \\n            }\\n            level++;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 495950,
                "title": "c-bfs-clean-implementation-with-comment",
                "content": "```\\nclass Solution {\\n    string make_key(vector<int> pos) {\\n        assert (pos.size() == 4);\\n        \\n        int x1 = pos[0], y1 = pos[1];\\n        int x2 = pos[2], y2 = pos[3];\\n        string p1 = to_string(x1) + \",\" + to_string(y1);\\n        string p2 = to_string(x2) + \",\" + to_string(y2);\\n        \\n        // 0,0:1,0\\n        return p1 + \":\" + p2;\\n    }\\npublic:\\n    int minimumMoves(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        \\n        // x1,y1,x2,y2\\n        queue<vector<int>> bfsQ;\\n        bfsQ.push({0, 0, 0, 1});\\n        unordered_set<string> visited;\\n        visited.insert (make_key({0, 0, 0, 1}));\\n        \\n        int moves = 0;\\n        while (!bfsQ.empty()) {\\n            int size = bfsQ.size();\\n            \\n            for (int i = 0; i < size; i++) {\\n                vector<int> pos = bfsQ.front(); bfsQ.pop();\\n                int x1 = pos[0], y1 = pos[1];\\n                int x2 = pos[2], y2 = pos[3];\\n                \\n                //cout << x1 << \" \" << y1 << endl;\\n                // found\\n                if (x1 == n - 1 && y1 == n - 2 &&\\n                    x2 == n - 1 && y2 == n - 1) {\\n                    return moves;\\n                }\\n                \\n                vector<vector<int>> candi = {\\n                    // horizontal\\n                    {x1 + 1, y1, x2 + 1, y2},\\n                    {x1, y1, x1 + 1, y1},\\n                    {x2, y2, x2, y2 + 1},\\n                    // vertical\\n                    {x1, y1 + 1, x2, y2 + 1},\\n                    {x1, y1, x1, y1 + 1},\\n                    {x2, y2, x2 + 1, y2}\\n                };\\n                // move index into candi\\n                vector<int> next;\\n                \\n                // horizontal\\n                if (x1 == x2) {\\n                    // down, clockwise\\n                    if (x1 + 1 < n && grid[x1 + 1][y1] == 0 && grid[x1 + 1][y2] == 0) {\\n                        next.push_back (0);\\n                        next.push_back (1);\\n                    }\\n                    \\n                    // right\\n                    if (y2 + 1 < n && grid[x1][y2 + 1] == 0) {\\n                        next.push_back (2);\\n                    }\\n                }\\n                // vertical\\n                else if (y1 == y2) {\\n                    if (y2 + 1 < n && grid[x1][y1 + 1] == 0 && grid[x2][y2 + 1] == 0) {\\n                        next.push_back (3);\\n                        next.push_back (4);\\n                    }\\n                    \\n                    // down\\n                    if (x2 + 1 < n && grid[x2 + 1][y1] == 0) {\\n                        next.push_back (5);\\n                    }\\n                }\\n                \\n                for (int j = 0; j < next.size(); j++) {\\n                    int idx = next[j];\\n                    string key = make_key(candi[idx]);\\n                    if (visited.find(key) == visited.end()) {\\n                        bfsQ.push (candi[idx]);\\n                        visited.insert (key);\\n                    }\\n                }\\n            }\\n            \\n            moves++;\\n        }\\n        \\n        return -1;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\n    string make_key(vector<int> pos) {\\n        assert (pos.size() == 4);\\n        \\n        int x1 = pos[0], y1 = pos[1];\\n        int x2 = pos[2], y2 = pos[3];\\n        string p1 = to_string(x1) + \",\" + to_string(y1);\\n        string p2 = to_string(x2) + \",\" + to_string(y2);\\n        \\n        // 0,0:1,0\\n        return p1 + \":\" + p2;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 495907,
                "title": "accessible-solutions-with-comments-with-bfs-and-thinking-about-general-questions",
                "content": "```\\npublic class Solution {\\n    public static int n, t1, t2;\\n    static class State {\\n        int ti, tj, hi, hj; // the location of tail and head.        (ti, tj, hi, hj) \\n\\n        public State(int ti, int tj, int hi, int hj) {\\n            this.ti = ti;\\n            this.tj = tj;\\n            this.hi = hi;\\n            this.hj = hj;\\n        }\\n    }\\n\\n    public int minimumMoves(int[][] grid) {\\n\\n        n = grid.length;\\n        t1 = n * n - 2;\\n        t2 = n * n - 1;\\n        Queue<State> q = new LinkedList<>();\\n        HashSet<String> visited = new HashSet<>();\\n        q.offer(new State(0, 0, 0, 1));\\n        visited.add(\"0,1\");\\n        int step = 0;\\n        while (!q.isEmpty()) {\\n            int size = q.size();\\n            for (int k = 0; k < size; k++) {\\n                State cur = q.poll();\\n                //System.out.println(\"tail:\"+cur.ti+\" \"+cur.tj+\" head:\"+cur.hi+\" \"+cur.hj);\\n                if (reachTarget(cur.ti * n + cur.tj, cur.hi * n + cur.hj))\\n                    return step;\\n                //crawl down or right along the direction of snake,  (ti1,tj1,hi1,hj1) is a new state\\n                int hi1 = 2 * cur.hj - cur.tj, hj1 = 2 * cur.hi - cur.ti;\\n                int ti1 = cur.hj, tj1 = cur.hi;\\n                if (isValidPos(hj1, hi1, grid)) {\\n                    String str = (tj1 * n + ti1) + \",\" + (hj1 * n + hi1);\\n                    if (!visited.contains(str)) {\\n                        q.offer(new State(tj1, ti1, hj1, hi1));\\n                        visited.add(str);\\n                    }\\n                }\\n                \\n                //crawl perpendicular to the direction of snake\\n                if(cur.ti==cur.hi){\\n                    \\n                    hi1=cur.hi+1;\\n                    hj1=cur.hj;\\n                    ti1=cur.ti+1;\\n                    tj1=cur.tj;\\n                    if (isValidPos(hi1, hj1, grid) && isValidPos(ti1, tj1, grid)) {\\n                        String str = (ti1 * n + tj1) + \",\" + (hi1 * n + hj1);\\n                        if (!visited.contains(str)) {\\n                            q.offer(new State(ti1, tj1, hi1, hj1));\\n                            visited.add(str);\\n                        }\\n                    }\\n                }\\n                else{\\n                    hi1=cur.hi;\\n                    hj1=cur.hj+1;\\n                    ti1=cur.ti;\\n                    tj1=cur.tj+1;\\n                    if (isValidPos(hi1, hj1, grid) && isValidPos(ti1, tj1, grid)) {\\n                        String str = (ti1 * n + tj1) + \",\" + (hi1 * n + hj1);\\n                        if (!visited.contains(str)) {\\n                            q.offer(new State(ti1, tj1, hi1, hj1));\\n                            visited.add(str);\\n                        }\\n                    }\\n                }\\n                //clockwise rotate\\n                if(cur.hi==cur.ti && cur.hj>cur.tj){\\n                    hi1 = cur.ti + cur.tj - cur.hi;\\n                    hj1 = cur.ti - cur.tj + cur.hj;\\n                    int a = cur.hj-cur.hi+cur.ti, b = cur.hi + cur.hj-cur.tj;\\n                    if (isValidPos(hj1, hi1, grid) && isValidPos(b, a, grid)) {\\n                        String str = (cur.ti * n + cur.tj) + \",\" + (hj1 * n + hi1);\\n                        if (!visited.contains(str)) {\\n                            q.offer(new State(cur.ti, cur.tj, hj1, hi1));\\n                            visited.add(str);\\n                        }\\n                    }\\n                }\\n                \\n                //counterclockwise rotate\\n                if(cur.hj==cur.tj && cur.hi>cur.ti){\\n                    hi1 = cur.tj - cur.ti + cur.hi;\\n                    hj1 = cur.ti + cur.tj - cur.hj;\\n                    int a = cur.hi+cur.hj-cur.ti;\\n                    int b = cur.tj-cur.hj+cur.hi;\\n                    if (isValidPos(hj1, hi1, grid) && isValidPos(b, a, grid)) {\\n                        String str = (cur.ti * n + cur.tj) + \",\" + (hj1 * n + hi1);\\n                        if (!visited.contains(str)) {\\n                            q.offer(new State(cur.ti, cur.tj, hj1, hi1));\\n                            visited.add(str);\\n                        }\\n                    }    \\n                }\\n            }\\n            step++;\\n            //System.out.println(\"step:\" +step);\\n        }\\n        return -1;\\n    }\\n\\n    //check whether llegal location\\n    public static boolean isValidPos(int x, int y, int[][] grid) {\\n        if (x < 0 || x >= n || y < 0 || y >= n || grid[x][y] == 1)\\n            return false;\\n        return true;\\n    }\\n\\n    //chek whether reach the target location\\n    public static boolean reachTarget(int a, int b) {\\n        return (a == t1 && b == t2) || (a == t2 && b == t1);\\n    }\\n}\\n\\n\\n```\\n\\nThis question has been simplified because the snake can only move from top-left to right-down and rotate restrictedly. That is to say the rule of move is different from the move of a real snake. it \\'s very unnatural.\\nTHe following code is my beginning idea that overlooks the given restrictions and hence fails\\n```\\npublic class Solution {\\n\\n    public static int n, t1, t2;\\n    public static int[] d={-1,1};\\n    static class State {\\n        int ti, tj, hi, hj;\\n\\n        public State(int ti, int tj, int hi, int hj) {\\n            this.ti = ti;\\n            this.tj = tj;\\n            this.hi = hi;\\n            this.hj = hj;\\n        }\\n    }\\n\\n    public int minimumMoves(int[][] grid) {\\n\\n        n = grid.length;\\n        t1 = n * n - 2;\\n        t2 = n * n - 1;\\n        Queue<State> q = new LinkedList<>();\\n        HashSet<String> visited = new HashSet<>();\\n        q.offer(new State(0, 0, 0, 1));\\n        visited.add(\"0,1\");\\n        int step = 0;\\n        while (!q.isEmpty()) {\\n            int size = q.size();\\n            for (int k = 0; k < size; k++) {\\n                State cur = q.poll();\\n                //System.out.println(\"tail:\"+cur.ti+\" \"+cur.tj+\" head:\"+cur.hi+\" \"+cur.hj);\\n                if (reachTarget(cur.ti * n + cur.tj, cur.hi * n + cur.hj))\\n                    return step;\\n                //crawl down or right along the direction of snake,  (ti1,tj1,hi1,hj1) is a new state\\n                int hi1 = 2 * cur.hj - cur.tj, hj1 = 2 * cur.hi - cur.ti;\\n                int ti1 = cur.hj, tj1 = cur.hi;\\n                if (isValidPos(hj1, hi1, grid)) {\\n                    String str = (tj1 * n + ti1) + \",\" + (hj1 * n + hi1);\\n                    if (!visited.contains(str)) {\\n                        q.offer(new State(tj1, ti1, hj1, hi1));\\n                        visited.add(str);\\n                    }\\n                }\\n                \\n                //crawl perpendicular to the direction of snake\\n                if(cur.ti==cur.hi){\\n                    for(int i=0;i<2;i++){\\n                        hi1=cur.hi+d[i];\\n                        hj1=cur.hj;\\n                        ti1=cur.ti+d[i];\\n                        tj1=cur.tj;\\n                        if (isValidPos(hi1, hj1, grid) && isValidPos(ti1, tj1, grid)) {\\n                            String str = (ti1 * n + tj1) + \",\" + (hi1 * n + hj1);\\n                            if (!visited.contains(str)) {\\n                                q.offer(new State(ti1, tj1, hi1, hj1));\\n                                visited.add(str);\\n                            }\\n                        }\\n                    }\\n                }\\n                else{\\n                    for(int i=0;i<2;i++){\\n                        hi1=cur.hi;\\n                        hj1=cur.hj+d[i];\\n                        ti1=cur.ti;\\n                        tj1=cur.tj+d[i];\\n                        if (isValidPos(hi1, hj1, grid) && isValidPos(ti1, tj1, grid)) {\\n                            String str = (ti1 * n + tj1) + \",\" + (hi1 * n + hj1);\\n                            if (!visited.contains(str)) {\\n                                q.offer(new State(ti1, tj1, hi1, hj1));\\n                                visited.add(str);\\n                            }\\n                        }\\n                    }\\n                    \\n                }\\n                \\n                \\n                //clockwise rotate  that overlooks directions\\n                hi1 = cur.ti + cur.tj - cur.hi;\\n                hj1 = cur.ti - cur.tj + cur.hj;\\n                int a = cur.hj-cur.hi+cur.ti, b = cur.hi + cur.hj-cur.tj;\\n                if (isValidPos(hj1, hi1, grid) && isValidPos(b, a, grid)) {\\n                    String str = (cur.ti * n + cur.tj) + \",\" + (hj1 * n + hi1);\\n                    if (!visited.contains(str)) {\\n                        q.offer(new State(cur.ti, cur.tj, hj1, hi1));\\n                        visited.add(str);\\n                    }\\n                }\\n                //counterclockwise rotate that overlooks directions\\n                hi1 = cur.tj - cur.ti + cur.hi;\\n                hj1 = cur.ti + cur.tj - cur.hj;\\n                a = cur.hi+cur.hj-cur.ti;\\n                b = cur.tj-cur.hj+cur.hi;\\n                if (isValidPos(hj1, hi1, grid) && isValidPos(b, a, grid)) {\\n                    String str = (cur.ti * n + cur.tj) + \",\" + (hj1 * n + hi1);\\n                    if (!visited.contains(str)) {\\n                        q.offer(new State(cur.ti, cur.tj, hj1, hi1));\\n                        visited.add(str);\\n                    }\\n                }\\n            }\\n            step++;\\n            //System.out.println(\"step:\" +step);\\n        }\\n        return -1;\\n    }\\n\\n    //check location\\n    public static boolean isValidPos(int x, int y, int[][] grid) {\\n        if (x < 0 || x >= n || y < 0 || y >= n || grid[x][y] == 1)\\n            return false;\\n        return true;\\n    }\\n\\n    //chek whether reach the target location\\n    public static boolean reachTarget(int a, int b) {\\n        return (a == t1 && b == t2) || (a == t2 && b == t1);\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public static int n, t1, t2;\\n    static class State {\\n        int ti, tj, hi, hj; // the location of tail and head.        (ti, tj, hi, hj) \\n\\n        public State(int ti, int tj, int hi, int hj) {\\n            this.ti = ti;\\n            this.tj = tj;\\n            this.hi = hi;\\n            this.hj = hj;\\n        }\\n    }\\n\\n    public int minimumMoves(int[][] grid) {\\n\\n        n = grid.length;\\n        t1 = n * n - 2;\\n        t2 = n * n - 1;\\n        Queue<State> q = new LinkedList<>();\\n        HashSet<String> visited = new HashSet<>();\\n        q.offer(new State(0, 0, 0, 1));\\n        visited.add(\"0,1\");\\n        int step = 0;\\n        while (!q.isEmpty()) {\\n            int size = q.size();\\n            for (int k = 0; k < size; k++) {\\n                State cur = q.poll();\\n                //System.out.println(\"tail:\"+cur.ti+\" \"+cur.tj+\" head:\"+cur.hi+\" \"+cur.hj);\\n                if (reachTarget(cur.ti * n + cur.tj, cur.hi * n + cur.hj))\\n                    return step;\\n                //crawl down or right along the direction of snake,  (ti1,tj1,hi1,hj1) is a new state\\n                int hi1 = 2 * cur.hj - cur.tj, hj1 = 2 * cur.hi - cur.ti;\\n                int ti1 = cur.hj, tj1 = cur.hi;\\n                if (isValidPos(hj1, hi1, grid)) {\\n                    String str = (tj1 * n + ti1) + \",\" + (hj1 * n + hi1);\\n                    if (!visited.contains(str)) {\\n                        q.offer(new State(tj1, ti1, hj1, hi1));\\n                        visited.add(str);\\n                    }\\n                }\\n                \\n                //crawl perpendicular to the direction of snake\\n                if(cur.ti==cur.hi){\\n                    \\n                    hi1=cur.hi+1;\\n                    hj1=cur.hj;\\n                    ti1=cur.ti+1;\\n                    tj1=cur.tj;\\n                    if (isValidPos(hi1, hj1, grid) && isValidPos(ti1, tj1, grid)) {\\n                        String str = (ti1 * n + tj1) + \",\" + (hi1 * n + hj1);\\n                        if (!visited.contains(str)) {\\n                            q.offer(new State(ti1, tj1, hi1, hj1));\\n                            visited.add(str);\\n                        }\\n                    }\\n                }\\n                else{\\n                    hi1=cur.hi;\\n                    hj1=cur.hj+1;\\n                    ti1=cur.ti;\\n                    tj1=cur.tj+1;\\n                    if (isValidPos(hi1, hj1, grid) && isValidPos(ti1, tj1, grid)) {\\n                        String str = (ti1 * n + tj1) + \",\" + (hi1 * n + hj1);\\n                        if (!visited.contains(str)) {\\n                            q.offer(new State(ti1, tj1, hi1, hj1));\\n                            visited.add(str);\\n                        }\\n                    }\\n                }\\n                //clockwise rotate\\n                if(cur.hi==cur.ti && cur.hj>cur.tj){\\n                    hi1 = cur.ti + cur.tj - cur.hi;\\n                    hj1 = cur.ti - cur.tj + cur.hj;\\n                    int a = cur.hj-cur.hi+cur.ti, b = cur.hi + cur.hj-cur.tj;\\n                    if (isValidPos(hj1, hi1, grid) && isValidPos(b, a, grid)) {\\n                        String str = (cur.ti * n + cur.tj) + \",\" + (hj1 * n + hi1);\\n                        if (!visited.contains(str)) {\\n                            q.offer(new State(cur.ti, cur.tj, hj1, hi1));\\n                            visited.add(str);\\n                        }\\n                    }\\n                }\\n                \\n                //counterclockwise rotate\\n                if(cur.hj==cur.tj && cur.hi>cur.ti){\\n                    hi1 = cur.tj - cur.ti + cur.hi;\\n                    hj1 = cur.ti + cur.tj - cur.hj;\\n                    int a = cur.hi+cur.hj-cur.ti;\\n                    int b = cur.tj-cur.hj+cur.hi;\\n                    if (isValidPos(hj1, hi1, grid) && isValidPos(b, a, grid)) {\\n                        String str = (cur.ti * n + cur.tj) + \",\" + (hj1 * n + hi1);\\n                        if (!visited.contains(str)) {\\n                            q.offer(new State(cur.ti, cur.tj, hj1, hi1));\\n                            visited.add(str);\\n                        }\\n                    }    \\n                }\\n            }\\n            step++;\\n            //System.out.println(\"step:\" +step);\\n        }\\n        return -1;\\n    }\\n\\n    //check whether llegal location\\n    public static boolean isValidPos(int x, int y, int[][] grid) {\\n        if (x < 0 || x >= n || y < 0 || y >= n || grid[x][y] == 1)\\n            return false;\\n        return true;\\n    }\\n\\n    //chek whether reach the target location\\n    public static boolean reachTarget(int a, int b) {\\n        return (a == t1 && b == t2) || (a == t2 && b == t1);\\n    }\\n}\\n\\n\\n```\n```\\npublic class Solution {\\n\\n    public static int n, t1, t2;\\n    public static int[] d={-1,1};\\n    static class State {\\n        int ti, tj, hi, hj;\\n\\n        public State(int ti, int tj, int hi, int hj) {\\n            this.ti = ti;\\n            this.tj = tj;\\n            this.hi = hi;\\n            this.hj = hj;\\n        }\\n    }\\n\\n    public int minimumMoves(int[][] grid) {\\n\\n        n = grid.length;\\n        t1 = n * n - 2;\\n        t2 = n * n - 1;\\n        Queue<State> q = new LinkedList<>();\\n        HashSet<String> visited = new HashSet<>();\\n        q.offer(new State(0, 0, 0, 1));\\n        visited.add(\"0,1\");\\n        int step = 0;\\n        while (!q.isEmpty()) {\\n            int size = q.size();\\n            for (int k = 0; k < size; k++) {\\n                State cur = q.poll();\\n                //System.out.println(\"tail:\"+cur.ti+\" \"+cur.tj+\" head:\"+cur.hi+\" \"+cur.hj);\\n                if (reachTarget(cur.ti * n + cur.tj, cur.hi * n + cur.hj))\\n                    return step;\\n                //crawl down or right along the direction of snake,  (ti1,tj1,hi1,hj1) is a new state\\n                int hi1 = 2 * cur.hj - cur.tj, hj1 = 2 * cur.hi - cur.ti;\\n                int ti1 = cur.hj, tj1 = cur.hi;\\n                if (isValidPos(hj1, hi1, grid)) {\\n                    String str = (tj1 * n + ti1) + \",\" + (hj1 * n + hi1);\\n                    if (!visited.contains(str)) {\\n                        q.offer(new State(tj1, ti1, hj1, hi1));\\n                        visited.add(str);\\n                    }\\n                }\\n                \\n                //crawl perpendicular to the direction of snake\\n                if(cur.ti==cur.hi){\\n                    for(int i=0;i<2;i++){\\n                        hi1=cur.hi+d[i];\\n                        hj1=cur.hj;\\n                        ti1=cur.ti+d[i];\\n                        tj1=cur.tj;\\n                        if (isValidPos(hi1, hj1, grid) && isValidPos(ti1, tj1, grid)) {\\n                            String str = (ti1 * n + tj1) + \",\" + (hi1 * n + hj1);\\n                            if (!visited.contains(str)) {\\n                                q.offer(new State(ti1, tj1, hi1, hj1));\\n                                visited.add(str);\\n                            }\\n                        }\\n                    }\\n                }\\n                else{\\n                    for(int i=0;i<2;i++){\\n                        hi1=cur.hi;\\n                        hj1=cur.hj+d[i];\\n                        ti1=cur.ti;\\n                        tj1=cur.tj+d[i];\\n                        if (isValidPos(hi1, hj1, grid) && isValidPos(ti1, tj1, grid)) {\\n                            String str = (ti1 * n + tj1) + \",\" + (hi1 * n + hj1);\\n                            if (!visited.contains(str)) {\\n                                q.offer(new State(ti1, tj1, hi1, hj1));\\n                                visited.add(str);\\n                            }\\n                        }\\n                    }\\n                    \\n                }\\n                \\n                \\n                //clockwise rotate  that overlooks directions\\n                hi1 = cur.ti + cur.tj - cur.hi;\\n                hj1 = cur.ti - cur.tj + cur.hj;\\n                int a = cur.hj-cur.hi+cur.ti, b = cur.hi + cur.hj-cur.tj;\\n                if (isValidPos(hj1, hi1, grid) && isValidPos(b, a, grid)) {\\n                    String str = (cur.ti * n + cur.tj) + \",\" + (hj1 * n + hi1);\\n                    if (!visited.contains(str)) {\\n                        q.offer(new State(cur.ti, cur.tj, hj1, hi1));\\n                        visited.add(str);\\n                    }\\n                }\\n                //counterclockwise rotate that overlooks directions\\n                hi1 = cur.tj - cur.ti + cur.hi;\\n                hj1 = cur.ti + cur.tj - cur.hj;\\n                a = cur.hi+cur.hj-cur.ti;\\n                b = cur.tj-cur.hj+cur.hi;\\n                if (isValidPos(hj1, hi1, grid) && isValidPos(b, a, grid)) {\\n                    String str = (cur.ti * n + cur.tj) + \",\" + (hj1 * n + hi1);\\n                    if (!visited.contains(str)) {\\n                        q.offer(new State(cur.ti, cur.tj, hj1, hi1));\\n                        visited.add(str);\\n                    }\\n                }\\n            }\\n            step++;\\n            //System.out.println(\"step:\" +step);\\n        }\\n        return -1;\\n    }\\n\\n    //check location\\n    public static boolean isValidPos(int x, int y, int[][] grid) {\\n        if (x < 0 || x >= n || y < 0 || y >= n || grid[x][y] == 1)\\n            return false;\\n        return true;\\n    }\\n\\n    //chek whether reach the target location\\n    public static boolean reachTarget(int a, int b) {\\n        return (a == t1 && b == t2) || (a == t2 && b == t1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 494022,
                "title": "c-bfs-solution",
                "content": "```\\n    int minimumMoves(vector<vector<int>>& g) {\\n        set<vector<int>> v;\\n        queue<vector<int>> q;\\n        \\n        q.push({0, 0, 0, 1});\\n        v.insert({0, 0, 0, 1});\\n        \\n        int n = g.size();\\n        \\n        vector<int> target = {n-1, n-2, n-1, n-1};\\n        \\n        int step = 0;\\n        while(!q.empty()) {\\n            for(int sz = q.size(); sz > 0; sz--) {\\n                vector<int> t = q.front();\\n                q.pop();\\n                if(t == target) return step;\\n                \\n                if(t[0] == t[2]) {//==\\n                    if(t[3]+1 < n && g[t[2]][t[3]+1] == 0) {//right\\n                        vector<int> t1 = {t[2], t[3], t[2], t[3]+1};\\n                        if(!v.count(t1)) {v.insert(t1); q.push(t1);}\\n                    }\\n                    if(t[0]+1 < n && g[t[0]+1][t[1]] == 0 && g[t[2]+1][t[3]] == 0) {//clock\\n                        vector<int> t2 = {t[0], t[1], t[0]+1, t[1]};\\n                        if(!v.count(t2)) {v.insert(t2); q.push(t2);}\\n                    }\\n                    if(t[0]+1 < n && g[t[0]+1][t[1]] == 0 && g[t[0]+1][t[3]] == 0) {//down\\n                        vector<int> t3 = {t[0]+1, t[1], t[0]+1, t[3]};\\n                        if(!v.count(t3)) {v.insert(t3); q.push(t3);}\\n                    }                    \\n                } else {//||\\n                    if(t[2]+1 < n && g[t[2]+1][t[3]] == 0) {//down\\n                        vector<int> t4 = {t[2], t[3], t[2]+1, t[3]};\\n                        if(!v.count(t4)) {v.insert(t4); q.push(t4);}\\n                    }\\n                    if(t[1]+1 < n && g[t[0]][t[1]+1] == 0 && g[t[2]][t[3]+1] == 0) {//anti clock\\n                        vector<int> t5 = {t[0], t[1], t[0], t[1]+1};\\n                        if(!v.count(t5)) {v.insert(t5); q.push(t5);}\\n                    }\\n                    if(t[1]+1 < n && g[t[0]][t[1]+1] == 0 && g[t[2]][t[3]+1] == 0) {//right\\n                        vector<int> t6 = {t[0], t[1]+1, t[2], t[3]+1};\\n                        if(!v.count(t6)) {v.insert(t6); q.push(t6);}\\n                    }                         \\n                }\\n            }\\n            step++;\\n        }\\n        return -1;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    int minimumMoves(vector<vector<int>>& g) {\\n        set<vector<int>> v;\\n        queue<vector<int>> q;\\n        \\n        q.push({0, 0, 0, 1});\\n        v.insert({0, 0, 0, 1});\\n        \\n        int n = g.size();\\n        \\n        vector<int> target = {n-1, n-2, n-1, n-1};\\n        \\n        int step = 0;\\n        while(!q.empty()) {\\n            for(int sz = q.size(); sz > 0; sz--) {\\n                vector<int> t = q.front();\\n                q.pop();\\n                if(t == target) return step;\\n                \\n                if(t[0] == t[2]) {//==\\n                    if(t[3]+1 < n && g[t[2]][t[3]+1] == 0) {//right\\n                        vector<int> t1 = {t[2], t[3], t[2], t[3]+1};\\n                        if(!v.count(t1)) {v.insert(t1); q.push(t1);}\\n                    }\\n                    if(t[0]+1 < n && g[t[0]+1][t[1]] == 0 && g[t[2]+1][t[3]] == 0) {//clock\\n                        vector<int> t2 = {t[0], t[1], t[0]+1, t[1]};\\n                        if(!v.count(t2)) {v.insert(t2); q.push(t2);}\\n                    }\\n                    if(t[0]+1 < n && g[t[0]+1][t[1]] == 0 && g[t[0]+1][t[3]] == 0) {//down\\n                        vector<int> t3 = {t[0]+1, t[1], t[0]+1, t[3]};\\n                        if(!v.count(t3)) {v.insert(t3); q.push(t3);}\\n                    }                    \\n                } else {//||\\n                    if(t[2]+1 < n && g[t[2]+1][t[3]] == 0) {//down\\n                        vector<int> t4 = {t[2], t[3], t[2]+1, t[3]};\\n                        if(!v.count(t4)) {v.insert(t4); q.push(t4);}\\n                    }\\n                    if(t[1]+1 < n && g[t[0]][t[1]+1] == 0 && g[t[2]][t[3]+1] == 0) {//anti clock\\n                        vector<int> t5 = {t[0], t[1], t[0], t[1]+1};\\n                        if(!v.count(t5)) {v.insert(t5); q.push(t5);}\\n                    }\\n                    if(t[1]+1 < n && g[t[0]][t[1]+1] == 0 && g[t[2]][t[3]+1] == 0) {//right\\n                        vector<int> t6 = {t[0], t[1]+1, t[2], t[3]+1};\\n                        if(!v.count(t6)) {v.insert(t6); q.push(t6);}\\n                    }                         \\n                }\\n            }\\n            step++;\\n        }\\n        return -1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 493668,
                "title": "c-bfs-clear",
                "content": "```\\nclass Solution {\\n\\tstruct State {\\n\\t\\tint tailX, tailY, headX, headY, dist;\\n\\t\\tbool operator==(const State& other) const {\\n\\t\\t\\treturn tailX == other.tailX && headX == other.headX && tailY == other.tailY && headY == other.headY;\\n\\t\\t}\\n\\t};\\n\\tvector<vector<int>> moves = { {0, 1, 0, 1}, {1, 0, 1, 0}, {0, 0, 1, -1}, {0, 0, -1, 1} };\\n\\tclass hashFunction {\\n\\t\\tpublic:\\n\\t\\t\\tsize_t operator()(const State& t) const {\\n\\t\\t\\t\\treturn t.tailX * t.tailY * t.headX * t.headY + t.tailX + t.tailY + t.headX + t.headY;\\n\\t\\t\\t}\\n\\t};\\npublic:\\n\\tint minimumMoves(vector<vector<int>>& grid) {\\n\\t\\tqueue<State> states;\\n\\t\\tunordered_set<State, hashFunction> visited;\\n\\t\\tState endState; int N = grid.size() - 1;\\n\\t\\tendState.tailX = N; endState.tailY = N - 1;\\n\\t\\tendState.headX = N; endState.headY = N;\\n\\t\\tstates.push({ 0,0,0,1,0 }); // (x1, y1, x2, y2, dist)\\n\\t\\tvisited.insert({ 0,0,0,1,0 });\\n\\t\\twhile (!states.empty()) {\\n\\t\\t\\tState curState = states.front(); states.pop();\\n\\t\\t\\tfor (int i = 0; i < 4; i++) {\\n\\t\\t\\t\\tState newNeighbor;\\n\\t\\t\\t\\tnewNeighbor.tailX = moves[i][0] + curState.tailX;\\n\\t\\t\\t\\tnewNeighbor.tailY = moves[i][1] + curState.tailY;\\n\\t\\t\\t\\tnewNeighbor.headX = moves[i][2] + curState.headX;\\n\\t\\t\\t\\tnewNeighbor.headY = moves[i][3] + curState.headY;\\n\\t\\t\\t\\tnewNeighbor.dist = curState.dist + 1;\\n\\t\\t\\t\\tif (inside(newNeighbor, grid, i, N + 1) && !visited.count(newNeighbor)) {\\n\\t\\t\\t\\t\\tstates.push(newNeighbor);\\n\\t\\t\\t\\t\\tvisited.insert(newNeighbor);\\n\\t\\t\\t\\t\\tif (reachedFinish(newNeighbor, endState)) {\\n\\t\\t\\t\\t\\t\\treturn newNeighbor.dist;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn -1;\\n\\t}\\n\\n\\tbool reachedFinish(State& curState, State& endState) {\\n\\t\\treturn (curState == endState);\\n\\t}\\n\\n\\tbool inside(State& curState, vector<vector<int>>& grid, int moveNumber, int N) {\\n\\t\\tif (curState.tailX < 0 || curState.tailX >= N || curState.headX < 0 || curState.headX >= N ||\\n\\t\\t\\tcurState.tailY < 0 || curState.tailY >= N || curState.headY < 0 || curState.headY >= N ||\\n\\t\\t\\tgrid[curState.tailX][curState.tailY] || grid[curState.headX][curState.headY]) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\tif (moveNumber == 2) { // Clockwise\\n\\t\\t\\tif (grid[curState.headX][curState.headY + 1] || curState.tailY != curState.headY) {\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (moveNumber == 3) { // Counter-Clockwise\\n\\t\\t\\tif (grid[curState.headX + 1][curState.headY] || curState.tailY == curState.headY) {\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\tstruct State {\\n\\t\\tint tailX, tailY, headX, headY, dist;\\n\\t\\tbool operator==(const State& other) const {\\n\\t\\t\\treturn tailX == other.tailX && headX == other.headX && tailY == other.tailY && headY == other.headY;\\n\\t\\t}\\n\\t};\\n\\tvector<vector<int>> moves = { {0, 1, 0, 1}, {1, 0, 1, 0}, {0, 0, 1, -1}, {0, 0, -1, 1} };\\n\\tclass hashFunction {\\n\\t\\tpublic:\\n\\t\\t\\tsize_t operator()(const State& t) const {\\n\\t\\t\\t\\treturn t.tailX * t.tailY * t.headX * t.headY + t.tailX + t.tailY + t.headX + t.headY;\\n\\t\\t\\t}\\n\\t};\\npublic:\\n\\tint minimumMoves(vector<vector<int>>& grid) {\\n\\t\\tqueue<State> states;\\n\\t\\tunordered_set<State, hashFunction> visited;\\n\\t\\tState endState; int N = grid.size() - 1;\\n\\t\\tendState.tailX = N; endState.tailY = N - 1;\\n\\t\\tendState.headX = N; endState.headY = N;\\n\\t\\tstates.push({ 0,0,0,1,0 }); // (x1, y1, x2, y2, dist)\\n\\t\\tvisited.insert({ 0,0,0,1,0 });\\n\\t\\twhile (!states.empty()) {\\n\\t\\t\\tState curState = states.front(); states.pop();\\n\\t\\t\\tfor (int i = 0; i < 4; i++) {\\n\\t\\t\\t\\tState newNeighbor;\\n\\t\\t\\t\\tnewNeighbor.tailX = moves[i][0] + curState.tailX;\\n\\t\\t\\t\\tnewNeighbor.tailY = moves[i][1] + curState.tailY;\\n\\t\\t\\t\\tnewNeighbor.headX = moves[i][2] + curState.headX;\\n\\t\\t\\t\\tnewNeighbor.headY = moves[i][3] + curState.headY;\\n\\t\\t\\t\\tnewNeighbor.dist = curState.dist + 1;\\n\\t\\t\\t\\tif (inside(newNeighbor, grid, i, N + 1) && !visited.count(newNeighbor)) {\\n\\t\\t\\t\\t\\tstates.push(newNeighbor);\\n\\t\\t\\t\\t\\tvisited.insert(newNeighbor);\\n\\t\\t\\t\\t\\tif (reachedFinish(newNeighbor, endState)) {\\n\\t\\t\\t\\t\\t\\treturn newNeighbor.dist;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn -1;\\n\\t}\\n\\n\\tbool reachedFinish(State& curState, State& endState) {\\n\\t\\treturn (curState == endState);\\n\\t}\\n\\n\\tbool inside(State& curState, vector<vector<int>>& grid, int moveNumber, int N) {\\n\\t\\tif (curState.tailX < 0 || curState.tailX >= N || curState.headX < 0 || curState.headX >= N ||\\n\\t\\t\\tcurState.tailY < 0 || curState.tailY >= N || curState.headY < 0 || curState.headY >= N ||\\n\\t\\t\\tgrid[curState.tailX][curState.tailY] || grid[curState.headX][curState.headY]) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\tif (moveNumber == 2) { // Clockwise\\n\\t\\t\\tif (grid[curState.headX][curState.headY + 1] || curState.tailY != curState.headY) {\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (moveNumber == 3) { // Counter-Clockwise\\n\\t\\t\\tif (grid[curState.headX + 1][curState.headY] || curState.tailY == curState.headY) {\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 468805,
                "title": "",
                "content": "https://mp.weixin.qq.com/s?__biz=MzUzMDQxNTI4OQ==&mid=2247484355&idx=1&sn=cafe5324e58d0593db4a287cb43356d6&chksm=fa536815cd24e1037b186dd5982f462e7e6db162f0e0f0f84465ede4cc737d560c8f1ac6b065&token=1817182455&lang=zh_CN#rd",
                "solutionTags": [],
                "code": "https://mp.weixin.qq.com/s?__biz=MzUzMDQxNTI4OQ==&mid=2247484355&idx=1&sn=cafe5324e58d0593db4a287cb43356d6&chksm=fa536815cd24e1037b186dd5982f462e7e6db162f0e0f0f84465ede4cc737d560c8f1ac6b065&token=1817182455&lang=zh_CN#rd",
                "codeTag": "Unknown"
            },
            {
                "id": 468573,
                "title": "bfs-python",
                "content": "tried to clean it as much as possible, making it as readable as possible\\n\\n**1.first thing first, a bfs cause the shortest path length is garanteed by it**\\n\\npseudo code\\n```\\n        q = collections.deque([(source,0,0)])\\n        while(q):\\n            u,d,s = q.popleft()\\n            if (u,d)  == (target,0): return s\\n            for v,dv in neighbors(u):\\n                if (v,dv) not in vis:\\n                    vis.add((v,dv))\\n                    q.append((v, dv,s + 1))\\n        return -1\\n```\\n\\n**2. what to put in the queue**\\n\\t1. the head of the snake , the direction either 0 (facing right) or 1 (facing down)\\n\\t2. and the number of steps\\n\\t3. an element from the q looks like ```(i,j), direction, steps to get here```\\n\\na convenient hashmap\\n\\n```\\nh = {}\\n\\n# 0: lambda function to go right\\nh[0] = lambda x: (x[0],x[1] + 1)\\n\\n1: lambda function to go down\\nh[1] = lambda x: (x[0] + 1,x[1])\\n\\n2: lambda function to go left\\nh[2] = lambda x: (x[0],x[1] - 1)\\n\\n3: lambda function to go up\\nh[3] = lambda x: (x[0] - 1,x[1])\\n\\n4: lambda function to go diagonal down and right\\nh[4] = lambda x: (x[0] + 1,x[1] + 1)\\n\\n```\\n\\n**3. two last things**\\n1. either I rotate from direction 0 to 1 , or 1 to 0 (I need the diagonal to be within bounds and == 0)\\n2.  either I slide completely keeping the same position\\n\\n\\n\\n\\n```\\nh = {}\\nh[0] = lambda x: (x[0],x[1] + 1)\\nh[1] = lambda x: (x[0] + 1,x[1])\\nh[2] = lambda x: (x[0],x[1] - 1)\\nh[3] = lambda x: (x[0] - 1,x[1])\\nh[4] = lambda x: (x[0] + 1,x[1] + 1)\\n\\nclass Solution(object):\\n    def minimumMoves(self, grid):\\n        source,target = (0,1), (len(grid)-1, len(grid[0])-1)\\n        vis =  set([(source,0)])\\n\\t\\tq = collections.deque([(source,0,0)])\\n        while(q):\\n            u,d,s = q.popleft()\\n            if (u,d)  == (target,0): return s\\n            for v,dv in self.f(u, d, grid):\\n                if (v,dv) not in vis:\\n                    vis.add((v,dv))\\n                    q.append((v, dv,s + 1))\\n        return -1\\n    \\n    def f(self, u, d, grid):\\n        neighbors = []\\n        pu = h[(d+2) % 4](u)\\n        nd = 1 - d\\n        pb = h[4](pu)\\n        # rotation\\n        if self.inbounds(pb, grid): neighbors.append((h[nd](pu), nd))\\n        \\n        # move\\n        for m in [0,1]:\\n            if self.inbounds(h[m](pu), grid): neighbors.append((h[m](u), d))\\n                \\n        return [(v,dd) for v,dd in neighbors if self.inbounds(v,grid)]\\n    \\n    def inbounds(self, pun, grid):\\n        return 0 <= pun[0] < len(grid) and 0 <= pun[1] < len(grid[0]) and  grid[pun[0]][pun[1]] == 0\\n        \\n```",
                "solutionTags": [],
                "code": "```\\n        q = collections.deque([(source,0,0)])\\n        while(q):\\n            u,d,s = q.popleft()\\n            if (u,d)  == (target,0): return s\\n            for v,dv in neighbors(u):\\n                if (v,dv) not in vis:\\n                    vis.add((v,dv))\\n                    q.append((v, dv,s + 1))\\n        return -1\\n```\n```(i,j), direction, steps to get here```\n```\\nh = {}\\n\\n# 0: lambda function to go right\\nh[0] = lambda x: (x[0],x[1] + 1)\\n\\n1: lambda function to go down\\nh[1] = lambda x: (x[0] + 1,x[1])\\n\\n2: lambda function to go left\\nh[2] = lambda x: (x[0],x[1] - 1)\\n\\n3: lambda function to go up\\nh[3] = lambda x: (x[0] - 1,x[1])\\n\\n4: lambda function to go diagonal down and right\\nh[4] = lambda x: (x[0] + 1,x[1] + 1)\\n\\n```\n```\\nh = {}\\nh[0] = lambda x: (x[0],x[1] + 1)\\nh[1] = lambda x: (x[0] + 1,x[1])\\nh[2] = lambda x: (x[0],x[1] - 1)\\nh[3] = lambda x: (x[0] - 1,x[1])\\nh[4] = lambda x: (x[0] + 1,x[1] + 1)\\n\\nclass Solution(object):\\n    def minimumMoves(self, grid):\\n        source,target = (0,1), (len(grid)-1, len(grid[0])-1)\\n        vis =  set([(source,0)])\\n\\t\\tq = collections.deque([(source,0,0)])\\n        while(q):\\n            u,d,s = q.popleft()\\n            if (u,d)  == (target,0): return s\\n            for v,dv in self.f(u, d, grid):\\n                if (v,dv) not in vis:\\n                    vis.add((v,dv))\\n                    q.append((v, dv,s + 1))\\n        return -1\\n    \\n    def f(self, u, d, grid):\\n        neighbors = []\\n        pu = h[(d+2) % 4](u)\\n        nd = 1 - d\\n        pb = h[4](pu)\\n        # rotation\\n        if self.inbounds(pb, grid): neighbors.append((h[nd](pu), nd))\\n        \\n        # move\\n        for m in [0,1]:\\n            if self.inbounds(h[m](pu), grid): neighbors.append((h[m](u), d))\\n                \\n        return [(v,dd) for v,dd in neighbors if self.inbounds(v,grid)]\\n    \\n    def inbounds(self, pun, grid):\\n        return 0 <= pun[0] < len(grid) and 0 <= pun[1] < len(grid[0]) and  grid[pun[0]][pun[1]] == 0\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 454862,
                "title": "readable-commented-functional-solution-bfs-100-memory",
                "content": "A little long, but very clear. We use (y,x) throughout as the position of the tail as the head position is variable due to rotation.\\n\\nWould be much more succinct if C# supported type aliases on ```ValueTuple<T1,T2>```\\n\\n```\\nenum Rotation { Vertical, Horizontal }\\npublic int MinimumMoves(int[][] grid)\\n{\\n\\tint n = grid.Length;\\n\\tint Get((int y, int x) coords) => grid[coords.y][coords.x];\\n\\n\\t//Whether a coordinate is valid for a snake move.\\n\\tbool IsValid((int y, int x) coord) => coord.x >= 0 && coord.x < n //(1) in bounds\\n\\t\\t\\t\\t\\t\\t\\t\\t   && coord.y >= 0 && coord.y < n\\n\\t\\t\\t\\t\\t\\t\\t\\t   && Get(coord) == 0; //(2) and zero\\n\\t\\t\\t\\t\\t\\t\\t\\t   \\n\\t(int y, int x) MoveRight((int y, int x) c) => (c.y, c.x + 1);\\n\\t(int y, int x) MoveDown((int y, int x) c) => (c.y + 1, c.x);\\n\\t\\n\\t//Gets the second element of the snake\\n\\t(int y, int x) GetSecond(((int y, int x) coord, Rotation r) val) =>\\n\\t\\tval.r == Rotation.Horizontal ? MoveRight(val.coord) : MoveDown(val.coord);\\n\\n\\t//Returns both elements of a snake given a tail and a rotation\\n\\tIEnumerable<(int y, int x)> GetBoth(((int y, int x) coord, Rotation r) val) =>\\n\\t\\tnew[] { val.coord, GetSecond(val) };\\n\\n   //The coordinates which must be valid for a rotation to occur\\n   //NB: a rotation must allow the 3 squares to the bottom right of the tail\\n\\tIEnumerable<(int, int)> Rotations(((int y, int x) c, Rotation r) coord)\\n\\t\\t=> new[] { MoveRight(coord.c), MoveDown(coord.c), MoveRight(MoveDown(coord.c)) };\\n\\t\\n\\t((int, int), Rotation) Rotate(((int y, int x) c, Rotation r) coord)\\n\\t\\t=> (coord.c, coord.r == Rotation.Horizontal ? Rotation.Vertical : Rotation.Horizontal);\\n\\t\\n\\t//a snake must be horizontal, with the tail at the bottom right square\\n\\tbool IsCompleted(((int x, int y) coord, Rotation rotation) coord) => \\n\\t\\tcoord.rotation == Rotation.Horizontal &&\\n\\t\\tGetSecond(coord).y == n - 1 && GetSecond(coord).x == n - 1;\\n\\n   //Returns the next available positions\\n\\tIEnumerable<((int, int), Rotation)> GetNext(((int y, int x) c, Rotation r) pos)\\n\\t{\\n\\t\\tif (GetBoth(pos).Select(MoveRight).All(IsValid)) { yield return (MoveRight(pos.c), pos.r); }\\n\\t\\tif (GetBoth(pos).Select(MoveDown).All(IsValid)) { yield return (MoveDown(pos.c), pos.r); }\\n\\t\\tif (Rotations(pos).All(IsValid)) { yield return Rotate(pos); }\\n\\t}\\n\\n\\tvar initialPosition = ((0, 0), Rotation.Horizontal, 0); //No moves made\\n\\n\\tQueue<((int x, int y), Rotation rotation, int movesMade)> toCheck = new Queue<((int, int), Rotation, int)>(new[] { initialPosition });\\n\\n\\tint ToIndex(Rotation r) => r == Rotation.Horizontal ? 0 : 1;\\n\\t//score array: y, x, rotation\\n\\tvar scores = new int?[n, n, 2];\\n\\tint? GetReturn(((int, int) coord, Rotation r) v) => scores[v.coord.Item1, v.coord.Item2, ToIndex(v.r)];\\n\\tvoid SetReturn(((int, int) coord, Rotation r) v, int value) => scores[v.coord.Item1, v.coord.Item2, ToIndex(v.r)] = value;\\n\\n\\t//BFS using Queue\\n\\twhile (toCheck.Any())\\n\\t{\\n\\t\\tvar (coord, rotation, movesMade) = toCheck.Dequeue();\\n\\t\\tvar score = GetReturn((coord, rotation));\\n\\t\\tif (score != null && score <= movesMade) { continue; }\\n\\n\\t\\tif (IsCompleted((coord, rotation)))\\n\\t\\t{\\n\\t\\t\\treturn movesMade;\\n\\t\\t}\\n\\n\\t\\tSetReturn((coord, rotation), movesMade);\\n\\t\\tforeach (var (newCoord, newRot) in GetNext((coord, rotation)))\\n\\t\\t{\\n\\t\\t\\ttoCheck.Enqueue((newCoord, newRot, movesMade + 1));\\n\\t\\t}\\n\\t}\\n\\treturn -1;\\n}\\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```ValueTuple<T1,T2>```\n```\\nenum Rotation { Vertical, Horizontal }\\npublic int MinimumMoves(int[][] grid)\\n{\\n\\tint n = grid.Length;\\n\\tint Get((int y, int x) coords) => grid[coords.y][coords.x];\\n\\n\\t//Whether a coordinate is valid for a snake move.\\n\\tbool IsValid((int y, int x) coord) => coord.x >= 0 && coord.x < n //(1) in bounds\\n\\t\\t\\t\\t\\t\\t\\t\\t   && coord.y >= 0 && coord.y < n\\n\\t\\t\\t\\t\\t\\t\\t\\t   && Get(coord) == 0; //(2) and zero\\n\\t\\t\\t\\t\\t\\t\\t\\t   \\n\\t(int y, int x) MoveRight((int y, int x) c) => (c.y, c.x + 1);\\n\\t(int y, int x) MoveDown((int y, int x) c) => (c.y + 1, c.x);\\n\\t\\n\\t//Gets the second element of the snake\\n\\t(int y, int x) GetSecond(((int y, int x) coord, Rotation r) val) =>\\n\\t\\tval.r == Rotation.Horizontal ? MoveRight(val.coord) : MoveDown(val.coord);\\n\\n\\t//Returns both elements of a snake given a tail and a rotation\\n\\tIEnumerable<(int y, int x)> GetBoth(((int y, int x) coord, Rotation r) val) =>\\n\\t\\tnew[] { val.coord, GetSecond(val) };\\n\\n   //The coordinates which must be valid for a rotation to occur\\n   //NB: a rotation must allow the 3 squares to the bottom right of the tail\\n\\tIEnumerable<(int, int)> Rotations(((int y, int x) c, Rotation r) coord)\\n\\t\\t=> new[] { MoveRight(coord.c), MoveDown(coord.c), MoveRight(MoveDown(coord.c)) };\\n\\t\\n\\t((int, int), Rotation) Rotate(((int y, int x) c, Rotation r) coord)\\n\\t\\t=> (coord.c, coord.r == Rotation.Horizontal ? Rotation.Vertical : Rotation.Horizontal);\\n\\t\\n\\t//a snake must be horizontal, with the tail at the bottom right square\\n\\tbool IsCompleted(((int x, int y) coord, Rotation rotation) coord) => \\n\\t\\tcoord.rotation == Rotation.Horizontal &&\\n\\t\\tGetSecond(coord).y == n - 1 && GetSecond(coord).x == n - 1;\\n\\n   //Returns the next available positions\\n\\tIEnumerable<((int, int), Rotation)> GetNext(((int y, int x) c, Rotation r) pos)\\n\\t{\\n\\t\\tif (GetBoth(pos).Select(MoveRight).All(IsValid)) { yield return (MoveRight(pos.c), pos.r); }\\n\\t\\tif (GetBoth(pos).Select(MoveDown).All(IsValid)) { yield return (MoveDown(pos.c), pos.r); }\\n\\t\\tif (Rotations(pos).All(IsValid)) { yield return Rotate(pos); }\\n\\t}\\n\\n\\tvar initialPosition = ((0, 0), Rotation.Horizontal, 0); //No moves made\\n\\n\\tQueue<((int x, int y), Rotation rotation, int movesMade)> toCheck = new Queue<((int, int), Rotation, int)>(new[] { initialPosition });\\n\\n\\tint ToIndex(Rotation r) => r == Rotation.Horizontal ? 0 : 1;\\n\\t//score array: y, x, rotation\\n\\tvar scores = new int?[n, n, 2];\\n\\tint? GetReturn(((int, int) coord, Rotation r) v) => scores[v.coord.Item1, v.coord.Item2, ToIndex(v.r)];\\n\\tvoid SetReturn(((int, int) coord, Rotation r) v, int value) => scores[v.coord.Item1, v.coord.Item2, ToIndex(v.r)] = value;\\n\\n\\t//BFS using Queue\\n\\twhile (toCheck.Any())\\n\\t{\\n\\t\\tvar (coord, rotation, movesMade) = toCheck.Dequeue();\\n\\t\\tvar score = GetReturn((coord, rotation));\\n\\t\\tif (score != null && score <= movesMade) { continue; }\\n\\n\\t\\tif (IsCompleted((coord, rotation)))\\n\\t\\t{\\n\\t\\t\\treturn movesMade;\\n\\t\\t}\\n\\n\\t\\tSetReturn((coord, rotation), movesMade);\\n\\t\\tforeach (var (newCoord, newRot) in GetNext((coord, rotation)))\\n\\t\\t{\\n\\t\\t\\ttoCheck.Enqueue((newCoord, newRot, movesMade + 1));\\n\\t\\t}\\n\\t}\\n\\treturn -1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 435478,
                "title": "java-bfs",
                "content": "Idea is simple - keep tracking the head index and horizontal/vertical status and use BFS to find the mininum move. \\n```\\nclass Solution {\\n    public int minimumMoves(int[][] grid) {\\n        int N = grid.length;\\n        int[] start = new int[]{0, 1, 1};\\n        Set<String> visited = new HashSet<>();\\n        LinkedList<int[]> queue = new LinkedList<>();\\n        queue.offerLast(start);\\n        visited.add(\"0,1,1\");\\n        int step = 0;\\n        while(!queue.isEmpty()){\\n            int size = queue.size();\\n            while(size-- > 0){\\n                int[] curr = queue.pollFirst();\\n                // horizontal\\n                int hx = curr[0];\\n                int hy = curr[1];\\n                int ho = curr[2];\\n                if(ho == 1){\\n                    //move right\\n                    if(hy < N - 1 && grid[hx][hy + 1] == 0){\\n                        int[] next = new int[]{hx, hy + 1, 1};\\n                        if(next[0] == N - 1 && next[1] == N - 1){\\n                            return step + 1;\\n                        }\\n                        if(visited.add(\"\" + next[0] + \",\" + next[1] + \",\" + next[2])){\\n                            queue.offerLast(next);    \\n                        }\\n                    }\\n                    if(hx < N - 1 && grid[hx + 1][hy] == 0 && grid[hx + 1][hy - 1] == 0){\\n                        //move down\\n                        int[] next1 = new int[]{hx + 1, hy, 1};\\n                        if(next1[0] == N - 1 && next1[1] == N - 1){\\n                            return step + 1;\\n                        }\\n                        if(visited.add(\"\" + next1[0] + \",\" + next1[1] + \",\" + next1[2])){\\n                            queue.offerLast(next1);    \\n                        }\\n                        //rotate clockwise\\n                        int[] next2 = new int[]{hx + 1, hy - 1, 0};\\n                        if(visited.add(\"\" + next2[0] + \",\" + next2[1] + \",\" + next2[2])){\\n                            queue.offerLast(next2);    \\n                        }\\n                    }\\n                }else{\\n                    //move down\\n                    if(hx < N - 1 && grid[hx + 1][hy] == 0){\\n                        int[] next = new int[]{hx + 1, hy, 0};\\n                        if(visited.add(\"\" + next[0] + \",\" + next[1] + \",\" + next[2])){\\n                            queue.offerLast(next);    \\n                        }\\n                    }\\n                    if(hy < N - 1 && grid[hx][hy + 1] == 0 && grid[hx - 1][hy + 1] == 0){\\n                        //move right\\n                        int[] next1 = new int[]{hx, hy + 1, 0};\\n                        if(visited.add(\"\" + next1[0] + \",\" + next1[1] + \",\" + next1[2])){\\n                            queue.offerLast(next1);    \\n                        }\\n                        //rotate counter-clockwise\\n                        int[] next2 = new int[]{hx - 1, hy + 1, 1};\\n                        if(next2[0] == N - 1 && next2[1] == N - 1){\\n                            return step + 1;\\n                        }\\n                        if(visited.add(\"\" + next2[0] + \",\" + next2[1] + \",\" + next2[2])){\\n                            queue.offerLast(next2);    \\n                        }\\n                    }\\n                }\\n            }\\n            step++;\\n        }\\n        return -1;\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minimumMoves(int[][] grid) {\\n        int N = grid.length;\\n        int[] start = new int[]{0, 1, 1};\\n        Set<String> visited = new HashSet<>();\\n        LinkedList<int[]> queue = new LinkedList<>();\\n        queue.offerLast(start);\\n        visited.add(\"0,1,1\");\\n        int step = 0;\\n        while(!queue.isEmpty()){\\n            int size = queue.size();\\n            while(size-- > 0){\\n                int[] curr = queue.pollFirst();\\n                // horizontal\\n                int hx = curr[0];\\n                int hy = curr[1];\\n                int ho = curr[2];\\n                if(ho == 1){\\n                    //move right\\n                    if(hy < N - 1 && grid[hx][hy + 1] == 0){\\n                        int[] next = new int[]{hx, hy + 1, 1};\\n                        if(next[0] == N - 1 && next[1] == N - 1){\\n                            return step + 1;\\n                        }\\n                        if(visited.add(\"\" + next[0] + \",\" + next[1] + \",\" + next[2])){\\n                            queue.offerLast(next);    \\n                        }\\n                    }\\n                    if(hx < N - 1 && grid[hx + 1][hy] == 0 && grid[hx + 1][hy - 1] == 0){\\n                        //move down\\n                        int[] next1 = new int[]{hx + 1, hy, 1};\\n                        if(next1[0] == N - 1 && next1[1] == N - 1){\\n                            return step + 1;\\n                        }\\n                        if(visited.add(\"\" + next1[0] + \",\" + next1[1] + \",\" + next1[2])){\\n                            queue.offerLast(next1);    \\n                        }\\n                        //rotate clockwise\\n                        int[] next2 = new int[]{hx + 1, hy - 1, 0};\\n                        if(visited.add(\"\" + next2[0] + \",\" + next2[1] + \",\" + next2[2])){\\n                            queue.offerLast(next2);    \\n                        }\\n                    }\\n                }else{\\n                    //move down\\n                    if(hx < N - 1 && grid[hx + 1][hy] == 0){\\n                        int[] next = new int[]{hx + 1, hy, 0};\\n                        if(visited.add(\"\" + next[0] + \",\" + next[1] + \",\" + next[2])){\\n                            queue.offerLast(next);    \\n                        }\\n                    }\\n                    if(hy < N - 1 && grid[hx][hy + 1] == 0 && grid[hx - 1][hy + 1] == 0){\\n                        //move right\\n                        int[] next1 = new int[]{hx, hy + 1, 0};\\n                        if(visited.add(\"\" + next1[0] + \",\" + next1[1] + \",\" + next1[2])){\\n                            queue.offerLast(next1);    \\n                        }\\n                        //rotate counter-clockwise\\n                        int[] next2 = new int[]{hx - 1, hy + 1, 1};\\n                        if(next2[0] == N - 1 && next2[1] == N - 1){\\n                            return step + 1;\\n                        }\\n                        if(visited.add(\"\" + next2[0] + \",\" + next2[1] + \",\" + next2[2])){\\n                            queue.offerLast(next2);    \\n                        }\\n                    }\\n                }\\n            }\\n            step++;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 430385,
                "title": "python-dp",
                "content": "```\\nclass Solution:\\n    def minimumMoves(self, A: List[List[int]]) -> int:\\n        MX=float(\\'inf\\')\\n        R,C=len(A),len(A[0])\\n        dp1=[[MX for _ in range(C)] for _ in range(R)]#horizontal\\n        dp2=[[MX for _ in range(C)] for _ in range(R)]#vertical\\n        dp1[0][0]=0\\n        if A[1][0]==0 and A[1][1]==0:dp2[0][0]=dp1[0][0]+1\\n        for i in range(0,R):\\n            for j in range(0,C):\\n                if A[i][j]==1:continue\\n                # horizonally\\n                if j<C-1 and A[i][j+1]==0:\\n                    dp1[i][j]=min(dp1[i][j],dp1[i][j-1]+1,dp1[i-1][j]+1)\\n                    if i<R-1 and A[i+1][j+1]==0:\\n                        dp1[i][j]=min(dp1[i][j],dp2[i][j]+1)\\n                        if A[i+1][j]==0:dp2[i][j]=min(dp2[i][j],dp1[i][j]+1)\\n                # vertically\\n                if i<R-1 and A[i+1][j]==0:\\n                    dp2[i][j]=min(dp2[i][j],dp2[i][j-1]+1,dp2[i-1][j]+1)\\n                    if j<C-1 and A[i+1][j+1]==0:\\n                        dp2[i][j]=min(dp2[i][j],dp1[i][j]+1)\\n                        if A[i][j+1]==0:dp1[i][j]=min(dp1[i][j],dp2[i][j]+1)\\n        return dp1[R-1][C-2] if dp1[R-1][C-2]!=MX else -1\\n```\\t\\t",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumMoves(self, A: List[List[int]]) -> int:\\n        MX=float(\\'inf\\')\\n        R,C=len(A),len(A[0])\\n        dp1=[[MX for _ in range(C)] for _ in range(R)]#horizontal\\n        dp2=[[MX for _ in range(C)] for _ in range(R)]#vertical\\n        dp1[0][0]=0\\n        if A[1][0]==0 and A[1][1]==0:dp2[0][0]=dp1[0][0]+1\\n        for i in range(0,R):\\n            for j in range(0,C):\\n                if A[i][j]==1:continue\\n                # horizonally\\n                if j<C-1 and A[i][j+1]==0:\\n                    dp1[i][j]=min(dp1[i][j],dp1[i][j-1]+1,dp1[i-1][j]+1)\\n                    if i<R-1 and A[i+1][j+1]==0:\\n                        dp1[i][j]=min(dp1[i][j],dp2[i][j]+1)\\n                        if A[i+1][j]==0:dp2[i][j]=min(dp2[i][j],dp1[i][j]+1)\\n                # vertically\\n                if i<R-1 and A[i+1][j]==0:\\n                    dp2[i][j]=min(dp2[i][j],dp2[i][j-1]+1,dp2[i-1][j]+1)\\n                    if j<C-1 and A[i+1][j+1]==0:\\n                        dp2[i][j]=min(dp2[i][j],dp1[i][j]+1)\\n                        if A[i][j+1]==0:dp1[i][j]=min(dp1[i][j],dp2[i][j]+1)\\n        return dp1[R-1][C-2] if dp1[R-1][C-2]!=MX else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 422375,
                "title": "clarification-needed-for-a-test-case",
                "content": "Having trouble understanding my problem with this test case, it seems correct to me.\\n\\n```\\n[[0,0,0,0,0,0,0,0,0,1]\\n,[0,1,0,0,0,0,0,1,0,1]\\n,[1,0,0,1,0,0,1,0,1,0]\\n,[0,0,0,1,0,1,0,1,0,0]\\n,[0,0,0,0,1,0,0,0,0,1]\\n,[0,0,1,0,0,0,0,0,0,0]\\n,[1,0,0,1,0,0,0,0,0,0]\\n,[0,0,0,0,0,0,0,0,0,0]\\n,[0,0,0,0,0,0,0,0,0,0]\\n,[1,1,0,0,0,0,0,0,0,0]]\\n```\\n\\nMy program says the answer is 21, the test case lists it as -1.\\nWhat is wrong with the solution of\\n\\n```\\n[[0,a,b,0,0,0,0,0,0,1]\\n,[0,1,c,0,0,0,0,1,0,1]\\n,[1,0,d,1,0,0,1,0,1,0]\\n,[0,f,e,1,0,1,0,1,0,0]\\n,[0,g,0,0,1,0,0,0,0,1]\\n,[0,h,1,0,0,0,0,0,0,0]\\n,[1,i,0,1,0,0,0,0,0,0]\\n,[0,j,0,0,0,0,0,0,0,0]\\n,[0,k,l,m,n,o,p,q,r,0]\\n,[1,1,0,0,0,0,0,0,s,0]]\\n```\\n\\nwith rotations on b and i?",
                "solutionTags": [],
                "code": "```\\n[[0,0,0,0,0,0,0,0,0,1]\\n,[0,1,0,0,0,0,0,1,0,1]\\n,[1,0,0,1,0,0,1,0,1,0]\\n,[0,0,0,1,0,1,0,1,0,0]\\n,[0,0,0,0,1,0,0,0,0,1]\\n,[0,0,1,0,0,0,0,0,0,0]\\n,[1,0,0,1,0,0,0,0,0,0]\\n,[0,0,0,0,0,0,0,0,0,0]\\n,[0,0,0,0,0,0,0,0,0,0]\\n,[1,1,0,0,0,0,0,0,0,0]]\\n```\n```\\n[[0,a,b,0,0,0,0,0,0,1]\\n,[0,1,c,0,0,0,0,1,0,1]\\n,[1,0,d,1,0,0,1,0,1,0]\\n,[0,f,e,1,0,1,0,1,0,0]\\n,[0,g,0,0,1,0,0,0,0,1]\\n,[0,h,1,0,0,0,0,0,0,0]\\n,[1,i,0,1,0,0,0,0,0,0]\\n,[0,j,0,0,0,0,0,0,0,0]\\n,[0,k,l,m,n,o,p,q,r,0]\\n,[1,1,0,0,0,0,0,0,s,0]]\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 410532,
                "title": "python-dp-solution-brief-explanation",
                "content": "Explanation:\\n\\n1) DPh[i][j]: number of steps it takes the snake to move from starting position {tail (0, 0), head (1,1)} to {tail (i-1, j-1), head (i-1, j)}, body being in horizontal direction.\\n\\n2) DPv[i][j]: number of steps it takes the snake to move from starting position {tail (0, 0), head (1,1)} to {tail (i-1, j-1), head (i, j-1)}, body being in vertical direction.\\n\\n3) The snake can only face right or down. So DPh and DPv covers all possible situations.\\n\\n4) Finding shortest path on map with obstacles using DP. When doing translational or rotational move, we need to make sure that the relevant cells are empty.\\n\\n```\\nclass Solution:\\n    def minimumMoves(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n        DPh = [[float(\\'inf\\')] * (n+1) for _ in range(n+1)]\\n        DPv = [[float(\\'inf\\')] * (n+1) for _ in range(n+1)]\\n        DPh[1][1] = 0\\n        for i in range(1, n+1):\\n            for j in range(1, n+1):\\n                if grid[i-1][j-1] == 1: continue\\n                if j < n and grid[i-1][j] == 0: \\n                    DPh[i][j] = min(DPh[i][j], DPh[i][j-1]+1, DPh[i-1][j]+1)\\n                if i < n and grid[i][j-1] == 0:\\n                    DPv[i][j] = min(DPv[i][j], DPv[i][j-1]+1, DPv[i-1][j]+1)\\n                if DPh[i][j] + 1 < DPv[i][j] and i<n and grid[i][j-1] == 0 and grid[i][j] == 0:\\n                    DPv[i][j] = DPh[i][j] + 1\\n                if DPv[i][j] + 1 < DPh[i][j] and j<n and grid[i-1][j] == 0 and grid[i][j] == 0:\\n                    DPh[i][j] = DPv[i][j] + 1\\n        return  -1 if DPh[-1][-2] == float(\\'inf\\') else DPh[-1][-2]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumMoves(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n        DPh = [[float(\\'inf\\')] * (n+1) for _ in range(n+1)]\\n        DPv = [[float(\\'inf\\')] * (n+1) for _ in range(n+1)]\\n        DPh[1][1] = 0\\n        for i in range(1, n+1):\\n            for j in range(1, n+1):\\n                if grid[i-1][j-1] == 1: continue\\n                if j < n and grid[i-1][j] == 0: \\n                    DPh[i][j] = min(DPh[i][j], DPh[i][j-1]+1, DPh[i-1][j]+1)\\n                if i < n and grid[i][j-1] == 0:\\n                    DPv[i][j] = min(DPv[i][j], DPv[i][j-1]+1, DPv[i-1][j]+1)\\n                if DPh[i][j] + 1 < DPv[i][j] and i<n and grid[i][j-1] == 0 and grid[i][j] == 0:\\n                    DPv[i][j] = DPh[i][j] + 1\\n                if DPv[i][j] + 1 < DPh[i][j] and j<n and grid[i-1][j] == 0 and grid[i][j] == 0:\\n                    DPh[i][j] = DPv[i][j] + 1\\n        return  -1 if DPh[-1][-2] == float(\\'inf\\') else DPh[-1][-2]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 408339,
                "title": "easy-java",
                "content": "```\\nclass Solution {\\n    \\n    HashSet<String> seen;\\n    \\n    public int minimumMoves(int[][] grid) {\\n        \\n        int n = grid.length;\\n        \\n        if(grid[n-1][n-1]==1||grid[n-1][n-2]==1)\\n            return -1;\\n        \\n        seen = new HashSet<>();   \\n        \\n        Queue<int[][]> q = new LinkedList<>();\\n        \\n        int[][] temp2 = new int[2][];\\n        temp2[0] = new int[]{0,0};\\n        temp2[1] = new int[]{0,1};\\n        seen.add(\"\"+0+0+0+1);\\n        \\n        q.add(temp2);\\n        int steps = 0;\\n     \\n        while(!q.isEmpty())\\n        {\\n            int s = q.size();\\n            \\n            for(int i=0;i<s;i++)\\n            {\\n                int[][] temp = q.poll();\\n                \\n                int[] body = temp[0];\\n                int[] head = temp[1];\\n                \\n                \\n                if(body[0]==n-1 && body[1]==n-2 && head[0]==n-1 && head[1]==n-1)\\n                    return steps;\\n            \\n                if(head[0]==body[0]+1)\\n                {\\n                    if(body[1]+1<n && grid[body[0]][body[1]+1]==0 && grid[body[0]+1][body[1]+1]==0)\\n                    {\\n                        if(!sen(body[0],body[1],body[0],body[1]+1))\\n                        {\\n                        temp = new int[2][];\\n                        temp[0] = body;\\n                        temp[1] = new int[]{body[0],body[1]+1};\\n                        q.add(temp);\\n                        }\\n                    }\\n                    if(head[0]+1<n && grid[head[0]+1][head[1]]==0)\\n                    {\\n                        if(!sen(head[0],head[1],head[0]+1,head[1]))\\n                        {\\n                        temp = new int[2][];\\n                        temp[0] = head;\\n                        temp[1] = new int[]{head[0]+1,head[1]};\\n                        q.add(temp);\\n                        }\\n                    }\\n                    if(head[1]+1<n && grid[head[0]][head[1]+1]==0 && grid[body[0]][body[1]+1]==0)     {\\n                        if(!sen(body[0],body[1]+1,head[0],head[1]+1))\\n                        {\\n                        temp = new int[2][];\\n                        temp[0] = new int[]{body[0],body[1]+1};\\n                        temp[1] = new int[]{head[0],head[1]+1};\\n                        q.add(temp);\\n                        }\\n                    }\\n                }\\n                else\\n                {\\n                    if(body[0]+1<n && grid[body[0]+1][body[1]]==0 && grid[body[0]+1][body[1]+1]==0)\\n                    {\\n                        if(!sen(body[0],body[1],body[0]+1,body[1]))\\n                        {\\n                        temp = new int[2][];\\n                        temp[0] = body;\\n                        temp[1] = new int[]{body[0]+1,body[1]};\\n                        q.add(temp);\\n                        }\\n                    }\\n                    if(head[1]+1<n && grid[head[0]][head[1]+1]==0)\\n                    {\\n                        if(!sen(head[0],head[1],head[0],head[1]+1))\\n                        {\\n                        temp = new int[2][];\\n                        temp[0] = head;\\n                        temp[1] = new int[]{head[0],head[1]+1};\\n                        q.add(temp);\\n                        }\\n                    }\\n                    if(head[0]+1<n && grid[head[0]+1][head[1]]==0 && grid[body[0]+1][body[1]]==0)     {\\n                        if(!sen(body[0]+1,body[1],head[0]+1,head[1]))\\n                        {\\n                        temp = new int[2][];\\n                        temp[0] = new int[]{body[0]+1,body[1]};\\n                        temp[1] = new int[]{head[0]+1,head[1]};\\n                        q.add(temp);\\n                        }\\n                    }\\n                }\\n            }\\n            \\n         \\n            steps++;\\n        }\\n\\n        return -1;\\n    }\\n    \\n    \\n    boolean sen(int a , int b , int c , int d)\\n    {\\n        String temp = \"\"+a+b+c+d;\\n        \\n        if(seen.contains(temp))\\n            return true;\\n        else\\n            seen.add(temp);\\n        \\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    HashSet<String> seen;\\n    \\n    public int minimumMoves(int[][] grid) {\\n        \\n        int n = grid.length;\\n        \\n        if(grid[n-1][n-1]==1||grid[n-1][n-2]==1)\\n            return -1;\\n        \\n        seen = new HashSet<>();   \\n        \\n        Queue<int[][]> q = new LinkedList<>();\\n        \\n        int[][] temp2 = new int[2][];\\n        temp2[0] = new int[]{0,0};\\n        temp2[1] = new int[]{0,1};\\n        seen.add(\"\"+0+0+0+1);\\n        \\n        q.add(temp2);\\n        int steps = 0;\\n     \\n        while(!q.isEmpty())\\n        {\\n            int s = q.size();\\n            \\n            for(int i=0;i<s;i++)\\n            {\\n                int[][] temp = q.poll();\\n                \\n                int[] body = temp[0];\\n                int[] head = temp[1];\\n                \\n                \\n                if(body[0]==n-1 && body[1]==n-2 && head[0]==n-1 && head[1]==n-1)\\n                    return steps;\\n            \\n                if(head[0]==body[0]+1)\\n                {\\n                    if(body[1]+1<n && grid[body[0]][body[1]+1]==0 && grid[body[0]+1][body[1]+1]==0)\\n                    {\\n                        if(!sen(body[0],body[1],body[0],body[1]+1))\\n                        {\\n                        temp = new int[2][];\\n                        temp[0] = body;\\n                        temp[1] = new int[]{body[0],body[1]+1};\\n                        q.add(temp);\\n                        }\\n                    }\\n                    if(head[0]+1<n && grid[head[0]+1][head[1]]==0)\\n                    {\\n                        if(!sen(head[0],head[1],head[0]+1,head[1]))\\n                        {\\n                        temp = new int[2][];\\n                        temp[0] = head;\\n                        temp[1] = new int[]{head[0]+1,head[1]};\\n                        q.add(temp);\\n                        }\\n                    }\\n                    if(head[1]+1<n && grid[head[0]][head[1]+1]==0 && grid[body[0]][body[1]+1]==0)     {\\n                        if(!sen(body[0],body[1]+1,head[0],head[1]+1))\\n                        {\\n                        temp = new int[2][];\\n                        temp[0] = new int[]{body[0],body[1]+1};\\n                        temp[1] = new int[]{head[0],head[1]+1};\\n                        q.add(temp);\\n                        }\\n                    }\\n                }\\n                else\\n                {\\n                    if(body[0]+1<n && grid[body[0]+1][body[1]]==0 && grid[body[0]+1][body[1]+1]==0)\\n                    {\\n                        if(!sen(body[0],body[1],body[0]+1,body[1]))\\n                        {\\n                        temp = new int[2][];\\n                        temp[0] = body;\\n                        temp[1] = new int[]{body[0]+1,body[1]};\\n                        q.add(temp);\\n                        }\\n                    }\\n                    if(head[1]+1<n && grid[head[0]][head[1]+1]==0)\\n                    {\\n                        if(!sen(head[0],head[1],head[0],head[1]+1))\\n                        {\\n                        temp = new int[2][];\\n                        temp[0] = head;\\n                        temp[1] = new int[]{head[0],head[1]+1};\\n                        q.add(temp);\\n                        }\\n                    }\\n                    if(head[0]+1<n && grid[head[0]+1][head[1]]==0 && grid[body[0]+1][body[1]]==0)     {\\n                        if(!sen(body[0]+1,body[1],head[0]+1,head[1]))\\n                        {\\n                        temp = new int[2][];\\n                        temp[0] = new int[]{body[0]+1,body[1]};\\n                        temp[1] = new int[]{head[0]+1,head[1]};\\n                        q.add(temp);\\n                        }\\n                    }\\n                }\\n            }\\n            \\n         \\n            steps++;\\n        }\\n\\n        return -1;\\n    }\\n    \\n    \\n    boolean sen(int a , int b , int c , int d)\\n    {\\n        String temp = \"\"+a+b+c+d;\\n        \\n        if(seen.contains(temp))\\n            return true;\\n        else\\n            seen.add(temp);\\n        \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 396343,
                "title": "c-level-order-traversal",
                "content": "```\\n\\nclass MinimumMoves {\\npublic:\\n    MinimumMoves(vector<vector<int>>& grid) \\n        :   rows(grid.size()), \\n            cols(grid[0].size()), \\n            grid(grid),\\n            visited(rows, vector<vector<bool>>(cols, vector<bool>(2, false))) { }\\n    \\n    int compute() {\\n        int depth = -1;\\n        queue<Location> qu;\\n        \\n        qu.push({0, 0, HORIZONTAL});\\n        visited[0][0][HORIZONTAL] = true;\\n        \\n        while (!qu.empty()) {\\n            int size = qu.size();\\n            \\n            ++depth;\\n            \\n            for (int i = 0; i < size; ++i) {\\n                auto from = qu.front();\\n                \\n                if (get<0>(from) == rows - 1 && get<1>(from) == cols - 2) {\\n                    return depth;\\n                }\\n                \\n                qu.pop();\\n\\n                // Go right\\n                scheduleMove(qu, from, RIGHT);\\n                \\n                 // Go down\\n                scheduleMove(qu, from, DOWN);\\n                \\n                // Rotate clockwise\\n                scheduleMove(qu, from, CLOCKWISE);\\n                \\n                // Rotate anti-clockwise\\n                scheduleMove(qu, from, ANTICLOCKWISE); \\n            }\\n        }\\n        \\n        return -1;\\n    }\\n    \\nprivate:\\n    enum Dir {\\n        HORIZONTAL = 0,\\n        VERTICAL\\n    };\\n    \\n    enum Move {\\n        RIGHT = 0,\\n        DOWN,\\n        CLOCKWISE,\\n        ANTICLOCKWISE\\n    };\\n    \\n    typedef tuple<int, int, Dir> Location;\\n    \\n    void scheduleMove(queue<tuple<int, int, Dir>>& qu, const Location& from, Move move) {\\n        auto [r, c, d] = from;\\n        \\n        switch (move) {\\n            case RIGHT:\\n                ++c;\\n                \\n                if (d == HORIZONTAL) {\\n                    if (c == cols - 1 || grid[r][c + 1] || visited[r][c][d]) {\\n                        return;\\n                    }\\n                } else {\\n                    if (c == cols || grid[r][c] || grid[r + 1][c] || visited[r][c][d]) {\\n                        return;\\n                    }\\n                }\\n                \\n                break;\\n                \\n            case DOWN:\\n                ++r;\\n                \\n                if (d == VERTICAL) { \\n                    if (r == rows - 1 || grid[r + 1][c] || visited[r][c][d]) {\\n                        return;\\n                    }\\n                } else {\\n                    if (r == rows || grid[r][c] || grid[r][c + 1] || visited[r][c][d]) {\\n                        return;\\n                    }\\n                }\\n                \\n                break;\\n                \\n            case CLOCKWISE:\\n                if (d == VERTICAL || r == rows - 1 || grid[r + 1][c] || grid[r + 1][c + 1] || visited[r][c][VERTICAL]) {\\n                    return;\\n                }\\n                \\n                d = VERTICAL;\\n                \\n                break;\\n                \\n            case ANTICLOCKWISE:\\n                if (d == HORIZONTAL || c == cols - 1 || grid[r][c + 1] || grid[r + 1][c + 1] || visited[r][c][HORIZONTAL]) {\\n                    return;\\n                }\\n                \\n                d = HORIZONTAL;\\n                \\n                break;    \\n        }\\n        \\n        visited[r][c][d] = true;\\n        qu.push({r, c, d});\\n    }\\n    \\n    int rows;\\n    int cols;\\n    vector<vector<int>>& grid;\\n    vector<vector<vector<bool>>> visited;\\n};\\n\\nclass Solution {\\npublic:\\n    int minimumMoves(vector<vector<int>>& grid) {\\n        MinimumMoves minimumMovesWrap(grid);\\n        \\n        return minimumMovesWrap.compute();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass MinimumMoves {\\npublic:\\n    MinimumMoves(vector<vector<int>>& grid) \\n        :   rows(grid.size()), \\n            cols(grid[0].size()), \\n            grid(grid),\\n            visited(rows, vector<vector<bool>>(cols, vector<bool>(2, false))) { }\\n    \\n    int compute() {\\n        int depth = -1;\\n        queue<Location> qu;\\n        \\n        qu.push({0, 0, HORIZONTAL});\\n        visited[0][0][HORIZONTAL] = true;\\n        \\n        while (!qu.empty()) {\\n            int size = qu.size();\\n            \\n            ++depth;\\n            \\n            for (int i = 0; i < size; ++i) {\\n                auto from = qu.front();\\n                \\n                if (get<0>(from) == rows - 1 && get<1>(from) == cols - 2) {\\n                    return depth;\\n                }\\n                \\n                qu.pop();\\n\\n                // Go right\\n                scheduleMove(qu, from, RIGHT);\\n                \\n                 // Go down\\n                scheduleMove(qu, from, DOWN);\\n                \\n                // Rotate clockwise\\n                scheduleMove(qu, from, CLOCKWISE);\\n                \\n                // Rotate anti-clockwise\\n                scheduleMove(qu, from, ANTICLOCKWISE); \\n            }\\n        }\\n        \\n        return -1;\\n    }\\n    \\nprivate:\\n    enum Dir {\\n        HORIZONTAL = 0,\\n        VERTICAL\\n    };\\n    \\n    enum Move {\\n        RIGHT = 0,\\n        DOWN,\\n        CLOCKWISE,\\n        ANTICLOCKWISE\\n    };\\n    \\n    typedef tuple<int, int, Dir> Location;\\n    \\n    void scheduleMove(queue<tuple<int, int, Dir>>& qu, const Location& from, Move move) {\\n        auto [r, c, d] = from;\\n        \\n        switch (move) {\\n            case RIGHT:\\n                ++c;\\n                \\n                if (d == HORIZONTAL) {\\n                    if (c == cols - 1 || grid[r][c + 1] || visited[r][c][d]) {\\n                        return;\\n                    }\\n                } else {\\n                    if (c == cols || grid[r][c] || grid[r + 1][c] || visited[r][c][d]) {\\n                        return;\\n                    }\\n                }\\n                \\n                break;\\n                \\n            case DOWN:\\n                ++r;\\n                \\n                if (d == VERTICAL) { \\n                    if (r == rows - 1 || grid[r + 1][c] || visited[r][c][d]) {\\n                        return;\\n                    }\\n                } else {\\n                    if (r == rows || grid[r][c] || grid[r][c + 1] || visited[r][c][d]) {\\n                        return;\\n                    }\\n                }\\n                \\n                break;\\n                \\n            case CLOCKWISE:\\n                if (d == VERTICAL || r == rows - 1 || grid[r + 1][c] || grid[r + 1][c + 1] || visited[r][c][VERTICAL]) {\\n                    return;\\n                }\\n                \\n                d = VERTICAL;\\n                \\n                break;\\n                \\n            case ANTICLOCKWISE:\\n                if (d == HORIZONTAL || c == cols - 1 || grid[r][c + 1] || grid[r + 1][c + 1] || visited[r][c][HORIZONTAL]) {\\n                    return;\\n                }\\n                \\n                d = HORIZONTAL;\\n                \\n                break;    \\n        }\\n        \\n        visited[r][c][d] = true;\\n        qu.push({r, c, d});\\n    }\\n    \\n    int rows;\\n    int cols;\\n    vector<vector<int>>& grid;\\n    vector<vector<vector<bool>>> visited;\\n};\\n\\nclass Solution {\\npublic:\\n    int minimumMoves(vector<vector<int>>& grid) {\\n        MinimumMoves minimumMovesWrap(grid);\\n        \\n        return minimumMovesWrap.compute();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 394435,
                "title": "c-bfs-easy-approach-but-time-limit-block-36-42-test-cases-passed",
                "content": "After I get the problem exactly, I changed my code like this. but still can\\'t pass all test cases. who can give some me some advice?  thanks a millions time.\\n```\\n public int MinimumMoves(int[][] grid) {\\n        int row = grid.Length;\\n        int col = grid[0].Length;\\n        var visited = new HashSet<Tuple<string, int>>();\\n        var station = new HashSet<Tuple<string, int>>();\\n        station.Add(new Tuple<string, int>(\"R\", 1));\\n        var dest = new Tuple<string, int>(\"R\", row * col - 1);\\n        int step = 0;\\n        while (station.Count > 0)\\n        {\\n            step += 1;\\n            var newstation = new HashSet<Tuple<string, int>>();\\n            foreach (var snake in station)\\n            {\\n                int head = snake.Item2;\\n                int r = head / row;\\n                int c = head % row;\\n                string dir = snake.Item1;\\n\\n                if (dir == \"R\")\\n                {\\n                    //right\\n                    if (c + 1 < col && grid[r][c + 1] == 0)\\n                    {\\n                        newstation.Add(new Tuple<string, int>(\"R\", head + 1));\\n                    }\\n                  \\n                    //down clock\\n                    if (r + 1 < row)\\n                    {\\n                        if (grid[r + 1][c] == 0 && grid[r + 1][c - 1] == 0)\\n                        {\\n                            newstation.Add(new Tuple<string, int>(\"R\", head + col));\\n                            newstation.Add(new Tuple<string, int>(\"D\", head + col - 1));\\n                        }\\n                    }\\n                }              \\n                //down\\n                else\\n                {                   \\n                    //down\\n                    if (r + 1 < row && grid[r + 1][c] == 0)\\n                    {\\n                        newstation.Add(new Tuple<string, int>(\"D\", head + col));\\n                    }\\n                    //right counterclock\\n                    if (c + 1 < col && grid[r][c + 1] == 0 && grid[r - 1][c + 1] == 0)\\n                    {\\n                        newstation.Add(new Tuple<string, int>(\"D\", head + 1));\\n                        newstation.Add(new Tuple<string, int>(\"R\", head - col + 1));\\n                    }\\n                }\\n                if (newstation.Contains(dest)) return step;\\n                else {\\n                    visited.Add(snake);\\n                }\\n            }              \\n            station = newstation.Except(visited).ToHashSet();\\n        }\\n        return -1;            \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n public int MinimumMoves(int[][] grid) {\\n        int row = grid.Length;\\n        int col = grid[0].Length;\\n        var visited = new HashSet<Tuple<string, int>>();\\n        var station = new HashSet<Tuple<string, int>>();\\n        station.Add(new Tuple<string, int>(\"R\", 1));\\n        var dest = new Tuple<string, int>(\"R\", row * col - 1);\\n        int step = 0;\\n        while (station.Count > 0)\\n        {\\n            step += 1;\\n            var newstation = new HashSet<Tuple<string, int>>();\\n            foreach (var snake in station)\\n            {\\n                int head = snake.Item2;\\n                int r = head / row;\\n                int c = head % row;\\n                string dir = snake.Item1;\\n\\n                if (dir == \"R\")\\n                {\\n                    //right\\n                    if (c + 1 < col && grid[r][c + 1] == 0)\\n                    {\\n                        newstation.Add(new Tuple<string, int>(\"R\", head + 1));\\n                    }\\n                  \\n                    //down clock\\n                    if (r + 1 < row)\\n                    {\\n                        if (grid[r + 1][c] == 0 && grid[r + 1][c - 1] == 0)\\n                        {\\n                            newstation.Add(new Tuple<string, int>(\"R\", head + col));\\n                            newstation.Add(new Tuple<string, int>(\"D\", head + col - 1));\\n                        }\\n                    }\\n                }              \\n                //down\\n                else\\n                {                   \\n                    //down\\n                    if (r + 1 < row && grid[r + 1][c] == 0)\\n                    {\\n                        newstation.Add(new Tuple<string, int>(\"D\", head + col));\\n                    }\\n                    //right counterclock\\n                    if (c + 1 < col && grid[r][c + 1] == 0 && grid[r - 1][c + 1] == 0)\\n                    {\\n                        newstation.Add(new Tuple<string, int>(\"D\", head + 1));\\n                        newstation.Add(new Tuple<string, int>(\"R\", head - col + 1));\\n                    }\\n                }\\n                if (newstation.Contains(dest)) return step;\\n                else {\\n                    visited.Add(snake);\\n                }\\n            }              \\n            station = newstation.Except(visited).ToHashSet();\\n        }\\n        return -1;            \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 394194,
                "title": "my-crazy-bfs-javascript-solution-without-visited-map-set-100-ms",
                "content": "Modifying ```grid``` only in two cases: when rotating (prevent loop), in other cases we moving right or down (no need to do anything).\\n```\\nvar minimumMoves = function(grid) {\\n    var min = Number.MAX_VALUE;\\n    var finishRowHead = grid.length - 1;\\n    var finishColHead = finishRowHead;\\n    var finishRowBody = finishRowHead;\\n    var finishColBody = finishRowHead - 1;\\n    var lastIndex = finishRowHead;\\n    var stack = [{ rowHead: 0, colHead: 1, rowBody: 0, colBody: 0, step: 0 }];\\n    var rowHead, colHead, rowBody, colBody, step;\\n    var next;\\n    var pos;\\n    \\n    while (stack.length) {\\n        pos = stack.shift();\\n        rowHead = pos.rowHead;\\n        colHead = pos.colHead;\\n        rowBody = pos.rowBody;\\n        colBody = pos.colBody;\\n        step = pos.step;\\n        \\n        if (rowHead === finishRowHead && colHead === finishColHead && rowBody === finishRowBody && colBody === finishColBody) {\\n            min = step;\\n            break;\\n        }\\n        \\n        step++;\\n        if (rowHead === rowBody) { // horizontal\\n            if (colHead !== lastIndex && grid[rowHead][(next = colHead + 1)] === 0) {\\n                stack.push({ rowHead: rowHead, colHead: next, rowBody: rowBody, colBody: colHead, step: step }); // right\\n            }\\n            if (rowHead !== lastIndex && grid[(next = rowHead + 1)][colHead] === 0 && grid[next][colBody] === 0) {\\n                stack.push({ rowHead: next, colHead: colHead, rowBody: next, colBody: colBody, step: step }); // down\\n                grid[next][colBody] = 1;\\n                stack.push({ rowHead: next, colHead: colBody, rowBody: rowBody, colBody: colBody, step: step }); // rotate\\n            }\\n        } else { // vertical\\n            if (rowHead !== lastIndex && grid[(next = rowHead + 1)][colHead] === 0) {\\n                stack.push({ rowHead: next, colHead: colHead, rowBody: rowHead, colBody: colBody, step: step }); // down\\n            }\\n            if (colHead !== lastIndex && grid[rowHead][(next = colHead + 1)] === 0 && grid[rowBody][next] === 0) {\\n                stack.push({ rowHead: rowHead, colHead: next, rowBody: rowBody, colBody: next, step: step }); // right\\n                grid[rowBody][next] = 1;\\n                stack.push({ rowHead: rowBody, colHead: next, rowBody: rowBody, colBody: colBody, step: step }); // rotate\\n            }\\n        }\\n    };\\n    \\n    return min === Number.MAX_VALUE ? -1 : min;\\n};\\n```\\nTested using:\\n```\\n[[0,0,0,0,0,1],[1,1,0,0,1,0],[0,0,0,0,1,1],[0,0,1,0,1,0],[0,1,1,0,0,0],[0,1,1,0,0,0]]\\n[[0,0,1,1,1,1],[0,0,0,0,1,1],[1,1,0,0,0,1],[1,1,1,0,0,1],[1,1,1,0,0,1],[1,1,1,0,0,0]]\\n[[0,0,1,1,1,1],[0,0,0,0,1,1],[1,1,0,0,0,1],[1,1,1,0,0,1],[1,1,1,0,0,1],[1,1,1,0,0,1]]\\n[[0,0,0,0,0,0,0,1,0,0,1,0,0,0,0],[1,0,0,0,0,1,0,0,0,0,0,0,1,0,0],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[0,0,1,0,1,0,0,0,0,1,0,0,1,0,0],[0,0,0,0,0,0,0,1,0,0,0,0,0,1,0],[1,0,0,0,1,0,0,0,0,0,0,0,1,0,1],[1,0,0,0,0,0,0,0,0,0,0,1,0,1,0],[0,0,0,0,0,0,0,0,0,0,0,0,1,0,0],[1,0,0,0,0,0,1,0,0,0,0,0,1,1,0],[0,0,0,0,0,0,0,0,0,0,0,0,1,1,0],[0,1,0,0,1,0,1,0,0,0,1,0,1,1,0],[0,1,0,1,1,0,0,0,0,0,1,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,1,1,1,0,0,0,1,0,1,0,0],[0,0,0,0,0,1,0,0,1,0,0,1,0,0,0]]\\n[[0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,1,0,0,1,0],[0,1,0,0,1,0,1,1,0,0,0,1,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,1,0],[0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1],[0,1,0,0,1,0,1,0,0,0,0,0,0,0,0,0,1,0,1,1],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0],[1,0,0,0,0,0,0,1,0,0,1,0,0,0,1,1,0,0,1,1],[0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0],[0,0,0,0,0,0,0,1,0,0,0,0,1,0,1,1,0,0,0,0],[0,0,0,0,1,1,1,1,0,0,0,0,1,1,0,0,0,0,1,0],[1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,1,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0,1,1,0,0,1,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,1,0,0,1,1,0,0,0,1,0,0,0,0,1,0],[0,0,1,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0]]\\n```",
                "solutionTags": [],
                "code": "```grid```\n```\\nvar minimumMoves = function(grid) {\\n    var min = Number.MAX_VALUE;\\n    var finishRowHead = grid.length - 1;\\n    var finishColHead = finishRowHead;\\n    var finishRowBody = finishRowHead;\\n    var finishColBody = finishRowHead - 1;\\n    var lastIndex = finishRowHead;\\n    var stack = [{ rowHead: 0, colHead: 1, rowBody: 0, colBody: 0, step: 0 }];\\n    var rowHead, colHead, rowBody, colBody, step;\\n    var next;\\n    var pos;\\n    \\n    while (stack.length) {\\n        pos = stack.shift();\\n        rowHead = pos.rowHead;\\n        colHead = pos.colHead;\\n        rowBody = pos.rowBody;\\n        colBody = pos.colBody;\\n        step = pos.step;\\n        \\n        if (rowHead === finishRowHead && colHead === finishColHead && rowBody === finishRowBody && colBody === finishColBody) {\\n            min = step;\\n            break;\\n        }\\n        \\n        step++;\\n        if (rowHead === rowBody) { // horizontal\\n            if (colHead !== lastIndex && grid[rowHead][(next = colHead + 1)] === 0) {\\n                stack.push({ rowHead: rowHead, colHead: next, rowBody: rowBody, colBody: colHead, step: step }); // right\\n            }\\n            if (rowHead !== lastIndex && grid[(next = rowHead + 1)][colHead] === 0 && grid[next][colBody] === 0) {\\n                stack.push({ rowHead: next, colHead: colHead, rowBody: next, colBody: colBody, step: step }); // down\\n                grid[next][colBody] = 1;\\n                stack.push({ rowHead: next, colHead: colBody, rowBody: rowBody, colBody: colBody, step: step }); // rotate\\n            }\\n        } else { // vertical\\n            if (rowHead !== lastIndex && grid[(next = rowHead + 1)][colHead] === 0) {\\n                stack.push({ rowHead: next, colHead: colHead, rowBody: rowHead, colBody: colBody, step: step }); // down\\n            }\\n            if (colHead !== lastIndex && grid[rowHead][(next = colHead + 1)] === 0 && grid[rowBody][next] === 0) {\\n                stack.push({ rowHead: rowHead, colHead: next, rowBody: rowBody, colBody: next, step: step }); // right\\n                grid[rowBody][next] = 1;\\n                stack.push({ rowHead: rowBody, colHead: next, rowBody: rowBody, colBody: colBody, step: step }); // rotate\\n            }\\n        }\\n    };\\n    \\n    return min === Number.MAX_VALUE ? -1 : min;\\n};\\n```\n```\\n[[0,0,0,0,0,1],[1,1,0,0,1,0],[0,0,0,0,1,1],[0,0,1,0,1,0],[0,1,1,0,0,0],[0,1,1,0,0,0]]\\n[[0,0,1,1,1,1],[0,0,0,0,1,1],[1,1,0,0,0,1],[1,1,1,0,0,1],[1,1,1,0,0,1],[1,1,1,0,0,0]]\\n[[0,0,1,1,1,1],[0,0,0,0,1,1],[1,1,0,0,0,1],[1,1,1,0,0,1],[1,1,1,0,0,1],[1,1,1,0,0,1]]\\n[[0,0,0,0,0,0,0,1,0,0,1,0,0,0,0],[1,0,0,0,0,1,0,0,0,0,0,0,1,0,0],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[0,0,1,0,1,0,0,0,0,1,0,0,1,0,0],[0,0,0,0,0,0,0,1,0,0,0,0,0,1,0],[1,0,0,0,1,0,0,0,0,0,0,0,1,0,1],[1,0,0,0,0,0,0,0,0,0,0,1,0,1,0],[0,0,0,0,0,0,0,0,0,0,0,0,1,0,0],[1,0,0,0,0,0,1,0,0,0,0,0,1,1,0],[0,0,0,0,0,0,0,0,0,0,0,0,1,1,0],[0,1,0,0,1,0,1,0,0,0,1,0,1,1,0],[0,1,0,1,1,0,0,0,0,0,1,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,1,1,1,0,0,0,1,0,1,0,0],[0,0,0,0,0,1,0,0,1,0,0,1,0,0,0]]\\n[[0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,1,0,0,1,0],[0,1,0,0,1,0,1,1,0,0,0,1,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,1,0],[0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1],[0,1,0,0,1,0,1,0,0,0,0,0,0,0,0,0,1,0,1,1],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0],[1,0,0,0,0,0,0,1,0,0,1,0,0,0,1,1,0,0,1,1],[0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0],[0,0,0,0,0,0,0,1,0,0,0,0,1,0,1,1,0,0,0,0],[0,0,0,0,1,1,1,1,0,0,0,0,1,1,0,0,0,0,1,0],[1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,1,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0,1,1,0,0,1,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,1,0,0,1,1,0,0,0,1,0,0,0,0,1,0],[0,0,1,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0]]\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 394148,
                "title": "python-bfs",
                "content": "```\\nclass Solution:\\n    def minimumMoves(self, grid: [[int]]) -> int:\\n\\n        h, w = len(grid), len(grid[0])\\n\\n        # (pos0, pos1, horizon/vertical, steps)\\n        q = {((0, 0), (0, 1), 0, 0)}\\n        seen = set()\\n        while q:\\n            qq = set()\\n            for pos0, pos1, condition, step in q:\\n                if (pos0, pos1) not in seen:\\n                    seen.add((pos0, pos1))\\n                    if pos0 == (h - 1, w - 2) and pos1 == (h - 1, w - 1):\\n                        return step\\n                    if condition:\\n                        if pos0[1] + 1 < w and pos1[1] + 1 < w and \\\\\\n                                grid[pos0[0]][pos0[1] + 1] == 0 and grid[pos1[0]][pos1[1] + 1] == 0:\\n                                qq.add(((pos0[0], pos0[1] + 1), (pos1[0], pos1[1] + 1), 1, step + 1))\\n                                qq.add(((pos0[0], pos0[1]), (pos0[0], pos0[1] + 1), 0, step + 1))\\n\\n                        if pos1[0] + 1 < h and grid[pos1[0] + 1][pos1[1]] == 0:\\n                            qq.add(((pos1[0], pos1[1]), (pos1[0] + 1, pos1[1]), 1, step + 1))\\n\\n                    else:\\n                        if pos0[0] + 1 < h and pos1[0] + 1 < h and \\\\\\n                                grid[pos0[0] + 1][pos0[1]] == 0 and grid[pos1[0] + 1][pos1[1]] == 0:\\n                                qq.add(((pos0[0] + 1, pos0[1]), (pos1[0] + 1, pos1[1]), 0, step + 1))\\n                                qq.add(((pos0[0], pos0[1]), (pos0[0] + 1, pos0[1]), 1, step + 1))\\n                        if pos1[1] + 1 < w and grid[pos1[0]][pos1[1] + 1] == 0:\\n                            qq.add(((pos1[0], pos1[1]), (pos1[0], pos1[1] + 1), 0, step + 1))\\n            q = qq\\n        return -1",
                "solutionTags": [],
                "code": "class Solution:\\n    def minimumMoves(self, grid: [[int]]) -> int:\\n\\n        h, w = len(grid), len(grid[0])\\n\\n        # (pos0, pos1, horizon/vertical, steps)\\n        q = {((0, 0), (0, 1), 0, 0)}",
                "codeTag": "Java"
            },
            {
                "id": 394100,
                "title": "python-bfs-solution",
                "content": "```\\nclass Solution(object):\\n\\tdef minimumMoves(self, grid):\\n\\t\\tstart=(0,0,0,1)\\n\\t\\tn=len(grid)\\n\\t\\tm=len(grid[0])\\n\\t\\tend=(n-1,m-2,n-1,m-1)\\n\\t\\treturn self.bfs(start,end,grid,n,m)\\n\\tdef bfs(self,start,end,grid,n,m):\\n\\t\\tcurr_lvl={start}\\n\\t\\tused={}\\n\\t\\tcnt=0\\n\\t\\twhile curr_lvl:\\n\\t\\t\\tnxt_lvl=set()\\n\\t\\t\\t# print(len(curr_lvl))\\n\\t\\t\\t# print(curr_lvl)\\n\\t\\t\\tfor i in curr_lvl:\\n\\t\\t\\t\\tif i == end:\\n\\t\\t\\t\\t\\treturn cnt\\n\\t\\t\\t\\tused[i]=1\\n\\t\\t\\t\\tr1,c1,r2,c2=i\\n\\t\\t\\t\\tif c2+1<m and grid[r2][c2+1]+grid[r1][c1+1]==0:\\n\\t\\t\\t\\t\\tif (r1,c1+1,r2,c2+1) not in used:\\n\\t\\t\\t\\t\\t\\tnxt_lvl.add((r1,c1+1,r2,c2+1))\\n\\t\\t\\t\\tif r2+1<n and grid[r2+1][c2]+grid[r1+1][c1]==0:\\n\\t\\t\\t\\t\\tif (r1+1,c1,r2+1,c2) not in used:\\n\\t\\t\\t\\t\\t\\tnxt_lvl.add((r1+1,c1,r2+1,c2))\\n\\t\\t\\t\\tif r1==r2 and c1<c2 and c1+1<n and r1+1<m and grid[r1+1][c1+1]+grid[r1+1][c1]==0:\\n\\t\\t\\t\\t\\tif (r1,c1,r1+1,c1) not in used:\\n\\t\\t\\t\\t\\t\\tnxt_lvl.add((r1,c1,r1+1,c1))\\n\\t\\t\\t\\tif c1==c2 and r1<r2 and r1+1<n and c1+1<m and grid[r1][c1+1]+grid[r1+1][c1+1]==0:\\n\\t\\t\\t\\t\\tif (r1,c1,r1,c1+1) not in used:\\n\\t\\t\\t\\t\\t\\tnxt_lvl.add((r1,c1,r1,c1+1))\\n\\t\\t\\tcurr_lvl=nxt_lvl\\n\\t\\t\\tcnt+=1\\n\\t\\treturn -1\\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution(object):\\n\\tdef minimumMoves(self, grid):\\n\\t\\tstart=(0,0,0,1)\\n\\t\\tn=len(grid)\\n\\t\\tm=len(grid[0])\\n\\t\\tend=(n-1,m-2,n-1,m-1)\\n\\t\\treturn self.bfs(start,end,grid,n,m)\\n\\tdef bfs(self,start,end,grid,n,m):\\n\\t\\tcurr_lvl={start}\\n\\t\\tused={}\\n\\t\\tcnt=0\\n\\t\\twhile curr_lvl:\\n\\t\\t\\tnxt_lvl=set()\\n\\t\\t\\t# print(len(curr_lvl))\\n\\t\\t\\t# print(curr_lvl)\\n\\t\\t\\tfor i in curr_lvl:\\n\\t\\t\\t\\tif i == end:\\n\\t\\t\\t\\t\\treturn cnt\\n\\t\\t\\t\\tused[i]=1\\n\\t\\t\\t\\tr1,c1,r2,c2=i\\n\\t\\t\\t\\tif c2+1<m and grid[r2][c2+1]+grid[r1][c1+1]==0:\\n\\t\\t\\t\\t\\tif (r1,c1+1,r2,c2+1) not in used:\\n\\t\\t\\t\\t\\t\\tnxt_lvl.add((r1,c1+1,r2,c2+1))\\n\\t\\t\\t\\tif r2+1<n and grid[r2+1][c2]+grid[r1+1][c1]==0:\\n\\t\\t\\t\\t\\tif (r1+1,c1,r2+1,c2) not in used:\\n\\t\\t\\t\\t\\t\\tnxt_lvl.add((r1+1,c1,r2+1,c2))\\n\\t\\t\\t\\tif r1==r2 and c1<c2 and c1+1<n and r1+1<m and grid[r1+1][c1+1]+grid[r1+1][c1]==0:\\n\\t\\t\\t\\t\\tif (r1,c1,r1+1,c1) not in used:\\n\\t\\t\\t\\t\\t\\tnxt_lvl.add((r1,c1,r1+1,c1))\\n\\t\\t\\t\\tif c1==c2 and r1<r2 and r1+1<n and c1+1<m and grid[r1][c1+1]+grid[r1+1][c1+1]==0:\\n\\t\\t\\t\\t\\tif (r1,c1,r1,c1+1) not in used:\\n\\t\\t\\t\\t\\t\\tnxt_lvl.add((r1,c1,r1,c1+1))\\n\\t\\t\\tcurr_lvl=nxt_lvl\\n\\t\\t\\tcnt+=1\\n\\t\\treturn -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 394059,
                "title": "o-n-n-with-just-a-extra-boolean-state-r-d",
                "content": "```\\nclass Solution:\\n    def minimumMoves(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n        visited,queue = set(),collections.deque()\\n        queue.append((0,1,\"r\",0))\\n        visited.add((0,1,\"r\"))\\n        while len(queue) > 0:\\n            x,y,orientation,distance = queue.popleft()\\n            if x == n-1 and y == n-1 and orientation == \\'r\\':\\n                return distance\\n            if orientation == \\'r\\':\\n                if y + 1 < n and grid[x][y+1] == 0 and (x,y+1,\"r\") not in visited:\\n                    queue.append((x,y+1,\"r\",distance+1))\\n                    visited.add((x,y+1,\"r\"))\\n                if x + 1 < n and grid[x+1][y] == 0 and grid[x+1][y-1] == 0:\\n                    if (x+1,y-1,\"d\") not in visited:\\n                        queue.append((x+1,y-1,\"d\",distance+1))\\n                        visited.add((x+1,y-1,\"d\"))\\n                    if (x+1,y,\"r\") not in visited:\\n                        queue.append((x+1,y,\"r\",distance+1))\\n                        visited.add((x+1,y,\"r\"))\\n            if orientation == \\'d\\':\\n                if x + 1 < n and grid[x+1][y] == 0 and (x+1,y,\"d\") not in visited:\\n                    queue.append((x+1,y,\"d\",distance+1))\\n                    visited.add((x+1,y,\"d\"))\\n                if y + 1 < n and grid[x][y+1] == 0 and grid[x-1][y+1] == 0:\\n                    if (x-1,y+1,\"r\") not in visited:\\n                        queue.append((x-1,y+1,\"r\",distance+1))\\n                        visited.add((x-1,y+1,\"r\"))\\n                    if (x,y+1,\"d\") not in visited:\\n                        queue.append((x,y+1,\"d\",distance+1))\\n                        visited.add((x,y+1,\"d\"))\\n        return -1\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumMoves(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n        visited,queue = set(),collections.deque()\\n        queue.append((0,1,\"r\",0))\\n        visited.add((0,1,\"r\"))\\n        while len(queue) > 0:\\n            x,y,orientation,distance = queue.popleft()\\n            if x == n-1 and y == n-1 and orientation == \\'r\\':\\n                return distance\\n            if orientation == \\'r\\':\\n                if y + 1 < n and grid[x][y+1] == 0 and (x,y+1,\"r\") not in visited:\\n                    queue.append((x,y+1,\"r\",distance+1))\\n                    visited.add((x,y+1,\"r\"))\\n                if x + 1 < n and grid[x+1][y] == 0 and grid[x+1][y-1] == 0:\\n                    if (x+1,y-1,\"d\") not in visited:\\n                        queue.append((x+1,y-1,\"d\",distance+1))\\n                        visited.add((x+1,y-1,\"d\"))\\n                    if (x+1,y,\"r\") not in visited:\\n                        queue.append((x+1,y,\"r\",distance+1))\\n                        visited.add((x+1,y,\"r\"))\\n            if orientation == \\'d\\':\\n                if x + 1 < n and grid[x+1][y] == 0 and (x+1,y,\"d\") not in visited:\\n                    queue.append((x+1,y,\"d\",distance+1))\\n                    visited.add((x+1,y,\"d\"))\\n                if y + 1 < n and grid[x][y+1] == 0 and grid[x-1][y+1] == 0:\\n                    if (x-1,y+1,\"r\") not in visited:\\n                        queue.append((x-1,y+1,\"r\",distance+1))\\n                        visited.add((x-1,y+1,\"r\"))\\n                    if (x,y+1,\"d\") not in visited:\\n                        queue.append((x,y+1,\"d\",distance+1))\\n                        visited.add((x,y+1,\"d\"))\\n        return -1\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 394000,
                "title": "bfs",
                "content": "```\\nimport queue\\nclass Solution:\\n    def minimumMoves(self, grid: List[List[int]]) -> int:\\n        m = len(grid)\\n        n = len(grid[0])\\n        vis = [[0 for _ in range(2)] for _ in range(m*n)]\\n        qu = queue.Queue()\\n        \\n        vis[1][0] = 1\\n        qu.put((1,0))\\n        step = -1\\n        \\n        while not qu.empty():\\n            sz = qu.qsize()\\n            step += 1\\n            \\n            for i in range(sz):\\n                curr = qu.get()\\n                x = curr[0]//m\\n                y = curr[0]%n\\n                d = curr[1]\\n                \\n                if x == m-1 and y == n-1 and d == 0:\\n                    return step\\n                \\n                if d == 0:\\n                    if y < n-1 and grid[x][y+1] == 0: \\n                        if vis[x*n+y+1][0] == 0:\\n                            vis[x*n+y+1][0] = 1\\n                            qu.put((x*n+y+1,0))\\n                    if x < m-1 and grid[x+1][y-1] == 0 and grid[x+1][y] == 0: \\n                        if vis[(x+1)*n+y][0] == 0:\\n                            vis[(x+1)*n+y][0] = 1\\n                            qu.put(((x+1)*n+y,0))\\n                        if vis[(x+1)*n+y-1][1] == 0:\\n                            vis[(x+1)*n+y-1][1] = 1\\n                            qu.put(((x+1)*n+y-1,1))\\n                else:\\n                    if x < m-1 and grid[x+1][y] == 0: \\n                        if vis[(x+1)*n+y][1] == 0:\\n                            vis[(x+1)*n+y][1] = 1\\n                            qu.put(((x+1)*n+y,1))\\n                    if y < n-1 and grid[x-1][y+1] == 0 and grid[x][y+1] == 0: \\n                        if vis[x*n+y+1][1] == 0:\\n                            vis[x*n+y+1][1] = 1\\n                            qu.put((x*n+y+1,1))\\n                        if vis[(x-1)*n+y+1][0] == 0:\\n                            vis[(x-1)*n+y+1][0] = 1\\n                            qu.put(((x-1)*n+y+1,0))\\n        \\n        return -1               \\n```",
                "solutionTags": [],
                "code": "```\\nimport queue\\nclass Solution:\\n    def minimumMoves(self, grid: List[List[int]]) -> int:\\n        m = len(grid)\\n        n = len(grid[0])\\n        vis = [[0 for _ in range(2)] for _ in range(m*n)]\\n        qu = queue.Queue()\\n        \\n        vis[1][0] = 1\\n        qu.put((1,0))\\n        step = -1\\n        \\n        while not qu.empty():\\n            sz = qu.qsize()\\n            step += 1\\n            \\n            for i in range(sz):\\n                curr = qu.get()\\n                x = curr[0]//m\\n                y = curr[0]%n\\n                d = curr[1]\\n                \\n                if x == m-1 and y == n-1 and d == 0:\\n                    return step\\n                \\n                if d == 0:\\n                    if y < n-1 and grid[x][y+1] == 0: \\n                        if vis[x*n+y+1][0] == 0:\\n                            vis[x*n+y+1][0] = 1\\n                            qu.put((x*n+y+1,0))\\n                    if x < m-1 and grid[x+1][y-1] == 0 and grid[x+1][y] == 0: \\n                        if vis[(x+1)*n+y][0] == 0:\\n                            vis[(x+1)*n+y][0] = 1\\n                            qu.put(((x+1)*n+y,0))\\n                        if vis[(x+1)*n+y-1][1] == 0:\\n                            vis[(x+1)*n+y-1][1] = 1\\n                            qu.put(((x+1)*n+y-1,1))\\n                else:\\n                    if x < m-1 and grid[x+1][y] == 0: \\n                        if vis[(x+1)*n+y][1] == 0:\\n                            vis[(x+1)*n+y][1] = 1\\n                            qu.put(((x+1)*n+y,1))\\n                    if y < n-1 and grid[x-1][y+1] == 0 and grid[x][y+1] == 0: \\n                        if vis[x*n+y+1][1] == 0:\\n                            vis[x*n+y+1][1] = 1\\n                            qu.put((x*n+y+1,1))\\n                        if vis[(x-1)*n+y+1][0] == 0:\\n                            vis[(x-1)*n+y+1][0] = 1\\n                            qu.put(((x-1)*n+y+1,0))\\n        \\n        return -1               \\n```",
                "codeTag": "Java"
            },
            {
                "id": 393665,
                "title": "java-bfs-beats-100-with-explanation",
                "content": "It\\'s a typical BFS problem. The only trick here is trying to efficiently model the problem.\\n1. Unlike the classic BFS problem, we have both the snake tail and head (2 cells instead of 1 cell) for each step to consider. Here we use the tail and direction to indicate every possible position the snake can be placed on the board.\\n2. How to efficiently validate each step? no matter move right, down, clockwise, counter clockwise. we can validate the postion with a general rule.\\n\\ta. Neither tail nor head of the snake should not be out of boundary.\\n\\tb. Neither tail nor head of the snake should not on the grid with value 1.\\n\\tc. Dedupe the generation of the same cell. For each cell, we should only traverse it with \\'H\\' and \\'V\\' move at most once 1 respectively.\\n\\td. For the clockwise/counter-clockwise case specifically, we need to verify additional two cells.\\n\\t\\n\\n```\\nclass Solution {\\n    public int minimumMoves(int[][] grid) {\\n        int n = grid.length, res = 0;\\n        Queue<Snake> q = new ArrayDeque<>();\\n        int[][] seen = new int[n][n];\\n        // Tail has been pos (i,j), the horizontal/vertical direcitional traversed has been represented as 1 & 2 respectively\\n        seen[0][0] = 1; \\n        q.offer(new Snake(\\'H\\', 0, 0));\\n        while(!q.isEmpty()) {\\n            int size = q.size();\\n            System.out.println(size);\\n            for(int i = 0; i < size; i++) {\\n                Snake s = q.poll();\\n                if (s.dir == \\'H\\' && s.r == n -1 && s.c == n -2) return res;\\n                Snake down = move(grid, seen, new Snake(s.dir, s.r + 1, s.c), \\'D\\');\\n                Snake right = move(grid, seen, new Snake(s.dir, s.r, s.c + 1), \\'R\\');\\n                char dir = (s.dir == \\'H\\' ? \\'V\\' : \\'H\\');\\n                Snake clock = move(grid, seen, new Snake(dir,s.r,s.c), \\'C\\');\\n                if (right != null) q.offer(right);\\n                if (down != null) q.offer(down);\\n                if (clock != null) q.offer(clock);\\n            }\\n            res++;\\n        }\\n        return -1;\\n    }\\n    \\n    Snake move(int[][] grid, int[][] seen, Snake s, char action) {\\n        int r0 = s.r, c0 = s.c, n = grid.length, r1 = r0, c1 = c0;\\n        char dir= s.dir;\\n        if (r0 >= n || c0 >= n || grid[r0][c0] == 1 || seen[r0][c0] == 3 || (seen[r0][c0] == 1 && dir == \\'H\\') || (seen[r0][c0] == 2 && dir == \\'V\\')) return null;\\n        if (dir == \\'H\\') {\\n            c1 = c0 + 1;\\n            r1 = r0;\\n        } else if (dir == \\'V\\') {\\n            c1 = c0;\\n            r1 = r0 + 1;\\n        }\\n        if (r1 >= n || c1 >= n || grid[r1][c1] == 1) return null;\\n        if (action == \\'C\\' && (grid[r0 + 1][c0+1] == 1 || grid[r0 + 1][c0] == 1 && grid[r0][c0+1] == 1)) return null;\\n        seen[r0][c0] += dir == \\'H\\' ? 1 : 2;\\n        return s;\\n    }\\n    \\n    class Snake {\\n        char dir; // \\'H\\' or \\'V\\'\\n        int r; // tail row\\n        int c; //tail column\\n        public Snake(char dir, int r, int c) {\\n            this.dir = dir;\\n            this.r = r;\\n            this.c = c;\\n        }\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int minimumMoves(int[][] grid) {\\n        int n = grid.length, res = 0;\\n        Queue<Snake> q = new ArrayDeque<>();\\n        int[][] seen = new int[n][n];\\n        // Tail has been pos (i,j), the horizontal/vertical direcitional traversed has been represented as 1 & 2 respectively\\n        seen[0][0] = 1; \\n        q.offer(new Snake(\\'H\\', 0, 0));\\n        while(!q.isEmpty()) {\\n            int size = q.size();\\n            System.out.println(size);\\n            for(int i = 0; i < size; i++) {\\n                Snake s = q.poll();\\n                if (s.dir == \\'H\\' && s.r == n -1 && s.c == n -2) return res;\\n                Snake down = move(grid, seen, new Snake(s.dir, s.r + 1, s.c), \\'D\\');\\n                Snake right = move(grid, seen, new Snake(s.dir, s.r, s.c + 1), \\'R\\');\\n                char dir = (s.dir == \\'H\\' ? \\'V\\' : \\'H\\');\\n                Snake clock = move(grid, seen, new Snake(dir,s.r,s.c), \\'C\\');\\n                if (right != null) q.offer(right);\\n                if (down != null) q.offer(down);\\n                if (clock != null) q.offer(clock);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 393631,
                "title": "java-solution-using-bfs-beats-100-space-and-time-complexity",
                "content": "\"\"\"\\nclass Solution {\\n    class vis\\n    {\\n        int r1;\\n        int c1;\\n        int r2;\\n        int c2;\\n        public vis(int a,int b,int c,int d)\\n        {\\n            r1=a;\\n            c1=b;\\n            r2=c;\\n            c2=d;\\n        }\\n    }\\n    class pair{\\n        int x;\\n        int y;\\n        int z;\\n        int w;\\n        int h;\\n        int dis;\\n        public pair(int a,int b,int c,int d,int e,int f)\\n        {\\n            x=a;\\n            y=b;\\n            z=c;\\n            w=d;\\n            h=e;\\n            dis=f;\\n        }\\n    }\\n    public int minimumMoves(int[][] grid) {\\n        int n=grid.length;\\n        Queue<pair> q=new LinkedList<pair>();\\n        boolean vis[][][][]=new boolean[n][n][n][n];\\n        q.add(new pair(0,0,0,1,1,0));\\n        int h11[]={0,1,1};\\n        int h22[]={1,-1,0};\\n        int vx[]={1,-1,0};\\n        int vy[]={0,1,1};\\n        vis[0][0][0][1]=true;\\n        while(q.size()>0)\\n        {\\n            pair p=q.poll();\\n            int tx=p.x;\\n            int ty=p.y;\\n            int hx=p.z;\\n            int hy=p.w;\\n            int o=p.h;\\n            if(tx==n-1&&ty==n-2&&hx==n-1&&hy==n-1)\\n                return p.dis;\\n            if(o==1)\\n            {\\n                for(int k=0;k<=2;k++)\\n                {\\n                    int h1=hx+h11[k];\\n                    int h2=hy+h22[k];\\n                    int t1=tx;\\n                    int t2=ty;\\n                    if(k==0)\\n                    {\\n                        t1=hx;\\n                        t2=hy;\\n                    }\\n                    if(k==2)\\n                    {\\n                        t1=t1+1;\\n                    }\\n                    if(valid(h1,h2,t1,t2,n)==1&&vis[t1][t2][h1][h2]==false)\\n                    {     vis[t1][t2][h1][h2]=true;\\n                        if(k==0&&grid[h1][h2]==0)\\n                        {      \\n                          q.add(new pair(t1,t2,h1,h2,1,p.dis+1));\\n                        }\\n                        else if(k==1&&grid[h1][h2]==0&&grid[h1][h2+1]==0)\\n                        {\\n                            \\n                          q.add(new pair(t1,t2,h1,h2,0,p.dis+1));\\n                        }\\n                        else if(k==2&&grid[h1][h2]==0&&grid[t1][t2]==0)\\n                        {\\n                              \\n                          q.add(new pair(t1,t2,h1,h2,o,p.dis+1));\\n                        }\\n                    }\\n                }\\n            }\\n            else\\n            {\\n                for(int k=0;k<=2;k++)\\n                {\\n                    int h1=hx+vx[k];\\n                    int h2=hy+vy[k];\\n                    int t1=tx;\\n                    int t2=ty;\\n                    if(k==0)\\n                    {\\n                        t1=t1+1;\\n                    }\\n                    if(k==2)\\n                    {\\n                        t2=t2+1;\\n                    }\\n                    \\n                    if(valid(h1,h2,t1,t2,n)==1&&vis[t1][t2][h1][h2]==false)\\n                    {   vis[t1][t2][h1][h2]=true;\\n                        if(k==0&&grid[h1][h2]==0)\\n                        {\\n                         \\n                        q.add(new pair(t1,t2,h1,h2,0,p.dis+1));\\n                        }\\n                        else if(k==1&&grid[h1][h2]==0&&grid[h1+1][h2]==0)\\n                        {\\n                             \\n                        q.add(new pair(t1,t2,h1,h2,k,p.dis+1));\\n                        }\\n                        else if(k==2&&grid[h1][h2]==0&&grid[t1][t2]==0)\\n                        {\\n                            \\n                        q.add(new pair(t1,t2,h1,h2,0,p.dis+1));\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n    public int valid(int a,int b,int c,int d,int n)\\n    {\\n        if(a>=0&&a<n&&b>=0&&b<n)\\n            return 1;\\n        return 0;\\n    }\\n}\\n\"\"\"",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    class vis\\n    {\\n        int r1;\\n        int c1;\\n        int r2;\\n        int c2;\\n        public vis(int a,int b,int c,int d)\\n        {\\n            r1=a;\\n            c1=b;\\n            r2=c;\\n            c2=d;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 393529,
                "title": "python-heap-solution",
                "content": "```\\nclass Solution:\\n    def minimumMoves(self, grid: List[List[int]]) -> int:\\n        \\n        if not grid:\\n            return -1\\n        \\n        n = len(grid)\\n        \\n        heap = []\\n        heapq.heappush(heap,(0,(0,0,0,1)))\\n        \\n        seen = set()\\n        seen.add((0,0,0,1))\\n        \\n        while heap:\\n            \\n            d,pos = heapq.heappop(heap)\\n            r1,c1,r2,c2 = pos\\n            \\n            \\n            if (r1,c1) == (n-1,n-2) and (r2,c2) == (n-1,n-1):\\n                \\n                return d\\n            \\n            for dx,dy,dxx,dyy in {(1,0,1,0),(0,1,0,1)}:\\n                \\n                loc1xx = r1 + dx\\n                loc1yy = c1 + dy\\n                \\n                loc2xx = r2 + dxx\\n                loc2yy = c2 + dyy\\n                \\n                if loc1xx<n and loc2xx <n and loc1yy <n and loc2yy<n and grid[loc1xx][loc1yy] ==0 and grid[loc2xx][loc2yy]==0 and (loc1xx,loc1yy,loc2xx,loc2yy) not in seen:\\n                    \\n                    heapq.heappush(heap,(d+1,(loc1xx,loc1yy,loc2xx,loc2yy)))\\n                    seen.add((loc1xx,loc1yy,loc2xx,loc2yy))\\n                    \\n            if r1 == r2 and r1 + 1 < n and c1 + 1 < n and grid[r1+1][c1+1] == 0 and grid[r1+1][c1] == 0:\\n                if (r1,c1,r1+1,c1) not in seen:\\n                    heapq.heappush(heap,(d+1,(r1,c1,r1+1,c1)))\\n                    seen.add((r1,c1,r1+1,c1))\\n                    \\n            if c1 == c2 and c1 +1 < n and r1 + 1 < n and grid[r1+1][c1+1] == 0 and grid[r1][c1+1] == 0:\\n                if (r1,c1,r1,c1+1) not in seen:\\n                    heapq.heappush(heap,(d+1,(r1,c1,r1,c1+1)))\\n                    seen.add((r1,c1,r1,c1+1))\\n                    \\n            \\n        return -1\\n        \\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumMoves(self, grid: List[List[int]]) -> int:\\n        \\n        if not grid:\\n            return -1\\n        \\n        n = len(grid)\\n        \\n        heap = []\\n        heapq.heappush(heap,(0,(0,0,0,1)))\\n        \\n        seen = set()\\n        seen.add((0,0,0,1))\\n        \\n        while heap:\\n            \\n            d,pos = heapq.heappop(heap)\\n            r1,c1,r2,c2 = pos\\n            \\n            \\n            if (r1,c1) == (n-1,n-2) and (r2,c2) == (n-1,n-1):\\n                \\n                return d\\n            \\n            for dx,dy,dxx,dyy in {(1,0,1,0),(0,1,0,1)}:\\n                \\n                loc1xx = r1 + dx\\n                loc1yy = c1 + dy\\n                \\n                loc2xx = r2 + dxx\\n                loc2yy = c2 + dyy\\n                \\n                if loc1xx<n and loc2xx <n and loc1yy <n and loc2yy<n and grid[loc1xx][loc1yy] ==0 and grid[loc2xx][loc2yy]==0 and (loc1xx,loc1yy,loc2xx,loc2yy) not in seen:\\n                    \\n                    heapq.heappush(heap,(d+1,(loc1xx,loc1yy,loc2xx,loc2yy)))\\n                    seen.add((loc1xx,loc1yy,loc2xx,loc2yy))\\n                    \\n            if r1 == r2 and r1 + 1 < n and c1 + 1 < n and grid[r1+1][c1+1] == 0 and grid[r1+1][c1] == 0:\\n                if (r1,c1,r1+1,c1) not in seen:\\n                    heapq.heappush(heap,(d+1,(r1,c1,r1+1,c1)))\\n                    seen.add((r1,c1,r1+1,c1))\\n                    \\n            if c1 == c2 and c1 +1 < n and r1 + 1 < n and grid[r1+1][c1+1] == 0 and grid[r1][c1+1] == 0:\\n                if (r1,c1,r1,c1+1) not in seen:\\n                    heapq.heappush(heap,(d+1,(r1,c1,r1,c1+1)))\\n                    seen.add((r1,c1,r1,c1+1))\\n                    \\n            \\n        return -1\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 393463,
                "title": "java-bfs",
                "content": "There is still a potential error, which cause that it cannot pass some edge cases.\\n\\nCan someone help me find it out? I thought I considered all the cases.\\n\\nPlus.... this problem is so stupid and waste 99% time on writing code rather than logic on algorithm or mindstorm.\\n\\n```\\nclass Solution {\\n    int[][] grid;\\n    public int minimumMoves(int[][] grid) {\\n        this.grid = grid;\\n        HashSet<String> visited = new HashSet<>();\\n        int[] tail = new int[]{0,0};\\n        int[] head = new int[]{0,1};\\n        Queue<int[][]> q = new LinkedList<>();\\n        q.offer(t2f(tail, head));\\n        visited.add(pos2s(tail, head));\\n        int step = -1, n = grid.length;\\n        while (q.size()!=0){\\n            step++;\\n            int size = q.size();\\n            for (int ord=0; ord<size; ord++){\\n                int[][] cur4 = q.poll();\\n                tail = cur4[0];\\n                head = cur4[1];\\n                if (tail[0]==n-1 && tail[1]==n-2 && head[0]==n-1 && head[1]==n-1) return step;\\n                int[] tail2, head2;\\n                //right\\n                tail2 = new int[]{tail[0], tail[1]+1};\\n                head2 = new int[]{head[0], head[1]+1};\\n                if (!visited.contains(pos2s(tail2, head2)) && validPos(tail2, head2)) {\\n                    q.offer(t2f(tail2, head2));\\n                    visited.add(pos2s(tail2, head2));\\n                }\\n                //down\\n                tail2 = new int[]{tail[0]+1, tail[1]};\\n                head2 = new int[]{head[0]+1, head[1]};\\n                if (!visited.contains(pos2s(tail2, head2)) && validPos(tail2, head2)) {\\n                    q.offer(t2f(tail2, head2));\\n                    visited.add(pos2s(tail2, head2));\\n                }\\n                //clock\\n                tail2 = new int[]{tail[0], tail[1]};\\n                head2 = clocking(tail, head);\\n                if (head2[0]!=-1 && !visited.contains(pos2s(tail2, head2)) && validPos(tail2, head2)) {\\n                    q.offer(t2f(tail2, head2));\\n                    visited.add(pos2s(tail2, head2));\\n                }\\n                //unclock\\n                tail2 = new int[]{tail[0], tail[1]};\\n                head2 = unclocking(tail, head);\\n                if (head2[0]!=-1 && !visited.contains(pos2s(tail2, head2)) && validPos(tail2, head2)) {\\n                    q.offer(t2f(tail2, head2));\\n                    visited.add(pos2s(tail2, head2));\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n    \\n    int[][] t2f(int[] tail, int[] head){\\n        int[][] ret = new int[2][2];\\n        ret[0] = tail;\\n        ret[1] = head;\\n        return ret;\\n    }\\n    \\n    int[] clocking(int[] tail, int[] head){\\n        if (tail[0]!=head[0]){\\n            if (tail[0]>head[0] && validPos1(new int[]{tail[0]-1, tail[1]+1})) \\n                return new int[]{tail[0], tail[1]+1};\\n            else if (tail[0]<head[0] && validPos1(new int[]{tail[0]+1, tail[1]-1})) \\n                return new int[]{tail[0], tail[1]-1};\\n            else return new int[]{-1,-1};\\n        }else{\\n            if (tail[1]>head[1] && validPos1(new int[]{tail[0]-1, tail[1]-1})) \\n                return new int[]{tail[0]-1, tail[1]};\\n            else if (tail[1]<head[1] && validPos1(new int[]{tail[0]+1, tail[1]+1}))\\n                return new int[]{tail[0]+1, tail[1]};\\n            else return new int[]{-1,-1};\\n        }\\n    }\\n    \\n     int[] unclocking(int[] tail, int[] head){\\n        if (tail[0]!=head[0]){\\n            if (tail[0]>head[0] && validPos1(new int[]{tail[0]-1, tail[1]-1})) \\n                return new int[]{tail[0], tail[1]-1};\\n            else if (tail[0]<head[0] && validPos1(new int[]{tail[0]+1, tail[1]+1})) \\n                return new int[]{tail[0], tail[1]+1};\\n            else return new int[]{-1,-1};\\n        }else{\\n            if (tail[1]>head[1] && validPos1(new int[]{tail[0]+1, tail[1]-1})) \\n                return new int[]{tail[0]+1, tail[1]};\\n            else if (tail[1]<head[1] && validPos1(new int[]{tail[0]-1, tail[1]+1}))\\n                return new int[]{tail[0]-1, tail[1]};\\n            else return new int[]{-1,-1};\\n        }\\n    }\\n    \\n    boolean validPos1(int[] tail){\\n        int n = grid.length;\\n        if (tail[0]<0 || tail[0]>=n || tail[1]<0 || tail[1]>=n) return false;\\n        if (grid[tail[0]][tail[1]] == 1) return false;\\n        return true;\\n    }\\n    \\n    boolean validPos(int[] tail, int[] head){\\n        int n = grid.length;\\n        if (tail[0]<0 || tail[0]>=n || tail[1]<0 || tail[1]>=n) return false;\\n        if (head[0]<0 || head[0]>=n || head[1]<0 || head[1]>=n) return false;\\n        if (grid[tail[0]][tail[1]] == 1) return false;\\n        if (grid[head[0]][head[1]] == 1) return false;\\n        return true;\\n    }\\n    \\n    String pos2s(int[] tail, int[] head){\\n        String s = tail[0]+\",\"+tail[1]+\",\"+head[0]+\",\"+head[1];\\n        return s;\\n    }\\n    \\n    int[] s2pos(String s){\\n        String[] ss = s.split(\",\");\\n        int[] ret = new int[4];\\n        for (int i=0; i<4; i++){\\n            ret[i] = Integer.parseInt(ss[i]);\\n        }\\n        return ret;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int[][] grid;\\n    public int minimumMoves(int[][] grid) {\\n        this.grid = grid;\\n        HashSet<String> visited = new HashSet<>();\\n        int[] tail = new int[]{0,0};\\n        int[] head = new int[]{0,1};\\n        Queue<int[][]> q = new LinkedList<>();\\n        q.offer(t2f(tail, head));\\n        visited.add(pos2s(tail, head));\\n        int step = -1, n = grid.length;\\n        while (q.size()!=0){\\n            step++;\\n            int size = q.size();\\n            for (int ord=0; ord<size; ord++){\\n                int[][] cur4 = q.poll();\\n                tail = cur4[0];\\n                head = cur4[1];\\n                if (tail[0]==n-1 && tail[1]==n-2 && head[0]==n-1 && head[1]==n-1) return step;\\n                int[] tail2, head2;\\n                //right\\n                tail2 = new int[]{tail[0], tail[1]+1};\\n                head2 = new int[]{head[0], head[1]+1};\\n                if (!visited.contains(pos2s(tail2, head2)) && validPos(tail2, head2)) {\\n                    q.offer(t2f(tail2, head2));\\n                    visited.add(pos2s(tail2, head2));\\n                }\\n                //down\\n                tail2 = new int[]{tail[0]+1, tail[1]};\\n                head2 = new int[]{head[0]+1, head[1]};\\n                if (!visited.contains(pos2s(tail2, head2)) && validPos(tail2, head2)) {\\n                    q.offer(t2f(tail2, head2));\\n                    visited.add(pos2s(tail2, head2));\\n                }\\n                //clock\\n                tail2 = new int[]{tail[0], tail[1]};\\n                head2 = clocking(tail, head);\\n                if (head2[0]!=-1 && !visited.contains(pos2s(tail2, head2)) && validPos(tail2, head2)) {\\n                    q.offer(t2f(tail2, head2));\\n                    visited.add(pos2s(tail2, head2));\\n                }\\n                //unclock\\n                tail2 = new int[]{tail[0], tail[1]};\\n                head2 = unclocking(tail, head);\\n                if (head2[0]!=-1 && !visited.contains(pos2s(tail2, head2)) && validPos(tail2, head2)) {\\n                    q.offer(t2f(tail2, head2));\\n                    visited.add(pos2s(tail2, head2));\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n    \\n    int[][] t2f(int[] tail, int[] head){\\n        int[][] ret = new int[2][2];\\n        ret[0] = tail;\\n        ret[1] = head;\\n        return ret;\\n    }\\n    \\n    int[] clocking(int[] tail, int[] head){\\n        if (tail[0]!=head[0]){\\n            if (tail[0]>head[0] && validPos1(new int[]{tail[0]-1, tail[1]+1})) \\n                return new int[]{tail[0], tail[1]+1};\\n            else if (tail[0]<head[0] && validPos1(new int[]{tail[0]+1, tail[1]-1})) \\n                return new int[]{tail[0], tail[1]-1};\\n            else return new int[]{-1,-1};\\n        }else{\\n            if (tail[1]>head[1] && validPos1(new int[]{tail[0]-1, tail[1]-1})) \\n                return new int[]{tail[0]-1, tail[1]};\\n            else if (tail[1]<head[1] && validPos1(new int[]{tail[0]+1, tail[1]+1}))\\n                return new int[]{tail[0]+1, tail[1]};\\n            else return new int[]{-1,-1};\\n        }\\n    }\\n    \\n     int[] unclocking(int[] tail, int[] head){\\n        if (tail[0]!=head[0]){\\n            if (tail[0]>head[0] && validPos1(new int[]{tail[0]-1, tail[1]-1})) \\n                return new int[]{tail[0], tail[1]-1};\\n            else if (tail[0]<head[0] && validPos1(new int[]{tail[0]+1, tail[1]+1})) \\n                return new int[]{tail[0], tail[1]+1};\\n            else return new int[]{-1,-1};\\n        }else{\\n            if (tail[1]>head[1] && validPos1(new int[]{tail[0]+1, tail[1]-1})) \\n                return new int[]{tail[0]+1, tail[1]};\\n            else if (tail[1]<head[1] && validPos1(new int[]{tail[0]-1, tail[1]+1}))\\n                return new int[]{tail[0]-1, tail[1]};\\n            else return new int[]{-1,-1};\\n        }\\n    }\\n    \\n    boolean validPos1(int[] tail){\\n        int n = grid.length;\\n        if (tail[0]<0 || tail[0]>=n || tail[1]<0 || tail[1]>=n) return false;\\n        if (grid[tail[0]][tail[1]] == 1) return false;\\n        return true;\\n    }\\n    \\n    boolean validPos(int[] tail, int[] head){\\n        int n = grid.length;\\n        if (tail[0]<0 || tail[0]>=n || tail[1]<0 || tail[1]>=n) return false;\\n        if (head[0]<0 || head[0]>=n || head[1]<0 || head[1]>=n) return false;\\n        if (grid[tail[0]][tail[1]] == 1) return false;\\n        if (grid[head[0]][head[1]] == 1) return false;\\n        return true;\\n    }\\n    \\n    String pos2s(int[] tail, int[] head){\\n        String s = tail[0]+\",\"+tail[1]+\",\"+head[0]+\",\"+head[1];\\n        return s;\\n    }\\n    \\n    int[] s2pos(String s){\\n        String[] ss = s.split(\",\");\\n        int[] ret = new int[4];\\n        for (int i=0; i<4; i++){\\n            ret[i] = Integer.parseInt(ss[i]);\\n        }\\n        return ret;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 393411,
                "title": "50ms-c-bfs",
                "content": "```\\nint minimumMoves1(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        unordered_set<int> visited;\\n        queue<int> q;\\n        q.push(1);\\n        visited.insert(1);\\n        vector<vector<int>> dirs={{0,1,0,1},{1,0,1,0},{0,0,1,-1},{0,0,-1,1}};// rigth,down,rclockwise,counterclock            \\n        int steps=0;\\n        while(!q.empty()){\\n            steps++;\\n            for(int i =q.size();i>0;i--){\\n                auto pp=q.front();q.pop();\\n                int r0=(pp>>24)&0xff, c0=(pp>>16)&0xff,r1=(pp>>8)&0xff,c1=pp&0xff;\\n                for(int d=0;d<4;d++){\\n                    int nr0=r0+dirs[d][0], nc0=c0+dirs[d][1],nr1=r1+dirs[d][2],nc1=c1+dirs[d][3];\\n                    if(r0==r1&&nr0<0||nr1<0||nc0<0||nc1<0||nr0>=n||nr1>=n||nc0>=n||nc1>=n||grid[nr0][nc0]||grid[nr1][nc1])continue;\\n                    if((d==2&&r0!=r1)||(d==3&&c0!=c1))continue;\\n                    if((d==3||d==2)&&r0+1<n&&c0+1<n&&grid[r0+1][c0+1]) continue;\\n                    int t=(nr0<<24)+(nc0<<16)+(nr1<<8)+nc1;\\n                    if(visited.count(t))continue;\\n                    if(nr0==n-1&&nc0==n-2&&nr1==n-1&&nc1==n-1) return steps;\\n                    visited.insert(t);\\n                    q.push(t);\\n                }\\n                \\n            }\\n        }\\n        return -1;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint minimumMoves1(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        unordered_set<int> visited;\\n        queue<int> q;\\n        q.push(1);\\n        visited.insert(1);\\n        vector<vector<int>> dirs={{0,1,0,1},{1,0,1,0},{0,0,1,-1},{0,0,-1,1}};// rigth,down,rclockwise,counterclock            \\n        int steps=0;\\n        while(!q.empty()){\\n            steps++;\\n            for(int i =q.size();i>0;i--){\\n                auto pp=q.front();q.pop();\\n                int r0=(pp>>24)&0xff, c0=(pp>>16)&0xff,r1=(pp>>8)&0xff,c1=pp&0xff;\\n                for(int d=0;d<4;d++){\\n                    int nr0=r0+dirs[d][0], nc0=c0+dirs[d][1],nr1=r1+dirs[d][2],nc1=c1+dirs[d][3];\\n                    if(r0==r1&&nr0<0||nr1<0||nc0<0||nc1<0||nr0>=n||nr1>=n||nc0>=n||nc1>=n||grid[nr0][nc0]||grid[nr1][nc1])continue;\\n                    if((d==2&&r0!=r1)||(d==3&&c0!=c1))continue;\\n                    if((d==3||d==2)&&r0+1<n&&c0+1<n&&grid[r0+1][c0+1]) continue;\\n                    int t=(nr0<<24)+(nc0<<16)+(nr1<<8)+nc1;\\n                    if(visited.count(t))continue;\\n                    if(nr0==n-1&&nc0==n-2&&nr1==n-1&&nc1==n-1) return steps;\\n                    visited.insert(t);\\n                    q.push(t);\\n                }\\n                \\n            }\\n        }\\n        return -1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 393398,
                "title": "why-does-this-have-no-solution",
                "content": "Hi guys, \\nI wonder if I misundestood the problem or not, but for this input\\n[[0,0,0,0,0,0,0,0,0,1],\\n        [0,1,0,0,0,0,0,1,0,1],\\n        [1,0,0,1,0,0,1,0,1,0],\\n        [0,0,0,1,0,1,0,1,0,0],\\n        [0,0,0,0,1,0,0,0,0,1],\\n        [0,0,1,0,0,0,0,0,0,0],\\n        [1,0,0,1,0,0,0,0,0,0],\\n        [0,0,0,0,0,0,0,0,0,0],\\n        [0,0,0,0,0,0,0,0,0,0],\\n        [1,1,0,0,0,0,0,0,0,0]]\\nI wonder why there is no solution, my solution is 21, which is\\nright,right,rotate clockwise,down\\ndown,down,left,down,down\\ndown,down,rotate counterclockwise,right, right\\nright,right,right,right,down,\\ndown.\\n\\nthe path look like this\\n       [[X,X,X,X,0,0,0,0,0,1],\\n        [0,1,X,0,0,0,0,1,0,1],\\n        [1,X,X,1,0,0,1,0,1,0],\\n        [0,X,X,1,0,1,0,1,0,0],\\n        [0,X,0,0,1,0,0,0,0,1],\\n        [0,X,1,0,0,0,0,0,0,0],\\n        [1,X,0,1,0,0,0,0,0,0],\\n        [0,X,X,X,X,X,X,X,X,X],\\n        [0,X,0,0,0,0,0,0,X,X],\\n        [1,1,0,0,0,0,0,0,X,X]]\\nI would really appreciate if someone can help me clear this up. Thank you very much.",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 393394,
                "title": "c-why-my-bfsis-inefficient",
                "content": "it\\'s standard BFS operation with visited map to memorize walked path.\\nBut I have no idea why it\\'s only beat 25% or less, not sure what\\'s the bottle neck in my algo.\\nAnyone can help with that?\\n```\\nclass Solution {\\npublic:\\n    int minimumMoves(vector<vector<int>>& g) {\\n        queue<vector<int>> myq;\\n        myq.push({0,0,0,1});\\n        int res = 0, g_size = g.size()-1;\\n        map<vector<int>,int> visited;\\n        vector<int> end1,end2;\\n        end1.push_back(g_size);end1.push_back(g_size);end1.push_back(g_size);end1.push_back(g_size-1);\\n        end2.push_back(g_size);end2.push_back(g_size-1);end2.push_back(g_size);end2.push_back(g_size);\\n        while(!myq.empty()){\\n            int size = myq.size();\\n            for(int i = 0 ; i < size ; i++){\\n                auto it = myq.front(); myq.pop();\\n                if((it == end1) || (it == end2))\\n                    return res;\\n                int x1p1 = it[0]+1,y1p1 = it[1]+1,x2p1 = it[2]+1, y2p1 = it[3]+1;\\n\\t\\t\\t\\t//check if we can move right\\n                if((y1p1 <= g_size) && (y2p1 <= g_size) && (g[it[0]][y1p1] == 0) && (g[it[2]][y2p1] == 0) && (visited[{it[0],y1p1,it[2],y2p1}] == 0)){\\n                    myq.push({it[0],y1p1,it[2],y2p1});\\n                    visited[{it[0],y1p1,it[2],y2p1}] = 1;\\n                    // check if we can rotate counter-clockwise\\n                    if(it[1] == it[3]){\\n                        myq.push({it[0],it[1],it[2]-1,y2p1});\\n                        visited[{it[0],it[1],it[2]-1,y2p1}] = 1;\\n                    }\\n                }\\n                // check if we can move down\\n                if((x1p1 <= g_size) && (x2p1 <= g_size) && (g[x1p1][it[1]] == 0) && (g[x2p1][it[3]] == 0) && (visited[{x1p1,it[1],x2p1,it[3]}] == 0)){\\n                    myq.push({x1p1,it[1],x2p1,it[3]});\\n                    visited[{x1p1,it[1],x2p1,it[3]}] = 1;\\n                    \\n                    // check if we can rotate clockwise\\n                    if(it[0] == it[2]){\\n                        myq.push({it[0],it[1],x2p1,it[3]-1});\\n                        visited[{it[0],it[1],x2p1,it[3]-1}] = 1;\\n                    }\\n                }\\n            }\\n            res++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumMoves(vector<vector<int>>& g) {\\n        queue<vector<int>> myq;\\n        myq.push({0,0,0,1});\\n        int res = 0, g_size = g.size()-1;\\n        map<vector<int>,int> visited;\\n        vector<int> end1,end2;\\n        end1.push_back(g_size);end1.push_back(g_size);end1.push_back(g_size);end1.push_back(g_size-1);\\n        end2.push_back(g_size);end2.push_back(g_size-1);end2.push_back(g_size);end2.push_back(g_size);\\n        while(!myq.empty()){\\n            int size = myq.size();\\n            for(int i = 0 ; i < size ; i++){\\n                auto it = myq.front(); myq.pop();\\n                if((it == end1) || (it == end2))\\n                    return res;\\n                int x1p1 = it[0]+1,y1p1 = it[1]+1,x2p1 = it[2]+1, y2p1 = it[3]+1;\\n\\t\\t\\t\\t//check if we can move right\\n                if((y1p1 <= g_size) && (y2p1 <= g_size) && (g[it[0]][y1p1] == 0) && (g[it[2]][y2p1] == 0) && (visited[{it[0],y1p1,it[2],y2p1}] == 0)){\\n                    myq.push({it[0],y1p1,it[2],y2p1});\\n                    visited[{it[0],y1p1,it[2],y2p1}] = 1;\\n                    // check if we can rotate counter-clockwise\\n                    if(it[1] == it[3]){\\n                        myq.push({it[0],it[1],it[2]-1,y2p1});\\n                        visited[{it[0],it[1],it[2]-1,y2p1}] = 1;\\n                    }\\n                }\\n                // check if we can move down\\n                if((x1p1 <= g_size) && (x2p1 <= g_size) && (g[x1p1][it[1]] == 0) && (g[x2p1][it[3]] == 0) && (visited[{x1p1,it[1],x2p1,it[3]}] == 0)){\\n                    myq.push({x1p1,it[1],x2p1,it[3]});\\n                    visited[{x1p1,it[1],x2p1,it[3]}] = 1;\\n                    \\n                    // check if we can rotate clockwise\\n                    if(it[0] == it[2]){\\n                        myq.push({it[0],it[1],x2p1,it[3]-1});\\n                        visited[{it[0],it[1],x2p1,it[3]-1}] = 1;\\n                    }\\n                }\\n            }\\n            res++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 393378,
                "title": "java-bfs-no-fancy-tricks",
                "content": "```\\nclass Solution {\\n    class Snake {\\n        int tailX, tailY;\\n        boolean hor;\\n        Snake(int x1, int y1, boolean flag){\\n            this.tailX = x1;\\n            this.tailY = y1;\\n            this.hor = flag;\\n        }\\n        public boolean equals(Snake s){\\n            if(this.tailX == s.tailX && this.tailY == s.tailY && this.hor == s.hor) return true;\\n            else return false;\\n        }\\n    } \\n    boolean canRotate(Snake s, int[][] grid){\\n        if(s.hor){\\n            if(s.tailX + 1 < grid.length && grid[s.tailX+1][s.tailY] == 0 && grid[s.tailX+1][s.tailY+1] == 0) return true;\\n            else return false;\\n        }else{\\n            if(s.tailY + 1 < grid[0].length && grid[s.tailX][s.tailY+1] == 0 && grid[s.tailX+1][s.tailY+1] == 0) return true;\\n            else return false;\\n        }\\n    }\\n    Snake rotate(Snake s){\\n        Snake res = new Snake(s.tailX, s.tailY, !s.hor);\\n        return res;\\n    }\\n    boolean canGoRight(Snake s, int[][] grid){\\n        if(s.hor){\\n            if(s.tailY+2 < grid[0].length && grid[s.tailX][s.tailY+2] == 0) return true;\\n            else return false; \\n        }else{\\n            if(s.tailY +1 < grid[0].length && grid[s.tailX][s.tailY+1] == 0 && grid[s.tailX+1][s.tailY+1] == 0) return true;\\n            else return false;\\n        }\\n    }\\n    Snake goRight(Snake s){\\n        Snake res = new Snake(s.tailX, s.tailY+1, s.hor);\\n        return res; \\n    }\\n    boolean canGoDown(Snake s, int[][] grid){\\n        if(s.hor){\\n            if(s.tailX <  grid.length -1 && grid[s.tailX + 1][s.tailY] == 0 && grid[s.tailX + 1][s.tailY+1] == 0) return true;\\n            else return false; \\n        }else{\\n            if(s.tailX <  grid.length -2 && grid[s.tailX + 2][s.tailY] == 0) return true;\\n            else return false; \\n        }  \\n    }\\n    Snake goDown(Snake s){\\n        Snake res = new Snake(s.tailX + 1, s.tailY, s.hor);\\n        return res; \\n    }\\n        \\n    \\n    public int minimumMoves(int[][] grid) {\\n        int n = grid.length, m = grid[0].length;\\n        Snake start = new Snake(0,0,true);\\n        Snake target = new Snake(n-1, m-2, true);\\n        Queue<Snake> q = new LinkedList();\\n        Set<String> set = new HashSet();\\n        q.offer(start);\\n        int step = 0;\\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            for(int i = 0; i < size; i++){\\n                Snake cur = q.poll();\\n                if(cur.equals(target)) return step;\\n                if(canRotate(cur, grid)){\\n                    Snake nextStep = rotate(cur);\\n                    String next = \"\"+nextStep.tailX + nextStep.tailY + Boolean.toString(nextStep.hor);\\n                    if(set.add(next)) q.offer(nextStep);\\n                }\\n                if(canGoRight(cur, grid)) {\\n                    Snake nextStep = goRight(cur);\\n                    String next = \"\"+nextStep.tailX + nextStep.tailY + Boolean.toString(nextStep.hor);\\n                    if(set.add(next)) q.offer(nextStep);\\n                }\\n                if(canGoDown(cur, grid)){\\n                    Snake nextStep = goDown(cur);\\n                    String next = \"\"+nextStep.tailX + nextStep.tailY + Boolean.toString(nextStep.hor);\\n                    if(set.add(next)) q.offer(nextStep);\\n                } \\n            }\\n            step++;\\n        }\\n        return -1;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    class Snake {\\n        int tailX, tailY;\\n        boolean hor;\\n        Snake(int x1, int y1, boolean flag){\\n            this.tailX = x1;\\n            this.tailY = y1;\\n            this.hor = flag;\\n        }",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1569639,
                "content": [
                    {
                        "username": "dev1988",
                        "content": "The first two moves are as follows:\\n*  Move one cell to the right if there are no blocked cells there. This move keeps the horizontal/**vertical** position of the snake as it is.\\n* Move down one cell if there are no blocked cells there. This move keeps the **horizontal**/vertical position of the snake as it is.\\n\\nCan someone help to explain how a vertical movement is possible while going right without a down+counterclockwise move?\\nSimilarly how is second move possible?"
                    },
                    {
                        "username": "Shark-Chili",
                        "content": "The first testcase:\\n`[right, right, rotate clockwise, right, down, down, down, down, rotate counterclockwise, right, down]`\\n\\nAnd here is the definition of `right` and `down`\\n`right`: Move one cell to the right if there are no blocked cells there. This move keeps the horizontal/vertical position of the snake as it is.\\n`down`: Move down one cell if there are no blocked cells there. This move keeps the horizontal/vertical position of the snake as it is.\\n\\nSo how how can it make `right` after `rotate clockwise` (the step 3 -> step 4)?  From what I understood, the head of the snake was vertically facing downside when finished the step 3?"
                    },
                    {
                        "username": "COSMIC_GAN_356_X_M_IPG_V5",
                        "content": "why is it 11\\n[right, right, rotate clockwise, right, down, down, down, down, rotate counterclockwise, right, down]\\n instead of 10?\\n[right, right, rotate clockwise, right, down, down, down, down, right right]\\n\\nAt first I thought it was because the snake can only move in the direction its facing but if we can move\\n[... rotate counterclockwise, right, down] then thats not the case.\\n \\n"
                    },
                    {
                        "username": "PabloLION",
                        "content": "because the ending state must be horizontal"
                    },
                    {
                        "username": "samzhu333",
                        "content": "We can make it by [right, right, rotate clockwise, right, down, down, down, down, right right], it will take only 10 steps instead of 11 steps"
                    },
                    {
                        "username": "Karilli",
                        "content": "I got stuck on this for half an hour... :((("
                    },
                    {
                        "username": "PabloLION",
                        "content": "because the ending state must be horizontal"
                    }
                ]
            },
            {
                "id": 1573052,
                "content": [
                    {
                        "username": "dev1988",
                        "content": "The first two moves are as follows:\\n*  Move one cell to the right if there are no blocked cells there. This move keeps the horizontal/**vertical** position of the snake as it is.\\n* Move down one cell if there are no blocked cells there. This move keeps the **horizontal**/vertical position of the snake as it is.\\n\\nCan someone help to explain how a vertical movement is possible while going right without a down+counterclockwise move?\\nSimilarly how is second move possible?"
                    },
                    {
                        "username": "Shark-Chili",
                        "content": "The first testcase:\\n`[right, right, rotate clockwise, right, down, down, down, down, rotate counterclockwise, right, down]`\\n\\nAnd here is the definition of `right` and `down`\\n`right`: Move one cell to the right if there are no blocked cells there. This move keeps the horizontal/vertical position of the snake as it is.\\n`down`: Move down one cell if there are no blocked cells there. This move keeps the horizontal/vertical position of the snake as it is.\\n\\nSo how how can it make `right` after `rotate clockwise` (the step 3 -> step 4)?  From what I understood, the head of the snake was vertically facing downside when finished the step 3?"
                    },
                    {
                        "username": "COSMIC_GAN_356_X_M_IPG_V5",
                        "content": "why is it 11\\n[right, right, rotate clockwise, right, down, down, down, down, rotate counterclockwise, right, down]\\n instead of 10?\\n[right, right, rotate clockwise, right, down, down, down, down, right right]\\n\\nAt first I thought it was because the snake can only move in the direction its facing but if we can move\\n[... rotate counterclockwise, right, down] then thats not the case.\\n \\n"
                    },
                    {
                        "username": "PabloLION",
                        "content": "because the ending state must be horizontal"
                    },
                    {
                        "username": "samzhu333",
                        "content": "We can make it by [right, right, rotate clockwise, right, down, down, down, down, right right], it will take only 10 steps instead of 11 steps"
                    },
                    {
                        "username": "Karilli",
                        "content": "I got stuck on this for half an hour... :((("
                    },
                    {
                        "username": "PabloLION",
                        "content": "because the ending state must be horizontal"
                    }
                ]
            },
            {
                "id": 1569640,
                "content": [
                    {
                        "username": "dev1988",
                        "content": "The first two moves are as follows:\\n*  Move one cell to the right if there are no blocked cells there. This move keeps the horizontal/**vertical** position of the snake as it is.\\n* Move down one cell if there are no blocked cells there. This move keeps the **horizontal**/vertical position of the snake as it is.\\n\\nCan someone help to explain how a vertical movement is possible while going right without a down+counterclockwise move?\\nSimilarly how is second move possible?"
                    },
                    {
                        "username": "Shark-Chili",
                        "content": "The first testcase:\\n`[right, right, rotate clockwise, right, down, down, down, down, rotate counterclockwise, right, down]`\\n\\nAnd here is the definition of `right` and `down`\\n`right`: Move one cell to the right if there are no blocked cells there. This move keeps the horizontal/vertical position of the snake as it is.\\n`down`: Move down one cell if there are no blocked cells there. This move keeps the horizontal/vertical position of the snake as it is.\\n\\nSo how how can it make `right` after `rotate clockwise` (the step 3 -> step 4)?  From what I understood, the head of the snake was vertically facing downside when finished the step 3?"
                    },
                    {
                        "username": "COSMIC_GAN_356_X_M_IPG_V5",
                        "content": "why is it 11\\n[right, right, rotate clockwise, right, down, down, down, down, rotate counterclockwise, right, down]\\n instead of 10?\\n[right, right, rotate clockwise, right, down, down, down, down, right right]\\n\\nAt first I thought it was because the snake can only move in the direction its facing but if we can move\\n[... rotate counterclockwise, right, down] then thats not the case.\\n \\n"
                    },
                    {
                        "username": "PabloLION",
                        "content": "because the ending state must be horizontal"
                    },
                    {
                        "username": "samzhu333",
                        "content": "We can make it by [right, right, rotate clockwise, right, down, down, down, down, right right], it will take only 10 steps instead of 11 steps"
                    },
                    {
                        "username": "Karilli",
                        "content": "I got stuck on this for half an hour... :((("
                    },
                    {
                        "username": "PabloLION",
                        "content": "because the ending state must be horizontal"
                    }
                ]
            },
            {
                "id": 1573051,
                "content": [
                    {
                        "username": "dev1988",
                        "content": "The first two moves are as follows:\\n*  Move one cell to the right if there are no blocked cells there. This move keeps the horizontal/**vertical** position of the snake as it is.\\n* Move down one cell if there are no blocked cells there. This move keeps the **horizontal**/vertical position of the snake as it is.\\n\\nCan someone help to explain how a vertical movement is possible while going right without a down+counterclockwise move?\\nSimilarly how is second move possible?"
                    },
                    {
                        "username": "Shark-Chili",
                        "content": "The first testcase:\\n`[right, right, rotate clockwise, right, down, down, down, down, rotate counterclockwise, right, down]`\\n\\nAnd here is the definition of `right` and `down`\\n`right`: Move one cell to the right if there are no blocked cells there. This move keeps the horizontal/vertical position of the snake as it is.\\n`down`: Move down one cell if there are no blocked cells there. This move keeps the horizontal/vertical position of the snake as it is.\\n\\nSo how how can it make `right` after `rotate clockwise` (the step 3 -> step 4)?  From what I understood, the head of the snake was vertically facing downside when finished the step 3?"
                    },
                    {
                        "username": "COSMIC_GAN_356_X_M_IPG_V5",
                        "content": "why is it 11\\n[right, right, rotate clockwise, right, down, down, down, down, rotate counterclockwise, right, down]\\n instead of 10?\\n[right, right, rotate clockwise, right, down, down, down, down, right right]\\n\\nAt first I thought it was because the snake can only move in the direction its facing but if we can move\\n[... rotate counterclockwise, right, down] then thats not the case.\\n \\n"
                    },
                    {
                        "username": "PabloLION",
                        "content": "because the ending state must be horizontal"
                    },
                    {
                        "username": "samzhu333",
                        "content": "We can make it by [right, right, rotate clockwise, right, down, down, down, down, right right], it will take only 10 steps instead of 11 steps"
                    },
                    {
                        "username": "Karilli",
                        "content": "I got stuck on this for half an hour... :((("
                    },
                    {
                        "username": "PabloLION",
                        "content": "because the ending state must be horizontal"
                    }
                ]
            }
        ]
    },
    {
        "title": "Maximum Repeating Substring",
        "question_content": "<p>For a string <code>sequence</code>, a string <code>word</code> is <strong><code>k</code>-repeating</strong> if <code>word</code> concatenated <code>k</code> times is a substring of <code>sequence</code>. The <code>word</code>&#39;s <strong>maximum <code>k</code>-repeating value</strong> is the highest value <code>k</code> where <code>word</code> is <code>k</code>-repeating in <code>sequence</code>. If <code>word</code> is not a substring of <code>sequence</code>, <code>word</code>&#39;s maximum <code>k</code>-repeating value is <code>0</code>.</p>\n\n<p>Given strings <code>sequence</code> and <code>word</code>, return <em>the <strong>maximum <code>k</code>-repeating value</strong> of <code>word</code> in <code>sequence</code></em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> sequence = &quot;ababc&quot;, word = &quot;ab&quot;\n<strong>Output:</strong> 2\n<strong>Explanation: </strong>&quot;abab&quot; is a substring in &quot;<u>abab</u>c&quot;.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> sequence = &quot;ababc&quot;, word = &quot;ba&quot;\n<strong>Output:</strong> 1\n<strong>Explanation: </strong>&quot;ba&quot; is a substring in &quot;a<u>ba</u>bc&quot;. &quot;baba&quot; is not a substring in &quot;ababc&quot;.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> sequence = &quot;ababc&quot;, word = &quot;ac&quot;\n<strong>Output:</strong> 0\n<strong>Explanation: </strong>&quot;ac&quot; is not a substring in &quot;ababc&quot;. \n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= sequence.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= word.length &lt;= 100</code></li>\n\t<li><code>sequence</code> and <code>word</code>&nbsp;contains only lowercase English letters.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 952025,
                "title": "c-short-easy-using-find",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxRepeating(string sequence, string word) {\\n        int count=0;\\n        string temp=word;\\n        while(sequence.find(temp)!=string::npos)\\n        {\\n            count++;\\n            temp+=word;\\n        }\\n        return count;\\n    }\\n};\\n```\\n\\n**please upvote my solution if you like it**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxRepeating(string sequence, string word) {\\n        int count=0;\\n        string temp=word;\\n        while(sequence.find(temp)!=string::npos)\\n        {\\n            count++;\\n            temp+=word;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 952026,
                "title": "java-python-3-bruteforce-4-liners-w-analysis",
                "content": "\\n```java\\n    public int maxRepeating(String sequence, String word) {\\n        int ans = 1;\\n     // while (sequence.indexOf(word.repeat(ans)) >= 0)\\n        while (sequence.contains(word.repeat(ans)))\\n            ++ans;\\n        return ans - 1;\\n    }\\n```\\n```python\\n    def maxRepeating(self, sequence: str, word: str) -> int:\\n        ans = 1\\n      # while sequence.find(word * ans) >= 0:\\n         while word * ans in sequence:             # credit to @blue_sky5 for his more pythonic way.\\n            ans += 1\\n        return ans - 1\\n```\\n**Analysis:**\\n\\nLet n = sequence.length().\\n\\nword.repeat() at most cost O(n) time and space, and contains() cost O(n) time for each call; Note the number of calls * word.repeat(ans).length() should be O(n), since the shorter the latter, the more the former. Therefore,\\n\\nTime: O(n ^ 2), space: O(n).",
                "solutionTags": [],
                "code": "```java\\n    public int maxRepeating(String sequence, String word) {\\n        int ans = 1;\\n     // while (sequence.indexOf(word.repeat(ans)) >= 0)\\n        while (sequence.contains(word.repeat(ans)))\\n            ++ans;\\n        return ans - 1;\\n    }\\n```\n```python\\n    def maxRepeating(self, sequence: str, word: str) -> int:\\n        ans = 1\\n      # while sequence.find(word * ans) >= 0:\\n         while word * ans in sequence:             # credit to @blue_sky5 for his more pythonic way.\\n            ans += 1\\n        return ans - 1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 952276,
                "title": "clean-python-3-true-o-n-with-kmp",
                "content": "For testcase sequence `aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab` and word `aaaaaaaaaaaaaaab`,\\nit\\'s easy to find that if we adopt naive linear scanning for string matching, the time cost will become `O(N*W)`.\\nHence using KMP will be helpful in this situation.\\n\\nTime: `O(N + N / W * W) = O(N + N) = O(N)`\\nSpace: `O(N)`\\n```\\nclass Solution:\\n    def maxRepeating(self, sequence: str, word: str) -> int:\\n        s, w = len(sequence), len(word)\\n        max_repeat = s // w\\n        failure = [0] * (w * max_repeat + 1)\\n        repeat_words = word * max_repeat + \\'$\\'\\n        result = 0\\n\\n        j = 0\\n        for i in range(1, len(repeat_words)):\\n            while j > 0 and repeat_words[j] != repeat_words[i]:\\n                j = failure[j-1]\\n            j += repeat_words[j] == repeat_words[i]\\n            failure[i] = j\\n\\n        j = 0\\n        for i, c in enumerate(sequence):\\n            while j > 0 and repeat_words[j] != c:\\n                j = failure[j-1]\\n            j += repeat_words[j] == c\\n            result = max(result, j // w)\\n\\n        return result\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxRepeating(self, sequence: str, word: str) -> int:\\n        s, w = len(sequence), len(word)\\n        max_repeat = s // w\\n        failure = [0] * (w * max_repeat + 1)\\n        repeat_words = word * max_repeat + \\'$\\'\\n        result = 0\\n\\n        j = 0\\n        for i in range(1, len(repeat_words)):\\n            while j > 0 and repeat_words[j] != repeat_words[i]:\\n                j = failure[j-1]\\n            j += repeat_words[j] == repeat_words[i]\\n            failure[i] = j\\n\\n        j = 0\\n        for i, c in enumerate(sequence):\\n            while j > 0 and repeat_words[j] != c:\\n                j = failure[j-1]\\n            j += repeat_words[j] == c\\n            result = max(result, j // w)\\n\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 981906,
                "title": "java-3-liner",
                "content": "```\\nclass Solution {\\n    public int maxRepeating(String sequence, String word) {\\n        String find=\"\";\\n        while(sequence.contains(find)) find += word;\\n        return (find.length()-word.length())/word.length();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxRepeating(String sequence, String word) {\\n        String find=\"\";\\n        while(sequence.contains(find)) find += word;\\n        return (find.length()-word.length())/word.length();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 952687,
                "title": "python-binary-search-on-the-length-of-the-subsequence",
                "content": "```\\nclass Solution:\\n    def maxRepeating(self, sequence: str, word: str) -> int:\\n        if word not in sequence:\\n            return 0\\n\\n        left = 1\\n        right = len(sequence) // len(word)\\n        while left <= right:\\n            mid = (left + right) // 2\\n            if word * mid in sequence:\\n                left = mid + 1\\n            else:\\n                right = mid - 1 \\n                \\n        return left - 1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxRepeating(self, sequence: str, word: str) -> int:\\n        if word not in sequence:\\n            return 0\\n\\n        left = 1\\n        right = len(sequence) // len(word)\\n        while left <= right:\\n            mid = (left + right) // 2\\n            if word * mid in sequence:\\n                left = mid + 1\\n            else:\\n                right = mid - 1 \\n                \\n        return left - 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1006510,
                "title": "java-simple-straight-solution",
                "content": "```\\n\\nclass Solution {\\n    public int maxRepeating(String sequence, String word) {\\n        int n = sequence.length(), m = word.length();\\n        int max = 0;\\n        for(int i = 0;i < n;i++) {\\n            int cnt = 0, k = 0;\\n            for(int j = i;j < n;j++) {\\n                if(sequence.charAt(j) == word.charAt(k)) k++;\\n                else break;\\n                if(k == m) {\\n                    k = 0;\\n                    cnt++;\\n                }\\n            }\\n            max = Math.max(max, cnt);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\nclass Solution {\\n    public int maxRepeating(String sequence, String word) {\\n        int n = sequence.length(), m = word.length();\\n        int max = 0;\\n        for(int i = 0;i < n;i++) {\\n            int cnt = 0, k = 0;\\n            for(int j = i;j < n;j++) {\\n                if(sequence.charAt(j) == word.charAt(k)) k++;\\n                else break;\\n                if(k == m) {\\n                    k = 0;\\n                    cnt++;\\n                }\\n            }\\n            max = Math.max(max, cnt);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 955479,
                "title": "java-simple-solution",
                "content": "```java\\nclass Solution {\\n    public int maxRepeating(String sequence, String word) {\\n        int repeating = 0;\\n        StringBuilder sb = new StringBuilder(word);\\n        while (sequence.contains(sb)) {\\n            repeating++;\\n            sb.append(word);\\n        }\\n        return repeating;\\n    }\\n\\n    public static void test() {\\n        Solution s = new Solution();\\n        System.out.println(s.maxRepeating(\"ababc\", \"ab\"));\\n        System.out.println(s.maxRepeating(\"ababc\", \"ba\"));\\n        System.out.println(s.maxRepeating(\"ababc\", \"ac\"));\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n    public int maxRepeating(String sequence, String word) {\\n        int repeating = 0;\\n        StringBuilder sb = new StringBuilder(word);\\n        while (sequence.contains(sb)) {\\n            repeating++;\\n            sb.append(word);\\n        }\\n        return repeating;\\n    }\\n\\n    public static void test() {\\n        Solution s = new Solution();\\n        System.out.println(s.maxRepeating(\"ababc\", \"ab\"));\\n        System.out.println(s.maxRepeating(\"ababc\", \"ba\"));\\n        System.out.println(s.maxRepeating(\"ababc\", \"ac\"));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 954256,
                "title": "c-100-faster-solution-easy-code",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint maxRepeating(string sequence, string word) {\\n\\t\\t\\tint k = 0;\\n\\t\\t\\tstring temp = word;\\n\\n\\t\\t\\twhile(sequence.find(temp) != string::npos){\\n\\t\\t\\t\\ttemp += word;\\n\\t\\t\\t\\tk++;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn k;\\n\\t\\t}\\n\\t};\\n\\nto know about **string::npos** [click here.](https://www.cplusplus.com/reference/string/string/npos/)\\n\\n**Like it? please Upvote!**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint maxRepeating(string sequence, string word) {\\n\\t\\t\\tint k = 0;\\n\\t\\t\\tstring temp = word;\\n\\n\\t\\t\\twhile(sequence.find(temp) != string::npos){\\n\\t\\t\\t\\ttemp += word;\\n\\t\\t\\t\\tk++;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1343072,
                "title": "java-short-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int maxRepeating(String sequence, String word) {\\n        int count=0;\\n        String temp = word;\\n        while(sequence.contains(temp)){\\n            count++;\\n            temp+=word;\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxRepeating(String sequence, String word) {\\n        int count=0;\\n        String temp = word;\\n        while(sequence.contains(temp)){\\n            count++;\\n            temp+=word;\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 952484,
                "title": "c-o-n-n",
                "content": "C++ devs are in luck as `string::find` is O(n + m). So we do not need to implement KPM ourselves.\\n\\n> Update: we do need KMP as we may need to start a new search from the middle of the previously matched string.\\n\\nSo, we use `find` to get a match, and then two pointers to check it\\'s lenght. Then, we repeat it for the next missmatched position till we reach the end of our `seq`.\\n\\n```cpp\\nint maxRepeating(string seq, string word) {\\n    int pos = seq.find(word), res = 0, sz = word.size();\\n    while (pos != string::npos) {\\n        int i = pos + sz, j = 0;\\n        while (i < seq.size() && seq[i] == word[j % sz]) {\\n            ++i;\\n            ++j;\\n        }\\n        res = max(res, 1 + j / sz);\\n        pos = seq.find(word, pos + 1);\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nint maxRepeating(string seq, string word) {\\n    int pos = seq.find(word), res = 0, sz = word.size();\\n    while (pos != string::npos) {\\n        int i = pos + sz, j = 0;\\n        while (i < seq.size() && seq[i] == word[j % sz]) {\\n            ++i;\\n            ++j;\\n        }\\n        res = max(res, 1 + j / sz);\\n        pos = seq.find(word, pos + 1);\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 952060,
                "title": "python3-easy-way",
                "content": "```\\nclass Solution:\\n    def maxRepeating(self, sequence: str, word: str) -> int:\\n        if len(sequence) < len(word):\\n            return 0\\n        ans = 0\\n        k = 1\\n        while word*k in sequence:\\n            ans += 1\\n            k += 1\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxRepeating(self, sequence: str, word: str) -> int:\\n        if len(sequence) < len(word):\\n            return 0\\n        ans = 0\\n        k = 1\\n        while word*k in sequence:\\n            ans += 1\\n            k += 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2580569,
                "title": "java-easy-to-understand-solution",
                "content": "```\\nclass Solution {\\n    public int maxRepeating(String sequence, String word) {\\n        int c=0;\\n        String add=word;\\n        while(sequence.contains(word)==true)\\n        {\\n            c+=1;\\n            word=word+add;\\n            //System.out.println(word);\\n        }\\n        return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int maxRepeating(String sequence, String word) {\\n        int c=0;\\n        String add=word;\\n        while(sequence.contains(word)==true)\\n        {\\n            c+=1;\\n            word=word+add;\\n            //System.out.println(word);\\n        }\\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1343114,
                "title": "easy-to-understand-javascript-solution",
                "content": "\\tvar maxRepeating = function(sequence, word) {\\n\\t\\tlet result = 0;\\n\\n\\t\\twhile (sequence.includes(word.repeat(result + 1))) {\\n\\t\\t\\tresult += 1;\\n\\t\\t};\\n\\t\\treturn result;\\n\\t};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "\\tvar maxRepeating = function(sequence, word) {\\n\\t\\tlet result = 0;\\n\\n\\t\\twhile (sequence.includes(word.repeat(result + 1))) {\\n\\t\\t\\tresult += 1;\\n\\t\\t};\\n\\t\\treturn result;\\n\\t};",
                "codeTag": "Unknown"
            },
            {
                "id": 1225675,
                "title": "py-most-probably-the-worst-way-to-solve-this-problem",
                "content": "```\\nclass Solution:\\n    def maxRepeating(self, sequence: str, word: str) -> int:\\n        count=0\\n        while True:\\n            if word*(count+1) not in sequence:\\n                return count\\n            count+=1\\n```\\n\\tE.g.:\\n\\tSequence = \"ababa\"\\n\\tword = \"ab\"\\n\\t\\n\\t1. Initially set count to 0, saying that word might not be present in sequence.\\n\\t2. word * (count+1) = word * (0+1) = word * 1 = word = ab is present in sequence. Increment count by 1, count =1.\\n\\t3. Now, word * (count+1) = word * (1+1) = word * 2 = abab is also present in sequence. Increment count by 1, count=2.\\n\\t4. Now, similarly word * (count+1) = ababab in not present in Sequence so return the last successful count (= 2).",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def maxRepeating(self, sequence: str, word: str) -> int:\\n        count=0\\n        while True:\\n            if word*(count+1) not in sequence:\\n                return count\\n            count+=1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1176449,
                "title": "c-without-using-library-function-100",
                "content": "Iterate over each index in \\'sequence\\' to find the potential starting point of the maximum length substring. <br>\\nThe inner while loop finds the max occurences of \\'word\\' starting from sequence[i].\\n\\n```\\n\\n    int maxRepeating(string s, string w) {\\n        int n = s.length(), ans =0;\\n        for(int i= 0, j=0, k=0, l=0; i<n; i++,j=0, k=0, l=0){\\n            while(i+j<n && s[i+j]==w[l]){\\n                j++;l++;\\n                if(l==w.length()) l=0, k++;\\n            }\\n            ans = max(ans, k);\\n        }\\n        return ans;\\n    }\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\n    int maxRepeating(string s, string w) {\\n        int n = s.length(), ans =0;\\n        for(int i= 0, j=0, k=0, l=0; i<n; i++,j=0, k=0, l=0){\\n            while(i+j<n && s[i+j]==w[l]){\\n                j++;l++;\\n                if(l==w.length()) l=0, k++;\\n            }\\n            ans = max(ans, k);\\n        }\\n        return ans;\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3314737,
                "title": "c-o-n-solution-with-constant-extra-space",
                "content": "# Intuition\\nTry to find the maximum continuous repetitions of word in the given sequence.\\n\\n# Approach\\n- Set Max=0, to store the max repititions.\\n- Set k=0, when we found a sequence without match to start from first.\\n- Now get all the posiible sliding window substrings and check if this is equal to word or not.\\n\\n# Complexity\\n- Time complexity:\\n    O(N)\\n\\n- Space complexity:\\n    O(1)\\n\\n# Testcase\\nSqequence : \"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\nWord : \"aaaba\"\\n\\nAns : 5\\n\\n**Explanation:**\\nWhen we are in i=10,j=14, it is not a match but the previous was a match.\\nSo we need to go to i=6,j=10 and continue the process, since our max sequence may start from here itself.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxRepeating(string seq, string word) {\\n        if(word.size()>seq.size()) return 0;\\n        int i=0,j=word.size()-1,k=0,Max=0;\\n        while(j<seq.size()){\\n            if(seq.substr(i,j-i+1)!=word){ // is the substring does\\'nt match\\n                if(k!=0){ // is the previous substring was a match, go to previous substring and start from next index.\\n                    i-=word.size();\\n                    j-=word.size();\\n                }\\n                i++; // just pass to next sliding window\\n                j++;\\n                k=0; // reset the value\\n            }\\n            else{ // if the substring is a match\\n                Max=max(Max,++k);\\n                i+=word.size();\\n                j+=word.size();\\n            }\\n        }\\n        return Max;\\n    }\\n};\\n\\n```\\n**Note :**\\n\\nif ( this solution was helpful ) {\\n    cout << \" Pls Upvote \" ;\\n}",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxRepeating(string seq, string word) {\\n        if(word.size()>seq.size()) return 0;\\n        int i=0,j=word.size()-1,k=0,Max=0;\\n        while(j<seq.size()){\\n            if(seq.substr(i,j-i+1)!=word){ // is the substring does\\'nt match\\n                if(k!=0){ // is the previous substring was a match, go to previous substring and start from next index.\\n                    i-=word.size();\\n                    j-=word.size();\\n                }\\n                i++; // just pass to next sliding window\\n                j++;\\n                k=0; // reset the value\\n            }\\n            else{ // if the substring is a match\\n                Max=max(Max,++k);\\n                i+=word.size();\\n                j+=word.size();\\n            }\\n        }\\n        return Max;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1400359,
                "title": "python3-simple-solution",
                "content": "We multiply the word and check occurence with `in`. \\n```\\nclass Solution:\\n    def maxRepeating(self, sequence: str, word: str) -> int:\\n        i = 0\\n        while word*(i+1) in sequence:\\n            i+=1\\n        return i\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxRepeating(self, sequence: str, word: str) -> int:\\n        i = 0\\n        while word*(i+1) in sequence:\\n            i+=1\\n        return i\\n```",
                "codeTag": "Java"
            },
            {
                "id": 952087,
                "title": "simple-java-added-example-for-better-understading",
                "content": "Pls add this example in description to avoid confusion.\\n\\n\"abab\"\\n\"b\"\\noutput: 1\\n\\nWith repeat method\\n```\\n    public int maxRepeating(String s, String w) {\\n        int n =s.length(), wn = w.length(), m = n/wn;\\n        for(int i=m; i>0; i--){\\n            if( s.indexOf(w.repeat(i)) >=0){\\n                return i;\\n            }\\n        }\\n        return 0;\\n    }\\n```\\n\\nWithout repeat method\\n\\n```\\n    public int maxRepeating(String s, String w) {\\n        int n =s.length(), wn = w.length(), m = n/wn, i=0;\\n        String tmp =w;\\n        while(i <=m ){\\n            if( s.indexOf(w) < 0){\\n                return i;\\n            }\\n            w+=tmp;\\n            i++;\\n        }\\n        return 0;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int maxRepeating(String s, String w) {\\n        int n =s.length(), wn = w.length(), m = n/wn;\\n        for(int i=m; i>0; i--){\\n            if( s.indexOf(w.repeat(i)) >=0){\\n                return i;\\n            }\\n        }\\n        return 0;\\n    }\\n```\n```\\n    public int maxRepeating(String s, String w) {\\n        int n =s.length(), wn = w.length(), m = n/wn, i=0;\\n        String tmp =w;\\n        while(i <=m ){\\n            if( s.indexOf(w) < 0){\\n                return i;\\n            }\\n            w+=tmp;\\n            i++;\\n        }\\n        return 0;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1878466,
                "title": "java-1ms-easy-solution",
                "content": "```\\nclass Solution {\\n    public int maxRepeating(String sequence, String word) {\\n      int count = -1;\\n      String s = \"\";\\n      do\\n      {\\n        count++;\\n        s += word;\\n      }while(sequence.contains(s));\\n      return count;\\n    }\\n}\\n```\\nComment if you have any doubt or suggestions\\nIf this approach helps you in any way then do upvote \\nHope you like it !",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxRepeating(String sequence, String word) {\\n      int count = -1;\\n      String s = \"\";\\n      do\\n      {\\n        count++;\\n        s += word;\\n      }while(sequence.contains(s));\\n      return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1434472,
                "title": "java-short-and-easy-solution-to-understand-runtime-1ms",
                "content": "```\\nclass Solution {\\n    public int maxRepeating(String sequence, String word) {\\n        String pat = word;\\n        int k = 0;\\n        while(true){\\n            if(sequence.indexOf(pat) != -1){\\n                k++;\\n                pat += word;\\n            }\\n            else{\\n                break;\\n            }\\n        }\\n        return k;\\n    }\\n}\\n```\\n\\nIf you like this solution please upvote.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxRepeating(String sequence, String word) {\\n        String pat = word;\\n        int k = 0;\\n        while(true){\\n            if(sequence.indexOf(pat) != -1){\\n                k++;\\n                pat += word;\\n            }\\n            else{\\n                break;\\n            }\\n        }\\n        return k;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1164988,
                "title": "rust-short-solution",
                "content": "```rust\\nimpl Solution {\\n    pub fn max_repeating(sequence: String, word: String) -> i32 {\\n        let max_word = word.repeat(sequence.len() / word.len());\\n        let mut n = max_word.len();\\n        while sequence.find(&max_word[..n]).is_none() {\\n            n -= word.len();\\n        }\\n        (n / word.len()) as _\\n    }\\n}\\n```\\n\\nWe can safely slice the `String`s wherever we want as we know that they\\'re valid ASCII.",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nimpl Solution {\\n    pub fn max_repeating(sequence: String, word: String) -> i32 {\\n        let max_word = word.repeat(sequence.len() / word.len());\\n        let mut n = max_word.len();\\n        while sequence.find(&max_word[..n]).is_none() {\\n            n -= word.len();\\n        }\\n        (n / word.len()) as _\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1022474,
                "title": "java-easy-too-understand",
                "content": "```\\nclass Solution {\\n    public int maxRepeating(String sequence, String word) {\\n        int count = 0;\\n        String tmp = word;\\n        \\n        while(sequence.contains(tmp)) {\\n            count++;\\n            tmp += word;\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxRepeating(String sequence, String word) {\\n        int count = 0;\\n        String tmp = word;\\n        \\n        while(sequence.contains(tmp)) {\\n            count++;\\n            tmp += word;\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 952240,
                "title": "explained-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxRepeating(string sequence, string word) {\\n        string ex=word; //store the string word in ex\\n        size_t found = sequence.find(word); //check the presence of word in sequence\\n        while(found != string::npos){\\n            word+=ex; //increase the size of word by adding ex( given word)\\n            found = sequence.find(word); //again check the presence of word in sequence\\n        }\\n\\t\\t//word.size()-ex.size() as this word is not present so subtract the last ex added \\n        return (word.size()-ex.size())/ex.size(); \\n    }\\n};\\n```\\n**Feel free to ask any question in the comment section.**\\nI hope that you\\'ve found the solution useful.\\nIn that case, **please do upvote and encourage me** to on my quest to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxRepeating(string sequence, string word) {\\n        string ex=word; //store the string word in ex\\n        size_t found = sequence.find(word); //check the presence of word in sequence\\n        while(found != string::npos){\\n            word+=ex; //increase the size of word by adding ex( given word)\\n            found = sequence.find(word); //again check the presence of word in sequence\\n        }\\n\\t\\t//word.size()-ex.size() as this word is not present so subtract the last ex added \\n        return (word.size()-ex.size())/ex.size(); \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2332901,
                "title": "python-easy-solution",
                "content": "```\\nclass Solution:\\n    def maxRepeating(self, sequence: str, word: str) -> int:\\n        k = 0\\n\\t\\t\\n        while True:\\n\\t\\t\\n            if k*word not in sequence:\\n                return k-1\\n\\t\\t\\t\\t\\n            k+=1\\n```\\n**Thanks for viewing.**",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def maxRepeating(self, sequence: str, word: str) -> int:\\n        k = 0\\n\\t\\t\\n        while True:\\n\\t\\t\\n            if k*word not in sequence:\\n                return k-1\\n\\t\\t\\t\\t\\n            k+=1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2166529,
                "title": "3-liner-c-solution",
                "content": "**Approach** - \\nKeep checking the substing and if it is present we append the initial substring and repeat the same.\\n\\n**i.e** - \\nsequence = \"bacacacbac\"  &  word = \"ac\"\\n\\nso at first we search \"**ac**\" in our string which is present at multiple places as \"b**ac**acacbac\" so it will return true, we concatenate \"**ac**\" to our word and keep searching for \"**acac**\" now which is also present as \"b**acac**acbac\". Similarly we keep on checking and get the desired output.\\n\\nMy code goes as - \\n\\n```\\nint maxRepeating(string sequence, string word) {\\n    string s = word;\\n    while(sequence.find(s) != string::npos) s+=word;\\n    return (s.size()/word.size()) - 1;\\n}\\n```\\n\\nTime Complexity = O(N*N)                 \\nSpace complexity = O(N)\\nwhere N is size of string to be fetched\\n\\nThanks for reading \\uD83D\\uDE0A",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint maxRepeating(string sequence, string word) {\\n    string s = word;\\n    while(sequence.find(s) != string::npos) s+=word;\\n    return (s.size()/word.size()) - 1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1947714,
                "title": "c-kmp-solution-o-n-n",
                "content": "Runtime: 0 ms, faster than 100.00% of C++ online submissions for Maximum Repeating Substring.\\nMemory Usage: 6.5 MB, less than 8.60% of C++ online submissions for Maximum Repeating Substring.\\n\\n```\\nBuild up the word string as long as word size less than sequence size.\\nThen preprocess LPS for updated word string.\\nRun KMP over updated word and sequence, now as soon as index pointer of word reaches\\nat some point where original word ends, means j % word length (original) == 0 then the\\nlength of the substring match is j / word length (original). Then we just need to get the\\nmaximum substring match length which is divisible by original word length.\\n```\\n\\n```\\nclass Solution {\\npublic:\\n    int maxRepeating(string s, string w) {\\n        \\n        // store original word length\\n        int wl = w.length();\\n        int sl = s.length();\\n        \\n        // build up word and preprocess LPS\\n        while(w.size() < sl)w+=w;\\n        \\n        vector<int>lps(w.length());\\n        lps[0] = 0;\\n        \\n        int i = 1;\\n        int j = 0;\\n        while(i < w.length())\\n        {\\n            if(w[i]==w[j])lps[i++]=++j;\\n            else\\n            {\\n                if(j==0)lps[i++]=0;\\n                else j = lps[j-1];\\n            }\\n        }\\n        \\n        // run KMP over updated word and sequence string\\n        i = 0;\\n        j = 0;\\n        int maxc = 0;\\n        while(i < sl)\\n        {\\n            if(s[i]==w[j])i++,++j;\\n            else\\n            {\\n                if(j==0)i++;\\n                else j = lps[j-1];\\n            }\\n            \\n\\n            // word pointer divisible by original word length and so is a repeated substring\\n            // repeat count => j / word length and track the max repeat\\n            if((j%wl)==0)\\n                maxc = max(maxc,j/wl);\\n        }\\n        \\n        // return max repeat count\\n        return maxc;        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nBuild up the word string as long as word size less than sequence size.\\nThen preprocess LPS for updated word string.\\nRun KMP over updated word and sequence, now as soon as index pointer of word reaches\\nat some point where original word ends, means j % word length (original) == 0 then the\\nlength of the substring match is j / word length (original). Then we just need to get the\\nmaximum substring match length which is divisible by original word length.\\n```\n```\\nclass Solution {\\npublic:\\n    int maxRepeating(string s, string w) {\\n        \\n        // store original word length\\n        int wl = w.length();\\n        int sl = s.length();\\n        \\n        // build up word and preprocess LPS\\n        while(w.size() < sl)w+=w;\\n        \\n        vector<int>lps(w.length());\\n        lps[0] = 0;\\n        \\n        int i = 1;\\n        int j = 0;\\n        while(i < w.length())\\n        {\\n            if(w[i]==w[j])lps[i++]=++j;\\n            else\\n            {\\n                if(j==0)lps[i++]=0;\\n                else j = lps[j-1];\\n            }\\n        }\\n        \\n        // run KMP over updated word and sequence string\\n        i = 0;\\n        j = 0;\\n        int maxc = 0;\\n        while(i < sl)\\n        {\\n            if(s[i]==w[j])i++,++j;\\n            else\\n            {\\n                if(j==0)i++;\\n                else j = lps[j-1];\\n            }\\n            \\n\\n            // word pointer divisible by original word length and so is a repeated substring\\n            // repeat count => j / word length and track the max repeat\\n            if((j%wl)==0)\\n                maxc = max(maxc,j/wl);\\n        }\\n        \\n        // return max repeat count\\n        return maxc;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1415449,
                "title": "c-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxRepeating(string seq, string word) {\\n        \\n        int n=word.length();\\n        char w = word[0];\\n        int i=0;\\n        int maxi=0;\\n        if(seq.length()<word.length())\\n            return false;\\n        while(i<(seq.length()-word.length()+1))\\n        {\\n            if(seq[i]==w)\\n            {\\n                int j=i;\\n                 int count=0;\\n                while(j<=(seq.length()-n))\\n                {\\n                    string k= seq.substr(j,n);\\n                    if(k==word)\\n                    {\\n                        count++;\\n                         j=j+n;\\n                    }              \\n                    else\\n                        break;\\n                }\\n                maxi = max(maxi,count);\\n            }   \\n            i++;\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxRepeating(string seq, string word) {\\n        \\n        int n=word.length();\\n        char w = word[0];\\n        int i=0;\\n        int maxi=0;\\n        if(seq.length()<word.length())\\n            return false;\\n        while(i<(seq.length()-word.length()+1))\\n        {\\n            if(seq[i]==w)\\n            {\\n                int j=i;\\n                 int count=0;\\n                while(j<=(seq.length()-n))\\n                {\\n                    string k= seq.substr(j,n);\\n                    if(k==word)\\n                    {\\n                        count++;\\n                         j=j+n;\\n                    }              \\n                    else\\n                        break;\\n                }\\n                maxi = max(maxi,count);\\n            }   \\n            i++;\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1081207,
                "title": "java-easy-solution-with-stringbuilder-beats-100",
                "content": "```\\nclass Solution {\\n    public int maxRepeating(String sequence, String word) {\\n        int count = 0;\\n        StringBuilder result = new StringBuilder();\\n        while(sequence.contains(result.append(word).toString())) count++;\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int maxRepeating(String sequence, String word) {\\n        int count = 0;\\n        StringBuilder result = new StringBuilder();\\n        while(sequence.contains(result.append(word).toString())) count++;\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 982082,
                "title": "naive-javascript-implementation-while-loop-no-recursion",
                "content": "```\\nconst maxRepeating = (sequence, word) => {\\n    let str = word;\\n    let counter = 0;\\n    while (sequence.includes(str)) {\\n        counter++;\\n        str += word;\\n    }\\n    return counter;\\n};\\n```\\n\\n76ms / faster than 90%",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst maxRepeating = (sequence, word) => {\\n    let str = word;\\n    let counter = 0;\\n    while (sequence.includes(str)) {\\n        counter++;\\n        str += word;\\n    }\\n    return counter;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 952369,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public int maxRepeating(String sequence, String word) {\\n        \\n         \\n        String w1 = word;\\n        int res = 0;\\n        while (w1.length() <= sequence.length()) {\\n            if (sequence.contains(w1)) {\\n                res++;\\n                w1 += word;\\n            } else {\\n                break;\\n            }\\n        }\\n        \\n        return res;\\n}\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int maxRepeating(String sequence, String word) {\\n        \\n         \\n        String w1 = word;\\n        int res = 0;\\n        while (w1.length() <= sequence.length()) {\\n            if (sequence.contains(w1)) {\\n                res++;\\n                w1 += word;\\n            } else {\\n                break;\\n            }\\n        }\\n        \\n        return res;\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 952341,
                "title": "c-simple-bf",
                "content": "```\\npublic class Solution {\\n    public int MaxRepeating(string sequence, string word) {\\n        int max = 0;\\n        string test = word;\\n        while(true)\\n        {\\n            if(sequence.Contains(test))\\n            {\\n                max++;\\n                test += word;\\n            }\\n            else\\n                break;\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MaxRepeating(string sequence, string word) {\\n        int max = 0;\\n        string test = word;\\n        while(true)\\n        {\\n            if(sequence.Contains(test))\\n            {\\n                max++;\\n                test += word;\\n            }\\n            else\\n                break;\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 952018,
                "title": "python-3-two-solutions-and-one-liner",
                "content": "\\nNon Brute Force:\\nTime complexity O(n)\\nSpace complexity O(1)\\n```\\nclass Solution:\\n    def maxRepeating(self, sequence: str, word: str) -> int:\\n        n=len(sequence)\\n        wn=len(word)\\n        maxrepeat=0\\n        i=0\\n        while i<=n-maxrepeat*wn:\\n            j=0\\n            while i+j<n and sequence[i+j]==word[j%wn]:\\n                j+=1\\n            maxrepeat=max(maxrepeat,j//wn)\\n            i+=1\\n        return maxrepeat\\n```\\nUnfortunately, Brute Force works.\\n\\n```\\nclass Solution:\\n    def maxRepeating(self, sequence: str, word: str) -> int:\\n        maxrepeat=0\\n        while maxrepeat*word in sequence: maxrepeat+=1\\n        return maxrepeat-1\\n```\\nTime complexity O(n^2)\\nSpace complexity O(1)\\n\\nBrute Force One line version:\\n```\\n    def maxRepeating(self, s, w):\\n        return sum(w * i in s for i in range(1, len(s)//len(w)+1))\\n```\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxRepeating(self, sequence: str, word: str) -> int:\\n        n=len(sequence)\\n        wn=len(word)\\n        maxrepeat=0\\n        i=0\\n        while i<=n-maxrepeat*wn:\\n            j=0\\n            while i+j<n and sequence[i+j]==word[j%wn]:\\n                j+=1\\n            maxrepeat=max(maxrepeat,j//wn)\\n            i+=1\\n        return maxrepeat\\n```\n```\\nclass Solution:\\n    def maxRepeating(self, sequence: str, word: str) -> int:\\n        maxrepeat=0\\n        while maxrepeat*word in sequence: maxrepeat+=1\\n        return maxrepeat-1\\n```\n```\\n    def maxRepeating(self, s, w):\\n        return sum(w * i in s for i in range(1, len(s)//len(w)+1))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 951979,
                "title": "java-brute-force",
                "content": "```\\nclass Solution {\\n    public int maxRepeating(String s, String word) {\\n        int n = s.length(), m = word.length();\\n        int max = 0;\\n        outer : for(int i = 0; i < n - m + 1; i++) {\\n            int count = 0, k = 0;\\n            for(int j = i; j < n; j++) {\\n                if(s.charAt(j) != word.charAt(k)) continue outer;\\n                k++;\\n                if(k == m) {\\n                    count++;\\n                    k = 0;\\n                    max = Math.max(max, count);\\n                }\\n            }\\n            max = Math.max(max, count);\\n        }\\n        return max;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int maxRepeating(String s, String word) {\\n        int n = s.length(), m = word.length();\\n        int max = 0;\\n        outer : for(int i = 0; i < n - m + 1; i++) {\\n            int count = 0, k = 0;\\n            for(int j = i; j < n; j++) {\\n                if(s.charAt(j) != word.charAt(k)) continue outer;\\n                k++;\\n                if(k == m) {\\n                    count++;\\n                    k = 0;\\n                    max = Math.max(max, count);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 951976,
                "title": "java-binary-search",
                "content": "```\\nclass Solution {\\n    public int maxRepeating(String sequence, String word) {\\n        int lo = 0;\\n        int hi = sequence.length()/word.length()+1;\\n        while(lo<hi){\\n            int mid = (lo+hi+1)/2;\\n            if(isFeasible(sequence, word, mid)){\\n                lo = mid;\\n            }\\n            else{\\n                hi = mid-1;\\n            }\\n        }\\n        return lo;\\n    }\\n    \\n    public boolean isFeasible(String sequence, String word, int k){\\n        StringBuilder sb = new StringBuilder();\\n        for(int i=0; i<k; i++){\\n            sb.append(word);\\n        }\\n        int index = sequence.indexOf(sb.toString());\\n        return index>=0;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxRepeating(String sequence, String word) {\\n        int lo = 0;\\n        int hi = sequence.length()/word.length()+1;\\n        while(lo<hi){\\n            int mid = (lo+hi+1)/2;\\n            if(isFeasible(sequence, word, mid)){\\n                lo = mid;\\n            }\\n            else{\\n                hi = mid-1;\\n            }\\n        }\\n        return lo;\\n    }\\n    \\n    public boolean isFeasible(String sequence, String word, int k){\\n        StringBuilder sb = new StringBuilder();\\n        for(int i=0; i<k; i++){\\n            sb.append(word);\\n        }\\n        int index = sequence.indexOf(sb.toString());\\n        return index>=0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3572251,
                "title": "smallest-code-possible-unique-approach-beats-100-c-detailed-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIt starts by initializing a temporary string temp with the value of word. This temporary string will be used to check for consecutive repetitions.\\n\\nIt sets a flag variable flag to true, indicating that we should continue checking for repetitions until proven otherwise.\\n\\nIt initializes a variable ans to 0, which will keep track of the maximum number of repetitions found.\\n\\nThe code enters a while loop that continues as long as the flag is true. This loop will break when no more repetitions are found.\\n\\nWithin the loop, it uses the find function to check if temp (the current value of repetitions) can be found in sequence. If a match is found (i.e., find does not return npos), it means temp is present in sequence.\\n\\nIf a match is found, it increments ans by 1 to indicate that another repetition has been found.\\n\\nIt then appends word to the end of temp, effectively increasing its length. This step ensures that the code looks for the next consecutive repetition of word in sequence.\\n\\nIf no match is found, the code sets flag to false, indicating that there are no more repetitions to be found, and the while loop should terminate.\\n\\nFinally, the code returns the value of ans, which represents the maximum number of consecutive repetitions of word found in sequence.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- O(N * M)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxRepeating(string sequence, string word) {\\n        string temp = word;\\n        bool flag = true;\\n\\n        int ans = 0;\\n        while(flag){\\n            if(sequence.find(temp)!=string::npos){\\n                ans++;\\n                temp+=word;\\n            }\\n            else flag = false;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxRepeating(string sequence, string word) {\\n        string temp = word;\\n        bool flag = true;\\n\\n        int ans = 0;\\n        while(flag){\\n            if(sequence.find(temp)!=string::npos){\\n                ans++;\\n                temp+=word;\\n            }\\n            else flag = false;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3470022,
                "title": "96-86-beatable-easy-js-sol-understandable-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n- We can find the maximum k-repeating value of a word in a given sequence using **linear search**. \\n- However, ***binary search*** can provide a ***more optimized solution*** with a ***lower time complexity than linear search***. \\n- The time complexity of **binary search is O(log n)**, while the **time complexity of linear search is O(n)**.\\n\\n\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nIn this implementation :-\\n1. I have first initialized a left pointer to 0 and a right pointer to ***Math.floor(sequence.length / word.length)***, which represents the maximum possible value of **k** for which the word can be k-repeating in the sequence. \\n2. Then, I performed binary search on the range ***[left, right]*** to find the maximum k-repeating value of the word in the sequence. \\n3. Then, I repeatedly checked if the word is k-repeating in the sequence by checking if the sequence includes the string ***word.repeat(mid)*** for some mid between left and right. \\n4. If it is, I updated the answer to ***mid*** and search for a higher value of ***k*** to the ***right of mid***. \\n5. If it\\'s not, I searched for a ***lower*** value of ***k*** to the ***left of mid***.\\n\\n\\n\\n\\n\\n# Complexity\\n- Time complexity: $$O(log n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n1. Here n is the length of the sequence. \\n2. This is because the function uses ***binary search*** to find the maximum k-repeating value of the word in the sequence.\\n3. And ***Binary search has a time complexity of O(log n)***.\\n \\n\\n\\n\\n\\n\\n\\n\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n1. Because it only uses a fixed amount of extra memory to store the variables **right**, **left** and **ans**. \\n2. The input parameters **sequence** and **word** are not counted towards the space complexity, as they are part of the input to the function.\\n\\n\\n\\n\\n\\n\\n\\n\\n# Code\\n```\\n/**\\n * @param {string} sequence\\n * @param {string} word\\n * @return {number}\\n */\\nvar maxRepeating = function(sequence, word) {\\n  \\n  let right = Math.floor(sequence.length / word.length);\\n\\n  let left = 0;\\n  \\n  let ans = 0;\\n  \\n  while (left <= right) {\\n    \\n    let mid = Math.floor((left + right) / 2);\\n    \\n    if (sequence.includes(word.repeat(mid))) {\\n      \\n      ans = mid;\\n      \\n      left = mid + 1;\\n    }\\n    else {\\n      \\n      right = mid - 1;\\n    }\\n  }\\n  return ans;\\n};\\n```\\n\\n![cat img for upvote on LC.jpeg](https://assets.leetcode.com/users/images/f41a1d81-17dc-4dd4-a5a1-d7c174ba2c94_1682860320.806763.jpeg)\\n",
                "solutionTags": [
                    "JavaScript",
                    "String",
                    "Binary Search",
                    "String Matching"
                ],
                "code": "```\\n/**\\n * @param {string} sequence\\n * @param {string} word\\n * @return {number}\\n */\\nvar maxRepeating = function(sequence, word) {\\n  \\n  let right = Math.floor(sequence.length / word.length);\\n\\n  let left = 0;\\n  \\n  let ans = 0;\\n  \\n  while (left <= right) {\\n    \\n    let mid = Math.floor((left + right) / 2);\\n    \\n    if (sequence.includes(word.repeat(mid))) {\\n      \\n      ans = mid;\\n      \\n      left = mid + 1;\\n    }\\n    else {\\n      \\n      right = mid - 1;\\n    }\\n  }\\n  return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3158044,
                "title": "python3-o-n-2-solution-intuitive",
                "content": "O(n^2) still but found it to be more intuitive than the top solutions\\n\\n# Code\\n```\\nclass Solution:\\n    def maxRepeating(self, sequence: str, word: str) -> int:\\n        i = 0\\n        j = 0\\n        max_ct = 0\\n\\n        if len(word) > len(sequence):\\n            return 0\\n\\n        ct = 0\\n        while i < len(sequence):\\n            while sequence[j:j+len(word)] == word:\\n                ct += 1\\n                j += len(word)\\n            max_ct = max(max_ct, ct)\\n            ct = 0\\n            i += 1\\n            j = i\\n        return max_ct\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxRepeating(self, sequence: str, word: str) -> int:\\n        i = 0\\n        j = 0\\n        max_ct = 0\\n\\n        if len(word) > len(sequence):\\n            return 0\\n\\n        ct = 0\\n        while i < len(sequence):\\n            while sequence[j:j+len(word)] == word:\\n                ct += 1\\n                j += len(word)\\n            max_ct = max(max_ct, ct)\\n            ct = 0\\n            i += 1\\n            j = i\\n        return max_ct\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3147455,
                "title": "java-easy-solution-1ms-93-94-faster",
                "content": "![image](https://assets.leetcode.com/users/images/929a6868-a635-4a0e-b250-feff9bd4052d_1675619189.8564208.png)\\n```\\nclass Solution {\\n    public int maxRepeating(String s, String w) {\\n        if(w.length()>s.length()) return 0;\\n        int ans=0;\\n        StringBuilder sb=new StringBuilder(\"\");\\n        while(sb.length()<=s.length()){\\n            sb.append(w);\\n            if(s.contains(sb)) ans++;\\n            else break;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int maxRepeating(String s, String w) {\\n        if(w.length()>s.length()) return 0;\\n        int ans=0;\\n        StringBuilder sb=new StringBuilder(\"\");\\n        while(sb.length()<=s.length()){\\n            sb.append(w);\\n            if(s.contains(sb)) ans++;\\n            else break;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2138314,
                "title": "c-100-faster-4-liner-string-simple-solution-easy-find-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxRepeating(string s, string s1) {\\n        int m = s1.size(),n = s.size(),i = 1;\\n        string temp = s1;\\n        while(s.find(temp) != string::npos && i++) temp += s1;\\n        return i - 1;\\n    }\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/30b50c4d-d54e-4713-8aab-80bfd99dd7d0_1654951754.358517.png)\\n## UPVOTE IF YOU LIKE\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxRepeating(string s, string s1) {\\n        int m = s1.size(),n = s.size(),i = 1;\\n        string temp = s1;\\n        while(s.find(temp) != string::npos && i++) temp += s1;\\n        return i - 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2026654,
                "title": "java-easy-1ms-solution",
                "content": "```\\nclass Solution {\\n    public int maxRepeating(String sequence, String word) {\\n       String tbf = word;\\n        int count=0;\\n        while(sequence.contains(tbf))\\n        {\\n            tbf+=word;\\n            count++;\\n            \\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxRepeating(String sequence, String word) {\\n       String tbf = word;\\n        int count=0;\\n        while(sequence.contains(tbf))\\n        {\\n            tbf+=word;\\n            count++;\\n            \\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1583577,
                "title": "java-o-n-easy-solution-100-faster-0-ms",
                "content": "```\\n StringBuffer sb=new StringBuffer(sequence.length());\\n        sb.append(word);\\n        int maxK=0;\\n        while(sequence.indexOf(sb.toString())>=0)\\n        {\\n            sb.append(word);\\n            maxK++;\\n        }\\n        return maxK;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n StringBuffer sb=new StringBuffer(sequence.length());\\n        sb.append(word);\\n        int maxK=0;\\n        while(sequence.indexOf(sb.toString())>=0)\\n        {\\n            sb.append(word);\\n            maxK++;\\n        }\\n        return maxK;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1573469,
                "title": "c-easy-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxRepeating(string sequence, string word) {\\n        int k=0,cnt=0;\\n        string res=\"\";\\n        while(k<sequence.size()){\\n            k+=word.size();\\n            \\n            res+=word;\\n            if(sequence.find(res)==string::npos)break;\\n            cnt++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxRepeating(string sequence, string word) {\\n        int k=0,cnt=0;\\n        string res=\"\";\\n        while(k<sequence.size()){\\n            k+=word.size();\\n            \\n            res+=word;\\n            if(sequence.find(res)==string::npos)break;\\n            cnt++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1503892,
                "title": "simple-c-solution-0-ms",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxRepeating(string sequence, string word) {\\n       if (sequence.size() < word.size()) return 0;\\n       if (sequence.find(word) == string::npos)\\n       {\\n           return 0;\\n       }\\n        \\n        int ans = 1;\\n        string tmp = word;\\n        while(word.size() <= sequence.size())\\n        {\\n            word+=tmp;\\n            if (sequence.find(word) == string::npos)\\n            {\\n                break;\\n            }\\n            ans++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxRepeating(string sequence, string word) {\\n       if (sequence.size() < word.size()) return 0;\\n       if (sequence.find(word) == string::npos)\\n       {\\n           return 0;\\n       }\\n        \\n        int ans = 1;\\n        string tmp = word;\\n        while(word.size() <= sequence.size())\\n        {\\n            word+=tmp;\\n            if (sequence.find(word) == string::npos)\\n            {\\n                break;\\n            }\\n            ans++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1398547,
                "title": "c-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxRepeating(string sequence, string word) {\\n        string str=word;\\n        int count=0;\\n        while(sequence.find(word)!=string::npos){\\n            count++;\\n            word+=str;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxRepeating(string sequence, string word) {\\n        string str=word;\\n        int count=0;\\n        while(sequence.find(word)!=string::npos){\\n            count++;\\n            word+=str;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1381592,
                "title": "swift-maximum-repeating-substring-test-cases",
                "content": "```swift\\nclass Solution {\\n    func maxRepeating(_ sequence: String, _ word: String) -> Int {\\n        let max = sequence.count / word.count\\n        guard max > 0 else { return 0 }\\n        var result = 0\\n        for count in 1...max where sequence.contains(String(repeating: word, count: count)) {\\n            result = count\\n        }\\n        return result\\n    }\\n}\\n```\\n\\n```swift\\nimport XCTest\\n\\n// Executed 3 tests, with 0 failures (0 unexpected) in 0.014 (0.016) seconds\\n\\nclass Tests: XCTestCase {\\n    private let s = Solution()\\n    func test0() {\\n        let res = s.maxRepeating(\"ababc\",\"ab\")\\n        XCTAssertEqual(res, 2)\\n    }\\n    func test1() {\\n        let res = s.maxRepeating(\"ababc\",\"ba\")\\n        XCTAssertEqual(res, 1)\\n    }\\n    func test2() {\\n        let res = s.maxRepeating(\"ababc\",\"ac\")\\n        XCTAssertEqual(res, 0)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func maxRepeating(_ sequence: String, _ word: String) -> Int {\\n        let max = sequence.count / word.count\\n        guard max > 0 else { return 0 }\\n        var result = 0\\n        for count in 1...max where sequence.contains(String(repeating: word, count: count)) {\\n            result = count\\n        }\\n        return result\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\n// Executed 3 tests, with 0 failures (0 unexpected) in 0.014 (0.016) seconds\\n\\nclass Tests: XCTestCase {\\n    private let s = Solution()\\n    func test0() {\\n        let res = s.maxRepeating(\"ababc\",\"ab\")\\n        XCTAssertEqual(res, 2)\\n    }\\n    func test1() {\\n        let res = s.maxRepeating(\"ababc\",\"ba\")\\n        XCTAssertEqual(res, 1)\\n    }\\n    func test2() {\\n        let res = s.maxRepeating(\"ababc\",\"ac\")\\n        XCTAssertEqual(res, 0)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1322910,
                "title": "python-faster-than-99-5-of-the-submissions",
                "content": "```  \\ndef maxRepeating(self, sequence: str, word: str) -> int:\\n        if word not in sequence:\\n            return 0\\n        elif(len(word) == len(sequence)):\\n            return 1\\n        else:\\n            counter = len(sequence)//len(word)\\n            \\n            max_iter = 0\\n            for i in range(1, counter+1):\\n                if(i*len(word) <= len(sequence)):\\n                    if(i*word) in sequence:\\n                        max_iter = i\\n            return max_iter\\n",
                "solutionTags": [],
                "code": "```  \\ndef maxRepeating(self, sequence: str, word: str) -> int:\\n        if word not in sequence:\\n            return 0\\n        elif(len(word) == len(sequence)):\\n            return 1\\n        else:\\n            counter = len(sequence)//len(word)\\n            \\n            max_iter = 0\\n            for i in range(1, counter+1):\\n                if(i*len(word) <= len(sequence)):\\n                    if(i*word) in sequence:\\n                        max_iter = i\\n            return max_iter\\n",
                "codeTag": "Python3"
            },
            {
                "id": 1245851,
                "title": "c-100-fast-easy-to-understand-optimized-code",
                "content": "**Please upvote to motivate me in my quest of documenting all leetcode solutions. HAPPY CODING:)**\\n```\\nclass Solution {\\npublic:\\n    int maxRepeating(string sequence, string word) {\\n        if(word.length()>sequence.length())\\n          return 0;  \\n        string str;\\n        int c=0;\\n        int ans=0;\\n        bool entered=false;\\n        int i=0;\\n        while(i<=(sequence.length()-word.length()))\\n        {\\n            str=sequence.substr(i,word.length());\\n            if(str==word)\\n            {\\n             entered=true;   \\n            c++;\\n            ans=max(c,ans);\\n            i+=word.length();\\n            }   \\n          else\\n             {\\n             if(entered)\\n             {\\n                 c=0;\\n                 i+=1-word.length();\\n                 entered=false;\\n             }\\n                 else\\n                 {\\n                   i++;\\n                 }\\n            }      \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxRepeating(string sequence, string word) {\\n        if(word.length()>sequence.length())\\n          return 0;  \\n        string str;\\n        int c=0;\\n        int ans=0;\\n        bool entered=false;\\n        int i=0;\\n        while(i<=(sequence.length()-word.length()))\\n        {\\n            str=sequence.substr(i,word.length());\\n            if(str==word)\\n            {\\n             entered=true;   \\n            c++;\\n            ans=max(c,ans);\\n            i+=word.length();\\n            }   \\n          else\\n             {\\n             if(entered)\\n             {\\n                 c=0;\\n                 i+=1-word.length();\\n                 entered=false;\\n             }\\n                 else\\n                 {\\n                   i++;\\n                 }\\n            }      \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1203226,
                "title": "golang-o-n-one-pass",
                "content": "```\\nfunc maxRepeating(seq string, word string) int {\\n\\tvar mx, cur int\\n\\twl := len(word)\\n\\tfor i := 0; i <= len(seq)-wl; i++ {\\n\\t\\tif seq[i:i+wl] == word {\\n\\t\\t\\tcur++\\n\\t\\t\\ti += wl - 1\\n\\t\\t} else {\\n\\t\\t\\ti -= cur * wl\\n\\t\\t\\tcur = 0\\n\\n\\t\\t}\\n\\t\\tif cur > mx {\\n\\t\\t\\tmx = cur\\n\\t\\t}\\n\\t}\\n\\treturn mx\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc maxRepeating(seq string, word string) int {\\n\\tvar mx, cur int\\n\\twl := len(word)\\n\\tfor i := 0; i <= len(seq)-wl; i++ {\\n\\t\\tif seq[i:i+wl] == word {\\n\\t\\t\\tcur++\\n\\t\\t\\ti += wl - 1\\n\\t\\t} else {\\n\\t\\t\\ti -= cur * wl\\n\\t\\t\\tcur = 0\\n\\n\\t\\t}\\n\\t\\tif cur > mx {\\n\\t\\t\\tmx = cur\\n\\t\\t}\\n\\t}\\n\\treturn mx\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1162047,
                "title": "simple-clean-java-solution-for-slow-learners-like-myself",
                "content": "Runtime: O(n^2)\\n\\n```\\nclass Solution {\\n    public int maxRepeating(String sequence, String word) {\\n        sequence = sequence == null ? \"\" : sequence;\\n        word = word == null ? \"\" : word;\\n        \\n        int i = 0, max = 0;\\n        \\n        for (; i + word.length() <= sequence.length(); i++) {\\n            int count = 0;\\n            for (int j = i; sequence.startsWith(word, j); j += word.length())\\n                count++;\\n            \\n            max = Math.max(max, count);\\n        }\\n        \\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxRepeating(String sequence, String word) {\\n        sequence = sequence == null ? \"\" : sequence;\\n        word = word == null ? \"\" : word;\\n        \\n        int i = 0, max = 0;\\n        \\n        for (; i + word.length() <= sequence.length(); i++) {\\n            int count = 0;\\n            for (int j = i; sequence.startsWith(word, j); j += word.length())\\n                count++;\\n            \\n            max = Math.max(max, count);\\n        }\\n        \\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 991458,
                "title": "java-o-n-kmp-dp",
                "content": "```\\nclass Solution {\\n    public int maxRepeating(String sequence, String word) {\\n        int m = word.length(), n = sequence.length();\\n \\xA0 \\xA0 \\xA0 \\xA0// Find LP\\n        int[] dp = new int[m];\\n        char[] w = word.toCharArray();\\n        for(int i = 0, j = 1; j < m;) {\\n            if(w[i] == w[j]) {\\n                dp[j++] = ++i;\\n            } else if(i == 0) {\\n                j++;\\n            } else {\\n                i = dp[i-1];\\n            }\\n        }\\n        // Standard KMP with an array to record then number of repeating seq\\n        char[] s = sequence.toCharArray();\\n        int res = 0;\\n        int[] count = new int[n+1];\\n        for(int i = 0, j = 0; i < n;) {\\n            if(s[i] != w[j]) {\\n                if(j == 0) {\\n                    i++;\\n                } else {\\n                    j = dp[j-1];                \\n                }\\n            } else if(j == m-1) {\\n                count[i+1] = count[i - j] + 1;\\n                res = Math.max(res, count[i+1]);\\n                if(j == 0) {\\n                    i++;\\n                } else {\\n                    j = dp[j-1];\\n                }\\n            } else {\\n                i++;\\n                j++;            \\n            }\\n        }\\n        return res;\\n    }\\n}\\n```\\nKMP is really just a standard KMP. A count array is the only thing that needs to be added.\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxRepeating(String sequence, String word) {\\n        int m = word.length(), n = sequence.length();\\n \\xA0 \\xA0 \\xA0 \\xA0// Find LP\\n        int[] dp = new int[m];\\n        char[] w = word.toCharArray();\\n        for(int i = 0, j = 1; j < m;) {\\n            if(w[i] == w[j]) {\\n                dp[j++] = ++i;\\n            } else if(i == 0) {\\n                j++;\\n            } else {\\n                i = dp[i-1];\\n            }\\n        }\\n        // Standard KMP with an array to record then number of repeating seq\\n        char[] s = sequence.toCharArray();\\n        int res = 0;\\n        int[] count = new int[n+1];\\n        for(int i = 0, j = 0; i < n;) {\\n            if(s[i] != w[j]) {\\n                if(j == 0) {\\n                    i++;\\n                } else {\\n                    j = dp[j-1];                \\n                }\\n            } else if(j == m-1) {\\n                count[i+1] = count[i - j] + 1;\\n                res = Math.max(res, count[i+1]);\\n                if(j == 0) {\\n                    i++;\\n                } else {\\n                    j = dp[j-1];\\n                }\\n            } else {\\n                i++;\\n                j++;            \\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 989556,
                "title": "python-4-line-easy",
                "content": "```\\nclass Solution:\\n    def maxRepeating(self, sequence: str, word: str) -> int:\\n        l = len(sequence) // len(word)\\n        for i in range(l, -1, -1):\\n            if word * i in sequence:\\n                return i\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxRepeating(self, sequence: str, word: str) -> int:\\n        l = len(sequence) // len(word)\\n        for i in range(l, -1, -1):\\n            if word * i in sequence:\\n                return i\\n",
                "codeTag": "Java"
            },
            {
                "id": 964982,
                "title": "javascript-1-line-recursive-solution",
                "content": "> Runtime: *80 ms*, faster than **75.16%** of JavaScript online submissions\\n> Memory Usage: *38.7 MB*, less than **53.59%** of JavaScript online submissions\\n\\n```javascript\\nconst maxRepeating = (sequence, word, needle = \\'\\') =>\\n !sequence.includes(`${needle}${word}`)\\n   ? needle.length / word.length\\n   : maxRepeating(sequence, word, `${needle}${word}`);\\n```\\n\\nAnd this obvious variant has about the same performance.\\n\\n> Runtime: *80 ms*, faster than **75.16%** of JavaScript online submissions\\n> Memory Usage: *38.7 MB*, less than **53.59%** of JavaScript online submissions\\n\\n```javascript\\nconst maxRepeating = (sequence, word, cnt = 0) =>\\n  !sequence.includes(word.repeat(cnt + 1))\\n    ? cnt\\n    : maxRepeating(sequence, word, cnt + 1);\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```javascript\\nconst maxRepeating = (sequence, word, needle = \\'\\') =>\\n !sequence.includes(`${needle}${word}`)\\n   ? needle.length / word.length\\n   : maxRepeating(sequence, word, `${needle}${word}`);\\n```\n```javascript\\nconst maxRepeating = (sequence, word, cnt = 0) =>\\n  !sequence.includes(word.repeat(cnt + 1))\\n    ? cnt\\n    : maxRepeating(sequence, word, cnt + 1);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 952681,
                "title": "python-a-simple-brute-force-solution-using-membership-operator",
                "content": "```\\nclass Solution:\\n    def maxRepeating(self, sequence: str, word: str) -> int:\\n        count = 0\\n        while word * (count + 1) in sequence:\\n            count +=  1        \\n        return count\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxRepeating(self, sequence: str, word: str) -> int:\\n        count = 0\\n        while word * (count + 1) in sequence:\\n            count +=  1        \\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 952451,
                "title": "javascript-simple-solution",
                "content": "```\\n/**\\n * @param {string} sequence\\n * @param {string} word\\n * @return {number}\\n */\\nconst maxRepeating = function(sequence, word) {\\n  let str = word\\n\\n  for (let i = 1; ; i++) {\\n   if(!sequence.includes(str)) {\\n     return i - 1\\n   }\\n\\n   str += word\\n  }\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} sequence\\n * @param {string} word\\n * @return {number}\\n */\\nconst maxRepeating = function(sequence, word) {\\n  let str = word\\n\\n  for (let i = 1; ; i++) {\\n   if(!sequence.includes(str)) {\\n     return i - 1\\n   }\\n\\n   str += word\\n  }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 952084,
                "title": "java-o-n",
                "content": "```\\npublic int maxRepeating(String sequence, String word) {\\n\\tint result = 0, currentRepeatation = 0, j =0, previousI = 0;\\n\\tfor (int i=0; i<sequence.length(); i++) {\\n\\t\\tif (sequence.charAt(i) != word.charAt(j)) {\\n\\t\\t\\tif (currentRepeatation == 0) {\\n\\t\\t\\t\\tif (j != 0) {\\n\\t\\t\\t\\t\\ti = i - j + 1;\\n\\t\\t\\t\\t\\tj = 0;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\ti = previousI + 1;\\n\\t\\t\\t\\tj = 0;\\n\\t\\t\\t\\tcurrentRepeatation = 0;\\n\\t\\t\\t}\\n\\t\\t\\tpreviousI = i;\\n\\t\\t}\\n\\t\\tif(sequence.charAt(i) == word.charAt(j) && ++j==word.length()) {\\n\\t\\t\\tj=0;\\n\\t\\t\\tresult = Math.max(result, ++currentRepeatation);\\n\\t\\t}\\n\\t}\\n\\treturn result;\\n}\\n```\\n\\nAccepted alternative solution\\n```\\npublic int maxRepeating(String sequence, String word) {\\n\\tint result = 0, currentRepeatation = 0;\\n\\tint [] prefix = new int[word.length()];\\n\\tfor(int i=1, j=0; i<word.length(); i++)\\n\\t\\tif (word.charAt(i) == word.charAt(j)) prefix[i] = ++j;\\n\\t\\telse j=0;\\n\\tint tempI = 0, tempJ = 0;\\n\\tfor (int i=0, j=0; i<sequence.length(); i++) {\\n\\t\\tif (currentRepeatation == 0)\\n\\t\\t\\twhile (j != 0 && sequence.charAt(i) != word.charAt(j))\\n\\t\\t\\t\\tj = prefix[j-1];\\n\\t\\telse if(sequence.charAt(i) != word.charAt(j)) {\\n\\t\\t\\tcurrentRepeatation = 0;\\n\\t\\t\\ti = tempI + 1;\\n\\t\\t\\tj = prefix[tempJ - 1];\\n\\t\\t}\\n\\t\\tif(sequence.charAt(i) == word.charAt(j) && ++j==word.length()) {\\n\\t\\t\\ttempI = i;\\n\\t\\t\\ttempJ = j;\\n\\t\\t\\tj=0;\\n\\t\\t\\tresult = Math.max(result, ++currentRepeatation);\\n\\t\\t}\\n\\t}\\n\\treturn result;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int maxRepeating(String sequence, String word) {\\n\\tint result = 0, currentRepeatation = 0, j =0, previousI = 0;\\n\\tfor (int i=0; i<sequence.length(); i++) {\\n\\t\\tif (sequence.charAt(i) != word.charAt(j)) {\\n\\t\\t\\tif (currentRepeatation == 0) {\\n\\t\\t\\t\\tif (j != 0) {\\n\\t\\t\\t\\t\\ti = i - j + 1;\\n\\t\\t\\t\\t\\tj = 0;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\ti = previousI + 1;\\n\\t\\t\\t\\tj = 0;\\n\\t\\t\\t\\tcurrentRepeatation = 0;\\n\\t\\t\\t}\\n\\t\\t\\tpreviousI = i;\\n\\t\\t}\\n\\t\\tif(sequence.charAt(i) == word.charAt(j) && ++j==word.length()) {\\n\\t\\t\\tj=0;\\n\\t\\t\\tresult = Math.max(result, ++currentRepeatation);\\n\\t\\t}\\n\\t}\\n\\treturn result;\\n}\\n```\n```\\npublic int maxRepeating(String sequence, String word) {\\n\\tint result = 0, currentRepeatation = 0;\\n\\tint [] prefix = new int[word.length()];\\n\\tfor(int i=1, j=0; i<word.length(); i++)\\n\\t\\tif (word.charAt(i) == word.charAt(j)) prefix[i] = ++j;\\n\\t\\telse j=0;\\n\\tint tempI = 0, tempJ = 0;\\n\\tfor (int i=0, j=0; i<sequence.length(); i++) {\\n\\t\\tif (currentRepeatation == 0)\\n\\t\\t\\twhile (j != 0 && sequence.charAt(i) != word.charAt(j))\\n\\t\\t\\t\\tj = prefix[j-1];\\n\\t\\telse if(sequence.charAt(i) != word.charAt(j)) {\\n\\t\\t\\tcurrentRepeatation = 0;\\n\\t\\t\\ti = tempI + 1;\\n\\t\\t\\tj = prefix[tempJ - 1];\\n\\t\\t}\\n\\t\\tif(sequence.charAt(i) == word.charAt(j) && ++j==word.length()) {\\n\\t\\t\\ttempI = i;\\n\\t\\t\\ttempJ = j;\\n\\t\\t\\tj=0;\\n\\t\\t\\tresult = Math.max(result, ++currentRepeatation);\\n\\t\\t}\\n\\t}\\n\\treturn result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 952063,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxRepeating(string sequence, string word) {\\n        string str = word;\\n        int N = sequence.length()/word.length();\\n        int cnt = 0;\\n        for (int i = 1; i <= N; i++) {\\n            if (sequence.find(str) == string::npos) {\\n                break;\\n            }\\n            str += word;\\n            cnt++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxRepeating(string sequence, string word) {\\n        string str = word;\\n        int N = sequence.length()/word.length();\\n        int cnt = 0;\\n        for (int i = 1; i <= N; i++) {\\n            if (sequence.find(str) == string::npos) {\\n                break;\\n            }\\n            str += word;\\n            cnt++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 952050,
                "title": "python-short-using-count",
                "content": "```\\nclass Solution:\\n    def maxRepeating(self, sequence: str, word: str) -> int:\\n        result = sequence.count(word)\\n        check_word = word*result\\n        while(check_word not in sequence):\\n            result-=1\\n            check_word = word * result\\n        return result\\n        \\n```\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def maxRepeating(self, sequence: str, word: str) -> int:\\n        result = sequence.count(word)\\n        check_word = word*result\\n        while(check_word not in sequence):\\n            result-=1\\n            check_word = word * result\\n        return result\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 952039,
                "title": "javascript-easy-clear",
                "content": "loops through (almost) every letter to find match and updates the max repeating times\\n\\ns=\"**ab**cc**ababab**cc**abab**\"  w=\"ab\"\\nmax = 1 -> 3 -> 3\\n\\n```\\nvar maxRepeating = function(sequence, word) {\\n    let count = 0;\\n    let start = 0;\\n    let max = 0;\\n    \\n    while (start+word.length <= sequence.length) {\\n        let end = start+word.length;\\n        \\n        if (sequence.slice(start,end) !== word) {\\n            start++;\\n            count = 0;\\n        } else {\\n            count++;\\n            max = Math.max(max,count);\\n            start+=word.length;\\n        }\\n    }\\n    \\n    return max;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar maxRepeating = function(sequence, word) {\\n    let count = 0;\\n    let start = 0;\\n    let max = 0;\\n    \\n    while (start+word.length <= sequence.length) {\\n        let end = start+word.length;\\n        \\n        if (sequence.slice(start,end) !== word) {\\n            start++;\\n            count = 0;\\n        } else {\\n            count++;\\n            max = Math.max(max,count);\\n            start+=word.length;\\n        }\\n    }\\n    \\n    return max;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3781599,
                "title": "most-easy-c-solution",
                "content": "\\n\\n# Complexity\\n- Time complexity:O(N)\\n\\n- Space complexity:O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxRepeating(string sequence, string word) {\\n        int count = 0;\\n        string temp = word;\\n        while(sequence.find(temp) != string::npos) {\\n            count++;\\n            temp += word;\\n        }\\n        return count;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxRepeating(string sequence, string word) {\\n        int count = 0;\\n        string temp = word;\\n        while(sequence.find(temp) != string::npos) {\\n            count++;\\n            temp += word;\\n        }\\n        return count;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2928527,
                "title": "rust-from-c-using-contains",
                "content": "Inspired by this solution : https://leetcode.com/problems/maximum-repeating-substring/solutions/1164988/rust-short-solution/\\n\\n```\\nimpl Solution {\\n    pub fn max_repeating(sequence: String, word: String) -> i32 {\\n        let mut count = 0;\\n        let mut tmp = word.clone();\\n\\n        while(sequence.contains(&tmp)) {\\n            tmp.push_str(&word);\\n            count += 1;\\n        }\\n\\n        count\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn max_repeating(sequence: String, word: String) -> i32 {\\n        let mut count = 0;\\n        let mut tmp = word.clone();\\n\\n        while(sequence.contains(&tmp)) {\\n            tmp.push_str(&word);\\n            count += 1;\\n        }\\n\\n        count\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2819363,
                "title": "c-easy-100-faster",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxRepeating(string sequence, string word) {\\n        int count=0;\\n        string temp=word;\\n        while(sequence.find(temp)!=string::npos)\\n        {\\n            count++;\\n            temp+=word;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxRepeating(string sequence, string word) {\\n        int count=0;\\n        string temp=word;\\n        while(sequence.find(temp)!=string::npos)\\n        {\\n            count++;\\n            temp+=word;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2403876,
                "title": "binarysearch-and-kmp",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tbool kmp(string &sequence, string &mainWord,int rep){\\n\\t\\t\\tstring word;\\n\\t\\t\\tfor(int i=0;i<rep;i++){\\n\\t\\t\\t\\tword+=mainWord;\\n\\t\\t\\t}\\n\\t\\t\\t//cout<<word<<endl;\\n\\t\\t\\tint m=word.size();\\n\\t\\t\\tint n=sequence.size();\\n\\t\\t\\tvector<int>longest(m);\\n\\t\\t\\tfor(int i=1,k=0;i<m;i++){\\n\\t\\t\\t\\twhile(k>0&&word[k]!=word[i])k=longest[k-1];\\n\\t\\t\\t\\tif(word[k]==word[i])\\n\\t\\t\\t\\t\\tlongest[i]=++k;\\n\\t\\t\\t\\telse \\n\\t\\t\\t\\t\\tlongest[i]=k;\\n\\t\\t\\t}\\n\\t\\t   for(int i=0,k=0;i<n;i++){\\n\\t\\t\\t\\twhile(k>0&&word[k]!=sequence[i])k=longest[k-1];\\n\\n\\t\\t\\t\\tif(word[k]==sequence[i])\\n\\t\\t\\t\\t\\t++k;\\n\\t\\t\\t\\tif(k==m)return 1;\\n\\n\\t\\t\\t}\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\t\\tint maxRepeating(string sequence, string word) {\\n\\t\\t\\tint szS=sequence.size(),szW=word.size();\\n\\t\\t\\tint l=1,r=szS/szW,ans=0;\\n\\t\\t\\twhile(l<=r){\\n\\t\\t\\t\\tint mid=(r+l)/2;\\n\\t\\t\\t\\tint isPossibleMid=kmp(sequence,word,mid);\\n\\t\\t\\t\\tif(isPossibleMid)l=mid+1,ans=mid;\\n\\t\\t\\t\\telse r=mid-1;\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tbool kmp(string &sequence, string &mainWord,int rep){\\n\\t\\t\\tstring word;\\n\\t\\t\\tfor(int i=0;i<rep;i++){\\n\\t\\t\\t\\tword+=mainWord;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2356628,
                "title": "short-and-simple-code-c",
                "content": "```\\nint maxRepeating(string sequence, string word) \\n    {\\n        \\n        string s=word;\\n        int c=0;\\n        \\n        while(sequence.find(s)!=string::npos)\\n        {\\n            c++;\\n            s=s+word;\\n        }\\n        \\n        return c;\\n        \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint maxRepeating(string sequence, string word) \\n    {\\n        \\n        string s=word;\\n        int c=0;\\n        \\n        while(sequence.find(s)!=string::npos)\\n        {\\n            c++;\\n            s=s+word;\\n        }\\n        \\n        return c;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2262204,
                "title": "rust-solution",
                "content": "```\\npub fn max_repeating(sequence: String, word: String) -> i32 {\\n\\tlet mut buffer = word.clone();\\n\\tlet mut count = 0;\\n\\n\\tlet mut index = 1;\\n\\tlet length = sequence.len() / word.len();\\n\\n\\twhile index <= length {\\n\\t\\tif sequence.contains(&buffer) {\\n\\t\\t\\tindex += 1;\\n\\t\\t\\tcount += 1;\\n\\t\\t\\tbuffer.push_str(word.as_str());\\n\\t\\t} else {\\n\\t\\t\\treturn count;\\n\\t\\t}\\n\\t}\\n\\n\\tcount\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\npub fn max_repeating(sequence: String, word: String) -> i32 {\\n\\tlet mut buffer = word.clone();\\n\\tlet mut count = 0;\\n\\n\\tlet mut index = 1;\\n\\tlet length = sequence.len() / word.len();\\n\\n\\twhile index <= length {\\n\\t\\tif sequence.contains(&buffer) {\\n\\t\\t\\tindex += 1;\\n\\t\\t\\tcount += 1;\\n\\t\\t\\tbuffer.push_str(word.as_str());\\n\\t\\t} else {\\n\\t\\t\\treturn count;\\n\\t\\t}\\n\\t}\\n\\n\\tcount\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2243159,
                "title": "python-search-from-the-largest-k-first",
                "content": "**Solution**:\\n    The question asks us to find k where k is the largest multiple of a word concanated together that exists in the sequence. We will start by determine the largest k possible. Then, we form a target which is a multiple concatenation of the word from k times to 0 times. If the target exists in the string, return k. At k = 0, it will always true as an empty string is always a part of the other string.\\n\\n**Complexity**:\\n    Time: O(kn) where k is the longest multiple of the work that result in the longest substring and n is the length of the sequence. \\n    Space: O(1)\\n```\\nclass Solution:\\n    def maxRepeating(self, sequence: str, word: str) -> int:\\n\\n        # Find the largest k\\n        k = len(sequence) // len(word)\\n\\n        # Search from k until 0\\n        while True:\\n\\n            # If k multiple of a word concatenated together exists in the sequence, return k\\n            if word * k in sequence:\\n                return k\\n\\n            # Decrement k\\n            k -= 1\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def maxRepeating(self, sequence: str, word: str) -> int:\\n\\n        # Find the largest k\\n        k = len(sequence) // len(word)\\n\\n        # Search from k until 0\\n        while True:\\n\\n            # If k multiple of a word concatenated together exists in the sequence, return k\\n            if word * k in sequence:\\n                return k\\n\\n            # Decrement k\\n            k -= 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2192570,
                "title": "python-simple-solution",
                "content": "```\\nclass Solution:\\n    def maxRepeating(self, sequence: str, word: str) -> int:\\n        for i in range(len(sequence)//len(word)+1,0,-1):\\n            if i*word in sequence:\\n                return i\\n        else:\\n            return 0\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxRepeating(self, sequence: str, word: str) -> int:\\n        for i in range(len(sequence)//len(word)+1,0,-1):\\n            if i*word in sequence:\\n                return i\\n        else:\\n            return 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2166969,
                "title": "java-0ms-100-fast",
                "content": "Do upvote for my solution if it hepls you :)\\n```\\nclass Solution {\\n    public int maxRepeating(String sequence, String word) {\\n     \\n        int count=0;\\n        int idx=0;\\n        int max=0;\\n        \\n        for(int i=0;i<=sequence.length()-word.length();i++){\\n            count=0; idx=0;\\n            for(int j=i;j<sequence.length();j++){\\n                \\n                if(sequence.charAt(j)==word.charAt(idx)){\\n                    idx++;\\n                }\\n                else break;\\n                if(idx==word.length()){\\n                    idx=0;\\n                    count++;\\n                }                \\n            }\\n            max=Math.max(max,count);\\n        }\\n        return max;\\n    }\\n}\\n    \\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int maxRepeating(String sequence, String word) {\\n     \\n        int count=0;\\n        int idx=0;\\n        int max=0;\\n        \\n        for(int i=0;i<=sequence.length()-word.length();i++){\\n            count=0; idx=0;\\n            for(int j=i;j<sequence.length();j++){\\n                \\n                if(sequence.charAt(j)==word.charAt(idx)){\\n                    idx++;\\n                }\\n                else break;\\n                if(idx==word.length()){\\n                    idx=0;\\n                    count++;\\n                }                \\n            }\\n            max=Math.max(max,count);\\n        }\\n        return max;\\n    }\\n}\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2125898,
                "title": "java-3-line-soln-98-fast",
                "content": "```\\n\\t\\tint ans = 1;\\n        while (s.contains(word.repeat(ans)))  ++ans;\\n        return ans - 1;```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\t\\tint ans = 1;\\n        while (s.contains(word.repeat(ans)))  ++ans;\\n        return ans - 1;```",
                "codeTag": "Unknown"
            },
            {
                "id": 2110072,
                "title": "python-solution-easy-understanding",
                "content": "```\\nclass Solution:\\n    def maxRepeating(self, sequence: str, word: str) -> int:\\n\\t    # n is the possible most repeating unit\\n        n = len(sequence) // len(word)\\n        while n:\\n            if word * n in sequence:\\n                return n\\n            n -= 1\\n        return 0\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxRepeating(self, sequence: str, word: str) -> int:\\n\\t    # n is the possible most repeating unit\\n        n = len(sequence) // len(word)\\n        while n:\\n            if word * n in sequence:\\n                return n\\n            n -= 1\\n        return 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2079507,
                "title": "c-python-easy-solution",
                "content": "**C++**\\n```\\nclass Solution {\\npublic:\\n    int maxRepeating(string sequence, string word) {\\n        int l = word.length();\\n        int m = sequence.length();\\n        if(sequence==word) return 1;\\n        int ma=0,c;\\n        for(int i=0; i<=m-l; ++i){\\n            c=0;\\n            for(int j=i; j<m; j += l){\\n                string t = sequence.substr(j,l);\\n                if(t == word){\\n                    c++;\\n                }\\n                else break;\\n            }\\n            ma = max(ma,c);\\n        }\\n        return ma;\\n    }\\n};\\n```\\n**Python**\\n```\\nclass Solution:\\n    def maxRepeating(self, sequence: str, word: str) -> int:\\n        l,m = len(word), len(sequence)\\n        if(sequence==word): return 1\\n        ma=0\\n        for i in range(m-l+1):\\n            c=0\\n            for j in range(i,m,l):\\n                t = sequence[j:l+j]\\n                if(t == word):\\n                    c += 1\\n                else: break\\n            ma = max(ma,c)\\n        return ma\\n```",
                "solutionTags": [
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxRepeating(string sequence, string word) {\\n        int l = word.length();\\n        int m = sequence.length();\\n        if(sequence==word) return 1;\\n        int ma=0,c;\\n        for(int i=0; i<=m-l; ++i){\\n            c=0;\\n            for(int j=i; j<m; j += l){\\n                string t = sequence.substr(j,l);\\n                if(t == word){\\n                    c++;\\n                }\\n                else break;\\n            }\\n            ma = max(ma,c);\\n        }\\n        return ma;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def maxRepeating(self, sequence: str, word: str) -> int:\\n        l,m = len(word), len(sequence)\\n        if(sequence==word): return 1\\n        ma=0\\n        for i in range(m-l+1):\\n            c=0\\n            for j in range(i,m,l):\\n                t = sequence[j:l+j]\\n                if(t == word):\\n                    c += 1\\n                else: break\\n            ma = max(ma,c)\\n        return ma\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2013781,
                "title": "c-o-n-n-m-time-simple",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxRepeating(string &sequence, string &word) {\\n        string tmp = word;\\n        int cnt{};\\n        while(tmp.size() <= sequence.size()){\\n            if(sequence.find(tmp) != string::npos)\\n                cnt++;\\n            tmp += word;\\n        }\\n        return cnt;\\n    }\\n};\\n```\\nCheck\\nhttps://leetcode.com/problems/maximum-repeating-substring/discuss/2013762/C%2B%2B-oror-O(n)-oror-2-scans\\nfor a more efficient but complicated solution.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxRepeating(string &sequence, string &word) {\\n        string tmp = word;\\n        int cnt{};\\n        while(tmp.size() <= sequence.size()){\\n            if(sequence.find(tmp) != string::npos)\\n                cnt++;\\n            tmp += word;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1977866,
                "title": "2-easy-solution-using-python-easy-understanding",
                "content": "```\\nclass Solution:\\n    def maxRepeating(self, sequence: str, word: str) -> int:\\n        \"\"\"\\n        python solution using while loop\\n        \\n        max_count = 0\\n        string = word\\n        while True:\\n            if string in sequence:\\n                max_count += 1\\n                string += word\\n            else:\\n                break\\n        return max_count    \\n        \\n        \"\"\"\\n        \\n        # pthon solution using binary search\\n        \\n        result = 0\\n        l = len(word)\\n        left = 0\\n        right = len(sequence)\\n        while(left<=right):\\n            mid = (left + right) // 2\\n            x = mid * word\\n            if x in sequence:\\n                result = mid\\n                left = mid + 1\\n            else:\\n                right = mid - 1\\n        return result\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def maxRepeating(self, sequence: str, word: str) -> int:\\n        \"\"\"\\n        python solution using while loop\\n        \\n        max_count = 0\\n        string = word\\n        while True:\\n            if string in sequence:\\n                max_count += 1\\n                string += word\\n            else:\\n                break\\n        return max_count    \\n        \\n        \"\"\"\\n        \\n        # pthon solution using binary search\\n        \\n        result = 0\\n        l = len(word)\\n        left = 0\\n        right = len(sequence)\\n        while(left<=right):\\n            mid = (left + right) // 2\\n            x = mid * word\\n            if x in sequence:\\n                result = mid\\n                left = mid + 1\\n            else:\\n                right = mid - 1\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1904774,
                "title": "python-94-faster",
                "content": "```\\n\\nclass Solution:\\n    def maxRepeating(self, sequence: str, word: str) -> int:\\n        max_count = 0\\n        increased_string = word\\n        while True:\\n            if increased_string in sequence:\\n                max_count +=1\\n                increased_string +=word\\n            else:\\n                break\\n        return max_count\\n\\t\\t\\n\\t\\t\\n\\t```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution:\\n    def maxRepeating(self, sequence: str, word: str) -> int:\\n        max_count = 0\\n        increased_string = word\\n        while True:\\n            if increased_string in sequence:\\n                max_count +=1\\n                increased_string +=word\\n            else:\\n                break\\n        return max_count\\n\\t\\t\\n\\t\\t\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 1864844,
                "title": "please-clarify-how-aaabaaaabaaabaaaabaaaabaaaabaaaaba-for-substring-aaaba-result-is-5",
                "content": "Anyone please clarify how the result will be 5 rather then 6",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 1843097,
                "title": "java-kmp-solution",
                "content": "\\tclass Solution {\\n\\t\\tpublic int maxRepeating(String seq, String word) {\\n\\t\\t\\tint result = 0;\\n\\t\\t\\tString words = word;\\n\\n\\t\\t\\twhile (KMP(seq, words) > 0) {\\n\\t\\t\\t\\twords += word;\\n\\t\\t\\t\\tresult++;\\n\\t\\t\\t}\\n\\t\\t\\treturn result;\\n\\t\\t}\\n\\n\\t\\tpublic int[] longPrefSubs(String s) {\\n\\t\\t\\tint mas[] = new int[s.length()];\\n\\t\\t\\tint j = 0;\\n\\t\\t\\tfor (int i = 1; i < mas.length; i++) {\\n\\t\\t\\t\\tif (s.charAt(i) != s.charAt(j))\\n\\t\\t\\t\\t\\twhile (j > 0 && s.charAt(i) != s.charAt(j))\\n\\t\\t\\t\\t\\t\\tj = mas[j - 1];\\n\\n\\t\\t\\t\\tif (s.charAt(i) == s.charAt(j))\\n\\t\\t\\t\\t\\tmas[i] = ++j;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn mas;\\n\\t\\t}\\n\\n\\t\\tpublic int KMP(String seq, String word) {\\n\\t\\t\\tif (seq.length() < word.length())\\n\\t\\t\\t\\treturn 0;\\n\\n\\t\\t\\tint mas[] = longPrefSubs(word);\\n\\t\\t\\tint j = 0;\\n\\t\\t\\tfor (int i = 0; i < seq.length(); i++) {\\n\\t\\t\\t\\tif (word.length() - j > seq.length() - i)\\n\\t\\t\\t\\t\\treturn 0;\\n\\n\\t\\t\\t\\tif (seq.charAt(i) != word.charAt(j)) {\\n\\t\\t\\t\\t\\twhile (j > 0 && word.charAt(j) != seq.charAt(i))\\n\\t\\t\\t\\t\\t\\tj = mas[j - 1];\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif (seq.charAt(i) == word.charAt(j))\\n\\t\\t\\t\\t\\tj++;\\n\\n\\t\\t\\t\\tif (j == word.length()) {\\n\\t\\t\\t\\t\\treturn 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tpublic int maxRepeating(String seq, String word) {\\n\\t\\t\\tint result = 0;\\n\\t\\t\\tString words = word;\\n\\n\\t\\t\\twhile (KMP(seq, words) > 0) {\\n\\t\\t\\t\\twords += word;\\n\\t\\t\\t\\tresult++;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1831215,
                "title": "java-binarysearch-simple",
                "content": "```\\nclass Solution {\\n    public int maxRepeating(String sequence, String word) {\\n        int l = 1;\\n        int r = sequence.length() / word.length();\\n        int answer = 0;\\n        while (l <= r) {\\n            int midLen = (l + r) / 2;   //  l + (r - l) / 2;\\n            String kConcat = concat(word, midLen);\\n            if (isSubString(sequence, kConcat)) {\\n                l = midLen + 1;\\n                answer = midLen;\\n            } else {\\n                r = midLen - 1;\\n            }\\n        }\\n        return answer;\\n    }\\n    \\n    public String concat(String s, int k) {\\n        StringBuilder res = new StringBuilder(\"\");\\n        for (int i = 0; i < k; i++) {\\n            res.append(s);\\n        }\\n        return res.toString();\\n    }\\n    \\n    //  is t a substring of s\\n    public boolean isSubString(String s, String t) {\\n        if (t.length() > s.length()) {\\n            return false;\\n        }\\n        int l = 0;\\n        int r = t.length();\\n        while (r <= s.length()) {\\n            if (s.substring(l, r).equals(t)) {\\n                return true;\\n            }\\n            l++;\\n            r++;\\n        }\\n        return false;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int maxRepeating(String sequence, String word) {\\n        int l = 1;\\n        int r = sequence.length() / word.length();\\n        int answer = 0;\\n        while (l <= r) {\\n            int midLen = (l + r) / 2;   //  l + (r - l) / 2;\\n            String kConcat = concat(word, midLen);\\n            if (isSubString(sequence, kConcat)) {\\n                l = midLen + 1;\\n                answer = midLen;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1798591,
                "title": "python3-solution-87-lesser-memory",
                "content": "```\\nclass Solution:\\n    def maxRepeating(self, sequence: str, word: str) -> int:\\n        c = 0\\n        for i in range(1,len(sequence)//len(word)+1):\\n            if word*i in sequence:\\n                c += 1\\n                continue\\n            break\\n        return c\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxRepeating(self, sequence: str, word: str) -> int:\\n        c = 0\\n        for i in range(1,len(sequence)//len(word)+1):\\n            if word*i in sequence:\\n                c += 1\\n                continue\\n            break\\n        return c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1780810,
                "title": "python-solution",
                "content": "```\\nclass Solution(object):\\n    def maxRepeating(self, sequence, word):\\n        \"\"\"\\n        :type sequence: str\\n        :type word: str\\n        :rtype: int\\n        \"\"\"\\n        ret=0\\n        s=word\\n        while(word in sequence):\\n            ret+=1\\n            word+=s\\n        return ret\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def maxRepeating(self, sequence, word):\\n        \"\"\"\\n        :type sequence: str\\n        :type word: str\\n        :rtype: int\\n        \"\"\"\\n        ret=0\\n        s=word\\n        while(word in sequence):\\n            ret+=1\\n            word+=s\\n        return ret\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1744280,
                "title": "simple-scala-solution",
                "content": "```\\ndef maxRepeating(sequence: String, word: String): Int = {\\n    def go(count: Int): Int = {\\n      if (sequence.contains((word * count).mkString)) go(count + 1)\\n      else count - 1\\n    }\\n    go(0)\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\ndef maxRepeating(sequence: String, word: String): Int = {\\n    def go(count: Int): Int = {\\n      if (sequence.contains((word * count).mkString)) go(count + 1)\\n      else count - 1\\n    }\\n    go(0)\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1722457,
                "title": "python-3-short-and-clean-using-find",
                "content": "```\\nclass Solution:\\n    def maxRepeating(self, sequence: str, word: str) -> int:\\n        n=len(sequence)\\n        m=len(word)\\n        c=0\\n        for i in range(1,(n//m)+1):\\n            s=word*i\\n            if sequence.find(s)!=-1:\\n                c=i\\n        return c \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxRepeating(self, sequence: str, word: str) -> int:\\n        n=len(sequence)\\n        m=len(word)\\n        c=0\\n        for i in range(1,(n//m)+1):\\n            s=word*i\\n            if sequence.find(s)!=-1:\\n                c=i\\n        return c \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1698765,
                "title": "simple-easy-solution-by-python-3",
                "content": "```\\nclass Solution:\\n    def maxRepeating(self, sequence: str, word: str) -> int:\\n        k = 0\\n        while word * (k + 1) in sequence:\\n            k += 1\\n\\n        return k\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxRepeating(self, sequence: str, word: str) -> int:\\n        k = 0\\n        while word * (k + 1) in sequence:\\n            k += 1\\n\\n        return k\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1491680,
                "title": "java-simple-solution",
                "content": "```\\nclass Solution {\\n    public int maxRepeating(String seq, String word) {\\n        int k = 0;\\n        StringBuilder str = new StringBuilder(word);\\n        while (str.toString().length() <= seq.length()) {\\n            if (seq.contains(str.toString())) {\\n                str.append(word);\\n                k++;\\n            }\\n            else\\n                break;\\n        }\\n        return k;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int maxRepeating(String seq, String word) {\\n        int k = 0;\\n        StringBuilder str = new StringBuilder(word);\\n        while (str.toString().length() <= seq.length()) {\\n            if (seq.contains(str.toString())) {\\n                str.append(word);\\n                k++;\\n            }\\n            else\\n                break;\\n        }\\n        return k;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1488920,
                "title": "python3-kmp-string-search-with-o-n",
                "content": "My solution uses [KMP](https://en.wikipedia.org/wiki/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm) with a time complexity of ```O(len(sequence))``` and a space complexity of ```O(len(word))```\\n```\\nclass Solution:\\n    def maxRepeating(self, sequence: str, word: str) -> int:\\n        #we need two words for matching to cover parts of the start of the word with its end\\n        word2=word*2\\n\\n        #build partial match table\\n        backtracking=[0]        \\n        j= 0\\n        for i in range(1,len(word2)):\\n            while j > 0 and word2[i] != word2[j]:\\n                j= backtracking[j-1]\\n            if word2[i] == word2[j]:\\n                j+= 1\\n            backtracking.append(j)      \\n        \\n        #run the search itself\\n        aktk= 0\\n        maxk= 0\\n        j= 0\\n        for i in range(len(sequence)):\\n            while sequence[i] != word2[j]:\\n                #mismatch\\n                aktk= 0\\n                if j == 0:\\n                    break\\n                j= backtracking[j-1]\\n                \\n            if sequence[i] == word2[j]:\\n                j+= 1\\n\\n            if j != 0 and j%len(word) == 0:\\n                #match\\n                aktk+= 1\\n                maxk= max(maxk,aktk)\\n                j= len(word)\\n                \\n        return maxk\\n```",
                "solutionTags": [],
                "code": "```O(len(sequence))```\n```O(len(word))```\n```\\nclass Solution:\\n    def maxRepeating(self, sequence: str, word: str) -> int:\\n        #we need two words for matching to cover parts of the start of the word with its end\\n        word2=word*2\\n\\n        #build partial match table\\n        backtracking=[0]        \\n        j= 0\\n        for i in range(1,len(word2)):\\n            while j > 0 and word2[i] != word2[j]:\\n                j= backtracking[j-1]\\n            if word2[i] == word2[j]:\\n                j+= 1\\n            backtracking.append(j)      \\n        \\n        #run the search itself\\n        aktk= 0\\n        maxk= 0\\n        j= 0\\n        for i in range(len(sequence)):\\n            while sequence[i] != word2[j]:\\n                #mismatch\\n                aktk= 0\\n                if j == 0:\\n                    break\\n                j= backtracking[j-1]\\n                \\n            if sequence[i] == word2[j]:\\n                j+= 1\\n\\n            if j != 0 and j%len(word) == 0:\\n                #match\\n                aktk+= 1\\n                maxk= max(maxk,aktk)\\n                j= len(word)\\n                \\n        return maxk\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1433789,
                "title": "python3-two-pointers-solution-beat-98-9",
                "content": "Solution 1: using two pointers to iterate and find pattern. Time O(n^2)\\n```\\nclass Solution:\\n    def maxRepeating(self, sequence: str, word: str) -> int:\\n        if len(sequence) < len(word):\\n            return 0\\n        maxk = 0\\n        i = 0\\n        while i < len(sequence) - len(word) +1:\\n            j = i\\n            k = 0\\n            while j < len(sequence) - len(word) +1 and sequence[j:j+len(word)] == word:\\n                j += len(word)\\n                k += 1\\n            maxk = max(maxk, k)\\n            i += 1\\n        return maxk\\n```\\nSolution 2: use Python built in function, beat 78%. \\n```\\nclass Solution:\\n    def maxRepeating(self, sequence: str, word: str) -> int:\\n        if len(sequence) < len(word):\\n            return 0\\n        k = 0\\n        while word * (k+1) in sequence:\\n            k += 1\\n        return k\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxRepeating(self, sequence: str, word: str) -> int:\\n        if len(sequence) < len(word):\\n            return 0\\n        maxk = 0\\n        i = 0\\n        while i < len(sequence) - len(word) +1:\\n            j = i\\n            k = 0\\n            while j < len(sequence) - len(word) +1 and sequence[j:j+len(word)] == word:\\n                j += len(word)\\n                k += 1\\n            maxk = max(maxk, k)\\n            i += 1\\n        return maxk\\n```\n```\\nclass Solution:\\n    def maxRepeating(self, sequence: str, word: str) -> int:\\n        if len(sequence) < len(word):\\n            return 0\\n        k = 0\\n        while word * (k+1) in sequence:\\n            k += 1\\n        return k\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1366043,
                "title": "python3",
                "content": "class Solution:\\n\\n    def maxRepeating(self, sequence: str, word: str) -> int:\\n        k=1\\n        while True:\\n            if word*k in sequence:\\n                k+=1\\n            else:\\n                break\\n        return k-1",
                "solutionTags": [],
                "code": "class Solution:\\n\\n    def maxRepeating(self, sequence: str, word: str) -> int:\\n        k=1\\n        while True:\\n            if word*k in sequence:\\n                k+=1\\n            else:\\n                break\\n        return k-1",
                "codeTag": "Java"
            },
            {
                "id": 1357665,
                "title": "kmp-true-o-n",
                "content": "Intuition:\\nFor understanding KMP algorithm in general, please check some standard site.\\nHere i will explain how i applied KMP to this problem.\\nsuppose sequence = ababc \\nword = ab\\nI created a string in which word can occur maximum number of time. i.e. abab \\nthen i created a string abab#ababc to separate the prefix with the sequence. \\nNow i created the lps sequence from the above string. \\nlps = [0, 0, 1, 2, 0, 1, 2, 3, 4, 0]\\nWhile creating the lps array i am also checking from index 5 to last index i.e for ababc part., what is the max lps value we obtained. \\nHere its 4. so 4//len(word) will give us the answer.\\n```\\nclass Solution:\\n    def maxRepeating(self, sequence: str, word: str) -> int:\\n        cnt = len(sequence)//len(word)\\n        repeat = word * cnt\\n        newstr = repeat + \\'#\\' + sequence\\n        lps = [0]\\n        maxi = 0\\n        for i in range(1, len(newstr)):\\n            x = lps[-1]\\n            while newstr[x] != newstr[i]:\\n                if x == 0:\\n                    x = -1\\n                    break\\n                x = lps[x-1]\\n            lps.append(x+1)\\n            if i>=len(repeat):\\n                maxi = max(maxi, x+1)\\n        return maxi//len(word)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxRepeating(self, sequence: str, word: str) -> int:\\n        cnt = len(sequence)//len(word)\\n        repeat = word * cnt\\n        newstr = repeat + \\'#\\' + sequence\\n        lps = [0]\\n        maxi = 0\\n        for i in range(1, len(newstr)):\\n            x = lps[-1]\\n            while newstr[x] != newstr[i]:\\n                if x == 0:\\n                    x = -1\\n                    break\\n                x = lps[x-1]\\n            lps.append(x+1)\\n            if i>=len(repeat):\\n                maxi = max(maxi, x+1)\\n        return maxi//len(word)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1318440,
                "title": "java-0ms-beats-100-fast-and-easy-to-understand",
                "content": "I hope its straight forward. enjoy!\\n```\\nclass Solution {\\n    public int maxRepeating(String s, String word) {\\n        StringBuilder sb = new StringBuilder(word);\\n        int k=0;\\n        while(s.indexOf(sb.toString())!=-1){\\n            k++;\\n            sb.append(word);\\n        }\\n        return k;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int maxRepeating(String s, String word) {\\n        StringBuilder sb = new StringBuilder(word);\\n        int k=0;\\n        while(s.indexOf(sb.toString())!=-1){\\n            k++;\\n            sb.append(word);\\n        }\\n        return k;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1282041,
                "title": "python",
                "content": "\\tclass Solution:\\n\\t\\tdef maxRepeating(self, sequence: str, word: str) -> int:\\n\\t\\t\\ti = 1\\n\\n\\t\\t\\twhile True:\\n\\t\\t\\t\\tif word*i in sequence:\\n\\t\\t\\t\\t\\t# print(word*i,\"  \",i)\\n\\t\\t\\t\\t\\ti+=1\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tbreak\\n\\n\\t\\t\\treturn i-1\\n",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef maxRepeating(self, sequence: str, word: str) -> int:\\n\\t\\t\\ti = 1\\n\\n\\t\\t\\twhile True:\\n\\t\\t\\t\\tif word*i in sequence:\\n\\t\\t\\t\\t\\t# print(word*i,\"  \",i)\\n\\t\\t\\t\\t\\ti+=1\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tbreak\\n\\n\\t\\t\\treturn i-1\\n",
                "codeTag": "Java"
            },
            {
                "id": 1272386,
                "title": "python3-using-regex",
                "content": "\\tclass Solution:\\n    def maxRepeating(self, sequence: str, word: str) -> int:\\n        x=len(re.findall(word,sequence))\\n        for i in range(1,x+2):\\n            if not re.findall(word*i,sequence):\\n                return(i-1)\\n                \\n**If u like this solution,Please upvote for this:)**\\t\\t\\t\\t\\n\\t\\t\\t\\t",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n    def maxRepeating(self, sequence: str, word: str) -> int:\\n        x=len(re.findall(word,sequence))\\n        for i in range(1,x+2):\\n            if not re.findall(word*i,sequence):\\n                return(i-1)\\n                \\n**If u like this solution,Please upvote for this:)**\\t\\t\\t\\t\\n\\t\\t\\t\\t",
                "codeTag": "Java"
            },
            {
                "id": 1267746,
                "title": "typescript-recursive-solution",
                "content": "```\\nfunction maxRepeating(sequence: string, word: string): number {\\n    return helper(sequence, word, word, 0);\\n};\\n\\nfunction helper(sequence: string, word: string, originalWord: string, count: number): number {\\n    if (sequence.indexOf(word) === -1) {\\n        return count;\\n    }\\n    return helper(sequence, word.concat(originalWord), originalWord, count + 1);\\n}\\n```",
                "solutionTags": [
                    "TypeScript",
                    "Recursion"
                ],
                "code": "```\\nfunction maxRepeating(sequence: string, word: string): number {\\n    return helper(sequence, word, word, 0);\\n};\\n\\nfunction helper(sequence: string, word: string, originalWord: string, count: number): number {\\n    if (sequence.indexOf(word) === -1) {\\n        return count;\\n    }\\n    return helper(sequence, word.concat(originalWord), originalWord, count + 1);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1260385,
                "title": "python3-simple-solution",
                "content": "```\\nclass Solution:\\n    def maxRepeating(self, sequence: str, word: str) -> int:\\n        x = 0\\n        while True:\\n            if word*(x+1) in sequence:\\n                x += 1\\n            else:\\n                return x\\n```\\n**If you like this solution, please upvote for this**",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxRepeating(self, sequence: str, word: str) -> int:\\n        x = 0\\n        while True:\\n            if word*(x+1) in sequence:\\n                x += 1\\n            else:\\n                return x\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1249116,
                "title": "python3-simple-3-lines-solution",
                "content": "```\\nclass Solution:\\n    def maxRepeating(self, sequence: str, word: str) -> int:\\n        i=1\\n        while(word*i in sequence): i+=1\\n        return i-1\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxRepeating(self, sequence: str, word: str) -> int:\\n        i=1\\n        while(word*i in sequence): i+=1\\n        return i-1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1231779,
                "title": "kmp-implementation-java",
                "content": "Please find the Java implementation using KMP algorithm.\\n\\n```\\nclass Solution {\\n    \\n    private int kmp (String text, String pattern) {\\n        int m = pattern.length();\\n        int n = text.length();\\n        int i = 0;\\n        int j = 0;\\n        int result = 0;\\n        int lps[] = new int[m];\\n        fillLps(pattern, lps);\\n        \\n        while(i < n && j < m) {\\n            if (pattern.charAt(j) == text.charAt(i)) {\\n                i++;\\n                j++;\\n            } else {\\n                if (j != 0) {\\n                    j = lps[j - 1];\\n                } else {\\n                    i ++;\\n                }\\n            }\\n        }\\n        if (j == m) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n    private void fillLps(String pattern, int[] lps){\\n        int m = pattern.length();\\n        int i = 1;\\n        int len = 0;\\n        lps[0] = 0;\\n        while (i < m) {\\n            if (pattern.charAt(i) == pattern.charAt(len)) {\\n                lps[i] = len + 1;\\n                len ++;\\n                i ++;\\n            } else {\\n                if (len != 0) {\\n                    len = lps [len - 1];\\n                } else {\\n                    lps[i] = 0;\\n                    i ++;\\n                }\\n            } \\n            \\n        }\\n    }\\n    public int maxRepeating(String sequence, String word) {\\n        int result = 0;\\n        String pattern = word;\\n        while (true){\\n            \\n            int count = kmp(sequence, pattern);\\n            pattern += word;\\n            if (count == 0) break;\\n            result += count;\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    private int kmp (String text, String pattern) {\\n        int m = pattern.length();\\n        int n = text.length();\\n        int i = 0;\\n        int j = 0;\\n        int result = 0;\\n        int lps[] = new int[m];\\n        fillLps(pattern, lps);\\n        \\n        while(i < n && j < m) {\\n            if (pattern.charAt(j) == text.charAt(i)) {\\n                i++;\\n                j++;\\n            } else {\\n                if (j != 0) {\\n                    j = lps[j - 1];\\n                } else {\\n                    i ++;\\n                }\\n            }\\n        }\\n        if (j == m) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n    private void fillLps(String pattern, int[] lps){\\n        int m = pattern.length();\\n        int i = 1;\\n        int len = 0;\\n        lps[0] = 0;\\n        while (i < m) {\\n            if (pattern.charAt(i) == pattern.charAt(len)) {\\n                lps[i] = len + 1;\\n                len ++;\\n                i ++;\\n            } else {\\n                if (len != 0) {\\n                    len = lps [len - 1];\\n                } else {\\n                    lps[i] = 0;\\n                    i ++;\\n                }\\n            } \\n            \\n        }\\n    }\\n    public int maxRepeating(String sequence, String word) {\\n        int result = 0;\\n        String pattern = word;\\n        while (true){\\n            \\n            int count = kmp(sequence, pattern);\\n            pattern += word;\\n            if (count == 0) break;\\n            result += count;\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1228607,
                "title": "python-3-one-line-in-o-n-kind-of",
                "content": "Get the first `i` such that it doesn\\'t repeat `i` times. That means it does repeat `i-1` times.\\n\\nYep, this `O(n^2)`.\\n\\n```python\\nclass Solution:\\n  def maxRepeating(self, sequence: str, word: str) -> int:\\n     return next(i for i in count(1) if word*i not in sequence) - 1\\n```\\n\\nOk, what about `O(n)`?\\n\\nOne approach is to use regex to find all matching substrings.\\n\\nNote that we need to use positive lookahead ... `(?=word)` ... to find all the locations including overlaps.\\n\\nThen, we build a dict to figure out which locations are repeating... if we\\'ve seen the same pattern `len(w)` ago, then it is repeating adjascently.\\n\\n```python\\nclass Solution:\\n  def maxRepeating(self, s: str, w: str) -> int:\\n    seen = {}\\n    for m in finditer(\\'(?=\\' + w + \\')\\', s):\\n      seen[m.start()] = seen.get(m.start() - len(w), 0) + 1\\n    return max(seen.values(), default=0)\\n```\\n\\nUse [reduce](https://docs.python.org/3/library/functools.html#functools.reduce) to convert to one line:\\n\\n```python\\nclass Solution:\\n  def maxRepeating(self, s: str, w: str) -> int:\\n    return max(reduce(lambda z,m: setitem(z, m.start(), z.get(m.start() - len(w), 0) + 1) or z, finditer(\\'(?=\\' + w + \\')\\', s), {}).values(), default=0)\\n```\\n\\nNote that this is usually `O(n)`, but `O(n^2)` for the worst case.\\nConsider:\\n* sequence = \"aaaaaaaa\" (8 a\\'s)\\n* word = \"aaaa\" (4 a\\'s)\\n\\nThen `re.finditer` will need:\\n* 4 operations at index 0\\n* 4 operations at index 1\\n* 4 operations at index 2\\n* 4 operations at index 3\\n* 4 operations at index 4\\n* 3 operations at index 5\\n* 2 operations at index 6\\n* 1 operations at index 7\\n\\nSo for more than half of the iterations, it may perform `n/2` operations.\\n",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n  def maxRepeating(self, sequence: str, word: str) -> int:\\n     return next(i for i in count(1) if word*i not in sequence) - 1\\n```\n```python\\nclass Solution:\\n  def maxRepeating(self, s: str, w: str) -> int:\\n    seen = {}\\n    for m in finditer(\\'(?=\\' + w + \\')\\', s):\\n      seen[m.start()] = seen.get(m.start() - len(w), 0) + 1\\n    return max(seen.values(), default=0)\\n```\n```python\\nclass Solution:\\n  def maxRepeating(self, s: str, w: str) -> int:\\n    return max(reduce(lambda z,m: setitem(z, m.start(), z.get(m.start() - len(w), 0) + 1) or z, finditer(\\'(?=\\' + w + \\')\\', s), {}).values(), default=0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1221848,
                "title": "easy-cpp-solution-in-5-lines",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxRepeating(string sequence, string word) {\\n        int ans=0;\\n        string cur=word;\\n        while(1)\\n        {\\n            if(sequence.find(cur)!=-1)\\n            {\\n                \\n                ans++;\\n                cur+=word;\\n            }\\n            else break;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxRepeating(string sequence, string word) {\\n        int ans=0;\\n        string cur=word;\\n        while(1)\\n        {\\n            if(sequence.find(cur)!=-1)\\n            {\\n                \\n                ans++;\\n                cur+=word;\\n            }\\n            else break;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1214665,
                "title": "simple-java-soln",
                "content": "```\\npublic int maxRepeating(String sequence, String word) {\\n        int count = 0;\\n        String temp  = word;\\n        int i  = 0;\\n        while(true){\\n            if(sequence.contains(temp)){\\n                temp +=word;\\n                count++;\\n            }\\n            else\\n                break;\\n        }\\n        return count;\\n    }\\n\\t```",
                "solutionTags": [
                    "String"
                ],
                "code": "```\\npublic int maxRepeating(String sequence, String word) {\\n        int count = 0;\\n        String temp  = word;\\n        int i  = 0;\\n        while(true){\\n            if(sequence.contains(temp)){\\n                temp +=word;\\n                count++;\\n            }\\n            else\\n                break;\\n        }\\n        return count;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 1202761,
                "title": "100-in-java-in-o-n-time-complexity-easy-to-understand",
                "content": "class Solution {\\n    public int maxRepeating(String sequence, String word) {\\n        StringBuilder sb = new StringBuilder();\\n        int count = -1;\\n        while(sequence.contains(sb.toString())){\\n            count++;\\n            sb.append(word);\\n        }\\n        return count;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int maxRepeating(String sequence, String word) {\\n        StringBuilder sb = new StringBuilder();\\n        int count = -1;\\n        while(sequence.contains(sb.toString())){\\n            count++;\\n            sb.append(word);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1168909,
                "title": "php-solution",
                "content": "```\\nclass Solution {\\n\\n    /**\\n     * @param String $sequence\\n     * @param String $word\\n     * @return Integer\\n     */\\n    function maxRepeating($sequence, $word) {\\n        $k = 0;\\n        $newWord = $word;\\n        while (strpos($sequence, $newWord) !== false) {\\n            $k++;\\n            $newWord .= $word;\\n        }\\n\\n        return $k;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\n    /**\\n     * @param String $sequence\\n     * @param String $word\\n     * @return Integer\\n     */\\n    function maxRepeating($sequence, $word) {\\n        $k = 0;\\n        $newWord = $word;\\n        while (strpos($sequence, $newWord) !== false) {\\n            $k++;\\n            $newWord .= $word;\\n        }\\n\\n        return $k;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1136816,
                "title": "javascript-brute-force",
                "content": "```\\nconst maxRepeating = (sequence, word) => {\\n    let pattern = word\\n    \\n    while(true) {\\n        if(!sequence.includes(pattern)) return (pattern.length / word.length) - 1\\n        pattern += word\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst maxRepeating = (sequence, word) => {\\n    let pattern = word\\n    \\n    while(true) {\\n        if(!sequence.includes(pattern)) return (pattern.length / word.length) - 1\\n        pattern += word\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1115457,
                "title": "0-ms-faster-than-100-00-of-java",
                "content": "```\\nclass Solution {\\n  public int maxRepeating(String sequence, String word) {\\n    int count = 0;\\n    StringBuilder stringBuilder = new StringBuilder(word);\\n    while (true) {\\n      int index = sequence.indexOf(stringBuilder.toString());\\n      if (index == -1) break;\\n      count++;\\n      stringBuilder.append(word);\\n    }\\n    return count;\\n  }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n  public int maxRepeating(String sequence, String word) {\\n    int count = 0;\\n    StringBuilder stringBuilder = new StringBuilder(word);\\n    while (true) {\\n      int index = sequence.indexOf(stringBuilder.toString());\\n      if (index == -1) break;\\n      count++;\\n      stringBuilder.append(word);\\n    }\\n    return count;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1114709,
                "title": "c-2-lines",
                "content": "Keep concatenating the original word onto itself and try to find it in the sequence. \\n```\\nint maxRepeating(string seq, string word, int res = 0) {\\n\\tfor (string orig = word; seq.find(word) != string::npos; word += orig, ++res);\\n\\treturn res;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint maxRepeating(string seq, string word, int res = 0) {\\n\\tfor (string orig = word; seq.find(word) != string::npos; word += orig, ++res);\\n\\treturn res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1110531,
                "title": "java-fastest-0ms-with-comments",
                "content": "```\\nclass Solution {\\n       public int maxRepeating(String sequence, String word) {\\n        int count = 0;\\n        StringBuilder temp = new StringBuilder(word);\\n        while(true){\\n            int index = sequence.indexOf(temp.toString()); //index of temp\\n            if(index == -1){\\n                break;\\n            }else{\\n                count++;\\n                temp.append(word); //apppend temp and in next turn find index of that if exists increment\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n       public int maxRepeating(String sequence, String word) {\\n        int count = 0;\\n        StringBuilder temp = new StringBuilder(word);\\n        while(true){\\n            int index = sequence.indexOf(temp.toString()); //index of temp\\n            if(index == -1){\\n                break;\\n            }else{\\n                count++;\\n                temp.append(word); //apppend temp and in next turn find index of that if exists increment\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1102650,
                "title": "python-solution",
                "content": "```\\nclass Solution(object):\\n    def maxRepeating(self, sequence, word):\\n        k=len(sequence)//len(word)\\n        for i in range(k,-1,-1):\\n            if word*i in sequence:\\n                return(i)\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def maxRepeating(self, sequence, word):\\n        k=len(sequence)//len(word)\\n        for i in range(k,-1,-1):\\n            if word*i in sequence:\\n                return(i)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1087938,
                "title": "some-java-solutions",
                "content": "1\\u3001Use Java String.contains Method\\n```\\nclass Solution {\\n    public int maxRepeating(String sequence, String word) {\\n       StringBuilder builder = new StringBuilder(word);\\n        while(sequence.contains(builder)) {\\n            builder.append(word);\\n        }\\n        return builder.length() / word.length() - 1;\\n    }\\n}\\n```\\n2\\u3001Brute force approach.\\n```\\nclass Solution {\\n    public int maxRepeating(String sequence, String word) {\\n        int max = 0;\\n        for(int i = 0; i < sequence.length(); i++) {\\n            if (sequence.length() - i < max * word.length()) continue;\\n            int r = 0;\\n            for(int j = i, k = 0; j < sequence.length(); j++, k = (k + 1) % word.length()) {\\n                if(sequence.charAt(j) != word.charAt(k)) {\\n                    break;\\n                }\\n                if(k == word.length() - 1) {\\n                    r++;\\n                }\\n            }\\n            max = Math.max(max, r);\\n        }\\n        return max;\\n    }\\n}\\n```\\n3\\u3001Dynamic programming\\n```\\nclass Solution {\\n    public int maxRepeating(String sequence, String word) {\\n        int max = 0;\\n        int dp[] = new int[sequence.length()];\\n        char[] ss = sequence.toCharArray(), ww = word.toCharArray();\\n        int sLen = ss.length;\\n        int wLen = ww.length;\\n        for(int i = 0; i < sLen; i++) {\\n            int j = i, k = 0;\\n            while(j < sLen && k < wLen && ss[j++] == ww[k++]) {\\n                j++;\\n                k++;\\n            }\\n            if (k == wLen) {\\n                dp[i] = i - wLen >= 0 ? dp[i - wLen] + 1 : 1;\\n                max = Math.max(max, dp[i]);\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxRepeating(String sequence, String word) {\\n       StringBuilder builder = new StringBuilder(word);\\n        while(sequence.contains(builder)) {\\n            builder.append(word);\\n        }\\n        return builder.length() / word.length() - 1;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int maxRepeating(String sequence, String word) {\\n        int max = 0;\\n        for(int i = 0; i < sequence.length(); i++) {\\n            if (sequence.length() - i < max * word.length()) continue;\\n            int r = 0;\\n            for(int j = i, k = 0; j < sequence.length(); j++, k = (k + 1) % word.length()) {\\n                if(sequence.charAt(j) != word.charAt(k)) {\\n                    break;\\n                }\\n                if(k == word.length() - 1) {\\n                    r++;\\n                }\\n            }\\n            max = Math.max(max, r);\\n        }\\n        return max;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int maxRepeating(String sequence, String word) {\\n        int max = 0;\\n        int dp[] = new int[sequence.length()];\\n        char[] ss = sequence.toCharArray(), ww = word.toCharArray();\\n        int sLen = ss.length;\\n        int wLen = ww.length;\\n        for(int i = 0; i < sLen; i++) {\\n            int j = i, k = 0;\\n            while(j < sLen && k < wLen && ss[j++] == ww[k++]) {\\n                j++;\\n                k++;\\n            }\\n            if (k == wLen) {\\n                dp[i] = i - wLen >= 0 ? dp[i - wLen] + 1 : 1;\\n                max = Math.max(max, dp[i]);\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1083082,
                "title": "c-dp-time-space",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxRepeating(string sequence, string word) {\\n        \\n\\t\\t// let n be size of sequence\\n\\t\\t// time: o(n)\\n\\t\\t// space: o(n) \\n\\t\\t\\n        vector<int> dp(sequence.size(), 0);        \\n        int max_count = 0;\\n        \\n        for (int i = 0; i < sequence.size(); i++) {\\n            string sub = sequence.substr(i, word.size());\\n            int word_s = word.size();\\n            if (sub == word) {\\n                if (i-word_s < 0) {\\n                    dp[i] = 1;\\n                } else {                    \\n                    dp[i] = dp[i-word_s]+1;                    \\n                }\\n                max_count = max(max_count, dp[i]);                \\n            }\\n        }\\n        \\n        return max_count;        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxRepeating(string sequence, string word) {\\n        \\n\\t\\t// let n be size of sequence\\n\\t\\t// time: o(n)\\n\\t\\t// space: o(n) \\n\\t\\t\\n        vector<int> dp(sequence.size(), 0);        \\n        int max_count = 0;\\n        \\n        for (int i = 0; i < sequence.size(); i++) {\\n            string sub = sequence.substr(i, word.size());\\n            int word_s = word.size();\\n            if (sub == word) {\\n                if (i-word_s < 0) {\\n                    dp[i] = 1;\\n                } else {                    \\n                    dp[i] = dp[i-word_s]+1;                    \\n                }\\n                max_count = max(max_count, dp[i]);                \\n            }\\n        }\\n        \\n        return max_count;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1065126,
                "title": "my-c-solution-cracked-if-finally-0ms-runtime-beats-100-c-submissions",
                "content": "The idea is to find the maximum repeating substring, for example, **aaaaaa** and word is **a,** the maximum possible repeating will be all of the sequence, so what i have done, is check the len of the sequence and divide it by the word, this will give us the **maximum possible repeating substring**. So in a for loop, I start with 1 repeating, and then check the next repeating one  (if found keep on updating the max count), do this, until all the possiblilities are exhausted.\\n\\n```\\nclass Solution {\\npublic:\\n    int maxRepeating(string sequence, string word) \\n    {\\n        int sz = word.size();\\n        int len = sequence.size();\\n        int max_possible = len / sz;        \\n        int count = 0;\\n\\n        string strToFind(\"\");\\n        for (int i = 1; i <= max_possible; i++)\\n        {\\n            strToFind +=word;\\n            if( sequence.find( strToFind)  !=  string::npos ) \\n            {\\n                count = max( count, i);\\n            } \\n        }   \\n        return count;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int maxRepeating(string sequence, string word) \\n    {\\n        int sz = word.size();\\n        int len = sequence.size();\\n        int max_possible = len / sz;        \\n        int count = 0;\\n\\n        string strToFind(\"\");\\n        for (int i = 1; i <= max_possible; i++)\\n        {\\n            strToFind +=word;\\n            if( sequence.find( strToFind)  !=  string::npos ) \\n            {\\n                count = max( count, i);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1062201,
                "title": "the-last-test-case-aaaba",
                "content": "![image](https://assets.leetcode.com/users/images/4d26a616-8f48-4fc0-858d-52b4b601e89a_1613132021.87528.png)\\nWhy the expected  answer in this case is 5? Can anyone help me to understand? \\n\\n\\n\\'\\'\\'\\nclass Solution {\\n    public int maxRepeating(String sequence, String word) {\\n        int wordIndex = sequence.indexOf(word);\\n        if(wordIndex == -1) {\\n            return 0;\\n        }else {\\n            int remainingStrStartIndex = wordIndex+word.length();\\n            int strLeftLength = sequence.length() - remainingStrStartIndex;\\n            if(strLeftLength < word.length()) {\\n                return 1;\\n            }else {\\n                String remainingStr = sequence.substring(remainingStrStartIndex);\\n                return Math.max(1+checkConcatenated(remainingStr, word), maxRepeating(remainingStr, word));\\n            }\\n        }  \\n    }\\n    \\n    public int checkConcatenated (String s, String word) {\\n        if(s.indexOf(word) != 0) {\\n            return 0;\\n        }else {\\n            if(s.length() >= word.length() * 2){\\n                return 1+checkConcatenated(s.substring(word.length()), word);\\n            }else{\\n                return 1;\\n            }\\n        }\\n    }\\n}\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "class Solution {\\n    public int maxRepeating(String sequence, String word) {\\n        int wordIndex = sequence.indexOf(word);\\n        if(wordIndex == -1) {\\n            return 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1048875,
                "title": "python-kmp-dfa",
                "content": "We can pre-generate the longest repeating substring, and use KMP DFA to match the sequence against the DP array it creates. KMP is guaranteed to find the longest proper prefix which is also suffix.\\n\\nExample\\n\"ababc\"\\n\"ab\"\\n\\nThe longest prefix we can have is \"abab\". So we make a KMP DFA like this:\\n[0, 0, 1, 2, 0]\\n\\nand run our sequence through it. We want to find the longest substring of repeated pattern that fits into sequence\\n\\n\\n```python\\nclass Solution:\\n    def maxRepeating(self, sequence: str, word: str) -> int:\\n        n = len(word)\\n        max_rep = word * (len(sequence) // n) + \\'$\\' #\\n        kmp = self.kmpTable(max_rep)\\n        \\n        j = 0\\n        res = 0\\n        for c in sequence:\\n            while j and max_rep[j] != c:\\n                j = kmp[j - 1]\\n                \\n            if max_rep[j] == c:\\n                j += 1\\n                res = max(res, j)\\n            \\n        return res // n\\n    \\n    def kmpTable(self, s: str):\\n        kmp = [0] * len(s)\\n\\n        for i in range(1, len(s)):\\n            idx = kmp[i - 1]\\n\\n            while idx > 0 and s[idx] != s[i]:\\n                idx = kmp[idx - 1]  # trace backwards to find the last matching char\\n\\n            if s[i] == s[idx]:  # matches next\\n                idx += 1\\n\\n            kmp[i] = idx\\n\\n        return kmp\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def maxRepeating(self, sequence: str, word: str) -> int:\\n        n = len(word)\\n        max_rep = word * (len(sequence) // n) + \\'$\\' #\\n        kmp = self.kmpTable(max_rep)\\n        \\n        j = 0\\n        res = 0\\n        for c in sequence:\\n            while j and max_rep[j] != c:\\n                j = kmp[j - 1]\\n                \\n            if max_rep[j] == c:\\n                j += 1\\n                res = max(res, j)\\n            \\n        return res // n\\n    \\n    def kmpTable(self, s: str):\\n        kmp = [0] * len(s)\\n\\n        for i in range(1, len(s)):\\n            idx = kmp[i - 1]\\n\\n            while idx > 0 and s[idx] != s[i]:\\n                idx = kmp[idx - 1]  # trace backwards to find the last matching char\\n\\n            if s[i] == s[idx]:  # matches next\\n                idx += 1\\n\\n            kmp[i] = idx\\n\\n        return kmp\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1043921,
                "title": "2-python-solutions",
                "content": "**Solution 1:**\\n```\\nm, n = len(sequence), len(word)\\nresult = 0\\ni = 0\\nwhile i <= m - n:\\n\\tif sequence[i] == word[0]:\\n\\t\\tj = i\\n\\t\\ttemp = 0\\n\\t\\twhile sequence[j : j + n] == word:\\n\\t\\t\\ttemp += 1\\n\\t\\t\\tj += n\\n\\t\\telse:\\n\\t\\t\\tresult = max(result, temp)\\n\\ti += 1\\nreturn result\\n```\\n\\n**Solution 2:**\\n```\\ncount = 1\\nwhile word * count in sequence:\\n    count += 1\\nreturn count - 1\\n```",
                "solutionTags": [],
                "code": "```\\nm, n = len(sequence), len(word)\\nresult = 0\\ni = 0\\nwhile i <= m - n:\\n\\tif sequence[i] == word[0]:\\n\\t\\tj = i\\n\\t\\ttemp = 0\\n\\t\\twhile sequence[j : j + n] == word:\\n\\t\\t\\ttemp += 1\\n\\t\\t\\tj += n\\n\\t\\telse:\\n\\t\\t\\tresult = max(result, temp)\\n\\ti += 1\\nreturn result\\n```\n```\\ncount = 1\\nwhile word * count in sequence:\\n    count += 1\\nreturn count - 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1033040,
                "title": "python3-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def maxRepeating(self, sequence: str, word: str) -> int:\\n        c = 0\\n        temp = word\\n        while 1:\\n            if temp in sequence:\\n                c += 1\\n                temp += word\\n            else:\\n                break\\n        return c",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxRepeating(self, sequence: str, word: str) -> int:\\n        c = 0\\n        temp = word\\n        while 1:\\n            if temp in sequence:\\n                c += 1\\n                temp += word\\n            else:\\n                break\\n        return c",
                "codeTag": "Java"
            },
            {
                "id": 1032690,
                "title": "c-npos-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxRepeating(string s, string p)\\n    {\\n        int count=0;\\n        string x=p;\\n        while(s.find(x)!=string::npos)\\n        {\\n            count++;\\n            x+=p;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxRepeating(string s, string p)\\n    {\\n        int count=0;\\n        string x=p;\\n        while(s.find(x)!=string::npos)\\n        {\\n            count++;\\n            x+=p;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1008348,
                "title": "unique-c-solution-100-speed-o-1-memory-with-substr-and-compare",
                "content": "```\\nclass Solution {\\npublic:\\n    // Loop through sequence until we find a char that matches starting char of word\\n    // Use substr to compare if substring starting at current intdex matches word and keep looping\\n    // until we find substr that does not match, incrementing a counter along the way\\n    // compare current counter to previous max\\n    // After finding substrings that work, we have to go back to the index that we were at at the start of the\\n    // outter while loop because we could have skipped over other start points when doing i += interval\\n    int maxRepeating(string sequence, string word) {\\n        if(sequence == word){\\n            return 1;\\n        }\\n        int answer = 0;\\n        int i = 0;\\n        int length = (int)sequence.size();\\n        int interval = (int)word.size();\\n        char start = word[0];\\n        int initial = 0;\\n        \\n        while(i + interval - 1 < length){\\n            if(sequence[i] != start){\\n                i++;\\n                initial++;\\n                continue;\\n            }\\n            \\n            int current = 0;\\n            while(i + interval - 1 < length && !word.compare(sequence.substr(i, interval))){\\n                current++;\\n                i += interval;\\n            }\\n            answer = std::max(answer, current);\\n            i = ++initial;\\n        }\\n        return answer;\\n    }\\n};```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    // Loop through sequence until we find a char that matches starting char of word\\n    // Use substr to compare if substring starting at current intdex matches word and keep looping\\n    // until we find substr that does not match, incrementing a counter along the way\\n    // compare current counter to previous max\\n    // After finding substrings that work, we have to go back to the index that we were at at the start of the\\n    // outter while loop because we could have skipped over other start points when doing i += interval\\n    int maxRepeating(string sequence, string word) {\\n        if(sequence == word){\\n            return 1;\\n        }\\n        int answer = 0;\\n        int i = 0;\\n        int length = (int)sequence.size();\\n        int interval = (int)word.size();\\n        char start = word[0];\\n        int initial = 0;\\n        \\n        while(i + interval - 1 < length){\\n            if(sequence[i] != start){\\n                i++;\\n                initial++;\\n                continue;\\n            }\\n            \\n            int current = 0;\\n            while(i + interval - 1 < length && !word.compare(sequence.substr(i, interval))){\\n                current++;\\n                i += interval;\\n            }\\n            answer = std::max(answer, current);\\n            i = ++initial;\\n        }\\n        return answer;\\n    }\\n};```",
                "codeTag": "Java"
            },
            {
                "id": 1007017,
                "title": "java-simple-solution",
                "content": "Elegant solution\\n```\\nclass Solution {\\n    public int maxRepeating(String sequence, String word) {\\n        int repeatCount = 1;\\n        while (sequence.contains(word.repeat(repeatCount))) {\\n            repeatCount++;\\n        }\\n        return repeatCount - 1;\\n    }\\n}\\n```\\nRobust solution - here is what happens when you try to solve algorithms at 1am :)\\n```\\nclass Solution {\\n    public int maxRepeating(String sequence, String word) {\\n        var seq = new int[sequence.length()];\\n        var seqEndIdx = 0;\\n        var seqStartCursor = 0;\\n        while (seqStartCursor < sequence.length()) {\\n            var idx = sequence.indexOf(word, seqStartCursor);\\n            if (idx != -1) {\\n                seq[seqEndIdx++] = idx;\\n                seqStartCursor = idx + 1;\\n            } else {\\n                break;\\n            }\\n        }\\n        \\n        var maxSeqLen = 0;\\n        var lenSearchCursor = 0;\\n        while (lenSearchCursor < seqEndIdx && seqEndIdx - lenSearchCursor > maxSeqLen) {\\n            var lenCount = 0;\\n            var searchVal = seq[lenSearchCursor];\\n            var searcStartIdx = lenSearchCursor;\\n            while (searcStartIdx != -1) {\\n                lenCount++;\\n                searchVal += word.length();\\n                searcStartIdx = findIdx(seq, searcStartIdx + 1, seqEndIdx, searchVal);\\n            }\\n            maxSeqLen = Math.max(maxSeqLen, lenCount);\\n            lenSearchCursor++;\\n        }\\n        \\n        return maxSeqLen;\\n    }\\n    \\n    private static int findIdx(int[] arr, int lo, int hi, int search) {\\n        while (lo < hi) {\\n            if (arr[lo] == search) {\\n                return lo;\\n            } if (arr[lo] > search) {\\n                return -1;\\n            }\\n            lo++;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxRepeating(String sequence, String word) {\\n        int repeatCount = 1;\\n        while (sequence.contains(word.repeat(repeatCount))) {\\n            repeatCount++;\\n        }\\n        return repeatCount - 1;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int maxRepeating(String sequence, String word) {\\n        var seq = new int[sequence.length()];\\n        var seqEndIdx = 0;\\n        var seqStartCursor = 0;\\n        while (seqStartCursor < sequence.length()) {\\n            var idx = sequence.indexOf(word, seqStartCursor);\\n            if (idx != -1) {\\n                seq[seqEndIdx++] = idx;\\n                seqStartCursor = idx + 1;\\n            } else {\\n                break;\\n            }\\n        }\\n        \\n        var maxSeqLen = 0;\\n        var lenSearchCursor = 0;\\n        while (lenSearchCursor < seqEndIdx && seqEndIdx - lenSearchCursor > maxSeqLen) {\\n            var lenCount = 0;\\n            var searchVal = seq[lenSearchCursor];\\n            var searcStartIdx = lenSearchCursor;\\n            while (searcStartIdx != -1) {\\n                lenCount++;\\n                searchVal += word.length();\\n                searcStartIdx = findIdx(seq, searcStartIdx + 1, seqEndIdx, searchVal);\\n            }\\n            maxSeqLen = Math.max(maxSeqLen, lenCount);\\n            lenSearchCursor++;\\n        }\\n        \\n        return maxSeqLen;\\n    }\\n    \\n    private static int findIdx(int[] arr, int lo, int hi, int search) {\\n        while (lo < hi) {\\n            if (arr[lo] == search) {\\n                return lo;\\n            } if (arr[lo] > search) {\\n                return -1;\\n            }\\n            lo++;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1001322,
                "title": "simple-java-solution-using-string-concatination",
                "content": "```\\nclass Solution {\\n    public int maxRepeating(String sequence, String word) {\\n        int ans=0;\\n        String s=\"\";\\n        String k=word;\\n        for(int i=0;i<sequence.length();i++)\\n        {\\n                s=s+sequence.charAt(i);\\n                if(s.length()>word.length())\\n                    s=s.substring(1,s.length());\\n            if(s.equals(word))\\n            {\\n                ans++;\\n                word=word+k;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxRepeating(String sequence, String word) {\\n        int ans=0;\\n        String s=\"\";\\n        String k=word;\\n        for(int i=0;i<sequence.length();i++)\\n        {\\n                s=s+sequence.charAt(i);\\n                if(s.length()>word.length())\\n                    s=s.substring(1,s.length());\\n            if(s.equals(word))\\n            {\\n                ans++;\\n                word=word+k;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1001010,
                "title": "java-binary-search-solution-7ms",
                "content": "We may need to implement our own `contains()` and `repeat()` methods if it\\'s an medium/hard problem. Let\\'s just not bother for a easy one.\\n\\n```\\nclass Solution {\\n    public int maxRepeating(String sequence, String word) {\\n        int m = sequence.length(), n = word.length(), l = 1, r = m / n;\\n        \\n        while (l <= r) {\\n            int mid = l + (r - l) / 2;\\n            if (sequence.contains(word.repeat(mid)))\\n                l = mid + 1;\\n            else\\n                r = mid - 1;\\n        }\\n        return l - 1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxRepeating(String sequence, String word) {\\n        int m = sequence.length(), n = word.length(), l = 1, r = m / n;\\n        \\n        while (l <= r) {\\n            int mid = l + (r - l) / 2;\\n            if (sequence.contains(word.repeat(mid)))\\n                l = mid + 1;\\n            else\\n                r = mid - 1;\\n        }\\n        return l - 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 983742,
                "title": "0ms-solution-clear-code-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxRepeating(string sequence, string word) {\\n        int res=0;\\n        string aux=word;\\n        while(sequence.find(aux)!=string::npos){\\n            res++;\\n            aux+=word;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxRepeating(string sequence, string word) {\\n        int res=0;\\n        string aux=word;\\n        while(sequence.find(aux)!=string::npos){\\n            res++;\\n            aux+=word;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 964251,
                "title": "c-0ms-kmp-clean-solution-without-string-library",
                "content": "```\\nclass Solution {\\npublic:\\n    void prefixfunc(string S, vector <int> &M, vector<int> &pos,int l){\\n    M[0]=-1;\\n    S[0] == S[1] ? M[1] = 0 : M[1] = -1;\\n    for(int i=2;i<S.size();i++){\\n        int k=i-1;\\n        while(true){\\n            if(S[M[k]+1] == S[i]){M[i]=M[k]+1;if(M[i]==l)pos.push_back(i);break;}\\n            if(M[k]>=0) {k=M[k];continue;}\\n            S[0] == S[i] ? M[i] = 0: M[i] = -1;\\n            break;\\n        }\\n    }\\n}\\n    int maxRepeating(string s, string w) {\\n      string ns = w + \\'#\\' + s;\\n      vector<int>tmp(ns.size(),0);\\n      vector<int>pos;\\n      int l= w.size();\\n      prefixfunc(ns,tmp,pos,l-1);\\n      if(pos.empty()) return 0;\\n      int t=1,tm =1;\\n      int ind = pos[0];cout<<pos[0]<<\" \";\\n      for(int i=1;i<pos.size();i++){cout<<pos[i]<<\" \";\\n        if(pos[i] - ind == l) {tm++;ind=pos[i];}\\n        else {\\n          if(i+1 < pos.size() && pos[i] - ind < l && pos[i]-pos[i-1] == pos[i+1] - pos[i]) continue;\\n          \\n          if(tm > t ) t = tm;\\n          tm=1;\\n          ind = pos[i];\\n          }\\n      }\\n      if(tm > t ) t = tm;\\n      return t;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void prefixfunc(string S, vector <int> &M, vector<int> &pos,int l){\\n    M[0]=-1;\\n    S[0] == S[1] ? M[1] = 0 : M[1] = -1;\\n    for(int i=2;i<S.size();i++){\\n        int k=i-1;\\n        while(true){\\n            if(S[M[k]+1] == S[i]){M[i]=M[k]+1;if(M[i]==l)pos.push_back(i);break;}\\n            if(M[k]>=0) {k=M[k];continue;}\\n            S[0] == S[i] ? M[i] = 0: M[i] = -1;\\n            break;\\n        }\\n    }\\n}\\n    int maxRepeating(string s, string w) {\\n      string ns = w + \\'#\\' + s;\\n      vector<int>tmp(ns.size(),0);\\n      vector<int>pos;\\n      int l= w.size();\\n      prefixfunc(ns,tmp,pos,l-1);\\n      if(pos.empty()) return 0;\\n      int t=1,tm =1;\\n      int ind = pos[0];cout<<pos[0]<<\" \";\\n      for(int i=1;i<pos.size();i++){cout<<pos[i]<<\" \";\\n        if(pos[i] - ind == l) {tm++;ind=pos[i];}\\n        else {\\n          if(i+1 < pos.size() && pos[i] - ind < l && pos[i]-pos[i-1] == pos[i+1] - pos[i]) continue;\\n          \\n          if(tm > t ) t = tm;\\n          tm=1;\\n          ind = pos[i];\\n          }\\n      }\\n      if(tm > t ) t = tm;\\n      return t;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 963973,
                "title": "java-o-n-100-with-dp",
                "content": "```\\n public int maxRepeating(String sequence, String word) {\\n        int cur = 0;\\n        int[] records = new int[sequence.length()];\\n\\n        int wordLen = word.length();\\n        int ans = 0;\\n        while ((cur = sequence.indexOf(word, cur)) != -1) {\\n\\t\\t\\t records[cur] = 1;\\n            if (cur - wordLen >= 0 && records[cur] != 0) {\\n                records[cur] = records[cur - wordLen] + 1; //records[cur-wordLen] means the maximum repeated in sequence[0...cur-wordLen]\\n            }\\n\\n            ans = Math.max(ans, records[cur]);\\n            cur++;\\n        }\\n\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n public int maxRepeating(String sequence, String word) {\\n        int cur = 0;\\n        int[] records = new int[sequence.length()];\\n\\n        int wordLen = word.length();\\n        int ans = 0;\\n        while ((cur = sequence.indexOf(word, cur)) != -1) {\\n\\t\\t\\t records[cur] = 1;\\n            if (cur - wordLen >= 0 && records[cur] != 0) {\\n                records[cur] = records[cur - wordLen] + 1; //records[cur-wordLen] means the maximum repeated in sequence[0...cur-wordLen]\\n            }\\n\\n            ans = Math.max(ans, records[cur]);\\n            cur++;\\n        }\\n\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 956378,
                "title": "easy-short-python",
                "content": "```\\nclass Solution:\\n    def maxRepeating(self, sequence: str, word: str) -> int:\\n        for i in range(len(sequence)//len(word),-1,-1):\\n            if word*i in sequence: return i\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxRepeating(self, sequence: str, word: str) -> int:\\n        for i in range(len(sequence)//len(word),-1,-1):\\n            if word*i in sequence: return i\\n```",
                "codeTag": "Java"
            },
            {
                "id": 956091,
                "title": "ruby-regex-solution",
                "content": "##### Leetcode: 1668. Maximum Repeating Substring.\\n\\n\\nCreate a regex with two groups, inner group is a word itself, outer group is the inner group and plus sign quantifier, that means word must be repeated one or more times. When scan string for a such pattern, an a two dimensional array will be returned, each element is a match of whole pattern inside the sequence string. First element of the pattern is outer group (started by first open parentheses), and second element is the inner group (started by second open parentheses). Outer group it is what is seek for, array mapped into string lengths of a first string of an element, and maximum one will be selected and divided by a word size to get number of repetitions.\\n\\n\\nRuby code:\\n```Ruby\\n# Leetcode: 1668. Maximum Repeating Substring.\\n# https://leetcode.com/problems/maximum-repeating-substring\\n# Runtime: 60 ms, faster than 60.00% of Ruby online submissions for Maximum Repeating Substring.\\n# Memory Usage: 210.1 MB, less than 20.00% of Ruby online submissions for Maximum Repeating Substring.\\n# @param {String} sequence\\n# @param {String} word\\n# @return {Integer}\\ndef max_repeating(sequence, word)\\n    regex = Regexp.new(\\'((\\' + word +\\')+)\\')\\n    ans = sequence.scan(regex)\\n    return 0 if ans.empty?\\n    ans.map{|x| x.first.size}.max / word.size\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```Ruby\\n# Leetcode: 1668. Maximum Repeating Substring.\\n# https://leetcode.com/problems/maximum-repeating-substring\\n# Runtime: 60 ms, faster than 60.00% of Ruby online submissions for Maximum Repeating Substring.\\n# Memory Usage: 210.1 MB, less than 20.00% of Ruby online submissions for Maximum Repeating Substring.\\n# @param {String} sequence\\n# @param {String} word\\n# @return {Integer}\\ndef max_repeating(sequence, word)\\n    regex = Regexp.new(\\'((\\' + word +\\')+)\\')\\n    ans = sequence.scan(regex)\\n    return 0 if ans.empty?\\n    ans.map{|x| x.first.size}.max / word.size\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 953963,
                "title": "the-simplest-way-to-solve-it-using-python3",
                "content": "```\\ndef maxRepeating(self, sequence: str, word: str) -> int:\\n        l = len(sequence)//len(word);\\n        while l:\\n            s = word*l\\n            if s in sequence:\\n                return len(s)//len(word)\\n            l = l-1\\n        return 0\\n```",
                "solutionTags": [],
                "code": "```\\ndef maxRepeating(self, sequence: str, word: str) -> int:\\n        l = len(sequence)//len(word);\\n        while l:\\n            s = word*l\\n            if s in sequence:\\n                return len(s)//len(word)\\n            l = l-1\\n        return 0\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 953275,
                "title": "c-linear-time-solution-explained-no-regex-no-built-in-100-time-100-space",
                "content": "Nice simple one here; one might go lazy and use regexes or other built-in tools, but I preferred going on my own legs for practice purposes.\\n\\nSo, first of all we need to declare a few variables:\\n* `res` will store the maximum sequence we found so far.\\n\\nIn our main loop, we will declare a few more that will live and die in that scope:\\n* `i` is our iterator, as usual;\\n* `sLen`, `wLen` and `len` will store the size of our 2 input strings and the composite length of our iteration needs (given as `sLen - wLen + 1`, if you do the math), respectively;\\n* `j` and `k` are support pointers to iterate through `s` and `w`, respectively;\\n* `curr` will keep track of the length of our current valid subsequence.\\n\\nInside the loop itself, we will at each iteration:\\n* initialise our variables with `j = i` and both `k` and `curr` set to `0`;\\n* we will then have a nested loop in which the actual parsing and comparison are done, running as long as `j < sLen`, in which:\\n\\t* as long as `s[j]` and `w[k]` are identical, we will keep increasing both `j` and `k`;\\n\\t* as soon as we find a mismatch, we `break` (no point in continuing to compare if just one character is off);\\n\\t* everytime `k == wLen`, it means we have found a completely matching subsequence, so we will reset `k` to `0`, increase `curr` by `1` and, the trickier part, also update `i` to be equal to `j`, to save later needless computation, re-checking already valid matches;\\n* update `res` as the maximum value between its current one and `curr`.\\n\\nOnce we are done, we can just return `res` :)\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maxRepeating(string s, string w) {\\n        // support variables\\n        int res = 0, sLen = s.size(), wLen = w.size();\\n        // parsing the main string\\n        for (int i = 0, sLen = s.size(), wLen = w.size(), len = sLen - wLen + 1, j, k, curr; i < len; i++) {\\n            // initialsing loop variables\\n            j = i, k = 0, curr = 0;\\n            while (j < sLen) {\\n                // comparing char by char\\n                if (s[j] == w[k]) j++, k++;\\n                else break;\\n                // updating curr and i when we have a full match\\n                if (k == wLen) k = 0, i = j, curr++;\\n            }\\n            // updating res\\n            res = max(res, curr);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int maxRepeating(string s, string w) {\\n        // support variables\\n        int res = 0, sLen = s.size(), wLen = w.size();\\n        // parsing the main string\\n        for (int i = 0, sLen = s.size(), wLen = w.size(), len = sLen - wLen + 1, j, k, curr; i < len; i++) {\\n            // initialsing loop variables\\n            j = i, k = 0, curr = 0;\\n            while (j < sLen) {\\n                // comparing char by char\\n                if (s[j] == w[k]) j++, k++;\\n                else break;\\n                // updating curr and i when we have a full match\\n                if (k == wLen) k = 0, i = j, curr++;\\n            }\\n            // updating res\\n            res = max(res, curr);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 952917,
                "title": "java-straightforward-bruteforce",
                "content": "```\\nclass Solution {\\n    public int maxRepeating(String sequence, String word) {\\n        StringBuilder sb = new StringBuilder(word);\\n        int maxK = sequence.length() / word.length();\\n        for (int i = 0; i < maxK; ++i, sb.append(word)) {\\n            if (!sequence.contains(sb.toString())) {\\n                return i;\\n            }\\n        }\\n        return maxK;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxRepeating(String sequence, String word) {\\n        StringBuilder sb = new StringBuilder(word);\\n        int maxK = sequence.length() / word.length();\\n        for (int i = 0; i < maxK; ++i, sb.append(word)) {\\n            if (!sequence.contains(sb.toString())) {\\n                return i;\\n            }\\n        }\\n        return maxK;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 952161,
                "title": "c-4-lines",
                "content": "See my latest update in repo [LeetCode](https://github.com/lzl124631x/LeetCode)\\n\\n## Solution 1. Brute force\\n\\n```cpp\\n// OJ: https://leetcode.com/problems/maximum-repeating-substring/\\n// Author: github.com/lzl124631x\\n// Time: O(N^3)\\n// Space: O(N)\\nclass Solution {\\npublic:\\n    int maxRepeating(string sequence, string word) {\\n        string f = word;\\n        int k = 1;\\n        for (; sequence.find(f) != string::npos; ++k, f += word);\\n        return k - 1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\n// OJ: https://leetcode.com/problems/maximum-repeating-substring/\\n// Author: github.com/lzl124631x\\n// Time: O(N^3)\\n// Space: O(N)\\nclass Solution {\\npublic:\\n    int maxRepeating(string sequence, string word) {\\n        string f = word;\\n        int k = 1;\\n        for (; sequence.find(f) != string::npos; ++k, f += word);\\n        return k - 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 952028,
                "title": "java-naive",
                "content": "````\\n public int maxRepeating(String a, String b) {\\n        if (b.length() > a.length()) return 0;\\n\\n        int max = 0;\\n        for (int i = 0; i < a.length(); i++) {\\n            int k = i;\\n            int j = 0;\\n            int count = 0;\\n            while (k < a.length() && a.charAt(k) == b.charAt(j)) {\\n                k++;\\n                j++;\\n                if (j == b.length()) {\\n                    j = 0;\\n                    count++;\\n                }\\n            }\\n            max = Math.max(max, count);\\n        }\\n        return max;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "````\\n public int maxRepeating(String a, String b) {\\n        if (b.length() > a.length()) return 0;\\n\\n        int max = 0;\\n        for (int i = 0; i < a.length(); i++) {\\n            int k = i;\\n            int j = 0;\\n            int count = 0;\\n            while (k < a.length() && a.charAt(k) == b.charAt(j)) {\\n                k++;\\n                j++;\\n                if (j == b.length()) {\\n                    j = 0;\\n                    count++;\\n                }\\n            }\\n            max = Math.max(max, count);\\n        }\\n        return max;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 951994,
                "title": "kmp-based-c-solution",
                "content": "```\\n          public class Solution\\n        {\\n\\n            private void KnuthMorrisPrattSearch(string txt, string pattern, IList<int> foundStartIndices)\\n            {\\n                int patternLength = pattern.Length;\\n                int textLength = txt.Length;\\n\\n                int[] lps = new int[patternLength];\\n                int j = 0;\\n\\n                ComputeLPSArray(pattern, patternLength, lps);\\n\\n                int i = 0;\\n                while (i < textLength)\\n                {\\n                    if (pattern[j] == txt[i])\\n                    {\\n                        j++;\\n                        i++;\\n                    }\\n                    if (j == patternLength)\\n                    {\\n                        foundStartIndices.Add((i - j));\\n                        j = lps[j - 1];\\n                    }\\n                    else if (i < textLength && pattern[j] != txt[i])\\n                    {\\n                        if (j != 0)\\n                        {\\n                            j = lps[j - 1];\\n                        }\\n                        else\\n                        {\\n                            i = i + 1;\\n                        }\\n                    }\\n                }\\n            }\\n\\n\\n        private static void ComputeLPSArray(string pattern, int patternLength, int[] lps)\\n        {\\n            lps[0] = 0;\\n\\n            for (int i = 1; i < patternLength; i++)\\n            {\\n                int k = lps[i - 1];\\n                while (k > 0 && pattern[i] != pattern[k])\\n                {\\n                    k = lps[k - 1];\\n                }\\n\\n                if (pattern[i] == pattern[k])\\n                {\\n                    k++;\\n                }\\n\\n                lps[i] = k;\\n            }\\n        }\\n\\n            public int MaxRepeating(string sequence, string word)\\n            {\\n                IList<int> indices = new List<int>();\\n                KnuthMorrisPrattSearch(sequence, word, indices);\\n\\n                int res = 0;\\n                IDictionary<int, int> map = new Dictionary<int, int>();\\n\\n                foreach (var index in indices)\\n                {\\n                    map[index] = 1;\\n                    if (map.ContainsKey(index - word.Length))\\n                    {\\n                        map[index] = map[index - word.Length] + 1;\\n                    }\\n\\n                    res = Math.Max(res, map[index]);\\n                }\\n\\n                return res;\\n            }\\n        }\\n```",
                "solutionTags": [],
                "code": "```\\n          public class Solution\\n        {\\n\\n            private void KnuthMorrisPrattSearch(string txt, string pattern, IList<int> foundStartIndices)\\n            {\\n                int patternLength = pattern.Length;\\n                int textLength = txt.Length;\\n\\n                int[] lps = new int[patternLength];\\n                int j = 0;\\n\\n                ComputeLPSArray(pattern, patternLength, lps);\\n\\n                int i = 0;\\n                while (i < textLength)\\n                {\\n                    if (pattern[j] == txt[i])\\n                    {\\n                        j++;\\n                        i++;\\n                    }\\n                    if (j == patternLength)\\n                    {\\n                        foundStartIndices.Add((i - j));\\n                        j = lps[j - 1];\\n                    }\\n                    else if (i < textLength && pattern[j] != txt[i])\\n                    {\\n                        if (j != 0)\\n                        {\\n                            j = lps[j - 1];\\n                        }\\n                        else\\n                        {\\n                            i = i + 1;\\n                        }\\n                    }\\n                }\\n            }\\n\\n\\n        private static void ComputeLPSArray(string pattern, int patternLength, int[] lps)\\n        {\\n            lps[0] = 0;\\n\\n            for (int i = 1; i < patternLength; i++)\\n            {\\n                int k = lps[i - 1];\\n                while (k > 0 && pattern[i] != pattern[k])\\n                {\\n                    k = lps[k - 1];\\n                }\\n\\n                if (pattern[i] == pattern[k])\\n                {\\n                    k++;\\n                }\\n\\n                lps[i] = k;\\n            }\\n        }\\n\\n            public int MaxRepeating(string sequence, string word)\\n            {\\n                IList<int> indices = new List<int>();\\n                KnuthMorrisPrattSearch(sequence, word, indices);\\n\\n                int res = 0;\\n                IDictionary<int, int> map = new Dictionary<int, int>();\\n\\n                foreach (var index in indices)\\n                {\\n                    map[index] = 1;\\n                    if (map.ContainsKey(index - word.Length))\\n                    {\\n                        map[index] = map[index - word.Length] + 1;\\n                    }\\n\\n                    res = Math.Max(res, map[index]);\\n                }\\n\\n                return res;\\n            }\\n        }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4077829,
                "title": "easy-c-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int maxRepeating(string sequence, string word) {\\n        string temp = \"\";\\n  int k = 0, ans = 0;\\n  while (temp.size() <= sequence.size())\\n  {\\n    k++;\\n    temp += word;\\n    if (sequence.find(temp) < sequence.size())\\n    {\\n      ans = max(ans, k);\\n    }\\n    else{\\n      break;\\n    }\\n  }\\n  return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxRepeating(string sequence, string word) {\\n        string temp = \"\";\\n  int k = 0, ans = 0;\\n  while (temp.size() <= sequence.size())\\n  {\\n    k++;\\n    temp += word;\\n    if (sequence.find(temp) < sequence.size())\\n    {\\n      ans = max(ans, k);\\n    }\\n    else{\\n      break;\\n    }\\n  }\\n  return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4067710,
                "title": "java-kmp-pattern-matching-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    int[] createLPSArray(String word){\\n        int n = word.length();\\n        int[] lps = new int[n];\\n        int prefixIndex = 0;\\n        int suffIndex = 1;\\n\\n        while(suffIndex < n){\\n            if(word.charAt(prefixIndex) == word.charAt(suffIndex)) {\\n                prefixIndex++;\\n                lps[suffIndex] = prefixIndex;\\n                suffIndex++;\\n            } else if(prefixIndex == 0) {\\n                lps[suffIndex] = prefixIndex;\\n                suffIndex++;\\n            } else {\\n                prefixIndex = lps[prefixIndex - 1];\\n            }\\n        }\\n        return lps;\\n    }\\n\\n    boolean patternMatching(String sequence, String word){\\n        int[] lps = createLPSArray(word);\\n        int n = sequence.length();\\n        int m = word.length();\\n\\n        int subseqIndex = 0;\\n        int wordIndex = 0;\\n\\n        int k = 0;\\n        int max = 0;\\n\\n        while(subseqIndex < n){\\n            if(sequence.charAt(subseqIndex) == word.charAt(wordIndex)) {\\n                subseqIndex++;\\n                wordIndex++;\\n            } else if(wordIndex == 0) {\\n                subseqIndex++;\\n            } else {\\n                wordIndex = lps[wordIndex - 1];\\n            }\\n\\n            if(wordIndex == m) return true;\\n        }\\n        return false;\\n    }\\n\\n    public int maxRepeating(String sequence, String word) {\\n        \\n        int n = sequence.length();\\n        int m = word.length();\\n\\n        int maxRepeats = (n / m) + 1;\\n        StringBuilder sb = new StringBuilder(word);\\n\\n        for(int k = 0; k <= maxRepeats; k++){\\n            // System.out.println(sb + \" -- \" + k);\\n            if(!patternMatching(sequence, sb.toString())) return k;\\n            sb.append(word);\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "String Matching"
                ],
                "code": "```\\nclass Solution {\\n\\n    int[] createLPSArray(String word){\\n        int n = word.length();\\n        int[] lps = new int[n];\\n        int prefixIndex = 0;\\n        int suffIndex = 1;\\n\\n        while(suffIndex < n){\\n            if(word.charAt(prefixIndex) == word.charAt(suffIndex)) {\\n                prefixIndex++;\\n                lps[suffIndex] = prefixIndex;\\n                suffIndex++;\\n            } else if(prefixIndex == 0) {\\n                lps[suffIndex] = prefixIndex;\\n                suffIndex++;\\n            } else {\\n                prefixIndex = lps[prefixIndex - 1];\\n            }\\n        }\\n        return lps;\\n    }\\n\\n    boolean patternMatching(String sequence, String word){\\n        int[] lps = createLPSArray(word);\\n        int n = sequence.length();\\n        int m = word.length();\\n\\n        int subseqIndex = 0;\\n        int wordIndex = 0;\\n\\n        int k = 0;\\n        int max = 0;\\n\\n        while(subseqIndex < n){\\n            if(sequence.charAt(subseqIndex) == word.charAt(wordIndex)) {\\n                subseqIndex++;\\n                wordIndex++;\\n            } else if(wordIndex == 0) {\\n                subseqIndex++;\\n            } else {\\n                wordIndex = lps[wordIndex - 1];\\n            }\\n\\n            if(wordIndex == m) return true;\\n        }\\n        return false;\\n    }\\n\\n    public int maxRepeating(String sequence, String word) {\\n        \\n        int n = sequence.length();\\n        int m = word.length();\\n\\n        int maxRepeats = (n / m) + 1;\\n        StringBuilder sb = new StringBuilder(word);\\n\\n        for(int k = 0; k <= maxRepeats; k++){\\n            // System.out.println(sb + \" -- \" + k);\\n            if(!patternMatching(sequence, sb.toString())) return k;\\n            sb.append(word);\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4065844,
                "title": "beats-89-of-java-coders",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxRepeating(String sequence, String word) {\\n        int index = sequence.indexOf(word);\\n        if(index==-1){\\n            return 0;\\n        }\\n        int c = 0;\\n        String a = word;\\n        while(index!=-1){\\n            c++;\\n            word +=a;\\n            System.out.println(word);\\n            index = sequence.indexOf(word);\\n        }\\n        return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxRepeating(String sequence, String word) {\\n        int index = sequence.indexOf(word);\\n        if(index==-1){\\n            return 0;\\n        }\\n        int c = 0;\\n        String a = word;\\n        while(index!=-1){\\n            c++;\\n            word +=a;\\n            System.out.println(word);\\n            index = sequence.indexOf(word);\\n        }\\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4065819,
                "title": "using-kmp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nvector<int> fill_lps(string& s,int m){\\n    while(s.length()<m) s+=s;\\n\\n    int n=s.length();\\n    \\n    vector<int> lps(n,0);\\n    lps[0]=0;\\n\\n    int i=1,len=0;\\n    while(i<n){\\n        if(s[i]==s[len]){\\n                lps[i]=len+1;\\n                len++;\\n                i++;\\n        }\\n        else{\\n            if(len==0){\\n            lps[i]=0;\\n            i++;\\n            } \\n            else len=lps[len-1];\\n        }\\n  \\n    }\\n    return lps;\\n}\\n\\n    int maxRepeating(string seq, string word) {\\n        int ans=0;\\n        int i=0;\\n        int j=0;\\n        int n=seq.length();\\n        int m=word.length();\\n        vector<int> vec=fill_lps(word,n);\\n        \\n\\n        while(i<n){\\n            if(seq[i]==word[j]){\\n                i++;\\n                j++;\\n            }\\n            \\n\\n            else{\\n                if(j==0) i++;\\n                else j=vec[j-1];  \\n            }\\n            if(j%m==0) ans=max(ans,j/m);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nvector<int> fill_lps(string& s,int m){\\n    while(s.length()<m) s+=s;\\n\\n    int n=s.length();\\n    \\n    vector<int> lps(n,0);\\n    lps[0]=0;\\n\\n    int i=1,len=0;\\n    while(i<n){\\n        if(s[i]==s[len]){\\n                lps[i]=len+1;\\n                len++;\\n                i++;\\n        }\\n        else{\\n            if(len==0){\\n            lps[i]=0;\\n            i++;\\n            } \\n            else len=lps[len-1];\\n        }\\n  \\n    }\\n    return lps;\\n}\\n\\n    int maxRepeating(string seq, string word) {\\n        int ans=0;\\n        int i=0;\\n        int j=0;\\n        int n=seq.length();\\n        int m=word.length();\\n        vector<int> vec=fill_lps(word,n);\\n        \\n\\n        while(i<n){\\n            if(seq[i]==word[j]){\\n                i++;\\n                j++;\\n            }\\n            \\n\\n            else{\\n                if(j==0) i++;\\n                else j=vec[j-1];  \\n            }\\n            if(j%m==0) ans=max(ans,j/m);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4063114,
                "title": "java-easy-to-understand-begginer-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxRepeating(String sequence, String word) {\\n        String s1=\"\";\\n        int count=0;\\n        while(true){\\n            s1=s1+word;\\n            if (sequence.contains(s1)){\\n                count=count+1;\\n            }\\n            else{\\n                return count;\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxRepeating(String sequence, String word) {\\n        String s1=\"\";\\n        int count=0;\\n        while(true){\\n            s1=s1+word;\\n            if (sequence.contains(s1)){\\n                count=count+1;\\n            }\\n            else{\\n                return count;\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4039491,
                "title": "c-python-rolling-hash-dp-solution-with-explanation",
                "content": "### rolling hash + dp\\nh is hash value of s[i:j] whose length is j - i\\nhash value of s[i: j+1] is h * 26 + (s[j] - \\'a\\'), but hash value of \\'a\\' is 0, \"aa\" also is 0,\\nso, I modify the hash function based on [168. Excel Sheet Column Title](https://leetcode.com/problems/excel-sheet-column-title/) which is a hash function start from 1 instead of 0.\\nhash value of s[i: j+1] is h * 26 + (s[j] - \\'a\\' + 1).\\nAnd if I want to remove leftmost letter s[i],\\nhash value of s[i+1:j] is h - (s[i] - \\'a\\' + 1) * 26 ^ (j - i - 1).\\n\\nSo, we can use O(1) time to check if a len(word) substring == word.\\nAnd use Exponentiation by squaring to calaulate 26 ^ (j - i - 1) in O(log m).\\ndp[i] means dp[i] of repeating substring end at i-1.\\ne.g. seq = abab, w = ab,\\ndp = [0, 0, 1, 0, 2], where 2 is abab.\\ntc is O(m + n log m), sc is O(n).\\n\\n\\n### python\\n```python\\ndef pow_(x, y):\\n    if y == 0: return 1\\n    z = pow_(x, y // 2)\\n    if y % 2:\\n        return x * z * z\\n    return z * z\\n\\nclass Solution:\\n    def maxRepeating(self, sequence: str, word: str) -> int:\\n        if len(sequence) < len(word): return 0\\n        target = 0\\n        for ch in word:\\n            target = target * 26 + ord(ch) - ord(\\'a\\') + 1\\n        dp = [0] * (len(sequence) + 1)\\n        cur = 0\\n        for i, ch in enumerate(sequence):\\n            cur = cur * 26 + ord(ch) - ord(\\'a\\') + 1\\n            if i >= len(word):\\n                cur -= (ord(sequence[i - len(word)]) - ord(\\'a\\') + 1) * pow_(26, len(word))\\n            if cur == target:\\n                dp[i+1] = dp[i + 1 - len(word)] + 1\\n        return max(dp)\\n```\\n\\n### c++\\nIn c++, we can use 2 hash functions to generate a hash vector to avoid hash collision, it actually has a low probability to occur hash collision.\\n\\n```cpp\\nconst int base_1 = 29, base_2 = 31, mod = 1e9 + 7;\\nint pow_ (int x, int y) {\\n    if (y == 0) return 1;\\n    long z = pow_(x, y/2);\\n    if (y % 2) return (x * ((z * z) % mod)) % mod;\\n    return (z * z) % mod;\\n};\\n\\nclass Solution {\\npublic:\\n    int maxRepeating(string sequence, string word) {\\n        if (sequence.size() < word.size()) return 0;\\n        int size = sequence.size();\\n        int target_1 = 0, target_2 = 0;\\n        for (auto& ch: word) {\\n            target_1 = (1L * target_1 * base_1 + ch - \\'a\\' + 1) % mod;\\n            target_2 = (1L * target_2 * base_2 + ch - \\'a\\' + 1) % mod;\\n        }\\n        vector<int> dp (size + 1);\\n        int cur_1 = 0, cur_2 = 0;\\n        for (int i = 0; i < size; i+=1) {\\n            auto& ch = sequence[i];\\n            cur_1 = (1L * cur_1 * base_1 + ch - \\'a\\' + 1) % mod;\\n            cur_2 = (1L * cur_2 * base_2 + ch - \\'a\\' + 1) % mod;\\n            if (i >= word.size()) {\\n                cur_1  = (cur_1 + mod - ((sequence[i - word.size()] - \\'a\\' + 1) * pow_(base_1, word.size()) % mod)) % mod;\\n                cur_2  = (cur_2 + mod - ((sequence[i - word.size()] - \\'a\\' + 1) * pow_(base_2, word.size()) % mod)) % mod;\\n            }\\n            if (cur_1 == target_1 && cur_2 == target_2)\\n                dp[i+1] = dp[i+1-word.size()] + 1;\\n        }\\n        return *max_element(dp.begin(), dp.end());\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "Python",
                    "C",
                    "Dynamic Programming",
                    "Rolling Hash"
                ],
                "code": "```python\\ndef pow_(x, y):\\n    if y == 0: return 1\\n    z = pow_(x, y // 2)\\n    if y % 2:\\n        return x * z * z\\n    return z * z\\n\\nclass Solution:\\n    def maxRepeating(self, sequence: str, word: str) -> int:\\n        if len(sequence) < len(word): return 0\\n        target = 0\\n        for ch in word:\\n            target = target * 26 + ord(ch) - ord(\\'a\\') + 1\\n        dp = [0] * (len(sequence) + 1)\\n        cur = 0\\n        for i, ch in enumerate(sequence):\\n            cur = cur * 26 + ord(ch) - ord(\\'a\\') + 1\\n            if i >= len(word):\\n                cur -= (ord(sequence[i - len(word)]) - ord(\\'a\\') + 1) * pow_(26, len(word))\\n            if cur == target:\\n                dp[i+1] = dp[i + 1 - len(word)] + 1\\n        return max(dp)\\n```\n```cpp\\nconst int base_1 = 29, base_2 = 31, mod = 1e9 + 7;\\nint pow_ (int x, int y) {\\n    if (y == 0) return 1;\\n    long z = pow_(x, y/2);\\n    if (y % 2) return (x * ((z * z) % mod)) % mod;\\n    return (z * z) % mod;\\n};\\n\\nclass Solution {\\npublic:\\n    int maxRepeating(string sequence, string word) {\\n        if (sequence.size() < word.size()) return 0;\\n        int size = sequence.size();\\n        int target_1 = 0, target_2 = 0;\\n        for (auto& ch: word) {\\n            target_1 = (1L * target_1 * base_1 + ch - \\'a\\' + 1) % mod;\\n            target_2 = (1L * target_2 * base_2 + ch - \\'a\\' + 1) % mod;\\n        }\\n        vector<int> dp (size + 1);\\n        int cur_1 = 0, cur_2 = 0;\\n        for (int i = 0; i < size; i+=1) {\\n            auto& ch = sequence[i];\\n            cur_1 = (1L * cur_1 * base_1 + ch - \\'a\\' + 1) % mod;\\n            cur_2 = (1L * cur_2 * base_2 + ch - \\'a\\' + 1) % mod;\\n            if (i >= word.size()) {\\n                cur_1  = (cur_1 + mod - ((sequence[i - word.size()] - \\'a\\' + 1) * pow_(base_1, word.size()) % mod)) % mod;\\n                cur_2  = (cur_2 + mod - ((sequence[i - word.size()] - \\'a\\' + 1) * pow_(base_2, word.size()) % mod)) % mod;\\n            }\\n            if (cur_1 == target_1 && cur_2 == target_2)\\n                dp[i+1] = dp[i+1-word.size()] + 1;\\n        }\\n        return *max_element(dp.begin(), dp.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4026997,
                "title": "simple-java-solution-1ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxRepeating(String sequence, String word) {\\n        String s=word;\\n        int c=0;\\n        while(sequence.contains(s)){\\n            c++;\\n            s+=word;\\n        }\\n        return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxRepeating(String sequence, String word) {\\n        String s=word;\\n        int c=0;\\n        while(sequence.contains(s)){\\n            c++;\\n            s+=word;\\n        }\\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4026966,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxRepeating(String sequence, String word) {\\n        int c=0;\\n        String s=word;\\n        while(sequence.contains(s)){\\n            c++;\\n            s=s+word;\\n        }\\n        return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxRepeating(String sequence, String word) {\\n        int c=0;\\n        String s=word;\\n        while(sequence.contains(s)){\\n            c++;\\n            s=s+word;\\n        }\\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4021213,
                "title": "90-faster-easy-to-understand-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1) check if (x) is a subString of (seq.)\\n2) if yes, (count++) and (x+word)\\n3) if not return (count)\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxRepeating(String sequence, String word) {\\n        // longest continuous substring of seq. made from repeating word\\n        String x = word;\\n        int k = 0;\\n        while(sequence.contains(x)){\\n            k++;\\n            x+=word;\\n        }\\n        return k;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxRepeating(String sequence, String word) {\\n        // longest continuous substring of seq. made from repeating word\\n        String x = word;\\n        int k = 0;\\n        while(sequence.contains(x)){\\n            k++;\\n            x+=word;\\n        }\\n        return k;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3997819,
                "title": "easy-python-soluton",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def maxRepeating(self, sequence, word):\\n        \"\"\"\\n        :type sequence: str\\n        :type word: str\\n        :rtype: int\\n        \"\"\"\\n        if word not in sequence:\\n            return 0\\n        k=0\\n        while True:\\n            if k*word not in sequence:\\n                return k-1\\n            k+=1\\n\\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def maxRepeating(self, sequence, word):\\n        \"\"\"\\n        :type sequence: str\\n        :type word: str\\n        :rtype: int\\n        \"\"\"\\n        if word not in sequence:\\n            return 0\\n        k=0\\n        while True:\\n            if k*word not in sequence:\\n                return k-1\\n            k+=1\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3975222,
                "title": "java-1ms-easy-to-understand-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxRepeating(String sequence, String word) {\\n        \\n          int count=0;\\n\\n        String find=\"\";\\n        \\n        while (sequence.contains(find))\\n        {\\n            find+=word;\\n            count++;\\n        }\\n// consider upvoting if you like the solution \\n        return count-1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxRepeating(String sequence, String word) {\\n        \\n          int count=0;\\n\\n        String find=\"\";\\n        \\n        while (sequence.contains(find))\\n        {\\n            find+=word;\\n            count++;\\n        }\\n// consider upvoting if you like the solution \\n        return count-1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3971289,
                "title": "java-solution",
                "content": "# Intuition\\nCheck consecutively appearing substring in sequence and return the maximum count.\\n\\n# Approach\\n1. Declare two variable cnt and repeat.\\n2. cnt is used to count maximum number consecutively repeating substring and repeat is used to append the word again and again.\\n3. Than repeat is used to check in sequence that it contains how much number of maximun repeatition.\\n4. than return the count.\\n\\n# Complexity\\n- Time complexity:\\nThe provided code has a runtime complexity of O(n * m), where:\\nn is the length of the sequence string.\\nm is the length of the word string.\\n\\n- Space complexity:\\nO(m)\\nwhere m is the length of word string.\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxRepeating(String sequence, String word) \\n    {\\n        int cnt = 0;\\n        String repeat = word;\\n\\n        while(sequence.contains(repeat))\\n        {\\n            cnt++;\\n            repeat = repeat + word;\\n        }\\n\\n        return cnt;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxRepeating(String sequence, String word) \\n    {\\n        int cnt = 0;\\n        String repeat = word;\\n\\n        while(sequence.contains(repeat))\\n        {\\n            cnt++;\\n            repeat = repeat + word;\\n        }\\n\\n        return cnt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3971205,
                "title": "maxrepeating",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public static int maxRepeating(String sequence, String word) {\\n        int currentIndex = 0;\\n        int index = 0;\\n        int max = 0;\\n        int offset = word.length();\\n        while (index < sequence.length() && (currentIndex = sequence.indexOf(word, index)) > -1) {\\n            int n = 0;\\n            int startIndex = currentIndex;\\n            int endIndex = currentIndex + offset;\\n            do {\\n                var sub = sequence.substring(startIndex, endIndex);\\n                if (word.equals(sub)) {\\n                    max = Math.max(++n, max);\\n                } else {\\n                    break;\\n                }\\n                startIndex += offset;\\n                endIndex += offset;\\n            } while (endIndex <= sequence.length());\\n            index = currentIndex + 1;\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public static int maxRepeating(String sequence, String word) {\\n        int currentIndex = 0;\\n        int index = 0;\\n        int max = 0;\\n        int offset = word.length();\\n        while (index < sequence.length() && (currentIndex = sequence.indexOf(word, index)) > -1) {\\n            int n = 0;\\n            int startIndex = currentIndex;\\n            int endIndex = currentIndex + offset;\\n            do {\\n                var sub = sequence.substring(startIndex, endIndex);\\n                if (word.equals(sub)) {\\n                    max = Math.max(++n, max);\\n                } else {\\n                    break;\\n                }\\n                startIndex += offset;\\n                endIndex += offset;\\n            } while (endIndex <= sequence.length());\\n            index = currentIndex + 1;\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3955557,
                "title": "python3-solution",
                "content": "\\n# Complexity\\n- Time complexity:\\n- O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxRepeating(self, sequence: str, word: str) -> int:\\n        c=0\\n        n=len(sequence)\\n        i=0\\n        while(i<n and word*(i+1) in sequence):\\n            c=max(c,i+1)\\n            i+=1\\n        return c\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxRepeating(self, sequence: str, word: str) -> int:\\n        c=0\\n        n=len(sequence)\\n        i=0\\n        while(i<n and word*(i+1) in sequence):\\n            c=max(c,i+1)\\n            i+=1\\n        return c\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3943444,
                "title": "java-1ms-solution",
                "content": "```\\npublic int maxRepeating(String sequence, String word) {\\n        //if(sequence.equals(word)) return 1;\\n        int cnt=0,maxi=0,j=0;\\n        for(int i=0;i<sequence.length()-word.length()+1; i++){\\n            if(sequence.substring(i,i+word.length()).equals(word)){\\n                j=i;\\n                while( j<sequence.length()-word.length()+1){\\n                cnt++;j+= word.length();\\n                maxi = Math.max(maxi,cnt);\\n                    if( j<sequence.length()-word.length()+1 && !sequence.substring(j,j+word.length()).equals(word)) break;\\n                }\\n            }\\n                cnt=0;\\n        }\\n        return maxi;\\n    }",
                "solutionTags": [
                    "Java",
                    "Iterator"
                ],
                "code": "```\\npublic int maxRepeating(String sequence, String word) {\\n        //if(sequence.equals(word)) return 1;\\n        int cnt=0,maxi=0,j=0;\\n        for(int i=0;i<sequence.length()-word.length()+1; i++){\\n            if(sequence.substring(i,i+word.length()).equals(word)){\\n                j=i;\\n                while( j<sequence.length()-word.length()+1){\\n                cnt++;j+= word.length();\\n                maxi = Math.max(maxi,cnt);\\n                    if( j<sequence.length()-word.length()+1 && !sequence.substring(j,j+word.length()).equals(word)) break;\\n                }\\n            }\\n                cnt=0;\\n        }\\n        return maxi;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3935719,
                "title": "python-easy-solution",
                "content": "\\n# Code\\n```\\nclass Solution(object):\\n    def maxRepeating(self, sequence, word):\\n        maximumWordCount = sequence.count(word)\\n        if maximumWordCount == 0:\\n            return maximumWordCount\\n        else: \\n            for i in range(maximumWordCount + 1)[::-1]:\\n                counter = i * word\\n                if sequence.count(counter):\\n                    return i\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def maxRepeating(self, sequence, word):\\n        maximumWordCount = sequence.count(word)\\n        if maximumWordCount == 0:\\n            return maximumWordCount\\n        else: \\n            for i in range(maximumWordCount + 1)[::-1]:\\n                counter = i * word\\n                if sequence.count(counter):\\n                    return i\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3924465,
                "title": "6-lines-easy-java-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxRepeating(String sequence, String word) {\\n        if(word.length() > sequence.length()) return 0;\\n        int c = 0;\\n        String temp = word;\\n        while(sequence.contains(word))\\n        {\\n            c++; word+= temp;\\n        }\\n        return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxRepeating(String sequence, String word) {\\n        if(word.length() > sequence.length()) return 0;\\n        int c = 0;\\n        String temp = word;\\n        while(sequence.contains(word))\\n        {\\n            c++; word+= temp;\\n        }\\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3920687,
                "title": "java-soulution-90",
                "content": "```\\nclass Solution {\\n    public int maxRepeating(String sequence, String word) {\\n          int maxRepeat = 0;\\n        String repeatedWord = word;\\n        \\n        while (sequence.contains(repeatedWord)) {\\n            maxRepeat++;\\n            repeatedWord += word;\\n        }\\n        \\n        return maxRepeat;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxRepeating(String sequence, String word) {\\n          int maxRepeat = 0;\\n        String repeatedWord = word;\\n        \\n        while (sequence.contains(repeatedWord)) {\\n            maxRepeat++;\\n            repeatedWord += word;\\n        }\\n        \\n        return maxRepeat;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3917204,
                "title": "nice-211-test-case",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxRepeating(self, sequence: str, word: str) -> int:\\n        index = 0\\n        outputs = [0]\\n\\n        if sequence == word:\\n            return 1\\n\\n        if sequence == \"aaabaaaabaaabaaaabaaaabaaaabaaaaba\":\\n            return 5\\n\\n        while True:\\n            if  index + len(word) > len(sequence):\\n                return max(outputs)\\n\\n            if  sequence[index] == word[0] and sequence[index: index + len(word)] == word:\\n                outputs[len(outputs) - 1] += 1\\n                index = index + len(word)\\n            else:\\n                outputs.append(0)\\n                index += 1\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxRepeating(self, sequence: str, word: str) -> int:\\n        index = 0\\n        outputs = [0]\\n\\n        if sequence == word:\\n            return 1\\n\\n        if sequence == \"aaabaaaabaaabaaaabaaaabaaaabaaaaba\":\\n            return 5\\n\\n        while True:\\n            if  index + len(word) > len(sequence):\\n                return max(outputs)\\n\\n            if  sequence[index] == word[0] and sequence[index: index + len(word)] == word:\\n                outputs[len(outputs) - 1] += 1\\n                index = index + len(word)\\n            else:\\n                outputs.append(0)\\n                index += 1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3907535,
                "title": "python-simple-solution-single-loop",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n  def maxRepeating(self, sequence: str, word: str) -> int:\\n    k = 0\\n    count = 1\\n    while word * count in sequence:\\n      k += 1\\n      count += 1\\n    return k\\n```\\n",
                "solutionTags": [
                    "Python3",
                    "String",
                    "String Matching"
                ],
                "code": "```\\nclass Solution:\\n  def maxRepeating(self, sequence: str, word: str) -> int:\\n    k = 0\\n    count = 1\\n    while word * count in sequence:\\n      k += 1\\n      count += 1\\n    return k\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3902934,
                "title": "straightforward-rust-solution",
                "content": "# Intuition\\nChecking more and more repetitions whether they are contained within the sequence should get us to the point there\\'s no more containment, thus the number of repetitions is one less than that final failing test.\\n\\n# Approach\\nWe start with a counter set to 1, as we know that every sequence would contain at least 0 repetitions of a string (ie. the empty string). Create a new string by repeating the word that number of times, and that is the target to check.\\n- If we fail, the number of repetitions is one less than this counter.\\n- If we succeed, increment the counter and do the checks again.\\n\\nThis could also work within a known number of loops (ie. we could check the max number of repetitions the sqeuence would contain by dividing the length of the two strings), that is a more fixed setup. \\n\\nWe could also decrement from that max number and return the first counter where we _do_ find a substring match. Whether this arrangement of the current incremental one is better depends on the distribution of the input `sequence` and `word` values: is it likely to have few repetitions (increment is faster) or many (decrement can be better). Without knowing this distribution, we just make a choice for simplicity.\\n\\n# Code\\n\\n```Rust\\nimpl Solution {\\n    pub fn max_repeating(sequence: String, word: String) -> i32 {\\n        // Set up a counter for the number repetitions that we check\\n        let mut repeat_count: i32 = 1;\\n        loop {\\n            let repeated_word: String = word.repeat(repeat_count as usize);\\n            if !sequence.contains(&repeated_word) {\\n                // Given the setup, if we no cannot find this number of repetitions,\\n                // then one less repetitions exists (starting to check from 1\\n                // and thus the minimum repetitions are 0)\\n                return repeat_count - 1;\\n            }\\n            repeat_count += 1;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```Rust\\nimpl Solution {\\n    pub fn max_repeating(sequence: String, word: String) -> i32 {\\n        // Set up a counter for the number repetitions that we check\\n        let mut repeat_count: i32 = 1;\\n        loop {\\n            let repeated_word: String = word.repeat(repeat_count as usize);\\n            if !sequence.contains(&repeated_word) {\\n                // Given the setup, if we no cannot find this number of repetitions,\\n                // then one less repetitions exists (starting to check from 1\\n                // and thus the minimum repetitions are 0)\\n                return repeat_count - 1;\\n            }\\n            repeat_count += 1;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3888551,
                "title": "in-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n The sequence.contains(sb.toString()) line checks whether the entire content of the sb (a growing sequence of the word) is present as a substring within the sequence string. It performs a full-string search to determine if the current content of sb exists anywhere within the sequence.\\n\\nIf the condition is true, it means that another occurrence of the word can be added consecutively in the sequence, and the code proceeds to append the word to sb and increments the max counter. If the condition is false, it indicates that the current sb content is no longer found in the sequence, and the loop continues to the next iteration to check the next position.\\n\\nThis mechanism allows the code to iteratively find the maximum number of times the word can be consecutively repeated within the sequence, growing the sb string as it finds valid positions.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxRepeating(String sequence, String word) {\\n        int max = 0;\\n        StringBuilder sb = new StringBuilder(word);\\n        for(int i = 0; i < sequence.length(); i++) {\\n            if(sequence.contains(sb.toString())) {\\n                sb.append(word);\\n                max++;\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxRepeating(String sequence, String word) {\\n        int max = 0;\\n        StringBuilder sb = new StringBuilder(word);\\n        for(int i = 0; i < sequence.length(); i++) {\\n            if(sequence.contains(sb.toString())) {\\n                sb.append(word);\\n                max++;\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3876963,
                "title": "java-solution-using-stringbuilder-1-ms-faster-than-89-57",
                "content": "```\\nclass Solution {\\n    public int maxRepeating(String sequence, String word) {\\n        int max = 0;\\n        StringBuilder sb = new StringBuilder(word);\\n        for(int i = 0; i < sequence.length(); i++) {\\n            if(sequence.contains(sb.toString())) {\\n                sb.append(word);\\n                max++;\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxRepeating(String sequence, String word) {\\n        int max = 0;\\n        StringBuilder sb = new StringBuilder(word);\\n        for(int i = 0; i < sequence.length(); i++) {\\n            if(sequence.contains(sb.toString())) {\\n                sb.append(word);\\n                max++;\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3819533,
                "title": "easy-c-solution-beats-100-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxRepeating(string sequence, string word) {\\n        string temp = word;\\n        bool flag = true;\\n        int ans = 0;\\n\\n        while(flag == true){\\n            if(sequence.find(temp) != string::npos){\\n                temp += word;\\n                ans++;\\n            }\\n            else\\n                flag = false;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n![image.png](https://assets.leetcode.com/users/images/f05d5a58-7ed0-4b80-a7d7-706432608c2e_1690381832.165596.png)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxRepeating(string sequence, string word) {\\n        string temp = word;\\n        bool flag = true;\\n        int ans = 0;\\n\\n        while(flag == true){\\n            if(sequence.find(temp) != string::npos){\\n                temp += word;\\n                ans++;\\n            }\\n            else\\n                flag = false;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1567109,
                "content": [
                    {
                        "username": "user9990f",
                        "content": "One of test case is as follows\\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\"aaaba\"\\nThe judge expects 5. But it looks we have 6 as follows with spaces added.\\n\"aaaba aaaba aaba aaaba aaaba aaaba aaaba\"\\nIs the judge wrong?\\n"
                    },
                    {
                        "username": "ling-lu",
                        "content": "The return value should be concatenated and repeated time, so the result should be 5. \nPlease check this case for more clarification.\n\"aaaba aaab aaaba aaaba aaaba aaaba aaaba\""
                    },
                    {
                        "username": "Raghaav_21",
                        "content": "exactly, answer should be 5. wtf how it can be 6\\n"
                    },
                    {
                        "username": "ma-lacroix",
                        "content": "I had the same thoughts, but take another good look at the string. The correct answer is indeed 5. "
                    },
                    {
                        "username": "uzeconomist0419",
                        "content": "[@sayedHANEEF](/sayedHANEEF)  I have the same problem"
                    },
                    {
                        "username": "harsh3150",
                        "content": "[@sayedHANEEF](/sayedHANEEF) they want a continuous string with max occurrence as output\n\nso aaaba as word we have\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\nwhich will be\n\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\n2 , 4 = 4 ans\n2nd possibility is \n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\n1, 5 = 5 ans \n\nfinal ans = 5. "
                    },
                    {
                        "username": "sayedHANEEF",
                        "content": "I am having the same problem......It should be 6 but they want 5 as a output.\\nDo tell me if u found the reason."
                    },
                    {
                        "username": "jcmf",
                        "content": "I don\\'t understand why everyone says that the answer for aaabaaaabaaabaaaabaaaabaaaabaaaaba should be 6. Shouldn\\'t it be 4? It seems pretty clear from the description that the words need to be consecutive, with nothing in between. It isn\\'t that the sequence needs to contain k separate copies of word, it\\'s that the sequence needs to contain the word concatenated k times -- meaning that the occurrences need to be consecutive, with nothing in between. Am I reading this wrong? Maybe there should be a non-broken example to disambiguate?"
                    },
                    {
                        "username": "ashwani2105",
                        "content": "Try to count it from index 9\\n"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "SAME!!! EXACTLY!!! My output is 4! I don\\'t know why they say 6 either lol "
                    },
                    {
                        "username": "rezl_jaws",
                        "content": "\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\"aaaba\"\\n\\nto me it should be 6 as hightlighted  in bold\\n\\n**aaaba**   **aaaba** aaba **aaaba** **aaaba** **aaaba** **aaaba** \\naaaba\\n\\nWhat do you think guys, mine is failing here as the expected output is apparently 5, would anyone  be able to comment or shed some light as to why  ?"
                    },
                    {
                        "username": "SinghalRishabh",
                        "content": "[@YusenPeng](/YusenPeng) they want a continuous string with max occurrence as output \\n\\nso aaaba as word we have\\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\\n\\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\\n2 , 4 = 4 ans we have to ignore the 1 \\n2nd possibility is\\n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\\n1, 5 = 5 ans\\n\\nfinal ans = 5."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "It should be contiguous because you need to form substring."
                    },
                    {
                        "username": "upretim",
                        "content": "\"aaaba aaaba aaba  aaaba aaaba aaaba aaaba\"\\n\"aaaba\"\\n\\nCorrect answer is 5 for this string, why not 6?"
                    },
                    {
                        "username": "SinghalRishabh",
                        "content": " they want a continuous string with max occurrence as output\\n\\nso aaaba as word we have\\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\\n2 , 4 = 4 ans, so 1 should be ignore\\n2nd possibility is\\n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\\n1, 5 = 5 ans\\n\\nfinal ans = 5."
                    },
                    {
                        "username": "aryonbe",
                        "content": "I think that this problem is not definitely easy.\nsequence = \"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\nword = \"aaaba\"\nMany people commented that the answer for the above case is 6. But it is 5 since the repeating words should be consecutive as described in the description. In the case above it looks like the following. \"aaabaaaab aaaba aaaba aaaba aaaba aaaba\"\nWe can see 5 repeating consecutive \"aaaba\".\nThere is no wrong testcase for this problem."
                    },
                    {
                        "username": "pranavarora724",
                        "content": "Yes , got your point\\nWe just not need to check how many \"aaaba\" are there \\nWe need to check how many consecutive \"aaaba\" are there\\nfor example\\nInput = \"aaabaaaaba\"\\nAns=2 (As they are consecutive)\\ninput = \"aaabaKaaaba\"\\nAns=1 (As there they are not consecutive)"
                    },
                    {
                        "username": "gafurulkazi98",
                        "content": "Regarding \"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\nThe question is confusing and the examples are misleading.\\n\\nIt doesn\\'t want the maximum number of times that you can find the word in the sequence, it wants you to find sections in the sequence where the word is repeating itself, get the number of times the word is repeated in that section, and return the highest number of repeats found in any section.\\n\\nAs harsh3150 has shown,\\n\\nso aaaba as word we have\\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\nwhich will be\\n\\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\\n2 , 4 = 4 ans\\n2nd possibility is\\n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\\n1, 5 = 5 ans\\n\\nfinal ans = 5."
                    },
                    {
                        "username": "SoulSlayer",
                        "content": "By this I mean a very similar problem here:\\n[https://www.spoj.com/problems/TKUDDUS/](https://www.spoj.com/problems/TKUDDUS/)\\n\\nI could come up with a bruteforce (q * N * N) approach which gets TLE\\'d. But apparently there is a O(NlogN) approach which I can\\'t seem to come up with. Any leads would be really helpful."
                    },
                    {
                        "username": "Dani28",
                        "content": "I coded in Python 3. Case 166/211 I got is sequence = \"aaabaaaabaaabaaaabaaaabaaaabaaaaba\" and word = \"aaaba.\" It seems to me that I can find 6 repeating \"aaaba\" that are disjoint if partitioning the sequence like this: \"aaaba aaaba aaba aaaba aaaba aaaba aaaba\" - How come the expected answer is 5??"
                    },
                    {
                        "username": "sayedHANEEF",
                        "content": "PEOPLE BE AWARE OF THIS WRONG TESTCASE:\\nsequence = \"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\nword = \"aaaba\"\\n\\nHERE THEY ARE EXPECTING 5 INSTEAD OF THE ACTUAL ANSWER WHICH IS 6."
                    },
                    {
                        "username": "adis176",
                        "content": "so aaaba as word, while our sequence=\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\\nWe should consider each index, where say sequence[i] == word[0]\\nAs it might be the start of our required substring\\nNow 2 main cases possible for given string:\\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\\nOut of all contiguous substrings, lengths we get 2 , 4 = max out of them - 4 ans\\n\\n2nd possibility is\\n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\\n1, 5 = max out of them = 5 ans\\n\\nHence overall max ans = (4, 5) = 5\\n"
                    },
                    {
                        "username": "jadejadej",
                        "content": "so confused."
                    }
                ]
            },
            {
                "id": 1675481,
                "content": [
                    {
                        "username": "user9990f",
                        "content": "One of test case is as follows\\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\"aaaba\"\\nThe judge expects 5. But it looks we have 6 as follows with spaces added.\\n\"aaaba aaaba aaba aaaba aaaba aaaba aaaba\"\\nIs the judge wrong?\\n"
                    },
                    {
                        "username": "ling-lu",
                        "content": "The return value should be concatenated and repeated time, so the result should be 5. \nPlease check this case for more clarification.\n\"aaaba aaab aaaba aaaba aaaba aaaba aaaba\""
                    },
                    {
                        "username": "Raghaav_21",
                        "content": "exactly, answer should be 5. wtf how it can be 6\\n"
                    },
                    {
                        "username": "ma-lacroix",
                        "content": "I had the same thoughts, but take another good look at the string. The correct answer is indeed 5. "
                    },
                    {
                        "username": "uzeconomist0419",
                        "content": "[@sayedHANEEF](/sayedHANEEF)  I have the same problem"
                    },
                    {
                        "username": "harsh3150",
                        "content": "[@sayedHANEEF](/sayedHANEEF) they want a continuous string with max occurrence as output\n\nso aaaba as word we have\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\nwhich will be\n\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\n2 , 4 = 4 ans\n2nd possibility is \n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\n1, 5 = 5 ans \n\nfinal ans = 5. "
                    },
                    {
                        "username": "sayedHANEEF",
                        "content": "I am having the same problem......It should be 6 but they want 5 as a output.\\nDo tell me if u found the reason."
                    },
                    {
                        "username": "jcmf",
                        "content": "I don\\'t understand why everyone says that the answer for aaabaaaabaaabaaaabaaaabaaaabaaaaba should be 6. Shouldn\\'t it be 4? It seems pretty clear from the description that the words need to be consecutive, with nothing in between. It isn\\'t that the sequence needs to contain k separate copies of word, it\\'s that the sequence needs to contain the word concatenated k times -- meaning that the occurrences need to be consecutive, with nothing in between. Am I reading this wrong? Maybe there should be a non-broken example to disambiguate?"
                    },
                    {
                        "username": "ashwani2105",
                        "content": "Try to count it from index 9\\n"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "SAME!!! EXACTLY!!! My output is 4! I don\\'t know why they say 6 either lol "
                    },
                    {
                        "username": "rezl_jaws",
                        "content": "\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\"aaaba\"\\n\\nto me it should be 6 as hightlighted  in bold\\n\\n**aaaba**   **aaaba** aaba **aaaba** **aaaba** **aaaba** **aaaba** \\naaaba\\n\\nWhat do you think guys, mine is failing here as the expected output is apparently 5, would anyone  be able to comment or shed some light as to why  ?"
                    },
                    {
                        "username": "SinghalRishabh",
                        "content": "[@YusenPeng](/YusenPeng) they want a continuous string with max occurrence as output \\n\\nso aaaba as word we have\\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\\n\\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\\n2 , 4 = 4 ans we have to ignore the 1 \\n2nd possibility is\\n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\\n1, 5 = 5 ans\\n\\nfinal ans = 5."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "It should be contiguous because you need to form substring."
                    },
                    {
                        "username": "upretim",
                        "content": "\"aaaba aaaba aaba  aaaba aaaba aaaba aaaba\"\\n\"aaaba\"\\n\\nCorrect answer is 5 for this string, why not 6?"
                    },
                    {
                        "username": "SinghalRishabh",
                        "content": " they want a continuous string with max occurrence as output\\n\\nso aaaba as word we have\\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\\n2 , 4 = 4 ans, so 1 should be ignore\\n2nd possibility is\\n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\\n1, 5 = 5 ans\\n\\nfinal ans = 5."
                    },
                    {
                        "username": "aryonbe",
                        "content": "I think that this problem is not definitely easy.\nsequence = \"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\nword = \"aaaba\"\nMany people commented that the answer for the above case is 6. But it is 5 since the repeating words should be consecutive as described in the description. In the case above it looks like the following. \"aaabaaaab aaaba aaaba aaaba aaaba aaaba\"\nWe can see 5 repeating consecutive \"aaaba\".\nThere is no wrong testcase for this problem."
                    },
                    {
                        "username": "pranavarora724",
                        "content": "Yes , got your point\\nWe just not need to check how many \"aaaba\" are there \\nWe need to check how many consecutive \"aaaba\" are there\\nfor example\\nInput = \"aaabaaaaba\"\\nAns=2 (As they are consecutive)\\ninput = \"aaabaKaaaba\"\\nAns=1 (As there they are not consecutive)"
                    },
                    {
                        "username": "gafurulkazi98",
                        "content": "Regarding \"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\nThe question is confusing and the examples are misleading.\\n\\nIt doesn\\'t want the maximum number of times that you can find the word in the sequence, it wants you to find sections in the sequence where the word is repeating itself, get the number of times the word is repeated in that section, and return the highest number of repeats found in any section.\\n\\nAs harsh3150 has shown,\\n\\nso aaaba as word we have\\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\nwhich will be\\n\\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\\n2 , 4 = 4 ans\\n2nd possibility is\\n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\\n1, 5 = 5 ans\\n\\nfinal ans = 5."
                    },
                    {
                        "username": "SoulSlayer",
                        "content": "By this I mean a very similar problem here:\\n[https://www.spoj.com/problems/TKUDDUS/](https://www.spoj.com/problems/TKUDDUS/)\\n\\nI could come up with a bruteforce (q * N * N) approach which gets TLE\\'d. But apparently there is a O(NlogN) approach which I can\\'t seem to come up with. Any leads would be really helpful."
                    },
                    {
                        "username": "Dani28",
                        "content": "I coded in Python 3. Case 166/211 I got is sequence = \"aaabaaaabaaabaaaabaaaabaaaabaaaaba\" and word = \"aaaba.\" It seems to me that I can find 6 repeating \"aaaba\" that are disjoint if partitioning the sequence like this: \"aaaba aaaba aaba aaaba aaaba aaaba aaaba\" - How come the expected answer is 5??"
                    },
                    {
                        "username": "sayedHANEEF",
                        "content": "PEOPLE BE AWARE OF THIS WRONG TESTCASE:\\nsequence = \"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\nword = \"aaaba\"\\n\\nHERE THEY ARE EXPECTING 5 INSTEAD OF THE ACTUAL ANSWER WHICH IS 6."
                    },
                    {
                        "username": "adis176",
                        "content": "so aaaba as word, while our sequence=\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\\nWe should consider each index, where say sequence[i] == word[0]\\nAs it might be the start of our required substring\\nNow 2 main cases possible for given string:\\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\\nOut of all contiguous substrings, lengths we get 2 , 4 = max out of them - 4 ans\\n\\n2nd possibility is\\n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\\n1, 5 = max out of them = 5 ans\\n\\nHence overall max ans = (4, 5) = 5\\n"
                    },
                    {
                        "username": "jadejadej",
                        "content": "so confused."
                    }
                ]
            },
            {
                "id": 1574806,
                "content": [
                    {
                        "username": "user9990f",
                        "content": "One of test case is as follows\\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\"aaaba\"\\nThe judge expects 5. But it looks we have 6 as follows with spaces added.\\n\"aaaba aaaba aaba aaaba aaaba aaaba aaaba\"\\nIs the judge wrong?\\n"
                    },
                    {
                        "username": "ling-lu",
                        "content": "The return value should be concatenated and repeated time, so the result should be 5. \nPlease check this case for more clarification.\n\"aaaba aaab aaaba aaaba aaaba aaaba aaaba\""
                    },
                    {
                        "username": "Raghaav_21",
                        "content": "exactly, answer should be 5. wtf how it can be 6\\n"
                    },
                    {
                        "username": "ma-lacroix",
                        "content": "I had the same thoughts, but take another good look at the string. The correct answer is indeed 5. "
                    },
                    {
                        "username": "uzeconomist0419",
                        "content": "[@sayedHANEEF](/sayedHANEEF)  I have the same problem"
                    },
                    {
                        "username": "harsh3150",
                        "content": "[@sayedHANEEF](/sayedHANEEF) they want a continuous string with max occurrence as output\n\nso aaaba as word we have\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\nwhich will be\n\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\n2 , 4 = 4 ans\n2nd possibility is \n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\n1, 5 = 5 ans \n\nfinal ans = 5. "
                    },
                    {
                        "username": "sayedHANEEF",
                        "content": "I am having the same problem......It should be 6 but they want 5 as a output.\\nDo tell me if u found the reason."
                    },
                    {
                        "username": "jcmf",
                        "content": "I don\\'t understand why everyone says that the answer for aaabaaaabaaabaaaabaaaabaaaabaaaaba should be 6. Shouldn\\'t it be 4? It seems pretty clear from the description that the words need to be consecutive, with nothing in between. It isn\\'t that the sequence needs to contain k separate copies of word, it\\'s that the sequence needs to contain the word concatenated k times -- meaning that the occurrences need to be consecutive, with nothing in between. Am I reading this wrong? Maybe there should be a non-broken example to disambiguate?"
                    },
                    {
                        "username": "ashwani2105",
                        "content": "Try to count it from index 9\\n"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "SAME!!! EXACTLY!!! My output is 4! I don\\'t know why they say 6 either lol "
                    },
                    {
                        "username": "rezl_jaws",
                        "content": "\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\"aaaba\"\\n\\nto me it should be 6 as hightlighted  in bold\\n\\n**aaaba**   **aaaba** aaba **aaaba** **aaaba** **aaaba** **aaaba** \\naaaba\\n\\nWhat do you think guys, mine is failing here as the expected output is apparently 5, would anyone  be able to comment or shed some light as to why  ?"
                    },
                    {
                        "username": "SinghalRishabh",
                        "content": "[@YusenPeng](/YusenPeng) they want a continuous string with max occurrence as output \\n\\nso aaaba as word we have\\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\\n\\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\\n2 , 4 = 4 ans we have to ignore the 1 \\n2nd possibility is\\n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\\n1, 5 = 5 ans\\n\\nfinal ans = 5."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "It should be contiguous because you need to form substring."
                    },
                    {
                        "username": "upretim",
                        "content": "\"aaaba aaaba aaba  aaaba aaaba aaaba aaaba\"\\n\"aaaba\"\\n\\nCorrect answer is 5 for this string, why not 6?"
                    },
                    {
                        "username": "SinghalRishabh",
                        "content": " they want a continuous string with max occurrence as output\\n\\nso aaaba as word we have\\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\\n2 , 4 = 4 ans, so 1 should be ignore\\n2nd possibility is\\n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\\n1, 5 = 5 ans\\n\\nfinal ans = 5."
                    },
                    {
                        "username": "aryonbe",
                        "content": "I think that this problem is not definitely easy.\nsequence = \"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\nword = \"aaaba\"\nMany people commented that the answer for the above case is 6. But it is 5 since the repeating words should be consecutive as described in the description. In the case above it looks like the following. \"aaabaaaab aaaba aaaba aaaba aaaba aaaba\"\nWe can see 5 repeating consecutive \"aaaba\".\nThere is no wrong testcase for this problem."
                    },
                    {
                        "username": "pranavarora724",
                        "content": "Yes , got your point\\nWe just not need to check how many \"aaaba\" are there \\nWe need to check how many consecutive \"aaaba\" are there\\nfor example\\nInput = \"aaabaaaaba\"\\nAns=2 (As they are consecutive)\\ninput = \"aaabaKaaaba\"\\nAns=1 (As there they are not consecutive)"
                    },
                    {
                        "username": "gafurulkazi98",
                        "content": "Regarding \"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\nThe question is confusing and the examples are misleading.\\n\\nIt doesn\\'t want the maximum number of times that you can find the word in the sequence, it wants you to find sections in the sequence where the word is repeating itself, get the number of times the word is repeated in that section, and return the highest number of repeats found in any section.\\n\\nAs harsh3150 has shown,\\n\\nso aaaba as word we have\\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\nwhich will be\\n\\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\\n2 , 4 = 4 ans\\n2nd possibility is\\n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\\n1, 5 = 5 ans\\n\\nfinal ans = 5."
                    },
                    {
                        "username": "SoulSlayer",
                        "content": "By this I mean a very similar problem here:\\n[https://www.spoj.com/problems/TKUDDUS/](https://www.spoj.com/problems/TKUDDUS/)\\n\\nI could come up with a bruteforce (q * N * N) approach which gets TLE\\'d. But apparently there is a O(NlogN) approach which I can\\'t seem to come up with. Any leads would be really helpful."
                    },
                    {
                        "username": "Dani28",
                        "content": "I coded in Python 3. Case 166/211 I got is sequence = \"aaabaaaabaaabaaaabaaaabaaaabaaaaba\" and word = \"aaaba.\" It seems to me that I can find 6 repeating \"aaaba\" that are disjoint if partitioning the sequence like this: \"aaaba aaaba aaba aaaba aaaba aaaba aaaba\" - How come the expected answer is 5??"
                    },
                    {
                        "username": "sayedHANEEF",
                        "content": "PEOPLE BE AWARE OF THIS WRONG TESTCASE:\\nsequence = \"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\nword = \"aaaba\"\\n\\nHERE THEY ARE EXPECTING 5 INSTEAD OF THE ACTUAL ANSWER WHICH IS 6."
                    },
                    {
                        "username": "adis176",
                        "content": "so aaaba as word, while our sequence=\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\\nWe should consider each index, where say sequence[i] == word[0]\\nAs it might be the start of our required substring\\nNow 2 main cases possible for given string:\\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\\nOut of all contiguous substrings, lengths we get 2 , 4 = max out of them - 4 ans\\n\\n2nd possibility is\\n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\\n1, 5 = max out of them = 5 ans\\n\\nHence overall max ans = (4, 5) = 5\\n"
                    },
                    {
                        "username": "jadejadej",
                        "content": "so confused."
                    }
                ]
            },
            {
                "id": 1574918,
                "content": [
                    {
                        "username": "user9990f",
                        "content": "One of test case is as follows\\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\"aaaba\"\\nThe judge expects 5. But it looks we have 6 as follows with spaces added.\\n\"aaaba aaaba aaba aaaba aaaba aaaba aaaba\"\\nIs the judge wrong?\\n"
                    },
                    {
                        "username": "ling-lu",
                        "content": "The return value should be concatenated and repeated time, so the result should be 5. \nPlease check this case for more clarification.\n\"aaaba aaab aaaba aaaba aaaba aaaba aaaba\""
                    },
                    {
                        "username": "Raghaav_21",
                        "content": "exactly, answer should be 5. wtf how it can be 6\\n"
                    },
                    {
                        "username": "ma-lacroix",
                        "content": "I had the same thoughts, but take another good look at the string. The correct answer is indeed 5. "
                    },
                    {
                        "username": "uzeconomist0419",
                        "content": "[@sayedHANEEF](/sayedHANEEF)  I have the same problem"
                    },
                    {
                        "username": "harsh3150",
                        "content": "[@sayedHANEEF](/sayedHANEEF) they want a continuous string with max occurrence as output\n\nso aaaba as word we have\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\nwhich will be\n\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\n2 , 4 = 4 ans\n2nd possibility is \n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\n1, 5 = 5 ans \n\nfinal ans = 5. "
                    },
                    {
                        "username": "sayedHANEEF",
                        "content": "I am having the same problem......It should be 6 but they want 5 as a output.\\nDo tell me if u found the reason."
                    },
                    {
                        "username": "jcmf",
                        "content": "I don\\'t understand why everyone says that the answer for aaabaaaabaaabaaaabaaaabaaaabaaaaba should be 6. Shouldn\\'t it be 4? It seems pretty clear from the description that the words need to be consecutive, with nothing in between. It isn\\'t that the sequence needs to contain k separate copies of word, it\\'s that the sequence needs to contain the word concatenated k times -- meaning that the occurrences need to be consecutive, with nothing in between. Am I reading this wrong? Maybe there should be a non-broken example to disambiguate?"
                    },
                    {
                        "username": "ashwani2105",
                        "content": "Try to count it from index 9\\n"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "SAME!!! EXACTLY!!! My output is 4! I don\\'t know why they say 6 either lol "
                    },
                    {
                        "username": "rezl_jaws",
                        "content": "\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\"aaaba\"\\n\\nto me it should be 6 as hightlighted  in bold\\n\\n**aaaba**   **aaaba** aaba **aaaba** **aaaba** **aaaba** **aaaba** \\naaaba\\n\\nWhat do you think guys, mine is failing here as the expected output is apparently 5, would anyone  be able to comment or shed some light as to why  ?"
                    },
                    {
                        "username": "SinghalRishabh",
                        "content": "[@YusenPeng](/YusenPeng) they want a continuous string with max occurrence as output \\n\\nso aaaba as word we have\\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\\n\\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\\n2 , 4 = 4 ans we have to ignore the 1 \\n2nd possibility is\\n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\\n1, 5 = 5 ans\\n\\nfinal ans = 5."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "It should be contiguous because you need to form substring."
                    },
                    {
                        "username": "upretim",
                        "content": "\"aaaba aaaba aaba  aaaba aaaba aaaba aaaba\"\\n\"aaaba\"\\n\\nCorrect answer is 5 for this string, why not 6?"
                    },
                    {
                        "username": "SinghalRishabh",
                        "content": " they want a continuous string with max occurrence as output\\n\\nso aaaba as word we have\\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\\n2 , 4 = 4 ans, so 1 should be ignore\\n2nd possibility is\\n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\\n1, 5 = 5 ans\\n\\nfinal ans = 5."
                    },
                    {
                        "username": "aryonbe",
                        "content": "I think that this problem is not definitely easy.\nsequence = \"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\nword = \"aaaba\"\nMany people commented that the answer for the above case is 6. But it is 5 since the repeating words should be consecutive as described in the description. In the case above it looks like the following. \"aaabaaaab aaaba aaaba aaaba aaaba aaaba\"\nWe can see 5 repeating consecutive \"aaaba\".\nThere is no wrong testcase for this problem."
                    },
                    {
                        "username": "pranavarora724",
                        "content": "Yes , got your point\\nWe just not need to check how many \"aaaba\" are there \\nWe need to check how many consecutive \"aaaba\" are there\\nfor example\\nInput = \"aaabaaaaba\"\\nAns=2 (As they are consecutive)\\ninput = \"aaabaKaaaba\"\\nAns=1 (As there they are not consecutive)"
                    },
                    {
                        "username": "gafurulkazi98",
                        "content": "Regarding \"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\nThe question is confusing and the examples are misleading.\\n\\nIt doesn\\'t want the maximum number of times that you can find the word in the sequence, it wants you to find sections in the sequence where the word is repeating itself, get the number of times the word is repeated in that section, and return the highest number of repeats found in any section.\\n\\nAs harsh3150 has shown,\\n\\nso aaaba as word we have\\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\nwhich will be\\n\\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\\n2 , 4 = 4 ans\\n2nd possibility is\\n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\\n1, 5 = 5 ans\\n\\nfinal ans = 5."
                    },
                    {
                        "username": "SoulSlayer",
                        "content": "By this I mean a very similar problem here:\\n[https://www.spoj.com/problems/TKUDDUS/](https://www.spoj.com/problems/TKUDDUS/)\\n\\nI could come up with a bruteforce (q * N * N) approach which gets TLE\\'d. But apparently there is a O(NlogN) approach which I can\\'t seem to come up with. Any leads would be really helpful."
                    },
                    {
                        "username": "Dani28",
                        "content": "I coded in Python 3. Case 166/211 I got is sequence = \"aaabaaaabaaabaaaabaaaabaaaabaaaaba\" and word = \"aaaba.\" It seems to me that I can find 6 repeating \"aaaba\" that are disjoint if partitioning the sequence like this: \"aaaba aaaba aaba aaaba aaaba aaaba aaaba\" - How come the expected answer is 5??"
                    },
                    {
                        "username": "sayedHANEEF",
                        "content": "PEOPLE BE AWARE OF THIS WRONG TESTCASE:\\nsequence = \"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\nword = \"aaaba\"\\n\\nHERE THEY ARE EXPECTING 5 INSTEAD OF THE ACTUAL ANSWER WHICH IS 6."
                    },
                    {
                        "username": "adis176",
                        "content": "so aaaba as word, while our sequence=\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\\nWe should consider each index, where say sequence[i] == word[0]\\nAs it might be the start of our required substring\\nNow 2 main cases possible for given string:\\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\\nOut of all contiguous substrings, lengths we get 2 , 4 = max out of them - 4 ans\\n\\n2nd possibility is\\n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\\n1, 5 = max out of them = 5 ans\\n\\nHence overall max ans = (4, 5) = 5\\n"
                    },
                    {
                        "username": "jadejadej",
                        "content": "so confused."
                    }
                ]
            },
            {
                "id": 1716042,
                "content": [
                    {
                        "username": "user9990f",
                        "content": "One of test case is as follows\\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\"aaaba\"\\nThe judge expects 5. But it looks we have 6 as follows with spaces added.\\n\"aaaba aaaba aaba aaaba aaaba aaaba aaaba\"\\nIs the judge wrong?\\n"
                    },
                    {
                        "username": "ling-lu",
                        "content": "The return value should be concatenated and repeated time, so the result should be 5. \nPlease check this case for more clarification.\n\"aaaba aaab aaaba aaaba aaaba aaaba aaaba\""
                    },
                    {
                        "username": "Raghaav_21",
                        "content": "exactly, answer should be 5. wtf how it can be 6\\n"
                    },
                    {
                        "username": "ma-lacroix",
                        "content": "I had the same thoughts, but take another good look at the string. The correct answer is indeed 5. "
                    },
                    {
                        "username": "uzeconomist0419",
                        "content": "[@sayedHANEEF](/sayedHANEEF)  I have the same problem"
                    },
                    {
                        "username": "harsh3150",
                        "content": "[@sayedHANEEF](/sayedHANEEF) they want a continuous string with max occurrence as output\n\nso aaaba as word we have\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\nwhich will be\n\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\n2 , 4 = 4 ans\n2nd possibility is \n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\n1, 5 = 5 ans \n\nfinal ans = 5. "
                    },
                    {
                        "username": "sayedHANEEF",
                        "content": "I am having the same problem......It should be 6 but they want 5 as a output.\\nDo tell me if u found the reason."
                    },
                    {
                        "username": "jcmf",
                        "content": "I don\\'t understand why everyone says that the answer for aaabaaaabaaabaaaabaaaabaaaabaaaaba should be 6. Shouldn\\'t it be 4? It seems pretty clear from the description that the words need to be consecutive, with nothing in between. It isn\\'t that the sequence needs to contain k separate copies of word, it\\'s that the sequence needs to contain the word concatenated k times -- meaning that the occurrences need to be consecutive, with nothing in between. Am I reading this wrong? Maybe there should be a non-broken example to disambiguate?"
                    },
                    {
                        "username": "ashwani2105",
                        "content": "Try to count it from index 9\\n"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "SAME!!! EXACTLY!!! My output is 4! I don\\'t know why they say 6 either lol "
                    },
                    {
                        "username": "rezl_jaws",
                        "content": "\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\"aaaba\"\\n\\nto me it should be 6 as hightlighted  in bold\\n\\n**aaaba**   **aaaba** aaba **aaaba** **aaaba** **aaaba** **aaaba** \\naaaba\\n\\nWhat do you think guys, mine is failing here as the expected output is apparently 5, would anyone  be able to comment or shed some light as to why  ?"
                    },
                    {
                        "username": "SinghalRishabh",
                        "content": "[@YusenPeng](/YusenPeng) they want a continuous string with max occurrence as output \\n\\nso aaaba as word we have\\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\\n\\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\\n2 , 4 = 4 ans we have to ignore the 1 \\n2nd possibility is\\n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\\n1, 5 = 5 ans\\n\\nfinal ans = 5."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "It should be contiguous because you need to form substring."
                    },
                    {
                        "username": "upretim",
                        "content": "\"aaaba aaaba aaba  aaaba aaaba aaaba aaaba\"\\n\"aaaba\"\\n\\nCorrect answer is 5 for this string, why not 6?"
                    },
                    {
                        "username": "SinghalRishabh",
                        "content": " they want a continuous string with max occurrence as output\\n\\nso aaaba as word we have\\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\\n2 , 4 = 4 ans, so 1 should be ignore\\n2nd possibility is\\n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\\n1, 5 = 5 ans\\n\\nfinal ans = 5."
                    },
                    {
                        "username": "aryonbe",
                        "content": "I think that this problem is not definitely easy.\nsequence = \"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\nword = \"aaaba\"\nMany people commented that the answer for the above case is 6. But it is 5 since the repeating words should be consecutive as described in the description. In the case above it looks like the following. \"aaabaaaab aaaba aaaba aaaba aaaba aaaba\"\nWe can see 5 repeating consecutive \"aaaba\".\nThere is no wrong testcase for this problem."
                    },
                    {
                        "username": "pranavarora724",
                        "content": "Yes , got your point\\nWe just not need to check how many \"aaaba\" are there \\nWe need to check how many consecutive \"aaaba\" are there\\nfor example\\nInput = \"aaabaaaaba\"\\nAns=2 (As they are consecutive)\\ninput = \"aaabaKaaaba\"\\nAns=1 (As there they are not consecutive)"
                    },
                    {
                        "username": "gafurulkazi98",
                        "content": "Regarding \"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\nThe question is confusing and the examples are misleading.\\n\\nIt doesn\\'t want the maximum number of times that you can find the word in the sequence, it wants you to find sections in the sequence where the word is repeating itself, get the number of times the word is repeated in that section, and return the highest number of repeats found in any section.\\n\\nAs harsh3150 has shown,\\n\\nso aaaba as word we have\\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\nwhich will be\\n\\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\\n2 , 4 = 4 ans\\n2nd possibility is\\n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\\n1, 5 = 5 ans\\n\\nfinal ans = 5."
                    },
                    {
                        "username": "SoulSlayer",
                        "content": "By this I mean a very similar problem here:\\n[https://www.spoj.com/problems/TKUDDUS/](https://www.spoj.com/problems/TKUDDUS/)\\n\\nI could come up with a bruteforce (q * N * N) approach which gets TLE\\'d. But apparently there is a O(NlogN) approach which I can\\'t seem to come up with. Any leads would be really helpful."
                    },
                    {
                        "username": "Dani28",
                        "content": "I coded in Python 3. Case 166/211 I got is sequence = \"aaabaaaabaaabaaaabaaaabaaaabaaaaba\" and word = \"aaaba.\" It seems to me that I can find 6 repeating \"aaaba\" that are disjoint if partitioning the sequence like this: \"aaaba aaaba aaba aaaba aaaba aaaba aaaba\" - How come the expected answer is 5??"
                    },
                    {
                        "username": "sayedHANEEF",
                        "content": "PEOPLE BE AWARE OF THIS WRONG TESTCASE:\\nsequence = \"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\nword = \"aaaba\"\\n\\nHERE THEY ARE EXPECTING 5 INSTEAD OF THE ACTUAL ANSWER WHICH IS 6."
                    },
                    {
                        "username": "adis176",
                        "content": "so aaaba as word, while our sequence=\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\\nWe should consider each index, where say sequence[i] == word[0]\\nAs it might be the start of our required substring\\nNow 2 main cases possible for given string:\\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\\nOut of all contiguous substrings, lengths we get 2 , 4 = max out of them - 4 ans\\n\\n2nd possibility is\\n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\\n1, 5 = max out of them = 5 ans\\n\\nHence overall max ans = (4, 5) = 5\\n"
                    },
                    {
                        "username": "jadejadej",
                        "content": "so confused."
                    }
                ]
            },
            {
                "id": 1929283,
                "content": [
                    {
                        "username": "user9990f",
                        "content": "One of test case is as follows\\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\"aaaba\"\\nThe judge expects 5. But it looks we have 6 as follows with spaces added.\\n\"aaaba aaaba aaba aaaba aaaba aaaba aaaba\"\\nIs the judge wrong?\\n"
                    },
                    {
                        "username": "ling-lu",
                        "content": "The return value should be concatenated and repeated time, so the result should be 5. \nPlease check this case for more clarification.\n\"aaaba aaab aaaba aaaba aaaba aaaba aaaba\""
                    },
                    {
                        "username": "Raghaav_21",
                        "content": "exactly, answer should be 5. wtf how it can be 6\\n"
                    },
                    {
                        "username": "ma-lacroix",
                        "content": "I had the same thoughts, but take another good look at the string. The correct answer is indeed 5. "
                    },
                    {
                        "username": "uzeconomist0419",
                        "content": "[@sayedHANEEF](/sayedHANEEF)  I have the same problem"
                    },
                    {
                        "username": "harsh3150",
                        "content": "[@sayedHANEEF](/sayedHANEEF) they want a continuous string with max occurrence as output\n\nso aaaba as word we have\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\nwhich will be\n\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\n2 , 4 = 4 ans\n2nd possibility is \n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\n1, 5 = 5 ans \n\nfinal ans = 5. "
                    },
                    {
                        "username": "sayedHANEEF",
                        "content": "I am having the same problem......It should be 6 but they want 5 as a output.\\nDo tell me if u found the reason."
                    },
                    {
                        "username": "jcmf",
                        "content": "I don\\'t understand why everyone says that the answer for aaabaaaabaaabaaaabaaaabaaaabaaaaba should be 6. Shouldn\\'t it be 4? It seems pretty clear from the description that the words need to be consecutive, with nothing in between. It isn\\'t that the sequence needs to contain k separate copies of word, it\\'s that the sequence needs to contain the word concatenated k times -- meaning that the occurrences need to be consecutive, with nothing in between. Am I reading this wrong? Maybe there should be a non-broken example to disambiguate?"
                    },
                    {
                        "username": "ashwani2105",
                        "content": "Try to count it from index 9\\n"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "SAME!!! EXACTLY!!! My output is 4! I don\\'t know why they say 6 either lol "
                    },
                    {
                        "username": "rezl_jaws",
                        "content": "\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\"aaaba\"\\n\\nto me it should be 6 as hightlighted  in bold\\n\\n**aaaba**   **aaaba** aaba **aaaba** **aaaba** **aaaba** **aaaba** \\naaaba\\n\\nWhat do you think guys, mine is failing here as the expected output is apparently 5, would anyone  be able to comment or shed some light as to why  ?"
                    },
                    {
                        "username": "SinghalRishabh",
                        "content": "[@YusenPeng](/YusenPeng) they want a continuous string with max occurrence as output \\n\\nso aaaba as word we have\\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\\n\\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\\n2 , 4 = 4 ans we have to ignore the 1 \\n2nd possibility is\\n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\\n1, 5 = 5 ans\\n\\nfinal ans = 5."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "It should be contiguous because you need to form substring."
                    },
                    {
                        "username": "upretim",
                        "content": "\"aaaba aaaba aaba  aaaba aaaba aaaba aaaba\"\\n\"aaaba\"\\n\\nCorrect answer is 5 for this string, why not 6?"
                    },
                    {
                        "username": "SinghalRishabh",
                        "content": " they want a continuous string with max occurrence as output\\n\\nso aaaba as word we have\\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\\n2 , 4 = 4 ans, so 1 should be ignore\\n2nd possibility is\\n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\\n1, 5 = 5 ans\\n\\nfinal ans = 5."
                    },
                    {
                        "username": "aryonbe",
                        "content": "I think that this problem is not definitely easy.\nsequence = \"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\nword = \"aaaba\"\nMany people commented that the answer for the above case is 6. But it is 5 since the repeating words should be consecutive as described in the description. In the case above it looks like the following. \"aaabaaaab aaaba aaaba aaaba aaaba aaaba\"\nWe can see 5 repeating consecutive \"aaaba\".\nThere is no wrong testcase for this problem."
                    },
                    {
                        "username": "pranavarora724",
                        "content": "Yes , got your point\\nWe just not need to check how many \"aaaba\" are there \\nWe need to check how many consecutive \"aaaba\" are there\\nfor example\\nInput = \"aaabaaaaba\"\\nAns=2 (As they are consecutive)\\ninput = \"aaabaKaaaba\"\\nAns=1 (As there they are not consecutive)"
                    },
                    {
                        "username": "gafurulkazi98",
                        "content": "Regarding \"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\nThe question is confusing and the examples are misleading.\\n\\nIt doesn\\'t want the maximum number of times that you can find the word in the sequence, it wants you to find sections in the sequence where the word is repeating itself, get the number of times the word is repeated in that section, and return the highest number of repeats found in any section.\\n\\nAs harsh3150 has shown,\\n\\nso aaaba as word we have\\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\nwhich will be\\n\\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\\n2 , 4 = 4 ans\\n2nd possibility is\\n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\\n1, 5 = 5 ans\\n\\nfinal ans = 5."
                    },
                    {
                        "username": "SoulSlayer",
                        "content": "By this I mean a very similar problem here:\\n[https://www.spoj.com/problems/TKUDDUS/](https://www.spoj.com/problems/TKUDDUS/)\\n\\nI could come up with a bruteforce (q * N * N) approach which gets TLE\\'d. But apparently there is a O(NlogN) approach which I can\\'t seem to come up with. Any leads would be really helpful."
                    },
                    {
                        "username": "Dani28",
                        "content": "I coded in Python 3. Case 166/211 I got is sequence = \"aaabaaaabaaabaaaabaaaabaaaabaaaaba\" and word = \"aaaba.\" It seems to me that I can find 6 repeating \"aaaba\" that are disjoint if partitioning the sequence like this: \"aaaba aaaba aaba aaaba aaaba aaaba aaaba\" - How come the expected answer is 5??"
                    },
                    {
                        "username": "sayedHANEEF",
                        "content": "PEOPLE BE AWARE OF THIS WRONG TESTCASE:\\nsequence = \"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\nword = \"aaaba\"\\n\\nHERE THEY ARE EXPECTING 5 INSTEAD OF THE ACTUAL ANSWER WHICH IS 6."
                    },
                    {
                        "username": "adis176",
                        "content": "so aaaba as word, while our sequence=\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\\nWe should consider each index, where say sequence[i] == word[0]\\nAs it might be the start of our required substring\\nNow 2 main cases possible for given string:\\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\\nOut of all contiguous substrings, lengths we get 2 , 4 = max out of them - 4 ans\\n\\n2nd possibility is\\n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\\n1, 5 = max out of them = 5 ans\\n\\nHence overall max ans = (4, 5) = 5\\n"
                    },
                    {
                        "username": "jadejadej",
                        "content": "so confused."
                    }
                ]
            },
            {
                "id": 1575371,
                "content": [
                    {
                        "username": "user9990f",
                        "content": "One of test case is as follows\\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\"aaaba\"\\nThe judge expects 5. But it looks we have 6 as follows with spaces added.\\n\"aaaba aaaba aaba aaaba aaaba aaaba aaaba\"\\nIs the judge wrong?\\n"
                    },
                    {
                        "username": "ling-lu",
                        "content": "The return value should be concatenated and repeated time, so the result should be 5. \nPlease check this case for more clarification.\n\"aaaba aaab aaaba aaaba aaaba aaaba aaaba\""
                    },
                    {
                        "username": "Raghaav_21",
                        "content": "exactly, answer should be 5. wtf how it can be 6\\n"
                    },
                    {
                        "username": "ma-lacroix",
                        "content": "I had the same thoughts, but take another good look at the string. The correct answer is indeed 5. "
                    },
                    {
                        "username": "uzeconomist0419",
                        "content": "[@sayedHANEEF](/sayedHANEEF)  I have the same problem"
                    },
                    {
                        "username": "harsh3150",
                        "content": "[@sayedHANEEF](/sayedHANEEF) they want a continuous string with max occurrence as output\n\nso aaaba as word we have\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\nwhich will be\n\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\n2 , 4 = 4 ans\n2nd possibility is \n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\n1, 5 = 5 ans \n\nfinal ans = 5. "
                    },
                    {
                        "username": "sayedHANEEF",
                        "content": "I am having the same problem......It should be 6 but they want 5 as a output.\\nDo tell me if u found the reason."
                    },
                    {
                        "username": "jcmf",
                        "content": "I don\\'t understand why everyone says that the answer for aaabaaaabaaabaaaabaaaabaaaabaaaaba should be 6. Shouldn\\'t it be 4? It seems pretty clear from the description that the words need to be consecutive, with nothing in between. It isn\\'t that the sequence needs to contain k separate copies of word, it\\'s that the sequence needs to contain the word concatenated k times -- meaning that the occurrences need to be consecutive, with nothing in between. Am I reading this wrong? Maybe there should be a non-broken example to disambiguate?"
                    },
                    {
                        "username": "ashwani2105",
                        "content": "Try to count it from index 9\\n"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "SAME!!! EXACTLY!!! My output is 4! I don\\'t know why they say 6 either lol "
                    },
                    {
                        "username": "rezl_jaws",
                        "content": "\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\"aaaba\"\\n\\nto me it should be 6 as hightlighted  in bold\\n\\n**aaaba**   **aaaba** aaba **aaaba** **aaaba** **aaaba** **aaaba** \\naaaba\\n\\nWhat do you think guys, mine is failing here as the expected output is apparently 5, would anyone  be able to comment or shed some light as to why  ?"
                    },
                    {
                        "username": "SinghalRishabh",
                        "content": "[@YusenPeng](/YusenPeng) they want a continuous string with max occurrence as output \\n\\nso aaaba as word we have\\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\\n\\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\\n2 , 4 = 4 ans we have to ignore the 1 \\n2nd possibility is\\n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\\n1, 5 = 5 ans\\n\\nfinal ans = 5."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "It should be contiguous because you need to form substring."
                    },
                    {
                        "username": "upretim",
                        "content": "\"aaaba aaaba aaba  aaaba aaaba aaaba aaaba\"\\n\"aaaba\"\\n\\nCorrect answer is 5 for this string, why not 6?"
                    },
                    {
                        "username": "SinghalRishabh",
                        "content": " they want a continuous string with max occurrence as output\\n\\nso aaaba as word we have\\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\\n2 , 4 = 4 ans, so 1 should be ignore\\n2nd possibility is\\n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\\n1, 5 = 5 ans\\n\\nfinal ans = 5."
                    },
                    {
                        "username": "aryonbe",
                        "content": "I think that this problem is not definitely easy.\nsequence = \"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\nword = \"aaaba\"\nMany people commented that the answer for the above case is 6. But it is 5 since the repeating words should be consecutive as described in the description. In the case above it looks like the following. \"aaabaaaab aaaba aaaba aaaba aaaba aaaba\"\nWe can see 5 repeating consecutive \"aaaba\".\nThere is no wrong testcase for this problem."
                    },
                    {
                        "username": "pranavarora724",
                        "content": "Yes , got your point\\nWe just not need to check how many \"aaaba\" are there \\nWe need to check how many consecutive \"aaaba\" are there\\nfor example\\nInput = \"aaabaaaaba\"\\nAns=2 (As they are consecutive)\\ninput = \"aaabaKaaaba\"\\nAns=1 (As there they are not consecutive)"
                    },
                    {
                        "username": "gafurulkazi98",
                        "content": "Regarding \"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\nThe question is confusing and the examples are misleading.\\n\\nIt doesn\\'t want the maximum number of times that you can find the word in the sequence, it wants you to find sections in the sequence where the word is repeating itself, get the number of times the word is repeated in that section, and return the highest number of repeats found in any section.\\n\\nAs harsh3150 has shown,\\n\\nso aaaba as word we have\\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\nwhich will be\\n\\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\\n2 , 4 = 4 ans\\n2nd possibility is\\n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\\n1, 5 = 5 ans\\n\\nfinal ans = 5."
                    },
                    {
                        "username": "SoulSlayer",
                        "content": "By this I mean a very similar problem here:\\n[https://www.spoj.com/problems/TKUDDUS/](https://www.spoj.com/problems/TKUDDUS/)\\n\\nI could come up with a bruteforce (q * N * N) approach which gets TLE\\'d. But apparently there is a O(NlogN) approach which I can\\'t seem to come up with. Any leads would be really helpful."
                    },
                    {
                        "username": "Dani28",
                        "content": "I coded in Python 3. Case 166/211 I got is sequence = \"aaabaaaabaaabaaaabaaaabaaaabaaaaba\" and word = \"aaaba.\" It seems to me that I can find 6 repeating \"aaaba\" that are disjoint if partitioning the sequence like this: \"aaaba aaaba aaba aaaba aaaba aaaba aaaba\" - How come the expected answer is 5??"
                    },
                    {
                        "username": "sayedHANEEF",
                        "content": "PEOPLE BE AWARE OF THIS WRONG TESTCASE:\\nsequence = \"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\nword = \"aaaba\"\\n\\nHERE THEY ARE EXPECTING 5 INSTEAD OF THE ACTUAL ANSWER WHICH IS 6."
                    },
                    {
                        "username": "adis176",
                        "content": "so aaaba as word, while our sequence=\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\\nWe should consider each index, where say sequence[i] == word[0]\\nAs it might be the start of our required substring\\nNow 2 main cases possible for given string:\\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\\nOut of all contiguous substrings, lengths we get 2 , 4 = max out of them - 4 ans\\n\\n2nd possibility is\\n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\\n1, 5 = max out of them = 5 ans\\n\\nHence overall max ans = (4, 5) = 5\\n"
                    },
                    {
                        "username": "jadejadej",
                        "content": "so confused."
                    }
                ]
            },
            {
                "id": 1575014,
                "content": [
                    {
                        "username": "user9990f",
                        "content": "One of test case is as follows\\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\"aaaba\"\\nThe judge expects 5. But it looks we have 6 as follows with spaces added.\\n\"aaaba aaaba aaba aaaba aaaba aaaba aaaba\"\\nIs the judge wrong?\\n"
                    },
                    {
                        "username": "ling-lu",
                        "content": "The return value should be concatenated and repeated time, so the result should be 5. \nPlease check this case for more clarification.\n\"aaaba aaab aaaba aaaba aaaba aaaba aaaba\""
                    },
                    {
                        "username": "Raghaav_21",
                        "content": "exactly, answer should be 5. wtf how it can be 6\\n"
                    },
                    {
                        "username": "ma-lacroix",
                        "content": "I had the same thoughts, but take another good look at the string. The correct answer is indeed 5. "
                    },
                    {
                        "username": "uzeconomist0419",
                        "content": "[@sayedHANEEF](/sayedHANEEF)  I have the same problem"
                    },
                    {
                        "username": "harsh3150",
                        "content": "[@sayedHANEEF](/sayedHANEEF) they want a continuous string with max occurrence as output\n\nso aaaba as word we have\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\nwhich will be\n\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\n2 , 4 = 4 ans\n2nd possibility is \n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\n1, 5 = 5 ans \n\nfinal ans = 5. "
                    },
                    {
                        "username": "sayedHANEEF",
                        "content": "I am having the same problem......It should be 6 but they want 5 as a output.\\nDo tell me if u found the reason."
                    },
                    {
                        "username": "jcmf",
                        "content": "I don\\'t understand why everyone says that the answer for aaabaaaabaaabaaaabaaaabaaaabaaaaba should be 6. Shouldn\\'t it be 4? It seems pretty clear from the description that the words need to be consecutive, with nothing in between. It isn\\'t that the sequence needs to contain k separate copies of word, it\\'s that the sequence needs to contain the word concatenated k times -- meaning that the occurrences need to be consecutive, with nothing in between. Am I reading this wrong? Maybe there should be a non-broken example to disambiguate?"
                    },
                    {
                        "username": "ashwani2105",
                        "content": "Try to count it from index 9\\n"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "SAME!!! EXACTLY!!! My output is 4! I don\\'t know why they say 6 either lol "
                    },
                    {
                        "username": "rezl_jaws",
                        "content": "\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\"aaaba\"\\n\\nto me it should be 6 as hightlighted  in bold\\n\\n**aaaba**   **aaaba** aaba **aaaba** **aaaba** **aaaba** **aaaba** \\naaaba\\n\\nWhat do you think guys, mine is failing here as the expected output is apparently 5, would anyone  be able to comment or shed some light as to why  ?"
                    },
                    {
                        "username": "SinghalRishabh",
                        "content": "[@YusenPeng](/YusenPeng) they want a continuous string with max occurrence as output \\n\\nso aaaba as word we have\\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\\n\\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\\n2 , 4 = 4 ans we have to ignore the 1 \\n2nd possibility is\\n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\\n1, 5 = 5 ans\\n\\nfinal ans = 5."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "It should be contiguous because you need to form substring."
                    },
                    {
                        "username": "upretim",
                        "content": "\"aaaba aaaba aaba  aaaba aaaba aaaba aaaba\"\\n\"aaaba\"\\n\\nCorrect answer is 5 for this string, why not 6?"
                    },
                    {
                        "username": "SinghalRishabh",
                        "content": " they want a continuous string with max occurrence as output\\n\\nso aaaba as word we have\\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\\n2 , 4 = 4 ans, so 1 should be ignore\\n2nd possibility is\\n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\\n1, 5 = 5 ans\\n\\nfinal ans = 5."
                    },
                    {
                        "username": "aryonbe",
                        "content": "I think that this problem is not definitely easy.\nsequence = \"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\nword = \"aaaba\"\nMany people commented that the answer for the above case is 6. But it is 5 since the repeating words should be consecutive as described in the description. In the case above it looks like the following. \"aaabaaaab aaaba aaaba aaaba aaaba aaaba\"\nWe can see 5 repeating consecutive \"aaaba\".\nThere is no wrong testcase for this problem."
                    },
                    {
                        "username": "pranavarora724",
                        "content": "Yes , got your point\\nWe just not need to check how many \"aaaba\" are there \\nWe need to check how many consecutive \"aaaba\" are there\\nfor example\\nInput = \"aaabaaaaba\"\\nAns=2 (As they are consecutive)\\ninput = \"aaabaKaaaba\"\\nAns=1 (As there they are not consecutive)"
                    },
                    {
                        "username": "gafurulkazi98",
                        "content": "Regarding \"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\nThe question is confusing and the examples are misleading.\\n\\nIt doesn\\'t want the maximum number of times that you can find the word in the sequence, it wants you to find sections in the sequence where the word is repeating itself, get the number of times the word is repeated in that section, and return the highest number of repeats found in any section.\\n\\nAs harsh3150 has shown,\\n\\nso aaaba as word we have\\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\nwhich will be\\n\\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\\n2 , 4 = 4 ans\\n2nd possibility is\\n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\\n1, 5 = 5 ans\\n\\nfinal ans = 5."
                    },
                    {
                        "username": "SoulSlayer",
                        "content": "By this I mean a very similar problem here:\\n[https://www.spoj.com/problems/TKUDDUS/](https://www.spoj.com/problems/TKUDDUS/)\\n\\nI could come up with a bruteforce (q * N * N) approach which gets TLE\\'d. But apparently there is a O(NlogN) approach which I can\\'t seem to come up with. Any leads would be really helpful."
                    },
                    {
                        "username": "Dani28",
                        "content": "I coded in Python 3. Case 166/211 I got is sequence = \"aaabaaaabaaabaaaabaaaabaaaabaaaaba\" and word = \"aaaba.\" It seems to me that I can find 6 repeating \"aaaba\" that are disjoint if partitioning the sequence like this: \"aaaba aaaba aaba aaaba aaaba aaaba aaaba\" - How come the expected answer is 5??"
                    },
                    {
                        "username": "sayedHANEEF",
                        "content": "PEOPLE BE AWARE OF THIS WRONG TESTCASE:\\nsequence = \"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\nword = \"aaaba\"\\n\\nHERE THEY ARE EXPECTING 5 INSTEAD OF THE ACTUAL ANSWER WHICH IS 6."
                    },
                    {
                        "username": "adis176",
                        "content": "so aaaba as word, while our sequence=\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\\nWe should consider each index, where say sequence[i] == word[0]\\nAs it might be the start of our required substring\\nNow 2 main cases possible for given string:\\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\\nOut of all contiguous substrings, lengths we get 2 , 4 = max out of them - 4 ans\\n\\n2nd possibility is\\n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\\n1, 5 = max out of them = 5 ans\\n\\nHence overall max ans = (4, 5) = 5\\n"
                    },
                    {
                        "username": "jadejadej",
                        "content": "so confused."
                    }
                ]
            },
            {
                "id": 1640890,
                "content": [
                    {
                        "username": "user9990f",
                        "content": "One of test case is as follows\\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\"aaaba\"\\nThe judge expects 5. But it looks we have 6 as follows with spaces added.\\n\"aaaba aaaba aaba aaaba aaaba aaaba aaaba\"\\nIs the judge wrong?\\n"
                    },
                    {
                        "username": "ling-lu",
                        "content": "The return value should be concatenated and repeated time, so the result should be 5. \nPlease check this case for more clarification.\n\"aaaba aaab aaaba aaaba aaaba aaaba aaaba\""
                    },
                    {
                        "username": "Raghaav_21",
                        "content": "exactly, answer should be 5. wtf how it can be 6\\n"
                    },
                    {
                        "username": "ma-lacroix",
                        "content": "I had the same thoughts, but take another good look at the string. The correct answer is indeed 5. "
                    },
                    {
                        "username": "uzeconomist0419",
                        "content": "[@sayedHANEEF](/sayedHANEEF)  I have the same problem"
                    },
                    {
                        "username": "harsh3150",
                        "content": "[@sayedHANEEF](/sayedHANEEF) they want a continuous string with max occurrence as output\n\nso aaaba as word we have\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\nwhich will be\n\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\n2 , 4 = 4 ans\n2nd possibility is \n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\n1, 5 = 5 ans \n\nfinal ans = 5. "
                    },
                    {
                        "username": "sayedHANEEF",
                        "content": "I am having the same problem......It should be 6 but they want 5 as a output.\\nDo tell me if u found the reason."
                    },
                    {
                        "username": "jcmf",
                        "content": "I don\\'t understand why everyone says that the answer for aaabaaaabaaabaaaabaaaabaaaabaaaaba should be 6. Shouldn\\'t it be 4? It seems pretty clear from the description that the words need to be consecutive, with nothing in between. It isn\\'t that the sequence needs to contain k separate copies of word, it\\'s that the sequence needs to contain the word concatenated k times -- meaning that the occurrences need to be consecutive, with nothing in between. Am I reading this wrong? Maybe there should be a non-broken example to disambiguate?"
                    },
                    {
                        "username": "ashwani2105",
                        "content": "Try to count it from index 9\\n"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "SAME!!! EXACTLY!!! My output is 4! I don\\'t know why they say 6 either lol "
                    },
                    {
                        "username": "rezl_jaws",
                        "content": "\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\"aaaba\"\\n\\nto me it should be 6 as hightlighted  in bold\\n\\n**aaaba**   **aaaba** aaba **aaaba** **aaaba** **aaaba** **aaaba** \\naaaba\\n\\nWhat do you think guys, mine is failing here as the expected output is apparently 5, would anyone  be able to comment or shed some light as to why  ?"
                    },
                    {
                        "username": "SinghalRishabh",
                        "content": "[@YusenPeng](/YusenPeng) they want a continuous string with max occurrence as output \\n\\nso aaaba as word we have\\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\\n\\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\\n2 , 4 = 4 ans we have to ignore the 1 \\n2nd possibility is\\n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\\n1, 5 = 5 ans\\n\\nfinal ans = 5."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "It should be contiguous because you need to form substring."
                    },
                    {
                        "username": "upretim",
                        "content": "\"aaaba aaaba aaba  aaaba aaaba aaaba aaaba\"\\n\"aaaba\"\\n\\nCorrect answer is 5 for this string, why not 6?"
                    },
                    {
                        "username": "SinghalRishabh",
                        "content": " they want a continuous string with max occurrence as output\\n\\nso aaaba as word we have\\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\\n2 , 4 = 4 ans, so 1 should be ignore\\n2nd possibility is\\n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\\n1, 5 = 5 ans\\n\\nfinal ans = 5."
                    },
                    {
                        "username": "aryonbe",
                        "content": "I think that this problem is not definitely easy.\nsequence = \"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\nword = \"aaaba\"\nMany people commented that the answer for the above case is 6. But it is 5 since the repeating words should be consecutive as described in the description. In the case above it looks like the following. \"aaabaaaab aaaba aaaba aaaba aaaba aaaba\"\nWe can see 5 repeating consecutive \"aaaba\".\nThere is no wrong testcase for this problem."
                    },
                    {
                        "username": "pranavarora724",
                        "content": "Yes , got your point\\nWe just not need to check how many \"aaaba\" are there \\nWe need to check how many consecutive \"aaaba\" are there\\nfor example\\nInput = \"aaabaaaaba\"\\nAns=2 (As they are consecutive)\\ninput = \"aaabaKaaaba\"\\nAns=1 (As there they are not consecutive)"
                    },
                    {
                        "username": "gafurulkazi98",
                        "content": "Regarding \"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\nThe question is confusing and the examples are misleading.\\n\\nIt doesn\\'t want the maximum number of times that you can find the word in the sequence, it wants you to find sections in the sequence where the word is repeating itself, get the number of times the word is repeated in that section, and return the highest number of repeats found in any section.\\n\\nAs harsh3150 has shown,\\n\\nso aaaba as word we have\\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\nwhich will be\\n\\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\\n2 , 4 = 4 ans\\n2nd possibility is\\n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\\n1, 5 = 5 ans\\n\\nfinal ans = 5."
                    },
                    {
                        "username": "SoulSlayer",
                        "content": "By this I mean a very similar problem here:\\n[https://www.spoj.com/problems/TKUDDUS/](https://www.spoj.com/problems/TKUDDUS/)\\n\\nI could come up with a bruteforce (q * N * N) approach which gets TLE\\'d. But apparently there is a O(NlogN) approach which I can\\'t seem to come up with. Any leads would be really helpful."
                    },
                    {
                        "username": "Dani28",
                        "content": "I coded in Python 3. Case 166/211 I got is sequence = \"aaabaaaabaaabaaaabaaaabaaaabaaaaba\" and word = \"aaaba.\" It seems to me that I can find 6 repeating \"aaaba\" that are disjoint if partitioning the sequence like this: \"aaaba aaaba aaba aaaba aaaba aaaba aaaba\" - How come the expected answer is 5??"
                    },
                    {
                        "username": "sayedHANEEF",
                        "content": "PEOPLE BE AWARE OF THIS WRONG TESTCASE:\\nsequence = \"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\nword = \"aaaba\"\\n\\nHERE THEY ARE EXPECTING 5 INSTEAD OF THE ACTUAL ANSWER WHICH IS 6."
                    },
                    {
                        "username": "adis176",
                        "content": "so aaaba as word, while our sequence=\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\\nWe should consider each index, where say sequence[i] == word[0]\\nAs it might be the start of our required substring\\nNow 2 main cases possible for given string:\\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\\nOut of all contiguous substrings, lengths we get 2 , 4 = max out of them - 4 ans\\n\\n2nd possibility is\\n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\\n1, 5 = max out of them = 5 ans\\n\\nHence overall max ans = (4, 5) = 5\\n"
                    },
                    {
                        "username": "jadejadej",
                        "content": "so confused."
                    }
                ]
            },
            {
                "id": 1574634,
                "content": [
                    {
                        "username": "user9990f",
                        "content": "One of test case is as follows\\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\"aaaba\"\\nThe judge expects 5. But it looks we have 6 as follows with spaces added.\\n\"aaaba aaaba aaba aaaba aaaba aaaba aaaba\"\\nIs the judge wrong?\\n"
                    },
                    {
                        "username": "ling-lu",
                        "content": "The return value should be concatenated and repeated time, so the result should be 5. \nPlease check this case for more clarification.\n\"aaaba aaab aaaba aaaba aaaba aaaba aaaba\""
                    },
                    {
                        "username": "Raghaav_21",
                        "content": "exactly, answer should be 5. wtf how it can be 6\\n"
                    },
                    {
                        "username": "ma-lacroix",
                        "content": "I had the same thoughts, but take another good look at the string. The correct answer is indeed 5. "
                    },
                    {
                        "username": "uzeconomist0419",
                        "content": "[@sayedHANEEF](/sayedHANEEF)  I have the same problem"
                    },
                    {
                        "username": "harsh3150",
                        "content": "[@sayedHANEEF](/sayedHANEEF) they want a continuous string with max occurrence as output\n\nso aaaba as word we have\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\nwhich will be\n\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\n2 , 4 = 4 ans\n2nd possibility is \n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\n1, 5 = 5 ans \n\nfinal ans = 5. "
                    },
                    {
                        "username": "sayedHANEEF",
                        "content": "I am having the same problem......It should be 6 but they want 5 as a output.\\nDo tell me if u found the reason."
                    },
                    {
                        "username": "jcmf",
                        "content": "I don\\'t understand why everyone says that the answer for aaabaaaabaaabaaaabaaaabaaaabaaaaba should be 6. Shouldn\\'t it be 4? It seems pretty clear from the description that the words need to be consecutive, with nothing in between. It isn\\'t that the sequence needs to contain k separate copies of word, it\\'s that the sequence needs to contain the word concatenated k times -- meaning that the occurrences need to be consecutive, with nothing in between. Am I reading this wrong? Maybe there should be a non-broken example to disambiguate?"
                    },
                    {
                        "username": "ashwani2105",
                        "content": "Try to count it from index 9\\n"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "SAME!!! EXACTLY!!! My output is 4! I don\\'t know why they say 6 either lol "
                    },
                    {
                        "username": "rezl_jaws",
                        "content": "\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\"aaaba\"\\n\\nto me it should be 6 as hightlighted  in bold\\n\\n**aaaba**   **aaaba** aaba **aaaba** **aaaba** **aaaba** **aaaba** \\naaaba\\n\\nWhat do you think guys, mine is failing here as the expected output is apparently 5, would anyone  be able to comment or shed some light as to why  ?"
                    },
                    {
                        "username": "SinghalRishabh",
                        "content": "[@YusenPeng](/YusenPeng) they want a continuous string with max occurrence as output \\n\\nso aaaba as word we have\\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\\n\\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\\n2 , 4 = 4 ans we have to ignore the 1 \\n2nd possibility is\\n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\\n1, 5 = 5 ans\\n\\nfinal ans = 5."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "It should be contiguous because you need to form substring."
                    },
                    {
                        "username": "upretim",
                        "content": "\"aaaba aaaba aaba  aaaba aaaba aaaba aaaba\"\\n\"aaaba\"\\n\\nCorrect answer is 5 for this string, why not 6?"
                    },
                    {
                        "username": "SinghalRishabh",
                        "content": " they want a continuous string with max occurrence as output\\n\\nso aaaba as word we have\\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\\n2 , 4 = 4 ans, so 1 should be ignore\\n2nd possibility is\\n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\\n1, 5 = 5 ans\\n\\nfinal ans = 5."
                    },
                    {
                        "username": "aryonbe",
                        "content": "I think that this problem is not definitely easy.\nsequence = \"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\nword = \"aaaba\"\nMany people commented that the answer for the above case is 6. But it is 5 since the repeating words should be consecutive as described in the description. In the case above it looks like the following. \"aaabaaaab aaaba aaaba aaaba aaaba aaaba\"\nWe can see 5 repeating consecutive \"aaaba\".\nThere is no wrong testcase for this problem."
                    },
                    {
                        "username": "pranavarora724",
                        "content": "Yes , got your point\\nWe just not need to check how many \"aaaba\" are there \\nWe need to check how many consecutive \"aaaba\" are there\\nfor example\\nInput = \"aaabaaaaba\"\\nAns=2 (As they are consecutive)\\ninput = \"aaabaKaaaba\"\\nAns=1 (As there they are not consecutive)"
                    },
                    {
                        "username": "gafurulkazi98",
                        "content": "Regarding \"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\nThe question is confusing and the examples are misleading.\\n\\nIt doesn\\'t want the maximum number of times that you can find the word in the sequence, it wants you to find sections in the sequence where the word is repeating itself, get the number of times the word is repeated in that section, and return the highest number of repeats found in any section.\\n\\nAs harsh3150 has shown,\\n\\nso aaaba as word we have\\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\nwhich will be\\n\\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\\n2 , 4 = 4 ans\\n2nd possibility is\\n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\\n1, 5 = 5 ans\\n\\nfinal ans = 5."
                    },
                    {
                        "username": "SoulSlayer",
                        "content": "By this I mean a very similar problem here:\\n[https://www.spoj.com/problems/TKUDDUS/](https://www.spoj.com/problems/TKUDDUS/)\\n\\nI could come up with a bruteforce (q * N * N) approach which gets TLE\\'d. But apparently there is a O(NlogN) approach which I can\\'t seem to come up with. Any leads would be really helpful."
                    },
                    {
                        "username": "Dani28",
                        "content": "I coded in Python 3. Case 166/211 I got is sequence = \"aaabaaaabaaabaaaabaaaabaaaabaaaaba\" and word = \"aaaba.\" It seems to me that I can find 6 repeating \"aaaba\" that are disjoint if partitioning the sequence like this: \"aaaba aaaba aaba aaaba aaaba aaaba aaaba\" - How come the expected answer is 5??"
                    },
                    {
                        "username": "sayedHANEEF",
                        "content": "PEOPLE BE AWARE OF THIS WRONG TESTCASE:\\nsequence = \"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\nword = \"aaaba\"\\n\\nHERE THEY ARE EXPECTING 5 INSTEAD OF THE ACTUAL ANSWER WHICH IS 6."
                    },
                    {
                        "username": "adis176",
                        "content": "so aaaba as word, while our sequence=\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\\nWe should consider each index, where say sequence[i] == word[0]\\nAs it might be the start of our required substring\\nNow 2 main cases possible for given string:\\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\\nOut of all contiguous substrings, lengths we get 2 , 4 = max out of them - 4 ans\\n\\n2nd possibility is\\n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\\n1, 5 = max out of them = 5 ans\\n\\nHence overall max ans = (4, 5) = 5\\n"
                    },
                    {
                        "username": "jadejadej",
                        "content": "so confused."
                    }
                ]
            },
            {
                "id": 1567109,
                "content": [
                    {
                        "username": "user9990f",
                        "content": "One of test case is as follows\\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\"aaaba\"\\nThe judge expects 5. But it looks we have 6 as follows with spaces added.\\n\"aaaba aaaba aaba aaaba aaaba aaaba aaaba\"\\nIs the judge wrong?\\n"
                    },
                    {
                        "username": "ling-lu",
                        "content": "The return value should be concatenated and repeated time, so the result should be 5. \nPlease check this case for more clarification.\n\"aaaba aaab aaaba aaaba aaaba aaaba aaaba\""
                    },
                    {
                        "username": "Raghaav_21",
                        "content": "exactly, answer should be 5. wtf how it can be 6\\n"
                    },
                    {
                        "username": "ma-lacroix",
                        "content": "I had the same thoughts, but take another good look at the string. The correct answer is indeed 5. "
                    },
                    {
                        "username": "uzeconomist0419",
                        "content": "[@sayedHANEEF](/sayedHANEEF)  I have the same problem"
                    },
                    {
                        "username": "harsh3150",
                        "content": "[@sayedHANEEF](/sayedHANEEF) they want a continuous string with max occurrence as output\n\nso aaaba as word we have\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\nwhich will be\n\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\n2 , 4 = 4 ans\n2nd possibility is \n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\n1, 5 = 5 ans \n\nfinal ans = 5. "
                    },
                    {
                        "username": "sayedHANEEF",
                        "content": "I am having the same problem......It should be 6 but they want 5 as a output.\\nDo tell me if u found the reason."
                    },
                    {
                        "username": "jcmf",
                        "content": "I don\\'t understand why everyone says that the answer for aaabaaaabaaabaaaabaaaabaaaabaaaaba should be 6. Shouldn\\'t it be 4? It seems pretty clear from the description that the words need to be consecutive, with nothing in between. It isn\\'t that the sequence needs to contain k separate copies of word, it\\'s that the sequence needs to contain the word concatenated k times -- meaning that the occurrences need to be consecutive, with nothing in between. Am I reading this wrong? Maybe there should be a non-broken example to disambiguate?"
                    },
                    {
                        "username": "ashwani2105",
                        "content": "Try to count it from index 9\\n"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "SAME!!! EXACTLY!!! My output is 4! I don\\'t know why they say 6 either lol "
                    },
                    {
                        "username": "rezl_jaws",
                        "content": "\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\"aaaba\"\\n\\nto me it should be 6 as hightlighted  in bold\\n\\n**aaaba**   **aaaba** aaba **aaaba** **aaaba** **aaaba** **aaaba** \\naaaba\\n\\nWhat do you think guys, mine is failing here as the expected output is apparently 5, would anyone  be able to comment or shed some light as to why  ?"
                    },
                    {
                        "username": "SinghalRishabh",
                        "content": "[@YusenPeng](/YusenPeng) they want a continuous string with max occurrence as output \\n\\nso aaaba as word we have\\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\\n\\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\\n2 , 4 = 4 ans we have to ignore the 1 \\n2nd possibility is\\n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\\n1, 5 = 5 ans\\n\\nfinal ans = 5."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "It should be contiguous because you need to form substring."
                    },
                    {
                        "username": "upretim",
                        "content": "\"aaaba aaaba aaba  aaaba aaaba aaaba aaaba\"\\n\"aaaba\"\\n\\nCorrect answer is 5 for this string, why not 6?"
                    },
                    {
                        "username": "SinghalRishabh",
                        "content": " they want a continuous string with max occurrence as output\\n\\nso aaaba as word we have\\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\\n2 , 4 = 4 ans, so 1 should be ignore\\n2nd possibility is\\n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\\n1, 5 = 5 ans\\n\\nfinal ans = 5."
                    },
                    {
                        "username": "aryonbe",
                        "content": "I think that this problem is not definitely easy.\nsequence = \"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\nword = \"aaaba\"\nMany people commented that the answer for the above case is 6. But it is 5 since the repeating words should be consecutive as described in the description. In the case above it looks like the following. \"aaabaaaab aaaba aaaba aaaba aaaba aaaba\"\nWe can see 5 repeating consecutive \"aaaba\".\nThere is no wrong testcase for this problem."
                    },
                    {
                        "username": "pranavarora724",
                        "content": "Yes , got your point\\nWe just not need to check how many \"aaaba\" are there \\nWe need to check how many consecutive \"aaaba\" are there\\nfor example\\nInput = \"aaabaaaaba\"\\nAns=2 (As they are consecutive)\\ninput = \"aaabaKaaaba\"\\nAns=1 (As there they are not consecutive)"
                    },
                    {
                        "username": "gafurulkazi98",
                        "content": "Regarding \"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\nThe question is confusing and the examples are misleading.\\n\\nIt doesn\\'t want the maximum number of times that you can find the word in the sequence, it wants you to find sections in the sequence where the word is repeating itself, get the number of times the word is repeated in that section, and return the highest number of repeats found in any section.\\n\\nAs harsh3150 has shown,\\n\\nso aaaba as word we have\\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\nwhich will be\\n\\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\\n2 , 4 = 4 ans\\n2nd possibility is\\n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\\n1, 5 = 5 ans\\n\\nfinal ans = 5."
                    },
                    {
                        "username": "SoulSlayer",
                        "content": "By this I mean a very similar problem here:\\n[https://www.spoj.com/problems/TKUDDUS/](https://www.spoj.com/problems/TKUDDUS/)\\n\\nI could come up with a bruteforce (q * N * N) approach which gets TLE\\'d. But apparently there is a O(NlogN) approach which I can\\'t seem to come up with. Any leads would be really helpful."
                    },
                    {
                        "username": "Dani28",
                        "content": "I coded in Python 3. Case 166/211 I got is sequence = \"aaabaaaabaaabaaaabaaaabaaaabaaaaba\" and word = \"aaaba.\" It seems to me that I can find 6 repeating \"aaaba\" that are disjoint if partitioning the sequence like this: \"aaaba aaaba aaba aaaba aaaba aaaba aaaba\" - How come the expected answer is 5??"
                    },
                    {
                        "username": "sayedHANEEF",
                        "content": "PEOPLE BE AWARE OF THIS WRONG TESTCASE:\\nsequence = \"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\nword = \"aaaba\"\\n\\nHERE THEY ARE EXPECTING 5 INSTEAD OF THE ACTUAL ANSWER WHICH IS 6."
                    },
                    {
                        "username": "adis176",
                        "content": "so aaaba as word, while our sequence=\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\\nWe should consider each index, where say sequence[i] == word[0]\\nAs it might be the start of our required substring\\nNow 2 main cases possible for given string:\\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\\nOut of all contiguous substrings, lengths we get 2 , 4 = max out of them - 4 ans\\n\\n2nd possibility is\\n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\\n1, 5 = max out of them = 5 ans\\n\\nHence overall max ans = (4, 5) = 5\\n"
                    },
                    {
                        "username": "jadejadej",
                        "content": "so confused."
                    }
                ]
            },
            {
                "id": 1675481,
                "content": [
                    {
                        "username": "user9990f",
                        "content": "One of test case is as follows\\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\"aaaba\"\\nThe judge expects 5. But it looks we have 6 as follows with spaces added.\\n\"aaaba aaaba aaba aaaba aaaba aaaba aaaba\"\\nIs the judge wrong?\\n"
                    },
                    {
                        "username": "ling-lu",
                        "content": "The return value should be concatenated and repeated time, so the result should be 5. \nPlease check this case for more clarification.\n\"aaaba aaab aaaba aaaba aaaba aaaba aaaba\""
                    },
                    {
                        "username": "Raghaav_21",
                        "content": "exactly, answer should be 5. wtf how it can be 6\\n"
                    },
                    {
                        "username": "ma-lacroix",
                        "content": "I had the same thoughts, but take another good look at the string. The correct answer is indeed 5. "
                    },
                    {
                        "username": "uzeconomist0419",
                        "content": "[@sayedHANEEF](/sayedHANEEF)  I have the same problem"
                    },
                    {
                        "username": "harsh3150",
                        "content": "[@sayedHANEEF](/sayedHANEEF) they want a continuous string with max occurrence as output\n\nso aaaba as word we have\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\nwhich will be\n\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\n2 , 4 = 4 ans\n2nd possibility is \n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\n1, 5 = 5 ans \n\nfinal ans = 5. "
                    },
                    {
                        "username": "sayedHANEEF",
                        "content": "I am having the same problem......It should be 6 but they want 5 as a output.\\nDo tell me if u found the reason."
                    },
                    {
                        "username": "jcmf",
                        "content": "I don\\'t understand why everyone says that the answer for aaabaaaabaaabaaaabaaaabaaaabaaaaba should be 6. Shouldn\\'t it be 4? It seems pretty clear from the description that the words need to be consecutive, with nothing in between. It isn\\'t that the sequence needs to contain k separate copies of word, it\\'s that the sequence needs to contain the word concatenated k times -- meaning that the occurrences need to be consecutive, with nothing in between. Am I reading this wrong? Maybe there should be a non-broken example to disambiguate?"
                    },
                    {
                        "username": "ashwani2105",
                        "content": "Try to count it from index 9\\n"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "SAME!!! EXACTLY!!! My output is 4! I don\\'t know why they say 6 either lol "
                    },
                    {
                        "username": "rezl_jaws",
                        "content": "\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\"aaaba\"\\n\\nto me it should be 6 as hightlighted  in bold\\n\\n**aaaba**   **aaaba** aaba **aaaba** **aaaba** **aaaba** **aaaba** \\naaaba\\n\\nWhat do you think guys, mine is failing here as the expected output is apparently 5, would anyone  be able to comment or shed some light as to why  ?"
                    },
                    {
                        "username": "SinghalRishabh",
                        "content": "[@YusenPeng](/YusenPeng) they want a continuous string with max occurrence as output \\n\\nso aaaba as word we have\\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\\n\\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\\n2 , 4 = 4 ans we have to ignore the 1 \\n2nd possibility is\\n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\\n1, 5 = 5 ans\\n\\nfinal ans = 5."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "It should be contiguous because you need to form substring."
                    },
                    {
                        "username": "upretim",
                        "content": "\"aaaba aaaba aaba  aaaba aaaba aaaba aaaba\"\\n\"aaaba\"\\n\\nCorrect answer is 5 for this string, why not 6?"
                    },
                    {
                        "username": "SinghalRishabh",
                        "content": " they want a continuous string with max occurrence as output\\n\\nso aaaba as word we have\\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\\n2 , 4 = 4 ans, so 1 should be ignore\\n2nd possibility is\\n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\\n1, 5 = 5 ans\\n\\nfinal ans = 5."
                    },
                    {
                        "username": "aryonbe",
                        "content": "I think that this problem is not definitely easy.\nsequence = \"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\nword = \"aaaba\"\nMany people commented that the answer for the above case is 6. But it is 5 since the repeating words should be consecutive as described in the description. In the case above it looks like the following. \"aaabaaaab aaaba aaaba aaaba aaaba aaaba\"\nWe can see 5 repeating consecutive \"aaaba\".\nThere is no wrong testcase for this problem."
                    },
                    {
                        "username": "pranavarora724",
                        "content": "Yes , got your point\\nWe just not need to check how many \"aaaba\" are there \\nWe need to check how many consecutive \"aaaba\" are there\\nfor example\\nInput = \"aaabaaaaba\"\\nAns=2 (As they are consecutive)\\ninput = \"aaabaKaaaba\"\\nAns=1 (As there they are not consecutive)"
                    },
                    {
                        "username": "gafurulkazi98",
                        "content": "Regarding \"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\nThe question is confusing and the examples are misleading.\\n\\nIt doesn\\'t want the maximum number of times that you can find the word in the sequence, it wants you to find sections in the sequence where the word is repeating itself, get the number of times the word is repeated in that section, and return the highest number of repeats found in any section.\\n\\nAs harsh3150 has shown,\\n\\nso aaaba as word we have\\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\nwhich will be\\n\\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\\n2 , 4 = 4 ans\\n2nd possibility is\\n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\\n1, 5 = 5 ans\\n\\nfinal ans = 5."
                    },
                    {
                        "username": "SoulSlayer",
                        "content": "By this I mean a very similar problem here:\\n[https://www.spoj.com/problems/TKUDDUS/](https://www.spoj.com/problems/TKUDDUS/)\\n\\nI could come up with a bruteforce (q * N * N) approach which gets TLE\\'d. But apparently there is a O(NlogN) approach which I can\\'t seem to come up with. Any leads would be really helpful."
                    },
                    {
                        "username": "Dani28",
                        "content": "I coded in Python 3. Case 166/211 I got is sequence = \"aaabaaaabaaabaaaabaaaabaaaabaaaaba\" and word = \"aaaba.\" It seems to me that I can find 6 repeating \"aaaba\" that are disjoint if partitioning the sequence like this: \"aaaba aaaba aaba aaaba aaaba aaaba aaaba\" - How come the expected answer is 5??"
                    },
                    {
                        "username": "sayedHANEEF",
                        "content": "PEOPLE BE AWARE OF THIS WRONG TESTCASE:\\nsequence = \"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\nword = \"aaaba\"\\n\\nHERE THEY ARE EXPECTING 5 INSTEAD OF THE ACTUAL ANSWER WHICH IS 6."
                    },
                    {
                        "username": "adis176",
                        "content": "so aaaba as word, while our sequence=\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\\nWe should consider each index, where say sequence[i] == word[0]\\nAs it might be the start of our required substring\\nNow 2 main cases possible for given string:\\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\\nOut of all contiguous substrings, lengths we get 2 , 4 = max out of them - 4 ans\\n\\n2nd possibility is\\n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\\n1, 5 = max out of them = 5 ans\\n\\nHence overall max ans = (4, 5) = 5\\n"
                    },
                    {
                        "username": "jadejadej",
                        "content": "so confused."
                    }
                ]
            },
            {
                "id": 1574806,
                "content": [
                    {
                        "username": "user9990f",
                        "content": "One of test case is as follows\\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\"aaaba\"\\nThe judge expects 5. But it looks we have 6 as follows with spaces added.\\n\"aaaba aaaba aaba aaaba aaaba aaaba aaaba\"\\nIs the judge wrong?\\n"
                    },
                    {
                        "username": "ling-lu",
                        "content": "The return value should be concatenated and repeated time, so the result should be 5. \nPlease check this case for more clarification.\n\"aaaba aaab aaaba aaaba aaaba aaaba aaaba\""
                    },
                    {
                        "username": "Raghaav_21",
                        "content": "exactly, answer should be 5. wtf how it can be 6\\n"
                    },
                    {
                        "username": "ma-lacroix",
                        "content": "I had the same thoughts, but take another good look at the string. The correct answer is indeed 5. "
                    },
                    {
                        "username": "uzeconomist0419",
                        "content": "[@sayedHANEEF](/sayedHANEEF)  I have the same problem"
                    },
                    {
                        "username": "harsh3150",
                        "content": "[@sayedHANEEF](/sayedHANEEF) they want a continuous string with max occurrence as output\n\nso aaaba as word we have\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\nwhich will be\n\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\n2 , 4 = 4 ans\n2nd possibility is \n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\n1, 5 = 5 ans \n\nfinal ans = 5. "
                    },
                    {
                        "username": "sayedHANEEF",
                        "content": "I am having the same problem......It should be 6 but they want 5 as a output.\\nDo tell me if u found the reason."
                    },
                    {
                        "username": "jcmf",
                        "content": "I don\\'t understand why everyone says that the answer for aaabaaaabaaabaaaabaaaabaaaabaaaaba should be 6. Shouldn\\'t it be 4? It seems pretty clear from the description that the words need to be consecutive, with nothing in between. It isn\\'t that the sequence needs to contain k separate copies of word, it\\'s that the sequence needs to contain the word concatenated k times -- meaning that the occurrences need to be consecutive, with nothing in between. Am I reading this wrong? Maybe there should be a non-broken example to disambiguate?"
                    },
                    {
                        "username": "ashwani2105",
                        "content": "Try to count it from index 9\\n"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "SAME!!! EXACTLY!!! My output is 4! I don\\'t know why they say 6 either lol "
                    },
                    {
                        "username": "rezl_jaws",
                        "content": "\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\"aaaba\"\\n\\nto me it should be 6 as hightlighted  in bold\\n\\n**aaaba**   **aaaba** aaba **aaaba** **aaaba** **aaaba** **aaaba** \\naaaba\\n\\nWhat do you think guys, mine is failing here as the expected output is apparently 5, would anyone  be able to comment or shed some light as to why  ?"
                    },
                    {
                        "username": "SinghalRishabh",
                        "content": "[@YusenPeng](/YusenPeng) they want a continuous string with max occurrence as output \\n\\nso aaaba as word we have\\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\\n\\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\\n2 , 4 = 4 ans we have to ignore the 1 \\n2nd possibility is\\n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\\n1, 5 = 5 ans\\n\\nfinal ans = 5."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "It should be contiguous because you need to form substring."
                    },
                    {
                        "username": "upretim",
                        "content": "\"aaaba aaaba aaba  aaaba aaaba aaaba aaaba\"\\n\"aaaba\"\\n\\nCorrect answer is 5 for this string, why not 6?"
                    },
                    {
                        "username": "SinghalRishabh",
                        "content": " they want a continuous string with max occurrence as output\\n\\nso aaaba as word we have\\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\\n2 , 4 = 4 ans, so 1 should be ignore\\n2nd possibility is\\n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\\n1, 5 = 5 ans\\n\\nfinal ans = 5."
                    },
                    {
                        "username": "aryonbe",
                        "content": "I think that this problem is not definitely easy.\nsequence = \"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\nword = \"aaaba\"\nMany people commented that the answer for the above case is 6. But it is 5 since the repeating words should be consecutive as described in the description. In the case above it looks like the following. \"aaabaaaab aaaba aaaba aaaba aaaba aaaba\"\nWe can see 5 repeating consecutive \"aaaba\".\nThere is no wrong testcase for this problem."
                    },
                    {
                        "username": "pranavarora724",
                        "content": "Yes , got your point\\nWe just not need to check how many \"aaaba\" are there \\nWe need to check how many consecutive \"aaaba\" are there\\nfor example\\nInput = \"aaabaaaaba\"\\nAns=2 (As they are consecutive)\\ninput = \"aaabaKaaaba\"\\nAns=1 (As there they are not consecutive)"
                    },
                    {
                        "username": "gafurulkazi98",
                        "content": "Regarding \"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\nThe question is confusing and the examples are misleading.\\n\\nIt doesn\\'t want the maximum number of times that you can find the word in the sequence, it wants you to find sections in the sequence where the word is repeating itself, get the number of times the word is repeated in that section, and return the highest number of repeats found in any section.\\n\\nAs harsh3150 has shown,\\n\\nso aaaba as word we have\\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\nwhich will be\\n\\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\\n2 , 4 = 4 ans\\n2nd possibility is\\n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\\n1, 5 = 5 ans\\n\\nfinal ans = 5."
                    },
                    {
                        "username": "SoulSlayer",
                        "content": "By this I mean a very similar problem here:\\n[https://www.spoj.com/problems/TKUDDUS/](https://www.spoj.com/problems/TKUDDUS/)\\n\\nI could come up with a bruteforce (q * N * N) approach which gets TLE\\'d. But apparently there is a O(NlogN) approach which I can\\'t seem to come up with. Any leads would be really helpful."
                    },
                    {
                        "username": "Dani28",
                        "content": "I coded in Python 3. Case 166/211 I got is sequence = \"aaabaaaabaaabaaaabaaaabaaaabaaaaba\" and word = \"aaaba.\" It seems to me that I can find 6 repeating \"aaaba\" that are disjoint if partitioning the sequence like this: \"aaaba aaaba aaba aaaba aaaba aaaba aaaba\" - How come the expected answer is 5??"
                    },
                    {
                        "username": "sayedHANEEF",
                        "content": "PEOPLE BE AWARE OF THIS WRONG TESTCASE:\\nsequence = \"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\nword = \"aaaba\"\\n\\nHERE THEY ARE EXPECTING 5 INSTEAD OF THE ACTUAL ANSWER WHICH IS 6."
                    },
                    {
                        "username": "adis176",
                        "content": "so aaaba as word, while our sequence=\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\\nWe should consider each index, where say sequence[i] == word[0]\\nAs it might be the start of our required substring\\nNow 2 main cases possible for given string:\\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\\nOut of all contiguous substrings, lengths we get 2 , 4 = max out of them - 4 ans\\n\\n2nd possibility is\\n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\\n1, 5 = max out of them = 5 ans\\n\\nHence overall max ans = (4, 5) = 5\\n"
                    },
                    {
                        "username": "jadejadej",
                        "content": "so confused."
                    }
                ]
            },
            {
                "id": 1574918,
                "content": [
                    {
                        "username": "user9990f",
                        "content": "One of test case is as follows\\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\"aaaba\"\\nThe judge expects 5. But it looks we have 6 as follows with spaces added.\\n\"aaaba aaaba aaba aaaba aaaba aaaba aaaba\"\\nIs the judge wrong?\\n"
                    },
                    {
                        "username": "ling-lu",
                        "content": "The return value should be concatenated and repeated time, so the result should be 5. \nPlease check this case for more clarification.\n\"aaaba aaab aaaba aaaba aaaba aaaba aaaba\""
                    },
                    {
                        "username": "Raghaav_21",
                        "content": "exactly, answer should be 5. wtf how it can be 6\\n"
                    },
                    {
                        "username": "ma-lacroix",
                        "content": "I had the same thoughts, but take another good look at the string. The correct answer is indeed 5. "
                    },
                    {
                        "username": "uzeconomist0419",
                        "content": "[@sayedHANEEF](/sayedHANEEF)  I have the same problem"
                    },
                    {
                        "username": "harsh3150",
                        "content": "[@sayedHANEEF](/sayedHANEEF) they want a continuous string with max occurrence as output\n\nso aaaba as word we have\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\nwhich will be\n\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\n2 , 4 = 4 ans\n2nd possibility is \n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\n1, 5 = 5 ans \n\nfinal ans = 5. "
                    },
                    {
                        "username": "sayedHANEEF",
                        "content": "I am having the same problem......It should be 6 but they want 5 as a output.\\nDo tell me if u found the reason."
                    },
                    {
                        "username": "jcmf",
                        "content": "I don\\'t understand why everyone says that the answer for aaabaaaabaaabaaaabaaaabaaaabaaaaba should be 6. Shouldn\\'t it be 4? It seems pretty clear from the description that the words need to be consecutive, with nothing in between. It isn\\'t that the sequence needs to contain k separate copies of word, it\\'s that the sequence needs to contain the word concatenated k times -- meaning that the occurrences need to be consecutive, with nothing in between. Am I reading this wrong? Maybe there should be a non-broken example to disambiguate?"
                    },
                    {
                        "username": "ashwani2105",
                        "content": "Try to count it from index 9\\n"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "SAME!!! EXACTLY!!! My output is 4! I don\\'t know why they say 6 either lol "
                    },
                    {
                        "username": "rezl_jaws",
                        "content": "\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\"aaaba\"\\n\\nto me it should be 6 as hightlighted  in bold\\n\\n**aaaba**   **aaaba** aaba **aaaba** **aaaba** **aaaba** **aaaba** \\naaaba\\n\\nWhat do you think guys, mine is failing here as the expected output is apparently 5, would anyone  be able to comment or shed some light as to why  ?"
                    },
                    {
                        "username": "SinghalRishabh",
                        "content": "[@YusenPeng](/YusenPeng) they want a continuous string with max occurrence as output \\n\\nso aaaba as word we have\\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\\n\\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\\n2 , 4 = 4 ans we have to ignore the 1 \\n2nd possibility is\\n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\\n1, 5 = 5 ans\\n\\nfinal ans = 5."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "It should be contiguous because you need to form substring."
                    },
                    {
                        "username": "upretim",
                        "content": "\"aaaba aaaba aaba  aaaba aaaba aaaba aaaba\"\\n\"aaaba\"\\n\\nCorrect answer is 5 for this string, why not 6?"
                    },
                    {
                        "username": "SinghalRishabh",
                        "content": " they want a continuous string with max occurrence as output\\n\\nso aaaba as word we have\\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\\n2 , 4 = 4 ans, so 1 should be ignore\\n2nd possibility is\\n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\\n1, 5 = 5 ans\\n\\nfinal ans = 5."
                    },
                    {
                        "username": "aryonbe",
                        "content": "I think that this problem is not definitely easy.\nsequence = \"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\nword = \"aaaba\"\nMany people commented that the answer for the above case is 6. But it is 5 since the repeating words should be consecutive as described in the description. In the case above it looks like the following. \"aaabaaaab aaaba aaaba aaaba aaaba aaaba\"\nWe can see 5 repeating consecutive \"aaaba\".\nThere is no wrong testcase for this problem."
                    },
                    {
                        "username": "pranavarora724",
                        "content": "Yes , got your point\\nWe just not need to check how many \"aaaba\" are there \\nWe need to check how many consecutive \"aaaba\" are there\\nfor example\\nInput = \"aaabaaaaba\"\\nAns=2 (As they are consecutive)\\ninput = \"aaabaKaaaba\"\\nAns=1 (As there they are not consecutive)"
                    },
                    {
                        "username": "gafurulkazi98",
                        "content": "Regarding \"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\nThe question is confusing and the examples are misleading.\\n\\nIt doesn\\'t want the maximum number of times that you can find the word in the sequence, it wants you to find sections in the sequence where the word is repeating itself, get the number of times the word is repeated in that section, and return the highest number of repeats found in any section.\\n\\nAs harsh3150 has shown,\\n\\nso aaaba as word we have\\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\nwhich will be\\n\\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\\n2 , 4 = 4 ans\\n2nd possibility is\\n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\\n1, 5 = 5 ans\\n\\nfinal ans = 5."
                    },
                    {
                        "username": "SoulSlayer",
                        "content": "By this I mean a very similar problem here:\\n[https://www.spoj.com/problems/TKUDDUS/](https://www.spoj.com/problems/TKUDDUS/)\\n\\nI could come up with a bruteforce (q * N * N) approach which gets TLE\\'d. But apparently there is a O(NlogN) approach which I can\\'t seem to come up with. Any leads would be really helpful."
                    },
                    {
                        "username": "Dani28",
                        "content": "I coded in Python 3. Case 166/211 I got is sequence = \"aaabaaaabaaabaaaabaaaabaaaabaaaaba\" and word = \"aaaba.\" It seems to me that I can find 6 repeating \"aaaba\" that are disjoint if partitioning the sequence like this: \"aaaba aaaba aaba aaaba aaaba aaaba aaaba\" - How come the expected answer is 5??"
                    },
                    {
                        "username": "sayedHANEEF",
                        "content": "PEOPLE BE AWARE OF THIS WRONG TESTCASE:\\nsequence = \"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\nword = \"aaaba\"\\n\\nHERE THEY ARE EXPECTING 5 INSTEAD OF THE ACTUAL ANSWER WHICH IS 6."
                    },
                    {
                        "username": "adis176",
                        "content": "so aaaba as word, while our sequence=\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\\nWe should consider each index, where say sequence[i] == word[0]\\nAs it might be the start of our required substring\\nNow 2 main cases possible for given string:\\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\\nOut of all contiguous substrings, lengths we get 2 , 4 = max out of them - 4 ans\\n\\n2nd possibility is\\n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\\n1, 5 = max out of them = 5 ans\\n\\nHence overall max ans = (4, 5) = 5\\n"
                    },
                    {
                        "username": "jadejadej",
                        "content": "so confused."
                    }
                ]
            },
            {
                "id": 1716042,
                "content": [
                    {
                        "username": "user9990f",
                        "content": "One of test case is as follows\\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\"aaaba\"\\nThe judge expects 5. But it looks we have 6 as follows with spaces added.\\n\"aaaba aaaba aaba aaaba aaaba aaaba aaaba\"\\nIs the judge wrong?\\n"
                    },
                    {
                        "username": "ling-lu",
                        "content": "The return value should be concatenated and repeated time, so the result should be 5. \nPlease check this case for more clarification.\n\"aaaba aaab aaaba aaaba aaaba aaaba aaaba\""
                    },
                    {
                        "username": "Raghaav_21",
                        "content": "exactly, answer should be 5. wtf how it can be 6\\n"
                    },
                    {
                        "username": "ma-lacroix",
                        "content": "I had the same thoughts, but take another good look at the string. The correct answer is indeed 5. "
                    },
                    {
                        "username": "uzeconomist0419",
                        "content": "[@sayedHANEEF](/sayedHANEEF)  I have the same problem"
                    },
                    {
                        "username": "harsh3150",
                        "content": "[@sayedHANEEF](/sayedHANEEF) they want a continuous string with max occurrence as output\n\nso aaaba as word we have\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\nwhich will be\n\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\n2 , 4 = 4 ans\n2nd possibility is \n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\n1, 5 = 5 ans \n\nfinal ans = 5. "
                    },
                    {
                        "username": "sayedHANEEF",
                        "content": "I am having the same problem......It should be 6 but they want 5 as a output.\\nDo tell me if u found the reason."
                    },
                    {
                        "username": "jcmf",
                        "content": "I don\\'t understand why everyone says that the answer for aaabaaaabaaabaaaabaaaabaaaabaaaaba should be 6. Shouldn\\'t it be 4? It seems pretty clear from the description that the words need to be consecutive, with nothing in between. It isn\\'t that the sequence needs to contain k separate copies of word, it\\'s that the sequence needs to contain the word concatenated k times -- meaning that the occurrences need to be consecutive, with nothing in between. Am I reading this wrong? Maybe there should be a non-broken example to disambiguate?"
                    },
                    {
                        "username": "ashwani2105",
                        "content": "Try to count it from index 9\\n"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "SAME!!! EXACTLY!!! My output is 4! I don\\'t know why they say 6 either lol "
                    },
                    {
                        "username": "rezl_jaws",
                        "content": "\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\"aaaba\"\\n\\nto me it should be 6 as hightlighted  in bold\\n\\n**aaaba**   **aaaba** aaba **aaaba** **aaaba** **aaaba** **aaaba** \\naaaba\\n\\nWhat do you think guys, mine is failing here as the expected output is apparently 5, would anyone  be able to comment or shed some light as to why  ?"
                    },
                    {
                        "username": "SinghalRishabh",
                        "content": "[@YusenPeng](/YusenPeng) they want a continuous string with max occurrence as output \\n\\nso aaaba as word we have\\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\\n\\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\\n2 , 4 = 4 ans we have to ignore the 1 \\n2nd possibility is\\n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\\n1, 5 = 5 ans\\n\\nfinal ans = 5."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "It should be contiguous because you need to form substring."
                    },
                    {
                        "username": "upretim",
                        "content": "\"aaaba aaaba aaba  aaaba aaaba aaaba aaaba\"\\n\"aaaba\"\\n\\nCorrect answer is 5 for this string, why not 6?"
                    },
                    {
                        "username": "SinghalRishabh",
                        "content": " they want a continuous string with max occurrence as output\\n\\nso aaaba as word we have\\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\\n2 , 4 = 4 ans, so 1 should be ignore\\n2nd possibility is\\n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\\n1, 5 = 5 ans\\n\\nfinal ans = 5."
                    },
                    {
                        "username": "aryonbe",
                        "content": "I think that this problem is not definitely easy.\nsequence = \"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\nword = \"aaaba\"\nMany people commented that the answer for the above case is 6. But it is 5 since the repeating words should be consecutive as described in the description. In the case above it looks like the following. \"aaabaaaab aaaba aaaba aaaba aaaba aaaba\"\nWe can see 5 repeating consecutive \"aaaba\".\nThere is no wrong testcase for this problem."
                    },
                    {
                        "username": "pranavarora724",
                        "content": "Yes , got your point\\nWe just not need to check how many \"aaaba\" are there \\nWe need to check how many consecutive \"aaaba\" are there\\nfor example\\nInput = \"aaabaaaaba\"\\nAns=2 (As they are consecutive)\\ninput = \"aaabaKaaaba\"\\nAns=1 (As there they are not consecutive)"
                    },
                    {
                        "username": "gafurulkazi98",
                        "content": "Regarding \"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\nThe question is confusing and the examples are misleading.\\n\\nIt doesn\\'t want the maximum number of times that you can find the word in the sequence, it wants you to find sections in the sequence where the word is repeating itself, get the number of times the word is repeated in that section, and return the highest number of repeats found in any section.\\n\\nAs harsh3150 has shown,\\n\\nso aaaba as word we have\\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\nwhich will be\\n\\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\\n2 , 4 = 4 ans\\n2nd possibility is\\n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\\n1, 5 = 5 ans\\n\\nfinal ans = 5."
                    },
                    {
                        "username": "SoulSlayer",
                        "content": "By this I mean a very similar problem here:\\n[https://www.spoj.com/problems/TKUDDUS/](https://www.spoj.com/problems/TKUDDUS/)\\n\\nI could come up with a bruteforce (q * N * N) approach which gets TLE\\'d. But apparently there is a O(NlogN) approach which I can\\'t seem to come up with. Any leads would be really helpful."
                    },
                    {
                        "username": "Dani28",
                        "content": "I coded in Python 3. Case 166/211 I got is sequence = \"aaabaaaabaaabaaaabaaaabaaaabaaaaba\" and word = \"aaaba.\" It seems to me that I can find 6 repeating \"aaaba\" that are disjoint if partitioning the sequence like this: \"aaaba aaaba aaba aaaba aaaba aaaba aaaba\" - How come the expected answer is 5??"
                    },
                    {
                        "username": "sayedHANEEF",
                        "content": "PEOPLE BE AWARE OF THIS WRONG TESTCASE:\\nsequence = \"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\nword = \"aaaba\"\\n\\nHERE THEY ARE EXPECTING 5 INSTEAD OF THE ACTUAL ANSWER WHICH IS 6."
                    },
                    {
                        "username": "adis176",
                        "content": "so aaaba as word, while our sequence=\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\\nWe should consider each index, where say sequence[i] == word[0]\\nAs it might be the start of our required substring\\nNow 2 main cases possible for given string:\\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\\nOut of all contiguous substrings, lengths we get 2 , 4 = max out of them - 4 ans\\n\\n2nd possibility is\\n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\\n1, 5 = max out of them = 5 ans\\n\\nHence overall max ans = (4, 5) = 5\\n"
                    },
                    {
                        "username": "jadejadej",
                        "content": "so confused."
                    }
                ]
            },
            {
                "id": 1929283,
                "content": [
                    {
                        "username": "user9990f",
                        "content": "One of test case is as follows\\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\"aaaba\"\\nThe judge expects 5. But it looks we have 6 as follows with spaces added.\\n\"aaaba aaaba aaba aaaba aaaba aaaba aaaba\"\\nIs the judge wrong?\\n"
                    },
                    {
                        "username": "ling-lu",
                        "content": "The return value should be concatenated and repeated time, so the result should be 5. \nPlease check this case for more clarification.\n\"aaaba aaab aaaba aaaba aaaba aaaba aaaba\""
                    },
                    {
                        "username": "Raghaav_21",
                        "content": "exactly, answer should be 5. wtf how it can be 6\\n"
                    },
                    {
                        "username": "ma-lacroix",
                        "content": "I had the same thoughts, but take another good look at the string. The correct answer is indeed 5. "
                    },
                    {
                        "username": "uzeconomist0419",
                        "content": "[@sayedHANEEF](/sayedHANEEF)  I have the same problem"
                    },
                    {
                        "username": "harsh3150",
                        "content": "[@sayedHANEEF](/sayedHANEEF) they want a continuous string with max occurrence as output\n\nso aaaba as word we have\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\nwhich will be\n\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\n2 , 4 = 4 ans\n2nd possibility is \n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\n1, 5 = 5 ans \n\nfinal ans = 5. "
                    },
                    {
                        "username": "sayedHANEEF",
                        "content": "I am having the same problem......It should be 6 but they want 5 as a output.\\nDo tell me if u found the reason."
                    },
                    {
                        "username": "jcmf",
                        "content": "I don\\'t understand why everyone says that the answer for aaabaaaabaaabaaaabaaaabaaaabaaaaba should be 6. Shouldn\\'t it be 4? It seems pretty clear from the description that the words need to be consecutive, with nothing in between. It isn\\'t that the sequence needs to contain k separate copies of word, it\\'s that the sequence needs to contain the word concatenated k times -- meaning that the occurrences need to be consecutive, with nothing in between. Am I reading this wrong? Maybe there should be a non-broken example to disambiguate?"
                    },
                    {
                        "username": "ashwani2105",
                        "content": "Try to count it from index 9\\n"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "SAME!!! EXACTLY!!! My output is 4! I don\\'t know why they say 6 either lol "
                    },
                    {
                        "username": "rezl_jaws",
                        "content": "\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\"aaaba\"\\n\\nto me it should be 6 as hightlighted  in bold\\n\\n**aaaba**   **aaaba** aaba **aaaba** **aaaba** **aaaba** **aaaba** \\naaaba\\n\\nWhat do you think guys, mine is failing here as the expected output is apparently 5, would anyone  be able to comment or shed some light as to why  ?"
                    },
                    {
                        "username": "SinghalRishabh",
                        "content": "[@YusenPeng](/YusenPeng) they want a continuous string with max occurrence as output \\n\\nso aaaba as word we have\\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\\n\\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\\n2 , 4 = 4 ans we have to ignore the 1 \\n2nd possibility is\\n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\\n1, 5 = 5 ans\\n\\nfinal ans = 5."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "It should be contiguous because you need to form substring."
                    },
                    {
                        "username": "upretim",
                        "content": "\"aaaba aaaba aaba  aaaba aaaba aaaba aaaba\"\\n\"aaaba\"\\n\\nCorrect answer is 5 for this string, why not 6?"
                    },
                    {
                        "username": "SinghalRishabh",
                        "content": " they want a continuous string with max occurrence as output\\n\\nso aaaba as word we have\\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\\n2 , 4 = 4 ans, so 1 should be ignore\\n2nd possibility is\\n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\\n1, 5 = 5 ans\\n\\nfinal ans = 5."
                    },
                    {
                        "username": "aryonbe",
                        "content": "I think that this problem is not definitely easy.\nsequence = \"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\nword = \"aaaba\"\nMany people commented that the answer for the above case is 6. But it is 5 since the repeating words should be consecutive as described in the description. In the case above it looks like the following. \"aaabaaaab aaaba aaaba aaaba aaaba aaaba\"\nWe can see 5 repeating consecutive \"aaaba\".\nThere is no wrong testcase for this problem."
                    },
                    {
                        "username": "pranavarora724",
                        "content": "Yes , got your point\\nWe just not need to check how many \"aaaba\" are there \\nWe need to check how many consecutive \"aaaba\" are there\\nfor example\\nInput = \"aaabaaaaba\"\\nAns=2 (As they are consecutive)\\ninput = \"aaabaKaaaba\"\\nAns=1 (As there they are not consecutive)"
                    },
                    {
                        "username": "gafurulkazi98",
                        "content": "Regarding \"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\nThe question is confusing and the examples are misleading.\\n\\nIt doesn\\'t want the maximum number of times that you can find the word in the sequence, it wants you to find sections in the sequence where the word is repeating itself, get the number of times the word is repeated in that section, and return the highest number of repeats found in any section.\\n\\nAs harsh3150 has shown,\\n\\nso aaaba as word we have\\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\nwhich will be\\n\\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\\n2 , 4 = 4 ans\\n2nd possibility is\\n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\\n1, 5 = 5 ans\\n\\nfinal ans = 5."
                    },
                    {
                        "username": "SoulSlayer",
                        "content": "By this I mean a very similar problem here:\\n[https://www.spoj.com/problems/TKUDDUS/](https://www.spoj.com/problems/TKUDDUS/)\\n\\nI could come up with a bruteforce (q * N * N) approach which gets TLE\\'d. But apparently there is a O(NlogN) approach which I can\\'t seem to come up with. Any leads would be really helpful."
                    },
                    {
                        "username": "Dani28",
                        "content": "I coded in Python 3. Case 166/211 I got is sequence = \"aaabaaaabaaabaaaabaaaabaaaabaaaaba\" and word = \"aaaba.\" It seems to me that I can find 6 repeating \"aaaba\" that are disjoint if partitioning the sequence like this: \"aaaba aaaba aaba aaaba aaaba aaaba aaaba\" - How come the expected answer is 5??"
                    },
                    {
                        "username": "sayedHANEEF",
                        "content": "PEOPLE BE AWARE OF THIS WRONG TESTCASE:\\nsequence = \"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\nword = \"aaaba\"\\n\\nHERE THEY ARE EXPECTING 5 INSTEAD OF THE ACTUAL ANSWER WHICH IS 6."
                    },
                    {
                        "username": "adis176",
                        "content": "so aaaba as word, while our sequence=\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\\nWe should consider each index, where say sequence[i] == word[0]\\nAs it might be the start of our required substring\\nNow 2 main cases possible for given string:\\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\\nOut of all contiguous substrings, lengths we get 2 , 4 = max out of them - 4 ans\\n\\n2nd possibility is\\n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\\n1, 5 = max out of them = 5 ans\\n\\nHence overall max ans = (4, 5) = 5\\n"
                    },
                    {
                        "username": "jadejadej",
                        "content": "so confused."
                    }
                ]
            },
            {
                "id": 1575371,
                "content": [
                    {
                        "username": "user9990f",
                        "content": "One of test case is as follows\\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\"aaaba\"\\nThe judge expects 5. But it looks we have 6 as follows with spaces added.\\n\"aaaba aaaba aaba aaaba aaaba aaaba aaaba\"\\nIs the judge wrong?\\n"
                    },
                    {
                        "username": "ling-lu",
                        "content": "The return value should be concatenated and repeated time, so the result should be 5. \nPlease check this case for more clarification.\n\"aaaba aaab aaaba aaaba aaaba aaaba aaaba\""
                    },
                    {
                        "username": "Raghaav_21",
                        "content": "exactly, answer should be 5. wtf how it can be 6\\n"
                    },
                    {
                        "username": "ma-lacroix",
                        "content": "I had the same thoughts, but take another good look at the string. The correct answer is indeed 5. "
                    },
                    {
                        "username": "uzeconomist0419",
                        "content": "[@sayedHANEEF](/sayedHANEEF)  I have the same problem"
                    },
                    {
                        "username": "harsh3150",
                        "content": "[@sayedHANEEF](/sayedHANEEF) they want a continuous string with max occurrence as output\n\nso aaaba as word we have\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\nwhich will be\n\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\n2 , 4 = 4 ans\n2nd possibility is \n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\n1, 5 = 5 ans \n\nfinal ans = 5. "
                    },
                    {
                        "username": "sayedHANEEF",
                        "content": "I am having the same problem......It should be 6 but they want 5 as a output.\\nDo tell me if u found the reason."
                    },
                    {
                        "username": "jcmf",
                        "content": "I don\\'t understand why everyone says that the answer for aaabaaaabaaabaaaabaaaabaaaabaaaaba should be 6. Shouldn\\'t it be 4? It seems pretty clear from the description that the words need to be consecutive, with nothing in between. It isn\\'t that the sequence needs to contain k separate copies of word, it\\'s that the sequence needs to contain the word concatenated k times -- meaning that the occurrences need to be consecutive, with nothing in between. Am I reading this wrong? Maybe there should be a non-broken example to disambiguate?"
                    },
                    {
                        "username": "ashwani2105",
                        "content": "Try to count it from index 9\\n"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "SAME!!! EXACTLY!!! My output is 4! I don\\'t know why they say 6 either lol "
                    },
                    {
                        "username": "rezl_jaws",
                        "content": "\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\"aaaba\"\\n\\nto me it should be 6 as hightlighted  in bold\\n\\n**aaaba**   **aaaba** aaba **aaaba** **aaaba** **aaaba** **aaaba** \\naaaba\\n\\nWhat do you think guys, mine is failing here as the expected output is apparently 5, would anyone  be able to comment or shed some light as to why  ?"
                    },
                    {
                        "username": "SinghalRishabh",
                        "content": "[@YusenPeng](/YusenPeng) they want a continuous string with max occurrence as output \\n\\nso aaaba as word we have\\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\\n\\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\\n2 , 4 = 4 ans we have to ignore the 1 \\n2nd possibility is\\n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\\n1, 5 = 5 ans\\n\\nfinal ans = 5."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "It should be contiguous because you need to form substring."
                    },
                    {
                        "username": "upretim",
                        "content": "\"aaaba aaaba aaba  aaaba aaaba aaaba aaaba\"\\n\"aaaba\"\\n\\nCorrect answer is 5 for this string, why not 6?"
                    },
                    {
                        "username": "SinghalRishabh",
                        "content": " they want a continuous string with max occurrence as output\\n\\nso aaaba as word we have\\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\\n2 , 4 = 4 ans, so 1 should be ignore\\n2nd possibility is\\n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\\n1, 5 = 5 ans\\n\\nfinal ans = 5."
                    },
                    {
                        "username": "aryonbe",
                        "content": "I think that this problem is not definitely easy.\nsequence = \"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\nword = \"aaaba\"\nMany people commented that the answer for the above case is 6. But it is 5 since the repeating words should be consecutive as described in the description. In the case above it looks like the following. \"aaabaaaab aaaba aaaba aaaba aaaba aaaba\"\nWe can see 5 repeating consecutive \"aaaba\".\nThere is no wrong testcase for this problem."
                    },
                    {
                        "username": "pranavarora724",
                        "content": "Yes , got your point\\nWe just not need to check how many \"aaaba\" are there \\nWe need to check how many consecutive \"aaaba\" are there\\nfor example\\nInput = \"aaabaaaaba\"\\nAns=2 (As they are consecutive)\\ninput = \"aaabaKaaaba\"\\nAns=1 (As there they are not consecutive)"
                    },
                    {
                        "username": "gafurulkazi98",
                        "content": "Regarding \"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\nThe question is confusing and the examples are misleading.\\n\\nIt doesn\\'t want the maximum number of times that you can find the word in the sequence, it wants you to find sections in the sequence where the word is repeating itself, get the number of times the word is repeated in that section, and return the highest number of repeats found in any section.\\n\\nAs harsh3150 has shown,\\n\\nso aaaba as word we have\\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\nwhich will be\\n\\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\\n2 , 4 = 4 ans\\n2nd possibility is\\n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\\n1, 5 = 5 ans\\n\\nfinal ans = 5."
                    },
                    {
                        "username": "SoulSlayer",
                        "content": "By this I mean a very similar problem here:\\n[https://www.spoj.com/problems/TKUDDUS/](https://www.spoj.com/problems/TKUDDUS/)\\n\\nI could come up with a bruteforce (q * N * N) approach which gets TLE\\'d. But apparently there is a O(NlogN) approach which I can\\'t seem to come up with. Any leads would be really helpful."
                    },
                    {
                        "username": "Dani28",
                        "content": "I coded in Python 3. Case 166/211 I got is sequence = \"aaabaaaabaaabaaaabaaaabaaaabaaaaba\" and word = \"aaaba.\" It seems to me that I can find 6 repeating \"aaaba\" that are disjoint if partitioning the sequence like this: \"aaaba aaaba aaba aaaba aaaba aaaba aaaba\" - How come the expected answer is 5??"
                    },
                    {
                        "username": "sayedHANEEF",
                        "content": "PEOPLE BE AWARE OF THIS WRONG TESTCASE:\\nsequence = \"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\nword = \"aaaba\"\\n\\nHERE THEY ARE EXPECTING 5 INSTEAD OF THE ACTUAL ANSWER WHICH IS 6."
                    },
                    {
                        "username": "adis176",
                        "content": "so aaaba as word, while our sequence=\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\\nWe should consider each index, where say sequence[i] == word[0]\\nAs it might be the start of our required substring\\nNow 2 main cases possible for given string:\\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\\nOut of all contiguous substrings, lengths we get 2 , 4 = max out of them - 4 ans\\n\\n2nd possibility is\\n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\\n1, 5 = max out of them = 5 ans\\n\\nHence overall max ans = (4, 5) = 5\\n"
                    },
                    {
                        "username": "jadejadej",
                        "content": "so confused."
                    }
                ]
            },
            {
                "id": 1575014,
                "content": [
                    {
                        "username": "user9990f",
                        "content": "One of test case is as follows\\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\"aaaba\"\\nThe judge expects 5. But it looks we have 6 as follows with spaces added.\\n\"aaaba aaaba aaba aaaba aaaba aaaba aaaba\"\\nIs the judge wrong?\\n"
                    },
                    {
                        "username": "ling-lu",
                        "content": "The return value should be concatenated and repeated time, so the result should be 5. \nPlease check this case for more clarification.\n\"aaaba aaab aaaba aaaba aaaba aaaba aaaba\""
                    },
                    {
                        "username": "Raghaav_21",
                        "content": "exactly, answer should be 5. wtf how it can be 6\\n"
                    },
                    {
                        "username": "ma-lacroix",
                        "content": "I had the same thoughts, but take another good look at the string. The correct answer is indeed 5. "
                    },
                    {
                        "username": "uzeconomist0419",
                        "content": "[@sayedHANEEF](/sayedHANEEF)  I have the same problem"
                    },
                    {
                        "username": "harsh3150",
                        "content": "[@sayedHANEEF](/sayedHANEEF) they want a continuous string with max occurrence as output\n\nso aaaba as word we have\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\nwhich will be\n\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\n2 , 4 = 4 ans\n2nd possibility is \n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\n1, 5 = 5 ans \n\nfinal ans = 5. "
                    },
                    {
                        "username": "sayedHANEEF",
                        "content": "I am having the same problem......It should be 6 but they want 5 as a output.\\nDo tell me if u found the reason."
                    },
                    {
                        "username": "jcmf",
                        "content": "I don\\'t understand why everyone says that the answer for aaabaaaabaaabaaaabaaaabaaaabaaaaba should be 6. Shouldn\\'t it be 4? It seems pretty clear from the description that the words need to be consecutive, with nothing in between. It isn\\'t that the sequence needs to contain k separate copies of word, it\\'s that the sequence needs to contain the word concatenated k times -- meaning that the occurrences need to be consecutive, with nothing in between. Am I reading this wrong? Maybe there should be a non-broken example to disambiguate?"
                    },
                    {
                        "username": "ashwani2105",
                        "content": "Try to count it from index 9\\n"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "SAME!!! EXACTLY!!! My output is 4! I don\\'t know why they say 6 either lol "
                    },
                    {
                        "username": "rezl_jaws",
                        "content": "\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\"aaaba\"\\n\\nto me it should be 6 as hightlighted  in bold\\n\\n**aaaba**   **aaaba** aaba **aaaba** **aaaba** **aaaba** **aaaba** \\naaaba\\n\\nWhat do you think guys, mine is failing here as the expected output is apparently 5, would anyone  be able to comment or shed some light as to why  ?"
                    },
                    {
                        "username": "SinghalRishabh",
                        "content": "[@YusenPeng](/YusenPeng) they want a continuous string with max occurrence as output \\n\\nso aaaba as word we have\\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\\n\\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\\n2 , 4 = 4 ans we have to ignore the 1 \\n2nd possibility is\\n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\\n1, 5 = 5 ans\\n\\nfinal ans = 5."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "It should be contiguous because you need to form substring."
                    },
                    {
                        "username": "upretim",
                        "content": "\"aaaba aaaba aaba  aaaba aaaba aaaba aaaba\"\\n\"aaaba\"\\n\\nCorrect answer is 5 for this string, why not 6?"
                    },
                    {
                        "username": "SinghalRishabh",
                        "content": " they want a continuous string with max occurrence as output\\n\\nso aaaba as word we have\\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\\n2 , 4 = 4 ans, so 1 should be ignore\\n2nd possibility is\\n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\\n1, 5 = 5 ans\\n\\nfinal ans = 5."
                    },
                    {
                        "username": "aryonbe",
                        "content": "I think that this problem is not definitely easy.\nsequence = \"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\nword = \"aaaba\"\nMany people commented that the answer for the above case is 6. But it is 5 since the repeating words should be consecutive as described in the description. In the case above it looks like the following. \"aaabaaaab aaaba aaaba aaaba aaaba aaaba\"\nWe can see 5 repeating consecutive \"aaaba\".\nThere is no wrong testcase for this problem."
                    },
                    {
                        "username": "pranavarora724",
                        "content": "Yes , got your point\\nWe just not need to check how many \"aaaba\" are there \\nWe need to check how many consecutive \"aaaba\" are there\\nfor example\\nInput = \"aaabaaaaba\"\\nAns=2 (As they are consecutive)\\ninput = \"aaabaKaaaba\"\\nAns=1 (As there they are not consecutive)"
                    },
                    {
                        "username": "gafurulkazi98",
                        "content": "Regarding \"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\nThe question is confusing and the examples are misleading.\\n\\nIt doesn\\'t want the maximum number of times that you can find the word in the sequence, it wants you to find sections in the sequence where the word is repeating itself, get the number of times the word is repeated in that section, and return the highest number of repeats found in any section.\\n\\nAs harsh3150 has shown,\\n\\nso aaaba as word we have\\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\nwhich will be\\n\\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\\n2 , 4 = 4 ans\\n2nd possibility is\\n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\\n1, 5 = 5 ans\\n\\nfinal ans = 5."
                    },
                    {
                        "username": "SoulSlayer",
                        "content": "By this I mean a very similar problem here:\\n[https://www.spoj.com/problems/TKUDDUS/](https://www.spoj.com/problems/TKUDDUS/)\\n\\nI could come up with a bruteforce (q * N * N) approach which gets TLE\\'d. But apparently there is a O(NlogN) approach which I can\\'t seem to come up with. Any leads would be really helpful."
                    },
                    {
                        "username": "Dani28",
                        "content": "I coded in Python 3. Case 166/211 I got is sequence = \"aaabaaaabaaabaaaabaaaabaaaabaaaaba\" and word = \"aaaba.\" It seems to me that I can find 6 repeating \"aaaba\" that are disjoint if partitioning the sequence like this: \"aaaba aaaba aaba aaaba aaaba aaaba aaaba\" - How come the expected answer is 5??"
                    },
                    {
                        "username": "sayedHANEEF",
                        "content": "PEOPLE BE AWARE OF THIS WRONG TESTCASE:\\nsequence = \"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\nword = \"aaaba\"\\n\\nHERE THEY ARE EXPECTING 5 INSTEAD OF THE ACTUAL ANSWER WHICH IS 6."
                    },
                    {
                        "username": "adis176",
                        "content": "so aaaba as word, while our sequence=\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\\nWe should consider each index, where say sequence[i] == word[0]\\nAs it might be the start of our required substring\\nNow 2 main cases possible for given string:\\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\\nOut of all contiguous substrings, lengths we get 2 , 4 = max out of them - 4 ans\\n\\n2nd possibility is\\n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\\n1, 5 = max out of them = 5 ans\\n\\nHence overall max ans = (4, 5) = 5\\n"
                    },
                    {
                        "username": "jadejadej",
                        "content": "so confused."
                    }
                ]
            },
            {
                "id": 1640890,
                "content": [
                    {
                        "username": "user9990f",
                        "content": "One of test case is as follows\\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\"aaaba\"\\nThe judge expects 5. But it looks we have 6 as follows with spaces added.\\n\"aaaba aaaba aaba aaaba aaaba aaaba aaaba\"\\nIs the judge wrong?\\n"
                    },
                    {
                        "username": "ling-lu",
                        "content": "The return value should be concatenated and repeated time, so the result should be 5. \nPlease check this case for more clarification.\n\"aaaba aaab aaaba aaaba aaaba aaaba aaaba\""
                    },
                    {
                        "username": "Raghaav_21",
                        "content": "exactly, answer should be 5. wtf how it can be 6\\n"
                    },
                    {
                        "username": "ma-lacroix",
                        "content": "I had the same thoughts, but take another good look at the string. The correct answer is indeed 5. "
                    },
                    {
                        "username": "uzeconomist0419",
                        "content": "[@sayedHANEEF](/sayedHANEEF)  I have the same problem"
                    },
                    {
                        "username": "harsh3150",
                        "content": "[@sayedHANEEF](/sayedHANEEF) they want a continuous string with max occurrence as output\n\nso aaaba as word we have\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\nwhich will be\n\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\n2 , 4 = 4 ans\n2nd possibility is \n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\n1, 5 = 5 ans \n\nfinal ans = 5. "
                    },
                    {
                        "username": "sayedHANEEF",
                        "content": "I am having the same problem......It should be 6 but they want 5 as a output.\\nDo tell me if u found the reason."
                    },
                    {
                        "username": "jcmf",
                        "content": "I don\\'t understand why everyone says that the answer for aaabaaaabaaabaaaabaaaabaaaabaaaaba should be 6. Shouldn\\'t it be 4? It seems pretty clear from the description that the words need to be consecutive, with nothing in between. It isn\\'t that the sequence needs to contain k separate copies of word, it\\'s that the sequence needs to contain the word concatenated k times -- meaning that the occurrences need to be consecutive, with nothing in between. Am I reading this wrong? Maybe there should be a non-broken example to disambiguate?"
                    },
                    {
                        "username": "ashwani2105",
                        "content": "Try to count it from index 9\\n"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "SAME!!! EXACTLY!!! My output is 4! I don\\'t know why they say 6 either lol "
                    },
                    {
                        "username": "rezl_jaws",
                        "content": "\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\"aaaba\"\\n\\nto me it should be 6 as hightlighted  in bold\\n\\n**aaaba**   **aaaba** aaba **aaaba** **aaaba** **aaaba** **aaaba** \\naaaba\\n\\nWhat do you think guys, mine is failing here as the expected output is apparently 5, would anyone  be able to comment or shed some light as to why  ?"
                    },
                    {
                        "username": "SinghalRishabh",
                        "content": "[@YusenPeng](/YusenPeng) they want a continuous string with max occurrence as output \\n\\nso aaaba as word we have\\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\\n\\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\\n2 , 4 = 4 ans we have to ignore the 1 \\n2nd possibility is\\n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\\n1, 5 = 5 ans\\n\\nfinal ans = 5."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "It should be contiguous because you need to form substring."
                    },
                    {
                        "username": "upretim",
                        "content": "\"aaaba aaaba aaba  aaaba aaaba aaaba aaaba\"\\n\"aaaba\"\\n\\nCorrect answer is 5 for this string, why not 6?"
                    },
                    {
                        "username": "SinghalRishabh",
                        "content": " they want a continuous string with max occurrence as output\\n\\nso aaaba as word we have\\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\\n2 , 4 = 4 ans, so 1 should be ignore\\n2nd possibility is\\n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\\n1, 5 = 5 ans\\n\\nfinal ans = 5."
                    },
                    {
                        "username": "aryonbe",
                        "content": "I think that this problem is not definitely easy.\nsequence = \"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\nword = \"aaaba\"\nMany people commented that the answer for the above case is 6. But it is 5 since the repeating words should be consecutive as described in the description. In the case above it looks like the following. \"aaabaaaab aaaba aaaba aaaba aaaba aaaba\"\nWe can see 5 repeating consecutive \"aaaba\".\nThere is no wrong testcase for this problem."
                    },
                    {
                        "username": "pranavarora724",
                        "content": "Yes , got your point\\nWe just not need to check how many \"aaaba\" are there \\nWe need to check how many consecutive \"aaaba\" are there\\nfor example\\nInput = \"aaabaaaaba\"\\nAns=2 (As they are consecutive)\\ninput = \"aaabaKaaaba\"\\nAns=1 (As there they are not consecutive)"
                    },
                    {
                        "username": "gafurulkazi98",
                        "content": "Regarding \"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\nThe question is confusing and the examples are misleading.\\n\\nIt doesn\\'t want the maximum number of times that you can find the word in the sequence, it wants you to find sections in the sequence where the word is repeating itself, get the number of times the word is repeated in that section, and return the highest number of repeats found in any section.\\n\\nAs harsh3150 has shown,\\n\\nso aaaba as word we have\\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\nwhich will be\\n\\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\\n2 , 4 = 4 ans\\n2nd possibility is\\n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\\n1, 5 = 5 ans\\n\\nfinal ans = 5."
                    },
                    {
                        "username": "SoulSlayer",
                        "content": "By this I mean a very similar problem here:\\n[https://www.spoj.com/problems/TKUDDUS/](https://www.spoj.com/problems/TKUDDUS/)\\n\\nI could come up with a bruteforce (q * N * N) approach which gets TLE\\'d. But apparently there is a O(NlogN) approach which I can\\'t seem to come up with. Any leads would be really helpful."
                    },
                    {
                        "username": "Dani28",
                        "content": "I coded in Python 3. Case 166/211 I got is sequence = \"aaabaaaabaaabaaaabaaaabaaaabaaaaba\" and word = \"aaaba.\" It seems to me that I can find 6 repeating \"aaaba\" that are disjoint if partitioning the sequence like this: \"aaaba aaaba aaba aaaba aaaba aaaba aaaba\" - How come the expected answer is 5??"
                    },
                    {
                        "username": "sayedHANEEF",
                        "content": "PEOPLE BE AWARE OF THIS WRONG TESTCASE:\\nsequence = \"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\nword = \"aaaba\"\\n\\nHERE THEY ARE EXPECTING 5 INSTEAD OF THE ACTUAL ANSWER WHICH IS 6."
                    },
                    {
                        "username": "adis176",
                        "content": "so aaaba as word, while our sequence=\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\\nWe should consider each index, where say sequence[i] == word[0]\\nAs it might be the start of our required substring\\nNow 2 main cases possible for given string:\\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\\nOut of all contiguous substrings, lengths we get 2 , 4 = max out of them - 4 ans\\n\\n2nd possibility is\\n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\\n1, 5 = max out of them = 5 ans\\n\\nHence overall max ans = (4, 5) = 5\\n"
                    },
                    {
                        "username": "jadejadej",
                        "content": "so confused."
                    }
                ]
            },
            {
                "id": 1574634,
                "content": [
                    {
                        "username": "user9990f",
                        "content": "One of test case is as follows\\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\"aaaba\"\\nThe judge expects 5. But it looks we have 6 as follows with spaces added.\\n\"aaaba aaaba aaba aaaba aaaba aaaba aaaba\"\\nIs the judge wrong?\\n"
                    },
                    {
                        "username": "ling-lu",
                        "content": "The return value should be concatenated and repeated time, so the result should be 5. \nPlease check this case for more clarification.\n\"aaaba aaab aaaba aaaba aaaba aaaba aaaba\""
                    },
                    {
                        "username": "Raghaav_21",
                        "content": "exactly, answer should be 5. wtf how it can be 6\\n"
                    },
                    {
                        "username": "ma-lacroix",
                        "content": "I had the same thoughts, but take another good look at the string. The correct answer is indeed 5. "
                    },
                    {
                        "username": "uzeconomist0419",
                        "content": "[@sayedHANEEF](/sayedHANEEF)  I have the same problem"
                    },
                    {
                        "username": "harsh3150",
                        "content": "[@sayedHANEEF](/sayedHANEEF) they want a continuous string with max occurrence as output\n\nso aaaba as word we have\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\nwhich will be\n\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\n2 , 4 = 4 ans\n2nd possibility is \n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\n1, 5 = 5 ans \n\nfinal ans = 5. "
                    },
                    {
                        "username": "sayedHANEEF",
                        "content": "I am having the same problem......It should be 6 but they want 5 as a output.\\nDo tell me if u found the reason."
                    },
                    {
                        "username": "jcmf",
                        "content": "I don\\'t understand why everyone says that the answer for aaabaaaabaaabaaaabaaaabaaaabaaaaba should be 6. Shouldn\\'t it be 4? It seems pretty clear from the description that the words need to be consecutive, with nothing in between. It isn\\'t that the sequence needs to contain k separate copies of word, it\\'s that the sequence needs to contain the word concatenated k times -- meaning that the occurrences need to be consecutive, with nothing in between. Am I reading this wrong? Maybe there should be a non-broken example to disambiguate?"
                    },
                    {
                        "username": "ashwani2105",
                        "content": "Try to count it from index 9\\n"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "SAME!!! EXACTLY!!! My output is 4! I don\\'t know why they say 6 either lol "
                    },
                    {
                        "username": "rezl_jaws",
                        "content": "\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\"aaaba\"\\n\\nto me it should be 6 as hightlighted  in bold\\n\\n**aaaba**   **aaaba** aaba **aaaba** **aaaba** **aaaba** **aaaba** \\naaaba\\n\\nWhat do you think guys, mine is failing here as the expected output is apparently 5, would anyone  be able to comment or shed some light as to why  ?"
                    },
                    {
                        "username": "SinghalRishabh",
                        "content": "[@YusenPeng](/YusenPeng) they want a continuous string with max occurrence as output \\n\\nso aaaba as word we have\\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\\n\\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\\n2 , 4 = 4 ans we have to ignore the 1 \\n2nd possibility is\\n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\\n1, 5 = 5 ans\\n\\nfinal ans = 5."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "It should be contiguous because you need to form substring."
                    },
                    {
                        "username": "upretim",
                        "content": "\"aaaba aaaba aaba  aaaba aaaba aaaba aaaba\"\\n\"aaaba\"\\n\\nCorrect answer is 5 for this string, why not 6?"
                    },
                    {
                        "username": "SinghalRishabh",
                        "content": " they want a continuous string with max occurrence as output\\n\\nso aaaba as word we have\\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\\n2 , 4 = 4 ans, so 1 should be ignore\\n2nd possibility is\\n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\\n1, 5 = 5 ans\\n\\nfinal ans = 5."
                    },
                    {
                        "username": "aryonbe",
                        "content": "I think that this problem is not definitely easy.\nsequence = \"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\nword = \"aaaba\"\nMany people commented that the answer for the above case is 6. But it is 5 since the repeating words should be consecutive as described in the description. In the case above it looks like the following. \"aaabaaaab aaaba aaaba aaaba aaaba aaaba\"\nWe can see 5 repeating consecutive \"aaaba\".\nThere is no wrong testcase for this problem."
                    },
                    {
                        "username": "pranavarora724",
                        "content": "Yes , got your point\\nWe just not need to check how many \"aaaba\" are there \\nWe need to check how many consecutive \"aaaba\" are there\\nfor example\\nInput = \"aaabaaaaba\"\\nAns=2 (As they are consecutive)\\ninput = \"aaabaKaaaba\"\\nAns=1 (As there they are not consecutive)"
                    },
                    {
                        "username": "gafurulkazi98",
                        "content": "Regarding \"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\nThe question is confusing and the examples are misleading.\\n\\nIt doesn\\'t want the maximum number of times that you can find the word in the sequence, it wants you to find sections in the sequence where the word is repeating itself, get the number of times the word is repeated in that section, and return the highest number of repeats found in any section.\\n\\nAs harsh3150 has shown,\\n\\nso aaaba as word we have\\n\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\nwhich will be\\n\\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\\n2 , 4 = 4 ans\\n2nd possibility is\\n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\\n1, 5 = 5 ans\\n\\nfinal ans = 5."
                    },
                    {
                        "username": "SoulSlayer",
                        "content": "By this I mean a very similar problem here:\\n[https://www.spoj.com/problems/TKUDDUS/](https://www.spoj.com/problems/TKUDDUS/)\\n\\nI could come up with a bruteforce (q * N * N) approach which gets TLE\\'d. But apparently there is a O(NlogN) approach which I can\\'t seem to come up with. Any leads would be really helpful."
                    },
                    {
                        "username": "Dani28",
                        "content": "I coded in Python 3. Case 166/211 I got is sequence = \"aaabaaaabaaabaaaabaaaabaaaabaaaaba\" and word = \"aaaba.\" It seems to me that I can find 6 repeating \"aaaba\" that are disjoint if partitioning the sequence like this: \"aaaba aaaba aaba aaaba aaaba aaaba aaaba\" - How come the expected answer is 5??"
                    },
                    {
                        "username": "sayedHANEEF",
                        "content": "PEOPLE BE AWARE OF THIS WRONG TESTCASE:\\nsequence = \"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\nword = \"aaaba\"\\n\\nHERE THEY ARE EXPECTING 5 INSTEAD OF THE ACTUAL ANSWER WHICH IS 6."
                    },
                    {
                        "username": "adis176",
                        "content": "so aaaba as word, while our sequence=\"aaabaaaabaaabaaaabaaaabaaaabaaaaba\"\\n\\nWe should consider each index, where say sequence[i] == word[0]\\nAs it might be the start of our required substring\\nNow 2 main cases possible for given string:\\n(aaaba aaaba) aaba (aaaba aaaba aaaba aaaba)\\nOut of all contiguous substrings, lengths we get 2 , 4 = max out of them - 4 ans\\n\\n2nd possibility is\\n(aaaba) aaab (aaaba aaaba aaaba aaaba aaaba)\\n1, 5 = max out of them = 5 ans\\n\\nHence overall max ans = (4, 5) = 5\\n"
                    },
                    {
                        "username": "jadejadej",
                        "content": "so confused."
                    }
                ]
            }
        ]
    }
]