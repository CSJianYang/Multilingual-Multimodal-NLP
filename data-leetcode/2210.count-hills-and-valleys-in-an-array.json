[
    {
        "title": "Count Hills and Valleys in an Array",
        "question_content": "You are given a 0-indexed integer array nums. An index i is part of a hill in nums if the closest non-equal neighbors of i are smaller than nums[i]. Similarly, an index i is part of a valley in nums if the closest non-equal neighbors of i are larger than nums[i]. Adjacent indices i and j are part of the same hill or valley if nums[i] == nums[j].\nNote that for an index to be part of a hill or valley, it must have a non-equal neighbor on both the left and right of the index.\nReturn the number of hills and valleys in nums.\n&nbsp;\nExample 1:\n\nInput: nums = [2,4,1,1,6,5]\nOutput: 3\nExplanation:\nAt index 0: There is no non-equal neighbor of 2 on the left, so index 0 is neither a hill nor a valley.\nAt index 1: The closest non-equal neighbors of 4 are 2 and 1. Since 4 > 2 and 4 > 1, index 1 is a hill. \nAt index 2: The closest non-equal neighbors of 1 are 4 and 6. Since 1 < 4 and 1 < 6, index 2 is a valley.\nAt index 3: The closest non-equal neighbors of 1 are 4 and 6. Since 1 < 4 and 1 < 6, index 3 is a valley, but note that it is part of the same valley as index 2.\nAt index 4: The closest non-equal neighbors of 6 are 1 and 5. Since 6 > 1 and 6 > 5, index 4 is a hill.\nAt index 5: There is no non-equal neighbor of 5 on the right, so index 5 is neither a hill nor a valley. \nThere are 3 hills and valleys so we return 3.\n\nExample 2:\n\nInput: nums = [6,6,5,5,4,1]\nOutput: 0\nExplanation:\nAt index 0: There is no non-equal neighbor of 6 on the left, so index 0 is neither a hill nor a valley.\nAt index 1: There is no non-equal neighbor of 6 on the left, so index 1 is neither a hill nor a valley.\nAt index 2: The closest non-equal neighbors of 5 are 6 and 4. Since 5 < 6 and 5 > 4, index 2 is neither a hill nor a valley.\nAt index 3: The closest non-equal neighbors of 5 are 6 and 4. Since 5 < 6 and 5 > 4, index 3 is neither a hill nor a valley.\nAt index 4: The closest non-equal neighbors of 4 are 5 and 1. Since 4 < 5 and 4 > 1, index 4 is neither a hill nor a valley.\nAt index 5: There is no non-equal neighbor of 1 on the right, so index 5 is neither a hill nor a valley.\nThere are 0 hills and valleys so we return 0.\n\n&nbsp;\nConstraints:\n\n\t3 <= nums.length <= 100\n\t1 <= nums[i] <= 100",
        "solutions": [
            {
                "id": 1879182,
                "title": "two-pointers",
                "content": "Duplicates could be tricky to handle. For that, we use a second pointer (`j`), which we update only when we detect a hill or a valley.\\n\\n**C++**\\n```cpp\\nint countHillValley(vector<int>& nums) {\\n    int res = 0;\\n    for (int i = 1, j = 0; i < nums.size() - 1; ++i)\\n        if ((nums[j] < nums[i] && nums[i] > nums [i + 1]) || \\n            (nums[j] > nums[i] && nums[i] < nums [i + 1])) {\\n            ++res;\\n            j = i;\\n        }            \\n    return res;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint countHillValley(vector<int>& nums) {\\n    int res = 0;\\n    for (int i = 1, j = 0; i < nums.size() - 1; ++i)\\n        if ((nums[j] < nums[i] && nums[i] > nums [i + 1]) || \\n            (nums[j] > nums[i] && nums[i] < nums [i + 1])) {\\n            ++res;\\n            j = i;\\n        }            \\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1865693,
                "title": "java-one-pass-7-lines-o-1-space",
                "content": "```java\\n public int countHillValley(int[] a){\\n        int r = 0, left = a[0];\\n        for(int i = 1; i < a.length - 1; i++)\\n            if(left < a[i] && a[i] > a[i + 1] || left > a[i] && a[i] < a[i + 1]){\\n                r++;\\n                left = a[i];\\n            }\\n        return r;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\n public int countHillValley(int[] a){\\n        int r = 0, left = a[0];\\n        for(int i = 1; i < a.length - 1; i++)\\n            if(left < a[i] && a[i] > a[i + 1] || left > a[i] && a[i] < a[i + 1]){\\n                r++;\\n                left = a[i];\\n            }\\n        return r;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1866831,
                "title": "python-clean-solution-simple-and-easy",
                "content": "We start by taking a for loop which goes from 1 to length of array -1.\\nSince we cannot take 2 adjacent values such that nums[i] == nums[j]. \\nSo, we update the current value to previous value which will help us in counting the next hill or valley. \\n\\nTime complexity = O(n)\\nSpace complexity = O(1)\\n\\n```class Solution:\\n    def countHillValley(self, nums: List[int]) -> int:\\n        hillValley = 0\\n        for i in range(1, len(nums)-1):\\n            if nums[i] == nums[i+1]:\\n                nums[i] = nums[i-1]\\n            if nums[i] > nums[i-1] and nums[i] > nums[i+1]:     #hill check\\n                hillValley += 1\\n            if nums[i] < nums[i-1] and nums[i] < nums[i+1]:     #valley check\\n                hillValley += 1\\n        return hillValley\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```class Solution:\\n    def countHillValley(self, nums: List[int]) -> int:\\n        hillValley = 0\\n        for i in range(1, len(nums)-1):\\n            if nums[i] == nums[i+1]:\\n                nums[i] = nums[i-1]\\n            if nums[i] > nums[i-1] and nums[i] > nums[i+1]:     #hill check\\n                hillValley += 1\\n            if nums[i] < nums[i-1] and nums[i] < nums[i+1]:     #valley check\\n                hillValley += 1\\n        return hillValley\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1865624,
                "title": "count-hills-and-valleys-in-an-array-c-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n\\t// taking a new vector\\n        vector<int>v;\\n        v.push_back(nums[0]);\\n\\t\\t//pushing unique elements into new vector\\n        for(int i=1;i<nums.size();i++){\\n            if(nums[i]!=nums[i-1]){\\n                v.push_back(nums[i]);\\n            }\\n        }\\n        int c=0;\\n\\t\\t//checking for valley or hill\\n        for(int i=1;i<v.size()-1;i++){\\n            if(v[i]>v[i-1] and v[i]>v[i+1] or v[i]<v[i-1] and v[i]<v[i+1]){\\n                c++;\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n\\t// taking a new vector\\n        vector<int>v;\\n        v.push_back(nums[0]);\\n\\t\\t//pushing unique elements into new vector\\n        for(int i=1;i<nums.size();i++){\\n            if(nums[i]!=nums[i-1]){\\n                v.push_back(nums[i]);\\n            }\\n        }\\n        int c=0;\\n\\t\\t//checking for valley or hill\\n        for(int i=1;i<v.size()-1;i++){\\n            if(v[i]>v[i-1] and v[i]>v[i+1] or v[i]<v[i-1] and v[i]<v[i+1]){\\n                c++;\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1865635,
                "title": "java-single-pass-solution-with-comments-o-n-time-o-1-space",
                "content": "\\n    class Solution {\\n        public int countHillValley(int[] nums) {\\n            int result = 0;\\n        \\n\\t\\t\\t// Get head start. Find first index for which nums[index] != nums[index-1]\\n\\t\\t\\tint start = 1;\\n\\t\\t\\twhile(start < nums.length && nums[start] == nums[start-1])\\n\\t\\t\\t\\tstart++;\\n\\n\\t\\t\\tint prev = start-1; //index of prev different value num\\n\\t\\t\\tfor(int i=start; i<nums.length-1; i++) {\\n\\t\\t\\t\\tif(nums[i] == nums[i+1]) //If numbers are same, simply ignore them\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\tif(nums[i] > nums[prev] && nums[i] > nums[i+1]) //compare current num with prev number and next number\\n\\t\\t\\t\\t\\t\\tresult++;\\n\\t\\t\\t\\t\\tif(nums[i] < nums[prev] && nums[i] < nums[i+1])\\n\\t\\t\\t\\t\\t\\tresult++;\\n\\t\\t\\t\\t\\tprev = i;   // Now your current number will become prev number.\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn result;\\n\\t\\t}\\n\\t}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public int countHillValley(int[] nums) {\\n            int result = 0;\\n        \\n\\t\\t\\t// Get head start. Find first index for which nums[index] != nums[index-1]\\n\\t\\t\\tint start = 1;\\n\\t\\t\\twhile(start < nums.length && nums[start] == nums[start-1])\\n\\t\\t\\t\\tstart++;\\n\\n\\t\\t\\tint prev = start-1; //index of prev different value num\\n\\t\\t\\tfor(int i=start; i<nums.length-1; i++) {\\n\\t\\t\\t\\tif(nums[i] == nums[i+1]) //If numbers are same, simply ignore them\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\tif(nums[i] > nums[prev] && nums[i] > nums[i+1]) //compare current num with prev number and next number\\n\\t\\t\\t\\t\\t\\tresult++;\\n\\t\\t\\t\\t\\tif(nums[i] < nums[prev] && nums[i] < nums[i+1])\\n\\t\\t\\t\\t\\t\\tresult++;\\n\\t\\t\\t\\t\\tprev = i;   // Now your current number will become prev number.\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1865658,
                "title": "easiest-c-solution-two-pointers",
                "content": "```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        int ans = 0, n = nums.size();\\n        for(int i = 1; i < n; i++){\\n            if(nums[i] == nums[i-1]) continue; //  same hill or valley\\n            \\n            int idx = i - 1, jdx = i + 1;\\n            while(idx >= 0 && nums[idx] == nums[i]) idx--;\\n            if(idx < 0) continue; // no left neighbour found\\n\\t\\t\\t\\n            while(jdx < n && nums[jdx] == nums[i]) jdx++;\\n            if(jdx == n) continue; // no right neighbour found\\n            \\n            if(nums[idx] < nums[i] && nums[jdx] < nums[i]) ans++;\\n            else if(nums[idx] > nums[i] && nums[jdx] > nums[i]) ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        int ans = 0, n = nums.size();\\n        for(int i = 1; i < n; i++){\\n            if(nums[i] == nums[i-1]) continue; //  same hill or valley\\n            \\n            int idx = i - 1, jdx = i + 1;\\n            while(idx >= 0 && nums[idx] == nums[i]) idx--;\\n            if(idx < 0) continue; // no left neighbour found\\n\\t\\t\\t\\n            while(jdx < n && nums[jdx] == nums[i]) jdx++;\\n            if(jdx == n) continue; // no right neighbour found\\n            \\n            if(nums[idx] < nums[i] && nums[jdx] < nums[i]) ans++;\\n            else if(nums[idx] > nums[i] && nums[jdx] > nums[i]) ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1866666,
                "title": "count-hills-and-valleys-java-space-o-1-time-o-n-simple-solution",
                "content": "Problem: Finding the non-equal nearest neighbours on both the sides of an array element and comparing those values to decide a peak or valley. It is simple if we there are no duplicate values next to each.\\n\\nFor the adjacent duplicates we have to keep track of the closest neighbour on left and not update it till duplicates are crossed. \\n\\nOnce the adjacent duplicates are done, we can update it for the newer values .\\n\\n```\\npublic int countHillValley(int[] nums) {\\n        int ans = 0;\\n        int prev = nums[0];\\n        for(int i = 1; i < nums.length-1; i++){\\n            if((nums[i] > nums[i+1] && nums[i] > prev || (nums[i] < nums[i+1] && nums[i] < prev)))\\n                ans++;\\n            if(nums[i] != nums[i+1]){\\n                prev = nums[i];\\n            }\\n        }\\n        return ans;\\n    }\\n\\t```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\npublic int countHillValley(int[] nums) {\\n        int ans = 0;\\n        int prev = nums[0];\\n        for(int i = 1; i < nums.length-1; i++){\\n            if((nums[i] > nums[i+1] && nums[i] > prev || (nums[i] < nums[i+1] && nums[i] < prev)))\\n                ans++;\\n            if(nums[i] != nums[i+1]){\\n                prev = nums[i];\\n            }\\n        }\\n        return ans;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 1865655,
                "title": "python3-single-pass-o-n-time-o-1-space",
                "content": "```\\nclass Solution:\\n    def countHillValley(self, nums: List[int]) -> int:\\n        res = 0\\n        candidate = last_num = None\\n        \\n        for i in range(1, len(nums)):\\n            if nums[i] != nums[i-1]:\\n                if candidate and ((candidate > last_num and candidate > nums[i]) or (candidate < last_num and candidate < nums[i])):\\n                    res += 1\\n                candidate = nums[i]\\n                last_num = nums[i-1]\\n                    \\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countHillValley(self, nums: List[int]) -> int:\\n        res = 0\\n        candidate = last_num = None\\n        \\n        for i in range(1, len(nums)):\\n            if nums[i] != nums[i-1]:\\n                if candidate and ((candidate > last_num and candidate > nums[i]) or (candidate < last_num and candidate < nums[i])):\\n                    res += 1\\n                candidate = nums[i]\\n                last_num = nums[i-1]\\n                    \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1868487,
                "title": "javascript-filter-loop",
                "content": "By removing side-by-side duplicates, we can shorten the array and remove the need for code that would tell us if a number was part of a previous valley or hill. We then have our loop ignore the edges of the array, as our code tests each number against the one before & after it.\\n\\n```\\nvar countHillValley = function(nums) {\\n    let answer = 0;\\n    nums = nums.filter((a, i, b) => a !== b[i + 1]); // Remove Flatlands\\n    for (let i = 1; i < nums.length - 1; i++) {\\n        if (nums[i - 1] > nums [i] && nums[i] < nums[i + 1]) answer++; // Valley\\n        if (nums[i - 1] < nums [i] && nums[i] > nums[i + 1]) answer++; // Hill\\n    }\\n    return answer;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar countHillValley = function(nums) {\\n    let answer = 0;\\n    nums = nums.filter((a, i, b) => a !== b[i + 1]); // Remove Flatlands\\n    for (let i = 1; i < nums.length - 1; i++) {\\n        if (nums[i - 1] > nums [i] && nums[i] < nums[i + 1]) answer++; // Valley\\n        if (nums[i - 1] < nums [i] && nums[i] > nums[i + 1]) answer++; // Hill\\n    }\\n    return answer;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1865568,
                "title": "c-python-js-simple-explained-o-n-faster-than-100",
                "content": "The idea of this problem is pretty simple, we wish to count the number of Valleys and Hills in the array.\\nThe solution used in this problem is focused on simplicity and being easy to understand.\\nThis is O(n) time complexity, and O(n) memory complexity.\\n\\n**Strategy:**\\n\\nSo, to find if a number is a hill or a valley, we need to see if the neighboring values that aren\\'t the same are both an increase or decrease relative to this number.\\n\\nStep 1:\\n\\nMake sure that there are no neighboring nodes of the same values, so turning something like ``[6,7,7,7,8,8,9,2] -> [6,7,8,9,2]``.\\n\\nStep 2:\\n\\nLoop through the array starting at the 2nd index and up to the 2nd last index, and increase the return value if a nodes neighbors are both greater than or less than the node.\\n\\n**Solution:**\\n\\n**C++**\\n\\n```\\nint countHillValley(vector<int>& ns) {\\n    //Step 1\\n    std::vector<int> nums;\\n    int l = ns[0];\\n    nums.push_back(l);\\n    for (int n : ns) {\\n        if (n != l) {\\n            nums.push_back(n);\\n            l = n;\\n        }\\n    }\\n        \\n    //Step 2.\\n    int ret = 0;\\n    for (int i = 1; i < nums.size() - 1; i++) {\\n        if (nums[i-1] < nums[i] == nums[i+1] < nums[i]) ret++;\\n    }\\n    return ret;\\n}\\n```\\n\\n**Python**\\n\\n```\\ndef countHillValley(self, ns: List[int]) -> int:\\n    #Step 1\\n    nums = []\\n    l = ns[0]\\n    nums.append(l)\\n    for n in ns:\\n        if n != l:\\n            nums.append(n)\\n            l = n\\n                \\n    #Step 2\\n    ret = 0\\n    for i in range (1, len(nums) - 1):\\n        if ((nums[i-1] < nums[i]) == (nums[i+1] < nums[i])):\\n             ret += 1\\n            \\n    return ret\\n```\\n\\n**Javascript**\\n\\n```\\nvar countHillValley = function(ns) {\\n    //Step 1\\n    nums = [];\\n    let l = ns[0];\\n    nums.push(l);\\n    for (let i = 0; i < ns.length; i++) {\\n        n = ns[i];\\n        if (n != l) {\\n            l = n;\\n            nums.push(n);\\n        }\\n    }\\n\\n    \\n    //Step 2\\n    let ret = 0;\\n    for (let i = 1; i < nums.length - 1; i++) {\\n        if (nums[i-1] < nums[i] == nums[i+1] < nums[i]) ret++;\\n    }\\n    \\n    return ret;        \\n};\\n```\\n",
                "solutionTags": [
                    "Python",
                    "C",
                    "JavaScript"
                ],
                "code": "```\\nint countHillValley(vector<int>& ns) {\\n    //Step 1\\n    std::vector<int> nums;\\n    int l = ns[0];\\n    nums.push_back(l);\\n    for (int n : ns) {\\n        if (n != l) {\\n            nums.push_back(n);\\n            l = n;\\n        }\\n    }\\n        \\n    //Step 2.\\n    int ret = 0;\\n    for (int i = 1; i < nums.size() - 1; i++) {\\n        if (nums[i-1] < nums[i] == nums[i+1] < nums[i]) ret++;\\n    }\\n    return ret;\\n}\\n```\n```\\ndef countHillValley(self, ns: List[int]) -> int:\\n    #Step 1\\n    nums = []\\n    l = ns[0]\\n    nums.append(l)\\n    for n in ns:\\n        if n != l:\\n            nums.append(n)\\n            l = n\\n                \\n    #Step 2\\n    ret = 0\\n    for i in range (1, len(nums) - 1):\\n        if ((nums[i-1] < nums[i]) == (nums[i+1] < nums[i])):\\n             ret += 1\\n            \\n    return ret\\n```\n```\\nvar countHillValley = function(ns) {\\n    //Step 1\\n    nums = [];\\n    let l = ns[0];\\n    nums.push(l);\\n    for (let i = 0; i < ns.length; i++) {\\n        n = ns[i];\\n        if (n != l) {\\n            l = n;\\n            nums.push(n);\\n        }\\n    }\\n\\n    \\n    //Step 2\\n    let ret = 0;\\n    for (let i = 1; i < nums.length - 1; i++) {\\n        if (nums[i-1] < nums[i] == nums[i+1] < nums[i]) ret++;\\n    }\\n    \\n    return ret;        \\n};\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1868034,
                "title": "my-easy-java-solution",
                "content": "Only move the previous pointer when we have a hill or valley.\\nElse keep that pointer, never move it.\\n\\n```\\nclass Solution {\\n    public int countHillValley(int[] nums) {\\n        int length = nums.length;\\n        int countHillValley = 0;\\n        int previous = nums[0];\\n        for (int i = 1; i < length - 1; i++) {\\n            if (previous < nums[i] && nums[i] > nums[i + 1] || previous > nums[i] && nums[i] < nums[i + 1]) {\\n                previous = nums[i];\\n                countHillValley++;\\n            }\\n        }\\n        return countHillValley;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countHillValley(int[] nums) {\\n        int length = nums.length;\\n        int countHillValley = 0;\\n        int previous = nums[0];\\n        for (int i = 1; i < length - 1; i++) {\\n            if (previous < nums[i] && nums[i] > nums[i + 1] || previous > nums[i] && nums[i] < nums[i + 1]) {\\n                previous = nums[i];\\n                countHillValley++;\\n            }\\n        }\\n        return countHillValley;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1867081,
                "title": "java-clean-code",
                "content": "```\\npublic int countHillValley(int[] nums) {\\n        int left = nums[0];\\n        int result = 0;\\n\\n        for (int i = 1; i < nums.length - 1; i++) {\\n            if (isHill(left, nums[i], nums[i + 1]) || isValley(left, nums[i], nums[i + 1])) {\\n                result++;\\n                left = nums[i];\\n            }\\n        }\\n        return result;\\n    }\\n\\n    private boolean isHill(int left, int value, int right) {\\n        return value > left && value > right;\\n    }\\n\\n    private boolean isValley(int left, int value, int right) {\\n        return value < left && value < right;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int countHillValley(int[] nums) {\\n        int left = nums[0];\\n        int result = 0;\\n\\n        for (int i = 1; i < nums.length - 1; i++) {\\n            if (isHill(left, nums[i], nums[i + 1]) || isValley(left, nums[i], nums[i + 1])) {\\n                result++;\\n                left = nums[i];\\n            }\\n        }\\n        return result;\\n    }\\n\\n    private boolean isHill(int left, int value, int right) {\\n        return value > left && value > right;\\n    }\\n\\n    private boolean isValley(int left, int value, int right) {\\n        return value < left && value < right;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1867075,
                "title": "c-6-lines-with-std-erase-and-std-unique-2-lines-using-count-if",
                "content": "```cpp\\nint countHillValley(vector<int>& nums) {\\n\\tnums.erase(unique(nums.begin(), nums.end()), nums.end()); // this removes equal adjacent numbers\\n\\tint n = 0;\\n\\tfor(int i = 1; i < nums.size() -1; ++i)\\n\\t\\tn += (nums[i-1] < nums[i] && nums[i] > nums[i+1])  // hill\\n\\t\\t  || (nums[i-1] > nums[i] && nums[i] < nums[i+1]); // valley\\n\\treturn n;\\n}\\n```\\n\\nAs suggested by @izackwu, detection of hill or valley can be reduced :\\n```cpp\\nint countHillValley(vector<int>& nums) {\\n\\tnums.erase(unique(nums.begin(), nums.end()), nums.end()); // this removes equal adjacent numbers\\n\\tint n = 0;\\n\\tfor(int i = 1; i < nums.size() -1; ++i)\\n\\t\\tn += (nums[i - 1] > nums[i]) == (nums[i] < nums[i + 1]); // hill or valley\\n   return n;\\n}\\n```\\n\\nJust for the fun of ccode golfing, we can even drop it to 2 lines using (or abusing) `std::count_if` :\\n\\n```cpp\\nint countHillValley(vector<int>& nums) {\\n\\tnums.erase(unique(nums.begin(), nums.end()), nums.end()); \\n\\treturn nums.size()>2?count_if(next(nums.begin()), prev(nums.end()),[](const int& a) {return (*(&a-1) > a) == (a < *(&a+1));}):0;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nint countHillValley(vector<int>& nums) {\\n\\tnums.erase(unique(nums.begin(), nums.end()), nums.end()); // this removes equal adjacent numbers\\n\\tint n = 0;\\n\\tfor(int i = 1; i < nums.size() -1; ++i)\\n\\t\\tn += (nums[i-1] < nums[i] && nums[i] > nums[i+1])  // hill\\n\\t\\t  || (nums[i-1] > nums[i] && nums[i] < nums[i+1]); // valley\\n\\treturn n;\\n}\\n```\n```cpp\\nint countHillValley(vector<int>& nums) {\\n\\tnums.erase(unique(nums.begin(), nums.end()), nums.end()); // this removes equal adjacent numbers\\n\\tint n = 0;\\n\\tfor(int i = 1; i < nums.size() -1; ++i)\\n\\t\\tn += (nums[i - 1] > nums[i]) == (nums[i] < nums[i + 1]); // hill or valley\\n   return n;\\n}\\n```\n```cpp\\nint countHillValley(vector<int>& nums) {\\n\\tnums.erase(unique(nums.begin(), nums.end()), nums.end()); \\n\\treturn nums.size()>2?count_if(next(nums.begin()), prev(nums.end()),[](const int& a) {return (*(&a-1) > a) == (a < *(&a+1));}):0;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2552317,
                "title": "python-clean-concise-short-and-simple",
                "content": "You will be able to understand the solution using the comments. \\nLet me know if any questions. \\n\\n```\\nclass Solution:\\n    def countHillValley(self, nums: List[int]) -> int:\\n        hillValley  = 0 \\n\\t\\t\\n\\t\\t#Here we will keep track of the left neighbour \\n        #Initially left neighbour is the 0th element. \\n        leftNeighbour = nums[0]\\n        \\n        #We will apply a loop from 1st index to second last index becuase for any element to be a \\n        #hill or a valley it must have both neighbours. \\n        for i in range(1, len(nums) - 1):\\n            \\n            #If both the left neighbour and right element are greater that it is a valley.\\n            #We incerement count and also we will update the left neighbour to current element. \\n            if nums[i]<nums[i+1] and nums[i]<leftNeighbour:\\n                leftNeighbour = nums[i]\\n                hillValley  += 1\\n            \\n            #If both the left neighbour and right element are smaller that it is a hill.\\n            #We incerement count and also we will update the left neighbour to current element. \\n            if nums[i]>nums[i+1] and nums[i]>leftNeighbour:\\n                leftNeighbour = nums[i]\\n                hillValley  += 1\\n                \\n        return hillValley\\n```\\n\\nWe can also have another solution in which we update the left neighbour in a different way:\\n\\n```\\nclass Solution:\\n    def countHillValley(self, nums: List[int]) -> int:\\n        #Here we will keep track of the left neighbour \\n        hillValley  = 0 \\n        #Initially left neighbour is the left 0th element. \\n        leftNeighbour = nums[0]\\n        \\n        #We will apply a loop from 1st index to second last index becuase for any element to be a \\n        #hill or a valley it must have both neighbours. \\n        for i in range(1, len(nums) - 1):\\n            \\n            #If both the left neighbour and right element are greater that it is a valley.\\n            if nums[i]<nums[i+1] and nums[i]<leftNeighbour:\\n                hillValley  += 1\\n            \\n            #If both the left neighbour and right element are smaller that it is a hill. \\n            if nums[i]>nums[i+1] and nums[i]>leftNeighbour:\\n                hillValley  += 1\\n            \\n            #If current element and next element are not same then current element will be the \\n            #left neighbour for next element\\n            #If not then the old left neighbour will continue.            \\n            if nums[i] != nums[i+1]:\\n                leftNeighbour = nums[i]\\n                \\n        return hillValley \\n\\t\\t",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def countHillValley(self, nums: List[int]) -> int:\\n        hillValley  = 0 \\n\\t\\t\\n\\t\\t#Here we will keep track of the left neighbour \\n        #Initially left neighbour is the 0th element. \\n        leftNeighbour = nums[0]\\n        \\n        #We will apply a loop from 1st index to second last index becuase for any element to be a \\n        #hill or a valley it must have both neighbours. \\n        for i in range(1, len(nums) - 1):\\n            \\n            #If both the left neighbour and right element are greater that it is a valley.\\n            #We incerement count and also we will update the left neighbour to current element. \\n            if nums[i]<nums[i+1] and nums[i]<leftNeighbour:\\n                leftNeighbour = nums[i]\\n                hillValley  += 1\\n            \\n            #If both the left neighbour and right element are smaller that it is a hill.\\n            #We incerement count and also we will update the left neighbour to current element. \\n            if nums[i]>nums[i+1] and nums[i]>leftNeighbour:\\n                leftNeighbour = nums[i]\\n                hillValley  += 1\\n                \\n        return hillValley\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2528962,
                "title": "python-easy-o-n-solution",
                "content": "```\\nclass Solution:\\n    def countHillValley(self, nums: List[int]) -> int:\\n        increasing, changed = -1, 0\\n        for i in range(1, len(nums)):\\n            if nums[i] > nums[i - 1]:\\n                changed += int(increasing == 0)\\n                increasing = 1\\n            elif nums[i] < nums[i - 1]:\\n                changed += int(increasing == 1)\\n                increasing = 0\\n        return changed\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def countHillValley(self, nums: List[int]) -> int:\\n        increasing, changed = -1, 0\\n        for i in range(1, len(nums)):\\n            if nums[i] > nums[i - 1]:\\n                changed += int(increasing == 0)\\n                increasing = 1\\n            elif nums[i] < nums[i - 1]:\\n                changed += int(increasing == 1)\\n                increasing = 0\\n        return changed\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1865653,
                "title": "python-simple-iteration-o-n",
                "content": "```\\nclass Solution:\\n    def countHillValley(self, nums: List[int]) -> int:\\n        c = 0\\n        i = 1\\n        while i <len(nums)-1:\\n            j = i+1\\n            while j < len(nums)-1 and nums[j] == nums[i]:\\n                j += 1\\n            if (nums[i-1] > nums[i] and nums[j] > nums[i]) or (nums[i-1] < nums[i] and nums[j] < nums[i]):\\n                    c += 1\\n            i = j\\n        return c\\n ```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def countHillValley(self, nums: List[int]) -> int:\\n        c = 0\\n        i = 1\\n        while i <len(nums)-1:\\n            j = i+1\\n            while j < len(nums)-1 and nums[j] == nums[i]:\\n                j += 1\\n            if (nums[i-1] > nums[i] and nums[j] > nums[i]) or (nums[i-1] < nums[i] and nums[j] < nums[i]):\\n                    c += 1\\n            i = j\\n        return c\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 2595420,
                "title": "java-array-faster-than-100-java-submissions",
                "content": "```\\nclass Solution {\\n    public int countHillValley(int[] a){\\n        int r=0,left=a[0];\\n        for(int i=1;i<a.length-1;i++){\\n            if(left<a[i] && a[i]>a[i+1] || left>a[i] && a[i]<a[i+1]){\\n                r++;\\n                left=a[i];\\n            }\\n        }\\n        return r;\\n    }\\n}\\n```\\nKindly upvote if you like the code.",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\n    public int countHillValley(int[] a){\\n        int r=0,left=a[0];\\n        for(int i=1;i<a.length-1;i++){\\n            if(left<a[i] && a[i]>a[i+1] || left>a[i] && a[i]<a[i+1]){\\n                r++;\\n                left=a[i];\\n            }\\n        }\\n        return r;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1866869,
                "title": "python3-one-pass-o-1-space",
                "content": "```\\nclass Solution:\\n    def countHillValley(self, nums: List[int]) -> int:\\n        \\n        #cnt: An integer to store total hills and valleys\\n        #left: Highest point of hill or lowest point of valley left of the current index\\n        cnt, left = 0, nums[0]\\n        \\n        for i in range(1, len(nums)-1):\\n            if (left<nums[i] and nums[i]>nums[i+1]) or (left>nums[i] and nums[i]<nums[i+1]):\\n                cnt+=1\\n                left=nums[i]\\n        return cnt\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countHillValley(self, nums: List[int]) -> int:\\n        \\n        #cnt: An integer to store total hills and valleys\\n        #left: Highest point of hill or lowest point of valley left of the current index\\n        cnt, left = 0, nums[0]\\n        \\n        for i in range(1, len(nums)-1):\\n            if (left<nums[i] and nums[i]>nums[i+1]) or (left>nums[i] and nums[i]<nums[i+1]):\\n                cnt+=1\\n                left=nums[i]\\n        return cnt\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1866196,
                "title": "c-easy-to-understand-beginners-friendly-using-pointer",
                "content": "**Please upvote if it helps **\\n\\n```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) \\n    {\\n        int ans = 0;                   // for storing the final result\\n        int k = -1;                    // it is used as a pointer for the new creating nums without duplicaccy\\n        int size = 0;                  // it will store the size of new nums \\n    \\n        //eliminating duplicates from the array\\n        for(int i = 0; i<nums.size(); i++)\\n        {\\n            if(k == -1 or nums[k]!=nums[i])       // k==-1 means first element and if there is no duplicaccy then  \\n            {\\n                size++;                           // increase the size\\n                nums[k+1] = nums[i];              // assign the i to k+1\\n                k++;                              // move pointer to the next\\n            }\\n        }\\n    \\n        for(int i = 1; i<size-1; i++)\\n        {\\n            // H  ills\\n            if((nums[i]>nums[i+1] and nums[i]>nums[i-1]))\\n            {\\n                ans++;\\n            }\\n            \\n            // Valleys\\n            if((nums[i]<nums[i+1] and nums[i]<nums[i-1]))\\n            {\\n                ans++;\\n            }\\n        }\\n    \\n        return ans;\\n    }\\n};\\n```\\n**Please upvote if it helps **",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) \\n    {\\n        int ans = 0;                   // for storing the final result\\n        int k = -1;                    // it is used as a pointer for the new creating nums without duplicaccy\\n        int size = 0;                  // it will store the size of new nums \\n    \\n        //eliminating duplicates from the array\\n        for(int i = 0; i<nums.size(); i++)\\n        {\\n            if(k == -1 or nums[k]!=nums[i])       // k==-1 means first element and if there is no duplicaccy then  \\n            {\\n                size++;                           // increase the size\\n                nums[k+1] = nums[i];              // assign the i to k+1\\n                k++;                              // move pointer to the next\\n            }\\n        }\\n    \\n        for(int i = 1; i<size-1; i++)\\n        {\\n            // H  ills\\n            if((nums[i]>nums[i+1] and nums[i]>nums[i-1]))\\n            {\\n                ans++;\\n            }\\n            \\n            // Valleys\\n            if((nums[i]<nums[i+1] and nums[i]<nums[i-1]))\\n            {\\n                ans++;\\n            }\\n        }\\n    \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3576588,
                "title": "tail-pointer",
                "content": "# \\uD83D\\uDE09Don\\'t just watch & move away, also give an Upvote.\\uD83D\\uDE09\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        int n = size(nums);\\n        int count=0;\\n        int i=1,j=0; // j is a tail pointer\\n        for(i=1; i<n-1; i++)\\n        {\\n            if(nums[j] < nums[i] && nums[i] > nums[i+1]){\\n                count++;\\n                j = i;\\n            }\\n            else if(nums[j] > nums[i] && nums[i] < nums[i+1]){\\n                count++;\\n                j = i;\\n            }\\n        }\\n\\n<!-- \\u2705Well before returning answer don\\'t forget to UPVOTE.\\u2705 -->\\n        return count;\\n    }\\n};\\n```\\n![Leetcode Upvote.gif](https://assets.leetcode.com/users/images/ebe03d36-f10f-4b43-aebb-8a3f2c73c77b_1685388122.1682274.gif)\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        int n = size(nums);\\n        int count=0;\\n        int i=1,j=0; // j is a tail pointer\\n        for(i=1; i<n-1; i++)\\n        {\\n            if(nums[j] < nums[i] && nums[i] > nums[i+1]){\\n                count++;\\n                j = i;\\n            }\\n            else if(nums[j] > nums[i] && nums[i] < nums[i+1]){\\n                count++;\\n                j = i;\\n            }\\n        }\\n\\n<!-- \\u2705Well before returning answer don\\'t forget to UPVOTE.\\u2705 -->\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3412861,
                "title": "count-hills-and-valleys-in-an-array-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        int i, count=0, hill=0, valley=0;\\n        for(i=1 ; i<nums.size() ; i++)\\n        {\\n            if(nums[i-1]<nums[i] && hill==0)\\n            {\\n                hill=1;\\n                if(valley==1)\\n                {\\n                    count++;\\n                    valley=0;\\n                }\\n            }\\n            else if(nums[i-1]>nums[i])\\n            {\\n                valley=1;\\n                if(hill==1)\\n                {\\n                    count++;\\n                    hill=0;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```\\n![upvote new.jpg](https://assets.leetcode.com/users/images/792a2ee3-fa92-4936-9a87-216cd9a9ac02_1682613207.1269994.jpeg)",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        int i, count=0, hill=0, valley=0;\\n        for(i=1 ; i<nums.size() ; i++)\\n        {\\n            if(nums[i-1]<nums[i] && hill==0)\\n            {\\n                hill=1;\\n                if(valley==1)\\n                {\\n                    count++;\\n                    valley=0;\\n                }\\n            }\\n            else if(nums[i-1]>nums[i])\\n            {\\n                valley=1;\\n                if(hill==1)\\n                {\\n                    count++;\\n                    hill=0;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3169968,
                "title": "python-clean-solution-explanation-of-an-edge-case",
                "content": "# Intuition\\nWe are iterating from 1st to last -1 element.\\nFor each one determine is it hill or velly:\\nelement-1 < element > element + 1 or element-1 > element < element + 1\\n\\n# Approach\\nImportant to not count the same velly [4, ***1,1,1*** ,4] multiple times.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def countHillValley(self, nums: List[int]) -> int:\\n        result = 0\\n        for i in range(1, len(nums)-1):\\n            # edge case, the same velly!\\n            # adjacent indexes should be considered as one velly or hill\\n            # to handle this, we can check if next value is the same as current\\n            # for example in [4,1,1,6]\\n            # [4, 1(we are here), 1(detected next value), 6]\\n            # replace the first 1 by 4 (4 is a previous value)\\n            # as result we get: [4,4,1,6]\\n            # so thet at the next iteration the second 1 will be detected as a valley\\n            # [4,4,1(we are here),6] \\n            # 4 > 1 < 6\\n            if nums[i] == nums[i+1]:\\n                nums[i] = nums[i-1]\\n            elif nums[i-1] > nums[i] < nums[i+1] or nums[i-1] < nums[i] > nums[i+1]:\\n                result += 1\\n        return result\\n            \\n\\n            \\n\\n\\n            \\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Shortest Path"
                ],
                "code": "```\\nclass Solution:\\n    def countHillValley(self, nums: List[int]) -> int:\\n        result = 0\\n        for i in range(1, len(nums)-1):\\n            # edge case, the same velly!\\n            # adjacent indexes should be considered as one velly or hill\\n            # to handle this, we can check if next value is the same as current\\n            # for example in [4,1,1,6]\\n            # [4, 1(we are here), 1(detected next value), 6]\\n            # replace the first 1 by 4 (4 is a previous value)\\n            # as result we get: [4,4,1,6]\\n            # so thet at the next iteration the second 1 will be detected as a valley\\n            # [4,4,1(we are here),6] \\n            # 4 > 1 < 6\\n            if nums[i] == nums[i+1]:\\n                nums[i] = nums[i-1]\\n            elif nums[i-1] > nums[i] < nums[i+1] or nums[i-1] < nums[i] > nums[i+1]:\\n                result += 1\\n        return result\\n            \\n\\n            \\n\\n\\n            \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3147988,
                "title": "cool-single-pass-java-solution-beats-100-0ms",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int countHillValley(int[] nums) {\\n        int prevDiff = nums[1] - nums[0];\\n        int nextDiff = 0;\\n        int sum = 0;\\n\\n        for(int i = 2; i < nums.length; i++) {\\n            nextDiff = nums[i] - nums[i - 1];\\n            if(nextDiff != 0) {\\n                if(nextDiff * prevDiff < 0) {\\n                    sum += 1;\\n                }\\n                prevDiff = nextDiff;\\n            }\\n        }\\n\\n        return sum;\\n\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int countHillValley(int[] nums) {\\n        int prevDiff = nums[1] - nums[0];\\n        int nextDiff = 0;\\n        int sum = 0;\\n\\n        for(int i = 2; i < nums.length; i++) {\\n            nextDiff = nums[i] - nums[i - 1];\\n            if(nextDiff != 0) {\\n                if(nextDiff * prevDiff < 0) {\\n                    sum += 1;\\n                }\\n                prevDiff = nextDiff;\\n            }\\n        }\\n\\n        return sum;\\n\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2950309,
                "title": "java-time-complexity-o-n-space-o-1-easy-solution",
                "content": "```\\nclass Solution {\\n    public int countHillValley(int[] arr) {\\n        int count = 0;\\n        for(int i = 1; i<arr.length-1; i++){\\n            if( arr[i] == arr[i+1]){ \\n                arr[i] = arr[i-1];\\n                continue;\\n            }\\n            if(arr[i]>arr[i-1] && arr[i]>arr[i+1]){\\n                count++;\\n            }else if(arr[i]<arr[i-1] && arr[i]<arr[i+1]){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}",
                "solutionTags": [
                    "Array"
                ],
                "code": "class Solution {\\n    public int countHillValley(int[] arr) {\\n        int count = 0;\\n        for(int i = 1; i<arr.length-1; i++){\\n            if( arr[i] == arr[i+1]){ \\n                arr[i] = arr[i-1];\\n                continue;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2563706,
                "title": "with-explanation-comments-time-4-ms-61-39-space-9-mb-38-09",
                "content": "**Like it? ->Upvote please!** \\u30C4\\n\\n\\'\\'\\'\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        \\n        //initialize a counter for both hills and valleys\\n        int counter=0;\\n        \\n        //initialize a new vector for the non-repeated numbers\\n        vector<int> res;\\n        \\n        //save the first array value as the first unique one\\n        res.push_back(nums[0]);\\n        \\n        //loop over the whole array elements\\n        for(int i=1;i<nums.size();i++)\\n            \\n            //check if the current one doesn\\'t equal to the last saved value\\n            if(nums[i]!=nums[i-1]){\\n                //add the non-repeated number to the new array\\n                res.push_back(nums[i]);\\n            }\\n    \\n        //loop over the whole unique array numbers        \\n        for(int i=1;i<res.size()-1;i++)\\n            \\n            //check of the two conditions: if their both neighbors are greater-> hill++ | both are smaller-> valley++ -> or counter++ for simplicity\\n            if(res[i]>res[i+1] && res[i]>res[i-1] || res[i] < res[i+1] && res[i]<res[i-1])\\n                counter++;\\n        \\n        //return the hill+vally values-> general counter value\\n        return counter;\\n    }\\n};\\n\\'\\'\\'\\n\\n**Like it? ->Upvote please!** \\u30C4\\n**If still not understood, feel free to comment. I will help you out**\\n**Happy Coding :)**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array"
                ],
                "code": "class Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        \\n        //initialize a counter for both hills and valleys\\n        int counter=0;\\n        \\n        //initialize a new vector for the non-repeated numbers\\n        vector<int> res;\\n        \\n        //save the first array value as the first unique one\\n        res.push_back(nums[0]);\\n        \\n        //loop over the whole array elements\\n        for(int i=1;i<nums.size();i++)\\n            \\n            //check if the current one doesn\\'t equal to the last saved value\\n            if(nums[i]!=nums[i-1]){\\n                //add the non-repeated number to the new array\\n                res.push_back(nums[i]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2272429,
                "title": "easy-to-understand-c-o-n-solution",
                "content": "\\'\\'\\'\\n     //Time Complexity : O(n)  Space Complexity : O(1)\\n   \\n        int countHillValley(vector<int>& nums) {\\n        \\n        int hills=0, valleys=0;\\n\\n        //Index before and after the \\'i\\' th index for which we are checking for hill or valley \\n        int low=0, high=1;\\n        \\n        for(int i=1;i<nums.size()-1;i++){\\n            low=i-1;\\n            high=i+1;\\n            \\n            //Handling Duplicates \\n            while(high<nums.size() && nums[high]==nums[i]) high++;\\n            if(high==nums.size()) break;\\n            \\n\\t\\t\\t//Check for Hill or Valley \\n            if(nums[i]<nums[low] && nums[i]<nums[high]) valleys++;\\n            else if(nums[i]>nums[low] && nums[i]>nums[high]) hills++;\\n            \\n            //Directly jump to high(index) and -1 because i will be incremented in loop itself \\n            i=high-1;\\n        }\\n        \\n        return hills+valleys;\\n    }\\n\\'\\'\\'",
                "solutionTags": [
                    "C"
                ],
                "code": "\\'\\'\\'\\n     //Time Complexity : O(n)  Space Complexity : O(1)\\n   \\n        int countHillValley(vector<int>& nums) {\\n        \\n        int hills=0, valleys=0;\\n\\n        //Index before and after the \\'i\\' th index for which we are checking for hill or valley \\n        int low=0, high=1;\\n        \\n        for(int i=1;i<nums.size()-1;i++){\\n            low=i-1;\\n            high=i+1;\\n            \\n            //Handling Duplicates \\n            while(high<nums.size() && nums[high]==nums[i]) high++;\\n            if(high==nums.size()) break;\\n            \\n\\t\\t\\t//Check for Hill or Valley \\n            if(nums[i]<nums[low] && nums[i]<nums[high]) valleys++;\\n            else if(nums[i]>nums[low] && nums[i]>nums[high]) hills++;\\n            \\n            //Directly jump to high(index) and -1 because i will be incremented in loop itself \\n            i=high-1;\\n        }\\n        \\n        return hills+valleys;\\n    }\\n\\'\\'\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 2160938,
                "title": "typescript-o-n-time-o-1-space",
                "content": "Remember previous status, going up or going down. If current node goes down since previous status is going up, it meas you just past a valley. Or conversely, you just past a hill.\\n```ts\\nfunction countHillValley(nums: number[]): number {\\n  let res = 0, status: boolean;\\n  for (let i = 1; i < nums.length; i++) {\\n    if (nums[i] === nums[i - 1]) continue;\\n    \\n    if (status === undefined) {\\n      if (nums[i] < nums[i - 1]) status = false\\n      else status = true;\\n      \\n      continue;\\n    }\\n    \\n    if (status && nums[i] < nums[i - 1] || !status && nums[i] > nums[i - 1]) res++, status = !status\\n  }\\n  \\n  return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```ts\\nfunction countHillValley(nums: number[]): number {\\n  let res = 0, status: boolean;\\n  for (let i = 1; i < nums.length; i++) {\\n    if (nums[i] === nums[i - 1]) continue;\\n    \\n    if (status === undefined) {\\n      if (nums[i] < nums[i - 1]) status = false\\n      else status = true;\\n      \\n      continue;\\n    }\\n    \\n    if (status && nums[i] < nums[i - 1] || !status && nums[i] > nums[i - 1]) res++, status = !status\\n  }\\n  \\n  return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2058335,
                "title": "count-hills-and-valleys-in-an-array-java-easy",
                "content": "```\\n\\n       int ans = 0;\\n        int left = arr[0];\\n        for(int i = 1; i < arr.length-1; i++){\\n            if(arr[i] > arr[i+1] && arr[i] > left){\\n                ans++;\\n                left=arr[i];     \\n            }\\n            else if(arr[i] < arr[i+1] && arr[i] < left){\\n                ans++;\\n                left=arr[i];\\n            }\\n        }\\n        return ans;\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\n       int ans = 0;\\n        int left = arr[0];\\n        for(int i = 1; i < arr.length-1; i++){\\n            if(arr[i] > arr[i+1] && arr[i] > left){\\n                ans++;\\n                left=arr[i];     \\n            }\\n            else if(arr[i] < arr[i+1] && arr[i] < left){\\n                ans++;\\n                left=arr[i];\\n            }\\n        }\\n        return ans;\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1977956,
                "title": "java-o-n-0ms-faster-than-100",
                "content": "```\\nclass Solution {\\n    public int countHillValley(int[] nums) {\\n        int count = 0;\\n        int leftNeighbour = nums[0];\\n        for(int i = 1; i < nums.length-1; i++){\\n            if(leftNeighbour < nums[i] && nums[i+1] < nums[i])\\n                count++;\\n            if(leftNeighbour > nums[i] && nums[i+1] > nums[i])\\n                count++;\\n            if(nums[i] != nums[i+1])\\n                leftNeighbour = nums[i];\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int countHillValley(int[] nums) {\\n        int count = 0;\\n        int leftNeighbour = nums[0];\\n        for(int i = 1; i < nums.length-1; i++){\\n            if(leftNeighbour < nums[i] && nums[i+1] < nums[i])\\n                count++;\\n            if(leftNeighbour > nums[i] && nums[i+1] > nums[i])\\n                count++;\\n            if(nums[i] != nums[i+1])\\n                leftNeighbour = nums[i];\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1950026,
                "title": "vert-simple-commented-solution-with-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        int answer = 0;\\n         // this removes equal adjacent numbers.\\n     \\tnums.erase(unique(nums.begin(), nums.end()), nums.end());\\n        \\n        //Note the start (1) and the end (size-1) as the first and the last number can\\'t be a valley or a hill.\\n\\tfor(int i = 1; i < nums.size() -1; ++i)\\n\\t\\t  if ((nums[i-1] < nums[i] && nums[i] > nums[i+1])  // if it\\'s a hill\\n\\t\\t  || (nums[i-1] > nums[i] && nums[i] < nums[i+1])) // if it\\'s a valley\\n              answer++;\\n\\treturn answer;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        int answer = 0;\\n         // this removes equal adjacent numbers.\\n     \\tnums.erase(unique(nums.begin(), nums.end()), nums.end());\\n        \\n        //Note the start (1) and the end (size-1) as the first and the last number can\\'t be a valley or a hill.\\n\\tfor(int i = 1; i < nums.size() -1; ++i)\\n\\t\\t  if ((nums[i-1] < nums[i] && nums[i] > nums[i+1])  // if it\\'s a hill\\n\\t\\t  || (nums[i-1] > nums[i] && nums[i] < nums[i+1])) // if it\\'s a valley\\n              answer++;\\n\\treturn answer;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1932870,
                "title": "python",
                "content": "```\\ndef countHillValley(self, nums: List[int]) -> int:\\n        nums1 = [nums[0]]\\n        for i in range(1, len(nums)):\\n            if nums[i] != nums1[-1]:\\n                nums1.append(nums[i])\\n        cnt = 0\\n        for i in range(1, len(nums1) - 1):\\n            if nums1[i - 1] < nums1[i] > nums1[i + 1] or nums1[i - 1] > nums1[i] < nums1[i + 1]:\\n                cnt += 1\\n        return cnt\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef countHillValley(self, nums: List[int]) -> int:\\n        nums1 = [nums[0]]\\n        for i in range(1, len(nums)):\\n            if nums[i] != nums1[-1]:\\n                nums1.append(nums[i])\\n        cnt = 0\\n        for i in range(1, len(nums1) - 1):\\n            if nums1[i - 1] < nums1[i] > nums1[i + 1] or nums1[i - 1] > nums1[i] < nums1[i + 1]:\\n                cnt += 1\\n        return cnt\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1870566,
                "title": "c-one-pass-solution",
                "content": "```\\n\\tpublic int CountHillValley(int[] nums) {\\n        var count = 0;\\n        int leftBorder = nums[0];\\n        for (int i=1; i<nums.Length-1; i++) {\\n            if (nums[i] == nums[i+1]) \\n               continue;\\n            if (IsHill(nums[i], leftBorder, nums[i+1]) || IsValley(nums[i], leftBorder, nums[i+1])) \\n                count++;\\n            leftBorder = nums[i];\\n        }\\n        return count;\\n    }\\n\\t\\n\\tbool IsValley(int height, int leftBorder, int rightBorder)\\n        => height < leftBorder && height < rightBorder;\\n                \\n    bool IsHill(int height, int leftBorder, int rightBorder)\\n        => height > leftBorder && height > rightBorder;\\n```",
                "solutionTags": [],
                "code": "```\\n\\tpublic int CountHillValley(int[] nums) {\\n        var count = 0;\\n        int leftBorder = nums[0];\\n        for (int i=1; i<nums.Length-1; i++) {\\n            if (nums[i] == nums[i+1]) \\n               continue;\\n            if (IsHill(nums[i], leftBorder, nums[i+1]) || IsValley(nums[i], leftBorder, nums[i+1])) \\n                count++;\\n            leftBorder = nums[i];\\n        }\\n        return count;\\n    }\\n\\t\\n\\tbool IsValley(int height, int leftBorder, int rightBorder)\\n        => height < leftBorder && height < rightBorder;\\n                \\n    bool IsHill(int height, int leftBorder, int rightBorder)\\n        => height > leftBorder && height > rightBorder;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1868597,
                "title": "easy-solution-with-full-explanation-c-o-n-time-o-n-space",
                "content": "The question would be trivial if duplicate elements cannot be beside each other, as we would only have to compare v[i - 1] and v[i + 1] for i from 1 to N - 1. Therefore, we must come up with a method to remove adjacent elements that are equal. \\n\\nKey Observation: Adjacent duplicates will not affect the result. \\nSuppose there is a valley. Adding another trough beside the lowest element will not change the result, as there will still only be one valley. \\n\\nWithout loss of generality, adding another peak beside the highest element will not change the result, as there will still only be one peak. \\n\\nShown in the image below, adjacent duplicates do not affect the result. \\n![image](https://assets.leetcode.com/users/images/98308d6b-7748-4165-b99d-104c77961a17_1647815885.0251374.png)\\n\\n\\nTherefore, the array can be \"condensed\" by removing adjacement duplicates. \\n\\nImplementation\\nStep 1: make a new array and insert elements from the original array without adjacent duplicates. \\nStep 2. Iterate through 1 ... N - 2 (0 indexed) and count number of hills and valleys. \\n\\nTime Complexity: O(N). Traverse the graph once to make the new array, and once to count the number of peaks and troughs. \\nSpace Complexity: O(N). Insert all elements into new array without adjacent duplicates. \\n\\nC++ Implementation: \\n```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        vector<int> v;\\n        for(int i = 0; i < nums.size(); i++){\\n            if(v.size() == 0 || v.back() != nums[i]) v.push_back(nums[i]);\\n        }\\n        int res = 0;\\n        for(int i = 1; i < v.size() - 1; i++){\\n            if(v[i] < v[i - 1] && v[i] < v[i + 1]) res++;\\n            else if(v[i] > v[i - 1] && v[i] > v[i + 1]) res++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        vector<int> v;\\n        for(int i = 0; i < nums.size(); i++){\\n            if(v.size() == 0 || v.back() != nums[i]) v.push_back(nums[i]);\\n        }\\n        int res = 0;\\n        for(int i = 1; i < v.size() - 1; i++){\\n            if(v[i] < v[i - 1] && v[i] < v[i + 1]) res++;\\n            else if(v[i] > v[i - 1] && v[i] > v[i + 1]) res++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1866016,
                "title": "java-linear-time",
                "content": "```\\nclass Solution {\\n    public int countHillValley(int[] arr) {\\n         int ans = 0;\\n        int left = arr[0];\\n        for(int i = 1; i < arr.length-1; i++){\\n            if(arr[i] > arr[i+1] && arr[i] > left){\\n                ans++;\\n                left = arr[i];\\n            }\\n            else if(arr[i] < arr[i+1] && arr[i] < left){\\n                ans++;\\n                left = arr[i];\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countHillValley(int[] arr) {\\n         int ans = 0;\\n        int left = arr[0];\\n        for(int i = 1; i < arr.length-1; i++){\\n            if(arr[i] > arr[i+1] && arr[i] > left){\\n                ans++;\\n                left = arr[i];\\n            }\\n            else if(arr[i] < arr[i+1] && arr[i] < left){\\n                ans++;\\n                left = arr[i];\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1865638,
                "title": "0ms-100-faster-o-n-2-solutions-explained-with-steps",
                "content": "If any questions, please let me know.  I will be updating the step-by-step dry run shortly.\\nIf you liked it, pls **Upvote** :)\\n\\n\\n**Solution 1:** \\n## Complexity:\\n\\tTime:  O(n)\\n\\tSpace: O(n)\\n\\n## Dry Run:\\n\\n\\tInitialize res[] =  [\\' \\', \\' \\', \\' \\', \\' \\', \\' \\', \\' \\']\\n\\t\\n\\t                  0  1  2  3  4  5\\n\\t nums[]= \\t     [2, 4, 1, 1, 6, 5]\\n\\ti: 0, res[]:     [ ,  ,  ,  ,  ,  ]\\n\\ti: 1, res[]:     [ , H,  ,  ,  ,  ]               // keep updating \\'res\\' array in each iteration of i\\n\\ti: 2, res[]:     [ , H, v,  ,  ,  ]\\n\\ti: 3, res[]:     [ , H, v, V,  ,  ]\\n\\ti: 4, res[]:     [ , H, v, V, H,  ]\\n\\t\\n\\tNow, count the number of uppercase H & V (and ignore all lowercase h & v).\\n\\tSo, return count = 3   (because, H, V, H)\\n\\n## Code:\\n\\tpublic int countHillValley(int[] nums) {\\n\\t\\t\\tint count = 0;\\n\\t\\t\\tint len = nums.length;\\n\\t\\t\\tchar[] res = new char[len];\\n\\t\\t\\tArrays.fill(res,\\' \\');\\n\\n\\t\\t\\tfor(int i = 1; i < len-1; i++){\\n\\t\\t\\t\\tif(nums[i] > nums[i-1]){                                                 // if... num at i > num at i-1                      \\n\\t\\t\\t\\t\\tif(nums[i] > nums[i+1]){ res[i] = \\'H\\'; }                                 // also, if num at i > num at i+1. => found Hill. Mark as \\'H\\'   \\n\\t\\t\\t\\t\\telse if(nums[i] == nums[i+1]){ res[i] = \\'h\\'; }                           // else, if num at i == num at i+1. Then mark as \\'h\\' instead of \\'H\\'. \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t    // Means, it may or may not be hill, and will be figured out in next steps.\\n\\t\\t\\t\\t}else if( nums[i] < nums[i-1] ){                                         // Else if....\\n\\t\\t\\t\\t\\tif(nums[i] < nums[i+1]){ res[i] = \\'V\\'; }                                 //  means, found Valley. So, mark as \\'V\\' \\n\\t\\t\\t\\t\\telse if(nums[i] == nums[i+1]){ res[i] = \\'v\\'; }                              // Means, it may or may not be a valley, and will be figured out in next steps.\\n\\t\\t\\t\\t}else{                                                                   // Else.. Here we will figure out if \\'v\\' becomes valley \\'V\\', and if \\'h\\' becomes hill \\'H\\'\\n\\t\\t\\t\\t\\tif( res[i-1] == \\'v\\' && nums[i] < nums[i+1] ){ res[i] = \\'V\\'; }     \\n\\t\\t\\t\\t\\telse if( res[i-1] == \\'h\\' && nums[i] > nums[i+1] ){ res[i] = \\'H\\'; }\\n\\t\\t\\t\\t\\telse{ res[i] = res[i-1]; }\\n\\t\\t\\t\\t}\\n\\t\\t\\t}        \\n\\t\\t\\t\\n\\t\\t\\tfor(int i = 1; i < len-1; i++){                                              // Now, count the number of uppercase H & V (and ignore all lowercase h & v).\\n\\t\\t\\t\\tif(res[i] == \\'H\\' || res[i] == \\'V\\'){ count++; }   \\n\\t\\t\\t}        \\n\\t\\t\\treturn count;\\n\\t\\t}\\n//\\n//\\n//\\n//\\n\\n**Solution 2:**\\n## Complexity:\\n\\tTime:  O(n)\\n\\tSpace: O(1)  // constant\\n## Code:\\t\\n    public int countHillValley(int[] nums) {\\n        int count = 0, prev = 0;\\n        \\n\\t\\tfor(int i=1; i<nums.length-1; i++) {\\n\\t\\t\\tif(nums[i] == nums[i+1]){ continue; }                     // if this and next values are equal, we can not yet confirm if there is Hill or Valley.\\n\\t\\t\\telse{\\n\\t\\t\\t\\tif( (nums[i] > nums[prev] && nums[i] > nums[i+1]) || (nums[i] < nums[prev] && nums[i] < nums[i+1]) ){ \\n                    count++; \\n                }\\n\\t\\t\\t\\tprev = i;  \\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn count;\\n\\t}\\n\\t\\t\\nIf you liked it, pls **Upvote** :)\\n**NOTE:** I mentioned these 2 solutions keeping **coding interviews** in mind, as it may be better to first give a brute-force or sub optimal solution, and then more optimal solution.",
                "solutionTags": [
                    "Java"
                ],
                "code": "If any questions, please let me know.  I will be updating the step-by-step dry run shortly.\\nIf you liked it, pls **Upvote** :)\\n\\n\\n**Solution 1:** \\n## Complexity:\\n\\tTime:  O(n)\\n\\tSpace: O(n)\\n\\n## Dry Run:\\n\\n\\tInitialize res[] =  [\\' \\', \\' \\', \\' \\', \\' \\', \\' \\', \\' \\']\\n\\t\\n\\t                  0  1  2  3  4  5\\n\\t nums[]= \\t     [2, 4, 1, 1, 6, 5]\\n\\ti: 0, res[]:     [ ,  ,  ,  ,  ,  ]\\n\\ti: 1, res[]:     [ , H,  ,  ,  ,  ]               // keep updating \\'res\\' array in each iteration of i\\n\\ti: 2, res[]:     [ , H, v,  ,  ,  ]\\n\\ti: 3, res[]:     [ , H, v, V,  ,  ]\\n\\ti: 4, res[]:     [ , H, v, V, H,  ]\\n\\t\\n\\tNow, count the number of uppercase H & V (and ignore all lowercase h & v).\\n\\tSo, return count = 3   (because, H, V, H)\\n\\n## Code:\\n\\tpublic int countHillValley(int[] nums) {\\n\\t\\t\\tint count = 0;\\n\\t\\t\\tint len = nums.length;\\n\\t\\t\\tchar[] res = new char[len];\\n\\t\\t\\tArrays.fill(res,\\' \\');\\n\\n\\t\\t\\tfor(int i = 1; i < len-1; i++){\\n\\t\\t\\t\\tif(nums[i] > nums[i-1]){                                                 // if... num at i > num at i-1                      \\n\\t\\t\\t\\t\\tif(nums[i] > nums[i+1]){ res[i] = \\'H\\'; }                                 // also, if num at i > num at i+1. => found Hill. Mark as \\'H\\'   \\n\\t\\t\\t\\t\\telse if(nums[i] == nums[i+1]){ res[i] = \\'h\\'; }                           // else, if num at i == num at i+1. Then mark as \\'h\\' instead of \\'H\\'. \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t    // Means, it may or may not be hill, and will be figured out in next steps.\\n\\t\\t\\t\\t}else if( nums[i] < nums[i-1] ){                                         // Else if....\\n\\t\\t\\t\\t\\tif(nums[i] < nums[i+1]){ res[i] = \\'V\\'; }                                 //  means, found Valley. So, mark as \\'V\\' \\n\\t\\t\\t\\t\\telse if(nums[i] == nums[i+1]){ res[i] = \\'v\\'; }                              // Means, it may or may not be a valley, and will be figured out in next steps.\\n\\t\\t\\t\\t}else{                                                                   // Else.. Here we will figure out if \\'v\\' becomes valley \\'V\\', and if \\'h\\' becomes hill \\'H\\'\\n\\t\\t\\t\\t\\tif( res[i-1] == \\'v\\' && nums[i] < nums[i+1] ){ res[i] = \\'V\\'; }     \\n\\t\\t\\t\\t\\telse if( res[i-1] == \\'h\\' && nums[i] > nums[i+1] ){ res[i] = \\'H\\'; }\\n\\t\\t\\t\\t\\telse{ res[i] = res[i-1]; }\\n\\t\\t\\t\\t}\\n\\t\\t\\t}        \\n\\t\\t\\t\\n\\t\\t\\tfor(int i = 1; i < len-1; i++){                                              // Now, count the number of uppercase H & V (and ignore all lowercase h & v).\\n\\t\\t\\t\\tif(res[i] == \\'H\\' || res[i] == \\'V\\'){ count++; }   \\n\\t\\t\\t}        \\n\\t\\t\\treturn count;\\n\\t\\t}\\n//\\n//\\n//\\n//\\n\\n**Solution 2:**\\n## Complexity:\\n\\tTime:  O(n)\\n\\tSpace: O(1)  // constant\\n## Code:\\t\\n    public int countHillValley(int[] nums) {\\n        int count = 0, prev = 0;\\n        \\n\\t\\tfor(int i=1; i<nums.length-1; i++) {\\n\\t\\t\\tif(nums[i] == nums[i+1]){ continue; }                     // if this and next values are equal, we can not yet confirm if there is Hill or Valley.\\n\\t\\t\\telse{\\n\\t\\t\\t\\tif( (nums[i] > nums[prev] && nums[i] > nums[i+1]) || (nums[i] < nums[prev] && nums[i] < nums[i+1]) ){ \\n                    count++; \\n                }\\n\\t\\t\\t\\tprev = i;  \\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn count;\\n\\t}\\n\\t\\t\\nIf you liked it, pls **Upvote** :)\\n**NOTE:** I mentioned these 2 solutions keeping **coding interviews** in mind, as it may be better to first give a brute-force or sub optimal solution, and then more optimal solution.",
                "codeTag": "Unknown"
            },
            {
                "id": 1865637,
                "title": "c-easy-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        int ans = 0;\\n        \\n        \\n        for(int i=1;i<nums.size()-1;i++){\\n           \\n            if(nums[i]==nums[i-1]) continue; \\n            int l = nums[i-1];\\n            int r = nums[i+1];\\n            \\n            if(l==nums[i]){\\n                int j = i;\\n                while(j>=0 && nums[j]==l){\\n                    j--;\\n                }\\n                if(j<0) continue;\\n                if(nums[j]==l) continue;\\n                else l = nums[j];\\n            }\\n            if(r==nums[i]){\\n                int j = i;\\n                while(j<nums.size() && nums[j]==r){\\n                    j++;\\n                }\\n                if(j==nums.size()) continue;\\n                if(nums[j]==r) continue;\\n                else r = nums[j];\\n            }\\n            \\n            if(nums[i]>l && nums[i]>r) ans++;\\n            else if(l>nums[i] && r>nums[i]) ans++;\\n            \\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        int ans = 0;\\n        \\n        \\n        for(int i=1;i<nums.size()-1;i++){\\n           \\n            if(nums[i]==nums[i-1]) continue; \\n            int l = nums[i-1];\\n            int r = nums[i+1];\\n            \\n            if(l==nums[i]){\\n                int j = i;\\n                while(j>=0 && nums[j]==l){\\n                    j--;\\n                }\\n                if(j<0) continue;\\n                if(nums[j]==l) continue;\\n                else l = nums[j];\\n            }\\n            if(r==nums[i]){\\n                int j = i;\\n                while(j<nums.size() && nums[j]==r){\\n                    j++;\\n                }\\n                if(j==nums.size()) continue;\\n                if(nums[j]==r) continue;\\n                else r = nums[j];\\n            }\\n            \\n            if(nums[i]>l && nums[i]>r) ans++;\\n            else if(l>nums[i] && r>nums[i]) ans++;\\n            \\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1865633,
                "title": "simople-c-solution-easy-0-n",
                "content": "```\\nint n=nums.size();\\n    int count=0;\\n    for(int i=0;i<n;i++){\\n        int j=i-1;\\n        int k=i+1;\\n        if(i>0 and i<n-1){\\n            if(nums[i]==nums[j]){\\n                continue;\\n            }\\n        }\\n        while(j>=0 and k<n  and (nums[i]==nums[j] or nums[i]==nums[k])){\\n            if(nums[i]==nums[j])\\n            j--;\\n            if(nums[i]==nums[k])\\n            k++;\\n        }\\n        if(j>=0 and k<n){\\n            if(nums[j]<nums[i] and nums[k]<nums[i])count++;\\n            else if(nums[j]>nums[i]and nums [k]>nums[i])count++;\\n        }\\n    }\\n    return count;\\n```",
                "solutionTags": [],
                "code": "```\\nint n=nums.size();\\n    int count=0;\\n    for(int i=0;i<n;i++){\\n        int j=i-1;\\n        int k=i+1;\\n        if(i>0 and i<n-1){\\n            if(nums[i]==nums[j]){\\n                continue;\\n            }\\n        }\\n        while(j>=0 and k<n  and (nums[i]==nums[j] or nums[i]==nums[k])){\\n            if(nums[i]==nums[j])\\n            j--;\\n            if(nums[i]==nums[k])\\n            k++;\\n        }\\n        if(j>=0 and k<n){\\n            if(nums[j]<nums[i] and nums[k]<nums[i])count++;\\n            else if(nums[j]>nums[i]and nums [k]>nums[i])count++;\\n        }\\n    }\\n    return count;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1865570,
                "title": "simple-c-solution-with-o-n-tc",
                "content": "\\n\\t   \\n\\t   \\n\\t   \\n\\t   \\n\\t   \\n\\t   \\n\\t   \\n\\t   \\n\\t   \\n\\t   \\n\\t   int n=nums.size();\\n        int count=0;\\n        for(int i=0;i<n;i++){\\n            int j=i-1;\\n            int k=i+1;\\n            if(i>0 and i<n-1){\\n                if(nums[i]==nums[j]){\\n                    continue;\\n                }\\n            }\\n            while(j>=0 and k<n  and (nums[i]==nums[j] or nums[i]==nums[k])){\\n                if(nums[i]==nums[j])\\n                j--;\\n                if(nums[i]==nums[k])\\n                k++;\\n            }\\n            if(j>=0 and k<n){\\n                if(nums[j]<nums[i] and nums[k]<nums[i])count++;\\n                else if(nums[j]>nums[i]and nums [k]>nums[i])count++;\\n            }\\n        }\\n        return count;",
                "solutionTags": [
                    "C"
                ],
                "code": "\\n\\t   \\n\\t   \\n\\t   \\n\\t   \\n\\t   \\n\\t   \\n\\t   \\n\\t   \\n\\t   \\n\\t   \\n\\t   int n=nums.size();\\n        int count=0;\\n        for(int i=0;i<n;i++){\\n            int j=i-1;\\n            int k=i+1;\\n            if(i>0 and i<n-1){\\n                if(nums[i]==nums[j]){\\n                    continue;\\n                }\\n            }\\n            while(j>=0 and k<n  and (nums[i]==nums[j] or nums[i]==nums[k])){\\n                if(nums[i]==nums[j])\\n                j--;\\n                if(nums[i]==nums[k])\\n                k++;\\n            }\\n            if(j>=0 and k<n){\\n                if(nums[j]<nums[i] and nums[k]<nums[i])count++;\\n                else if(nums[j]>nums[i]and nums [k]>nums[i])count++;\\n            }\\n        }\\n        return count;",
                "codeTag": "Unknown"
            },
            {
                "id": 3355594,
                "title": "c-golang",
                "content": "# Code\\n```\\n// C++\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        int n = nums.size(), prev = nums[0], ans = 0;\\n        for(int i = 1; i < n; i++) {\\n            while(i < n && nums[i] == nums[i - 1]) i++;\\n            if(i < n && ((nums[i - 1] > nums[i] && nums[i - 1] > prev) || (nums[i - 1] < nums[i] && nums[i - 1] < prev))) {\\n                ans++;\\n            }\\n            prev = nums[i - 1];\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n// Golang\\nfunc countHillValley(nums []int) int {\\n    var n, prev, ans int = len(nums), nums[0], 0\\n    for i := 1; i < n; i++ {\\n        for i < n && nums[i] == nums[i - 1] {i++}\\n        if i < n && ((nums[i - 1] > nums[i] && nums[i - 1] > prev) || (nums[i - 1] < nums[i] && nums[i - 1] < prev)) {\\n            ans++\\n        }\\n        prev = nums[i - 1]\\n    }\\n    return ans\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Go"
                ],
                "code": "```\\n// C++\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        int n = nums.size(), prev = nums[0], ans = 0;\\n        for(int i = 1; i < n; i++) {\\n            while(i < n && nums[i] == nums[i - 1]) i++;\\n            if(i < n && ((nums[i - 1] > nums[i] && nums[i - 1] > prev) || (nums[i - 1] < nums[i] && nums[i - 1] < prev))) {\\n                ans++;\\n            }\\n            prev = nums[i - 1];\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n// Golang\\nfunc countHillValley(nums []int) int {\\n    var n, prev, ans int = len(nums), nums[0], 0\\n    for i := 1; i < n; i++ {\\n        for i < n && nums[i] == nums[i - 1] {i++}\\n        if i < n && ((nums[i - 1] > nums[i] && nums[i - 1] > prev) || (nums[i - 1] < nums[i] && nums[i - 1] < prev)) {\\n            ans++\\n        }\\n        prev = nums[i - 1]\\n    }\\n    return ans\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3246224,
                "title": "o-n-tc-o-1-sc-without-filtering",
                "content": "# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar countHillValley = function(nums) {\\n    let res = 0;\\n    let i = 1;\\n    while (i < nums.length - 1) {\\n        const startIndex = i;\\n        if (nums[i] === nums[i + 1]) {\\n            while (nums[i] === nums[i + 1]) i++;\\n        }\\n        const endIndex = i;\\n        if (\\n            nums[startIndex] > nums[startIndex - 1] && nums[endIndex] > nums[endIndex + 1] ||\\n            nums[startIndex] < nums[startIndex - 1] && nums[endIndex] < nums[endIndex + 1]\\n        ) {\\n            res++;\\n        }\\n        i++;\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar countHillValley = function(nums) {\\n    let res = 0;\\n    let i = 1;\\n    while (i < nums.length - 1) {\\n        const startIndex = i;\\n        if (nums[i] === nums[i + 1]) {\\n            while (nums[i] === nums[i + 1]) i++;\\n        }\\n        const endIndex = i;\\n        if (\\n            nums[startIndex] > nums[startIndex - 1] && nums[endIndex] > nums[endIndex + 1] ||\\n            nums[startIndex] < nums[startIndex - 1] && nums[endIndex] < nums[endIndex + 1]\\n        ) {\\n            res++;\\n        }\\n        i++;\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3243372,
                "title": "c-solution-beats-100-runtime-0ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n\\n    vector<int> v;\\n    v.push_back(nums[0]);\\n    for (int i = 1; i < nums.size(); i++)\\n    {\\n        if (nums[i] != nums[i - 1])\\n            v.push_back(nums[i]);\\n    }\\n    int count=0;\\n    int i = 1;\\n    while (i < v.size() - 1)\\n    {\\n        if (v[i] > v[i - 1] && v[i] > v[i + 1])\\n            count++;\\n        else if (v[i] < v[i - 1] && v[i] < v[i + 1])\\n            count++;\\n        i++;\\n    }\\n    return count;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n\\n    vector<int> v;\\n    v.push_back(nums[0]);\\n    for (int i = 1; i < nums.size(); i++)\\n    {\\n        if (nums[i] != nums[i - 1])\\n            v.push_back(nums[i]);\\n    }\\n    int count=0;\\n    int i = 1;\\n    while (i < v.size() - 1)\\n    {\\n        if (v[i] > v[i - 1] && v[i] > v[i + 1])\\n            count++;\\n        else if (v[i] < v[i - 1] && v[i] < v[i + 1])\\n            count++;\\n        i++;\\n    }\\n    return count;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3170115,
                "title": "hills-and-valleys-js-splice-easy-to-undestand-w-comments",
                "content": "# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar countHillValley = function(nums) {\\n    let sum = 0                                                 //store sum of hills and valleys\\n    for (let i = 1; i < nums.length - 1; i++) {                 //loop all nums except fist / last\\n        while (nums[i+1] == nums[i])                            //remove same elements in nums\\n            nums.splice(i + 1, 1)                          \\n        if ( nums[i] > nums[i - 1] &&  nums[i] > nums[i + 1] )  //if hill? -> sum ++\\n            sum ++\\n        if ( nums[i] < nums[i - 1] &&  nums[i] < nums[i + 1] )  //if valley? -> sum ++  \\n            sum ++        \\n    }\\n    return sum          //return sum of hills and valleys\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar countHillValley = function(nums) {\\n    let sum = 0                                                 //store sum of hills and valleys\\n    for (let i = 1; i < nums.length - 1; i++) {                 //loop all nums except fist / last\\n        while (nums[i+1] == nums[i])                            //remove same elements in nums\\n            nums.splice(i + 1, 1)                          \\n        if ( nums[i] > nums[i - 1] &&  nums[i] > nums[i + 1] )  //if hill? -> sum ++\\n            sum ++\\n        if ( nums[i] < nums[i - 1] &&  nums[i] < nums[i + 1] )  //if valley? -> sum ++  \\n            sum ++        \\n    }\\n    return sum          //return sum of hills and valleys\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2732107,
                "title": "two-pointers-python",
                "content": "Two pointers (Python solution)\\n\\nTime complexity: O(n)\\nSpace complexity: O(1)\\n\\n```\\nclass Solution:\\n    def countHillValley(self, nums: List[int]) -> int:\\n        left, right = 1, 2\\n        total = 0\\n        while right < len(nums):\\n            if nums[left] != nums[right]:\\n                if (nums[left-1] < nums[left] and nums[right] < nums[left]) or (nums[left-1] > nums[left] and nums[right] > nums[left]):\\n                    total += 1\\n                left = right\\n            right += 1\\n        return total\\n```\\nThis is my first post. Please give me feedback about it. Cheers!",
                "solutionTags": [
                    "Python",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def countHillValley(self, nums: List[int]) -> int:\\n        left, right = 1, 2\\n        total = 0\\n        while right < len(nums):\\n            if nums[left] != nums[right]:\\n                if (nums[left-1] < nums[left] and nums[right] < nums[left]) or (nums[left-1] > nums[left] and nums[right] > nums[left]):\\n                    total += 1\\n                left = right\\n            right += 1\\n        return total\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2663165,
                "title": "python3",
                "content": "```\\nclass Solution:\\n    def countHillValley(self, nums: List[int]) -> int:\\n        left = None\\n        right = None\\n        total = 0\\n        for i in range(1, len(nums)-1):\\n\\n            if nums[i] == nums[i+1]:\\n                continue\\n            for j in range(-i+1,1):\\n\\n                if nums[-j] < nums[i]:\\n                    \\n                    left = 0\\n                    break\\n                elif nums[-j] > nums[i]:\\n                    left = 1\\n                    break\\n                else:\\n                    continue\\n            for k in range(i+1,len(nums)):\\n\\n                if nums[k] < nums[i]:\\n                    right = 0\\n                    break\\n                elif nums[k] > nums[i]:\\n                    right = 1\\n                    break\\n                else:\\n                    continue\\n\\n            if left == right:\\n                total += 1\\n\\n        return total\\n                \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countHillValley(self, nums: List[int]) -> int:\\n        left = None\\n        right = None\\n        total = 0\\n        for i in range(1, len(nums)-1):\\n\\n            if nums[i] == nums[i+1]:\\n                continue\\n            for j in range(-i+1,1):\\n\\n                if nums[-j] < nums[i]:\\n                    \\n                    left = 0\\n                    break\\n                elif nums[-j] > nums[i]:\\n                    left = 1\\n                    break\\n                else:\\n                    continue\\n            for k in range(i+1,len(nums)):\\n\\n                if nums[k] < nums[i]:\\n                    right = 0\\n                    break\\n                elif nums[k] > nums[i]:\\n                    right = 1\\n                    break\\n                else:\\n                    continue\\n\\n            if left == right:\\n                total += 1\\n\\n        return total\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2647858,
                "title": "c-fastest-and-easy-to-understand-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& n) {\\n        int a=n.size();\\n        int b=0;\\n        for(int i=0;i<a-1;i++)\\n        {\\n            if(n[i]==n[i+1])\\n            {\\n                n.erase(n.begin()+i);\\n                i=i-1;\\n                a=a-1;\\n            }\\n        }\\n        for(int i=1;i<a-1;i++)\\n        {\\n            if((n[i]>n[i-1]&&n[i]>n[i+1])||(n[i]<n[i-1]&&n[i]<n[i+1]))\\n            {\\n                b++;\\n            }\\n        }\\n        return b;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int countHillValley(vector<int>& n) {\\n        int a=n.size();\\n        int b=0;\\n        for(int i=0;i<a-1;i++)\\n        {\\n            if(n[i]==n[i+1])\\n            {\\n                n.erase(n.begin()+i);\\n                i=i-1;\\n                a=a-1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2623247,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        if(nums.size()<3)\\n        {\\n            return 0;\\n        }\\n        int ans=0;\\n        for(int i=1;i<nums.size()-1;)\\n        {\\n            int num=nums[i];\\n            int idx1=i+1;\\n            int idx2=i-1;\\n            while(idx1<nums.size() and nums[idx1]==num)\\n            {\\n                idx1++;\\n            }\\n            while(idx2>0 and nums[idx2]==num)\\n            {\\n                idx2--;\\n            }\\n            if(idx1==nums.size() || idx2<0)\\n            {\\n                break;\\n            }\\n            if((nums[i]<nums[idx1] and nums[i]<nums[idx2]) || (nums[i]>nums[idx1] and nums[i]>nums[idx2]))\\n            {\\n                ans++;\\n            }\\n            i=idx1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        if(nums.size()<3)\\n        {\\n            return 0;\\n        }\\n        int ans=0;\\n        for(int i=1;i<nums.size()-1;)\\n        {\\n            int num=nums[i];\\n            int idx1=i+1;\\n            int idx2=i-1;\\n            while(idx1<nums.size() and nums[idx1]==num)\\n            {\\n                idx1++;\\n            }\\n            while(idx2>0 and nums[idx2]==num)\\n            {\\n                idx2--;\\n            }\\n            if(idx1==nums.size() || idx2<0)\\n            {\\n                break;\\n            }\\n            if((nums[i]<nums[idx1] and nums[i]<nums[idx2]) || (nums[i]>nums[idx1] and nums[i]>nums[idx2]))\\n            {\\n                ans++;\\n            }\\n            i=idx1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2567837,
                "title": "easy-java-solution-beginner-friendly-simple",
                "content": "**If you really found my solution helpful please upvote it, as it motivates me to post such kind of codes and help the coding community, if you have some queries or some improvements please feel free to comment and share your views.**\\n```\\nclass Solution {\\n    public int countHillValley(int[] nums) {\\n        int n = nums.length;\\n        int count = 0;\\n        for(int i = 1;i < n-1; i ++){\\n\\t\\t\\t//assigning the immediate left from the index i\\n            int left = i-1;\\n\\t\\t\\t//assigning the immediate right from the index i\\n            int right = i+1;\\n\\t\\t\\t//Searching for the closest neighbour at the left whose value not equal to the ith index\\n            while(left != 0 && nums[left] == nums[i]){\\n                left--;\\n            }\\n\\t\\t\\t//Searching for the closest neighbour at the right whose value not equal to the ith index and not equal to the left closest neighbour\\n            while(right != n && nums[right] == nums[i] && nums[left] == nums[right]){\\n                right++;\\n            }\\n\\t\\t\\t//checking if any of the left and right index does meet the closest neighbour\\n            if(left == -1 || right == n){\\n                continue;\\n            }\\n\\t\\t\\t//check if its a hill\\n            if(nums[i] > nums[left] && nums[i] > nums[right]){\\n                count++;\\n\\t\\t\\t\\t//if its a hill no need to check if its valley or not\\n                continue;\\n            }\\n\\t\\t\\t//check if its a valley\\n            if(nums[i] < nums[left] && nums[i] < nums[right]){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```\\n**Happy Coding**",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int countHillValley(int[] nums) {\\n        int n = nums.length;\\n        int count = 0;\\n        for(int i = 1;i < n-1; i ++){\\n\\t\\t\\t//assigning the immediate left from the index i\\n            int left = i-1;\\n\\t\\t\\t//assigning the immediate right from the index i\\n            int right = i+1;\\n\\t\\t\\t//Searching for the closest neighbour at the left whose value not equal to the ith index\\n            while(left != 0 && nums[left] == nums[i]){\\n                left--;\\n            }\\n\\t\\t\\t//Searching for the closest neighbour at the right whose value not equal to the ith index and not equal to the left closest neighbour\\n            while(right != n && nums[right] == nums[i] && nums[left] == nums[right]){\\n                right++;\\n            }\\n\\t\\t\\t//checking if any of the left and right index does meet the closest neighbour\\n            if(left == -1 || right == n){\\n                continue;\\n            }\\n\\t\\t\\t//check if its a hill\\n            if(nums[i] > nums[left] && nums[i] > nums[right]){\\n                count++;\\n\\t\\t\\t\\t//if its a hill no need to check if its valley or not\\n                continue;\\n            }\\n\\t\\t\\t//check if its a valley\\n            if(nums[i] < nums[left] && nums[i] < nums[right]){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2551677,
                "title": "java-o-n-with-explanation",
                "content": "\\tclass Solution {\\n\\t\\tpublic int countHillValley(int[] nums) {\\n\\t\\t\\tif(nums.length<=2) return 0;\\n\\t\\t\\tint pre = nums[0]; // record the previous num \\n\\t\\t\\tint res = 0;\\n\\n\\t\\t\\tfor(int i=1; i<nums.length-1; ++i){\\n\\t\\t\\t\\tif(nums[i] == nums[i-1]) continue; // find a duplicate, which could be in the same hills or valley as the previous number, we just ignore \\n\\n\\t\\t\\t\\tint cur=nums[i]; // record current num \\n\\t\\t\\t\\tint next=nums[i+1];// record the next num \\n\\t\\t\\t\\tint j=i+1; \\n\\n\\t\\t\\t\\twhile(next==cur){ // if next == cur, we have to skip it \\n\\t\\t\\t\\t\\tj++;\\n\\t\\t\\t\\t\\tif(j>nums.length-1)break; // if next > nums.length-1, we run out of number; \\n\\t\\t\\t\\t\\tnext = nums[j]; // we find a valid number \\n\\t\\t\\t\\t\\ti=j-1; // i should jump to the last duplicate number of cur \\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif((pre<cur && cur>next) || (pre>cur && next>cur)){ // compute hills or valley \\n\\t\\t\\t\\t\\tres++;\\n\\t\\t\\t\\t} \\n\\t\\t\\t\\tpre = cur; // relocate pre \\n\\t\\t\\t}\\n\\t\\t\\treturn res; \\n\\t\\t}\\n\\t}\\n\\n\\t// time O(n)\\n\\t// space O(1)",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tpublic int countHillValley(int[] nums) {\\n\\t\\t\\tif(nums.length<=2) return 0;\\n\\t\\t\\tint pre = nums[0]; // record the previous num \\n\\t\\t\\tint res = 0;\\n\\n\\t\\t\\tfor(int i=1; i<nums.length-1; ++i){\\n\\t\\t\\t\\tif(nums[i] == nums[i-1]) continue; // find a duplicate, which could be in the same hills or valley as the previous number, we just ignore \\n\\n\\t\\t\\t\\tint cur=nums[i]; // record current num \\n\\t\\t\\t\\tint next=nums[i+1];// record the next num \\n\\t\\t\\t\\tint j=i+1; \\n\\n\\t\\t\\t\\twhile(next==cur){ // if next == cur, we have to skip it \\n\\t\\t\\t\\t\\tj++;\\n\\t\\t\\t\\t\\tif(j>nums.length-1)break; // if next > nums.length-1, we run out of number; \\n\\t\\t\\t\\t\\tnext = nums[j]; // we find a valid number \\n\\t\\t\\t\\t\\ti=j-1; // i should jump to the last duplicate number of cur \\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2501526,
                "title": "easy-fast-solution",
                "content": "```\\nPLEASE UPVOTE IF YOU LIKE\\n```\\n```\\n    public int countHillValley(int[] nums) {\\n        int len = nums.length - 1;\\n        int temp = nums[0];\\n        int count = 0;\\n\\t\\t\\n        for (int i = 1; i < len; i++) {\\n            while (i < len && nums[i] == nums[i+1]) i++;\\n            if (i < len && isHillsOrValleys(temp, nums[i], nums[i+1])) count++;\\n            temp = nums[i];\\n        }\\n        return count;\\n    }\\n    \\n    private boolean isHillsOrValleys(int left, int mid, int right){\\n        return (left > mid && mid < right) || (left < mid && mid > right);\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nPLEASE UPVOTE IF YOU LIKE\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2461987,
                "title": "java-solution-1ms-runtime-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int countHillValley(int[] arr) {\\n        int cnt = 0;\\n        for (int i = 1; i < arr.length - 1; i++) {\\n            if (arr[i] == arr[i-1]) continue;\\n            if (arr[i] == arr[i+1]) {\\n                int right = getRight(arr, i), left = getLeft(arr, i);\\n                if (right == -1 || left == -1) continue;\\n                if (left > arr[i]) {\\n                    if (arr[i] < right) cnt++;\\n                }\\n                else if (left < arr[i]) {\\n                    if (arr[i] > right) cnt++;\\n                }\\n            }\\n            else if (arr[i-1] > arr[i]) {\\n                if (arr[i] < arr[i+1]) cnt++;\\n            }\\n            else if (arr[i-1] < arr[i]) {\\n                if (arr[i] > arr[i+1]) cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n\\n    private static int getLeft(int[] arr, int i) {\\n        for (int k = i-1; k >= 0; k--) {\\n            if (arr[i] != arr[k]) return arr[k];\\n        }\\n        return -1;\\n    }\\n\\n    private static int getRight(int[] arr, int i) {\\n        for (int k = i+1; k < arr.length; k++){\\n            if (arr[i] != arr[k]) return arr[k];\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countHillValley(int[] arr) {\\n        int cnt = 0;\\n        for (int i = 1; i < arr.length - 1; i++) {\\n            if (arr[i] == arr[i-1]) continue;\\n            if (arr[i] == arr[i+1]) {\\n                int right = getRight(arr, i), left = getLeft(arr, i);\\n                if (right == -1 || left == -1) continue;\\n                if (left > arr[i]) {\\n                    if (arr[i] < right) cnt++;\\n                }\\n                else if (left < arr[i]) {\\n                    if (arr[i] > right) cnt++;\\n                }\\n            }\\n            else if (arr[i-1] > arr[i]) {\\n                if (arr[i] < arr[i+1]) cnt++;\\n            }\\n            else if (arr[i-1] < arr[i]) {\\n                if (arr[i] > arr[i+1]) cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n\\n    private static int getLeft(int[] arr, int i) {\\n        for (int k = i-1; k >= 0; k--) {\\n            if (arr[i] != arr[k]) return arr[k];\\n        }\\n        return -1;\\n    }\\n\\n    private static int getRight(int[] arr, int i) {\\n        for (int k = i+1; k < arr.length; k++){\\n            if (arr[i] != arr[k]) return arr[k];\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2435109,
                "title": "q2210-accepted-c-sol-using-two-methods-easy-simple",
                "content": "Solution 1 Using Vector Extra Space\\n```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        int n=nums.size();\\n        int j=0;\\n        int a=0;\\n        for(int i=1;i<n-1;i++){\\n            if((nums[i]>nums[j] && nums[i]>nums[i+1])|| \\n               (nums[j]>nums[i] && nums[i]<nums[i+1])){\\n                a++;\\n                j=i;\\n            }\\n        }\\n        return a;\\n    }\\n};\\n```\\nSolution 2 Using Two Pointer Approach\\n```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        int n=nums.size();\\n        vector <int> v;\\n        v.push_back(nums[0]);\\n        for(int i=1;i<n;i++)\\n            if(nums[i]!=nums[i-1])\\n                v.push_back(nums[i]);\\n        int a=0;\\n        for(int i=1;i<v.size()-1;i++){\\n            if((v[i]>v[i-1] && v[i]>v[i+1])||(v[i]<v[i-1] && v[i]<v[i+1]))\\n                a++;\\n        }\\n        return a;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        int n=nums.size();\\n        int j=0;\\n        int a=0;\\n        for(int i=1;i<n-1;i++){\\n            if((nums[i]>nums[j] && nums[i]>nums[i+1])|| \\n               (nums[j]>nums[i] && nums[i]<nums[i+1])){\\n                a++;\\n                j=i;\\n            }\\n        }\\n        return a;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        int n=nums.size();\\n        vector <int> v;\\n        v.push_back(nums[0]);\\n        for(int i=1;i<n;i++)\\n            if(nums[i]!=nums[i-1])\\n                v.push_back(nums[i]);\\n        int a=0;\\n        for(int i=1;i<v.size()-1;i++){\\n            if((v[i]>v[i-1] && v[i]>v[i+1])||(v[i]<v[i-1] && v[i]<v[i+1]))\\n                a++;\\n        }\\n        return a;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2411775,
                "title": "java-easy-one",
                "content": "```\\nclass Solution {\\n    public int countHillValley(int[] nums) {\\n        int c=0;\\n        for(int i=1;i<nums.length;i++){\\n            int l=i-1;\\n            int r=i+1;\\n            while(l>=0 && nums[l]==nums[i]) l--;\\n            while(r<nums.length && nums[r]==nums[i]) r++;\\n            if(l<0 || r>=nums.length) continue;\\n            if(nums[i]==nums[i+1]) continue;\\n            if(nums[i]>nums[l] && nums[i]>nums[r]) c++;\\n            if(nums[i]<nums[l] && nums[i]<nums[r]) c++;\\n        }\\n        return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countHillValley(int[] nums) {\\n        int c=0;\\n        for(int i=1;i<nums.length;i++){\\n            int l=i-1;\\n            int r=i+1;\\n            while(l>=0 && nums[l]==nums[i]) l--;\\n            while(r<nums.length && nums[r]==nums[i]) r++;\\n            if(l<0 || r>=nums.length) continue;\\n            if(nums[i]==nums[i+1]) continue;\\n            if(nums[i]>nums[l] && nums[i]>nums[r]) c++;\\n            if(nums[i]<nums[l] && nums[i]<nums[r]) c++;\\n        }\\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2316611,
                "title": "simple-traverse-c",
                "content": "**Code :**\\n\\n```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        int n = nums.size();\\n        int last = nums[0];\\n        int hills = 0 , valleys = 0;\\n        \\n        for(int i=1; i<n-1; i++){\\n            if(nums[i]==last){\\n                last = nums[i];\\n                continue;\\n            }\\n            \\n            if(nums[i]>last && nums[i]>nums[i+1])\\n                hills++ , last = nums[i];\\n            else if(nums[i]<last && nums[i]<nums[i+1])\\n                valleys++ , last = nums[i];\\n            \\n        }\\n        \\n        return hills+valleys;\\n    }\\n};\\n```\\n\\nThank You!",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        int n = nums.size();\\n        int last = nums[0];\\n        int hills = 0 , valleys = 0;\\n        \\n        for(int i=1; i<n-1; i++){\\n            if(nums[i]==last){\\n                last = nums[i];\\n                continue;\\n            }\\n            \\n            if(nums[i]>last && nums[i]>nums[i+1])\\n                hills++ , last = nums[i];\\n            else if(nums[i]<last && nums[i]<nums[i+1])\\n                valleys++ , last = nums[i];\\n            \\n        }\\n        \\n        return hills+valleys;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2279305,
                "title": "easy-java-solution-o-n",
                "content": "```\\nclass Solution {\\n    public int countHillValley(int[] nums) {\\n        int count=0;\\n        int prev=nums[0];\\n        \\n        for(int i=1;i<nums.length-1;i++){\\n            if(nums[i]>prev && nums[i]>nums[i+1] || nums[i]<prev && nums[i]<nums[i+1]){\\n                count++;\\n                prev=nums[i];\\n            }\\n        }\\n        return count;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countHillValley(int[] nums) {\\n        int count=0;\\n        int prev=nums[0];\\n        \\n        for(int i=1;i<nums.length-1;i++){\\n            if(nums[i]>prev && nums[i]>nums[i+1] || nums[i]<prev && nums[i]<nums[i+1]){\\n                count++;\\n                prev=nums[i];\\n            }\\n        }\\n        return count;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2242017,
                "title": "java-1-ms-o-n-explained",
                "content": "**The Idea:\\n~ - ~ - ~ -**\\n\\nCreate a \"slopes\" array, in the following manner --->\\n**The first identical digits in nums, will be noted as -1 in the slopes array.**\\nWhen digit is greater than the previous, the \"slope\" will be noted as **1**.\\nWhen digit is smaller than the previous, the \"slope\" will be noted as **0**.\\nWhen digit is equals to the previous, the \"slope\" will be noted **as the previous slope.**\\n\\nThe trick is to count how many times the slope changes, **as long as it not equlas -1.**\\n(Meaning ---> we ignore the beginning).\\n\\nExample:\\n~ - ~ - ~ -\\n\\nArray: >>>>>>>>>>>>>>>>>>>>>>>>>> { 1, 1, 1,  1, 1, 1, 1, 57, 57, 57, 50, 50, 50, 50, 22, 22, 22, 86 }\\nIts corresponding slopes array would be: { -1, -1,-1,-1,-1,-1,-1 ,1   ,1,   1  **(x)**  ,0   ,0  ,0    ,0   ,0   ,0   ,0  **(x)** ,1 }\\nNumber of slope changes (each change designated with x) is **2**.\\n\\nMore examples:\\n~ - ~ - ~ - ~ - ~ -\\n\\n{  6,  5,     10 }\\n{ -1,  0, **(x)** 1 }\\nNumber of slope changes (each change designated with x) is **1**.\\n\\n{ 8, 2,      5, 7, 7,       2,    10,      3,      6,      2}\\n{-1, 0, **(x)** 1, 1, 1, **(x)** 0, **(x)** 1, **(x)** 0, **(x)** 1, **(x)** 0}\\nNumber of slope changes (each change designated with x) is **6**.\\n\\n { 6, 6, 5, 5, 4, 1 }\\n {-1,-1, 0, 0, 0, 0 }\\nNumber of slope changes (each change designated with x) is **0**.\\n\\n{  2, 4,      1, 1,       6,      5 }\\n{ -1, 1, **(x)** 0, 0, **(x)** 1, **(x)** 0 }\\nNumber of slope changes (each change designated with x) is **3**.\\n\\n    public int countHillValley(int[] nums) {\\n        int counter = 0, previous = -1;\\n        int[] slopes = new int[nums.length];\\n        slopes[0] = -1;\\n\\n        if (nums[0] < nums[1]) slopes[1] = 1;\\n        else if (nums[0] > nums[1]) slopes[1] = 0;\\n        else slopes[1] = -1;\\n\\n        for (int i = 2; i < nums.length; i++)\\n            if (nums[i] == nums[i - 1]) slopes[i] = slopes[i - 1];\\n            else if (nums[i] > nums[i - 1]) slopes[i] = 1;\\n            else slopes[i] = 0;\\n\\n        for (int i = 1; i < slopes.length; i++) {\\n            if (previous != -1 && slopes[i] != previous)\\n                counter++;\\n\\n            previous = slopes[i];\\n        }\\n\\n        return counter;\\n    }\\n\\nPlease **upvote** if you liked to solution :)",
                "solutionTags": [
                    "Java"
                ],
                "code": "**The Idea:\\n~ - ~ - ~ -**\\n\\nCreate a \"slopes\" array, in the following manner --->\\n**The first identical digits in nums, will be noted as -1 in the slopes array.**\\nWhen digit is greater than the previous, the \"slope\" will be noted as **1**.\\nWhen digit is smaller than the previous, the \"slope\" will be noted as **0**.\\nWhen digit is equals to the previous, the \"slope\" will be noted **as the previous slope.**\\n\\nThe trick is to count how many times the slope changes, **as long as it not equlas -1.**\\n(Meaning ---> we ignore the beginning).\\n\\nExample:\\n~ - ~ - ~ -\\n\\nArray: >>>>>>>>>>>>>>>>>>>>>>>>>> { 1, 1, 1,  1, 1, 1, 1, 57, 57, 57, 50, 50, 50, 50, 22, 22, 22, 86 }\\nIts corresponding slopes array would be: { -1, -1,-1,-1,-1,-1,-1 ,1   ,1,   1  **(x)**  ,0   ,0  ,0    ,0   ,0   ,0   ,0  **(x)** ,1 }\\nNumber of slope changes (each change designated with x) is **2**.\\n\\nMore examples:\\n~ - ~ - ~ - ~ - ~ -\\n\\n{  6,  5,     10 }\\n{ -1,  0, **(x)** 1 }\\nNumber of slope changes (each change designated with x) is **1**.\\n\\n{ 8, 2,      5, 7, 7,       2,    10,      3,      6,      2}\\n{-1, 0, **(x)** 1, 1, 1, **(x)** 0, **(x)** 1, **(x)** 0, **(x)** 1, **(x)** 0}\\nNumber of slope changes (each change designated with x) is **6**.\\n\\n { 6, 6, 5, 5, 4, 1 }\\n {-1,-1, 0, 0, 0, 0 }\\nNumber of slope changes (each change designated with x) is **0**.\\n\\n{  2, 4,      1, 1,       6,      5 }\\n{ -1, 1, **(x)** 0, 0, **(x)** 1, **(x)** 0 }\\nNumber of slope changes (each change designated with x) is **3**.\\n\\n    public int countHillValley(int[] nums) {\\n        int counter = 0, previous = -1;\\n        int[] slopes = new int[nums.length];\\n        slopes[0] = -1;\\n\\n        if (nums[0] < nums[1]) slopes[1] = 1;\\n        else if (nums[0] > nums[1]) slopes[1] = 0;\\n        else slopes[1] = -1;\\n\\n        for (int i = 2; i < nums.length; i++)\\n            if (nums[i] == nums[i - 1]) slopes[i] = slopes[i - 1];\\n            else if (nums[i] > nums[i - 1]) slopes[i] = 1;\\n            else slopes[i] = 0;\\n\\n        for (int i = 1; i < slopes.length; i++) {\\n            if (previous != -1 && slopes[i] != previous)\\n                counter++;\\n\\n            previous = slopes[i];\\n        }\\n\\n        return counter;\\n    }\\n\\nPlease **upvote** if you liked to solution :)",
                "codeTag": "Unknown"
            },
            {
                "id": 2167204,
                "title": "python-lists-very-easy-to-follow",
                "content": "```\\n def countHillValley(self, nums: List[int]) -> int:\\n        nn=nums.copy()\\n        i = 1\\n        while i < len(nn) and len(nn) > 0:\\n            if nn[i] == nn[i-1]:\\n                nn.pop(i)\\n            else:\\n                i+=1\\n                   \\n        i = 1\\n        count = 0\\n        while i < len(nn)-1:\\n            if nn[i] > nn[i-1] and nn[i] > nn[i+1]:                \\n                count+= 1\\n                i+=1\\n            elif nn[i] < nn[i-1] and nn[i] < nn[i+1]:                \\n                count+= 1\\n                i+=1           \\n            else:                \\n                i+=1\\n                \\n        \\n        return count",
                "solutionTags": [],
                "code": "```\\n def countHillValley(self, nums: List[int]) -> int:\\n        nn=nums.copy()\\n        i = 1\\n        while i < len(nn) and len(nn) > 0:\\n            if nn[i] == nn[i-1]:\\n                nn.pop(i)\\n            else:\\n                i+=1\\n                   \\n        i = 1\\n        count = 0\\n        while i < len(nn)-1:\\n            if nn[i] > nn[i-1] and nn[i] > nn[i+1]:                \\n                count+= 1\\n                i+=1\\n            elif nn[i] < nn[i-1] and nn[i] < nn[i+1]:                \\n                count+= 1\\n                i+=1           \\n            else:                \\n                i+=1\\n                \\n        \\n        return count",
                "codeTag": "Python3"
            },
            {
                "id": 2136198,
                "title": "explained-with-comments-no-extra-space-easy-to-understand-c",
                "content": "**A VERY EASY WAY TO HANDLE DUPLICATES IS TO REPLACE FIRST DUPLICATE WITH IT\\'S PREVIOUS ELEMENT THUS TENDING TO NORMAL CASE!**\\n```\\n  int countHillValley(vector<int>& nums) {\\n        int hv=0;   //hv for total number of hills and valley\\n        int mid=1;     //will do start from index 1 as no need to check for 0th index\\n        while(mid<(nums.size()-1))   //will end with size-2 because last element does not make a hill or valley\\n        {\\n            if((nums[mid]>nums[mid-1] && nums[mid]>nums[mid+1]) || (nums[mid]<nums[mid-1] && nums[mid]<nums[mid+1])) //just put conditions over there for hills and valley\\n                hv++;\\n            else{\\n                if(nums[mid]==nums[mid+1])     //for same element \\n                   nums[mid]= nums[mid-1];       //updating duplicate element with its previous one\\n                }   \\n            mid++;\\n        }\\n        return hv;\\n    }\\n\\t```\\n\\t**PLEASE DO UPVOTE IF YOU UNDERSTAND THE SOLUTION**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n  int countHillValley(vector<int>& nums) {\\n        int hv=0;   //hv for total number of hills and valley\\n        int mid=1;     //will do start from index 1 as no need to check for 0th index\\n        while(mid<(nums.size()-1))   //will end with size-2 because last element does not make a hill or valley\\n        {\\n            if((nums[mid]>nums[mid-1] && nums[mid]>nums[mid+1]) || (nums[mid]<nums[mid-1] && nums[mid]<nums[mid+1])) //just put conditions over there for hills and valley\\n                hv++;\\n            else{\\n                if(nums[mid]==nums[mid+1])     //for same element \\n                   nums[mid]= nums[mid-1];       //updating duplicate element with its previous one\\n                }   \\n            mid++;\\n        }\\n        return hv;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 2064402,
                "title": "java-1ms-alternative-solution",
                "content": "```\\nclass Solution {\\n    /** Algorithm\\n        1. For each index 1 .. n-2 try to expand a search window with 2 indexes: left and right.\\n        2. while (i >= 0 and nums[left] == nums[i]) left--;\\n           while (right < nums.length and nums[right] == nums[i]) right++;\\n           EG: [3,1,1,1,1,17];\\n             #1 step 1 will start from index 1\\n             #2 a. first while will stop at 3 since it\\'s the first index != nums[1]\\n                b. second while will stop at 17 since it\\'s the first index != nums[i];\\n        3. If right >= nums.length break immediately as all the numbers are equal and no hill/valley can exist\\n        4. If left >= 0, check if you have a valley or hill between nums[left], nums[i], nums[right].\\n           If yes, increment the count\\n        5. Our index will be updated with the right index, as this is the first non equal i index. \\n           Everything between i and right will be part of the same hill or valley.\\n    */\\n    public int countHillValley(int[] nums) {\\n        int hillsAndValleys = 0;\\n        int i = 0;\\n        int left, right;\\n        while (i < nums.length -1) {\\n            left = i -1;\\n            right = i +1;\\n            while(left >= 0 && nums[left] == nums[i]) {\\n                left--;\\n            }\\n            while(right < nums.length && nums[right] == nums[i]) {\\n                right++;\\n            }\\n            if (right == nums.length) {\\n                break;\\n            }\\n            if (left >= 0) {\\n                if ((nums[left] < nums[i] && nums[i] > nums[right]) || \\n                    (nums[left] > nums[i] && nums[i] < nums[right])) {\\n                    hillsAndValleys++;\\n                }\\n            }\\n            i = right;\\n        }\\n        return hillsAndValleys;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    /** Algorithm\\n        1. For each index 1 .. n-2 try to expand a search window with 2 indexes: left and right.\\n        2. while (i >= 0 and nums[left] == nums[i]) left--;\\n           while (right < nums.length and nums[right] == nums[i]) right++;\\n           EG: [3,1,1,1,1,17];\\n             #1 step 1 will start from index 1\\n             #2 a. first while will stop at 3 since it\\'s the first index != nums[1]\\n                b. second while will stop at 17 since it\\'s the first index != nums[i];\\n        3. If right >= nums.length break immediately as all the numbers are equal and no hill/valley can exist\\n        4. If left >= 0, check if you have a valley or hill between nums[left], nums[i], nums[right].\\n           If yes, increment the count\\n        5. Our index will be updated with the right index, as this is the first non equal i index. \\n           Everything between i and right will be part of the same hill or valley.\\n    */\\n    public int countHillValley(int[] nums) {\\n        int hillsAndValleys = 0;\\n        int i = 0;\\n        int left, right;\\n        while (i < nums.length -1) {\\n            left = i -1;\\n            right = i +1;\\n            while(left >= 0 && nums[left] == nums[i]) {\\n                left--;\\n            }\\n            while(right < nums.length && nums[right] == nums[i]) {\\n                right++;\\n            }\\n            if (right == nums.length) {\\n                break;\\n            }\\n            if (left >= 0) {\\n                if ((nums[left] < nums[i] && nums[i] > nums[right]) || \\n                    (nums[left] > nums[i] && nums[i] < nums[right])) {\\n                    hillsAndValleys++;\\n                }\\n            }\\n            i = right;\\n        }\\n        return hillsAndValleys;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2061606,
                "title": "approach-using-3-pointers-basic-level-logic-beats-100-submissions-0ms",
                "content": "Basic approach: \\nPointers:\\nInitially, \\'prev\\' will point to 0th index\\n\\'current\\' will point to first index, \\n\\'next\\' will point to second index,\\n\\'count\\' to count hills & valleys\\n\\nLoop till your \\'next\\' reached last index.\\n\\n* (EQUAL NEIGHBOURS) check if your values in current is same as next, if yes , move \\'current\\' and \\'next\\' to +1 index and skip the iteration using continue;\\n* (NON EQUAL NEIGHBOURS-VALLEY) If your current value is less than both \\'prev\\' and \\'next\\', increase your count+1\\n* (NON EQUAL NEIGHBOURS-HILL) If your current value is greater than both \\'prev\\' and \\'next\\', increase your count+1\\n* Finally, make \\'prev\\' index to current, \\'current\\' index to next, and increase next+1; \\n\\nNOTE: You can reduce your space complexity by using i+1 instead of defining \\'next\\', but then you have to make amendments to your algorithm. \\n\\n```\\nclass Solution {\\n    public int countHillValley(int[] nums) {\\n        int count=0;\\n        int prev=0;\\n        int next=2;\\n        int current=1;\\n        while(next<nums.length)\\n        {\\n            if(nums[current]==nums[next])\\n            {  \\n             current+=1;next+=1;\\n             continue;\\n            }\\n            \\n            else\\n            {    \\n            if(nums[prev]>nums[current] && nums[next]>nums[current])\\n            {   \\n                count++;\\n                \\n            }\\n            else if(nums[prev]<nums[curent] && nums[next]<nums[current])\\n            {   \\n                count++; \\n             }\\n            }\\n            prev=current;current=next;next++;\\n            \\n            \\n        }\\n        return(count);\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int countHillValley(int[] nums) {\\n        int count=0;\\n        int prev=0;\\n        int next=2;\\n        int current=1;\\n        while(next<nums.length)\\n        {\\n            if(nums[current]==nums[next])\\n            {  \\n             current+=1;next+=1;\\n             continue;\\n            }\\n            \\n            else\\n            {    \\n            if(nums[prev]>nums[current] && nums[next]>nums[current])\\n            {   \\n                count++;\\n                \\n            }\\n            else if(nums[prev]<nums[curent] && nums[next]<nums[current])\\n            {   \\n                count++; \\n             }\\n            }\\n            prev=current;current=next;next++;\\n            \\n            \\n        }\\n        return(count);\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2046453,
                "title": "java-0ms-beats-100-dp-approach-with-three-variables",
                "content": "My dynamic programming approach used three values (`left`, `mid`, and `right`) to track the elevation values in the array. `right` represented the current array value, and `mid` and `left` were updated as appropriate to reflect the previous elevation trend. \\n\\n<table>\\n<tr ><th>`left`</th><th>`mid`</th><th>`right`</th><th>Value Diagram</th><th>Meaning</th></tr>\\n<tr><td>low</td><td>high</td><td>low</td><td style=\"text-align: center;\">__\\u203E\\u203E__</td><td>hill</td></tr>\\n<tr><td>high</td><td>low</td><td>high</td><td style=\"text-align: center;\">\\u203E\\u203E__\\u203E\\u203E</td><td>valley</td></tr>\\n<tr><td>low</td><td>equal or lower than `left`</td><td>equal or lower than `mid`</td><td style=\"text-align: center;\">\\u203E\\u203E\\u23AF__</td><td>non-increasing trend</td></tr>\\n<tr><td>high</td><td>equal or higher than `left`</td><td>equal or higher than `mid`</td><td style=\"text-align: center;\">__\\u23AF\\u203E\\u203E</td><td>non-decreasing trend</td></tr>\\n</table>\\n\\n```\\n/*\\nRuntime: 0 ms, faster than 100.00% of Java online submissions for Count Hills and Valleys in an Array.\\nMemory Usage: 40.2 MB, less than 93.01% of Java online submissions for Count Hills and Valleys in an Array.\\nElapsed dev time: 0h:24m\\n*/\\n\\nclass Solution {\\n    public int countHillValley(int[] nums) {\\n        \\n        int numHillsValleys = 0;  // what we\\'ll return\\n        \\n        int left = nums[0];\\n        int mid = nums[0];\\n        int right = nums[0];\\n        \\n        for (int i = 0; i < nums.length; ++i) {\\n            \\n            right = nums[i];\\n            \\n            // case: found valley\\n            if (left > mid && mid < right) {\\n                ++numHillsValleys;\\n                left = mid;\\n                mid = right;\\n            }\\n            // case: on non-increasing slope\\n            if (left >= mid && mid >= right) {\\n                mid = right;  // update mid\\n            }\\n            // case: found hill\\n            if (left < mid && mid > right) {\\n                ++numHillsValleys;\\n                left = mid;\\n                mid = right;\\n            }\\n            // case: on non-decreasing slope\\n            if (left <= mid && mid <= right) {\\n                mid = right;  // update mid\\n            }\\n        }\\n        \\n        return numHillsValleys;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\n/*\\nRuntime: 0 ms, faster than 100.00% of Java online submissions for Count Hills and Valleys in an Array.\\nMemory Usage: 40.2 MB, less than 93.01% of Java online submissions for Count Hills and Valleys in an Array.\\nElapsed dev time: 0h:24m\\n*/\\n\\nclass Solution {\\n    public int countHillValley(int[] nums) {\\n        \\n        int numHillsValleys = 0;  // what we\\'ll return\\n        \\n        int left = nums[0];\\n        int mid = nums[0];\\n        int right = nums[0];\\n        \\n        for (int i = 0; i < nums.length; ++i) {\\n            \\n            right = nums[i];\\n            \\n            // case: found valley\\n            if (left > mid && mid < right) {\\n                ++numHillsValleys;\\n                left = mid;\\n                mid = right;\\n            }\\n            // case: on non-increasing slope\\n            if (left >= mid && mid >= right) {\\n                mid = right;  // update mid\\n            }\\n            // case: found hill\\n            if (left < mid && mid > right) {\\n                ++numHillsValleys;\\n                left = mid;\\n                mid = right;\\n            }\\n            // case: on non-decreasing slope\\n            if (left <= mid && mid <= right) {\\n                mid = right;  // update mid\\n            }\\n        }\\n        \\n        return numHillsValleys;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1989771,
                "title": "c-easy-o-n-solution-with-full-explanation",
                "content": "Hey all..\\nI have solved this using 3 Methods in cpp using two pointers and basic traversing and counting.\\nI have commented in the code so that it can be useful..\\nIf you have any doubts be free to ask..\\nand please upvote if you understood or found it useful :)\\n\\nThank you..\\n```\\n// Method 1:- Removing adjacent duplicates and finding.\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        int count=0,n=nums.size();\\n\\t\\t// Creating a new vector to store elements with no adjacency duplicates.\\n        vector<int> ans;\\n\\t\\t\\n\\t\\t//Traversing vector to remove adjacent duplicates.\\n        for(int i=0;i<n-1;i++){\\n            if(nums[i]!=nums[i+1]){\\n                ans.push_back(nums[i]);\\n            }\\n        }\\n\\t\\t// Adding last element because it was missing in the traversal.\\n        if(nums[n-2]!=nums[n-1]){\\n            ans.push_back(nums[n-1]);\\n        }\\n        \\n\\t\\t//If new vector formed has no elements means its monotonic(Increasing or decreasing or all elements are same)\\n        int l=ans.size();\\n        if(l==0 or l==1){\\n            return 0;\\n        }\\n\\t\\t\\n\\t\\t//This is to just check normally any valley or hill appears in new vector and incrementing every time we get it.\\n        for(int i=1;i<ans.size()-1;i++){\\n            if(ans[i]<ans[i-1] and ans[i]<ans[i+1]){\\n                count++;\\n                continue;\\n            }\\n            if(ans[i]>ans[i-1] and ans[i]>ans[i+1]){\\n                count++;\\n                continue;\\n            }\\n        }\\n        return count;\\n\\n\\n// Method 2:- Same as method 1,but tricky one..\\n           int hills =0;\\n           int valleys = 0;\\n           for(int i=1;i<nums.size()-1;i++){\\n               if(nums[i-1]<nums[i] && nums[i]>nums[i+1])\\n                   hills++;\\n               else if(nums[i-1]>nums[i] && nums[i]<nums[i+1])\\n                   valleys++;\\n\\t\\t\\t  // Same above method,but in this if we find any adjacent duplicates,we just replace first duplicate one by its previous element.\\n              else nums[i]=nums[i-1];\\n           }\\n           return hills+valleys;\\n        \\n// Method 3 :- Two pointers\\n      int countHillValley(vector<int>& nums) {\\n           int count = 0;\\n           for (int i = 1, j = 0; i < nums.size() - 1; ++i)\\n           if ((nums[j] < nums[i] && nums[i] > nums [i + 1]) || \\n               (nums[j] > nums[i] && nums[i] < nums [i + 1])) {\\n               ++count;\\n               j = i;\\n           }            \\n           return count;\\n          }\\n \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\n// Method 1:- Removing adjacent duplicates and finding.\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        int count=0,n=nums.size();\\n\\t\\t// Creating a new vector to store elements with no adjacency duplicates.\\n        vector<int> ans;\\n\\t\\t\\n\\t\\t//Traversing vector to remove adjacent duplicates.\\n        for(int i=0;i<n-1;i++){\\n            if(nums[i]!=nums[i+1]){\\n                ans.push_back(nums[i]);\\n            }\\n        }\\n\\t\\t// Adding last element because it was missing in the traversal.\\n        if(nums[n-2]!=nums[n-1]){\\n            ans.push_back(nums[n-1]);\\n        }\\n        \\n\\t\\t//If new vector formed has no elements means its monotonic(Increasing or decreasing or all elements are same)\\n        int l=ans.size();\\n        if(l==0 or l==1){\\n            return 0;\\n        }\\n\\t\\t\\n\\t\\t//This is to just check normally any valley or hill appears in new vector and incrementing every time we get it.\\n        for(int i=1;i<ans.size()-1;i++){\\n            if(ans[i]<ans[i-1] and ans[i]<ans[i+1]){\\n                count++;\\n                continue;\\n            }\\n            if(ans[i]>ans[i-1] and ans[i]>ans[i+1]){\\n                count++;\\n                continue;\\n            }\\n        }\\n        return count;\\n\\n\\n// Method 2:- Same as method 1,but tricky one..\\n           int hills =0;\\n           int valleys = 0;\\n           for(int i=1;i<nums.size()-1;i++){\\n               if(nums[i-1]<nums[i] && nums[i]>nums[i+1])\\n                   hills++;\\n               else if(nums[i-1]>nums[i] && nums[i]<nums[i+1])\\n                   valleys++;\\n\\t\\t\\t  // Same above method,but in this if we find any adjacent duplicates,we just replace first duplicate one by its previous element.\\n              else nums[i]=nums[i-1];\\n           }\\n           return hills+valleys;\\n        \\n// Method 3 :- Two pointers\\n      int countHillValley(vector<int>& nums) {\\n           int count = 0;\\n           for (int i = 1, j = 0; i < nums.size() - 1; ++i)\\n           if ((nums[j] < nums[i] && nums[i] > nums [i + 1]) || \\n               (nums[j] > nums[i] && nums[i] < nums [i + 1])) {\\n               ++count;\\n               j = i;\\n           }            \\n           return count;\\n          }\\n \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1976013,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int countHillValley(int[] nums) {\\n        int count = 0;\\n        for(int i=1; i<nums.length-1; i++){\\n            int pre = i-1;\\n            if(nums[i] == nums[i+1]){\\n                while(nums[i]==nums[i+1] && i<nums.length-2){\\n                    i++;\\n                }\\n            }\\n            if((nums[i] > nums[pre] && nums[i] > nums[i+1]) || (nums[i] < nums[pre] && nums[i] < nums[i+1])){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "class Solution {\\n    public int countHillValley(int[] nums) {\\n        int count = 0;\\n        for(int i=1; i<nums.length-1; i++){\\n            int pre = i-1;\\n            if(nums[i] == nums[i+1]){\\n                while(nums[i]==nums[i+1] && i<nums.length-2){\\n                    i++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1959470,
                "title": "simple-java-solution-with-comment-o-n-time-o-1-space",
                "content": "```\\nclass Solution {\\n    //balance will be 1 if hill and -1 if valley, and count will be updated based on the last balance value\\n    public int countHillValley(int[] nums) {\\n        int count = 0;\\n        int balance = 0;\\n        for(int i=1; i<nums.length; i++) {\\n            if(nums[i] > nums[i-1]) {\\n                if(balance == -1)\\n                    count++;\\n                balance = 1;\\n            }\\n            if(nums[i] < nums[i-1]) {\\n                if(balance == 1)\\n                    count++;\\n                balance = -1;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    //balance will be 1 if hill and -1 if valley, and count will be updated based on the last balance value\\n    public int countHillValley(int[] nums) {\\n        int count = 0;\\n        int balance = 0;\\n        for(int i=1; i<nums.length; i++) {\\n            if(nums[i] > nums[i-1]) {\\n                if(balance == -1)\\n                    count++;\\n                balance = 1;\\n            }\\n            if(nums[i] < nums[i-1]) {\\n                if(balance == 1)\\n                    count++;\\n                balance = -1;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908197,
                "title": "python-linear-solution",
                "content": "Traverse the array\\'s internal elements (from ``1`` to ``n-1``) and maintaining previous and current values, and comparing to the next value. For the current skipping all values equal to current (since adjacent equal elements are parts pf the same hill or valley).\\n\\n```\\nclass Solution:\\n    def countHillValley(self, nums: List[int]) -> int:\\n        cnt = 0\\n        n = len(nums)\\n        prev = nums[0]\\n        i = 1\\n        while i < n-1:\\n            current = nums[i]\\n            while i < n-1 and nums[i] == nums[i+1]:\\n                i += 1\\n            if i >= n-1:\\n                break\\n            if current < prev and current < nums[i+1] or \\\\\\n               current > prev and current > nums[i+1]:\\n                cnt += 1\\n            prev = current\\n            i += 1\\n        return cnt\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countHillValley(self, nums: List[int]) -> int:\\n        cnt = 0\\n        n = len(nums)\\n        prev = nums[0]\\n        i = 1\\n        while i < n-1:\\n            current = nums[i]\\n            while i < n-1 and nums[i] == nums[i+1]:\\n                i += 1\\n            if i >= n-1:\\n                break\\n            if current < prev and current < nums[i+1] or \\\\\\n               current > prev and current > nums[i+1]:\\n                cnt += 1\\n            prev = current\\n            i += 1\\n        return cnt\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1903461,
                "title": "easy-javascript",
                "content": "```\\nvar countHillValley = function(nums) {\\n    let arr=[];\\n    for(let i=0; i<nums.length; i++){\\n      if(nums[i]!==nums[i-1]){arr.push(nums[i]);}\\n    }\\n    let count=0;\\n    for(let i=1; i<arr.length-1; i++){\\n      if(arr[i-1]<arr[i] && arr[i+1]<arr[i]){count++;}\\n      else if(arr[i-1]>arr[i] && arr[i+1]>arr[i]){count++;}\\n    }\\n    return count; \\n}; \\n```",
                "solutionTags": [],
                "code": "```\\nvar countHillValley = function(nums) {\\n    let arr=[];\\n    for(let i=0; i<nums.length; i++){\\n      if(nums[i]!==nums[i-1]){arr.push(nums[i]);}\\n    }\\n    let count=0;\\n    for(let i=1; i<arr.length-1; i++){\\n      if(arr[i-1]<arr[i] && arr[i+1]<arr[i]){count++;}\\n      else if(arr[i-1]>arr[i] && arr[i+1]>arr[i]){count++;}\\n    }\\n    return count; \\n}; \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1894612,
                "title": "2210-count-hills-and-valleys-in-an-array",
                "content": "```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& v) {\\n     \\n        int n = v.size();\\n        \\n        int c = 0;\\n        \\n        for(int i=1;i<n-1;i++){\\n            if(i!=1 && v[i]==v[i-1]) continue;\\n            \\n            int l = i-1 , h = i+1;\\n            \\n            while(l>=0 && v[l]==v[i]) l--;\\n            while(h<n  && v[h]==v[i]) h++;\\n            \\n            if(l<0 || h>=n) continue;\\n            \\n            if(v[i] > v[l] && v[i] > v[h]) c++;\\n            if(v[i] < v[l] && v[i] < v[h]) c++;\\n        }\\n        \\n        return c;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& v) {\\n     \\n        int n = v.size();\\n        \\n        int c = 0;\\n        \\n        for(int i=1;i<n-1;i++){\\n            if(i!=1 && v[i]==v[i-1]) continue;\\n            \\n            int l = i-1 , h = i+1;\\n            \\n            while(l>=0 && v[l]==v[i]) l--;\\n            while(h<n  && v[h]==v[i]) h++;\\n            \\n            if(l<0 || h>=n) continue;\\n            \\n            if(v[i] > v[l] && v[i] > v[h]) c++;\\n            if(v[i] < v[l] && v[i] < v[h]) c++;\\n        }\\n        \\n        return c;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1892793,
                "title": "java-1ms-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int countHillValley(int[] nums) {\\n        int res=0;\\n        // left pointer will being updated only when is encountered with valley or hill\\n        // to solve the problem with adjent indices since they are the same part of hill or valley \\n       int left=nums[0];\\n        \\n        for(int i=1;i<nums.length-1;i++)\\n        {\\n          \\n            int right = nums[i+1];\\n            int curr = nums[i];\\n          \\n          \\n         \\n          \\n        if((curr>left && curr>right)||(curr<left && curr<right))\\n        {\\n              res++;\\n              left=nums[i];\\n        }\\n                  \\n      \\n        \\n            \\n\\n        }\\n        return res;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int countHillValley(int[] nums) {\\n        int res=0;\\n        // left pointer will being updated only when is encountered with valley or hill\\n        // to solve the problem with adjent indices since they are the same part of hill or valley \\n       int left=nums[0];\\n        \\n        for(int i=1;i<nums.length-1;i++)\\n        {\\n          \\n            int right = nums[i+1];\\n            int curr = nums[i];\\n          \\n          \\n         \\n          \\n        if((curr>left && curr>right)||(curr<left && curr<right))\\n        {\\n              res++;\\n              left=nums[i];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1888448,
                "title": "python-solution-o-n-linear-time-and-space-over-90-faster",
                "content": "First, obtain a new list containing the unique adjacent values only!\\nApply hill and valley checks on each element of new list!\\n```\\ndef countHillValley(self, nums: List[int]) -> int:\\n        uniqs = [nums[0]]\\n        for i in range(1,len(nums)):\\n            if nums[i] != nums[i-1]:\\n                uniqs.append(nums[i])\\n        print(uniqs)\\n        ans = 0\\n        for i in range(1,len(uniqs)-1):\\n            if uniqs[i] > uniqs[i-1] and uniqs[i] > uniqs[i+1]:\\n                # hill case\\n                ans += 1\\n            if uniqs[i] < uniqs[i-1] and uniqs[i] < uniqs[i+1]:\\n                # valley case\\n                ans += 1\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef countHillValley(self, nums: List[int]) -> int:\\n        uniqs = [nums[0]]\\n        for i in range(1,len(nums)):\\n            if nums[i] != nums[i-1]:\\n                uniqs.append(nums[i])\\n        print(uniqs)\\n        ans = 0\\n        for i in range(1,len(uniqs)-1):\\n            if uniqs[i] > uniqs[i-1] and uniqs[i] > uniqs[i+1]:\\n                # hill case\\n                ans += 1\\n            if uniqs[i] < uniqs[i-1] and uniqs[i] < uniqs[i+1]:\\n                # valley case\\n                ans += 1\\n        return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1886080,
                "title": "python-one-pass-o-n-time-o-1-space",
                "content": "**Algorithm Details**\\n* Keep track of previous potential hill/valley\\n* If flat surface i.e equal elements keep incrementing\\n* Check if new unequal element is same as before or not, if yes increment count\\n\\n```\\nclass Solution:\\n    def countHillValley(self, nums: List[int]) -> int:\\n        prev = None; cnt = 0\\n        for i in range(len(nums)):\\n            while i < len(nums) - 1 and nums[i+1] == nums[i]:\\n                i += 1\\n            \\n\\t\\t\\t# edge case 1: end of array\\n            if i+1 >= len(nums):\\n                break\\n            \\n\\t\\t\\t#edge case 2: start of array\\n            if prev == None:\\n                prev = nums[i]\\n                continue\\n            \\n            if ( prev > nums[i] and nums[i+1] > nums[i] ) or ( prev < nums[i] and nums[i+1] < nums[i] ):\\n                cnt += 1\\n                \\n            prev = nums[i]\\n            \\n        return cnt\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countHillValley(self, nums: List[int]) -> int:\\n        prev = None; cnt = 0\\n        for i in range(len(nums)):\\n            while i < len(nums) - 1 and nums[i+1] == nums[i]:\\n                i += 1\\n            \\n\\t\\t\\t# edge case 1: end of array\\n            if i+1 >= len(nums):\\n                break\\n            \\n\\t\\t\\t#edge case 2: start of array\\n            if prev == None:\\n                prev = nums[i]\\n                continue\\n            \\n            if ( prev > nums[i] and nums[i+1] > nums[i] ) or ( prev < nums[i] and nums[i+1] < nums[i] ):\\n                cnt += 1\\n                \\n            prev = nums[i]\\n            \\n        return cnt\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1883086,
                "title": "count-hills-and-valleys-in-an-array",
                "content": "int countHillValley(vector<int>& nums) {\\n        int count=0,n=nums.size();\\n        for(int i=1;i<n-1;i++){\\n           \\n            if(nums[i]==nums[i-1]){\\n                continue;\\n            }\\n             int j=i-1,k=i+1;\\n            \\n            while(k<n && nums[i]==nums[k]){\\n                k++;\\n            }\\n            \\n            while(j>=0 && nums[i]==nums[j]){\\n                j--;\\n            }\\n            \\n            if(k>=n || j<0){\\n                continue;\\n            }\\n            \\n            if(nums[i]>nums[k] && nums[i]>nums[j]){\\n                count++;\\n            }\\n            else if(nums[i]<nums[k] && nums[i]<nums[j]){\\n                count++;\\n            }\\n            \\n        }\\n        return count;\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "int countHillValley(vector<int>& nums) {\\n        int count=0,n=nums.size();\\n        for(int i=1;i<n-1;i++){\\n           \\n            if(nums[i]==nums[i-1]){\\n                continue;\\n            }\\n             int j=i-1,k=i+1;\\n            \\n            while(k<n && nums[i]==nums[k]){\\n                k++;\\n            }\\n            \\n            while(j>=0 && nums[i]==nums[j]){\\n                j--;\\n            }\\n            \\n            if(k>=n || j<0){\\n                continue;\\n            }\\n            \\n            if(nums[i]>nums[k] && nums[i]>nums[j]){\\n                count++;\\n            }\\n            else if(nums[i]<nums[k] && nums[i]<nums[j]){\\n                count++;\\n            }\\n            \\n        }\\n        return count;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1870613,
                "title": "rust-solution",
                "content": "```\\nimpl Solution {\\n    pub fn count_hill_valley(nums: Vec<i32>) -> i32 {\\n        let mut cur_sign;\\n        let mut count = 0;\\n        let mut prev_sign = 0;\\n        for (&x, &y) in nums.iter().zip(nums[1..].iter()).filter(|(x, y)| x != y) {\\n            cur_sign = (y - x).signum();\\n            if cur_sign != prev_sign && prev_sign != 0 {\\n                count += 1;\\n            }\\n            prev_sign = cur_sign;\\n        }\\n        count\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn count_hill_valley(nums: Vec<i32>) -> i32 {\\n        let mut cur_sign;\\n        let mut count = 0;\\n        let mut prev_sign = 0;\\n        for (&x, &y) in nums.iter().zip(nums[1..].iter()).filter(|(x, y)| x != y) {\\n            cur_sign = (y - x).signum();\\n            if cur_sign != prev_sign && prev_sign != 0 {\\n                count += 1;\\n            }\\n            prev_sign = cur_sign;\\n        }\\n        count\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1870313,
                "title": "a-few-solutions",
                "content": "*Kotlin*\\n```\\nclass Solution {\\n    fun countHillValley(A: IntArray): Int {\\n        var cnt = 0\\n        for (i in 1 until A.size - 1) {\\n            if (A[i] == A[i + 1])\\n                A[i] = A[i - 1]\\n            cnt += if (A[i - 1] < A[i] && A[i] > A[i + 1]) 1 else 0\\n            cnt += if (A[i - 1] > A[i] && A[i] < A[i + 1]) 1 else 0\\n        }\\n        return cnt\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet countHillValley = (A, cnt = 0) => {\\n    for (let i = 1; i + 1 < A.length; ++i) {\\n        if (A[i] == A[i + 1])\\n            A[i] = A[i - 1];\\n        cnt += Number(A[i - 1] < A[i] && A[i] > A[i + 1]);\\n        cnt += Number(A[i - 1] > A[i] && A[i] < A[i + 1]);\\n    }\\n    return cnt;\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def countHillValley(self, A: List[int], cnt = 0) -> int:\\n        for i in range(1, len(A) - 1):\\n            if A[i] == A[i + 1]:\\n                A[i] = A[i - 1]\\n            cnt += int(A[i - 1] < A[i] > A[i + 1])\\n            cnt += int(A[i - 1] > A[i] < A[i + 1])\\n        return cnt\\n```\\n\\n*Rust*\\n```\\ntype VI = Vec<i32>;\\nimpl Solution {\\n    pub fn count_hill_valley(A_: VI) -> i32 {\\n        let mut cnt = 0;\\n        let mut A = A_.clone();\\n        for i in 1..A.len() - 1 {\\n            if A[i] == A[i + 1] {\\n                A[i] = A[i - 1];\\n            }\\n            cnt += if A[i - 1] < A[i] && A[i] > A[i + 1] { 1 } else { 0 };\\n            cnt += if A[i - 1] > A[i] && A[i] < A[i + 1] { 1 } else { 0 };\\n        }\\n        return cnt;\\n    }\\n}\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    int countHillValley(VI& A, int cnt = 0) {\\n        for (auto i{ 1 }; i + 1 < A.size(); ++i) {\\n            if (A[i] == A[i + 1])\\n                A[i] = A[i - 1];\\n            cnt += A[i - 1] > A[i] && A[i] < A[i + 1];\\n            cnt += A[i - 1] < A[i] && A[i] > A[i + 1];\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun countHillValley(A: IntArray): Int {\\n        var cnt = 0\\n        for (i in 1 until A.size - 1) {\\n            if (A[i] == A[i + 1])\\n                A[i] = A[i - 1]\\n            cnt += if (A[i - 1] < A[i] && A[i] > A[i + 1]) 1 else 0\\n            cnt += if (A[i - 1] > A[i] && A[i] < A[i + 1]) 1 else 0\\n        }\\n        return cnt\\n    }\\n}\\n```\n```\\nlet countHillValley = (A, cnt = 0) => {\\n    for (let i = 1; i + 1 < A.length; ++i) {\\n        if (A[i] == A[i + 1])\\n            A[i] = A[i - 1];\\n        cnt += Number(A[i - 1] < A[i] && A[i] > A[i + 1]);\\n        cnt += Number(A[i - 1] > A[i] && A[i] < A[i + 1]);\\n    }\\n    return cnt;\\n};\\n```\n```\\nclass Solution:\\n    def countHillValley(self, A: List[int], cnt = 0) -> int:\\n        for i in range(1, len(A) - 1):\\n            if A[i] == A[i + 1]:\\n                A[i] = A[i - 1]\\n            cnt += int(A[i - 1] < A[i] > A[i + 1])\\n            cnt += int(A[i - 1] > A[i] < A[i + 1])\\n        return cnt\\n```\n```\\ntype VI = Vec<i32>;\\nimpl Solution {\\n    pub fn count_hill_valley(A_: VI) -> i32 {\\n        let mut cnt = 0;\\n        let mut A = A_.clone();\\n        for i in 1..A.len() - 1 {\\n            if A[i] == A[i + 1] {\\n                A[i] = A[i - 1];\\n            }\\n            cnt += if A[i - 1] < A[i] && A[i] > A[i + 1] { 1 } else { 0 };\\n            cnt += if A[i - 1] > A[i] && A[i] < A[i + 1] { 1 } else { 0 };\\n        }\\n        return cnt;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    int countHillValley(VI& A, int cnt = 0) {\\n        for (auto i{ 1 }; i + 1 < A.size(); ++i) {\\n            if (A[i] == A[i + 1])\\n                A[i] = A[i - 1];\\n            cnt += A[i - 1] > A[i] && A[i] < A[i + 1];\\n            cnt += A[i - 1] < A[i] && A[i] > A[i + 1];\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1868506,
                "title": "java-solutions",
                "content": "**Time: O(n) Space: O(n)**\\n```\\nclass Solution {\\n  public int countHillValley(int[] nums) {\\n    List<Integer> uniqueVals = new ArrayList<>();\\n    for (int n : nums) {\\n      if (uniqueVals.isEmpty() || uniqueVals.get(uniqueVals.size() - 1) != n) {\\n        uniqueVals.add(n);\\n      }\\n    }\\n    int count = 0;\\n    for (int i = 1; i < uniqueVals.size() - 1; i++) {\\n      if ((uniqueVals.get(i) > uniqueVals.get(i - 1))\\n          == (uniqueVals.get(i) > uniqueVals.get(i + 1))) {\\n        count++;\\n      }\\n    }\\n    return count;\\n  }\\n}\\n```\\n\\nSimple example of uniqueVals:\\n![image](https://assets.leetcode.com/users/images/ad0f1077-c405-4338-98b6-3ffc257527a3_1647811688.047779.png)\\n\\n\\nIt is not necessary to keep track of all the unique values, we can just keep track of three:\\nhttps://leetcode.com/problems/count-hills-and-valleys-in-an-array/discuss/1865658/Easiest-C++-Solution-oror-Two-Pointers/1316542\\n**Time: O(n) Space: O(1)**\\n```\\nclass Solution {\\n  public int countHillValley(int[] nums) {\\n    int unique1 = -1, unique2 = -1, count = 0;\\n    for (int unique3 : nums) {\\n      if (unique3 != unique2) {\\n        if (unique1 != -1 && (unique2 > unique3) == (unique2 > unique1)) count++;\\n        unique1 = unique2;\\n        unique2 = unique3;\\n      }\\n    }\\n    return count;\\n  }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n  public int countHillValley(int[] nums) {\\n    List<Integer> uniqueVals = new ArrayList<>();\\n    for (int n : nums) {\\n      if (uniqueVals.isEmpty() || uniqueVals.get(uniqueVals.size() - 1) != n) {\\n        uniqueVals.add(n);\\n      }\\n    }\\n    int count = 0;\\n    for (int i = 1; i < uniqueVals.size() - 1; i++) {\\n      if ((uniqueVals.get(i) > uniqueVals.get(i - 1))\\n          == (uniqueVals.get(i) > uniqueVals.get(i + 1))) {\\n        count++;\\n      }\\n    }\\n    return count;\\n  }\\n}\\n```\n```\\nclass Solution {\\n  public int countHillValley(int[] nums) {\\n    int unique1 = -1, unique2 = -1, count = 0;\\n    for (int unique3 : nums) {\\n      if (unique3 != unique2) {\\n        if (unique1 != -1 && (unique2 > unique3) == (unique2 > unique1)) count++;\\n        unique1 = unique2;\\n        unique2 = unique3;\\n      }\\n    }\\n    return count;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1868455,
                "title": "java-0ms-beats-100",
                "content": "```\\n public int countHillValley(int[] nums) {\\n        int count=0;\\n        int nonEqL=0;\\n        int nonEqR=0;\\n        for(int i=1; i<nums.length-1; i++) {\\n            if(nums[i] != nums[i-1]) {  //set non equal left\\n                nonEqL = nums[i-1];\\n            }\\n            \\n            if(nums[i] != nums[i+1]) {  //set non equal right\\n                nonEqR = nums[i+1];\\n            }\\n            //should either be greater than both non equal left and non eq right to be counted as a hill\\n\\t\\t\\t// OR less than both non equal left and non eq right to be counted as a valley\\n            if((nonEqL != 0 && nonEqR != 0) \\n               && ((nums[i] > nonEqL && nums[i] > nonEqR) \\n                    || (nums[i] < nonEqL && nums[i] < nonEqR))) { \\n                count++;\\n            }\\n        }\\n        \\n        return count;\\n    \\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n public int countHillValley(int[] nums) {\\n        int count=0;\\n        int nonEqL=0;\\n        int nonEqR=0;\\n        for(int i=1; i<nums.length-1; i++) {\\n            if(nums[i] != nums[i-1]) {  //set non equal left\\n                nonEqL = nums[i-1];\\n            }\\n            \\n            if(nums[i] != nums[i+1]) {  //set non equal right\\n                nonEqR = nums[i+1];\\n            }\\n            //should either be greater than both non equal left and non eq right to be counted as a hill\\n\\t\\t\\t// OR less than both non equal left and non eq right to be counted as a valley\\n            if((nonEqL != 0 && nonEqR != 0) \\n               && ((nums[i] > nonEqL && nums[i] > nonEqR) \\n                    || (nums[i] < nonEqL && nums[i] < nonEqR))) { \\n                count++;\\n            }\\n        }\\n        \\n        return count;\\n    \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1868448,
                "title": "java-easy-o-n-count-hills-and-valleys-with-comments",
                "content": "```\\nclass Solution {\\n    public int countHillValley(int[] nums) {\\n        \\n        int count=0;\\n        \\n        for ( int i=1 ; i < nums.length-1 ; i++)  \\n        {\\n            // 1. find  hill \\n            // left neighbor smaller\\n            if(nums[i-1] < nums[i] ) \\n            {\\n                // skip all equal number \\n                 while(  i < nums.length-1 && (nums[i] == nums[i+1] ))\\n                     i++;\\n                \\n                 // if we get right closest neighbor is smaller , this is hill\\n                 if ( i < nums.length-1 && nums[i+1] < nums[i])\\n                   count++;\\n            }   \\n             // 1. find  Valley\\n              // left neighbor greater\\n            else if(nums[i-1] > nums[i] ) \\n            {\\n                // skip all equal number \\n                 while(i < nums.length-1 && (nums[i] == nums[i+1] ))\\n                     i++;\\n                 // if we get right closest neighbor is greater , this is Valley\\n               if ( i < nums.length-1 && nums[i+1] > nums[i])\\n                   count++;\\n            } \\n        }\\n        \\n        return count;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countHillValley(int[] nums) {\\n        \\n        int count=0;\\n        \\n        for ( int i=1 ; i < nums.length-1 ; i++)  \\n        {\\n            // 1. find  hill \\n            // left neighbor smaller\\n            if(nums[i-1] < nums[i] ) \\n            {\\n                // skip all equal number \\n                 while(  i < nums.length-1 && (nums[i] == nums[i+1] ))\\n                     i++;\\n                \\n                 // if we get right closest neighbor is smaller , this is hill\\n                 if ( i < nums.length-1 && nums[i+1] < nums[i])\\n                   count++;\\n            }   \\n             // 1. find  Valley\\n              // left neighbor greater\\n            else if(nums[i-1] > nums[i] ) \\n            {\\n                // skip all equal number \\n                 while(i < nums.length-1 && (nums[i] == nums[i+1] ))\\n                     i++;\\n                 // if we get right closest neighbor is greater , this is Valley\\n               if ( i < nums.length-1 && nums[i+1] > nums[i])\\n                   count++;\\n            } \\n        }\\n        \\n        return count;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1868412,
                "title": "inplace-c-o-n-two-pointer",
                "content": "# Steps\\n* **Remove the duplicates** from the original array.(**using two pointer**)\\n* **Count the Hills and Valleys** `nums[i - 1] >  nums[i] && nums[i] < nums[i + 1])` for valley and `nums[i - 1] <  nums[i] && nums[i] > nums[i + 1]` for Hills.\\n* **Time Complexity is O(n) and space complexity os O(1) so inplace algorithm**\\n```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        cout.tie(NULL);\\n\\n        int count = 0;\\n        int i = 0,j = 1;\\n        while(j != nums.size()){\\n            if(nums[i] != nums[j]){\\n                i++;\\n                nums[i] = nums[j];\\n                j++;\\n            }\\n            else{\\n                j++;\\n            }\\n        }\\n        while(i < nums.size() - 1){\\n            nums.pop_back();\\n        }\\n        for(int i = 1;i < nums.size() - 1;i++){\\n            if(nums[i - 1] >  nums[i] && nums[i] < nums[i + 1]){\\n                count ++;\\n            }\\n            else if(nums[i - 1] <  nums[i] && nums[i] > nums[i + 1]){\\n                count ++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        cout.tie(NULL);\\n\\n        int count = 0;\\n        int i = 0,j = 1;\\n        while(j != nums.size()){\\n            if(nums[i] != nums[j]){\\n                i++;\\n                nums[i] = nums[j];\\n                j++;\\n            }\\n            else{\\n                j++;\\n            }\\n        }\\n        while(i < nums.size() - 1){\\n            nums.pop_back();\\n        }\\n        for(int i = 1;i < nums.size() - 1;i++){\\n            if(nums[i - 1] >  nums[i] && nums[i] < nums[i + 1]){\\n                count ++;\\n            }\\n            else if(nums[i - 1] <  nums[i] && nums[i] > nums[i + 1]){\\n                count ++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1868305,
                "title": "cpp-c-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        int counter=0;\\n        nums = remove(nums);\\n        for(int i=1;i<nums.size()-1;i++){\\n            if(nums[i] > nums[i+1] && nums[i] > nums[i-1]) { counter++; }\\n            else if(nums[i] < nums[i+1] && nums[i] < nums[i-1]) { counter++; }\\n        }\\n        \\n        return counter;\\n    }\\npublic:\\n    vector<int> remove(vector<int> &temp){\\n        vector<int> ans;\\n        for(int i=0;i<temp.size()-1;i++){\\n            if(temp[i] != temp[i+1])\\n                ans.push_back(temp[i]);\\n        }\\n        ans.push_back(temp[temp.size()-1]);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        int counter=0;\\n        nums = remove(nums);\\n        for(int i=1;i<nums.size()-1;i++){\\n            if(nums[i] > nums[i+1] && nums[i] > nums[i-1]) { counter++; }\\n            else if(nums[i] < nums[i+1] && nums[i] < nums[i-1]) { counter++; }\\n        }\\n        \\n        return counter;\\n    }\\npublic:\\n    vector<int> remove(vector<int> &temp){\\n        vector<int> ans;\\n        for(int i=0;i<temp.size()-1;i++){\\n            if(temp[i] != temp[i+1])\\n                ans.push_back(temp[i]);\\n        }\\n        ans.push_back(temp[temp.size()-1]);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1867498,
                "title": "c-soln",
                "content": "```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) \\n    {\\n        int n = nums.size();\\n        int res=0;\\n        \\n        \\n        for(int i=1;i<n-1;i++)\\n        {\\n            //removing duplicates\\n            if(nums[i]==nums[i-1]) continue;\\n            \\n            int left = i-1;\\n            int right = i+1;\\n            \\n            // finding unique number to the left\\n            while(left>0 && nums[left]==nums[i])\\n                left--;\\n            \\n            // finding unique number to the right\\n            while(right<n-1 && nums[right]==nums[i])\\n                right++;\\n            \\n            //hill\\n            if(nums[left] < nums[i] && nums[right] < nums[i])\\n                res++;\\n            //valley\\n            else if(nums[left] > nums[i] && nums[right] > nums[i])\\n                res++;\\n            \\n        }\\n        \\n         return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) \\n    {\\n        int n = nums.size();\\n        int res=0;\\n        \\n        \\n        for(int i=1;i<n-1;i++)\\n        {\\n            //removing duplicates\\n            if(nums[i]==nums[i-1]) continue;\\n            \\n            int left = i-1;\\n            int right = i+1;\\n            \\n            // finding unique number to the left\\n            while(left>0 && nums[left]==nums[i])\\n                left--;\\n            \\n            // finding unique number to the right\\n            while(right<n-1 && nums[right]==nums[i])\\n                right++;\\n            \\n            //hill\\n            if(nums[left] < nums[i] && nums[right] < nums[i])\\n                res++;\\n            //valley\\n            else if(nums[left] > nums[i] && nums[right] > nums[i])\\n                res++;\\n            \\n        }\\n        \\n         return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1866949,
                "title": "simple-cpp-solution-count-hills-and-valleys",
                "content": "class Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        vector<int>::iterator it;\\n      \\n        it = std::unique(nums.begin(), nums.begin() + nums.size());\\n        nums.resize(std::distance(nums.begin(), it));\\n        int cnt=0;\\n        for(int i=1;i<nums.size()-1;i++){\\n            if((nums[i]>nums[i-1])&&(nums[i]>nums[i+1])){cnt++;}\\n            else if((nums[i]<nums[i-1])&&(nums[i]<nums[i+1])){cnt++;}\\n          \\n        }\\n        return cnt;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        vector<int>::iterator it;\\n      \\n        it = std::unique(nums.begin(), nums.begin() + nums.size());\\n        nums.resize(std::distance(nums.begin(), it));\\n        int cnt=0;\\n        for(int i=1;i<nums.size()-1;i++){\\n            if((nums[i]>nums[i-1])&&(nums[i]>nums[i+1])){cnt++;}",
                "codeTag": "Java"
            },
            {
                "id": 1866808,
                "title": "5-line-c-solution-unique-function",
                "content": "```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        nums.erase(unique(nums.begin(),nums.end()),nums.end());\\n        int n=nums.size(), h=0;\\n        for(int i=0;i<n-2;i++)\\n            if((nums[i]<nums[i+1] and nums[i+1]>nums[i+2]) or (nums[i]>nums[i+1] and nums[i+1]<nums[i+2]))   h++;\\n        return h;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        nums.erase(unique(nums.begin(),nums.end()),nums.end());\\n        int n=nums.size(), h=0;\\n        for(int i=0;i<n-2;i++)\\n            if((nums[i]<nums[i+1] and nums[i+1]>nums[i+2]) or (nums[i]>nums[i+1] and nums[i+1]<nums[i+2]))   h++;\\n        return h;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1866756,
                "title": "c-o-n-time-o-1-space-beats-100-c-solutions-easy-solution-with-explaination",
                "content": "**Psuedocode**\\n1-Remove all repeating elements\\n2-Counting hills and valleys is now easy using an ans (count) variable\\n3-Use a for loop and check these conditon\\n\\ta-(nums[i]>nums[i+1] && nums[i]>nums[i-1]) Conditon for valid hill\\n\\tb-(nums[i]<nums[i-1] && nums[i]<nums[i+1]) Condtion for valid valley\\n```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n\\t\\t//removed repeating numbers using unique stl\\n        vector<int>::iterator ip;\\n        ip=unique(nums.begin(),nums.begin()+nums.size());\\n        nums.resize(distance(nums.begin(),ip));\\n\\t\\t//used ans to count hills and valleys\\n        int ans=0;\\n        for(int i=1;i<nums.size()-1;i++){\\n            if(nums[i]>nums[i+1] && nums[i]>nums[i-1]){\\n                ans++;\\n            }\\n            else if(nums[i]<nums[i-1] && nums[i]<nums[i+1]){\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n\\t\\t//removed repeating numbers using unique stl\\n        vector<int>::iterator ip;\\n        ip=unique(nums.begin(),nums.begin()+nums.size());\\n        nums.resize(distance(nums.begin(),ip));\\n\\t\\t//used ans to count hills and valleys\\n        int ans=0;\\n        for(int i=1;i<nums.size()-1;i++){\\n            if(nums[i]>nums[i+1] && nums[i]>nums[i-1]){\\n                ans++;\\n            }\\n            else if(nums[i]<nums[i-1] && nums[i]<nums[i+1]){\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1866388,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n          int ans = 0;\\n          int i = 1;\\n          while(i < nums.size() - 1){\\n              int ele = nums[i];\\n              int j = i -1;\\n              bool flag1 = true, flag2 = true;\\n              while(nums[j] == ele){\\n                  j--;\\n                  if(j < 0) {flag1 = false; break;}\\n              }\\n              \\n              int k = i + 1;\\n               while(nums[k] == ele){\\n                  k++;\\n                  if(k >= nums.size()) {flag2 = false; break;}\\n              }\\n              \\n              if(flag1 && flag2){\\n                  if(ele > nums[j] && ele > nums[k]) ans++;\\n                  else if(ele < nums[j] && ele < nums[k]) ans++;\\n              }\\n               // skippings the duplicates \\n                while(nums[i] == ele) i++;\\n          }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n          int ans = 0;\\n          int i = 1;\\n          while(i < nums.size() - 1){\\n              int ele = nums[i];\\n              int j = i -1;\\n              bool flag1 = true, flag2 = true;\\n              while(nums[j] == ele){\\n                  j--;\\n                  if(j < 0) {flag1 = false; break;}",
                "codeTag": "Java"
            },
            {
                "id": 1865900,
                "title": "difference-arrary-to-count-the-flip-direction-o-n-o-1",
                "content": "nums = [2,4,1,1,6,5]\\ndiff_arr=[ 2,-3,0,5,-1]\\nPN = [+,-,0,+,-]\\n\\nthe count equal the positive and negtive flips(+ -> - or - ->+);\\n\\n```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n < 2) return 0;\\n\\t\\t\\n        int dif = 0;\\n        int prev = 0;\\n        int count = 0;  // count is the result \\n\\t\\t\\n        for(int i = 1;i < n;i++){\\n            dif = nums[i] - nums[i-1];\\n\\t\\t\\t// if there is flips, count increased\\n            if(dif*prev < 0){\\n                count++;\\n            }\\n\\t\\t\\t// save the cur state(positive or negtive) as prev\\n            if(dif != 0){\\n                prev = dif;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n < 2) return 0;\\n\\t\\t\\n        int dif = 0;\\n        int prev = 0;\\n        int count = 0;  // count is the result \\n\\t\\t\\n        for(int i = 1;i < n;i++){\\n            dif = nums[i] - nums[i-1];\\n\\t\\t\\t// if there is flips, count increased\\n            if(dif*prev < 0){\\n                count++;\\n            }\\n\\t\\t\\t// save the cur state(positive or negtive) as prev\\n            if(dif != 0){\\n                prev = dif;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1865672,
                "title": "beginners-friendly-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        int count=0;\\n        for(int i=1;i<nums.size()-1;i++)\\n        {\\n            if(nums[i]==nums[i-1])\\n                continue;\\n            int first=-1;\\n            int second=-1;\\n         \\n            bool temp1=false;\\n            bool temp2=false;\\n           \\n            for(int j=i-1;j>=0;j--)\\n            {\\n                if(nums[j]!=nums[i])\\n                {   \\n                    first=nums[j];\\n                    // cout<<nums[j];\\n                    temp1=true;\\n                     break;\\n                }\\n            }\\n            \\n           \\n            for(int j=i+1;j<nums.size();j++)\\n            {\\n                if(nums[j]!=nums[i])\\n                {   \\n                    second=nums[j];\\n                    temp2=true;\\n                   \\n                    break;\\n                    \\n                }\\n            }\\n            \\n            if(temp1==true&&temp2==true)\\n            {\\n                if(first<nums[i]&&second<nums[i])\\n                {   count+=1;}\\n                else if(first>nums[i]&&second>nums[i])\\n                {  count+=1;}\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```\\n**Like it? Please Upvote ;-)**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        int count=0;\\n        for(int i=1;i<nums.size()-1;i++)\\n        {\\n            if(nums[i]==nums[i-1])\\n                continue;\\n            int first=-1;\\n            int second=-1;\\n         \\n            bool temp1=false;\\n            bool temp2=false;\\n           \\n            for(int j=i-1;j>=0;j--)\\n            {\\n                if(nums[j]!=nums[i])\\n                {   \\n                    first=nums[j];\\n                    // cout<<nums[j];\\n                    temp1=true;\\n                     break;\\n                }\\n            }\\n            \\n           \\n            for(int j=i+1;j<nums.size();j++)\\n            {\\n                if(nums[j]!=nums[i])\\n                {   \\n                    second=nums[j];\\n                    temp2=true;\\n                   \\n                    break;\\n                    \\n                }\\n            }\\n            \\n            if(temp1==true&&temp2==true)\\n            {\\n                if(first<nums[i]&&second<nums[i])\\n                {   count+=1;}\\n                else if(first>nums[i]&&second>nums[i])\\n                {  count+=1;}\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1865664,
                "title": "simple-java-solution-o-n-2",
                "content": "```\\nclass Solution {\\n    public int countHillValley(int[] nums) {\\n        int count =0;\\n        for(int i=0;i<nums.length;i++){\\n            Boolean isPrevLower = null;\\n            Boolean isNextLower = null;\\n            int j = i-1;\\n            while(j>=0){ \\n                if(nums[i]!=nums[j]){\\n                    if(nums[i]>nums[j])\\n                        isPrevLower = true;\\n                    else\\n                        isPrevLower = false;\\n\\n                    break;\\n                }\\n                j--;\\n            }\\n            j = i+1;\\n            while(j<nums.length){\\n                if(nums[i]!=nums[j]){\\n                    if(nums[i]>nums[j])\\n                        isNextLower = true;\\n                    else\\n                        isNextLower = false;\\n                    \\n                    break;\\n                }else\\n                    i=j;\\n                j++;\\n            }\\n            if(isPrevLower!=null && isNextLower!=null && isPrevLower == isNextLower)\\n                count++;\\n        }\\n        return count;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int countHillValley(int[] nums) {\\n        int count =0;\\n        for(int i=0;i<nums.length;i++){\\n            Boolean isPrevLower = null;\\n            Boolean isNextLower = null;\\n            int j = i-1;\\n            while(j>=0){ \\n                if(nums[i]!=nums[j]){\\n                    if(nums[i]>nums[j])\\n                        isPrevLower = true;\\n                    else\\n                        isPrevLower = false;\\n\\n                    break;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1865663,
                "title": "python-sol",
                "content": "```\\nclass Solution:\\n    def countHillValley(self, nums: List[int]) -> int:\\n        hills,valley=0,0\\n        n=len(nums)\\n        if n<3:\\n            return 0\\n        \\n        for i in range(1,len(nums)):\\n            if i==i-1:\\n                continue\\n            for j in range(i,len(nums)):\\n                if i!=j and nums[i]!=nums[j]:\\n                    if nums[i]>nums[i-1] and nums[i]>nums[j] : \\n                        hills+=1\\n                        break\\n                    elif nums[i]<nums[i-1] and nums[i]<nums[j]: \\n                        valley+=1\\n                        break\\n                    elif (nums[i]>nums[i-1] and nums[i]<nums[j])or (nums[i]<nums[i-1] and nums[i]>nums[j]):\\n                        break\\n        return hills+valley\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def countHillValley(self, nums: List[int]) -> int:\\n        hills,valley=0,0\\n        n=len(nums)\\n        if n<3:\\n            return 0\\n        \\n        for i in range(1,len(nums)):\\n            if i==i-1:\\n                continue\\n            for j in range(i,len(nums)):\\n                if i!=j and nums[i]!=nums[j]:\\n                    if nums[i]>nums[i-1] and nums[i]>nums[j] : \\n                        hills+=1\\n                        break\\n                    elif nums[i]<nums[i-1] and nums[i]<nums[j]: \\n                        valley+=1\\n                        break\\n                    elif (nums[i]>nums[i-1] and nums[i]<nums[j])or (nums[i]<nums[i-1] and nums[i]>nums[j]):\\n                        break\\n        return hills+valley\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1865581,
                "title": "java-easy-solution-single-loop",
                "content": "```\\nclass Solution {\\n    public int countHillValley(int[] nums) {\\n        if(nums.length<3){\\n            return 0;\\n        }\\n        int hills = 0;\\n        for(int i=1;i<nums.length-1;i++){\\n            if(nums[i-1]==nums[i] && i>1){\\n                nums[i-1] = nums[i-2];\\n            }\\n            if(nums[i]>nums[i-1] && nums[i]>nums[i+1]){\\n                hills++;\\n            }\\n            else if(nums[i]<nums[i-1] && nums[i]<nums[i+1]){\\n                hills++;\\n            }\\n        }\\n        return hills;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countHillValley(int[] nums) {\\n        if(nums.length<3){\\n            return 0;\\n        }\\n        int hills = 0;\\n        for(int i=1;i<nums.length-1;i++){\\n            if(nums[i-1]==nums[i] && i>1){\\n                nums[i-1] = nums[i-2];\\n            }\\n            if(nums[i]>nums[i-1] && nums[i]>nums[i+1]){\\n                hills++;\\n            }\\n            else if(nums[i]<nums[i-1] && nums[i]<nums[i+1]){\\n                hills++;\\n            }\\n        }\\n        return hills;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4086393,
                "title": "python-clean-and-easy-to-understand-o-n",
                "content": "\\n# Code\\n```\\nclass Solution(object):\\n    def countHillValley(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        count = 0\\n        length = len(nums)\\n        for i in range(1, length - 1):\\n            if nums[i] == nums[i+1]:\\n                nums[i] = nums[i - 1]\\n                continue\\n            if nums[i - 1] < nums[i] and nums[i] > nums[i + 1]:\\n                count += 1\\n            elif nums[i - 1] > nums[i] and nums[i] < nums[i + 1]:\\n                count += 1\\n            else:\\n                continue\\n        return count\\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def countHillValley(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        count = 0\\n        length = len(nums)\\n        for i in range(1, length - 1):\\n            if nums[i] == nums[i+1]:\\n                nums[i] = nums[i - 1]\\n                continue\\n            if nums[i - 1] < nums[i] and nums[i] > nums[i + 1]:\\n                count += 1\\n            elif nums[i - 1] > nums[i] and nums[i] < nums[i + 1]:\\n                count += 1\\n            else:\\n                continue\\n        return count\\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4085717,
                "title": "beats-100-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) \\n    {\\n        int n =nums.size();\\n        int count=0;\\n        int j=0;\\n        for(int i=1; i<n-1; i++)\\n        {\\n            if(nums[j] < nums[i] && nums[i] > nums[i+1])\\n            {\\n                count++;\\n                j=i;\\n            }\\n            else if(nums[j] > nums[i] && nums[i] < nums[i+1])\\n            {\\n                count++;\\n                j=i;\\n            }\\n            else \\n            continue;\\n        }\\n        return count;\\n    }\\n};    \\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) \\n    {\\n        int n =nums.size();\\n        int count=0;\\n        int j=0;\\n        for(int i=1; i<n-1; i++)\\n        {\\n            if(nums[j] < nums[i] && nums[i] > nums[i+1])\\n            {\\n                count++;\\n                j=i;\\n            }\\n            else if(nums[j] > nums[i] && nums[i] < nums[i+1])\\n            {\\n                count++;\\n                j=i;\\n            }\\n            else \\n            continue;\\n        }\\n        return count;\\n    }\\n};    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4083954,
                "title": "single-pass-t-o-n-s-o-1",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nvar countHillValley = function(nums) {\\n    let counter = 0;\\n    let i = 1;\\n\\n    while (i < nums.length - 1) {\\n        const num = nums[i];\\n        const prevNum = nums[i - 1];\\n        const nextNum = (() => {\\n            while (nums[i + 1] === num) {\\n                i += 1;\\n            }\\n            return nums[i + 1];\\n        })();\\n        if ((prevNum < num && nextNum < num) ||\\n            (prevNum > num && nextNum > num)) {\\n            counter += 1;\\n        }\\n        i += 1;\\n    }\\n    return counter;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar countHillValley = function(nums) {\\n    let counter = 0;\\n    let i = 1;\\n\\n    while (i < nums.length - 1) {\\n        const num = nums[i];\\n        const prevNum = nums[i - 1];\\n        const nextNum = (() => {\\n            while (nums[i + 1] === num) {\\n                i += 1;\\n            }\\n            return nums[i + 1];\\n        })();\\n        if ((prevNum < num && nextNum < num) ||\\n            (prevNum > num && nextNum > num)) {\\n            counter += 1;\\n        }\\n        i += 1;\\n    }\\n    return counter;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4081836,
                "title": "cpp-short-simple",
                "content": "---\\n\\n# Complexity\\n- Time complexity:\\n\\uD83D\\uDFE2 $$O(n)$$ \\n\\n- Space complexity:\\n\\uD83D\\uDFE2 $$O(n)$$ \\n---\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        int hill = 0; \\n        int valley = 0;\\n        vector<int> nums1;\\n        nums1.push_back(nums[0]);\\n        for(int i=1; i<nums.size(); i++){\\n            if(nums[i] == nums[i-1]) continue;\\n            nums1.push_back(nums[i]);\\n        }\\n        for(int i = 1; i<nums1.size()-1; i++){\\n            if(nums1[i] > nums1[i-1] && nums1[i] > nums1[i+1]) hill++;\\n        }\\n        for(int i = 1; i<nums1.size()-1; i++){\\n            if(nums1[i] < nums1[i-1] && nums1[i] < nums1[i+1]) valley++;\\n        }\\n\\n        return hill+valley;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        int hill = 0; \\n        int valley = 0;\\n        vector<int> nums1;\\n        nums1.push_back(nums[0]);\\n        for(int i=1; i<nums.size(); i++){\\n            if(nums[i] == nums[i-1]) continue;\\n            nums1.push_back(nums[i]);\\n        }\\n        for(int i = 1; i<nums1.size()-1; i++){\\n            if(nums1[i] > nums1[i-1] && nums1[i] > nums1[i+1]) hill++;\\n        }\\n        for(int i = 1; i<nums1.size()-1; i++){\\n            if(nums1[i] < nums1[i-1] && nums1[i] < nums1[i+1]) valley++;\\n        }\\n\\n        return hill+valley;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4069204,
                "title": "easy-logic",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countHillValley(self, nums: List[int]) -> int:\\n        r = []\\n        i = 1\\n        while i < len(nums)-1:\\n            temp = nums[:i][::-1] \\n            for j in temp:                \\n                if (nums[i] != j ) :\\n                    break\\n            for k in nums[i+1:] :\\n                if (nums[i] != k) :\\n                    break\\n            if (nums[i] > j and nums[i] > k) or (nums[i] < j and nums[i] < k) :\\n                l = [j, k]\\n                r += [l]\\n            i += 1\\n        \\n        if r:\\n            c = 0\\n            for i in range(len(r)-1) :\\n                if r[i] != r[i+1] :\\n                    c += 1\\n            return c+1\\n        return 0\\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Array"
                ],
                "code": "```\\nclass Solution:\\n    def countHillValley(self, nums: List[int]) -> int:\\n        r = []\\n        i = 1\\n        while i < len(nums)-1:\\n            temp = nums[:i][::-1] \\n            for j in temp:                \\n                if (nums[i] != j ) :\\n                    break\\n            for k in nums[i+1:] :\\n                if (nums[i] != k) :\\n                    break\\n            if (nums[i] > j and nums[i] > k) or (nums[i] < j and nums[i] < k) :\\n                l = [j, k]\\n                r += [l]\\n            i += 1\\n        \\n        if r:\\n            c = 0\\n            for i in range(len(r)-1) :\\n                if r[i] != r[i+1] :\\n                    c += 1\\n            return c+1\\n        return 0\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4067657,
                "title": "ez",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar countHillValley = function(nums) {\\n    const arr=nums.filter((a,i,b)=> a!=b[i+1]);\\n    let flag=0;\\n    \\n    for(i=1;i<=arr.length-1;i++){\\n        if(arr[i-1]<arr[i]&&arr[i+1]<arr[i]){\\n            flag++;\\n        }\\n        else if(arr[i-1]>arr[i]&&arr[i+1]>arr[i]){\\n            flag++;\\n        }\\n    }\\n    \\n   return flag;\\n    \\n\\n    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar countHillValley = function(nums) {\\n    const arr=nums.filter((a,i,b)=> a!=b[i+1]);\\n    let flag=0;\\n    \\n    for(i=1;i<=arr.length-1;i++){\\n        if(arr[i-1]<arr[i]&&arr[i+1]<arr[i]){\\n            flag++;\\n        }\\n        else if(arr[i-1]>arr[i]&&arr[i+1]>arr[i]){\\n            flag++;\\n        }\\n    }\\n    \\n   return flag;\\n    \\n\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4050081,
                "title": "c-easy-worst-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        int count=0;\\n        nums.erase(unique(nums.begin(),nums.end()),nums.end());\\n        for(int i=1;i<nums.size()-1;i++)\\n        {\\n          if(nums[i]>nums[i-1]&&nums[i]>nums[i+1] || nums[i]<nums[i-1]&&nums[i]<nums[i+1])\\n          {\\n              count++;\\n          }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        int count=0;\\n        nums.erase(unique(nums.begin(),nums.end()),nums.end());\\n        for(int i=1;i<nums.size()-1;i++)\\n        {\\n          if(nums[i]>nums[i-1]&&nums[i]>nums[i+1] || nums[i]<nums[i-1]&&nums[i]<nums[i+1])\\n          {\\n              count++;\\n          }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4042920,
                "title": "easy-java-solution",
                "content": "```\\n        int count = 0;\\n        int i = 1;\\n        int len = nums.length;\\n\\n        while (i < len - 1) {\\n\\n            if (nums[i] == nums[i + 1]) {\\n                i++;\\n                continue;\\n            }\\n\\n            int j = i - 1;\\n            int k = i + 1;\\n\\n            while (j != 0 && nums[i] == nums[j]) {\\n                j--;\\n            }\\n            while (k < len && nums[i] == nums[k]) {\\n                k++;\\n            }\\n\\n            if (nums[i] > nums[j] && nums[i] > nums[k]) count++;\\n\\n            else if (nums[i] < nums[j] && nums[i] < nums[k]) count++;\\n\\n            i++;\\n\\n\\n        }\\n        return count;\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\n        int count = 0;\\n        int i = 1;\\n        int len = nums.length;\\n\\n        while (i < len - 1) {\\n\\n            if (nums[i] == nums[i + 1]) {\\n                i++;\\n                continue;\\n            }\\n\\n            int j = i - 1;\\n            int k = i + 1;\\n\\n            while (j != 0 && nums[i] == nums[j]) {\\n                j--;\\n            }\\n            while (k < len && nums[i] == nums[k]) {\\n                k++;\\n            }\\n\\n            if (nums[i] > nums[j] && nums[i] > nums[k]) count++;\\n\\n            else if (nums[i] < nums[j] && nums[i] < nums[k]) count++;\\n\\n            i++;\\n\\n\\n        }\\n        return count;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4006488,
                "title": "simple-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) \\n    {\\n        vector<int> traversal;\\n        traversal.push_back(nums[0]);\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            if(nums[i-1]!=nums[i])\\n            traversal.push_back(nums[i]);\\n        }\\n        bool inc=traversal[0]<traversal[1];\\n        int count=1;\\n        for(int i=0;i<traversal.size()-1;i++)\\n        {\\n            if(traversal[i]<traversal[i+1]&&!inc)\\n            {\\n                inc=true;\\n                count++;\\n            }\\n            if(traversal[i]>traversal[i+1]&&inc)\\n            {\\n                inc=false;\\n                count++;\\n            }\\n        }\\n        return count-1;   \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) \\n    {\\n        vector<int> traversal;\\n        traversal.push_back(nums[0]);\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            if(nums[i-1]!=nums[i])\\n            traversal.push_back(nums[i]);\\n        }\\n        bool inc=traversal[0]<traversal[1];\\n        int count=1;\\n        for(int i=0;i<traversal.size()-1;i++)\\n        {\\n            if(traversal[i]<traversal[i+1]&&!inc)\\n            {\\n                inc=true;\\n                count++;\\n            }\\n            if(traversal[i]>traversal[i+1]&&inc)\\n            {\\n                inc=false;\\n                count++;\\n            }\\n        }\\n        return count-1;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3990242,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n public:\\n  int countHillValley(vector<int>& nums) {\\n    int ans = 0;\\n    int left = nums[0];\\n\\n    for (int i = 1; i + 1 < nums.size(); ++i)\\n      if (left < nums[i] && nums[i] > nums[i + 1] ||  // Hill\\n          left > nums[i] && nums[i] < nums[i + 1]) {  // Valley\\n        ++ans;\\n        left = nums[i];\\n      }\\n\\n    return ans;\\n  }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n public:\\n  int countHillValley(vector<int>& nums) {\\n    int ans = 0;\\n    int left = nums[0];\\n\\n    for (int i = 1; i + 1 < nums.size(); ++i)\\n      if (left < nums[i] && nums[i] > nums[i + 1] ||  // Hill\\n          left > nums[i] && nums[i] < nums[i + 1]) {  // Valley\\n        ++ans;\\n        left = nums[i];\\n      }\\n\\n    return ans;\\n  }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3982923,
                "title": "typescript-javascript-simple-solution",
                "content": "# Code\\n```\\nfunction countHillValley(nums: number[]): number {\\n    let result = 0;\\n    let prev = nums[0];\\n\\n    for (let i = 1; i < nums.length - 1; i++) {\\n        const curr = nums[i];\\n        const next = nums[i + 1];\\n        \\n        if (curr === next) continue;\\n\\n        if (curr > prev && curr > next) {\\n            result++;\\n        }\\n\\n        if (curr < prev && curr < next) {\\n            result++;\\n        }\\n\\n        prev = curr;\\n    }\\n\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nfunction countHillValley(nums: number[]): number {\\n    let result = 0;\\n    let prev = nums[0];\\n\\n    for (let i = 1; i < nums.length - 1; i++) {\\n        const curr = nums[i];\\n        const next = nums[i + 1];\\n        \\n        if (curr === next) continue;\\n\\n        if (curr > prev && curr > next) {\\n            result++;\\n        }\\n\\n        if (curr < prev && curr < next) {\\n            result++;\\n        }\\n\\n        prev = curr;\\n    }\\n\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3972297,
                "title": "easy-to-understand-python3-solution-tc-o-n-sc-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countHillValley(self, nums: List[int]) -> int:\\n        position = 1\\n        count = 0\\n\\n        while position < len(nums) - 1:\\n            low = position -1\\n            high = position + 1\\n\\n            while low >= 1:\\n                if nums[low] == nums[position]:\\n                    low -= 1\\n                else:\\n                    break\\n            \\n            while high < len(nums) - 1:\\n                if nums[high] == nums[position]:\\n                    high += 1\\n                else:\\n                    break\\n            \\n            if nums[low] < nums[position] and nums[position] > nums[high]:\\n                count += 1\\n            \\n            if nums[low] > nums[position] and nums[position] < nums[high]:\\n                count += 1\\n            \\n            position = high\\n        \\n        return count\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countHillValley(self, nums: List[int]) -> int:\\n        position = 1\\n        count = 0\\n\\n        while position < len(nums) - 1:\\n            low = position -1\\n            high = position + 1\\n\\n            while low >= 1:\\n                if nums[low] == nums[position]:\\n                    low -= 1\\n                else:\\n                    break\\n            \\n            while high < len(nums) - 1:\\n                if nums[high] == nums[position]:\\n                    high += 1\\n                else:\\n                    break\\n            \\n            if nums[low] < nums[position] and nums[position] > nums[high]:\\n                count += 1\\n            \\n            if nums[low] > nums[position] and nums[position] < nums[high]:\\n                count += 1\\n            \\n            position = high\\n        \\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3946563,
                "title": "java-beat-100-in-time",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countHillValley(int[] nums) {\\n        int count =0;\\n        for(int i=1; i<nums.length-1; i++) {\\n            int j = i;\\n            while (j<nums.length-2 && nums[j] == nums[j+1]) {\\n                j++;\\n            }\\n            if ((nums[i-1] < nums[i] && nums[i] > nums[j+1]) || (nums[i-1] > nums[i] && nums[i] < nums[j+1])) {\\n                count++;\\n            }\\n            i = j;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countHillValley(int[] nums) {\\n        int count =0;\\n        for(int i=1; i<nums.length-1; i++) {\\n            int j = i;\\n            while (j<nums.length-2 && nums[j] == nums[j+1]) {\\n                j++;\\n            }\\n            if ((nums[i-1] < nums[i] && nums[i] > nums[j+1]) || (nums[i-1] > nums[i] && nums[i] < nums[j+1])) {\\n                count++;\\n            }\\n            i = j;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3923963,
                "title": "simple-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        \\n        int count=0;\\n        for(int i=1;i<nums.size()-1;i++)\\n        {\\n             int prev=i-1;\\n             int next=i+1;\\n             if(nums[i]==nums[i-1])\\n             {\\n                 continue;\\n             }\\n             while(prev>=0 && nums[prev]==nums[i])\\n             {\\n                prev--;\\n             }\\n             while(next<nums.size() && nums[next]==nums[i])\\n             {\\n                next++;\\n             }\\n             if(prev<0 || next>=nums.size())\\n             {\\n                 continue;\\n             }\\n             if(nums[i]>nums[prev]  && nums[i]>nums[next])\\n             {\\n                 count++;\\n                 \\n             }\\n             if(nums[i]<nums[next] && nums[i]<nums[prev])\\n             {\\n                 count++;\\n             }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        \\n        int count=0;\\n        for(int i=1;i<nums.size()-1;i++)\\n        {\\n             int prev=i-1;\\n             int next=i+1;\\n             if(nums[i]==nums[i-1])\\n             {\\n                 continue;\\n             }\\n             while(prev>=0 && nums[prev]==nums[i])\\n             {\\n                prev--;\\n             }\\n             while(next<nums.size() && nums[next]==nums[i])\\n             {\\n                next++;\\n             }\\n             if(prev<0 || next>=nums.size())\\n             {\\n                 continue;\\n             }\\n             if(nums[i]>nums[prev]  && nums[i]>nums[next])\\n             {\\n                 count++;\\n                 \\n             }\\n             if(nums[i]<nums[next] && nums[i]<nums[prev])\\n             {\\n                 count++;\\n             }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3920918,
                "title": "rust-beats-100-o-n-o-1",
                "content": "# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nimpl Solution {\\n    pub fn count_hill_valley(nums: Vec<i32>) -> i32 {\\n        let mut res = 0;\\n        let mut uphill = nums[1].cmp(&nums[0]);\\n        for i in 1..nums.len() {\\n            match nums[i].cmp(&nums[i - 1]) {\\n                std::cmp::Ordering::Greater => {\\n                    if uphill == std::cmp::Ordering::Less {\\n                        res += 1;\\n                    }\\n                    uphill = std::cmp::Ordering::Greater;\\n                }\\n                std::cmp::Ordering::Equal => (),\\n                std::cmp::Ordering::Less => {\\n                    if uphill == std::cmp::Ordering::Greater {\\n                        res += 1;\\n                    }\\n                    uphill = std::cmp::Ordering::Less;\\n                }\\n            }\\n        }\\n\\n        res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn count_hill_valley(nums: Vec<i32>) -> i32 {\\n        let mut res = 0;\\n        let mut uphill = nums[1].cmp(&nums[0]);\\n        for i in 1..nums.len() {\\n            match nums[i].cmp(&nums[i - 1]) {\\n                std::cmp::Ordering::Greater => {\\n                    if uphill == std::cmp::Ordering::Less {\\n                        res += 1;\\n                    }\\n                    uphill = std::cmp::Ordering::Greater;\\n                }\\n                std::cmp::Ordering::Equal => (),\\n                std::cmp::Ordering::Less => {\\n                    if uphill == std::cmp::Ordering::Greater {\\n                        res += 1;\\n                    }\\n                    uphill = std::cmp::Ordering::Less;\\n                }\\n            }\\n        }\\n\\n        res\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3914698,
                "title": "python-simple-solution-beats-93-user-in-both-time-and-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countHillValley(self, nums: List[int]) -> int:\\n        arr=[]\\n        left=nums[0]\\n        for i in range(1,len(nums)-1):\\n            j=i+1\\n\\n            if left==nums[i]:\\n                continue\\n            while j<len(nums) and nums[i]==nums[j]:\\n                j+=1\\n            if j>=len(nums):\\n                continue\\n            right=nums[j]\\n            if left<nums[i] and right<nums[i]:\\n                arr.append(\\'hill\\')\\n                left=nums[i]\\n            elif left>nums[i] and right>nums[i]:\\n                arr.append(\\'valley\\')\\n                left=nums[i]\\n    \\n        val=\\'\\'\\n        count=0\\n        for i in range(len(arr)):\\n            if arr[i]!=val:\\n                count+=1\\n            val=arr[i]\\n            \\n        return(count)\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countHillValley(self, nums: List[int]) -> int:\\n        arr=[]\\n        left=nums[0]\\n        for i in range(1,len(nums)-1):\\n            j=i+1\\n\\n            if left==nums[i]:\\n                continue\\n            while j<len(nums) and nums[i]==nums[j]:\\n                j+=1\\n            if j>=len(nums):\\n                continue\\n            right=nums[j]\\n            if left<nums[i] and right<nums[i]:\\n                arr.append(\\'hill\\')\\n                left=nums[i]\\n            elif left>nums[i] and right>nums[i]:\\n                arr.append(\\'valley\\')\\n                left=nums[i]\\n    \\n        val=\\'\\'\\n        count=0\\n        for i in range(len(arr)):\\n            if arr[i]!=val:\\n                count+=1\\n            val=arr[i]\\n            \\n        return(count)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3901205,
                "title": "iteration-tracking-last-hill-or-valley-checking-valley-or-hill-iteratively",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countHillValley(int[] nums) {\\n        if (nums == null || nums.length <= 2) {\\n            return 0;\\n        }\\n        int numberOfHills = 0;\\n        int numberOfValleys = 0;\\n        int indexOfLastHillOrValley = 0;\\n        for (int i = 1; i < nums.length - 1; i++) {\\n            //is Hill?\\n            if (nums[i] > nums[indexOfLastHillOrValley] && nums[i] > nums[i + 1]) {\\n                numberOfHills++;\\n                indexOfLastHillOrValley = i;\\n            } else if (nums[i] < nums[indexOfLastHillOrValley] && nums[i] < nums[i + 1]) {\\n                numberOfValleys++;\\n                indexOfLastHillOrValley = i;\\n            }\\n        }\\n        return numberOfHills + numberOfValleys;        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countHillValley(int[] nums) {\\n        if (nums == null || nums.length <= 2) {\\n            return 0;\\n        }\\n        int numberOfHills = 0;\\n        int numberOfValleys = 0;\\n        int indexOfLastHillOrValley = 0;\\n        for (int i = 1; i < nums.length - 1; i++) {\\n            //is Hill?\\n            if (nums[i] > nums[indexOfLastHillOrValley] && nums[i] > nums[i + 1]) {\\n                numberOfHills++;\\n                indexOfLastHillOrValley = i;\\n            } else if (nums[i] < nums[indexOfLastHillOrValley] && nums[i] < nums[i + 1]) {\\n                numberOfValleys++;\\n                indexOfLastHillOrValley = i;\\n            }\\n        }\\n        return numberOfHills + numberOfValleys;        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3892683,
                "title": "c-o-n-solution-faster-than-100",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        int c = 0;\\n        int prev = nums[0];\\n        for(int i=1;i<nums.size()-1;i++){\\n            if((nums[i]>prev && nums[i]>nums[i+1]) || \\n                (nums[i]<prev && nums[i]<nums[i+1])){\\n                c++;\\n                prev=nums[i];\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        int c = 0;\\n        int prev = nums[0];\\n        for(int i=1;i<nums.size()-1;i++){\\n            if((nums[i]>prev && nums[i]>nums[i+1]) || \\n                (nums[i]<prev && nums[i]<nums[i+1])){\\n                c++;\\n                prev=nums[i];\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3879937,
                "title": "count-hills-and-valleys-in-an-array",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countHillValley(int[] nums) {\\n        int count =0;\\n        ArrayList<Integer> arr = new ArrayList<Integer>();\\n        arr.add(nums[0]);\\n        for(int i=1;i<nums.length;i++)\\n        {\\n            if(nums[i-1]!=nums[i])\\n            arr.add(nums[i]);\\n        }\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            System.out.println(arr.get(i)+\" \");\\n        }\\n        for(int i=1;i<arr.size()-1;i++)\\n        {\\n            if(arr.get(i)>arr.get(i-1)&&arr.get(i)>arr.get(i+1))\\n            count++;\\n            else if(arr.get(i)<arr.get(i-1)&&arr.get(i)<arr.get(i+1))\\n            count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countHillValley(int[] nums) {\\n        int count =0;\\n        ArrayList<Integer> arr = new ArrayList<Integer>();\\n        arr.add(nums[0]);\\n        for(int i=1;i<nums.length;i++)\\n        {\\n            if(nums[i-1]!=nums[i])\\n            arr.add(nums[i]);\\n        }\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            System.out.println(arr.get(i)+\" \");\\n        }\\n        for(int i=1;i<arr.size()-1;i++)\\n        {\\n            if(arr.get(i)>arr.get(i-1)&&arr.get(i)>arr.get(i+1))\\n            count++;\\n            else if(arr.get(i)<arr.get(i-1)&&arr.get(i)<arr.get(i+1))\\n            count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3879550,
                "title": "scala",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nobject Solution {\\n    def countHillValley(nums: Array[Int]): Int = {\\n        var isHill: Option[Boolean] = None\\n        (1 until nums.length).map { i => \\n            val prev = nums(i-1)\\n            val curr = nums(i)\\n            if(prev != curr) {\\n                if (prev > curr) {\\n                    val result = isHill match {\\n                        case Some(true) => 1\\n                        case _ => 0\\n                    }\\n                    isHill = Some(false)\\n                    result\\n                } else {\\n                    val result = isHill match {\\n                        case Some(false) => 1\\n                        case _ => 0\\n                    }\\n                    isHill = Some(true)\\n                    result\\n                }\\n            } else 0\\n        }.sum\\n    }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n    def countHillValley(nums: Array[Int]): Int = {\\n        var isHill: Option[Boolean] = None\\n        (1 until nums.length).map { i => \\n            val prev = nums(i-1)\\n            val curr = nums(i)\\n            if(prev != curr) {\\n                if (prev > curr) {\\n                    val result = isHill match {\\n                        case Some(true) => 1\\n                        case _ => 0\\n                    }\\n                    isHill = Some(false)\\n                    result\\n                } else {\\n                    val result = isHill match {\\n                        case Some(false) => 1\\n                        case _ => 0\\n                    }\\n                    isHill = Some(true)\\n                    result\\n                }\\n            } else 0\\n        }.sum\\n    }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3872802,
                "title": "basic-java-soln-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countHillValley(int[] nums) {\\n        int c=0;\\n        for(int i=1;i<nums.length-1;i++){\\n            if((nums[i]>nums[i-1]&&nums[i]>nums[i+1])||(nums[i]<nums[i-1]&&nums[i]<nums[i+1])){\\n                c++;\\n            }\\n            if(nums[i]==nums[i+1])\\n                nums[i]=nums[i-1];\\n        }\\n        return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countHillValley(int[] nums) {\\n        int c=0;\\n        for(int i=1;i<nums.length-1;i++){\\n            if((nums[i]>nums[i-1]&&nums[i]>nums[i+1])||(nums[i]<nums[i-1]&&nums[i]<nums[i+1])){\\n                c++;\\n            }\\n            if(nums[i]==nums[i+1])\\n                nums[i]=nums[i-1];\\n        }\\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3858259,
                "title": "count-hills-and-valleys-in-an-array",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) \\n    {\\n\\n        vector<int> v;\\n        v.push_back(nums[0]);\\n        int j=0;\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            if(nums[i]!=v[j])\\n            {\\n                v.push_back(nums[i]);\\n                j++;\\n            }\\n        }\\n        int cnt=0;\\n        for(int i=1;i<v.size()-1;i++)\\n        {\\n            if(v[i]>v[i-1]&&v[i]>v[i+1])\\n            cnt++;\\n            if(v[i]<v[i-1] && v[i]<v[i+1])\\n            cnt++;\\n        }\\n        return cnt;\\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) \\n    {\\n\\n        vector<int> v;\\n        v.push_back(nums[0]);\\n        int j=0;\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            if(nums[i]!=v[j])\\n            {\\n                v.push_back(nums[i]);\\n                j++;\\n            }\\n        }\\n        int cnt=0;\\n        for(int i=1;i<v.size()-1;i++)\\n        {\\n            if(v[i]>v[i-1]&&v[i]>v[i+1])\\n            cnt++;\\n            if(v[i]<v[i-1] && v[i]<v[i+1])\\n            cnt++;\\n        }\\n        return cnt;\\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3857687,
                "title": "javasctipt-very-intuitive",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nwe dont care about the number of indeces in valleys and hills, so remove all adjacent elements of same value. Then loop through the resultant array.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. create a new array where no element is of same value and are adjacent. \\n2. iterate starting from idx 1 and till one before last and check if each idx you are at is either bigger or smaller its left and right neighbors. \\n3. if so, add to the result\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n2 * O(n) since we loop through array twice, discard constant -> so O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n) since we create another array of potentially size equal to the original array.\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar countHillValley = function(nums) {\\n    let cnt = 0;\\n    const u =  []\\n\\n    for (const n of nums) {\\n        if (u.length === 0 || u.at(-1) !== n) {\\n            u.push(n)\\n        }\\n    }\\n\\n    for (let i = 1; i<u.length-1; i++) {\\n        if (u[i] > u[i-1] && u[i] > u[i+1] ||\\n        u[i] < u[i-1] && u[i] < u[i+1]) {\\n            cnt++;\\n        }\\n    }\\n\\n    return cnt;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar countHillValley = function(nums) {\\n    let cnt = 0;\\n    const u =  []\\n\\n    for (const n of nums) {\\n        if (u.length === 0 || u.at(-1) !== n) {\\n            u.push(n)\\n        }\\n    }\\n\\n    for (let i = 1; i<u.length-1; i++) {\\n        if (u[i] > u[i-1] && u[i] > u[i+1] ||\\n        u[i] < u[i-1] && u[i] < u[i+1]) {\\n            cnt++;\\n        }\\n    }\\n\\n    return cnt;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3810778,
                "title": "o-n-solution-in-cpp",
                "content": "\\n# Complexity\\n- Time complexity:```O(n)```\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:  ```O(1)```\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        int ans = 0;\\n        for (int i = 1, j = 0; i < nums.size() - 1; ++i)\\n            if ((nums[j] < nums[i] && nums[i] > nums[i + 1]) ||\\n                (nums[j] > nums[i] && nums[i] < nums[i + 1])) {\\n                ++ans;\\n                j = i;\\n            }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```O(n)```\n```O(1)```\n```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        int ans = 0;\\n        for (int i = 1, j = 0; i < nums.size() - 1; ++i)\\n            if ((nums[j] < nums[i] && nums[i] > nums[i + 1]) ||\\n                (nums[j] > nums[i] && nums[i] < nums[i + 1])) {\\n                ++ans;\\n                j = i;\\n            }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3808368,
                "title": "java-array-traversal-100-fast-quickest-easy",
                "content": "# Code\\n```\\nclass Solution {\\n    public int countHillValley(int[] nums) {\\n        int ans = 0;\\n        for(int i=1 ; i<nums.length-1; i++){\\n            if(nums[i]==nums[i-1]) {continue;}\\n            int left = closestLeft(i,nums);\\n            int rigt = closestRigt(i,nums);\\n            if(left>nums[i] && rigt>nums[i]) ans++;\\n            if(left<nums[i] && rigt<nums[i]) ans++;\\n        }\\n        return ans;\\n    }\\n    private int closestLeft(int index, int[] arr) {\\n        if(arr[index-1]!=arr[index]) return arr[index-1];\\n        else {\\n            int i = index-1;\\n            while(i>0){\\n                if(arr[i]!=arr[index]) return arr[i];\\n                else i--;\\n            }\\n            return arr[index];\\n        }\\n    }\\n    private int closestRigt(int index, int[] arr) {\\n        if(arr[index+1]!=arr[index]) return arr[index+1];\\n        else {\\n            int i = index+1;\\n            while(i<arr.length){\\n                if(arr[i]!=arr[index]) return arr[i];\\n                else i++;\\n            }\\n            return arr[index];\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countHillValley(int[] nums) {\\n        int ans = 0;\\n        for(int i=1 ; i<nums.length-1; i++){\\n            if(nums[i]==nums[i-1]) {continue;}\\n            int left = closestLeft(i,nums);\\n            int rigt = closestRigt(i,nums);\\n            if(left>nums[i] && rigt>nums[i]) ans++;\\n            if(left<nums[i] && rigt<nums[i]) ans++;\\n        }\\n        return ans;\\n    }\\n    private int closestLeft(int index, int[] arr) {\\n        if(arr[index-1]!=arr[index]) return arr[index-1];\\n        else {\\n            int i = index-1;\\n            while(i>0){\\n                if(arr[i]!=arr[index]) return arr[i];\\n                else i--;\\n            }\\n            return arr[index];\\n        }\\n    }\\n    private int closestRigt(int index, int[] arr) {\\n        if(arr[index+1]!=arr[index]) return arr[index+1];\\n        else {\\n            int i = index+1;\\n            while(i<arr.length){\\n                if(arr[i]!=arr[index]) return arr[i];\\n                else i++;\\n            }\\n            return arr[index];\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3782614,
                "title": "easy-c-solution",
                "content": "# Intuition\\nLook for closest left and right non-equal numbers\\n# Approach\\nSkip the equal numbers and look for hills and valleys by accessing closest left and right non-equal numbers. Make three variables l,m,r to denote left, middle and right values.\\n# Complexity\\n- Time complexity:\\nO(N)\\n- Space complexity:\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        int count = 0;\\n        int l = 0;\\n        int m = 1;\\n        int r = 2;\\n        while(r<nums.size()){\\n            if((nums[l] > nums[m] && nums[r] > nums[m]) ||\\n                (nums[l] < nums[m] && nums[r] < nums[m])\\n            ){\\n                cout<<nums[l]<<\" \"<<nums[m]<<\" \"<<nums[r]<<endl;\\n                count++;\\n                r++;\\n                m++;\\n                l= m-1;\\n            }else if(nums[l]==nums[m]){\\n                r++;\\n                m++;\\n                l++;\\n            }else if(nums[r]==nums[m]){\\n                r++;\\n                m++;\\n            }else{\\n                r++;\\n                m++;\\n                l++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        int count = 0;\\n        int l = 0;\\n        int m = 1;\\n        int r = 2;\\n        while(r<nums.size()){\\n            if((nums[l] > nums[m] && nums[r] > nums[m]) ||\\n                (nums[l] < nums[m] && nums[r] < nums[m])\\n            ){\\n                cout<<nums[l]<<\" \"<<nums[m]<<\" \"<<nums[r]<<endl;\\n                count++;\\n                r++;\\n                m++;\\n                l= m-1;\\n            }else if(nums[l]==nums[m]){\\n                r++;\\n                m++;\\n                l++;\\n            }else if(nums[r]==nums[m]){\\n                r++;\\n                m++;\\n            }else{\\n                r++;\\n                m++;\\n                l++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3780341,
                "title": "beats-100-memory-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countHillValley(int[] nums) {         \\n         int left=-1;\\n         int count=0;\\n          for (int i=0;i<nums.length-1;i++){\\n            if(nums[i]==nums[i+1]){\\n              continue;\\n            }\\n            int right=nums[i+1];\\n            if(left!=-1 && nums[i]>left && nums[i]>right || nums[i]<left && nums[i]<right)\\n            {\\n                count++;\\n            }\\n\\n            left= nums[i];\\n        }\\n         return count;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countHillValley(int[] nums) {         \\n         int left=-1;\\n         int count=0;\\n          for (int i=0;i<nums.length-1;i++){\\n            if(nums[i]==nums[i+1]){\\n              continue;\\n            }\\n            int right=nums[i+1];\\n            if(left!=-1 && nums[i]>left && nums[i]>right || nums[i]<left && nums[i]<right)\\n            {\\n                count++;\\n            }\\n\\n            left= nums[i];\\n        }\\n         return count;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3778163,
                "title": "best-way-to-solve-problem-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        int i=0,count=0,hill=0,valley=0;\\n        for(int i=1;i<nums.size();i++){\\n            if(nums[i-1]<nums[i] && hill==0){\\n                hill=1;\\n                if(valley==1){\\n                count++;\\n                valley=0;\\n                }\\n            }\\n             else if(nums[i-1]>nums[i] && valley==0)\\n            {\\n                valley=1;\\n                if(hill==1){\\n                count++;\\n                hill=0;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        int i=0,count=0,hill=0,valley=0;\\n        for(int i=1;i<nums.size();i++){\\n            if(nums[i-1]<nums[i] && hill==0){\\n                hill=1;\\n                if(valley==1){\\n                count++;\\n                valley=0;\\n                }\\n            }\\n             else if(nums[i-1]>nums[i] && valley==0)\\n            {\\n                valley=1;\\n                if(hill==1){\\n                count++;\\n                hill=0;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3773052,
                "title": "python-3-solution",
                "content": "we first create a new list with no same element in adjacent indices.That will make our calculation easier.and then just by basic comparision with the previous and former element we can calculate the ans.This logic is easy to understand for the beginners.thank you .Happy Coding. If u like this solution plz give an upvote\\n\\n\\n\\n```\\nclass Solution:\\n    def countHillValley(self, nums: List[int]) -> int:\\n        num1=[]\\n        nums.append(0)\\n        \\n        c=0\\n        for i in range (len(nums)-1):\\n            if(nums[i]!=nums[i+1]):\\n                num1.append(nums[i])\\n                \\n                \\n        for i in range(1,len(num1)-1):\\n            if(num1[i]>num1[i+1] and num1[i]>num1[i-1]):\\n                c+=1\\n            elif(num1[i]<num1[i+1] and num1[i]<num1[i-1]):\\n                c+=1\\n            else:\\n                continue\\n        return c\\n            \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countHillValley(self, nums: List[int]) -> int:\\n        num1=[]\\n        nums.append(0)\\n        \\n        c=0\\n        for i in range (len(nums)-1):\\n            if(nums[i]!=nums[i+1]):\\n                num1.append(nums[i])\\n                \\n                \\n        for i in range(1,len(num1)-1):\\n            if(num1[i]>num1[i+1] and num1[i]>num1[i-1]):\\n                c+=1\\n            elif(num1[i]<num1[i+1] and num1[i]<num1[i-1]):\\n                c+=1\\n            else:\\n                continue\\n        return c\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3761858,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        int result = 0;\\n        int idxXtrmStart = 1;\\n        int idxXtrmEnd = idxXtrmStart;\\n        while (idxXtrmEnd < (nums.size() - 1))\\n        {\\n            while ((idxXtrmEnd < (nums.size() - 2)) &&\\n                    (nums[idxXtrmEnd] == nums[idxXtrmEnd+1]))\\n            {\\n                idxXtrmEnd++;\\n            }\\n            if ( ((nums[idxXtrmStart] > nums[idxXtrmStart - 1]) \\n                    && (nums[idxXtrmEnd] > nums[idxXtrmEnd + 1])) ||\\n                 ((nums[idxXtrmStart] < nums[idxXtrmStart - 1]) \\n                    && (nums[idxXtrmEnd] < nums[idxXtrmEnd + 1])))\\n            {\\n                result++;\\n            }\\n            idxXtrmStart = idxXtrmEnd + 1;\\n            idxXtrmEnd = idxXtrmStart;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        int result = 0;\\n        int idxXtrmStart = 1;\\n        int idxXtrmEnd = idxXtrmStart;\\n        while (idxXtrmEnd < (nums.size() - 1))\\n        {\\n            while ((idxXtrmEnd < (nums.size() - 2)) &&\\n                    (nums[idxXtrmEnd] == nums[idxXtrmEnd+1]))\\n            {\\n                idxXtrmEnd++;\\n            }\\n            if ( ((nums[idxXtrmStart] > nums[idxXtrmStart - 1]) \\n                    && (nums[idxXtrmEnd] > nums[idxXtrmEnd + 1])) ||\\n                 ((nums[idxXtrmStart] < nums[idxXtrmStart - 1]) \\n                    && (nums[idxXtrmEnd] < nums[idxXtrmEnd + 1])))\\n            {\\n                result++;\\n            }\\n            idxXtrmStart = idxXtrmEnd + 1;\\n            idxXtrmEnd = idxXtrmStart;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3754852,
                "title": "easy-to-understand-java-beginner-s-need",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countHillValley(int[] nums) {\\n        int prev=nums[0];\\n        int count=0,j=0,i=0;\\n        int[] temp=new int[nums.length];\\n        for( i=0;i<nums.length-1;i++)\\n        {\\nif(nums[i]==nums[i+1])\\ncontinue;\\ntemp[j++]=nums[i];\\n        }\\n        temp[j]=nums[i];\\n        for(int k=1;k<j;k++)\\n        {\\n     if(temp[k]<temp[k-1] && temp[k]<temp[k+1])\\n    count++;\\n    if(temp[k]>temp[k-1] && temp[k]>temp[k+1])\\n    count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countHillValley(int[] nums) {\\n        int prev=nums[0];\\n        int count=0,j=0,i=0;\\n        int[] temp=new int[nums.length];\\n        for( i=0;i<nums.length-1;i++)\\n        {\\nif(nums[i]==nums[i+1])\\ncontinue;\\ntemp[j++]=nums[i];\\n        }\\n        temp[j]=nums[i];\\n        for(int k=1;k<j;k++)\\n        {\\n     if(temp[k]<temp[k-1] && temp[k]<temp[k+1])\\n    count++;\\n    if(temp[k]>temp[k-1] && temp[k]>temp[k+1])\\n    count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3750511,
                "title": "solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar countHillValley = function(nums) {\\n        // if current >= left && current >= right => hill\\n        // current <= left && current <= right => valley;\\n\\n        let count = 0;\\n        let lastElement = 0;\\n        let current = nums[0];\\n        let lst = [current];\\n\\n        for(let i=1;i<nums.length;i++){\\n            if (current != nums[i])lst.push(nums[i]);\\n            current = nums[i];\\n        }\\n        \\n\\n        for(let i=0;i<lst.length-1;i++){\\n            let current = lst[i];\\n            if (current >= lst[i-1] && current >= lst[i+1])count+=1;\\n            else if (current <= lst[i-1] && current <= lst[i+1])count+=1;            \\n        }\\n\\n        return count;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar countHillValley = function(nums) {\\n        // if current >= left && current >= right => hill\\n        // current <= left && current <= right => valley;\\n\\n        let count = 0;\\n        let lastElement = 0;\\n        let current = nums[0];\\n        let lst = [current];\\n\\n        for(let i=1;i<nums.length;i++){\\n            if (current != nums[i])lst.push(nums[i]);\\n            current = nums[i];\\n        }\\n        \\n\\n        for(let i=0;i<lst.length-1;i++){\\n            let current = lst[i];\\n            if (current >= lst[i-1] && current >= lst[i+1])count+=1;\\n            else if (current <= lst[i-1] && current <= lst[i+1])count+=1;            \\n        }\\n\\n        return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3748747,
                "title": "java-easy-solution-0-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countHillValley(int[] nums) {\\n      int hill=0;\\n      int valley=0;\\n      int j=0;\\n      for(int i=1;i<nums.length-1;i++)\\n      {\\n          if(nums[j]<nums[i] && nums[i]>nums[i+1])\\n          {\\n              hill++;\\n              j=i;\\n          }\\n          if(nums[j]>nums[i] && nums[i]<nums[i+1])\\n          {\\n              valley++;\\n              j=i;\\n          }\\n      }  \\n      return hill+valley;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countHillValley(int[] nums) {\\n      int hill=0;\\n      int valley=0;\\n      int j=0;\\n      for(int i=1;i<nums.length-1;i++)\\n      {\\n          if(nums[j]<nums[i] && nums[i]>nums[i+1])\\n          {\\n              hill++;\\n              j=i;\\n          }\\n          if(nums[j]>nums[i] && nums[i]<nums[i+1])\\n          {\\n              valley++;\\n              j=i;\\n          }\\n      }  \\n      return hill+valley;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3748746,
                "title": "java-easy-solution-0-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countHillValley(int[] nums) {\\n      int hill=0;\\n      int valley=0;\\n      int j=0;\\n      for(int i=1;i<nums.length-1;i++)\\n      {\\n          if(nums[j]<nums[i] && nums[i]>nums[i+1])\\n          {\\n              hill++;\\n              j=i;\\n          }\\n          if(nums[j]>nums[i] && nums[i]<nums[i+1])\\n          {\\n              valley++;\\n              j=i;\\n          }\\n      }  \\n      return hill+valley;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countHillValley(int[] nums) {\\n      int hill=0;\\n      int valley=0;\\n      int j=0;\\n      for(int i=1;i<nums.length-1;i++)\\n      {\\n          if(nums[j]<nums[i] && nums[i]>nums[i+1])\\n          {\\n              hill++;\\n              j=i;\\n          }\\n          if(nums[j]>nums[i] && nums[i]<nums[i+1])\\n          {\\n              valley++;\\n              j=i;\\n          }\\n      }  \\n      return hill+valley;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3730058,
                "title": "using-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n     public int countHillValley(int[] a){\\n        int r = 0, left = a[0];\\n        for(int i = 1; i < a.length - 1; i++)\\n            if(left < a[i] && a[i] > a[i + 1] || left > a[i] && a[i] < a[i + 1]){\\n                r++;\\n                left = a[i];\\n            }\\n        return r;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n     public int countHillValley(int[] a){\\n        int r = 0, left = a[0];\\n        for(int i = 1; i < a.length - 1; i++)\\n            if(left < a[i] && a[i] > a[i + 1] || left > a[i] && a[i] < a[i + 1]){\\n                r++;\\n                left = a[i];\\n            }\\n        return r;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3728749,
                "title": "best-solution-in-o-n-time-and-space-complexity-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach \\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        int count=0;\\n\\n        vector<int> arr{nums[0]};\\n        \\n        for(int i=1; i<nums.size(); i++){\\n            if(nums[i-1]!=nums[i]){\\n                arr.push_back(nums[i]);\\n            }\\n        }\\n\\n        for(int i=1; i<arr.size()-1; i++){\\n            if(arr[i] > arr[i+1] && arr[i] > arr[i-1]) count++;\\n\\n            else if(arr[i] <arr[i+1] && arr[i]<arr[i-1]) count++;\\n\\n\\n        }\\n\\n        return count;\\n\\n        \\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        int count=0;\\n\\n        vector<int> arr{nums[0]};\\n        \\n        for(int i=1; i<nums.size(); i++){\\n            if(nums[i-1]!=nums[i]){\\n                arr.push_back(nums[i]);\\n            }\\n        }\\n\\n        for(int i=1; i<arr.size()-1; i++){\\n            if(arr[i] > arr[i+1] && arr[i] > arr[i-1]) count++;\\n\\n            else if(arr[i] <arr[i+1] && arr[i]<arr[i-1]) count++;\\n\\n\\n        }\\n\\n        return count;\\n\\n        \\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3724501,
                "title": "java-simple-readable",
                "content": "Code is self explanatory, but feel free to ask questions\\n>**T/S:** O(n)/O(1), where n = size(nums)\\n```\\npublic int countHillValley(int[] nums) {\\n\\tvar hilleys = 0;\\n\\tvar prev = nums[0];\\n\\n\\tfor (var i = 1; i + 1 < nums.length; i++) {\\n\\t\\tif (nums[i] == prev)\\n\\t\\t\\tcontinue;\\n\\n\\t\\tvar isHill = prev < nums[i] && nums[i] > nums[i + 1];\\n\\t\\tvar isValley = prev > nums[i] && nums[i] < nums[i + 1];\\n\\n\\t\\tif (isHill || isValley)\\n\\t\\t\\thilleys++;\\n\\t\\tif (nums[i] != nums[i + 1])\\n\\t\\t\\tprev = nums[i];\\n\\t}\\n\\n\\treturn hilleys;\\n}\\n```\\n***Please upvote if this helps***",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int countHillValley(int[] nums) {\\n\\tvar hilleys = 0;\\n\\tvar prev = nums[0];\\n\\n\\tfor (var i = 1; i + 1 < nums.length; i++) {\\n\\t\\tif (nums[i] == prev)\\n\\t\\t\\tcontinue;\\n\\n\\t\\tvar isHill = prev < nums[i] && nums[i] > nums[i + 1];\\n\\t\\tvar isValley = prev > nums[i] && nums[i] < nums[i + 1];\\n\\n\\t\\tif (isHill || isValley)\\n\\t\\t\\thilleys++;\\n\\t\\tif (nums[i] != nums[i + 1])\\n\\t\\t\\tprev = nums[i];\\n\\t}\\n\\n\\treturn hilleys;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3721426,
                "title": "2-pointers",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countHillValley(int[] nums) {\\n        int count= 0, left = nums[0];\\n        for(int i = 1; i < nums.length - 1; i++)\\n            if(left < nums[i] && nums[i] > nums[i + 1] || left > nums[i] && nums[i] < nums[i + 1]){\\n                count++;\\n                left = nums[i];\\n            }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countHillValley(int[] nums) {\\n        int count= 0, left = nums[0];\\n        for(int i = 1; i < nums.length - 1; i++)\\n            if(left < nums[i] && nums[i] > nums[i + 1] || left > nums[i] && nums[i] < nums[i + 1]){\\n                count++;\\n                left = nums[i];\\n            }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3711856,
                "title": "java-easy-solution-0ms-beats-100",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    Mantain a pointer for the leftmost element of a hill or a valley\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n# Code\\n```\\nclass Solution {\\n    public int countHillValley(int[] nums) {\\n        int pointer=nums[0];\\n        int count=0;\\n        for(int i=1;i<nums.length-1;i++){\\n            if( (pointer<nums[i] && nums[i]>nums[i+1]) || (nums[i]<pointer && nums[i]<nums[i+1]) ){\\n                count++;\\n                pointer=nums[i];\\n            }\\n        }\\n        return count;\\n    }\\n//commment if you like the solution\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int countHillValley(int[] nums) {\\n        int pointer=nums[0];\\n        int count=0;\\n        for(int i=1;i<nums.length-1;i++){\\n            if( (pointer<nums[i] && nums[i]>nums[i+1]) || (nums[i]<pointer && nums[i]<nums[i+1]) ){\\n                count++;\\n                pointer=nums[i];\\n            }\\n        }\\n        return count;\\n    }\\n//commment if you like the solution\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3704360,
                "title": "easy-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countHillValley(self, nums: List[int]) -> int:\\n        counter = 0\\n        temp = nums[0]\\n        for ind, i in enumerate(nums[1:-1], start=1):\\n            if i < temp and i < nums[ind + 1] or i > temp and i > nums[ind+1]:\\n                counter += 1\\n                temp = i\\n        return counter       \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countHillValley(self, nums: List[int]) -> int:\\n        counter = 0\\n        temp = nums[0]\\n        for ind, i in enumerate(nums[1:-1], start=1):\\n            if i < temp and i < nums[ind + 1] or i > temp and i > nums[ind+1]:\\n                counter += 1\\n                temp = i\\n        return counter       \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3696321,
                "title": "simple-javascript-solution",
                "content": "\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar countHillValley = function(nums) {\\n        let diff = nums[1] - nums[0];\\n        let currDiff = 0;\\n        let count = 0;\\n        for(let i = 2; i < nums.length; i++) {\\n            currDiff = nums[i] - nums[i - 1];\\n            if(currDiff != 0) {\\n                if(currDiff * diff < 0) count++;\\n                diff = currDiff;\\n            }\\n        }\\n        return count;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar countHillValley = function(nums) {\\n        let diff = nums[1] - nums[0];\\n        let currDiff = 0;\\n        let count = 0;\\n        for(let i = 2; i < nums.length; i++) {\\n            currDiff = nums[i] - nums[i - 1];\\n            if(currDiff != 0) {\\n                if(currDiff * diff < 0) count++;\\n                diff = currDiff;\\n            }\\n        }\\n        return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3690943,
                "title": "c-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nRemove adjecent duplicates and apply the condition \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\no(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        vector<int> res;\\n        res.push_back(nums[0]);\\n        for(int i=1;i<nums.size();i++){\\n            if(nums[i]!=nums[i-1]){\\n                res.push_back(nums[i]);\\n            }\\n        }\\n        nums.clear();\\n      \\n        int count=0;\\n        for(int i=2;i<res.size();i++){\\n            if(res[i-2]>res[i-1] && res[i-1]<res[i]){\\n                count++;\\n            }\\n            else if(res[i-2]<res[i-1] && res[i-1]>res[i]){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        vector<int> res;\\n        res.push_back(nums[0]);\\n        for(int i=1;i<nums.size();i++){\\n            if(nums[i]!=nums[i-1]){\\n                res.push_back(nums[i]);\\n            }\\n        }\\n        nums.clear();\\n      \\n        int count=0;\\n        for(int i=2;i<res.size();i++){\\n            if(res[i-2]>res[i-1] && res[i-1]<res[i]){\\n                count++;\\n            }\\n            else if(res[i-2]<res[i-1] && res[i-1]>res[i]){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3689763,
                "title": "scala-solution",
                "content": "# Code\\n```\\nobject Solution {\\n    def countHillValley(list: Array[Int]): Int = {\\n    var i = 0\\n      var count: Int = 0\\n      while (i < list.length - 1) {\\n        val leftNonEqual = (i - 1 to 0 by -1).collectFirst { case x if list(x) != list(i) => x }\\n        val rightNonEqual = (i + 1 until list.length).collectFirst { case x if list(x) != list(i) => x }\\n\\n        val isHillOrValley = for {\\n          left <- leftNonEqual\\n          right <- rightNonEqual\\n        } yield (list(left) < list(i) && list(i) > list(right)) || (list(left) > list(i) && list(i) < list(right))\\n\\n        i = rightNonEqual.getOrElse(i + 1)\\n        count += (isHillOrValley match {\\n          case Some(true) => 1\\n          case _ => 0\\n        })\\n      }\\n\\n      count\\n    }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n    def countHillValley(list: Array[Int]): Int = {\\n    var i = 0\\n      var count: Int = 0\\n      while (i < list.length - 1) {\\n        val leftNonEqual = (i - 1 to 0 by -1).collectFirst { case x if list(x) != list(i) => x }\\n        val rightNonEqual = (i + 1 until list.length).collectFirst { case x if list(x) != list(i) => x }\\n\\n        val isHillOrValley = for {\\n          left <- leftNonEqual\\n          right <- rightNonEqual\\n        } yield (list(left) < list(i) && list(i) > list(right)) || (list(left) > list(i) && list(i) < list(right))\\n\\n        i = rightNonEqual.getOrElse(i + 1)\\n        count += (isHillOrValley match {\\n          case Some(true) => 1\\n          case _ => 0\\n        })\\n      }\\n\\n      count\\n    }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3688446,
                "title": "easy-c-for-beginner",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N2) as for every element we are traversing the array for left and right in worst case it can go n2\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1) as we are not using any as such space\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        int ans = 0;\\n        int n = nums.size();\\n\\n        for(int i=1;i<n-1;i++){\\n            // if same hill\\n            if(nums[i] == nums[i+1])continue;\\n\\n            // else find the first left index which is not equal\\n            int j = i-1;\\n            int left = -1;\\n            while(j >= 0){\\n                if(nums[j] != nums[i]){\\n                    left = nums[j];\\n                    break;\\n                }\\n                j--;\\n            }\\n\\n            // also find the first right index which is not equal\\n            j=i+1;\\n            int right = -1;\\n            while(j < n){\\n                if(nums[j] != nums[i]){\\n                    right = nums[j];\\n                    break;\\n                }\\n                j++;\\n            }\\n\\n            // if u have both left and right available i.e != -1 then check for hill or valley and increase the ans\\n            if(left != -1 and right != -1 and nums[i] > left and nums[i] > right)ans++;\\n            else if(left != -1 and right != -1 and nums[i] < left and nums[i] < right)ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        int ans = 0;\\n        int n = nums.size();\\n\\n        for(int i=1;i<n-1;i++){\\n            // if same hill\\n            if(nums[i] == nums[i+1])continue;\\n\\n            // else find the first left index which is not equal\\n            int j = i-1;\\n            int left = -1;\\n            while(j >= 0){\\n                if(nums[j] != nums[i]){\\n                    left = nums[j];\\n                    break;\\n                }\\n                j--;\\n            }\\n\\n            // also find the first right index which is not equal\\n            j=i+1;\\n            int right = -1;\\n            while(j < n){\\n                if(nums[j] != nums[i]){\\n                    right = nums[j];\\n                    break;\\n                }\\n                j++;\\n            }\\n\\n            // if u have both left and right available i.e != -1 then check for hill or valley and increase the ans\\n            if(left != -1 and right != -1 and nums[i] > left and nums[i] > right)ans++;\\n            else if(left != -1 and right != -1 and nums[i] < left and nums[i] < right)ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3686323,
                "title": "c-single-pass-elegant-clean-easy-o-1-space-o-n-time",
                "content": "# Intuition\\nIncrement the count in case: \\n    - When we are at the hill and if we have already seen the valley in the past. \\n    - When we are at the Valley and if we have already seen the Hill in the past. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    // last_pos = 0  --> Initial position\\n    // last_pos = 1  --> At the Hill.\\n    // last_pos = 2  --> At the Valley.\\n\\n    #define START   0\\n    #define HILL    1\\n    #define VALLEY  2\\n    int countHillValley(vector<int>& nums) {\\n        int count = 0, last_pos = START;\\n        for (int i = 1; i < nums.size(); i++) {\\n            if (nums[i] > nums[i - 1]) {\\n                count += (last_pos == VALLEY ? 1 : 0);\\n                last_pos = HILL;\\n            } else if (nums[i] < nums[i - 1]) {\\n                count += (last_pos == HILL ? 1 : 0);\\n                last_pos = VALLEY;\\n            }\\n       }\\n       return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // last_pos = 0  --> Initial position\\n    // last_pos = 1  --> At the Hill.\\n    // last_pos = 2  --> At the Valley.\\n\\n    #define START   0\\n    #define HILL    1\\n    #define VALLEY  2\\n    int countHillValley(vector<int>& nums) {\\n        int count = 0, last_pos = START;\\n        for (int i = 1; i < nums.size(); i++) {\\n            if (nums[i] > nums[i - 1]) {\\n                count += (last_pos == VALLEY ? 1 : 0);\\n                last_pos = HILL;\\n            } else if (nums[i] < nums[i - 1]) {\\n                count += (last_pos == HILL ? 1 : 0);\\n                last_pos = VALLEY;\\n            }\\n       }\\n       return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3678492,
                "title": "easy-o-n-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        int ct=0,n=nums.size();\\n        vector<int> dp1(n,-1),dp2(n,-1);\\n        for(int i=1;i<n;i++){\\n            if(nums[i]==nums[i-1]) dp1[i]=dp1[i-1];\\n            else dp1[i]=nums[i-1];\\n        }\\n        for(int i=n-2;i>=0;i--){\\n            if(nums[i]==nums[i+1]) dp2[i]=dp2[i+1];\\n            else dp2[i]=nums[i+1];\\n        }\\n        for(int i=1;i<n-1;i++){\\n            if(dp1[i]!=-1 && dp2[i]!=-1 && nums[i]>dp1[i] && nums[i]>dp2[i] && nums[i]!=nums[i-1]) ct++;\\n            if(dp1[i]!=-1 && dp2[i]!=-1 && nums[i]<dp1[i] && nums[i]<dp2[i] && nums[i]!=nums[i-1]) ct++;\\n        }\\n        return ct;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        int ct=0,n=nums.size();\\n        vector<int> dp1(n,-1),dp2(n,-1);\\n        for(int i=1;i<n;i++){\\n            if(nums[i]==nums[i-1]) dp1[i]=dp1[i-1];\\n            else dp1[i]=nums[i-1];\\n        }\\n        for(int i=n-2;i>=0;i--){\\n            if(nums[i]==nums[i+1]) dp2[i]=dp2[i+1];\\n            else dp2[i]=nums[i+1];\\n        }\\n        for(int i=1;i<n-1;i++){\\n            if(dp1[i]!=-1 && dp2[i]!=-1 && nums[i]>dp1[i] && nums[i]>dp2[i] && nums[i]!=nums[i-1]) ct++;\\n            if(dp1[i]!=-1 && dp2[i]!=-1 && nums[i]<dp1[i] && nums[i]<dp2[i] && nums[i]!=nums[i-1]) ct++;\\n        }\\n        return ct;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3676413,
                "title": "easy-c-solution-beginner-friendly-two-pointer-tail-pointer-approach",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n    int ans = 0;\\n    for (int i=1, j=0; i<nums.size()-1; i++)\\n        if((nums[j]<nums[i] && nums[i]>nums[i+1]) || (nums[j]>nums[i] && nums[i]<nums[i+1]))\\n        {\\n            ans++;\\n            j = i;\\n        }            \\n    return ans;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n    int ans = 0;\\n    for (int i=1, j=0; i<nums.size()-1; i++)\\n        if((nums[j]<nums[i] && nums[i]>nums[i+1]) || (nums[j]>nums[i] && nums[i]<nums[i+1]))\\n        {\\n            ans++;\\n            j = i;\\n        }            \\n    return ans;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3671491,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n*n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        int ans = 0;\\n\\n        for (int i=1 ; i<nums.size()-1 ; i++){\\n            int left=-1 , right=-1;\\n            int j=i-1 ; \\n            while (j>=0){\\n                if (nums[j] != nums[i]){\\n                    left = j;\\n                    break;\\n                }\\n                j--;\\n            }\\n\\n            j = i+1;\\n            while (j<nums.size()){\\n                if (nums[j] != nums[i]){\\n                    right = j;\\n                    break;\\n                }\\n                j++;\\n            }\\n            if (left == -1 || right == -1)\\n                continue;\\n\\n            if (nums[i]>max(nums[left] , nums[right]) || nums[i]<min(nums[left] , nums[right])){    \\n                if (nums[i] != nums[i-1]) {\\n                    ans++;\\n                }\\n            }\\n        }    \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        int ans = 0;\\n\\n        for (int i=1 ; i<nums.size()-1 ; i++){\\n            int left=-1 , right=-1;\\n            int j=i-1 ; \\n            while (j>=0){\\n                if (nums[j] != nums[i]){\\n                    left = j;\\n                    break;\\n                }\\n                j--;\\n            }\\n\\n            j = i+1;\\n            while (j<nums.size()){\\n                if (nums[j] != nums[i]){\\n                    right = j;\\n                    break;\\n                }\\n                j++;\\n            }\\n            if (left == -1 || right == -1)\\n                continue;\\n\\n            if (nums[i]>max(nums[left] , nums[right]) || nums[i]<min(nums[left] , nums[right])){    \\n                if (nums[i] != nums[i-1]) {\\n                    ans++;\\n                }\\n            }\\n        }    \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3665297,
                "title": "1ms-solution-and-100-less-memory-ovecomplicated-solution-rust-tm-noob",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn count_hill_valley(nums: Vec<i32>) -> i32 {\\n        let mut count: i32 = 0;\\n        let mut i: usize = 1;\\n        while i < nums.len()-1 {\\n            let mut temp_i: usize = i;\\n            let mut what: u8 = 0;\\n            // o: neither, 1: hill, 2: valley\\n            while temp_i > 0{\\n                temp_i -= 1;\\n                if nums[i] < nums[temp_i]{\\n                    what = 2; // valley\\n                    break;\\n                }\\n                if nums[i] > nums[temp_i]{\\n                    what = 1; // hill\\n                    break;\\n                }\\n                what = 0;\\n                if temp_i == 0 {break;}\\n            }\\n            if what == 0 {\\n                i += 1;\\n                continue;\\n            }\\n            let mut temp_i: usize = i;\\n            while temp_i < nums.len(){\\n                temp_i += 1;\\n                if what == 2 && nums[i] < nums[temp_i]{\\n                    count += 1;\\n                    i = temp_i;\\n                    break;\\n                }\\n                if what == 1 && nums[i] > nums[temp_i]{\\n                    count += 1;\\n                    i = temp_i;\\n                    break;\\n                }\\n                what = 0;\\n            }\\n            if what == 0  {i += 1;}\\n        }\\n\\n        count\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Array"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn count_hill_valley(nums: Vec<i32>) -> i32 {\\n        let mut count: i32 = 0;\\n        let mut i: usize = 1;\\n        while i < nums.len()-1 {\\n            let mut temp_i: usize = i;\\n            let mut what: u8 = 0;\\n            // o: neither, 1: hill, 2: valley\\n            while temp_i > 0{\\n                temp_i -= 1;\\n                if nums[i] < nums[temp_i]{\\n                    what = 2; // valley\\n                    break;\\n                }\\n                if nums[i] > nums[temp_i]{\\n                    what = 1; // hill\\n                    break;\\n                }\\n                what = 0;\\n                if temp_i == 0 {break;}\\n            }\\n            if what == 0 {\\n                i += 1;\\n                continue;\\n            }\\n            let mut temp_i: usize = i;\\n            while temp_i < nums.len(){\\n                temp_i += 1;\\n                if what == 2 && nums[i] < nums[temp_i]{\\n                    count += 1;\\n                    i = temp_i;\\n                    break;\\n                }\\n                if what == 1 && nums[i] > nums[temp_i]{\\n                    count += 1;\\n                    i = temp_i;\\n                    break;\\n                }\\n                what = 0;\\n            }\\n            if what == 0  {i += 1;}\\n        }\\n\\n        count\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3656200,
                "title": "c-easy",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        int c=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            int j=i-1,k=i+1;\\n            while(j>=0 && nums[j]==nums[i]) j--;\\n            while(k<nums.size() && nums[k]==nums[i]) k++;\\n            if(j>=0 && k<nums.size())\\n            {\\n                if(nums[i]>nums[j] && nums[i]>nums[k]) c++;\\n                if(nums[i]<nums[j] && nums[i]<nums[k]) c++;\\n                i=k-1;\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        int c=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            int j=i-1,k=i+1;\\n            while(j>=0 && nums[j]==nums[i]) j--;\\n            while(k<nums.size() && nums[k]==nums[i]) k++;\\n            if(j>=0 && k<nums.size())\\n            {\\n                if(nums[i]>nums[j] && nums[i]>nums[k]) c++;\\n                if(nums[i]<nums[j] && nums[i]<nums[k]) c++;\\n                i=k-1;\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3647317,
                "title": "php-two-pointers-solution",
                "content": "# Complexity\\n- Time complexity: O(n)\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\n\\n    /**\\n     * @param Integer[] $nums\\n     * @return Integer\\n     */\\n    function countHillValley($nums) {\\n        $j = 0;\\n        $count = 0;\\n\\n        // Iterate through the array, excluding the first and last elements\\n        for($i = 1; $i < count($nums)-1; $i++) {\\n            \\n            // Check if the current element is part of a hill\\n            if($nums[$i] > $nums[$j] && $nums[$i] > $nums[$i + 1]) {\\n                $count++;\\n                $j = $i;\\n            }\\n            \\n            // Check if the current element is part of a valley\\n            if($nums[$i] < $nums[$j] && $nums[$i] < $nums[$i + 1]) {\\n                $count++;\\n                $j = $i;\\n            }\\n        }\\n\\n        return $count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "PHP",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n\\n    /**\\n     * @param Integer[] $nums\\n     * @return Integer\\n     */\\n    function countHillValley($nums) {\\n        $j = 0;\\n        $count = 0;\\n\\n        // Iterate through the array, excluding the first and last elements\\n        for($i = 1; $i < count($nums)-1; $i++) {\\n            \\n            // Check if the current element is part of a hill\\n            if($nums[$i] > $nums[$j] && $nums[$i] > $nums[$i + 1]) {\\n                $count++;\\n                $j = $i;\\n            }\\n            \\n            // Check if the current element is part of a valley\\n            if($nums[$i] < $nums[$j] && $nums[$i] < $nums[$i + 1]) {\\n                $count++;\\n                $j = $i;\\n            }\\n        }\\n\\n        return $count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3602803,
                "title": "eliminate-duplicates",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nEliminate Duplicates and check the condition for a hill or a valley. \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\niterate over the array (after removing duplicates) and compare current elements with the one before and the one after and if the number is smaller than both or greater than both, increase the number of valleys/hills by one.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\ntime: O(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nspace: O(n)\\n# Code\\n```\\nclass Solution:\\n    def countHillValley(self, nums: List[int]) -> int:\\n        res = [nums[0]]\\n        for x in nums[1:]:\\n            if x != res[-1]:\\n                res.append(x)\\n\\n        ans = 0\\n        for i in range(1, len(res) - 1):\\n            if (res[i] > res[i -1] and res[i] > res[i+1]\\n                or res[i] < res[i -1] and res[i] < res[i+1]):\\n                ans += 1    \\n\\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countHillValley(self, nums: List[int]) -> int:\\n        res = [nums[0]]\\n        for x in nums[1:]:\\n            if x != res[-1]:\\n                res.append(x)\\n\\n        ans = 0\\n        for i in range(1, len(res) - 1):\\n            if (res[i] > res[i -1] and res[i] > res[i+1]\\n                or res[i] < res[i -1] and res[i] < res[i+1]):\\n                ans += 1    \\n\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3597019,
                "title": "o-n-c-faster-than-100-submissions",
                "content": "```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n      \\n int i=0,j=i+2;\\n int id=1;\\n   int count=0;\\n while(id<nums.size()-1){\\n   if(nums[id]==nums[j]){\\n     j++;\\n     id++;\\n     continue;\\n     }\\n   \\n     \\n   if(nums[i]<nums[id]&&nums[id]>nums[j])\\n  count++;\\n if(nums[i]>nums[id]&&nums[id]<nums[j])\\n\\n  count++;\\n     \\n \\n i=id,id++,j++;    \\n }    \\n     \\n  return count;\\n    }\\n};[](http://)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n      \\n int i=0,j=i+2;\\n int id=1;\\n   int count=0;\\n while(id<nums.size()-1){\\n   if(nums[id]==nums[j]){\\n     j++;\\n     id++;\\n     continue;\\n     }\\n   \\n     \\n   if(nums[i]<nums[id]&&nums[id]>nums[j])\\n  count++;\\n if(nums[i]>nums[id]&&nums[id]<nums[j])\\n\\n  count++;\\n     \\n \\n i=id,id++,j++;    \\n }    \\n     \\n  return count;\\n    }\\n};[](http://)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3590537,
                "title": "python-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def countHillValley(self, nums: List[int]) -> int:\\n        ans=0\\n        prev=0\\n        for i in range(1,len(nums)-1):\\n            curr=i\\n            if (nums[curr]<nums[prev] and nums[curr]<nums[curr+1]) or (nums[curr]>nums[curr+1] and nums[curr]>nums[prev]):\\n                ans+=1\\n                prev=curr\\n        return ans\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countHillValley(self, nums: List[int]) -> int:\\n        ans=0\\n        prev=0\\n        for i in range(1,len(nums)-1):\\n            curr=i\\n            if (nums[curr]<nums[prev] and nums[curr]<nums[curr+1]) or (nums[curr]>nums[curr+1] and nums[curr]>nums[prev]):\\n                ans+=1\\n                prev=curr\\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3590450,
                "title": "count-hills-and-valleys-in-an-array-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n\\n        vector<int> pre, suf;\\n        suf.push_back(0);\\n\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            for(int j=i+1;j<nums.size();j++)\\n            {\\n                if(nums[i]!=nums[j])\\n                {\\n                    pre.push_back(nums[j]);\\n                    break;\\n                }\\n                if(j==nums.size()-1)\\n                pre.push_back(0);\\n            }\\n        }\\n\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            for(int j=i-1;j>=0;j--)\\n            {\\n                if(nums[i]!=nums[j])\\n                {\\n                    suf.push_back(nums[j]);\\n                    break;\\n                }\\n                if(j==0)\\n                suf.push_back(0);\\n            }\\n        }\\n\\n        pre.push_back(0);\\n\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            cout<<pre[i]<<\" \"<<suf[i]<<endl;\\n        }\\n\\n        int hill=0;\\n\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(i==0 || i==nums.size()-1)\\n            continue;\\n\\n            cout<<\"nums=\"<<nums[i]<<\" pre=\"<<pre[i]<<\" suf=\"<<suf[i]<<endl;\\n            if(nums[i]==nums[i-1])\\n            continue;\\n\\n            if(nums[i]>pre[i] && nums[i]>suf[i] && pre[i]!=0 && suf[i]!=0)\\n            {hill++;\\n            cout<<hill<<endl;\\n            }\\n            else if(nums[i]<pre[i] && nums[i]<suf[i] && pre[i]!=0 && suf[i]!=0)\\n            {hill++;\\n            cout<<hill<<endl;}\\n        }\\n\\n        return hill;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n\\n        vector<int> pre, suf;\\n        suf.push_back(0);\\n\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            for(int j=i+1;j<nums.size();j++)\\n            {\\n                if(nums[i]!=nums[j])\\n                {\\n                    pre.push_back(nums[j]);\\n                    break;\\n                }\\n                if(j==nums.size()-1)\\n                pre.push_back(0);\\n            }\\n        }\\n\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            for(int j=i-1;j>=0;j--)\\n            {\\n                if(nums[i]!=nums[j])\\n                {\\n                    suf.push_back(nums[j]);\\n                    break;\\n                }\\n                if(j==0)\\n                suf.push_back(0);\\n            }\\n        }\\n\\n        pre.push_back(0);\\n\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            cout<<pre[i]<<\" \"<<suf[i]<<endl;\\n        }\\n\\n        int hill=0;\\n\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(i==0 || i==nums.size()-1)\\n            continue;\\n\\n            cout<<\"nums=\"<<nums[i]<<\" pre=\"<<pre[i]<<\" suf=\"<<suf[i]<<endl;\\n            if(nums[i]==nums[i-1])\\n            continue;\\n\\n            if(nums[i]>pre[i] && nums[i]>suf[i] && pre[i]!=0 && suf[i]!=0)\\n            {hill++;\\n            cout<<hill<<endl;\\n            }\\n            else if(nums[i]<pre[i] && nums[i]<suf[i] && pre[i]!=0 && suf[i]!=0)\\n            {hill++;\\n            cout<<hill<<endl;}\\n        }\\n\\n        return hill;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3580508,
                "title": "beats-100-o-n-vector",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        vector<int>v;\\n        v.push_back(nums[0]);\\n         for(int i=1;i<nums.size();i++)\\n         {\\n             if(nums[i]!=nums[i-1])\\n              v.push_back(nums[i]);\\n         }\\n         int count=0,i=1;\\n         while(i<v.size()-1)\\n         {\\n             if(v[i]<v[i-1]&&v[i]<v[i+1])\\n               count++;\\n             else if(v[i]>v[i-1]&&v[i]>v[i+1])  \\n                 count++;\\n            i++;     \\n         }\\n         return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        vector<int>v;\\n        v.push_back(nums[0]);\\n         for(int i=1;i<nums.size();i++)\\n         {\\n             if(nums[i]!=nums[i-1])\\n              v.push_back(nums[i]);\\n         }\\n         int count=0,i=1;\\n         while(i<v.size()-1)\\n         {\\n             if(v[i]<v[i-1]&&v[i]<v[i+1])\\n               count++;\\n             else if(v[i]>v[i-1]&&v[i]>v[i+1])  \\n                 count++;\\n            i++;     \\n         }\\n         return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3567207,
                "title": "beats-72-85-simple-solution-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        vector<int>ans;\\n        ans.push_back(nums[0]);\\n        for(int i=1;i<nums.size();i++){\\n            if(nums[i]!=nums[i-1]){\\n                ans.push_back(nums[i]);\\n            }\\n        }\\n        int count = 0;\\n        for(int i=1;i<ans.size()-1;i++){\\n            if(ans[i-1]>ans[i] && ans[i]<ans[i+1]){\\n                count ++;\\n            }\\n            else if(ans[i-1]<ans[i] && ans[i]>ans[i+1]){\\n                count ++;\\n            }\\n        }\\n        return count;\\n    }\\n}; \\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        vector<int>ans;\\n        ans.push_back(nums[0]);\\n        for(int i=1;i<nums.size();i++){\\n            if(nums[i]!=nums[i-1]){\\n                ans.push_back(nums[i]);\\n            }\\n        }\\n        int count = 0;\\n        for(int i=1;i<ans.size()-1;i++){\\n            if(ans[i-1]>ans[i] && ans[i]<ans[i+1]){\\n                count ++;\\n            }\\n            else if(ans[i-1]<ans[i] && ans[i]>ans[i+1]){\\n                count ++;\\n            }\\n        }\\n        return count;\\n    }\\n}; \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3550699,
                "title": "very-easy-to-read-python-solution-o-n-time-and-o-1-space",
                "content": "\\n# Complexity\\n- Time complexity: O(N) for iterating through nums once\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1) for constants\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countHillValley(self, nums: List[int]) -> int:\\n        sum = 0\\n        # working with left, middle, and right and passing those values to the left in the loop\\n        # just storing indices\\n        m, r = 0, 1\\n        while True:\\n            # pass values from right to left\\n            l, m = m, r\\n\\n            # find right value and skip duplicates. The prior line passing down values makes it so the duplicates are skipped again.\\n            while r < len(nums)-1 and nums[r] == nums[m]: r += 1\\n\\n            # if left and right are greater than m. hill. OR left and right less than m. valley. increment sum\\n            if nums[l] > nums[m] and nums[r] > nums[m] or nums[l] < nums[m] and nums[r] < nums[m]: sum += 1\\n\\n            # if right has hit end of the list return sum\\n            if r == len(nums)-1: return sum\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countHillValley(self, nums: List[int]) -> int:\\n        sum = 0\\n        # working with left, middle, and right and passing those values to the left in the loop\\n        # just storing indices\\n        m, r = 0, 1\\n        while True:\\n            # pass values from right to left\\n            l, m = m, r\\n\\n            # find right value and skip duplicates. The prior line passing down values makes it so the duplicates are skipped again.\\n            while r < len(nums)-1 and nums[r] == nums[m]: r += 1\\n\\n            # if left and right are greater than m. hill. OR left and right less than m. valley. increment sum\\n            if nums[l] > nums[m] and nums[r] > nums[m] or nums[l] < nums[m] and nums[r] < nums[m]: sum += 1\\n\\n            # if right has hit end of the list return sum\\n            if r == len(nums)-1: return sum\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3548284,
                "title": "simple-iteration-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        int count = 0;\\n        int left = nums[0], right;\\n        for(int i=1; i < nums.size()-1; i++){\\n            if(nums[i]==nums[i+1]) continue;\\n            right = nums[i + 1];\\n            if(left < nums[i] and right < nums[i] or left > nums[i] and right > nums[i]) count++;\\n            left = nums[i];\\n        }\\n        return count;\\n    }\\n};\\n```\\n```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        int count = 0;\\n        for(int i=1; i < nums.size()-1; i++){\\n            int left = -1, right = -1;\\n            if(nums[i]==nums[i-1]){\\n                int j = i - 1;\\n                while(j!=-1){\\n                    if(nums[i]!=nums[j]){\\n                        left = nums[j];\\n                        break;\\n                    }\\n                    j--;\\n                }\\n                if(left == -1) continue;\\n            }\\n            else left = nums[i-1];\\n\\n            if(nums[i]==nums[i+1]){\\n                int j = i + 1;\\n                while(j!=nums.size()){\\n                    if(nums[i]!=nums[j]){\\n                        right = nums[j];\\n                        break;\\n                    }\\n                    j++;\\n                }\\n                if(right == -1) continue;\\n            }\\n            else right = nums[i+1];\\n            if(((nums[i] < left and nums[i] < right) or (nums[i] > left and nums[i] > right)) and nums[i]!=nums[i-1]) count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        int count = 0;\\n        int left = nums[0], right;\\n        for(int i=1; i < nums.size()-1; i++){\\n            if(nums[i]==nums[i+1]) continue;\\n            right = nums[i + 1];\\n            if(left < nums[i] and right < nums[i] or left > nums[i] and right > nums[i]) count++;\\n            left = nums[i];\\n        }\\n        return count;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        int count = 0;\\n        for(int i=1; i < nums.size()-1; i++){\\n            int left = -1, right = -1;\\n            if(nums[i]==nums[i-1]){\\n                int j = i - 1;\\n                while(j!=-1){\\n                    if(nums[i]!=nums[j]){\\n                        left = nums[j];\\n                        break;\\n                    }\\n                    j--;\\n                }\\n                if(left == -1) continue;\\n            }\\n            else left = nums[i-1];\\n\\n            if(nums[i]==nums[i+1]){\\n                int j = i + 1;\\n                while(j!=nums.size()){\\n                    if(nums[i]!=nums[j]){\\n                        right = nums[j];\\n                        break;\\n                    }\\n                    j++;\\n                }\\n                if(right == -1) continue;\\n            }\\n            else right = nums[i+1];\\n            if(((nums[i] < left and nums[i] < right) or (nums[i] > left and nums[i] > right)) and nums[i]!=nums[i-1]) count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3542126,
                "title": "nice-and-elegant-solution-in-java-beats-100-rt-and-98-memory",
                "content": "```\\nclass Solution {\\n    public int countHillValley(int[] nums) {\\n        int count = 0;\\n        for(int i = 1, j = 0, k = 2; i < nums.length - 1; i++, j++, k++) {\\n            boolean isTheSameHillOrValley = i > 1 && nums[i] == nums[i - 1];\\n            if (!isTheSameHillOrValley) {\\n                int l = nums[j], m = nums[i], r = nums[k];\\n                if (l == m) {\\n                    int index = j;\\n                    while (index > 0 && l == m) {\\n                        l = nums[--index];\\n                    }\\n                }\\n                if (r == m) {\\n                    int index = k;\\n                    while (index + 1 < nums.length && r == m) {\\n                        r = nums[++index];\\n                    }\\n                }\\n                if ((m > l && m > r) || (m < l && m < r)) {\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;       \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int countHillValley(int[] nums) {\\n        int count = 0;\\n        for(int i = 1, j = 0, k = 2; i < nums.length - 1; i++, j++, k++) {\\n            boolean isTheSameHillOrValley = i > 1 && nums[i] == nums[i - 1];\\n            if (!isTheSameHillOrValley) {\\n                int l = nums[j], m = nums[i], r = nums[k];\\n                if (l == m) {\\n                    int index = j;\\n                    while (index > 0 && l == m) {\\n                        l = nums[--index];\\n                    }\\n                }\\n                if (r == m) {\\n                    int index = k;\\n                    while (index + 1 < nums.length && r == m) {\\n                        r = nums[++index];\\n                    }\\n                }\\n                if ((m > l && m > r) || (m < l && m < r)) {\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;       \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3525060,
                "title": "trivial-c-beats-100",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        auto result = 0;\\n        for (auto l = 0, m = 1, r = 2; r < nums.size(); ++m, ++r) {\\n            if (nums[m] == nums[r]) continue;\\n            if (nums[l] > nums[m] && nums[m] < nums[r] || nums[l] < nums[m] && nums[m] > nums[r]) ++result;\\n            l = m;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countHillValley(vector<int>& nums) {\\n        auto result = 0;\\n        for (auto l = 0, m = 1, r = 2; r < nums.size(); ++m, ++r) {\\n            if (nums[m] == nums[r]) continue;\\n            if (nums[l] > nums[m] && nums[m] < nums[r] || nums[l] < nums[m] && nums[m] > nums[r]) ++result;\\n            l = m;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3515009,
                "title": "java-beats-100-solution",
                "content": "# Intuition -- Iteration over the array.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach-- Iterating over the array and checking the conditions according to questions.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:1\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countHillValley(int[] nums) {\\n        int count =0;\\n        int left = nums[0];\\n        int end = nums[nums.length-1];\\n        int hill = 0;\\n        int valley=0; \\n        for(int i=1;i<nums.length-1;i++){\\n            if(nums[i]!=left && nums[i]>left && nums[i]>nums[i+1]){\\n                hill++;\\n                left=nums[i];\\n            }else if(nums[i]!=left && nums[i]<left && nums[i]<nums[i+1]){\\n                valley++;\\n                left=nums[i];\\n            }\\n            \\n        }\\n        return hill+valley;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int countHillValley(int[] nums) {\\n        int count =0;\\n        int left = nums[0];\\n        int end = nums[nums.length-1];\\n        int hill = 0;\\n        int valley=0; \\n        for(int i=1;i<nums.length-1;i++){\\n            if(nums[i]!=left && nums[i]>left && nums[i]>nums[i+1]){\\n                hill++;\\n                left=nums[i];\\n            }else if(nums[i]!=left && nums[i]<left && nums[i]<nums[i+1]){\\n                valley++;\\n                left=nums[i];\\n            }\\n            \\n        }\\n        return hill+valley;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3483965,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countHillValley(int[] nums) {\\n        int val=nums[0];\\n        int count=0;\\n        for(int i=1;i<nums.length-1;i++){\\n            if((nums[i]>val&&nums[i]>nums[i+1])||(nums[i]<val&&nums[i]<nums[i+1])){\\n                count++;\\n                 val=nums[i];\\n            }\\n           \\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countHillValley(int[] nums) {\\n        int val=nums[0];\\n        int count=0;\\n        for(int i=1;i<nums.length-1;i++){\\n            if((nums[i]>val&&nums[i]>nums[i+1])||(nums[i]<val&&nums[i]<nums[i+1])){\\n                count++;\\n                 val=nums[i];\\n            }\\n           \\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1846182,
                "content": [
                    {
                        "username": "rohit_adithya",
                        "content": "You can consider to `remove the adjacent equal values` first by transferring elements to another array which are `not equal to immediately preceding element`, which makes it easy to iterate from `second element` to `last second element` and checking the adjacent elements for a valley/hill."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "i didn\\'t think of that.... I solved it by using the original nums array which made things a lot more complicated :("
                    },
                    {
                        "username": "Enkri_",
                        "content": "Feeling defeated by an easy question"
                    },
                    {
                        "username": "Enkri_",
                        "content": "[@curiosity_kids](/curiosity_kids) Thanks for the encouragement! I\\'m feeling defeated coz I\\'m not new to Leetcode and even tho I can solve medium problems, I found myself stuck at this easy one lol, granted that I have to work during the day and it\\'s hard for me to barely squeeze an hour a day to work on leetcode, but still I did fail to solve an easy question, sigh"
                    },
                    {
                        "username": "curiosity_kids",
                        "content": "I know the feeling, I had the same defeated feeling so, so many times in the last 3 months, but now I am much better than when I started, and as long as you continue to work, you will become better too.\\nAlso when I started these easy were no where easy, till you get more practice, you have to look at the solutions and start noting patterns and putting the methods in your toolkit, especially if you want to save time.\\nJust keep on working, it will get better! I can attest to this my own case."
                    },
                    {
                        "username": "JaspreetKaur_leetcode",
                        "content": "class Solution {\\n    public int countHillValley(int[] nums) {\\n        int counter=0;\\n        for(int i=1;i<nums.length-1;i++){\\n            int nearest_r=nearest_right_element(nums, i+1);\\n            int nearest_l=nearest_left_element(nums, i-1);\\n            if(nums[i]!=nums[i-1]){\\n                if((nearest_r !=-1 && nearest_l!=-1 && nums[i] < nearest_r && nums[i] < nearest_l) || \\n                (nearest_r !=-1 && nearest_l!=-1 && nums[i] > nearest_r && nums[i] > nearest_l)){\\n                    counter++;\\n                }\\n            }\\n        }\\n        return counter;\\n    }\\n\\n    public int nearest_right_element(int[] nums, int start){\\n        int nearest_r=-1;\\n        for(int i=start;i<nums.length;i++){\\n            if(nums[i]!=nums[start-1]){\\n                nearest_r=nums[i];\\n                break;\\n            }\\n        }\\n        return nearest_r;\\n    }\\n\\n    public int nearest_left_element(int[] nums, int destination){\\n        int nearest_l=-1;\\n        for(int i=destination;i>=0;i--){\\n            if(nums[i]!=nums[destination+1]){\\n                nearest_l=nums[i];\\n                break;\\n            }\\n        }\\n        return nearest_l;\\n    }\\n}"
                    },
                    {
                        "username": "geekyshark",
                        "content": "A good \\'easy\\' problem i would say, dont get demotivated if you weren\\'t able to come up with the solution, watch my solution for easy understanding"
                    },
                    {
                        "username": "Anonymous_user_79",
                        "content": "Beats 100% CPP Solution:\\n int countHillValley(vector<int>& nums) {\\n        int count=0, n=nums.size();\\n        for(int i=1;i<n-1;i++)\\n        {\\n            if(nums[i]==nums[i-1]) continue;\\n            int j=i-1,k=i+1;\\n\\n            while(k<n && nums[i]==nums[k]) k++;\\n\\n            if(k>=n) continue;\\n            if(nums[i]>nums[j] && nums[i]>nums[k]) count++;\\n            else if(nums[i]<nums[j] && nums[i]<nums[k]) count++;       \\n        }\\n        return count;\\n    }"
                    }
                ]
            },
            {
                "id": 1675543,
                "content": [
                    {
                        "username": "rohit_adithya",
                        "content": "You can consider to `remove the adjacent equal values` first by transferring elements to another array which are `not equal to immediately preceding element`, which makes it easy to iterate from `second element` to `last second element` and checking the adjacent elements for a valley/hill."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "i didn\\'t think of that.... I solved it by using the original nums array which made things a lot more complicated :("
                    },
                    {
                        "username": "Enkri_",
                        "content": "Feeling defeated by an easy question"
                    },
                    {
                        "username": "Enkri_",
                        "content": "[@curiosity_kids](/curiosity_kids) Thanks for the encouragement! I\\'m feeling defeated coz I\\'m not new to Leetcode and even tho I can solve medium problems, I found myself stuck at this easy one lol, granted that I have to work during the day and it\\'s hard for me to barely squeeze an hour a day to work on leetcode, but still I did fail to solve an easy question, sigh"
                    },
                    {
                        "username": "curiosity_kids",
                        "content": "I know the feeling, I had the same defeated feeling so, so many times in the last 3 months, but now I am much better than when I started, and as long as you continue to work, you will become better too.\\nAlso when I started these easy were no where easy, till you get more practice, you have to look at the solutions and start noting patterns and putting the methods in your toolkit, especially if you want to save time.\\nJust keep on working, it will get better! I can attest to this my own case."
                    },
                    {
                        "username": "JaspreetKaur_leetcode",
                        "content": "class Solution {\\n    public int countHillValley(int[] nums) {\\n        int counter=0;\\n        for(int i=1;i<nums.length-1;i++){\\n            int nearest_r=nearest_right_element(nums, i+1);\\n            int nearest_l=nearest_left_element(nums, i-1);\\n            if(nums[i]!=nums[i-1]){\\n                if((nearest_r !=-1 && nearest_l!=-1 && nums[i] < nearest_r && nums[i] < nearest_l) || \\n                (nearest_r !=-1 && nearest_l!=-1 && nums[i] > nearest_r && nums[i] > nearest_l)){\\n                    counter++;\\n                }\\n            }\\n        }\\n        return counter;\\n    }\\n\\n    public int nearest_right_element(int[] nums, int start){\\n        int nearest_r=-1;\\n        for(int i=start;i<nums.length;i++){\\n            if(nums[i]!=nums[start-1]){\\n                nearest_r=nums[i];\\n                break;\\n            }\\n        }\\n        return nearest_r;\\n    }\\n\\n    public int nearest_left_element(int[] nums, int destination){\\n        int nearest_l=-1;\\n        for(int i=destination;i>=0;i--){\\n            if(nums[i]!=nums[destination+1]){\\n                nearest_l=nums[i];\\n                break;\\n            }\\n        }\\n        return nearest_l;\\n    }\\n}"
                    },
                    {
                        "username": "geekyshark",
                        "content": "A good \\'easy\\' problem i would say, dont get demotivated if you weren\\'t able to come up with the solution, watch my solution for easy understanding"
                    },
                    {
                        "username": "Anonymous_user_79",
                        "content": "Beats 100% CPP Solution:\\n int countHillValley(vector<int>& nums) {\\n        int count=0, n=nums.size();\\n        for(int i=1;i<n-1;i++)\\n        {\\n            if(nums[i]==nums[i-1]) continue;\\n            int j=i-1,k=i+1;\\n\\n            while(k<n && nums[i]==nums[k]) k++;\\n\\n            if(k>=n) continue;\\n            if(nums[i]>nums[j] && nums[i]>nums[k]) count++;\\n            else if(nums[i]<nums[j] && nums[i]<nums[k]) count++;       \\n        }\\n        return count;\\n    }"
                    }
                ]
            },
            {
                "id": 1974428,
                "content": [
                    {
                        "username": "rohit_adithya",
                        "content": "You can consider to `remove the adjacent equal values` first by transferring elements to another array which are `not equal to immediately preceding element`, which makes it easy to iterate from `second element` to `last second element` and checking the adjacent elements for a valley/hill."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "i didn\\'t think of that.... I solved it by using the original nums array which made things a lot more complicated :("
                    },
                    {
                        "username": "Enkri_",
                        "content": "Feeling defeated by an easy question"
                    },
                    {
                        "username": "Enkri_",
                        "content": "[@curiosity_kids](/curiosity_kids) Thanks for the encouragement! I\\'m feeling defeated coz I\\'m not new to Leetcode and even tho I can solve medium problems, I found myself stuck at this easy one lol, granted that I have to work during the day and it\\'s hard for me to barely squeeze an hour a day to work on leetcode, but still I did fail to solve an easy question, sigh"
                    },
                    {
                        "username": "curiosity_kids",
                        "content": "I know the feeling, I had the same defeated feeling so, so many times in the last 3 months, but now I am much better than when I started, and as long as you continue to work, you will become better too.\\nAlso when I started these easy were no where easy, till you get more practice, you have to look at the solutions and start noting patterns and putting the methods in your toolkit, especially if you want to save time.\\nJust keep on working, it will get better! I can attest to this my own case."
                    },
                    {
                        "username": "JaspreetKaur_leetcode",
                        "content": "class Solution {\\n    public int countHillValley(int[] nums) {\\n        int counter=0;\\n        for(int i=1;i<nums.length-1;i++){\\n            int nearest_r=nearest_right_element(nums, i+1);\\n            int nearest_l=nearest_left_element(nums, i-1);\\n            if(nums[i]!=nums[i-1]){\\n                if((nearest_r !=-1 && nearest_l!=-1 && nums[i] < nearest_r && nums[i] < nearest_l) || \\n                (nearest_r !=-1 && nearest_l!=-1 && nums[i] > nearest_r && nums[i] > nearest_l)){\\n                    counter++;\\n                }\\n            }\\n        }\\n        return counter;\\n    }\\n\\n    public int nearest_right_element(int[] nums, int start){\\n        int nearest_r=-1;\\n        for(int i=start;i<nums.length;i++){\\n            if(nums[i]!=nums[start-1]){\\n                nearest_r=nums[i];\\n                break;\\n            }\\n        }\\n        return nearest_r;\\n    }\\n\\n    public int nearest_left_element(int[] nums, int destination){\\n        int nearest_l=-1;\\n        for(int i=destination;i>=0;i--){\\n            if(nums[i]!=nums[destination+1]){\\n                nearest_l=nums[i];\\n                break;\\n            }\\n        }\\n        return nearest_l;\\n    }\\n}"
                    },
                    {
                        "username": "geekyshark",
                        "content": "A good \\'easy\\' problem i would say, dont get demotivated if you weren\\'t able to come up with the solution, watch my solution for easy understanding"
                    },
                    {
                        "username": "Anonymous_user_79",
                        "content": "Beats 100% CPP Solution:\\n int countHillValley(vector<int>& nums) {\\n        int count=0, n=nums.size();\\n        for(int i=1;i<n-1;i++)\\n        {\\n            if(nums[i]==nums[i-1]) continue;\\n            int j=i-1,k=i+1;\\n\\n            while(k<n && nums[i]==nums[k]) k++;\\n\\n            if(k>=n) continue;\\n            if(nums[i]>nums[j] && nums[i]>nums[k]) count++;\\n            else if(nums[i]<nums[j] && nums[i]<nums[k]) count++;       \\n        }\\n        return count;\\n    }"
                    }
                ]
            },
            {
                "id": 1942903,
                "content": [
                    {
                        "username": "rohit_adithya",
                        "content": "You can consider to `remove the adjacent equal values` first by transferring elements to another array which are `not equal to immediately preceding element`, which makes it easy to iterate from `second element` to `last second element` and checking the adjacent elements for a valley/hill."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "i didn\\'t think of that.... I solved it by using the original nums array which made things a lot more complicated :("
                    },
                    {
                        "username": "Enkri_",
                        "content": "Feeling defeated by an easy question"
                    },
                    {
                        "username": "Enkri_",
                        "content": "[@curiosity_kids](/curiosity_kids) Thanks for the encouragement! I\\'m feeling defeated coz I\\'m not new to Leetcode and even tho I can solve medium problems, I found myself stuck at this easy one lol, granted that I have to work during the day and it\\'s hard for me to barely squeeze an hour a day to work on leetcode, but still I did fail to solve an easy question, sigh"
                    },
                    {
                        "username": "curiosity_kids",
                        "content": "I know the feeling, I had the same defeated feeling so, so many times in the last 3 months, but now I am much better than when I started, and as long as you continue to work, you will become better too.\\nAlso when I started these easy were no where easy, till you get more practice, you have to look at the solutions and start noting patterns and putting the methods in your toolkit, especially if you want to save time.\\nJust keep on working, it will get better! I can attest to this my own case."
                    },
                    {
                        "username": "JaspreetKaur_leetcode",
                        "content": "class Solution {\\n    public int countHillValley(int[] nums) {\\n        int counter=0;\\n        for(int i=1;i<nums.length-1;i++){\\n            int nearest_r=nearest_right_element(nums, i+1);\\n            int nearest_l=nearest_left_element(nums, i-1);\\n            if(nums[i]!=nums[i-1]){\\n                if((nearest_r !=-1 && nearest_l!=-1 && nums[i] < nearest_r && nums[i] < nearest_l) || \\n                (nearest_r !=-1 && nearest_l!=-1 && nums[i] > nearest_r && nums[i] > nearest_l)){\\n                    counter++;\\n                }\\n            }\\n        }\\n        return counter;\\n    }\\n\\n    public int nearest_right_element(int[] nums, int start){\\n        int nearest_r=-1;\\n        for(int i=start;i<nums.length;i++){\\n            if(nums[i]!=nums[start-1]){\\n                nearest_r=nums[i];\\n                break;\\n            }\\n        }\\n        return nearest_r;\\n    }\\n\\n    public int nearest_left_element(int[] nums, int destination){\\n        int nearest_l=-1;\\n        for(int i=destination;i>=0;i--){\\n            if(nums[i]!=nums[destination+1]){\\n                nearest_l=nums[i];\\n                break;\\n            }\\n        }\\n        return nearest_l;\\n    }\\n}"
                    },
                    {
                        "username": "geekyshark",
                        "content": "A good \\'easy\\' problem i would say, dont get demotivated if you weren\\'t able to come up with the solution, watch my solution for easy understanding"
                    },
                    {
                        "username": "Anonymous_user_79",
                        "content": "Beats 100% CPP Solution:\\n int countHillValley(vector<int>& nums) {\\n        int count=0, n=nums.size();\\n        for(int i=1;i<n-1;i++)\\n        {\\n            if(nums[i]==nums[i-1]) continue;\\n            int j=i-1,k=i+1;\\n\\n            while(k<n && nums[i]==nums[k]) k++;\\n\\n            if(k>=n) continue;\\n            if(nums[i]>nums[j] && nums[i]>nums[k]) count++;\\n            else if(nums[i]<nums[j] && nums[i]<nums[k]) count++;       \\n        }\\n        return count;\\n    }"
                    }
                ]
            },
            {
                "id": 1698914,
                "content": [
                    {
                        "username": "rohit_adithya",
                        "content": "You can consider to `remove the adjacent equal values` first by transferring elements to another array which are `not equal to immediately preceding element`, which makes it easy to iterate from `second element` to `last second element` and checking the adjacent elements for a valley/hill."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "i didn\\'t think of that.... I solved it by using the original nums array which made things a lot more complicated :("
                    },
                    {
                        "username": "Enkri_",
                        "content": "Feeling defeated by an easy question"
                    },
                    {
                        "username": "Enkri_",
                        "content": "[@curiosity_kids](/curiosity_kids) Thanks for the encouragement! I\\'m feeling defeated coz I\\'m not new to Leetcode and even tho I can solve medium problems, I found myself stuck at this easy one lol, granted that I have to work during the day and it\\'s hard for me to barely squeeze an hour a day to work on leetcode, but still I did fail to solve an easy question, sigh"
                    },
                    {
                        "username": "curiosity_kids",
                        "content": "I know the feeling, I had the same defeated feeling so, so many times in the last 3 months, but now I am much better than when I started, and as long as you continue to work, you will become better too.\\nAlso when I started these easy were no where easy, till you get more practice, you have to look at the solutions and start noting patterns and putting the methods in your toolkit, especially if you want to save time.\\nJust keep on working, it will get better! I can attest to this my own case."
                    },
                    {
                        "username": "JaspreetKaur_leetcode",
                        "content": "class Solution {\\n    public int countHillValley(int[] nums) {\\n        int counter=0;\\n        for(int i=1;i<nums.length-1;i++){\\n            int nearest_r=nearest_right_element(nums, i+1);\\n            int nearest_l=nearest_left_element(nums, i-1);\\n            if(nums[i]!=nums[i-1]){\\n                if((nearest_r !=-1 && nearest_l!=-1 && nums[i] < nearest_r && nums[i] < nearest_l) || \\n                (nearest_r !=-1 && nearest_l!=-1 && nums[i] > nearest_r && nums[i] > nearest_l)){\\n                    counter++;\\n                }\\n            }\\n        }\\n        return counter;\\n    }\\n\\n    public int nearest_right_element(int[] nums, int start){\\n        int nearest_r=-1;\\n        for(int i=start;i<nums.length;i++){\\n            if(nums[i]!=nums[start-1]){\\n                nearest_r=nums[i];\\n                break;\\n            }\\n        }\\n        return nearest_r;\\n    }\\n\\n    public int nearest_left_element(int[] nums, int destination){\\n        int nearest_l=-1;\\n        for(int i=destination;i>=0;i--){\\n            if(nums[i]!=nums[destination+1]){\\n                nearest_l=nums[i];\\n                break;\\n            }\\n        }\\n        return nearest_l;\\n    }\\n}"
                    },
                    {
                        "username": "geekyshark",
                        "content": "A good \\'easy\\' problem i would say, dont get demotivated if you weren\\'t able to come up with the solution, watch my solution for easy understanding"
                    },
                    {
                        "username": "Anonymous_user_79",
                        "content": "Beats 100% CPP Solution:\\n int countHillValley(vector<int>& nums) {\\n        int count=0, n=nums.size();\\n        for(int i=1;i<n-1;i++)\\n        {\\n            if(nums[i]==nums[i-1]) continue;\\n            int j=i-1,k=i+1;\\n\\n            while(k<n && nums[i]==nums[k]) k++;\\n\\n            if(k>=n) continue;\\n            if(nums[i]>nums[j] && nums[i]>nums[k]) count++;\\n            else if(nums[i]<nums[j] && nums[i]<nums[k]) count++;       \\n        }\\n        return count;\\n    }"
                    }
                ]
            }
        ]
    }
]