[
    {
        "title": "Number of Equivalent Domino Pairs",
        "question_content": "Given a list of dominoes, dominoes[i] = [a, b] is equivalent to dominoes[j] = [c, d] if and only if either (a == c and b == d), or (a == d and b == c) - that is, one domino can be rotated to be equal to another domino.\nReturn the number of pairs (i, j) for which 0 <= i < j < dominoes.length, and dominoes[i] is equivalent to dominoes[j].\n&nbsp;\nExample 1:\n\nInput: dominoes = [[1,2],[2,1],[3,4],[5,6]]\nOutput: 1\n\nExample 2:\n\nInput: dominoes = [[1,2],[1,2],[1,1],[1,2],[2,2]]\nOutput: 3\n\n&nbsp;\nConstraints:\n\n\t1 <= dominoes.length <= 4 * 104\n\tdominoes[i].length == 2\n\t1 <= dominoes[i][j] <= 9",
        "solutions": [
            {
                "id": 340022,
                "title": "java-c-python-easy-and-concise",
                "content": "# **Intuition**\\nJust count the number of different dominoes.\\n<br>\\n\\n# **Explanation**\\nYou need to distinguish the different dominoes and count the same.\\n\\nI did it in this way:\\n`f(domino) = min(d[0], d[1]) * 10 + max(d[0], d[1])`\\nFor each domino `d`, calculate `min(d[0], d[1]) * 10 + max(d[0], d[1])`\\nThis will put the smaller number on the left and bigger one on the right (in decimal).\\nSo same number same domino, different number different domino.\\n\\nTake the example from the problem:\\n`dominoes = [[1,2],[2,1],[3,4],[5,6]]`\\nnow we transform it into `[12,12,34,56]`.\\n\\n@sendAsync also suggest other intersting ways to do that:\\n1. Use the product of primes\\n`primes = [2,3,5,7,11,13,17,19,23,29]`\\n`f(domino) = primes[d[0]] * primes[d[1]]`\\n(though primes[0] is not used)\\n\\n2. Use the bit manipulation.\\n`primes = [2,3,5,7,11,13,17,19,23,29]`\\n`f(domino) = 1 << d[0]| 1 << d[1];`\\n\\nPersonaly I like the second more.\\n<br>\\n\\n# **Complexity**\\nTime `O(N)`\\nSpace `O(N)`\\n<br>\\n\\n# Solution 1\\n\\nWe sum up the pair in the end after the loop,\\nusing the guass formula `sum = v * (v + 1) / 2`,\\nwhere `v` is the number of count.\\n\\n**Java:**\\n```java\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        Map<Integer, Integer> count = new HashMap<>();\\n        int res = 0;\\n        for (int[] d : dominoes) {\\n            int k = Math.min(d[0], d[1]) * 10 + Math.max(d[0], d[1]);\\n            count.put(k, count.getOrDefault(k, 0) + 1);\\n        }\\n        for (int v : count.values()) {\\n            res += v * (v - 1) / 2;\\n        }\\n        return res;\\n    }\\n```\\n\\n**Python:**\\n```python\\n    def numEquivDominoPairs(self, A):\\n        return sum(v * (v - 1) / 2 for v in collections.Counter(tuple(sorted(x)) for x in A).values())\\n```\\n<br>\\n\\n# Solution 2\\n\\nWe sum up the pairs right away during the loop.\\n`count[domino]` is the number of same dominoes that we have seen.\\n\\n**C++:**\\n```cpp\\n    int numEquivDominoPairs(vector<vector<int>>& dominoes) {\\n        unordered_map<int, int> count;\\n        int res = 0;\\n        for (auto& d : dominoes) {\\n            res += count[min(d[0], d[1]) * 10 + max(d[0], d[1])]++;\\n        }\\n        return res;\\n    }\\n```\\n",
                "solutionTags": [],
                "code": "```java\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        Map<Integer, Integer> count = new HashMap<>();\\n        int res = 0;\\n        for (int[] d : dominoes) {\\n            int k = Math.min(d[0], d[1]) * 10 + Math.max(d[0], d[1]);\\n            count.put(k, count.getOrDefault(k, 0) + 1);\\n        }\\n        for (int v : count.values()) {\\n            res += v * (v - 1) / 2;\\n        }\\n        return res;\\n    }\\n```\n```python\\n    def numEquivDominoPairs(self, A):\\n        return sum(v * (v - 1) / 2 for v in collections.Counter(tuple(sorted(x)) for x in A).values())\\n```\n```cpp\\n    int numEquivDominoPairs(vector<vector<int>>& dominoes) {\\n        unordered_map<int, int> count;\\n        int res = 0;\\n        for (auto& d : dominoes) {\\n            res += count[min(d[0], d[1]) * 10 + max(d[0], d[1])]++;\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 339969,
                "title": "java-python-3-o-n-code-with-brief-explanation-and-analysis",
                "content": "**Explanation of `cnt += pairs`** credit to **@wunanpty**\\nI want to explain why here we accumulate count like: cnt += pairs;\\nfor example our map is\\n\\nmap: <23, 1> <24, 1>\\ncurrent key = 23, so pair = 1, count += 1 -> count = 1 (which means we have 2 dominoes has same key, 2 dominoes is 1 pair)\\nmap become: <23, 2><24, 1>\\n\\ncurrent key = 23, so pair = 2, count += 2 -> count = 3 (which means we have 3 dominoes has same key, 3 dominoes is 3 pair -> (a, b)(a,c)(b,c))\\nmap become :<23, 3><24, 1>\\n\\ncurrent key = 23, so pair = 3, count += 3 -> count = 6 (4 dominoes has same key, 4 dominoes is 6 pair ->(a,b)(a,c)(a,d)(b,c)(b,d)(c,d))\\nmap become :<23, 4><24, 1>\\n\\n**End**\\n\\n**Q & A:**\\n**Q:** \\n1. Why do we use this for min * 10 + max, encoding?  how to decide on encoding?  \\n2. what if the maximum is infinite?\\n\\n**A:**\\n1. We do NOT have to use `10`, as long as the number `m` > `max(dominoes)`, there will be no collision; In addition, the corresponding decoding is `encoded / m`, `encoded % m`;\\n2. .If the size of the number is limited, we can convert it to a String. \\n\\n**End of Q & A**\\n\\n----\\n1. Encode each domino as min * 10 + max, where min and max are the smaller and bigger values of each domino, respectively;\\n2. Use a HashMap to store the number of dominoes with same encoding, and for each encoding (key), count the newly found pairs;\\n\\n**Java:**\\n```\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        int cnt = 0;\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int[] a : dominoes) {\\n            int max = Math.max(a[0], a[1]), min = Math.min(a[0], a[1]);\\n            int key = min * 10 + max;\\n            int pairs = map.getOrDefault(key, 0); // the number of dominoes already in the map is the number of the newly found pairs.\\n            cnt += pairs;\\n            map.put(key, 1 + pairs);\\n                               \\n        }\\n        return cnt;\\n    }\\n```\\n\\n----\\n**Python 3:**\\n\\n```\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        d = {}\\n        cnt = 0\\n        for a, b in dominoes:\\n            key = min(a, b) * 10 + max(a, b) \\n            if key in d:\\n                cnt += d[key] # the number of dominoes already in the map is the number of the newly found pairs.\\n                d[key] += 1\\n            else:\\n                d[key] = 1   \\n        return cnt\\n```\\nor \\n```python\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        d, ans = defaultdict(int), 0\\n        for a, b in dominoes:\\n            key = min(a, b), max(a, b)\\n            ans += d[key]\\n            d[key] += 1\\n        return ans\\n```\\n\\n**Analysis:**\\n\\nSince `1 <= dominoes[i][j] <= 9`, there are at most `9 * (9 + 1) / 2 = 45` encodings.\\nTime: O(n), space: O(45), where n = dominoes.length.",
                "solutionTags": [],
                "code": "```\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        int cnt = 0;\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int[] a : dominoes) {\\n            int max = Math.max(a[0], a[1]), min = Math.min(a[0], a[1]);\\n            int key = min * 10 + max;\\n            int pairs = map.getOrDefault(key, 0); // the number of dominoes already in the map is the number of the newly found pairs.\\n            cnt += pairs;\\n            map.put(key, 1 + pairs);\\n                               \\n        }\\n        return cnt;\\n    }\\n```\n```\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        d = {}\\n        cnt = 0\\n        for a, b in dominoes:\\n            key = min(a, b) * 10 + max(a, b) \\n            if key in d:\\n                cnt += d[key] # the number of dominoes already in the map is the number of the newly found pairs.\\n                d[key] += 1\\n            else:\\n                d[key] = 1   \\n        return cnt\\n```\n```python\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        d, ans = defaultdict(int), 0\\n        for a, b in dominoes:\\n            key = min(a, b), max(a, b)\\n            ans += d[key]\\n            d[key] += 1\\n        return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 549709,
                "title": "easy-without-hashmap-java-solution-runtime-0ms",
                "content": "__Idea__ \\n```\\nThe main idea is to store each domino pair as a number for example..\\n[1,2] it will be stored as 12 and for domino [2,1] it is same as the above domino \\naccording to the question so this will also be stored as number 12. \\n\\nMaximum range for each number is 9 so the array which will store the frequency of each number will be of size100.\\nAt the end, In the freq array we will have freq of each type of domino and now we need to do nCr of those values.\\nSee the example to support this above line..,\\n[[1,2], [2,1], [1,2], [5,6], [6,5], [1,2]] \\nHere [1,2] this type of domino are 4 and [5,6] this type of domino are 2. \\nThe ans will be 4C2 + 2C2. so 4! \\xF7 (2! * 2!) + 2! \\xF7 (2! * 1!). \\n```\\n\\n\\nTo shorten the Formula see the below picture...,!\\n![image](https://assets.leetcode.com/users/frankenstein32/image_1585029327.png)\\n\\n```\\nclass Solution {\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        int[] freq = new int[100];\\n        for(int[] d : dominoes){\\n            int x = Math.min(d[0],d[1]);\\n            int y = Math.max(d[1],d[0]);\\n            freq[x*10 + y]++;\\n        }\\n        int res = 0;\\n        for(int i = 0;i < 100;i++){\\n            if(freq[i] > 0){\\n                res += ((freq[i] * (freq[i] - 1)) / 2);\\n            }       \\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nThe main idea is to store each domino pair as a number for example..\\n[1,2] it will be stored as 12 and for domino [2,1] it is same as the above domino \\naccording to the question so this will also be stored as number 12. \\n\\nMaximum range for each number is 9 so the array which will store the frequency of each number will be of size100.\\nAt the end, In the freq array we will have freq of each type of domino and now we need to do nCr of those values.\\nSee the example to support this above line..,\\n[[1,2], [2,1], [1,2], [5,6], [6,5], [1,2]] \\nHere [1,2] this type of domino are 4 and [5,6] this type of domino are 2. \\nThe ans will be 4C2 + 2C2. so 4! \\xF7 (2! * 2!) + 2! \\xF7 (2! * 1!). \\n```\n```\\nclass Solution {\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        int[] freq = new int[100];\\n        for(int[] d : dominoes){\\n            int x = Math.min(d[0],d[1]);\\n            int y = Math.max(d[1],d[0]);\\n            freq[x*10 + y]++;\\n        }\\n        int res = 0;\\n        for(int i = 0;i < 100;i++){\\n            if(freq[i] > 0){\\n                res += ((freq[i] * (freq[i] - 1)) / 2);\\n            }       \\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 348400,
                "title": "python3-dictionary-count",
                "content": "* Use a dictionary to count how many times an intrinsic domino appeared. Here we define intrinsic domino as a sorted domino. By sort the list, we can easily identify the intrinsic domino.  Use the intrinsic domino as key, the intrinsic domino frequency as value, store the information we need in a dictionary.\\n```\\nExample:\\nindex     0     1      2     3\\ninput = [[1,2],[2,1],[1,2],[1,2]]\\nd = { [1,2] : 4}\\nThe number of equivalent domino pairs of the input will be 4 * 3 / 2 = 6\\n          index               index\\npair  1 :   0    [1,2]   and     1        [2,1]\\npair  2 :   0    [1,2]   and     2        [1,2]\\npair  3 :   0    [1,2]   and     3        [1,2]\\npair  4 :   1    [2,1]   and     0        [1,2]\\npair  5 :   1    [2,1]   and     2        [1,2]\\npair  6 :   1    [2,1]   and     3        [1,2]\\npair  7 :   2    [1,2]   and     0        [1,2]\\npair  8 :   2    [1,2]   and     1        [1,2]\\npair  9 :   2    [1,2]   and     3        [1,2]\\npair 10 :   3    [1,2]   and     0        [1,2]\\npair 11 :   3    [1,2]   and     1        [1,2]\\npair 12 :   3    [1,2]   and     2        [1,2]\\n\\napparently, \\npair 1 (index 0, 1) and pair 4  (index 1,0)  are considered the same pair. \\npair 2 (index 0, 2) and pair 7  (index 2,0)  are considered the same pair. \\npair 3 (index 0, 3) and pair 10 (index 3,0)  are considered the same pair. \\npair 5 (index 1, 2) and pair 8 (index 2,1)  are considered the same pair. \\npair 6 (index 1, 3) and pair 11 (index 3,1)  are considered the same pair. \\npair 9 (index 2, 3) and pair 12 (index 3,2)  are considered the same pair. \\n\\n\\n                    \\n```\\n* Calculate how many pairs of Equivalent domino:\\nFor each domino, the number of pairs = n*(n-1)//2, \\nwhere n is the domino frequency.\\nExplanation:\\n\\tFor the first domino in the pair, we have n options, \\n\\tFor the second domino in the pair, we have (n - 1) options. \\n\\tSince the order of domino in the pair doesn\\'t matter, which means\\n```\\nPair 1 : [1,2],[2,1]\\nPair 2 : [2,1],[1,2]\\nare considered the same pair.\\n```\\nWe need to divide by 2 to eliminate the duplicate.\\n```\\nimport collections\\nclass Solution:\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        # step 1: count the dominoes\\n        d = {}\\n        for domi in dominoes:\\n            p = tuple(sorted(domi))\\n            if p in d:\\n                d[p] += 1\\n            else:\\n                d[p] = 1\\n        # step 2: caculate the pairs. for each pair, number of pairs = n*(n-1)//2\\n        c = 0\\n        for n in d.values():\\n            s = n*(n-1)//2\\n            c += s\\n        return c\\n```\\n**Complexity Analysis**\\n* Time complexity: O(n)\\nDictionary takes O(1) to store. \\nTo generate the dictionary takes n*O(1) and calculate pairs takes O(n), the total time complexity is O(n), where n is the length of the input list.\\n* Space complexity: O(n)\\nAt worst case (every item in the input list appeared once), the algorithm needs a dictionary which it\\'s size equals the length of the list, where n is the length of the input list.\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nExample:\\nindex     0     1      2     3\\ninput = [[1,2],[2,1],[1,2],[1,2]]\\nd = { [1,2] : 4}\\nThe number of equivalent domino pairs of the input will be 4 * 3 / 2 = 6\\n          index               index\\npair  1 :   0    [1,2]   and     1        [2,1]\\npair  2 :   0    [1,2]   and     2        [1,2]\\npair  3 :   0    [1,2]   and     3        [1,2]\\npair  4 :   1    [2,1]   and     0        [1,2]\\npair  5 :   1    [2,1]   and     2        [1,2]\\npair  6 :   1    [2,1]   and     3        [1,2]\\npair  7 :   2    [1,2]   and     0        [1,2]\\npair  8 :   2    [1,2]   and     1        [1,2]\\npair  9 :   2    [1,2]   and     3        [1,2]\\npair 10 :   3    [1,2]   and     0        [1,2]\\npair 11 :   3    [1,2]   and     1        [1,2]\\npair 12 :   3    [1,2]   and     2        [1,2]\\n\\napparently, \\npair 1 (index 0, 1) and pair 4  (index 1,0)  are considered the same pair. \\npair 2 (index 0, 2) and pair 7  (index 2,0)  are considered the same pair. \\npair 3 (index 0, 3) and pair 10 (index 3,0)  are considered the same pair. \\npair 5 (index 1, 2) and pair 8 (index 2,1)  are considered the same pair. \\npair 6 (index 1, 3) and pair 11 (index 3,1)  are considered the same pair. \\npair 9 (index 2, 3) and pair 12 (index 3,2)  are considered the same pair. \\n\\n\\n                    \\n```\n```\\nPair 1 : [1,2],[2,1]\\nPair 2 : [2,1],[1,2]\\nare considered the same pair.\\n```\n```\\nimport collections\\nclass Solution:\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        # step 1: count the dominoes\\n        d = {}\\n        for domi in dominoes:\\n            p = tuple(sorted(domi))\\n            if p in d:\\n                d[p] += 1\\n            else:\\n                d[p] = 1\\n        # step 2: caculate the pairs. for each pair, number of pairs = n*(n-1)//2\\n        c = 0\\n        for n in d.values():\\n            s = n*(n-1)//2\\n            c += s\\n        return c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 340458,
                "title": "java-one-pass-o-1-space-beats-100",
                "content": "We can save number of times we\\'ve seen each domino pair in the array of 9x9 < 100 elements. We are looping over the dominoes array and check every pair. Increment element [i,j] of our array. To take into account cases 1,2 and 2,1 we flip the pair so the upper number is always smaller. \\nThe catch is - for every next same pair we check array, if it\\'s > 1 we increment the result, but each time increment will be the number saved in array. So for case like this:\\n1,2 1,2 3,4 1,2 correct answer is 3 - index 0 matches 1 and 3, index 1 matches 3, there are no matches for index 2 and 3.\\n\\narray of results at [1,2] and num will be:\\n1. res[1,2] = 0 - initial\\n2. res[1,2] = 1, num=0 when index = 0\\n3. res[1,2] = 2, num = 1 when index = 1\\n4. res[3,4] = 1, num = 1 when index = 2\\n5. res[1,2] = 3, num = 3 when index = 3\\n\\nWe can use flat array, just compute the index by doing up*10 + down. This is 99 index max, means 100 elements.\\n\\nThis is O(n) time complexity - one scan of the inout array, O(1) space - we\\'ll need count array of the same size independently of number of dominoes.\\n\\nUPD: Make code compact by refactoring some part, thanks to @ysboss\\n\\n```\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        //we need to acceess indexes from 0 to 99. max number of dominoes is 9\\n        int[] counts = new int[100];\\n        int res = 0;\\n        //check every pair of dominoes\\n        for (int[] d : dominoes) {\\n            //get upper and down number, make upper always smaller\\n            int up = d[0] < d[1] ? d[0] : d[1]; \\n\\t\\t\\tint down = d[0] < d[1] ? d[1] : d[0];\\n            //increment number of times we\\'ve seen exactly this pair\\n            //if more than once increment result, every next same pair will contribute on 1 more than a previous one\\n            res+=counts[up * 10 + down]++;\\n        }\\n\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        //we need to acceess indexes from 0 to 99. max number of dominoes is 9\\n        int[] counts = new int[100];\\n        int res = 0;\\n        //check every pair of dominoes\\n        for (int[] d : dominoes) {\\n            //get upper and down number, make upper always smaller\\n            int up = d[0] < d[1] ? d[0] : d[1]; \\n\\t\\t\\tint down = d[0] < d[1] ? d[1] : d[0];\\n            //increment number of times we\\'ve seen exactly this pair\\n            //if more than once increment result, every next same pair will contribute on 1 more than a previous one\\n            res+=counts[up * 10 + down]++;\\n        }\\n\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 767338,
                "title": "c-2-approaches-easy-to-understand",
                "content": "# TIME LIMIT EXCEEDED\\n```\\nclass Solution {\\npublic:\\n    int numEquivDominoPairs(vector<vector<int>>& d) {\\n        int result = 0;\\n        for(int i = 0; i<d.size();i++){\\n            for(int j = i+1;j<d.size();j++){\\n                if((d[i][0] == d[j][0] && d[i][1] == d[j][1]) || (d[i][0] == d[j][1] && d[i][1] == d[j][0])){\\n                    result++;\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```\\n\\n***Runtime: 104 ms, faster than 80.73% of C++ online submissions for Number of Equivalent Domino Pairs.\\nMemory Usage: 22 MB, less than 96.88% of C++ online submissions for Number of Equivalent Domino Pairs.***\\n```\\nclass Solution {\\npublic:\\n    int numEquivDominoPairs(vector<vector<int>>& dominoes) {\\n        map<pair<int,int>,int> seen;\\n        int result = 0;\\n        for(auto& v:dominoes){\\n            if(v[0] > v[1]){\\n                swap(v[0], v[1]);\\n            }\\n            seen[make_pair(v[0],v[1])]++;\\n        }\\n        for(auto& [key, value] : seen){\\n            result += value*(value-1)/2;\\n        }\\n        return result;\\n    }\\n};\\n```\\n\\n***Runtime: 100 ms, faster than 88.74% of C++ online submissions for Number of Equivalent Domino Pairs.\\nMemory Usage: 22.1 MB, less than 90.63% of C++ online submissions for Number of Equivalent Domino Pairs.***\\n```\\nclass Solution {\\npublic:\\n    int numEquivDominoPairs(vector<vector<int>>& dominoes) {\\n        map<pair<int,int>,int> seen;\\n        int result = 0;\\n        for(auto& v:dominoes){\\n            if(v[0] > v[1]){\\n                swap(v[0], v[1]);\\n            }\\n            result += seen[make_pair(v[0],v[1])]++;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numEquivDominoPairs(vector<vector<int>>& d) {\\n        int result = 0;\\n        for(int i = 0; i<d.size();i++){\\n            for(int j = i+1;j<d.size();j++){\\n                if((d[i][0] == d[j][0] && d[i][1] == d[j][1]) || (d[i][0] == d[j][1] && d[i][1] == d[j][0])){\\n                    result++;\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int numEquivDominoPairs(vector<vector<int>>& dominoes) {\\n        map<pair<int,int>,int> seen;\\n        int result = 0;\\n        for(auto& v:dominoes){\\n            if(v[0] > v[1]){\\n                swap(v[0], v[1]);\\n            }\\n            seen[make_pair(v[0],v[1])]++;\\n        }\\n        for(auto& [key, value] : seen){\\n            result += value*(value-1)/2;\\n        }\\n        return result;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int numEquivDominoPairs(vector<vector<int>>& dominoes) {\\n        map<pair<int,int>,int> seen;\\n        int result = 0;\\n        for(auto& v:dominoes){\\n            if(v[0] > v[1]){\\n                swap(v[0], v[1]);\\n            }\\n            result += seen[make_pair(v[0],v[1])]++;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 506930,
                "title": "c-o-n-domino-id-and-map",
                "content": "##### Algorithm:\\nFor each domino I create an identifying number:\\n* if `d` is current domino, than identifier is: (d[1] << 4) + d[0]\\n* And reverse identifier, if we flip domino: (d[0] << 4) + d[1]\\n\\nCause **one side** of domino has **max value** of `9` (`1001` in binary), it can only take 4 bits. Total lenght of an identifier is `8` bits.\\n\\nFor `d=[9,5]` identifiers gonna look like:\\n![image](https://assets.leetcode.com/users/andnik/image_1582091923.png)\\n\\n##### Code:\\n```\\nclass Solution {\\npublic:\\n    int numEquivDominoPairs(vector<vector<int>>& dominoes) {\\n        unordered_map<int, int> dict;\\n        int count = 0;\\n        for (vector<int> d: dominoes) {\\n            int a = (d[0] << 4) | d[1], b = (d[1] << 4) | d[0];\\n            count += (a == b ? 0 : dict[b]) + dict[a]++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numEquivDominoPairs(vector<vector<int>>& dominoes) {\\n        unordered_map<int, int> dict;\\n        int count = 0;\\n        for (vector<int> d: dominoes) {\\n            int a = (d[0] << 4) | d[1], b = (d[1] << 4) | d[0];\\n            count += (a == b ? 0 : dict[b]) + dict[a]++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 359439,
                "title": "java-simple-solution-8ms-beats-80-runtime-and-100-memory",
                "content": "Represents each domino as 2-digit number, when the first number is always the smallest.\\nFor example [2,3] or [3,2] domino will be represented as 23 number:\\n\\n```\\npublic int numEquivDominoPairs(int[][] dominoes) {\\n        \\n        Map<Integer, Integer> counts = new HashMap<Integer, Integer>();\\n        int res = 0;\\n        for (int[] domino : dominoes) {\\n            \\n            int num = Math.min(domino[0], domino[1]) * 10 + Math.max(domino[0], domino[1]);\\n            int currCount = counts.getOrDefault(num, 0);\\n            res += currCount;\\n            counts.put(num, currCount + 1);\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int numEquivDominoPairs(int[][] dominoes) {\\n        \\n        Map<Integer, Integer> counts = new HashMap<Integer, Integer>();\\n        int res = 0;\\n        for (int[] domino : dominoes) {\\n            \\n            int num = Math.min(domino[0], domino[1]) * 10 + Math.max(domino[0], domino[1]);\\n            int currCount = counts.getOrDefault(num, 0);\\n            res += currCount;\\n            counts.put(num, currCount + 1);\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 342042,
                "title": "javascript-o-n-simple-solution-using-map",
                "content": "Permutation:\\na -> 0\\naa -> 1 (0 + 1) pairs\\naaa -> 3 (1 + 2) paris\\naaaa -> 6 (3 + 3) pairs\\naaaaa -> 10 (6 + 4) pairs\\n.....\\n\\n```\\n/**\\n * @param {number[][]} dominoes\\n * @return {number}\\n */\\nvar numEquivDominoPairs = function(dominoes) {\\n    let map = new Map();\\n    let count = 0;\\n    for (let [a , b] of dominoes) {\\n        let key = a < b ? `${a}${b}` : `${b}${a}`;\\n\\n        if (map.has(key)) {\\n            let currentIndex = map.get(key) + 1;\\n            map.set(key, currentIndex);\\n            count += currentIndex;\\n        } else {\\n            map.set(key, 0);\\n        }\\n    }\\n\\n    return count;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} dominoes\\n * @return {number}\\n */\\nvar numEquivDominoPairs = function(dominoes) {\\n    let map = new Map();\\n    let count = 0;\\n    for (let [a , b] of dominoes) {\\n        let key = a < b ? `${a}${b}` : `${b}${a}`;\\n\\n        if (map.has(key)) {\\n            let currentIndex = map.get(key) + 1;\\n            map.set(key, currentIndex);\\n            count += currentIndex;\\n        } else {\\n            map.set(key, 0);\\n        }\\n    }\\n\\n    return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 817564,
                "title": "java-clean-and-beats-99-o-n-time-o-1-space-with-explanation",
                "content": "```\\nclass Solution {\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        int[] dominoMap = new int[100];\\n        int matches = 0;\\n        for (int[] domino : dominoes) {\\n            int n1 = domino[0], n2 = domino[1];\\n            int hash = Math.max(n1,n2) * 10 + Math.min(n1,n2);\\n            matches += dominoMap[hash]++;\\n        }\\n        return matches;\\n    }\\n}\\n```\\n\\nThe basic strategy is to keep track of matching dominos in the map using a key that will be the same if the numbers are the same, no matter the order. Since the return needs to be the number of pairs, you can derive that using a summation. Therefore, when a match is found the total matches for that domino is added each time.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        int[] dominoMap = new int[100];\\n        int matches = 0;\\n        for (int[] domino : dominoes) {\\n            int n1 = domino[0], n2 = domino[1];\\n            int hash = Math.max(n1,n2) * 10 + Math.min(n1,n2);\\n            matches += dominoMap[hash]++;\\n        }\\n        return matches;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 553484,
                "title": "python-99-48-one-liner-explained",
                "content": "```\\nclass Solution:\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        return sum( [ (v-1)*v//2 for v in collections.Counter([ 10*min(i)+max(i) for i in dominoes ]).values() ]) \\n```\\n\\nThis is how it works step by step. \\n\\nFirst we need to find a a way to assign a unique id to a domino regardless if it\\'s [x:y] or [y:x]. Since domino value is `1<x<9`, we can simply convert it into a 2 digit number like this `[ 10*min(i)+max(i) for i in dominoes ]` . Another approach would to use tuples like `[ tuple(sorted(i)) for i in dominoes ]`. \\n\\nOnce we converted the original list of dominoes into a list of dominoes disregarding orientation, the next step is to calculate counts using `collection.Counter()`. It will produce a dictionary with values like `\\'domino1\\':count1, \\'domino2\\':count2, ...`\\n\\nSince we just need the number of pairs, we can ignore the exact keys and just look at the values (the counts). Calculating pairs is a bit tricky, it\\'s basically n*(n-1)//2 for each domino.\\n\\nFinally we calculate the total count by using `sum()`",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        return sum( [ (v-1)*v//2 for v in collections.Counter([ 10*min(i)+max(i) for i in dominoes ]).values() ]) \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1871033,
                "title": "python-dictionary-solution-with-explanation-252ms",
                "content": "```\\nclass Solution:\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        \\n        #Keep track of the dominoes with a dictionary\\n\\t\\t#counter[ DOMINO ] = COUNT\\n        counter = defaultdict( int );\\n        \\n        #Total will be the total number of pairs\\n        total = 0;\\n        \\n        #Go through all of the dominoes\\n        for i in range( len ( dominoes ) ):\\n            #Check the pair at the index\\n            pair = dominoes[ i ];\\n            \\n            #Pull the two values\\n            first = pair[ 0 ];\\n            second = pair[ 1 ];\\n            \\n            #Sort them by value\\n\\t\\t\\t#This way, the reversed matches will go into the same count\\n            smaller = min ( first, second );\\n            bigger = max( first, second );\\n            \\n            #Reassemble into tuple\\n\\t\\t\\t#This will act as our key for each domino\\n            pair_sorted = ( smaller, bigger );\\n            \\n            #If the current domino is already in our counter\\n            #Add to the total the previous matches\\n            \\n            #That is\\n            #If we have already added matching dominoes\\n            #Our current one will match with all the previous\\n            if pair_sorted in counter:\\n                total += counter[ pair_sorted ];\\n            \\n            #Lastly, we increment the count of the current\\n            counter [ pair_sorted ] += 1;\\n            \\n            \\n        return total;\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        \\n        #Keep track of the dominoes with a dictionary\\n\\t\\t#counter[ DOMINO ] = COUNT\\n        counter = defaultdict( int );\\n        \\n        #Total will be the total number of pairs\\n        total = 0;\\n        \\n        #Go through all of the dominoes\\n        for i in range( len ( dominoes ) ):\\n            #Check the pair at the index\\n            pair = dominoes[ i ];\\n            \\n            #Pull the two values\\n            first = pair[ 0 ];\\n            second = pair[ 1 ];\\n            \\n            #Sort them by value\\n\\t\\t\\t#This way, the reversed matches will go into the same count\\n            smaller = min ( first, second );\\n            bigger = max( first, second );\\n            \\n            #Reassemble into tuple\\n\\t\\t\\t#This will act as our key for each domino\\n            pair_sorted = ( smaller, bigger );\\n            \\n            #If the current domino is already in our counter\\n            #Add to the total the previous matches\\n            \\n            #That is\\n            #If we have already added matching dominoes\\n            #Our current one will match with all the previous\\n            if pair_sorted in counter:\\n                total += counter[ pair_sorted ];\\n            \\n            #Lastly, we increment the count of the current\\n            counter [ pair_sorted ] += 1;\\n            \\n            \\n        return total;\\n```",
                "codeTag": "Java"
            },
            {
                "id": 405437,
                "title": "python3-concise-and-efficient",
                "content": "```\\nclass Solution:\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        m = collections.defaultdict(int)\\n        ans = 0\\n        for a, b in dominoes:\\n            if a > b: a, b = b, a\\n            v = 10*a + b\\n            if v in m:\\n                ans += m[v]\\n            m[v] += 1\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        m = collections.defaultdict(int)\\n        ans = 0\\n        for a, b in dominoes:\\n            if a > b: a, b = b, a\\n            v = 10*a + b\\n            if v in m:\\n                ans += m[v]\\n            m[v] += 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 339957,
                "title": "6-lines-c-with-explanation-0-n-runtime",
                "content": "Key ideas:\\n1. Iterate through dominoes and build a Dictionary (HashMap in Java).\\n2. Form a key from domino values in the same (i.e accending) order so dominoes \\'1:2\\' and \\'2:1\\' will have the same key.\\n3. Count occurences of the key and count number of pairs at the same time.\\n\\nMy initial approach to counting pairs was to count occurences first and then have another iteration through dictionary to calculate pairs.\\nNumber of pairs for N number of occurences is (N-1) + (N-2) + ... + 1 or N*(N-1)/2. \\nThen I realised that pairs can be counted at the same time as occurences, i.e. 1 + 2 + ... + (N-2) + (N-1). \\nSo I started occurences from 0 and count pairs at the same time hence the line: count += ++dictionary[key].\\n\\n```\\npublic int NumEquivDominoPairs(int[][] dominoes)\\n{\\n    var count = 0;\\n    var dictionary = new Dictionary<string, int>();\\n    foreach (var d in dominoes) \\n    {\\n        var key = d[0] < d[1] ? string.Format(\"{0}{1}\", d[0], d[1]) : string.Format(\"{0}{1}\", d[1], d[0]); \\n        if (dictionary.ContainsKey(key)) count += ++dictionary[key]; else dictionary.Add(key, 0);\\n    }\\n    return count;\\n}",
                "solutionTags": [],
                "code": "Key ideas:\\n1. Iterate through dominoes and build a Dictionary (HashMap in Java).\\n2. Form a key from domino values in the same (i.e accending) order so dominoes \\'1:2\\' and \\'2:1\\' will have the same key.\\n3. Count occurences of the key and count number of pairs at the same time.\\n\\nMy initial approach to counting pairs was to count occurences first and then have another iteration through dictionary to calculate pairs.\\nNumber of pairs for N number of occurences is (N-1) + (N-2) + ... + 1 or N*(N-1)/2. \\nThen I realised that pairs can be counted at the same time as occurences, i.e. 1 + 2 + ... + (N-2) + (N-1). \\nSo I started occurences from 0 and count pairs at the same time hence the line: count += ++dictionary[key].\\n\\n```\\npublic int NumEquivDominoPairs(int[][] dominoes)\\n{\\n    var count = 0;\\n    var dictionary = new Dictionary<string, int>();\\n    foreach (var d in dominoes) \\n    {\\n        var key = d[0] < d[1] ? string.Format(\"{0}{1}\", d[0], d[1]) : string.Format(\"{0}{1}\", d[1], d[0]); \\n        if (dictionary.ContainsKey(key)) count += ++dictionary[key]; else dictionary.Add(key, 0);\\n    }\\n    return count;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 607490,
                "title": "c-solution-with-map",
                "content": "```\\nWe store the pair into hashmap and increment it wheever we encounter this.\\nHow do we store the pair?\\nLet the pair be {a,b} where a store the minimum of the 2 and b stores the maximum of the two.\\n\\nOnce we iterate through the map we our count value will not store n or n-1 nut will store this\\nif n=it->second-1\\ncount+=(n)*(n+1)/2 why?\\nbecause dominoes matching occurs for every domino after it so for example\\n\\n[1,2][1,2][1,2][1,2][2,1][2,1]\\n\\nhere map[{1,2}] = 6\\nbut for the first 1,2 5 are matched with it\\nfor second 1,2 4 are matched with it\\nThus n,n-1,n-2,,,,1 = n*(n+1)/2 (Sum of natural numbers upto n)\\n\\n    int numEquivDominoPairs(vector<vector<int>>& dominoes) {\\n        map<pair<int,int>,int> map;\\n        for(int i=0;i<dominoes.size();i++)\\n        {\\n            int a=min(dominoes[i][0],dominoes[i][1]),b=max(dominoes[i][0],dominoes[i][1]);\\n            map[{a,b}]++;\\n        }\\n        int count=0;\\n        for(auto it=map.begin();it!=map.end();it++)\\n        {\\n            if(it->second>1)\\n            {\\n                int n=it->second-1;\\n                count+=(n)*(n+1)/2;\\n            }\\n        }\\n        return count;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nWe store the pair into hashmap and increment it wheever we encounter this.\\nHow do we store the pair?\\nLet the pair be {a,b} where a store the minimum of the 2 and b stores the maximum of the two.\\n\\nOnce we iterate through the map we our count value will not store n or n-1 nut will store this\\nif n=it->second-1\\ncount+=(n)*(n+1)/2 why?\\nbecause dominoes matching occurs for every domino after it so for example\\n\\n[1,2][1,2][1,2][1,2][2,1][2,1]\\n\\nhere map[{1,2}] = 6\\nbut for the first 1,2 5 are matched with it\\nfor second 1,2 4 are matched with it\\nThus n,n-1,n-2,,,,1 = n*(n+1)/2 (Sum of natural numbers upto n)\\n\\n    int numEquivDominoPairs(vector<vector<int>>& dominoes) {\\n        map<pair<int,int>,int> map;\\n        for(int i=0;i<dominoes.size();i++)\\n        {\\n            int a=min(dominoes[i][0],dominoes[i][1]),b=max(dominoes[i][0],dominoes[i][1]);\\n            map[{a,b}]++;\\n        }\\n        int count=0;\\n        for(auto it=map.begin();it!=map.end();it++)\\n        {\\n            if(it->second>1)\\n            {\\n                int n=it->second-1;\\n                count+=(n)*(n+1)/2;\\n            }\\n        }\\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 519357,
                "title": "intuitive-python-solution-with-comments",
                "content": "`dic` keeps track of how many number of _sorted_ pair that we have seen before. For a given domino pair, if we have seen `x` times before that means we can make `x` number of new pairs. We need to sort the domino pair so that we get a consistent key since we don\\'t want to differentiate let say `[1, 2]` & `[2, 1]`.\\n\\n```Python\\nclass Solution:\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        dic = collections.defaultdict(int)\\n        res = 0\\n        for dom in dominoes:\\n            # sort so that we get a consistent key\\n            sdom = tuple(sorted(dom))\\n            \\n            # if we haven\\'t seen it before that means there\\n            # is no pair. if we have seen x number before\\n            # that means we can make x pairs\\n            if sdom in dic:\\n                res += dic[sdom]\\n                \\n            # record that we have seen it\\n            dic[sdom] += 1\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```Python\\nclass Solution:\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        dic = collections.defaultdict(int)\\n        res = 0\\n        for dom in dominoes:\\n            # sort so that we get a consistent key\\n            sdom = tuple(sorted(dom))\\n            \\n            # if we haven\\'t seen it before that means there\\n            # is no pair. if we have seen x number before\\n            # that means we can make x pairs\\n            if sdom in dic:\\n                res += dic[sdom]\\n                \\n            # record that we have seen it\\n            dic[sdom] += 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1087193,
                "title": "java-solution-with-explanation",
                "content": "**Simple String key**\\n```\\nclass Solution {\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        Map<String, Integer> map = new HashMap<>();\\n        int result = 0;\\n        for(int[] item : dominoes) {\\n            //key should be unique\\n            String val = item[0] < item[1] ? item[0] + \":\" + item[1] : item[1] + \":\" + item[0];\\n            int count = map.getOrDefault(val,0);\\n            //increment the count\\n\\t\\t\\tmap.put(val, count + 1);\\n            //store in the result\\n\\t\\t\\tresult += count;\\n        }\\n        return result;\\n    }\\n}\\n```\\n**for better runtime we make the key as integer**\\n```\\nclass Solution {\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        int result = 0;\\n        for(int[] item : dominoes) {\\n            //key should be unique\\n            int val = item[0] < item[1] ? item[0] *10 + item[1] : item[1] *10 + item[0];\\n            int count = map.getOrDefault(val,0);\\n            //increment the count\\n\\t\\t\\tmap.put(val, count + 1);\\n            //store in the result\\n\\t\\t\\tresult += count;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        Map<String, Integer> map = new HashMap<>();\\n        int result = 0;\\n        for(int[] item : dominoes) {\\n            //key should be unique\\n            String val = item[0] < item[1] ? item[0] + \":\" + item[1] : item[1] + \":\" + item[0];\\n            int count = map.getOrDefault(val,0);\\n            //increment the count\\n\\t\\t\\tmap.put(val, count + 1);\\n            //store in the result\\n\\t\\t\\tresult += count;\\n        }\\n        return result;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        int result = 0;\\n        for(int[] item : dominoes) {\\n            //key should be unique\\n            int val = item[0] < item[1] ? item[0] *10 + item[1] : item[1] *10 + item[0];\\n            int count = map.getOrDefault(val,0);\\n            //increment the count\\n\\t\\t\\tmap.put(val, count + 1);\\n            //store in the result\\n\\t\\t\\tresult += count;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 920471,
                "title": "simple-concise-c-solution-using-map",
                "content": "```\\nclass Solution {\\npublic:\\n    int numEquivDominoPairs(vector<vector<int>>& dominoes) {\\n        int ans=0;\\n        map<vector<int>,int> m;\\n        for(auto i:dominoes)\\n        {\\n            sort(i.begin(),i.end());\\n            if(m.find(i)!=m.end()) ans+=m[i]++;\\n            else m[i]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numEquivDominoPairs(vector<vector<int>>& dominoes) {\\n        int ans=0;\\n        map<vector<int>,int> m;\\n        for(auto i:dominoes)\\n        {\\n            sort(i.begin(),i.end());\\n            if(m.find(i)!=m.end()) ans+=m[i]++;\\n            else m[i]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 491615,
                "title": "java-t-96-56-s-100-array-to-the-rescue",
                "content": "```\\n\\tpublic int numEquivDominoPairs(int[][] d) {\\n        int pairs = 0; // number of pairs\\n        int[][] count = new int[10][10]; // in this scenario better than hashmap\\n        \\n        for(int i=0;i<d.length;i++){\\n            int m = d[i][0];\\n            int n = d[i][1];\\n            \\n            if(m > n){ // if m is bigger than n just swap them to align with similar dominoes\\n                n = d[i][0];\\n                m = d[i][1];\\n            }\\n            \\n            pairs += count[m][n]; // equivalent to doing \\'n(n+1)/2\\' one time for each unique domino \\n            \\n            count[m][n]++; // increase the occurence count\\n        }\\n        \\n        return pairs;\\n\\t}\\n```",
                "solutionTags": [],
                "code": "```\\n\\tpublic int numEquivDominoPairs(int[][] d) {\\n        int pairs = 0; // number of pairs\\n        int[][] count = new int[10][10]; // in this scenario better than hashmap\\n        \\n        for(int i=0;i<d.length;i++){\\n            int m = d[i][0];\\n            int n = d[i][1];\\n            \\n            if(m > n){ // if m is bigger than n just swap them to align with similar dominoes\\n                n = d[i][0];\\n                m = d[i][1];\\n            }\\n            \\n            pairs += count[m][n]; // equivalent to doing \\'n(n+1)/2\\' one time for each unique domino \\n            \\n            count[m][n]++; // increase the occurence count\\n        }\\n        \\n        return pairs;\\n\\t}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 340012,
                "title": "c-no-sort",
                "content": "No customized sort.\\n\\nSince it\\'s hard (for me) to sort by first element in ascending order then second in ascending order, use a map to count ```freq```. Map will sort in the aforementioned fashion for you.\\n\\nNotice ```freq[make_pair(d[0], d[1])]``` is first added to ```res``` in each round, then self-increment. \\nThis ensures adding ```1, 2, 3...``` respectively in each round.\\n\\n```\\nclass Solution {\\npublic:\\n    int numEquivDominoPairs(vector<vector<int>>& dominoes) {\\n        map<pair<int, int>, int> freq;\\n        int res = 0;\\n\\n        for (vector<int> d : dominoes) {\\n            if (d[0] > d[1]) { \\n\\t        // swap elements\\n                d[0] = d[0] + d[1];\\n                d[1] = d[0] - d[1];\\n                d[0] = d[0] - d[1];\\n            }\\n\\n            res += freq[make_pair(d[0], d[1])]++;\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```freq```\n```freq[make_pair(d[0], d[1])]```\n```res```\n```1, 2, 3...```\n```\\nclass Solution {\\npublic:\\n    int numEquivDominoPairs(vector<vector<int>>& dominoes) {\\n        map<pair<int, int>, int> freq;\\n        int res = 0;\\n\\n        for (vector<int> d : dominoes) {\\n            if (d[0] > d[1]) { \\n\\t        // swap elements\\n                d[0] = d[0] + d[1];\\n                d[1] = d[0] - d[1];\\n                d[0] = d[0] - d[1];\\n            }\\n\\n            res += freq[make_pair(d[0], d[1])]++;\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2309741,
                "title": "python-simple-hashmap",
                "content": "\\n    def numEquivDominoPairs(self, dominoes):\\n        dict1, total = defaultdict(int), 0\\n        \\n        for i, j in dominoes:\\n            min_val = min(i, j)\\n            max_val = max(i, j)\\n            dict1[(min_val, max_val)] += 1\\n            \\n        for i in dict1:\\n            total += dict1[i]*(dict1[i]-1)//2\\n            \\n        return total",
                "solutionTags": [],
                "code": "\\n    def numEquivDominoPairs(self, dominoes):\\n        dict1, total = defaultdict(int), 0\\n        \\n        for i, j in dominoes:\\n            min_val = min(i, j)\\n            max_val = max(i, j)\\n            dict1[(min_val, max_val)] += 1\\n            \\n        for i in dict1:\\n            total += dict1[i]*(dict1[i]-1)//2\\n            \\n        return total",
                "codeTag": "Python3"
            },
            {
                "id": 1176876,
                "title": "java-by-using-only-array-faster-than-82-89-memory-used-less-than-76-11-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        \\n        int cn =0;\\n        \\n        int[][] n = new int[10][10];\\n        \\n      \\n        \\n        for(int i = 0 ; i< dominoes.length ; i++){\\n            \\n            if(dominoes[i][0] < dominoes[i][1]){\\n                int t= dominoes[i][0];\\n                dominoes[i][0] = dominoes[i][1];\\n                dominoes[i][1] = t ;\\n            }\\n            \\n            cn = cn +   n[dominoes[i][0]][dominoes[i][1]];\\n            n[dominoes[i][0]][dominoes[i][1]] ++;\\n            \\n        }\\n        \\n       \\n            \\n        return cn;\\n        \\n        \\n        \\n        \\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "class Solution {\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        \\n        int cn =0;\\n        \\n        int[][] n = new int[10][10];\\n        \\n      \\n        \\n        for(int i = 0 ; i< dominoes.length ; i++){\\n            \\n            if(dominoes[i][0] < dominoes[i][1]){\\n                int t= dominoes[i][0];\\n                dominoes[i][0] = dominoes[i][1];\\n                dominoes[i][1] = t ;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1174121,
                "title": "java-array-hashing-beats-99-10-2ms-t-c-o-n-s-c-o-1",
                "content": "\\n    // O(dominoes.length) O(1)\\n\\tpublic int numEquivDominoPairs(int[][] dominoes) {\\n\\n\\t\\tint len = dominoes.length, count = 0;\\n\\t\\tint[] map = new int[91];\\n\\n\\t\\tfor (int i = 0; i < len; i++) {\\n\\t\\t\\tint[] domino = dominoes[i];\\n\\t\\t\\tint hash1 = 9 * domino[0] + domino[1], hash2 = 9 * domino[1] + domino[0];\\n\\t\\t\\tcount += map[hash1];\\n\\t\\t\\tcount += (hash1 != hash2) ? map[hash2] : 0;\\n\\t\\t\\tmap[hash1]++;\\n\\t\\t}\\n\\n\\t\\treturn count;\\n\\t}",
                "solutionTags": [],
                "code": "\\n    // O(dominoes.length) O(1)\\n\\tpublic int numEquivDominoPairs(int[][] dominoes) {\\n\\n\\t\\tint len = dominoes.length, count = 0;\\n\\t\\tint[] map = new int[91];\\n\\n\\t\\tfor (int i = 0; i < len; i++) {\\n\\t\\t\\tint[] domino = dominoes[i];\\n\\t\\t\\tint hash1 = 9 * domino[0] + domino[1], hash2 = 9 * domino[1] + domino[0];\\n\\t\\t\\tcount += map[hash1];\\n\\t\\t\\tcount += (hash1 != hash2) ? map[hash2] : 0;\\n\\t\\t\\tmap[hash1]++;\\n\\t\\t}\\n\\n\\t\\treturn count;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 982936,
                "title": "python-o-n-beats-97-37-dictionary-combinatorial-number",
                "content": "```\\nclass Solution:\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        num_dic = collections.defaultdict(int)\\n        n = len(dominoes)\\n        for i in range(n):\\n\\t\\t# make dominoe like [1, 2] and [2, 1] become the same\\n            a, b = sorted(dominoes[i])\\n            num_dic[(a, b)] += 1\\n        pairs = 0\\n        for k, v in num_dic.items():\\n\\t\\t# number of equivalents in dictionary\\n            if v >= 2:\\n\\t\\t\\t# formula of comtinational number, C(2, n) = n(n-1)/2. For example, item a, b, c could form three combinations of two: (a, b), (a, c), (b, c)\\n                pairs += (v * (v-1))//2\\n        return pairs\\n```",
                "solutionTags": [
                    "Python",
                    "Combinatorics"
                ],
                "code": "```\\nclass Solution:\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        num_dic = collections.defaultdict(int)\\n        n = len(dominoes)\\n        for i in range(n):\\n\\t\\t# make dominoe like [1, 2] and [2, 1] become the same\\n            a, b = sorted(dominoes[i])\\n            num_dic[(a, b)] += 1\\n        pairs = 0\\n        for k, v in num_dic.items():\\n\\t\\t# number of equivalents in dictionary\\n            if v >= 2:\\n\\t\\t\\t# formula of comtinational number, C(2, n) = n(n-1)/2. For example, item a, b, c could form three combinations of two: (a, b), (a, c), (b, c)\\n                pairs += (v * (v-1))//2\\n        return pairs\\n```",
                "codeTag": "Java"
            },
            {
                "id": 819546,
                "title": "javascript-solution-with-object",
                "content": "```\\nvar sum = 0;\\n  var obj = {};\\n  dominoes.map((x) => {\\n    var cha = x.sort((a, b) => a - b).join(\"\");\\n    if (obj.hasOwnProperty(cha)) {\\n      sum += obj[cha];\\n      obj[cha]++;\\n    } else {\\n      obj[cha] = 1;\\n    }\\n  });\\n  return sum;\\n  \\n  ES6:\\n  var numEquivDominoPairs = function (dominoes) {\\n    const dic = {};\\n    let pairs = 0;\\n    dominoes.map((domi) => {\\n        domi.sort((a, b) => a - b);\\n        dic[domi] ? ((pairs += dic[domi]), dic[domi]++) : (dic[domi] = 1);\\n    });\\n    return pairs;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar sum = 0;\\n  var obj = {};\\n  dominoes.map((x) => {\\n    var cha = x.sort((a, b) => a - b).join(\"\");\\n    if (obj.hasOwnProperty(cha)) {\\n      sum += obj[cha];\\n      obj[cha]++;\\n    } else {\\n      obj[cha] = 1;\\n    }\\n  });\\n  return sum;\\n  \\n  ES6:\\n  var numEquivDominoPairs = function (dominoes) {\\n    const dic = {};\\n    let pairs = 0;\\n    dominoes.map((domi) => {\\n        domi.sort((a, b) => a - b);\\n        dic[domi] ? ((pairs += dic[domi]), dic[domi]++) : (dic[domi] = 1);\\n    });\\n    return pairs;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 597640,
                "title": "python-3-use-dictionary",
                "content": "```\\nclass Solution:\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        mydic={}\\n        for ele in dominoes:\\n            if ele[0]<=ele[1]:\\n                a=tuple(ele)\\n            else:\\n                a=tuple(ele[::-1])\\n            if a in mydic:\\n                mydic[a]+=1\\n            else:\\n                mydic[a]=1\\n        count=0\\n        for k, v in mydic.items():\\n            if v>1:\\n                count+=v*(v-1)//2\\n        return count\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        mydic={}\\n        for ele in dominoes:\\n            if ele[0]<=ele[1]:\\n                a=tuple(ele)\\n            else:\\n                a=tuple(ele[::-1])\\n            if a in mydic:\\n                mydic[a]+=1\\n            else:\\n                mydic[a]=1\\n        count=0\\n        for k, v in mydic.items():\\n            if v>1:\\n                count+=v*(v-1)//2\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 510614,
                "title": "simple-java-with-hasmap",
                "content": "```\\nclass Solution {\\n    public static int numEquivDominoPairs(int[][] dominoes) {\\n        Map<Integer, Integer> dic = new HashMap<>();\\n        int res = 0;\\n        for(int[] domino : dominoes) {\\n            int val = domino[0] < domino[1] ? domino[0] * 10 + domino[1] : domino[1] * 10 + domino[0];\\n            int count = dic.getOrDefault(val,0);\\n            dic.put(val, count + 1);\\n            res = res + count;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public static int numEquivDominoPairs(int[][] dominoes) {\\n        Map<Integer, Integer> dic = new HashMap<>();\\n        int res = 0;\\n        for(int[] domino : dominoes) {\\n            int val = domino[0] < domino[1] ? domino[0] * 10 + domino[1] : domino[1] * 10 + domino[0];\\n            int count = dic.getOrDefault(val,0);\\n            dic.put(val, count + 1);\\n            res = res + count;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 360111,
                "title": "linear-time-linear-space",
                "content": "```\\n\\nclass Solution {\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        HashMap<String, Integer> domGroup = new HashMap<>();\\n        int totalPairs = 0; // Solution\\n        \\n        for (int[] dominoe: dominoes){\\n            int smallest = dominoe[0] < dominoe[1] ? dominoe[0] : dominoe[1];\\n            int largest = dominoe[1] > dominoe[0] ? dominoe[1] : dominoe[0];\\n            String key = smallest + \"#\" + largest;\\n            domGroup.put(key, domGroup.getOrDefault(key, 0) + 1);\\n        }\\n        \\n        for (String key: domGroup.keySet()){\\n            int count = domGroup.get(key);\\n            totalPairs += (count*(count-1)) / 2;\\n        }\\n        \\n        return totalPairs;\\n            \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        HashMap<String, Integer> domGroup = new HashMap<>();\\n        int totalPairs = 0; // Solution\\n        \\n        for (int[] dominoe: dominoes){\\n            int smallest = dominoe[0] < dominoe[1] ? dominoe[0] : dominoe[1];\\n            int largest = dominoe[1] > dominoe[0] ? dominoe[1] : dominoe[0];\\n            String key = smallest + \"#\" + largest;\\n            domGroup.put(key, domGroup.getOrDefault(key, 0) + 1);\\n        }\\n        \\n        for (String key: domGroup.keySet()){\\n            int count = domGroup.get(key);\\n            totalPairs += (count*(count-1)) / 2;\\n        }\\n        \\n        return totalPairs;\\n            \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3483730,
                "title": "java-2-approaches-counting-with-array-counting-with-hashmap",
                "content": "### Counting With Array\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    \\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        int[] counts = new int[100];\\n        int pairsCount = 0;\\n        for (int[] domino : dominoes) {\\n            int up = Math.min(domino[0], domino[1]);\\n            int down = Math.max(domino[0], domino[1]);\\n            \\n            pairsCount += counts[up * 10 + down]++;\\n        }\\n\\n        return pairsCount;\\n    }\\n}\\n```\\n### Counting With HashMap\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    \\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        int pairsCountSum = 0;\\n        Map<Integer, Integer> pairsCount = new HashMap<>();\\n        for (int[] domino : dominoes) {\\n            int up = Math.min(domino[0], domino[1]);\\n            int down = Math.max(domino[0], domino[1]);\\n\\n            int num = up * 10 + down;\\n            if (!pairsCount.containsKey(num)) {\\n                pairsCount.put(num, 1);\\n            } else {\\n                pairsCountSum += pairsCount.get(num);\\n                pairsCount.put(num, pairsCount.get(num) + 1);\\n            }\\n        }\\n\\n        return pairsCountSum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        int[] counts = new int[100];\\n        int pairsCount = 0;\\n        for (int[] domino : dominoes) {\\n            int up = Math.min(domino[0], domino[1]);\\n            int down = Math.max(domino[0], domino[1]);\\n            \\n            pairsCount += counts[up * 10 + down]++;\\n        }\\n\\n        return pairsCount;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    \\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        int pairsCountSum = 0;\\n        Map<Integer, Integer> pairsCount = new HashMap<>();\\n        for (int[] domino : dominoes) {\\n            int up = Math.min(domino[0], domino[1]);\\n            int down = Math.max(domino[0], domino[1]);\\n\\n            int num = up * 10 + down;\\n            if (!pairsCount.containsKey(num)) {\\n                pairsCount.put(num, 1);\\n            } else {\\n                pairsCountSum += pairsCount.get(num);\\n                pairsCount.put(num, pairsCount.get(num) + 1);\\n            }\\n        }\\n\\n        return pairsCountSum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2598466,
                "title": "hashmap-c-bit-manipulation",
                "content": "```\\nclass Solution {\\npublic:\\n    int numEquivDominoPairs(vector<vector<int>>& dominoes) {\\n        unordered_map<int, int> mp;\\n        int ans = 0;\\n        for(auto &x : dominoes) {\\n            int key = 0;\\n            key = key | (1 << x[0]);\\n            key = key | (1 << x[1]);\\n            if(mp.count(key))\\n                ans += mp[key];\\n            mp[key]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numEquivDominoPairs(vector<vector<int>>& dominoes) {\\n        unordered_map<int, int> mp;\\n        int ans = 0;\\n        for(auto &x : dominoes) {\\n            int key = 0;\\n            key = key | (1 << x[0]);\\n            key = key | (1 << x[1]);\\n            if(mp.count(key))\\n                ans += mp[key];\\n            mp[key]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2561757,
                "title": "java-solution-using-hashmap",
                "content": "Step 1 : swap the dominoes[i]->(a,b) according to which one is smaller\\nStep 2 : Creating hashMap with key as a*10+b and value as the number of occurences of (a,b)\\nStep 3 : Counting the values of hashmap which are greater than 1\\nStep 4 : By combination theorem nCr = n!/(n-r)!*r! \\n            here we have to find out the number of pairs we get so n is the value of key and r is 2 as we are            considering pairs\\n```\\nclass Solution {\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        for(int i=0;i<dominoes.length;i++)\\n        {\\n            if(dominoes[i][0]>dominoes[i][1])\\n            {\\n                int tmp=dominoes[i][1];\\n                dominoes[i][1]=dominoes[i][0];\\n                dominoes[i][0]=tmp;\\n            }\\n        }\\n        HashMap<Integer,Integer>hm=new HashMap<>();\\n        int c=0;\\n        for(int i=0;i<dominoes.length;i++)\\n        {\\n            if(hm.get(dominoes[i][0]*10+dominoes[i][1])==null)\\n            {\\n                hm.put(dominoes[i][0]*10+dominoes[i][1],1);\\n            }\\n            else hm.put(dominoes[i][0]*10+dominoes[i][1],hm.get(dominoes[i][0]*10+dominoes[i][1])+1);\\n            \\n        }\\n        System.out.println(hm);\\n        for(Map.Entry<Integer,Integer>e:hm.entrySet())\\n        {\\n            int k=e.getValue();\\n            if(k>1)c+=((k*(k-1))/2);\\n        }\\n        return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        for(int i=0;i<dominoes.length;i++)\\n        {\\n            if(dominoes[i][0]>dominoes[i][1])\\n            {\\n                int tmp=dominoes[i][1];\\n                dominoes[i][1]=dominoes[i][0];\\n                dominoes[i][0]=tmp;\\n            }\\n        }\\n        HashMap<Integer,Integer>hm=new HashMap<>();\\n        int c=0;\\n        for(int i=0;i<dominoes.length;i++)\\n        {\\n            if(hm.get(dominoes[i][0]*10+dominoes[i][1])==null)\\n            {\\n                hm.put(dominoes[i][0]*10+dominoes[i][1],1);\\n            }\\n            else hm.put(dominoes[i][0]*10+dominoes[i][1],hm.get(dominoes[i][0]*10+dominoes[i][1])+1);\\n            \\n        }\\n        System.out.println(hm);\\n        for(Map.Entry<Integer,Integer>e:hm.entrySet())\\n        {\\n            int k=e.getValue();\\n            if(k>1)c+=((k*(k-1))/2);\\n        }\\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2459029,
                "title": "go-without-hashmap-o-n",
                "content": "```\\nfunc numEquivDominoPairs(dominoes [][]int) int {\\n    res, cache := 0, make([][]int, 10)\\n    \\n    for i := 0; i < 10; i++ {\\n        cache[i] = make([]int, 10)\\n    }\\n    \\n    for i := 0; i < len(dominoes); i++ {\\n        begin, end := dominoes[i][0], dominoes[i][1]\\n        \\n        res += cache[begin][end]\\n        \\n        if begin != end {\\n            res += cache[end][begin]\\n        }\\n        \\n        \\n        cache[begin][end]++\\n    }\\n    \\n    return res\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc numEquivDominoPairs(dominoes [][]int) int {\\n    res, cache := 0, make([][]int, 10)\\n    \\n    for i := 0; i < 10; i++ {\\n        cache[i] = make([]int, 10)\\n    }\\n    \\n    for i := 0; i < len(dominoes); i++ {\\n        begin, end := dominoes[i][0], dominoes[i][1]\\n        \\n        res += cache[begin][end]\\n        \\n        if begin != end {\\n            res += cache[end][begin]\\n        }\\n        \\n        \\n        cache[begin][end]++\\n    }\\n    \\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2330705,
                "title": "simple-c-nlog-n-soln-and-o-1-space",
                "content": "```\\nint numEquivDominoPairs(vector<vector<int>>& d) {\\n        for(int i=0;i<d.size();i++){\\n            if(d[i][0]>d[i][1]) swap(d[i][0],d[i][1]);\\n        }\\n        sort(d.begin(),d.end());\\n        int ans=0;\\n        for(int i=0;i<d.size();){\\n            int j=i+1;\\n            while(j<d.size()&&d[j]==d[i]) j++;\\n            if(j==i+1){\\n                i=j;\\n                continue;\\n            }\\n            ans+=(j-i)*(j-i-1)/2;\\n            i=j;\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nint numEquivDominoPairs(vector<vector<int>>& d) {\\n        for(int i=0;i<d.size();i++){\\n            if(d[i][0]>d[i][1]) swap(d[i][0],d[i][1]);\\n        }\\n        sort(d.begin(),d.end());\\n        int ans=0;\\n        for(int i=0;i<d.size();){\\n            int j=i+1;\\n            while(j<d.size()&&d[j]==d[i]) j++;\\n            if(j==i+1){\\n                i=j;\\n                continue;\\n            }\\n            ans+=(j-i)*(j-i-1)/2;\\n            i=j;\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1643791,
                "title": "java-2ms-100-one-pass-dp-w-arrhash-just-5-lines-thinking-process",
                "content": "Because there are a lot of reoccuring identical domino, 1 scan to hash and another scan over the hash array / map is the first that came to mind. However, we can improve upon this with the principle of Dynamic Programming, with every new identical domino found, there are **\"1 + valid count that ends with previous identical domino\"** We can then count as we loop through the array for the first time, meaing <ins>*1 for loop should suffice*</ins>.\\n\\nWith that in mind, then, we have to come up with a way to group all the identical dominos together. One quick observation is that **those with identical max and min number in the domino are identical, regardless of how the min and max are arranged**, and then next observation is that the number can only go up to 9 at most according to the problem constraint. Hence, we duduce that the HashID of each domino is then <ins>`10 * max + min`</ins>. And this number can only go up to 99 at most. Domino with the same HashID are identical as laid out by this problem. We will utilize an array with size 100 to handle the counting aspect of it. \\n```\\nclass Solution {\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        int[] count = new int[100];\\n        int ans = 0;\\n        for (int[] d : dominoes)\\n            if (++count[hash(d)] > 1) //increment count and if it is >= 2, then\\n                ans += count[hash(d)] - 1; //we add to the ans (remember to -1 because single 1 domino isn\\'t a pair)\\n        return ans;\\n    }\\n\\n    private static int hash(int[] d){ //domino with the same id are the same.\\n        return 10 * Math.max(d[0], d[1]) + Math.min(d[0], d[1]);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        int[] count = new int[100];\\n        int ans = 0;\\n        for (int[] d : dominoes)\\n            if (++count[hash(d)] > 1) //increment count and if it is >= 2, then\\n                ans += count[hash(d)] - 1; //we add to the ans (remember to -1 because single 1 domino isn\\'t a pair)\\n        return ans;\\n    }\\n\\n    private static int hash(int[] d){ //domino with the same id are the same.\\n        return 10 * Math.max(d[0], d[1]) + Math.min(d[0], d[1]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1607621,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int numEquivDominoPairs(vector<vector<int>>& dominoes) {\\n        int count=0;\\n        map<vector<int>,int>m;\\n        for(int i=0;i<dominoes.size();i++) {\\n            vector<int>aux=dominoes[i];\\n            // sort the pair and store in the hashmap\\n            if(aux[0]>aux[1]) {\\n                swap(aux[0],aux[1]);\\n            }\\n            m[aux]++;\\n        }\\n        for(auto it:m) {\\n            if(it.second>1) {\\n                // so if for any domino we\\'ve \\'n\\' instances then we can make nC2 equivalent pair from them..\\n                int n=it.second;\\n                count+=((n*(n-1))/2);\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```\\n***Please upvote if you have got any help from my code. Thank you.***",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numEquivDominoPairs(vector<vector<int>>& dominoes) {\\n        int count=0;\\n        map<vector<int>,int>m;\\n        for(int i=0;i<dominoes.size();i++) {\\n            vector<int>aux=dominoes[i];\\n            // sort the pair and store in the hashmap\\n            if(aux[0]>aux[1]) {\\n                swap(aux[0],aux[1]);\\n            }\\n            m[aux]++;\\n        }\\n        for(auto it:m) {\\n            if(it.second>1) {\\n                // so if for any domino we\\'ve \\'n\\' instances then we can make nC2 equivalent pair from them..\\n                int n=it.second;\\n                count+=((n*(n-1))/2);\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1564329,
                "title": "c-easy-solution-map",
                "content": "```\\nclass Solution\\n{\\npublic:\\n    int numEquivDominoPairs(vector<vector<int>> &dominoes)\\n    {\\n        map<pair<int, int>, int> mp;\\n        int ans = 0;\\n        for (const auto &i : dominoes)\\n        {\\n            //checking in map and updating \\'ans\\' variable\\n            if (i[0] < i[1])  ans += mp[{i[0], i[1]}];\\n            else  ans += mp[{i[1], i[0]}];\\n            \\n            //updation of map based on small value first and large value second\\n            if (i[0] < i[1])  ++mp[{i[0], i[1]}];\\n            else  ++mp[{i[1], i[0]}];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    int numEquivDominoPairs(vector<vector<int>> &dominoes)\\n    {\\n        map<pair<int, int>, int> mp;\\n        int ans = 0;\\n        for (const auto &i : dominoes)\\n        {\\n            //checking in map and updating \\'ans\\' variable\\n            if (i[0] < i[1])  ans += mp[{i[0], i[1]}];\\n            else  ans += mp[{i[1], i[0]}];\\n            \\n            //updation of map based on small value first and large value second\\n            if (i[0] < i[1])  ++mp[{i[0], i[1]}];\\n            else  ++mp[{i[1], i[0]}];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1514590,
                "title": "python-1-liner",
                "content": "```\\nclass Solution:\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        return sum(v*(v-1)//2 for v in collections.Counter([min(a,b)*10+max(a,b) for a,b in dominoes]).values())\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        return sum(v*(v-1)//2 for v in collections.Counter([min(a,b)*10+max(a,b) for a,b in dominoes]).values())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1452251,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int numEquivDominoPairs(vector<vector<int>>& dominoes) {\\n        map<pair<int,int>,int>m;\\n        int ret=0;\\n        for(auto i:dominoes) {\\n            if(i[0]>i[1]) {\\n                m[{i[1],i[0]}]++;\\n            }\\n            else m[{i[0],i[1]}]++;\\n        }\\n        for(auto i:m) {\\n            ret+=i.second*(i.second-1)/2;\\n        }\\n        return ret;   \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numEquivDominoPairs(vector<vector<int>>& dominoes) {\\n        map<pair<int,int>,int>m;\\n        int ret=0;\\n        for(auto i:dominoes) {\\n            if(i[0]>i[1]) {\\n                m[{i[1],i[0]}]++;\\n            }\\n            else m[{i[0],i[1]}]++;\\n        }\\n        for(auto i:m) {\\n            ret+=i.second*(i.second-1)/2;\\n        }\\n        return ret;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1405532,
                "title": "c-simple-and-clean",
                "content": "```\\nclass Solution {\\npublic:\\n    int numEquivDominoPairs(vector<vector<int>>& dominoes) {\\n        map<pair<int, int>, int> mp;\\n        \\n        for(auto &vec : dominoes) {\\n            if(vec[0] > vec[1])\\n                swap(vec[0], vec[1]); //so that we get {2, 1} and {1, 2} counted together\\n            mp[{vec[0], vec[1]}]++;\\n        }\\n        \\n        int count = 0;\\n        \\n        for(auto &it : mp) {\\n            int val = it.second;\\n            count += val*(val-1)/2;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numEquivDominoPairs(vector<vector<int>>& dominoes) {\\n        map<pair<int, int>, int> mp;\\n        \\n        for(auto &vec : dominoes) {\\n            if(vec[0] > vec[1])\\n                swap(vec[0], vec[1]); //so that we get {2, 1} and {1, 2} counted together\\n            mp[{vec[0], vec[1]}]++;\\n        }\\n        \\n        int count = 0;\\n        \\n        for(auto &it : mp) {\\n            int val = it.second;\\n            count += val*(val-1)/2;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1318549,
                "title": "java-approach-using-10x10-grid-o-n-time-o-1-space",
                "content": "[https://github.com/2018hsridhar/Leetcode_Solutions/blob/master/leetcode_1128.java](http://)\\n```\\n/*\\n1128. Number of Equivalent Domino Pairs\\nURL = https://leetcode.com/problems/number-of-equivalent-domino-pairs/\\n\\nThought process : \\n1. Summation of dominoe values - [1,12] here : but can have multiple sums too, so take note of that\\n-> Gets problematic with middle summations though\\n\\n\\n2. Let us generation sums maps\\n\\n2 => [1,1]\\n3 => [1,2], [2,1] \\n4 => [1,3], [3,1], [2,2]\\n5 => [1,4],[4,1],[2,3],[4,3]\\n6 => [1,5],[5,1],[2,4][4,2],[3,3] \\n\\nIdea #2 : sort and compare to previous elements ( after a global sort operation )?\\n\\nA lot of dominos are possible here\\nDomino values are reasonable too : [1,9] only\\n\\nComputational complexity :\\n\\nPairwise comparisons : O(N^2) due to N(N-1)/2 unique number of domino pairings here\\nSpace Complexity, with pairwise comparison approach = O(1) though ... may run into a RLE error\\n\\nEdge case testing  :\\n\\nUse an matrix instead of a hashmap approach, and add indices as we go? Is a 9x9 only!\\n\\n\\n*/\\n\\nclass Solution\\n{\\n    public int numEquivDominoPairs(int[][] dominoes) \\n    {\\n        int numPairs = 0;\\n        int[][] matrix = new int[10][10];\\n        for(int i = 0; i < matrix.length; ++i)\\n            for(int j = 0; j < matrix[0].length; ++j)\\n                matrix[i][j] = 0;\\n        \\n        for(int i = 0; i < dominoes.length; ++i)\\n        {\\n            int[] domino = dominoes[i];\\n            int x = domino[0];\\n            int y = domino[1];\\n            ++matrix[x][y];\\n        }\\n        \\n        // Iterate over upper triangle only\\n        for(int i = 0; i < 10; ++i)\\n        {\\n            for(int j = i; j < 10; ++j)\\n            {\\n                int dominoCount = matrix[i][j];\\n                if(i != j)\\n                    dominoCount += matrix[j][i];\\n                numPairs += (dominoCount*(dominoCount - 1) / 2); // n choose 2 type of thing now!\\n            }\\n        }\\n        return numPairs;\\n        \\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Matrix"
                ],
                "code": "class Solution\\n{\\n    public int numEquivDominoPairs(int[][] dominoes) \\n    {\\n        int numPairs = 0;\\n        int[][] matrix = new int[10][10];\\n        for(int i = 0; i < matrix.length; ++i)\\n            for(int j = 0; j < matrix[0].length; ++j)\\n                matrix[i][j] = 0;\\n        \\n        for(int i = 0; i < dominoes.length; ++i)\\n        {\\n            int[] domino = dominoes[i];\\n            int x = domino[0];\\n            int y = domino[1];\\n            ++matrix[x][y];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1211473,
                "title": "c",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint numEquivDominoPairs(vector<vector<int>>& dominoes) {\\n\\t\\t\\tmap< pair<int,int>,int>mp;\\n\\t\\t\\tfor(auto  &p:dominoes){\\n\\t\\t\\t\\tint x=p[0];\\n\\t\\t\\t\\tint y=p[1];\\n\\t\\t\\t\\tif(x>y)swap(x,y);\\n\\t\\t\\t\\tmp[{x,y}]++;\\n\\t\\t\\t}\\n\\t\\t\\tint cnt=0;\\n\\t\\t\\tfor(auto &p :mp){\\n\\t\\t\\t\\tif(p.second>=2){\\n\\t\\t\\t\\t\\tint n=p.second;\\n\\t\\t\\t\\t\\tcnt+= (n*(n-1))/2;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn cnt;\\n\\t\\t}\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint numEquivDominoPairs(vector<vector<int>>& dominoes) {\\n\\t\\t\\tmap< pair<int,int>,int>mp;\\n\\t\\t\\tfor(auto  &p:dominoes){\\n\\t\\t\\t\\tint x=p[0];\\n\\t\\t\\t\\tint y=p[1];\\n\\t\\t\\t\\tif(x>y)swap(x,y);\\n\\t\\t\\t\\tmp[{x,y}",
                "codeTag": "Java"
            },
            {
                "id": 1147918,
                "title": "java-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int numEquivDominoPairs(int[][] arr) {\\n        Map<List<Integer>,Integer> map = new HashMap<>();\\n        int ans =0;\\n        \\n        for(int i=0;i<arr.length;i++)\\n        {\\n            List<Integer> list = new LinkedList<>();\\n            if(arr[i][0] > arr[i][1])\\n            {\\n                list.add(arr[i][0]);\\n                list.add(arr[i][1]);\\n            }\\n            else {\\n                list.add(arr[i][1]);\\n                list.add(arr[i][0]);\\n            }\\n            if(map.containsKey(list)){\\n                map.replace(list,1+map.get(list));\\n                ans += map.get(list);\\n            }\\n            else map.put(list,0);\\n            \\n        }\\n        \\n        return ans;\\n    }\\n}\\n```\\nPlease upvote if you find my code easy to understand",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numEquivDominoPairs(int[][] arr) {\\n        Map<List<Integer>,Integer> map = new HashMap<>();\\n        int ans =0;\\n        \\n        for(int i=0;i<arr.length;i++)\\n        {\\n            List<Integer> list = new LinkedList<>();\\n            if(arr[i][0] > arr[i][1])\\n            {\\n                list.add(arr[i][0]);\\n                list.add(arr[i][1]);\\n            }\\n            else {\\n                list.add(arr[i][1]);\\n                list.add(arr[i][0]);\\n            }\\n            if(map.containsKey(list)){\\n                map.replace(list,1+map.get(list));\\n                ans += map.get(list);\\n            }\\n            else map.put(list,0);\\n            \\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1029486,
                "title": "python-solution",
                "content": "\\th, result = {}, 0\\n\\tfor domino in dominoes:\\n\\t\\ts = tuple(sorted(domino))\\n\\t\\th[s] = h.get(s, 0) + 1\\n\\tfor val in h.values():\\n\\t\\tif val > 1:\\n\\t\\t\\tresult += val * (val - 1) / 2\\n\\treturn result",
                "solutionTags": [],
                "code": "\\th, result = {}, 0\\n\\tfor domino in dominoes:\\n\\t\\ts = tuple(sorted(domino))\\n\\t\\th[s] = h.get(s, 0) + 1\\n\\tfor val in h.values():\\n\\t\\tif val > 1:\\n\\t\\t\\tresult += val * (val - 1) / 2\\n\\treturn result",
                "codeTag": "Unknown"
            },
            {
                "id": 839014,
                "title": "rust-cleaner-rust-solution",
                "content": "```rust\\nuse std::collections::HashMap;\\n\\nimpl Solution {\\n    pub fn num_equiv_domino_pairs(dominoes: Vec<Vec<i32>>) -> i32 {\\n        let mut count = HashMap::new();\\n        for d in dominoes {\\n            let d = (d[0].min(d[1]), d[0].max(d[1]));\\n            *count.entry(d).or_insert(0) += 1;\\n        }\\n        count.values().map(|c| (c * (c - 1)) / 2).sum()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nuse std::collections::HashMap;\\n\\nimpl Solution {\\n    pub fn num_equiv_domino_pairs(dominoes: Vec<Vec<i32>>) -> i32 {\\n        let mut count = HashMap::new();\\n        for d in dominoes {\\n            let d = (d[0].min(d[1]), d[0].max(d[1]));\\n            *count.entry(d).or_insert(0) += 1;\\n        }\\n        count.values().map(|c| (c * (c - 1)) / 2).sum()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 589387,
                "title": "c-faster-than-100-less-than-100-mem-o-n",
                "content": "```\\npublic int NumEquivDominoPairs(int[][] dominoes) {\\n     Dictionary<int, int> numbers = new Dictionary<int, int>();\\n\\n            for (int i = 0; i < dominoes.Length; i++)\\n            {\\n                int key = 0;\\n\\n                if (dominoes[i][0] <= dominoes[i][1])\\n                {\\n                    key = dominoes[i][0] * 10 + dominoes[i][1];\\n                }\\n                else\\n                {\\n                    key = dominoes[i][1] * 10 + dominoes[i][0];\\n                }\\n\\n                if (numbers.TryGetValue(key, out var s))\\n                {\\n                    numbers[key] += 1;\\n                }\\n                else numbers.Add(key, 1);\\n            }\\n            return numbers.Values.Sum(e => e*(e - 1)/2);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int NumEquivDominoPairs(int[][] dominoes) {\\n     Dictionary<int, int> numbers = new Dictionary<int, int>();\\n\\n            for (int i = 0; i < dominoes.Length; i++)\\n            {\\n                int key = 0;\\n\\n                if (dominoes[i][0] <= dominoes[i][1])\\n                {\\n                    key = dominoes[i][0] * 10 + dominoes[i][1];\\n                }\\n                else\\n                {\\n                    key = dominoes[i][1] * 10 + dominoes[i][0];\\n                }\\n\\n                if (numbers.TryGetValue(key, out var s))\\n                {\\n                    numbers[key] += 1;\\n                }\\n                else numbers.Add(key, 1);\\n            }\\n            return numbers.Values.Sum(e => e*(e - 1)/2);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 487328,
                "title": "python-frozenset-1-liner",
                "content": "As the order of a domino\\'s numbers doesn\\'t matter, we should regard dominos as sets. To use a `Counter`, we need them hashable, so we use `frozenset`.\\n\\n```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def numEquivDominoPairs(self, D):\\n        return sum(d*(d-1)/2 for d in Counter(map(frozenset, D)).values())\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def numEquivDominoPairs(self, D):\\n        return sum(d*(d-1)/2 for d in Counter(map(frozenset, D)).values())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 484568,
                "title": "java-solution",
                "content": "```\\npublic int numEquivDominoPairs(int[][] dominoes) {\\n        int count = 0;\\n        HashMap<String, Integer> map = new HashMap<String, Integer>();\\n        for(int[] dominoe : dominoes){\\n            int small = Math.min(dominoe[0], dominoe[1]);\\n            int large = Math.max(dominoe[0], dominoe[1]);\\n            String key = small + \"$\" + large;\\n            count += map.getOrDefault(key,0);\\n            map.put(key, map.getOrDefault(key,0)+1);\\n        }\\n        \\n        return count;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int numEquivDominoPairs(int[][] dominoes) {\\n        int count = 0;\\n        HashMap<String, Integer> map = new HashMap<String, Integer>();\\n        for(int[] dominoe : dominoes){\\n            int small = Math.min(dominoe[0], dominoe[1]);\\n            int large = Math.max(dominoe[0], dominoe[1]);\\n            String key = small + \"$\" + large;\\n            count += map.getOrDefault(key,0);\\n            map.put(key, map.getOrDefault(key,0)+1);\\n        }\\n        \\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 417112,
                "title": "python-3-two-solutions-one-pass-99-38-two-pass-98-03",
                "content": "Method 1 (one pass) (beating 99.38%)\\n1) loop through `dominoes`\\n2) at each domino pair, add the number of equivalent domino pairs observed so far to answer and add count of equivalent domino pairs by 1;\\n3) return the anser.\\n\\n```\\nclass Solution:\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        ans = 0\\n        freq = defaultdict(int)\\n        for x, y in dominoes: \\n            if x > y: x, y = y, x\\n            key = 10*x + y\\n            ans += freq[key]\\n            freq[key] += 1\\n        return ans \\n```\\nMethod 2 (two pass) (beating 98.03%)\\n1) pass-1, count occurrence of each equivalent domino pair;\\n2) pass-2, loop through the counts and compute 1 + ... + v-1 using formula;\\n3) return the sum \\n4) \\n```\\nclass Solution:\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        freq = defaultdict(int)\\n        for x, y in dominoes:\\n            if x > y: x, y = y, x\\n            freq[10*x + y] += 1\\n        return sum(v*(v-1)//2 for v in freq.values())\\n```\\n\\nA two-line version of method 2 is below. \\n```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        count = Counter((lambda x,y: 10*x+y)(*sorted(d)) for d in dominoes)\\n        return sum(v*(v-1)//2 for v in count.values())\\n```\\n\\nEdited on 4/20/2021 \\n```\\nclass Solution:\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        ans = 0 \\n        freq = defaultdict(int)\\n        for x, y in dominoes: \\n            ans += freq[x, y]\\n            if x != y: ans += freq[y, x]\\n            freq[x, y] += 1\\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        ans = 0\\n        freq = defaultdict(int)\\n        for x, y in dominoes: \\n            if x > y: x, y = y, x\\n            key = 10*x + y\\n            ans += freq[key]\\n            freq[key] += 1\\n        return ans \\n```\n```\\nclass Solution:\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        freq = defaultdict(int)\\n        for x, y in dominoes:\\n            if x > y: x, y = y, x\\n            freq[10*x + y] += 1\\n        return sum(v*(v-1)//2 for v in freq.values())\\n```\n```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        count = Counter((lambda x,y: 10*x+y)(*sorted(d)) for d in dominoes)\\n        return sum(v*(v-1)//2 for v in count.values())\\n```\n```\\nclass Solution:\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        ans = 0 \\n        freq = defaultdict(int)\\n        for x, y in dominoes: \\n            ans += freq[x, y]\\n            if x != y: ans += freq[y, x]\\n            freq[x, y] += 1\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 389413,
                "title": "simple-c-solution",
                "content": "```\\nint cmpfunc (const void * a, const void * b)\\n{\\n   return ( *(int*)a - *(int*)b );\\n}\\nint numEquivDominoPairs(int** dominoes, int dominoesSize, int* dominoesColSize){\\n    int cnt=1,total=0;\\n    int *arr=malloc(sizeof(int)*dominoesSize);\\n    for(int i=0;i<dominoesSize;i++)\\n    {\\n        if(dominoes[i][0]<dominoes[i][1])\\n            arr[i]=dominoes[i][0]*10+dominoes[i][1];\\n        else\\n            arr[i]=dominoes[i][1]*10+dominoes[i][0];\\n    }\\n    qsort(arr, dominoesSize, sizeof(int), cmpfunc);\\n    for(int i=0;i<dominoesSize-1;i++)\\n    {\\n        while(i+1<dominoesSize&&arr[i]==arr[i+1])\\n        {\\n            //printf(\"%d \",arr[i]);\\n            cnt++;\\n            i++;\\n        }\\n        total+=cnt*(cnt-1)/2;\\n        cnt=1;\\n    }\\n    return total;\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nint cmpfunc (const void * a, const void * b)\\n{\\n   return ( *(int*)a - *(int*)b );\\n}\\nint numEquivDominoPairs(int** dominoes, int dominoesSize, int* dominoesColSize){\\n    int cnt=1,total=0;\\n    int *arr=malloc(sizeof(int)*dominoesSize);\\n    for(int i=0;i<dominoesSize;i++)\\n    {\\n        if(dominoes[i][0]<dominoes[i][1])\\n            arr[i]=dominoes[i][0]*10+dominoes[i][1];\\n        else\\n            arr[i]=dominoes[i][1]*10+dominoes[i][0];\\n    }\\n    qsort(arr, dominoesSize, sizeof(int), cmpfunc);\\n    for(int i=0;i<dominoesSize-1;i++)\\n    {\\n        while(i+1<dominoesSize&&arr[i]==arr[i+1])\\n        {\\n            //printf(\"%d \",arr[i]);\\n            cnt++;\\n            i++;\\n        }\\n        total+=cnt*(cnt-1)/2;\\n        cnt=1;\\n    }\\n    return total;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 375987,
                "title": "c-easy-solution-map-free-counting-combination-problem-beats-95-92-100",
                "content": "At first, count all the dominoes and initialize the 9x9 matrix, which had already been initialized with zeros, with the counted values.\\nIt is possible because of the second constraint that tells us the range of the values [1-9].\\nFor example, a domino numbered [1, 1] increases the value of matrix[0][0].\\n\\nNext, think about the possible cases.\\n(1) i == j (diagonal)\\n\\t- consider only 1 sub-case\\n(2) i != j\\n\\t- consider 3 sub-cases\\n\\nFinally, let\\'s count the number of answers.\\ncase (1):\\n\\nIf we have 6 for the matrix[0][0], the problem could be counted as drawing two balls from the pocket which has 6 balls numbered as index of [0][0] numbered domino.\\nIn this sense, 6C2 = 6 * 5 / 2 * 1 = 15 (answers) can be computed. (because swap doesn\\'t have any meanings, so the two conditions, (a==c and b==d), or (a==d and b==c), are counted as one..)\\n\\ncase(2):\\n\\nsub-case #1: matrix[i][j]\\nSAME AS case(1)\\n\\nsub-case #2: matrix[j][i]\\nSAME AS case(1)\\n\\nsub-case #3: matrix[i][j] and matrix[j][j] (*remind (a==c and b==d), or (a==d and b==c))\\n\\nIn this case, the problem could be counted as drawing two balls from two pockets which has matrix[i][j], matrix[j][i] balls each.\\n\\nSUM UP ALL THE ANSWERS FROM case(1) and case (2), then you can get the final result.\\n\\n```\\nclass Solution {\\npublic:\\n    int numEquivDominoPairs(vector<vector<int>>& dominoes) {\\n        int mat[9][9] = {0,};\\n        int result = 0;\\n        \\n        // init matrix\\n        for(unsigned int i = 0; i < dominoes.size(); i++){\\n            mat[dominoes[i][0] - 1][dominoes[i][1] - 1]++;\\n        }\\n        \\n        // search till diagonal element\\n        for(int i = 0; i < 9; i++){\\n            for(int j = 0; j <= i; j++){\\n\\t\\t\\t\\t// diagonal element case\\n                if(i==j){\\n                    if(mat[i][j] > 1)\\n                       result += (mat[i][j] * (mat[i][j] - 1)) / 2; // combination\\n                }\\n                else{\\n\\t\\t\\t\\t\\t// only from [i, j] cases \\n                    if(mat[i][j] > 1)\\n                        result += (mat[i][j] * (mat[i][j] - 1)) / 2; // combination\\n                    // only from [j, i] cases\\n                    if(mat[j][i] > 1)    \\n                        result += (mat[j][i] * (mat[j][i] - 1)) / 2; // combination\\n                    // from both\\n                    result += (mat[i][j] * mat[j][i]); // permutation\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```\\n\\nTHANK YOU.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numEquivDominoPairs(vector<vector<int>>& dominoes) {\\n        int mat[9][9] = {0,};\\n        int result = 0;\\n        \\n        // init matrix\\n        for(unsigned int i = 0; i < dominoes.size(); i++){\\n            mat[dominoes[i][0] - 1][dominoes[i][1] - 1]++;\\n        }\\n        \\n        // search till diagonal element\\n        for(int i = 0; i < 9; i++){\\n            for(int j = 0; j <= i; j++){\\n\\t\\t\\t\\t// diagonal element case\\n                if(i==j){\\n                    if(mat[i][j] > 1)\\n                       result += (mat[i][j] * (mat[i][j] - 1)) / 2; // combination\\n                }\\n                else{\\n\\t\\t\\t\\t\\t// only from [i, j] cases \\n                    if(mat[i][j] > 1)\\n                        result += (mat[i][j] * (mat[i][j] - 1)) / 2; // combination\\n                    // only from [j, i] cases\\n                    if(mat[j][i] > 1)    \\n                        result += (mat[j][i] * (mat[j][i] - 1)) / 2; // combination\\n                    // from both\\n                    result += (mat[i][j] * mat[j][i]); // permutation\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 354445,
                "title": "share-my-python3-solution-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        if not dominoes:\\n            return 0\\n        res = 0\\n        help_map = {}\\n        for x, y in dominoes:\\n            if x > y:\\n                x, y = y, x\\n            temp = (x, y)\\n            if temp in help_map:\\n                res += help_map[temp]\\n                help_map[temp] += 1\\n            else:\\n                help_map[temp] = 1\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        if not dominoes:\\n            return 0\\n        res = 0\\n        help_map = {}\\n        for x, y in dominoes:\\n            if x > y:\\n                x, y = y, x\\n            temp = (x, y)\\n            if temp in help_map:\\n                res += help_map[temp]\\n                help_map[temp] += 1\\n            else:\\n                help_map[temp] = 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 340894,
                "title": "js-o-n-time-and-o-1-space",
                "content": "```\\nconst numEquivDominoPairs = dominoes => {\\n    let occur = Array.from(Array(10), () => Array(10).fill(0));\\n    \\n    for (let [a, b] of dominoes) {\\n        let min = Math.min(a, b);\\n        let max = Math.max(a, b);\\n        \\n        occur[min][max] += 1;\\n    }\\n    \\n    let cnt = 0;\\n    for (let i = 0; i <= 9; i++) {\\n        for (let j = 0; j <= 9; j++) {\\n            let o = Math.max(0, occur[i][j] - 1);        \\n            cnt += (o * (o + 1)) / 2;\\n        }\\n    }\\n    \\n    return cnt;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nconst numEquivDominoPairs = dominoes => {\\n    let occur = Array.from(Array(10), () => Array(10).fill(0));\\n    \\n    for (let [a, b] of dominoes) {\\n        let min = Math.min(a, b);\\n        let max = Math.max(a, b);\\n        \\n        occur[min][max] += 1;\\n    }\\n    \\n    let cnt = 0;\\n    for (let i = 0; i <= 9; i++) {\\n        for (let j = 0; j <= 9; j++) {\\n            let o = Math.max(0, occur[i][j] - 1);        \\n            cnt += (o * (o + 1)) / 2;\\n        }\\n    }\\n    \\n    return cnt;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 340372,
                "title": "javascript-solution-with-explanation",
                "content": "2 steps:\\n1. create a hashmap to record how many times each domino appears\\n2. if n dominos (n>1), how many combinations can they make? use `n*(n-1)/2)`\\n\\n```\\nvar numEquivDominoPairs = function(dominoes) {\\n    let map = {};\\n    dominoes.forEach(p => {\\n        const [s,b] = p.sort();\\n        const n = s*10 + b;\\n        if(!map[n]) map[n] = 0;\\n        map[n]++;\\n    });\\n    \\n    return Object.values(map).reduce((res, ct) => res += ct>1 ? ct*(ct-1)/2 : 0, 0);\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar numEquivDominoPairs = function(dominoes) {\\n    let map = {};\\n    dominoes.forEach(p => {\\n        const [s,b] = p.sort();\\n        const n = s*10 + b;\\n        if(!map[n]) map[n] = 0;\\n        map[n]++;\\n    });\\n    \\n    return Object.values(map).reduce((res, ct) => res += ct>1 ? ct*(ct-1)/2 : 0, 0);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 340322,
                "title": "java-solution-using-hashmap",
                "content": "```\\nclass Solution {\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        Map<String, Integer> map = new HashMap<>();\\n        int res = 0;\\n        for (int[] domino : dominoes) {\\n            StringBuilder sb = new StringBuilder();\\n            if (domino[0] < domino[1]) {\\n                sb.append(domino[0] + \",\" + domino[1]);\\n            } else {\\n                sb.append(domino[1] + \",\" + domino[0]);\\n            }\\n            if (map.containsKey(sb.toString())) res += map.get(sb.toString());\\n            map.put(sb.toString(), map.getOrDefault(sb.toString(), 0) + 1);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        Map<String, Integer> map = new HashMap<>();\\n        int res = 0;\\n        for (int[] domino : dominoes) {\\n            StringBuilder sb = new StringBuilder();\\n            if (domino[0] < domino[1]) {\\n                sb.append(domino[0] + \",\" + domino[1]);\\n            } else {\\n                sb.append(domino[1] + \",\" + domino[0]);\\n            }\\n            if (map.containsKey(sb.toString())) res += map.get(sb.toString());\\n            map.put(sb.toString(), map.getOrDefault(sb.toString(), 0) + 1);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 340009,
                "title": "java-simple-with-combination",
                "content": "1) To make unique key and avoid dublication with keys \\nhave done this\\n`(Math.min(d[0], d[1]) * 1000 + Math.max(d[0], d[1]))`\\n2) To get all Combination of Domino \\n` n!(r!(n\\u2212r)!)`\\nsince our r =2 always\\n`n*(n-1)/2`\\n\\n\\n\\t\\t\\n\\t\\tMap<Long, Integer> map = new HashMap<>();\\n\\t\\tfor(int[] d : dominoes){\\n\\t\\t\\tlong key = (Math.min(d[0], d[1]) * 1000 + Math.max(d[0], d[1]));\\n\\t\\t\\tif(!map.containsKey(key)){\\n\\t\\t\\t\\tmap.put(key, 0);\\n\\t\\t\\t}\\n\\t\\t\\tmap.put(key, map.get(key) + 1);\\n\\t\\t}\\n\\t\\tint ret = 0;\\n\\t\\tfor(int v : map.values()){\\n\\t\\t\\tret += v*(v-1)/2;\\n\\t\\t}\\n\\t\\treturn ret;",
                "solutionTags": [
                    "Java",
                    "Combinatorics"
                ],
                "code": "1) To make unique key and avoid dublication with keys \\nhave done this\\n`(Math.min(d[0], d[1]) * 1000 + Math.max(d[0], d[1]))`\\n2) To get all Combination of Domino \\n` n!(r!(n\\u2212r)!)`\\nsince our r =2 always\\n`n*(n-1)/2`\\n\\n\\n\\t\\t\\n\\t\\tMap<Long, Integer> map = new HashMap<>();\\n\\t\\tfor(int[] d : dominoes){\\n\\t\\t\\tlong key = (Math.min(d[0], d[1]) * 1000 + Math.max(d[0], d[1]));\\n\\t\\t\\tif(!map.containsKey(key)){\\n\\t\\t\\t\\tmap.put(key, 0);\\n\\t\\t\\t}\\n\\t\\t\\tmap.put(key, map.get(key) + 1);\\n\\t\\t}\\n\\t\\tint ret = 0;\\n\\t\\tfor(int v : map.values()){\\n\\t\\t\\tret += v*(v-1)/2;\\n\\t\\t}\\n\\t\\treturn ret;",
                "codeTag": "Unknown"
            },
            {
                "id": 3959061,
                "title": "2328-ms-in-tc",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        int count=0;\\n        for(int i =0;i<dominoes.length-1;i++){\\n       \\n                for(int k =i+1;k<dominoes.length;k++){\\n                 \\n                        if((dominoes[i][0] == dominoes[k][0] && dominoes[i][1] == dominoes[k][1]) || (dominoes[i][1] == dominoes[k][0] && dominoes[i][0] == dominoes[k][1]))\\n                        count++;\\n                    \\n                }\\n            \\n            \\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        int count=0;\\n        for(int i =0;i<dominoes.length-1;i++){\\n       \\n                for(int k =i+1;k<dominoes.length;k++){\\n                 \\n                        if((dominoes[i][0] == dominoes[k][0] && dominoes[i][1] == dominoes[k][1]) || (dominoes[i][1] == dominoes[k][0] && dominoes[i][0] == dominoes[k][1]))\\n                        count++;\\n                    \\n                }\\n            \\n            \\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3863991,
                "title": "java-solution-without-using-hashing-direct-solution-using-java",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        int count=0;\\n       for(int i=0;i<dominoes.length-1;i++){\\n           int one=dominoes[i][0];\\n           int second=dominoes[i][1];\\n           for(int j=i+1;j<dominoes.length;j++){\\n               int check1=dominoes[j][0];\\n               int check2=dominoes[j][1];\\n               if(one==check1){\\n                   if(second==check2){\\n                       count+=1;\\n                   }\\n               }\\n               else if(one==check2){\\n                   if(second==check1){\\n                       count+=1;\\n                   }\\n               }\\n           }\\n       }\\nreturn count;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        int count=0;\\n       for(int i=0;i<dominoes.length-1;i++){\\n           int one=dominoes[i][0];\\n           int second=dominoes[i][1];\\n           for(int j=i+1;j<dominoes.length;j++){\\n               int check1=dominoes[j][0];\\n               int check2=dominoes[j][1];\\n               if(one==check1){\\n                   if(second==check2){\\n                       count+=1;\\n                   }\\n               }\\n               else if(one==check2){\\n                   if(second==check1){\\n                       count+=1;\\n                   }\\n               }\\n           }\\n       }\\nreturn count;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3788589,
                "title": "easy-c-solution-hash-table-approach-with-explanation-beats-90-in-both",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numEquivDominoPairs(vector<vector<int>>& dominoes) {\\n        map<pair<int, int>, int> mp;\\n        for (auto& d : dominoes) {\\n            if (d[0] > d[1]) \\n                swap(d[0], d[1]); // We swap the numbers so that [1,2] and [2,1] can be counted together as [1,2]\\n            mp[{d[0], d[1]}]++;\\n        }\\n        int ans = 0;\\n        for (auto& m : mp)\\n            ans += m.second * (m.second - 1) / 2; // Formula for sum of first n-1 numbers\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numEquivDominoPairs(vector<vector<int>>& dominoes) {\\n        map<pair<int, int>, int> mp;\\n        for (auto& d : dominoes) {\\n            if (d[0] > d[1]) \\n                swap(d[0], d[1]); // We swap the numbers so that [1,2] and [2,1] can be counted together as [1,2]\\n            mp[{d[0], d[1]}]++;\\n        }\\n        int ans = 0;\\n        for (auto& m : mp)\\n            ans += m.second * (m.second - 1) / 2; // Formula for sum of first n-1 numbers\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3621111,
                "title": "java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int numEquivDominoPairs(int[][] dom) {\\n        int  count=0;\\n        HashMap<String,Integer>map=new HashMap<>();\\n        int i=0;\\n        int n=dom.length;\\n        while(i<n){\\n            String temp=\"\";\\n            if(dom[i][0]>dom[i][1]){\\n                temp+=dom[i][1];\\n                temp+=dom[i][0];\\n            }else{\\n                temp+=dom[i][0];\\n                temp+=dom[i][1];\\n            }\\n            if(map.containsKey(temp))count+=map.get(temp);\\n            map.put(temp,map.getOrDefault(temp,0)+1);\\n            i++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numEquivDominoPairs(int[][] dom) {\\n        int  count=0;\\n        HashMap<String,Integer>map=new HashMap<>();\\n        int i=0;\\n        int n=dom.length;\\n        while(i<n){\\n            String temp=\"\";\\n            if(dom[i][0]>dom[i][1]){\\n                temp+=dom[i][1];\\n                temp+=dom[i][0];\\n            }else{\\n                temp+=dom[i][0];\\n                temp+=dom[i][1];\\n            }\\n            if(map.containsKey(temp))count+=map.get(temp);\\n            map.put(temp,map.getOrDefault(temp,0)+1);\\n            i++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3096524,
                "title": "easy-java-solution",
                "content": "\\n```\\nclass Solution {\\n    public int numEquivDominoPairs(int[][] dom) {\\n        int  count=0;\\n        HashMap<String,Integer>map=new HashMap<>();\\n        int i=0;\\n        int n=dom.length;\\n        while(i<n){\\n            String temp=\"\";\\n            if(dom[i][0]>dom[i][1]){\\n                temp+=dom[i][1];\\n                temp+=dom[i][0];\\n            }else{\\n                temp+=dom[i][0];\\n                temp+=dom[i][1];\\n            }\\n            if(map.containsKey(temp))count+=map.get(temp);\\n            map.put(temp,map.getOrDefault(temp,0)+1);\\n            i++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public int numEquivDominoPairs(int[][] dom) {\\n        int  count=0;\\n        HashMap<String,Integer>map=new HashMap<>();\\n        int i=0;\\n        int n=dom.length;\\n        while(i<n){\\n            String temp=\"\";\\n            if(dom[i][0]>dom[i][1]){\\n                temp+=dom[i][1];\\n                temp+=dom[i][0];\\n            }else{\\n                temp+=dom[i][0];\\n                temp+=dom[i][1];\\n            }\\n            if(map.containsKey(temp))count+=map.get(temp);\\n            map.put(temp,map.getOrDefault(temp,0)+1);\\n            i++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2641954,
                "title": "js-very-easy-solution-o-n-with-hashmap",
                "content": "```\\nvar numEquivDominoPairs = function(dominoes) {\\n    let output = 0;\\n    const hashmap = new Map();\\n    \\n    for (let i = 0 ; i < dominoes.length; i++) {\\n        const key = dominoes[i].toString();\\n        const reverseKey = dominoes[i].reverse().toString();\\n\\n        output += (hashmap.get(key) || 0) + (hashmap.has(reverseKey) && key !== reverseKey ? hashmap.get(reverseKey) : 0);\\n        \\n        \\n        if (!hashmap.has(key)) {\\n            hashmap.set(key, 1);\\n        } else {\\n            hashmap.set(key, hashmap.get(key) + 1);\\n        }\\n    }\\n    \\n    return output;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar numEquivDominoPairs = function(dominoes) {\\n    let output = 0;\\n    const hashmap = new Map();\\n    \\n    for (let i = 0 ; i < dominoes.length; i++) {\\n        const key = dominoes[i].toString();\\n        const reverseKey = dominoes[i].reverse().toString();\\n\\n        output += (hashmap.get(key) || 0) + (hashmap.has(reverseKey) && key !== reverseKey ? hashmap.get(reverseKey) : 0);\\n        \\n        \\n        if (!hashmap.has(key)) {\\n            hashmap.set(key, 1);\\n        } else {\\n            hashmap.set(key, hashmap.get(key) + 1);\\n        }\\n    }\\n    \\n    return output;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2499940,
                "title": "c-solution-using-map",
                "content": "\\tint numEquivDominoPairs(vector<vector<int>>& dominoes) {\\n        map<pair<int , int> , int > m;\\n        int cnt = 0;\\n        for(vector v : dominoes){\\n            int a = v[0] ,b = v[1];\\n            if(a > b) swap(a , b);\\n            if(m[{a , b}]) cnt += m[{a , b}];\\n            m[{a , b}]++;\\n        }\\n        return cnt;\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "\\tint numEquivDominoPairs(vector<vector<int>>& dominoes) {\\n        map<pair<int , int> , int > m;\\n        int cnt = 0;\\n        for(vector v : dominoes){\\n            int a = v[0] ,b = v[1];\\n            if(a > b) swap(a , b);\\n            if(m[{a , b}]) cnt += m[{a , b}];\\n            m[{a , b}]++;\\n        }\\n        return cnt;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2191418,
                "title": "easy-to-uderstand-brute-force-c",
                "content": "class Solution {\\npublic:\\n    int numEquivDominoPairs(vector<vector<int>>& dominoes) {\\n        int result=0;\\n       for(int i=0;i<dominoes.size();i++)\\n           sort(dominoes[i].begin(),dominoes[i].end());\\n        map<vector<int>,int> m;\\n        for(int i=0;i<dominoes.size();i++)\\n            m[dominoes[i]]++;\\n        for(auto x:m)\\n            result+=x.second*(x.second-1)/2;\\n        return result;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int numEquivDominoPairs(vector<vector<int>>& dominoes) {\\n        int result=0;\\n       for(int i=0;i<dominoes.size();i++)\\n           sort(dominoes[i].begin(),dominoes[i].end());\\n        map<vector<int>,int> m;\\n        for(int i=0;i<dominoes.size();i++)\\n            m[dominoes[i]]++;\\n        for(auto x:m)\\n            result+=x.second*(x.second-1)/2;\\n        return result;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2176290,
                "title": "o-n-time-o-1-space-python-easy",
                "content": "since l is 9*9 array only 81 bit space used\\n\\n```\\nclass Solution:\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        l=[[0]*9 for _ in range(10)]\\n        c=0\\n        for i in dominoes:\\n            if(i[0]<i[1]):\\n                c+=l[i[0]-1][i[1]-1]\\n                l[i[0]-1][i[1]-1]+=1\\n            else:\\n                c+=l[i[1]-1][i[0]-1]\\n                l[i[1]-1][i[0]-1]+=1\\n        return c\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        l=[[0]*9 for _ in range(10)]\\n        c=0\\n        for i in dominoes:\\n            if(i[0]<i[1]):\\n                c+=l[i[0]-1][i[1]-1]\\n                l[i[0]-1][i[1]-1]+=1\\n            else:\\n                c+=l[i[1]-1][i[0]-1]\\n                l[i[1]-1][i[0]-1]+=1\\n        return c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2158866,
                "title": "simple-python-solution",
                "content": "```\\nimport math\\nclass Solution:\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        d=dict()\\n        for i in dominoes:\\n            i.sort()            #Just to make everything equal and comparable\\n            if(tuple(i) in d.keys()):   #In python, lists are unhashable so converted the list into tuples\\n                d[tuple(i)]+=1\\n            else:\\n                d[tuple(i)]=1\\n        count=0\\n        for x,y in d.items():\\n            if(y>1):\\n\\t\\t\\t\\tcount+=y*(y-1)//2        #To check the number of pairs, if 2 elements pairs is 1,if 3 pair is 3 and so                                                                     on.....formula is n*n-1/2\\n        return count\\n                \\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Combinatorics"
                ],
                "code": "```\\nimport math\\nclass Solution:\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        d=dict()\\n        for i in dominoes:\\n            i.sort()            #Just to make everything equal and comparable\\n            if(tuple(i) in d.keys()):   #In python, lists are unhashable so converted the list into tuples\\n                d[tuple(i)]+=1\\n            else:\\n                d[tuple(i)]=1\\n        count=0\\n        for x,y in d.items():\\n            if(y>1):\\n\\t\\t\\t\\tcount+=y*(y-1)//2        #To check the number of pairs, if 2 elements pairs is 1,if 3 pair is 3 and so                                                                     on.....formula is n*n-1/2\\n        return count\\n                \\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2136036,
                "title": "c-solution-based-on-map",
                "content": "```\\nclass Solution {\\npublic:\\n    int numEquivDominoPairs(vector<vector<int>>& dominoes) {\\n        map<pair<int, int>, int> records;\\n        for (int i = 0; i < dominoes.size(); i++){\\n            sort(dominoes[i].begin(), dominoes[i].end());\\n            int a = dominoes[i][0], b = dominoes[i][1];\\n            if (records.count({a, b}) == 0){\\n                records.insert({{a, b}, 1});\\n            }\\n            else{\\n                records[{a, b}]++;\\n            }\\n        }\\n        int result = 0;\\n        for (auto it=records.begin(); it!=records.end(); it++){\\n            // it->second\\n            int n = it->second;\\n            result += (n - 1) * n / 2;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numEquivDominoPairs(vector<vector<int>>& dominoes) {\\n        map<pair<int, int>, int> records;\\n        for (int i = 0; i < dominoes.size(); i++){\\n            sort(dominoes[i].begin(), dominoes[i].end());\\n            int a = dominoes[i][0], b = dominoes[i][1];\\n            if (records.count({a, b}) == 0){\\n                records.insert({{a, b}, 1});\\n            }\\n            else{\\n                records[{a, b}]++;\\n            }\\n        }\\n        int result = 0;\\n        for (auto it=records.begin(); it!=records.end(); it++){\\n            // it->second\\n            int n = it->second;\\n            result += (n - 1) * n / 2;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2081480,
                "title": "java-solution",
                "content": "```java\\nclass Solution {\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        int[][] mat = new int[9][9];\\n        \\n        for(int i=0;i<dominoes.length;i++)\\n        {\\n            if(dominoes[i][0]!=dominoes[i][1])\\n            {\\n            mat[dominoes[i][0]-1][dominoes[i][1]-1]++;\\n            mat[dominoes[i][1]-1][dominoes[i][0]-1]++;\\n            }\\n            else\\n            {\\n                mat[dominoes[i][0]-1][dominoes[i][1]-1]++;\\n            }\\n        }\\n        int c=0;\\n        for(int i=0;i<9;i++)\\n        {\\n            for(int j=i;j<9;j++)\\n            {\\n                c+=sum(mat[i][j]-1);\\n            }\\n        }\\n        return c;\\n    }\\n    \\n    private int sum(int n)\\n    {\\n       return (n*(n+1))/2;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        int[][] mat = new int[9][9];\\n        \\n        for(int i=0;i<dominoes.length;i++)\\n        {\\n            if(dominoes[i][0]!=dominoes[i][1])\\n            {\\n            mat[dominoes[i][0]-1][dominoes[i][1]-1]++;\\n            mat[dominoes[i][1]-1][dominoes[i][0]-1]++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2013314,
                "title": "super-clear-illustrated-explanation",
                "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/bef0b639-52a1-49f5-9ba5-72db5f7e41c7_1651830320.6071334.png)\\n\\n\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        \"\"\" O(N)TS \"\"\"\\n        d = collections.Counter(map(frozenset, dominoes))\\n        return sum(math.comb(v, 2) for v in d.values())",
                "solutionTags": [],
                "code": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/bef0b639-52a1-49f5-9ba5-72db5f7e41c7_1651830320.6071334.png)\\n\\n\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        \"\"\" O(N)TS \"\"\"\\n        d = collections.Counter(map(frozenset, dominoes))\\n        return sum(math.comb(v, 2) for v in d.values())",
                "codeTag": "Python3"
            },
            {
                "id": 2001242,
                "title": "java-5-lines-of-code-faster-than-99-19",
                "content": "```\\npublic int numEquivDominoPairs(int[][] dominoes) {\\n\\tint[] counts = new int[100];\\n\\tint ans = 0;\\n\\tfor (int[] d : dominoes)\\n\\t\\tans += counts[Math.min(d[0], d[1])*10 + Math.max(d[0], d[1])]++;\\n\\treturn ans;\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\npublic int numEquivDominoPairs(int[][] dominoes) {\\n\\tint[] counts = new int[100];\\n\\tint ans = 0;\\n\\tfor (int[] d : dominoes)\\n\\t\\tans += counts[Math.min(d[0], d[1])*10 + Math.max(d[0], d[1])]++;\\n\\treturn ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1937753,
                "title": "c",
                "content": "```\\n    public int NumEquivDominoPairs(int[][] dominoes) {\\n        \\n        List<string> temp = new List<string>();\\n\\n        for(int i=0; i< dominoes.Length; i++)\\n        {\\n            Array.Sort(dominoes[i]);\\n            temp.Add(string.Join(\"\", dominoes[i]));\\n        }\\n\\n        return temp.GroupBy(x => x).Where(x => x.Count() != 1).Select( x=>x.Count() * (x.Count() - 1) / 2 ).Sum();\\n        \\n    }",
                "solutionTags": [],
                "code": "```\\n    public int NumEquivDominoPairs(int[][] dominoes) {\\n        \\n        List<string> temp = new List<string>();\\n\\n        for(int i=0; i< dominoes.Length; i++)\\n        {\\n            Array.Sort(dominoes[i]);\\n            temp.Add(string.Join(\"\", dominoes[i]));\\n        }\\n\\n        return temp.GroupBy(x => x).Where(x => x.Count() != 1).Select( x=>x.Count() * (x.Count() - 1) / 2 ).Sum();\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1901650,
                "title": "java-2ms-math-explanations",
                "content": "```\\nclass Solution {\\n    /** Algorithm\\n        1. Brute force cannot be used because of the set size.\\n        2. Traverse the dominos and group & count them by min-max value.\\n           As pieces can be from 1 to 9, means their groups will be from 11 to 99.\\n            eg: [1,2] will be the same as [2,1]. Their value is 10 * (min(1,2)) + max(1,2)\\n                => 10 * 1 + 2 = 12.\\n            so pieces[12]++;\\n        3. After finishing traversing, iterate over the counted pieces and if the count is\\n          > 1, calculate the combinations of X by 2.\\n        4. The formula is n!/ (k! * (n-k)!)\\n           As n! can be very large, use the short version of it; (n * (n-1)) / 2. EG n= 40\\n           Eg:  40!         simplify this(divide by 38!) 39 * 40\\n              --------                                  ---------   \\n               2! * (38!)                                   2\\n        5. Return the total result      \\n    */\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        int[] pieces = new int[100];\\n        for (int[] domino : dominoes) {\\n            pieces[10 * Math.min(domino[0], domino[1]) + Math.max(domino[0], domino[1])]++;\\n        }\\n        int pairs = 0;\\n        for (int i = 11; i <= 99; i++) {\\n            if (pieces[i] > 1) {\\n                pairs += getCombinations(pieces[i]);\\n            }\\n        }\\n        \\n        return pairs;    \\n    }\\n    \\n    private int getCombinations(int n) {\\n        return (n * (n-1)) / 2;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    /** Algorithm\\n        1. Brute force cannot be used because of the set size.\\n        2. Traverse the dominos and group & count them by min-max value.\\n           As pieces can be from 1 to 9, means their groups will be from 11 to 99.\\n            eg: [1,2] will be the same as [2,1]. Their value is 10 * (min(1,2)) + max(1,2)\\n                => 10 * 1 + 2 = 12.\\n            so pieces[12]++;\\n        3. After finishing traversing, iterate over the counted pieces and if the count is\\n          > 1, calculate the combinations of X by 2.\\n        4. The formula is n!/ (k! * (n-k)!)\\n           As n! can be very large, use the short version of it; (n * (n-1)) / 2. EG n= 40\\n           Eg:  40!         simplify this(divide by 38!) 39 * 40\\n              --------                                  ---------   \\n               2! * (38!)                                   2\\n        5. Return the total result      \\n    */\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        int[] pieces = new int[100];\\n        for (int[] domino : dominoes) {\\n            pieces[10 * Math.min(domino[0], domino[1]) + Math.max(domino[0], domino[1])]++;\\n        }\\n        int pairs = 0;\\n        for (int i = 11; i <= 99; i++) {\\n            if (pieces[i] > 1) {\\n                pairs += getCombinations(pieces[i]);\\n            }\\n        }\\n        \\n        return pairs;    \\n    }\\n    \\n    private int getCombinations(int n) {\\n        return (n * (n-1)) / 2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1881671,
                "title": "c-java-dictionary-hashmap-solution",
                "content": "**Implementation**\\n* C#\\n```\\npublic class Solution {\\n    public int NumEquivDominoPairs(int[][] dominoes) {\\n        \\n        if(dominoes == null || dominoes.Length == 0)\\n            throw new ArgumentException(\"Invalid Input.\");\\n        \\n        int res = 0;\\n        Dictionary<string,int> dic = new Dictionary<string,int>();\\n\\n        foreach(var pair in dominoes)\\n        {\\n            string key = Math.Min(pair[0], pair[1]) + \"-\" + Math.Max(pair[0], pair[1]);  \\n            int cnt = dic.GetValueOrDefault(key,0);\\n            res += cnt;\\n            dic[key] = cnt + 1;\\n        }\\n        \\n        return res;\\n    }\\n}\\n```\\n* Java\\n```\\nclass Solution {\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        \\n        Map<String,Integer> map = new HashMap<String,Integer>();\\n        \\n        int res = 0; \\n        for(var pair : dominoes)\\n        {\\n            String key = Math.min(pair[0], pair[1]) + \"-\" + Math.max(pair[0], pair[1]);  \\n            int cnt = map.getOrDefault(key, 0);\\n            res += cnt;\\n            map.put(key, cnt + 1);\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int NumEquivDominoPairs(int[][] dominoes) {\\n        \\n        if(dominoes == null || dominoes.Length == 0)\\n            throw new ArgumentException(\"Invalid Input.\");\\n        \\n        int res = 0;\\n        Dictionary<string,int> dic = new Dictionary<string,int>();\\n\\n        foreach(var pair in dominoes)\\n        {\\n            string key = Math.Min(pair[0], pair[1]) + \"-\" + Math.Max(pair[0], pair[1]);  \\n            int cnt = dic.GetValueOrDefault(key,0);\\n            res += cnt;\\n            dic[key] = cnt + 1;\\n        }\\n        \\n        return res;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        \\n        Map<String,Integer> map = new HashMap<String,Integer>();\\n        \\n        int res = 0; \\n        for(var pair : dominoes)\\n        {\\n            String key = Math.min(pair[0], pair[1]) + \"-\" + Math.max(pair[0], pair[1]);  \\n            int cnt = map.getOrDefault(key, 0);\\n            res += cnt;\\n            map.put(key, cnt + 1);\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1833075,
                "title": "faster-than-89-memory-usage-less-than-90-c-solution",
                "content": "```\\n int numEquivDominoPairs(vector<vector<int>>& d) {\\n        map<pair<int,int>,int> m;\\n        map<pair<int,int>,int>::iterator itr;\\n        int c=0;\\n        for(int i=0;i<d.size();i++)\\n        {\\n            pair<int,int> p;\\n           p.first=min(d[i][0],d[i][1]);\\n            p.second=max(d[i][1],d[i][0]);\\n            m[p]++;\\n                \\n        }\\n        for(itr=m.begin();itr!=m.end();itr++)\\n        {\\n            int n=itr->second*(itr->second-1);\\n            n=n/2;\\n            c+=n;\\n        }\\n        return c;\\n        \\n    }\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n int numEquivDominoPairs(vector<vector<int>>& d) {\\n        map<pair<int,int>,int> m;\\n        map<pair<int,int>,int>::iterator itr;\\n        int c=0;\\n        for(int i=0;i<d.size();i++)\\n        {\\n            pair<int,int> p;\\n           p.first=min(d[i][0],d[i][1]);\\n            p.second=max(d[i][1],d[i][0]);\\n            m[p]++;\\n                \\n        }\\n        for(itr=m.begin();itr!=m.end();itr++)\\n        {\\n            int n=itr->second*(itr->second-1);\\n            n=n/2;\\n            c+=n;\\n        }\\n        return c;\\n        \\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1811069,
                "title": "3-lines-python-solution-75-faster-memory-less-than-60",
                "content": "```\\nclass Solution:\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        counter = defaultdict(int)\\n        for domino in dominoes: counter[tuple(sorted(domino))] +=1\\n        return sum([n*(n-1)//2 for n in counter.values()])\\n```\\n-------------------\\n***----- Taha Choura -----***\\n*taha.choura@outlook.com*",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        counter = defaultdict(int)\\n        for domino in dominoes: counter[tuple(sorted(domino))] +=1\\n        return sum([n*(n-1)//2 for n in counter.values()])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1759360,
                "title": "java-3-liner-hashing-explained",
                "content": "**Idea:** Sort the dominoes and count the number of pairs using nC2 formula = n(n - 1) / 2\\n>**T/S:** O(n)/O(n), where n = size(dominoes)\\n```\\npublic int numEquivDominoPairs(int[][] dominoes) {\\n\\tvar dominoToCount = new HashMap<List<Integer>, Integer>();\\n\\tfor (var domino : dominoes)\\n\\t\\tdominoToCount.compute(List.of(Math.min(domino[0], domino[1]), \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t  Math.max(domino[0], domino[1])), \\n\\t\\t\\t\\t\\t\\t\\t  (k, v) -> v == null ? 1 : v + 1);\\n\\tvar pairs = 0;\\n\\tfor (var count : dominoToCount.values())\\n\\t\\tpairs += count * (count - 1) / 2;\\n\\treturn pairs;\\n}\\n```\\n**Version 2:** 3 liner stream version\\n```\\npublic int numEquivDominoPairs(int[][] dominoes) {\\n\\tvar dominoToCount = new HashMap<List<Integer>, Integer>();\\n\\tArrays.stream(dominoes)\\n\\t\\t  .forEach(domino -> dominoToCount.compute(List.of(Math.min(domino[0], domino[1]), \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   Math.max(domino[0], domino[1])), \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   (k, v) -> v == null ? 1 : v + 1));\\n\\treturn dominoToCount.values()\\n\\t\\t\\t\\t\\t\\t.stream()\\n\\t\\t\\t\\t\\t\\t.mapToInt(v -> v * (v - 1) / 2)\\n\\t\\t\\t\\t\\t\\t.sum();\\n}\\n```\\n***Please upvote if this helps***",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int numEquivDominoPairs(int[][] dominoes) {\\n\\tvar dominoToCount = new HashMap<List<Integer>, Integer>();\\n\\tfor (var domino : dominoes)\\n\\t\\tdominoToCount.compute(List.of(Math.min(domino[0], domino[1]), \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t  Math.max(domino[0], domino[1])), \\n\\t\\t\\t\\t\\t\\t\\t  (k, v) -> v == null ? 1 : v + 1);\\n\\tvar pairs = 0;\\n\\tfor (var count : dominoToCount.values())\\n\\t\\tpairs += count * (count - 1) / 2;\\n\\treturn pairs;\\n}\\n```\n```\\npublic int numEquivDominoPairs(int[][] dominoes) {\\n\\tvar dominoToCount = new HashMap<List<Integer>, Integer>();\\n\\tArrays.stream(dominoes)\\n\\t\\t  .forEach(domino -> dominoToCount.compute(List.of(Math.min(domino[0], domino[1]), \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   Math.max(domino[0], domino[1])), \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   (k, v) -> v == null ? 1 : v + 1));\\n\\treturn dominoToCount.values()\\n\\t\\t\\t\\t\\t\\t.stream()\\n\\t\\t\\t\\t\\t\\t.mapToInt(v -> v * (v - 1) / 2)\\n\\t\\t\\t\\t\\t\\t.sum();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1722329,
                "title": "c-easy-to-understand-simple-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int numEquivDominoPairs(vector<vector<int>>& d) {\\n        int n=d.size();\\n        map<vector<int>,int> freq;\\n        for(int i=0;i<n;i++)\\n        {\\n            vector<int> ele=d[i];\\n            if(ele[0]<ele[1])\\n            {\\n                swap(ele[0],ele[1]);\\n            }\\n            freq[ele]++;\\n        }\\n        int ans=0;\\n        for(auto pr:freq)\\n        {\\n            if(pr.second>1)\\n            {\\n                int x=pr.second;\\n                ans+=(x*(x-1)/2);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numEquivDominoPairs(vector<vector<int>>& d) {\\n        int n=d.size();\\n        map<vector<int>,int> freq;\\n        for(int i=0;i<n;i++)\\n        {\\n            vector<int> ele=d[i];\\n            if(ele[0]<ele[1])\\n            {\\n                swap(ele[0],ele[1]);\\n            }\\n            freq[ele]++;\\n        }\\n        int ans=0;\\n        for(auto pr:freq)\\n        {\\n            if(pr.second>1)\\n            {\\n                int x=pr.second;\\n                ans+=(x*(x-1)/2);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1578746,
                "title": "c-90-time-91-space-map-sum-of-natural-numbers",
                "content": "```\\nint sum(int n){\\n\\treturn (n * (n+1)) / 2;\\n}\\nclass Solution {\\npublic:\\n    int numEquivDominoPairs(vector<vector<int>>& arr) {\\n        map<pair<int,int>,int>m;\\n        int summation=0;\\n        for(int i=0;i<arr.size();i++){\\n         \\n            int a=min(arr[i][0],arr[i][1]);\\n            int b=max(arr[i][0],arr[i][1]);\\n           m[{a,b}]++;  \\n        }\\n        for(auto i:m){\\n            summation+=sum(i.second-1);\\n        }\\n        return summation;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nint sum(int n){\\n\\treturn (n * (n+1)) / 2;\\n}\\nclass Solution {\\npublic:\\n    int numEquivDominoPairs(vector<vector<int>>& arr) {\\n        map<pair<int,int>,int>m;\\n        int summation=0;\\n        for(int i=0;i<arr.size();i++){\\n         \\n            int a=min(arr[i][0],arr[i][1]);\\n            int b=max(arr[i][0],arr[i][1]);\\n           m[{a,b}]++;  \\n        }\\n        for(auto i:m){\\n            summation+=sum(i.second-1);\\n        }\\n        return summation;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1532449,
                "title": "java-explained-2-solutions-o-n-hashmap-explained",
                "content": "Solution 1 : TLE\\n// TC: O(m * m), where m is dominoes.length\\n```\\n class Solution {\\n     public int numEquivDominoPairs(int[][] dominoes) {\\n         int res = 0;\\n        \\n         for(int i = 0; i < dominoes.length - 1; i++) {\\n             for(int j = i + 1; j < dominoes.length; j++) {\\n                 int[] dominoe1 = dominoes[i];\\n                 int[] dominoe2 = dominoes[j];\\n                \\n                 if(dominoe1[0] == dominoe2[0] && dominoe1[1] == dominoe2[1] || dominoe1[0] == dominoe2[1] && dominoe1[1] == dominoe2[0]) {\\n                     res++;\\n                 }\\n             }\\n         }\\n         return res;\\n     }\\n }\\n```\\n\\nSolution 2: \\n// TC: O(m), where m is dominoes.length\\n// SC: O(100), since max value can be 9, so max number that can be formed is 99\\n```\\nclass Solution {\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        int res = 0;\\n        Map<Integer, Integer> map = new HashMap<>(); // this contains the number formed from each elements of a dominoe and its freq (num formed meaning, if domino[i] = [1,2], then we form number 12 ( min(donimoe[0], dominoe[1]) * 10 + max(donimoe[0], dominoe[1])) ) \\n                                                    // we are forming a number like this because we are interested in dominoes where either a == c && b == d OR a == d && b == c (so [1,2] & [2,1] will both form 12 as a number and then freq would be 2 for 12)\\n        \\n        for(int[] dominoe : dominoes) { // read all dominoe from dominoes and form the number out of its values and place in map and find freq of such numbers formed\\n            int number = Math.min(dominoe[0], dominoe[1]) * 10 + Math.max(dominoe[0], dominoe[1]);\\n            map.put(number, map.getOrDefault(number, 0) + 1);\\n        }\\n        \\n        for(int value : map.values()) {\\n            res += value * (value - 1)/2; // n(n-1)/2 find the total combinations from N elements\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n class Solution {\\n     public int numEquivDominoPairs(int[][] dominoes) {\\n         int res = 0;\\n        \\n         for(int i = 0; i < dominoes.length - 1; i++) {\\n             for(int j = i + 1; j < dominoes.length; j++) {\\n                 int[] dominoe1 = dominoes[i];\\n                 int[] dominoe2 = dominoes[j];\\n                \\n                 if(dominoe1[0] == dominoe2[0] && dominoe1[1] == dominoe2[1] || dominoe1[0] == dominoe2[1] && dominoe1[1] == dominoe2[0]) {\\n                     res++;\\n                 }\\n             }\\n         }\\n         return res;\\n     }\\n }\\n```\n```\\nclass Solution {\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        int res = 0;\\n        Map<Integer, Integer> map = new HashMap<>(); // this contains the number formed from each elements of a dominoe and its freq (num formed meaning, if domino[i] = [1,2], then we form number 12 ( min(donimoe[0], dominoe[1]) * 10 + max(donimoe[0], dominoe[1])) ) \\n                                                    // we are forming a number like this because we are interested in dominoes where either a == c && b == d OR a == d && b == c (so [1,2] & [2,1] will both form 12 as a number and then freq would be 2 for 12)\\n        \\n        for(int[] dominoe : dominoes) { // read all dominoe from dominoes and form the number out of its values and place in map and find freq of such numbers formed\\n            int number = Math.min(dominoe[0], dominoe[1]) * 10 + Math.max(dominoe[0], dominoe[1]);\\n            map.put(number, map.getOrDefault(number, 0) + 1);\\n        }\\n        \\n        for(int value : map.values()) {\\n            res += value * (value - 1)/2; // n(n-1)/2 find the total combinations from N elements\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1517620,
                "title": "rust-solution",
                "content": "```\\nimpl Solution {\\n    pub fn num_equiv_domino_pairs(dominoes: Vec<Vec<i32>>) -> i32 {\\n        let mut res = 0;\\n        let mut table = [[0; 9]; 9];\\n        let combinations = |n: i32| -> i32 { (n - 1) * n / 2 };\\n\\n        // construct an upper triangular matrix\\n        dominoes.iter().for_each(|d| {\\n            let (row, col) = match (d[0] - 1, d[1] - 1) {\\n                (a, b) if a < b => (a, b),\\n                (a, b) => (b, a),\\n            };\\n            table[row as usize][col as usize] += 1;\\n        });\\n\\n        // check the elements above the main diagonal of the matrix\\n        for (start_col, row) in table.iter().enumerate() {\\n            for &num in row[start_col..].iter().filter(|&&num| num > 1) {\\n                res += combinations(num);\\n            }\\n        }\\n        res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Combinatorics"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn num_equiv_domino_pairs(dominoes: Vec<Vec<i32>>) -> i32 {\\n        let mut res = 0;\\n        let mut table = [[0; 9]; 9];\\n        let combinations = |n: i32| -> i32 { (n - 1) * n / 2 };\\n\\n        // construct an upper triangular matrix\\n        dominoes.iter().for_each(|d| {\\n            let (row, col) = match (d[0] - 1, d[1] - 1) {\\n                (a, b) if a < b => (a, b),\\n                (a, b) => (b, a),\\n            };\\n            table[row as usize][col as usize] += 1;\\n        });\\n\\n        // check the elements above the main diagonal of the matrix\\n        for (start_col, row) in table.iter().enumerate() {\\n            for &num in row[start_col..].iter().filter(|&&num| num > 1) {\\n                res += combinations(num);\\n            }\\n        }\\n        res\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1439836,
                "title": "python3-nice-hack-to-use-dictionary-faster-than-94",
                "content": "![image](https://assets.leetcode.com/users/images/1095d3ee-7b9e-4bc0-b904-5647a5754eec_1630555519.8157907.png)\\n\\n\\n```\\nclass Solution:\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        \\n        d, c = dict(), 0\\n        for i in dominoes:\\n            if i[0] > i[1]:\\n                i[0], i[1] = i[1], i[0]\\n\\n            if (i[0], i[1]) not in d:\\n                d[(i[0], i[1])] = 1\\n            else:\\n                d[(i[0], i[1])] += 1\\n\\n        for j in d:\\n            if d[j] > 1:\\n                c += d[j] * (d[j] - 1) // 2\\n        return c\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        \\n        d, c = dict(), 0\\n        for i in dominoes:\\n            if i[0] > i[1]:\\n                i[0], i[1] = i[1], i[0]\\n\\n            if (i[0], i[1]) not in d:\\n                d[(i[0], i[1])] = 1\\n            else:\\n                d[(i[0], i[1])] += 1\\n\\n        for j in d:\\n            if d[j] > 1:\\n                c += d[j] * (d[j] - 1) // 2\\n        return c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1408737,
                "title": "python-beats-97-simple",
                "content": "Just count how many pairs, then and add them. During counting, make sure swap the smaller one as first.\\n\\n\\n```\\nclass Solution:\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        pairs = defaultdict(int)\\n        for i, j in dominoes:\\n            s = (i, j) if i <= j else (j, i)\\n            pairs[s] += 1\\n        \\n        ans = 0\\n        for pair in pairs:\\n            if pairs[pair] > 1:\\n                ans += (pairs[pair] * (pairs[pair] - 1)) // 2\\n        \\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        pairs = defaultdict(int)\\n        for i, j in dominoes:\\n            s = (i, j) if i <= j else (j, i)\\n            pairs[s] += 1\\n        \\n        ans = 0\\n        for pair in pairs:\\n            if pairs[pair] > 1:\\n                ans += (pairs[pair] * (pairs[pair] - 1)) // 2\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1386655,
                "title": "faster-than-97-python",
                "content": "```\\nclass Solution:\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        \\n        t = [tuple(sorted(x)) for x in dominoes ]\\n        dic = dict(collections.Counter(t))\\n        count = 0\\n        for key in dic :\\n            count += (dic[key]-1)*(dic[key])//2\\n        return count\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        \\n        t = [tuple(sorted(x)) for x in dominoes ]\\n        dic = dict(collections.Counter(t))\\n        count = 0\\n        for key in dic :\\n            count += (dic[key]-1)*(dic[key])//2\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1383642,
                "title": "java-solution-beats-97-runtime",
                "content": "We use the fact that the dominoes have values in the set [1,9] and create a 2-dimensional array to store all dominoes that we find (making sure that we add values both directions - *corner case*: indices need to be different so that we don\\'t count a domino twice). For example, a domino (1,2) we will increase the values in our matrix at indexes (1,2) and (2,1). \\n\\nAfter passing through all dominoes, we use all values above the first diagonal and calculate a Gauss sum for each element. For example, if the value in the matrix is 5, that means that we found 5 identical dominoes, and that makes the a total of (4 * 5 / 2 = 10) identical pairs.  \\n\\n\\n```\\nclass Solution {\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n\\t\\t// I used len 10 so that I don\\'t have to use mat[pair[0]-1,pair[1]-1]\\n        int len = 10;\\n        int[][] mat = new int[len][len];\\n        int count = 0;\\n        for (int[] pair: dominoes) {\\n            mat[pair[0]][pair[1]]++;\\n            if (pair[0] != pair[1])\\n                mat[pair[1]][pair[0]]++;\\n        }\\n        for (int i = 0; i < len; i++) {\\n            for (int j = i; j < len; j++) {\\n                int current = mat[i][j];\\n                count += (current * (current - 1)) / 2;\\n            }\\n        } \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n\\t\\t// I used len 10 so that I don\\'t have to use mat[pair[0]-1,pair[1]-1]\\n        int len = 10;\\n        int[][] mat = new int[len][len];\\n        int count = 0;\\n        for (int[] pair: dominoes) {\\n            mat[pair[0]][pair[1]]++;\\n            if (pair[0] != pair[1])\\n                mat[pair[1]][pair[0]]++;\\n        }\\n        for (int i = 0; i < len; i++) {\\n            for (int j = i; j < len; j++) {\\n                int current = mat[i][j];\\n                count += (current * (current - 1)) / 2;\\n            }\\n        } \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1355610,
                "title": "go",
                "content": "```\\nfunc numEquivDominoPairs(dominoes [][]int) int {\\n    dict := make(map[[2]int]int)\\n    for _, v := range dominoes {\\n        if v[0] <= v[1] {\\n            dict[[2]int{v[0], v[1]}]++\\n        } else {\\n            dict[[2]int{v[1], v[0]}]++\\n        }\\n    }\\n    res := 0\\n    for _, v := range dict {\\n        res += v * (v - 1) / 2\\n    }\\n    return res\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc numEquivDominoPairs(dominoes [][]int) int {\\n    dict := make(map[[2]int]int)\\n    for _, v := range dominoes {\\n        if v[0] <= v[1] {\\n            dict[[2]int{v[0], v[1]}]++\\n        } else {\\n            dict[[2]int{v[1], v[0]}]++\\n        }\\n    }\\n    res := 0\\n    for _, v := range dict {\\n        res += v * (v - 1) / 2\\n    }\\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1301280,
                "title": "java-solution-bitwise",
                "content": "```\\npublic int numEquivDominoPairs(int[][] dominoes) {\\n\\tMap<Integer, Integer> m = new HashMap<>();\\n\\tint n = dominoes.length;\\n\\tint c = 0;\\n\\tfor (int i = 0; i < n; i++) {\\n\\t\\tint mask = 0;\\n\\t\\tmask |= 1 << dominoes[i][0];\\n\\t\\tmask |= 1 << dominoes[i][1];\\n\\t\\tif (!m.containsKey(mask)) {\\n\\t\\t\\tm.put(mask, 1);\\n\\t\\t} else {\\n\\t\\t\\tc += m.get(mask);\\n\\t\\t\\tm.put(mask, m.get(mask) + 1);\\n\\t\\t}\\n\\t}\\n\\treturn c;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int numEquivDominoPairs(int[][] dominoes) {\\n\\tMap<Integer, Integer> m = new HashMap<>();\\n\\tint n = dominoes.length;\\n\\tint c = 0;\\n\\tfor (int i = 0; i < n; i++) {\\n\\t\\tint mask = 0;\\n\\t\\tmask |= 1 << dominoes[i][0];\\n\\t\\tmask |= 1 << dominoes[i][1];\\n\\t\\tif (!m.containsKey(mask)) {\\n\\t\\t\\tm.put(mask, 1);\\n\\t\\t} else {\\n\\t\\t\\tc += m.get(mask);\\n\\t\\t\\tm.put(mask, m.get(mask) + 1);\\n\\t\\t}\\n\\t}\\n\\treturn c;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1266661,
                "title": "using-hashmaps-and-swapping-c",
                "content": "class Solution {\\npublic:\\n    int numEquivDominoPairs(vector<vector<int>>& dominoes) {\\n        map<pair<int,int>,int> mp;\\n        for(int i = 0; i<dominoes.size(); i++){\\n            if(dominoes[i][0]>dominoes[i][1]){\\n                swap(dominoes[i][0],dominoes[i][1]);\\n            }\\n        }\\n        for(int i = 0; i<dominoes.size(); i++){\\n            mp[{dominoes[i][0],dominoes[i][1]}]++;\\n        }\\n        int answer = 0;\\n        \\n        for(auto i:mp){\\n            int n = i.second;\\n            answer+= (n*(n-1))/2;\\n        }\\n        return answer;\\n    }\\n};\\n\\n\\nFor any doubts, i will respond in comment section",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int numEquivDominoPairs(vector<vector<int>>& dominoes) {\\n        map<pair<int,int>,int> mp;\\n        for(int i = 0; i<dominoes.size(); i++){\\n            if(dominoes[i][0]>dominoes[i][1]){\\n                swap(dominoes[i][0],dominoes[i][1]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1215378,
                "title": "c-solution-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int numEquivDominoPairs(vector<vector<int>>& dominoes   )\\n    {\\n       vector<vector<int> >vec(10,vector<int>(10,0));\\n       int ans=0;\\n       for(int i=0;i<dominoes.size();i++)\\n       {\\n           if(dominoes[i][0]<dominoes[i][1])\\n           {\\n               ans+=vec[dominoes[i][0]][dominoes[i][1]]++;\\n           }\\n           else\\n           {\\n                ans+=vec[dominoes[i][1]][dominoes[i][0]]++;\\n           }\\n       }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numEquivDominoPairs(vector<vector<int>>& dominoes   )\\n    {\\n       vector<vector<int> >vec(10,vector<int>(10,0));\\n       int ans=0;\\n       for(int i=0;i<dominoes.size();i++)\\n       {\\n           if(dominoes[i][0]<dominoes[i][1])\\n           {\\n               ans+=vec[dominoes[i][0]][dominoes[i][1]]++;\\n           }\\n           else\\n           {\\n                ans+=vec[dominoes[i][1]][dominoes[i][0]]++;\\n           }\\n       }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1190899,
                "title": "a-very-simple-code-using-find-function-in-map-c",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint numEquivDominoPairs(vector<vector<int>>& dominoes) {\\n\\t\\t\\tint n=dominoes.size();\\n\\t\\t\\tmap<pair<int,int>,int>mp;\\n\\t\\t\\tint count=0;\\n\\t\\t\\tfor(int i=0;i<n;i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint first=min(dominoes[i][0],dominoes[i][1]);\\n\\t\\t\\t\\tint second=max(dominoes[i][0],dominoes[i][1]);\\n\\t\\t\\t\\tif(mp.find({first,second})!=mp.end())\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tcount+=mp[{first,second}];\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tmp[{first,second}]++;\\n\\t\\t\\t}\\n\\t\\t\\treturn count;\\n\\n\\n\\t\\t}\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint numEquivDominoPairs(vector<vector<int>>& dominoes) {\\n\\t\\t\\tint n=dominoes.size();\\n\\t\\t\\tmap<pair<int,int>,int>mp;\\n\\t\\t\\tint count=0;\\n\\t\\t\\tfor(int i=0;i<n;i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint first=min(dominoes[i][0],dominoes[i][1]);\\n\\t\\t\\t\\tint second=max(dominoes[i][0],dominoes[i][1]);\\n\\t\\t\\t\\tif(mp.find({first,second}",
                "codeTag": "Java"
            },
            {
                "id": 1177977,
                "title": "c-99-faster-easy-simple",
                "content": "```class Solution {\\npublic:\\n    int numEquivDominoPairs(vector<vector<int>>& dominoes) {\\n        vector < int > arr(100,0);\\n        for(int i=0 ; i < dominoes.size();i++)\\n            arr[min(dominoes[i][0]*10+dominoes[i][1],dominoes[i][1]*10+dominoes[i][0])]++;\\n        int ans=0;\\n        for(int  i = 11 ; i < 100 ; i++)\\n        {\\n            if(arr[i]>1)\\n                ans=ans+arr[i]*(arr[i]-1)/2;\\n        }\\n        return ans;\\n    }\\n};\\n\\n",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int numEquivDominoPairs(vector<vector<int>>& dominoes) {\\n        vector < int > arr(100,0);\\n        for(int i=0 ; i < dominoes.size();i++)\\n            arr[min(dominoes[i][0]*10+dominoes[i][1],dominoes[i][1]*10+dominoes[i][0])]++;\\n        int ans=0;\\n        for(int  i = 11 ; i < 100 ; i++)\\n        {\\n            if(arr[i]>1)\\n                ans=ans+arr[i]*(arr[i]-1)/2;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1131593,
                "title": "optimized-and-very-easy-c-implementation",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    int mat[10][10];\\n    int numEquivDominoPairs(vector<vector<int>>& dominoes) {\\n        int c,ans=0;\\n        for(int i=0;i<dominoes.size();i++){\\n            int mx = max(dominoes[i][0],dominoes[i][1]);\\n            int mn = min(dominoes[i][0],dominoes[i][1]);\\n            mat[mn][mx]++;\\n        }\\n        \\n        for(int i=1;i<10;i++){\\n            for(int j=i;j<10;j++){\\n                c = mat[i][j];\\n                ans+= c*(c-1)/2;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n```\\n};\\n\\n\\nMore Optimized:\\n```\\nclass Solution {\\npublic:\\n    int mat[10][10];\\n    int numEquivDominoPairs(vector<vector<int>>& dominoes) {\\n        int ans=0;\\n        for(int i=0;i<dominoes.size();i++){\\n            int mx = max(dominoes[i][0],dominoes[i][1]);\\n            int mn = min(dominoes[i][0],dominoes[i][1]);\\n            ans += mat[mn][mx]++;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int mat[10][10];\\n    int numEquivDominoPairs(vector<vector<int>>& dominoes) {\\n        int c,ans=0;\\n        for(int i=0;i<dominoes.size();i++){\\n            int mx = max(dominoes[i][0],dominoes[i][1]);\\n            int mn = min(dominoes[i][0],dominoes[i][1]);\\n            mat[mn][mx]++;\\n        }\\n        \\n        for(int i=1;i<10;i++){\\n            for(int j=i;j<10;j++){\\n                c = mat[i][j];\\n                ans+= c*(c-1)/2;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n```\n```\\nclass Solution {\\npublic:\\n    int mat[10][10];\\n    int numEquivDominoPairs(vector<vector<int>>& dominoes) {\\n        int ans=0;\\n        for(int i=0;i<dominoes.size();i++){\\n            int mx = max(dominoes[i][0],dominoes[i][1]);\\n            int mn = min(dominoes[i][0],dominoes[i][1]);\\n            ans += mat[mn][mx]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1067503,
                "title": "python3-228ms-beating-93-70",
                "content": "I\\'m pretty sure this is optimal; I had three successive runs with difference of 4ms that made a big difference to the runtime percentile ranking:\\n\\n* 236 ms, faster than 78.18% of Python3 online submissions for Number of Equivalent Domino Pairs.\\n* 232 ms, faster than 87.12% of Python3 online submissions for Number of Equivalent Domino Pairs.\\n* 228 ms, faster than 93.70% of Python3 online submissions for Number of Equivalent Domino Pairs.\\n\\nSo, I feel like I\\'m fighting leetcode noise, rather than the problem, now. \\n\\n```\\nclass Solution:\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        counts = collections.Counter(tuple(sorted(domino)) for domino in dominoes)\\n        return sum(c * (c-1) // 2 for c in counts.values())\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        counts = collections.Counter(tuple(sorted(domino)) for domino in dominoes)\\n        return sum(c * (c-1) // 2 for c in counts.values())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1062742,
                "title": "python3-easy-o-n",
                "content": "```\\nclass Solution:\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        d = dict()\\n        for p in dominoes:\\n            t = (min(p[0], p[1]), max(p[0], p[1]))\\n            if t in d:\\n                d[t] += 1\\n            else:\\n                d[t] = 1\\n        ans = 0\\n        for t in d:\\n            if d[t] > 1:\\n                ans += d[t]*(d[t]-1)//2\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        d = dict()\\n        for p in dominoes:\\n            t = (min(p[0], p[1]), max(p[0], p[1]))\\n            if t in d:\\n                d[t] += 1\\n            else:\\n                d[t] = 1\\n        ans = 0\\n        for t in d:\\n            if d[t] > 1:\\n                ans += d[t]*(d[t]-1)//2\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1052313,
                "title": "golang-brute-force-solution",
                "content": "```\\nfunc numEquivDominoPairs(dominoes [][]int) int {\\n\\tcounter := 0\\n\\tfor i := 0; i < len(dominoes); i++ {\\n\\t\\tfor j := i + 1; j < len(dominoes); j++ {\\n\\t\\t\\tif (dominoes[i][0] == dominoes[j][0] && dominoes[i][1] == dominoes[j][1]) || \\n\\t\\t\\t\\t(dominoes[i][1] == dominoes[j][0] && dominoes[i][0] == dominoes[j][1]) {\\n\\t\\t\\t\\tcounter++\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn counter\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc numEquivDominoPairs(dominoes [][]int) int {\\n\\tcounter := 0\\n\\tfor i := 0; i < len(dominoes); i++ {\\n\\t\\tfor j := i + 1; j < len(dominoes); j++ {\\n\\t\\t\\tif (dominoes[i][0] == dominoes[j][0] && dominoes[i][1] == dominoes[j][1]) || \\n\\t\\t\\t\\t(dominoes[i][1] == dominoes[j][0] && dominoes[i][0] == dominoes[j][1]) {\\n\\t\\t\\t\\tcounter++\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn counter\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1035877,
                "title": "c-o-nlogn",
                "content": "```\\nclass Solution {\\npublic:\\n    int numEquivDominoPairs(vector<vector<int>>& dominoes) \\n    {\\n        for(int i = 0; i < dominoes.size(); i++)\\n            sort(dominoes[i].begin(), dominoes[i].end());\\n        sort(dominoes.begin(), dominoes.end());\\n        dominoes.push_back({0,0});\\n        int res = 0;\\n        int cnt = 1;\\n        vector<int> curr = dominoes[0];\\n        for(int i = 1; i < dominoes.size(); i++)\\n        {\\n            if(dominoes[i] == curr)\\n                cnt++;\\n            else\\n            {\\n                res += cnt * (cnt - 1);\\n                curr = dominoes[i];\\n                cnt = 1;\\n            }\\n        }\\n        return res / 2;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numEquivDominoPairs(vector<vector<int>>& dominoes) \\n    {\\n        for(int i = 0; i < dominoes.size(); i++)\\n            sort(dominoes[i].begin(), dominoes[i].end());\\n        sort(dominoes.begin(), dominoes.end());\\n        dominoes.push_back({0,0});\\n        int res = 0;\\n        int cnt = 1;\\n        vector<int> curr = dominoes[0];\\n        for(int i = 1; i < dominoes.size(); i++)\\n        {\\n            if(dominoes[i] == curr)\\n                cnt++;\\n            else\\n            {\\n                res += cnt * (cnt - 1);\\n                curr = dominoes[i];\\n                cnt = 1;\\n            }\\n        }\\n        return res / 2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 996225,
                "title": "java-beats-98-5-simple-20-lines-using-arrays-only",
                "content": "```\\nclass Solution {\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        \\n        if (dominoes.length < 2) return 0;\\n        \\n        int[][] res = new int[10][10];\\n        \\n        int tCount=0,x,y,x1,y1;\\n            \\n        for (int i=0;i<dominoes.length;i++) {\\n            x = dominoes[i][0];\\n            y = dominoes[i][1];\\n            \\n            x1 = Math.min(x, y);\\n            y1 = Math.max(x, y);\\n            \\n            res[x1][y1] += 1;\\n        }\\n        \\n        for (int i=0;i<10;i++) {\\n            for (int j=0;j<10;j++) {\\n                int val = res[i][j];\\n                if (val > 0) {\\n                    tCount += val*(val-1)/2;\\n                }\\n            }\\n        }\\n        \\n        return tCount;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        \\n        if (dominoes.length < 2) return 0;\\n        \\n        int[][] res = new int[10][10];\\n        \\n        int tCount=0,x,y,x1,y1;\\n            \\n        for (int i=0;i<dominoes.length;i++) {\\n            x = dominoes[i][0];\\n            y = dominoes[i][1];\\n            \\n            x1 = Math.min(x, y);\\n            y1 = Math.max(x, y);\\n            \\n            res[x1][y1] += 1;\\n        }\\n        \\n        for (int i=0;i<10;i++) {\\n            for (int j=0;j<10;j++) {\\n                int val = res[i][j];\\n                if (val > 0) {\\n                    tCount += val*(val-1)/2;\\n                }\\n            }\\n        }\\n        \\n        return tCount;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 977090,
                "title": "java-using-encoding",
                "content": "```\\nclass Solution {\\n    public int numEquivDominoPairs(int[][] dominoes)\\n    {\\n        int arr[] = new int[100];\\n        int s=0;\\n        for(int[] a:dominoes)\\n        {\\n            arr[Math.min(a[0],a[1])*10+Math.max(a[0],a[1])]++;\\n        }\\n        for(int i:arr)\\n        {\\n            s+=(i*(i-1))/2;\\n        }\\n        return s;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numEquivDominoPairs(int[][] dominoes)\\n    {\\n        int arr[] = new int[100];\\n        int s=0;\\n        for(int[] a:dominoes)\\n        {\\n            arr[Math.min(a[0],a[1])*10+Math.max(a[0],a[1])]++;\\n        }\\n        for(int i:arr)\\n        {\\n            s+=(i*(i-1))/2;\\n        }\\n        return s;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 948244,
                "title": "hashmap-javascript",
                "content": "```\\nconst numEquivDominoPairs = dominoes => {\\n  const seen = new Map();\\n  let count = 0;\\n  \\n  dominoes.forEach(domino => {\\n    domino.sort((a,b) => a-b);\\n    const str = domino.join(\\'\\')\\n    if(seen.get(str)){\\n      count += seen.get(str);\\n      seen.set(str, seen.get(str)+1)\\n    }\\n    else\\n      seen.set(str,1)\\n  })\\n  return count;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst numEquivDominoPairs = dominoes => {\\n  const seen = new Map();\\n  let count = 0;\\n  \\n  dominoes.forEach(domino => {\\n    domino.sort((a,b) => a-b);\\n    const str = domino.join(\\'\\')\\n    if(seen.get(str)){\\n      count += seen.get(str);\\n      seen.set(str, seen.get(str)+1)\\n    }\\n    else\\n      seen.set(str,1)\\n  })\\n  return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 946335,
                "title": "java-by-custom-range-class-you-will-learn-something-new-tc-o-n-sc-o-1",
                "content": "```\\nclass Solution {\\n    \\n    class Range {\\n        int a;\\n        int b;\\n        \\n        Range(int a, int b) {\\n            this.a = a;\\n            this.b = b;\\n        }\\n        \\n        @Override\\n        public boolean equals(Object o) {\\n            if(this == o) return true;\\n            \\n            if(o == null || this.getClass() != o.getClass()) return false;\\n            \\n            Range r = (Range)o;\\n            \\n            if(r.a != this.a) return false;\\n            \\n            return r.b == this.b;\\n        }\\n        \\n        @Override\\n        public int hashCode() {\\n            return (a * 31 + b);\\n        }\\n    }\\n    \\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        Map<Range, Integer> hm = new HashMap<>();\\n        int cnt = 0;\\n        for(int i = 0; i < dominoes.length; i += 1) {\\n            int first = dominoes[i][0], second = dominoes[i][1];\\n            Range r = new Range(Math.min(first, second), Math.max(first, second));\\n            hm.put(r, hm.getOrDefault(r, 0) + 1);\\n        }\\n        \\n        /*\\n            If we know that a pair -> (a, b) comes how many times\\n            then it would becomes easy to find out how many \\n            distinct pairs can be made by suing frequency of pair (a, b).\\n            \\n            Num(dis_pairs) = freq * (freq - 1) / 2;\\n            \\n        */\\n        for(int freq : hm.values()) {\\n            cnt += (freq * (freq - 1) / 2);\\n        }\\n        \\n        return cnt;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    class Range {\\n        int a;\\n        int b;\\n        \\n        Range(int a, int b) {\\n            this.a = a;\\n            this.b = b;\\n        }\\n        \\n        @Override\\n        public boolean equals(Object o) {\\n            if(this == o) return true;\\n            \\n            if(o == null || this.getClass() != o.getClass()) return false;\\n            \\n            Range r = (Range)o;\\n            \\n            if(r.a != this.a) return false;\\n            \\n            return r.b == this.b;\\n        }\\n        \\n        @Override\\n        public int hashCode() {\\n            return (a * 31 + b);\\n        }\\n    }\\n    \\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        Map<Range, Integer> hm = new HashMap<>();\\n        int cnt = 0;\\n        for(int i = 0; i < dominoes.length; i += 1) {\\n            int first = dominoes[i][0], second = dominoes[i][1];\\n            Range r = new Range(Math.min(first, second), Math.max(first, second));\\n            hm.put(r, hm.getOrDefault(r, 0) + 1);\\n        }\\n        \\n        /*\\n            If we know that a pair -> (a, b) comes how many times\\n            then it would becomes easy to find out how many \\n            distinct pairs can be made by suing frequency of pair (a, b).\\n            \\n            Num(dis_pairs) = freq * (freq - 1) / 2;\\n            \\n        */\\n        for(int freq : hm.values()) {\\n            cnt += (freq * (freq - 1) / 2);\\n        }\\n        \\n        return cnt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 944279,
                "title": "java-solution",
                "content": "```\\n    private int uniqueKey(int a, int b) {\\n        return a < b ? a * 10 + b : b * 10 + a;            \\n    }\\n    \\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        int[] countByKey = new int[1000];\\n        int result = 0;\\n        for(int[] domino: dominoes) {\\n            int key = uniqueKey(domino[0], domino[1]);\\n            result += countByKey[key]++;\\n        }\\n        return result;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    private int uniqueKey(int a, int b) {\\n        return a < b ? a * 10 + b : b * 10 + a;            \\n    }\\n    \\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        int[] countByKey = new int[1000];\\n        int result = 0;\\n        for(int[] domino: dominoes) {\\n            int key = uniqueKey(domino[0], domino[1]);\\n            result += countByKey[key]++;\\n        }\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 906956,
                "title": "c-hash-table",
                "content": "```\\npublic int NumEquivDominoPairs2(int[][] dominoes)\\n{\\n\\tint[] arr = new int[100];\\n\\tforeach (var d in dominoes)\\n\\t{\\n\\t\\tint t = d[0] * 10 + d[1];\\n\\t\\tif (d[0] > d[1])\\n\\t\\t\\tt = d[1] * 10 + d[0];\\n\\t\\tarr[t]++;\\n\\t}\\n\\n\\tint res = 0;\\n\\tforeach (var a in arr)\\n\\t\\tres += a * (a - 1) / 2;\\n\\n\\treturn res;\\n}\\n```\\n`C#`",
                "solutionTags": [],
                "code": "```\\npublic int NumEquivDominoPairs2(int[][] dominoes)\\n{\\n\\tint[] arr = new int[100];\\n\\tforeach (var d in dominoes)\\n\\t{\\n\\t\\tint t = d[0] * 10 + d[1];\\n\\t\\tif (d[0] > d[1])\\n\\t\\t\\tt = d[1] * 10 + d[0];\\n\\t\\tarr[t]++;\\n\\t}\\n\\n\\tint res = 0;\\n\\tforeach (var a in arr)\\n\\t\\tres += a * (a - 1) / 2;\\n\\n\\treturn res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 881192,
                "title": "java-1ms-solution-beats-100-time-o-n-space-o-1-short-code-with-explanation",
                "content": "```\\nclass Solution {\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        int ans = 0;\\n        int[] bucket = new int[100];\\n        for (int[] domino : dominoes)\\n            bucket[domino[0] * 10 + domino[1]]++;\\n        int ten = 0, one = 0;\\n        for (int i = 11; i < 100; i++) {\\n            int k = bucket[i]; // for 11,22,33...99, add k*(k-1)/2\\n            ten = i / 10;\\n            one = i % 10;\\n            if (one > ten)\\n                k += bucket[one * 10 + ten]; // for bucket[12], k= bucket[12]+bucket[21], then add k*(k-1)/2\\n            else if (one < ten) // for bucket[21], ignore since already counted in bucket[12]\\n                continue;\\n            ans += k * (k - 1) / 2;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        int ans = 0;\\n        int[] bucket = new int[100];\\n        for (int[] domino : dominoes)\\n            bucket[domino[0] * 10 + domino[1]]++;\\n        int ten = 0, one = 0;\\n        for (int i = 11; i < 100; i++) {\\n            int k = bucket[i]; // for 11,22,33...99, add k*(k-1)/2\\n            ten = i / 10;\\n            one = i % 10;\\n            if (one > ten)\\n                k += bucket[one * 10 + ten]; // for bucket[12], k= bucket[12]+bucket[21], then add k*(k-1)/2\\n            else if (one < ten) // for bucket[21], ignore since already counted in bucket[12]\\n                continue;\\n            ans += k * (k - 1) / 2;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 867272,
                "title": "python3-no-dict-math-solution-100-220ms-100-22mb",
                "content": "**Fast Dictionary-Free Solution**\\n\\nWe keep track of how many times we encounter a domino (up to equivalence) by using an array to count the number of occurences and use an encoding for efficiency. As we count, we `pop` from `dominoes` to conserve space. Once we\\'ve counted everything, we use the well-known combinatorial fact that the number of unordered pairs that can be made from `n` objects is `n choose 2 =  n*(n-1)/2`. \\n\\n```python 3\\ndef numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n\\tcnt = [0]*73  # (Explanation for 73 in discussion below)\\n\\twhile dominoes: \\n\\t\\td = dominoes.pop()\\n\\t\\tcnt[9*max(d) - 8*min(d) - 1] += 1\\n\\treturn sum([n*(n-1)//2 for n in cnt])\\n```\\n\\nHere we encode the domino  `d=[a,b]` as `E(a,b) = 9*max(a,b) - 8*min(a,b) - 1`.  This encoding is always symmetric and is collision-free whenever  `1 <= a,b <= 9` (which is the case for our dominoes). To see why this claim is true, first note that since `|a-b| = max(a,b) - min(a,b) ` we have\\n\\n```\\n9*|a-b| + min(a,b) - 1\\n= 9*(max(a,b)-min(a,b)) + min(a,b) - 1\\n= 9*max(a,b) - 8*min(a,b) - 1\\n= E(a,b)\\n```\\n\\nThis alternate expression  of `E(a,b)` makes it easier to see why there are no collisions. A quick mental check confirms that `min(a,b)-1` can only be 0,1,2,3,4,5,6,7,8. These are the possible remainders mod 9, thus \\n\\n``` python 3\\nE(a,b) % 9  = min(a,b) -1  # remainder of division by 9\\nE(a,b) // 9 = |a-b|  # division by 9 rounded down (quotient)\\n```\\n\\nSince `max(a,b) = min(a,b) + |a-b|` this let\\'s us undo the encoding as follows:\\n\\n``` python 3\\nmin(a,b) = 1 + E(a,b) % 9 \\nmax(a,b) = 1 + E(a,b) % 9 +  E(a,b)//9\\n```\\n\\nThus, given the encoding `E(a,b)`, we can recover `d=[a,b]` (up to equivalence) since we know the `min` and `max` elements. This means there are no collisions.\\n\\nFinally, it is worth noting that that the the smallest encoding is `0=E(1,1)` and the largest encoding is `72=E(1,9)`. Thus the minimum size for a contiguous array that can hold these values is one of size `73`. \\n\\n---\\n---\\n**Alternate (but less efficient) Encoding**\\nInstead of the above encoding, we could have tried something like  `F(a,b) = 10*max(a,b) + min(a,b)`. This is also collision free since we can take remainders and quotients like before to obtain the `max` and `min`. However, the smallest encoding is `11=F(1,1)` and the largest is `99=F(9,9)`. Thus we need at least `89` slots in the counting array to accomodate this encoding. \\n\\n--- \\n---\\n**Just for Fun: Minimizing Array Size**\\n\\nBasic combinatorics tells us that it should be possible to make the counting array even smaller since we know that there are exactly `9 choose 2 + 9= 9*8/2 + 9 = 45` possible dominos (up to equivalence). By making the encoding more complicated we can reflect this fact. However we will lose some performance due to the more complicated logic, so this is mostly just an interesting exercise. Not really useful for interviews.\\n\\nFirst, let\\'s determine where the `0`\\'s are in the array `cnt`. Then we can shift the nonzero entries around to fill up that empty space. We can write some quick code to generate all pairs and then place a `1` at the encoded index if that position is used and `0` if not. This allows us to see which indices are utilized and which aren\\'t. Printing these values shows us an interesting pattern. \\n\\n``` python 3\\n# Reading left-to-right, top-to-bottom, first index is 0, last index is 72\\n1, 1, 1, 1, 1, 1, 1, 1, 1, \\n1, 1, 1, 1, 1, 1, 1, 1, 0, \\n1, 1, 1, 1, 1, 1, 1, 0, 0, \\n1, 1, 1, 1, 1, 1, 0, 0, 0, \\n1, 1, 1, 1, 1, 0, 0, 0, 0, \\n1, 1, 1, 1, 0, 0, 0, 0, 0, \\n1, 1, 1, 0, 0, 0, 0, 0, 0,\\n1, 1, 0, 0, 0, 0, 0, 0, 0,\\n1\\n```\\n\\nOne approach to fix this is to shift all indices up by `1` then apply `% 73` to wrap things back around, and then reduce the array size to omit the trailing zeroes. Then we can shift by `2` and apply `% 66` and remove trailing zeros. Then shift by `3`, apply `% 60`, then truncate. Etc. This yields the following code:\\n\\n``` python 3\\ndef numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n\\t\\t# Minimizing array size (Cyclic Shifting + Truncation via Modular Arithmetic)\\n        cnt = [0]*45\\n        for d in dominoes: \\n            d = 9*max(d) - 8*min(d)\\n            d = d % 73 + 2\\n            d = d % 66 + 3\\n            d = d % 60 + 4\\n            d = d % 55 + 5\\n            d = d % 51 + 6\\n            d = d % 48 + 7\\n            d = d % 46\\n            cnt[d] +=1\\n        return sum([n*(n-1)//2 for n in cnt])\\n```\\n\\nAnother approach is to manually move the value at `72` to `17`. Then move `63, 64` to `25, 26`. Then move `54,55,56` to `33,34,35`. Then finally move `45,46,47,48` to `41,42,43,44`. We code this in order that moves the most things first.\\n\\n``` python 3\\ndef numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        # Minimizing array size (Manually moving the encoding to correct spot)\\n        cnt = [0]*45\\n        for d in dominoes: \\n            d = 9*max(d) - 8*min(d) - 1\\n            if 44 < d < 49: d -= 4\\n            elif 53 < d < 57: d -= 21\\n            elif 62 < d < 65: d -= 38\\n            elif d == 72: d = 17\\n            cnt[d] +=1\\n        return sum([n*(n-1)//2 for n in cnt])\\n```\\n\\nOn a final note, I find these two above approaches kinda messy. I think it would be very cool to see if there is a way to do the symmetric collision-free encoding with the minimum array size of `45` in a clean way. Please let me know in comments if you come up with one!\\n",
                "solutionTags": [
                    "Python3",
                    "Math"
                ],
                "code": "```python 3\\ndef numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n\\tcnt = [0]*73  # (Explanation for 73 in discussion below)\\n\\twhile dominoes: \\n\\t\\td = dominoes.pop()\\n\\t\\tcnt[9*max(d) - 8*min(d) - 1] += 1\\n\\treturn sum([n*(n-1)//2 for n in cnt])\\n```\n```\\n9*|a-b| + min(a,b) - 1\\n= 9*(max(a,b)-min(a,b)) + min(a,b) - 1\\n= 9*max(a,b) - 8*min(a,b) - 1\\n= E(a,b)\\n```\n``` python 3\\nE(a,b) % 9  = min(a,b) -1  # remainder of division by 9\\nE(a,b) // 9 = |a-b|  # division by 9 rounded down (quotient)\\n```\n``` python 3\\nmin(a,b) = 1 + E(a,b) % 9 \\nmax(a,b) = 1 + E(a,b) % 9 +  E(a,b)//9\\n```\n``` python 3\\n# Reading left-to-right, top-to-bottom, first index is 0, last index is 72\\n1, 1, 1, 1, 1, 1, 1, 1, 1, \\n1, 1, 1, 1, 1, 1, 1, 1, 0, \\n1, 1, 1, 1, 1, 1, 1, 0, 0, \\n1, 1, 1, 1, 1, 1, 0, 0, 0, \\n1, 1, 1, 1, 1, 0, 0, 0, 0, \\n1, 1, 1, 1, 0, 0, 0, 0, 0, \\n1, 1, 1, 0, 0, 0, 0, 0, 0,\\n1, 1, 0, 0, 0, 0, 0, 0, 0,\\n1\\n```\n``` python 3\\ndef numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n\\t\\t# Minimizing array size (Cyclic Shifting + Truncation via Modular Arithmetic)\\n        cnt = [0]*45\\n        for d in dominoes: \\n            d = 9*max(d) - 8*min(d)\\n            d = d % 73 + 2\\n            d = d % 66 + 3\\n            d = d % 60 + 4\\n            d = d % 55 + 5\\n            d = d % 51 + 6\\n            d = d % 48 + 7\\n            d = d % 46\\n            cnt[d] +=1\\n        return sum([n*(n-1)//2 for n in cnt])\\n```\n``` python 3\\ndef numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        # Minimizing array size (Manually moving the encoding to correct spot)\\n        cnt = [0]*45\\n        for d in dominoes: \\n            d = 9*max(d) - 8*min(d) - 1\\n            if 44 < d < 49: d -= 4\\n            elif 53 < d < 57: d -= 21\\n            elif 62 < d < 65: d -= 38\\n            elif d == 72: d = 17\\n            cnt[d] +=1\\n        return sum([n*(n-1)//2 for n in cnt])\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 863934,
                "title": "c-map",
                "content": "```\\nclass Solution {\\npublic:\\n    int numEquivDominoPairs(vector<vector<int>> &dominoes) {\\n        map<pair<int, int>, int> dp;\\n        for (int i = 0; i < dominoes.size(); ++i) {\\n            int a = dominoes[i][0], b = dominoes[i][1];\\n            pair<int, int> tmp(min(a, b), max(a, b));\\n            dp[tmp]++;\\n        }\\n        int ans = 0;\\n        for (auto it = dp.begin(); it != dp.end(); ++it) {\\n            ans += ((it->second) * (it->second - 1) / 2);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numEquivDominoPairs(vector<vector<int>> &dominoes) {\\n        map<pair<int, int>, int> dp;\\n        for (int i = 0; i < dominoes.size(); ++i) {\\n            int a = dominoes[i][0], b = dominoes[i][1];\\n            pair<int, int> tmp(min(a, b), max(a, b));\\n            dp[tmp]++;\\n        }\\n        int ans = 0;\\n        for (auto it = dp.begin(); it != dp.end(); ++it) {\\n            ans += ((it->second) * (it->second - 1) / 2);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 861706,
                "title": "o-n-c-hashmap",
                "content": "```\\nclass Solution {\\npublic:\\n  int cal(int n){\\n        return ((n*(n-1))/2);\\n    }\\n    int numEquivDominoPairs(vector<vector<int>>& dominoes) {\\n       map<pair<int, int>, int> s;  \\n        int cnt=0;\\n        for(int i=0;i<dominoes.size();i++)\\n            if(s.find({dominoes[i][0],dominoes[i][1]})!=s.end() )\\n            {\\n                s[{dominoes[i][0],dominoes[i][1]}]++;\\n                int n=s[{dominoes[i][0],dominoes[i][1]}];\\n                cnt=cnt-cal(n-1)+cal(n);\\n            }\\n            else if( s.find({dominoes[i][1],dominoes[i][0]})!=s.end()){\\n                  s[{dominoes[i][1],dominoes[i][0]}]++;\\n                int n= s[{dominoes[i][1],dominoes[i][0]}];\\n                 cnt=cnt-cal(n-1)+cal(n);\\n                \\n            }\\n            else\\n                  s[{dominoes[i][0],dominoes[i][1]}]++;\\n          return cnt;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n  int cal(int n){\\n        return ((n*(n-1))/2);\\n    }\\n    int numEquivDominoPairs(vector<vector<int>>& dominoes) {\\n       map<pair<int, int>, int> s;  \\n        int cnt=0;\\n        for(int i=0;i<dominoes.size();i++)\\n            if(s.find({dominoes[i][0],dominoes[i][1]})!=s.end() )\\n            {\\n                s[{dominoes[i][0],dominoes[i][1]}]++;\\n                int n=s[{dominoes[i][0],dominoes[i][1]}];\\n                cnt=cnt-cal(n-1)+cal(n);\\n            }\\n            else if( s.find({dominoes[i][1],dominoes[i][0]})!=s.end()){\\n                  s[{dominoes[i][1],dominoes[i][0]}]++;\\n                int n= s[{dominoes[i][1],dominoes[i][0]}];\\n                 cnt=cnt-cal(n-1)+cal(n);\\n                \\n            }\\n            else\\n                  s[{dominoes[i][0],dominoes[i][1]}]++;\\n          return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 832888,
                "title": "python-3-use-dict",
                "content": "When the length of array is around 50k, it means we don\\'t get Memory Limit Exceeded, and can sacrefice space for speed (since it more often happens TLE for slow speed).\\n\\n```\\nclass Solution:\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        d = dict()\\n        for dom in dominoes:\\n            a, b = dom[0], dom[1]\\n            if a > b:\\n                a, b = b, a\\n            d[(a, b)] = d.get((a,b), 0) + 1\\n        \\n        res = 0\\n        for v in d.values():\\n            res += (v-1) * v / 2\\n                    \\n        return int(res)",
                "solutionTags": [],
                "code": "When the length of array is around 50k, it means we don\\'t get Memory Limit Exceeded, and can sacrefice space for speed (since it more often happens TLE for slow speed).\\n\\n```\\nclass Solution:\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        d = dict()\\n        for dom in dominoes:\\n            a, b = dom[0], dom[1]\\n            if a > b:\\n                a, b = b, a\\n            d[(a, b)] = d.get((a,b), 0) + 1\\n        \\n        res = 0\\n        for v in d.values():\\n            res += (v-1) * v / 2\\n                    \\n        return int(res)",
                "codeTag": "Java"
            },
            {
                "id": 822802,
                "title": "a-neat-math-based-solution-in-python",
                "content": "Convert the pairs into tuple keys in a dict. \\nif the count is more than 1, then its the number of occurrences\\nto find the number of pairs possible .. we just nC2 and add it our output.\\nIt took me 45 min to get to this solution.\\n\\n```\\nfrom math import comb\\n\\nclass Solution:\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        hdict = {}\\n        output = 0\\n                \\n        for val in dominoes:            \\n            s_val = tuple(sorted(val))\\n            if s_val in hdict:\\n                hdict[s_val] += 1\\n            else:\\n                hdict[s_val] = 1\\n        \\n        for k, v in hdict.items():\\n            \\n            if v > 1:\\n                output += comb(v, 2)\\n        \\n        \\n        return output\\n```",
                "solutionTags": [],
                "code": "```\\nfrom math import comb\\n\\nclass Solution:\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        hdict = {}\\n        output = 0\\n                \\n        for val in dominoes:            \\n            s_val = tuple(sorted(val))\\n            if s_val in hdict:\\n                hdict[s_val] += 1\\n            else:\\n                hdict[s_val] = 1\\n        \\n        for k, v in hdict.items():\\n            \\n            if v > 1:\\n                output += comb(v, 2)\\n        \\n        \\n        return output\\n```",
                "codeTag": "Java"
            },
            {
                "id": 809986,
                "title": "python-3-dictionary-explanation",
                "content": "* For this question we want to keep a record of all the previous dominoes we\\'ve seen, and how many times we\\'ve seen them.\\n* We also want to consider equivalent dominoes under the same \\'count\\'\\n\\t* For example, the dominoes `(1, 2)` and `(2, 1)` should be considered as \\'seen\\' twice, since they are equivalent once rotated.\\n\\t* So the dictionary `dominoToCount` counts up how many matching dominoes we have seen.\\n* In order to pair up matching dominoes, we need some way of mapping dominoes like `(1, 2)` and `(2, 1)` into the same key.\\n\\t* For this we can use the `getKey` function that ensures that both map to the same value, we do this by using the smaller number as the first in the tuple.\\n\\t* So both `(1, 2)` and `(2, 1)` will be mapped to `(1, 2)`.\\n* As we iterate through `dominoes` we add to the running total `equivalentPairs` how many existing equivalent dominoes there are.\\n```\\nfrom typing import Tuple\\n\\nclass Solution:\\n    \\n    def getKey(self, a: int, b: int) -> Tuple[int, int]:\\n        return (a, b) if a < b else (b, a)\\n    \\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        equivalentPairs = 0\\n        dominoes = [tuple(domino) for domino in dominoes]\\n        dominoToCount = {}\\n        \\n        for a, b in dominoes:\\n            key = self.getKey(a, b)\\n            \\n            if key in dominoToCount:\\n                equivalentPairs += dominoToCount[key]\\n                dominoToCount[key] = dominoToCount[key] + 1\\n            else:\\n                dominoToCount[key] = 1\\n                \\n        return equivalentPairs\\n```",
                "solutionTags": [],
                "code": "```\\nfrom typing import Tuple\\n\\nclass Solution:\\n    \\n    def getKey(self, a: int, b: int) -> Tuple[int, int]:\\n        return (a, b) if a < b else (b, a)\\n    \\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        equivalentPairs = 0\\n        dominoes = [tuple(domino) for domino in dominoes]\\n        dominoToCount = {}\\n        \\n        for a, b in dominoes:\\n            key = self.getKey(a, b)\\n            \\n            if key in dominoToCount:\\n                equivalentPairs += dominoToCount[key]\\n                dominoToCount[key] = dominoToCount[key] + 1\\n            else:\\n                dominoToCount[key] = 1\\n                \\n        return equivalentPairs\\n```",
                "codeTag": "Java"
            },
            {
                "id": 801653,
                "title": "c-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int A[9][9];\\n    \\n    int numEquivDominoPairs(vector<vector<int>>& dominoes) {\\n        memset(A,0,sizeof A);\\n        for(int i = 0;i<dominoes.size();i++){\\n            if(dominoes[i][0]!=dominoes[i][1]){\\n            A[dominoes[i][0]-1][dominoes[i][1]-1]++;\\n            A[dominoes[i][1]-1][dominoes[i][0]-1]++;\\n                }\\n            else{\\n                A[dominoes[i][0]-1][dominoes[i][1]-1]++;\\n            }\\n        }    \\n        \\n        int sum =0;\\n\\n        for(int i = 0;i<9;i++){\\n            for(int j = i;j<9;j++){\\n                    sum+=((A[i][j])*(A[i][j]-1))/2;\\n            }\\n\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int A[9][9];\\n    \\n    int numEquivDominoPairs(vector<vector<int>>& dominoes) {\\n        memset(A,0,sizeof A);\\n        for(int i = 0;i<dominoes.size();i++){\\n            if(dominoes[i][0]!=dominoes[i][1]){\\n            A[dominoes[i][0]-1][dominoes[i][1]-1]++;\\n            A[dominoes[i][1]-1][dominoes[i][0]-1]++;\\n                }\\n            else{\\n                A[dominoes[i][0]-1][dominoes[i][1]-1]++;\\n            }\\n        }    \\n        \\n        int sum =0;\\n\\n        for(int i = 0;i<9;i++){\\n            for(int j = i;j<9;j++){\\n                    sum+=((A[i][j])*(A[i][j]-1))/2;\\n            }\\n\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 727438,
                "title": "c-clear",
                "content": "```\\nclass Solution {\\npublic:\\n    int numEquivDominoPairs(vector<vector<int>>& domino) {\\n        int ans=0;\\n        map<pair<int,int>, int> cnt;\\n        for(auto v : domino) {\\n            sort(v.begin(),v.end());\\n            auto p=make_pair(v[0],v[1]);\\n            cnt[p]++;\\n            if(cnt[p]==2) ans++;\\n            else if(cnt[p]>2) ans+=cnt[p]-1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numEquivDominoPairs(vector<vector<int>>& domino) {\\n        int ans=0;\\n        map<pair<int,int>, int> cnt;\\n        for(auto v : domino) {\\n            sort(v.begin(),v.end());\\n            auto p=make_pair(v[0],v[1]);\\n            cnt[p]++;\\n            if(cnt[p]==2) ans++;\\n            else if(cnt[p]>2) ans+=cnt[p]-1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 678287,
                "title": "java-o-n-solution-with-o-1-space",
                "content": "It can be solved with HashMap. Iterate over array, sort domino pair, add count of such pairs in map to the answer and increase this counter.\\nI am using array `used` instead of map, because number of possible values is small. It increases performance a little bit\\n\\n```\\nclass Solution {\\n    private static final int MAXIMUM_DOMINO_VALUE = 9;\\n    \\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        int answer = 0;\\n        int[] used = new int[MAXIMUM_DOMINO_VALUE * MAXIMUM_DOMINO_VALUE];\\n        \\n        for (int[] domino : dominoes) {\\n            int smallerSide = (Math.min(domino[0], domino[1]) - 1) * MAXIMUM_DOMINO_VALUE;\\n            int biggerSide = (Math.max(domino[0], domino[1]) - 1);\\n            \\n            answer += used[smallerSide + biggerSide];\\n            used[smallerSide + biggerSide]++;\\n        }\\n        \\n        return answer;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private static final int MAXIMUM_DOMINO_VALUE = 9;\\n    \\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        int answer = 0;\\n        int[] used = new int[MAXIMUM_DOMINO_VALUE * MAXIMUM_DOMINO_VALUE];\\n        \\n        for (int[] domino : dominoes) {\\n            int smallerSide = (Math.min(domino[0], domino[1]) - 1) * MAXIMUM_DOMINO_VALUE;\\n            int biggerSide = (Math.max(domino[0], domino[1]) - 1);\\n            \\n            answer += used[smallerSide + biggerSide];\\n            used[smallerSide + biggerSide]++;\\n        }\\n        \\n        return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 660959,
                "title": "c-simple-3-line-solution",
                "content": "Run-time is `O(N)`, space is `O(1)`.\\n\\n```\\nclass Solution {\\npublic:\\n    static int numEquivDominoPairs(const vector<vector<int>>& dominoes) {\\n        int m[100]{0}, count{0};\\n        for(const auto &d: dominoes) count += m[min(d[0], d[1]) + 10*max(d[0], d[1])]++;\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    static int numEquivDominoPairs(const vector<vector<int>>& dominoes) {\\n        int m[100]{0}, count{0};\\n        for(const auto &d: dominoes) count += m[min(d[0], d[1]) + 10*max(d[0], d[1])]++;\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 657664,
                "title": "java-solutions-o-n-time-o-n-space",
                "content": "Basically we need a way to serialize each domino (that is we need a way to check that [1,2] = [2, 1]). In my case I chose to get a number representation, so domino [1,2] and [2,1] would both have a number representation of 12. Then we keep track of frequency of the same dominoes using a hashmap. I just want to point out that the brute force solution would be simply using 2 for loops.\\n\\nUnfortunatley this is just one of those questions where you either know how to solve it, or you don\\'t. I found it very hard to logic my way through.\\n\\n```\\npublic int numEquivDominoPairs(int[][] dominoes) {\\n        \\n        int count = 0;\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int[] domino : dominoes) {\\n            Integer numRepresentation = getNumRepresentation(domino);\\n            if (map.containsKey(numRepresentation)) {\\n                int oldCount = map.get(numRepresentation);\\n                map.put(numRepresentation, oldCount + 1);\\n            }\\n            else map.put(numRepresentation, 0);\\n            count += map.get(numRepresentation);            \\n        }\\n        \\n        return count;\\n    }\\n    \\n    private Integer getNumRepresentation(int[] domino) {\\n        boolean isFirstNumSmaller = domino[0] < domino[1];\\n        return (isFirstNumberSmaller) domino[0] * 10 + domino[1] : domino[1] * 10 + domino[0];\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int numEquivDominoPairs(int[][] dominoes) {\\n        \\n        int count = 0;\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int[] domino : dominoes) {\\n            Integer numRepresentation = getNumRepresentation(domino);\\n            if (map.containsKey(numRepresentation)) {\\n                int oldCount = map.get(numRepresentation);\\n                map.put(numRepresentation, oldCount + 1);\\n            }\\n            else map.put(numRepresentation, 0);\\n            count += map.get(numRepresentation);            \\n        }\\n        \\n        return count;\\n    }\\n    \\n    private Integer getNumRepresentation(int[] domino) {\\n        boolean isFirstNumSmaller = domino[0] < domino[1];\\n        return (isFirstNumberSmaller) domino[0] * 10 + domino[1] : domino[1] * 10 + domino[0];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 654656,
                "title": "java-6ms-beats-80-18-superb-oop-plus-override-hashcode-and-equals",
                "content": "```\\nclass Solution {\\n  \\n  public int numEquivDominoPairs(int[][] dominoes) {\\n    \\n    /*\\n    Runtime: 6 ms, faster than 80.81% of Java online submissions for Number of Equivalent Domino Pairs.\\n    Memory Usage: 48.3 MB, less than 100.00% of Java online submissions for Number of Equivalent Domino Pairs.\\n    */\\n    \\n    Map<Domino, Integer> dominoFT = new HashMap<Domino, Integer>();// FT = frequency table\\n    \\n    // populate HashMap with dominoes\\n    for (int[] d : dominoes) {\\n      dominoFT.merge(new Domino(d[0], d[1]), 1, Integer::sum);// nice little merge/sum trick useful for frequency counting...\\n    }\\n    \\n    int quantityOfPairs = 0;\\n    \\n    for (int i : dominoFT.values()) {// all we need are the values, so no need for entrySet() or keySet()\\n      if (i > 1) {\\n        // LeetCode\\'s test cases require:\\n        // 2 matching dominoes counts as 1 pair, BUT!...\\n        // 3 matching dominoes counts as 3 pairs (i.e., it wants handshake formula)\\n        quantityOfPairs += handshakeNumber(i);   \\n      }\\n    }\\n    \\n    return quantityOfPairs;\\n  }\\n  \\n  private int handshakeNumber(int n) {\\n    --n;\\n    return n * (n + 1) / 2;\\n  }\\n  \\n  private class Domino {\\n    \\n    // fields\\n    int smallSpots;\\n    int bigSpots;\\n    \\n    // constructor\\n    Domino (int a, int b) {\\n      if (a < b) {\\n        smallSpots = a;\\n        bigSpots = b;\\n      } else {\\n        smallSpots = b;\\n        bigSpots = a;\\n      }\\n    }\\n    \\n    // methods\\n    \\n    @Override\\n    public boolean equals(Object obj) {\\n      return this.hashCode() == obj.hashCode();\\n    }\\n    \\n    @Override\\n    public int hashCode() {\\n      return this.smallSpots * 10 + bigSpots;\\n    }\\n    \\n  }\\n   \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n  \\n  public int numEquivDominoPairs(int[][] dominoes) {\\n    \\n    /*\\n    Runtime: 6 ms, faster than 80.81% of Java online submissions for Number of Equivalent Domino Pairs.\\n    Memory Usage: 48.3 MB, less than 100.00% of Java online submissions for Number of Equivalent Domino Pairs.\\n    */\\n    \\n    Map<Domino, Integer> dominoFT = new HashMap<Domino, Integer>();// FT = frequency table\\n    \\n    // populate HashMap with dominoes\\n    for (int[] d : dominoes) {\\n      dominoFT.merge(new Domino(d[0], d[1]), 1, Integer::sum);// nice little merge/sum trick useful for frequency counting...\\n    }\\n    \\n    int quantityOfPairs = 0;\\n    \\n    for (int i : dominoFT.values()) {// all we need are the values, so no need for entrySet() or keySet()\\n      if (i > 1) {\\n        // LeetCode\\'s test cases require:\\n        // 2 matching dominoes counts as 1 pair, BUT!...\\n        // 3 matching dominoes counts as 3 pairs (i.e., it wants handshake formula)\\n        quantityOfPairs += handshakeNumber(i);   \\n      }\\n    }\\n    \\n    return quantityOfPairs;\\n  }\\n  \\n  private int handshakeNumber(int n) {\\n    --n;\\n    return n * (n + 1) / 2;\\n  }\\n  \\n  private class Domino {\\n    \\n    // fields\\n    int smallSpots;\\n    int bigSpots;\\n    \\n    // constructor\\n    Domino (int a, int b) {\\n      if (a < b) {\\n        smallSpots = a;\\n        bigSpots = b;\\n      } else {\\n        smallSpots = b;\\n        bigSpots = a;\\n      }\\n    }\\n    \\n    // methods\\n    \\n    @Override\\n    public boolean equals(Object obj) {\\n      return this.hashCode() == obj.hashCode();\\n    }\\n    \\n    @Override\\n    public int hashCode() {\\n      return this.smallSpots * 10 + bigSpots;\\n    }\\n    \\n  }\\n   \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 646462,
                "title": "javascript-easy-and-readable-solution-using-map-and-math",
                "content": "This solution optimizes for readability and simplicity. We count how many dominos have the same number pairs and then sum up the different combinations of each set.\\n\\nThe math:\\nFor `n` items, the number of different ways to choose `r` items is given by the `nCr` formula\\n```\\nnumCombinations = n! / ((n-r)! * r!)\\n```\\n\\nGiven 2 dominos, the is only 1 way to choose 2 dominos. Given 3 domins, there are 2. For 4, there are 3.\\n\\nWe can further simplify this equation because we know `r = 2`\\n```\\nn! / ((n-2)! * 2!)\\n```\\nThen rewrite `n!` to be `n*(n-1)*(n-2)!`\\n```\\n(n*(n-1)*(n-2)!) / ((n-2)! * 2!)\\n```\\nSimplify\\n```\\nn*(n-1) / 2\\n```\\n\\nSolution:\\n```\\n/**\\n * @param {number[][]} dominoes\\n * @return {number}\\n */\\nvar numEquivDominoPairs = function(dominoes) {\\n    const counts = {};\\n    \\n    dominoes.forEach(d => {\\n\\t    // this converts all dominos with the same number pair to the same string\\n\\t\\t// [1,2] and [2,1] will get sorted to [1,2]\\n\\t\\t// toString method converts it to a string \"1,2\" so it can be used as keys\\n        const dStr = d.sort().toString();\\n\\t\\t\\n        if (!counts.hasOwnProperty(dStr)) {\\n            counts[dStr] = 0;\\n        }\\n        counts[dStr]++;\\n    })\\n    \\n\\t// sum all counts together while calculating combinations of domino pairs\\n    return Object.values(counts).reduce((sum, count) => {\\n        return sum + (count*(count-1))/2;\\n    }, 0)\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Probability and Statistics"
                ],
                "code": "```\\nnumCombinations = n! / ((n-r)! * r!)\\n```\n```\\nn! / ((n-2)! * 2!)\\n```\n```\\n(n*(n-1)*(n-2)!) / ((n-2)! * 2!)\\n```\n```\\nn*(n-1) / 2\\n```\n```\\n/**\\n * @param {number[][]} dominoes\\n * @return {number}\\n */\\nvar numEquivDominoPairs = function(dominoes) {\\n    const counts = {};\\n    \\n    dominoes.forEach(d => {\\n\\t    // this converts all dominos with the same number pair to the same string\\n\\t\\t// [1,2] and [2,1] will get sorted to [1,2]\\n\\t\\t// toString method converts it to a string \"1,2\" so it can be used as keys\\n        const dStr = d.sort().toString();\\n\\t\\t\\n        if (!counts.hasOwnProperty(dStr)) {\\n            counts[dStr] = 0;\\n        }\\n        counts[dStr]++;\\n    })\\n    \\n\\t// sum all counts together while calculating combinations of domino pairs\\n    return Object.values(counts).reduce((sum, count) => {\\n        return sum + (count*(count-1))/2;\\n    }, 0)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 640290,
                "title": "simple-java-using-hashmap",
                "content": "Intuition\\n1. Traverse loop while traversing store each pair in hashmap.\\n2. If the number already exists increment its count in hashmap.\\n3. At the end traverse hasmap and get the result for each pair by calculating its permutations as n pemute= n*(n-1)/2 .\\n```\\nclass Solution {\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        HashMap<Integer,Integer> hsmap=new HashMap<>();\\n        for(int i=0;i<dominoes.length;i++)\\n        {\\n            int a=Math.min(dominoes[i][0],dominoes[i][1]);\\n            int b=Math.max(dominoes[i][0],dominoes[i][1]);\\n            int key1=a*10+ b;\\n            hsmap.put(key1,hsmap.getOrDefault(key1,0)+1);\\n        }\\n        int count=0;\\n        for(Integer i:hsmap.values())\\n        {\\n            count+=(i*(i-1))/2;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        HashMap<Integer,Integer> hsmap=new HashMap<>();\\n        for(int i=0;i<dominoes.length;i++)\\n        {\\n            int a=Math.min(dominoes[i][0],dominoes[i][1]);\\n            int b=Math.max(dominoes[i][0],dominoes[i][1]);\\n            int key1=a*10+ b;\\n            hsmap.put(key1,hsmap.getOrDefault(key1,0)+1);\\n        }\\n        int count=0;\\n        for(Integer i:hsmap.values())\\n        {\\n            count+=(i*(i-1))/2;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 625460,
                "title": "c-solution-std-unordered-map",
                "content": "With numbers of pairs calculation on-the-fly\\n```\\nclass Solution {\\npublic:\\n    int numEquivDominoPairs(std::vector<std::vector<int>> const &d) {\\n        int count = 0;\\n        using key_t = std::array<int, 2>;\\n        struct Hash { size_t operator()(key_t const &k) const noexcept { return k[0] ^ k[1]; } };\\n        struct Comp { bool operator()(key_t const &k1, key_t const &k2) const noexcept { return k1 == k2 || (k1[0] == k2[1] && k1[1] == k2[0]); } };\\n        std::unordered_map<key_t, int, Hash, Comp> m;\\n        for (auto const &x : d)\\n        {\\n            auto it = m.emplace(key_t{x[0], x[1]}, 0).first;\\n            count += it->second;\\n            ++(it->second);\\n        }\\n        return count;\\n    }\\n};\\n```\\nOr with std::accumulate upon collecting information about pairs\\n```\\nclass Solution {\\npublic:\\n    int numEquivDominoPairs(std::vector<std::vector<int>> const &d) {\\n        int count = 0;\\n        using key_t = std::array<int, 2>;\\n        struct Hash { size_t operator()(key_t const &k) const noexcept { return k[0] ^ k[1]; } };\\n        struct Comp { bool operator()(key_t const &k1, key_t const &k2) const noexcept { return k1 == k2 || (k1[0] == k2[1] && k1[1] == k2[0]); } };\\n        std::unordered_map<key_t, int, Hash, Comp> m;\\n        for (auto const &x : d)\\n            ++m[{x[0], x[1]}];\\n        return std::accumulate(m.cbegin(), m.cend(), 0, [](auto sum, auto const &p){ return sum + p.second * (p.second - 1) / 2; });\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numEquivDominoPairs(std::vector<std::vector<int>> const &d) {\\n        int count = 0;\\n        using key_t = std::array<int, 2>;\\n        struct Hash { size_t operator()(key_t const &k) const noexcept { return k[0] ^ k[1]; } };\\n        struct Comp { bool operator()(key_t const &k1, key_t const &k2) const noexcept { return k1 == k2 || (k1[0] == k2[1] && k1[1] == k2[0]); } };\\n        std::unordered_map<key_t, int, Hash, Comp> m;\\n        for (auto const &x : d)\\n        {\\n            auto it = m.emplace(key_t{x[0], x[1]}, 0).first;\\n            count += it->second;\\n            ++(it->second);\\n        }\\n        return count;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int numEquivDominoPairs(std::vector<std::vector<int>> const &d) {\\n        int count = 0;\\n        using key_t = std::array<int, 2>;\\n        struct Hash { size_t operator()(key_t const &k) const noexcept { return k[0] ^ k[1]; } };\\n        struct Comp { bool operator()(key_t const &k1, key_t const &k2) const noexcept { return k1 == k2 || (k1[0] == k2[1] && k1[1] == k2[0]); } };\\n        std::unordered_map<key_t, int, Hash, Comp> m;\\n        for (auto const &x : d)\\n            ++m[{x[0], x[1]}];\\n        return std::accumulate(m.cbegin(), m.cend(), 0, [](auto sum, auto const &p){ return sum + p.second * (p.second - 1) / 2; });\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 620700,
                "title": "c-calculate-in-1-iteration-using-map",
                "content": "use a map to store a pair as key and it\\'s count so far as value. for counting pairs we just have to just count the same domino processed so far.\\n```\\nclass Solution {\\npublic:\\n    int numEquivDominoPairs(vector<vector<int>>& dominoes) {\\n        int ans=0;\\n        int s=dominoes.size();\\n        if(s==1)\\n            return ans;\\n        map<pair<int,int>,int> m;\\n        for(int i=0;i<dominoes.size();i++)\\n        {\\n        int a=min(dominoes[i][0],dominoes[i][1]);\\n        int b=max(dominoes[i][0],dominoes[i][1]);\\n        m[{a,b}]++;\\n        ans+=m[{a,b}]-1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numEquivDominoPairs(vector<vector<int>>& dominoes) {\\n        int ans=0;\\n        int s=dominoes.size();\\n        if(s==1)\\n            return ans;\\n        map<pair<int,int>,int> m;\\n        for(int i=0;i<dominoes.size();i++)\\n        {\\n        int a=min(dominoes[i][0],dominoes[i][1]);\\n        int b=max(dominoes[i][0],dominoes[i][1]);\\n        m[{a,b}]++;\\n        ans+=m[{a,b}]-1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 617208,
                "title": "python-rust-time-o-n-space-o-n",
                "content": "- **Python**\\n```python\\nclass Solution:\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        seen, count = {}, 0\\n        \\n        for d in dominoes:\\n            key = tuple(sorted(d))\\n            if key in seen:\\n                count += seen[key]\\n                seen[key] += 1\\n            else:\\n                seen[key] = 1\\n                \\n        return count\\n```\\n\\n- **Rust**\\n\\n```rust\\nuse std::collections::HashMap;\\n\\nimpl Solution {\\n    pub fn num_equiv_domino_pairs(dominoes: Vec<Vec<i32>>) -> i32 {\\n        let mut count: i32 = 0;\\n        let mut seen: HashMap<(i32,i32), i32> = HashMap::new();\\n        \\n        for d in dominoes.iter() {\\n            let mut t = d.clone();\\n            t.sort();\\n            let key = (t[0], t[1]);\\n            \\n            if seen.contains_key(&key) {\\n                let val = *seen.get(&key).unwrap();\\n                count += val;\\n                seen.insert(key, val + 1);\\n            } else {\\n                seen.insert(key, 1);\\n            }  \\n        } \\n        \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Python",
                    "Rust"
                ],
                "code": "```python\\nclass Solution:\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        seen, count = {}, 0\\n        \\n        for d in dominoes:\\n            key = tuple(sorted(d))\\n            if key in seen:\\n                count += seen[key]\\n                seen[key] += 1\\n            else:\\n                seen[key] = 1\\n                \\n        return count\\n```\n```rust\\nuse std::collections::HashMap;\\n\\nimpl Solution {\\n    pub fn num_equiv_domino_pairs(dominoes: Vec<Vec<i32>>) -> i32 {\\n        let mut count: i32 = 0;\\n        let mut seen: HashMap<(i32,i32), i32> = HashMap::new();\\n        \\n        for d in dominoes.iter() {\\n            let mut t = d.clone();\\n            t.sort();\\n            let key = (t[0], t[1]);\\n            \\n            if seen.contains_key(&key) {\\n                let val = *seen.get(&key).unwrap();\\n                count += val;\\n                seen.insert(key, val + 1);\\n            } else {\\n                seen.insert(key, 1);\\n            }  \\n        } \\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 595995,
                "title": "swift",
                "content": "```\\nfunc numEquivDominoPairs(_ dominoes: [[Int]]) -> Int {\\n        var map = [[Int]: Int]()\\n        for domin in dominoes {\\n            var cur = domin\\n            if cur[0] > cur[1] {\\n                cur = [cur[1], cur[0]]\\n            }\\n            map[cur, default: 0] += 1\\n        }\\n        var res = 0\\n        for value in map.values {\\n            if value > 1 {\\n                res += value * (value - 1) / 2\\n            }\\n        }\\n        return res\\n    }",
                "solutionTags": [],
                "code": "```\\nfunc numEquivDominoPairs(_ dominoes: [[Int]]) -> Int {\\n        var map = [[Int]: Int]()\\n        for domin in dominoes {\\n            var cur = domin\\n            if cur[0] > cur[1] {\\n                cur = [cur[1], cur[0]]\\n            }\\n            map[cur, default: 0] += 1\\n        }\\n        var res = 0\\n        for value in map.values {\\n            if value > 1 {\\n                res += value * (value - 1) / 2\\n            }\\n        }\\n        return res\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 568802,
                "title": "javascript-solution-o-n",
                "content": "```\\nvar numEquivDominoPairs = function(dominoes) {\\n    const map = new Map()\\n    let count = 0\\n    \\n    for (const [a, b] of dominoes) {\\n        const min = Math.min(a, b)\\n        const max = Math.max(a, b)\\n        const key = min + \"#\" + max\\n        if (!map.has(key)) map.set(key, 0)\\n        count += map.get(key)\\n        map.set(key, map.get(key) + 1)\\n    }\\n\\n    return count\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar numEquivDominoPairs = function(dominoes) {\\n    const map = new Map()\\n    let count = 0\\n    \\n    for (const [a, b] of dominoes) {\\n        const min = Math.min(a, b)\\n        const max = Math.max(a, b)\\n        const key = min + \"#\" + max\\n        if (!map.has(key)) map.set(key, 0)\\n        count += map.get(key)\\n        map.set(key, map.get(key) + 1)\\n    }\\n\\n    return count\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 553652,
                "title": "rust-4ms",
                "content": "```\\nuse std::collections::HashMap;\\n\\nimpl Solution {\\n  pub fn num_equiv_domino_pairs(mut dominoes: Vec<Vec<i32>>) -> i32 {\\n    let mut map: HashMap<i32, i32> = HashMap::new();\\n    for d in &mut dominoes {\\n      d.sort();\\n      *map.entry(d[0] * 10 + d[1]).or_default() += 1;\\n    }\\n    map.values().fold(0, |s, &v| s + v * (v - 1) / 2)\\n  }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nuse std::collections::HashMap;\\n\\nimpl Solution {\\n  pub fn num_equiv_domino_pairs(mut dominoes: Vec<Vec<i32>>) -> i32 {\\n    let mut map: HashMap<i32, i32> = HashMap::new();\\n    for d in &mut dominoes {\\n      d.sort();\\n      *map.entry(d[0] * 10 + d[1]).or_default() += 1;\\n    }\\n    map.values().fold(0, |s, &v| s + v * (v - 1) / 2)\\n  }\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 550585,
                "title": "python-1-line",
                "content": "```\\nclass Solution:\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:                \\n        return sum((v-1)*v//2 for v in collections.Counter([tuple(sorted(x)) for x in dominoes]).values())\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:                \\n        return sum((v-1)*v//2 for v in collections.Counter([tuple(sorted(x)) for x in dominoes]).values())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 538380,
                "title": "java-rewrite-hashcode-and-equals-method",
                "content": "This is not a concise method but a way to use hashCode and equals to solve the problem. The reason is that hashCode of int[] cannot be used to compare int[]. \\n\\n```\\n    class Point {\\n        int x;\\n        int y;\\n        public Point(int x, int y) {\\n            this.x = x;\\n            this.y = y;\\n        }\\n        @Override\\n        public int hashCode() {\\n            int result = 10;\\n            result = x * result + y;\\n            return result;\\n        }\\n\\n        @Override\\n        public boolean equals(Object o) {\\n            if (o == this) return true;\\n            if (!(o instanceof Point)) {\\n                return false;\\n            }\\n            Point p = (Point) o;\\n            return p.x == x && p.y == y;\\n        }\\n    }\\n\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        if (dominoes == null || dominoes.length == 0) {\\n            return 0;\\n        }\\n        Map<Point, Integer> hm = new HashMap<>();\\n        int res = 0;\\n        for (int[] key : dominoes) {\\n            Point point = new Point(key[0], key[1]);\\n            Point rPoint = new Point(key[1], key[0]);\\n            if (hm.containsKey(point)) {\\n                hm.put(point, hm.get(point) + 1);\\n            } else if(hm.containsKey(rPoint)) {\\n                hm.put(rPoint, hm.get(rPoint) + 1);\\n            } else {\\n                hm.put(point, 1);\\n            }\\n        }\\n        for (int v : hm.values()) {\\n            res += v * (v - 1) / 2;\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    class Point {\\n        int x;\\n        int y;\\n        public Point(int x, int y) {\\n            this.x = x;\\n            this.y = y;\\n        }\\n        @Override\\n        public int hashCode() {\\n            int result = 10;\\n            result = x * result + y;\\n            return result;\\n        }\\n\\n        @Override\\n        public boolean equals(Object o) {\\n            if (o == this) return true;\\n            if (!(o instanceof Point)) {\\n                return false;\\n            }\\n            Point p = (Point) o;\\n            return p.x == x && p.y == y;\\n        }\\n    }\\n\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        if (dominoes == null || dominoes.length == 0) {\\n            return 0;\\n        }\\n        Map<Point, Integer> hm = new HashMap<>();\\n        int res = 0;\\n        for (int[] key : dominoes) {\\n            Point point = new Point(key[0], key[1]);\\n            Point rPoint = new Point(key[1], key[0]);\\n            if (hm.containsKey(point)) {\\n                hm.put(point, hm.get(point) + 1);\\n            } else if(hm.containsKey(rPoint)) {\\n                hm.put(rPoint, hm.get(rPoint) + 1);\\n            } else {\\n                hm.put(point, 1);\\n            }\\n        }\\n        for (int v : hm.values()) {\\n            res += v * (v - 1) / 2;\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 522533,
                "title": "kotlin-solution-in-3-lines",
                "content": "I would be submitting two versions of the code that could be simple and small which would result in the solution.\\nSolution1:\\n```\\ndominoes.groupBy { it.min() to it.max() }\\n            .map { it.value.size }\\n            .sumBy { it * (it-1)/2 }\\n```\\nSolution2:\\n```\\ndominoes.groupBy { maxOf(it[0], it[1]) * 10 + minOf(it[0], it[1]) }\\n            .map { it.value.size }\\n            .sumBy { it * (it-1)/2 }\\n```",
                "solutionTags": [],
                "code": "```\\ndominoes.groupBy { it.min() to it.max() }\\n            .map { it.value.size }\\n            .sumBy { it * (it-1)/2 }\\n```\n```\\ndominoes.groupBy { maxOf(it[0], it[1]) * 10 + minOf(it[0], it[1]) }\\n            .map { it.value.size }\\n            .sumBy { it * (it-1)/2 }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 501941,
                "title": "very-slow-but-work-javascript-solution",
                "content": "```\\n/**\\n * @param {number[][]} dominoes\\n * @return {number}\\n */\\nvar numEquivDominoPairs = function(dom) {\\n  let count = 0;\\n  \\n  for (let i = 0; i < dom.length; i++) {\\n    for (let j = i + 1; j < dom.length; j++) {\\n      if (dom[i][0] === dom[j][0] && dom[i][1] === dom[j][1] ||\\n          dom[i][0] === dom[j][1] && dom[i][1] === dom[j][0]) count++;\\n    }\\n  }\\n  \\n  return count;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} dominoes\\n * @return {number}\\n */\\nvar numEquivDominoPairs = function(dom) {\\n  let count = 0;\\n  \\n  for (let i = 0; i < dom.length; i++) {\\n    for (let j = i + 1; j < dom.length; j++) {\\n      if (dom[i][0] === dom[j][0] && dom[i][1] === dom[j][1] ||\\n          dom[i][0] === dom[j][1] && dom[i][1] === dom[j][0]) count++;\\n    }\\n  }\\n  \\n  return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 476594,
                "title": "python-double-100",
                "content": "```\\nclass Solution(object):\\n    def numEquivDominoPairs(self, dominoes):\\n        \"\"\"\\n        :type dominoes: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        dic = [0]*100\\n        for i, j in dominoes:\\n            if i > j:\\n                i, j = j, i\\n            dic[i*10+j] += 1 \\n        res = 0\\n        for i in range(11,100):\\n            if dic[i] > 1:\\n                res += (dic[i]-1)*dic[i]/2\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def numEquivDominoPairs(self, dominoes):\\n        \"\"\"\\n        :type dominoes: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        dic = [0]*100\\n        for i, j in dominoes:\\n            if i > j:\\n                i, j = j, i\\n            dic[i*10+j] += 1 \\n        res = 0\\n        for i in range(11,100):\\n            if dic[i] > 1:\\n                res += (dic[i]-1)*dic[i]/2\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 466249,
                "title": "swift-code-o-n-space-and-time-complexity-solution",
                "content": "```\\nclass Solution {\\n    func numEquivDominoPairs(_ dominoes: [[Int]]) -> Int {\\n        var dict = [String: Int](), count = 0\\n        for pairs in dominoes{\\n            let minimum: Int = min(pairs[0], pairs[1])\\n            let maximum: Int = max(pairs[0], pairs[1])\\n            let number = String(\"\\\\(minimum)\\\\(maximum)\")\\n            if let occurance = dict[number]{\\n                dict[number] = occurance + 1\\n                count += dict[number]!\\n            }else{\\n                dict[number] = 0\\n            }\\n        }\\n        return count\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func numEquivDominoPairs(_ dominoes: [[Int]]) -> Int {\\n        var dict = [String: Int](), count = 0\\n        for pairs in dominoes{\\n            let minimum: Int = min(pairs[0], pairs[1])\\n            let maximum: Int = max(pairs[0], pairs[1])\\n            let number = String(\"\\\\(minimum)\\\\(maximum)\")\\n            if let occurance = dict[number]{\\n                dict[number] = occurance + 1\\n                count += dict[number]!\\n            }else{\\n                dict[number] = 0\\n            }\\n        }\\n        return count\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 462146,
                "title": "go-98-solution",
                "content": "```go\\nfunc numEquivDominoPairs(dominoes [][]int) int {\\n\\tmagic := map[[2]int]int{}\\n\\tfor i := range dominoes {\\n\\t\\tsort.Ints(dominoes[i])\\n\\t\\tmagic[[2]int{dominoes[i][0], dominoes[i][1]}]++\\n\\t}\\n\\n\\tdominoPairCount := 0\\n\\tfor _, v := range magic {\\n\\t\\tdominoPairCount += helper(v)\\n\\t}\\n\\treturn dominoPairCount\\n}\\n\\nfunc helper(n int) int  {\\n\\tif n < 2 {\\n\\t\\treturn 0\\n\\t}\\n\\tn *= n-1\\n\\treturn n / 2\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```go\\nfunc numEquivDominoPairs(dominoes [][]int) int {\\n\\tmagic := map[[2]int]int{}\\n\\tfor i := range dominoes {\\n\\t\\tsort.Ints(dominoes[i])\\n\\t\\tmagic[[2]int{dominoes[i][0], dominoes[i][1]}]++\\n\\t}\\n\\n\\tdominoPairCount := 0\\n\\tfor _, v := range magic {\\n\\t\\tdominoPairCount += helper(v)\\n\\t}\\n\\treturn dominoPairCount\\n}\\n\\nfunc helper(n int) int  {\\n\\tif n < 2 {\\n\\t\\treturn 0\\n\\t}\\n\\tn *= n-1\\n\\treturn n / 2\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 454287,
                "title": "python3-two-methods-using-hash-table-and-itertools-combinations",
                "content": "```\\nimport itertools\\n\\nclass Solution:\\n\\tdef numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n\\t\\tht = {}\\n\\t\\tfor dom in dominoes:\\n\\t\\t\\tht[tuple(sorted(dom))] = ht.get(tuple(sorted(dom)),0) + 1\\n\\t\\tcount = 0\\n\\t\\tfor pair in ht:\\n\\t\\t\\tcount += ht[pair]*(ht[pair]-1)//2\\n\\t\\treturn count\\n\\nclass Solution1:\\n\\tdef numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n\\t\\tif len(dominoes) <= 1:\\n\\t\\t\\treturn 0\\n\\n\\t\\tcombs = [x for x in itertools.combinations(dominoes,2)]\\n\\t\\tcount = 0\\n\\t\\tfor item in combs:\\n\\t\\t\\tif min(item[0]) == min(item[1]) and max(item[0]) == max(item[1]):\\n\\t\\t\\t\\tcount += 1\\n\\t\\treturn count\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nimport itertools\\n\\nclass Solution:\\n\\tdef numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n\\t\\tht = {}\\n\\t\\tfor dom in dominoes:\\n\\t\\t\\tht[tuple(sorted(dom))] = ht.get(tuple(sorted(dom)),0) + 1\\n\\t\\tcount = 0\\n\\t\\tfor pair in ht:\\n\\t\\t\\tcount += ht[pair]*(ht[pair]-1)//2\\n\\t\\treturn count\\n\\nclass Solution1:\\n\\tdef numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n\\t\\tif len(dominoes) <= 1:\\n\\t\\t\\treturn 0\\n\\n\\t\\tcombs = [x for x in itertools.combinations(dominoes,2)]\\n\\t\\tcount = 0\\n\\t\\tfor item in combs:\\n\\t\\t\\tif min(item[0]) == min(item[1]) and max(item[0]) == max(item[1]):\\n\\t\\t\\t\\tcount += 1\\n\\t\\treturn count\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 450685,
                "title": "bruteforce-java",
                "content": "\\tclass Solution {\\n\\t\\tpublic int numEquivDominoPairs(int[][] d) {\\n\\t\\t\\tint[] visit= new int[d.length];\\n\\t\\t\\tint ans=0;\\n\\t\\t\\tfor(int i=0;i<d.length;i++){\\n\\t\\t\\t\\tans=fn(d,i,visit,ans);\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t\\tpublic int fn(int[][] d, int x,int[] visit, int ans){\\n\\t\\t\\tint count=0;\\n\\t\\t\\tif(visit[x]==0){   \\n\\t\\t\\t\\tvisit[x]=1;\\n\\t\\t\\t\\tfor(int i=0;i<d.length; i++){\\n\\t\\t\\t\\t\\tif(visit[i]==0){\\n\\t\\t\\t\\t\\t\\tif(d[x][0]==d[i][0]&&d[x][1]==d[i][1]){\\n\\t\\t\\t\\t\\t\\t\\tvisit[i]=1;\\n\\t\\t\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t\\t\\t}else if(d[x][1]==d[i][0]&&d[x][0]==d[i][1]){\\n\\t\\t\\t\\t\\t\\t\\t visit[i]=1;\\n\\t\\t\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t} \\n\\t\\t\\t\\tans=ans+((count)*(count+1))/2;\\n\\t\\t\\t}  \\n\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\t\\tpublic int numEquivDominoPairs(int[][] d) {\\n\\t\\t\\tint[] visit= new int[d.length];\\n\\t\\t\\tint ans=0;\\n\\t\\t\\tfor(int i=0;i<d.length;i++){\\n\\t\\t\\t\\tans=fn(d,i,visit,ans);\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 444487,
                "title": "python-hashmap-100-100",
                "content": "```Python\\nclass Solution:\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        maps = {}\\n        count = 0\\n        for i in dominoes:\\n            if (i[0],i[1]) not in maps and  (i[1],i[0]) not in maps:\\n                maps[(i[0],i[1])] = 1\\n            else:\\n                if (i[0],i[1]) in maps:\\n                    maps[(i[0],i[1])] += 1\\n                else:\\n                    maps[(i[1],i[0])] += 1\\n        count = 0\\n        for i in maps:\\n            if maps[i] >= 2:\\n                count += maps[i] * (maps[i]-1)//2\\n        return count\\n```",
                "solutionTags": [],
                "code": "```Python\\nclass Solution:\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        maps = {}\\n        count = 0\\n        for i in dominoes:\\n            if (i[0],i[1]) not in maps and  (i[1],i[0]) not in maps:\\n                maps[(i[0],i[1])] = 1\\n            else:\\n                if (i[0],i[1]) in maps:\\n                    maps[(i[0],i[1])] += 1\\n                else:\\n                    maps[(i[1],i[0])] += 1\\n        count = 0\\n        for i in maps:\\n            if maps[i] >= 2:\\n                count += maps[i] * (maps[i]-1)//2\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 427312,
                "title": "hashmap-easy-to-uderstand-o-n-time-and-o-1-space",
                "content": "```\\nclass Solution {\\npublic:\\n    int numEquivDominoPairs(vector<vector<int>>& dominoes) \\n    {\\n        map<pair<int,int>,int> mp;\\n        int cnt=0;\\n        for(auto& x:dominoes)\\n        {\\n            int a=min(x[0],x[1]);\\n            int b=max(x[0],x[1]);\\n            cnt+=mp[{a,b}]++;\\n        }\\n        \\n       \\n        \\n        return cnt;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numEquivDominoPairs(vector<vector<int>>& dominoes) \\n    {\\n        map<pair<int,int>,int> mp;\\n        int cnt=0;\\n        for(auto& x:dominoes)\\n        {\\n            int a=min(x[0],x[1]);\\n            int b=max(x[0],x[1]);\\n            cnt+=mp[{a,b}]++;\\n        }\\n        \\n       \\n        \\n        return cnt;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 407991,
                "title": "java-o-n-method-using-hashmap",
                "content": "```\\n\\tpublic int numEquivDominoPairs(int[][] dominoes) {\\n\\t\\tMap<String, Integer> dominoToFrequency = new HashMap<>();\\n\\t\\tint count = 0;\\n\\t\\tfor(int[] domino : dominoes) {\\n\\t\\t\\tString key = \"\" + Math.min(domino[0], domino[1]) + Math.max(domino[0], domino[1]);\\n\\t\\t\\tdominoToFrequency.put(key, dominoToFrequency.getOrDefault(key, 0) + 1);\\n\\t\\t}\\n\\t\\t\\n\\t\\tfor(Map.Entry<String, Integer> domino : dominoToFrequency.entrySet()) {\\n\\t\\t\\tint n = domino.getValue();\\n\\t\\t\\tif(n >= 2) {\\n\\t\\t\\t\\tcount += n*(n-1)/2;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn count;\\n\\t}\\n```",
                "solutionTags": [],
                "code": "```\\n\\tpublic int numEquivDominoPairs(int[][] dominoes) {\\n\\t\\tMap<String, Integer> dominoToFrequency = new HashMap<>();\\n\\t\\tint count = 0;\\n\\t\\tfor(int[] domino : dominoes) {\\n\\t\\t\\tString key = \"\" + Math.min(domino[0], domino[1]) + Math.max(domino[0], domino[1]);\\n\\t\\t\\tdominoToFrequency.put(key, dominoToFrequency.getOrDefault(key, 0) + 1);\\n\\t\\t}\\n\\t\\t\\n\\t\\tfor(Map.Entry<String, Integer> domino : dominoToFrequency.entrySet()) {\\n\\t\\t\\tint n = domino.getValue();\\n\\t\\t\\tif(n >= 2) {\\n\\t\\t\\t\\tcount += n*(n-1)/2;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn count;\\n\\t}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 407141,
                "title": "easy-java-o-n",
                "content": "```\\n    public static int numEquivDominoPairs(int[][] dominoes) {\\n        int[][] count  =  new int[10][10];\\n        int ans = 0;\\n        for (int[] dominoe : dominoes) {\\n            ans += count[dominoe[0]][dominoe[1]];\\n            if(dominoe[0] != dominoe[1]) {\\n                ans += count[dominoe[1]][dominoe[0]];\\n            }\\n            count[dominoe[0]][dominoe[1]]++;\\n   \\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public static int numEquivDominoPairs(int[][] dominoes) {\\n        int[][] count  =  new int[10][10];\\n        int ans = 0;\\n        for (int[] dominoe : dominoes) {\\n            ans += count[dominoe[0]][dominoe[1]];\\n            if(dominoe[0] != dominoe[1]) {\\n                ans += count[dominoe[1]][dominoe[0]];\\n            }\\n            count[dominoe[0]][dominoe[1]]++;\\n   \\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 391994,
                "title": "python-easy-understading",
                "content": "```\\ndic = {}\\nfor dominoe in dominoes:\\n\\ttmp = max(dominoe)*10 + min(dominoe)\\n\\tif tmp in dic: dic[tmp] += 1\\n\\telse: dic[tmp] = 0\\n\\nres = 0\\nfor ele in dic:\\n\\tres += dic[ele]*(dic[ele]+1)//2\\n\\nreturn res\\n```",
                "solutionTags": [],
                "code": "```\\ndic = {}\\nfor dominoe in dominoes:\\n\\ttmp = max(dominoe)*10 + min(dominoe)\\n\\tif tmp in dic: dic[tmp] += 1\\n\\telse: dic[tmp] = 0\\n\\nres = 0\\nfor ele in dic:\\n\\tres += dic[ele]*(dic[ele]+1)//2\\n\\nreturn res\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 378223,
                "title": "java-o-n-time-o-n-space",
                "content": "Approach 1: For each domino, look for all domions to the right, and count all such pairs. Time: O(n^2), Space: O(1)  \\n\\nApproach 2: Sort the dominoes so that all equivalent dominos come together. For this make one pass to fix all such dominos where domino[0] > domino[1]. So each domino will have domino[0] <= domino[1]. After sorting count the equal domino pairs. Time: O(nlogn), Space: O(1) \\n\\nApproach 3: Use hashing. Time: O(n), Space: O(1)\\n\\n```\\nclass Solution {\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        Map<Integer, Integer> map = new HashMap<>();  \\n        int count = 0; \\n        for(int[] d : dominoes) {\\n            int key = Math.min(d[0],d[1])*10 + Math.max(d[0],d[1]); \\n            map.put(key, map.getOrDefault(key,0)+1);\\n        }\\n        for(int v : map.values()) count += v*(v-1)/2; \\n        return count; \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        Map<Integer, Integer> map = new HashMap<>();  \\n        int count = 0; \\n        for(int[] d : dominoes) {\\n            int key = Math.min(d[0],d[1])*10 + Math.max(d[0],d[1]); \\n            map.put(key, map.getOrDefault(key,0)+1);\\n        }\\n        for(int v : map.values()) count += v*(v-1)/2; \\n        return count; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 378146,
                "title": "python-o-n-with-frozenset",
                "content": "A lot of other solutions encode an entry with something like `min(a, b) + 10 * max(a, b)`. My first thought was to use a `Set`. However, `Set` in Python is not hashable. I ended up using a `frozenset` and a `dictionary`.\\n\\nEnjoy!\\n\\n```\\nclass Solution:\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        dominoes_count = 0\\n        sets = {}\\n        for pair in dominoes:\\n            this_set = frozenset(pair)\\n            if this_set in sets:\\n                dominoes_count += sets[this_set]\\n                sets[this_set] += 1\\n            else:\\n                sets[this_set] = 1\\n        return dominoes_count\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution:\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        dominoes_count = 0\\n        sets = {}\\n        for pair in dominoes:\\n            this_set = frozenset(pair)\\n            if this_set in sets:\\n                dominoes_count += sets[this_set]\\n                sets[this_set] += 1\\n            else:\\n                sets[this_set] = 1\\n        return dominoes_count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 377910,
                "title": "python-o-n-time-o-n-memory-2-pass-solution",
                "content": "```\\nclass Solution:\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        dict = {}\\n        res = 0\\n        for domino in dominoes:\\n            if domino[0] > domino[1]:\\n                val = tuple([domino[1], domino[0]])\\n            else:\\n                val = tuple(domino)\\n            freq = dict.get(val, 0) + 1\\n            dict[val] = freq\\n        for key in dict:\\n            res += dict[key]*(dict[key] - 1)//2\\n        return res\\n",
                "solutionTags": [],
                "code": "class Solution:\\n    def numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n        dict = {}",
                "codeTag": "Java"
            },
            {
                "id": 372149,
                "title": "easy-c-solution-using-maps-beats-88-100",
                "content": "Runtime: 40 ms\\nMemory Usage: 20.9 MB\\n\\n```\\nint numEquivDominoPairs(vector<vector<int>>& dominoes) {\\n        \\n        int n = dominoes.size();\\n        map<pair<int,int>, int> mp;\\n        \\n        int count = 0;\\n        for(int i=0; i<n; i++)\\n        {\\n            int minVal = min(dominoes[i][0], dominoes[i][1]);\\n            int maxVal = max(dominoes[i][0], dominoes[i][1]);\\n            \\n            pair<int, int> newEntry{minVal, maxVal};\\n            \\n            if(mp.find(newEntry) != mp.end())\\n            {\\n                count += mp[newEntry];\\n                mp[newEntry]++;\\n            }\\n            else\\n                mp.insert({newEntry, 1});\\n        }\\n        \\n        return count;\\n    }",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "Runtime: 40 ms\\nMemory Usage: 20.9 MB\\n\\n```\\nint numEquivDominoPairs(vector<vector<int>>& dominoes) {\\n        \\n        int n = dominoes.size();\\n        map<pair<int,int>, int> mp;\\n        \\n        int count = 0;\\n        for(int i=0; i<n; i++)\\n        {\\n            int minVal = min(dominoes[i][0], dominoes[i][1]);\\n            int maxVal = max(dominoes[i][0], dominoes[i][1]);\\n            \\n            pair<int, int> newEntry{minVal, maxVal};\\n            \\n            if(mp.find(newEntry) != mp.end())\\n            {\\n                count += mp[newEntry];\\n                mp[newEntry]++;\\n            }\\n            else\\n                mp.insert({newEntry, 1});\\n        }\\n        \\n        return count;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 367870,
                "title": "python",
                "content": "```\\ndef numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n      a = set()\\n      dic = {}\\n      for dom in dominoes:\\n          temp = sorted(dom)\\n          if (temp[0], temp[1]) in dic:\\n              dic[(temp[0], temp[1])] +=  1\\n          else:\\n              dic[(temp[0], temp[1])] =  1\\n       \\n      res = 0\\n      for key, values in dic.items():\\n          if values > 1:\\n              values = values - 1\\n              while values > 0:\\n                  res += values \\n                  values -= 1\\n      return res\\n\\t \\n```",
                "solutionTags": [],
                "code": "```\\ndef numEquivDominoPairs(self, dominoes: List[List[int]]) -> int:\\n      a = set()\\n      dic = {}\\n      for dom in dominoes:\\n          temp = sorted(dom)\\n          if (temp[0], temp[1]) in dic:\\n              dic[(temp[0], temp[1])] +=  1\\n          else:\\n              dic[(temp[0], temp[1])] =  1\\n       \\n      res = 0\\n      for key, values in dic.items():\\n          if values > 1:\\n              values = values - 1\\n              while values > 0:\\n                  res += values \\n                  values -= 1\\n      return res\\n\\t \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 356136,
                "title": "java-o-n",
                "content": "```\\nclass Solution {\\n    public int numEquivDominoPairs(int[][] d) {\\n        \\n        Map<Integer, Integer> map = new HashMap();\\n        for (int[] x : d)\\n        {\\n            Arrays.sort(x);\\n            int sig = x[0] * 10 + x[1];\\n            map.put(sig, map.getOrDefault(sig, 0) + 1);\\n        }\\n        \\n        int count = 0;\\n        for (int c : map.values())\\n        {\\n            if (c >= 2)\\n            {\\n                count += c * (c - 1) / 2;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numEquivDominoPairs(int[][] d) {\\n        \\n        Map<Integer, Integer> map = new HashMap();\\n        for (int[] x : d)\\n        {\\n            Arrays.sort(x);\\n            int sig = x[0] * 10 + x[1];\\n            map.put(sig, map.getOrDefault(sig, 0) + 1);\\n        }\\n        \\n        int count = 0;\\n        for (int c : map.values())\\n        {\\n            if (c >= 2)\\n            {\\n                count += c * (c - 1) / 2;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 354782,
                "title": "go-hashing-o-n-beats-100-space",
                "content": "```\\nfunc numEquivDominoPairs(dominoes [][]int) int {\\n    hash, pairs := make(map[string]int), 0\\n    for _, d := range dominoes {\\n        // generate key and reverse key\\n        key, revKey := fmt.Sprintf(\"%v:%v\",d[0],d[1]), fmt.Sprintf(\"%v:%v\",d[1],d[0])\\n        // look for previous pair\\n        if occurs, exists := hash[key]; exists {\\n            pairs += occurs\\n        }\\n        // count occurance\\n        hash[key]++\\n        if d[0] != d[1] {   // prevent [1,1] from double counting\\n            hash[revKey]++\\n        }\\n        \\n    }\\n    return pairs\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc numEquivDominoPairs(dominoes [][]int) int {\\n    hash, pairs := make(map[string]int), 0\\n    for _, d := range dominoes {\\n        // generate key and reverse key\\n        key, revKey := fmt.Sprintf(\"%v:%v\",d[0],d[1]), fmt.Sprintf(\"%v:%v\",d[1],d[0])\\n        // look for previous pair\\n        if occurs, exists := hash[key]; exists {\\n            pairs += occurs\\n        }\\n        // count occurance\\n        hash[key]++\\n        if d[0] != d[1] {   // prevent [1,1] from double counting\\n            hash[revKey]++\\n        }\\n        \\n    }\\n    return pairs\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 354732,
                "title": "easy-understand-c-solution",
                "content": "For each pair, make sure v[0] > v[1] and use v[0] * 10 + v[1] to represent it. \\n\\nLoop the vector and use hashmap to store each kind of equivalent pair numbers. \\n\\nWe can count the answer while looping, If preiously the number of [1, 0] is n for example, if a new [1,0] equivalent piar is find, then the ans will increased by n\\n\\n```\\n    int numEquivDominoPairs(vector<vector<int>>& dominoes) {\\n        unordered_map<int, int> m;\\n        int rv = 0;\\n        for (auto &v : dominoes) {\\n            if (v[0] < v[1]) {\\n                swap(v[0], v[1]);\\n            }\\n            int i = v[0] * 10 + v[1];\\n            rv += m[i];\\n            ++m[i];\\n        }\\n        return rv;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    int numEquivDominoPairs(vector<vector<int>>& dominoes) {\\n        unordered_map<int, int> m;\\n        int rv = 0;\\n        for (auto &v : dominoes) {\\n            if (v[0] < v[1]) {\\n                swap(v[0], v[1]);\\n            }\\n            int i = v[0] * 10 + v[1];\\n            rv += m[i];\\n            ++m[i];\\n        }\\n        return rv;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 347629,
                "title": "java-o-n-time-o-n-space-hashmap-easy-solution",
                "content": "```\\nclass Solution {\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        Map<String,Integer> map = new HashMap();\\n        int ans=0;\\n        for(int[] each: dominoes){\\n            String x = each[0]<each[1] ? each[0]+\",\"+each[1] : each[1]+\",\"+each[0];\\n           if(!map.containsKey(x)){\\n                map.put(x,0);\\n           }\\n           int count=map.get(x);\\n            map.put(x,count+1);\\n          }\\n          for(Map.Entry<String,Integer> curr:map.entrySet()){\\n                int cuCo=curr.getValue();\\n                ans+= (cuCo*(cuCo-1))/2;\\n            }\\n      return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        Map<String,Integer> map = new HashMap();\\n        int ans=0;\\n        for(int[] each: dominoes){\\n            String x = each[0]<each[1] ? each[0]+\",\"+each[1] : each[1]+\",\"+each[0];\\n           if(!map.containsKey(x)){\\n                map.put(x,0);\\n           }\\n           int count=map.get(x);\\n            map.put(x,count+1);\\n          }\\n          for(Map.Entry<String,Integer> curr:map.entrySet()){\\n                int cuCo=curr.getValue();\\n                ans+= (cuCo*(cuCo-1))/2;\\n            }\\n      return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 340718,
                "title": "java-super-simple-and-clean-9-line-o-n-solution-beats-100-time-and-100-space",
                "content": "```\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        Map<Integer, Integer> map=new HashMap<>();\\n        for(int i=0;i<dominoes.length;i++) {\\n            int tmp=10*Math.min(dominoes[i][0], dominoes[i][1])+Math.max(dominoes[i][0], dominoes[i][1]);\\n            if(map.containsKey(tmp)) map.put(tmp, map.get(tmp)+1);\\n            else map.put(tmp, 1);\\n        }\\n        int res=0;\\n        for(int i : map.values()) res+=i*(i-1)/2;\\n        return res;\\n    }",
                "solutionTags": [],
                "code": "```\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        Map<Integer, Integer> map=new HashMap<>();\\n        for(int i=0;i<dominoes.length;i++) {\\n            int tmp=10*Math.min(dominoes[i][0], dominoes[i][1])+Math.max(dominoes[i][0], dominoes[i][1]);\\n            if(map.containsKey(tmp)) map.put(tmp, map.get(tmp)+1);\\n            else map.put(tmp, 1);\\n        }\\n        int res=0;\\n        for(int i : map.values()) res+=i*(i-1)/2;\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 340324,
                "title": "c-solution-o-n",
                "content": "```\\npublic class Solution \\n{\\n    public int NumEquivDominoPairs(int[][] dominoes) \\n    {\\n        var dict = new Dictionary<string, int>();\\n        int sum = 0;\\n        foreach(var d in dominoes)\\n        {\\n            var key = d[0] < d[1] ? d[0] + \":\" + d[1] : d[1] + \":\" + d[0];\\n            if(!dict.ContainsKey(key)) dict[key] = 1;\\n            else sum += dict[key]++;\\n        }\\n        \\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution \\n{\\n    public int NumEquivDominoPairs(int[][] dominoes) \\n    {\\n        var dict = new Dictionary<string, int>();\\n        int sum = 0;\\n        foreach(var d in dominoes)\\n        {\\n            var key = d[0] < d[1] ? d[0] + \":\" + d[1] : d[1] + \":\" + d[0];\\n            if(!dict.ContainsKey(key)) dict[key] = 1;\\n            else sum += dict[key]++;\\n        }\\n        \\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 340252,
                "title": "the-description-is-wrong-isn-t-it",
                "content": "Initially I write my code according to my comprehension about the description, the test result confuses me. Then I read you guys\\' post, I think the description doesn\\'t match what this problem really want us to do.\\n\\n**Let\\'s look at the description:**\\n###### Given a list of dominoes, dominoes[i] = [a, b] is equivalent to dominoes[j] = [c, d] if and only if either (a==c and b==d), or (a==d and b==c) - that is, one domino can be rotated to be equal to another domino.\\n###### \\n###### Return the number of pairs (i, j) for which 0 <= i < j < dominoes.length, and dominoes[i] is equivalent to dominoes[j].\\n\\nFristly, it demands that a qualified pair (i, j) should satisfy 0<= i < j < length, notice that it\\'s strictly smaller, shouldn\\'t include i <= j.\\nSecondly, for a qualified pair (i,j), it asks us to make sure that dominoes[i] is supposed to be equivalent to dominoes[j]. a.k.a. the i th element of the input dominoes should be identical or can be rotated to j th element. \\n\\n(I assume that sequence starts from 1 instead of 0 given the example test case.) Look at the example test case:\\n###### Input: dominoes = [[1,2],[2,1],[3,4],[5,6]]\\n###### Output: 1\\nAs far as I understand, the logic goes this way:\\n###### 1. The 1st element [1,2] satisfy 0<=i<j<length, and the ith element [1,2] is equivalent to the jth element [2,1], so the answer=0+1=1;\\n###### 2. The 2nd element [2,1] doesn\\'t satisfy 0<=i<j<length, we skip it;\\n###### 3. The 3rd element [3,4] satisfy 0<=i<j<length, but the ith element [3,4] is not equivaleng to the jth element [5,6], the answer remains 1;\\n###### 4. The 4th element doesn\\'t satisfy 0<=i<j<length cuz length=4, we skip it.\\nSo the result is 1.\\n\\nThus here\\'s what I submit in the first place:\\n```\\nclass Solution {\\npublic:\\n    int numEquivDominoPairs(vector<vector<int>>& dominoes) {\\n        int result=0, length=dominoes.size();\\n        for (auto domino : dominoes) {\\n            int first=domino[0]-1, second=domino[1]-1;\\n            if (first<second&&second<length) {\\n                if ((dominoes[first][0]==dominoes[second][0]&&\\n                        dominoes[first][1]==dominoes[second][1])\\n                    ||\\n                    (dominoes[first][0]==dominoes[second][1]&&\\n                        dominoes[first][1]==dominoes[second][0]))\\n                    ++result;\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```\\nBut it didn\\'t pass. Take this failed test case for example:\\n###### Input:\\n###### [[1,1],[2,2],[1,1],[1,2],[1,2],[1,1]]\\n###### Output:\\n###### 0\\n###### Expected:\\n###### 4\\nonly the 4th and 5th elements (i.e. [1,2]) satisfy 0<=i<j<length, let alone neither of them satisfy **dominoes[i] equals to dominoes[j]**.\\nI take a look at other users\\' post, then I figure out that correct answer\\'s logic is completely different from what the description asks for. For instance, from the most voted  post, he encodes each group of equivalent pairs with a 2-digit number and store the count appearance frequency of them in a hash map. I didn\\'t mean that this idea isn\\'t perspicacious, but that solution doesn\\'t filter out domino pair that doesn\\'t satisfy **0<=i<j<length**, it doesn\\'t has anything to do with whether the ith element is equal to the jth element either. What the judge system want us to write is simply not what the description told us, and I\\'m confused why I didn\\'t see anyone point this out.\\nIt might be possible that I misunderstood the description as well, I made the same mistake before. Although this is just a simple problem, the cognitive difference makes me uncomfortable. If there\\'s a clear vulnerability in my reading comprehension about the description, welcome to correct me.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numEquivDominoPairs(vector<vector<int>>& dominoes) {\\n        int result=0, length=dominoes.size();\\n        for (auto domino : dominoes) {\\n            int first=domino[0]-1, second=domino[1]-1;\\n            if (first<second&&second<length) {\\n                if ((dominoes[first][0]==dominoes[second][0]&&\\n                        dominoes[first][1]==dominoes[second][1])\\n                    ||\\n                    (dominoes[first][0]==dominoes[second][1]&&\\n                        dominoes[first][1]==dominoes[second][0]))\\n                    ++result;\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 340096,
                "title": "python-solution",
                "content": "```\\nclass Solution(object):\\n    def numEquivDominoPairs(self, dominoes):\\n        \"\"\"\\n        :type dominoes: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        d = {}\\n        res = 0\\n        for i, j in dominoes:\\n            mi, ma = (i, j) if i <=j else (j, i)\\n            key = \\'%d_%d\\' % (mi, ma)\\n            if key not in d:\\n                d[key] = 0\\n            \\n            res += d[key]\\n            \\n            d[key] += 1\\n        \\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def numEquivDominoPairs(self, dominoes):\\n        \"\"\"\\n        :type dominoes: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        d = {}\\n        res = 0\\n        for i, j in dominoes:\\n            mi, ma = (i, j) if i <=j else (j, i)\\n            key = \\'%d_%d\\' % (mi, ma)\\n            if key not in d:\\n                d[key] = 0\\n            \\n            res += d[key]\\n            \\n            d[key] += 1\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 340015,
                "title": "can-any-one-explain-the-problem",
                "content": "Consider below two scenarios:\\n\\n[[1,2],[2,1],[3,4],[5,6]]\\n[1,2] appears twice - expected result = 1\\nIt is repeated once\\n\\n[[1,2],[1,2],[1,1],[1,2],[2,2]]\\n[1,2] appears thrice - expected result = 3\\n\\nIn first case [[1,2] , [1,2]]  = count = 1\\nThen in second case [[1,2] ,[1,2] , [1,2]] count = 2\\nTotal count = 3\\n\\nI still can\\'t get significance of counting like this - it could have straightforward if result of first scenario= 2 & second = 3. Can any one explain more on this?\\n\\nAfter finishing the contest, Based on this, I got following solution (C#):\\n``` csharp\\n    public int NumEquivDominoPairs(int[][] dominoes) {\\n        Dictionary<(int, int), int> frequency = new Dictionary<(int, int), int>();\\n        int count = 0;\\n        \\n        for(int i = 0; i < dominoes.Length; i++)\\n        {\\n           int d1 = dominoes[i][0];\\n           int d2 = dominoes[i][1];\\n            \\n           if(d1 > d2)\\n           {\\n               int t = d2;\\n               d2 = d1;\\n               d1 = t;\\n           }\\n               \\n           if(frequency.ContainsKey((d1, d2)))\\n           {              \\n               count += frequency[(d1,d2)]++;\\n           }\\n           else\\n           {\\n               frequency[(d1,d2)] = 1;\\n           }           \\n        }        \\n        \\n        return count;\\n    }\\n```",
                "solutionTags": [],
                "code": "``` csharp\\n    public int NumEquivDominoPairs(int[][] dominoes) {\\n        Dictionary<(int, int), int> frequency = new Dictionary<(int, int), int>();\\n        int count = 0;\\n        \\n        for(int i = 0; i < dominoes.Length; i++)\\n        {\\n           int d1 = dominoes[i][0];\\n           int d2 = dominoes[i][1];\\n            \\n           if(d1 > d2)\\n           {\\n               int t = d2;\\n               d2 = d1;\\n               d1 = t;\\n           }\\n               \\n           if(frequency.ContainsKey((d1, d2)))\\n           {              \\n               count += frequency[(d1,d2)]++;\\n           }\\n           else\\n           {\\n               frequency[(d1,d2)] = 1;\\n           }           \\n        }        \\n        \\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 340010,
                "title": "java-o-n-solution-with-constant-space",
                "content": "```\\nclass Solution {\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n\\t    // Construct an array to contain the number of occurrences of all possible ways of number combinations\\n        int[] ref = new int[45];\\n        int res = 0;\\n\\t\\t// Iterate through the dominoes and increment the number of occurrences accordingly\\n        for (int i = 0; i < dominoes.length; i++) {\\n            int[] thisArr = dominoes[i];\\n            int small = Math.min(thisArr[0], thisArr[1]);\\n            int big = Math.max(thisArr[0], thisArr[1]);\\n            ref[10 * (small - 1) + big - small * (small + 1) / 2] += 1;\\n        }\\n       // Number of pairs of dominoes by permutation\\n        for (int i = 0; i < ref.length; i++) {\\n            if (ref[i] > 1) {\\n                res += ref[i] * (ref[i] - 1) / 2;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n\\t    // Construct an array to contain the number of occurrences of all possible ways of number combinations\\n        int[] ref = new int[45];\\n        int res = 0;\\n\\t\\t// Iterate through the dominoes and increment the number of occurrences accordingly\\n        for (int i = 0; i < dominoes.length; i++) {\\n            int[] thisArr = dominoes[i];\\n            int small = Math.min(thisArr[0], thisArr[1]);\\n            int big = Math.max(thisArr[0], thisArr[1]);\\n            ref[10 * (small - 1) + big - small * (small + 1) / 2] += 1;\\n        }\\n       // Number of pairs of dominoes by permutation\\n        for (int i = 0; i < ref.length; i++) {\\n            if (ref[i] > 1) {\\n                res += ref[i] * (ref[i] - 1) / 2;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1566999,
                "content": [
                    {
                        "username": "musmanrao1994",
                        "content": "Why is `[[1,2],[1,2],[1,1],[1,2],[2,2]]` 3,\\nbut `[[1,2],[2,1],[3,4],[5,6]]` is 1?\\n\\n"
                    },
                    {
                        "username": "pingmehard",
                        "content": "In the first list you have three pairs: \\n0 index and 1 index\\n0 index and 3 index\\n1 index and 3 index\\nSo they are different. You can\\'t reuse it if you already count it.\\n\\nIn the second you have only one unique pair of dominoes.\\nIndex 0 and index 1\\n\\nSo you can\\'t count pair index 1 and index 0, because it\\'s the same."
                    },
                    {
                        "username": "aro",
                        "content": "The definition of \"pair\" is neither normal nor well-defined..."
                    },
                    {
                        "username": "YusenPeng",
                        "content": " brute force failed?\\nHint: use HashMap."
                    },
                    {
                        "username": "IliasDeros",
                        "content": "Clarification:\n[1,2] is a single domino\n[1,2] and [3,4] is two different dominos\n[1,2] and [1,2] is a \"pair\" of two identical dominos.\n[1,2]; [1,2]; [1,2] can be mixed-and-matched to make 3 pairs, as the example suggests.\n\nThe question is to count how many \"pairs\" you can make, given a bunch of dominoes"
                    },
                    {
                        "username": "Supernova10",
                        "content": "wrong. then [[1,2],[2,1],[3,4],[5,6]] here [1,2], [2, 1] should be two pairs. which is not per consideration"
                    },
                    {
                        "username": "Danger-29",
                        "content": "i get 2328ms in submission of TC :)\\nclass Solution {\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        int count=0;\\n        for(int i =0;i<dominoes.length-1;i++){\\n       \\n                for(int k =i+1;k<dominoes.length;k++){\\n                 \\n                        if((dominoes[i][0] == dominoes[k][0] && dominoes[i][1] == dominoes[k][1]) || (dominoes[i][1] == dominoes[k][0] && dominoes[i][0] == dominoes[k][1]))\\n                        count++;\\n                    \\n                }\\n            \\n            \\n        }\\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "yush_2001",
                        "content": "[[1,1],[2,2],[1,1],[1,2],[1,2],[1,1]]\\nHow the answer is 4, it should be three, if we defined a pair as in the problem of all possible handshakes , if two people shakes hands exactly one time with each person. "
                    },
                    {
                        "username": "core_guru",
                        "content": "Some math:\\nWe have Permutations and Combinations. \\nPermutation (order matters):\\na, b, c: ab, ba, ac, ca, bc, cb\\nCombinations (order does not matter):\\na, b, c: ab, bc, ac\\nThis problem is a Combinations problem\\nFormula for Combinations:\\nC(n,r) = n!/( r! (n - r)! )\\n\\nSimplifying for r = 2:\\nC(n, 2) = n*(n-1)/2\\n\\nHope that clarifies the description a little bit."
                    },
                    {
                        "username": "alecoder",
                        "content": "If you need to understand why it works like this, you have to imagine how you would solve this problem with nested loops. You compare each matching and counting them as pairs.\nBut Map based solution confuses us because it increases count differently. But if you look closer, the idea is the same as we would do with nested loops."
                    },
                    {
                        "username": "arteml",
                        "content": "__Dominoes, the Second Wisest of all Games after Chess__\\n\\n[1,2]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_one_ dominoe, __zero__ pairs\\n\\n[1,2]--[1,2]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_two_ dominoes,   __one__ pair\\n      \\n[1,2]--[1,2]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_three_ dominoes,  __three__ pairs\\n |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/   \\n[1,2]  \\n\\n[1,2]---[1,2]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_four_ dominoes,  __six__ pairs\\n  |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;X &nbsp;&nbsp;&nbsp;    |\\n[1,2]---[1,2]\\n\\nNow you can derive a formula...\\n>    (and find out that you might have seen it many times before!!!)                          "
                    }
                ]
            },
            {
                "id": 1655925,
                "content": [
                    {
                        "username": "musmanrao1994",
                        "content": "Why is `[[1,2],[1,2],[1,1],[1,2],[2,2]]` 3,\\nbut `[[1,2],[2,1],[3,4],[5,6]]` is 1?\\n\\n"
                    },
                    {
                        "username": "pingmehard",
                        "content": "In the first list you have three pairs: \\n0 index and 1 index\\n0 index and 3 index\\n1 index and 3 index\\nSo they are different. You can\\'t reuse it if you already count it.\\n\\nIn the second you have only one unique pair of dominoes.\\nIndex 0 and index 1\\n\\nSo you can\\'t count pair index 1 and index 0, because it\\'s the same."
                    },
                    {
                        "username": "aro",
                        "content": "The definition of \"pair\" is neither normal nor well-defined..."
                    },
                    {
                        "username": "YusenPeng",
                        "content": " brute force failed?\\nHint: use HashMap."
                    },
                    {
                        "username": "IliasDeros",
                        "content": "Clarification:\n[1,2] is a single domino\n[1,2] and [3,4] is two different dominos\n[1,2] and [1,2] is a \"pair\" of two identical dominos.\n[1,2]; [1,2]; [1,2] can be mixed-and-matched to make 3 pairs, as the example suggests.\n\nThe question is to count how many \"pairs\" you can make, given a bunch of dominoes"
                    },
                    {
                        "username": "Supernova10",
                        "content": "wrong. then [[1,2],[2,1],[3,4],[5,6]] here [1,2], [2, 1] should be two pairs. which is not per consideration"
                    },
                    {
                        "username": "Danger-29",
                        "content": "i get 2328ms in submission of TC :)\\nclass Solution {\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        int count=0;\\n        for(int i =0;i<dominoes.length-1;i++){\\n       \\n                for(int k =i+1;k<dominoes.length;k++){\\n                 \\n                        if((dominoes[i][0] == dominoes[k][0] && dominoes[i][1] == dominoes[k][1]) || (dominoes[i][1] == dominoes[k][0] && dominoes[i][0] == dominoes[k][1]))\\n                        count++;\\n                    \\n                }\\n            \\n            \\n        }\\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "yush_2001",
                        "content": "[[1,1],[2,2],[1,1],[1,2],[1,2],[1,1]]\\nHow the answer is 4, it should be three, if we defined a pair as in the problem of all possible handshakes , if two people shakes hands exactly one time with each person. "
                    },
                    {
                        "username": "core_guru",
                        "content": "Some math:\\nWe have Permutations and Combinations. \\nPermutation (order matters):\\na, b, c: ab, ba, ac, ca, bc, cb\\nCombinations (order does not matter):\\na, b, c: ab, bc, ac\\nThis problem is a Combinations problem\\nFormula for Combinations:\\nC(n,r) = n!/( r! (n - r)! )\\n\\nSimplifying for r = 2:\\nC(n, 2) = n*(n-1)/2\\n\\nHope that clarifies the description a little bit."
                    },
                    {
                        "username": "alecoder",
                        "content": "If you need to understand why it works like this, you have to imagine how you would solve this problem with nested loops. You compare each matching and counting them as pairs.\nBut Map based solution confuses us because it increases count differently. But if you look closer, the idea is the same as we would do with nested loops."
                    },
                    {
                        "username": "arteml",
                        "content": "__Dominoes, the Second Wisest of all Games after Chess__\\n\\n[1,2]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_one_ dominoe, __zero__ pairs\\n\\n[1,2]--[1,2]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_two_ dominoes,   __one__ pair\\n      \\n[1,2]--[1,2]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_three_ dominoes,  __three__ pairs\\n |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/   \\n[1,2]  \\n\\n[1,2]---[1,2]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_four_ dominoes,  __six__ pairs\\n  |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;X &nbsp;&nbsp;&nbsp;    |\\n[1,2]---[1,2]\\n\\nNow you can derive a formula...\\n>    (and find out that you might have seen it many times before!!!)                          "
                    }
                ]
            },
            {
                "id": 1733401,
                "content": [
                    {
                        "username": "musmanrao1994",
                        "content": "Why is `[[1,2],[1,2],[1,1],[1,2],[2,2]]` 3,\\nbut `[[1,2],[2,1],[3,4],[5,6]]` is 1?\\n\\n"
                    },
                    {
                        "username": "pingmehard",
                        "content": "In the first list you have three pairs: \\n0 index and 1 index\\n0 index and 3 index\\n1 index and 3 index\\nSo they are different. You can\\'t reuse it if you already count it.\\n\\nIn the second you have only one unique pair of dominoes.\\nIndex 0 and index 1\\n\\nSo you can\\'t count pair index 1 and index 0, because it\\'s the same."
                    },
                    {
                        "username": "aro",
                        "content": "The definition of \"pair\" is neither normal nor well-defined..."
                    },
                    {
                        "username": "YusenPeng",
                        "content": " brute force failed?\\nHint: use HashMap."
                    },
                    {
                        "username": "IliasDeros",
                        "content": "Clarification:\n[1,2] is a single domino\n[1,2] and [3,4] is two different dominos\n[1,2] and [1,2] is a \"pair\" of two identical dominos.\n[1,2]; [1,2]; [1,2] can be mixed-and-matched to make 3 pairs, as the example suggests.\n\nThe question is to count how many \"pairs\" you can make, given a bunch of dominoes"
                    },
                    {
                        "username": "Supernova10",
                        "content": "wrong. then [[1,2],[2,1],[3,4],[5,6]] here [1,2], [2, 1] should be two pairs. which is not per consideration"
                    },
                    {
                        "username": "Danger-29",
                        "content": "i get 2328ms in submission of TC :)\\nclass Solution {\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        int count=0;\\n        for(int i =0;i<dominoes.length-1;i++){\\n       \\n                for(int k =i+1;k<dominoes.length;k++){\\n                 \\n                        if((dominoes[i][0] == dominoes[k][0] && dominoes[i][1] == dominoes[k][1]) || (dominoes[i][1] == dominoes[k][0] && dominoes[i][0] == dominoes[k][1]))\\n                        count++;\\n                    \\n                }\\n            \\n            \\n        }\\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "yush_2001",
                        "content": "[[1,1],[2,2],[1,1],[1,2],[1,2],[1,1]]\\nHow the answer is 4, it should be three, if we defined a pair as in the problem of all possible handshakes , if two people shakes hands exactly one time with each person. "
                    },
                    {
                        "username": "core_guru",
                        "content": "Some math:\\nWe have Permutations and Combinations. \\nPermutation (order matters):\\na, b, c: ab, ba, ac, ca, bc, cb\\nCombinations (order does not matter):\\na, b, c: ab, bc, ac\\nThis problem is a Combinations problem\\nFormula for Combinations:\\nC(n,r) = n!/( r! (n - r)! )\\n\\nSimplifying for r = 2:\\nC(n, 2) = n*(n-1)/2\\n\\nHope that clarifies the description a little bit."
                    },
                    {
                        "username": "alecoder",
                        "content": "If you need to understand why it works like this, you have to imagine how you would solve this problem with nested loops. You compare each matching and counting them as pairs.\nBut Map based solution confuses us because it increases count differently. But if you look closer, the idea is the same as we would do with nested loops."
                    },
                    {
                        "username": "arteml",
                        "content": "__Dominoes, the Second Wisest of all Games after Chess__\\n\\n[1,2]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_one_ dominoe, __zero__ pairs\\n\\n[1,2]--[1,2]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_two_ dominoes,   __one__ pair\\n      \\n[1,2]--[1,2]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_three_ dominoes,  __three__ pairs\\n |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/   \\n[1,2]  \\n\\n[1,2]---[1,2]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_four_ dominoes,  __six__ pairs\\n  |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;X &nbsp;&nbsp;&nbsp;    |\\n[1,2]---[1,2]\\n\\nNow you can derive a formula...\\n>    (and find out that you might have seen it many times before!!!)                          "
                    }
                ]
            },
            {
                "id": 1678200,
                "content": [
                    {
                        "username": "musmanrao1994",
                        "content": "Why is `[[1,2],[1,2],[1,1],[1,2],[2,2]]` 3,\\nbut `[[1,2],[2,1],[3,4],[5,6]]` is 1?\\n\\n"
                    },
                    {
                        "username": "pingmehard",
                        "content": "In the first list you have three pairs: \\n0 index and 1 index\\n0 index and 3 index\\n1 index and 3 index\\nSo they are different. You can\\'t reuse it if you already count it.\\n\\nIn the second you have only one unique pair of dominoes.\\nIndex 0 and index 1\\n\\nSo you can\\'t count pair index 1 and index 0, because it\\'s the same."
                    },
                    {
                        "username": "aro",
                        "content": "The definition of \"pair\" is neither normal nor well-defined..."
                    },
                    {
                        "username": "YusenPeng",
                        "content": " brute force failed?\\nHint: use HashMap."
                    },
                    {
                        "username": "IliasDeros",
                        "content": "Clarification:\n[1,2] is a single domino\n[1,2] and [3,4] is two different dominos\n[1,2] and [1,2] is a \"pair\" of two identical dominos.\n[1,2]; [1,2]; [1,2] can be mixed-and-matched to make 3 pairs, as the example suggests.\n\nThe question is to count how many \"pairs\" you can make, given a bunch of dominoes"
                    },
                    {
                        "username": "Supernova10",
                        "content": "wrong. then [[1,2],[2,1],[3,4],[5,6]] here [1,2], [2, 1] should be two pairs. which is not per consideration"
                    },
                    {
                        "username": "Danger-29",
                        "content": "i get 2328ms in submission of TC :)\\nclass Solution {\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        int count=0;\\n        for(int i =0;i<dominoes.length-1;i++){\\n       \\n                for(int k =i+1;k<dominoes.length;k++){\\n                 \\n                        if((dominoes[i][0] == dominoes[k][0] && dominoes[i][1] == dominoes[k][1]) || (dominoes[i][1] == dominoes[k][0] && dominoes[i][0] == dominoes[k][1]))\\n                        count++;\\n                    \\n                }\\n            \\n            \\n        }\\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "yush_2001",
                        "content": "[[1,1],[2,2],[1,1],[1,2],[1,2],[1,1]]\\nHow the answer is 4, it should be three, if we defined a pair as in the problem of all possible handshakes , if two people shakes hands exactly one time with each person. "
                    },
                    {
                        "username": "core_guru",
                        "content": "Some math:\\nWe have Permutations and Combinations. \\nPermutation (order matters):\\na, b, c: ab, ba, ac, ca, bc, cb\\nCombinations (order does not matter):\\na, b, c: ab, bc, ac\\nThis problem is a Combinations problem\\nFormula for Combinations:\\nC(n,r) = n!/( r! (n - r)! )\\n\\nSimplifying for r = 2:\\nC(n, 2) = n*(n-1)/2\\n\\nHope that clarifies the description a little bit."
                    },
                    {
                        "username": "alecoder",
                        "content": "If you need to understand why it works like this, you have to imagine how you would solve this problem with nested loops. You compare each matching and counting them as pairs.\nBut Map based solution confuses us because it increases count differently. But if you look closer, the idea is the same as we would do with nested loops."
                    },
                    {
                        "username": "arteml",
                        "content": "__Dominoes, the Second Wisest of all Games after Chess__\\n\\n[1,2]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_one_ dominoe, __zero__ pairs\\n\\n[1,2]--[1,2]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_two_ dominoes,   __one__ pair\\n      \\n[1,2]--[1,2]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_three_ dominoes,  __three__ pairs\\n |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/   \\n[1,2]  \\n\\n[1,2]---[1,2]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_four_ dominoes,  __six__ pairs\\n  |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;X &nbsp;&nbsp;&nbsp;    |\\n[1,2]---[1,2]\\n\\nNow you can derive a formula...\\n>    (and find out that you might have seen it many times before!!!)                          "
                    }
                ]
            },
            {
                "id": 2029928,
                "content": [
                    {
                        "username": "musmanrao1994",
                        "content": "Why is `[[1,2],[1,2],[1,1],[1,2],[2,2]]` 3,\\nbut `[[1,2],[2,1],[3,4],[5,6]]` is 1?\\n\\n"
                    },
                    {
                        "username": "pingmehard",
                        "content": "In the first list you have three pairs: \\n0 index and 1 index\\n0 index and 3 index\\n1 index and 3 index\\nSo they are different. You can\\'t reuse it if you already count it.\\n\\nIn the second you have only one unique pair of dominoes.\\nIndex 0 and index 1\\n\\nSo you can\\'t count pair index 1 and index 0, because it\\'s the same."
                    },
                    {
                        "username": "aro",
                        "content": "The definition of \"pair\" is neither normal nor well-defined..."
                    },
                    {
                        "username": "YusenPeng",
                        "content": " brute force failed?\\nHint: use HashMap."
                    },
                    {
                        "username": "IliasDeros",
                        "content": "Clarification:\n[1,2] is a single domino\n[1,2] and [3,4] is two different dominos\n[1,2] and [1,2] is a \"pair\" of two identical dominos.\n[1,2]; [1,2]; [1,2] can be mixed-and-matched to make 3 pairs, as the example suggests.\n\nThe question is to count how many \"pairs\" you can make, given a bunch of dominoes"
                    },
                    {
                        "username": "Supernova10",
                        "content": "wrong. then [[1,2],[2,1],[3,4],[5,6]] here [1,2], [2, 1] should be two pairs. which is not per consideration"
                    },
                    {
                        "username": "Danger-29",
                        "content": "i get 2328ms in submission of TC :)\\nclass Solution {\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        int count=0;\\n        for(int i =0;i<dominoes.length-1;i++){\\n       \\n                for(int k =i+1;k<dominoes.length;k++){\\n                 \\n                        if((dominoes[i][0] == dominoes[k][0] && dominoes[i][1] == dominoes[k][1]) || (dominoes[i][1] == dominoes[k][0] && dominoes[i][0] == dominoes[k][1]))\\n                        count++;\\n                    \\n                }\\n            \\n            \\n        }\\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "yush_2001",
                        "content": "[[1,1],[2,2],[1,1],[1,2],[1,2],[1,1]]\\nHow the answer is 4, it should be three, if we defined a pair as in the problem of all possible handshakes , if two people shakes hands exactly one time with each person. "
                    },
                    {
                        "username": "core_guru",
                        "content": "Some math:\\nWe have Permutations and Combinations. \\nPermutation (order matters):\\na, b, c: ab, ba, ac, ca, bc, cb\\nCombinations (order does not matter):\\na, b, c: ab, bc, ac\\nThis problem is a Combinations problem\\nFormula for Combinations:\\nC(n,r) = n!/( r! (n - r)! )\\n\\nSimplifying for r = 2:\\nC(n, 2) = n*(n-1)/2\\n\\nHope that clarifies the description a little bit."
                    },
                    {
                        "username": "alecoder",
                        "content": "If you need to understand why it works like this, you have to imagine how you would solve this problem with nested loops. You compare each matching and counting them as pairs.\nBut Map based solution confuses us because it increases count differently. But if you look closer, the idea is the same as we would do with nested loops."
                    },
                    {
                        "username": "arteml",
                        "content": "__Dominoes, the Second Wisest of all Games after Chess__\\n\\n[1,2]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_one_ dominoe, __zero__ pairs\\n\\n[1,2]--[1,2]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_two_ dominoes,   __one__ pair\\n      \\n[1,2]--[1,2]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_three_ dominoes,  __three__ pairs\\n |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/   \\n[1,2]  \\n\\n[1,2]---[1,2]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_four_ dominoes,  __six__ pairs\\n  |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;X &nbsp;&nbsp;&nbsp;    |\\n[1,2]---[1,2]\\n\\nNow you can derive a formula...\\n>    (and find out that you might have seen it many times before!!!)                          "
                    }
                ]
            },
            {
                "id": 2013665,
                "content": [
                    {
                        "username": "musmanrao1994",
                        "content": "Why is `[[1,2],[1,2],[1,1],[1,2],[2,2]]` 3,\\nbut `[[1,2],[2,1],[3,4],[5,6]]` is 1?\\n\\n"
                    },
                    {
                        "username": "pingmehard",
                        "content": "In the first list you have three pairs: \\n0 index and 1 index\\n0 index and 3 index\\n1 index and 3 index\\nSo they are different. You can\\'t reuse it if you already count it.\\n\\nIn the second you have only one unique pair of dominoes.\\nIndex 0 and index 1\\n\\nSo you can\\'t count pair index 1 and index 0, because it\\'s the same."
                    },
                    {
                        "username": "aro",
                        "content": "The definition of \"pair\" is neither normal nor well-defined..."
                    },
                    {
                        "username": "YusenPeng",
                        "content": " brute force failed?\\nHint: use HashMap."
                    },
                    {
                        "username": "IliasDeros",
                        "content": "Clarification:\n[1,2] is a single domino\n[1,2] and [3,4] is two different dominos\n[1,2] and [1,2] is a \"pair\" of two identical dominos.\n[1,2]; [1,2]; [1,2] can be mixed-and-matched to make 3 pairs, as the example suggests.\n\nThe question is to count how many \"pairs\" you can make, given a bunch of dominoes"
                    },
                    {
                        "username": "Supernova10",
                        "content": "wrong. then [[1,2],[2,1],[3,4],[5,6]] here [1,2], [2, 1] should be two pairs. which is not per consideration"
                    },
                    {
                        "username": "Danger-29",
                        "content": "i get 2328ms in submission of TC :)\\nclass Solution {\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        int count=0;\\n        for(int i =0;i<dominoes.length-1;i++){\\n       \\n                for(int k =i+1;k<dominoes.length;k++){\\n                 \\n                        if((dominoes[i][0] == dominoes[k][0] && dominoes[i][1] == dominoes[k][1]) || (dominoes[i][1] == dominoes[k][0] && dominoes[i][0] == dominoes[k][1]))\\n                        count++;\\n                    \\n                }\\n            \\n            \\n        }\\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "yush_2001",
                        "content": "[[1,1],[2,2],[1,1],[1,2],[1,2],[1,1]]\\nHow the answer is 4, it should be three, if we defined a pair as in the problem of all possible handshakes , if two people shakes hands exactly one time with each person. "
                    },
                    {
                        "username": "core_guru",
                        "content": "Some math:\\nWe have Permutations and Combinations. \\nPermutation (order matters):\\na, b, c: ab, ba, ac, ca, bc, cb\\nCombinations (order does not matter):\\na, b, c: ab, bc, ac\\nThis problem is a Combinations problem\\nFormula for Combinations:\\nC(n,r) = n!/( r! (n - r)! )\\n\\nSimplifying for r = 2:\\nC(n, 2) = n*(n-1)/2\\n\\nHope that clarifies the description a little bit."
                    },
                    {
                        "username": "alecoder",
                        "content": "If you need to understand why it works like this, you have to imagine how you would solve this problem with nested loops. You compare each matching and counting them as pairs.\nBut Map based solution confuses us because it increases count differently. But if you look closer, the idea is the same as we would do with nested loops."
                    },
                    {
                        "username": "arteml",
                        "content": "__Dominoes, the Second Wisest of all Games after Chess__\\n\\n[1,2]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_one_ dominoe, __zero__ pairs\\n\\n[1,2]--[1,2]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_two_ dominoes,   __one__ pair\\n      \\n[1,2]--[1,2]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_three_ dominoes,  __three__ pairs\\n |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/   \\n[1,2]  \\n\\n[1,2]---[1,2]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_four_ dominoes,  __six__ pairs\\n  |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;X &nbsp;&nbsp;&nbsp;    |\\n[1,2]---[1,2]\\n\\nNow you can derive a formula...\\n>    (and find out that you might have seen it many times before!!!)                          "
                    }
                ]
            },
            {
                "id": 1944528,
                "content": [
                    {
                        "username": "musmanrao1994",
                        "content": "Why is `[[1,2],[1,2],[1,1],[1,2],[2,2]]` 3,\\nbut `[[1,2],[2,1],[3,4],[5,6]]` is 1?\\n\\n"
                    },
                    {
                        "username": "pingmehard",
                        "content": "In the first list you have three pairs: \\n0 index and 1 index\\n0 index and 3 index\\n1 index and 3 index\\nSo they are different. You can\\'t reuse it if you already count it.\\n\\nIn the second you have only one unique pair of dominoes.\\nIndex 0 and index 1\\n\\nSo you can\\'t count pair index 1 and index 0, because it\\'s the same."
                    },
                    {
                        "username": "aro",
                        "content": "The definition of \"pair\" is neither normal nor well-defined..."
                    },
                    {
                        "username": "YusenPeng",
                        "content": " brute force failed?\\nHint: use HashMap."
                    },
                    {
                        "username": "IliasDeros",
                        "content": "Clarification:\n[1,2] is a single domino\n[1,2] and [3,4] is two different dominos\n[1,2] and [1,2] is a \"pair\" of two identical dominos.\n[1,2]; [1,2]; [1,2] can be mixed-and-matched to make 3 pairs, as the example suggests.\n\nThe question is to count how many \"pairs\" you can make, given a bunch of dominoes"
                    },
                    {
                        "username": "Supernova10",
                        "content": "wrong. then [[1,2],[2,1],[3,4],[5,6]] here [1,2], [2, 1] should be two pairs. which is not per consideration"
                    },
                    {
                        "username": "Danger-29",
                        "content": "i get 2328ms in submission of TC :)\\nclass Solution {\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        int count=0;\\n        for(int i =0;i<dominoes.length-1;i++){\\n       \\n                for(int k =i+1;k<dominoes.length;k++){\\n                 \\n                        if((dominoes[i][0] == dominoes[k][0] && dominoes[i][1] == dominoes[k][1]) || (dominoes[i][1] == dominoes[k][0] && dominoes[i][0] == dominoes[k][1]))\\n                        count++;\\n                    \\n                }\\n            \\n            \\n        }\\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "yush_2001",
                        "content": "[[1,1],[2,2],[1,1],[1,2],[1,2],[1,1]]\\nHow the answer is 4, it should be three, if we defined a pair as in the problem of all possible handshakes , if two people shakes hands exactly one time with each person. "
                    },
                    {
                        "username": "core_guru",
                        "content": "Some math:\\nWe have Permutations and Combinations. \\nPermutation (order matters):\\na, b, c: ab, ba, ac, ca, bc, cb\\nCombinations (order does not matter):\\na, b, c: ab, bc, ac\\nThis problem is a Combinations problem\\nFormula for Combinations:\\nC(n,r) = n!/( r! (n - r)! )\\n\\nSimplifying for r = 2:\\nC(n, 2) = n*(n-1)/2\\n\\nHope that clarifies the description a little bit."
                    },
                    {
                        "username": "alecoder",
                        "content": "If you need to understand why it works like this, you have to imagine how you would solve this problem with nested loops. You compare each matching and counting them as pairs.\nBut Map based solution confuses us because it increases count differently. But if you look closer, the idea is the same as we would do with nested loops."
                    },
                    {
                        "username": "arteml",
                        "content": "__Dominoes, the Second Wisest of all Games after Chess__\\n\\n[1,2]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_one_ dominoe, __zero__ pairs\\n\\n[1,2]--[1,2]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_two_ dominoes,   __one__ pair\\n      \\n[1,2]--[1,2]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_three_ dominoes,  __three__ pairs\\n |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/   \\n[1,2]  \\n\\n[1,2]---[1,2]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_four_ dominoes,  __six__ pairs\\n  |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;X &nbsp;&nbsp;&nbsp;    |\\n[1,2]---[1,2]\\n\\nNow you can derive a formula...\\n>    (and find out that you might have seen it many times before!!!)                          "
                    }
                ]
            },
            {
                "id": 1912272,
                "content": [
                    {
                        "username": "musmanrao1994",
                        "content": "Why is `[[1,2],[1,2],[1,1],[1,2],[2,2]]` 3,\\nbut `[[1,2],[2,1],[3,4],[5,6]]` is 1?\\n\\n"
                    },
                    {
                        "username": "pingmehard",
                        "content": "In the first list you have three pairs: \\n0 index and 1 index\\n0 index and 3 index\\n1 index and 3 index\\nSo they are different. You can\\'t reuse it if you already count it.\\n\\nIn the second you have only one unique pair of dominoes.\\nIndex 0 and index 1\\n\\nSo you can\\'t count pair index 1 and index 0, because it\\'s the same."
                    },
                    {
                        "username": "aro",
                        "content": "The definition of \"pair\" is neither normal nor well-defined..."
                    },
                    {
                        "username": "YusenPeng",
                        "content": " brute force failed?\\nHint: use HashMap."
                    },
                    {
                        "username": "IliasDeros",
                        "content": "Clarification:\n[1,2] is a single domino\n[1,2] and [3,4] is two different dominos\n[1,2] and [1,2] is a \"pair\" of two identical dominos.\n[1,2]; [1,2]; [1,2] can be mixed-and-matched to make 3 pairs, as the example suggests.\n\nThe question is to count how many \"pairs\" you can make, given a bunch of dominoes"
                    },
                    {
                        "username": "Supernova10",
                        "content": "wrong. then [[1,2],[2,1],[3,4],[5,6]] here [1,2], [2, 1] should be two pairs. which is not per consideration"
                    },
                    {
                        "username": "Danger-29",
                        "content": "i get 2328ms in submission of TC :)\\nclass Solution {\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        int count=0;\\n        for(int i =0;i<dominoes.length-1;i++){\\n       \\n                for(int k =i+1;k<dominoes.length;k++){\\n                 \\n                        if((dominoes[i][0] == dominoes[k][0] && dominoes[i][1] == dominoes[k][1]) || (dominoes[i][1] == dominoes[k][0] && dominoes[i][0] == dominoes[k][1]))\\n                        count++;\\n                    \\n                }\\n            \\n            \\n        }\\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "yush_2001",
                        "content": "[[1,1],[2,2],[1,1],[1,2],[1,2],[1,1]]\\nHow the answer is 4, it should be three, if we defined a pair as in the problem of all possible handshakes , if two people shakes hands exactly one time with each person. "
                    },
                    {
                        "username": "core_guru",
                        "content": "Some math:\\nWe have Permutations and Combinations. \\nPermutation (order matters):\\na, b, c: ab, ba, ac, ca, bc, cb\\nCombinations (order does not matter):\\na, b, c: ab, bc, ac\\nThis problem is a Combinations problem\\nFormula for Combinations:\\nC(n,r) = n!/( r! (n - r)! )\\n\\nSimplifying for r = 2:\\nC(n, 2) = n*(n-1)/2\\n\\nHope that clarifies the description a little bit."
                    },
                    {
                        "username": "alecoder",
                        "content": "If you need to understand why it works like this, you have to imagine how you would solve this problem with nested loops. You compare each matching and counting them as pairs.\nBut Map based solution confuses us because it increases count differently. But if you look closer, the idea is the same as we would do with nested loops."
                    },
                    {
                        "username": "arteml",
                        "content": "__Dominoes, the Second Wisest of all Games after Chess__\\n\\n[1,2]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_one_ dominoe, __zero__ pairs\\n\\n[1,2]--[1,2]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_two_ dominoes,   __one__ pair\\n      \\n[1,2]--[1,2]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_three_ dominoes,  __three__ pairs\\n |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/   \\n[1,2]  \\n\\n[1,2]---[1,2]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_four_ dominoes,  __six__ pairs\\n  |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;X &nbsp;&nbsp;&nbsp;    |\\n[1,2]---[1,2]\\n\\nNow you can derive a formula...\\n>    (and find out that you might have seen it many times before!!!)                          "
                    }
                ]
            },
            {
                "id": 1715633,
                "content": [
                    {
                        "username": "musmanrao1994",
                        "content": "Why is `[[1,2],[1,2],[1,1],[1,2],[2,2]]` 3,\\nbut `[[1,2],[2,1],[3,4],[5,6]]` is 1?\\n\\n"
                    },
                    {
                        "username": "pingmehard",
                        "content": "In the first list you have three pairs: \\n0 index and 1 index\\n0 index and 3 index\\n1 index and 3 index\\nSo they are different. You can\\'t reuse it if you already count it.\\n\\nIn the second you have only one unique pair of dominoes.\\nIndex 0 and index 1\\n\\nSo you can\\'t count pair index 1 and index 0, because it\\'s the same."
                    },
                    {
                        "username": "aro",
                        "content": "The definition of \"pair\" is neither normal nor well-defined..."
                    },
                    {
                        "username": "YusenPeng",
                        "content": " brute force failed?\\nHint: use HashMap."
                    },
                    {
                        "username": "IliasDeros",
                        "content": "Clarification:\n[1,2] is a single domino\n[1,2] and [3,4] is two different dominos\n[1,2] and [1,2] is a \"pair\" of two identical dominos.\n[1,2]; [1,2]; [1,2] can be mixed-and-matched to make 3 pairs, as the example suggests.\n\nThe question is to count how many \"pairs\" you can make, given a bunch of dominoes"
                    },
                    {
                        "username": "Supernova10",
                        "content": "wrong. then [[1,2],[2,1],[3,4],[5,6]] here [1,2], [2, 1] should be two pairs. which is not per consideration"
                    },
                    {
                        "username": "Danger-29",
                        "content": "i get 2328ms in submission of TC :)\\nclass Solution {\\n    public int numEquivDominoPairs(int[][] dominoes) {\\n        int count=0;\\n        for(int i =0;i<dominoes.length-1;i++){\\n       \\n                for(int k =i+1;k<dominoes.length;k++){\\n                 \\n                        if((dominoes[i][0] == dominoes[k][0] && dominoes[i][1] == dominoes[k][1]) || (dominoes[i][1] == dominoes[k][0] && dominoes[i][0] == dominoes[k][1]))\\n                        count++;\\n                    \\n                }\\n            \\n            \\n        }\\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "yush_2001",
                        "content": "[[1,1],[2,2],[1,1],[1,2],[1,2],[1,1]]\\nHow the answer is 4, it should be three, if we defined a pair as in the problem of all possible handshakes , if two people shakes hands exactly one time with each person. "
                    },
                    {
                        "username": "core_guru",
                        "content": "Some math:\\nWe have Permutations and Combinations. \\nPermutation (order matters):\\na, b, c: ab, ba, ac, ca, bc, cb\\nCombinations (order does not matter):\\na, b, c: ab, bc, ac\\nThis problem is a Combinations problem\\nFormula for Combinations:\\nC(n,r) = n!/( r! (n - r)! )\\n\\nSimplifying for r = 2:\\nC(n, 2) = n*(n-1)/2\\n\\nHope that clarifies the description a little bit."
                    },
                    {
                        "username": "alecoder",
                        "content": "If you need to understand why it works like this, you have to imagine how you would solve this problem with nested loops. You compare each matching and counting them as pairs.\nBut Map based solution confuses us because it increases count differently. But if you look closer, the idea is the same as we would do with nested loops."
                    },
                    {
                        "username": "arteml",
                        "content": "__Dominoes, the Second Wisest of all Games after Chess__\\n\\n[1,2]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_one_ dominoe, __zero__ pairs\\n\\n[1,2]--[1,2]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_two_ dominoes,   __one__ pair\\n      \\n[1,2]--[1,2]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_three_ dominoes,  __three__ pairs\\n |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/   \\n[1,2]  \\n\\n[1,2]---[1,2]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_four_ dominoes,  __six__ pairs\\n  |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;X &nbsp;&nbsp;&nbsp;    |\\n[1,2]---[1,2]\\n\\nNow you can derive a formula...\\n>    (and find out that you might have seen it many times before!!!)                          "
                    }
                ]
            }
        ]
    },
    {
        "title": "Find Servers That Handled Most Number of Requests",
        "question_content": "<p>You have <code>k</code> servers numbered from <code>0</code> to <code>k-1</code> that are being used to handle multiple requests simultaneously. Each server has infinite computational capacity but <strong>cannot handle more than one request at a time</strong>. The requests are assigned to servers according to a specific algorithm:</p>\n\n<ul>\n\t<li>The <code>i<sup>th</sup></code> (0-indexed) request arrives.</li>\n\t<li>If all servers are busy, the request is dropped (not handled at all).</li>\n\t<li>If the <code>(i % k)<sup>th</sup></code> server is available, assign the request to that server.</li>\n\t<li>Otherwise, assign the request to the next available server (wrapping around the list of servers and starting from 0 if necessary). For example, if the <code>i<sup>th</sup></code> server is busy, try to assign the request to the <code>(i+1)<sup>th</sup></code> server, then the <code>(i+2)<sup>th</sup></code> server, and so on.</li>\n</ul>\n\n<p>You are given a <strong>strictly increasing</strong> array <code>arrival</code> of positive integers, where <code>arrival[i]</code> represents the arrival time of the <code>i<sup>th</sup></code> request, and another array <code>load</code>, where <code>load[i]</code> represents the load of the <code>i<sup>th</sup></code> request (the time it takes to complete). Your goal is to find the <strong>busiest server(s)</strong>. A server is considered <strong>busiest</strong> if it handled the most number of requests successfully among all the servers.</p>\n\n<p>Return <em>a list containing the IDs (0-indexed) of the <strong>busiest server(s)</strong></em>. You may return the IDs in any order.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/08/load-1.png\" style=\"width: 389px; height: 221px;\" />\n<pre>\n<strong>Input:</strong> k = 3, arrival = [1,2,3,4,5], load = [5,2,3,3,3] \n<strong>Output:</strong> [1] \n<strong>Explanation:</strong> \nAll of the servers start out available.\nThe first 3 requests are handled by the first 3 servers in order.\nRequest 3 comes in. Server 0 is busy, so it&#39;s assigned to the next available server, which is 1.\nRequest 4 comes in. It cannot be handled since all servers are busy, so it is dropped.\nServers 0 and 2 handled one request each, while server 1 handled two requests. Hence server 1 is the busiest server.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> k = 3, arrival = [1,2,3,4], load = [1,2,1,2]\n<strong>Output:</strong> [0]\n<strong>Explanation:</strong> \nThe first 3 requests are handled by first 3 servers.\nRequest 3 comes in. It is handled by server 0 since the server is available.\nServer 0 handled two requests, while servers 1 and 2 handled one request each. Hence server 0 is the busiest server.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> k = 3, arrival = [1,2,3], load = [10,12,11]\n<strong>Output:</strong> [0,1,2]\n<strong>Explanation:</strong> Each server handles a single request, so they are all considered the busiest.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= k &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= arrival.length, load.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>arrival.length == load.length</code></li>\n\t<li><code>1 &lt;= arrival[i], load[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>arrival</code> is <strong>strictly increasing</strong>.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 876793,
                "title": "java-o-nlogn-use-both-treeset-and-priorityqueue",
                "content": "```\\nclass Solution {\\n    public List<Integer> busiestServers(int k, int[] arrival, int[] load) {\\n        int[] counter = new int[k];\\n        // use a tree to track available servers\\n        TreeSet<Integer> available = new TreeSet<Integer>();\\n        for (int num = 0; num < k; num++) {\\n            available.add(num);\\n        }\\n        // use a PQ to maintain the availability at current arrival time\\n        Queue<int[]> busyServers = new PriorityQueue<>((a, b)->(a[0] - b[0]));\\n        \\n        for (int idx = 0; idx < arrival.length; idx++) {\\n            int curTime = arrival[idx];\\n            int endTime = curTime + load[idx];\\n            while (!busyServers.isEmpty() && busyServers.peek()[0] <= curTime) {\\n                int freedServer = busyServers.poll()[1];\\n                available.add(freedServer);\\n            }\\n            if (available.size() == 0) continue; // all busy\\n            Integer assignNum = available.ceiling(idx % k);\\n            if (assignNum == null) {\\n                assignNum = available.first();\\n            }\\n            counter[assignNum]++;\\n            available.remove(assignNum);\\n            busyServers.offer(new int[] {endTime, assignNum});\\n        }\\n        \\n        return findMaxesInCounter(counter);\\n    }\\n    \\n    \\n    \\n    private List<Integer> findMaxesInCounter(int[] counter) {\\n        int max = 0;\\n        for (int i = 0; i < counter.length; i++) {\\n            max = Math.max(max, counter[i]);\\n        }\\n        List<Integer> result = new ArrayList<>();\\n        for (int i = 0; i < counter.length; i++) {\\n            if (counter[i] == max) {\\n                result.add(i);\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> busiestServers(int k, int[] arrival, int[] load) {\\n        int[] counter = new int[k];\\n        // use a tree to track available servers\\n        TreeSet<Integer> available = new TreeSet<Integer>();\\n        for (int num = 0; num < k; num++) {\\n            available.add(num);\\n        }\\n        // use a PQ to maintain the availability at current arrival time\\n        Queue<int[]> busyServers = new PriorityQueue<>((a, b)->(a[0] - b[0]));\\n        \\n        for (int idx = 0; idx < arrival.length; idx++) {\\n            int curTime = arrival[idx];\\n            int endTime = curTime + load[idx];\\n            while (!busyServers.isEmpty() && busyServers.peek()[0] <= curTime) {\\n                int freedServer = busyServers.poll()[1];\\n                available.add(freedServer);\\n            }\\n            if (available.size() == 0) continue; // all busy\\n            Integer assignNum = available.ceiling(idx % k);\\n            if (assignNum == null) {\\n                assignNum = available.first();\\n            }\\n            counter[assignNum]++;\\n            available.remove(assignNum);\\n            busyServers.offer(new int[] {endTime, assignNum});\\n        }\\n        \\n        return findMaxesInCounter(counter);\\n    }\\n    \\n    \\n    \\n    private List<Integer> findMaxesInCounter(int[] counter) {\\n        int max = 0;\\n        for (int i = 0; i < counter.length; i++) {\\n            max = Math.max(max, counter[i]);\\n        }\\n        List<Integer> result = new ArrayList<>();\\n        for (int i = 0; i < counter.length; i++) {\\n            if (counter[i] == max) {\\n                result.add(i);\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 876883,
                "title": "python-using-only-heaps",
                "content": "Solution using three heaps. First heap is used to quickly free up the nodes. Then we split the servers to those that come after the `server_id` which is current server and those that come before, for loopback.\\n```\\ndef busiestServers(self, k: int, arrival: List[int], load: List[int]) -> List[int]:\\n\\tbusy_jobs = []  # heap (job_end_time, node) to free up the nodes quickly\\n\\tafter = [] # heap (nodes) free after current server\\n\\tbefore = list(range(k))  # heap (nodes) to use for loopback\\n\\trequests_handled = [0] * k\\n\\n\\tfor i, (arrvl, ld) in enumerate(zip(arrival, load)):\\n\\t\\tserver_id = i % k\\n\\t\\tif server_id == 0:  # loopback\\n\\t\\t\\tafter = before\\n\\t\\t\\tbefore = []\\n\\n\\t\\twhile busy_jobs and busy_jobs[0][0] <= arrvl:\\n\\t\\t\\tfreed_node = heapq.heappop(busy_jobs)[1]\\n\\t\\t\\tif freed_node < server_id: heapq.heappush(before, freed_node)\\n\\t\\t\\telse: heapq.heappush(after, freed_node)\\n\\n\\t\\tuse_queue = after if after else before\\n\\t\\tif not use_queue: continue  # request dropped\\n\\t\\tusing_node = heapq.heappop(use_queue)\\n\\t\\trequests_handled[using_node] += 1\\n\\t\\theapq.heappush(busy_jobs, (arrvl + ld, using_node))\\n\\n\\tmaxreqs = max(requests_handled)\\n\\treturn [i for i, handled in enumerate(requests_handled) if handled == maxreqs]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\ndef busiestServers(self, k: int, arrival: List[int], load: List[int]) -> List[int]:\\n\\tbusy_jobs = []  # heap (job_end_time, node) to free up the nodes quickly\\n\\tafter = [] # heap (nodes) free after current server\\n\\tbefore = list(range(k))  # heap (nodes) to use for loopback\\n\\trequests_handled = [0] * k\\n\\n\\tfor i, (arrvl, ld) in enumerate(zip(arrival, load)):\\n\\t\\tserver_id = i % k\\n\\t\\tif server_id == 0:  # loopback\\n\\t\\t\\tafter = before\\n\\t\\t\\tbefore = []\\n\\n\\t\\twhile busy_jobs and busy_jobs[0][0] <= arrvl:\\n\\t\\t\\tfreed_node = heapq.heappop(busy_jobs)[1]\\n\\t\\t\\tif freed_node < server_id: heapq.heappush(before, freed_node)\\n\\t\\t\\telse: heapq.heappush(after, freed_node)\\n\\n\\t\\tuse_queue = after if after else before\\n\\t\\tif not use_queue: continue  # request dropped\\n\\t\\tusing_node = heapq.heappop(use_queue)\\n\\t\\trequests_handled[using_node] += 1\\n\\t\\theapq.heappush(busy_jobs, (arrvl + ld, using_node))\\n\\n\\tmaxreqs = max(requests_handled)\\n\\treturn [i for i, handled in enumerate(requests_handled) if handled == maxreqs]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 963917,
                "title": "python-two-priorityqueue-back-and-forth-o-n-log-k",
                "content": "Idea is simple:\\n\\nUse a priority queue `available` to keep track of the available servers. When a server get a job, remove it from `available` and put it in another PriorityQueue `busy` whose priority is given by the done time. \\n\\nOn the arrival each job, check if any of the jobs in `busy` are done. If so, put them back in `available` with the **appropriate index**. So when the `i`-th job comes in, `min(available)` is at least `i`, at most `i+k-1`.\\n\\nNote that the length of `available` and `busy` are at most `k`. So the heaps are not too big and the complexity is O(n log k) -- every job goes in the priority queue `busy` once, goes out at most once, and when it goes out it go into `available` once.\\n\\nShort annotated version:\\n```\\nclass Solution:\\n    def busiestServers(self, k: int, A: List[int], B: List[int]) -> List[int]:\\n        available = list(range(k)) # already a min-heap\\n        busy = [] \\n        res = [0] * k\\n        for i, a in enumerate(A):\\n            while busy and busy[0][0] <= a: # these are done, put them back as available\\n                _, x = heapq.heappop(busy)\\n                heapq.heappush(available, i + (x-i)%k) # invariant: min(available) is at least i, at most i+k-1\\n            if available: \\n                j = heapq.heappop(available) % k\\n                heapq.heappush(busy, (a+B[i],j))\\n                res[j] += 1\\n        a = max(res)\\n        return [i for i in range(k) if res[i] == a]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def busiestServers(self, k: int, A: List[int], B: List[int]) -> List[int]:\\n        available = list(range(k)) # already a min-heap\\n        busy = [] \\n        res = [0] * k\\n        for i, a in enumerate(A):\\n            while busy and busy[0][0] <= a: # these are done, put them back as available\\n                _, x = heapq.heappop(busy)\\n                heapq.heappush(available, i + (x-i)%k) # invariant: min(available) is at least i, at most i+k-1\\n            if available: \\n                j = heapq.heappop(available) % k\\n                heapq.heappush(busy, (a+B[i],j))\\n                res[j] += 1\\n        a = max(res)\\n        return [i for i in range(k) if res[i] == a]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 876804,
                "title": "c-circular-array-ordered-set-priority-queue-o-n-log-k-log-n-o-k",
                "content": "## **APPROACH**\\n> Do what it says\\n\\n## **TECHNIQUE**\\n> We use the popular technique for circular arrays making it a linear array (by copying itself) \\n\\nnew_servers = `0` to `2*k - 1`\\nwhere `i` and `i + k`th servers are the same\\nSo whenever we change the state of server we do it for both `i` and `i + k`\\n\\n**FOR NEXT FREE SERVER** after `i % k` \\nor \\nsmallest free server greater than `i` (circularly), we can do `free_servers.lower_bound(i%k) % k` \\nlast `%k` because `x = i_th` or `x = (i + k)_th` server map to the same `(x % k)_th server`\\n\\nFor freeing the servers you can use a `min_heap`\\n\\n## **TIME COMPLEXITY**\\n`O(N * (log K + log N))`\\n\\n## **SPACE COMPLEXITY**\\n`O(K + N)`\\n\\n**Note** There are better and cleaner solutions than this, you can still learn about the circular array technique which can be used on some other problems :)\\n\\n### **The Technique**\\nCircular array `[1, 2, 3, ... K]`\\nLinear array `[1, 2, 3, ... K, 1, 2, 3 ... K-1]`\\nfor this array each subarray of length K is a rotation of the circular array\\n\\n## **CODE CPP**\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> busiestServers(int k, vector<int>& arr, vector<int>& lo) {\\n        set<int> free;\\n        int n = arr.size();\\n        for (int i = 0; i < 2*k - 1; i ++)\\n            free.insert(i);\\n        vector<int> cnt(k, 0);\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<>> pq;\\n        for (int i = 0; i < n; i ++)\\n        {\\n            int at = arr[i];\\n            int load = lo[i];\\n            while (!pq.empty() and pq.top().first <= at)\\n            {\\n                auto tt = pq.top();\\n                int server = tt.second;\\n                pq.pop();\\n                free.insert(server);\\n                free.insert(server + k);\\n            }\\n            if (!free.empty()) {\\n                int server = (*free.lower_bound(i % k)) % k;\\n                free.erase(server % k);\\n                free.erase(server % k + k);\\n\\n                cnt[server] ++;\\n                pq.push({at + load, server});\\n            }\\n        }\\n        int mv = -1;\\n        vector<int> res;\\n        for (int i = 0; i < k; i ++)\\n        {\\n            if (cnt[i] > mv)\\n            {\\n                mv = cnt[i];\\n                res = {i};\\n            }\\n            else if (cnt[i] == mv)\\n                res.push_back(i);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<int> busiestServers(int k, vector<int>& arr, vector<int>& lo) {\\n        set<int> free;\\n        int n = arr.size();\\n        for (int i = 0; i < 2*k - 1; i ++)\\n            free.insert(i);\\n        vector<int> cnt(k, 0);\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<>> pq;\\n        for (int i = 0; i < n; i ++)\\n        {\\n            int at = arr[i];\\n            int load = lo[i];\\n            while (!pq.empty() and pq.top().first <= at)\\n            {\\n                auto tt = pq.top();\\n                int server = tt.second;\\n                pq.pop();\\n                free.insert(server);\\n                free.insert(server + k);\\n            }\\n            if (!free.empty()) {\\n                int server = (*free.lower_bound(i % k)) % k;\\n                free.erase(server % k);\\n                free.erase(server % k + k);\\n\\n                cnt[server] ++;\\n                pq.push({at + load, server});\\n            }\\n        }\\n        int mv = -1;\\n        vector<int> res;\\n        for (int i = 0; i < k; i ++)\\n        {\\n            if (cnt[i] > mv)\\n            {\\n                mv = cnt[i];\\n                res = {i};\\n            }\\n            else if (cnt[i] == mv)\\n                res.push_back(i);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 876998,
                "title": "c-map",
                "content": "#### Intuition\\nWe need to avoid scanning through `k` servers for every request. So, instead looping through requests, we will loop through servers and take all requests that are available (not picked up by previous servers) and can be handled.\\n\\n#### Solution\\nFor each server, we track when it becomes available (`avail`), and also the count `cnt` of executed requests. We will use that count in the end to determine the busiest server.\\n\\nFor a current server `i % k`, we add request `i` to the list of available requests. If we can process that request, we remove it from the queue. If not - that request will become available for the next server to pick up. We will pick an earlier request first - to ensure that a request is processed by the first available server.\\n\\nHere, we are using ordered map to \\'queue\\' available requests, so it\\'s efficient to find requests that the current server can process. We can further optimize by removing \\'dropped\\' requests.\\n\\n**C++**\\n```cpp\\nvector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n    vector<int> cnt(k), avail(k), res;\\n    map<int, int> m;\\n    for (int i = 0, last_i = 0; ; ++i) {\\n        if (i < arrival.size())\\n            m[arrival[i]] = load[i];\\n        else if (i - last_i > k)\\n            break;\\n        auto it = m.lower_bound(avail[i % k]);\\n        while (it != end(m)) {\\n            last_i = i;\\n            ++cnt[i % k];\\n            avail[i % k] = it->first + it->second;\\n            m.erase(it);\\n            it = m.lower_bound(avail[i % k]);\\n        }\\n    }\\n    int max_req = *max_element(begin(cnt), end(cnt));\\n    for (int i = 0; i < k; ++i)\\n        if(cnt[i] == max_req)\\n            res.push_back(i);\\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nvector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n    vector<int> cnt(k), avail(k), res;\\n    map<int, int> m;\\n    for (int i = 0, last_i = 0; ; ++i) {\\n        if (i < arrival.size())\\n            m[arrival[i]] = load[i];\\n        else if (i - last_i > k)\\n            break;\\n        auto it = m.lower_bound(avail[i % k]);\\n        while (it != end(m)) {\\n            last_i = i;\\n            ++cnt[i % k];\\n            avail[i % k] = it->first + it->second;\\n            m.erase(it);\\n            it = m.lower_bound(avail[i % k]);\\n        }\\n    }\\n    int max_req = *max_element(begin(cnt), end(cnt));\\n    for (int i = 0; i < k; ++i)\\n        if(cnt[i] == max_req)\\n            res.push_back(i);\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 876803,
                "title": "python-folks-heavily-commented-you-might-learn-something-new-here-about-sortedcontainers",
                "content": "DataStructures Used : Priority Queue, SortedList\\nDocumentation of sorted list: \\nhttp://www.grantjenks.com/docs/sortedcontainers/sortedlist.html\\n\\n```\\nfrom sortedcontainers import SortedList\\nclass Solution:\\n    def getNextServer(self, index , sortedAvailableServers):\\n        nextIndexToRightOfServer = sortedAvailableServers.bisect_left(index)\\n        # Since We need to find next server availble greater than this index\\n        if nextIndexToRightOfServer != len(sortedAvailableServers):\\n            return sortedAvailableServers[nextIndexToRightOfServer]\\n        # No server greater than index found , means move in cycle and find the lowest avaiable server now\\n        lowestIdServerAvailable = sortedAvailableServers.bisect_left(0)\\n        return sortedAvailableServers[lowestIdServerAvailable]\\n                \\n    def busiestServers(self, k: int, arrival: List[int], load: List[int]) -> List[int]:\\n        heap = [] \\n        # This heap will be use to make servers as free , the first server to become free will be top element of heap\\n        \\n        sortedAvailableServers = SortedList([i for i in range(k)])      \\n        # This sorted available server list will be used to assign the load to new server , more comment in function \\n        \\n        count = collections.defaultdict(int)\\n        # This count dictionary will be used to record the count of request each server has handled, will be used in calculating result\\n        \\n        for i in range(len(arrival)):\\n            arrivalTime,loadTime = arrival[i], load[i]\\n            # ArrivalTime and loadTime , SimpleStuff\\n            \\n            # Check if any server has become free now, since top of heap will contain the first server which will get free\\n            # we just compare top server free time with currentTime and mark the server as free if possible\\n            while len(heap) > 0 and heap[0][0] <= arrivalTime:\\n                _,serverId = heapq.heappop(heap)\\n                # after marker this server free add it to list of free Servers\\n                sortedAvailableServers.add(serverId)\\n\\n            #Check for any server Available\\n            if len(sortedAvailableServers) == 0:\\n                # Drop this Request because no server available\\n                continue\\n            \\n            # Get the assigned serverId for this Request\\n            assignedServer = self.getNextServer(i%k,sortedAvailableServers)\\n            \\n            count[assignedServer] += 1 # increase requestcount of this server by 1\\n            sortedAvailableServers.remove(assignedServer) # remove this server from list of free server\\n            heapq.heappush(heap,(arrivalTime+loadTime,assignedServer)) # insert this server in heap with free time as arrivalTime+loadTime\\n        \\n        # get the max request servered by any server\\n        maxRequestServedCount = max(count.values())\\n        result = []\\n        \\n        #iterate and pick all servers which servered maxRequest\\n        for serverId in count:\\n            if count[serverId] == maxRequestServedCount:\\n                result.append(serverId)\\n\\n        return result\\n        \\n                \\n```",
                "solutionTags": [],
                "code": "```\\nfrom sortedcontainers import SortedList\\nclass Solution:\\n    def getNextServer(self, index , sortedAvailableServers):\\n        nextIndexToRightOfServer = sortedAvailableServers.bisect_left(index)\\n        # Since We need to find next server availble greater than this index\\n        if nextIndexToRightOfServer != len(sortedAvailableServers):\\n            return sortedAvailableServers[nextIndexToRightOfServer]\\n        # No server greater than index found , means move in cycle and find the lowest avaiable server now\\n        lowestIdServerAvailable = sortedAvailableServers.bisect_left(0)\\n        return sortedAvailableServers[lowestIdServerAvailable]\\n                \\n    def busiestServers(self, k: int, arrival: List[int], load: List[int]) -> List[int]:\\n        heap = [] \\n        # This heap will be use to make servers as free , the first server to become free will be top element of heap\\n        \\n        sortedAvailableServers = SortedList([i for i in range(k)])      \\n        # This sorted available server list will be used to assign the load to new server , more comment in function \\n        \\n        count = collections.defaultdict(int)\\n        # This count dictionary will be used to record the count of request each server has handled, will be used in calculating result\\n        \\n        for i in range(len(arrival)):\\n            arrivalTime,loadTime = arrival[i], load[i]\\n            # ArrivalTime and loadTime , SimpleStuff\\n            \\n            # Check if any server has become free now, since top of heap will contain the first server which will get free\\n            # we just compare top server free time with currentTime and mark the server as free if possible\\n            while len(heap) > 0 and heap[0][0] <= arrivalTime:\\n                _,serverId = heapq.heappop(heap)\\n                # after marker this server free add it to list of free Servers\\n                sortedAvailableServers.add(serverId)\\n\\n            #Check for any server Available\\n            if len(sortedAvailableServers) == 0:\\n                # Drop this Request because no server available\\n                continue\\n            \\n            # Get the assigned serverId for this Request\\n            assignedServer = self.getNextServer(i%k,sortedAvailableServers)\\n            \\n            count[assignedServer] += 1 # increase requestcount of this server by 1\\n            sortedAvailableServers.remove(assignedServer) # remove this server from list of free server\\n            heapq.heappush(heap,(arrivalTime+loadTime,assignedServer)) # insert this server in heap with free time as arrivalTime+loadTime\\n        \\n        # get the max request servered by any server\\n        maxRequestServedCount = max(count.values())\\n        result = []\\n        \\n        #iterate and pick all servers which servered maxRequest\\n        for serverId in count:\\n            if count[serverId] == maxRequestServedCount:\\n                result.append(serverId)\\n\\n        return result\\n        \\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 877051,
                "title": "c-pq-set-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n        vector<int> result;\\n        unordered_map<int, int> serverReqCount;\\n        \\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>> > pq;\\n        set<int> availableServers;\\n        \\n        //Assign the first k request to each server, add in PQ\\n        for(int i = 0; i < k && i < arrival.size(); i++)\\n        {\\n            pq.push({arrival[i] + load[i], i});\\n            serverReqCount[i]++;\\n        }\\n        \\n        for(int i = k; i < arrival.size(); i++)\\n        {\\n            if(availableServers.size() || (pq.size() && arrival[i] >= pq.top().first))\\n            {\\n                //Check if any other server got free.\\n                while(pq.size() && arrival[i] >= pq.top().first)\\n                {\\n                    //Add in to available list.\\n                    availableServers.insert(pq.top().second);\\n                    pq.pop();\\n                }\\n                \\n                //Find the first server in order.\\n                auto server = lower_bound(availableServers.begin(), availableServers.end(), i%k);\\n                \\n                //Roll over if no server found.\\n                if(server == availableServers.end())\\n                    server = availableServers.begin();\\n                \\n                //Update the ds.\\n                serverReqCount[*server]++;\\n                pq.push({arrival[i]+load[i], *server});                    \\n                \\n                //Remove from available list.\\n                availableServers.erase(server);                    \\n            }\\n        }\\n        \\n        \\n        //Get the max\\n        int maxr = INT_MIN;\\n        for(auto& sc: serverReqCount)\\n            maxr = max(maxr, sc.second);\\n        \\n        \\n        //There can be multiple servers with same req count.\\n        for(auto& sc: serverReqCount)\\n        {\\n            if(sc.second == maxr)\\n                result.push_back(sc.first);\\n        }\\n            \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n        vector<int> result;\\n        unordered_map<int, int> serverReqCount;\\n        \\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>> > pq;\\n        set<int> availableServers;\\n        \\n        //Assign the first k request to each server, add in PQ\\n        for(int i = 0; i < k && i < arrival.size(); i++)\\n        {\\n            pq.push({arrival[i] + load[i], i});\\n            serverReqCount[i]++;\\n        }\\n        \\n        for(int i = k; i < arrival.size(); i++)\\n        {\\n            if(availableServers.size() || (pq.size() && arrival[i] >= pq.top().first))\\n            {\\n                //Check if any other server got free.\\n                while(pq.size() && arrival[i] >= pq.top().first)\\n                {\\n                    //Add in to available list.\\n                    availableServers.insert(pq.top().second);\\n                    pq.pop();\\n                }\\n                \\n                //Find the first server in order.\\n                auto server = lower_bound(availableServers.begin(), availableServers.end(), i%k);\\n                \\n                //Roll over if no server found.\\n                if(server == availableServers.end())\\n                    server = availableServers.begin();\\n                \\n                //Update the ds.\\n                serverReqCount[*server]++;\\n                pq.push({arrival[i]+load[i], *server});                    \\n                \\n                //Remove from available list.\\n                availableServers.erase(server);                    \\n            }\\n        }\\n        \\n        \\n        //Get the max\\n        int maxr = INT_MIN;\\n        for(auto& sc: serverReqCount)\\n            maxr = max(maxr, sc.second);\\n        \\n        \\n        //There can be multiple servers with same req count.\\n        for(auto& sc: serverReqCount)\\n        {\\n            if(sc.second == maxr)\\n                result.push_back(sc.first);\\n        }\\n            \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1089184,
                "title": "python3-summarizing-3-approaches",
                "content": "**Approach 1** - heap only \\nI was completely amazed to learn this solution from @warmr0bot in this [post](https://leetcode.com/problems/find-servers-that-handled-most-number-of-requests/discuss/876883/Python-using-only-heaps). Here, the trick is to relocate a freed server to a later place by circularly adjusting its index. In this way, when we are looking server `ii` at position `i` where `ii < i`, we will free `ii` to a place `ii + x*k` where `x` is enough so that `ii+x*k` bearly passes `i`. Mathematically, `i + (ii-i)%k` does the trick. \\n\\nImplementation \\n```\\nclass Solution:\\n    def busiestServers(self, k: int, arrival: List[int], load: List[int]) -> List[int]:\\n        busy = [] # min-heap\\n        free = list(range(k)) # min-heap \\n        freq = [0]*k\\n        \\n        for i, (ta, tl) in enumerate(zip(arrival, load)): \\n            while busy and busy[0][0] <= ta: \\n                _, ii = heappop(busy)\\n                heappush(free, i + (ii - i) % k) # circularly relocate it\\n            if free: \\n                ii = heappop(free) % k \\n                freq[ii] += 1\\n                heappush(busy, (ta+tl, ii))\\n        \\n        mx = max(freq)\\n        return [i for i, x in enumerate(freq) if x == mx]\\n```\\n\\n**Approach 2** - Fenwick tree\\nThis is my original approach, but it is really slow (8000+ms). Here, we use a Fenwick tree to label free servers and use binary search to locate the left-most free servers past a give index `i`. \\n\\n```\\nclass Fenwick: \\n\\tdef __init__(self, n: int):\\n\\t\\tself.nums = [0]*(n+1)\\n\\n\\tdef sum(self, k: int) -> int: \\n\\t\\t\"\"\"Return the sum of nums[:k].\"\"\"\\n\\t\\tans = 0\\n\\t\\twhile k:\\n\\t\\t\\tans += self.nums[k]\\n\\t\\t\\tk -= k & -k # unset last set bit \\n\\t\\treturn ans\\n\\n\\tdef add(self, k: int, x: int) -> None: \\n\\t\\tk += 1\\n\\t\\twhile k < len(self.nums): \\n\\t\\t\\tself.nums[k] += x\\n\\t\\t\\tk += k & -k \\n    \\n\\nclass Solution:\\n    def busiestServers(self, k: int, arrival: List[int], load: List[int]) -> List[int]:\\n        freq = [0]*k # counter \\n        pq = [] # min-heap \\n        \\n        fw = Fenwick(k) # count of available servers \\n        for i in range(k): fw.add(i, 1) \\n        \\n        for i, (ta, tl) in enumerate(zip(arrival, load)): \\n            i %= k \\n            while pq and pq[0][0] <= ta: \\n                _, ii = heappop(pq) # release servers \\n                fw.add(ii, 1)\\n            \\n            if fw.sum(k):\\n                if fw.sum(k) - fw.sum(i): lo, hi, x = i, k, fw.sum(i)\\n                else: lo, hi, x = 0, i, 0\\n                \\n                while lo < hi: \\n                    mid = lo + hi >> 1\\n                    if fw.sum(mid) - x: hi = mid\\n                    else: lo = mid + 1\\n                fw.add(lo-1, -1)\\n                freq[lo-1] += 1\\n                heappush(pq, (ta+tl, lo-1))\\n                \\n        mx = max(freq)\\n        return [i for i, x in enumerate(freq) if x == mx]\\n```\\n\\n**Approach 3** - SortedList\\n`SortedList` is an interesting data structure of `sortedcontainers` which is an external library and doesn\\'t come with Python by default. I believe the underlying data structure is a balanced bst. \\n\\n```\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n    def busiestServers(self, k: int, arrival: List[int], load: List[int]) -> List[int]:\\n        freq = [0]*k\\n        busy = [] # min-heap \\n        free = SortedList(range(k)) # balanced bst\\n        \\n        for i, (ta, tl) in enumerate(zip(arrival, load)): \\n            while busy and busy[0][0] <= ta: \\n                _, ii = heappop(busy)\\n                free.add(ii)\\n            \\n            if free: \\n                ii = free.bisect_left(i%k) % len(free)\\n                server = free.pop(ii)\\n                freq[server] += 1\\n                heappush(busy, (ta+tl, server))\\n        \\n        mx = max(freq)\\n        return [i for i, x in enumerate(freq) if x == mx]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def busiestServers(self, k: int, arrival: List[int], load: List[int]) -> List[int]:\\n        busy = [] # min-heap\\n        free = list(range(k)) # min-heap \\n        freq = [0]*k\\n        \\n        for i, (ta, tl) in enumerate(zip(arrival, load)): \\n            while busy and busy[0][0] <= ta: \\n                _, ii = heappop(busy)\\n                heappush(free, i + (ii - i) % k) # circularly relocate it\\n            if free: \\n                ii = heappop(free) % k \\n                freq[ii] += 1\\n                heappush(busy, (ta+tl, ii))\\n        \\n        mx = max(freq)\\n        return [i for i, x in enumerate(freq) if x == mx]\\n```\n```\\nclass Fenwick: \\n\\tdef __init__(self, n: int):\\n\\t\\tself.nums = [0]*(n+1)\\n\\n\\tdef sum(self, k: int) -> int: \\n\\t\\t\"\"\"Return the sum of nums[:k].\"\"\"\\n\\t\\tans = 0\\n\\t\\twhile k:\\n\\t\\t\\tans += self.nums[k]\\n\\t\\t\\tk -= k & -k # unset last set bit \\n\\t\\treturn ans\\n\\n\\tdef add(self, k: int, x: int) -> None: \\n\\t\\tk += 1\\n\\t\\twhile k < len(self.nums): \\n\\t\\t\\tself.nums[k] += x\\n\\t\\t\\tk += k & -k \\n    \\n\\nclass Solution:\\n    def busiestServers(self, k: int, arrival: List[int], load: List[int]) -> List[int]:\\n        freq = [0]*k # counter \\n        pq = [] # min-heap \\n        \\n        fw = Fenwick(k) # count of available servers \\n        for i in range(k): fw.add(i, 1) \\n        \\n        for i, (ta, tl) in enumerate(zip(arrival, load)): \\n            i %= k \\n            while pq and pq[0][0] <= ta: \\n                _, ii = heappop(pq) # release servers \\n                fw.add(ii, 1)\\n            \\n            if fw.sum(k):\\n                if fw.sum(k) - fw.sum(i): lo, hi, x = i, k, fw.sum(i)\\n                else: lo, hi, x = 0, i, 0\\n                \\n                while lo < hi: \\n                    mid = lo + hi >> 1\\n                    if fw.sum(mid) - x: hi = mid\\n                    else: lo = mid + 1\\n                fw.add(lo-1, -1)\\n                freq[lo-1] += 1\\n                heappush(pq, (ta+tl, lo-1))\\n                \\n        mx = max(freq)\\n        return [i for i, x in enumerate(freq) if x == mx]\\n```\n```\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n    def busiestServers(self, k: int, arrival: List[int], load: List[int]) -> List[int]:\\n        freq = [0]*k\\n        busy = [] # min-heap \\n        free = SortedList(range(k)) # balanced bst\\n        \\n        for i, (ta, tl) in enumerate(zip(arrival, load)): \\n            while busy and busy[0][0] <= ta: \\n                _, ii = heappop(busy)\\n                free.add(ii)\\n            \\n            if free: \\n                ii = free.bisect_left(i%k) % len(free)\\n                server = free.pop(ii)\\n                freq[server] += 1\\n                heappush(busy, (ta+tl, server))\\n        \\n        mx = max(freq)\\n        return [i for i, x in enumerate(freq) if x == mx]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 876831,
                "title": "c-set-priority-queue-binary-search-o-nlogk-with-detailed-explanation",
                "content": "**Brute Force:**\\nFor each request i we traverse all servers starting from i%k and check which is the next available server and schedule the task. This will take O(k) time to know which server should schedule the current job.\\n\\n**Time Complexity: O(n * k)**\\n\\n**Optimized Solution:**\\nInstead of doing a linear search on servers for every job, it would be a good idea to use binary search instead. This will bring down the complexity for finding the next server where the job could be scheduled from O(k) to O(logk) time. \\n\\nTo keep the list of available servers sorted we\\'ll use stl sets, lower_bound function for binay search and priority_queue to reclaim servers that are available again.\\n\\nThus, we can solve this problem using sets, priority_queue and lower_bound function in nlogk time.\\n\\n**Time Complexity: O(nlogk)\\nSpace Complexity: O(k)**\\n\\n```\\nclass Solution {\\npublic:\\n    \\n     vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n\\t\\t // stores the number of processes scheduled on each server\\n        vector<int> servers(k,0);\\n\\t\\t\\n\\t\\t// max number of processes scheduled\\n        int max_val = 0;\\n\\t\\t\\n\\t\\t// for priority queue to reclaim servers that are idle now\\n        auto comp = [](pair<int,int>&a, pair<int,int>&b){\\n            return a.first > b.first;\\n        };\\n\\t\\t\\n\\t\\t// priority queue stores {time when server will become free, server id}\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,decltype(comp)> pq(comp);\\n\\t\\t\\n\\t\\t// set of available servers\\n        set<int> available;\\n\\t\\t\\n        for(int i=0;i<k;i++)\\n            available.insert(i);\\n\\t\\t\\t\\n        for(int i=0;i<arrival.size();i++){\\n            \\n\\t\\t\\t// if the time surpasses curr time reclaim server \\n            while(!pq.empty() && pq.top().first<=arrival[i]){\\n                available.insert(pq.top().second);\\n                pq.pop();\\n            }\\n           \\n\\t\\t   // if no server is available drop the request and continue\\n            if(available.empty())\\n                continue;\\n\\t\\t\\t\\n\\t\\t\\t// get the next available server\\n            auto itr = available.lower_bound(i%k);\\n\\t\\t\\t\\n\\t\\t\\t// wrap around\\n            if(itr==available.end()){\\n                itr = available.begin();\\n            }\\n           \\n\\t\\t    // schedule the process\\n            servers[*itr]++;\\n            \\n            pq.push({arrival[i]+load[i],*itr});\\n            int val = *itr;\\n\\t\\t\\t\\n\\t\\t\\t// mark server as known available\\n            available.erase(val);\\n           \\n            max_val = max(max_val,servers[val]);\\n\\n        }\\n     \\n        vector<int> ans;\\n\\t\\t\\n\\t\\t// get all busiest servers\\n        for(int i=0;i<servers.size();i++){\\n            if(servers[i] == max_val)\\n                ans.push_back(i);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n     vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n\\t\\t // stores the number of processes scheduled on each server\\n        vector<int> servers(k,0);\\n\\t\\t\\n\\t\\t// max number of processes scheduled\\n        int max_val = 0;\\n\\t\\t\\n\\t\\t// for priority queue to reclaim servers that are idle now\\n        auto comp = [](pair<int,int>&a, pair<int,int>&b){\\n            return a.first > b.first;\\n        };\\n\\t\\t\\n\\t\\t// priority queue stores {time when server will become free, server id}\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,decltype(comp)> pq(comp);\\n\\t\\t\\n\\t\\t// set of available servers\\n        set<int> available;\\n\\t\\t\\n        for(int i=0;i<k;i++)\\n            available.insert(i);\\n\\t\\t\\t\\n        for(int i=0;i<arrival.size();i++){\\n            \\n\\t\\t\\t// if the time surpasses curr time reclaim server \\n            while(!pq.empty() && pq.top().first<=arrival[i]){\\n                available.insert(pq.top().second);\\n                pq.pop();\\n            }\\n           \\n\\t\\t   // if no server is available drop the request and continue\\n            if(available.empty())\\n                continue;\\n\\t\\t\\t\\n\\t\\t\\t// get the next available server\\n            auto itr = available.lower_bound(i%k);\\n\\t\\t\\t\\n\\t\\t\\t// wrap around\\n            if(itr==available.end()){\\n                itr = available.begin();\\n            }\\n           \\n\\t\\t    // schedule the process\\n            servers[*itr]++;\\n            \\n            pq.push({arrival[i]+load[i],*itr});\\n            int val = *itr;\\n\\t\\t\\t\\n\\t\\t\\t// mark server as known available\\n            available.erase(val);\\n           \\n            max_val = max(max_val,servers[val]);\\n\\n        }\\n     \\n        vector<int> ans;\\n\\t\\t\\n\\t\\t// get all busiest servers\\n        for(int i=0;i<servers.size();i++){\\n            if(servers[i] == max_val)\\n                ans.push_back(i);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 877287,
                "title": "java-brutal-force",
                "content": "Please see the code, should be easy to understand;\\n```\\n    public List<Integer> busiestServers(int k, int[] as, int[] ls) {\\n        int exp[] = new int[k], cnt[] = new int[k], max = 0;\\n        for (int i = 0; i < as.length; i++) {\\n            int t = as[i], l = ls[i], s = i % k;\\n            for (int j = 0; j < k; j++, s++) {\\n                if (s == k) s = 0;\\n                if (exp[s] <= t) {  // check if free by last job expiration time;\\n                    cnt[s]++;\\n                    exp[s] = t + l;  // load the job and set the job exp time;\\n                    break;\\n                }\\n            }\\n        }\\n        List<Integer> res = new ArrayList<>();\\n        for (int i = 0; i < k; i++) {\\n            if (cnt[i] == max) res.add(i);\\n            else if (cnt[i] > max) {\\n                max = cnt[i];\\n                res = new ArrayList<>();\\n                res.add(i);\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public List<Integer> busiestServers(int k, int[] as, int[] ls) {\\n        int exp[] = new int[k], cnt[] = new int[k], max = 0;\\n        for (int i = 0; i < as.length; i++) {\\n            int t = as[i], l = ls[i], s = i % k;\\n            for (int j = 0; j < k; j++, s++) {\\n                if (s == k) s = 0;\\n                if (exp[s] <= t) {  // check if free by last job expiration time;\\n                    cnt[s]++;\\n                    exp[s] = t + l;  // load the job and set the job exp time;\\n                    break;\\n                }\\n            }\\n        }\\n        List<Integer> res = new ArrayList<>();\\n        for (int i = 0; i < k; i++) {\\n            if (cnt[i] == max) res.add(i);\\n            else if (cnt[i] > max) {\\n                max = cnt[i];\\n                res = new ArrayList<>();\\n                res.add(i);\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 876843,
                "title": "c-simple-o-nlogn-solution-sorted-available-servers-current-requests",
                "content": "Idea : Maintain a list of available servers in a ordered set. \\nWhen a new request arrives, take the first available server by using lower_bound on the set, if we reach end of set, use the first server in the set. \\nAssign the free server the request and maintain this in a set of `<finish-time, server-id>`.\\n\\nTo get servers who have finished execution, before assigning a new request, just check the server requests set and remove completed requests and mark these servers available.\\n\\nTo identify the busiest server(s), maintain a count of requests handled by each server and use it after all the requests are completed.\\n\\nTime complexity : O(nlogn)\\nSpace complexity : O(k)\\n```\\nclass Solution {\\npublic:\\n    vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n        vector<int> handled_requests(k);\\n        set<pair<int, int>> current_requests;\\n        set<int> available_servers;\\n        for(int i = 0; i < k; i++) {\\n            available_servers.insert(i);\\n        }\\n\\n        for(int i = 0; i < arrival.size(); i++) {\\n            while(!current_requests.empty()) {\\n                auto x = current_requests.begin();\\n                if(x->first <= arrival[i]) {\\n                    available_servers.insert(x->second); // add in available servers\\n                    current_requests.erase(current_requests.begin());\\n                } else {\\n                    break;\\n                }\\n            }\\n            int server_id = i % k;\\n            if(available_servers.size() == 0) {\\n                continue;\\n            }\\n            auto it = available_servers.lower_bound(server_id);\\n            if(it == available_servers.end()) {\\n                // cyclic behaviour\\n                it = available_servers.begin();\\n            }\\n            int u = *it;\\n            available_servers.erase(u); // remove from available servers\\n            handled_requests[u]++;\\n\\n            current_requests.insert({arrival[i] + load[i], u});\\n        }\\n        \\n        vector<int> ans;\\n        int m = *max_element(handled_requests.begin(), handled_requests.end());\\n        for(int i = 0; i < k; i++) {\\n            if(handled_requests[i] == m) {\\n                ans.push_back(i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n        vector<int> handled_requests(k);\\n        set<pair<int, int>> current_requests;\\n        set<int> available_servers;\\n        for(int i = 0; i < k; i++) {\\n            available_servers.insert(i);\\n        }\\n\\n        for(int i = 0; i < arrival.size(); i++) {\\n            while(!current_requests.empty()) {\\n                auto x = current_requests.begin();\\n                if(x->first <= arrival[i]) {\\n                    available_servers.insert(x->second); // add in available servers\\n                    current_requests.erase(current_requests.begin());\\n                } else {\\n                    break;\\n                }\\n            }\\n            int server_id = i % k;\\n            if(available_servers.size() == 0) {\\n                continue;\\n            }\\n            auto it = available_servers.lower_bound(server_id);\\n            if(it == available_servers.end()) {\\n                // cyclic behaviour\\n                it = available_servers.begin();\\n            }\\n            int u = *it;\\n            available_servers.erase(u); // remove from available servers\\n            handled_requests[u]++;\\n\\n            current_requests.insert({arrival[i] + load[i], u});\\n        }\\n        \\n        vector<int> ans;\\n        int m = *max_element(handled_requests.begin(), handled_requests.end());\\n        for(int i = 0; i < k; i++) {\\n            if(handled_requests[i] == m) {\\n                ans.push_back(i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 876797,
                "title": "java-o-nlogk-use-treeset-and-priorityqueue",
                "content": "Well, this question is really straight forward.\\nMy first idea is follow the instruction listed in description and simulate.\\n\\nSome common skills that we can think of:\\nTo track the frequency of each server, we use an array.\\nTo track the time point of each server\\'s availability, we use an array to record the time point server will be free.\\n\\nBut if we try `i`, `i + 1`, `i + 2`, ... , it will definatly lead to TLE.\\nSo, how to quickly find next empty server?\\nWe can use a `TreeSet` to store the index of all free servers, then we can quickly find next free serve.\\nAlso, to track which server will be free at a time point, we need to maintain a heap of busy servers.\\n\\n\\n```java\\nclass Solution {\\n    public List<Integer> busiestServers(int k, int[] arrival, int[] load) {\\n        \\n        int fre[] = new int[k], availability[] = new int[k], max = 0;\\n        \\n        TreeSet<Integer> free = new TreeSet<>();\\n        PriorityQueue<Integer> busy = new PriorityQueue<>((a, b) -> availability[a] - availability[b]);\\n        \\n        for(int i = 0; i < k; i++) free.add(i);\\n        \\n        for(int i = 0; i < arrival.length; i++) {\\n            // try to get all free nodes\\n            while(!busy.isEmpty() && availability[busy.peek()] <= arrival[i]) {\\n                free.add(busy.poll());\\n            }\\n            \\n            if(free.isEmpty()) continue ; // drop\\n            \\n            \\n            if(free.contains(i % k)) { // i + k server is free\\n                free.remove(i % k);\\n                availability[i % k] = arrival[i] + load[i];\\n                busy.add(i % k);\\n                \\n                fre[i % k]++;\\n                max = Math.max(max, fre[i % k]);\\n            } else { // find next free server\\n                Integer nxt = free.ceiling(i % k); // try to find a free server next to i\\n                if(nxt == null) nxt = free.first(); // no free server with index larger than i. So we use a server with minimum index\\n                \\n                free.remove(nxt);\\n                availability[nxt] = arrival[i] + load[i];\\n                busy.add(nxt);\\n                \\n                fre[nxt]++;\\n                max = Math.max(max, fre[nxt]);\\n            }\\n        }\\n        \\n        List<Integer> res = new ArrayList<>();\\n        for(int i = 0; i < k; i++) if(fre[i] == max) res.add(i);\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public List<Integer> busiestServers(int k, int[] arrival, int[] load) {\\n        \\n        int fre[] = new int[k], availability[] = new int[k], max = 0;\\n        \\n        TreeSet<Integer> free = new TreeSet<>();\\n        PriorityQueue<Integer> busy = new PriorityQueue<>((a, b) -> availability[a] - availability[b]);\\n        \\n        for(int i = 0; i < k; i++) free.add(i);\\n        \\n        for(int i = 0; i < arrival.length; i++) {\\n            // try to get all free nodes\\n            while(!busy.isEmpty() && availability[busy.peek()] <= arrival[i]) {\\n                free.add(busy.poll());\\n            }\\n            \\n            if(free.isEmpty()) continue ; // drop\\n            \\n            \\n            if(free.contains(i % k)) { // i + k server is free\\n                free.remove(i % k);\\n                availability[i % k] = arrival[i] + load[i];\\n                busy.add(i % k);\\n                \\n                fre[i % k]++;\\n                max = Math.max(max, fre[i % k]);\\n            } else { // find next free server\\n                Integer nxt = free.ceiling(i % k); // try to find a free server next to i\\n                if(nxt == null) nxt = free.first(); // no free server with index larger than i. So we use a server with minimum index\\n                \\n                free.remove(nxt);\\n                availability[nxt] = arrival[i] + load[i];\\n                busy.add(nxt);\\n                \\n                fre[nxt]++;\\n                max = Math.max(max, fre[nxt]);\\n            }\\n        }\\n        \\n        List<Integer> res = new ArrayList<>();\\n        for(int i = 0; i < k; i++) if(fre[i] == max) res.add(i);\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 877164,
                "title": "java-treemap-and-priorityqueue",
                "content": "```\\nclass Server {\\n    int tr = 0; // Total Requests\\n    int ft = 0; // Finishing Time\\n    int index; // Server Index\\n    \\n    public Server(int index) {\\n        this.index = index;\\n    }\\n    \\n}\\n\\nclass Solution {\\n    public List<Integer> busiestServers(int k, int[] arrival, int[] load) {\\n       \\n        TreeMap<Integer, Server> available = new TreeMap<>(); // Map of Available Servers\\n        PriorityQueue<Server> busy = new PriorityQueue<>((Server a, Server b) -> {\\n            return a.ft - b.ft;\\n        });\\n        List<Server> list = new ArrayList<>();\\n        for(int i = 0; i < k; i++) {\\n            Server server = new Server(i);\\n            list.add(server);\\n            available.put(i, server);\\n        }\\n       int max = 0;\\n       for(int i = 0; i < arrival.length; i++) {\\n            while(!busy.isEmpty() && busy.peek().ft <= arrival[i]){\\n                Server server = busy.remove();\\n                available.put(server.index, server);\\n            }\\n            if(available.size() == 0) continue;\\n            int req = (i % k);\\n            int serverIndex = -1;\\n            if(available.ceilingKey(req) != null) serverIndex = available.ceilingKey(req);           \\n            else serverIndex = available.firstKey();\\n            Server server = available.get(serverIndex);\\n            server.ft = arrival[i] + load[i];\\n            server.tr += 1;\\n            max = Math.max(max, server.tr);\\n            busy.add(server);\\n            available.remove(serverIndex);\\n        }\\n        List<Integer> result = new ArrayList<>();\\n        for(int j =0; j < k; j++) {\\n            if(list.get(j).tr == max) result.add(j);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Server {\\n    int tr = 0; // Total Requests\\n    int ft = 0; // Finishing Time\\n    int index; // Server Index\\n    \\n    public Server(int index) {\\n        this.index = index;\\n    }\\n    \\n}\\n\\nclass Solution {\\n    public List<Integer> busiestServers(int k, int[] arrival, int[] load) {\\n       \\n        TreeMap<Integer, Server> available = new TreeMap<>(); // Map of Available Servers\\n        PriorityQueue<Server> busy = new PriorityQueue<>((Server a, Server b) -> {\\n            return a.ft - b.ft;\\n        });\\n        List<Server> list = new ArrayList<>();\\n        for(int i = 0; i < k; i++) {\\n            Server server = new Server(i);\\n            list.add(server);\\n            available.put(i, server);\\n        }\\n       int max = 0;\\n       for(int i = 0; i < arrival.length; i++) {\\n            while(!busy.isEmpty() && busy.peek().ft <= arrival[i]){\\n                Server server = busy.remove();\\n                available.put(server.index, server);\\n            }\\n            if(available.size() == 0) continue;\\n            int req = (i % k);\\n            int serverIndex = -1;\\n            if(available.ceilingKey(req) != null) serverIndex = available.ceilingKey(req);           \\n            else serverIndex = available.firstKey();\\n            Server server = available.get(serverIndex);\\n            server.ft = arrival[i] + load[i];\\n            server.tr += 1;\\n            max = Math.max(max, server.tr);\\n            busy.add(server);\\n            available.remove(serverIndex);\\n        }\\n        List<Integer> result = new ArrayList<>();\\n        for(int j =0; j < k; j++) {\\n            if(list.get(j).tr == max) result.add(j);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 876910,
                "title": "python-o-nlogk-sortedlist-and-heap",
                "content": "Approach 1. Simulate (TLE)\\n\\nWe do exactly what we are told in the problem statement.\\n```python \\nclass Solution:\\n    def busiestServers(self, k: int, arrival: List[int], load: List[int]) -> List[int]:\\n        endtimes = [0] * k\\n        count    = [0] * k\\n        \\n        for aidx, (a, l) in enumerate(zip(arrival, load)):\\n            serveridx = aidx % k\\n            if endtimes[serveridx]<=a:\\n                count[serveridx]+=1\\n                endtimes[serveridx] = a+l\\n            else:\\n                nextserveridx = (serveridx + 1) % k\\n                while nextserveridx != serveridx:\\n                    if endtimes[nextserveridx] <= a:\\n                        count[nextserveridx]+=1\\n                        endtimes[nextserveridx] = a + l\\n                        break\\n                    nextserveridx = (nextserveridx + 1) % k\\n        \\n        max_ = max(count)\\n        ans = []\\n        for i in range(k):\\n            if count[i]==max_:\\n                ans.append(i)\\n        return ans\\n```\\nN=number of requests\\nK=number of servers\\nTime: O(NK)\\nSpace: O(K)\\n\\nApproach 2. Use SortedList and Heap\\n\\nWe need to find a better way to find the next available server. Since we need to find the next available server in a circular way, we can use a SortedList to give us O(logK) time for finding the next available server. And we also need to remember the servers that are curently used. We can use a heap to keeptrack of the earliest ending request and pop it when a new request starts later.\\n\\n```python\\nfrom sortedcontainers import SortedList\\nclass Solution:\\n    def busiestServers(self, k: int, arrival: List[int], load: List[int]) -> List[int]:\\n        count = [0] * k # keep track of how many requests handled each server\\n        \\n        available_servers = SortedList(range(k)) # a sorted list containing indices of available servers\\n        heap_endtimes = [] # use a heap data structure that contains tuples (end_time, server_idx)\\n        \\n        for aidx, (a, l) in enumerate(zip(arrival, load)):\\n            while h and h[0][0] <= a: # when a new request start time is greater that the endtime of any request\\n                _, free_server_idx = heapq.heappop(heap_endtimes) # free the server  from the hea[\\n                available_servers.add(free_server_idx) # and add it to the available servers list\\n\\n\\t\\t\\tif len(available_servers)==0: \\n                continue\\n                \\n            serveridx = aidx % k # which server should handle this request according to the presented rule?\\n            i = available_servers.bisect_left(serveridx) % len(available_servers) # i will point either to the serveridx if it exists in the sorted list, or it will point to the next one\\n            actual_server = available_servers.pop(i) # remove the server from the available list\\n            count[actual_server]+=1 # increment the number of times the server had been used\\n            heapq.heappush(heap_endtimes, (a+l, actual_server)) # make the server end at a+l\\n            \\n        max_ = max(count)\\n        ans = []\\n        for i in range(k):\\n            if count[i]==max_:\\n                ans.append(i)\\n        return ans\\n```\\nTime: O(NlogK)\\nSpace: O(K)",
                "solutionTags": [],
                "code": "```python \\nclass Solution:\\n    def busiestServers(self, k: int, arrival: List[int], load: List[int]) -> List[int]:\\n        endtimes = [0] * k\\n        count    = [0] * k\\n        \\n        for aidx, (a, l) in enumerate(zip(arrival, load)):\\n            serveridx = aidx % k\\n            if endtimes[serveridx]<=a:\\n                count[serveridx]+=1\\n                endtimes[serveridx] = a+l\\n            else:\\n                nextserveridx = (serveridx + 1) % k\\n                while nextserveridx != serveridx:\\n                    if endtimes[nextserveridx] <= a:\\n                        count[nextserveridx]+=1\\n                        endtimes[nextserveridx] = a + l\\n                        break\\n                    nextserveridx = (nextserveridx + 1) % k\\n        \\n        max_ = max(count)\\n        ans = []\\n        for i in range(k):\\n            if count[i]==max_:\\n                ans.append(i)\\n        return ans\\n```\n```python\\nfrom sortedcontainers import SortedList\\nclass Solution:\\n    def busiestServers(self, k: int, arrival: List[int], load: List[int]) -> List[int]:\\n        count = [0] * k # keep track of how many requests handled each server\\n        \\n        available_servers = SortedList(range(k)) # a sorted list containing indices of available servers\\n        heap_endtimes = [] # use a heap data structure that contains tuples (end_time, server_idx)\\n        \\n        for aidx, (a, l) in enumerate(zip(arrival, load)):\\n            while h and h[0][0] <= a: # when a new request start time is greater that the endtime of any request\\n                _, free_server_idx = heapq.heappop(heap_endtimes) # free the server  from the hea[\\n                available_servers.add(free_server_idx) # and add it to the available servers list\\n\\n\\t\\t\\tif len(available_servers)==0: \\n                continue\\n                \\n            serveridx = aidx % k # which server should handle this request according to the presented rule?\\n            i = available_servers.bisect_left(serveridx) % len(available_servers) # i will point either to the serveridx if it exists in the sorted list, or it will point to the next one\\n            actual_server = available_servers.pop(i) # remove the server from the available list\\n            count[actual_server]+=1 # increment the number of times the server had been used\\n            heapq.heappush(heap_endtimes, (a+l, actual_server)) # make the server end at a+l\\n            \\n        max_ = max(count)\\n        ans = []\\n        for i in range(k):\\n            if count[i]==max_:\\n                ans.append(i)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1346318,
                "title": "java-treeset-with-priorityqueue",
                "content": "We want to maintain two pools of servers - a busy pool and an available pool. Every time a request comes in, we will first check which servers in our busy pool become available. Then we iterate over the available pool starting from `i % k` and wrapping around until we find a free server. Then this server is transferred from our available pool to the busy pool. We model the available pool as a sorted set so we can quickly answer queries of the form give me the id right after `x`. The busy pool is modelled as priority queue with key being the finishing time of currently processing request. Once a request arrives (i.e. we iterate to it), then we go over our busy pool to remove servers which stopped processing before the arrival time of the current request and transfer it to the available pool. Once available pool is updated, we assign a server to it.\\n\\n```\\nclass Solution {\\n    class Server {\\n        final int id;\\n        final int busyTime;\\n        public Server(int id, int busyTime){\\n            this.id = id;\\n            this.busyTime = busyTime;\\n        }\\n    }\\n    \\n    public List<Integer> busiestServers(int k, int[] arrival, int[] load) {\\n        TreeSet<Integer> available = new TreeSet<>();\\n        PriorityQueue<Server> busy = new PriorityQueue<>((a, b) -> a.busyTime - b.busyTime);\\n        int[] requestCount = new int[k];\\n        int n = arrival.length;\\n        for(int id = 0; id < k; id++){\\n            available.add(id);\\n        }\\n        \\n        for(int i = 0; i < n; i++){\\n            int defaultServer = (i % k);\\n            while(!busy.isEmpty() && busy.peek().busyTime <= arrival[i]){\\n                Server top = busy.poll();\\n                available.add(top.id);\\n            }\\n            \\n            if(available.isEmpty())continue;\\n            Integer nextServer = available.ceiling(defaultServer);\\n            nextServer = (nextServer != null) ? \\n                nextServer : available.ceiling(0);\\n            int requestEnd = arrival[i] + load[i];\\n            available.remove(nextServer);\\n            busy.add(new Server(nextServer, requestEnd));\\n            requestCount[nextServer]++;\\n        }\\n        \\n        int maxRequests = Integer.MIN_VALUE;\\n        List<Integer> busiestServers = new ArrayList<>();\\n        for(int id = 0; id < k; id++){\\n            maxRequests = Math.max(maxRequests, requestCount[id]);\\n        }\\n        \\n        for(int id = 0; id < k; id++){\\n            if(requestCount[id] == maxRequests)busiestServers.add(id);\\n        }\\n        \\n        return busiestServers;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    class Server {\\n        final int id;\\n        final int busyTime;\\n        public Server(int id, int busyTime){\\n            this.id = id;\\n            this.busyTime = busyTime;\\n        }\\n    }\\n    \\n    public List<Integer> busiestServers(int k, int[] arrival, int[] load) {\\n        TreeSet<Integer> available = new TreeSet<>();\\n        PriorityQueue<Server> busy = new PriorityQueue<>((a, b) -> a.busyTime - b.busyTime);\\n        int[] requestCount = new int[k];\\n        int n = arrival.length;\\n        for(int id = 0; id < k; id++){\\n            available.add(id);\\n        }\\n        \\n        for(int i = 0; i < n; i++){\\n            int defaultServer = (i % k);\\n            while(!busy.isEmpty() && busy.peek().busyTime <= arrival[i]){\\n                Server top = busy.poll();\\n                available.add(top.id);\\n            }\\n            \\n            if(available.isEmpty())continue;\\n            Integer nextServer = available.ceiling(defaultServer);\\n            nextServer = (nextServer != null) ? \\n                nextServer : available.ceiling(0);\\n            int requestEnd = arrival[i] + load[i];\\n            available.remove(nextServer);\\n            busy.add(new Server(nextServer, requestEnd));\\n            requestCount[nextServer]++;\\n        }\\n        \\n        int maxRequests = Integer.MIN_VALUE;\\n        List<Integer> busiestServers = new ArrayList<>();\\n        for(int id = 0; id < k; id++){\\n            maxRequests = Math.max(maxRequests, requestCount[id]);\\n        }\\n        \\n        for(int id = 0; id < k; id++){\\n            if(requestCount[id] == maxRequests)busiestServers.add(id);\\n        }\\n        \\n        return busiestServers;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2824708,
                "title": "c-maintain-priority-queue-of-busy-servers-and-keep-free-server-in-diff-place-for-fast-look-up",
                "content": "```cpp\\nclass Node {\\npublic:\\n    int end;\\n    int serverId;\\n};\\n\\n//min heap comparator\\nbool operator< (const Node &a, const Node &b) {\\n    return a.end > b.end;\\n}\\n\\nclass Solution {\\npublic:\\n    vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n        priority_queue<Node> busyServer;        \\n        set<int> freeServer;\\n        int n = load.size();\\n        unordered_map<int, int> serverLoad;\\n        for (int i = 0; i < k; ++i) {\\n            freeServer.insert(i);\\n        }\\n        int loadSoFar = 0;\\n        int res = 0;\\n        for (int i = 0; i < n; ++i) {\\n            int start = arrival[i];\\n            int duration = load[i];\\n            //pick all the servers\\n            //which have become free now;\\n            while (busyServer.size() > 0 && busyServer.top().end <= start) {\\n                freeServer.insert(busyServer.top().serverId);\\n                busyServer.pop();\\n            }\\n            //If there is a server available\\n            //then pick it\\n            if (freeServer.size() > 0) {\\n                auto it = freeServer.lower_bound(i % k);\\n                if (it == freeServer.end()) {\\n                    it = freeServer.begin();\\n                }\\n                int serverId = *it;\\n                freeServer.erase(it);\\n                busyServer.push({start + duration, serverId});\\n                ++serverLoad[serverId];\\n                if (serverLoad[serverId] > loadSoFar) {\\n                    res = serverId;\\n                    loadSoFar = serverLoad[serverId];\\n                }                    \\n            }\\n        }\\n        vector<int> result;\\n        for (pair<int, int> e: serverLoad) {\\n            if (e.second == loadSoFar) {\\n                result.push_back(e.first);\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Node {\\npublic:\\n    int end;\\n    int serverId;\\n};\\n\\n//min heap comparator\\nbool operator< (const Node &a, const Node &b) {\\n    return a.end > b.end;\\n}\\n\\nclass Solution {\\npublic:\\n    vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n        priority_queue<Node> busyServer;        \\n        set<int> freeServer;\\n        int n = load.size();\\n        unordered_map<int, int> serverLoad;\\n        for (int i = 0; i < k; ++i) {\\n            freeServer.insert(i);\\n        }\\n        int loadSoFar = 0;\\n        int res = 0;\\n        for (int i = 0; i < n; ++i) {\\n            int start = arrival[i];\\n            int duration = load[i];\\n            //pick all the servers\\n            //which have become free now;\\n            while (busyServer.size() > 0 && busyServer.top().end <= start) {\\n                freeServer.insert(busyServer.top().serverId);\\n                busyServer.pop();\\n            }\\n            //If there is a server available\\n            //then pick it\\n            if (freeServer.size() > 0) {\\n                auto it = freeServer.lower_bound(i % k);\\n                if (it == freeServer.end()) {\\n                    it = freeServer.begin();\\n                }\\n                int serverId = *it;\\n                freeServer.erase(it);\\n                busyServer.push({start + duration, serverId});\\n                ++serverLoad[serverId];\\n                if (serverLoad[serverId] > loadSoFar) {\\n                    res = serverId;\\n                    loadSoFar = serverLoad[serverId];\\n                }                    \\n            }\\n        }\\n        vector<int> result;\\n        for (pair<int, int> e: serverLoad) {\\n            if (e.second == loadSoFar) {\\n                result.push_back(e.first);\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2423326,
                "title": "java-o-n-log-k-time-complexity-solution-using-treeset-and-priority-queue",
                "content": "```\\nclass ServerInfo {\\n    private int serverId;\\n    private int nextAvailableTime;\\n    \\n    public ServerInfo (int serverId, int nextAvailableTime) {\\n        this.serverId = serverId;\\n        this. nextAvailableTime = nextAvailableTime;\\n    }   \\n    \\n    public int getNextAvailableTime() {\\n        return this.nextAvailableTime;\\n    }    \\n    \\n    public int getServerId() {\\n        return this.serverId;\\n    }\\n}\\n\\nclass ServerComparator implements Comparator<ServerInfo> {\\n    public int compare(ServerInfo s1, ServerInfo s2) {\\n        if (s1.getNextAvailableTime() == s2.getNextAvailableTime())\\n            return Integer.compare(s1.getServerId(), s2.getServerId());\\n        return Integer.compare(s1.getNextAvailableTime(), s2.getNextAvailableTime());\\n    }\\n}\\n\\nclass Solution {\\n    \\n    ServerComparator serverComparator = new ServerComparator();\\n    \\n    \\n    public List<Integer> busiestServers(int k, int[] arrival, int[] load) {\\n        \\n        int[] serverRequestsCounter = new int[k];\\n        \\n        \\n        // Initially all servers are idle\\n        TreeSet<Integer> availableServers = new TreeSet<>();\\n        for (int serverId=0; serverId<k; serverId++) {\\n            availableServers.add(serverId);\\n        }\\n        \\n        // Maintain the buzy servers in Priority Queue, when new arrival time comes, free up previous servers\\n        PriorityQueue<ServerInfo> buzyServers = new PriorityQueue<>(serverComparator);\\n        \\n        for (int idx=0; idx<arrival.length; idx++) {\\n            \\n            int arrivalTime = arrival[idx];\\n\\n            while (!buzyServers.isEmpty() \\n                   && arrivalTime >= buzyServers.peek().getNextAvailableTime()) {\\n                \\n                availableServers.add(buzyServers.poll().getServerId());\\n                \\n            }\\n            \\n            if (availableServers.isEmpty())\\n                continue;\\n            \\n            // This will give next server Id which is freed up\\n            Integer assignedServerId = availableServers.ceiling(idx % k);\\n            \\n            if (assignedServerId == null) {\\n                assignedServerId = availableServers.first();\\n            }\\n            \\n            serverRequestsCounter[assignedServerId]++;\\n            \\n            // Remove the assigned server from available pool\\n            availableServers.remove(assignedServerId);\\n                  \\n            // Add the assigned server to buzy pool\\n            buzyServers.add(new ServerInfo(assignedServerId, arrivalTime + load[idx]));\\n        \\n        }\\n        \\n        return busiestServers(serverRequestsCounter, k);\\n    }\\n    \\n    \\n    private List<Integer> busiestServers (int[] serverRequestsCounter, int numServers) {\\n        int maxRequests = 0;\\n        \\n        for  (int i=0; i<numServers; i++) {\\n            maxRequests = Math.max(serverRequestsCounter[i], maxRequests);\\n        }\\n        \\n        List<Integer> busiestServers = new ArrayList<>();\\n            \\n        for (int i=0; i<numServers; i++) {\\n            if (serverRequestsCounter[i] == maxRequests) {\\n                busiestServers.add(i);\\n            }\\n        }\\n        \\n        return busiestServers;\\n    }\\n}\\n",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\n    \\n    ServerComparator serverComparator = new ServerComparator();\\n    \\n    \\n    public List<Integer> busiestServers(int k, int[] arrival, int[] load) {\\n        \\n        int[] serverRequestsCounter = new int[k];\\n        \\n        \\n        // Initially all servers are idle\\n        TreeSet<Integer> availableServers = new TreeSet<>();\\n        for (int serverId=0; serverId<k; serverId++) {\\n            availableServers.add(serverId);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 933702,
                "title": "python-fenwick-tree-o-n-log-k",
                "content": "**Goal:**\\n\\nThe objective here is to iterate over the list of jobs (arrival times and loads) and assign each job to a server. \\nKeep track of how many jobs each server handled and return a list of the most productive servers.  \\n\\n**Approach:**\\n\\nAt the beginning all the servers are free.\\nAssign the first job to server 0, the second job to server 1, ..., the k<sup>th</sup> to server k-1.  No problems.\\n\\nAfter the first k jobs have been assigned, a server must start it\\'s second job.\\nTo find out which servers are done with their first job and ready to accept a second job,\\nwe could iterate over a list of servers and see which servers have an end time less than \\nor equal to the current time. But this would be very time consuming.  \\n\\nInstead store the busy servers in a min-heap where each busy server is a tuple (end_time, server_id).  \\nWhere end_time is the time that the server will finish its current job and server_id is the index of the server.  \\nAll busy servers with an end_time earlier than the current time (arrival[i]) are now free and can be popped off the server heap.  \\n\\nAssign the current job to the first free server to the right of the current index.  \\nWrap around to the start of the server list if necessary.  \\nKeep count of how many jobs each server receives in a hash map.\\nOnce all jobs have been assigned to servers - or dropped - return a list of the most productive servers.  \\n\\n**The Challenge:**\\n\\nThis problem is more than deserving of it\\'s hard rating.  \\nWhat makes this problem difficult is finding the first free server in **less than** linear time.  \\n\\nThe first free server can be found with a linear search (as shown in the Simple Solution).\\nHowever, this will result in an overall time complexity of O(n<sup>2</sup>) which will TLE.\\n\\nIn the aptly named Fenwick Tree Solution, a Fenwick Tree is used to speed up the process of finding the first free server.\\nFenwick trees serve the same purpose as a presum array in that they provide fast range sum queries.\\nThe difference is that they take a little longer to query **but** they are much faster to update.  \\n\\n| |Create| Range Sum Query|Update|\\n|---|---|---|---|\\n|Fenwick Tree| O(n)| O(log(n)) | O(log(n)) |\\n|Presum Array| O(n) | O(1) | O(n) |\\n\\nTo use a Fenwick tree to find the first free server, use a binary array servers where server[i] = 1 \\nmeans the i<sup>th</sup> sever is busy and server[i] = 0 means the i<sup>th</sup> server is free.  \\n\\nIf a free server exists in the range [i, j] then the range sum query of range [i, j] will be less than the length of the range.  \\nThen binary search for the left-most range of length 1 that has a sum of 0.  \\n\\n\\n**Observations:**\\n\\nIf there are more servers than there are jobs, then the first n servers will all get 1 job.\\nThe solution reduces to range(n) where n is the number of jobs. \\n\\nIf there is only one free server, then that server **must** receive the current job.  \\nKeep track of which servers are not busy in a set.  \\nWhen the length of the set is 1, we can assign the current job in O(log(n)) time as opposed to O(log(n)<sup>2</sup>) time.  \\n\\n<details>\\n\\n<b><summary>Simple Solution: (click to show)</summary></b>\\n\\n```python\\n#Runtime: TLE\\nclass Solution:\\n    def busiestServers(self, k: int, arrival: List[int], load: List[int]) -> List[int]:\\n        \\n        requests_handled = collections.defaultdict(int)\\n        servers = [] # server heap (end_time, server_id)\\n        free_servers = set(range(k))\\n        \\n        for i, (t, c) in enumerate(zip(arrival, load)):\\n            \\n            while servers and servers[0][0] <= t:\\n                free_servers.add(heapq.heappop(servers)[1])\\n            \\n            if free_servers:\\n                \\n                # find first free server\\n                target_server = i % k\\n                while target_server not in free_servers:\\n                    target_server = (target_server + 1) % k\\n                \\n                # mark the server as busy\\n                free_servers.remove(target_server)\\n                \\n                # add the server to the server heap\\n                heapq.heappush(servers, (t + c, target_server))\\n                requests_handled[target_server] += 1\\n        \\n        maxi = max(requests_handled.values())\\n        return [server for server in requests_handled if requests_handled[server] == maxi]\\n```\\n\\n</details>\\n\\n\\n<details>\\n\\n<b><summary>Fenwick Tree Solution: (click to show)</summary></b>\\n\\n```python\\n# Runtime: 4264 ms\\nclass Fenwick(object):\\n    def __init__(self, arr):\\n        self.arr = [0] + arr\\n        self.fen = self.arr[:]\\n        self.construct()\\n    \\n    def construct(self):\\n        for i in range(len(self.fen)):\\n            j = i + self.lsb(i)\\n            if j < len(self.fen):\\n                self.fen[j] += self.fen[i]\\n            \\n    def lsb(self, n):\\n        \\'\\'\\'return the least significant bit of n\\'\\'\\'\\n        return -n&n\\n    \\n    def presum(self, i):\\n        \\'\\'\\'return sum of array from 0:i\\'\\'\\'\\n        res = 0\\n        while i:\\n            res += self.fen[i]\\n            i -= self.lsb(i)\\n        return res\\n    \\n    def range_sum(self, i, j):\\n        \\'\\'\\'return sum of array from i: j inclusive\\'\\'\\'\\n        i, j = i+1, j+1\\n        return self.presum(j) - self.presum(i-1)\\n    \\n    def update(self, i, val):\\n        \\'\\'\\'change value at arr[i] to val ; i.e. arr[i] = 1 if server busy and arr[i] = 0 if free\\'\\'\\'\\n        i += 1\\n        diff = val - self.arr[i]\\n        self.arr[i] = val\\n        while i < len(self.fen):\\n            self.fen[i] += diff\\n            i += self.lsb(i)\\n    \\n    def free_server_in_range(self, i, j):\\n        \\'\\'\\'returns True if there is a free server in the range [i,j] inclusive\\'\\'\\'\\n        return self.range_sum(i-1, j-1) < (j - i + 1)\\n    \\n    def binary_search(self, low, high):\\n        \\'\\'\\'Finds the left-most server that is free in the range low, high inclusive\\'\\'\\'\\n        first_free = float(\\'inf\\')\\n        if self.free_server_in_range(low, high):\\n            while low <= high:\\n                j = (low + high) // 2\\n                if self.free_server_in_range(low, j):\\n                    first_free = min(j, first_free)\\n                    high = j - 1\\n                else:\\n                    low = j + 1\\n        return first_free\\n    \\n    def find_first_free_server(self, i):\\n        \\'\\'\\'Returns the index of the first free server to the right of server i (wrapping around to server 0 if needed)\\'\\'\\'\\n        first_free = self.binary_search(i, len(self.arr) - 1)\\n        return (first_free - 1) if (first_free != float(\\'inf\\')) else (self.binary_search(1, i-1) - 1)\\n\\n    \\nclass Solution:\\n    def busiestServers(self, k: int, arrival: List[int], load: List[int]) -> List[int]:\\n        \\n        if k >= len(arrival):          # If we have more servers than jobs then\\n            return range(len(arrival)) # the first n servers will all receive 1 job\\n        \\n        end = [a + c for a,c in zip(arrival, load)]                                  # end[i] is the time at which the (i)th job will finished\\n        requests_handled = collections.defaultdict(lambda: 1)                        # All servers get one job to start with\\n        t_naught = arrival[k]                                                        # Arrival time of the (k)th job\\n        free_servers = Fenwick([int(end[i] > t_naught) for i in range(k)])           # All servers that finish their job before t_naught are free\\n        not_in_use = set(i for i in range(k) if end[i] <= t_naught)                  # Set of servers that are free\\n        servers = [(arrival[i] + load[i], i) for i in range(k) if end[i] > t_naught] # active server heap (end_time, server_id)\\n        heapq.heapify(servers)\\n        \\n        for i in range(k, len(arrival)):\\n            t = arrival[i]\\n            e = end[i]\\n            i = i % k\\n            \\n            while servers and servers[0][0] <= t:  # Remove all servers that have completed their job from the server heap\\n                s = heapq.heappop(servers)[1]\\n                free_servers.update(s, 0)          # 0 means the server is now free\\n                not_in_use.add(s)\\n            \\n            if len(servers) < k - 1:\\n                target_server = free_servers.find_first_free_server(i+1) if free_servers.arr[i+1] else i\\n                not_in_use.remove(target_server)             # mark server as not free\\n                free_servers.update(target_server, 1)        # 1 means the server is now busy\\n                heapq.heappush(servers, (e, target_server))  # add server to server heap\\n                requests_handled[target_server] += 1         # Record that server handled 1 request\\n            elif len(servers) == k - 1:\\n                target_server = not_in_use.pop()             # There is only one server available to use\\n                free_servers.update(target_server, 1)        # mark server as busy\\n                heapq.heappush(servers, (e, target_server))  # add server to server heap\\n                requests_handled[target_server] += 1         # Record that server handled 1 request\\n                \\n        maxi = max(requests_handled.values())\\n        return (server for server in requests_handled if requests_handled[server] == maxi)\\n```\\n\\n</details>",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Tree",
                    "Heap (Priority Queue)"
                ],
                "code": "```python\\n#Runtime: TLE\\nclass Solution:\\n    def busiestServers(self, k: int, arrival: List[int], load: List[int]) -> List[int]:\\n        \\n        requests_handled = collections.defaultdict(int)\\n        servers = [] # server heap (end_time, server_id)\\n        free_servers = set(range(k))\\n        \\n        for i, (t, c) in enumerate(zip(arrival, load)):\\n            \\n            while servers and servers[0][0] <= t:\\n                free_servers.add(heapq.heappop(servers)[1])\\n            \\n            if free_servers:\\n                \\n                # find first free server\\n                target_server = i % k\\n                while target_server not in free_servers:\\n                    target_server = (target_server + 1) % k\\n                \\n                # mark the server as busy\\n                free_servers.remove(target_server)\\n                \\n                # add the server to the server heap\\n                heapq.heappush(servers, (t + c, target_server))\\n                requests_handled[target_server] += 1\\n        \\n        maxi = max(requests_handled.values())\\n        return [server for server in requests_handled if requests_handled[server] == maxi]\\n```\n```python\\n# Runtime: 4264 ms\\nclass Fenwick(object):\\n    def __init__(self, arr):\\n        self.arr = [0] + arr\\n        self.fen = self.arr[:]\\n        self.construct()\\n    \\n    def construct(self):\\n        for i in range(len(self.fen)):\\n            j = i + self.lsb(i)\\n            if j < len(self.fen):\\n                self.fen[j] += self.fen[i]\\n            \\n    def lsb(self, n):\\n        \\'\\'\\'return the least significant bit of n\\'\\'\\'\\n        return -n&n\\n    \\n    def presum(self, i):\\n        \\'\\'\\'return sum of array from 0:i\\'\\'\\'\\n        res = 0\\n        while i:\\n            res += self.fen[i]\\n            i -= self.lsb(i)\\n        return res\\n    \\n    def range_sum(self, i, j):\\n        \\'\\'\\'return sum of array from i: j inclusive\\'\\'\\'\\n        i, j = i+1, j+1\\n        return self.presum(j) - self.presum(i-1)\\n    \\n    def update(self, i, val):\\n        \\'\\'\\'change value at arr[i] to val ; i.e. arr[i] = 1 if server busy and arr[i] = 0 if free\\'\\'\\'\\n        i += 1\\n        diff = val - self.arr[i]\\n        self.arr[i] = val\\n        while i < len(self.fen):\\n            self.fen[i] += diff\\n            i += self.lsb(i)\\n    \\n    def free_server_in_range(self, i, j):\\n        \\'\\'\\'returns True if there is a free server in the range [i,j] inclusive\\'\\'\\'\\n        return self.range_sum(i-1, j-1) < (j - i + 1)\\n    \\n    def binary_search(self, low, high):\\n        \\'\\'\\'Finds the left-most server that is free in the range low, high inclusive\\'\\'\\'\\n        first_free = float(\\'inf\\')\\n        if self.free_server_in_range(low, high):\\n            while low <= high:\\n                j = (low + high) // 2\\n                if self.free_server_in_range(low, j):\\n                    first_free = min(j, first_free)\\n                    high = j - 1\\n                else:\\n                    low = j + 1\\n        return first_free\\n    \\n    def find_first_free_server(self, i):\\n        \\'\\'\\'Returns the index of the first free server to the right of server i (wrapping around to server 0 if needed)\\'\\'\\'\\n        first_free = self.binary_search(i, len(self.arr) - 1)\\n        return (first_free - 1) if (first_free != float(\\'inf\\')) else (self.binary_search(1, i-1) - 1)\\n\\n    \\nclass Solution:\\n    def busiestServers(self, k: int, arrival: List[int], load: List[int]) -> List[int]:\\n        \\n        if k >= len(arrival):          # If we have more servers than jobs then\\n            return range(len(arrival)) # the first n servers will all receive 1 job\\n        \\n        end = [a + c for a,c in zip(arrival, load)]                                  # end[i] is the time at which the (i)th job will finished\\n        requests_handled = collections.defaultdict(lambda: 1)                        # All servers get one job to start with\\n        t_naught = arrival[k]                                                        # Arrival time of the (k)th job\\n        free_servers = Fenwick([int(end[i] > t_naught) for i in range(k)])           # All servers that finish their job before t_naught are free\\n        not_in_use = set(i for i in range(k) if end[i] <= t_naught)                  # Set of servers that are free\\n        servers = [(arrival[i] + load[i], i) for i in range(k) if end[i] > t_naught] # active server heap (end_time, server_id)\\n        heapq.heapify(servers)\\n        \\n        for i in range(k, len(arrival)):\\n            t = arrival[i]\\n            e = end[i]\\n            i = i % k\\n            \\n            while servers and servers[0][0] <= t:  # Remove all servers that have completed their job from the server heap\\n                s = heapq.heappop(servers)[1]\\n                free_servers.update(s, 0)          # 0 means the server is now free\\n                not_in_use.add(s)\\n            \\n            if len(servers) < k - 1:\\n                target_server = free_servers.find_first_free_server(i+1) if free_servers.arr[i+1] else i\\n                not_in_use.remove(target_server)             # mark server as not free\\n                free_servers.update(target_server, 1)        # 1 means the server is now busy\\n                heapq.heappush(servers, (e, target_server))  # add server to server heap\\n                requests_handled[target_server] += 1         # Record that server handled 1 request\\n            elif len(servers) == k - 1:\\n                target_server = not_in_use.pop()             # There is only one server available to use\\n                free_servers.update(target_server, 1)        # mark server as busy\\n                heapq.heappush(servers, (e, target_server))  # add server to server heap\\n                requests_handled[target_server] += 1         # Record that server handled 1 request\\n                \\n        maxi = max(requests_handled.values())\\n        return (server for server in requests_handled if requests_handled[server] == maxi)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3171163,
                "title": "python3-fast-solution-with-mathematical-derivation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nwe need to sort server_id in range: [i, i+k)\\nso we have:\\ni <= server_id + m*k < i+k\\n-> server_id + m*k = i + x  where x in range[0, k)\\n-> server_id % k + 0 = i % k + x\\n-> x = server_id % k - i % k\\nthat means we can use id = i + x = i + (server_id - i) % k  as key of the heap\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport heapq\\n\\nclass Solution:\\n    def busiestServers(self, k: int, arrival: List[int], load: List[int]) -> List[int]:\\n\\n        available_servers = list(range(k))\\n        busy_servers = []\\n        cnt = [0] * k\\n\\n        for i in range(len(arrival)):\\n            start, duration = arrival[i], load[i]\\n            while busy_servers and busy_servers[0][0] <= start:\\n                _, server = heapq.heappop(busy_servers)\\n                heapq.heappush(available_servers, i + (server - i) % k)\\n            if available_servers:\\n                server = heapq.heappop(available_servers) % k\\n                cnt[server] += 1\\n                heapq.heappush(busy_servers, (start + duration, server))\\n\\n        mx = max(cnt)\\n        return [i for i in range(len(cnt)) if cnt[i] == mx]\\n        \\n        \\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nimport heapq\\n\\nclass Solution:\\n    def busiestServers(self, k: int, arrival: List[int], load: List[int]) -> List[int]:\\n\\n        available_servers = list(range(k))\\n        busy_servers = []\\n        cnt = [0] * k\\n\\n        for i in range(len(arrival)):\\n            start, duration = arrival[i], load[i]\\n            while busy_servers and busy_servers[0][0] <= start:\\n                _, server = heapq.heappop(busy_servers)\\n                heapq.heappush(available_servers, i + (server - i) % k)\\n            if available_servers:\\n                server = heapq.heappop(available_servers) % k\\n                cnt[server] += 1\\n                heapq.heappush(busy_servers, (start + duration, server))\\n\\n        mx = max(cnt)\\n        return [i for i in range(len(cnt)) if cnt[i] == mx]\\n        \\n        \\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2346411,
                "title": "python-super-readable-solution-sortedlist-heap",
                "content": "#### The basic approach to this question is:\\n* iterate arrival and load values\\n\\t* Identify all available servers\\n\\t* Find the next available server and increase its handle count\\n\\t* Mark it is busy\\n\\n* return all servers that reached the same request handled count\\n\\n#### The main problem here is find an efficient method to:\\n* Know at any time which servers are available and which are busy\\n\\t* My implementation here is inspired by the question [Meetings Rooms II](https://leetcode.com/problems/meeting-rooms-ii/). We can use a min heap holding the end time of each meeting (busy time in our case) to know which servers are **busy** and when they are going to be **available again**.\\n* Find the **correct** next available server\\n\\t* In order to comply with the defined routing algorithm in the question, I keep a sorted list of the avaiable servers indices.\\tThis gives me the ability to do a binary search (O(logk)) in order to find the next available server\\n\\t\\n\\n\\n\\n\\n```\\nimport heapq\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n    def busiestServers(self, k: int, arrival: List[int], load: List[int]) -> List[int]:\\n        # map server to its handle count\\n        server_busy_count = [0] * k\\n        \\n        # init heap\\n        busy_servers_heap = []\\n        \\n        # init available servers sortedlist -> klogk\\n        available_servers = SortedList([idx for idx in range(k)])\\n        \\n        # iterate arrivals\\n        for req_idx, (curr_arrival, curr_load) in enumerate(zip(arrival, load)):\\n            # pop all available servers from heap\\n            while busy_servers_heap and curr_arrival >= busy_servers_heap[0][0]:\\n                _, server_idx = heapq.heappop(busy_servers_heap)\\n    \\n                # add servers to available sorted list\\n                available_servers.add(server_idx)\\n            \\n            # all servers are busy -> drop request\\n            if not available_servers: continue\\n            \\n            # binary search on available list to find the correct available server\\n            desired_server_idx = req_idx % k\\n            next_idx = available_servers.bisect_left(desired_server_idx)\\n            \\n            # no bigger idx found, use the first available server\\n            if next_idx == len(available_servers):\\n                next_idx = 0\\n            \\n            # select server by the next_idx calculated\\n            selected_server = available_servers[next_idx]\\n            \\n            # increase selected server handle count\\n            server_busy_count[selected_server] += 1\\n            \\n            # add selected server with end time to the heap\\n            heapq.heappush(busy_servers_heap, (curr_arrival + curr_load, selected_server))\\n            \\n            # pop selected servers from the available list\\n            available_servers.remove(selected_server)\\n            \\n        # return all servers the handled the max request count\\n        max_busy = max(server_busy_count)\\n        return [idx for idx in range(k) if server_busy_count[idx] == max_busy]           \\n```\\n\\n\\n#### Please upvote if you find this solution helpful, so it could help others as well :)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Heap (Priority Queue)",
                    "Binary Tree"
                ],
                "code": "```\\nimport heapq\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n    def busiestServers(self, k: int, arrival: List[int], load: List[int]) -> List[int]:\\n        # map server to its handle count\\n        server_busy_count = [0] * k\\n        \\n        # init heap\\n        busy_servers_heap = []\\n        \\n        # init available servers sortedlist -> klogk\\n        available_servers = SortedList([idx for idx in range(k)])\\n        \\n        # iterate arrivals\\n        for req_idx, (curr_arrival, curr_load) in enumerate(zip(arrival, load)):\\n            # pop all available servers from heap\\n            while busy_servers_heap and curr_arrival >= busy_servers_heap[0][0]:\\n                _, server_idx = heapq.heappop(busy_servers_heap)\\n    \\n                # add servers to available sorted list\\n                available_servers.add(server_idx)\\n            \\n            # all servers are busy -> drop request\\n            if not available_servers: continue\\n            \\n            # binary search on available list to find the correct available server\\n            desired_server_idx = req_idx % k\\n            next_idx = available_servers.bisect_left(desired_server_idx)\\n            \\n            # no bigger idx found, use the first available server\\n            if next_idx == len(available_servers):\\n                next_idx = 0\\n            \\n            # select server by the next_idx calculated\\n            selected_server = available_servers[next_idx]\\n            \\n            # increase selected server handle count\\n            server_busy_count[selected_server] += 1\\n            \\n            # add selected server with end time to the heap\\n            heapq.heappush(busy_servers_heap, (curr_arrival + curr_load, selected_server))\\n            \\n            # pop selected servers from the available list\\n            available_servers.remove(selected_server)\\n            \\n        # return all servers the handled the max request count\\n        max_busy = max(server_busy_count)\\n        return [idx for idx in range(k) if server_busy_count[idx] == max_busy]           \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1980482,
                "title": "java-elegant-and-concise-using-priorityqueue-and-treeset",
                "content": "```\\nclass Solution {\\n    public List<Integer> busiestServers(int k, int[] arrival, int[] load) {\\n        \\n        TreeSet<Integer> avalServers = new TreeSet<>();\\n        for(int i=0; i<k; i++){\\n            avalServers.add(i);\\n        }\\n        \\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[0] == b[0] ? a[1] - b[1] : a[0] - b[0]); // [Ending Times, Server]\\n        int[] count = new int[k]; // To count the number of requests handled by each server\\n        for(int i=0; i<arrival.length; i++){\\n            // Free the servers who have serviced the request\\n            while(!pq.isEmpty() && pq.peek()[0] <= arrival[i]){\\n                avalServers.add(pq.poll()[1]);\\n            }\\n            \\n            // Find the available server  for the current request \\n            if(avalServers.size() == 0) continue; // Request Dropped\\n            \\n            int serverReq = i%k;\\n            Integer nextServ = avalServers.ceiling(serverReq);\\n            if(nextServ != null){\\n                avalServers.remove(nextServ);\\n            }else{\\n                // Find the smallest numbered server\\n                nextServ = avalServers.first();\\n                avalServers.remove(nextServ);\\n            }\\n            \\n            pq.offer(new int[]{arrival[i] + load[i], nextServ});\\n            count[nextServ]++; \\n        }\\n        \\n        int max = -1;\\n        List<Integer> ans = null;\\n        for(int i=0; i<k; i++){\\n            if(count[i] > max){\\n                ans = new ArrayList<>();\\n                max = count[i];\\n                ans.add(i);\\n            }else if(count[i] == max){\\n                ans.add(i);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> busiestServers(int k, int[] arrival, int[] load) {\\n        \\n        TreeSet<Integer> avalServers = new TreeSet<>();\\n        for(int i=0; i<k; i++){\\n            avalServers.add(i);\\n        }\\n        \\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[0] == b[0] ? a[1] - b[1] : a[0] - b[0]); // [Ending Times, Server]\\n        int[] count = new int[k]; // To count the number of requests handled by each server\\n        for(int i=0; i<arrival.length; i++){\\n            // Free the servers who have serviced the request\\n            while(!pq.isEmpty() && pq.peek()[0] <= arrival[i]){\\n                avalServers.add(pq.poll()[1]);\\n            }\\n            \\n            // Find the available server  for the current request \\n            if(avalServers.size() == 0) continue; // Request Dropped\\n            \\n            int serverReq = i%k;\\n            Integer nextServ = avalServers.ceiling(serverReq);\\n            if(nextServ != null){\\n                avalServers.remove(nextServ);\\n            }else{\\n                // Find the smallest numbered server\\n                nextServ = avalServers.first();\\n                avalServers.remove(nextServ);\\n            }\\n            \\n            pq.offer(new int[]{arrival[i] + load[i], nextServ});\\n            count[nextServ]++; \\n        }\\n        \\n        int max = -1;\\n        List<Integer> ans = null;\\n        for(int i=0; i<k; i++){\\n            if(count[i] > max){\\n                ans = new ArrayList<>();\\n                max = count[i];\\n                ans.add(i);\\n            }else if(count[i] == max){\\n                ans.add(i);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1957427,
                "title": "c-priority-queue-set-beat-77",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n        int n = (int)arrival.size();\\n        \\n        set<int> freeServers;\\n        for (int i = 0; i < k; i++) freeServers.insert(i);\\n        \\n        vector<int> serverTaskCount(k, 0);\\n        \\n        set<pair<int, int>> workingServers;     // [end time, server index]\\n        for (int i = 0; i < n; i++) {\\n            int startTime = arrival[i];\\n            \\n            while (!workingServers.empty() && workingServers.begin()->first <= startTime) {\\n                auto s = *workingServers.begin();\\n                workingServers.erase(workingServers.begin());\\n                freeServers.insert(s.second);\\n            }\\n            \\n            if (freeServers.empty()) continue;\\n            \\n            int serverIndex = -1;\\n            auto it = freeServers.lower_bound(i % k);\\n            if (it == freeServers.end()) {\\n                serverIndex = *freeServers.begin();\\n                freeServers.erase(freeServers.begin());\\n            } else {\\n                serverIndex = *it;\\n                freeServers.erase(it);\\n            }\\n            \\n            workingServers.insert({startTime + load[i], serverIndex});\\n            \\n            serverTaskCount[serverIndex]++;\\n            //printf(\"Task %d (%d, %d) assigned to server %d\\\\n\", i, startTime, load[i], serverIndex);\\n        }\\n        // for (auto x : serverTaskCount) cout << x << \" \";\\n        // cout << endl;\\n        \\n        vector<int> ret;\\n        int maxVal = *max_element(serverTaskCount.begin(), serverTaskCount.end());\\n        for (int i = 0; i < k; i++) \\n            if (maxVal == serverTaskCount[i]) ret.push_back(i);\\n        \\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n        int n = (int)arrival.size();\\n        \\n        set<int> freeServers;\\n        for (int i = 0; i < k; i++) freeServers.insert(i);\\n        \\n        vector<int> serverTaskCount(k, 0);\\n        \\n        set<pair<int, int>> workingServers;     // [end time, server index]\\n        for (int i = 0; i < n; i++) {\\n            int startTime = arrival[i];\\n            \\n            while (!workingServers.empty() && workingServers.begin()->first <= startTime) {\\n                auto s = *workingServers.begin();\\n                workingServers.erase(workingServers.begin());\\n                freeServers.insert(s.second);\\n            }\\n            \\n            if (freeServers.empty()) continue;\\n            \\n            int serverIndex = -1;\\n            auto it = freeServers.lower_bound(i % k);\\n            if (it == freeServers.end()) {\\n                serverIndex = *freeServers.begin();\\n                freeServers.erase(freeServers.begin());\\n            } else {\\n                serverIndex = *it;\\n                freeServers.erase(it);\\n            }\\n            \\n            workingServers.insert({startTime + load[i], serverIndex});\\n            \\n            serverTaskCount[serverIndex]++;\\n            //printf(\"Task %d (%d, %d) assigned to server %d\\\\n\", i, startTime, load[i], serverIndex);\\n        }\\n        // for (auto x : serverTaskCount) cout << x << \" \";\\n        // cout << endl;\\n        \\n        vector<int> ret;\\n        int maxVal = *max_element(serverTaskCount.begin(), serverTaskCount.end());\\n        for (int i = 0; i < k; i++) \\n            if (maxVal == serverTaskCount[i]) ret.push_back(i);\\n        \\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1277420,
                "title": "segment-tree-based-solution-beats-88-solutions-in-time-and-96-solutions-in-memory",
                "content": "```\\n#define MAXN 100001\\nclass Solution {\\npublic:\\n    int seg[4*MAXN];\\n    void update(int ind,int l,int r,int i,int x)\\n    {\\n        if(ind>r||ind<l||l>r) return ;\\n        if(l==r)\\n        {\\n            if(l==ind)\\n                seg[i]=x;\\n            return ;\\n        }\\n        int mid=(l+r)/2;\\n        update(ind,l,mid,2*i+1,x);\\n        update(ind,mid+1,r,2*i+2,x);\\n        seg[i]=min(seg[2*i+1],seg[2*i+2]);\\n    }\\n    int query(int st,int en,int l,int r,int i,int x)\\n    {\\n        //cout<<l<<\" \"<<r<<\"\\\\n\";\\n        if(st>en||l>en||r<st||seg[i]>x)\\n            return -1;\\n        if(l==r) \\n            return l;\\n        int mid=(l+r)/2;\\n        int lf=query(st,en,l,mid,2*i+1,x);\\n        if(lf!=-1)\\n            return lf;\\n        int rf=query(st,en,mid+1,r,2*i+2,x);\\n        return rf;\\n    }\\n    int que(int st,int en,int l,int r,int i,int x)\\n    {\\n        if(st>en||l>en||r<st||seg[i]>x)\\n            return -1;\\n        if(l==r) \\n            return l;\\n        int mid=(l+r)/2;\\n        int rf=que(st,en,mid+1,r,2*i+1,x);\\n        if(rf!=-1)\\n            return rf;\\n        int lf=que(st,en,l,mid,2*i+2,x);\\n        return lf;\\n    }\\n    vector<int> busiestServers(int k, vector<int>& arr, vector<int>& lo) {\\n        int i,j,n=arr.size();\\n        j=-1;\\n        vector<int> b(n,0),ans;\\n        map<int,int> m;\\n        for(i=0;i<n;i++)\\n        {\\n            int x=query(i%k,k-1,0,k-1,0,arr[i]);\\n            if(x!=-1)\\n            {\\n                //cout<<1<<\" \"<<x<<\" \"<<i<<\"\\\\n\";\\n                m[x]++;\\n                b[x]=arr[i]+lo[i];\\n                update(x,0,k-1,0,b[x]);\\n                continue;\\n            }\\n            int y=query(0,i%k-1,0,k-1,0,arr[i]);\\n            if(y!=-1)\\n            {\\n                //cout<<2<<\" \"<<y<<\" \"<<i<<\"\\\\n\";\\n                m[y]++;\\n                b[y]=arr[i]+lo[i];\\n                update(y,0,k-1,0,b[y]);\\n            }\\n        }\\n        int maxi=0;\\n        for(auto e:m)\\n            maxi=max(maxi,e.second);\\n        // for(auto e:m)\\n        // cout<<e.first<<\" \"<<e.second<<\"\\\\n\";\\n        for(auto e:m)\\n        {\\n            if(e.second==maxi)\\n                ans.push_back(e.first);\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "Tree",
                    "Binary Tree"
                ],
                "code": "class Solution {\\npublic:\\n    int seg[4*MAXN];\\n    void update(int ind,int l,int r,int i,int x)\\n    {\\n        if(ind>r||ind<l||l>r) return ;\\n        if(l==r)\\n        {\\n            if(l==ind)\\n                seg[i]=x;\\n            return ;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 942408,
                "title": "rust-binary-heap-and-btreeset",
                "content": "I use a BTreeSet to keep track of the  of the available servers and and a priority queue to keep track of the assigned requests. \\n\\n```\\nuse std::cmp::Reverse;\\nuse std::collections::BinaryHeap;\\nuse std::collections::BTreeSet;\\n\\nimpl Solution {\\n    pub fn busiest_servers(k: i32, arrival: Vec<i32>, load: Vec<i32>) -> Vec<i32> {\\n        let k = k as usize;\\n        let mut servers = BTreeSet::new();\\n        for i in 0..k {\\n            servers.insert(i);\\n        }\\n        \\n        let mut activeRequests: BinaryHeap<Reverse<(i32, usize)>> = BinaryHeap::new();\\n        let mut iterator = arrival.iter().zip(load.iter()).peekable();\\n        let mut requests = vec![0; k];\\n        let mut i = 0;\\n        \\n        while let Some((&t2, &l)) = iterator.peek() {\\n            if activeRequests.peek().is_none() || (activeRequests.peek().unwrap().0).0 > t2 {\\n                let (time, load) = iterator.next().unwrap();\\n                \\n                if servers.len() > 0 {\\n                    let s = if let Some(server) = servers.range(i..).next() {\\n                        *server\\n                    } else {\\n                        *servers.range(..).next().unwrap()\\n                    };\\n                    servers.remove(&s);\\n                    requests[s] += 1;\\n                    activeRequests.push(Reverse((time+load, s)));\\n                }\\n                i += 1;\\n                i %= k;\\n            } else {\\n                let Reverse((_, server)) = activeRequests.pop().unwrap();\\n                servers.insert(server);\\n            }\\n        }\\n\\n        let maxR = *requests.iter().max().unwrap();\\n        requests.iter().enumerate().filter(|x| *x.1 == maxR).map(|x|x.0 as i32).collect()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::cmp::Reverse;\\nuse std::collections::BinaryHeap;\\nuse std::collections::BTreeSet;\\n\\nimpl Solution {\\n    pub fn busiest_servers(k: i32, arrival: Vec<i32>, load: Vec<i32>) -> Vec<i32> {\\n        let k = k as usize;\\n        let mut servers = BTreeSet::new();\\n        for i in 0..k {\\n            servers.insert(i);\\n        }\\n        \\n        let mut activeRequests: BinaryHeap<Reverse<(i32, usize)>> = BinaryHeap::new();\\n        let mut iterator = arrival.iter().zip(load.iter()).peekable();\\n        let mut requests = vec![0; k];\\n        let mut i = 0;\\n        \\n        while let Some((&t2, &l)) = iterator.peek() {\\n            if activeRequests.peek().is_none() || (activeRequests.peek().unwrap().0).0 > t2 {\\n                let (time, load) = iterator.next().unwrap();\\n                \\n                if servers.len() > 0 {\\n                    let s = if let Some(server) = servers.range(i..).next() {\\n                        *server\\n                    } else {\\n                        *servers.range(..).next().unwrap()\\n                    };\\n                    servers.remove(&s);\\n                    requests[s] += 1;\\n                    activeRequests.push(Reverse((time+load, s)));\\n                }\\n                i += 1;\\n                i %= k;\\n            } else {\\n                let Reverse((_, server)) = activeRequests.pop().unwrap();\\n                servers.insert(server);\\n            }\\n        }\\n\\n        let maxR = *requests.iter().max().unwrap();\\n        requests.iter().enumerate().filter(|x| *x.1 == maxR).map(|x|x.0 as i32).collect()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 881649,
                "title": "line-sweep",
                "content": "```\\nclass Solution {\\n    public List<Integer> busiestServers(int k, int[] arrival, int[] load) {\\n        int[] counts = new int[k];\\n        int[] eventToServer = new int[arrival.length];\\n        TreeSet<Integer> freeServers = new TreeSet<>();\\n        for(int i = 0; i<k; i++){\\n            freeServers.add(i);\\n        }\\n        \\n        Set<Integer> eventsDropped = new HashSet<>();\\n        \\n        int[][] events = new int[arrival.length*2][];//[time, eventID, start/end:0/1]\\n        \\n        for(int i = 0; i<arrival.length; i++){\\n            int start = arrival[i];\\n            int end = start + load[i];\\n            events[i] = new int[]{start, i, 0};\\n            events[i+arrival.length] = new int[]{end, i, 1};\\n        }\\n        \\n        Arrays.sort(events, (i,j)->{\\n            if(i[0]-j[0]!=0){\\n                return i[0]-j[0];\\n            }\\n            if(i[2]==0 && j[2]==1){\\n                return 1;\\n            }else if(i[2]==1 && j[2]==0){\\n                return -1;\\n            }\\n            return i[1]-j[1];\\n        });\\n        \\n        for(int i = 0; i<(arrival.length*2); i++){\\n            int[] event = events[i];\\n            int serverID = event[1]%k;\\n            \\n            if(event[2]==0){\\n                if(freeServers.size()>0){\\n                    Integer actualServerID = freeServers.ceiling(serverID);\\n                    if(actualServerID==null){\\n                        serverID=-1;\\n                        actualServerID = freeServers.ceiling(serverID);\\n                    }\\n                    counts[actualServerID]++;\\n                    freeServers.remove(actualServerID);\\n                    eventToServer[event[1]] = actualServerID;\\n                }else{\\n                    eventsDropped.add(event[1]);\\n                }\\n            }else{\\n                if(!eventsDropped.contains(event[1])){\\n                    freeServers.add(eventToServer[event[1]]);\\n                }\\n            }\\n        }\\n        \\n        \\n        \\n        List<Integer> result = new ArrayList<>();\\n        int max = 0;\\n        \\n        for(int i = 0; i<k; i++){\\n            if(max<counts[i]){\\n                result.clear();\\n                max = counts[i];\\n                result.add(i);\\n            }else if(max==counts[i]){\\n                result.add(i);\\n            }\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> busiestServers(int k, int[] arrival, int[] load) {\\n        int[] counts = new int[k];\\n        int[] eventToServer = new int[arrival.length];\\n        TreeSet<Integer> freeServers = new TreeSet<>();\\n        for(int i = 0; i<k; i++){\\n            freeServers.add(i);\\n        }\\n        \\n        Set<Integer> eventsDropped = new HashSet<>();\\n        \\n        int[][] events = new int[arrival.length*2][];//[time, eventID, start/end:0/1]\\n        \\n        for(int i = 0; i<arrival.length; i++){\\n            int start = arrival[i];\\n            int end = start + load[i];\\n            events[i] = new int[]{start, i, 0};\\n            events[i+arrival.length] = new int[]{end, i, 1};\\n        }\\n        \\n        Arrays.sort(events, (i,j)->{\\n            if(i[0]-j[0]!=0){\\n                return i[0]-j[0];\\n            }\\n            if(i[2]==0 && j[2]==1){\\n                return 1;\\n            }else if(i[2]==1 && j[2]==0){\\n                return -1;\\n            }\\n            return i[1]-j[1];\\n        });\\n        \\n        for(int i = 0; i<(arrival.length*2); i++){\\n            int[] event = events[i];\\n            int serverID = event[1]%k;\\n            \\n            if(event[2]==0){\\n                if(freeServers.size()>0){\\n                    Integer actualServerID = freeServers.ceiling(serverID);\\n                    if(actualServerID==null){\\n                        serverID=-1;\\n                        actualServerID = freeServers.ceiling(serverID);\\n                    }\\n                    counts[actualServerID]++;\\n                    freeServers.remove(actualServerID);\\n                    eventToServer[event[1]] = actualServerID;\\n                }else{\\n                    eventsDropped.add(event[1]);\\n                }\\n            }else{\\n                if(!eventsDropped.contains(event[1])){\\n                    freeServers.add(eventToServer[event[1]]);\\n                }\\n            }\\n        }\\n        \\n        \\n        \\n        List<Integer> result = new ArrayList<>();\\n        int max = 0;\\n        \\n        for(int i = 0; i<k; i++){\\n            if(max<counts[i]){\\n                result.clear();\\n                max = counts[i];\\n                result.add(i);\\n            }else if(max==counts[i]){\\n                result.add(i);\\n            }\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 877305,
                "title": "golang-solutions-using-three-heaps-with-runnable-tests",
                "content": "Idea is based on the following Python solution: https://leetcode.com/problems/find-servers-that-handled-most-number-of-requests/discuss/876883/Python-using-only-heaps\\n\\nRunnable tests on playground: https://play.golang.org/p/KmXY1RIWA5z\\n\\n```go\\nfunc busiestServers(k int, arrival []int, load []int) []int {\\n\\t// min heaps of items, sorted by \"priority\" value:\\n\\t//  - jobs heap    - will store requests that are being processed right now\\n\\t//  - serversBef   - will store ordered list of servers with server number less than one we need\\n\\t//  - serversAfter - will store ordered list of servers with server number equal or greater\\n\\tvar jobs, serversBef, serversAfter PriorityQueue\\n\\tvar reqs = make([]int, k) // to store number of handled requests\\n\\n\\t// populate initial list of available servers\\n\\tfor i := 0; i < k; i++ {\\n\\t\\tvar node = &Item{\\n\\t\\t\\tnum:      i,\\n\\t\\t\\tpriority: i,\\n\\t\\t\\tindex:    i,\\n\\t\\t}\\n\\n\\t\\tserversBef = append(serversBef, node)\\n\\t}\\n\\theap.Init(&serversBef)\\n\\n\\tfor i := range arrival {\\n\\t\\tsec := arrival[i]\\n\\t\\tload := load[i]\\n\\t\\tnum := i % k\\n\\t\\t// fmt.Println(sec, \"Looking for server\", num)\\n\\n\\t\\t// if we need first server, than swap\\n\\t\\t// \"before\" and \"after\" heaps, because all\\n\\t\\t// servers should become \"after\" at this point\\n\\t\\tif num == 0 {\\n\\t\\t\\tserversAfter = serversBef\\n\\t\\t\\tserversBef = PriorityQueue{}\\n\\t\\t}\\n\\n\\t\\t// check if some jobs completed, so we can\\n\\t\\t// count server as available\\n\\t\\tfor jobs.Len() > 0 {\\n\\t\\t\\t// since jobs are prioritized (sorted) by\\n\\t\\t\\t// time, it is enough to keep popping jobs\\n\\t\\t\\t// from the queue and check if time it\\'s time\\n\\t\\t\\tjob := heap.Pop(&jobs).(*Item)\\n\\t\\t\\tif job.priority > sec {\\n\\t\\t\\t\\t// if job\\'s time hasn\\'t passed yet\\n\\t\\t\\t\\t// put it back to the list, and stop checking\\n\\t\\t\\t\\theap.Push(&jobs, job)\\n\\t\\t\\t\\tbreak\\n\\t\\t\\t}\\n\\n\\t\\t\\t// now we know that this server become available\\n\\t\\t\\tnode := &Item{num: job.num, priority: job.num}\\n\\t\\t\\t// put it in the proper queue of nodes (sorted by server num)\\n\\t\\t\\tif job.num < num {\\n\\t\\t\\t\\theap.Push(&serversBef, node)\\n\\t\\t\\t} else {\\n\\t\\t\\t\\theap.Push(&serversAfter, node)\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tvar node *Item\\n\\t\\t// check if any server with number equal or\\n\\t\\t// greater to our is available, if it is\\n\\t\\t// pop the smallest one, if not\\n\\t\\t// pop from the \"before\" queue\\n\\t\\tif serversAfter.Len() > 0 {\\n\\t\\t\\tnode = heap.Pop(&serversAfter).(*Item)\\n\\t\\t} else if serversBef.Len() > 0 {\\n\\t\\t\\tnode = heap.Pop(&serversBef).(*Item)\\n\\t\\t} else {\\n\\t\\t\\t// if both queues are empty, this means\\n\\t\\t\\t// that all servers are busy at the moment\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\n\\t\\t// add job processed by this node to the\\n\\t\\t// jobs queue\\n\\t\\tjob := &Item{\\n\\t\\t\\tnum:      node.num,\\n\\t\\t\\tpriority: sec + load,\\n\\t\\t}\\n\\t\\theap.Push(&jobs, job)\\n\\t\\t// and increase processes requests count\\n\\t\\treqs[node.num]++\\n\\t}\\n\\n\\t// now find the busiest servers\\n\\tvar mr = map[int][]int{}\\n\\tvar max = 0\\n\\tfor i, r := range reqs {\\n\\t\\tif r > max {\\n\\t\\t\\tmax = r\\n\\t\\t}\\n\\t\\tmr[r] = append(mr[r], i)\\n\\t}\\n\\n\\treturn mr[max]\\n}\\n\\n// PQ implementation:\\n\\n// https://golang.org/src/container/heap/example_pq_test.go\\n// An Item is something we manage in a priority queue.\\ntype Item struct {\\n\\tnum      int\\n\\tpriority int\\n\\tindex    int\\n}\\n\\n// A PriorityQueue implements heap.Interface and holds Items.\\ntype PriorityQueue []*Item\\n\\nfunc (pq PriorityQueue) Len() int { return len(pq) }\\n\\nfunc (pq PriorityQueue) Less(i, j int) bool {\\n\\tif pq[i].priority == pq[j].priority {\\n\\t\\treturn pq[i].num < pq[j].num\\n\\t}\\n\\treturn pq[i].priority < pq[j].priority\\n}\\n\\nfunc (pq PriorityQueue) Swap(i, j int) {\\n\\tpq[i], pq[j] = pq[j], pq[i]\\n\\tpq[i].index = i\\n\\tpq[j].index = j\\n}\\n\\nfunc (pq *PriorityQueue) Push(x interface{}) {\\n\\tn := len(*pq)\\n\\titem := x.(*Item)\\n\\titem.index = n\\n\\t*pq = append(*pq, item)\\n}\\n\\nfunc (pq *PriorityQueue) Pop() interface{} {\\n\\told := *pq\\n\\tn := len(old)\\n\\titem := old[n-1]\\n\\told[n-1] = nil  // avoid memory leak\\n\\titem.index = -1 // for safety\\n\\t*pq = old[0 : n-1]\\n\\treturn item\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc busiestServers(k int, arrival []int, load []int) []int {\\n\\t// min heaps of items, sorted by \"priority\" value:\\n\\t//  - jobs heap    - will store requests that are being processed right now\\n\\t//  - serversBef   - will store ordered list of servers with server number less than one we need\\n\\t//  - serversAfter - will store ordered list of servers with server number equal or greater\\n\\tvar jobs, serversBef, serversAfter PriorityQueue\\n\\tvar reqs = make([]int, k) // to store number of handled requests\\n\\n\\t// populate initial list of available servers\\n\\tfor i := 0; i < k; i++ {\\n\\t\\tvar node = &Item{\\n\\t\\t\\tnum:      i,\\n\\t\\t\\tpriority: i,\\n\\t\\t\\tindex:    i,\\n\\t\\t}\\n\\n\\t\\tserversBef = append(serversBef, node)\\n\\t}\\n\\theap.Init(&serversBef)\\n\\n\\tfor i := range arrival {\\n\\t\\tsec := arrival[i]\\n\\t\\tload := load[i]\\n\\t\\tnum := i % k\\n\\t\\t// fmt.Println(sec, \"Looking for server\", num)\\n\\n\\t\\t// if we need first server, than swap\\n\\t\\t// \"before\" and \"after\" heaps, because all\\n\\t\\t// servers should become \"after\" at this point\\n\\t\\tif num == 0 {\\n\\t\\t\\tserversAfter = serversBef\\n\\t\\t\\tserversBef = PriorityQueue{}\\n\\t\\t}\\n\\n\\t\\t// check if some jobs completed, so we can\\n\\t\\t// count server as available\\n\\t\\tfor jobs.Len() > 0 {\\n\\t\\t\\t// since jobs are prioritized (sorted) by\\n\\t\\t\\t// time, it is enough to keep popping jobs\\n\\t\\t\\t// from the queue and check if time it\\'s time\\n\\t\\t\\tjob := heap.Pop(&jobs).(*Item)\\n\\t\\t\\tif job.priority > sec {\\n\\t\\t\\t\\t// if job\\'s time hasn\\'t passed yet\\n\\t\\t\\t\\t// put it back to the list, and stop checking\\n\\t\\t\\t\\theap.Push(&jobs, job)\\n\\t\\t\\t\\tbreak\\n\\t\\t\\t}\\n\\n\\t\\t\\t// now we know that this server become available\\n\\t\\t\\tnode := &Item{num: job.num, priority: job.num}\\n\\t\\t\\t// put it in the proper queue of nodes (sorted by server num)\\n\\t\\t\\tif job.num < num {\\n\\t\\t\\t\\theap.Push(&serversBef, node)\\n\\t\\t\\t} else {\\n\\t\\t\\t\\theap.Push(&serversAfter, node)\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tvar node *Item\\n\\t\\t// check if any server with number equal or\\n\\t\\t// greater to our is available, if it is\\n\\t\\t// pop the smallest one, if not\\n\\t\\t// pop from the \"before\" queue\\n\\t\\tif serversAfter.Len() > 0 {\\n\\t\\t\\tnode = heap.Pop(&serversAfter).(*Item)\\n\\t\\t} else if serversBef.Len() > 0 {\\n\\t\\t\\tnode = heap.Pop(&serversBef).(*Item)\\n\\t\\t} else {\\n\\t\\t\\t// if both queues are empty, this means\\n\\t\\t\\t// that all servers are busy at the moment\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\n\\t\\t// add job processed by this node to the\\n\\t\\t// jobs queue\\n\\t\\tjob := &Item{\\n\\t\\t\\tnum:      node.num,\\n\\t\\t\\tpriority: sec + load,\\n\\t\\t}\\n\\t\\theap.Push(&jobs, job)\\n\\t\\t// and increase processes requests count\\n\\t\\treqs[node.num]++\\n\\t}\\n\\n\\t// now find the busiest servers\\n\\tvar mr = map[int][]int{}\\n\\tvar max = 0\\n\\tfor i, r := range reqs {\\n\\t\\tif r > max {\\n\\t\\t\\tmax = r\\n\\t\\t}\\n\\t\\tmr[r] = append(mr[r], i)\\n\\t}\\n\\n\\treturn mr[max]\\n}\\n\\n// PQ implementation:\\n\\n// https://golang.org/src/container/heap/example_pq_test.go\\n// An Item is something we manage in a priority queue.\\ntype Item struct {\\n\\tnum      int\\n\\tpriority int\\n\\tindex    int\\n}\\n\\n// A PriorityQueue implements heap.Interface and holds Items.\\ntype PriorityQueue []*Item\\n\\nfunc (pq PriorityQueue) Len() int { return len(pq) }\\n\\nfunc (pq PriorityQueue) Less(i, j int) bool {\\n\\tif pq[i].priority == pq[j].priority {\\n\\t\\treturn pq[i].num < pq[j].num\\n\\t}\\n\\treturn pq[i].priority < pq[j].priority\\n}\\n\\nfunc (pq PriorityQueue) Swap(i, j int) {\\n\\tpq[i], pq[j] = pq[j], pq[i]\\n\\tpq[i].index = i\\n\\tpq[j].index = j\\n}\\n\\nfunc (pq *PriorityQueue) Push(x interface{}) {\\n\\tn := len(*pq)\\n\\titem := x.(*Item)\\n\\titem.index = n\\n\\t*pq = append(*pq, item)\\n}\\n\\nfunc (pq *PriorityQueue) Pop() interface{} {\\n\\told := *pq\\n\\tn := len(old)\\n\\titem := old[n-1]\\n\\told[n-1] = nil  // avoid memory leak\\n\\titem.index = -1 // for safety\\n\\t*pq = old[0 : n-1]\\n\\treturn item\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2545310,
                "title": "c-code-for-beginners-easy-understanding-code-set-binary-search-heap",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n        vector<int> serverUsed(k,0);\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> lockedServer;\\n        set<int> serverAvail;\\n        for(int i=0;i<k;i++){\\n            serverAvail.insert(i);\\n        }\\n        for(int i=0;i<arrival.size();i++){\\n            while(!lockedServer.empty() && lockedServer.top().first<=arrival[i]){  // every server that has deadline before this arrival\\n                serverAvail.insert(lockedServer.top().second);\\n                lockedServer.pop();\\n            }\\n            if(serverAvail.empty()){  // if no server available, whoops, this current task skipped\\n                continue;\\n            }\\n            auto serverAssigned=serverAvail.lower_bound(i%k);  // get as per condition the server \\n            if(serverAssigned==serverAvail.end()){\\n                serverAssigned=serverAvail.begin();\\n            }\\n            lockedServer.push({arrival[i]+load[i],*serverAssigned});\\n            serverUsed[*serverAssigned]++;\\n            serverAvail.erase(*serverAssigned);\\n        }\\n        \\n        int mxUsage=*max_element(serverUsed.begin(),serverUsed.end());\\n        vector<int> res;\\n        for(int i=0;i<k;i++){\\n            if(serverUsed[i]==mxUsage){\\n                res.push_back(i);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)",
                    "Binary Tree",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n        vector<int> serverUsed(k,0);\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> lockedServer;\\n        set<int> serverAvail;\\n        for(int i=0;i<k;i++){\\n            serverAvail.insert(i);\\n        }\\n        for(int i=0;i<arrival.size();i++){\\n            while(!lockedServer.empty() && lockedServer.top().first<=arrival[i]){  // every server that has deadline before this arrival\\n                serverAvail.insert(lockedServer.top().second);\\n                lockedServer.pop();\\n            }\\n            if(serverAvail.empty()){  // if no server available, whoops, this current task skipped\\n                continue;\\n            }\\n            auto serverAssigned=serverAvail.lower_bound(i%k);  // get as per condition the server \\n            if(serverAssigned==serverAvail.end()){\\n                serverAssigned=serverAvail.begin();\\n            }\\n            lockedServer.push({arrival[i]+load[i],*serverAssigned});\\n            serverUsed[*serverAssigned]++;\\n            serverAvail.erase(*serverAssigned);\\n        }\\n        \\n        int mxUsage=*max_element(serverUsed.begin(),serverUsed.end());\\n        vector<int> res;\\n        for(int i=0;i<k;i++){\\n            if(serverUsed[i]==mxUsage){\\n                res.push_back(i);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2287566,
                "title": "java-priorityqueue-and-treeset-with-explanation-o-nlogk",
                "content": "Queue to add the running/busy servers after assigning the work load.\\nTreeSet to add the available/free servers - treeset maintains ascending order, add the servers from 0 -> k-1 in the treeset.\\nserverHandledReqCount int[] array to keep the count of the requests handled by each server.\\n\\niterate over the arrival times, if the running servers queue is empty, get the server from the available servers queue.\\nwith the formula - available.ceiling(idx % k);\\n\\nadd the arrivalTime + loadTime = workTime and the server index into the runningServers queue.\\n\\npeek if the server\\'s work time is less than or equal to the next task completion time, if it is poll those servers from the running servers queue and add the index of that server to the availableServerIdxs treeSet\\n\\nlastly iterate over the serverHandledReqCount[] array and get the max value and add those servers who has the max value into a list and return that list\\n\\n``` \\nclass Solution {\\n    public List<Integer> busiestServers(int k, int[] arrival, int[] load) {\\n        \\n        // use a tree to track available servers\\n        TreeSet<Integer> availableServerIdxs = new TreeSet<Integer>();\\n        for (int num = 0; num < k; num++) {\\n            availableServerIdxs.add(num);\\n        }\\n        // use a PQ to maintain the availability based on curTime + loadTime and the server index = idx%k\\n        Queue<int[]> runningServers = new PriorityQueue<>((a, b)->(a[0] - b[0]));\\n        \\n        int[] serverHandledReqCount = new int[k];\\n        \\n        for (int idx = 0; idx < arrival.length; idx++) {\\n            int newTaskCompletionTime = arrival[idx];\\n            \\n          //  peek if the server\\'s work time is less than or equal to the next task completion time, if it is poll those servers from the running servers queue and add the index of that server to the availableServerIdxs treeSet\\n            while (!runningServers.isEmpty() && runningServers.peek()[0] <= newTaskCompletionTime) {\\n                int freedServer = runningServers.poll()[1];\\n                availableServerIdxs.add(freedServer);\\n            }\\n            \\n            if (availableServerIdxs.size() == 0) continue; // all busy\\n            \\n            // to always get the last freed server\\n            Integer serverIdx = availableServerIdxs.ceiling(idx % k);\\n            \\n            if (serverIdx == null) {\\n                serverIdx = availableServerIdxs.first();\\n            }\\n            \\n            serverHandledReqCount[serverIdx]++;\\n            availableServerIdxs.remove(serverIdx);\\n            \\n            runningServers.offer(new int[] {newTaskCompletionTime + load[idx], serverIdx});\\n        }\\n        \\n        int max = Arrays.stream(serverHandledReqCount).max().getAsInt();\\n        return IntStream.range(0, k).filter(i -> serverHandledReqCount[i] == max).boxed().collect(Collectors.toList());\\n        \\n        //return findMaxesInCounter(counter);\\n    }\\n    \\n    /*\\n    private List<Integer> findMaxesInCounter(int[] counter) {\\n        int max = 0;\\n        for (int i = 0; i < counter.length; i++) {\\n            max = Math.max(max, counter[i]);\\n        }\\n        List<Integer> result = new ArrayList<>();\\n        for (int i = 0; i < counter.length; i++) {\\n            if (counter[i] == max) {\\n                result.add(i);\\n            }\\n        }\\n        return result;\\n    }\\n    */\\n}",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\n    public List<Integer> busiestServers(int k, int[] arrival, int[] load) {\\n        \\n        // use a tree to track available servers\\n        TreeSet<Integer> availableServerIdxs = new TreeSet<Integer>();\\n        for (int num = 0; num < k; num++) {\\n            availableServerIdxs.add(num);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1769140,
                "title": "java-solution-using-heap-and-sorted-set",
                "content": "We use 2 data structures that together answer the main question (faster compared to linear scan):\\n*Which server with **smallest id with ceiling i%k** is **available** at time arrival[i]?*\\n\\n1. **availability** can be answered by Min heap ordered by end time of each server called busy.\\n2. **smalled id with ceiling i%k** can be answered by sorted set ordered by server id called free.\\n\\nWhile iterating over the loads:\\n1. move free servers from busy to free at arrival[i] (server.freeAt <= arrival[i])\\n2. query free servers to return smallest id after i%k (if none, get smallet id after 0).\\n3. update freeAt and move server from free to busy.\\n\\nKeep track of maxServer handled and add to the return list accodingly.\\n \\n```\\nclass Solution {\\n    \\n    static class Server {\\n        int id;\\n        int freeAt;\\n        int tasksHandled;\\n        \\n        public Server(int id, int freeAt) {\\n            this.id = id;\\n            this.freeAt = freeAt;\\n        }\\n        \\n        public boolean equals(Object o) {\\n            Server s = (Server) o;\\n            return s.id == this.id;\\n        }\\n        \\n        public int hashCode() {\\n            return this.id;\\n        }\\n    }\\n    \\n    public List<Integer> busiestServers(int k, int[] arrival, int[] load) {\\n        TreeSet<Server> free = new TreeSet<Server>((x, y) -> {return x.id - y.id;});\\n        PriorityQueue<Server> busy = new PriorityQueue<Server>((x, y) -> {return x.freeAt - y.freeAt;});\\n        \\n        int maxHandled = 0;\\n        List<Integer> maxHandleServers = null;\\n        \\n        for(int i=0; i<k; i++) free.add(new Server(i, 0));\\n        \\n        for(int i=0; i<arrival.length; i++) {\\n            while(!busy.isEmpty() && busy.peek().freeAt <= arrival[i]) {\\n                free.add(busy.poll());\\n            }\\n            \\n            if(free.isEmpty()) continue;\\n            \\n            Server freeServer = free.ceiling(new Server(i%k, 0));\\n            if(freeServer == null) freeServer = free.first();\\n            \\n            freeServer.freeAt = arrival[i] + load[i];\\n            freeServer.tasksHandled++;\\n            \\n            if(freeServer.tasksHandled > maxHandled) {\\n                maxHandled = freeServer.tasksHandled;\\n                maxHandleServers = new ArrayList();\\n                maxHandleServers.add(freeServer.id);\\n            } else if(freeServer.tasksHandled == maxHandled) {\\n                maxHandleServers.add(freeServer.id);\\n            }\\n            \\n            free.remove(freeServer);\\n            busy.add(freeServer);\\n        }\\n        \\n        return maxHandleServers;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    \\n    static class Server {\\n        int id;\\n        int freeAt;\\n        int tasksHandled;\\n        \\n        public Server(int id, int freeAt) {\\n            this.id = id;\\n            this.freeAt = freeAt;\\n        }\\n        \\n        public boolean equals(Object o) {\\n            Server s = (Server) o;\\n            return s.id == this.id;\\n        }\\n        \\n        public int hashCode() {\\n            return this.id;\\n        }\\n    }\\n    \\n    public List<Integer> busiestServers(int k, int[] arrival, int[] load) {\\n        TreeSet<Server> free = new TreeSet<Server>((x, y) -> {return x.id - y.id;});\\n        PriorityQueue<Server> busy = new PriorityQueue<Server>((x, y) -> {return x.freeAt - y.freeAt;});\\n        \\n        int maxHandled = 0;\\n        List<Integer> maxHandleServers = null;\\n        \\n        for(int i=0; i<k; i++) free.add(new Server(i, 0));\\n        \\n        for(int i=0; i<arrival.length; i++) {\\n            while(!busy.isEmpty() && busy.peek().freeAt <= arrival[i]) {\\n                free.add(busy.poll());\\n            }\\n            \\n            if(free.isEmpty()) continue;\\n            \\n            Server freeServer = free.ceiling(new Server(i%k, 0));\\n            if(freeServer == null) freeServer = free.first();\\n            \\n            freeServer.freeAt = arrival[i] + load[i];\\n            freeServer.tasksHandled++;\\n            \\n            if(freeServer.tasksHandled > maxHandled) {\\n                maxHandled = freeServer.tasksHandled;\\n                maxHandleServers = new ArrayList();\\n                maxHandleServers.add(freeServer.id);\\n            } else if(freeServer.tasksHandled == maxHandled) {\\n                maxHandleServers.add(freeServer.id);\\n            }\\n            \\n            free.remove(freeServer);\\n            busy.add(freeServer);\\n        }\\n        \\n        return maxHandleServers;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1711856,
                "title": "swift-heap-o-nlogn-logk",
                "content": "See details explaination from this article\\nhttps://leetcode.com/problems/find-servers-that-handled-most-number-of-requests/discuss/876883/Python-using-only-heaps\\n\\nBelow is Swift version\\n```\\nclass Heap<T> {\\n    private var data: [T] = []\\n    var count: Int {\\n        return data.count\\n    }\\n    private var sort: ((T, T) -> Bool)!\\n    init (_ sort: @escaping ((T, T) -> Bool)) {\\n        self.sort = sort\\n    }\\n    private func p(_ i: Int) -> Int { return (i - 1) / 2 }\\n    private func l(_ i: Int) -> Int { return i * 2 + 1 }\\n    private func r(_ i: Int) -> Int { return i * 2 + 2 }\\n    func isEmpty() -> Bool {\\n        return data.isEmpty\\n    }\\n    func add(_ val: T) {\\n        data.append(val)\\n        swim(data.count - 1)\\n    }\\n    private func swim(_ i: Int) {\\n        if sort(data[i], data[p(i)]) {\\n            data.swapAt(i, p(i))\\n            swim(p(i))\\n        }\\n    }\\n    func remove() -> T? {\\n        if data.count == 0 { return nil }\\n        if data.count == 1 { return data.removeLast() }\\n        let node = data[0]\\n        data[0] = data.removeLast()\\n        dive(0)\\n        return node\\n    }\\n    private func dive(_ i: Int) {\\n        let left = l(i) >= data.count ? data[i] : data[l(i)]\\n        let right = r(i) >= data.count ? data[i] : data[r(i)]\\n        if sort(left, data[i]) || sort(right, data[i]) {\\n            if sort(left, right) {\\n                data.swapAt(i, l(i))\\n                dive(l(i))\\n            } else {\\n                data.swapAt(i, r(i))\\n                dive(r(i))\\n            }\\n        }\\n    }\\n    func top() -> T? {\\n        return data.first\\n    }\\n}\\n\\nclass Solution {\\n    // Time: O(nlogn * logk) n is number of request, k is number of servers\\n    // Space: O(n+k)\\n    func busiestServers(_ k: Int, _ arrival: [Int], _ load: [Int]) -> [Int] {     \\n        // store current server are working, stored by end time\\n        var sessions = Heap<(Int,Int)> { $0.0 < $1.0 } \\n        \\n        // store server of current round\\n        var currentRound = Heap<Int> { $0 < $1 }\\n        \\n        // store server of next round\\n        var nextRound = Heap<Int> { $0 < $1 }\\n        for i in 0..<k {\\n            nextRound.add(i)\\n        }\\n        \\n        // record how many request of a server executed\\n        var timesheet = Array(repeating: 0, count: k)\\n        \\n        // map into requests (startTime, duration)\\n        var requests: [(Int, Int)] = []\\n        for i in 0..<arrival.count {\\n            requests.append((arrival[i], load[i]))\\n        }\\n        \\n        // start requesting...\\n        for (index, (startTime, duration)) in requests.enumerated() {\\n            let roundRobinServer = index % k\\n            // it is time to go back\\n            if roundRobinServer == 0 {\\n                currentRound = nextRound\\n                nextRound = Heap<Int> { $0 < $1 }\\n            }\\n            \\n            // releases servers which already done executing previous requests\\n            while sessions.count > 0 && sessions.top()!.0 <= startTime {\\n                let freeServer = sessions.remove()!.1\\n                \\n                // if server is free is < roundRobinServer, so it should be added to next round (current round more priority)\\n                if freeServer < roundRobinServer {\\n                    nextRound.add(freeServer)\\n                } else {\\n                    currentRound.add(freeServer)\\n                }\\n            }\\n            \\n            // now just pick a server from current round\\n            var chosenServer = -1\\n            if currentRound.count > 0 {\\n                chosenServer = currentRound.remove()!\\n            // if current round is out of server, consider to next round\\n            } else if nextRound.count > 0 {\\n                chosenServer = nextRound.remove()!\\n            }\\n            \\n            // if no server is availble, drop that\\n            if chosenServer == -1 {\\n                continue\\n            }\\n            \\n            // increment for the server execute this request\\n            timesheet[chosenServer] += 1\\n            // ... and add it into session\\n            sessions.add((startTime + duration, chosenServer))\\n        }\\n        \\n        // find out the maximum requests and all server has same amount\\n        var ans: [Int] = []\\n        var maxRequest = 0\\n        for server in 0..<timesheet.count {\\n            if maxRequest < timesheet[server] {\\n                maxRequest = timesheet[server]\\n                ans = []\\n            }\\n            if maxRequest == timesheet[server] {\\n                ans.append(server)\\n            }\\n        }\\n        \\n        return ans\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Heap<T> {\\n    private var data: [T] = []\\n    var count: Int {\\n        return data.count\\n    }\\n    private var sort: ((T, T) -> Bool)!\\n    init (_ sort: @escaping ((T, T) -> Bool)) {\\n        self.sort = sort\\n    }\\n    private func p(_ i: Int) -> Int { return (i - 1) / 2 }\\n    private func l(_ i: Int) -> Int { return i * 2 + 1 }\\n    private func r(_ i: Int) -> Int { return i * 2 + 2 }\\n    func isEmpty() -> Bool {\\n        return data.isEmpty\\n    }\\n    func add(_ val: T) {\\n        data.append(val)\\n        swim(data.count - 1)\\n    }\\n    private func swim(_ i: Int) {\\n        if sort(data[i], data[p(i)]) {\\n            data.swapAt(i, p(i))\\n            swim(p(i))\\n        }\\n    }\\n    func remove() -> T? {\\n        if data.count == 0 { return nil }\\n        if data.count == 1 { return data.removeLast() }\\n        let node = data[0]\\n        data[0] = data.removeLast()\\n        dive(0)\\n        return node\\n    }\\n    private func dive(_ i: Int) {\\n        let left = l(i) >= data.count ? data[i] : data[l(i)]\\n        let right = r(i) >= data.count ? data[i] : data[r(i)]\\n        if sort(left, data[i]) || sort(right, data[i]) {\\n            if sort(left, right) {\\n                data.swapAt(i, l(i))\\n                dive(l(i))\\n            } else {\\n                data.swapAt(i, r(i))\\n                dive(r(i))\\n            }\\n        }\\n    }\\n    func top() -> T? {\\n        return data.first\\n    }\\n}\\n\\nclass Solution {\\n    // Time: O(nlogn * logk) n is number of request, k is number of servers\\n    // Space: O(n+k)\\n    func busiestServers(_ k: Int, _ arrival: [Int], _ load: [Int]) -> [Int] {     \\n        // store current server are working, stored by end time\\n        var sessions = Heap<(Int,Int)> { $0.0 < $1.0 } \\n        \\n        // store server of current round\\n        var currentRound = Heap<Int> { $0 < $1 }\\n        \\n        // store server of next round\\n        var nextRound = Heap<Int> { $0 < $1 }\\n        for i in 0..<k {\\n            nextRound.add(i)\\n        }\\n        \\n        // record how many request of a server executed\\n        var timesheet = Array(repeating: 0, count: k)\\n        \\n        // map into requests (startTime, duration)\\n        var requests: [(Int, Int)] = []\\n        for i in 0..<arrival.count {\\n            requests.append((arrival[i], load[i]))\\n        }\\n        \\n        // start requesting...\\n        for (index, (startTime, duration)) in requests.enumerated() {\\n            let roundRobinServer = index % k\\n            // it is time to go back\\n            if roundRobinServer == 0 {\\n                currentRound = nextRound\\n                nextRound = Heap<Int> { $0 < $1 }\\n            }\\n            \\n            // releases servers which already done executing previous requests\\n            while sessions.count > 0 && sessions.top()!.0 <= startTime {\\n                let freeServer = sessions.remove()!.1\\n                \\n                // if server is free is < roundRobinServer, so it should be added to next round (current round more priority)\\n                if freeServer < roundRobinServer {\\n                    nextRound.add(freeServer)\\n                } else {\\n                    currentRound.add(freeServer)\\n                }\\n            }\\n            \\n            // now just pick a server from current round\\n            var chosenServer = -1\\n            if currentRound.count > 0 {\\n                chosenServer = currentRound.remove()!\\n            // if current round is out of server, consider to next round\\n            } else if nextRound.count > 0 {\\n                chosenServer = nextRound.remove()!\\n            }\\n            \\n            // if no server is availble, drop that\\n            if chosenServer == -1 {\\n                continue\\n            }\\n            \\n            // increment for the server execute this request\\n            timesheet[chosenServer] += 1\\n            // ... and add it into session\\n            sessions.add((startTime + duration, chosenServer))\\n        }\\n        \\n        // find out the maximum requests and all server has same amount\\n        var ans: [Int] = []\\n        var maxRequest = 0\\n        for server in 0..<timesheet.count {\\n            if maxRequest < timesheet[server] {\\n                maxRequest = timesheet[server]\\n                ans = []\\n            }\\n            if maxRequest == timesheet[server] {\\n                ans.append(server)\\n            }\\n        }\\n        \\n        return ans\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1411210,
                "title": "c-intuitive-map-heap-set-binary-search",
                "content": "Servers : The available servers right now\\npq : Busy servers right now\\nbusy : a map which contains the number of requests a servere handles\\n\\nIntuition : We compare the end time of currently busy servers with the arrival time of the new request. If the arrival time is greater, that means our server has finished its task and is now free to use.\\n\\nHow to handle next request?\\nSince the set is sorted, we search the next element which is greater than or equal to the required server. If we can\\'t find any such server, then we go back to the begining of the set to find the first free server.\\n\\nWe can further optimize it using unordered_map for busy.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n        set<int> servers;\\n        priority_queue< pair<int,int> ,vector<pair<int,int>> ,greater<pair<int,int>> > pq;\\n        \\n        for(int i=0;i<k;i++)\\n            servers.insert(i);\\n        \\n        map<int ,int> busy;\\n        int n=arrival.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            int start=arrival[i],end=arrival[i]+load[i];\\n            while(!pq.empty() and pq.top().first<=start)\\n            {\\n                auto it=pq.top();\\n                pq.pop();\\n                servers.insert(it.second);\\n            }\\n            if(servers.empty())\\n                continue;\\n            auto ser=servers.lower_bound(i%k);\\n            if(ser==servers.end())\\n                ser=servers.begin();\\n            \\n            int serverNo=*ser;\\n            cout<<serverNo<<\" \";\\n            pq.push({end,serverNo});\\n            busy[serverNo]++;\\n            servers.erase(ser);\\n        }\\n        int maxBusy=0;\\n        for(auto it:busy)\\n            maxBusy=max(maxBusy,it.second);\\n        vector<int> res;\\n        for(auto it:busy)\\n        {\\n            if(it.second==maxBusy)\\n                res.push_back(it.first);\\n        }\\n        return res;\\n    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)",
                    "Binary Tree",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n        set<int> servers;\\n        priority_queue< pair<int,int> ,vector<pair<int,int>> ,greater<pair<int,int>> > pq;\\n        \\n        for(int i=0;i<k;i++)\\n            servers.insert(i);\\n        \\n        map<int ,int> busy;\\n        int n=arrival.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            int start=arrival[i],end=arrival[i]+load[i];\\n            while(!pq.empty() and pq.top().first<=start)\\n            {\\n                auto it=pq.top();\\n                pq.pop();\\n                servers.insert(it.second);\\n            }\\n            if(servers.empty())\\n                continue;\\n            auto ser=servers.lower_bound(i%k);\\n            if(ser==servers.end())\\n                ser=servers.begin();\\n            \\n            int serverNo=*ser;\\n            cout<<serverNo<<\" \";\\n            pq.push({end,serverNo});\\n            busy[serverNo]++;\\n            servers.erase(ser);\\n        }\\n        int maxBusy=0;\\n        for(auto it:busy)\\n            maxBusy=max(maxBusy,it.second);\\n        vector<int> res;\\n        for(auto it:busy)\\n        {\\n            if(it.second==maxBusy)\\n                res.push_back(it.first);\\n        }\\n        return res;\\n    \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1343862,
                "title": "c-priority-queue-set-suggestions-improvements-are-welcome",
                "content": "```\\n\\ntypedef pair<int, int> pr;\\n\\nclass Solution {\\n    \\npublic:\\n    \\n    \\n    \\n    vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n        \\n        // min heap to store busy servers\\n        priority_queue<pr, vector<pr>, greater<pr>> busy;\\n        \\n        // set to store available servers\\n        set<int> avail;\\n        \\n        int count[k]; // keep track of hits for each server\\n\\n        int currentServer = 0; //for current starting index\\n        \\n        for(int j = 0; j<k; j++){\\n            avail.insert(j);\\n            count[j] = 0;\\n        }\\n        \\n \\n        int t = 0;       \\n        for(int i: arrival){\\n            \\n            currentServer = t % k; //set starting server for checking\\n \\n            //pop freed-up servers\\n            while(!busy.empty() && busy.top().first <= i){\\n\\n                avail.insert(busy.top().second);\\n                busy.pop();\\n            }\\n                 \\n            //iterators for next available server(returns next available server if desired server is busy)\\n            auto it = avail.lower_bound(currentServer);\\n            \\n    //iterators for next available server(returns next available server after loop back, if (it) is null)\\n            auto it0 = avail.lower_bound(0);\\n            \\n            // push into busy servers, remove from available servers\\n            if(it != avail.end()){\\n               busy.push(make_pair(i+load[t], *it));\\n               count[*it]++;\\n                avail.erase(*it);\\n            } else if(it0 != avail.end()){\\n                busy.push(make_pair(i+load[t], *it0));\\n                count[*it0]++;\\n                avail.erase(*it0);\\n            }\\n           \\n           t++;\\n        }\\n        \\n        vector<int> res;\\n        \\n        int max = 0;\\n        \\n        for(int y: count){\\n            max = y > max ? y : max;\\n        }\\n        \\n        for(int y=0; y<k; y++){\\n            if(count[y] == max) res.push_back(y);\\n        }\\n        \\n        return res;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)",
                    "Ordered Set"
                ],
                "code": "```\\n\\ntypedef pair<int, int> pr;\\n\\nclass Solution {\\n    \\npublic:\\n    \\n    \\n    \\n    vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n        \\n        // min heap to store busy servers\\n        priority_queue<pr, vector<pr>, greater<pr>> busy;\\n        \\n        // set to store available servers\\n        set<int> avail;\\n        \\n        int count[k]; // keep track of hits for each server\\n\\n        int currentServer = 0; //for current starting index\\n        \\n        for(int j = 0; j<k; j++){\\n            avail.insert(j);\\n            count[j] = 0;\\n        }\\n        \\n \\n        int t = 0;       \\n        for(int i: arrival){\\n            \\n            currentServer = t % k; //set starting server for checking\\n \\n            //pop freed-up servers\\n            while(!busy.empty() && busy.top().first <= i){\\n\\n                avail.insert(busy.top().second);\\n                busy.pop();\\n            }\\n                 \\n            //iterators for next available server(returns next available server if desired server is busy)\\n            auto it = avail.lower_bound(currentServer);\\n            \\n    //iterators for next available server(returns next available server after loop back, if (it) is null)\\n            auto it0 = avail.lower_bound(0);\\n            \\n            // push into busy servers, remove from available servers\\n            if(it != avail.end()){\\n               busy.push(make_pair(i+load[t], *it));\\n               count[*it]++;\\n                avail.erase(*it);\\n            } else if(it0 != avail.end()){\\n                busy.push(make_pair(i+load[t], *it0));\\n                count[*it0]++;\\n                avail.erase(*it0);\\n            }\\n           \\n           t++;\\n        }\\n        \\n        vector<int> res;\\n        \\n        int max = 0;\\n        \\n        for(int y: count){\\n            max = y > max ? y : max;\\n        }\\n        \\n        for(int y=0; y<k; y++){\\n            if(count[y] == max) res.push_back(y);\\n        }\\n        \\n        return res;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1191274,
                "title": "java-treeset-with-priorityqueue-w-explanation",
                "content": "For each query, put all of the available servers at that point to the TreeSet, so that you can find the successor in ```O(log(k))``` time. For tracking which all servers are available at the moment w/o going through the entire list, maintain a Min-Heap w.r.t finishing time, so that we can add them all to the TreeSet.\\n```\\nclass Solution \\n{\\n    public List<Integer> busiestServers(int k, int[] time, int[] load) \\n    {\\n        PriorityQueue<int[]> q=new PriorityQueue<int[]>((a,b)->((int[])a)[1]-((int[])b)[1]);\\n        TreeSet<Integer> ptr=new TreeSet<Integer>();\\n        for(int i=0;i<k;++i)\\n            ptr.add(i);\\n        int[] count=new int[k];\\n        int val=0;\\n        for(int i=0;i<time.length;++i)\\n        {\\n            while(!q.isEmpty()&&q.peek()[1]<=time[i])\\n                ptr.add(q.poll()[0]);\\n            int server=i%k;\\n            int ret=-1;\\n            if(ptr.isEmpty())\\n                continue;\\n            else if(ptr.contains(server))\\n                ret=server;\\n            else\\n            {\\n                Integer temp=ptr.higher(server);\\n                if(temp!=null)\\n                    ret=temp;\\n                else\\n                    ret=ptr.first();\\n            }\\n            if(ret!=-1)\\n            {\\n                val=Math.max(val,++count[ret]);\\n                ptr.remove(ret);\\n                q.add(new int[]{ret,time[i]+load[i]});\\n            }\\n        }\\n        List<Integer> ret=new ArrayList<Integer>();\\n        for(int i=0;i<k;++i)\\n            if(count[i]==val)\\n                ret.add(i);\\n        return ret;\\n    }\\n}\\n`````",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Heap (Priority Queue)",
                    "Ordered Set"
                ],
                "code": "```O(log(k))```\n```\\nclass Solution \\n{\\n    public List<Integer> busiestServers(int k, int[] time, int[] load) \\n    {\\n        PriorityQueue<int[]> q=new PriorityQueue<int[]>((a,b)->((int[])a)[1]-((int[])b)[1]);\\n        TreeSet<Integer> ptr=new TreeSet<Integer>();\\n        for(int i=0;i<k;++i)\\n            ptr.add(i);\\n        int[] count=new int[k];\\n        int val=0;\\n        for(int i=0;i<time.length;++i)\\n        {\\n            while(!q.isEmpty()&&q.peek()[1]<=time[i])\\n                ptr.add(q.poll()[0]);\\n            int server=i%k;\\n            int ret=-1;\\n            if(ptr.isEmpty())\\n                continue;\\n            else if(ptr.contains(server))\\n                ret=server;\\n            else\\n            {\\n                Integer temp=ptr.higher(server);\\n                if(temp!=null)\\n                    ret=temp;\\n                else\\n                    ret=ptr.first();\\n            }\\n            if(ret!=-1)\\n            {\\n                val=Math.max(val,++count[ret]);\\n                ptr.remove(ret);\\n                q.add(new int[]{ret,time[i]+load[i]});\\n            }\\n        }\\n        List<Integer> ret=new ArrayList<Integer>();\\n        for(int i=0;i<k;++i)\\n            if(count[i]==val)\\n                ret.add(i);\\n        return ret;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 950834,
                "title": "c-using-priority-queue-and-set-plz-have-a-look-for-your-better-understanding",
                "content": "```\\nclass Solution {\\npublic:\\n    #define ar array\\n    vector<int> busiestServers(int k, vector<int>& A, vector<int>& L) {\\n        \\n        set<int >st;\\n        vector<int>freq(k);//For Finding the Busy Server \\n        for(int i=0;i<k;i++)//Initial Available Server\\n            st.insert(i);\\n        priority_queue<ar<int,2>,vector<ar<int,2> > ,greater<ar<int,2> > >pq;\\n        for(int i=0;i<A.size(); i++)\\n        {\\n            while(!pq.empty()&& pq.top()[0]<=A[i])\\n            {\\n                st.insert(pq.top()[1]);\\n                pq.pop();\\n            }\\n            if(st.size()==0)// Currently Not available any Server,its means All Servers are Busy..So this request is dropped\\n            continue;\\n                auto it=st.lower_bound(i%k);// for finding next available server\\n                if(it==st.end())\\n                    it=st.lower_bound(0);\\n                int val=*it;\\n                freq[val]++;//Increase the  handled requests by this server \\n                st.erase(it);\\n                pq.push({A[i]+L[i],val});\\n            \\n        }\\n        \\n      int val=*max_element(freq.begin(),freq.end());\\n      vector<int>ans;\\n        for(int i=0;i<k; i++)\\n        {\\n            if(freq[i]==val)\\n            {\\n                ans.push_back(i);\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    #define ar array\\n    vector<int> busiestServers(int k, vector<int>& A, vector<int>& L) {\\n        \\n        set<int >st;\\n        vector<int>freq(k);//For Finding the Busy Server \\n        for(int i=0;i<k;i++)//Initial Available Server\\n            st.insert(i);\\n        priority_queue<ar<int,2>,vector<ar<int,2> > ,greater<ar<int,2> > >pq;\\n        for(int i=0;i<A.size(); i++)\\n        {\\n            while(!pq.empty()&& pq.top()[0]<=A[i])\\n            {\\n                st.insert(pq.top()[1]);\\n                pq.pop();\\n            }\\n            if(st.size()==0)// Currently Not available any Server,its means All Servers are Busy..So this request is dropped\\n            continue;\\n                auto it=st.lower_bound(i%k);// for finding next available server\\n                if(it==st.end())\\n                    it=st.lower_bound(0);\\n                int val=*it;\\n                freq[val]++;//Increase the  handled requests by this server \\n                st.erase(it);\\n                pq.push({A[i]+L[i],val});\\n            \\n        }\\n        \\n      int val=*max_element(freq.begin(),freq.end());\\n      vector<int>ans;\\n        for(int i=0;i<k; i++)\\n        {\\n            if(freq[i]==val)\\n            {\\n                ans.push_back(i);\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 931292,
                "title": "java-treeset-priorityqueue-131-ms-faster-than-44-71-62-4-mb-less-than-7-45",
                "content": "```\\nclass Solution {\\n    public List<Integer> busiestServers(int k, int[] arrival, int[] load) {\\n        TreeSet<Integer> available = new TreeSet<>();\\n        int[] cnts = new int[k];\\n        int maxCnt = 0;\\n        List<Integer> res = new ArrayList<>();\\n        for (int i = 0; i < k; ++i) {\\n            available.add(i);\\n        }\\n        PriorityQueue<int[]> pq = new PriorityQueue<>(Comparator.comparingInt(a -> a[1]));\\n        int n = load.length;\\n        for (int i = 0; i < n; ++i) {\\n            int start = arrival[i];\\n            while (!pq.isEmpty() && pq.peek()[1] <= start) {\\n                available.add(pq.poll()[0]);\\n            }\\n            if (available.isEmpty()) {\\n                continue;\\n            }\\n            Integer server = available.ceiling(i % k);\\n            if (server == null) {\\n                server = available.first();\\n            }\\n            available.remove(server);\\n            pq.offer(new int[]{server, start + load[i]});\\n            if (++cnts[server] >= maxCnt) {\\n                if (cnts[server] > maxCnt) {\\n                    maxCnt = cnts[server];\\n                    res.clear();\\n                }\\n                res.add(server);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> busiestServers(int k, int[] arrival, int[] load) {\\n        TreeSet<Integer> available = new TreeSet<>();\\n        int[] cnts = new int[k];\\n        int maxCnt = 0;\\n        List<Integer> res = new ArrayList<>();\\n        for (int i = 0; i < k; ++i) {\\n            available.add(i);\\n        }\\n        PriorityQueue<int[]> pq = new PriorityQueue<>(Comparator.comparingInt(a -> a[1]));\\n        int n = load.length;\\n        for (int i = 0; i < n; ++i) {\\n            int start = arrival[i];\\n            while (!pq.isEmpty() && pq.peek()[1] <= start) {\\n                available.add(pq.poll()[0]);\\n            }\\n            if (available.isEmpty()) {\\n                continue;\\n            }\\n            Integer server = available.ceiling(i % k);\\n            if (server == null) {\\n                server = available.first();\\n            }\\n            available.remove(server);\\n            pq.offer(new int[]{server, start + load[i]});\\n            if (++cnts[server] >= maxCnt) {\\n                if (cnts[server] > maxCnt) {\\n                    maxCnt = cnts[server];\\n                    res.clear();\\n                }\\n                res.add(server);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 926162,
                "title": "c-staightforward",
                "content": "```\\n    vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n        set<int> freeServers;\\n        for(int i=0;i<k;i++) freeServers.insert(i);\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<>> jobs; //complete time, server No.\\n        vector<int> counter(k,0);\\n        for(int i=0;i<arrival.size();i++){\\n            const int t = arrival[i];\\n            \\n            // check done job, and free the servers\\n            while(!jobs.empty() && jobs.top().first <= t){\\n                auto [t_out, server] = jobs.top(); jobs.pop();\\n                freeServers.insert(server);\\n            }\\n            \\n            if(freeServers.empty()) continue;\\n            \\n            // assign job to a server\\n            auto it = freeServers.lower_bound(i%k);\\n            if(it == freeServers.end()) it = freeServers.begin();\\n            const int server = *it;\\n            freeServers.erase(it);\\n            jobs.push(pair(t+load[i], server));\\n            counter[server]++;\\n        }\\n        \\n        const int maxCount = *max_element(counter.begin(), counter.end());\\n        vector<int> res;\\n        for(int i=0;i<k;i++) if(counter[i] == maxCount) res.push_back(i);\\n        return res;\\n    }",
                "solutionTags": [],
                "code": "```\\n    vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n        set<int> freeServers;\\n        for(int i=0;i<k;i++) freeServers.insert(i);\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<>> jobs; //complete time, server No.\\n        vector<int> counter(k,0);\\n        for(int i=0;i<arrival.size();i++){\\n            const int t = arrival[i];\\n            \\n            // check done job, and free the servers\\n            while(!jobs.empty() && jobs.top().first <= t){\\n                auto [t_out, server] = jobs.top(); jobs.pop();\\n                freeServers.insert(server);\\n            }\\n            \\n            if(freeServers.empty()) continue;\\n            \\n            // assign job to a server\\n            auto it = freeServers.lower_bound(i%k);\\n            if(it == freeServers.end()) it = freeServers.begin();\\n            const int server = *it;\\n            freeServers.erase(it);\\n            jobs.push(pair(t+load[i], server));\\n            counter[server]++;\\n        }\\n        \\n        const int maxCount = *max_element(counter.begin(), counter.end());\\n        vector<int> res;\\n        for(int i=0;i<k;i++) if(counter[i] == maxCount) res.push_back(i);\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 887507,
                "title": "simple-python-sortedlist-solution",
                "content": "```\\nfrom sortedcontainers import SortedList\\ndef busiestServers(self, k: int, a: List[int], l: List[int]) -> List[int]:\\n\\tans, pq = Counter(), []\\n\\tsl = SortedList(range(k))\\n\\tfor req, (t, ld) in enumerate(zip(a, l)):            \\n\\t\\twhile pq and pq[0][0] <= t: sl.add(heappop(pq)[1])\\n\\t\\tif not sl: continue\\n\\t\\ti = sl.bisect_left(req % k)\\n\\t\\tif i >= len(sl): i = 0\\n\\t\\th = sl.pop(i)\\n\\t\\theappush(pq, (t+ld, h))\\n\\t\\tans[h] += 1            \\n\\tmx = max(ans.values())\\n\\treturn [h for h in ans if ans[h] == mx]",
                "solutionTags": [],
                "code": "```\\nfrom sortedcontainers import SortedList\\ndef busiestServers(self, k: int, a: List[int], l: List[int]) -> List[int]:\\n\\tans, pq = Counter(), []\\n\\tsl = SortedList(range(k))\\n\\tfor req, (t, ld) in enumerate(zip(a, l)):            \\n\\t\\twhile pq and pq[0][0] <= t: sl.add(heappop(pq)[1])\\n\\t\\tif not sl: continue\\n\\t\\ti = sl.bisect_left(req % k)\\n\\t\\tif i >= len(sl): i = 0\\n\\t\\th = sl.pop(i)\\n\\t\\theappush(pq, (t+ld, h))\\n\\t\\tans[h] += 1            \\n\\tmx = max(ans.values())\\n\\treturn [h for h in ans if ans[h] == mx]",
                "codeTag": "Python3"
            },
            {
                "id": 879270,
                "title": "java-o-nlogn-with-treeset-and-priorityqueue-more-comprehensive-with-server-class",
                "content": "``` java\\nclass Solution {\\n    private class Server {\\n        // index of server, 0, 1, ..., k-1\\n        public int id;\\n        // release time on timeline\\n        public int release;\\n        // number of requests this server handled\\n        public int requests;\\n\\t\\t\\n        public Server(int id) {\\n            this.id = id;\\n        }\\n    }\\n\\n    public List<Integer> busiestServers(int k, int[] arrival, int[] load) {\\n        if (k == 0 || arrival == null || load == null || arrival.length < 1 || load.length < 1 || arrival.length != load.length) {\\n            return null;\\n        }\\n        \\n        TreeSet<Server> availableServers = new TreeSet<>(Comparator.comparing(s -> s.id));\\n        PriorityQueue<Server> busyServers = new PriorityQueue<>(Comparator.comparing(s -> s.release));\\n        int maxRequests = 0;\\n\\n        // initially all servers are available\\n        for (int i=0; i<k; ++i) {\\n            availableServers.add(new Server(i));\\n        }\\n\\n        int n = arrival.length;\\n        for (int i=0; i<n; ++i) {\\n            int requestStart = arrival[i];\\n            int requestLoad = load[i];\\n\\n            // release all servers that completed the task at requestStart time\\n            while(!busyServers.isEmpty() && busyServers.peek().release <= requestStart) {\\n                Server s = busyServers.poll();\\n                availableServers.add(s);\\n            }\\n            \\n\\t\\t\\t// all servers are busy\\n            if (availableServers.isEmpty()) {\\n                continue;\\n            }\\n\\n            // find a server from i%k, i%k+1, ...\\n            Server s = availableServers.ceiling(new Server(i%k));\\n\\t\\t\\t// wrap around if no server after i%k\\n            if (s == null) {\\n                s = availableServers.first();\\n            }\\n            availableServers.remove(s);\\n            \\n            s.release = requestStart + requestLoad;\\n            ++s.requests;\\n            maxRequests = Math.max(maxRequests, s.requests);\\n\\n            busyServers.add(s);\\n        }\\n\\n        List<Integer> busiestServers = new ArrayList<>();\\n        \\n        for (Server s: busyServers) {\\n            if (s.requests == maxRequests) {\\n                busiestServers.add(s.id);\\n            }\\n        }\\n\\n        for (Server s: availableServers) {\\n            if (s.requests == maxRequests) {\\n                busiestServers.add(s.id);\\n            }\\n        }\\n\\n        return busiestServers;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "``` java\\nclass Solution {\\n    private class Server {\\n        // index of server, 0, 1, ..., k-1\\n        public int id;\\n        // release time on timeline\\n        public int release;\\n        // number of requests this server handled\\n        public int requests;\\n\\t\\t\\n        public Server(int id) {\\n            this.id = id;\\n        }\\n    }\\n\\n    public List<Integer> busiestServers(int k, int[] arrival, int[] load) {\\n        if (k == 0 || arrival == null || load == null || arrival.length < 1 || load.length < 1 || arrival.length != load.length) {\\n            return null;\\n        }\\n        \\n        TreeSet<Server> availableServers = new TreeSet<>(Comparator.comparing(s -> s.id));\\n        PriorityQueue<Server> busyServers = new PriorityQueue<>(Comparator.comparing(s -> s.release));\\n        int maxRequests = 0;\\n\\n        // initially all servers are available\\n        for (int i=0; i<k; ++i) {\\n            availableServers.add(new Server(i));\\n        }\\n\\n        int n = arrival.length;\\n        for (int i=0; i<n; ++i) {\\n            int requestStart = arrival[i];\\n            int requestLoad = load[i];\\n\\n            // release all servers that completed the task at requestStart time\\n            while(!busyServers.isEmpty() && busyServers.peek().release <= requestStart) {\\n                Server s = busyServers.poll();\\n                availableServers.add(s);\\n            }\\n            \\n\\t\\t\\t// all servers are busy\\n            if (availableServers.isEmpty()) {\\n                continue;\\n            }\\n\\n            // find a server from i%k, i%k+1, ...\\n            Server s = availableServers.ceiling(new Server(i%k));\\n\\t\\t\\t// wrap around if no server after i%k\\n            if (s == null) {\\n                s = availableServers.first();\\n            }\\n            availableServers.remove(s);\\n            \\n            s.release = requestStart + requestLoad;\\n            ++s.requests;\\n            maxRequests = Math.max(maxRequests, s.requests);\\n\\n            busyServers.add(s);\\n        }\\n\\n        List<Integer> busiestServers = new ArrayList<>();\\n        \\n        for (Server s: busyServers) {\\n            if (s.requests == maxRequests) {\\n                busiestServers.add(s.id);\\n            }\\n        }\\n\\n        for (Server s: availableServers) {\\n            if (s.requests == maxRequests) {\\n                busiestServers.add(s.id);\\n            }\\n        }\\n\\n        return busiestServers;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 878406,
                "title": "c-easy-commented-code",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n        //stores all the servers that are busy.\\n        //pair.first = time at which it will get free\\n        //pair.second = id of the server\\n        set<pair<int,int>>busyServer;\\n        \\n        //tracks the number of requests served by k servers\\n        vector<int>frequency(k,0);\\n        \\n        //tracks the available servers.\\n        set<int>availableServer;\\n        for(int i=0;i<k;i++){\\n            availableServer.insert(i);\\n        }\\n        \\n        //simulate the process\\n        for(int i=0;i<arrival.size();i++){\\n            while(!busyServer.empty()){              \\n                //it pointing to first pair of busyServer\\n                auto it = busyServer.begin();\\n                \\n                if(it->first<=arrival[i]){\\n                    //unload the first server because at time\\n                    //arrival[i], that server will become free to use again.\\n                    //Add the id of that server to available server.\\n                    availableServer.insert(it->second);\\n                    busyServer.erase(it);\\n                }else{\\n                    //if the first element has greater time than\\n                    //arrival[i] then all the elements of set will have \\n                    //greater than arrival[i], as set is sorted in increasing order\\n                    break;\\n                }\\n            }   \\n            \\n            //if there are no available servers then drop the current request\\n            if(availableServer.size()==0){\\n                continue;\\n            }\\n            \\n            //find the i%k server from available server. If that points to end\\n            //then take the first available server from the list, assuming the cyclic \\n            //nature\\n            auto it = availableServer.lower_bound(i%k);\\n            if(it==availableServer.end()){\\n                it = availableServer.begin();\\n            }\\n            \\n            //remove the it from available server and insert into busy server\\n            //note: insert ending time = arrival[i]+load[i]\\n            int id = *it;\\n            frequency[id]++;\\n            availableServer.erase(it);\\n            busyServer.insert({arrival[i]+load[i],id});\\n        }\\n        \\n        //finding the busiest server\\n        vector<int>result;\\n        int maxx = -1;\\n        for(auto it:frequency){\\n            maxx = max(maxx,it);\\n        }\\n        \\n        for(int i=0;i<k;i++){\\n            if(frequency[i]==maxx){\\n                result.push_back(i);\\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n        //stores all the servers that are busy.\\n        //pair.first = time at which it will get free\\n        //pair.second = id of the server\\n        set<pair<int,int>>busyServer;\\n        \\n        //tracks the number of requests served by k servers\\n        vector<int>frequency(k,0);\\n        \\n        //tracks the available servers.\\n        set<int>availableServer;\\n        for(int i=0;i<k;i++){\\n            availableServer.insert(i);\\n        }\\n        \\n        //simulate the process\\n        for(int i=0;i<arrival.size();i++){\\n            while(!busyServer.empty()){              \\n                //it pointing to first pair of busyServer\\n                auto it = busyServer.begin();\\n                \\n                if(it->first<=arrival[i]){\\n                    //unload the first server because at time\\n                    //arrival[i], that server will become free to use again.\\n                    //Add the id of that server to available server.\\n                    availableServer.insert(it->second);\\n                    busyServer.erase(it);\\n                }else{\\n                    //if the first element has greater time than\\n                    //arrival[i] then all the elements of set will have \\n                    //greater than arrival[i], as set is sorted in increasing order\\n                    break;\\n                }\\n            }   \\n            \\n            //if there are no available servers then drop the current request\\n            if(availableServer.size()==0){\\n                continue;\\n            }\\n            \\n            //find the i%k server from available server. If that points to end\\n            //then take the first available server from the list, assuming the cyclic \\n            //nature\\n            auto it = availableServer.lower_bound(i%k);\\n            if(it==availableServer.end()){\\n                it = availableServer.begin();\\n            }\\n            \\n            //remove the it from available server and insert into busy server\\n            //note: insert ending time = arrival[i]+load[i]\\n            int id = *it;\\n            frequency[id]++;\\n            availableServer.erase(it);\\n            busyServer.insert({arrival[i]+load[i],id});\\n        }\\n        \\n        //finding the busiest server\\n        vector<int>result;\\n        int maxx = -1;\\n        for(auto it:frequency){\\n            maxx = max(maxx,it);\\n        }\\n        \\n        for(int i=0;i<k;i++){\\n            if(frequency[i]==maxx){\\n                result.push_back(i);\\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 877081,
                "title": "python-using-2-heaps-one-for-blocked-machine-one-for-next-available",
                "content": "heap for blocked servers are easy to think for me.\\nthe next available heapq will always give i%k highest priority and so on\\n\\n\\n\\tdef busiestServers(self, k: int, arrival: List[int], load: List[int]) -> List[int]:\\n        hq=[] # heap order by free time\\n\\t\\thqs=[i for i in range(k)] # constant length heap , order by index\\n        l=[0 for i in range(k)]\\n        for i in range(len(arrival)):\\n            #free all the available machine and push into index based heap \\n            while hq:\\n                \\n                if hq[0][0]<=arrival[i]:\\n                    t=heapq.heappop(hq)\\n                    if t[1]%k>=i%k:\\n                        heapq.heappush(hqs,t[1]%k+(i//k)*k)\\n                    else:\\n                        heapq.heappush(hqs,t[1]%k+(i//k+1)*k)\\n                    #print(i,t)\\n                else:\\n                    break\\n            #get first available index (i%k has priority)\\n            if hqs:\\n                t=heapq.heappop(hqs)\\n                j=t%k\\n                l[j]+=1\\n                heapq.heappush(hq,(arrival[i]+load[i],j%k))\\n            \\n        ans=[]\\n        mmm=max(l)\\n        #print(l)\\n        for i in range(k):\\n            if l[i]==mmm:\\n                ans.append(i)\\n        return ans\\n",
                "solutionTags": [],
                "code": "heap for blocked servers are easy to think for me.\\nthe next available heapq will always give i%k highest priority and so on\\n\\n\\n\\tdef busiestServers(self, k: int, arrival: List[int], load: List[int]) -> List[int]:\\n        hq=[] # heap order by free time\\n\\t\\thqs=[i for i in range(k)] # constant length heap , order by index\\n        l=[0 for i in range(k)]\\n        for i in range(len(arrival)):\\n            #free all the available machine and push into index based heap \\n            while hq:\\n                \\n                if hq[0][0]<=arrival[i]:\\n                    t=heapq.heappop(hq)\\n                    if t[1]%k>=i%k:\\n                        heapq.heappush(hqs,t[1]%k+(i//k)*k)\\n                    else:\\n                        heapq.heappush(hqs,t[1]%k+(i//k+1)*k)\\n                    #print(i,t)\\n                else:\\n                    break\\n            #get first available index (i%k has priority)\\n            if hqs:\\n                t=heapq.heappop(hqs)\\n                j=t%k\\n                l[j]+=1\\n                heapq.heappush(hq,(arrival[i]+load[i],j%k))\\n            \\n        ans=[]\\n        mmm=max(l)\\n        #print(l)\\n        for i in range(k):\\n            if l[i]==mmm:\\n                ans.append(i)\\n        return ans\\n",
                "codeTag": "Python3"
            },
            {
                "id": 876972,
                "title": "slow-ass-javascript",
                "content": "I imagine the area this needs to be optimized is finding the correct server, but not sure how to approach that\\n\\n```\\n\\nconst busiestServers = ( k, arrival, load ) => {\\n    \\n    // keep track of how many requests each server handled\\n    const handled = Array(k).fill(0)\\n    \\n    // keep track of when each server will be available again\\n    const servers = Array(k).fill(0)\\n    \\n    // finds the ideal available server\\n    // i think there\\'s an optimization here but not clue how to approach it\\n    const findserver = ( i, t ) => {\\n        let j = i % k\\n        if ( servers[j] <= t ) return j\\n\\n        for ( let l = j + 1; l < k; l++ ) {\\n            if ( servers[l] <= t ) return l\\n        }\\n        for ( let l = 0; l < j; l++ ) {\\n            if ( servers[l] <= t ) return l\\n        }\\n        \\n        return false\\n    }\\n    \\n    let max = 0\\n    arrival.forEach( ( time, i ) => {\\n\\n        // find available\\n        let serverIndex = findserver( i, time )\\n        if ( false === serverIndex ) return\\n        \\n        // add load\\n        handled[ serverIndex ]++\\n        max = Math.max( max, handled[ serverIndex ] )\\n        servers[ serverIndex ] = time + load[i]\\n    })\\n\\n    return handled.reduce( ( a, x, i ) => x == max ? a.push( i ) && a : a, [] )\\n}\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\nconst busiestServers = ( k, arrival, load ) => {\\n    \\n    // keep track of how many requests each server handled\\n    const handled = Array(k).fill(0)\\n    \\n    // keep track of when each server will be available again\\n    const servers = Array(k).fill(0)\\n    \\n    // finds the ideal available server\\n    // i think there\\'s an optimization here but not clue how to approach it\\n    const findserver = ( i, t ) => {\\n        let j = i % k\\n        if ( servers[j] <= t ) return j\\n\\n        for ( let l = j + 1; l < k; l++ ) {\\n            if ( servers[l] <= t ) return l\\n        }\\n        for ( let l = 0; l < j; l++ ) {\\n            if ( servers[l] <= t ) return l\\n        }\\n        \\n        return false\\n    }\\n    \\n    let max = 0\\n    arrival.forEach( ( time, i ) => {\\n\\n        // find available\\n        let serverIndex = findserver( i, time )\\n        if ( false === serverIndex ) return\\n        \\n        // add load\\n        handled[ serverIndex ]++\\n        max = Math.max( max, handled[ serverIndex ] )\\n        servers[ serverIndex ] = time + load[i]\\n    })\\n\\n    return handled.reduce( ( a, x, i ) => x == max ? a.push( i ) && a : a, [] )\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 876941,
                "title": "java-segment-tree-o-n-log-k",
                "content": "Use a SegmentTree for the minimum with query operation to find the first index greater than l that has a value <= to arrival time.\\nIf we can\\'t find a server that is not busy with index greater than the target index, search from index 0. If both searches fail drop the request.\\n\\nThis SegmentTree implementation is almost exactly the same as problems https://codeforces.com/edu/course/2/lesson/4/2/practice/contest/273278/problem/C and\\nhttps://codeforces.com/edu/course/2/lesson/4/2/practice/contest/273278/problem/D\\n\\n```\\n    private static class SegTree {\\n        int leftMost, rightMost;\\n        SegTree left, right;\\n        int min;\\n\\n        SegTree(int leftMost, int rightMost, int[] arr) {\\n            this.leftMost = leftMost;\\n            this.rightMost = rightMost;\\n            if (leftMost == rightMost) {\\n                min = arr[leftMost];\\n            } else {\\n                final int mid = leftMost + rightMost >>> 1;\\n                left = new SegTree(leftMost, mid, arr);\\n                right = new SegTree(mid + 1, rightMost, arr);\\n                recalc();\\n            }\\n        }\\n\\n        private void recalc() {\\n            if (leftMost == rightMost) {\\n                return;\\n            }\\n            min = Math.min(left.min, right.min);\\n        }\\n\\n        private int query(int idx, int val) {\\n            if (min > val || rightMost < idx) {\\n                return -1;\\n            }\\n            if (leftMost == rightMost) {\\n                return leftMost;\\n            }\\n            final int resL = left.query(idx, val);\\n            return resL != -1 ? resL : right.query(idx, val);\\n        }\\n\\n        private void update(int idx, int val) {\\n            if (leftMost == rightMost) {\\n                min = val;\\n            } else {\\n                final int mid = leftMost + rightMost >>> 1;\\n                if (idx <= mid) {\\n                    left.update(idx, val);\\n                } else {\\n                    right.update(idx, val);\\n                }\\n                recalc();\\n            }\\n        }\\n    }\\n    \\n    public List<Integer> busiestServers(int k, int[] arrival, int[] load) {\\n        final int[] handled = new int[k];\\n        final List<Integer> res = new ArrayList<>();\\n        final SegTree st = new SegTree(0, k - 1, new int[k]);\\n        for (int i = 0; i < arrival.length; i++) {\\n            final int target = i % k;\\n            int pos = st.query(target, arrival[i]);\\n            if (pos < target) {\\n                pos = st.query(0, arrival[i]);\\n            }\\n            if (pos != -1) {\\n                handled[pos]++;\\n                st.update(pos, arrival[i] + load[i]);\\n            }\\n        }\\n        int max = 0;\\n        for (int i = 0; i < k; i++) {\\n            max = Math.max(max, handled[i]);\\n        }\\n        for (int i = 0; i < k; i++) {\\n            if (handled[i] == max) {\\n                res.add(i);\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    private static class SegTree {\\n        int leftMost, rightMost;\\n        SegTree left, right;\\n        int min;\\n\\n        SegTree(int leftMost, int rightMost, int[] arr) {\\n            this.leftMost = leftMost;\\n            this.rightMost = rightMost;\\n            if (leftMost == rightMost) {\\n                min = arr[leftMost];\\n            } else {\\n                final int mid = leftMost + rightMost >>> 1;\\n                left = new SegTree(leftMost, mid, arr);\\n                right = new SegTree(mid + 1, rightMost, arr);\\n                recalc();\\n            }\\n        }\\n\\n        private void recalc() {\\n            if (leftMost == rightMost) {\\n                return;\\n            }\\n            min = Math.min(left.min, right.min);\\n        }\\n\\n        private int query(int idx, int val) {\\n            if (min > val || rightMost < idx) {\\n                return -1;\\n            }\\n            if (leftMost == rightMost) {\\n                return leftMost;\\n            }\\n            final int resL = left.query(idx, val);\\n            return resL != -1 ? resL : right.query(idx, val);\\n        }\\n\\n        private void update(int idx, int val) {\\n            if (leftMost == rightMost) {\\n                min = val;\\n            } else {\\n                final int mid = leftMost + rightMost >>> 1;\\n                if (idx <= mid) {\\n                    left.update(idx, val);\\n                } else {\\n                    right.update(idx, val);\\n                }\\n                recalc();\\n            }\\n        }\\n    }\\n    \\n    public List<Integer> busiestServers(int k, int[] arrival, int[] load) {\\n        final int[] handled = new int[k];\\n        final List<Integer> res = new ArrayList<>();\\n        final SegTree st = new SegTree(0, k - 1, new int[k]);\\n        for (int i = 0; i < arrival.length; i++) {\\n            final int target = i % k;\\n            int pos = st.query(target, arrival[i]);\\n            if (pos < target) {\\n                pos = st.query(0, arrival[i]);\\n            }\\n            if (pos != -1) {\\n                handled[pos]++;\\n                st.update(pos, arrival[i] + load[i]);\\n            }\\n        }\\n        int max = 0;\\n        for (int i = 0; i < k; i++) {\\n            max = Math.max(max, handled[i]);\\n        }\\n        for (int i = 0; i < k; i++) {\\n            if (handled[i] == max) {\\n                res.add(i);\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 876818,
                "title": "how-to-optimise-the-inner-while-loop",
                "content": "Hello,\\n\\nMy following solution gave TLE and I got stuck at how to optimise this further.\\n\\nHow can I approach such problem?\\n```\\nclass Solution {\\n    public List<Integer> busiestServers(int k, int[] arrival, int[] load) {\\n        long[] busy = new long[k];\\n        int[] nums = new int[k];\\n        int max = 0;\\n        for(int i=0;i<arrival.length; i++){\\n            int server = i % k;\\n            while(busy[server]>arrival[i]) {\\n                server = (server+1) % k;\\n                if(server == i%k) break;\\n            }\\n            System.out.println(busy[server]+\" \"+arrival[i]+\" \"+i+\" server=\"+server);\\n            if(busy[server]>arrival[i]) continue;\\n            \\n            busy[server] = arrival[i]+load[i];\\n            nums[server]++;\\n            max = Math.max(max, nums[server]);\\n        }\\n        \\n        List<Integer> ans = new ArrayList<>();\\n        for(int i=0;i<k;i++){\\n            System.out.println(nums[i]);\\n            if(nums[i]==max) ans.add(i);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> busiestServers(int k, int[] arrival, int[] load) {\\n        long[] busy = new long[k];\\n        int[] nums = new int[k];\\n        int max = 0;\\n        for(int i=0;i<arrival.length; i++){\\n            int server = i % k;\\n            while(busy[server]>arrival[i]) {\\n                server = (server+1) % k;\\n                if(server == i%k) break;\\n            }\\n            System.out.println(busy[server]+\" \"+arrival[i]+\" \"+i+\" server=\"+server);\\n            if(busy[server]>arrival[i]) continue;\\n            \\n            busy[server] = arrival[i]+load[i];\\n            nums[server]++;\\n            max = Math.max(max, nums[server]);\\n        }\\n        \\n        List<Integer> ans = new ArrayList<>();\\n        for(int i=0;i<k;i++){\\n            System.out.println(nums[i]);\\n            if(nums[i]==max) ans.add(i);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 876800,
                "title": "binary-search-priority-queue-well-explained-nlogn-java",
                "content": "```\\nclass Solution {\\n  class node {\\n    int expire;\\n    int idx;\\n\\n    node(int e, int i) {\\n      expire = e;\\n      idx = i;\\n    }\\n  }\\n\\n  public List<Integer> busiestServers(int k, int[] arrival, int[] load) {\\n\\n    //Free Server List.\\n    TreeSet<Integer> ts = new TreeSet<>();\\n    for (int i = 0; i < k; i++)\\n      ts.add(i);\\n\\n\\n    int max_count = 0;\\n\\n    HashMap<Integer, Integer> count = new HashMap<>();\\n\\n    //Maintains the count list of busy servers by computation expiration time\\n    PriorityQueue<node> pq = new PriorityQueue<>((node a, node b) -> a.expire - b.expire);\\n\\n    for (int i = 0; i < arrival.length; i++) {\\n\\n      //Add to free server list if the computation is finished\\n      while (!pq.isEmpty() && pq.peek().expire <= arrival[i]) {\\n        node p = pq.poll();\\n        ts.add(p.idx);\\n      }\\n\\n      //No Free Server\\n      if (ts.size() == 0)\\n        continue;\\n\\n\\n      //Find next server that is equal or just greater.\\n      Integer ceil = ts.ceiling(i % k);\\n\\n\\n      //If not found get the first available server\\n      if (ceil == null)\\n        ceil = ts.first();\\n\\n\\n      //Remove from free server list\\n      ts.remove(ceil);\\n\\n      count.put(ceil, count.getOrDefault(ceil, 0) + 1);\\n\\n      //Add to busy server list.\\n      pq.add(new node(arrival[i] + load[i], ceil));\\n\\t  \\n\\t  //update maxcount\\n\\t  max_count=Math.max(max_count,count.get(ceil));\\n\\n\\n    }\\n\\n\\n    //Get the most used server.\\n    List<Integer> ans= new ArrayList<>();\\n\\n    for (Map.Entry<Integer,Integer> e:count.entrySet())\\n    {\\n      if (e.getValue()==max_count)\\n      {\\n        ans.add(e.getKey());\\n      }\\n    }\\n\\n    return ans;\\n\\n\\n  }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n  class node {\\n    int expire;\\n    int idx;\\n\\n    node(int e, int i) {\\n      expire = e;\\n      idx = i;\\n    }\\n  }\\n\\n  public List<Integer> busiestServers(int k, int[] arrival, int[] load) {\\n\\n    //Free Server List.\\n    TreeSet<Integer> ts = new TreeSet<>();\\n    for (int i = 0; i < k; i++)\\n      ts.add(i);\\n\\n\\n    int max_count = 0;\\n\\n    HashMap<Integer, Integer> count = new HashMap<>();\\n\\n    //Maintains the count list of busy servers by computation expiration time\\n    PriorityQueue<node> pq = new PriorityQueue<>((node a, node b) -> a.expire - b.expire);\\n\\n    for (int i = 0; i < arrival.length; i++) {\\n\\n      //Add to free server list if the computation is finished\\n      while (!pq.isEmpty() && pq.peek().expire <= arrival[i]) {\\n        node p = pq.poll();\\n        ts.add(p.idx);\\n      }\\n\\n      //No Free Server\\n      if (ts.size() == 0)\\n        continue;\\n\\n\\n      //Find next server that is equal or just greater.\\n      Integer ceil = ts.ceiling(i % k);\\n\\n\\n      //If not found get the first available server\\n      if (ceil == null)\\n        ceil = ts.first();\\n\\n\\n      //Remove from free server list\\n      ts.remove(ceil);\\n\\n      count.put(ceil, count.getOrDefault(ceil, 0) + 1);\\n\\n      //Add to busy server list.\\n      pq.add(new node(arrival[i] + load[i], ceil));\\n\\t  \\n\\t  //update maxcount\\n\\t  max_count=Math.max(max_count,count.get(ceil));\\n\\n\\n    }\\n\\n\\n    //Get the most used server.\\n    List<Integer> ans= new ArrayList<>();\\n\\n    for (Map.Entry<Integer,Integer> e:count.entrySet())\\n    {\\n      if (e.getValue()==max_count)\\n      {\\n        ans.add(e.getKey());\\n      }\\n    }\\n\\n    return ans;\\n\\n\\n  }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4065320,
                "title": "c-segment-tree-binary-search",
                "content": "For each arrival, just find nearest index free using binary search + segment tree. Here is my implementation. If you find it helpful, please upvote. thank you for reading.\\n\\n# Code\\n```\\nvoid update(int node, int start, int end, int pos, int val, vector<int> &seg){\\n    if(start > pos || end < pos){\\n        return;\\n    }\\n    if(start == end){\\n        seg[node] = val;\\n        return;\\n    }\\n    int mid = (start+end)/2;\\n    update(node*2+1, start, mid, pos, val, seg);\\n    update(node*2+2, mid+1, end, pos, val, seg);\\n    seg[node] = min(seg[node*2+1], seg[node*2+2]);\\n}\\n\\nint get(int node, int start, int end, int left, int right, vector<int> &seg){\\n    if(start > right || end < left){\\n        return INT_MAX;\\n    }\\n    if(left<=start && end <= right){\\n        return seg[node];\\n    }\\n    int mid = (start+end)/2;\\n    return min(get(node*2+1, start, mid, left, right, seg), get(node*2+2, mid+1, end, left, right, seg));\\n}\\n\\nclass Solution {\\npublic:\\n    vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n        vector<int> seg(4*k+4, 0);\\n        vector<int> contain(k, 0);\\n        for(int i=0; i<arrival.size(); i++){\\n            \\n            int low = (i%k);\\n            int high = k-1;\\n            int index = -1;\\n            while(low <= high){\\n                int mid = (low+high)/2;\\n                \\n                if(get(0, 0, k-1, i%k, mid, seg) <= arrival[i]){\\n                    index = mid;\\n                    high = mid-1;\\n                }\\n                else{\\n                    low = mid+1;\\n                }\\n            }\\n            if(index == -1){\\n                low = 0;\\n                high = (i%k)-1;\\n                while(low <= high){\\n                    int mid = (low+high)/2;\\n                    if(get(0, 0, k-1, 0, mid, seg) <= arrival[i]){\\n                        index = mid;\\n                        high = mid-1;\\n                    }\\n                    else{\\n                        low = mid+1;\\n                    }\\n                }\\n            }\\n            if(index != -1){\\n                update(0, 0, k-1, index, arrival[i]+load[i], seg);\\n                contain[index] += 1;\\n            }\\n        }\\n        vector<int> ans;\\n        int maxx = -1;\\n        for(int i=0; i<k; i++){\\n            if(contain[i] > maxx){\\n                ans.clear();\\n                maxx = contain[i];\\n            }\\n            if(contain[i] == maxx){\\n                ans.push_back(i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Segment Tree"
                ],
                "code": "```\\nvoid update(int node, int start, int end, int pos, int val, vector<int> &seg){\\n    if(start > pos || end < pos){\\n        return;\\n    }\\n    if(start == end){\\n        seg[node] = val;\\n        return;\\n    }\\n    int mid = (start+end)/2;\\n    update(node*2+1, start, mid, pos, val, seg);\\n    update(node*2+2, mid+1, end, pos, val, seg);\\n    seg[node] = min(seg[node*2+1], seg[node*2+2]);\\n}\\n\\nint get(int node, int start, int end, int left, int right, vector<int> &seg){\\n    if(start > right || end < left){\\n        return INT_MAX;\\n    }\\n    if(left<=start && end <= right){\\n        return seg[node];\\n    }\\n    int mid = (start+end)/2;\\n    return min(get(node*2+1, start, mid, left, right, seg), get(node*2+2, mid+1, end, left, right, seg));\\n}\\n\\nclass Solution {\\npublic:\\n    vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n        vector<int> seg(4*k+4, 0);\\n        vector<int> contain(k, 0);\\n        for(int i=0; i<arrival.size(); i++){\\n            \\n            int low = (i%k);\\n            int high = k-1;\\n            int index = -1;\\n            while(low <= high){\\n                int mid = (low+high)/2;\\n                \\n                if(get(0, 0, k-1, i%k, mid, seg) <= arrival[i]){\\n                    index = mid;\\n                    high = mid-1;\\n                }\\n                else{\\n                    low = mid+1;\\n                }\\n            }\\n            if(index == -1){\\n                low = 0;\\n                high = (i%k)-1;\\n                while(low <= high){\\n                    int mid = (low+high)/2;\\n                    if(get(0, 0, k-1, 0, mid, seg) <= arrival[i]){\\n                        index = mid;\\n                        high = mid-1;\\n                    }\\n                    else{\\n                        low = mid+1;\\n                    }\\n                }\\n            }\\n            if(index != -1){\\n                update(0, 0, k-1, index, arrival[i]+load[i], seg);\\n                contain[index] += 1;\\n            }\\n        }\\n        vector<int> ans;\\n        int maxx = -1;\\n        for(int i=0; i<k; i++){\\n            if(contain[i] > maxx){\\n                ans.clear();\\n                maxx = contain[i];\\n            }\\n            if(contain[i] == maxx){\\n                ans.push_back(i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4057098,
                "title": "python3-simulate-servers-using-sorted-list-and-heap",
                "content": "```\\nfrom sortedcontainers import SortedList\\nfrom heapq import heappush, heappop\\n\\nclass Solution:\\n    def busiestServers(self, k: int, arrival: List[int], load: List[int]) -> List[int]:\\n        processed = [0]*k\\n        ready = SortedList(list(range(k)))\\n        processing = []  # (ready time, server number)\\n        for i, a, l in zip(range(len(arrival)), arrival, load):\\n            while processing and processing[0][0] <= a:\\n                _, s = heappop(processing)\\n                ready.add(s)\\n            \\n            if not ready:\\n                continue\\n            index = ready.bisect_left(i%k)\\n            if index == len(ready):\\n                index = 0\\n            s = ready[index]\\n            ready.pop(index)\\n            processed[s] += 1\\n            heappush(processing, (a+l, s))\\n\\n        m = max(processed)\\n        return [i for i in range(k) if processed[i] == m]\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom sortedcontainers import SortedList\\nfrom heapq import heappush, heappop\\n\\nclass Solution:\\n    def busiestServers(self, k: int, arrival: List[int], load: List[int]) -> List[int]:\\n        processed = [0]*k\\n        ready = SortedList(list(range(k)))\\n        processing = []  # (ready time, server number)\\n        for i, a, l in zip(range(len(arrival)), arrival, load):\\n            while processing and processing[0][0] <= a:\\n                _, s = heappop(processing)\\n                ready.add(s)\\n            \\n            if not ready:\\n                continue\\n            index = ready.bisect_left(i%k)\\n            if index == len(ready):\\n                index = 0\\n            s = ready[index]\\n            ready.pop(index)\\n            processed[s] += 1\\n            heappush(processing, (a+l, s))\\n\\n        m = max(processed)\\n        return [i for i in range(k) if processed[i] == m]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4033661,
                "title": "c-sortedset-nlogn",
                "content": "# Intuition\\nUse SortedSet to overcome TimeLimitExceeded issue.\\n\\n# Approach\\nChecking the existence in SortedSet is O(1) and doing search is a binary search operation since collection is sorted.\\n\\n# Complexity\\n- Time complexity:\\nO(n * log(n)) \\n(n is count of arrival)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\npublic class Solution {\\n\\n    class DuplicateKeyComparer : IComparer<int>\\n    {\\n        public int Compare(int x, int y)\\n        {\\n            int result = x.CompareTo(y);\\n\\n            result = result == 0 ? 1 : result;\\n\\n            return result;\\n        }            \\n    }\\n\\n    class ServerEqualityComparer : IComparer<Server>\\n    {\\n        public int Compare(Server x, Server y)\\n        {\\n            if (x == null || y == null) return -1;\\n\\n            return x.Id.CompareTo(y.Id);\\n        }\\n\\n        public bool Equals(Server x, Server y)\\n        {\\n            if(x == null || y == null) return false;\\n\\n            return x.Id.Equals(y.Id);\\n        }\\n\\n        public int GetHashCode(Server obj)\\n        {\\n            return obj.Id.GetHashCode();\\n        }\\n    }\\n\\n    class Server\\n    {\\n        public int Id { get; set; }\\n\\n        public int ReqCount { get; set; }\\n\\n        public int FreeTime { get; set;}\\n    }\\n\\n    public IList<int> BusiestServers(int k, int[] arrival, int[] load) {\\n        var busyServers = new SortedList<int, Server>(new DuplicateKeyComparer()); // free time, server\\n        var serverRange = Enumerable.Range(0, k);\\n        var serverReqCount = new Dictionary<int, int>(serverRange.Select(i => new KeyValuePair<int, int>(i, 0))); // server, req count\\n        var freeServers = new SortedSet<Server>(serverRange.Select(i => new Server\\n        {\\n            FreeTime = 0,\\n            Id = i,\\n            ReqCount = 0\\n        }), new ServerEqualityComparer());\\n\\n        for (var i = 0; i < arrival.Length; i++)\\n        {\\n            while (busyServers.Count > 0 && busyServers.ElementAt(0).Value.FreeTime <= arrival[i])\\n            {\\n                var firstServer = busyServers.First().Value;\\n                freeServers.Add(firstServer);\\n                busyServers.RemoveAt(0);\\n            }\\n\\n            if (freeServers.Count == 0)\\n            {\\n                //req dropped\\n                continue;\\n            }\\n\\n            Server freeServer = null;\\n\\n            if (freeServers.Contains(new Server { Id = i % k }))\\n            {\\n                freeServers.TryGetValue(new Server { Id = i % k }, out freeServer);\\n            }\\n            else\\n            {\\n                //first or default will do binary search if the collection is sorted\\n                freeServer = freeServers.FirstOrDefault(j => j.Id > (i % k)) ?? freeServers.Min;                    \\n            }\\n\\n            serverReqCount[freeServer.Id]++;\\n            freeServer.FreeTime = arrival[i] + load[i];\\n            busyServers.Add(freeServer.FreeTime, freeServer);\\n            freeServers.Remove(freeServer);\\n        }\\n\\n        var maxReqCount = 0;\\n        var maxReqServers = new List<int>(serverReqCount.Count);\\n\\n        foreach (var item in serverReqCount)\\n        {\\n            if (item.Value > maxReqCount)\\n            {\\n                maxReqCount = item.Value;\\n                maxReqServers = new List<int> { item.Key };\\n            }\\n            else if (item.Value == maxReqCount)\\n            {\\n                maxReqServers.Add(item.Key);\\n            }\\n        }\\n\\n        return maxReqServers;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Ordered Map",
                    "Ordered Set"
                ],
                "code": "```\\npublic class Solution {\\n\\n    class DuplicateKeyComparer : IComparer<int>\\n    {\\n        public int Compare(int x, int y)\\n        {\\n            int result = x.CompareTo(y);\\n\\n            result = result == 0 ? 1 : result;\\n\\n            return result;\\n        }            \\n    }\\n\\n    class ServerEqualityComparer : IComparer<Server>\\n    {\\n        public int Compare(Server x, Server y)\\n        {\\n            if (x == null || y == null) return -1;\\n\\n            return x.Id.CompareTo(y.Id);\\n        }\\n\\n        public bool Equals(Server x, Server y)\\n        {\\n            if(x == null || y == null) return false;\\n\\n            return x.Id.Equals(y.Id);\\n        }\\n\\n        public int GetHashCode(Server obj)\\n        {\\n            return obj.Id.GetHashCode();\\n        }\\n    }\\n\\n    class Server\\n    {\\n        public int Id { get; set; }\\n\\n        public int ReqCount { get; set; }\\n\\n        public int FreeTime { get; set;}\\n    }\\n\\n    public IList<int> BusiestServers(int k, int[] arrival, int[] load) {\\n        var busyServers = new SortedList<int, Server>(new DuplicateKeyComparer()); // free time, server\\n        var serverRange = Enumerable.Range(0, k);\\n        var serverReqCount = new Dictionary<int, int>(serverRange.Select(i => new KeyValuePair<int, int>(i, 0))); // server, req count\\n        var freeServers = new SortedSet<Server>(serverRange.Select(i => new Server\\n        {\\n            FreeTime = 0,\\n            Id = i,\\n            ReqCount = 0\\n        }), new ServerEqualityComparer());\\n\\n        for (var i = 0; i < arrival.Length; i++)\\n        {\\n            while (busyServers.Count > 0 && busyServers.ElementAt(0).Value.FreeTime <= arrival[i])\\n            {\\n                var firstServer = busyServers.First().Value;\\n                freeServers.Add(firstServer);\\n                busyServers.RemoveAt(0);\\n            }\\n\\n            if (freeServers.Count == 0)\\n            {\\n                //req dropped\\n                continue;\\n            }\\n\\n            Server freeServer = null;\\n\\n            if (freeServers.Contains(new Server { Id = i % k }))\\n            {\\n                freeServers.TryGetValue(new Server { Id = i % k }, out freeServer);\\n            }\\n            else\\n            {\\n                //first or default will do binary search if the collection is sorted\\n                freeServer = freeServers.FirstOrDefault(j => j.Id > (i % k)) ?? freeServers.Min;                    \\n            }\\n\\n            serverReqCount[freeServer.Id]++;\\n            freeServer.FreeTime = arrival[i] + load[i];\\n            busyServers.Add(freeServer.FreeTime, freeServer);\\n            freeServers.Remove(freeServer);\\n        }\\n\\n        var maxReqCount = 0;\\n        var maxReqServers = new List<int>(serverReqCount.Count);\\n\\n        foreach (var item in serverReqCount)\\n        {\\n            if (item.Value > maxReqCount)\\n            {\\n                maxReqCount = item.Value;\\n                maxReqServers = new List<int> { item.Key };\\n            }\\n            else if (item.Value == maxReqCount)\\n            {\\n                maxReqServers.Add(item.Key);\\n            }\\n        }\\n\\n        return maxReqServers;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4029615,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n public:\\n  vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n    vector<int> ans;\\n    vector<int> times(k);\\n    set<int> idleServers;\\n    // (endTime, server)\\n    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<>> minHeap;\\n\\n    for (int i = 0; i < k; ++i)\\n      idleServers.insert(i);\\n\\n    for (int i = 0; i < arrival.size(); ++i) {\\n      // Pop all servers that are available now.\\n      while (!minHeap.empty() && minHeap.top().first <= arrival[i]) {\\n        idleServers.insert(minHeap.top().second);\\n        minHeap.pop();\\n      }\\n      // Get next available server.\\n      const int server = getNextAvailableServer(idleServers, i, k);\\n      if (server == -1)\\n        continue;\\n      ++times[server];\\n      minHeap.emplace(arrival[i] + load[i], server);\\n      idleServers.erase(server);\\n    }\\n\\n    const int busiest = *max_element(times.begin(), times.end());\\n    for (int i = 0; i < k; ++i)\\n      if (times[i] == busiest)\\n        ans.push_back(i);\\n    return ans;\\n  }\\n\\n private:\\n  int getNextAvailableServer(const set<int>& idleServers, int ithRequest,\\n                             int k) {\\n    if (idleServers.empty())\\n      return -1;\\n    const auto it = idleServers.lower_bound(ithRequest % k);\\n    return it == idleServers.cend() ? *idleServers.begin() : *it;\\n  }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n public:\\n  vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n    vector<int> ans;\\n    vector<int> times(k);\\n    set<int> idleServers;\\n    // (endTime, server)\\n    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<>> minHeap;\\n\\n    for (int i = 0; i < k; ++i)\\n      idleServers.insert(i);\\n\\n    for (int i = 0; i < arrival.size(); ++i) {\\n      // Pop all servers that are available now.\\n      while (!minHeap.empty() && minHeap.top().first <= arrival[i]) {\\n        idleServers.insert(minHeap.top().second);\\n        minHeap.pop();\\n      }\\n      // Get next available server.\\n      const int server = getNextAvailableServer(idleServers, i, k);\\n      if (server == -1)\\n        continue;\\n      ++times[server];\\n      minHeap.emplace(arrival[i] + load[i], server);\\n      idleServers.erase(server);\\n    }\\n\\n    const int busiest = *max_element(times.begin(), times.end());\\n    for (int i = 0; i < k; ++i)\\n      if (times[i] == busiest)\\n        ans.push_back(i);\\n    return ans;\\n  }\\n\\n private:\\n  int getNextAvailableServer(const set<int>& idleServers, int ithRequest,\\n                             int k) {\\n    if (idleServers.empty())\\n      return -1;\\n    const auto it = idleServers.lower_bound(ithRequest % k);\\n    return it == idleServers.cend() ? *idleServers.begin() : *it;\\n  }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3991958,
                "title": "minheap-map-easily-understandable-commented-code-c-faster-than-90",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThere are few smart decisions that we need to make\\n1. Choosing set over vection for maintaining availaible servers, so that we can use the power of lower_bound directly to get the next availaible server faster (instead of linearly scanning over the next availaible server)\\n2. Using priority queue(min heap on ending time) for busy servers. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n        set <int> availaible; // We are using set to maintain currently availaible servers\\n        for(int i=0;i<k;i++) availaible.insert(i); // Currently all servers are availaible\\n\\n        vector <int> usedCount(k,0); // Used to maintain how many times given server is used\\n        priority_queue <pair <int,int>,vector <pair <int,int>>, greater <pair <int,int>>> busy; // end time,server id -> min queue\\n        \\n        for(int i=0;i<arrival.size();i++){\\n            // Making busy servers availaible whose endTime is less than current time (arrival time) \\n            while(!busy.empty() && arrival[i]>=busy.top().first){\\n                availaible.insert(busy.top().second);\\n                busy.pop();\\n            }\\n\\n            // Checking if any server is availaible, and making the candidate server busy\\n            if(availaible.size()){\\n                auto server = availaible.lower_bound(i%k);\\n                if(server==availaible.end()){\\n                    server = availaible.begin();\\n                }\\n                int serverId = *server;\\n                availaible.erase(server);\\n                int endTime = arrival[i]+load[i];\\n                usedCount[serverId]++;\\n                busy.push({endTime,serverId}); \\n            }\\n        }\\n\\n        // Finding the maximum number of time any server is used \\n        int mx = *max_element(usedCount.begin(),usedCount.end());\\n        // Adding servers in ans\\n        vector <int> ans;\\n        for(int i=0;i<usedCount.size();i++){\\n            if(usedCount[i]==mx){\\n                ans.push_back(i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n        set <int> availaible; // We are using set to maintain currently availaible servers\\n        for(int i=0;i<k;i++) availaible.insert(i); // Currently all servers are availaible\\n\\n        vector <int> usedCount(k,0); // Used to maintain how many times given server is used\\n        priority_queue <pair <int,int>,vector <pair <int,int>>, greater <pair <int,int>>> busy; // end time,server id -> min queue\\n        \\n        for(int i=0;i<arrival.size();i++){\\n            // Making busy servers availaible whose endTime is less than current time (arrival time) \\n            while(!busy.empty() && arrival[i]>=busy.top().first){\\n                availaible.insert(busy.top().second);\\n                busy.pop();\\n            }\\n\\n            // Checking if any server is availaible, and making the candidate server busy\\n            if(availaible.size()){\\n                auto server = availaible.lower_bound(i%k);\\n                if(server==availaible.end()){\\n                    server = availaible.begin();\\n                }\\n                int serverId = *server;\\n                availaible.erase(server);\\n                int endTime = arrival[i]+load[i];\\n                usedCount[serverId]++;\\n                busy.push({endTime,serverId}); \\n            }\\n        }\\n\\n        // Finding the maximum number of time any server is used \\n        int mx = *max_element(usedCount.begin(),usedCount.end());\\n        // Adding servers in ans\\n        vector <int> ans;\\n        for(int i=0;i<usedCount.size();i++){\\n            if(usedCount[i]==mx){\\n                ans.push_back(i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3928951,
                "title": "min-heap-priorityqueue-and-ordered-set-treeset-in-kotlin",
                "content": "Improved version of my [basic solution](https://leetcode.com/problems/find-servers-that-handled-most-number-of-requests/solutions/3928920/basic-brute-force-style-approach-in-kotlin-o-n-k-and-o-k/). Using an ordered set to store only the available servers and a priority queue to keep end times cuts down run time and storage significantly.\\n# Intuition\\nStore available servers in an ordered set, since the requests come in order. Keep a min heap of times when servers are going to become available again. Loop through requests and add servers to available/busy according to the time.\\n\\n# Approach\\n- Add all servers to available set.\\n- Loop through requests.\\n- If the current time is greater than the available times of servers in the busy server heap, add them to the available server set.\\n- Check if the k % i server, or the next one is available. If it is not then take the first available server. **Bonus of using ordered set**.\\n- Increment requests taken counter for the server and add it to the busy heap.\\n- Loop through requests taken and return the servers with the most.\\n\\n\\n# Complexity\\n- Time complexity: $$O(n*log(n))$$\\n\\n- Space complexity: $$O(maxOf(n, k))$$ worst case (full set/heap)\\n\\n# Code\\n```\\nclass Solution {\\n    fun busiestServers(k: Int, arrival: IntArray, load: IntArray): List<Int> {\\n        val availableServers = TreeSet<Int>() { a, b -> a - b }\\n        val busyServers = PriorityQueue<Pair<Int, Int>>() { a, b -> a.second - b.second } // Pair of (server, availableTime)\\n        val requestsTaken = IntArray(k) { 0 }\\n\\n        for (i in 0 until k) {\\n            availableServers.add(i)\\n        }\\n\\n        for (requestNumber in 0 until arrival.size) {\\n            while (busyServers.isNotEmpty() && busyServers.peek().second <= arrival[requestNumber]) {\\n                availableServers.add(busyServers.poll().first)\\n            }\\n\\n            if (availableServers.isNotEmpty()) {\\n                val server = availableServers.ceiling(requestNumber % k) ?: availableServers.first()\\n                requestsTaken[server]++\\n                availableServers.remove(server)\\n                busyServers.offer(Pair(server, arrival[requestNumber] + load[requestNumber]))\\n            }\\n        }\\n\\n        var maxLoad = 0\\n        var result = mutableListOf<Int>()\\n        for ((server, load) in requestsTaken.withIndex()) {\\n            if (load > maxLoad) {\\n                maxLoad = load\\n                result = mutableListOf(server)\\n            } else if (load == maxLoad) {\\n                result.add(server)\\n            }\\n        }\\n\\n        return result\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun busiestServers(k: Int, arrival: IntArray, load: IntArray): List<Int> {\\n        val availableServers = TreeSet<Int>() { a, b -> a - b }\\n        val busyServers = PriorityQueue<Pair<Int, Int>>() { a, b -> a.second - b.second } // Pair of (server, availableTime)\\n        val requestsTaken = IntArray(k) { 0 }\\n\\n        for (i in 0 until k) {\\n            availableServers.add(i)\\n        }\\n\\n        for (requestNumber in 0 until arrival.size) {\\n            while (busyServers.isNotEmpty() && busyServers.peek().second <= arrival[requestNumber]) {\\n                availableServers.add(busyServers.poll().first)\\n            }\\n\\n            if (availableServers.isNotEmpty()) {\\n                val server = availableServers.ceiling(requestNumber % k) ?: availableServers.first()\\n                requestsTaken[server]++\\n                availableServers.remove(server)\\n                busyServers.offer(Pair(server, arrival[requestNumber] + load[requestNumber]))\\n            }\\n        }\\n\\n        var maxLoad = 0\\n        var result = mutableListOf<Int>()\\n        for ((server, load) in requestsTaken.withIndex()) {\\n            if (load > maxLoad) {\\n                maxLoad = load\\n                result = mutableListOf(server)\\n            } else if (load == maxLoad) {\\n                result.add(server)\\n            }\\n        }\\n\\n        return result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3928920,
                "title": "basic-brute-force-style-approach-in-kotlin-o-n-k-and-o-k",
                "content": "Pretty basic first approach that came to mind. This is probably not good enough for an interview on it\\'s own, however could be a decent starting point for you to make some optimizations when asked, such as using a min heap and an ordered set instead of the IntArrays, as in my [improved solution.](https://leetcode.com/problems/find-servers-that-handled-most-number-of-requests/solutions/3928951/min-heap-priorityqueue-and-ordered-set-treeset-in-kotlin/)\\n\\n# Intuition\\nStore the time each server will be available again after a request, loop through for each request and see if it can take the request.\\n\\n# Approach\\n- Set all servers to be free at -1, so they are all able to take requests at the start.\\n- Set all of the servers requests taken to 0.\\n- Loop through requests, if the request start time is larger than the servers \"free\" time, it can take the request, so set it\\'s next available time to the time of the request + the load, and increment requests taken.\\n- Reset the server counter if it loops around all of them.\\n- Go through requests taken and return the servers with largest values.\\n\\n# Complexity\\n- Time complexity: $$O(n*k)$$\\n\\n- Space complexity: $$O(k)$$\\n\\n# Code\\n```\\nclass Solution {\\n    fun busiestServers(k: Int, arrival: IntArray, load: IntArray): List<Int> {\\n        val freeTimes = IntArray(k) { -1 }\\n        val requestsTaken = IntArray(k) { 0 }\\n\\n        for (requestNumber in 0 until arrival.size) {\\n            var i = 0\\n            var currentServer = requestNumber % k\\n            while (i < k) {\\n                if (currentServer == k) {\\n                    currentServer = 0\\n                }\\n                if (freeTimes[currentServer] <= arrival[requestNumber]) {\\n                    freeTimes[currentServer] = arrival[requestNumber] + load[requestNumber]\\n                    requestsTaken[currentServer]++\\n                    currentServer++\\n                    break\\n                }\\n                currentServer++\\n                i++\\n            }\\n        }\\n\\n        var maxLoad = 0\\n        var result = mutableListOf<Int>()\\n        for ((server, load) in requestsTaken.withIndex()) {\\n            if (load > maxLoad) {\\n                maxLoad = load\\n                result = mutableListOf(server)\\n            } else if (load == maxLoad) {\\n                result.add(server)\\n            }\\n        }\\n\\n        return result\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun busiestServers(k: Int, arrival: IntArray, load: IntArray): List<Int> {\\n        val freeTimes = IntArray(k) { -1 }\\n        val requestsTaken = IntArray(k) { 0 }\\n\\n        for (requestNumber in 0 until arrival.size) {\\n            var i = 0\\n            var currentServer = requestNumber % k\\n            while (i < k) {\\n                if (currentServer == k) {\\n                    currentServer = 0\\n                }\\n                if (freeTimes[currentServer] <= arrival[requestNumber]) {\\n                    freeTimes[currentServer] = arrival[requestNumber] + load[requestNumber]\\n                    requestsTaken[currentServer]++\\n                    currentServer++\\n                    break\\n                }\\n                currentServer++\\n                i++\\n            }\\n        }\\n\\n        var maxLoad = 0\\n        var result = mutableListOf<Int>()\\n        for ((server, load) in requestsTaken.withIndex()) {\\n            if (load > maxLoad) {\\n                maxLoad = load\\n                result = mutableListOf(server)\\n            } else if (load == maxLoad) {\\n                result.add(server)\\n            }\\n        }\\n\\n        return result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3898171,
                "title": "c-greedy-easy-solution-priority-queue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis is similar to meeting rooms III question. We can use set, priority queue and map to solve this question. Solve this using greedy approach.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTry to break the solution in smaller parts and you will be able to solve it easily.\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n        \\n        int n = arrival.size();\\n        vector<int> endTime(n);\\n        for(int i=0;i<n;i++)\\n            endTime[i] = arrival[i] + load[i];\\n\\n        //(endTime,serverNo)\\n\\n        priority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>>> trackRequests;\\n        set<int> unusedServers;\\n        unordered_map<int,int> freq;        \\n\\n        for(int i=0;i<k;i++)\\n            unusedServers.insert(i);\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            int start = arrival[i];\\n            int end = endTime[i];\\n\\n            // remove all the requests that has been done\\n            while(!trackRequests.empty() && trackRequests.top().first<=start)\\n            {\\n                unusedServers.insert(trackRequests.top().second);\\n                trackRequests.pop();\\n            }\\n\\n            int assignServer = i%k;\\n            if(unusedServers.find(assignServer)!=unusedServers.end())\\n            {\\n                unusedServers.erase(assignServer);\\n                trackRequests.push({end, assignServer});\\n                freq[assignServer]++;\\n            }\\n            else\\n            {\\n                if(unusedServers.size()==0)\\n                {\\n                    // all servers are busy\\n                    continue;\\n                }\\n                else\\n                {\\n                    auto lb = unusedServers.lower_bound(assignServer);\\n                    if(lb==unusedServers.end())\\n                    {\\n                        auto lb_start = unusedServers.lower_bound(0);\\n                        int newGivenServer = *lb_start;\\n                        unusedServers.erase(newGivenServer);\\n                        trackRequests.push({end, newGivenServer});\\n                        freq[newGivenServer]++;\\n                    }\\n                    else\\n                    {\\n                        int newGivenServer = *lb;\\n                        unusedServers.erase(newGivenServer);\\n                        trackRequests.push({end, newGivenServer});\\n                        freq[newGivenServer]++;\\n                    }\\n                }\\n            }\\n        }\\n\\n        int maxValue = 0;\\n        vector<int> server;\\n\\n        for(auto m: freq)\\n            maxValue = max(maxValue, m.second);\\n        \\n        for(auto m: freq)\\n        {\\n            if(m.second == maxValue)\\n                server.push_back(m.first);\\n        }\\n\\n        return server;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n        \\n        int n = arrival.size();\\n        vector<int> endTime(n);\\n        for(int i=0;i<n;i++)\\n            endTime[i] = arrival[i] + load[i];\\n\\n        //(endTime,serverNo)\\n\\n        priority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>>> trackRequests;\\n        set<int> unusedServers;\\n        unordered_map<int,int> freq;        \\n\\n        for(int i=0;i<k;i++)\\n            unusedServers.insert(i);\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            int start = arrival[i];\\n            int end = endTime[i];\\n\\n            // remove all the requests that has been done\\n            while(!trackRequests.empty() && trackRequests.top().first<=start)\\n            {\\n                unusedServers.insert(trackRequests.top().second);\\n                trackRequests.pop();\\n            }\\n\\n            int assignServer = i%k;\\n            if(unusedServers.find(assignServer)!=unusedServers.end())\\n            {\\n                unusedServers.erase(assignServer);\\n                trackRequests.push({end, assignServer});\\n                freq[assignServer]++;\\n            }\\n            else\\n            {\\n                if(unusedServers.size()==0)\\n                {\\n                    // all servers are busy\\n                    continue;\\n                }\\n                else\\n                {\\n                    auto lb = unusedServers.lower_bound(assignServer);\\n                    if(lb==unusedServers.end())\\n                    {\\n                        auto lb_start = unusedServers.lower_bound(0);\\n                        int newGivenServer = *lb_start;\\n                        unusedServers.erase(newGivenServer);\\n                        trackRequests.push({end, newGivenServer});\\n                        freq[newGivenServer]++;\\n                    }\\n                    else\\n                    {\\n                        int newGivenServer = *lb;\\n                        unusedServers.erase(newGivenServer);\\n                        trackRequests.push({end, newGivenServer});\\n                        freq[newGivenServer]++;\\n                    }\\n                }\\n            }\\n        }\\n\\n        int maxValue = 0;\\n        vector<int> server;\\n\\n        for(auto m: freq)\\n            maxValue = max(maxValue, m.second);\\n        \\n        for(auto m: freq)\\n        {\\n            if(m.second == maxValue)\\n                server.push_back(m.first);\\n        }\\n\\n        return server;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3856231,
                "title": "java-o-nlog-n-treeset-priorityqueue",
                "content": "# Code\\n```\\nclass Solution {\\n    public List<Integer> busiestServers(int k, int[] arrival, int[] load) {\\n        TreeSet<Integer> available = new TreeSet();\\n        for (int i = 0; i < k; i++) {\\n            available.add(i);\\n        }\\n\\n        int[] count = new int[k];\\n        int max = 0;\\n\\n        // 0 => end time\\n        // 1 => server index\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((int[] v1, int[] v2) -> Integer.compare(v1[0], v2[0]));\\n\\n        for (int i = 0; i < arrival.length; i++) {\\n            \\n            int time = arrival[i];\\n            int l = load[i];\\n\\n            while ( ! pq.isEmpty() && pq.peek()[0] <= time) {\\n                available.add(pq.poll()[1]);\\n            }\\n\\n            if (available.size() == 0) {\\n                continue;\\n            }\\n\\n            Integer si = available.ceiling(i % k);\\n            if (si == null) {\\n                si = available.first();\\n            }\\n            available.remove(si);\\n\\n            pq.add(new int[]{time + l, si});\\n            count[si]++;\\n            max = Math.max(max, count[si]);\\n        }\\n\\n        List<Integer> res = new ArrayList<>();\\n        for (int i = 0; i < k; i++) {\\n            if (count[i] == max) {\\n                res.add(i);\\n            }\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> busiestServers(int k, int[] arrival, int[] load) {\\n        TreeSet<Integer> available = new TreeSet();\\n        for (int i = 0; i < k; i++) {\\n            available.add(i);\\n        }\\n\\n        int[] count = new int[k];\\n        int max = 0;\\n\\n        // 0 => end time\\n        // 1 => server index\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((int[] v1, int[] v2) -> Integer.compare(v1[0], v2[0]));\\n\\n        for (int i = 0; i < arrival.length; i++) {\\n            \\n            int time = arrival[i];\\n            int l = load[i];\\n\\n            while ( ! pq.isEmpty() && pq.peek()[0] <= time) {\\n                available.add(pq.poll()[1]);\\n            }\\n\\n            if (available.size() == 0) {\\n                continue;\\n            }\\n\\n            Integer si = available.ceiling(i % k);\\n            if (si == null) {\\n                si = available.first();\\n            }\\n            available.remove(si);\\n\\n            pq.add(new int[]{time + l, si});\\n            count[si]++;\\n            max = Math.max(max, count[si]);\\n        }\\n\\n        List<Integer> res = new ArrayList<>();\\n        for (int i = 0; i < k; i++) {\\n            if (count[i] == max) {\\n                res.add(i);\\n            }\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3837770,
                "title": "easy-cpp-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int min(int a, int b)\\n    {\\n        if(a<b)\\n            return a;\\n        return b;\\n    }\\n    vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n        /*\\n\\n        3 servers are present...\\n        time OF ARRIVAL OF requests are 1,2,3,4,5\\n\\n        at time 1 : server 1 is blocked\\n        at time 2 : server 2 is blocked\\n        at time 3 : server 3 is blocked\\n        at time 4 : server 2 is used (1 --> 4 over, 2--> empty , 3--> 2 time over)\\n        at time 5 : No server is empty, so dropped..\\n\\n        server 1 and 3 handled only ONE request... Server 2 handled 2 requests\\n\\n        so server 2 is the ans...\\n\\n        */\\n\\n        vector<int> cnt(k+1,0);\\n        set<int> freeServers;\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> pq;\\n        for(int i=0;i<min(k,arrival.size());i++){\\n            pq.push({arrival[i]+load[i], i});\\n            cnt[i]++;\\n        }\\n\\n        for(int i=k;i<arrival.size();i++)\\n        {\\n            if(freeServers.size() || (pq.size() && arrival[i]>=pq.top().first))\\n            {\\n                while(pq.size() && arrival[i]>=pq.top().first){\\n                    freeServers.insert(pq.top().second);\\n                    pq.pop();\\n                }\\n                set<int> :: iterator nearestServer;\\n                nearestServer = lower_bound(freeServers.begin(),freeServers.end(),i%k);\\n                if(nearestServer==freeServers.end())\\n                    nearestServer = freeServers.begin();\\n                \\n                int curr = *nearestServer;\\n                cnt[curr]++;\\n                pq.push({arrival[i]+load[i],curr});\\n                freeServers.erase(nearestServer);\\n            }\\n        }\\n\\n        int maxi = -1;\\n        for(int i=0;i<k;i++)\\n            maxi = max(maxi,cnt[i]);\\n        \\n        vector<int> res;\\n        for(int i=0;i<k;i++)\\n        {\\n            if(cnt[i]==maxi)\\n                res.push_back(i);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int min(int a, int b)\\n    {\\n        if(a<b)\\n            return a;\\n        return b;\\n    }\\n    vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n        /*\\n\\n        3 servers are present...\\n        time OF ARRIVAL OF requests are 1,2,3,4,5\\n\\n        at time 1 : server 1 is blocked\\n        at time 2 : server 2 is blocked\\n        at time 3 : server 3 is blocked\\n        at time 4 : server 2 is used (1 --> 4 over, 2--> empty , 3--> 2 time over)\\n        at time 5 : No server is empty, so dropped..\\n\\n        server 1 and 3 handled only ONE request... Server 2 handled 2 requests\\n\\n        so server 2 is the ans...\\n\\n        */\\n\\n        vector<int> cnt(k+1,0);\\n        set<int> freeServers;\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> pq;\\n        for(int i=0;i<min(k,arrival.size());i++){\\n            pq.push({arrival[i]+load[i], i});\\n            cnt[i]++;\\n        }\\n\\n        for(int i=k;i<arrival.size();i++)\\n        {\\n            if(freeServers.size() || (pq.size() && arrival[i]>=pq.top().first))\\n            {\\n                while(pq.size() && arrival[i]>=pq.top().first){\\n                    freeServers.insert(pq.top().second);\\n                    pq.pop();\\n                }\\n                set<int> :: iterator nearestServer;\\n                nearestServer = lower_bound(freeServers.begin(),freeServers.end(),i%k);\\n                if(nearestServer==freeServers.end())\\n                    nearestServer = freeServers.begin();\\n                \\n                int curr = *nearestServer;\\n                cnt[curr]++;\\n                pq.push({arrival[i]+load[i],curr});\\n                freeServers.erase(nearestServer);\\n            }\\n        }\\n\\n        int maxi = -1;\\n        for(int i=0;i<k;i++)\\n            maxi = max(maxi,cnt[i]);\\n        \\n        vector<int> res;\\n        for(int i=0;i<k;i++)\\n        {\\n            if(cnt[i]==maxi)\\n                res.push_back(i);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3749727,
                "title": "java-solution-using-treeset-and-priorityqueue",
                "content": "\\n\\n# Approach\\nWe want to maintain two pools of servers - a busy pool and an available pool. Every time a request comes in, we will first check which servers in our busy pool become available. Then we iterate over the available pool starting from i % k and wrapping around until we find a free server. Then this server is transferred from our available pool to the busy pool. We model the available pool as a sorted set so we can quickly answer queries of the form give me the id right after x. The busy pool is modelled as priority queue with key being the finishing time of currently processing request. Once a request arrives (i.e. we iterate to it), then we go over our busy pool to remove servers which stopped processing before the arrival time of the current request and transfer it to the available pool. Once available pool is updated, we assign a server to it. \\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(nlogk)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(k)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    class server{\\n        int id;\\n        int busyTime;\\n        public server(int i,int t){\\n            id=i;\\n            busyTime=t;\\n        }\\n    }\\n    public List<Integer> busiestServers(int k, int[] arrival, int[] load) {\\n        // treeset is used to find next avalible server (using celling method) in case default server is not avalible\\n        TreeSet<Integer> available=new TreeSet<>();\\n        // to keep track of server that become avalible at cur arival time we will keep them in sorted order of busyTime\\n        PriorityQueue<server> busy=new PriorityQueue<>((a,b)->{\\n            return Integer.compare(a.busyTime,b.busyTime);\\n        });\\n        // to keep track of number request handled by each server to find bussiest server finally\\n        int[] requestCount=new int[k];\\n        int n=arrival.length;\\n        for(int id=0;id<k;id++){\\n            available.add(id);\\n        }\\n\\n\\n        for(int i=0;i<arrival.length;i++){\\n            int defaultServer=i%k;\\n            // remove available server from busyQueue which has busyTime less then cur arrival time\\n            while(!busy.isEmpty() && busy.peek().busyTime<=arrival[i]){\\n                server top=busy.poll();\\n                available.add(top.id);\\n            }\\n\\n            // if there is no available server then we will drop this request\\n            if(available.isEmpty()) continue;\\n\\n            // find nextServer available from available treeSet  ceiling will return next value present that is greater or equal to cur number if no number then it will return null to store null we will use wrapper class Integer\\n            Integer nextServer=available.ceiling(defaultServer);\\n            nextServer=(nextServer!=null)?nextServer:available.ceiling(0);\\n\\n            int requestEnd=arrival[i]+load[i];\\n\\n            available.remove(nextServer);\\n            busy.add(new server(nextServer,requestEnd));\\n            requestCount[nextServer]++;\\n        }\\n\\n\\n        int maxRequests=Integer.MIN_VALUE;\\n        List<Integer> busiestServer=new ArrayList<>();\\n        for(int id=0;id<k;id++){\\n            maxRequests=Math.max(maxRequests,requestCount[id]);\\n        }\\n        for(int id=0;id<k;id++){\\n            if(maxRequests==requestCount[id]){\\n                busiestServer.add(id);\\n            }\\n        }\\n        return busiestServer;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    class server{\\n        int id;\\n        int busyTime;\\n        public server(int i,int t){\\n            id=i;\\n            busyTime=t;\\n        }\\n    }\\n    public List<Integer> busiestServers(int k, int[] arrival, int[] load) {\\n        // treeset is used to find next avalible server (using celling method) in case default server is not avalible\\n        TreeSet<Integer> available=new TreeSet<>();\\n        // to keep track of server that become avalible at cur arival time we will keep them in sorted order of busyTime\\n        PriorityQueue<server> busy=new PriorityQueue<>((a,b)->{\\n            return Integer.compare(a.busyTime,b.busyTime);\\n        });\\n        // to keep track of number request handled by each server to find bussiest server finally\\n        int[] requestCount=new int[k];\\n        int n=arrival.length;\\n        for(int id=0;id<k;id++){\\n            available.add(id);\\n        }\\n\\n\\n        for(int i=0;i<arrival.length;i++){\\n            int defaultServer=i%k;\\n            // remove available server from busyQueue which has busyTime less then cur arrival time\\n            while(!busy.isEmpty() && busy.peek().busyTime<=arrival[i]){\\n                server top=busy.poll();\\n                available.add(top.id);\\n            }\\n\\n            // if there is no available server then we will drop this request\\n            if(available.isEmpty()) continue;\\n\\n            // find nextServer available from available treeSet  ceiling will return next value present that is greater or equal to cur number if no number then it will return null to store null we will use wrapper class Integer\\n            Integer nextServer=available.ceiling(defaultServer);\\n            nextServer=(nextServer!=null)?nextServer:available.ceiling(0);\\n\\n            int requestEnd=arrival[i]+load[i];\\n\\n            available.remove(nextServer);\\n            busy.add(new server(nextServer,requestEnd));\\n            requestCount[nextServer]++;\\n        }\\n\\n\\n        int maxRequests=Integer.MIN_VALUE;\\n        List<Integer> busiestServer=new ArrayList<>();\\n        for(int id=0;id<k;id++){\\n            maxRequests=Math.max(maxRequests,requestCount[id]);\\n        }\\n        for(int id=0;id<k;id++){\\n            if(maxRequests==requestCount[id]){\\n                busiestServer.add(id);\\n            }\\n        }\\n        return busiestServer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3573593,
                "title": "servers-with-most-number-of-handled-requests-c-explained-solution",
                "content": "***Upvote If Found Helpful !!!***\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe problem here is quite interesting and needs bit of observation. The pre-requisite for this question is **heaps**. We can also solve this problem through C++ **sets**. Let\\'s move towards the problem. Now initially we know that all servers are free. In order to keep track of which servers are free, we can easily maintain a set. Now to keep track of ending time of job requests and to update the free servers, we use **priority queue (min heap)** of type pair with ending time and the server handling that job. Now whenever a new request comes in, just check all the servers that can be freed. After this, find the next available server as asked in the problem. One can see that using sets for holding free servers helps us to use lower bound to get next available free server in logarithmic time. If free does not contains any free servers, then automatically that request would not be handled. At the end, just find the maximum number of requests handled and their corresponding servers. The implementation of above logic goes below : \\n\\n# Complexity\\n- Time complexity: **O(N*logK)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(K)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n        ios_base::sync_with_stdio(0);\\n        vector<int>busy(k,0);\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>pq;\\n        int n = load.size(); set<int>free;\\n        for(int i = 0; i < k; i++){\\n            free.insert(i);\\n        }\\n        for(int i = 0; i < n; i++){\\n            int end_time = arrival[i] + load[i];\\n            while(!pq.empty() && pq.top().first <= arrival[i]){\\n                free.insert(pq.top().second);\\n                pq.pop();\\n            }\\n            if(free.size()){\\n                set<int>::iterator iter;\\n                iter = free.lower_bound(i % k);\\n                if(iter == free.end()){\\n                    iter = free.begin();\\n                }\\n                int u = *iter;\\n                busy[u]++;\\n                pq.push({end_time,u});\\n                free.erase(u);\\n            }\\n        }\\n        int max_load = *max_element(busy.begin(),busy.end());\\n        vector<int>ans;\\n        for(int i = 0; i < k; i++){\\n            if(busy[i] == max_load){\\n                ans.push_back(i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n        ios_base::sync_with_stdio(0);\\n        vector<int>busy(k,0);\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>pq;\\n        int n = load.size(); set<int>free;\\n        for(int i = 0; i < k; i++){\\n            free.insert(i);\\n        }\\n        for(int i = 0; i < n; i++){\\n            int end_time = arrival[i] + load[i];\\n            while(!pq.empty() && pq.top().first <= arrival[i]){\\n                free.insert(pq.top().second);\\n                pq.pop();\\n            }\\n            if(free.size()){\\n                set<int>::iterator iter;\\n                iter = free.lower_bound(i % k);\\n                if(iter == free.end()){\\n                    iter = free.begin();\\n                }\\n                int u = *iter;\\n                busy[u]++;\\n                pq.push({end_time,u});\\n                free.erase(u);\\n            }\\n        }\\n        int max_load = *max_element(busy.begin(),busy.end());\\n        vector<int>ans;\\n        for(int i = 0; i < k; i++){\\n            if(busy[i] == max_load){\\n                ans.push_back(i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3435372,
                "title": "intuitive-straightforward-solution-with-binary-search-tree-in-python-with-explaination",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis problem can be solved by using heaps with some tricky properties. The heap solution is good and smart, but less intuitive and not that easy to understand. Fortunately, this problem can also be solved in a very intuitive approach in the same time complexity  by using an ordered container. In Python, we can happily employ the powerful `SortedList` or `SortedSet` in this problem. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThis straightforward solution maintains a priority queue (i.e., `heapq`) for the requests under processing and a table for the available servers by using `SortedSet`. At each time step, we clean done requests from the queue for freeing servers. Then, we look up the available server for the arrival request. When a server is found, we assign the request to the server, and update the priority queue and the `SortedSet` accordingly.  \\n\\nLike a balanced binary search tree, the operations including adding a server, removing a server, and finding a server can be performed in $$O(\\\\log k)$$ with `SortedSet`, where $$k$$ is the number of servers. \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTime complexity is $$O(n \\\\log k)$$ where $$n$$ is the number of requests and $$k$$ is the number of servers. Note that the complexity of this solution is the same as the heap solution. The heap solution is faster due to its less overhead, but this solution is more straightforward and easy to understand. \\n\\n# Code\\n```\\nfrom sortedcontainers import SortedSet\\nclass Solution:\\n    def busiestServers(self, k: int, arrival: List[int], load: List[int]) -> List[int]:\\n        requests = []\\n        servers = SortedSet(range(k))\\n        counter = defaultdict(int)\\n        for i, (t, d) in enumerate(zip(arrival, load)):\\n            while len(requests) and requests[0][0] <= t:\\n                servers.add(requests[0][1])\\n                heapq.heappop(requests)\\n            if len(servers) == 0:\\n                continue\\n            p = servers.bisect_left(i % k)\\n            server = servers[p] if p < len(servers) else servers[0]\\n            servers.remove(server)\\n            heapq.heappush(requests, (t+d, server))\\n            counter[server] += 1\\n        max_loads = max(counter.values())\\n        return [s for s, c in counter.items() if c == max_loads]\\n```",
                "solutionTags": [
                    "Python3",
                    "Binary Search Tree",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nfrom sortedcontainers import SortedSet\\nclass Solution:\\n    def busiestServers(self, k: int, arrival: List[int], load: List[int]) -> List[int]:\\n        requests = []\\n        servers = SortedSet(range(k))\\n        counter = defaultdict(int)\\n        for i, (t, d) in enumerate(zip(arrival, load)):\\n            while len(requests) and requests[0][0] <= t:\\n                servers.add(requests[0][1])\\n                heapq.heappop(requests)\\n            if len(servers) == 0:\\n                continue\\n            p = servers.bisect_left(i % k)\\n            server = servers[p] if p < len(servers) else servers[0]\\n            servers.remove(server)\\n            heapq.heappush(requests, (t+d, server))\\n            counter[server] += 1\\n        max_loads = max(counter.values())\\n        return [s for s, c in counter.items() if c == max_loads]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421432,
                "title": "my-solution",
                "content": "```\\n/**\\n * Time Complexity: O(n_requests * log(k))\\n * Space Complexity: O(k)\\n * where `n_requests` is the length of the vector `arrival`\\n */\\nclass Solution {\\n public:\\n  vector<int> busiestServers(const int k,\\n                             const vector<int> &arrival,\\n                             const vector<int> &load) {\\n    using pq_node_t = pair<int, int>;   // {the server, the available time of the server}\\n    set<int> available_servers;\\n    for (int server = 0; server < k; ++server) {\\n      available_servers.emplace(server);\\n    }\\n    \\n    auto compare = [](const pq_node_t &lhs, const pq_node_t &rhs) -> bool {\\n      return !(lhs.second < rhs.second);\\n    };\\n    priority_queue<pq_node_t, vector<pq_node_t>, decltype(compare)> pq_busy_servers(compare);\\n    \\n    int used_times[k];\\n    memset(used_times, 0, sizeof(used_times));\\n    \\n    const int n_requests = static_cast<int>(arrival.size());\\n    for (int request = 0; request < n_requests; ++request) {\\n      const int request_arrival_time = arrival[request];\\n      const int request_completed_time = arrival[request] + load[request];\\n      while (!pq_busy_servers.empty() && pq_busy_servers.top().second <= request_arrival_time) {\\n        available_servers.emplace(pq_busy_servers.top().first);\\n        pq_busy_servers.pop();\\n      }\\n      \\n      if (available_servers.empty()) {\\n        continue;\\n      }\\n      \\n      const int target_server = request % k;\\n      auto lb = available_servers.lower_bound(target_server);\\n      if (lb == available_servers.end()) {\\n        lb = available_servers.begin();\\n      }\\n      ++used_times[*lb];\\n      pq_busy_servers.emplace(*lb, request_completed_time);\\n      available_servers.erase(lb);\\n    }\\n    \\n    int max_times = 0;\\n    vector<int> ret;\\n    for (int server = 0; server < k; ++server) {\\n      if (used_times[server] >= max_times) {\\n        if (used_times[server] > max_times) {\\n          max_times = used_times[server];\\n          ret.clear();\\n        }\\n        ret.emplace_back(server);\\n      }\\n    }\\n    return ret;\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Time Complexity: O(n_requests * log(k))\\n * Space Complexity: O(k)\\n * where `n_requests` is the length of the vector `arrival`\\n */\\nclass Solution {\\n public:\\n  vector<int> busiestServers(const int k,\\n                             const vector<int> &arrival,\\n                             const vector<int> &load) {\\n    using pq_node_t = pair<int, int>;   // {the server, the available time of the server}\\n    set<int> available_servers;\\n    for (int server = 0; server < k; ++server) {\\n      available_servers.emplace(server);\\n    }\\n    \\n    auto compare = [](const pq_node_t &lhs, const pq_node_t &rhs) -> bool {\\n      return !(lhs.second < rhs.second);\\n    };\\n    priority_queue<pq_node_t, vector<pq_node_t>, decltype(compare)> pq_busy_servers(compare);\\n    \\n    int used_times[k];\\n    memset(used_times, 0, sizeof(used_times));\\n    \\n    const int n_requests = static_cast<int>(arrival.size());\\n    for (int request = 0; request < n_requests; ++request) {\\n      const int request_arrival_time = arrival[request];\\n      const int request_completed_time = arrival[request] + load[request];\\n      while (!pq_busy_servers.empty() && pq_busy_servers.top().second <= request_arrival_time) {\\n        available_servers.emplace(pq_busy_servers.top().first);\\n        pq_busy_servers.pop();\\n      }\\n      \\n      if (available_servers.empty()) {\\n        continue;\\n      }\\n      \\n      const int target_server = request % k;\\n      auto lb = available_servers.lower_bound(target_server);\\n      if (lb == available_servers.end()) {\\n        lb = available_servers.begin();\\n      }\\n      ++used_times[*lb];\\n      pq_busy_servers.emplace(*lb, request_completed_time);\\n      available_servers.erase(lb);\\n    }\\n    \\n    int max_times = 0;\\n    vector<int> ret;\\n    for (int server = 0; server < k; ++server) {\\n      if (used_times[server] >= max_times) {\\n        if (used_times[server] > max_times) {\\n          max_times = used_times[server];\\n          ret.clear();\\n        }\\n        ret.emplace_back(server);\\n      }\\n    }\\n    return ret;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3388719,
                "title": "c",
                "content": "```\\nusing PII = pair<int, int> ;  //{endtime, id}\\nclass Solution {\\npublic:\\n    vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n        vector<int>count(k) ;\\n        set<int>canUseServer ;\\n        priority_queue<PII, vector<PII>, greater<PII>>busyPQ ;\\n        for(int i = 0; i < k; i++)\\n            canUseServer.insert(i) ;    \\n        for(int i = 0; i < arrival.size(); i++)\\n        {\\n            int start =  arrival[i] ;\\n            int end = start + load[i] ;\\n            while(!busyPQ.empty() && busyPQ.top().first <= start)\\n            {\\n                int id = busyPQ.top().second ;\\n                busyPQ.pop() ;\\n                canUseServer.insert(id) ;\\n            }\\n            if(canUseServer.empty())\\n                continue ;\\n            \\n            auto it = canUseServer.lower_bound(i%k) ;\\n            \\n            if(it == canUseServer.end())\\n                it = canUseServer.begin() ;\\n            \\n            int id = *it ;\\n            canUseServer.erase(id) ;\\n            count[id]++ ;\\n            busyPQ.push({end, id}) ;\\n        }\\n        vector<int>ret ;\\n        auto it = max_element(count.begin(), count.end()) ;\\n        int maxCount = *it;\\n        \\n        for(auto iter = it ; iter != count.end(); iter++){\\n            if(*iter == maxCount)\\n                ret.push_back(iter - count.begin()) ;\\n        }\\n        return ret ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Heap (Priority Queue)",
                    "Ordered Set"
                ],
                "code": "```\\nusing PII = pair<int, int> ;  //{endtime, id}\\nclass Solution {\\npublic:\\n    vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n        vector<int>count(k) ;\\n        set<int>canUseServer ;\\n        priority_queue<PII, vector<PII>, greater<PII>>busyPQ ;\\n        for(int i = 0; i < k; i++)\\n            canUseServer.insert(i) ;    \\n        for(int i = 0; i < arrival.size(); i++)\\n        {\\n            int start =  arrival[i] ;\\n            int end = start + load[i] ;\\n            while(!busyPQ.empty() && busyPQ.top().first <= start)\\n            {\\n                int id = busyPQ.top().second ;\\n                busyPQ.pop() ;\\n                canUseServer.insert(id) ;\\n            }\\n            if(canUseServer.empty())\\n                continue ;\\n            \\n            auto it = canUseServer.lower_bound(i%k) ;\\n            \\n            if(it == canUseServer.end())\\n                it = canUseServer.begin() ;\\n            \\n            int id = *it ;\\n            canUseServer.erase(id) ;\\n            count[id]++ ;\\n            busyPQ.push({end, id}) ;\\n        }\\n        vector<int>ret ;\\n        auto it = max_element(count.begin(), count.end()) ;\\n        int maxCount = *it;\\n        \\n        for(auto iter = it ; iter != count.end(); iter++){\\n            if(*iter == maxCount)\\n                ret.push_back(iter - count.begin()) ;\\n        }\\n        return ret ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3306223,
                "title": "python3-binary-search-tree-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nUsing Binary search Tree though it looks big logic is pretty simple for all operations\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass BSTNode:\\n    def __init__(self,val,left=None,right=None):\\n        self.val = val\\n        self.leftCount,self.rightCount = 0,0\\n        self.there = True\\n        self.left = left\\n        #self.par = None\\n        self.right = right\\n\\nclass Tree:\\n    def __init__(self,k):\\n        self.root = self.makingTree(0,k-1)[0]\\n\\n    \\n    def makingTree(self,i,j):\\n        if j<i:return None,0\\n        mid = (i+j)//2\\n        l,r = self.makingTree(i,mid-1),self.makingTree(mid+1,j)\\n        root = BSTNode(mid,l[0],r[0])\\n        root.leftCount = l[1]\\n        root.rightCount = r[1]\\n        return root,1+root.leftCount+root.rightCount\\n\\n    def findBetterLeastThan(self,val):\\n        a = float(\\'inf\\')\\n        temp = self.root\\n        while temp.val!=val:\\n            if temp.val>val:\\n                a = min(a,self.findLeast(temp))\\n                temp = temp.left\\n            else:temp = temp.right\\n        a = min(a,self.findLeast(temp))\\n        return a\\n    \\n    def findLeast(self,node):\\n        ans = float(\\'inf\\')\\n        if node.there:return node.val\\n        temp = node.right\\n        while temp:\\n            if temp.there:\\n                ans = min(ans,temp.val)\\n            if temp.leftCount:\\n                temp = temp.left\\n            elif temp.rightCount:\\n                temp = temp.right\\n            else:break\\n        return ans\\n\\n    def abbaLeast(self):\\n        ans = float(\\'inf\\')\\n        temp = self.root\\n        while temp:\\n            if temp.there:\\n                ans = min(ans,temp.val)\\n            if temp.leftCount:\\n                temp = temp.left\\n            elif temp.rightCount:\\n                temp = temp.right\\n            else:break\\n        return ans\\n\\n    def allotNode(self,val):\\n        temp = self.root\\n        while temp.val!=val:\\n            if temp.val<val:\\n                temp.rightCount -= 1\\n                temp = temp.right\\n            else:\\n                temp.leftCount -= 1\\n                temp = temp.left\\n        temp.there = False\\n\\n    def freeNode(self,val):\\n        temp = self.root\\n        while temp.val!=val:\\n            if temp.val<val:\\n                temp.rightCount += 1\\n                temp = temp.right\\n            else:\\n                temp.leftCount += 1\\n                temp = temp.left\\n        temp.there = True\\n\\n    def getAlloted(self,val):\\n        a = self.findBetterLeastThan(val)\\n        if a==float(\\'inf\\'):\\n            a = self.abbaLeast()\\n        if a!=float(\\'inf\\'):\\n            self.allotNode(a)\\n            return a\\n        return -1\\n    \\n    def printTree(self):\\n        arr = []\\n        def getThis(root=self.root):\\n            if not root:return\\n            getThis(root.left)\\n            arr.append([root.val,root.there])\\n            getThis(root.right)\\n        getThis()\\n        print(arr)\\n    \\n    \\nfrom collections import defaultdict\\nclass Solution:\\n    def busiestServers(self, k: int, arrival: List[int], load: List[int]) -> List[int]:\\n        freeAt = defaultdict(list)\\n        count = [0]*k\\n        arr = set()\\n        allotments = defaultdict(lambda:-1)\\n        for i in range(len(arrival)):\\n            arr.add(arrival[i])\\n            allotments[arrival[i]] = i\\n            arr.add(arrival[i]+load[i])\\n        arr = sorted(list(arr))\\n        root = Tree(k)\\n        for i in arr:\\n            for node in freeAt[i]:\\n                root.freeNode(node)\\n            if allotments[i]+1:\\n                comp = root.getAlloted(allotments[i]%k)\\n                #print(allotments[i],allotments[i]%k,i,arrival[allotments[i]]+load[allotments[i]],comp)\\n                #if i==94:root.printTree()\\n                if comp+1:\\n                    count[comp]+=1\\n                    freeAt[arrival[allotments[i]]+load[allotments[i]]].append(comp)\\n        go = max(count)\\n        ans = []\\n        #print(arr)\\n        for i in range(len(count)):\\n            if count[i]==go:ans.append(i)\\n        #print(count)\\n        return ans\\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Binary Search Tree"
                ],
                "code": "```\\nclass BSTNode:\\n    def __init__(self,val,left=None,right=None):\\n        self.val = val\\n        self.leftCount,self.rightCount = 0,0\\n        self.there = True\\n        self.left = left\\n        #self.par = None\\n        self.right = right\\n\\nclass Tree:\\n    def __init__(self,k):\\n        self.root = self.makingTree(0,k-1)[0]\\n\\n    \\n    def makingTree(self,i,j):\\n        if j<i:return None,0\\n        mid = (i+j)//2\\n        l,r = self.makingTree(i,mid-1),self.makingTree(mid+1,j)\\n        root = BSTNode(mid,l[0],r[0])\\n        root.leftCount = l[1]\\n        root.rightCount = r[1]\\n        return root,1+root.leftCount+root.rightCount\\n\\n    def findBetterLeastThan(self,val):\\n        a = float(\\'inf\\')\\n        temp = self.root\\n        while temp.val!=val:\\n            if temp.val>val:\\n                a = min(a,self.findLeast(temp))\\n                temp = temp.left\\n            else:temp = temp.right\\n        a = min(a,self.findLeast(temp))\\n        return a\\n    \\n    def findLeast(self,node):\\n        ans = float(\\'inf\\')\\n        if node.there:return node.val\\n        temp = node.right\\n        while temp:\\n            if temp.there:\\n                ans = min(ans,temp.val)\\n            if temp.leftCount:\\n                temp = temp.left\\n            elif temp.rightCount:\\n                temp = temp.right\\n            else:break\\n        return ans\\n\\n    def abbaLeast(self):\\n        ans = float(\\'inf\\')\\n        temp = self.root\\n        while temp:\\n            if temp.there:\\n                ans = min(ans,temp.val)\\n            if temp.leftCount:\\n                temp = temp.left\\n            elif temp.rightCount:\\n                temp = temp.right\\n            else:break\\n        return ans\\n\\n    def allotNode(self,val):\\n        temp = self.root\\n        while temp.val!=val:\\n            if temp.val<val:\\n                temp.rightCount -= 1\\n                temp = temp.right\\n            else:\\n                temp.leftCount -= 1\\n                temp = temp.left\\n        temp.there = False\\n\\n    def freeNode(self,val):\\n        temp = self.root\\n        while temp.val!=val:\\n            if temp.val<val:\\n                temp.rightCount += 1\\n                temp = temp.right\\n            else:\\n                temp.leftCount += 1\\n                temp = temp.left\\n        temp.there = True\\n\\n    def getAlloted(self,val):\\n        a = self.findBetterLeastThan(val)\\n        if a==float(\\'inf\\'):\\n            a = self.abbaLeast()\\n        if a!=float(\\'inf\\'):\\n            self.allotNode(a)\\n            return a\\n        return -1\\n    \\n    def printTree(self):\\n        arr = []\\n        def getThis(root=self.root):\\n            if not root:return\\n            getThis(root.left)\\n            arr.append([root.val,root.there])\\n            getThis(root.right)\\n        getThis()\\n        print(arr)\\n    \\n    \\nfrom collections import defaultdict\\nclass Solution:\\n    def busiestServers(self, k: int, arrival: List[int], load: List[int]) -> List[int]:\\n        freeAt = defaultdict(list)\\n        count = [0]*k\\n        arr = set()\\n        allotments = defaultdict(lambda:-1)\\n        for i in range(len(arrival)):\\n            arr.add(arrival[i])\\n            allotments[arrival[i]] = i\\n            arr.add(arrival[i]+load[i])\\n        arr = sorted(list(arr))\\n        root = Tree(k)\\n        for i in arr:\\n            for node in freeAt[i]:\\n                root.freeNode(node)\\n            if allotments[i]+1:\\n                comp = root.getAlloted(allotments[i]%k)\\n                #print(allotments[i],allotments[i]%k,i,arrival[allotments[i]]+load[allotments[i]],comp)\\n                #if i==94:root.printTree()\\n                if comp+1:\\n                    count[comp]+=1\\n                    freeAt[arrival[allotments[i]]+load[allotments[i]]].append(comp)\\n        go = max(count)\\n        ans = []\\n        #print(arr)\\n        for i in range(len(count)):\\n            if count[i]==go:ans.append(i)\\n        #print(count)\\n        return ans\\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3293792,
                "title": "python-simple-heap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def busiestServers(self, k, arrival, load):\\n        available, busy, dict1 = [i for i in range(k)], [], collections.defaultdict(int)\\n\\n        for i,start in enumerate(arrival):\\n            while busy and busy[0][0] <= start:\\n                heapq.heappush(available,i + (heapq.heappop(busy)[1] - i)%k)\\n\\n            if available:\\n                j = heapq.heappop(available)%k\\n                dict1[j] += 1\\n                heapq.heappush(busy,(start+load[i],j))\\n\\n        max_val = max(dict1.values())\\n\\n        return [key for key,val in dict1.items() if val == max_val]\\n\\n\\n\\n            \\n\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def busiestServers(self, k, arrival, load):\\n        available, busy, dict1 = [i for i in range(k)], [], collections.defaultdict(int)\\n\\n        for i,start in enumerate(arrival):\\n            while busy and busy[0][0] <= start:\\n                heapq.heappush(available,i + (heapq.heappop(busy)[1] - i)%k)\\n\\n            if available:\\n                j = heapq.heappop(available)%k\\n                dict1[j] += 1\\n                heapq.heappush(busy,(start+load[i],j))\\n\\n        max_val = max(dict1.values())\\n\\n        return [key for key,val in dict1.items() if val == max_val]\\n\\n\\n\\n            \\n\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3216491,
                "title": "python3-two-heap-solution-explained-and-commented",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe want to prioritize our useage of the servers in a set range. This is similar to modular arithmetic, so we should look for a priority queue solution that can use a modular approach, like a circular priority queue. In this case, we arrive at the solution through comparison of the server ids, which are in order of the ith server to be processed at any given point in time. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSet up a list of servers currently available, called servers. \\nSet up an empty list of servers processing. \\nSet up a number of tasks by server of size k and value 0 to start. \\nLoop over the indices of your arrival index \\n- As you do, get the arrival time and the load size for the current arrival\\n- While you have servers processing, and the servers that are processing have a finish time before the current arrival time \\n    - Get the prior_task and server_id by popping off from the servers_processing \\n    - Push into the servers heap this server by its identification key at this point in the circular priority queue of servers with key value of arrival_index + (server_id - arrival_index) % k. See comments for details. \\n- Then, if you have servers avaialble \\n    - Pop out the most recent to complete one in ith order by using a heappop from servers and taking modulo of k for the value. This is needed to turn the arrival_index + (server_id - arrival_index) % k back into the correct server_id. For completeness, see example after time complexity. \\n    - Increment the number of tasks by server at this server by 1 \\n    - Push this ((arrival_time + load_size), server) back into servers processing \\n\\nAt end, get your highest productivity (number of tasks cleared by a server) \\nUse list comprehension to build the list of server for server in your range of servers if number of tasks by server at server is equal to highest productivity (as requested by problem)  \\n\\n# Complexity\\n- Time complexity: We need to process N arrivals \\n- During each arrival, we might process up to the ith arrival in a pop push fashion, necessitating an amount of work at most equal to N log N (where we go until the last prossible process before popping everything off of the servers processing before pushing them back into the arrivals) \\n- During each arrival, we may also do a 2 log N amount of work for popping from the servers and pushing to the servers processing. \\n- This gives an overall runtime of N log N. \\n\\n- Space complexity: At worst, we will store the entire space in the processing of this at least twice (Once for the heaps, and once for the return list if eveyrone processed only one item). So, we have O(N) space. \\n\\nExample for completeness \\nConsider the test case below \\nk = 3 \\nArrivals = [1,2,3,4,8,9,10]\\nLoads = [5,2,10,3,1,2,2]\\n\\nAt arrival index 0, we have arrival time 1 and load size five\\nWe\\'ll end up popping server 0 and incrementing tasks at 0 \\nThis leaves us at end of arrival index 0 in state of \\nServers -> [1, 2]\\nNumber_of_tasks_per_server = [1, 0, 0]\\nprocessing_servers -> [(6, 0)]\\n\\nAt arrival index 1, we have arrival time 2 and load size 2 \\nWe\\'ll end up popping server 1 and incrementing tasks at 1 \\nThis leaves us at end of arrival index 1 in state of \\nServers -> [2]\\nNumber_of_tasks_per_server = [1, 1, 0]\\nprocessing_servers = [(4, 1), (6, 0)]\\n\\nAt arrival index 2, we have arrival time of 3 and load size of 10 \\nWe\\'ll end up popping server 2 and incrementing tasks at 2 \\nThis leaves uas at end of arrival index 2 in state of \\nServers -> []\\nNumber_of_tasks_per_server -> [1, 1, 1]\\nprocessing_servers = [(4, 1), (6, 0), (13, 2)]\\n\\nAt arrival index 3, we have arrival time of 4 and load size of 3\\nWe now have a servers_processing[0][0] that is <= arrival time\\nSo, we pop from processing servers to get \\n- prior_task, server_id = 4, 1\\n- arrival_index = 3 \\n- 3 + (1 - 3) mod 3 = 4 \\n- servers -> [4]\\nWe now will pop server 4, however! we will do mod k on it (as we did on the others) and get a result of 1 (the server we started with!)\\nWe increment server 1 then and push in a node of (7, 1)\\nWe end arrival index 3 with \\nServers -> []\\nNumber_of_tasks_per_server = [1, 2, 1]\\nProcessing_servers = [(6, 0), (7, 1), (13, 2)]\\n\\nThe rest are left as an exercise but hopefully this has helped you get the process so you can check the rest. If not, please post in the comments about what can be made more clear and I\\'ll do my best. \\n\\n# Code\\n```\\nclass Solution:\\n    def busiestServers(self, k: int, arrival: List[int], load: List[int]) -> List[int]:\\n        # heap of servers currently available \\n        servers = list(range(k))\\n        # heap of servers currently processing \\n        servers_processing = []\\n        # number of tasks at this server over time \\n        number_of_tasks_by_server = [0]*k\\n\\n        # for each arrival in arrival\\n        for arrival_index in range(len(arrival)) : \\n            # get the arrival time and load size \\n            arrival_time = arrival[arrival_index]\\n            load_size = load[arrival_index]\\n            # while you have servers that were processing and have now finished \\n            while servers_processing and servers_processing[0][0] <= arrival_time : \\n                # finish those tasks you have completed \\n                prior_task, server_id = heapq.heappop(servers_processing)\\n                # print(\"Prior task at \", server_id, \" now completed.\")\\n                # push back into servers the current server_id at it\\'s heap key \\n                # the heap key is determined as arrival_index + (server_id - arrival_index) % k \\n                # this is because we are in a limited space (go to ith server until k, then loop back)\\n                # so, server_id + m*k  = i + x \\n                # where we have x going from 0 up to but not including k and i as some time quality \\n                # we then take modular of k of both sides \\n                # server_id % k + 0 (as m*k%k == 0) = i % k + x (as c % k == c iff c in [0, k)) \\n                # x = server_id % k - i % k \\n                # we then simplify by joining similar modulo\\'s \\n                # x = (server_id - i) % k \\n                # With x equal to this, if we use i as arrival index and go back to line 23 \\n                # we get server_id + mk = arrival_index + (server_id - arrival_index) % k \\n                # This means we can use arrival_index + (server_id - arrival_index) % k as our heap key \\n                # and that in doing so, it will map to a specific server id \\n                heapq.heappush(servers, arrival_index + (server_id - arrival_index)%k)\\n            # if you have servers available \\n            if servers : \\n                # get the next server by using heapq.heappop and keeping within k \\n                server = heapq.heappop(servers)%k\\n                # at this server, up the tasks by one \\n                number_of_tasks_by_server[server] += 1 \\n                # push this server into our servers processing with finish time of arrival_time plus load_size\\n                heapq.heappush(servers_processing, ((arrival_time+load_size), server))\\n            # else : \\n            #     print(\"No servers available, dropping task \", arrival_index, \" of size \", load_size)\\n\\n        highest_productivity = max(number_of_tasks_by_server)\\n        return [server for server in range(k) if number_of_tasks_by_server[server]==highest_productivity]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def busiestServers(self, k: int, arrival: List[int], load: List[int]) -> List[int]:\\n        # heap of servers currently available \\n        servers = list(range(k))\\n        # heap of servers currently processing \\n        servers_processing = []\\n        # number of tasks at this server over time \\n        number_of_tasks_by_server = [0]*k\\n\\n        # for each arrival in arrival\\n        for arrival_index in range(len(arrival)) : \\n            # get the arrival time and load size \\n            arrival_time = arrival[arrival_index]\\n            load_size = load[arrival_index]\\n            # while you have servers that were processing and have now finished \\n            while servers_processing and servers_processing[0][0] <= arrival_time : \\n                # finish those tasks you have completed \\n                prior_task, server_id = heapq.heappop(servers_processing)\\n                # print(\"Prior task at \", server_id, \" now completed.\")\\n                # push back into servers the current server_id at it\\'s heap key \\n                # the heap key is determined as arrival_index + (server_id - arrival_index) % k \\n                # this is because we are in a limited space (go to ith server until k, then loop back)\\n                # so, server_id + m*k  = i + x \\n                # where we have x going from 0 up to but not including k and i as some time quality \\n                # we then take modular of k of both sides \\n                # server_id % k + 0 (as m*k%k == 0) = i % k + x (as c % k == c iff c in [0, k)) \\n                # x = server_id % k - i % k \\n                # we then simplify by joining similar modulo\\'s \\n                # x = (server_id - i) % k \\n                # With x equal to this, if we use i as arrival index and go back to line 23 \\n                # we get server_id + mk = arrival_index + (server_id - arrival_index) % k \\n                # This means we can use arrival_index + (server_id - arrival_index) % k as our heap key \\n                # and that in doing so, it will map to a specific server id \\n                heapq.heappush(servers, arrival_index + (server_id - arrival_index)%k)\\n            # if you have servers available \\n            if servers : \\n                # get the next server by using heapq.heappop and keeping within k \\n                server = heapq.heappop(servers)%k\\n                # at this server, up the tasks by one \\n                number_of_tasks_by_server[server] += 1 \\n                # push this server into our servers processing with finish time of arrival_time plus load_size\\n                heapq.heappush(servers_processing, ((arrival_time+load_size), server))\\n            # else : \\n            #     print(\"No servers available, dropping task \", arrival_index, \" of size \", load_size)\\n\\n        highest_productivity = max(number_of_tasks_by_server)\\n        return [server for server in range(k) if number_of_tasks_by_server[server]==highest_productivity]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3032079,
                "title": "priority-queue-set-binary-search",
                "content": "\\n# Complexity\\n- Time complexity: O(nlogk)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n        vector<int>freq(k,0);\\n        vector<int>ans;\\n        priority_queue<pair<int,int>,vector<pair<int,int>>, greater<pair<int,int>>>busy_server;\\n        set<int>free_server;\\n        for(int i=0;i<k;i++)\\n            free_server.insert(i);\\n        for(int i=0;i<arrival.size();i++){\\n            int start_time=arrival[i];\\n            int end_time=start_time+load[i];\\n            while(busy_server.size()>0 && busy_server.top().first<=start_time){\\n                free_server.insert(busy_server.top().second);\\n                busy_server.pop();\\n            }\\n            if(free_server.size()>0){\\n                auto itr = free_server.lower_bound(i%k);\\n                if(itr==free_server.end())\\n                    itr=free_server.begin();\\n                busy_server.push({end_time,*itr});\\n                freq[*itr]++;\\n                free_server.erase(*itr);\\n            }\\n            else{\\n                continue;\\n            }\\n        }\\n\\n        int val=0;\\n        for(int i=0;i<k;i++)\\n            val=max(val,freq[i]);\\n        \\n        for(int i=0;i<k;i++){\\n            if(freq[i]==val){\\n                ans.push_back(i);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Heap (Priority Queue)",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n        vector<int>freq(k,0);\\n        vector<int>ans;\\n        priority_queue<pair<int,int>,vector<pair<int,int>>, greater<pair<int,int>>>busy_server;\\n        set<int>free_server;\\n        for(int i=0;i<k;i++)\\n            free_server.insert(i);\\n        for(int i=0;i<arrival.size();i++){\\n            int start_time=arrival[i];\\n            int end_time=start_time+load[i];\\n            while(busy_server.size()>0 && busy_server.top().first<=start_time){\\n                free_server.insert(busy_server.top().second);\\n                busy_server.pop();\\n            }\\n            if(free_server.size()>0){\\n                auto itr = free_server.lower_bound(i%k);\\n                if(itr==free_server.end())\\n                    itr=free_server.begin();\\n                busy_server.push({end_time,*itr});\\n                freq[*itr]++;\\n                free_server.erase(*itr);\\n            }\\n            else{\\n                continue;\\n            }\\n        }\\n\\n        int val=0;\\n        for(int i=0;i<k;i++)\\n            val=max(val,freq[i]);\\n        \\n        for(int i=0;i<k;i++){\\n            if(freq[i]==val){\\n                ans.push_back(i);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3020002,
                "title": "c-priorityqueue-ordered-set-binary-search-great-question",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    typedef long long int64;\\n\\n    vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n        int mxHandling = 0;\\n        // free server Ids\\n        set<int> free;\\n        // busy {freeTime, serverId} sorted in ascending order of free time.\\n        priority_queue<pair<int64, int>, vector<pair<int64, int>>, greater<pair<int64, int>>> busy;\\n        // {serverId --> count of tasks handled}\\n        int count[k + 1];\\n        for(int i = 0; i < k; i++) {\\n            free.insert(i);\\n            count[i] = 0;\\n        }\\n        int n = arrival.size();\\n        for(int i = 0; i < n; i++) {\\n            while(!busy.empty() && busy.top().first <= arrival[i]) {\\n                auto [freeTime, serverId] = busy.top();\\n                busy.pop();\\n                free.insert(serverId); \\n            }\\n            // request dropped if all servers are busy\\n            if(free.size() == 0) { \\n                continue;\\n            }\\n            auto it = free.lower_bound(i % k);\\n            if(it == free.end()) {\\n                it = free.begin();\\n            }\\n            int recommendedServerId = *it;    \\n            count[recommendedServerId]++;\\n            mxHandling = max(mxHandling, count[recommendedServerId]);\\n            busy.push({(int64)arrival[i] + load[i], recommendedServerId});\\n            free.erase(recommendedServerId);\\n        }\\n        vector<int> ans;\\n        for(int i = 0; i < k; i++) {\\n            if(count[i] == mxHandling) {\\n                ans.push_back(i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    typedef long long int64;\\n\\n    vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n        int mxHandling = 0;\\n        // free server Ids\\n        set<int> free;\\n        // busy {freeTime, serverId} sorted in ascending order of free time.\\n        priority_queue<pair<int64, int>, vector<pair<int64, int>>, greater<pair<int64, int>>> busy;\\n        // {serverId --> count of tasks handled}\\n        int count[k + 1];\\n        for(int i = 0; i < k; i++) {\\n            free.insert(i);\\n            count[i] = 0;\\n        }\\n        int n = arrival.size();\\n        for(int i = 0; i < n; i++) {\\n            while(!busy.empty() && busy.top().first <= arrival[i]) {\\n                auto [freeTime, serverId] = busy.top();\\n                busy.pop();\\n                free.insert(serverId); \\n            }\\n            // request dropped if all servers are busy\\n            if(free.size() == 0) { \\n                continue;\\n            }\\n            auto it = free.lower_bound(i % k);\\n            if(it == free.end()) {\\n                it = free.begin();\\n            }\\n            int recommendedServerId = *it;    \\n            count[recommendedServerId]++;\\n            mxHandling = max(mxHandling, count[recommendedServerId]);\\n            busy.push({(int64)arrival[i] + load[i], recommendedServerId});\\n            free.erase(recommendedServerId);\\n        }\\n        vector<int> ans;\\n        for(int i = 0; i < k; i++) {\\n            if(count[i] == mxHandling) {\\n                ans.push_back(i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2929257,
                "title": "java-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:N lon(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:N\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport java.util.Map.Entry;\\nclass Solution {\\n    public List<Integer> busiestServers(int k, int[] arrival, int[] load) {\\n        TreeMap<Integer,Server> freeServer = new TreeMap<>();\\n        for(int i=0;i<k;i++)\\n        {\\n            freeServer.put(i,new Server(0,0,i));\\n        }\\n\\n        PriorityQueue<Server> busyServer = new PriorityQueue<>((a,b)->a.endTime-b.endTime);\\n        for(int i = 0;i<arrival.length;i++)\\n        {\\n            while(!busyServer.isEmpty() && busyServer.peek().endTime<=arrival[i])\\n            {\\n                Server free = busyServer.poll();\\n                freeServer.put(free.id,free);\\n            }\\n            if(freeServer.isEmpty())\\n                continue;\\n            int index = i%k;\\n            Entry<Integer, Server> server = freeServer.ceilingEntry(index);\\n            if(server==null)\\n            {\\n                server = freeServer.firstEntry();\\n            }\\n            // System.out.println(\"Server -->>\"+server);\\n            // System.out.println(\"Server -->>\"+server);\\n            // System.out.println(\"arrival[i] -->>\"+arrival[i]);\\n            freeServer.remove(server.getKey());\\n            server.getValue().endTime = arrival[i]+load[i];\\n            server.getValue().count++;\\n            busyServer.add(server.getValue());\\n            //System.out.println(\"free Server -->>\"+freeServer);\\n            \\n        }\\n\\n         while(!busyServer.isEmpty())\\n        {\\n            Server free = busyServer.poll();\\n            freeServer.put(free.id,free);\\n        }\\n        \\n        int maxRequest = 0;\\n        for(Server server:freeServer.values())\\n        {\\n            maxRequest =Math.max(maxRequest, server.count);\\n        }\\n        // System.out.println(\"maxRequest -->>\"+maxRequest);\\n        // System.out.println(\"free Server -->>\"+freeServer);\\n        List<Integer> result = new ArrayList<>();\\n        for(int id:freeServer.keySet())\\n        {\\n            if(freeServer.get(id).count==maxRequest)\\n                result.add(id);\\n        }\\n        return result;\\n        \\n    }\\n    class Server{\\n        int endTime;\\n        int count;\\n        int id;\\n        public Server(int endTime, int count, int id)\\n        {\\n            this.endTime = endTime;\\n            this.count = count;\\n            this.id = id;\\n        }\\n        @Override\\n        public String toString() {\\n            return \"Server [endTime=\" + endTime + \", count=\" + count + \", id=\" + id + \"]\";\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.Map.Entry;\\nclass Solution {\\n    public List<Integer> busiestServers(int k, int[] arrival, int[] load) {\\n        TreeMap<Integer,Server> freeServer = new TreeMap<>();\\n        for(int i=0;i<k;i++)\\n        {\\n            freeServer.put(i,new Server(0,0,i));\\n        }\\n\\n        PriorityQueue<Server> busyServer = new PriorityQueue<>((a,b)->a.endTime-b.endTime);\\n        for(int i = 0;i<arrival.length;i++)\\n        {\\n            while(!busyServer.isEmpty() && busyServer.peek().endTime<=arrival[i])\\n            {\\n                Server free = busyServer.poll();\\n                freeServer.put(free.id,free);\\n            }\\n            if(freeServer.isEmpty())\\n                continue;\\n            int index = i%k;\\n            Entry<Integer, Server> server = freeServer.ceilingEntry(index);\\n            if(server==null)\\n            {\\n                server = freeServer.firstEntry();\\n            }\\n            // System.out.println(\"Server -->>\"+server);\\n            // System.out.println(\"Server -->>\"+server);\\n            // System.out.println(\"arrival[i] -->>\"+arrival[i]);\\n            freeServer.remove(server.getKey());\\n            server.getValue().endTime = arrival[i]+load[i];\\n            server.getValue().count++;\\n            busyServer.add(server.getValue());\\n            //System.out.println(\"free Server -->>\"+freeServer);\\n            \\n        }\\n\\n         while(!busyServer.isEmpty())\\n        {\\n            Server free = busyServer.poll();\\n            freeServer.put(free.id,free);\\n        }\\n        \\n        int maxRequest = 0;\\n        for(Server server:freeServer.values())\\n        {\\n            maxRequest =Math.max(maxRequest, server.count);\\n        }\\n        // System.out.println(\"maxRequest -->>\"+maxRequest);\\n        // System.out.println(\"free Server -->>\"+freeServer);\\n        List<Integer> result = new ArrayList<>();\\n        for(int id:freeServer.keySet())\\n        {\\n            if(freeServer.get(id).count==maxRequest)\\n                result.add(id);\\n        }\\n        return result;\\n        \\n    }\\n    class Server{\\n        int endTime;\\n        int count;\\n        int id;\\n        public Server(int endTime, int count, int id)\\n        {\\n            this.endTime = endTime;\\n            this.count = count;\\n            this.id = id;\\n        }\\n        @Override\\n        public String toString() {\\n            return \"Server [endTime=\" + endTime + \", count=\" + count + \", id=\" + id + \"]\";\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2879799,
                "title": "using-2-heap",
                "content": "```\\ntype Server struct {\\n    Id int\\n    AvailableAt int\\n}\\n\\ntype BusyPriorityQ []Server\\n\\nfunc (pq BusyPriorityQ) Len() int {\\n    return len(pq)\\n}\\n\\nfunc (pq BusyPriorityQ) Less(i, j int) bool {\\n    return pq[i].AvailableAt < pq[j].AvailableAt \\n}\\n\\nfunc (pq BusyPriorityQ) Swap(i, j int) {\\n    pq[i], pq[j] = pq[j], pq[i] \\n}\\n\\nfunc (pq *BusyPriorityQ) Push(item interface{}) {\\n    *pq = append(*pq, item.(Server)) \\n}\\n\\nfunc (pq *BusyPriorityQ) Pop() interface{} {\\n    l := len(*pq)\\n    item := (*pq)[l-1]\\n    (*pq) = (*pq)[:l-1]\\n    return item\\n}\\n\\ntype FreePriorityQ []Server\\n\\nfunc (pq FreePriorityQ) Len() int {\\n    return len(pq)\\n}\\n\\nfunc (pq FreePriorityQ) Less(i, j int) bool {\\n    return pq[i].Id < pq[j].Id \\n}\\n\\nfunc (pq FreePriorityQ) Swap(i, j int) {\\n    pq[i], pq[j] = pq[j], pq[i] \\n}\\n\\nfunc (pq *FreePriorityQ) Push(item interface{}) {\\n    *pq = append(*pq, item.(Server)) \\n}\\n\\nfunc (pq *FreePriorityQ) Pop() interface{} {\\n    l := len(*pq)\\n    item := (*pq)[l-1]\\n    (*pq) = (*pq)[:l-1]\\n    return item\\n}\\n\\nfunc busiestServers(k int, arrival []int, load []int) []int {\\n    busyPq := &BusyPriorityQ{}\\n    freePq := &FreePriorityQ{}\\n    \\n    heap.Init(freePq)\\n    heap.Init(busyPq)\\n    \\n    for i:=0; i<k;i++ {\\n        heap.Push(freePq, Server{\\n            Id : i,\\n            AvailableAt: 0,\\n        })\\n    }\\n    \\n    count := make([]int, k)\\n    max := 0\\n    \\n    for i:=0; i<len(arrival); i++ {\\n        startTime := arrival[i]\\n        endTime := startTime + load[i]\\n        \\n        for len(*busyPq) > 0 && (*busyPq)[0].AvailableAt <= startTime{\\n            nextFreeServer := heap.Pop(busyPq).(Server)\\n            \\n            serverId := nextFreeServer.Id\\n            \\n            modifiedId := serverId - i\\n            \\n            for modifiedId < 0 {\\n                modifiedId = modifiedId + k\\n            }\\n            \\n            modifiedId = modifiedId % k + i\\n            //fmt.Println(serverId, modifiedId, i, (serverId - i) % k)\\n            nextFreeServer.Id  = modifiedId\\n            heap.Push(freePq, nextFreeServer)\\n        }\\n        \\n        if len(*freePq) > 0 {\\n            assigning := heap.Pop(freePq).(Server)\\n            assigning.AvailableAt = endTime\\n            \\n            busyId  := assigning.Id % k \\n            assigning.Id = busyId\\n            \\n            heap.Push(busyPq, assigning)\\n            \\n            count[assigning.Id]++\\n            \\n            if max < count[assigning.Id] {\\n                max = count[assigning.Id]\\n            }\\n        }\\n    }\\n    \\n    \\n    result := []int{}\\n    for i:=0; i<k; i++ {\\n        if count[i] == max {\\n            result = append(result, i)\\n        }\\n    }\\n    \\n    return result\\n}\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\ntype Server struct {\\n    Id int\\n    AvailableAt int\\n}\\n\\ntype BusyPriorityQ []Server\\n\\nfunc (pq BusyPriorityQ) Len() int {\\n    return len(pq)\\n}\\n\\nfunc (pq BusyPriorityQ) Less(i, j int) bool {\\n    return pq[i].AvailableAt < pq[j].AvailableAt \\n}\\n\\nfunc (pq BusyPriorityQ) Swap(i, j int) {\\n    pq[i], pq[j] = pq[j], pq[i] \\n}\\n\\nfunc (pq *BusyPriorityQ) Push(item interface{}) {\\n    *pq = append(*pq, item.(Server)) \\n}\\n\\nfunc (pq *BusyPriorityQ) Pop() interface{} {\\n    l := len(*pq)\\n    item := (*pq)[l-1]\\n    (*pq) = (*pq)[:l-1]\\n    return item\\n}\\n\\ntype FreePriorityQ []Server\\n\\nfunc (pq FreePriorityQ) Len() int {\\n    return len(pq)\\n}\\n\\nfunc (pq FreePriorityQ) Less(i, j int) bool {\\n    return pq[i].Id < pq[j].Id \\n}\\n\\nfunc (pq FreePriorityQ) Swap(i, j int) {\\n    pq[i], pq[j] = pq[j], pq[i] \\n}\\n\\nfunc (pq *FreePriorityQ) Push(item interface{}) {\\n    *pq = append(*pq, item.(Server)) \\n}\\n\\nfunc (pq *FreePriorityQ) Pop() interface{} {\\n    l := len(*pq)\\n    item := (*pq)[l-1]\\n    (*pq) = (*pq)[:l-1]\\n    return item\\n}\\n\\nfunc busiestServers(k int, arrival []int, load []int) []int {\\n    busyPq := &BusyPriorityQ{}\\n    freePq := &FreePriorityQ{}\\n    \\n    heap.Init(freePq)\\n    heap.Init(busyPq)\\n    \\n    for i:=0; i<k;i++ {\\n        heap.Push(freePq, Server{\\n            Id : i,\\n            AvailableAt: 0,\\n        })\\n    }\\n    \\n    count := make([]int, k)\\n    max := 0\\n    \\n    for i:=0; i<len(arrival); i++ {\\n        startTime := arrival[i]\\n        endTime := startTime + load[i]\\n        \\n        for len(*busyPq) > 0 && (*busyPq)[0].AvailableAt <= startTime{\\n            nextFreeServer := heap.Pop(busyPq).(Server)\\n            \\n            serverId := nextFreeServer.Id\\n            \\n            modifiedId := serverId - i\\n            \\n            for modifiedId < 0 {\\n                modifiedId = modifiedId + k\\n            }\\n            \\n            modifiedId = modifiedId % k + i\\n            //fmt.Println(serverId, modifiedId, i, (serverId - i) % k)\\n            nextFreeServer.Id  = modifiedId\\n            heap.Push(freePq, nextFreeServer)\\n        }\\n        \\n        if len(*freePq) > 0 {\\n            assigning := heap.Pop(freePq).(Server)\\n            assigning.AvailableAt = endTime\\n            \\n            busyId  := assigning.Id % k \\n            assigning.Id = busyId\\n            \\n            heap.Push(busyPq, assigning)\\n            \\n            count[assigning.Id]++\\n            \\n            if max < count[assigning.Id] {\\n                max = count[assigning.Id]\\n            }\\n        }\\n    }\\n    \\n    \\n    result := []int{}\\n    for i:=0; i<k; i++ {\\n        if count[i] == max {\\n            result = append(result, i)\\n        }\\n    }\\n    \\n    return result\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2879228,
                "title": "easy-to-understand-brute-force-solution",
                "content": "```\\nfunc busiestServers(k int, arrival []int, load []int) []int {\\n    serverReqCount := make([]int, k)\\n    servers := make([]int, k)\\n    \\n    maxRequestServed := 0  // max request served by any sever \\n    \\n    for i:=0; i<len(arrival); i++ {\\n        arrivalTime := arrival[i]\\n        duration := load[i]\\n        nextServer := i % k // request will go to this server as per questioon\\n        for j:=0; j<k; j++ { // iterate over all servers \\n            if nextServer == k {  // reached to last server, start from frist\\n                nextServer = 0\\n            }\\n            if servers[nextServer] <= arrivalTime {\\n                servers[nextServer] = arrivalTime + duration  // serving requat till this time\\n                serverReqCount[nextServer]++\\n                \\n                if maxRequestServed < serverReqCount[nextServer] {\\n                    maxRequestServed = serverReqCount[nextServer]\\n                }\\n                break\\n            }\\n            nextServer++\\n        }\\n    \\n    }\\n    \\n    result := []int{}\\n    // all servers which served max request\\n    for i:=0; i<len(serverReqCount); i++ {\\n        if serverReqCount[i] == maxRequestServed {\\n            result = append(result, i)\\n        }\\n    }\\n    \\n    return result\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc busiestServers(k int, arrival []int, load []int) []int {\\n    serverReqCount := make([]int, k)\\n    servers := make([]int, k)\\n    \\n    maxRequestServed := 0  // max request served by any sever \\n    \\n    for i:=0; i<len(arrival); i++ {\\n        arrivalTime := arrival[i]\\n        duration := load[i]\\n        nextServer := i % k // request will go to this server as per questioon\\n        for j:=0; j<k; j++ { // iterate over all servers \\n            if nextServer == k {  // reached to last server, start from frist\\n                nextServer = 0\\n            }\\n            if servers[nextServer] <= arrivalTime {\\n                servers[nextServer] = arrivalTime + duration  // serving requat till this time\\n                serverReqCount[nextServer]++\\n                \\n                if maxRequestServed < serverReqCount[nextServer] {\\n                    maxRequestServed = serverReqCount[nextServer]\\n                }\\n                break\\n            }\\n            nextServer++\\n        }\\n    \\n    }\\n    \\n    result := []int{}\\n    // all servers which served max request\\n    for i:=0; i<len(serverReqCount); i++ {\\n        if serverReqCount[i] == maxRequestServed {\\n            result = append(result, i)\\n        }\\n    }\\n    \\n    return result\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2848573,
                "title": "just-working-one-for-js-as-no-one-exists",
                "content": "# Intuition\\nThe solution in general not very hard. \\nWe just need to track min next server before and after the current one.\\nAnd of course when the processing will be finished for already working.\\n\\n\\n# Approach\\n3 MinPriorityQueue\\n\\n1 - We keep tracking when the server will be free.\\n2 - We tracking the next min value after k%i\\n3 - We tracking the next min value before k%i\\n\\nOn each iteration we try to take the server from 2, if no from 3 if no - drop.\\nOn each new cercle 3 becomes 2.\\n \\n\\n\\n# Complexity\\n- Time complexity:\\narrival.length * log(k)\\n\\n- Space complexity:\\narrival.length + k\\n\\n# Code\\n```\\n/**\\n * @param {number} k\\n * @param {number[]} arrival\\n * @param {number[]} load\\n * @return {number[]}\\n */\\nvar busiestServers = function(k, arrival, load) {\\n    let louds = {};\\n\\n    let processing = new MinPriorityQueue();\\n    let servers1 = new MinPriorityQueue();\\n    let servers2 = new MinPriorityQueue();\\n    let max = 0;\\n\\n    for (let i = 0; i < k; i++) {\\n        servers2.enqueue(i, i);\\n    }\\n\\n    for (let i = 0; i < arrival.length; i++) {\\n        let start = arrival[i];\\n        let end = start + load[i];\\n\\n        let iterator = i % k;\\n\\n        if (iterator == 0) {\\n            servers1 = servers2;\\n            servers2 = new MinPriorityQueue();\\n        }\\n\\n        while (processing.front() && processing.front().priority <= start) {\\n            let servers = processing.dequeue();\\n            if (servers.element < iterator) {\\n                servers2.enqueue(servers.element);\\n            } else {\\n                servers1.enqueue(servers.element);\\n            }\\n        }\\n\\n        let server = null;\\n\\n        if (servers1.front()) {\\n            server = servers1.dequeue().element;\\n        } else if (servers2.front()) {\\n            server = servers2.dequeue().element;\\n        }\\n\\n        if (server != null) {\\n            if (louds[server] == undefined) {\\n                louds[server] = 0;\\n            }\\n            louds[server]++;\\n            max = Math.max(louds[server], max);\\n            processing.enqueue(server, end);\\n        }\\n    }\\n    \\n    let result = [];\\n    for (let prop in louds) {\\n        if (louds[prop] == max) {\\n            result.push(prop);\\n        }\\n\\n    }\\n\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n/**\\n * @param {number} k\\n * @param {number[]} arrival\\n * @param {number[]} load\\n * @return {number[]}\\n */\\nvar busiestServers = function(k, arrival, load) {\\n    let louds = {};\\n\\n    let processing = new MinPriorityQueue();\\n    let servers1 = new MinPriorityQueue();\\n    let servers2 = new MinPriorityQueue();\\n    let max = 0;\\n\\n    for (let i = 0; i < k; i++) {\\n        servers2.enqueue(i, i);\\n    }\\n\\n    for (let i = 0; i < arrival.length; i++) {\\n        let start = arrival[i];\\n        let end = start + load[i];\\n\\n        let iterator = i % k;\\n\\n        if (iterator == 0) {\\n            servers1 = servers2;\\n            servers2 = new MinPriorityQueue();\\n        }\\n\\n        while (processing.front() && processing.front().priority <= start) {\\n            let servers = processing.dequeue();\\n            if (servers.element < iterator) {\\n                servers2.enqueue(servers.element);\\n            } else {\\n                servers1.enqueue(servers.element);\\n            }\\n        }\\n\\n        let server = null;\\n\\n        if (servers1.front()) {\\n            server = servers1.dequeue().element;\\n        } else if (servers2.front()) {\\n            server = servers2.dequeue().element;\\n        }\\n\\n        if (server != null) {\\n            if (louds[server] == undefined) {\\n                louds[server] = 0;\\n            }\\n            louds[server]++;\\n            max = Math.max(louds[server], max);\\n            processing.enqueue(server, end);\\n        }\\n    }\\n    \\n    let result = [];\\n    for (let prop in louds) {\\n        if (louds[prop] == max) {\\n            result.push(prop);\\n        }\\n\\n    }\\n\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2841074,
                "title": "c-std-set-for-free-servers-and-std-priority-queue-for-busy-servers",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n        vector<pair<int,int>> serverLoad(k);\\n        std::set<int> freeServers;\\n        std::priority_queue<pair<int,int>, vector<pair<int,int>>, greater<>> busyServers;\\n\\t\\t/* initially, all servers are free */\\n        for (int i=0; i<k; i++) {\\n            freeServers.insert(i);\\n        }\\n        for (int i=0; i<k; i++) {\\n            serverLoad[i] = {0,i};\\n        }\\n        for (int i=0; i<arrival.size(); i++) {\\n\\t\\t/* check which servers become free at this arrival time and move them to the free servers set */\\n            while((!busyServers.empty()) && (busyServers.top().first <= arrival[i])) {\\n                int server = busyServers.top().second;\\n                busyServers.pop();\\n                freeServers.insert(server);\\n            }\\n\\t\\t\\t/* find the available server to assign to this request */\\n            auto itr = freeServers.lower_bound(i%k);\\n            if (itr == freeServers.end()) {\\n                itr = freeServers.begin();\\n            }\\n            if (itr != freeServers.end()) {\\n\\t\\t\\t/* asign server and move th eserver to busy pq */\\n                busyServers.push({arrival[i]+load[i], *itr});\\n                serverLoad[*itr].first++;\\n                freeServers.erase(itr);\\n            }\\n        }\\n\\t\\t/* find all servers that are teh busyest */\\n        sort(serverLoad.begin(), serverLoad.end(), greater<pair<int,int>>());\\n        vector<int> result;\\n        result.emplace_back(serverLoad[0].second);\\n        for(int i=1; i<serverLoad.size(); i++) {\\n            if (serverLoad[i].first == serverLoad[0].first) {\\n                result.emplace_back(serverLoad[i].second);\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n        vector<pair<int,int>> serverLoad(k);\\n        std::set<int> freeServers;\\n        std::priority_queue<pair<int,int>, vector<pair<int,int>>, greater<>> busyServers;\\n\\t\\t/* initially, all servers are free */\\n        for (int i=0; i<k; i++) {\\n            freeServers.insert(i);\\n        }\\n        for (int i=0; i<k; i++) {\\n            serverLoad[i] = {0,i};\\n        }\\n        for (int i=0; i<arrival.size(); i++) {\\n\\t\\t/* check which servers become free at this arrival time and move them to the free servers set */\\n            while((!busyServers.empty()) && (busyServers.top().first <= arrival[i])) {\\n                int server = busyServers.top().second;\\n                busyServers.pop();\\n                freeServers.insert(server);\\n            }\\n\\t\\t\\t/* find the available server to assign to this request */\\n            auto itr = freeServers.lower_bound(i%k);\\n            if (itr == freeServers.end()) {\\n                itr = freeServers.begin();\\n            }\\n            if (itr != freeServers.end()) {\\n\\t\\t\\t/* asign server and move th eserver to busy pq */\\n                busyServers.push({arrival[i]+load[i], *itr});\\n                serverLoad[*itr].first++;\\n                freeServers.erase(itr);\\n            }\\n        }\\n\\t\\t/* find all servers that are teh busyest */\\n        sort(serverLoad.begin(), serverLoad.end(), greater<pair<int,int>>());\\n        vector<int> result;\\n        result.emplace_back(serverLoad[0].second);\\n        for(int i=1; i<serverLoad.size(); i++) {\\n            if (serverLoad[i].first == serverLoad[0].first) {\\n                result.emplace_back(serverLoad[i].second);\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2813930,
                "title": "c-super-short-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n        set<int> svs;\\n        for(int i = 0; i < k; i++) svs.insert(i);\\n        priority_queue<array<int, 2>> pq;\\n        int N = arrival.size(), cnt[100001]{}, r = 0, server = 0, max_v = 0;\\n        for(int i = 0; i < N; i++) {\\n            while(!pq.empty() && -pq.top()[0] <= arrival[i]) {\\n                svs.insert(pq.top()[1]);\\n                pq.pop();\\n            }\\n            r = i%k;\\n            if(svs.size()) {\\n                auto p = svs.lower_bound(r);\\n                if(p != svs.end()) server = *p;\\n                else server = *begin(svs);\\n                max_v = max(max_v, ++cnt[server]);\\n                svs.erase(server);\\n                pq.push({-(arrival[i]+ load[i]), server});\\n            }\\n        }\\n        vector<int> res;\\n        for(int i = 0; i < k; i++) if(cnt[i] == max_v) res.push_back(i);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n        set<int> svs;\\n        for(int i = 0; i < k; i++) svs.insert(i);\\n        priority_queue<array<int, 2>> pq;\\n        int N = arrival.size(), cnt[100001]{}, r = 0, server = 0, max_v = 0;\\n        for(int i = 0; i < N; i++) {\\n            while(!pq.empty() && -pq.top()[0] <= arrival[i]) {\\n                svs.insert(pq.top()[1]);\\n                pq.pop();\\n            }\\n            r = i%k;\\n            if(svs.size()) {\\n                auto p = svs.lower_bound(r);\\n                if(p != svs.end()) server = *p;\\n                else server = *begin(svs);\\n                max_v = max(max_v, ++cnt[server]);\\n                svs.erase(server);\\n                pq.push({-(arrival[i]+ load[i]), server});\\n            }\\n        }\\n        vector<int> res;\\n        for(int i = 0; i < k; i++) if(cnt[i] == max_v) res.push_back(i);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2803656,
                "title": "c-solution",
                "content": "class Solution {\\npublic:\\n    \\n    vector<int> busiestServers(int k, vector<int>& arr, vector<int>&load) {\\n     int n=arr.size();\\n        \\n      vector<int>v;\\n        //server and req completed\\n        unordered_map<int,int>mp;\\n        \\n        // time , server\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>> >pq;\\n        \\n    \\n        //server  available\\n        set<int>st;\\n        \\n    //intially all server free so we assign first k req to server\\n        \\n    for(int i=0;i<k&&i<n;i++){\\n     pq.push({arr[i]+load[i] , i});\\n        mp[i]++;\\n    }     \\n  for(int i=k;i<n;i++){\\n  \\n      //we enter if any server is available or free the server at same time when new req arrive.\\n    if(st.size() || (!pq.empty()&&pq.top().first <= arr[i])){\\n        \\n      while(!pq.empty()&&pq.top().first <= arr[i]){\\n          st.insert(pq.top().second);\\n          pq.pop();\\n      }\\n          \\n    auto server=lower_bound(st.begin(),st.end(),i%k);\\n   \\n      if(server==st.end())\\n          server=st.begin();\\n        \\n  pq.push({arr[i]+load[i],*server});\\n        mp[*server]++;  \\n        \\n        st.erase(server);\\n    }  \\n      \\n      \\n  }    \\n        \\n        \\n  int req=0;\\n        \\n    for(auto x:mp) req=max(req,x.second);\\n        \\n  for(auto x:mp){\\n      if(x.second==req)v.push_back(x.first);\\n  }      \\n        \\n        \\n        \\n  return v;      \\n        \\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n    vector<int> busiestServers(int k, vector<int>& arr, vector<int>&load) {\\n     int n=arr.size();\\n        \\n      vector<int>v;\\n        //server and req completed\\n        unordered_map<int,int>mp;\\n        \\n        // time , server\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>> >pq;\\n        \\n    \\n        //server  available\\n        set<int>st;\\n        \\n    //intially all server free so we assign first k req to server\\n        \\n    for(int i=0;i<k&&i<n;i++){\\n     pq.push({arr[i]+load[i] , i}",
                "codeTag": "Java"
            },
            {
                "id": 2799288,
                "title": "c-segment-tree-detailed-explanation",
                "content": "# Intuition\\nPorted from C++: https://leetcode.com/problems/find-servers-that-handled-most-number-of-requests/solutions/1277420/segment-tree-based-solution-beats-88-solutions-in-time-and-96-solutions-in-memory/?topicTags=binary-tree\\n\\n# Approach\\nThere\\'s a reason why there aren\\'t many C# solutions for this problem. Most approaches use Java\\'s TreeSet which has no good equivalent in C#. Sometimes you can get away with SortedSet, but not in this problem. Using SortedSet you can get at most 104/108 in LeetCode, where the time limit exceptions start to occurr. Our bottleneck occurrs when we need to search for free servers. In Java we can use TreeSet\\'s Ceiling which is  O(logn), but C# has nothing close to that, in terms of performance, that can work with SortedSets, thus we time out. Fortunately, we can still solve this problem using Segment Trees.\\n\\nThe code below has an array representation of a segment tree. For each node at index $$i$$, the left child is at index $$(2*i+1)$$, right child at $$(2*i+2)$$ and the parent is at  $$(\\u230A(i \\u2013 1) / 2\\u230B)$$. \\n\\nThe memory needed for allocation for the segment tree should be at least $$(2 ** 2\\u2308log2n\\u2309  \\u2013 1)$$. The code below is using $$4*MAXN$$, which is larger than that.\\n\\n## Update\\n```\\nvoid Update(int ind,int l,int r,int i,int x)\\n```\\n\\n$$ind$$: index of current server\\n$$l$$: smallest valid server index\\n$$r$$: highest valid server index\\n$$i$$: segment tree array index to be updated\\n$$x$$: arrivalTime + load for the package that the current server is handling\\n\\n\\nThe first line of this method returns if the index of the current server is out of bounds of our tree, or our tree max and min are swaped.\\n\\n```\\n    if(ind>r||ind<l||l>r) return ;\\n```\\n\\nThe following situation handled consists of when the array has only one element $$(l==r)$$, then we store $$x$$ at the current node of the segment tree.\\nSince $$l==r$$, $$ind$$ has to be equal to $$l$$ as well, otherwise we\\'d be out of bounds.\\n\\n```\\nif(l==r)\\n{\\n    if(l==ind)\\n        seg[i]=x;\\n    return ;\\n}\\n```\\n\\nIf there is more than one element, then we recur for left and right subtrees and store the minimum of $$x$$ values in this node.\\n\\n ```\\nint mid=(l+r)/2;\\nUpdate(ind,l,mid,2*i+1,x);\\nUpdate(ind,mid+1,r,2*i+2,x);\\nseg[i] = Math.Min(seg[2*i+1],seg[2*i+2]);\\n```\\nAll levels of the constructed segment tree will be completely filled except the last level. The last level are the leaves, which are the server array elements, thus not needing to be stored.\\n\\n## Query\\n```\\nint Query(int st,int en,int l,int r,int i,int x)\\n```\\nst: start of query range\\nen: end of query range\\nl: smallest valid server index\\nr: highest valid server index\\ni: index of current node in the segment tree\\nx: arrival time\\n\\nNote that Query returns server indexes, not intervals.\\n\\n## BusiestServers\\n\\n1-Iterate over the arrival time array\\n2-start with a query for i%k to k-1, the server with lowest index will be returned if any server is available\\n3-increment the usage counter for that server\\n4-update the segment tree\\n5-start again until all start times were iterated\\n\\n3b-if the first query returned -1, do a second query for 0 to i%k-1\\n4b-go back to 3\\n\\n6-indetify the busiest servers and return them as an array\\n\\n\\n# Code\\n```\\npublic class Solution \\n{\\n    static readonly int MAXN = 100001;\\n    static int[] seg;\\n    void Update(int ind,int l,int r,int i,int x)\\n    {\\n        if(ind>r||ind<l||l>r) return ;\\n        if(l==r)\\n        {\\n            if(l==ind)\\n                seg[i]=x;\\n            return ;\\n        }\\n        int mid=(l+r)/2;\\n        Update(ind,l,mid,2*i+1,x);\\n        Update(ind,mid+1,r,2*i+2,x);\\n        seg[i] = Math.Min(seg[2*i+1],seg[2*i+2]);\\n    }\\n    int Query(int st,int en,int l,int r,int i,int x)\\n    {\\n\\n        if(st>en||l>en||r<st||seg[i]>x)\\n            return -1;\\n        if(l==r) \\n            return l;\\n        int mid = (l+r)/2;\\n        int lf = Query(st,en,l,mid,2*i+1,x);\\n        if(lf!=-1)\\n            return lf;\\n        int rf = Query(st,en,mid+1,r,2*i+2,x);\\n        return rf;\\n    }\\n    public IList<int> BusiestServers(int k, int[] arrival, int[] load) {\\n        int i,n=arrival.Length;\\n        seg = new int[4*MAXN];\\n        List<int> b = new List<int>(new int[n]),ans = new();\\n        Dictionary<int,int> m = new();\\n        for( i = 0; i< k; i++)\\n        {\\n            m.Add(i,0);\\n        }\\n        for(i=0;i<n;i++)\\n        {\\n            int x=Query(i%k,k-1,0,k-1,0,arrival[i]);\\n            if(x!=-1)\\n            {\\n                m[x]++;\\n                b[x] = arrival[i] + load[i];\\n                Update(x,0,k-1,0,b[x]);\\n                continue;\\n            }\\n            int y = Query(0,i%k-1,0,k-1,0,arrival[i]);\\n            if(y != -1)\\n            {\\n                m[y]++;\\n                b[y]= arrival[i] + load[i];\\n                Update(y,0,k-1,0,b[y]);\\n            }\\n        }\\n        int maxi=0;\\n        foreach(var e in m)\\n            maxi = Math.Max(maxi,e.Value);\\n\\n        foreach(var e in m)\\n        {\\n            if(e.Value == maxi)\\n                ans.Add(e.Key);\\n        }\\n        return ans;\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\nvoid Update(int ind,int l,int r,int i,int x)\\n```\n```\\n    if(ind>r||ind<l||l>r) return ;\\n```\n```\\nif(l==r)\\n{\\n    if(l==ind)\\n        seg[i]=x;\\n    return ;\\n}\\n```\n```\\nint mid=(l+r)/2;\\nUpdate(ind,l,mid,2*i+1,x);\\nUpdate(ind,mid+1,r,2*i+2,x);\\nseg[i] = Math.Min(seg[2*i+1],seg[2*i+2]);\\n```\n```\\nint Query(int st,int en,int l,int r,int i,int x)\\n```\n```\\npublic class Solution \\n{\\n    static readonly int MAXN = 100001;\\n    static int[] seg;\\n    void Update(int ind,int l,int r,int i,int x)\\n    {\\n        if(ind>r||ind<l||l>r) return ;\\n        if(l==r)\\n        {\\n            if(l==ind)\\n                seg[i]=x;\\n            return ;\\n        }\\n        int mid=(l+r)/2;\\n        Update(ind,l,mid,2*i+1,x);\\n        Update(ind,mid+1,r,2*i+2,x);\\n        seg[i] = Math.Min(seg[2*i+1],seg[2*i+2]);\\n    }\\n    int Query(int st,int en,int l,int r,int i,int x)\\n    {\\n\\n        if(st>en||l>en||r<st||seg[i]>x)\\n            return -1;\\n        if(l==r) \\n            return l;\\n        int mid = (l+r)/2;\\n        int lf = Query(st,en,l,mid,2*i+1,x);\\n        if(lf!=-1)\\n            return lf;\\n        int rf = Query(st,en,mid+1,r,2*i+2,x);\\n        return rf;\\n    }\\n    public IList<int> BusiestServers(int k, int[] arrival, int[] load) {\\n        int i,n=arrival.Length;\\n        seg = new int[4*MAXN];\\n        List<int> b = new List<int>(new int[n]),ans = new();\\n        Dictionary<int,int> m = new();\\n        for( i = 0; i< k; i++)\\n        {\\n            m.Add(i,0);\\n        }\\n        for(i=0;i<n;i++)\\n        {\\n            int x=Query(i%k,k-1,0,k-1,0,arrival[i]);\\n            if(x!=-1)\\n            {\\n                m[x]++;\\n                b[x] = arrival[i] + load[i];\\n                Update(x,0,k-1,0,b[x]);\\n                continue;\\n            }\\n            int y = Query(0,i%k-1,0,k-1,0,arrival[i]);\\n            if(y != -1)\\n            {\\n                m[y]++;\\n                b[y]= arrival[i] + load[i];\\n                Update(y,0,k-1,0,b[y]);\\n            }\\n        }\\n        int maxi=0;\\n        foreach(var e in m)\\n            maxi = Math.Max(maxi,e.Value);\\n\\n        foreach(var e in m)\\n        {\\n            if(e.Value == maxi)\\n                ans.Add(e.Key);\\n        }\\n        return ans;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2735772,
                "title": "c-ordered-set-min-heap-easy-to-understand",
                "content": "1. Since all servers are free initially, we can assign first k requests to first k servers.\\n2. We need to maintain a min-heap which contains requests sorted according to their end time. We also need to maintain a sorted set of all available servers.\\n3. Whenever a new request arrives, we can remove all requests which have ended from the min-heap and add the freed server back to the sorted set.\\n4. If there is no free server currently, we can continue with next request since current request will be dropped.\\n5. Otherwise, we can get the server which should serve this request using `i%k`. We can then binary search on the available sorted list of servers to get free server closest to `i%k`.\\n6. If there is no such server, start from begining and pick the 0th available server - `s.begin()`\\n7. Add the new request to min-heap & erase the picked server from set of available servers.\\n8. Increment the `server_freq` for this index.\\n9. Iterate over all server frequencies to get list of servers which processed most of the requests & return the list.\\n```\\nclass Solution {\\npublic:\\n    vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n        priority_queue<pair<int, int>, vector<pair<int, int> >, greater<pair<int, int> > > pq;\\n        set<int> s;\\n        int ans = 0;\\n        unordered_map<int, int> server_freq;\\n        for(int i = 0; i < min(k, (int)arrival.size()); i++) {\\n            pq.push({ arrival[i] + load[i], i });\\n            server_freq[i] = 1;\\n            ans = 1;\\n        }\\n        for(int i = k; i < arrival.size(); i++) {\\n            while(!pq.empty() && pq.top().first <= arrival[i]) {\\n                s.insert(pq.top().second);\\n                pq.pop();\\n            }\\n            if(s.size() == 0) continue;\\n            int idx = i%k;\\n            auto it = s.lower_bound(idx);\\n            if(it == s.end()) it = s.begin();\\n            int use_idx = *it;\\n            server_freq[use_idx]++;\\n            if(server_freq[use_idx] > ans) ans = server_freq[use_idx];\\n            pq.push({ arrival[i] + load[i], use_idx });\\n            s.erase(use_idx);\\n        }\\n        vector<int> res;\\n        for(auto it = server_freq.begin(); it != server_freq.end(); it++) {\\n            if(it->second == ans) res.push_back(it->first);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n        priority_queue<pair<int, int>, vector<pair<int, int> >, greater<pair<int, int> > > pq;\\n        set<int> s;\\n        int ans = 0;\\n        unordered_map<int, int> server_freq;\\n        for(int i = 0; i < min(k, (int)arrival.size()); i++) {\\n            pq.push({ arrival[i] + load[i], i });\\n            server_freq[i] = 1;\\n            ans = 1;\\n        }\\n        for(int i = k; i < arrival.size(); i++) {\\n            while(!pq.empty() && pq.top().first <= arrival[i]) {\\n                s.insert(pq.top().second);\\n                pq.pop();\\n            }\\n            if(s.size() == 0) continue;\\n            int idx = i%k;\\n            auto it = s.lower_bound(idx);\\n            if(it == s.end()) it = s.begin();\\n            int use_idx = *it;\\n            server_freq[use_idx]++;\\n            if(server_freq[use_idx] > ans) ans = server_freq[use_idx];\\n            pq.push({ arrival[i] + load[i], use_idx });\\n            s.erase(use_idx);\\n        }\\n        vector<int> res;\\n        for(auto it = server_freq.begin(); it != server_freq.end(); it++) {\\n            if(it->second == ans) res.push_back(it->first);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2727118,
                "title": "46-lines-of-bliss-optimization-idea-borrowed-from-lechen999",
                "content": "```\\nclass Solution {\\n    public List<Integer> busiestServers(int k, int[] arrival, int[] load) {\\n        PriorityQueue<int[]> busy = new PriorityQueue<>((a,b) -> a[1] - b[1]); // minHeap\\n        TreeSet<Integer> available = new TreeSet<>();\\n        int[] timesBusyCount = new int[k];\\n        List<Integer> busiestServers = new LinkedList<>();\\n        \\n        // init:\\n        busy.add(new int[]{0, arrival[0] + load[0]});\\n        // server with the index of 0 becomes busy right away\\n        for(int i=1;i<k;i++) available.add(i);\\n        int max = 1;\\n        busiestServers.add(0);\\n        timesBusyCount[0]=1;\\n        \\n        for(int i=1; i<arrival.length;i++){\\n            \\n            // free up all servers that became free on ith arrival\\n            while(!busy.isEmpty() && busy.peek()[1] <= arrival[i]){\\n                int[] pair = busy.poll();\\n                available.add(pair[0]);\\n            }\\n            \\n            int requestedServer = i%k;\\n            \\n            Integer nextBestServer = available.ceiling(requestedServer);\\n            if(!available.isEmpty() && nextBestServer == null) // starting from the beginning of the collection\\n                nextBestServer = available.first();\\n            \\n            if(nextBestServer !=null){\\n                busy.add(new int[]{nextBestServer, arrival[i] + load[i]});\\n                available.remove(nextBestServer);\\n                timesBusyCount[nextBestServer]++;\\n                if(timesBusyCount[nextBestServer] > max){\\n                    busiestServers = new LinkedList<>();\\n                    busiestServers.add(nextBestServer);\\n                    max = timesBusyCount[nextBestServer];\\n                }\\n                else if(timesBusyCount[nextBestServer] == max)\\n                    busiestServers.add(nextBestServer);\\n            }\\n            \\n        }\\n        return busiestServers;   \\n    }\\n}\\n```",
                "solutionTags": [
                    "Tree",
                    "Heap (Priority Queue)",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> busiestServers(int k, int[] arrival, int[] load) {\\n        PriorityQueue<int[]> busy = new PriorityQueue<>((a,b) -> a[1] - b[1]); // minHeap\\n        TreeSet<Integer> available = new TreeSet<>();\\n        int[] timesBusyCount = new int[k];\\n        List<Integer> busiestServers = new LinkedList<>();\\n        \\n        // init:\\n        busy.add(new int[]{0, arrival[0] + load[0]});\\n        // server with the index of 0 becomes busy right away\\n        for(int i=1;i<k;i++) available.add(i);\\n        int max = 1;\\n        busiestServers.add(0);\\n        timesBusyCount[0]=1;\\n        \\n        for(int i=1; i<arrival.length;i++){\\n            \\n            // free up all servers that became free on ith arrival\\n            while(!busy.isEmpty() && busy.peek()[1] <= arrival[i]){\\n                int[] pair = busy.poll();\\n                available.add(pair[0]);\\n            }\\n            \\n            int requestedServer = i%k;\\n            \\n            Integer nextBestServer = available.ceiling(requestedServer);\\n            if(!available.isEmpty() && nextBestServer == null) // starting from the beginning of the collection\\n                nextBestServer = available.first();\\n            \\n            if(nextBestServer !=null){\\n                busy.add(new int[]{nextBestServer, arrival[i] + load[i]});\\n                available.remove(nextBestServer);\\n                timesBusyCount[nextBestServer]++;\\n                if(timesBusyCount[nextBestServer] > max){\\n                    busiestServers = new LinkedList<>();\\n                    busiestServers.add(nextBestServer);\\n                    max = timesBusyCount[nextBestServer];\\n                }\\n                else if(timesBusyCount[nextBestServer] == max)\\n                    busiestServers.add(nextBestServer);\\n            }\\n            \\n        }\\n        return busiestServers;   \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2683390,
                "title": "java-beat-42-treeset-and-priority-o-n-k-logk",
                "content": "1. create PriorityQueue busy to help maintain every server that has assigned task, the endTime. And pops all that can accept new task once need;\\n2. create free TreeSet to records all servers that can serve, use i % k to rotately find one can serve tasks.\\n3. create int[100010] to record every server executed tasks number, iterate to find all with max tasks.  \\n```\\n    //records how many load each server worked on.\\n    int[] cnt;\\n    public List<Integer> busiestServers(int k, int[] arrival, int[] load) {\\n        //only need K servers.\\n\\t\\tcnt = new int[k];\\n        int n = arrival.length, max = 0;\\n        //record <idx, endTime> to record each server\\'s free time start point \\n        PriorityQueue<int[]> busy = new PriorityQueue<>((a,b) -> a[1] - b[1]);\\n        //need to find >= (i % k) th sever, which needs servers in order, and ceiling function.\\n        TreeSet<Integer> free = new TreeSet();\\n        for(int i = 0 ; i < k; i++) {\\n            free.add(i);\\n        }\\n        for(int i = 0 ; i < n; i++){\\n            int start = arrival[i];\\n            int end = start + load[i];\\n            //add back all previous buys servers to free, if they can pick up new taskes.\\n\\t\\t\\t// each task is arrival in increasing start time order.\\n            while(!busy.isEmpty() && busy.peek()[1] <= start) {\\n                free.add(busy.poll()[0]);\\n            }\\n            //find the >= (i%K)\\n            Integer server = free.ceiling(i % k);\\n            if(server == null) {\\n                //if no bigger one, start from 0;\\n                server = free.ceiling(0);\\n            }\\n            //need to drop the task\\n            if(server == null) continue;\\n            free.remove(server);\\n            //means one server is doing something\\n            busy.add(new int[]{server, end});\\n            max = Math.max(max, ++cnt[server]);\\n        }\\n        \\n        List<Integer> res = new ArrayList();\\n        for(int i = 0 ; i < k; i++) {\\n            if(cnt[i] == max) {\\n                res.add(i);\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)",
                    "Binary Tree"
                ],
                "code": "```\\n    //records how many load each server worked on.\\n    int[] cnt;\\n    public List<Integer> busiestServers(int k, int[] arrival, int[] load) {\\n        //only need K servers.\\n\\t\\tcnt = new int[k];\\n        int n = arrival.length, max = 0;\\n        //record <idx, endTime> to record each server\\'s free time start point \\n        PriorityQueue<int[]> busy = new PriorityQueue<>((a,b) -> a[1] - b[1]);\\n        //need to find >= (i % k) th sever, which needs servers in order, and ceiling function.\\n        TreeSet<Integer> free = new TreeSet();\\n        for(int i = 0 ; i < k; i++) {\\n            free.add(i);\\n        }\\n        for(int i = 0 ; i < n; i++){\\n            int start = arrival[i];\\n            int end = start + load[i];\\n            //add back all previous buys servers to free, if they can pick up new taskes.\\n\\t\\t\\t// each task is arrival in increasing start time order.\\n            while(!busy.isEmpty() && busy.peek()[1] <= start) {\\n                free.add(busy.poll()[0]);\\n            }\\n            //find the >= (i%K)\\n            Integer server = free.ceiling(i % k);\\n            if(server == null) {\\n                //if no bigger one, start from 0;\\n                server = free.ceiling(0);\\n            }\\n            //need to drop the task\\n            if(server == null) continue;\\n            free.remove(server);\\n            //means one server is doing something\\n            busy.add(new int[]{server, end});\\n            max = Math.max(max, ++cnt[server]);\\n        }\\n        \\n        List<Integer> res = new ArrayList();\\n        for(int i = 0 ; i < k; i++) {\\n            if(cnt[i] == max) {\\n                res.add(i);\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2525707,
                "title": "nlogn-solution-using-priorityqueue-and-treeset",
                "content": "```\\nclass Solution {\\n    public List<Integer> busiestServers(int k, int[] arrival, int[] load) {\\n        TreeSet<Integer> available = new TreeSet();//we will keep the available servers in order\\n        int[] count = new int[k];\\n        for(int i=0;i<k;i++){\\n            available.add(i);\\n        }\\n        int max = 0;\\n        PriorityQueue<int[]> pq = new PriorityQueue<int[]>((a,b)->Integer.compare(a[1], b[1]));//arr will be 1st param id of server and 2nd be the end time\\n        for(int i=0;i<arrival.length;i++){\\n            while(!pq.isEmpty() && pq.peek()[1] <= arrival[i]) {\\n                int[] arr = pq.remove();\\n                available.add(arr[0]);\\n            }\\n            if(available.contains(i%k)){\\n                available.remove(i%k);\\n                count[i%k]++;\\n                max = Math.max(max, count[i%k]);\\n                pq.add(new int[]{i%k, arrival[i]+load[i]});\\n            } else if(available.size() > 0){\\n                Integer next = available.higher(i%k) != null?available.higher(i%k):available.first();\\n                available.remove(next);\\n                count[next]++;\\n                max = Math.max(max, count[next]);\\n                pq.add(new int[]{next, arrival[i]+load[i]});    \\n            }\\n        }\\n        List<Integer> result = new LinkedList();\\n        for(int i=0;i<k;i++){\\n            if(count[i] == max){\\n                result.add(i);\\n            }\\n        }\\n        return result;\\n    }\\n}\\n\\n\\n//each request will have an end time , we will keep it in sorted order and will remove the \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> busiestServers(int k, int[] arrival, int[] load) {\\n        TreeSet<Integer> available = new TreeSet();//we will keep the available servers in order\\n        int[] count = new int[k];\\n        for(int i=0;i<k;i++){\\n            available.add(i);\\n        }\\n        int max = 0;\\n        PriorityQueue<int[]> pq = new PriorityQueue<int[]>((a,b)->Integer.compare(a[1], b[1]));//arr will be 1st param id of server and 2nd be the end time\\n        for(int i=0;i<arrival.length;i++){\\n            while(!pq.isEmpty() && pq.peek()[1] <= arrival[i]) {\\n                int[] arr = pq.remove();\\n                available.add(arr[0]);\\n            }\\n            if(available.contains(i%k)){\\n                available.remove(i%k);\\n                count[i%k]++;\\n                max = Math.max(max, count[i%k]);\\n                pq.add(new int[]{i%k, arrival[i]+load[i]});\\n            } else if(available.size() > 0){\\n                Integer next = available.higher(i%k) != null?available.higher(i%k):available.first();\\n                available.remove(next);\\n                count[next]++;\\n                max = Math.max(max, count[next]);\\n                pq.add(new int[]{next, arrival[i]+load[i]});    \\n            }\\n        }\\n        List<Integer> result = new LinkedList();\\n        for(int i=0;i<k;i++){\\n            if(count[i] == max){\\n                result.add(i);\\n            }\\n        }\\n        return result;\\n    }\\n}\\n\\n\\n//each request will have an end time , we will keep it in sorted order and will remove the \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2523922,
                "title": "python-brute-force-using-sortedset-4258-ms-50-1-mb",
                "content": "```\\nfrom sortedcontainers import SortedSet\\n\\nclass Solution(object):\\n    def busiestServers(self, k, arrival, load):\\n        \"\"\"\\n        :type k: int\\n        :type arrival: List[int]\\n        :type load: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        servers = list()\\n        emptyServers = SortedSet()\\n        handledRequestsCounter = list()\\n        for i in range(k):\\n            # initialise servers, each server (i.e. inner lists), if not empty,\\n            # should contain 2 values; request ID & enteredTime (time upon the request entered the server)\\n            servers.append([])\\n            \\n            # initialise emptyServers; all servers should be in emptyServers at the start\\n            emptyServers.add(i)\\n            \\n            # initialise handledRequestsCounter;\\n            # counts the number of requests each server has handled\\n            handledRequestsCounter.append(0)\\n        \\n        # initialise lastProcessedRequest\\n        # contains last known successful request\\n        lastProcessedRequest = None\\n\\n        processingRequests = dict()\\n\\n        # create timeSet to collate timings\\n        timeSet = set()\\n        for i, arrivalTime in enumerate(arrival):\\n            # add time upon requests will arrive at server\\n            timeSet.add(arrivalTime)\\n\\n            # add time upon requests should leave server\\n            timeSet.add(arrivalTime + load[i])\\n\\n        # create timeList for time to loop over\\n        timeList = sorted(timeSet)\\n        \\n        for time in timeList:\\n            # clear server and update handledRequestsCounter if load time is completed\\n            if time in processingRequests:\\n                for server in processingRequests[time]:\\n                    handledRequestsCounter[server] += 1\\n                    del servers[server][:]\\n                    emptyServers.add(server)\\n                else:\\n                    processingRequests.pop(time)\\n                    \\n            # move on to the next request after the last known successful request\\n            if lastProcessedRequest is None:\\n                i = 0\\n            else:\\n                i = lastProcessedRequest + 1\\n            \\n            # when all requests have arrived but some requests have not completed load time, move on to next iteration to complete their load time\\n            if i >= len(arrival):\\n                continue\\n\\n            arrivalTime = arrival[i]\\n            \\n            if arrivalTime == time:\\n                # when arrivalTime == time, request tries to enter a server\\n\\n                if len(servers[i%k]) == 0:\\n                    # if (i%k)th server is empty, request will enter this server\\n                    servers[i%k].extend((i, time))\\n                    emptyServers.remove(i%k)\\n                    try:\\n                        processingRequests[arrivalTime + load[i]].append(i%k)\\n                    except KeyError:\\n                        processingRequests[arrivalTime + load[i]] = [i%k]\\n                    # let server = servers[i%k]\\n                    # server[0] is requestID while server[1] is enteredTime\\n\\n                elif len(emptyServers) > 0:\\n                    # if (i%k)th server is occupied,\\n                    # request tries to enter servers after (i%k)th server\\n                    if emptyServers[-1] < i%k:\\n                        server = emptyServers[0]\\n                        servers[server].extend((i, time))\\n                        emptyServers.pop(0)\\n                        try:\\n                            processingRequests[arrivalTime + load[i]].append(server)\\n                        except KeyError:\\n                            processingRequests[arrivalTime + load[i]] = [server]\\n                    else:\\n                        v = emptyServers.bisect_left(i%k)\\n                        server = emptyServers[v]\\n                        servers[server].extend((i, time))\\n                        emptyServers.pop(v)\\n                        try:\\n                            processingRequests[arrivalTime + load[i]].append(server)\\n                        except KeyError:\\n                            processingRequests[arrivalTime + load[i]] = [server]\\n\\n                lastProcessedRequest = i\\n\\n            # if all servers are occupied, request is dropped; nothing will be done with this request\\n            \\n        maximumHandledRequests = max(handledRequestsCounter)\\n        # find all servers with maximumHandledRequests and collate them in busiestServers list\\n        busiestServers = [server for server, n in enumerate(handledRequestsCounter) if n == maximumHandledRequests]\\n\\n        return busiestServers\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom sortedcontainers import SortedSet\\n\\nclass Solution(object):\\n    def busiestServers(self, k, arrival, load):\\n        \"\"\"\\n        :type k: int\\n        :type arrival: List[int]\\n        :type load: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        servers = list()\\n        emptyServers = SortedSet()\\n        handledRequestsCounter = list()\\n        for i in range(k):\\n            # initialise servers, each server (i.e. inner lists), if not empty,\\n            # should contain 2 values; request ID & enteredTime (time upon the request entered the server)\\n            servers.append([])\\n            \\n            # initialise emptyServers; all servers should be in emptyServers at the start\\n            emptyServers.add(i)\\n            \\n            # initialise handledRequestsCounter;\\n            # counts the number of requests each server has handled\\n            handledRequestsCounter.append(0)\\n        \\n        # initialise lastProcessedRequest\\n        # contains last known successful request\\n        lastProcessedRequest = None\\n\\n        processingRequests = dict()\\n\\n        # create timeSet to collate timings\\n        timeSet = set()\\n        for i, arrivalTime in enumerate(arrival):\\n            # add time upon requests will arrive at server\\n            timeSet.add(arrivalTime)\\n\\n            # add time upon requests should leave server\\n            timeSet.add(arrivalTime + load[i])\\n\\n        # create timeList for time to loop over\\n        timeList = sorted(timeSet)\\n        \\n        for time in timeList:\\n            # clear server and update handledRequestsCounter if load time is completed\\n            if time in processingRequests:\\n                for server in processingRequests[time]:\\n                    handledRequestsCounter[server] += 1\\n                    del servers[server][:]\\n                    emptyServers.add(server)\\n                else:\\n                    processingRequests.pop(time)\\n                    \\n            # move on to the next request after the last known successful request\\n            if lastProcessedRequest is None:\\n                i = 0\\n            else:\\n                i = lastProcessedRequest + 1\\n            \\n            # when all requests have arrived but some requests have not completed load time, move on to next iteration to complete their load time\\n            if i >= len(arrival):\\n                continue\\n\\n            arrivalTime = arrival[i]\\n            \\n            if arrivalTime == time:\\n                # when arrivalTime == time, request tries to enter a server\\n\\n                if len(servers[i%k]) == 0:\\n                    # if (i%k)th server is empty, request will enter this server\\n                    servers[i%k].extend((i, time))\\n                    emptyServers.remove(i%k)\\n                    try:\\n                        processingRequests[arrivalTime + load[i]].append(i%k)\\n                    except KeyError:\\n                        processingRequests[arrivalTime + load[i]] = [i%k]\\n                    # let server = servers[i%k]\\n                    # server[0] is requestID while server[1] is enteredTime\\n\\n                elif len(emptyServers) > 0:\\n                    # if (i%k)th server is occupied,\\n                    # request tries to enter servers after (i%k)th server\\n                    if emptyServers[-1] < i%k:\\n                        server = emptyServers[0]\\n                        servers[server].extend((i, time))\\n                        emptyServers.pop(0)\\n                        try:\\n                            processingRequests[arrivalTime + load[i]].append(server)\\n                        except KeyError:\\n                            processingRequests[arrivalTime + load[i]] = [server]\\n                    else:\\n                        v = emptyServers.bisect_left(i%k)\\n                        server = emptyServers[v]\\n                        servers[server].extend((i, time))\\n                        emptyServers.pop(v)\\n                        try:\\n                            processingRequests[arrivalTime + load[i]].append(server)\\n                        except KeyError:\\n                            processingRequests[arrivalTime + load[i]] = [server]\\n\\n                lastProcessedRequest = i\\n\\n            # if all servers are occupied, request is dropped; nothing will be done with this request\\n            \\n        maximumHandledRequests = max(handledRequestsCounter)\\n        # find all servers with maximumHandledRequests and collate them in busiestServers list\\n        busiestServers = [server for server, n in enumerate(handledRequestsCounter) if n == maximumHandledRequests]\\n\\n        return busiestServers\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2521733,
                "title": "java-solution-101ms-100-time-priorityqueue-and-treeset",
                "content": "```\\nclass Solution {\\n    public List<Integer> busiestServers(int k, int[] arrival, int[] load) {\\n        List<Integer> result = new ArrayList<>();\\n        \\n        //trivial case\\n        if (k >= arrival.length){\\n            for (int i = 0; i < arrival.length; ++i){\\n                result.add(i);\\n            }\\n            return result;\\n        }\\n        \\n        //set time to arrival[0]\\n        int time = arrival[0];\\n        TreeSet<Integer> freeIndexSet = new TreeSet<>();\\n        int[] taskCount = new int[k];\\n        PriorityQueue<int[]> nextFree = new PriorityQueue<>((a, b) -> a[1] - b[1]);\\n        \\n        int i = 0;\\n        for (; i < k; ++i){\\n            nextFree.offer(new int[]{i, arrival[i] + load[i]});\\n        }\\n        \\n        \\n        //for each index in arrival\\n        for (; i < arrival.length; ++i){\\n            //move time to arrival[i]\\n            time = arrival[i];\\n            \\n            //remove from nextFree if servers become free, add to freeset\\n            while (!nextFree.isEmpty() && nextFree.peek()[1] <= time){\\n                freeIndexSet.add(nextFree.poll()[0]);\\n            }\\n            \\n            //try to assign task with load\\n            if (nextFree.size() < k){\\n                //if successful, add to count of server task\\n                int index = i % k;\\n\\n                Integer higherIndex = freeIndexSet.ceiling(index);\\n                if (higherIndex != null){\\n                    index = higherIndex.intValue();\\n                }\\n\\n                else {\\n                    index = freeIndexSet.ceiling(0).intValue();\\n                }\\n                \\n                ++taskCount[index];\\n                nextFree.offer(new int[] {index, time + load[i]});\\n                freeIndexSet.remove(index);\\n            }\\n        }\\n        \\n        //find servers with most arrivals\\n        int max = 0;\\n        for (int j = 0; j < k; ++j){\\n            max = Math.max(max, taskCount[j]);\\n        }\\n        \\n        for (int j = 0; j < k; ++j){\\n            if (max == taskCount[j]){\\n                result.add(j);\\n            }\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> busiestServers(int k, int[] arrival, int[] load) {\\n        List<Integer> result = new ArrayList<>();\\n        \\n        //trivial case\\n        if (k >= arrival.length){\\n            for (int i = 0; i < arrival.length; ++i){\\n                result.add(i);\\n            }\\n            return result;\\n        }\\n        \\n        //set time to arrival[0]\\n        int time = arrival[0];\\n        TreeSet<Integer> freeIndexSet = new TreeSet<>();\\n        int[] taskCount = new int[k];\\n        PriorityQueue<int[]> nextFree = new PriorityQueue<>((a, b) -> a[1] - b[1]);\\n        \\n        int i = 0;\\n        for (; i < k; ++i){\\n            nextFree.offer(new int[]{i, arrival[i] + load[i]});\\n        }\\n        \\n        \\n        //for each index in arrival\\n        for (; i < arrival.length; ++i){\\n            //move time to arrival[i]\\n            time = arrival[i];\\n            \\n            //remove from nextFree if servers become free, add to freeset\\n            while (!nextFree.isEmpty() && nextFree.peek()[1] <= time){\\n                freeIndexSet.add(nextFree.poll()[0]);\\n            }\\n            \\n            //try to assign task with load\\n            if (nextFree.size() < k){\\n                //if successful, add to count of server task\\n                int index = i % k;\\n\\n                Integer higherIndex = freeIndexSet.ceiling(index);\\n                if (higherIndex != null){\\n                    index = higherIndex.intValue();\\n                }\\n\\n                else {\\n                    index = freeIndexSet.ceiling(0).intValue();\\n                }\\n                \\n                ++taskCount[index];\\n                nextFree.offer(new int[] {index, time + load[i]});\\n                freeIndexSet.remove(index);\\n            }\\n        }\\n        \\n        //find servers with most arrivals\\n        int max = 0;\\n        for (int j = 0; j < k; ++j){\\n            max = Math.max(max, taskCount[j]);\\n        }\\n        \\n        for (int j = 0; j < k; ++j){\\n            if (max == taskCount[j]){\\n                result.add(j);\\n            }\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2518932,
                "title": "java-solution-with-explanation-map-treeset-heap",
                "content": "```\\n/**\\n    *   Keep a min heap for request-endTime sorted on endTime\\n    *   keep all available servers in treeset (for faster get of ceiling values)\\n    *   for every time remove completed requests from the heap\\n    *   then take next available server from set\\n    *   keep counting freq for each server\\n    *   at last, create result by iterating over freq map for max freq servers\\n    */\\n    \\n    // O(k + n*k*logk)\\n    public List<Integer> busiestServers(int k, int[] arrival, int[] load) {\\n        Map<Integer, Integer> freq = new HashMap<>();\\n        \\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[0] - b[0]); // [time, server]\\n        TreeSet<Integer> servers = new TreeSet<>();\\n        int max = 0;\\n        \\n        for(int i = 0; i < k; i++) servers.add(i); // O(k)\\n        \\n        for(int i = 0; i < arrival.length; i++) { // O(n)\\n            int t = arrival[i];\\n            while(!pq.isEmpty() && pq.peek()[0] <= t) servers.add(pq.poll()[1]); // O(klogk)\\n            \\n            if(servers.size() == 0) continue;\\n            Integer s = servers.ceiling(i%k);\\n            if(s == null) s = servers.first();\\n            servers.remove(s);\\n            \\n            freq.put(s, freq.getOrDefault(s, 0) + 1);\\n            max = Math.max(max, freq.get(s));\\n            pq.add(new int[] {t + load[i], s});\\n        }\\n                \\n        List<Integer> res = new ArrayList<>();\\n        for(int r: freq.keySet()) {\\n            if(max == freq.get(r)) res.add(r);\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Heap (Priority Queue)",
                    "Ordered Set"
                ],
                "code": "```\\n/**\\n    *   Keep a min heap for request-endTime sorted on endTime\\n    *   keep all available servers in treeset (for faster get of ceiling values)\\n    *   for every time remove completed requests from the heap\\n    *   then take next available server from set\\n    *   keep counting freq for each server\\n    *   at last, create result by iterating over freq map for max freq servers\\n    */\\n    \\n    // O(k + n*k*logk)\\n    public List<Integer> busiestServers(int k, int[] arrival, int[] load) {\\n        Map<Integer, Integer> freq = new HashMap<>();\\n        \\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[0] - b[0]); // [time, server]\\n        TreeSet<Integer> servers = new TreeSet<>();\\n        int max = 0;\\n        \\n        for(int i = 0; i < k; i++) servers.add(i); // O(k)\\n        \\n        for(int i = 0; i < arrival.length; i++) { // O(n)\\n            int t = arrival[i];\\n            while(!pq.isEmpty() && pq.peek()[0] <= t) servers.add(pq.poll()[1]); // O(klogk)\\n            \\n            if(servers.size() == 0) continue;\\n            Integer s = servers.ceiling(i%k);\\n            if(s == null) s = servers.first();\\n            servers.remove(s);\\n            \\n            freq.put(s, freq.getOrDefault(s, 0) + 1);\\n            max = Math.max(max, freq.get(s));\\n            pq.add(new int[] {t + load[i], s});\\n        }\\n                \\n        List<Integer> res = new ArrayList<>();\\n        for(int r: freq.keySet()) {\\n            if(max == freq.get(r)) res.add(r);\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2506300,
                "title": "c-set-priority-queue-o-nlogn",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n        int maxReq = 0;\\n        set<int> availableServers;\\n        unordered_map<int,int>serverToReqCount;\\n        \\n        priority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>>>pq;\\n        \\n        for(int i=0;i<k;i++)\\n            availableServers.insert(i);\\n        \\n        for(int i=0;i<arrival.size();i++){\\n            int start = arrival[i];\\n            int end = start + load[i];\\n            \\n            while(!pq.empty() && pq.top().first <= start){\\n                auto cur = pq.top();\\n                pq.pop();\\n                availableServers.insert(cur.second);\\n            }\\n            \\n            if(!availableServers.size())\\n                continue;\\n            \\n            int serverId = i % k;\\n            \\n            set<int>::iterator itr = availableServers.lower_bound(serverId);\\n            \\n            if(itr == availableServers.end()){\\n               itr = availableServers.begin();\\n            }\\n            \\n            serverToReqCount[*itr]++;\\n            maxReq= max(maxReq, serverToReqCount[*itr]);\\n            pq.push({end, *itr});\\n            \\n            availableServers.erase(itr);\\n  \\n        }\\n        \\n        vector<int>ans;\\n        \\n        for(auto p: serverToReqCount){\\n            if(p.second == maxReq)\\n                ans.push_back(p.first);\\n        }\\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "Heap (Priority Queue)",
                    "Binary Tree",
                    "Ordered Set"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n        int maxReq = 0;\\n        set<int> availableServers;\\n        unordered_map<int,int>serverToReqCount;\\n        \\n        priority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>>>pq;\\n        \\n        for(int i=0;i<k;i++)\\n            availableServers.insert(i);\\n        \\n        for(int i=0;i<arrival.size();i++){\\n            int start = arrival[i];\\n            int end = start + load[i];\\n            \\n            while(!pq.empty() && pq.top().first <= start){\\n                auto cur = pq.top();\\n                pq.pop();\\n                availableServers.insert(cur.second);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2461960,
                "title": "java-priorityqueue-treeset",
                "content": "It is just another two heap technique. O(NlgK) time complexity\\n```\\nclass Solution {\\n    public List<Integer> busiestServers(int k, int[] arrival, int[] load) {\\n        int[] cnt = new int[k];\\n        PriorityQueue<int[]> busy = new PriorityQueue<>(Comparator.comparing(e -> e[1]));\\n        TreeSet<Integer> avail = new TreeSet<>();\\n        int len = arrival.length;\\n        for(int i = 0; i < k; i++) {\\n            busy.add(new int[]{i, 0});\\n        }\\n        \\n        for(int i = 0; i < len; i++) {\\n            int time = arrival[i];\\n            int override = time + load[i];\\n            while(!busy.isEmpty() && busy.peek()[1] <= time) {\\n                avail.add(busy.poll()[0]);\\n            }\\n            if(avail.isEmpty()) continue;\\n            Integer find = avail.ceiling(i % k);\\n            if(find == null) find = avail.first();\\n            cnt[find]++;\\n            busy.add(new int[]{find, override});\\n            avail.remove(find);\\n        }\\n        \\n        List<Integer> ans = new LinkedList<>();\\n        int max = cnt[0];\\n        for(int i = 0; i < k; i++) {\\n            if(cnt[i] == max) {\\n                ans.add(i);\\n            }\\n            else if(cnt[i] > max) {\\n                max = cnt[i];\\n                ans.clear();\\n                ans.add(i);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n",
                "solutionTags": [],
                "code": "class Solution {\\n    public List<Integer> busiestServers(int k, int[] arrival, int[] load) {\\n        int[] cnt = new int[k];\\n        PriorityQueue<int[]> busy = new PriorityQueue<>(Comparator.comparing(e -> e[1]));\\n        TreeSet<Integer> avail = new TreeSet<>();\\n        int len = arrival.length;\\n        for(int i = 0; i < k; i++) {\\n            busy.add(new int[]{i, 0}",
                "codeTag": "Java"
            },
            {
                "id": 2444915,
                "title": "c-multimap-and-set",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n        set<int> available_servers;\\n        multimap<int,int> next_free_servers;\\n        vector<int> res;\\n \\t    vector<int> top_servers(k, 0);\\n \\n        for(int i = 0; i < k; ++i)\\n\\t\\t    available_servers.insert(i);\\n\\n\\t    for(int i = 0; i < arrival.size(); ++i) {\\n\\t\\t    int exec_time = arrival[i] + load[i];\\n            \\n            for(it = next_free_servers.begin(); it != next_free_servers.end(); ++it) {\\n                if(it->first > arrival[i])\\n                    break;\\n                available_servers.insert(it->second);\\n            }\\n            next_free_servers.erase(next_free_servers.begin(), it);\\n           \\n            if(!available_servers.size())\\n                continue;\\n            \\n            auto exec_server = available_servers.lower_bound(i % k);\\n            if(exec_server == available_servers.end())\\n                exec_server = available_servers.begin();\\n\\n            next_free_servers.insert(make_pair(exec_time, *exec_server));\\n            ++top_servers[*exec_server];\\n            available_servers.erase(exec_server);\\n        }\\n         \\n        int max_handled_server = *max_element(top_servers.begin(), top_servers.end());\\n        for(int i = 0; i < top_servers.size(); ++i) {\\n            if(top_servers[i] == max_handled_server)\\n                res.emplace_back(i);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n        set<int> available_servers;\\n        multimap<int,int> next_free_servers;\\n        vector<int> res;\\n \\t    vector<int> top_servers(k, 0);\\n \\n        for(int i = 0; i < k; ++i)\\n\\t\\t    available_servers.insert(i);\\n\\n\\t    for(int i = 0; i < arrival.size(); ++i) {\\n\\t\\t    int exec_time = arrival[i] + load[i];\\n            \\n            for(it = next_free_servers.begin(); it != next_free_servers.end(); ++it) {\\n                if(it->first > arrival[i])\\n                    break;\\n                available_servers.insert(it->second);\\n            }\\n            next_free_servers.erase(next_free_servers.begin(), it);\\n           \\n            if(!available_servers.size())\\n                continue;\\n            \\n            auto exec_server = available_servers.lower_bound(i % k);\\n            if(exec_server == available_servers.end())\\n                exec_server = available_servers.begin();\\n\\n            next_free_servers.insert(make_pair(exec_time, *exec_server));\\n            ++top_servers[*exec_server];\\n            available_servers.erase(exec_server);\\n        }\\n         \\n        int max_handled_server = *max_element(top_servers.begin(), top_servers.end());\\n        for(int i = 0; i < top_servers.size(); ++i) {\\n            if(top_servers[i] == max_handled_server)\\n                res.emplace_back(i);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2437691,
                "title": "python-priority-queue-with-detailed-explanation",
                "content": "```\\nclass Solution:\\n    def busiestServers(self, k: int, arrival: List[int], load: List[int]) -> List[int]:\\n        \\n        available = list(range(k)) \\n        busy = [] \\n        result = [0] * k\\n        \\n        for index, come in enumerate(arrival):\\n            while busy and busy[0][0] <= come: \\n                _, free = heapq.heappop(busy)\\n                heapq.heappush(available, index + (free - index) % k) \\n            if available: \\n                assigned = heapq.heappop(available) % k\\n                heapq.heappush(busy, (come + load[index], assigned))\\n                result[assigned] += 1\\n        \\n        Max = max(result)\\n        return [i for i in range(k) if result[i] == Max]\\n    \\n    \"\"\"\\n    Maintan two priority queues. AVAILABLE and BUSY. \\n    Take for example, input as k = 3; arrival = [1,2,3,4,5]; load = [5,2,3,3,3]\\n    Initialize AVAILABLE with (0, 1, 2).\\n    Push the servers into BUSY when tasks are assigned. \\n    In this example, you assign 0th item to server 0 (0 % 3).\\n    1st item to server 1 (1 % 3).\\n    2nd item to server 2 (2 % 3).\\n    At this stage, AVAILABLE is empty. BUSY = [(4, 1), (6, 0), (6, 1)]\\n    When you are inserting 3rd item with load 3, you need to assign it to \\n    (3 % 3) = 0th server. However, you can pop ony 1st server at this time. So, you\\n    have to assign it to first server.\\n    The expression, index + (free - index) % k does this.\\n    Here, index = 3. free = 1. index + (free - index) % 3 = 3 + (-2) % 3.\\n    That is, 3 + 1 = 4.\\n    This 4 is pulled out the the priority queue as 4 % 3 = 1.\\n    That is , we are saying server 0 is busy, add it one. \\n    This is exacly what the expression index + (free - index) % k does.\\n    \\n    Now, assume even 1 was not available, and server 2 is available. \\n    index = 3. free = 2. index + (free - index) % k = 3 + (2 - 3) % 3\\n    3 + (-1) % 3 = 3 + 2 = 5.\\n    When you pull this 5 out of the queue, you do 5 % 3 = 2. \\n    That is, you are adding the task to server 2.\\n    \\n    \"\"\"\\n```",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def busiestServers(self, k: int, arrival: List[int], load: List[int]) -> List[int]:\\n        \\n        available = list(range(k)) \\n        busy = [] \\n        result = [0] * k\\n        \\n        for index, come in enumerate(arrival):\\n            while busy and busy[0][0] <= come: \\n                _, free = heapq.heappop(busy)\\n                heapq.heappush(available, index + (free - index) % k) \\n            if available: \\n                assigned = heapq.heappop(available) % k\\n                heapq.heappush(busy, (come + load[index], assigned))\\n                result[assigned] += 1\\n        \\n        Max = max(result)\\n        return [i for i in range(k) if result[i] == Max]\\n    \\n    \"\"\"\\n    Maintan two priority queues. AVAILABLE and BUSY. \\n    Take for example, input as k = 3; arrival = [1,2,3,4,5]; load = [5,2,3,3,3]\\n    Initialize AVAILABLE with (0, 1, 2).\\n    Push the servers into BUSY when tasks are assigned. \\n    In this example, you assign 0th item to server 0 (0 % 3).\\n    1st item to server 1 (1 % 3).\\n    2nd item to server 2 (2 % 3).\\n    At this stage, AVAILABLE is empty. BUSY = [(4, 1), (6, 0), (6, 1)]\\n    When you are inserting 3rd item with load 3, you need to assign it to \\n    (3 % 3) = 0th server. However, you can pop ony 1st server at this time. So, you\\n    have to assign it to first server.\\n    The expression, index + (free - index) % k does this.\\n    Here, index = 3. free = 1. index + (free - index) % 3 = 3 + (-2) % 3.\\n    That is, 3 + 1 = 4.\\n    This 4 is pulled out the the priority queue as 4 % 3 = 1.\\n    That is , we are saying server 0 is busy, add it one. \\n    This is exacly what the expression index + (free - index) % k does.\\n    \\n    Now, assume even 1 was not available, and server 2 is available. \\n    index = 3. free = 2. index + (free - index) % k = 3 + (2 - 3) % 3\\n    3 + (-1) % 3 = 3 + 2 = 5.\\n    When you pull this 5 out of the queue, you do 5 % 3 = 2. \\n    That is, you are adding the task to server 2.\\n    \\n    \"\"\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2435047,
                "title": "python-consider-start-and-end-of-request-as-an-event-and-process-stream-of-events",
                "content": "```\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n    def busiestServers(self, k: int, arrival: List[int], load: List[int]) -> List[int]:\\n        free, processing, reqs = SortedList(range(k)), {}, [0] * k\\n        mx = 0       \\n        for t, tp, i in sorted(e for i, (r, t) in enumerate(zip(arrival, load)) for e in [(r, \\'S\\', i), (r+t, \\'E\\', i)]):\\n            if tp == \\'S\\': # Start of request\\n                if free:\\n                    sn = free.pop(free.bisect_left(i%k) % len(free))\\n                    processing[i] = sn\\n                    reqs[sn] += 1\\n                    mx = max(reqs[sn], mx)\\n                \\n            else: # End of request\\n                if i in processing:\\n                    sn = processing[i]\\n                    del processing[i]\\n                    free.add(sn)\\n    \\n        return [s for s, r in enumerate(reqs) if r == mx]\\n```",
                "solutionTags": [],
                "code": "```\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n    def busiestServers(self, k: int, arrival: List[int], load: List[int]) -> List[int]:\\n        free, processing, reqs = SortedList(range(k)), {}, [0] * k\\n        mx = 0       \\n        for t, tp, i in sorted(e for i, (r, t) in enumerate(zip(arrival, load)) for e in [(r, \\'S\\', i), (r+t, \\'E\\', i)]):\\n            if tp == \\'S\\': # Start of request\\n                if free:\\n                    sn = free.pop(free.bisect_left(i%k) % len(free))\\n                    processing[i] = sn\\n                    reqs[sn] += 1\\n                    mx = max(reqs[sn], mx)\\n                \\n            else: # End of request\\n                if i in processing:\\n                    sn = processing[i]\\n                    del processing[i]\\n                    free.add(sn)\\n    \\n        return [s for s, r in enumerate(reqs) if r == mx]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2396274,
                "title": "c-set-and-priority-queue",
                "content": "We keep track of the busy servers in a priority queue and the ready servers in a set.\\n```\\nclass Solution {\\npublic:\\n    vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n        vector<int> requests_handled(k, 0);\\n        // busy_servers is pq<pair<next avail time, server>>\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> busy_servers;\\n        set<int> ready_servers;\\n        for (int i = 0; i < k; ++i) {\\n            ready_servers.insert(i);\\n        }\\n        for (int i = 0; i < arrival.size(); ++i) {\\n            while (!busy_servers.empty() && busy_servers.top().first <= arrival[i]) {\\n                ready_servers.insert(busy_servers.top().second);\\n                busy_servers.pop();\\n            }\\n            if (ready_servers.empty()) continue;\\n            auto iter = ready_servers.lower_bound(i % k);\\n            if (iter == ready_servers.end()) {\\n                iter = ready_servers.begin();\\n            }\\n            ++requests_handled[*iter];\\n            busy_servers.push(make_pair(arrival[i] + load[i], *iter));\\n            ready_servers.erase(iter);\\n        }\\n        vector<int> busiest_servers;\\n        int max_requests = *max_element(requests_handled.begin(), requests_handled.end());\\n        for (int i = 0; i < k; ++i) {\\n            if (requests_handled[i] == max_requests) {\\n                busiest_servers.push_back(i);\\n            }\\n        }\\n        return busiest_servers;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n        vector<int> requests_handled(k, 0);\\n        // busy_servers is pq<pair<next avail time, server>>\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> busy_servers;\\n        set<int> ready_servers;\\n        for (int i = 0; i < k; ++i) {\\n            ready_servers.insert(i);\\n        }\\n        for (int i = 0; i < arrival.size(); ++i) {\\n            while (!busy_servers.empty() && busy_servers.top().first <= arrival[i]) {\\n                ready_servers.insert(busy_servers.top().second);\\n                busy_servers.pop();\\n            }\\n            if (ready_servers.empty()) continue;\\n            auto iter = ready_servers.lower_bound(i % k);\\n            if (iter == ready_servers.end()) {\\n                iter = ready_servers.begin();\\n            }\\n            ++requests_handled[*iter];\\n            busy_servers.push(make_pair(arrival[i] + load[i], *iter));\\n            ready_servers.erase(iter);\\n        }\\n        vector<int> busiest_servers;\\n        int max_requests = *max_element(requests_handled.begin(), requests_handled.end());\\n        for (int i = 0; i < k; ++i) {\\n            if (requests_handled[i] == max_requests) {\\n                busiest_servers.push_back(i);\\n            }\\n        }\\n        return busiest_servers;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2394558,
                "title": "java-treeset-heap-0-nlogn",
                "content": "```\\nclass Solution {\\n    public List<Integer> busiestServers(int k, int[] arrival, int[] load) {\\n        //arrival are sorted until that arrival get all the free servers\\n        PriorityQueue<int[]>pq=new PriorityQueue<>((a,b)->a[1]-b[1]);\\n        //id - end time\\n        \\n        int[]serve=new int[k];\\n        TreeSet<Integer>set=new TreeSet<>();\\n        \\n        for(int i=0;i<k;i++)set.add(i);\\n        \\n        int maxf=0;\\n            \\n        for(int i=0;i<arrival.length;i++){\\n            while(pq.size()>0 && pq.peek()[1] <= arrival[i])\\n                  set.add(pq.remove()[0]); //that server is now free to use\\n        \\n            int m=i%k;\\n            Integer ceil1=set.ceiling(m);\\n            Integer ceil2=set.ceiling(0);\\n            \\n           //System.out.println(ceil1+\" \"+ceil2);\\n            \\n            if(ceil1!=null){\\n                serve[ceil1]++;\\n                maxf=Math.max(maxf,serve[ceil1]);\\n                set.remove(ceil1);\\n                \\n                pq.add(new int[]{ceil1,arrival[i]+load[i]});\\n            }else if(ceil2!=null){\\n                serve[ceil2]++;\\n                maxf=Math.max(maxf,serve[ceil2]);\\n                set.remove(ceil2);\\n                \\n                pq.add(new int[]{ceil2,arrival[i]+load[i]});\\n            }\\n        }\\n        \\n        List<Integer>l=new ArrayList<>();\\n        for(int i=0;i<k;i++)\\n            if(serve[i]==maxf)l.add(i);\\n        \\n        return l;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> busiestServers(int k, int[] arrival, int[] load) {\\n        //arrival are sorted until that arrival get all the free servers\\n        PriorityQueue<int[]>pq=new PriorityQueue<>((a,b)->a[1]-b[1]);\\n        //id - end time\\n        \\n        int[]serve=new int[k];\\n        TreeSet<Integer>set=new TreeSet<>();\\n        \\n        for(int i=0;i<k;i++)set.add(i);\\n        \\n        int maxf=0;\\n            \\n        for(int i=0;i<arrival.length;i++){\\n            while(pq.size()>0 && pq.peek()[1] <= arrival[i])\\n                  set.add(pq.remove()[0]); //that server is now free to use\\n        \\n            int m=i%k;\\n            Integer ceil1=set.ceiling(m);\\n            Integer ceil2=set.ceiling(0);\\n            \\n           //System.out.println(ceil1+\" \"+ceil2);\\n            \\n            if(ceil1!=null){\\n                serve[ceil1]++;\\n                maxf=Math.max(maxf,serve[ceil1]);\\n                set.remove(ceil1);\\n                \\n                pq.add(new int[]{ceil1,arrival[i]+load[i]});\\n            }else if(ceil2!=null){\\n                serve[ceil2]++;\\n                maxf=Math.max(maxf,serve[ceil2]);\\n                set.remove(ceil2);\\n                \\n                pq.add(new int[]{ceil2,arrival[i]+load[i]});\\n            }\\n        }\\n        \\n        List<Integer>l=new ArrayList<>();\\n        for(int i=0;i<k;i++)\\n            if(serve[i]==maxf)l.add(i);\\n        \\n        return l;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2370859,
                "title": "nlogk-sweep-line-pq",
                "content": "1- maintain end time (X) in priority queue \\n2- scan through arrivals times\\n3- pop heap for all the events before time\\n4- binary look for the free server\\n```\\npublic List<Integer> busiestServers(int k, int[] arrival, int[] load) {\\n        TreeSet<Integer> free = new TreeSet<>();\\n        for(int idx=0; idx < k; ++idx) free.add(idx);\\n        int [] perf = new int[k];\\n        int max = 0;\\n        \\n        PriorityQueue<int[]> pq = new PriorityQueue<>((u, v) -> {\\n            int cmp = Integer.compare(u[0], v[0]);\\n            if(cmp != 0) return cmp;\\n            return Integer.compare(u[1], v[1]);\\n        });\\n        \\n        for(int idx=0; idx < arrival.length; ++idx) {\\n            int time = arrival[idx];\\n            //sweep out end times\\n            while(!pq.isEmpty() && pq.peek()[0] <= time) {\\n                free.add(pq.peek()[1]);\\n                pq.poll();\\n            }\\n            \\n            //~ drop req\\n            if(pq.size() == k) continue;\\n            \\n            //~ guaranteed that at least one server is free \\n            Integer srv = idx%k;\\n            srv = free.ceiling(srv);\\n            if(srv == null) srv = free.first();\\n            \\n            free.remove(srv);\\n            pq.add(new int[]{time+load[idx], srv});\\n            perf[srv] += 1;\\n            max = Math.max(perf[srv], max);\\n        }\\n\\n        List<Integer> res = new ArrayList<>();\\n        for(int idx=0; idx < k; ++idx)  if(perf[idx] == max) res.add(idx);\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic List<Integer> busiestServers(int k, int[] arrival, int[] load) {\\n        TreeSet<Integer> free = new TreeSet<>();\\n        for(int idx=0; idx < k; ++idx) free.add(idx);\\n        int [] perf = new int[k];\\n        int max = 0;\\n        \\n        PriorityQueue<int[]> pq = new PriorityQueue<>((u, v) -> {\\n            int cmp = Integer.compare(u[0], v[0]);\\n            if(cmp != 0) return cmp;\\n            return Integer.compare(u[1], v[1]);\\n        });\\n        \\n        for(int idx=0; idx < arrival.length; ++idx) {\\n            int time = arrival[idx];\\n            //sweep out end times\\n            while(!pq.isEmpty() && pq.peek()[0] <= time) {\\n                free.add(pq.peek()[1]);\\n                pq.poll();\\n            }\\n            \\n            //~ drop req\\n            if(pq.size() == k) continue;\\n            \\n            //~ guaranteed that at least one server is free \\n            Integer srv = idx%k;\\n            srv = free.ceiling(srv);\\n            if(srv == null) srv = free.first();\\n            \\n            free.remove(srv);\\n            pq.add(new int[]{time+load[idx], srv});\\n            perf[srv] += 1;\\n            max = Math.max(perf[srv], max);\\n        }\\n\\n        List<Integer> res = new ArrayList<>();\\n        for(int idx=0; idx < k; ++idx)  if(perf[idx] == max) res.add(idx);\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2282388,
                "title": "java-priority-queue-treeset-oo",
                "content": "**Explanation**\\n1. What you have in hand is the list of available servers\\n2. adding each process to the min heap with end time (arrival + load) and allocated server\\n3. before adding, make sure you remove the process which is complete, and those servers to the available servers list.\\n4. Keep track of the max variable of utilized server.\\n5. get the result.\\n\\n**if you like the solution, please upvote!**\\n\\n```\\nclass Solution {\\n    static class Process {\\n        int end, server;\\n        Process(int end, int server) {\\n            this.end = end;\\n            this.server = server;\\n        }\\n    }\\n    public List<Integer> busiestServers(int k, int[] arrival, int[] load) {\\n        Queue<Process> minHeap = new PriorityQueue<Process>((p1, p2) -> Integer.compare(p1.end, p2.end));\\n        \\n        TreeSet<Integer> availableServers = new TreeSet();\\n        for (int server = 0; server < k; server++) {\\n            availableServers.add(server);\\n        }\\n        int requests = arrival.length;\\n        int[] serversUsed = new int[k];\\n        int max = Integer.MIN_VALUE;\\n        for (int request = 0; request < requests; request++) {\\n            while (!minHeap.isEmpty() && minHeap.peek().end <= arrival[request]) {\\n                Process process = minHeap.remove();\\n                availableServers.add(process.server);\\n            }\\n            \\n            if (availableServers.isEmpty()) continue;\\n            Integer nextAvailableServer = availableServers.ceiling(request % k);\\n            if (nextAvailableServer == null) nextAvailableServer = availableServers.first();\\n            minHeap.offer(new Process(arrival[request] + load[request], nextAvailableServer));\\n            serversUsed[nextAvailableServer]++;\\n            max = Math.max(max, serversUsed[nextAvailableServer]);\\n            availableServers.remove(nextAvailableServer);\\n        }\\n        List<Integer> result = new ArrayList();\\n        for (int server = 0; server < k; server++) {\\n            if (serversUsed[server] == max) {\\n                result.add(server);\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    static class Process {\\n        int end, server;\\n        Process(int end, int server) {\\n            this.end = end;\\n            this.server = server;\\n        }\\n    }\\n    public List<Integer> busiestServers(int k, int[] arrival, int[] load) {\\n        Queue<Process> minHeap = new PriorityQueue<Process>((p1, p2) -> Integer.compare(p1.end, p2.end));\\n        \\n        TreeSet<Integer> availableServers = new TreeSet();\\n        for (int server = 0; server < k; server++) {\\n            availableServers.add(server);\\n        }\\n        int requests = arrival.length;\\n        int[] serversUsed = new int[k];\\n        int max = Integer.MIN_VALUE;\\n        for (int request = 0; request < requests; request++) {\\n            while (!minHeap.isEmpty() && minHeap.peek().end <= arrival[request]) {\\n                Process process = minHeap.remove();\\n                availableServers.add(process.server);\\n            }\\n            \\n            if (availableServers.isEmpty()) continue;\\n            Integer nextAvailableServer = availableServers.ceiling(request % k);\\n            if (nextAvailableServer == null) nextAvailableServer = availableServers.first();\\n            minHeap.offer(new Process(arrival[request] + load[request], nextAvailableServer));\\n            serversUsed[nextAvailableServer]++;\\n            max = Math.max(max, serversUsed[nextAvailableServer]);\\n            availableServers.remove(nextAvailableServer);\\n        }\\n        List<Integer> result = new ArrayList();\\n        for (int server = 0; server < k; server++) {\\n            if (serversUsed[server] == max) {\\n                result.add(server);\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2265634,
                "title": "c-priority-queue-set-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    // O((N+K)logk) time, O(K) space\\n    vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n        busiest = INT_MIN;\\n        this->k = k;\\n        inUse.resize(k,0);\\n        \\n        // O(KlogK) time, O(K) space. Where K is k\\n        for(int i=0;i<k;i++) freeServers.insert(i);\\n        \\n        priority_queue<pair<int,int>, vector<pair<int,int>>, greater<>> pq;\\n        \\n        // O(N) for outer loop. Where N is the number of requests.\\n        for(int i=0;i<arrival.size();i++)\\n        {\\n            int curTime = arrival[i];\\n            int loadTime = load[i];\\n            \\n            int serverId = -1;\\n            // pop finished requests\\n            while(!pq.empty() && pq.top().first <= curTime)\\n            {\\n                serverId = pq.top().second;\\n                inUse[serverId] = 0;\\n                freeServers.insert(serverId);\\n                pq.pop();\\n            }\\n            \\n            // push current request\\n            // O(logK)\\n            if(pq.empty())\\n            {\\n                serverId = i%k;\\n                pushRequest(serverId, curTime, loadTime, pq);\\n            }\\n            else if(pq.size() < k)\\n            {\\n                int j = i;\\n                auto iter = freeServers.lower_bound(j%k);\\n                if(iter == freeServers.end())\\n                {\\n                    iter = freeServers.lower_bound(0);\\n                }\\n                \\n                serverId = *iter;\\n                pushRequest(serverId, curTime, loadTime, pq);\\n            }  \\n        }\\n        \\n        // O(K)\\n        findAns();\\n        return ans;\\n    }\\n    \\nprivate:\\n    int k, busiest;\\n    vector<int> inUse;\\n    vector<int> ans;\\n    set<int> freeServers;\\n    unordered_map<int,int> serverCount; // serverId-> requests handled by this server.\\n    \\n    void findAns()\\n    {\\n        for(const auto& element : serverCount)\\n        {\\n            if(element.second == busiest)\\n                ans.push_back(element.first);\\n        }\\n    }\\n    \\n    void pushRequest(int serverId, int curTime, int loadTime,\\n                     priority_queue<pair<int,int>, vector<pair<int,int>>, greater<>>& pq)\\n    {\\n        inUse[serverId] = 1;\\n        freeServers.erase(serverId);\\n        serverCount[serverId]++;\\n        busiest = max(busiest, serverCount[serverId]);\\n        pq.push( {curTime+loadTime, serverId} );\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // O((N+K)logk) time, O(K) space\\n    vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n        busiest = INT_MIN;\\n        this->k = k;\\n        inUse.resize(k,0);\\n        \\n        // O(KlogK) time, O(K) space. Where K is k\\n        for(int i=0;i<k;i++) freeServers.insert(i);\\n        \\n        priority_queue<pair<int,int>, vector<pair<int,int>>, greater<>> pq;\\n        \\n        // O(N) for outer loop. Where N is the number of requests.\\n        for(int i=0;i<arrival.size();i++)\\n        {\\n            int curTime = arrival[i];\\n            int loadTime = load[i];\\n            \\n            int serverId = -1;\\n            // pop finished requests\\n            while(!pq.empty() && pq.top().first <= curTime)\\n            {\\n                serverId = pq.top().second;\\n                inUse[serverId] = 0;\\n                freeServers.insert(serverId);\\n                pq.pop();\\n            }\\n            \\n            // push current request\\n            // O(logK)\\n            if(pq.empty())\\n            {\\n                serverId = i%k;\\n                pushRequest(serverId, curTime, loadTime, pq);\\n            }\\n            else if(pq.size() < k)\\n            {\\n                int j = i;\\n                auto iter = freeServers.lower_bound(j%k);\\n                if(iter == freeServers.end())\\n                {\\n                    iter = freeServers.lower_bound(0);\\n                }\\n                \\n                serverId = *iter;\\n                pushRequest(serverId, curTime, loadTime, pq);\\n            }  \\n        }\\n        \\n        // O(K)\\n        findAns();\\n        return ans;\\n    }\\n    \\nprivate:\\n    int k, busiest;\\n    vector<int> inUse;\\n    vector<int> ans;\\n    set<int> freeServers;\\n    unordered_map<int,int> serverCount; // serverId-> requests handled by this server.\\n    \\n    void findAns()\\n    {\\n        for(const auto& element : serverCount)\\n        {\\n            if(element.second == busiest)\\n                ans.push_back(element.first);\\n        }\\n    }\\n    \\n    void pushRequest(int serverId, int curTime, int loadTime,\\n                     priority_queue<pair<int,int>, vector<pair<int,int>>, greater<>>& pq)\\n    {\\n        inUse[serverId] = 1;\\n        freeServers.erase(serverId);\\n        serverCount[serverId]++;\\n        busiest = max(busiest, serverCount[serverId]);\\n        pq.push( {curTime+loadTime, serverId} );\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2240266,
                "title": "c-set-map",
                "content": "* `free` maintains the servers which are free to take up requests.\\n\\n* `busy` includes the pairs of  [time it takes to finish the assigned task, server].\\n\\n* The Tricky part is while iterating in `arrivals` , we check for the lower_bound of index `i%k` in `free` , that will automatically ensure that next free server picked. \\n```\\nclass Solution {\\npublic:\\n    set<int> free ;\\n    set<pair<int,int>> busy ; // finish_time , id\\n    map<int,int> mpp ;\\n    int maxi  = 0 ;\\n    vector<int> ans ;\\n    vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n        for(int i = 0 ; i < k ; ++i) free.insert(i) , free.insert(i + k) ;\\n        \\n        for(int i = 0 ; i < arrival.size() ; ++i ){\\n            while(busy.size() and arrival[i] >= begin(busy)->first){\\n                free.insert(begin(busy)->second % k) ;\\n                free.insert(begin(busy)->second % k + k) ;\\n                busy.erase(begin(busy));\\n            }\\n            if(free.empty()) continue ;\\n            \\n            int server = (*free.lower_bound(i%k)) % k ; \\n            free.erase(server) ; free.erase(server + k) ;\\n            busy.insert({arrival[i] + load[i] , server}) ;\\n            ++mpp[server] ; maxi = max(maxi,mpp[server]) ;\\n        }\\n        \\n        for(auto &x : mpp) if(x.second == maxi) ans.push_back(x.first) ;\\n        return ans ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    set<int> free ;\\n    set<pair<int,int>> busy ; // finish_time , id\\n    map<int,int> mpp ;\\n    int maxi  = 0 ;\\n    vector<int> ans ;\\n    vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n        for(int i = 0 ; i < k ; ++i) free.insert(i) , free.insert(i + k) ;\\n        \\n        for(int i = 0 ; i < arrival.size() ; ++i ){\\n            while(busy.size() and arrival[i] >= begin(busy)->first){\\n                free.insert(begin(busy)->second % k) ;\\n                free.insert(begin(busy)->second % k + k) ;\\n                busy.erase(begin(busy));\\n            }\\n            if(free.empty()) continue ;\\n            \\n            int server = (*free.lower_bound(i%k)) % k ; \\n            free.erase(server) ; free.erase(server + k) ;\\n            busy.insert({arrival[i] + load[i] , server}) ;\\n            ++mpp[server] ; maxi = max(maxi,mpp[server]) ;\\n        }\\n        \\n        for(auto &x : mpp) if(x.second == maxi) ans.push_back(x.first) ;\\n        return ans ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2232928,
                "title": "cpp-min-heap-set",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> busiestServers(int k, vector<int>& arr, vector<int>& load) {\\n        int n=arr.size();\\n        set<int>st;\\n        vector<int>cnt(k,0);\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>pq;\\n        for(int i=0;i<k;i++)pq.push({0,i});\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            int pos=i%k;\\n            int tme=arr[i];\\n            while(pq.size()>0&&pq.top().first<=tme)\\n            {\\n                st.insert(pq.top().second);\\n                pq.pop();\\n            }\\n            auto idx=st.lower_bound(pos);\\n            if(idx==st.end())\\n            idx=st.lower_bound(0);\\n            if(idx==st.end())continue;\\n            int id=*idx;\\n            pq.push({load[i]+tme,id});\\n            cnt[id]++;\\n            //cout<<id<<\"\\\\n\";\\n            st.erase(idx);\\n        }\\n        int mxm=0;\\n        for(auto&p:cnt)mxm=max(mxm,p);\\n        vector<int>ans;\\n        for(int i=0;i<k;i++){if(cnt[i]==mxm)ans.push_back(i);}\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> busiestServers(int k, vector<int>& arr, vector<int>& load) {\\n        int n=arr.size();\\n        set<int>st;\\n        vector<int>cnt(k,0);\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>pq;\\n        for(int i=0;i<k;i++)pq.push({0,i});\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            int pos=i%k;\\n            int tme=arr[i];\\n            while(pq.size()>0&&pq.top().first<=tme)\\n            {\\n                st.insert(pq.top().second);\\n                pq.pop();\\n            }\\n            auto idx=st.lower_bound(pos);\\n            if(idx==st.end())\\n            idx=st.lower_bound(0);\\n            if(idx==st.end())continue;\\n            int id=*idx;\\n            pq.push({load[i]+tme,id});\\n            cnt[id]++;\\n            //cout<<id<<\"\\\\n\";\\n            st.erase(idx);\\n        }\\n        int mxm=0;\\n        for(auto&p:cnt)mxm=max(mxm,p);\\n        vector<int>ans;\\n        for(int i=0;i<k;i++){if(cnt[i]==mxm)ans.push_back(i);}\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2230313,
                "title": "c-heap-set-easy-solution-faster-than-83",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n        set<int>avalServers;\\n        for(int i=0; i<k; i++){\\n            avalServers.insert(i);\\n        }\\n        int len = arrival.size();\\n        vector<int>taskCount(k,0);\\n        int maxCount = 0;\\n        priority_queue<pair<int ,int>, vector<pair<int,int>>, greater<pair<int,int>>> minH; // {endTime, id}\\n        for(int task = 0; task<len; task++){\\n            int startTime = arrival[task];\\n            retrieveServer(minH, startTime, avalServers);\\n            \\n\\t\\t\\t//find next aval server\\n            if(avalServers.empty()) continue;\\n            auto iter = avalServers.lower_bound(task%k);\\n            if(iter == avalServers.end()) iter=avalServers.begin();\\n            int curServer = *iter;\\n            taskCount[curServer]++;\\n            maxCount = max(maxCount, taskCount[curServer]);\\n            \\n            avalServers.erase(curServer);\\n            minH.push({startTime+load[task], curServer});\\n        }\\n        \\n        vector<int>res;\\n        for(int i=0; i<k; i++){\\n            if(taskCount[i]==maxCount){\\n                res.push_back(i);\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    void retrieveServer(priority_queue<pair<int ,int>, vector<pair<int,int>>, greater<pair<int,int>>> & minH, int startTime,\\n                       set<int>& avalServers){\\n        while(!minH.empty() && (minH.top().first)<=startTime){\\n            avalServers.insert(minH.top().second);\\n            minH.pop();\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n        set<int>avalServers;\\n        for(int i=0; i<k; i++){\\n            avalServers.insert(i);\\n        }\\n        int len = arrival.size();\\n        vector<int>taskCount(k,0);\\n        int maxCount = 0;\\n        priority_queue<pair<int ,int>, vector<pair<int,int>>, greater<pair<int,int>>> minH; // {endTime, id}\\n        for(int task = 0; task<len; task++){\\n            int startTime = arrival[task];\\n            retrieveServer(minH, startTime, avalServers);\\n            \\n\\t\\t\\t//find next aval server\\n            if(avalServers.empty()) continue;\\n            auto iter = avalServers.lower_bound(task%k);\\n            if(iter == avalServers.end()) iter=avalServers.begin();\\n            int curServer = *iter;\\n            taskCount[curServer]++;\\n            maxCount = max(maxCount, taskCount[curServer]);\\n            \\n            avalServers.erase(curServer);\\n            minH.push({startTime+load[task], curServer});\\n        }\\n        \\n        vector<int>res;\\n        for(int i=0; i<k; i++){\\n            if(taskCount[i]==maxCount){\\n                res.push_back(i);\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    void retrieveServer(priority_queue<pair<int ,int>, vector<pair<int,int>>, greater<pair<int,int>>> & minH, int startTime,\\n                       set<int>& avalServers){\\n        while(!minH.empty() && (minH.top().first)<=startTime){\\n            avalServers.insert(minH.top().second);\\n            minH.pop();\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2219059,
                "title": "balanced-bst-algorithm",
                "content": "```\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n    def busiestServers(self, k: int, arrival: List[int], load: List[int]) -> List[int]:\\n        freq = [0]*k\\n        busy = [] # min-heap \\n        free = SortedList(range(k)) # balanced bst\\n        \\n        for i, (ta, tl) in enumerate(zip(arrival, load)): \\n            while busy and busy[0][0] <= ta: \\n                _, ii = heappop(busy)\\n                free.add(ii)\\n            \\n            if free: \\n                ii = free.bisect_left(i%k) % len(free)\\n                server = free.pop(ii)\\n                freq[server] += 1\\n                heappush(busy, (ta+tl, server))\\n        \\n        mx = max(freq)\\n        return [i for i, x in enumerate(freq) if x == mx]\\n```",
                "solutionTags": [],
                "code": "```\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n    def busiestServers(self, k: int, arrival: List[int], load: List[int]) -> List[int]:\\n        freq = [0]*k\\n        busy = [] # min-heap \\n        free = SortedList(range(k)) # balanced bst\\n        \\n        for i, (ta, tl) in enumerate(zip(arrival, load)): \\n            while busy and busy[0][0] <= ta: \\n                _, ii = heappop(busy)\\n                free.add(ii)\\n            \\n            if free: \\n                ii = free.bisect_left(i%k) % len(free)\\n                server = free.pop(ii)\\n                freq[server] += 1\\n                heappush(busy, (ta+tl, server))\\n        \\n        mx = max(freq)\\n        return [i for i, x in enumerate(freq) if x == mx]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2206274,
                "title": "javascript-tle-solution-with-priorityqueue-and-hashset",
                "content": "```\\nvar busiestServers = function(k, arrival, load) {\\n    let loadMap = {};\\n    let pq = new MinPriorityQueue({ compare: (a,b) => a[1] - b[1] });\\n    let availableServers = new Set(new Array(k).fill(0).map((_, index) => index));\\n\\n    for (let i = 0; i < arrival.length; i++) {\\n        // calc end time\\n        let end = arrival[i] + load[i];\\n        \\n        // bring server back\\n        while (pq.front()?.[1] <= arrival[i]) {\\n            const [server] = pq.dequeue();\\n            availableServers.add(server);\\n        }\\n        \\n        let server = i % k;\\n        // drop if no available server\\n        if (availableServers.size === 0) continue;\\n        \\n        // find the next avaiable sever\\n        while (!availableServers.has(server)) {\\n            server++;\\n            if (server === k + 1) {\\n                server = 0;\\n            }\\n        }\\n        \\n        // record the load\\n        if (!loadMap[server]) {\\n            loadMap[server] = 0;\\n        }\\n        \\n        loadMap[server]++;\\n        \\n        availableServers.delete(server);\\n        pq.enqueue([server, end]);\\n    }\\n    \\n    let res = [];\\n    let sorted = Object.entries(loadMap).sort((a,b) => b[1] - a[1]);\\n    let max = sorted[0][1];\\n    let i = 0;\\n    while (sorted[i]?.[1] === max) {\\n        res.push(+sorted[i++][0]);\\n    }\\n    \\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar busiestServers = function(k, arrival, load) {\\n    let loadMap = {};\\n    let pq = new MinPriorityQueue({ compare: (a,b) => a[1] - b[1] });\\n    let availableServers = new Set(new Array(k).fill(0).map((_, index) => index));\\n\\n    for (let i = 0; i < arrival.length; i++) {\\n        // calc end time\\n        let end = arrival[i] + load[i];\\n        \\n        // bring server back\\n        while (pq.front()?.[1] <= arrival[i]) {\\n            const [server] = pq.dequeue();\\n            availableServers.add(server);\\n        }\\n        \\n        let server = i % k;\\n        // drop if no available server\\n        if (availableServers.size === 0) continue;\\n        \\n        // find the next avaiable sever\\n        while (!availableServers.has(server)) {\\n            server++;\\n            if (server === k + 1) {\\n                server = 0;\\n            }\\n        }\\n        \\n        // record the load\\n        if (!loadMap[server]) {\\n            loadMap[server] = 0;\\n        }\\n        \\n        loadMap[server]++;\\n        \\n        availableServers.delete(server);\\n        pq.enqueue([server, end]);\\n    }\\n    \\n    let res = [];\\n    let sorted = Object.entries(loadMap).sort((a,b) => b[1] - a[1]);\\n    let max = sorted[0][1];\\n    let i = 0;\\n    while (sorted[i]?.[1] === max) {\\n        res.push(+sorted[i++][0]);\\n    }\\n    \\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2186916,
                "title": "python-heap-sortedlist",
                "content": "```\\nfrom sortedcontainers import SortedList\\nclass Solution:\\n    def busiestServers(self, k: int, x: List[int], y: List[int]) -> List[int]:\\n        z=SortedList([i for i in range(k)])\\n        q=[]\\n        f=defaultdict(int)\\n        l=len(x)\\n        for i in range(l):\\n            while q and q[0][0]<=x[i]:\\n                _,b=heappop(q)\\n                z.add(b)\\n            if not z:continue\\n            index=z.bisect_left(i%k)\\n            if index>=len(z):index=0\\n            heappush(q,(y[i]+x[i],z[index]))\\n            f[z[index]]+=1\\n            del z[index]\\n        ma=max(f.values())\\n        return [i for i in f if f[i]==ma]\\n```",
                "solutionTags": [],
                "code": "```\\nfrom sortedcontainers import SortedList\\nclass Solution:\\n    def busiestServers(self, k: int, x: List[int], y: List[int]) -> List[int]:\\n        z=SortedList([i for i in range(k)])\\n        q=[]\\n        f=defaultdict(int)\\n        l=len(x)\\n        for i in range(l):\\n            while q and q[0][0]<=x[i]:\\n                _,b=heappop(q)\\n                z.add(b)\\n            if not z:continue\\n            index=z.bisect_left(i%k)\\n            if index>=len(z):index=0\\n            heappush(q,(y[i]+x[i],z[index]))\\n            f[z[index]]+=1\\n            del z[index]\\n        ma=max(f.values())\\n        return [i for i in f if f[i]==ma]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2143059,
                "title": "c-priority-queue-ordered-set-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n        int i, j;\\n        set<int> available;\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\\n        int handledReq[k];\\n        int maxServe = 0;\\n        \\n        for(i = 0; i < k; i++){\\n            available.insert(i);\\n            handledReq[i] = 0;\\n        }\\n        \\n        for(i = 0; i < arrival.size(); i++){\\n            while(!pq.empty() && pq.top().first <= arrival[i]){\\n                j = pq.top().second;\\n                available.insert(j);\\n                pq.pop();\\n            }\\n            \\n            j = i % k;\\n            \\n            auto it = available.lower_bound(j);\\n            \\n            if(it == available.end()){\\n                it = available.begin();\\n            }\\n            \\n            if(it != available.end()){\\n                j = *it;\\n           \\n                handledReq[j]++; \\n                maxServe = max(handledReq[j], maxServe);\\n                pq.push(make_pair(arrival[i] + load[i], j));\\n                available.erase(it);\\n            }\\n        }\\n        \\n        vector<int> maxReq;\\n        for(i = 0; i < k; i++){\\n            if(handledReq[i] == maxServe){\\n                maxReq.push_back(i);\\n            }\\n        }\\n        \\n        return maxReq;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n        int i, j;\\n        set<int> available;\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\\n        int handledReq[k];\\n        int maxServe = 0;\\n        \\n        for(i = 0; i < k; i++){\\n            available.insert(i);\\n            handledReq[i] = 0;\\n        }\\n        \\n        for(i = 0; i < arrival.size(); i++){\\n            while(!pq.empty() && pq.top().first <= arrival[i]){\\n                j = pq.top().second;\\n                available.insert(j);\\n                pq.pop();\\n            }\\n            \\n            j = i % k;\\n            \\n            auto it = available.lower_bound(j);\\n            \\n            if(it == available.end()){\\n                it = available.begin();\\n            }\\n            \\n            if(it != available.end()){\\n                j = *it;\\n           \\n                handledReq[j]++; \\n                maxServe = max(handledReq[j], maxServe);\\n                pq.push(make_pair(arrival[i] + load[i], j));\\n                available.erase(it);\\n            }\\n        }\\n        \\n        vector<int> maxReq;\\n        for(i = 0; i < k; i++){\\n            if(handledReq[i] == maxServe){\\n                maxReq.push_back(i);\\n            }\\n        }\\n        \\n        return maxReq;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2133652,
                "title": "python-two-heaps",
                "content": "```\\nfrom heapq import heappush, heappop\\nfrom collections import defaultdict\\nclass Solution:\\n    def busiestServers(self, k: int, arrival: List[int], load: List[int]) -> List[int]:\\n        available = [i for i in range(k)]\\n        busy = []\\n        res = defaultdict(int)\\n        for i, s in enumerate(arrival):\\n            while busy and busy[0][0] <= s:\\n                heappush(available, i + (heappop(busy)[1]-i) % k)\\n            if available:\\n                j = heappop(available)%k\\n                res[j] += 1\\n                heappush(busy,(s+load[i], j))\\n        busiest = max(res.values())\\n        return [i for i in res if res[i] == busiest ]\\n",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nfrom heapq import heappush, heappop\\nfrom collections import defaultdict\\nclass Solution:\\n    def busiestServers(self, k: int, arrival: List[int], load: List[int]) -> List[int]:\\n        available = [i for i in range(k)]\\n        busy = []\\n        res = defaultdict(int)\\n        for i, s in enumerate(arrival):\\n            while busy and busy[0][0] <= s:\\n                heappush(available, i + (heappop(busy)[1]-i) % k)\\n            if available:\\n                j = heappop(available)%k\\n                res[j] += 1\\n                heappush(busy,(s+load[i], j))\\n        busiest = max(res.values())\\n        return [i for i in res if res[i] == busiest ]\\n",
                "codeTag": "Java"
            },
            {
                "id": 2106364,
                "title": "don-t-use-set-use-map-for-lower-bound-because-map-s-lower-bound-is-too-must-fast-than-set",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> busiestServers(int k, vector<int>& a, vector<int>& load) \\n    {\\n        int cnt[k+1];   memset(cnt,0,sizeof(cnt));\\n        set<pair<int,int>> free;\\n        map<int,bool> avl;\\n        for(int i=0;i<k;i++) \\n            avl.insert({i,1});\\n        \\n        for(int i=0;i<a.size();i++)\\n        {\\n            while(free.size()>0 && (*free.begin()).first<=a[i])\\n                avl.insert({(*free.begin()).second,1}),free.erase(free.begin());\\n            \\n            auto it=avl.lower_bound(i%k);\\n            if(it==avl.end() && avl.size()>0)\\n                it=avl.begin();\\n            if(it!=avl.end())\\n            {\\n                cnt[(*it).first]++;\\n                free.insert({a[i]+load[i],(*it).first});\\n                avl.erase(it);\\n            }\\n        }\\n                           \\n        int mx=0;\\n        for(int i=0;i<k;i++)\\n            mx=max(mx,cnt[i]);\\n        vector<int> ans;\\n        for(int i=0;i<k;i++)\\n            if(cnt[i]==mx)\\n                ans.push_back(i);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> busiestServers(int k, vector<int>& a, vector<int>& load) \\n    {\\n        int cnt[k+1];   memset(cnt,0,sizeof(cnt));\\n        set<pair<int,int>> free;\\n        map<int,bool> avl;\\n        for(int i=0;i<k;i++) \\n            avl.insert({i,1});\\n        \\n        for(int i=0;i<a.size();i++)\\n        {\\n            while(free.size()>0 && (*free.begin()).first<=a[i])\\n                avl.insert({(*free.begin()).second,1}),free.erase(free.begin());\\n            \\n            auto it=avl.lower_bound(i%k);\\n            if(it==avl.end() && avl.size()>0)\\n                it=avl.begin();\\n            if(it!=avl.end())\\n            {\\n                cnt[(*it).first]++;\\n                free.insert({a[i]+load[i],(*it).first});\\n                avl.erase(it);\\n            }\\n        }\\n                           \\n        int mx=0;\\n        for(int i=0;i<k;i++)\\n            mx=max(mx,cnt[i]);\\n        vector<int> ans;\\n        for(int i=0;i<k;i++)\\n            if(cnt[i]==mx)\\n                ans.push_back(i);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2092247,
                "title": "simple-python-sorted-list",
                "content": "```\\nfrom sortedcontainers import SortedList\\nimport heapq\\nclass Solution:\\n    def do_task(self, idx, stt, end):\\n        while self.busy and self.busy[0][0] <= stt:\\n            s, i = heapq.heappop(self.busy)\\n            self.idle.add(i)\\n        if len(self.idle) == 0:\\n            return\\n        ii = idx % self.k\\n        if self.idle[-1] >= ii:\\n            x = self.idle.bisect_left(ii)\\n        else:\\n            x = 0\\n        i = self.idle.pop(x)\\n        self.ct_map[i] += 1\\n        heapq.heappush(self.busy, (end, i))\\n    \\n    def busiestServers(self, k: int, arrival: List[int], load: List[int]) -> List[int]:\\n        self.k = k\\n        self.idle = SortedList()\\n        for i in range(k):\\n            self.idle.add(i)\\n        self.busy = []\\n        self.ct_map = {i: 0 for i in range(k)}\\n        idx = 0\\n        for stt, ld in zip(arrival, load):\\n            end = stt+ld\\n            self.do_task(idx, stt, end)\\n            idx += 1\\n        \\n        rst = []\\n        bct = 0\\n        for i, ct in self.ct_map.items():\\n            if ct > bct:\\n                bct = ct\\n                rst = [i]\\n            elif ct == bct:\\n                rst.append(i)\\n        return rst\\n```",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nfrom sortedcontainers import SortedList\\nimport heapq\\nclass Solution:\\n    def do_task(self, idx, stt, end):\\n        while self.busy and self.busy[0][0] <= stt:\\n            s, i = heapq.heappop(self.busy)\\n            self.idle.add(i)\\n        if len(self.idle) == 0:\\n            return\\n        ii = idx % self.k\\n        if self.idle[-1] >= ii:\\n            x = self.idle.bisect_left(ii)\\n        else:\\n            x = 0\\n        i = self.idle.pop(x)\\n        self.ct_map[i] += 1\\n        heapq.heappush(self.busy, (end, i))\\n    \\n    def busiestServers(self, k: int, arrival: List[int], load: List[int]) -> List[int]:\\n        self.k = k\\n        self.idle = SortedList()\\n        for i in range(k):\\n            self.idle.add(i)\\n        self.busy = []\\n        self.ct_map = {i: 0 for i in range(k)}\\n        idx = 0\\n        for stt, ld in zip(arrival, load):\\n            end = stt+ld\\n            self.do_task(idx, stt, end)\\n            idx += 1\\n        \\n        rst = []\\n        bct = 0\\n        for i, ct in self.ct_map.items():\\n            if ct > bct:\\n                bct = ct\\n                rst = [i]\\n            elif ct == bct:\\n                rst.append(i)\\n        return rst\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2085094,
                "title": "c-priority-queue-ordered-set",
                "content": "```\\n#define pii pair<int,int>\\nclass Solution {\\npublic:\\n    vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n        set<int>servers;\\n        unordered_map<int,int>count;\\n        priority_queue<pii,vector<pii>,greater<pii>>pq;\\n        for(int i=0;i<k;i++)\\n            servers.insert(i);\\n        for(int i=0;i<arrival.size();i++){\\n            \\n            while(!pq.empty()  && pq.top().first<=arrival[i]){\\n                auto fr = pq.top();\\n                pq.pop();\\n                servers.insert(fr.second);\\n            }\\n            \\n            if(!servers.size())\\n                continue;\\n            \\n            auto it = servers.lower_bound(i%k);\\n            if(it==servers.end()){\\n                it = servers.begin();\\n            }\\n            int server = *it;\\n            count[server]++;\\n            pq.push({arrival[i]+load[i],server});\\n            servers.erase(it);\\n        }\\n        int mx = 0;\\n        vector<int>ans;\\n        for(auto it :count){\\n            mx = max(mx,it.second);\\n        }\\n        for(auto it : count){\\n            if(it.second==mx){\\n                ans.push_back(it.first);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)",
                    "Ordered Set"
                ],
                "code": "```\\n#define pii pair<int,int>\\nclass Solution {\\npublic:\\n    vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n        set<int>servers;\\n        unordered_map<int,int>count;\\n        priority_queue<pii,vector<pii>,greater<pii>>pq;\\n        for(int i=0;i<k;i++)\\n            servers.insert(i);\\n        for(int i=0;i<arrival.size();i++){\\n            \\n            while(!pq.empty()  && pq.top().first<=arrival[i]){\\n                auto fr = pq.top();\\n                pq.pop();\\n                servers.insert(fr.second);\\n            }\\n            \\n            if(!servers.size())\\n                continue;\\n            \\n            auto it = servers.lower_bound(i%k);\\n            if(it==servers.end()){\\n                it = servers.begin();\\n            }\\n            int server = *it;\\n            count[server]++;\\n            pq.push({arrival[i]+load[i],server});\\n            servers.erase(it);\\n        }\\n        int mx = 0;\\n        vector<int>ans;\\n        for(auto it :count){\\n            mx = max(mx,it.second);\\n        }\\n        for(auto it : count){\\n            if(it.second==mx){\\n                ans.push_back(it.first);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2041097,
                "title": "java-priorityqueue-treeset-easy-to-understand",
                "content": "Maintain a treeset for all free server ids. Each time, try to get a server id from the treeset by:\\n```\\n\\t\\t\\tint index = i % k;    \\n            int serverId = freeServers.ceiling(index) == null ? freeServers.first() : freeServers.ceiling(index);\\n```\\n\\nMaintain a min priority queue for server id and end time pair, sort by end time in asending order. Each time, when a new task comes, just free the server from the priority queue if its end time <= task start time.\\n\\n**Code**\\n```\\n   public List<Integer> busiestServers(int k, int[] arrival, int[] load) {\\n        int[] counts = new int[k];\\n        TreeSet<Integer> freeServers = new TreeSet();\\n        int max = 0;\\n        for(int i=0; i<k; i++) {\\n           freeServers.add(i); \\n        }\\n        \\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a,b) -> Integer.compare(a[1], b[1])); //server, time\\n        \\n        for(int i=0; i<arrival.length; i++) {\\n            int start = arrival[i];\\n            int duration = load[i];\\n            int total = start + duration;\\n            \\n            while(!pq.isEmpty() && pq.peek()[1] <= start) {\\n                freeServers.add(pq.poll()[0]);\\n            }\\n            \\n            if(freeServers.isEmpty()) {\\n                continue;\\n            }\\n            \\n            int index = i % k;\\n            int serverId = freeServers.ceiling(index) == null ? freeServers.first() : freeServers.ceiling(index);\\n            freeServers.remove(serverId);\\n            counts[serverId]++;\\n            max = Math.max(max, counts[serverId]);\\n            pq.offer(new int[]{serverId, total});\\n        }\\n        \\n        List<Integer> ans = new ArrayList();\\n        for(int i=0; i<k; i++) {\\n            if(counts[i] == max) {\\n                ans.add(i);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n\\t\\t\\tint index = i % k;    \\n            int serverId = freeServers.ceiling(index) == null ? freeServers.first() : freeServers.ceiling(index);\\n```\n```\\n   public List<Integer> busiestServers(int k, int[] arrival, int[] load) {\\n        int[] counts = new int[k];\\n        TreeSet<Integer> freeServers = new TreeSet();\\n        int max = 0;\\n        for(int i=0; i<k; i++) {\\n           freeServers.add(i); \\n        }\\n        \\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a,b) -> Integer.compare(a[1], b[1])); //server, time\\n        \\n        for(int i=0; i<arrival.length; i++) {\\n            int start = arrival[i];\\n            int duration = load[i];\\n            int total = start + duration;\\n            \\n            while(!pq.isEmpty() && pq.peek()[1] <= start) {\\n                freeServers.add(pq.poll()[0]);\\n            }\\n            \\n            if(freeServers.isEmpty()) {\\n                continue;\\n            }\\n            \\n            int index = i % k;\\n            int serverId = freeServers.ceiling(index) == null ? freeServers.first() : freeServers.ceiling(index);\\n            freeServers.remove(serverId);\\n            counts[serverId]++;\\n            max = Math.max(max, counts[serverId]);\\n            pq.offer(new int[]{serverId, total});\\n        }\\n        \\n        List<Integer> ans = new ArrayList();\\n        for(int i=0; i<k; i++) {\\n            if(counts[i] == max) {\\n                ans.add(i);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2017380,
                "title": "why-this-case-failed",
                "content": "My codes failed on one test case :\\n3\\n[1,2,3,4,8,9,10]\\n[5,2,10,3,1,2,2]\\nI return [0,1] while it expect [1]\\nWhy it failed?\\nLet\\'s market the abve request as [a,b,c,d,e,f,g]\\nIt will be handled like :\\nserver 0: aaaaa--eff-\\nserver 1: -bbddd-gg\\nserver 2:--cccccccccc\\nserver 0  will handle 3 requests arrived on 1,8 and 9\\nserver 1 also handle 3 requests arrive on 2, 4 and 10\\n\\nDid I misunderstood anything?",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 1995686,
                "title": "python-sortedlist-and-heap",
                "content": "```\\nfrom sortedcontainers import SortedList\\nclass Solution:\\n    def busiestServers(self, k: int, arrival: List[int], load: List[int]) -> List[int]:\\n        completed = [0] * k\\n        tasks = []\\n        available = SortedList(range(k))\\n        greatest = 0\\n        out = []\\n        for i, (t, l) in enumerate(zip(arrival, load)):\\n            while tasks and tasks[0][0] <= t:\\n                _, server = heappop(tasks)\\n                completed[server] += 1\\n                if completed[server] > greatest:\\n                    greatest = completed[server]\\n                    out = [server]\\n                elif completed[server] == greatest:\\n                    out.append(server)\\n                available.add(server)\\n            if len(available) == 0:\\n                continue\\n            server = i % k\\n            index = available.bisect_left(server)\\n            if index == len(available):\\n                index = 0\\n            heappush(tasks, (t + l, available.pop(index)))\\n        while tasks:\\n            _, server = tasks.pop()\\n            completed[server] += 1\\n            if completed[server] > greatest:\\n                greatest = completed[server]\\n                out = [server]\\n            elif completed[server] == greatest:\\n                out.append(server)\\n        return out\\n```",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nfrom sortedcontainers import SortedList\\nclass Solution:\\n    def busiestServers(self, k: int, arrival: List[int], load: List[int]) -> List[int]:\\n        completed = [0] * k\\n        tasks = []\\n        available = SortedList(range(k))\\n        greatest = 0\\n        out = []\\n        for i, (t, l) in enumerate(zip(arrival, load)):\\n            while tasks and tasks[0][0] <= t:\\n                _, server = heappop(tasks)\\n                completed[server] += 1\\n                if completed[server] > greatest:\\n                    greatest = completed[server]\\n                    out = [server]\\n                elif completed[server] == greatest:\\n                    out.append(server)\\n                available.add(server)\\n            if len(available) == 0:\\n                continue\\n            server = i % k\\n            index = available.bisect_left(server)\\n            if index == len(available):\\n                index = 0\\n            heappush(tasks, (t + l, available.pop(index)))\\n        while tasks:\\n            _, server = tasks.pop()\\n            completed[server] += 1\\n            if completed[server] > greatest:\\n                greatest = completed[server]\\n                out = [server]\\n            elif completed[server] == greatest:\\n                out.append(server)\\n        return out\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1977192,
                "title": "python-heap-bisect-with-sorted-array-with-explanation-in-comments",
                "content": "```\\nclass Solution:\\n    def busiestServers(self, k: int, arrival: List[int], load: List[int]) -> List[int]:\\n        \\'\\'\\'\\n        keep track of number of requests served by a server x in requestsCnts array\\n        keep track of availability of server using sorted array,\\n            use python\\'s bisect_left to insert and find available servers in sorted array\\n        keep track of requests completion aka expiry time to server via expiryTimeToServers and, \\n        when time == expiry time, make associated server available.\\n        use a min-heap to get minimum completion times\\n            e.g. heap array [(5, server0)]\\n        At end of serving all requests,\\n        iterate throguh requestsCnts to find busiestServers\\n        \\n        time complexity calc - n = requests, k = servers\\n        We have to iterate each request in for loop - o(n) \\n        - o(logk) - for bringing servers in available state during each arrival of request\\n        - o(logk) - to find next available server\\n        but when we remove a server from available servers list. we take o(k) time and this\\n        in worst case can happen for all requests\\n        so o(n*k) + o(k) = o(n*k)\\n        \\n        memory\\n        o(k) for requestsCnts and availableServers, o(n) for expiryTimeToServer,\\n        \\'\\'\\'\\n        from heapq import heappop, heappush\\n        import bisect\\n        requestsCnts = [0]*k\\n        availableServers = []\\n        for i in range(k):\\n            availableServers.append(i)\\n        expiryTimeToServer = []\\n        \\n        def getFirstAvailableServer(requestIdx):\\n            n = len(availableServers)\\n            if requestIdx > availableServers[n-1]:\\n                serverIdx = availableServers[0]\\n            else:\\n                i = bisect.bisect_left(availableServers, requestIdx)\\n                serverIdx = availableServers[i]\\n            availableServers.remove(serverIdx)\\n            return serverIdx\\n        \\n        def insertAvailableServer(server):\\n            n = len(availableServers)\\n            if n == 0:\\n                availableServers.append(server)\\n                return\\n            i = bisect.bisect_left(availableServers, server)\\n            availableServers.insert(i, server)\\n                \\n        for requestIdx, arrivaltime in enumerate(arrival):\\n            # if server is becoming availble make server available\\n            while len(expiryTimeToServer) > 0:\\n                availabilityTime, server = heappop(expiryTimeToServer)\\n                if availabilityTime > arrivaltime:\\n                    heappush(expiryTimeToServer, (availabilityTime, server))\\n                    break\\n                \\n                #make server available\\n                insertAvailableServer(server)\\n                \\n            if len(availableServers) == 0:\\n                continue\\n                \\n            serverIdx = getFirstAvailableServer(requestIdx%k)\\n            # add no. of request handled by this available server\\n            requestsCnts[serverIdx] += 1\\n            # add request expiry in expiryTimeToServer map\\n            heappush(expiryTimeToServer, (arrivaltime+load[requestIdx], serverIdx))\\n            \\n        # iterate over requestsCnts\\n        maxRequests, busiestServers = 0, []\\n        for i, requests in enumerate(requestsCnts):\\n            if requests > maxRequests:\\n                maxRequests = requests\\n                busiestServers = [i]\\n            elif requests == maxRequests:\\n                busiestServers.append(i)\\n                \\n        return busiestServers\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def busiestServers(self, k: int, arrival: List[int], load: List[int]) -> List[int]:\\n        \\'\\'\\'\\n        keep track of number of requests served by a server x in requestsCnts array\\n        keep track of availability of server using sorted array,\\n            use python\\'s bisect_left to insert and find available servers in sorted array\\n        keep track of requests completion aka expiry time to server via expiryTimeToServers and, \\n        when time == expiry time, make associated server available.\\n        use a min-heap to get minimum completion times\\n            e.g. heap array [(5, server0)]\\n        At end of serving all requests,\\n        iterate throguh requestsCnts to find busiestServers\\n        \\n        time complexity calc - n = requests, k = servers\\n        We have to iterate each request in for loop - o(n) \\n        - o(logk) - for bringing servers in available state during each arrival of request\\n        - o(logk) - to find next available server\\n        but when we remove a server from available servers list. we take o(k) time and this\\n        in worst case can happen for all requests\\n        so o(n*k) + o(k) = o(n*k)\\n        \\n        memory\\n        o(k) for requestsCnts and availableServers, o(n) for expiryTimeToServer,\\n        \\'\\'\\'\\n        from heapq import heappop, heappush\\n        import bisect\\n        requestsCnts = [0]*k\\n        availableServers = []\\n        for i in range(k):\\n            availableServers.append(i)\\n        expiryTimeToServer = []\\n        \\n        def getFirstAvailableServer(requestIdx):\\n            n = len(availableServers)\\n            if requestIdx > availableServers[n-1]:\\n                serverIdx = availableServers[0]\\n            else:\\n                i = bisect.bisect_left(availableServers, requestIdx)\\n                serverIdx = availableServers[i]\\n            availableServers.remove(serverIdx)\\n            return serverIdx\\n        \\n        def insertAvailableServer(server):\\n            n = len(availableServers)\\n            if n == 0:\\n                availableServers.append(server)\\n                return\\n            i = bisect.bisect_left(availableServers, server)\\n            availableServers.insert(i, server)\\n                \\n        for requestIdx, arrivaltime in enumerate(arrival):\\n            # if server is becoming availble make server available\\n            while len(expiryTimeToServer) > 0:\\n                availabilityTime, server = heappop(expiryTimeToServer)\\n                if availabilityTime > arrivaltime:\\n                    heappush(expiryTimeToServer, (availabilityTime, server))\\n                    break\\n                \\n                #make server available\\n                insertAvailableServer(server)\\n                \\n            if len(availableServers) == 0:\\n                continue\\n                \\n            serverIdx = getFirstAvailableServer(requestIdx%k)\\n            # add no. of request handled by this available server\\n            requestsCnts[serverIdx] += 1\\n            # add request expiry in expiryTimeToServer map\\n            heappush(expiryTimeToServer, (arrivaltime+load[requestIdx], serverIdx))\\n            \\n        # iterate over requestsCnts\\n        maxRequests, busiestServers = 0, []\\n        for i, requests in enumerate(requestsCnts):\\n            if requests > maxRequests:\\n                maxRequests = requests\\n                busiestServers = [i]\\n            elif requests == maxRequests:\\n                busiestServers.append(i)\\n                \\n        return busiestServers\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1927616,
                "title": "c-clean-code",
                "content": "Named all things best to their use. \\nPLease UPVOTE if u like.\\n```\\nclass Solution {\\npublic:\\n    vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n        vector <array<int, 3>> events;\\n        int n = arrival.size();\\n        for (int i = 0; i < n; ++i) {\\n            events.push_back({arrival[i], 1, i});\\n            events.push_back({arrival[i] + load[i], 0, i});\\n        }\\n        sort(events.begin(), events.end());\\n        vector <int> cnt(k);\\n        vector <int> busiest;\\n        set <int> working;\\n        set <int> free;\\n        for (int i = 0; i < k; ++i) {\\n            free.insert(i);\\n        }\\n        vector <int> who(n, -1);\\n        for (int i = 0; i < events.size(); ++i) {\\n            int time = events[i][0];\\n            int type = events[i][1];\\n            int idx = events[i][2];\\n            if (type == 0) {\\n                if (who[idx] != -1) {\\n                    working.erase(who[idx]);\\n                    free.insert(who[idx]);\\n                }\\n            } else {\\n                int who_can = idx % k;\\n                if (free.size() == 0) {\\n                    who[idx] = -1;\\n                    continue;\\n                } else {\\n                    auto it = free.lower_bound(who_can);\\n                    if (it == free.end()) {\\n                        it = free.begin();\\n                    }\\n                    who_can = *it;\\n                    free.erase(who_can);\\n                    cnt[who_can]++;\\n                    working.insert(who_can);\\n                    who[idx] = who_can;\\n                }\\n            }\\n        }\\n        int mx = 0;\\n        /*\\n            For debugging..\\n        for (int i = 0; i < n; ++i) {\\n            cout << who[i] << \" \";\\n        }\\n        cout << \\'\\\\n\\';\\n        */\\n        for (int i = 0; i < k; ++i) {\\n            mx = max(mx, cnt[i]);\\n            //cout << cnt[i] << \" \";\\n        }\\n        for (int i = 0; i < k; ++i) {\\n            if (cnt[i] == mx) {\\n                busiest.push_back(i);\\n            }\\n        }\\n        return busiest;\\n    }\\n};\\n```\\nComment down below for further Queries.\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n        vector <array<int, 3>> events;\\n        int n = arrival.size();\\n        for (int i = 0; i < n; ++i) {\\n            events.push_back({arrival[i], 1, i});\\n            events.push_back({arrival[i] + load[i], 0, i});\\n        }\\n        sort(events.begin(), events.end());\\n        vector <int> cnt(k);\\n        vector <int> busiest;\\n        set <int> working;\\n        set <int> free;\\n        for (int i = 0; i < k; ++i) {\\n            free.insert(i);\\n        }\\n        vector <int> who(n, -1);\\n        for (int i = 0; i < events.size(); ++i) {\\n            int time = events[i][0];\\n            int type = events[i][1];\\n            int idx = events[i][2];\\n            if (type == 0) {\\n                if (who[idx] != -1) {\\n                    working.erase(who[idx]);\\n                    free.insert(who[idx]);\\n                }\\n            } else {\\n                int who_can = idx % k;\\n                if (free.size() == 0) {\\n                    who[idx] = -1;\\n                    continue;\\n                } else {\\n                    auto it = free.lower_bound(who_can);\\n                    if (it == free.end()) {\\n                        it = free.begin();\\n                    }\\n                    who_can = *it;\\n                    free.erase(who_can);\\n                    cnt[who_can]++;\\n                    working.insert(who_can);\\n                    who[idx] = who_can;\\n                }\\n            }\\n        }\\n        int mx = 0;\\n        /*\\n            For debugging..\\n        for (int i = 0; i < n; ++i) {\\n            cout << who[i] << \" \";\\n        }\\n        cout << \\'\\\\n\\';\\n        */\\n        for (int i = 0; i < k; ++i) {\\n            mx = max(mx, cnt[i]);\\n            //cout << cnt[i] << \" \";\\n        }\\n        for (int i = 0; i < k; ++i) {\\n            if (cnt[i] == mx) {\\n                busiest.push_back(i);\\n            }\\n        }\\n        return busiest;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1887825,
                "title": "c-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n        set<int>available = getSet(k);\\n        map<int,int>frequencies;\\n        set<pair<int,int>>busy;\\n        for(int i = 0; i < arrival.size(); ++i) {\\n            int arrivalTime = arrival[i], loadTime = load[i];\\n            while(busy.size() && busy.begin()->first <= arrivalTime) {\\n                auto [availableTime, index] = *busy.begin();\\n                available.insert(index);\\n                busy.erase(busy.begin());\\n            }\\n            if(available.empty()) {\\n                continue;\\n            }\\n            int position = getPosition(i,k,available);\\n            frequencies[position]++;\\n            busy.insert({arrivalTime+loadTime, position});\\n        }\\n        return getResult(frequencies);\\n    }\\n    \\n    int getPosition(int i, int k, set<int>&available) {\\n        int position = i%k;\\n        auto pos = available.lower_bound(position);\\n        if(pos == available.end()) {\\n            pos = available.begin();\\n        }\\n        position = *pos;\\n        available.erase(pos);\\n        return position;\\n    }\\n    \\n    vector<int> getResult(map<int,int>&frequencies) {\\n        int maxFrequency = 0;\\n        vector<int>result;\\n        for(auto [value, frequency]: frequencies) {\\n            maxFrequency = max(maxFrequency, frequency);\\n        }\\n        for(auto [value, frequency]: frequencies) {\\n            if(frequency == maxFrequency) {\\n                result.push_back(value);\\n            }\\n        }\\n        return result;\\n    }\\n    \\n    set<int> getSet(int k) {\\n        set<int>available;\\n        for(int i = 0; i < k; ++i) {\\n            available.insert(i);\\n        }\\n        return available;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n        set<int>available = getSet(k);\\n        map<int,int>frequencies;\\n        set<pair<int,int>>busy;\\n        for(int i = 0; i < arrival.size(); ++i) {\\n            int arrivalTime = arrival[i], loadTime = load[i];\\n            while(busy.size() && busy.begin()->first <= arrivalTime) {\\n                auto [availableTime, index] = *busy.begin();\\n                available.insert(index);\\n                busy.erase(busy.begin());\\n            }\\n            if(available.empty()) {\\n                continue;\\n            }\\n            int position = getPosition(i,k,available);\\n            frequencies[position]++;\\n            busy.insert({arrivalTime+loadTime, position});\\n        }\\n        return getResult(frequencies);\\n    }\\n    \\n    int getPosition(int i, int k, set<int>&available) {\\n        int position = i%k;\\n        auto pos = available.lower_bound(position);\\n        if(pos == available.end()) {\\n            pos = available.begin();\\n        }\\n        position = *pos;\\n        available.erase(pos);\\n        return position;\\n    }\\n    \\n    vector<int> getResult(map<int,int>&frequencies) {\\n        int maxFrequency = 0;\\n        vector<int>result;\\n        for(auto [value, frequency]: frequencies) {\\n            maxFrequency = max(maxFrequency, frequency);\\n        }\\n        for(auto [value, frequency]: frequencies) {\\n            if(frequency == maxFrequency) {\\n                result.push_back(value);\\n            }\\n        }\\n        return result;\\n    }\\n    \\n    set<int> getSet(int k) {\\n        set<int>available;\\n        for(int i = 0; i < k; ++i) {\\n            available.insert(i);\\n        }\\n        return available;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1884534,
                "title": "first-version-python-heap",
                "content": "```import heapq\\nimport bisect\\n\\nclass Solution:\\n    def __init__(self):\\n        self.availableServers = []\\n        self.requestsOfServers = []\\n        self.trackRunningProcess = []\\n    def busiestServers(self, k: int, arrival: List[int], load: List[int]) -> List[int]:\\n        \\n#         initialize severs\\'statues\\n        for i in range(k):\\n            self.availableServers.append(i)\\n            self.requestsOfServers.append(0)\\n#             heapify two lists\\n        heapq.heapify(self.trackRunningProcess)\\n        heapq.heapify(self.availableServers)\\n#         Start to handle requests\\n        for index, (a, l) in enumerate(zip(arrival, load)):\\n            # print(self.availableServers)\\n            # print(self.requestsOfServers)\\n            # print(self.trackRunningProcess)\\n            totalTimeCost = a + l\\n#             Need to pop servers which has done the request when the new request arrives\\n            while len(self.trackRunningProcess) and self.trackRunningProcess[0][0] <= a:\\n                heapq.heappush(self.availableServers, self.trackRunningProcess[0][1])\\n                heapq.heappop(self.trackRunningProcess)\\n#             Need to handle current request now\\n#             Check whether there is available serevr now\\n            if index%k in self.availableServers:\\n                heapq.heappush(self.trackRunningProcess, (totalTimeCost, index%k))\\n                self.availableServers.remove(index%k)\\n                self.requestsOfServers[index%k] += 1\\n            else:\\n                if len(self.availableServers):\\n                    serverToBeUsed = index%k\\n                    self.availableServers.sort()\\n                    if bisect.bisect_left(self.availableServers, serverToBeUsed) == len(self.availableServers):\\n                        serverToBeUsed = heapq.heappop(self.availableServers)\\n                    else:\\n                        serverToBeUsed = self.availableServers[bisect.bisect_left(self.availableServers, serverToBeUsed)]\\n                        self.availableServers.remove(serverToBeUsed)\\n                    heapq.heappush(self.trackRunningProcess, (totalTimeCost, serverToBeUsed))\\n                    self.requestsOfServers[serverToBeUsed] += 1\\n                else:\\n#                     drop this request\\n                    continue\\n#         Calculate the result\\n        # print(self.requestsOfServers)\\n        maxRqs = max(self.requestsOfServers)\\n        return [i for i, val in enumerate(self.requestsOfServers) if val == maxRqs ]\\n        \\n",
                "solutionTags": [],
                "code": "```import heapq\\nimport bisect\\n\\nclass Solution:\\n    def __init__(self):\\n        self.availableServers = []\\n        self.requestsOfServers = []\\n        self.trackRunningProcess = []\\n    def busiestServers(self, k: int, arrival: List[int], load: List[int]) -> List[int]:\\n        \\n#         initialize severs\\'statues\\n        for i in range(k):\\n            self.availableServers.append(i)\\n            self.requestsOfServers.append(0)\\n#             heapify two lists\\n        heapq.heapify(self.trackRunningProcess)\\n        heapq.heapify(self.availableServers)\\n#         Start to handle requests\\n        for index, (a, l) in enumerate(zip(arrival, load)):\\n            # print(self.availableServers)\\n            # print(self.requestsOfServers)\\n            # print(self.trackRunningProcess)\\n            totalTimeCost = a + l\\n#             Need to pop servers which has done the request when the new request arrives\\n            while len(self.trackRunningProcess) and self.trackRunningProcess[0][0] <= a:\\n                heapq.heappush(self.availableServers, self.trackRunningProcess[0][1])\\n                heapq.heappop(self.trackRunningProcess)\\n#             Need to handle current request now\\n#             Check whether there is available serevr now\\n            if index%k in self.availableServers:\\n                heapq.heappush(self.trackRunningProcess, (totalTimeCost, index%k))\\n                self.availableServers.remove(index%k)\\n                self.requestsOfServers[index%k] += 1\\n            else:\\n                if len(self.availableServers):\\n                    serverToBeUsed = index%k\\n                    self.availableServers.sort()\\n                    if bisect.bisect_left(self.availableServers, serverToBeUsed) == len(self.availableServers):\\n                        serverToBeUsed = heapq.heappop(self.availableServers)\\n                    else:\\n                        serverToBeUsed = self.availableServers[bisect.bisect_left(self.availableServers, serverToBeUsed)]\\n                        self.availableServers.remove(serverToBeUsed)\\n                    heapq.heappush(self.trackRunningProcess, (totalTimeCost, serverToBeUsed))\\n                    self.requestsOfServers[serverToBeUsed] += 1\\n                else:\\n#                     drop this request\\n                    continue\\n#         Calculate the result\\n        # print(self.requestsOfServers)\\n        maxRqs = max(self.requestsOfServers)\\n        return [i for i, val in enumerate(self.requestsOfServers) if val == maxRqs ]\\n        \\n",
                "codeTag": "Java"
            },
            {
                "id": 1875744,
                "title": "scala-using-treeset-and-treemap",
                "content": "```\\nobject Solution {\\n    def busiestServers(k: Int, arrival: Array[Int], load: Array[Int]): List[Int] = {\\n        import scala.collection.mutable._\\n        val availableServers = TreeSet[Int](Range(0,k).toList: _*)\\n        val busyServers = TreeMap[Int ,ListBuffer[Int]]().withDefaultValue(ListBuffer.empty[Int])\\n        val count = Array.fill[Int](k)(0)\\n        var maxRequest = 0\\n        \\n        arrival.zipWithIndex.foreach { case (arrivalTime, requestIdx) =>\\n            busyServers.rangeTo(arrivalTime).foreach { case (endTime, servers) =>\\n                servers.foreach { server =>\\n                    availableServers.add(server)\\n                }\\n                busyServers.remove(endTime)\\n            }\\n            \\n            val fromNatural = availableServers.rangeFrom(requestIdx % k).headOption\\n            val fromStart = availableServers.rangeUntil(requestIdx % k).headOption\\n            \\n            val headOpt = (fromNatural, fromStart) match {\\n                case (Some(_), _) => fromNatural\\n                case (_, Some(_)) => fromStart\\n                case (_, _) => None\\n            }\\n            \\n            headOpt.map { server => \\n                availableServers.remove(server) \\n                busyServers.put(arrivalTime + load(requestIdx), busyServers(arrivalTime + load(requestIdx)) :+ server)\\n                count(server) += 1\\n                maxRequest = maxRequest max count(server)\\n            }\\n        }\\n        \\n        count.zipWithIndex.filter(_._1 == maxRequest).map(_._2).toList\\n    }                           \\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n    def busiestServers(k: Int, arrival: Array[Int], load: Array[Int]): List[Int] = {\\n        import scala.collection.mutable._\\n        val availableServers = TreeSet[Int](Range(0,k).toList: _*)\\n        val busyServers = TreeMap[Int ,ListBuffer[Int]]().withDefaultValue(ListBuffer.empty[Int])\\n        val count = Array.fill[Int](k)(0)\\n        var maxRequest = 0\\n        \\n        arrival.zipWithIndex.foreach { case (arrivalTime, requestIdx) =>\\n            busyServers.rangeTo(arrivalTime).foreach { case (endTime, servers) =>\\n                servers.foreach { server =>\\n                    availableServers.add(server)\\n                }\\n                busyServers.remove(endTime)\\n            }\\n            \\n            val fromNatural = availableServers.rangeFrom(requestIdx % k).headOption\\n            val fromStart = availableServers.rangeUntil(requestIdx % k).headOption\\n            \\n            val headOpt = (fromNatural, fromStart) match {\\n                case (Some(_), _) => fromNatural\\n                case (_, Some(_)) => fromStart\\n                case (_, _) => None\\n            }\\n            \\n            headOpt.map { server => \\n                availableServers.remove(server) \\n                busyServers.put(arrivalTime + load(requestIdx), busyServers(arrivalTime + load(requestIdx)) :+ server)\\n                count(server) += 1\\n                maxRequest = maxRequest max count(server)\\n            }\\n        }\\n        \\n        count.zipWithIndex.filter(_._1 == maxRequest).map(_._2).toList\\n    }                           \\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1762973,
                "title": "python3-using-sortedlist",
                "content": "```\\n\"\"\"\\nBorrowed idea of using SortedList from \\nhttps://leetcode.com/problems/find-servers-that-handled-most-number-of-requests/discuss/887507/Simple-python-SortedList-solution\\n\"\"\"\\nfrom heapq import heappop, heappush, heapify\\nfrom sortedcontainers import SortedList\\nclass Solution:\\n    def busiestServers(self, k: int, arrival: List[int], load: List[int]) -> List[int]:\\n        self.K = k\\n        self.availables = SortedList([_ for _ in range(k)])\\n        self.busy_servers = []  # store [end time, server idx]\\n        self.count = {i:0 for i in range(k)}\\n        \\n        for i, (arrive, load) in enumerate(zip(arrival, load)):\\n            self.updateAvailables(arrive)\\n            sidx = self.getServerIdx(i)\\n            self.runServer(sidx, arrive, load)\\n        \\n        max_count = max(self.count.values())\\n        ret = []\\n        for i in self.count:\\n            if self.count[i] == max_count:\\n                ret.append(i)\\n        \\n        return ret\\n            \\n    def updateAvailables(self, arrive):\\n        while self.busy_servers and self.busy_servers[0][0] <= arrive:\\n            end_time, server_idx = heappop(self.busy_servers)\\n            self.availables.add(server_idx)\\n            \\n    def getServerIdx(self, i):\\n        if not self.availables:\\n            return -1\\n\\n        idx = self.availables.bisect_left(i%self.K)\\n        if idx >= len(self.availables):\\n            idx = 0\\n        return self.availables[idx]\\n\\n    \\n    def runServer(self, i, arrive, load):\\n        if i >= 0:\\n            self.availables.remove(i)\\n            self.count[i] += 1\\n            heappush(self.busy_servers, [arrive+load, i])\\n```",
                "solutionTags": [],
                "code": "```\\n\"\"\"\\nBorrowed idea of using SortedList from \\nhttps://leetcode.com/problems/find-servers-that-handled-most-number-of-requests/discuss/887507/Simple-python-SortedList-solution\\n\"\"\"\\nfrom heapq import heappop, heappush, heapify\\nfrom sortedcontainers import SortedList\\nclass Solution:\\n    def busiestServers(self, k: int, arrival: List[int], load: List[int]) -> List[int]:\\n        self.K = k\\n        self.availables = SortedList([_ for _ in range(k)])\\n        self.busy_servers = []  # store [end time, server idx]\\n        self.count = {i:0 for i in range(k)}\\n        \\n        for i, (arrive, load) in enumerate(zip(arrival, load)):\\n            self.updateAvailables(arrive)\\n            sidx = self.getServerIdx(i)\\n            self.runServer(sidx, arrive, load)\\n        \\n        max_count = max(self.count.values())\\n        ret = []\\n        for i in self.count:\\n            if self.count[i] == max_count:\\n                ret.append(i)\\n        \\n        return ret\\n            \\n    def updateAvailables(self, arrive):\\n        while self.busy_servers and self.busy_servers[0][0] <= arrive:\\n            end_time, server_idx = heappop(self.busy_servers)\\n            self.availables.add(server_idx)\\n            \\n    def getServerIdx(self, i):\\n        if not self.availables:\\n            return -1\\n\\n        idx = self.availables.bisect_left(i%self.K)\\n        if idx >= len(self.availables):\\n            idx = 0\\n        return self.availables[idx]\\n\\n    \\n    def runServer(self, i, arrive, load):\\n        if i >= 0:\\n            self.availables.remove(i)\\n            self.count[i] += 1\\n            heappush(self.busy_servers, [arrive+load, i])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1698776,
                "title": "explanation-of-the-existing-set-and-priroity-queue-solution",
                "content": "Already people have posted solution using existing set and priority queue.. I am not going to paste just the code as it has already been done.. I am more going inside about why someone reached to this solution..\\n\\nOk, so first thing first, we have servers 0,1,2,3,......k and now we have been given arrival [] array, each element represents the time at which they are reaching to the servers.. the arrival time (aka arrival array) is in strictly increasing order.. meaning we have them in sorted order.. problem is that if you look at the figure 1 then soon you will realize that those are processed on different servers and on different time. So what can we do.??? Well, first we need to know how much each server is processed or processing at time t. To do that we need to have an array, lets call it ```num_processed``` .. where can store how many times a server has been processed. Since there are k servers so the  ```num_processed``` is of k size.\\n\\nNow at time t we need to know how many servers are available to process the requests, question says we need to pick ```i%k``` right off the bat, if it is busy then we need to go to next one.. meaning if x = i%k and if x is busy then go to x+1, x+2 and so on.. now if somehow we maintain a data strucutre where which stores currrently available servers we can just search for xth element in the data structure and if not then go x+1 etc.. so we need something to store the currerntly available servers.. now note that if we simple stuff the servers in an array then we wont know which one is available or not.. but if we can store the servers based on the lowest load time then we can simply say smallest load will finish first.. hence we need a set (aka binary search tree) where we can easily pick the element with less load time and put them in the available list.\\n\\nNow we have the available list of servers.. all we need to do is find x (mentioned above) and then if it is busy then go to x+1, x+2 etc.. fortunately lower_bound of set gives us the first value which is going to be less than x, what the hell does it even mean? It means that we will find first server close to i%k value in the set.. aka first available server close to i%k. now we have server number which is available.. we need to use it.. now we need an array which keeps what server is being used, lets call it ```num_processed```.. so we will go to that index (server id) and increment that value.. we will do this operation for the arrival array.\\n\\nOnce we have the array (num_processed), we will find maximum of it and whatever server is being used at that maximum value in num_processed is our answer.\\n\\n```\\n int findServer(set<int>& available, int cond) {\\n        if (available.empty())\\n            return -1;\\n        \\n        auto later = available.lower_bound(cond);\\n        if (later != available.end()) \\n            return *later;\\n            \\n        return *available.begin();\\n    }\\n    \\n    vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n        \\n        set<int> available;\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\\n        \\n        int num_processed[k];\\n        \\n        //make all server available\\n        for (int i = 0; i < k; i++){\\n            available.insert(i);\\n            num_processed[i] = 0;\\n        }\\n        \\n        // process the requests\\n        for (int i = 0; i < arrival.size(); i++) {\\n            \\n            // Retreiving the parameter\\n            int curr_arrival = arrival[i];\\n            int curr_load = load[i];\\n            \\n            \\n            // iterating all the min heap elements which has \\n            // arrival time less than or equal to curr arrival\\n            // Meaning they arrived before the current arrival\\n            // and min heap meaning we have the available servers\\n            // in sorted order.\\n            while(!pq.empty() && pq.top().first <= curr_arrival) {\\n                available.insert(pq.top().second);\\n                pq.pop();\\n            }\\n            \\n            int cond = i % k;\\n            int server_to_use = findServer(available, cond);\\n            if (server_to_use != -1) {\\n                available.erase(server_to_use);\\n                num_processed[server_to_use] += 1;\\n                pq.push(make_pair(curr_arrival+ load[i], server_to_use));\\n            }\\n            \\n        }\\n        \\n        int max_val = num_processed[0];\\n        for (int i = 1; i < k; i++) {\\n            max_val = max(max_val, num_processed[i]);\\n        }\\n        \\n        vector<int> result;\\n        for (int i = 0; i < k; i++) {\\n            if (num_processed[i] == max_val) {\\n                result.push_back(i);\\n            }\\n        }\\n        \\n        return result;\\n    }\\n```",
                "solutionTags": [],
                "code": "```num_processed```\n```num_processed```\n```i%k```\n```num_processed```\n```\\n int findServer(set<int>& available, int cond) {\\n        if (available.empty())\\n            return -1;\\n        \\n        auto later = available.lower_bound(cond);\\n        if (later != available.end()) \\n            return *later;\\n            \\n        return *available.begin();\\n    }\\n    \\n    vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n        \\n        set<int> available;\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\\n        \\n        int num_processed[k];\\n        \\n        //make all server available\\n        for (int i = 0; i < k; i++){\\n            available.insert(i);\\n            num_processed[i] = 0;\\n        }\\n        \\n        // process the requests\\n        for (int i = 0; i < arrival.size(); i++) {\\n            \\n            // Retreiving the parameter\\n            int curr_arrival = arrival[i];\\n            int curr_load = load[i];\\n            \\n            \\n            // iterating all the min heap elements which has \\n            // arrival time less than or equal to curr arrival\\n            // Meaning they arrived before the current arrival\\n            // and min heap meaning we have the available servers\\n            // in sorted order.\\n            while(!pq.empty() && pq.top().first <= curr_arrival) {\\n                available.insert(pq.top().second);\\n                pq.pop();\\n            }\\n            \\n            int cond = i % k;\\n            int server_to_use = findServer(available, cond);\\n            if (server_to_use != -1) {\\n                available.erase(server_to_use);\\n                num_processed[server_to_use] += 1;\\n                pq.push(make_pair(curr_arrival+ load[i], server_to_use));\\n            }\\n            \\n        }\\n        \\n        int max_val = num_processed[0];\\n        for (int i = 1; i < k; i++) {\\n            max_val = max(max_val, num_processed[i]);\\n        }\\n        \\n        vector<int> result;\\n        for (int i = 0; i < k; i++) {\\n            if (num_processed[i] == max_val) {\\n                result.push_back(i);\\n            }\\n        }\\n        \\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1679966,
                "title": "python-match-server-for-request-w-2-heaps-c-match-requests-for-server-with-1-heap",
                "content": "Frankly I found the efficient way to solve this problem is hard for me.\\nMy brute force approach met with TLE error because it has O(nk) time complexity.\\nI then used two heaps to store available servers and potential candidates respectively, for each request. It still has TLE because it has O(nklogk) time.\\nI then looked up the others in the Discussion. Even that took me a while to figure out how their code worked. The idea is, we need to traverse the requests as it comes, then we can do either:\\n1. match request to available servers, use two efficient data structures to store free servers and busy servers. we can :\\n\\t\\tA. In C++, use ordered map or ordered set which offers  lower_bound() operation in O(logK) time to find the i%k server or its next available free server in cyclic order.\\n\\t\\tB. in Python, devise a clever formula for re-indexing the server: i+(x-i)%k , this will magically number the right server (honestly I won\\'t be able to come up with such a clever formula in an interview); \\n\\t\\tC. Or in Python, from sortedcontainers improt sorteddict or sortedset or sortedlist\\n2. match servers to pick up suitable requests, for each ith request, we put it in an ordered map<availTime,load>, then we target only the i%k server, let it pick up from a historically accumulated to-do tasks stored in the map. With map.lower_bound() and iterator we can efficient retrieval of available server set in O(logN) time, because the backlog can be O(N) long in worst case scenario.\\n```\\nclass Solution:\\n    def busiestServers2_heaps(self, k: int, arrival: List[int], load: List[int]) -> List[int]:  #failed with TLE at 100/108\\n        from queue import PriorityQueue\\n        pq=heapq.heapify(lst:=[(0,s) for s in range(k)])\\n        handled=[0]*k\\n        busiest=0\\n        candidate=PriorityQueue()\\n        for i in range(len(arrival)):\\n            t=arrival[i]\\n            target=i%k\\n            while lst and lst[0][0]<=t:  #lst stores server\\'s (availability , index), we first find all available servers\\n                avail,server=heapq.heappop(lst)\\n                server=(server-target+k)%k\\n                candidate.put((server,avail),block=False,timeout=None) #candidate stores server\\'s (index, availability) , where smallest index is the server that will server current request. we use min heap to put that server on the top\\n                if server==0: # Got what we prefer, no need to continue\\n                    break\\n            if not candidate.empty():  # the server of choice is the top element in the min heap according to its index\\n                server,avail=candidate.get(block=False,timeout=None)\\n                server=(server+target)%k\\n                handled[server]+=1\\n                busiest=max(busiest,handled[server])\\n                heapq.heappush(lst,(t+load[i],server))\\n                while not candidate.empty():\\n                    server,avail=candidate.get(block=False,timeout=None)\\n                    server=(server+target)%k\\n                    heapq.heappush(lst,(avail,server))\\n        return [i for i,v in enumerate(handled) if v==busiest]\\n    \\'\\'\\'\\n    An useful Test case\\n    3\\n    [1,2,3,4,8,9,10]\\n    [5,2,10,3,1,2,2]\\n    \\'\\'\\' \\n\\t# use two min heaps, one to track free servers, one to track busy servers. \\n\\t# when a new request arrives, free as many servers as possible into free heap, \\n\\t# then use i+(x-i)%k to magically specify the i%k server or its next available server in cyclic order.\\n    def busiestServers(self, k: int, A: List[int], B: List[int]) -> List[int]:\\n        available = list(range(k)) # already a min-heap, stores free server\\n        busy = []  # a min heap to store busy server\\n        res = [0] * k\\n        x=-1 #impotant for the i+(x-i)%k to work, note in Python/R, -4%3 yields 2, not -1 (as JS/JAVA/C#/C/C++/Scala)\\n        for i, a in enumerate(A):\\n            while busy and busy[0][0] <= a: # these are done, put them back as available\\n                _, x = heapq.heappop(busy)\\n\\t\\t\\t\\t#i+(x-i)%k guarantees the i%k or its next available free server will be the lowest in the available heap\\n                heapq.heappush(available, i + (x-i)%k) # invariant: min(available) is at least i, at most i+k-1\\n            if available: \\n                j = heapq.heappop(available) % k  # , (i+(x-i)%k)%k restores the index of the selected server\\n                heapq.heappush(busy, (a+B[i],j))\\n                res[j] += 1\\n        a = max(res)\\n        return [i for i in range(k) if res[i] == a]\\n```\\n\\nC++ TLDR. \\nSorry for the verbosity. This is to document my trial and error for quick future reference, and for anyone who is interested or share the same frustration.\\nApproach 1. Brute force looping through each request , trying to find available server. Failed as this is O(nk)\\nApproach 2. Looping thru requests, for each request, focus on the i%k server only, try to find all suitable requests that are currently available in the ordered tree (map), including the one that was not served by (i-x)%k servers because that server was busy and rolled up to the current i%k server.  Because the map is ordered, we can find all suitable request by call map.lower_bound() which takes O(lgN) time. This works because time complexity is O(nlogN).\\nApproach 3. Based on idea of Approach 2,but try to use priority_queue instead of ordered tree map to track available requests in the order of arrival time. This attempt failed because there is no good way to find the suitable requests in priority queue efficiently for the target server (i%k). I ended up using scanning through all requests and find the suitable one, and push back non-selected requests back to the priority queue. This encountered TLE as the time complexity is now O(N*N*logN) because I popped and pushed back the pq/heap.\\nApproach 4. Use  an ordered set to track all free servers\\'s availablity time set<avail, idx>,  also maintain a priority queues for busy servers. When a new request arrives, we free available servers from busy queue as pair<idx,avail> and put into free queue. If the free queue is not empty, we find the right server by set.lower_bound(i%k), if not found, pick set.begin() . That\\'s the i%k or its next available server. The lower_bound is O(logK) time. The popping from busy and pushing into free queue operations takes place at most (N-k) times. so the outer loop (traversing each request) takes O(NlogK), and shuffling between queues takes (N-k)logK times, so the overall time is still O(NlogK) !!!!\\n```\\nclass Solution {\\npublic:\\n    vector<int> busiestServersBForce(int k, vector<int>& arrival, vector<int>& load) {\\n        vector<int> handled(k,0);\\n        vector<int> avail(k,0);\\n        priority_queue<pair<int,int>> pq;\\n\\n        int maxv=0,nextAvail=0;\\n        for (auto i=0; i<arrival.size(); ++i) {\\n            auto s=i%k,t=arrival[i],tried=0;\\n            //BUG 1: while (avail[s]<t && ...) => avail[s]>t ...\\n            while (avail[s]>t && tried<k) s=(s+1)%k,++tried;\\n            if (tried==k) continue;\\n            ++handled[s];\\n            avail[s]=t+load[i];\\n            maxv=max(maxv,handled[s]);\\n        }\\n        auto busiest=vector<int>();\\n        //BUG 2: lambda (i,v) => lambda (v,i)\\n        for_each(begin(handled), handled.end(),[&](int& v)->void {\\n           if  (v==maxv) busiest.push_back(&v-&(*begin(handled))); \\n        });\\n        return busiest; \\n    }\\n\\n    //using treeset and priority queue \\n\\t/* Quoted from @lzl124631x: \\n\\tset<int> free contains the index of available servers. busy is a min-heap each item of which is a pair of { endTime, serverIndex }.\\n\\nWhen we find an available server, we erase it from free, and put { endTime, serverIndex } into a min-heap busy.\\n\\nFor each arrival[i], we first free all those servers from busy whose endTime is smaller than or equal to arrival[i], then find the first available server in free whose index is greater than i % k in circular order.\\n\\nAbout time complexity, iterating the N elements in A and L takes O(N), within each iteration, the amortized time complexity is O(logK). It\\'s because the sizes of the free and busy are at most K, so each push and pop operation takes O(logK) time.\\n\\nNote that for the loop popping busy, since at most we can pop busy K times and each pop takes O(logK) time, it looks like it\\'s O(KlogK) and the busy\\'s popping operation takes O(NKlogK) overall. But since we at most pop busy N - K times through out the entire function, so the busy\\'s popping operation takes at most (N - k)logK time. Thus the funtion\\'s overall time complexity is still O(NlogK).\\n*/\\n    vector<int> busiestServers2(int k, vector<int>& A, vector<int>& L) {\\n        vector<int> cnt(k);\\n        set<int> free;\\n        for (int i = 0; i < k; ++i) free.insert(i);\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<>> busy; // endTime, serverIndex\\n        for (int i = 0; i < A.size(); ++i) {\\n            int start = A[i], end = start + L[i];\\n            while (busy.size() && busy.top().first <= start) {\\n                int server = busy.top().second;\\n                busy.pop();\\n                free.insert(server);\\n            }\\n            if (free.empty()) continue;\\n            //this is where the logK operations are done\\n            auto it = free.lower_bound(i % k); //lower bound picks free server idx>=i%k \\n            if (it == free.end()) it = free.begin(); //if no server >=i%k is free, pick lowest\\n            cnt[*it]++;\\n            busy.emplace(end, *it);\\n            free.erase(*it);\\n        }\\n        vector<int> ans;\\n        int mx = *max_element(begin(cnt), end(cnt));\\n        for (int i = 0; i < k; ++i) {\\n            if (cnt[i] == mx) ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n    vector<int> busiestServers3(int k, vector<int>& A, vector<int>& L) { //priority_queue won\\'t work, if the top of pq blocks current server from picking subsequent availble requests, those requests will be mis-assigned to the next server.  4 [1,3,4,5,10,12] [11,9,3,1,9,12]\\n        using item=pair<int,int>; \\n        priority_queue<item, vector<item>,greater<>> pq; \\n        vector<int> avail(k), handled(k);\\n        int i=0,lasti=i,skip=0;\\n        while (true){\\n            if (i<A.size())  pq.push({A[i],L[i]});\\n            else if (i-lasti>k )  break;\\n            //BUG:  while (pq.top().first>=avail[i%k]) => without checking emptiness, pq.top is random value after it was emptied\\n            if (!pq.empty())   {\\n                if (pq.top().first<avail[i%k]) skip++;\\n                else skip=0;\\n            }\\n            if (skip==k) {pq.pop(); skip=0;lasti=i;}\\n            while (!pq.empty() && pq.top().first>=avail[i%k]) {\\n                if (i-lasti<=k) {\\n                   auto [a,l]=pq.top();\\n                   avail[i%k]=a+l;\\n                   ++handled[i%k];\\n                   lasti=i; \\n                }\\n               pq.pop();\\n            }\\n            ++i;\\n        }\\n        vector<int> result;\\n        auto max=max_element(handled.begin(),end(handled));\\n        for_each(begin(handled), end(handled), [&result,max,i=0](int v) mutable ->void {if(v==*max) result.push_back(i);i++;});\\n        return result;\\n    }\\n    vector<int> busiestServers4(int k, vector<int>& A, vector<int>& L) { //priority_queue won\\'t work even after modification, still get TLE error at 102/180 case point when k=2543. This basically is similar to brute force solution which trying to match each request with available server, the pop-look-pushback approach is not efficient with O(1) vector, let alone pq.\\n        using item=pair<int,int>; \\n        priority_queue<item, vector<item>,greater<>> pq; \\n        vector<int> avail(k), handled(k);\\n        int i=0,lasti=i;\\n        while (true){\\n            if (i<A.size())   pq.push({A[i],L[i]});\\n            else if (i-lasti>k )  break;\\n            //BUG:  while (pq.top().first>=avail[i%k]) => without checking emptiness, pq.top is random value after it was emptied\\n                   vector<item> pushback;\\n                while (!pq.empty() && pq.top().first< avail[i%k]) {\\n                    pushback.push_back(pq.top());\\n                    pq.pop();\\n                }\\n                while (!pq.empty()) {\\n                    if (pq.top().first>=avail[i%k]) {\\n                       avail[i%k]=pq.top().first+pq.top().second;\\n                       ++handled[i%k];\\n                       lasti=i; \\n                       pq.pop();\\n                    }\\n                    else {\\n                        pushback.push_back(pq.top());\\n                        pq.pop();\\n                    }\\n                }\\n                while (!pushback.empty()) {\\n                    pq.push(pushback.back());\\n                    pushback.pop_back();\\n                }\\n            ++i;\\n        }\\n        vector<int> result;\\n        auto max=max_element(handled.begin(),end(handled));\\n        for_each(begin(handled), end(handled), [&result,max,i=0](int v) mutable ->void {if(v==*max) result.push_back(i);i++;});\\n        return result;\\n    }\\n    vector<int> busiestServers(int k, vector<int>& A, vector<int>& L) { \\n        map<int,int> m;\\n        vector<int> avail(k), handled(k);\\n        int i=0,lasti=i;\\n        while (true) {\\n            if (i<A.size())  m[A[i]]=L[i];\\n            else if (i-lasti>k )  break;\\n            auto it=m.lower_bound(avail[i%k]);\\n            while ( it!=m.end()) {\\n                   avail[i%k]=it->first+it->second;\\n                   ++handled[i%k];\\n                   lasti=i; \\n                   m.erase(it);\\n                   it=m.lower_bound(avail[i%k]);\\n            }\\n            ++i;\\n        }\\n        vector<int> result;\\n        auto max=max_element(handled.begin(),end(handled));\\n        for_each(begin(handled), end(handled), [&result,max,i=0](int v) mutable ->void {if(v==*max) result.push_back(i);i++;});\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def busiestServers2_heaps(self, k: int, arrival: List[int], load: List[int]) -> List[int]:  #failed with TLE at 100/108\\n        from queue import PriorityQueue\\n        pq=heapq.heapify(lst:=[(0,s) for s in range(k)])\\n        handled=[0]*k\\n        busiest=0\\n        candidate=PriorityQueue()\\n        for i in range(len(arrival)):\\n            t=arrival[i]\\n            target=i%k\\n            while lst and lst[0][0]<=t:  #lst stores server\\'s (availability , index), we first find all available servers\\n                avail,server=heapq.heappop(lst)\\n                server=(server-target+k)%k\\n                candidate.put((server,avail),block=False,timeout=None) #candidate stores server\\'s (index, availability) , where smallest index is the server that will server current request. we use min heap to put that server on the top\\n                if server==0: # Got what we prefer, no need to continue\\n                    break\\n            if not candidate.empty():  # the server of choice is the top element in the min heap according to its index\\n                server,avail=candidate.get(block=False,timeout=None)\\n                server=(server+target)%k\\n                handled[server]+=1\\n                busiest=max(busiest,handled[server])\\n                heapq.heappush(lst,(t+load[i],server))\\n                while not candidate.empty():\\n                    server,avail=candidate.get(block=False,timeout=None)\\n                    server=(server+target)%k\\n                    heapq.heappush(lst,(avail,server))\\n        return [i for i,v in enumerate(handled) if v==busiest]\\n    \\'\\'\\'\\n    An useful Test case\\n    3\\n    [1,2,3,4,8,9,10]\\n    [5,2,10,3,1,2,2]\\n    \\'\\'\\' \\n\\t# use two min heaps, one to track free servers, one to track busy servers. \\n\\t# when a new request arrives, free as many servers as possible into free heap, \\n\\t# then use i+(x-i)%k to magically specify the i%k server or its next available server in cyclic order.\\n    def busiestServers(self, k: int, A: List[int], B: List[int]) -> List[int]:\\n        available = list(range(k)) # already a min-heap, stores free server\\n        busy = []  # a min heap to store busy server\\n        res = [0] * k\\n        x=-1 #impotant for the i+(x-i)%k to work, note in Python/R, -4%3 yields 2, not -1 (as JS/JAVA/C#/C/C++/Scala)\\n        for i, a in enumerate(A):\\n            while busy and busy[0][0] <= a: # these are done, put them back as available\\n                _, x = heapq.heappop(busy)\\n\\t\\t\\t\\t#i+(x-i)%k guarantees the i%k or its next available free server will be the lowest in the available heap\\n                heapq.heappush(available, i + (x-i)%k) # invariant: min(available) is at least i, at most i+k-1\\n            if available: \\n                j = heapq.heappop(available) % k  # , (i+(x-i)%k)%k restores the index of the selected server\\n                heapq.heappush(busy, (a+B[i],j))\\n                res[j] += 1\\n        a = max(res)\\n        return [i for i in range(k) if res[i] == a]\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> busiestServersBForce(int k, vector<int>& arrival, vector<int>& load) {\\n        vector<int> handled(k,0);\\n        vector<int> avail(k,0);\\n        priority_queue<pair<int,int>> pq;\\n\\n        int maxv=0,nextAvail=0;\\n        for (auto i=0; i<arrival.size(); ++i) {\\n            auto s=i%k,t=arrival[i],tried=0;\\n            //BUG 1: while (avail[s]<t && ...) => avail[s]>t ...\\n            while (avail[s]>t && tried<k) s=(s+1)%k,++tried;\\n            if (tried==k) continue;\\n            ++handled[s];\\n            avail[s]=t+load[i];\\n            maxv=max(maxv,handled[s]);\\n        }\\n        auto busiest=vector<int>();\\n        //BUG 2: lambda (i,v) => lambda (v,i)\\n        for_each(begin(handled), handled.end(),[&](int& v)->void {\\n           if  (v==maxv) busiest.push_back(&v-&(*begin(handled))); \\n        });\\n        return busiest; \\n    }\\n\\n    //using treeset and priority queue \\n\\t/* Quoted from @lzl124631x: \\n\\tset<int> free contains the index of available servers. busy is a min-heap each item of which is a pair of { endTime, serverIndex }.\\n\\nWhen we find an available server, we erase it from free, and put { endTime, serverIndex } into a min-heap busy.\\n\\nFor each arrival[i], we first free all those servers from busy whose endTime is smaller than or equal to arrival[i], then find the first available server in free whose index is greater than i % k in circular order.\\n\\nAbout time complexity, iterating the N elements in A and L takes O(N), within each iteration, the amortized time complexity is O(logK). It\\'s because the sizes of the free and busy are at most K, so each push and pop operation takes O(logK) time.\\n\\nNote that for the loop popping busy, since at most we can pop busy K times and each pop takes O(logK) time, it looks like it\\'s O(KlogK) and the busy\\'s popping operation takes O(NKlogK) overall. But since we at most pop busy N - K times through out the entire function, so the busy\\'s popping operation takes at most (N - k)logK time. Thus the funtion\\'s overall time complexity is still O(NlogK).\\n*/\\n    vector<int> busiestServers2(int k, vector<int>& A, vector<int>& L) {\\n        vector<int> cnt(k);\\n        set<int> free;\\n        for (int i = 0; i < k; ++i) free.insert(i);\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<>> busy; // endTime, serverIndex\\n        for (int i = 0; i < A.size(); ++i) {\\n            int start = A[i], end = start + L[i];\\n            while (busy.size() && busy.top().first <= start) {\\n                int server = busy.top().second;\\n                busy.pop();\\n                free.insert(server);\\n            }\\n            if (free.empty()) continue;\\n            //this is where the logK operations are done\\n            auto it = free.lower_bound(i % k); //lower bound picks free server idx>=i%k \\n            if (it == free.end()) it = free.begin(); //if no server >=i%k is free, pick lowest\\n            cnt[*it]++;\\n            busy.emplace(end, *it);\\n            free.erase(*it);\\n        }\\n        vector<int> ans;\\n        int mx = *max_element(begin(cnt), end(cnt));\\n        for (int i = 0; i < k; ++i) {\\n            if (cnt[i] == mx) ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n    vector<int> busiestServers3(int k, vector<int>& A, vector<int>& L) { //priority_queue won\\'t work, if the top of pq blocks current server from picking subsequent availble requests, those requests will be mis-assigned to the next server.  4 [1,3,4,5,10,12] [11,9,3,1,9,12]\\n        using item=pair<int,int>; \\n        priority_queue<item, vector<item>,greater<>> pq; \\n        vector<int> avail(k), handled(k);\\n        int i=0,lasti=i,skip=0;\\n        while (true){\\n            if (i<A.size())  pq.push({A[i],L[i]});\\n            else if (i-lasti>k )  break;\\n            //BUG:  while (pq.top().first>=avail[i%k]) => without checking emptiness, pq.top is random value after it was emptied\\n            if (!pq.empty())   {\\n                if (pq.top().first<avail[i%k]) skip++;\\n                else skip=0;\\n            }\\n            if (skip==k) {pq.pop(); skip=0;lasti=i;}\\n            while (!pq.empty() && pq.top().first>=avail[i%k]) {\\n                if (i-lasti<=k) {\\n                   auto [a,l]=pq.top();\\n                   avail[i%k]=a+l;\\n                   ++handled[i%k];\\n                   lasti=i; \\n                }\\n               pq.pop();\\n            }\\n            ++i;\\n        }\\n        vector<int> result;\\n        auto max=max_element(handled.begin(),end(handled));\\n        for_each(begin(handled), end(handled), [&result,max,i=0](int v) mutable ->void {if(v==*max) result.push_back(i);i++;});\\n        return result;\\n    }\\n    vector<int> busiestServers4(int k, vector<int>& A, vector<int>& L) { //priority_queue won\\'t work even after modification, still get TLE error at 102/180 case point when k=2543. This basically is similar to brute force solution which trying to match each request with available server, the pop-look-pushback approach is not efficient with O(1) vector, let alone pq.\\n        using item=pair<int,int>; \\n        priority_queue<item, vector<item>,greater<>> pq; \\n        vector<int> avail(k), handled(k);\\n        int i=0,lasti=i;\\n        while (true){\\n            if (i<A.size())   pq.push({A[i],L[i]});\\n            else if (i-lasti>k )  break;\\n            //BUG:  while (pq.top().first>=avail[i%k]) => without checking emptiness, pq.top is random value after it was emptied\\n                   vector<item> pushback;\\n                while (!pq.empty() && pq.top().first< avail[i%k]) {\\n                    pushback.push_back(pq.top());\\n                    pq.pop();\\n                }\\n                while (!pq.empty()) {\\n                    if (pq.top().first>=avail[i%k]) {\\n                       avail[i%k]=pq.top().first+pq.top().second;\\n                       ++handled[i%k];\\n                       lasti=i; \\n                       pq.pop();\\n                    }\\n                    else {\\n                        pushback.push_back(pq.top());\\n                        pq.pop();\\n                    }\\n                }\\n                while (!pushback.empty()) {\\n                    pq.push(pushback.back());\\n                    pushback.pop_back();\\n                }\\n            ++i;\\n        }\\n        vector<int> result;\\n        auto max=max_element(handled.begin(),end(handled));\\n        for_each(begin(handled), end(handled), [&result,max,i=0](int v) mutable ->void {if(v==*max) result.push_back(i);i++;});\\n        return result;\\n    }\\n    vector<int> busiestServers(int k, vector<int>& A, vector<int>& L) { \\n        map<int,int> m;\\n        vector<int> avail(k), handled(k);\\n        int i=0,lasti=i;\\n        while (true) {\\n            if (i<A.size())  m[A[i]]=L[i];\\n            else if (i-lasti>k )  break;\\n            auto it=m.lower_bound(avail[i%k]);\\n            while ( it!=m.end()) {\\n                   avail[i%k]=it->first+it->second;\\n                   ++handled[i%k];\\n                   lasti=i; \\n                   m.erase(it);\\n                   it=m.lower_bound(avail[i%k]);\\n            }\\n            ++i;\\n        }\\n        vector<int> result;\\n        auto max=max_element(handled.begin(),end(handled));\\n        for_each(begin(handled), end(handled), [&result,max,i=0](int v) mutable ->void {if(v==*max) result.push_back(i);i++;});\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1648304,
                "title": "java-treeset-and-pq",
                "content": "```\\nclass Solution {\\n    public List<Integer> busiestServers(int k, int[] arrival, int[] load) {\\n        PriorityQueue<Integer[]> pq = new PriorityQueue<>((o1, o2) -> Integer.compare(o1[0], o2[0]));\\n        TreeSet<Integer> free = new TreeSet<>();\\n        for (int i = 0; i < k; i++) {\\n            free.add(i);\\n        }\\n        HashMap<Integer, Integer> serverTime = new HashMap<>();\\n        for (int i = 0; i < arrival.length; i++) {\\n            while (!pq.isEmpty() && pq.peek()[0] <= arrival[i]) {\\n                Integer[] curr = pq.poll();\\n                free.add(curr[1]);\\n            }\\n            if (!free.isEmpty()) {\\n                if (free.contains(i % k)) {\\n                    pq.add(new Integer[]{arrival[i] + load[i], i % k});\\n                    serverTime.put(i % k, serverTime.getOrDefault(i % k, 0) + 1);\\n                    free.remove(i % k);\\n                } else {\\n                    Integer server = free.higher(i % k);\\n                    if (server == null) {\\n                        server = free.first();\\n                    }\\n                    pq.add(new Integer[]{arrival[i] + load[i], server});\\n                    free.remove(server);\\n                    serverTime.put(server, serverTime.getOrDefault(server, 0) + 1);\\n                }\\n            }\\n        }\\n        List<Map.Entry<Integer, Integer>> list = new ArrayList<>(serverTime.entrySet());\\n        list.sort((o1, o2) -> -Integer.compare(o1.getValue(), o2.getValue()));\\n        List<Integer> ans = new ArrayList<>();\\n        int max = list.get(0).getValue();\\n        for (int i = 0; i < list.size(); i++) {\\n            if (list.get(i).getValue() == max) {\\n                ans.add(list.get(i).getKey());\\n            } else {\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> busiestServers(int k, int[] arrival, int[] load) {\\n        PriorityQueue<Integer[]> pq = new PriorityQueue<>((o1, o2) -> Integer.compare(o1[0], o2[0]));\\n        TreeSet<Integer> free = new TreeSet<>();\\n        for (int i = 0; i < k; i++) {\\n            free.add(i);\\n        }\\n        HashMap<Integer, Integer> serverTime = new HashMap<>();\\n        for (int i = 0; i < arrival.length; i++) {\\n            while (!pq.isEmpty() && pq.peek()[0] <= arrival[i]) {\\n                Integer[] curr = pq.poll();\\n                free.add(curr[1]);\\n            }\\n            if (!free.isEmpty()) {\\n                if (free.contains(i % k)) {\\n                    pq.add(new Integer[]{arrival[i] + load[i], i % k});\\n                    serverTime.put(i % k, serverTime.getOrDefault(i % k, 0) + 1);\\n                    free.remove(i % k);\\n                } else {\\n                    Integer server = free.higher(i % k);\\n                    if (server == null) {\\n                        server = free.first();\\n                    }\\n                    pq.add(new Integer[]{arrival[i] + load[i], server});\\n                    free.remove(server);\\n                    serverTime.put(server, serverTime.getOrDefault(server, 0) + 1);\\n                }\\n            }\\n        }\\n        List<Map.Entry<Integer, Integer>> list = new ArrayList<>(serverTime.entrySet());\\n        list.sort((o1, o2) -> -Integer.compare(o1.getValue(), o2.getValue()));\\n        List<Integer> ans = new ArrayList<>();\\n        int max = list.get(0).getValue();\\n        for (int i = 0; i < list.size(); i++) {\\n            if (list.get(i).getValue() == max) {\\n                ans.add(list.get(i).getKey());\\n            } else {\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1567170,
                "title": "c-set-and-priority-queue-solution",
                "content": "The idea is as follows - we maintain two data structures, one is a set of available servers we can use, and one is a priority queue of servers, consisting of a pair of a server id and the next time the server is available, and the priority is given by the next time the server will be available. Each time we get a new request, we look in our set of available servers to find the next available server as in the problem statement. This is handled in the query function. If we find a server, we increment the number of times that server has been used, and we push that server, onto the priority queue, with priority given by the current time plus the load, as this will be the next time the server will be available. If N is the number of requests we have to process, then the runtime will be NlogN. Indeed, each Query operation will take log(N) time, as there can be at most N available times. Also, for each request, we add at most 1 element to the priority queue, so we will be doing at most N push and pops from the priority queue, each of which can take at most log(N) time. Note that at any given request, we may perform more than one pop from the priority queue, but this does not affect the overall runtime because over the lifetime of the program, we are still doing at most N pops. \\n\\n```\\n#include <set>\\n#include <queue>\\n#include <utility>\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    \\n    int query(const set<int>& available, int i) {\\n        if(available.empty()) {return -1;}\\n        \\n        auto later = available.lower_bound(i);\\n        if(later != available.end()) {return *later;}\\n        return *available.begin();\\n    }\\n    \\n    vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n        set<int> available;\\n        priority_queue<pair<int, int>, vector<pair<int, int> >, greater<pair<int, int> > > pq;\\n        int num_processed[k];\\n        for(int i = 0; i < k; i++) {available.insert(i); num_processed[i] = 0;}\\n        \\n        for(int i = 0; i < arrival.size(); i++) {\\n            int curr_arrival = arrival[i];\\n            int curr_load = load[i];\\n            while(!pq.empty() && pq.top().first <= curr_arrival) {\\n                available.insert(pq.top().second);\\n                pq.pop();\\n            }\\n            int server_to_use = query(available, i%k); \\n            if(server_to_use != -1) {\\n                available.erase(server_to_use);\\n                num_processed[server_to_use] += 1;\\n                pq.push(make_pair(curr_arrival + curr_load, server_to_use));\\n            }\\n        }\\n        int max_val = num_processed[0];\\n        for(int i = 1; i < k; i++) {\\n            if(num_processed[i] > max_val) {\\n                max_val = num_processed[i];\\n            }\\n        }\\n        vector<int> biggest_servers;\\n        for(int i = 0; i < k; i++) {\\n            if(num_processed[i] == max_val) {\\n                biggest_servers.push_back(i);\\n            }\\n        }\\n        return biggest_servers;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#include <set>\\n#include <queue>\\n#include <utility>\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    \\n    int query(const set<int>& available, int i) {\\n        if(available.empty()) {return -1;}\\n        \\n        auto later = available.lower_bound(i);\\n        if(later != available.end()) {return *later;}\\n        return *available.begin();\\n    }\\n    \\n    vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n        set<int> available;\\n        priority_queue<pair<int, int>, vector<pair<int, int> >, greater<pair<int, int> > > pq;\\n        int num_processed[k];\\n        for(int i = 0; i < k; i++) {available.insert(i); num_processed[i] = 0;}\\n        \\n        for(int i = 0; i < arrival.size(); i++) {\\n            int curr_arrival = arrival[i];\\n            int curr_load = load[i];\\n            while(!pq.empty() && pq.top().first <= curr_arrival) {\\n                available.insert(pq.top().second);\\n                pq.pop();\\n            }\\n            int server_to_use = query(available, i%k); \\n            if(server_to_use != -1) {\\n                available.erase(server_to_use);\\n                num_processed[server_to_use] += 1;\\n                pq.push(make_pair(curr_arrival + curr_load, server_to_use));\\n            }\\n        }\\n        int max_val = num_processed[0];\\n        for(int i = 1; i < k; i++) {\\n            if(num_processed[i] > max_val) {\\n                max_val = num_processed[i];\\n            }\\n        }\\n        vector<int> biggest_servers;\\n        for(int i = 0; i < k; i++) {\\n            if(num_processed[i] == max_val) {\\n                biggest_servers.push_back(i);\\n            }\\n        }\\n        return biggest_servers;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1449176,
                "title": "can-anyone-explain-what-is-ordered-set",
                "content": "can anyone explain what is ordered set",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 1432118,
                "title": "simple-java-solution-using-array-runtime-o-n-and-space-o-k",
                "content": "Simple solution:\\n\\n\\n```\\npublic List<Integer> busiestServers(int k, int[] arrival, int[] load) {\\n\\n        int[] serversAvailability = new int[k];\\n        int[] serversProcessCount = new int[k];\\n\\n        for (int i = 0; i < arrival.length; i++) {\\n            int startTime = arrival[i];\\n            int endTime = startTime + load[i];\\n\\n            int initialServer = i % k;\\n            int currentServer = initialServer;\\n\\n            do {\\n                int exitingProcessEndTime = serversAvailability[currentServer];\\n                if (exitingProcessEndTime <= startTime) {\\n                    serversAvailability[currentServer] = endTime;\\n                    serversProcessCount[currentServer] = serversProcessCount[currentServer] + 1;\\n                    break;\\n                }\\n                currentServer++;\\n                if (currentServer == k) {\\n                    currentServer = 0;\\n                }\\n            } while (currentServer != initialServer);\\n        }\\n\\n        int max = 0;\\n        Map<Integer, List<Integer>> maxProcessCountMap = new HashMap<Integer, List<Integer>>();\\n        for (int i = 0; i < k; i++) {\\n            if (serversProcessCount[i] >= max) {\\n                max = serversProcessCount[i];\\n                List<Integer> processors = maxProcessCountMap.get(max);\\n                if (processors == null) {\\n                    processors = new ArrayList<Integer>();\\n                    maxProcessCountMap.put(max, processors);\\n                }\\n\\n                processors.add(i);\\n\\n            }\\n        }\\n\\n        return maxProcessCountMap.get(max);\\n    }",
                "solutionTags": [],
                "code": "Simple solution:\\n\\n\\n```\\npublic List<Integer> busiestServers(int k, int[] arrival, int[] load) {\\n\\n        int[] serversAvailability = new int[k];\\n        int[] serversProcessCount = new int[k];\\n\\n        for (int i = 0; i < arrival.length; i++) {\\n            int startTime = arrival[i];\\n            int endTime = startTime + load[i];\\n\\n            int initialServer = i % k;\\n            int currentServer = initialServer;\\n\\n            do {\\n                int exitingProcessEndTime = serversAvailability[currentServer];\\n                if (exitingProcessEndTime <= startTime) {\\n                    serversAvailability[currentServer] = endTime;\\n                    serversProcessCount[currentServer] = serversProcessCount[currentServer] + 1;\\n                    break;\\n                }\\n                currentServer++;\\n                if (currentServer == k) {\\n                    currentServer = 0;\\n                }\\n            } while (currentServer != initialServer);\\n        }\\n\\n        int max = 0;\\n        Map<Integer, List<Integer>> maxProcessCountMap = new HashMap<Integer, List<Integer>>();\\n        for (int i = 0; i < k; i++) {\\n            if (serversProcessCount[i] >= max) {\\n                max = serversProcessCount[i];\\n                List<Integer> processors = maxProcessCountMap.get(max);\\n                if (processors == null) {\\n                    processors = new ArrayList<Integer>();\\n                    maxProcessCountMap.put(max, processors);\\n                }\\n\\n                processors.add(i);\\n\\n            }\\n        }\\n\\n        return maxProcessCountMap.get(max);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1383896,
                "title": "python-heap-maths",
                "content": "```\\nfrom heapq import heappush, heappop\\nclass Solution:\\n    def busiestServers(self, k: int, arrival: List[int], load: List[int]) -> List[int]:\\n        server_timers= []\\n        task_count= [0 for _ in range(k)]\\n        avail_servers=list(range(k))\\n        for i,arr in enumerate(arrival):\\n            while server_timers and server_timers[0][0]<=arr:\\n                heappush(avail_servers,i+(heappop(server_timers)[1]-i)%k)\\n            if avail_servers:\\n                assigned_server=heappop(avail_servers)%k;\\n                heappush(server_timers,(arr+load[i],assigned_server))\\n                task_count[assigned_server]+=1\\n        maxx=max(task_count)\\n        return [i for i in range(k) if task_count[i]==maxx]\\n```",
                "solutionTags": [],
                "code": "```\\nfrom heapq import heappush, heappop\\nclass Solution:\\n    def busiestServers(self, k: int, arrival: List[int], load: List[int]) -> List[int]:\\n        server_timers= []\\n        task_count= [0 for _ in range(k)]\\n        avail_servers=list(range(k))\\n        for i,arr in enumerate(arrival):\\n            while server_timers and server_timers[0][0]<=arr:\\n                heappush(avail_servers,i+(heappop(server_timers)[1]-i)%k)\\n            if avail_servers:\\n                assigned_server=heappop(avail_servers)%k;\\n                heappush(server_timers,(arr+load[i],assigned_server))\\n                task_count[assigned_server]+=1\\n        maxx=max(task_count)\\n        return [i for i in range(k) if task_count[i]==maxx]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1238486,
                "title": "c-ordered-map-priority-queue",
                "content": "class Solution {\\n    \\n    struct Compare\\n    {\\n        bool operator ()(pair<int, int> const& p1, pair<int, int> const& p2)\\n        {\\n            return p1.first > p2.first;\\n        }\\n    };\\n    \\npublic:\\n    vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n        \\n        set<int> available_servers;\\n        for (int i=0;i<k;i++)\\n            available_servers.emplace(i);\\n        \\n        priority_queue<pair<int, int>, vector<pair<int, int>>, Compare> minheap;\\n                \\n        vector<int> freq (k, 0);\\n        for (int i=0;i<arrival.size();i++)\\n        {            \\n            while (!minheap.empty())\\n            {\\n                auto top = minheap.top();\\n                if(top.first <= arrival[i])\\n                {\\n                    minheap.pop();\\n                    available_servers.emplace(top.second);\\n                }\\n                else\\n                    break;\\n            }\\n            \\n            set<int>::iterator it;\\n            it = available_servers.lower_bound(i % k);\\n            if (it == available_servers.end())\\n                it = available_servers.lower_bound(0);\\n            \\n            if (it != available_servers.end())\\n            {\\n                minheap.emplace(arrival[i] + load[i], *it);\\n                \\n                freq[*it]++;\\n            \\n                available_servers.erase(it);\\n            }\\n        }\\n        \\n        vector<int> result;\\n        int max = *max_element(freq.begin(), freq.end());\\n        for (int i=0; i<k; i++)\\n        {\\n            if (freq[i] == max)\\n                result.emplace_back(i);\\n        }\\n        \\n        return result;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\n    \\n    struct Compare\\n    {\\n        bool operator ()(pair<int, int> const& p1, pair<int, int> const& p2)\\n        {\\n            return p1.first > p2.first;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1132392,
                "title": "treeset-solution",
                "content": "greedily choose the server from the pool and then count the busiest servers \\n```\\npublic List<Integer> busiestServers(int k, int[] arrival, int[] load) {\\n        int dp[] = new int[k], n = arrival.length;\\n        TreeSet<Integer> ts = new TreeSet<>();\\n        for (int i = 0; i < k; i++){\\n            ts.add(i);\\n        }\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a,b)->a[0]-b[0]);\\n        for (int i = 0; i < n; i++){\\n            int cur = i%k, time = arrival[i];\\n            while (!pq.isEmpty() && pq.peek()[0] <= time){\\n                ts.add(pq.poll()[1]);\\n            }\\n            if (ts.isEmpty()) continue;\\n            if (ts.contains(cur)){\\n                dp[cur]++;\\n                pq.add(new int[]{time+load[i],cur});\\n                ts.remove(cur);\\n            }else{\\n                Integer max = ts.ceiling(cur);\\n                if (max != null){\\n                    dp[max]++;\\n                    pq.add(new int[]{time+load[i],max});\\n                    ts.remove(max);\\n                }else{\\n                    int nxt = ts.ceiling(0);\\n                    dp[nxt]++;\\n                    pq.add(new int[]{time+load[i],nxt});\\n                    ts.remove(nxt);\\n                }\\n            }\\n        }\\n        int cnt = 0;\\n        for (int i: dp){\\n            cnt = Math.max(i,cnt);\\n        }\\n        List<Integer> res = new ArrayList<>();\\n        for (int i = 0 ; i < k; i++){\\n            if (dp[i] == cnt) res.add(i);\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic List<Integer> busiestServers(int k, int[] arrival, int[] load) {\\n        int dp[] = new int[k], n = arrival.length;\\n        TreeSet<Integer> ts = new TreeSet<>();\\n        for (int i = 0; i < k; i++){\\n            ts.add(i);\\n        }\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a,b)->a[0]-b[0]);\\n        for (int i = 0; i < n; i++){\\n            int cur = i%k, time = arrival[i];\\n            while (!pq.isEmpty() && pq.peek()[0] <= time){\\n                ts.add(pq.poll()[1]);\\n            }\\n            if (ts.isEmpty()) continue;\\n            if (ts.contains(cur)){\\n                dp[cur]++;\\n                pq.add(new int[]{time+load[i],cur});\\n                ts.remove(cur);\\n            }else{\\n                Integer max = ts.ceiling(cur);\\n                if (max != null){\\n                    dp[max]++;\\n                    pq.add(new int[]{time+load[i],max});\\n                    ts.remove(max);\\n                }else{\\n                    int nxt = ts.ceiling(0);\\n                    dp[nxt]++;\\n                    pq.add(new int[]{time+load[i],nxt});\\n                    ts.remove(nxt);\\n                }\\n            }\\n        }\\n        int cnt = 0;\\n        for (int i: dp){\\n            cnt = Math.max(i,cnt);\\n        }\\n        List<Integer> res = new ArrayList<>();\\n        for (int i = 0 ; i < k; i++){\\n            if (dp[i] == cnt) res.add(i);\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1087601,
                "title": "javascript-solution",
                "content": "Here\\'s my javascript solution. Time is so limited, I had to avoid using ```i % k``` and instead used an iterator.\\n\\n```\\n/**\\n * @param {number} k\\n * @param {number[]} arrival\\n * @param {number[]} load\\n * @return {number[]}\\n */\\nvar busiestServers = function(k, arrival, load) {\\n    var serverHits = [];\\n    var servers = [];\\n    var imk = k-1;\\n    \\n    for(let i in load) {\\n        var j = 0;\\n        imk++;\\n        if(imk >= k) imk -= k;\\n        while(j < k) {\\n            currentServer = (imk) + j;\\n            if(currentServer >= k) currentServer -= k;\\n            if(arrival[i] >= (servers[currentServer] ?? 0)) {\\n                servers[currentServer] = arrival[i] + load[i];\\n                serverHits[currentServer] = (serverHits[currentServer] ?? 0) + 1;\\n                break;\\n            }\\n            j++;\\n        }\\n    }\\n    var maxHits = Math.max(...serverHits);\\n    var maxHitServers = [];\\n    for(let hitServer in serverHits) {\\n        if(serverHits[hitServer] == maxHits) maxHitServers.push(hitServer);\\n    }\\n    \\n    return maxHitServers;\\n};\\n```",
                "solutionTags": [],
                "code": "```i % k```\n```\\n/**\\n * @param {number} k\\n * @param {number[]} arrival\\n * @param {number[]} load\\n * @return {number[]}\\n */\\nvar busiestServers = function(k, arrival, load) {\\n    var serverHits = [];\\n    var servers = [];\\n    var imk = k-1;\\n    \\n    for(let i in load) {\\n        var j = 0;\\n        imk++;\\n        if(imk >= k) imk -= k;\\n        while(j < k) {\\n            currentServer = (imk) + j;\\n            if(currentServer >= k) currentServer -= k;\\n            if(arrival[i] >= (servers[currentServer] ?? 0)) {\\n                servers[currentServer] = arrival[i] + load[i];\\n                serverHits[currentServer] = (serverHits[currentServer] ?? 0) + 1;\\n                break;\\n            }\\n            j++;\\n        }\\n    }\\n    var maxHits = Math.max(...serverHits);\\n    var maxHitServers = [];\\n    for(let hitServer in serverHits) {\\n        if(serverHits[hitServer] == maxHits) maxHitServers.push(hitServer);\\n    }\\n    \\n    return maxHitServers;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1067108,
                "title": "java",
                "content": "\\n```\\nclass Solution {\\n    public List<Integer> busiestServers(int k, int[] arrival, int[] load) {\\n        int[] cnt = new int[k];\\n        TreeSet<Integer> avail = new TreeSet();\\n        for(int i=0; i<k; i++)\\n            avail.add(i);\\n        int max = 0;\\n        PriorityQueue<int[]> q = new PriorityQueue<int[]>((a,b)->(a[1]-b[1]));\\n        for(int i=0; i<arrival.length; i++){\\n            while(!q.isEmpty()){\\n                if(q.peek()[1]<=arrival[i])\\n                    avail.add(q.poll()[0]);\\n                else break;\\n            }\\n            Integer sevIdx = avail.ceiling(i%k);\\n            if(sevIdx == null)\\n                sevIdx = avail.ceiling(0);\\n            if(sevIdx != null){\\n                avail.remove(sevIdx);\\n                cnt[sevIdx]++;\\n                q.offer(new int[]{sevIdx, arrival[i]+load[i]});\\n                if(cnt[sevIdx]>max)\\n                    max = cnt[sevIdx];\\n            }\\n        }\\n        List<Integer> res = new ArrayList();\\n        for(int i=0; i<cnt.length; i++)\\n            if(cnt[i] == max)\\n                res.add(i);\\n        return res;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public List<Integer> busiestServers(int k, int[] arrival, int[] load) {\\n        int[] cnt = new int[k];\\n        TreeSet<Integer> avail = new TreeSet();\\n        for(int i=0; i<k; i++)\\n            avail.add(i);\\n        int max = 0;\\n        PriorityQueue<int[]> q = new PriorityQueue<int[]>((a,b)->(a[1]-b[1]));\\n        for(int i=0; i<arrival.length; i++){\\n            while(!q.isEmpty()){\\n                if(q.peek()[1]<=arrival[i])\\n                    avail.add(q.poll()[0]);\\n                else break;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1054308,
                "title": "java-easy-to-understand-solution-with-explanation",
                "content": "The question requires us to keep two information at any point of time, available servers and the time values at which the occupied servers, will be free. So, we will need two data structures, a **TreeSet** and a **PriorityQueue**.\\n\\n**Why TreeSet ?**\\nBecause, we need to pick the server on the basis of the given algorithm. *If there was no such condition, we could have done with the PriorityQueue alone.*\\nTreeSet will keep the indicies of available servers, in a sorted order, and searching the required index and the next greatest index is fast.\\n\\n**Why PriorityQueue ?**\\nBecause, PriorityQueue will keep the information when the occupied servers are going to be free, in the order sorted by the free time. So, at every point of time, we can simply pick all the servers, which are free, and add to the available servers TreeSet.\\n\\n```\\npublic List<Integer> busiestServers(int k, int[] arrival, int[] load) {\\n        int[] counts = new int[k];\\n        int maxReqHandled = 0;\\n        TreeSet<Integer> availableServers = new TreeSet<>();\\n\\t\\tPriorityQueue<int[]> pQueue = new PriorityQueue<>((a,b) -> Integer.compare(a[1], b[1]));\\n        // int[] : {serverIndex, timeAtWhichItWillBeFree}\\n        for (int i = 0; i < k; i++) availableServers.add(i);\\n        for (int i = 0; i < arrival.length; i++) {\\n            int reqStartTime = arrival[i], reqEndTime = arrival[i] + load[i];\\n            while (!pQueue.isEmpty() && pQueue.peek()[1] <= reqStartTime) {\\n                availableServers.add(pQueue.poll()[0]);\\n            }\\n            Integer server = availableServers.ceiling(i % k);\\n            if (server == null) server = availableServers.ceiling(0);\\n\\t\\t\\t// check from i%k to k, then from 0 to i%k\\n            if (server != null) {\\n                availableServers.remove(server);\\n                pQueue.add(new int[] {server, reqEndTime});\\n                counts[server]++;\\n                if (counts[server] > maxReqHandled) maxReqHandled = counts[server];\\n            }\\n        }\\n        List<Integer> res = new ArrayList<>();\\n        for (int i = 0; i < k; i++) {\\n            if (counts[i] == maxReqHandled) res.add(i);\\n        }\\n        return res;\\n    }\\n```\\nI hope, it helps someone!",
                "solutionTags": [],
                "code": "```\\npublic List<Integer> busiestServers(int k, int[] arrival, int[] load) {\\n        int[] counts = new int[k];\\n        int maxReqHandled = 0;\\n        TreeSet<Integer> availableServers = new TreeSet<>();\\n\\t\\tPriorityQueue<int[]> pQueue = new PriorityQueue<>((a,b) -> Integer.compare(a[1], b[1]));\\n        // int[] : {serverIndex, timeAtWhichItWillBeFree}\\n        for (int i = 0; i < k; i++) availableServers.add(i);\\n        for (int i = 0; i < arrival.length; i++) {\\n            int reqStartTime = arrival[i], reqEndTime = arrival[i] + load[i];\\n            while (!pQueue.isEmpty() && pQueue.peek()[1] <= reqStartTime) {\\n                availableServers.add(pQueue.poll()[0]);\\n            }\\n            Integer server = availableServers.ceiling(i % k);\\n            if (server == null) server = availableServers.ceiling(0);\\n\\t\\t\\t// check from i%k to k, then from 0 to i%k\\n            if (server != null) {\\n                availableServers.remove(server);\\n                pQueue.add(new int[] {server, reqEndTime});\\n                counts[server]++;\\n                if (counts[server] > maxReqHandled) maxReqHandled = counts[server];\\n            }\\n        }\\n        List<Integer> res = new ArrayList<>();\\n        for (int i = 0; i < k; i++) {\\n            if (counts[i] == maxReqHandled) res.add(i);\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1011087,
                "title": "help-java-not-using-priority-queue",
                "content": "Why is this solution resulting in time out? \\n\\nTime complexity should be O(N*K) where K is number of servers , N is number of requests.\\n\\n```\\nclass Solution {\\n    HashMap<Integer, Stack<Integer>> monitor = new HashMap<>();\\n    \\n    public List<Integer> busiestServers(int k, int[] arrival, int[] load) {\\n        int ans = -1;\\n        for (int i = 0; i< arrival.length; i++) {\\n            int server = getServer(k, i, arrival, load);\\n            if (server == -1) continue;\\n            \\n            Stack<Integer> stack = monitor.getOrDefault(server, new Stack<Integer>());\\n            stack.push(arrival[i]+load[i]);\\n            monitor.put(server, stack);\\n            \\n            ans = Math.max(ans, stack.size());\\n        }\\n        \\n        ArrayList<Integer> result = new ArrayList<>();\\n        if (ans == -1) {return result;}\\n        \\n        for (Integer e: monitor.keySet()){\\n            Stack<Integer> values = monitor.get(e); \\n            if (values.size() == ans) result.add(e);\\n        }\\n        \\n        return result;\\n    }\\n    \\n    public int getServer(int k, int index, int[]arrival, int[]load) {\\n        if (index < k) return index;\\n            \\n        int end = -1;\\n        int server = -1;\\n        for (int i = 0; i<k; i++) {\\n            server = (index+i) %k ;\\n            end = monitor.get(server).peek(); \\n            if (end <= arrival[index]) {\\n                return server;                \\n            }\\n        }\\n        \\n        return -1;    \\n    }\\n\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    HashMap<Integer, Stack<Integer>> monitor = new HashMap<>();\\n    \\n    public List<Integer> busiestServers(int k, int[] arrival, int[] load) {\\n        int ans = -1;\\n        for (int i = 0; i< arrival.length; i++) {\\n            int server = getServer(k, i, arrival, load);\\n            if (server == -1) continue;\\n            \\n            Stack<Integer> stack = monitor.getOrDefault(server, new Stack<Integer>());\\n            stack.push(arrival[i]+load[i]);\\n            monitor.put(server, stack);\\n            \\n            ans = Math.max(ans, stack.size());\\n        }\\n        \\n        ArrayList<Integer> result = new ArrayList<>();\\n        if (ans == -1) {return result;}\\n        \\n        for (Integer e: monitor.keySet()){\\n            Stack<Integer> values = monitor.get(e); \\n            if (values.size() == ans) result.add(e);\\n        }\\n        \\n        return result;\\n    }\\n    \\n    public int getServer(int k, int index, int[]arrival, int[]load) {\\n        if (index < k) return index;\\n            \\n        int end = -1;\\n        int server = -1;\\n        for (int i = 0; i<k; i++) {\\n            server = (index+i) %k ;\\n            end = monitor.get(server).peek(); \\n            if (end <= arrival[index]) {\\n                return server;                \\n            }\\n        }\\n        \\n        return -1;    \\n    }\\n\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 990366,
                "title": "share-my-java-solution-using-tree-set-and-sliding-window-algorithm",
                "content": "```\\nclass Solution {\\n    public List<Integer> busiestServers(int k, int[] arrival, int[] load) {\\n        List<Integer> res = new ArrayList<>();\\n        int[] count = new int[k];\\n        List<int[]> times = new ArrayList<>();\\n        for(int i=0;i<arrival.length;i++){\\n            times.add(new int[]{arrival[i], arrival[i]+load[i]});\\n        }\\n        \\n        TreeSet<Integer> avail = new TreeSet<>();\\n        for(int i=0;i<k;i++){\\n            avail.add(i);\\n        }\\n        int max_count = 0;\\n        PriorityQueue<int[]> minHeap = new PriorityQueue<>((a,b)->(a[0]-b[0]));\\n        for(int i=0;i<times.size();i++){\\n            int[] cur_interval = times.get(i);\\n            int start = cur_interval[0];\\n            int end = cur_interval[1];\\n            while(minHeap.size()!=0){\\n                int[] temp = minHeap.peek();\\n                if(temp[0]<=start){\\n                    minHeap.poll();\\n                    avail.add(temp[1]);\\n                }else{\\n                    break;\\n                }\\n            }\\n            \\n            int index = i%k;\\n            Integer pos = avail.ceiling(index);\\n            if(pos==null || pos>=k){\\n                pos = avail.ceiling(0);\\n            }\\n            // System.out.println(pos);\\n            if(pos!=null && pos<k){\\n                count[pos]++;\\n                avail.remove(pos);\\n                minHeap.offer(new int[]{end, pos});\\n                max_count = Math.max(max_count, count[pos]);\\n            }\\n        }\\n        \\n        \\n        for(int i=0;i<count.length;i++){\\n            if(max_count == count[i]){\\n                res.add(i);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> busiestServers(int k, int[] arrival, int[] load) {\\n        List<Integer> res = new ArrayList<>();\\n        int[] count = new int[k];\\n        List<int[]> times = new ArrayList<>();\\n        for(int i=0;i<arrival.length;i++){\\n            times.add(new int[]{arrival[i], arrival[i]+load[i]});\\n        }\\n        \\n        TreeSet<Integer> avail = new TreeSet<>();\\n        for(int i=0;i<k;i++){\\n            avail.add(i);\\n        }\\n        int max_count = 0;\\n        PriorityQueue<int[]> minHeap = new PriorityQueue<>((a,b)->(a[0]-b[0]));\\n        for(int i=0;i<times.size();i++){\\n            int[] cur_interval = times.get(i);\\n            int start = cur_interval[0];\\n            int end = cur_interval[1];\\n            while(minHeap.size()!=0){\\n                int[] temp = minHeap.peek();\\n                if(temp[0]<=start){\\n                    minHeap.poll();\\n                    avail.add(temp[1]);\\n                }else{\\n                    break;\\n                }\\n            }\\n            \\n            int index = i%k;\\n            Integer pos = avail.ceiling(index);\\n            if(pos==null || pos>=k){\\n                pos = avail.ceiling(0);\\n            }\\n            // System.out.println(pos);\\n            if(pos!=null && pos<k){\\n                count[pos]++;\\n                avail.remove(pos);\\n                minHeap.offer(new int[]{end, pos});\\n                max_count = Math.max(max_count, count[pos]);\\n            }\\n        }\\n        \\n        \\n        for(int i=0;i<count.length;i++){\\n            if(max_count == count[i]){\\n                res.add(i);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 930342,
                "title": "straightforward-java-solution-treeset-and-priorityqueue",
                "content": "```\\nclass Solution {\\n    public List<Integer> busiestServers(int k, int[] arrival, int[] load) {\\n        List<Integer> ans = new ArrayList<>();\\n        int[] count = new int[k];\\n        int maxCount = 0;\\n        TreeSet<Integer> availableServer = new TreeSet<>();\\n        for (int i = 0; i < k; i++) {\\n            availableServer.add(i);\\n        }\\n        Queue<int[]> runningServer = new PriorityQueue<>(new Comparator<int[]>(){\\n            @Override\\n            public int compare(int[] a, int[] b) {\\n                if (a[1] == b[1]) {\\n                    return a[0] - b[0];\\n                }\\n                return a[1] - b[1];\\n            }\\n        });\\n        for (int i = 0; i < arrival.length; i++) {\\n            int start = arrival[i];\\n            int end = start + load[i];\\n            while (!runningServer.isEmpty() && runningServer.peek()[1] <= start) {\\n                availableServer.add(runningServer.poll()[0]);\\n            }\\n            Integer assignedServer = availableServer.ceiling(i % k);\\n            if (assignedServer == null) {\\n                assignedServer = availableServer.ceiling(0);\\n                if (assignedServer == null) {\\n                    continue;\\n                }\\n            }\\n            availableServer.remove(assignedServer);\\n            runningServer.add(new int[]{assignedServer, end});\\n            count[assignedServer]++;\\n            maxCount = Math.max(maxCount, count[assignedServer]);\\n        }\\n        for (int i = 0; i < k; i++) {\\n            if (count[i] == maxCount) {\\n                ans.add(i);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> busiestServers(int k, int[] arrival, int[] load) {\\n        List<Integer> ans = new ArrayList<>();\\n        int[] count = new int[k];\\n        int maxCount = 0;\\n        TreeSet<Integer> availableServer = new TreeSet<>();\\n        for (int i = 0; i < k; i++) {\\n            availableServer.add(i);\\n        }\\n        Queue<int[]> runningServer = new PriorityQueue<>(new Comparator<int[]>(){\\n            @Override\\n            public int compare(int[] a, int[] b) {\\n                if (a[1] == b[1]) {\\n                    return a[0] - b[0];\\n                }\\n                return a[1] - b[1];\\n            }\\n        });\\n        for (int i = 0; i < arrival.length; i++) {\\n            int start = arrival[i];\\n            int end = start + load[i];\\n            while (!runningServer.isEmpty() && runningServer.peek()[1] <= start) {\\n                availableServer.add(runningServer.poll()[0]);\\n            }\\n            Integer assignedServer = availableServer.ceiling(i % k);\\n            if (assignedServer == null) {\\n                assignedServer = availableServer.ceiling(0);\\n                if (assignedServer == null) {\\n                    continue;\\n                }\\n            }\\n            availableServer.remove(assignedServer);\\n            runningServer.add(new int[]{assignedServer, end});\\n            count[assignedServer]++;\\n            maxCount = Math.max(maxCount, count[assignedServer]);\\n        }\\n        for (int i = 0; i < k; i++) {\\n            if (count[i] == maxCount) {\\n                ans.add(i);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 914177,
                "title": "why-using-treeset-instead-of-priorityqueue-for-endtime-serverid-pair-times-out",
                "content": "Following solution uses TreeSet and does not pass the time limit.\\n```\\nclass Solution {\\n    public List<Integer> busiestServers(int k, int[] arrival, int[] load) {\\n        TreeSet<int[]> busy = new TreeSet<>(new Comparator<int[]>() {\\n            public int compare(int[] a, int[] b) {\\n                return a[0] == b[0] ? a[1] - b[1] : a[0]-b[0];\\n            }    \\n        });\\n        \\n        TreeSet<Integer> available = new TreeSet<>();\\n        \\n        for (int i=0; i<k; i++) {\\n\\t\\t\\tavailable.add(i);\\n\\t\\t}\\n\\t\\t\\n        //req completed by ith server\\n        int[] reqDone = new int[k]; \\n        int maxReqDone = 0;\\n            \\n        for (int i=0; i<arrival.length; i++) {\\n            update(busy, available, arrival[i]);\\n            \\n            if (available.isEmpty()) {\\n                // no server available\\n                continue;\\n            }\\n            \\n            int targetId = i % k;\\n            \\n            // get server with id >= targetId\\n            Integer nextAvailableId = available.ceiling(targetId);\\n            \\n            if (nextAvailableId == null) {\\n\\t\\t\\t\\t// no next server then get the first available server\\n\\t\\t\\t\\tnextAvailableId = available.first();\\n\\t\\t\\t} \\n\\t\\t\\t\\n\\t\\t\\treqDone[nextAvailableId]++;\\n\\n\\t\\t\\tif (reqDone[nextAvailableId] > maxReqDone) {\\n\\t\\t\\t\\tmaxReqDone = reqDone[nextAvailableId];\\n\\t\\t\\t}\\n\\n\\t\\t\\t// assign request to server with id = nextAvailableId\\n\\t\\t\\tavailable.remove(nextAvailableId);\\n\\t\\t\\tbusy.add(new int[]{arrival[i] + load[i], nextAvailableId});\\n        }\\n        \\n        List<Integer> result = new ArrayList<>();\\n        \\n        for (int i=0; i<k; i++) {\\n            if (reqDone[i] == maxReqDone) {\\n                result.add(i);\\n            }\\n        }\\n        \\n        return result;\\n    }\\n    \\n    private void update(final TreeSet<int[]> busy, final TreeSet<Integer> available, final int time) {        \\n        // remove all servers from busy for which request has been finished till time \\n        Iterator<int[]> it = busy.iterator();\\n        \\n        while (it.hasNext()) {\\n            int[] entry = it.next();\\n            \\n            if (entry[0] <= time) {\\n                available.add(entry[1]);\\n                it.remove();\\n            }\\n        }\\n    }\\n}\\n```\\n\\nBut if i use Priority Queue i.e. following solution it passes why ?\\n```\\nclass Solution {\\n    public List<Integer> busiestServers(int k, int[] arrival, int[] load) {\\n        PriorityQueue<int[]> busy = new PriorityQueue<>((a, b) -> (a[0]-b[0]));\\n        \\n        TreeSet<Integer> available = new TreeSet<>();\\n        \\n        for (int i=0; i<k; i++) {\\n\\t\\t\\tavailable.add(i);\\n\\t\\t}\\n\\t\\t\\n        //req completed by ith server\\n        int[] reqDone = new int[k]; \\n        int maxReqDone = 0;\\n            \\n        for (int i=0; i<arrival.length; i++) {\\n            update(busy, available, arrival[i]);\\n            \\n            if (available.isEmpty()) {\\n                // no server available\\n                continue;\\n            }\\n            \\n            int targetId = i % k;\\n            \\n            // get server with id >= targetId\\n            Integer nextAvailableId = available.ceiling(targetId);\\n            \\n            if (nextAvailableId == null) {\\n\\t\\t\\t\\t// no next server then get the first available server\\n\\t\\t\\t\\tnextAvailableId = available.first();\\n\\t\\t\\t} \\n\\t\\t\\t\\n\\t\\t\\treqDone[nextAvailableId]++;\\n\\n\\t\\t\\tif (reqDone[nextAvailableId] > maxReqDone) {\\n\\t\\t\\t\\tmaxReqDone = reqDone[nextAvailableId];\\n\\t\\t\\t}\\n\\n\\t\\t\\t// assign request to server with id = nextAvailableId\\n\\t\\t\\tavailable.remove(nextAvailableId);\\n\\t\\t\\tbusy.offer(new int[]{arrival[i] + load[i], nextAvailableId});\\n        }\\n        \\n        List<Integer> result = new ArrayList<>();\\n        \\n        for (int i=0; i<k; i++) {\\n            if (reqDone[i] == maxReqDone) {\\n                result.add(i);\\n            }\\n        }\\n        \\n        return result;\\n    }\\n    \\n    private void update(final PriorityQueue<int[]> busy, final TreeSet<Integer> available, final int time) {        \\n        // remove all servers from busy for which request has been finished till time \\n        \\n        while (!busy.isEmpty() && busy.peek()[0] <= time) {\\n            available.add(busy.poll()[1]);\\n        }\\n    }\\n}\\n```\\n\\nAlso, how to prove that time complexity of while loop for iteration within priority queue is log(K) ? In worst case, we might have to pop out all the elements within Priority Queue.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> busiestServers(int k, int[] arrival, int[] load) {\\n        TreeSet<int[]> busy = new TreeSet<>(new Comparator<int[]>() {\\n            public int compare(int[] a, int[] b) {\\n                return a[0] == b[0] ? a[1] - b[1] : a[0]-b[0];\\n            }    \\n        });\\n        \\n        TreeSet<Integer> available = new TreeSet<>();\\n        \\n        for (int i=0; i<k; i++) {\\n\\t\\t\\tavailable.add(i);\\n\\t\\t}\\n\\t\\t\\n        //req completed by ith server\\n        int[] reqDone = new int[k]; \\n        int maxReqDone = 0;\\n            \\n        for (int i=0; i<arrival.length; i++) {\\n            update(busy, available, arrival[i]);\\n            \\n            if (available.isEmpty()) {\\n                // no server available\\n                continue;\\n            }\\n            \\n            int targetId = i % k;\\n            \\n            // get server with id >= targetId\\n            Integer nextAvailableId = available.ceiling(targetId);\\n            \\n            if (nextAvailableId == null) {\\n\\t\\t\\t\\t// no next server then get the first available server\\n\\t\\t\\t\\tnextAvailableId = available.first();\\n\\t\\t\\t} \\n\\t\\t\\t\\n\\t\\t\\treqDone[nextAvailableId]++;\\n\\n\\t\\t\\tif (reqDone[nextAvailableId] > maxReqDone) {\\n\\t\\t\\t\\tmaxReqDone = reqDone[nextAvailableId];\\n\\t\\t\\t}\\n\\n\\t\\t\\t// assign request to server with id = nextAvailableId\\n\\t\\t\\tavailable.remove(nextAvailableId);\\n\\t\\t\\tbusy.add(new int[]{arrival[i] + load[i], nextAvailableId});\\n        }\\n        \\n        List<Integer> result = new ArrayList<>();\\n        \\n        for (int i=0; i<k; i++) {\\n            if (reqDone[i] == maxReqDone) {\\n                result.add(i);\\n            }\\n        }\\n        \\n        return result;\\n    }\\n    \\n    private void update(final TreeSet<int[]> busy, final TreeSet<Integer> available, final int time) {        \\n        // remove all servers from busy for which request has been finished till time \\n        Iterator<int[]> it = busy.iterator();\\n        \\n        while (it.hasNext()) {\\n            int[] entry = it.next();\\n            \\n            if (entry[0] <= time) {\\n                available.add(entry[1]);\\n                it.remove();\\n            }\\n        }\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public List<Integer> busiestServers(int k, int[] arrival, int[] load) {\\n        PriorityQueue<int[]> busy = new PriorityQueue<>((a, b) -> (a[0]-b[0]));\\n        \\n        TreeSet<Integer> available = new TreeSet<>();\\n        \\n        for (int i=0; i<k; i++) {\\n\\t\\t\\tavailable.add(i);\\n\\t\\t}\\n\\t\\t\\n        //req completed by ith server\\n        int[] reqDone = new int[k]; \\n        int maxReqDone = 0;\\n            \\n        for (int i=0; i<arrival.length; i++) {\\n            update(busy, available, arrival[i]);\\n            \\n            if (available.isEmpty()) {\\n                // no server available\\n                continue;\\n            }\\n            \\n            int targetId = i % k;\\n            \\n            // get server with id >= targetId\\n            Integer nextAvailableId = available.ceiling(targetId);\\n            \\n            if (nextAvailableId == null) {\\n\\t\\t\\t\\t// no next server then get the first available server\\n\\t\\t\\t\\tnextAvailableId = available.first();\\n\\t\\t\\t} \\n\\t\\t\\t\\n\\t\\t\\treqDone[nextAvailableId]++;\\n\\n\\t\\t\\tif (reqDone[nextAvailableId] > maxReqDone) {\\n\\t\\t\\t\\tmaxReqDone = reqDone[nextAvailableId];\\n\\t\\t\\t}\\n\\n\\t\\t\\t// assign request to server with id = nextAvailableId\\n\\t\\t\\tavailable.remove(nextAvailableId);\\n\\t\\t\\tbusy.offer(new int[]{arrival[i] + load[i], nextAvailableId});\\n        }\\n        \\n        List<Integer> result = new ArrayList<>();\\n        \\n        for (int i=0; i<k; i++) {\\n            if (reqDone[i] == maxReqDone) {\\n                result.add(i);\\n            }\\n        }\\n        \\n        return result;\\n    }\\n    \\n    private void update(final PriorityQueue<int[]> busy, final TreeSet<Integer> available, final int time) {        \\n        // remove all servers from busy for which request has been finished till time \\n        \\n        while (!busy.isEmpty() && busy.peek()[0] <= time) {\\n            available.add(busy.poll()[1]);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 897267,
                "title": "ruby-o-n-log-m-solution-using-only-arrays",
                "content": "## Brute force solution that gives TLE. \\n*Complexity:* `O(N * K)`, where `N` - the number of tasks.\\n\\n```\\ndef busiest_servers(k, arrival, load)\\n  job_end_times = [0] * k # busy till time per sever\\n  cnt = [0] * k # handled tasks count per server\\n  max_cnt = 0\\n  arrival.zip(load).each_with_index do |(time, duration), i|\\n    cond = proc { |j| job_end_times[j] <= time }\\n    j = (i % k...k).find(&cond) || (0...i % k).find(&cond) # O(K)\\n    next unless j\\n\\n    job_end_times[j] = time + duration\\n\\n    # count taken tasks\\n    cnt[j] += 1\\n    max_cnt = cnt[j] if cnt[j] > max_cnt\\n  end\\n  (0...k).select { |i| cnt[i] == max_cnt }\\nend\\n```\\n\\n## Optimization\\n\\nTo speed up the next available server lookup, we\\'ll search only within available servers using binray search.\\nAdd available servers sorted `Array`  with servers numbers and list of in-progress tasks (`jobs`) sorted by tasks end time.\\n\\n*Complexity:* `O(N * log M)`, where `N` - the number of tasks, `M` - max(`N`, `K`)\\n\\n```\\nJob = Struct.new(:server_no, :end_time)\\n\\ndef busiest_servers(k, arrival, load)\\n  servers = *0...k # available servers\\n  jobs = [] # in-progress tasks\\n  cnt = [0] * k # handled tasks count per server\\n  max_cnt = 0\\n  arrival.zip(load).each_with_index do |(time, duration), i|\\n    # Unregister comleted jobs, add to available servers.\\n\\t# The body of the loop is executed O(N) times in the WHOLE program.\\n    while jobs.any? && jobs[0].end_time <= time\\n      job = jobs.delete_at(0)\\n      insert_at = servers.bsearch_index { |n| n >= job.server_no } || servers.size\\n      servers.insert(insert_at, job.server_no)\\n    end\\n    next if servers.empty?\\n\\n    # get the next available server starting from (i % k)th server -- O(K)\\n    ik = i % k\\n    j = servers.bsearch_index { |n| n >= ik } || 0\\n\\n    # register server as busy till task\\'s end time -- O(N)\\n    server_no = servers.delete_at(j)\\n    end_time = time + duration\\n    insert_at = jobs.bsearch_index { |j| j.end_time >= end_time } || jobs.size\\n    jobs.insert(insert_at, Job[server_no, end_time])\\n\\n    # count taken tasks\\n    cnt[server_no] += 1\\n    max_cnt = cnt[server_no] if cnt[server_no] > max_cnt\\n  end\\n  # return servers that handled most tasks\\n  (0...k).select { |i| cnt[i] == max_cnt }\\nend\\n```\\n\\n## Some refactoring\\nIntroduce `SortedArray` class with method `#add` and make jobs comparable by end time. \\n\\n```\\nclass Job < Struct.new(:server_no, :end_time)\\n  include Comparable\\n\\n  def <=>(other)\\n    end_time <=> other.end_time\\n  end\\nend\\n\\nclass SortedArray < Array\\n  def add(val)\\n    insert_at = bsearch_index { |n| n >= val } || size\\n    insert(insert_at, val)\\n  end\\nend\\n\\ndef busiest_servers(k, arrival, load)\\n  servers = SortedArray.new(k) { |i| i } # available servers\\n  jobs = SortedArray.new # in-progress tasks\\n  cnt = [0] * k # handled tasks count per server\\n  max_cnt = 0\\n  arrival.zip(load).each_with_index do |(time, duration), i|\\n    # Unregister comleted jobs, add to available servers.\\n\\t# The body of the loop is executed O(N) times in the WHOLE program.\\n    while jobs.any? && jobs[0].end_time <= time\\n      servers.add(jobs.shift.server_no)\\n    end\\n    next if servers.empty?\\n\\n    # get the next available server starting from (i % k)th server -- O(K)\\n    ik = i % k\\n    server_no = servers.delete_at(servers.bsearch_index { |n| n >= ik } || 0)\\n\\n    # register server as busy till task\\'s end time -- O(N)\\n    jobs.add(Job[server_no, time + duration])\\n\\n    # count assigned tasks\\n    cnt[server_no] += 1\\n    max_cnt = cnt[server_no] if cnt[server_no] > max_cnt\\n  end\\n  # return servers that handled most tasks\\n  (0...k).select { |i| cnt[i] == max_cnt }\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\ndef busiest_servers(k, arrival, load)\\n  job_end_times = [0] * k # busy till time per sever\\n  cnt = [0] * k # handled tasks count per server\\n  max_cnt = 0\\n  arrival.zip(load).each_with_index do |(time, duration), i|\\n    cond = proc { |j| job_end_times[j] <= time }\\n    j = (i % k...k).find(&cond) || (0...i % k).find(&cond) # O(K)\\n    next unless j\\n\\n    job_end_times[j] = time + duration\\n\\n    # count taken tasks\\n    cnt[j] += 1\\n    max_cnt = cnt[j] if cnt[j] > max_cnt\\n  end\\n  (0...k).select { |i| cnt[i] == max_cnt }\\nend\\n```\n```\\nJob = Struct.new(:server_no, :end_time)\\n\\ndef busiest_servers(k, arrival, load)\\n  servers = *0...k # available servers\\n  jobs = [] # in-progress tasks\\n  cnt = [0] * k # handled tasks count per server\\n  max_cnt = 0\\n  arrival.zip(load).each_with_index do |(time, duration), i|\\n    # Unregister comleted jobs, add to available servers.\\n\\t# The body of the loop is executed O(N) times in the WHOLE program.\\n    while jobs.any? && jobs[0].end_time <= time\\n      job = jobs.delete_at(0)\\n      insert_at = servers.bsearch_index { |n| n >= job.server_no } || servers.size\\n      servers.insert(insert_at, job.server_no)\\n    end\\n    next if servers.empty?\\n\\n    # get the next available server starting from (i % k)th server -- O(K)\\n    ik = i % k\\n    j = servers.bsearch_index { |n| n >= ik } || 0\\n\\n    # register server as busy till task\\'s end time -- O(N)\\n    server_no = servers.delete_at(j)\\n    end_time = time + duration\\n    insert_at = jobs.bsearch_index { |j| j.end_time >= end_time } || jobs.size\\n    jobs.insert(insert_at, Job[server_no, end_time])\\n\\n    # count taken tasks\\n    cnt[server_no] += 1\\n    max_cnt = cnt[server_no] if cnt[server_no] > max_cnt\\n  end\\n  # return servers that handled most tasks\\n  (0...k).select { |i| cnt[i] == max_cnt }\\nend\\n```\n```\\nclass Job < Struct.new(:server_no, :end_time)\\n  include Comparable\\n\\n  def <=>(other)\\n    end_time <=> other.end_time\\n  end\\nend\\n\\nclass SortedArray < Array\\n  def add(val)\\n    insert_at = bsearch_index { |n| n >= val } || size\\n    insert(insert_at, val)\\n  end\\nend\\n\\ndef busiest_servers(k, arrival, load)\\n  servers = SortedArray.new(k) { |i| i } # available servers\\n  jobs = SortedArray.new # in-progress tasks\\n  cnt = [0] * k # handled tasks count per server\\n  max_cnt = 0\\n  arrival.zip(load).each_with_index do |(time, duration), i|\\n    # Unregister comleted jobs, add to available servers.\\n\\t# The body of the loop is executed O(N) times in the WHOLE program.\\n    while jobs.any? && jobs[0].end_time <= time\\n      servers.add(jobs.shift.server_no)\\n    end\\n    next if servers.empty?\\n\\n    # get the next available server starting from (i % k)th server -- O(K)\\n    ik = i % k\\n    server_no = servers.delete_at(servers.bsearch_index { |n| n >= ik } || 0)\\n\\n    # register server as busy till task\\'s end time -- O(N)\\n    jobs.add(Job[server_no, time + duration])\\n\\n    # count assigned tasks\\n    cnt[server_no] += 1\\n    max_cnt = cnt[server_no] if cnt[server_no] > max_cnt\\n  end\\n  # return servers that handled most tasks\\n  (0...k).select { |i| cnt[i] == max_cnt }\\nend\\n```",
                "codeTag": "Java"
            },
            {
                "id": 885027,
                "title": "cpp14-solution-priority-queue-set",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n        set<int> s;\\n        priority_queue<pair<int,int> , vector<pair<int,int>> , greater<pair<int,int>> > pq;\\n        int n = int(arrival.size());\\n        unordered_map<int,int> mpp;\\n        for(int i = 0 ; i < k ; ++i) s.insert(i);\\n        for(int i = 0 ; i < n ; ++i){\\n            int start = arrival[i];\\n            int end   = start + load[i];\\n            while(1){\\n                if(pq.empty() == true) break;\\n                int currentending = pq.top().first;\\n                if(currentending <= start){\\n                    s.insert(pq.top().second);\\n                    pq.pop();\\n                    continue;\\n                }\\n                else break;\\n            }\\n            if(s.size() == 0) continue;\\n            int first = i % k ;\\n            auto it = s.find(first);\\n            if(it != s.end()){\\n                s.erase(s.find(first));\\n                pq.push({end , first});\\n                mpp[first]++;\\n                continue;\\n            }\\n            else if(it == s.end()){\\n                auto itr = s.lower_bound(first);\\n                if(itr == s.end()){\\n                    itr = s.begin();\\n                }\\n                int now = *itr;\\n                mpp[now]++;\\n                pq.push({end , now});\\n                s.erase(s.find(now));\\n            }\\n        }\\n        vector<int> ans;\\n        int maxx = INT_MIN;\\n        for(auto x : mpp) maxx = max(maxx , x.second) ;\\n        for(auto x : mpp) if(x.second == maxx){\\n            ans.push_back(x.first);\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n        set<int> s;\\n        priority_queue<pair<int,int> , vector<pair<int,int>> , greater<pair<int,int>> > pq;\\n        int n = int(arrival.size());\\n        unordered_map<int,int> mpp;\\n        for(int i = 0 ; i < k ; ++i) s.insert(i);\\n        for(int i = 0 ; i < n ; ++i){\\n            int start = arrival[i];\\n            int end   = start + load[i];\\n            while(1){\\n                if(pq.empty() == true) break;\\n                int currentending = pq.top().first;\\n                if(currentending <= start){\\n                    s.insert(pq.top().second);\\n                    pq.pop();\\n                    continue;\\n                }\\n                else break;\\n            }\\n            if(s.size() == 0) continue;\\n            int first = i % k ;\\n            auto it = s.find(first);\\n            if(it != s.end()){\\n                s.erase(s.find(first));\\n                pq.push({end , first});\\n                mpp[first]++;\\n                continue;\\n            }\\n            else if(it == s.end()){\\n                auto itr = s.lower_bound(first);\\n                if(itr == s.end()){\\n                    itr = s.begin();\\n                }\\n                int now = *itr;\\n                mpp[now]++;\\n                pq.push({end , now});\\n                s.erase(s.find(now));\\n            }\\n        }\\n        vector<int> ans;\\n        int maxx = INT_MIN;\\n        for(auto x : mpp) maxx = max(maxx , x.second) ;\\n        for(auto x : mpp) if(x.second == maxx){\\n            ans.push_back(x.first);\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 883952,
                "title": "treemap-priority-queue-based-solution",
                "content": "set is List of Server\\nmap is for request processed\\nPriorityQueue to know when that server will be free \\n\\n```\\nclass Solution {\\n    public List<Integer> busiestServers(int k, int[] arrival, int[] load) {\\n        TreeSet<Integer>  set  = new TreeSet<>();\\n        HashMap<Integer, Integer> map =  new HashMap<>();\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> {return a[0] - b[0];});\\n        int l = arrival.length;\\n        \\n        for(int  i = 0; i < k; i++)\\n            set.add(i);\\n        \\n        int maxReq = 0;\\n        for(int i  = 0; i < l; i++) {\\n            int exp = i%k;\\n            int at = arrival[i];\\n            \\n            while(!pq.isEmpty() && pq.peek()[0] <=  at ) {\\n                int tarr[] = pq.poll();\\n                set.add(tarr[1]);\\n            }\\n            \\n             Integer server =  set.ceiling(exp);\\n             if(server == null){\\n               server =  set.ceiling(0);\\n             }\\n            if(server == null){\\n                continue;\\n            }\\n            set.remove(server);\\n            pq.add(new int[] {arrival[i] + load[i], server});\\n            map.put( server, map.getOrDefault( server, 0)+ 1);\\n            if(maxReq < map.get(server))\\n                maxReq = map.get(server);\\n        }\\n        \\n        List<Integer>  list  = new ArrayList<>();\\n        for( Map.Entry<Integer, Integer>  e : map.entrySet()) {\\n            if(e.getValue() ==  maxReq)\\n                list.add(e.getKey());\\n        }\\n        \\n        return list;\\n        \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public List<Integer> busiestServers(int k, int[] arrival, int[] load) {\\n        TreeSet<Integer>  set  = new TreeSet<>();\\n        HashMap<Integer, Integer> map =  new HashMap<>();\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> {return a[0] - b[0];}",
                "codeTag": "Java"
            },
            {
                "id": 883302,
                "title": "c-version-timeout-2-versions",
                "content": "**simple version (107 of 108 passed)**\\n```\\nclass _1606_Find_Servers_That_Handled_Most_Number_of_Requests\\n    {\\n        public IList<int> BusiestServers(int k, int[] arrival, int[] load)\\n        {\\n            var servers = Enumerable.Repeat(1, k).ToArray();\\n\\n            var loadCount = new int[k];\\n            var max = 0;\\n\\n            for (int i = 0; i < arrival.Length; i++)\\n            {\\n                int serverIndexInitial = i % k;\\n                int serverIndex = i % k;\\n                var hasNext = true;\\n                while (hasNext)\\n                {\\n                    if (servers[serverIndex] <= arrival[i])\\n                    {\\n                        servers[serverIndex] = arrival[i] + load[i];\\n                        loadCount[serverIndex]++;\\n                        if (loadCount[serverIndex] > max)\\n                        {\\n                            max = loadCount[serverIndex];\\n                        }\\n                        break;\\n                    }\\n\\n                    serverIndex++;\\n                    if (serverIndex == servers.Length)\\n                    {\\n                        serverIndex = 0;\\n                    }\\n                    if (serverIndex == serverIndexInitial)\\n                    {\\n                        hasNext = false;\\n                    }\\n                }\\n            }\\n            List<int> result = GetResult(loadCount, max);\\n\\n            return result;\\n        }\\n\\n        private static List<int> GetResult(int[] loadCount, int max)\\n        {\\n            var result = new List<int>();\\n            for (int i = 0; i < loadCount.Length; i++)\\n            {\\n                if (loadCount[i] == max)\\n                {\\n                    result.Add(i);\\n                }\\n            }\\n\\n            return result;\\n        }\\n    }\\n```\\n\\n\\n**using sortedset\\n105 / 108 test cases passed.**\\n```\\nclass _1606_Find_Servers_That_Handled_Most_Number_of_Requests_2\\n    {\\n        public IList<int> BusiestServers(int k, int[] arrival, int[] load)\\n        {\\n            SortedSet<Server> busyServers = new SortedSet<Server>(new BusyServerComparer());\\n            SortedDictionary<int, Server> freeServers = new SortedDictionary<int, Server>();\\n            for (int i = 0; i < k; i++)\\n            {\\n                freeServers.Add(i, new Server { Index = i });\\n            }\\n\\n            var max = 0;\\n\\n            for (int i = 0; i < arrival.Length; i++)\\n            {\\n                while ((busyServers.Count > 0) && (busyServers.First().BusyUntil <= arrival[i]))\\n                {\\n                    var srv = busyServers.First();\\n                    freeServers.Add(srv.Index, srv);\\n                    busyServers.Remove(srv);\\n                }\\n\\n                int serverIndexInitial = i % k;\\n                int serverIndex = i % k;\\n                var hasNext = true;\\n                while (hasNext)\\n                {\\n                    if (freeServers.ContainsKey(serverIndex))\\n                    {\\n                        var srv = freeServers[serverIndex];\\n                        srv.BusyUntil = arrival[i] + load[i];\\n                        srv.Used++;\\n                        if (srv.Used > max)\\n                        {\\n                            max = srv.Used;\\n                        }\\n                        busyServers.Add(srv);\\n                        freeServers.Remove(srv.Index);\\n                        break;\\n                    }\\n\\n                    serverIndex++;\\n                    if (serverIndex == k)\\n                    {\\n                        serverIndex = 0;\\n                    }\\n                    if (serverIndex == serverIndexInitial)\\n                    {\\n                        hasNext = false;\\n                    }\\n                }\\n            }\\n\\n            List<int> result = new List<int>();\\n            foreach (var sr in busyServers)\\n            {\\n                if (sr.Used == max)\\n                    result.Add(sr.Index);\\n            }\\n\\n            foreach (var sr in freeServers)\\n            {\\n                if (sr.Value.Used == max)\\n                    result.Add(sr.Key);\\n            }\\n\\n            return result;\\n        }\\n    }\\n\\n    class Server\\n    {\\n        public int Index { get; set; }\\n        public int BusyUntil { get; set; }\\n        public int Used { get; set; }\\n    }\\n\\n    class BusyServerComparer : IComparer<Server>\\n    {\\n        public int Compare(Server a, Server b)\\n        { \\n            //first by BusyUntil\\n            int result = a.BusyUntil.CompareTo(b.BusyUntil);\\n\\n            //then index\\n            if (result == 0)\\n                result = a.Index.CompareTo(b.Index);\\n\\n\\n\\n            return result;\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nclass _1606_Find_Servers_That_Handled_Most_Number_of_Requests\\n    {\\n        public IList<int> BusiestServers(int k, int[] arrival, int[] load)\\n        {\\n            var servers = Enumerable.Repeat(1, k).ToArray();\\n\\n            var loadCount = new int[k];\\n            var max = 0;\\n\\n            for (int i = 0; i < arrival.Length; i++)\\n            {\\n                int serverIndexInitial = i % k;\\n                int serverIndex = i % k;\\n                var hasNext = true;\\n                while (hasNext)\\n                {\\n                    if (servers[serverIndex] <= arrival[i])\\n                    {\\n                        servers[serverIndex] = arrival[i] + load[i];\\n                        loadCount[serverIndex]++;\\n                        if (loadCount[serverIndex] > max)\\n                        {\\n                            max = loadCount[serverIndex];\\n                        }\\n                        break;\\n                    }\\n\\n                    serverIndex++;\\n                    if (serverIndex == servers.Length)\\n                    {\\n                        serverIndex = 0;\\n                    }\\n                    if (serverIndex == serverIndexInitial)\\n                    {\\n                        hasNext = false;\\n                    }\\n                }\\n            }\\n            List<int> result = GetResult(loadCount, max);\\n\\n            return result;\\n        }\\n\\n        private static List<int> GetResult(int[] loadCount, int max)\\n        {\\n            var result = new List<int>();\\n            for (int i = 0; i < loadCount.Length; i++)\\n            {\\n                if (loadCount[i] == max)\\n                {\\n                    result.Add(i);\\n                }\\n            }\\n\\n            return result;\\n        }\\n    }\\n```\n```\\nclass _1606_Find_Servers_That_Handled_Most_Number_of_Requests_2\\n    {\\n        public IList<int> BusiestServers(int k, int[] arrival, int[] load)\\n        {\\n            SortedSet<Server> busyServers = new SortedSet<Server>(new BusyServerComparer());\\n            SortedDictionary<int, Server> freeServers = new SortedDictionary<int, Server>();\\n            for (int i = 0; i < k; i++)\\n            {\\n                freeServers.Add(i, new Server { Index = i });\\n            }\\n\\n            var max = 0;\\n\\n            for (int i = 0; i < arrival.Length; i++)\\n            {\\n                while ((busyServers.Count > 0) && (busyServers.First().BusyUntil <= arrival[i]))\\n                {\\n                    var srv = busyServers.First();\\n                    freeServers.Add(srv.Index, srv);\\n                    busyServers.Remove(srv);\\n                }\\n\\n                int serverIndexInitial = i % k;\\n                int serverIndex = i % k;\\n                var hasNext = true;\\n                while (hasNext)\\n                {\\n                    if (freeServers.ContainsKey(serverIndex))\\n                    {\\n                        var srv = freeServers[serverIndex];\\n                        srv.BusyUntil = arrival[i] + load[i];\\n                        srv.Used++;\\n                        if (srv.Used > max)\\n                        {\\n                            max = srv.Used;\\n                        }\\n                        busyServers.Add(srv);\\n                        freeServers.Remove(srv.Index);\\n                        break;\\n                    }\\n\\n                    serverIndex++;\\n                    if (serverIndex == k)\\n                    {\\n                        serverIndex = 0;\\n                    }\\n                    if (serverIndex == serverIndexInitial)\\n                    {\\n                        hasNext = false;\\n                    }\\n                }\\n            }\\n\\n            List<int> result = new List<int>();\\n            foreach (var sr in busyServers)\\n            {\\n                if (sr.Used == max)\\n                    result.Add(sr.Index);\\n            }\\n\\n            foreach (var sr in freeServers)\\n            {\\n                if (sr.Value.Used == max)\\n                    result.Add(sr.Key);\\n            }\\n\\n            return result;\\n        }\\n    }\\n\\n    class Server\\n    {\\n        public int Index { get; set; }\\n        public int BusyUntil { get; set; }\\n        public int Used { get; set; }\\n    }\\n\\n    class BusyServerComparer : IComparer<Server>\\n    {\\n        public int Compare(Server a, Server b)\\n        { \\n            //first by BusyUntil\\n            int result = a.BusyUntil.CompareTo(b.BusyUntil);\\n\\n            //then index\\n            if (result == 0)\\n                result = a.Index.CompareTo(b.Index);\\n\\n\\n\\n            return result;\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 882858,
                "title": "java-solution-treeset-less-code",
                "content": "```\\nclass Solution {\\n    \\n    class Server {\\n        int idx;\\n        int load=0;\\n        int cnt=0;\\n        Server(int idx, int load){\\n            this.idx = idx;\\n            this.load = load;\\n        }\\n    }\\n    \\n    public List<Integer> busiestServers(int k, int[] arrival, int[] load) {\\n        \\n        TreeSet<Server> set1 = new TreeSet<>((a, b)->{return a.idx-b.idx;});  // sort by index\\n        TreeSet<Server> set2 = new TreeSet<>((a, b)->{return a.load == b.load?a.idx-b.idx:a.load-b.load;}); // sort by load\\n        \\n        for(int i=0; i<k; i++)\\n            set1.add(new Server(i, 0));\\n\\t\\t\\t\\n        int max = 0;\\n     \\n        for(int i=0; i<arrival.length; i++){\\n\\t\\t    // for each loop, \\n\\t\\t\\t// get all available servers from set2 and add to set1, \\n\\t\\t\\t// get the first available server from set1, update the load and cnt\\n\\t\\t\\t// put the server to set2\\n            \\n            Set<Server> sub = set2.headSet(new Server(999999, arrival[i]));\\n            Iterator<Server> it = sub.iterator();\\n            \\n            while(it.hasNext()){\\n                Server next = it.next();\\n                it.remove();\\n                set1.add(next);\\n            }\\n\\n            if(set1.isEmpty()) continue; // no available server\\n            Server ser = set1.ceiling(new Server(i%k, 0));\\n            if(ser==null) ser=set1.first();\\n            ser.load=arrival[i]+load[i];\\n            ser.cnt++;\\n            set1.remove(ser);\\n            set2.add(ser);\\n            \\n            max = Math.max(max, ser.cnt);\\n        }\\n        \\n        List<Integer> list = new ArrayList<>();\\n        for(Server s:set1) if(s.cnt==max) list.add(s.idx);\\n        for(Server s:set2) if(s.cnt==max) list.add(s.idx);\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    class Server {\\n        int idx;\\n        int load=0;\\n        int cnt=0;\\n        Server(int idx, int load){\\n            this.idx = idx;\\n            this.load = load;\\n        }\\n    }\\n    \\n    public List<Integer> busiestServers(int k, int[] arrival, int[] load) {\\n        \\n        TreeSet<Server> set1 = new TreeSet<>((a, b)->{return a.idx-b.idx;});  // sort by index\\n        TreeSet<Server> set2 = new TreeSet<>((a, b)->{return a.load == b.load?a.idx-b.idx:a.load-b.load;}); // sort by load\\n        \\n        for(int i=0; i<k; i++)\\n            set1.add(new Server(i, 0));\\n\\t\\t\\t\\n        int max = 0;\\n     \\n        for(int i=0; i<arrival.length; i++){\\n\\t\\t    // for each loop, \\n\\t\\t\\t// get all available servers from set2 and add to set1, \\n\\t\\t\\t// get the first available server from set1, update the load and cnt\\n\\t\\t\\t// put the server to set2\\n            \\n            Set<Server> sub = set2.headSet(new Server(999999, arrival[i]));\\n            Iterator<Server> it = sub.iterator();\\n            \\n            while(it.hasNext()){\\n                Server next = it.next();\\n                it.remove();\\n                set1.add(next);\\n            }\\n\\n            if(set1.isEmpty()) continue; // no available server\\n            Server ser = set1.ceiling(new Server(i%k, 0));\\n            if(ser==null) ser=set1.first();\\n            ser.load=arrival[i]+load[i];\\n            ser.cnt++;\\n            set1.remove(ser);\\n            set2.add(ser);\\n            \\n            max = Math.max(max, ser.cnt);\\n        }\\n        \\n        List<Integer> list = new ArrayList<>();\\n        for(Server s:set1) if(s.cnt==max) list.add(s.idx);\\n        for(Server s:set2) if(s.cnt==max) list.add(s.idx);\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 880610,
                "title": "priority-queue-and-set-hashmap-in-c-o-nlog-k",
                "content": "class Solution {\\npublic:\\n    vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> min_heap;\\n        set<int> availables;\\n        for (int i = 0; i < k; ++i) {\\n            availables.insert(i);\\n        }\\n        vector<int> count(k);\\n        for (int i = 0; i < size(arrival); ++i) {\\n            while (!empty(min_heap) && min_heap.top().first <= arrival[i]) {\\n                pair<int,int>v = min_heap.top();\\n                min_heap.pop();\\n                availables.insert(v.second);\\n            }\\n            if (empty(availables)) {\\n                continue;\\n            }\\n            auto it = availables.lower_bound(i % k);\\n            if (it == end(availables)) {\\n                it = begin(availables);\\n            }\\n            ++count[*it];\\n            min_heap.emplace(arrival[i] + load[i], *it);\\n            availables.erase(it);\\n        }\\n        int max_count = *max_element(cbegin(count), cend(count));\\n        vector<int> result;\\n        for (int i = 0; i < k; ++i) {\\n            if (count[i] == max_count) {\\n                result.emplace_back(i);\\n            }\\n        }\\n        return result;\\n    }\\n};\\n\\nTime Complexity - O(nlogK)\\nSpace Complexity - O(K)\\nHope this will be helpful",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> min_heap;\\n        set<int> availables;\\n        for (int i = 0; i < k; ++i) {\\n            availables.insert(i);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 880103,
                "title": "python-heap-sortedlist",
                "content": "Heap tracks working servers and SortedList stores idle servers.\\n```python\\nfrom sortedcontainers import SortedList\\nclass Solution:\\n    def busiestServers(self, k: int, arrival: List[int], load: List[int]) -> List[int]:\\n        num_tasks = [0] * k\\n        heap = []\\n        sl = SortedList([i for i in range(k)] + [i+k for i in range(k)])\\n        for i, (s, t) in enumerate(zip(arrival, load)):\\n            i %= k\\n            while heap and heap[0][0] <= s:\\n                _, j = heapq.heappop(heap)\\n                sl.add(j)\\n                sl.add(j+k)\\n            if len(sl):\\n                j = sl[sl.bisect_left(i)] % k\\n                sl.remove(j)\\n                sl.remove(j+k)\\n                num_tasks[j] += 1\\n                heapq.heappush(heap, (s+t, j))\\n        m = max(num_tasks)\\n        return [i for i, n in enumerate(num_tasks) if n == m]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nfrom sortedcontainers import SortedList\\nclass Solution:\\n    def busiestServers(self, k: int, arrival: List[int], load: List[int]) -> List[int]:\\n        num_tasks = [0] * k\\n        heap = []\\n        sl = SortedList([i for i in range(k)] + [i+k for i in range(k)])\\n        for i, (s, t) in enumerate(zip(arrival, load)):\\n            i %= k\\n            while heap and heap[0][0] <= s:\\n                _, j = heapq.heappop(heap)\\n                sl.add(j)\\n                sl.add(j+k)\\n            if len(sl):\\n                j = sl[sl.bisect_left(i)] % k\\n                sl.remove(j)\\n                sl.remove(j+k)\\n                num_tasks[j] += 1\\n                heapq.heappush(heap, (s+t, j))\\n        m = max(num_tasks)\\n        return [i for i, n in enumerate(num_tasks) if n == m]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 880095,
                "title": "java-o-nlogn-using-only-treeset",
                "content": "Idea is simple, we maintain a sorted list of free servers (initially all servers are free) and process request endpoints (start & end) in order of increasing time. If its end of req, we remove from free servers. We first look for request index (ri) % k. If this server is free, then we use it, otherwise we look for next free server with index > ri, and we remove from free servers.\\nWe maintain count in an array for each server and return servers with max no of req at the end.\\n\\n\\n```\\nimport java.util.ArrayList;\\nimport java.util.HashMap;\\nimport java.util.List;\\nimport java.util.Map;\\nimport java.util.TreeSet;\\n\\nclass Solution {\\n\\n    static class Point {\\n        private final int x, index;\\n        private final boolean start;\\n\\n        Point(int x, int index, boolean start) {\\n            this.x = x;\\n            this.index = index;\\n            this.start = start;\\n        }\\n    }\\n\\n    public List<Integer> busiestServers(int k, int[] arrival, int[] load) {\\n\\n        // INIT\\n        TreeSet<Integer> free = new TreeSet<>();\\n        Map<Integer, Integer> reqToServer = new HashMap<>();\\n        Integer[] servers = new Integer[k];\\n        for (int i = 0; i < k; i++) {\\n            free.add(i);\\n            servers[i] = i;\\n        }\\n\\n        // BUILD POINTS TO PROCESS\\n        List<Point> points = buildPointsToProcess(arrival, load);\\n\\n        // PROCESS POINTS\\n        int[] count = new int[k];\\n        for (Point point : points) {\\n            processPoint(k, free, reqToServer, servers, count, point);\\n        }\\n\\n        // CALC ANS\\n        return findServersWithMaxReq(k, count);\\n    }\\n\\n    private void processPoint(int k, TreeSet<Integer> free, Map<Integer, Integer> reqToServer, Integer[] servers,\\n            int[] count, Point point) {\\n\\n        if (!point.start) {\\n\\n            // PROCESS END OF REQ\\n            if (reqToServer.containsKey(point.index)) {\\n                Integer s = reqToServer.get(point.index);\\n                reqToServer.remove(point.index);\\n                free.add(s);\\n            }\\n            return;\\n        }\\n\\n        if (free.isEmpty()) {\\n\\n            // DROP REQ\\n            return;\\n        }\\n\\n        // FIND A FREE SERVER TO PROCESS REQ\\n        int ri = point.index % k;\\n        Integer server;\\n        if (free.contains(servers[ri])) {\\n\\n            // CURR SERVER CAN HANDLE REQ\\n            server = servers[ri];\\n        } else {\\n\\n            // LOOK FOR FREE SERVER WITH HIGHER INDEX THAN s\\n            server = free.higher(servers[ri]);\\n            if (server == null) {\\n\\n                // LOOK FOR FREE SERVER WITH LOWEST INDEX\\n                server = free.higher(-1);\\n            }\\n        }\\n\\n        // SERVE REQUEST\\n        free.remove(server);\\n        count[server]++;\\n        reqToServer.put(point.index, server);\\n    }\\n\\n    private List<Point> buildPointsToProcess(int[] arrival, int[] load) {\\n        List<Point> points = new ArrayList<>();\\n        for (int i = 0; i < arrival.length; i++) {\\n            points.add(new Point(arrival[i], i, true));\\n            points.add(new Point(arrival[i] + load[i], i, false));\\n        }\\n        points.sort((p1, p2) -> {\\n            int compare = Integer.compare(p1.x, p2.x);\\n            if (compare != 0) {\\n                return compare;\\n            }\\n            if (!p1.start && p2.start) {\\n                return -1;\\n            }\\n            if (p1.start && !p2.start) {\\n                return 1;\\n            }\\n            return Integer.compare(p1.index, p2.index);\\n        });\\n        return points;\\n    }\\n\\n    private List<Integer> findServersWithMaxReq(int k, int[] count) {\\n\\n        // FIND MAX\\n        int maxc = Integer.MIN_VALUE;\\n        for (int i = 0; i < k; i++) {\\n            if (count[i] > maxc) {\\n                maxc = count[i];\\n            }\\n        }\\n\\n        // FIND ALL VALUES = MAX\\n        List<Integer> ans = new ArrayList<>();\\n        for (int i = 0; i < k; i++) {\\n            if (count[i] == maxc) {\\n                ans.add(i);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimport java.util.ArrayList;\\nimport java.util.HashMap;\\nimport java.util.List;\\nimport java.util.Map;\\nimport java.util.TreeSet;\\n\\nclass Solution {\\n\\n    static class Point {\\n        private final int x, index;\\n        private final boolean start;\\n\\n        Point(int x, int index, boolean start) {\\n            this.x = x;\\n            this.index = index;\\n            this.start = start;\\n        }\\n    }\\n\\n    public List<Integer> busiestServers(int k, int[] arrival, int[] load) {\\n\\n        // INIT\\n        TreeSet<Integer> free = new TreeSet<>();\\n        Map<Integer, Integer> reqToServer = new HashMap<>();\\n        Integer[] servers = new Integer[k];\\n        for (int i = 0; i < k; i++) {\\n            free.add(i);\\n            servers[i] = i;\\n        }\\n\\n        // BUILD POINTS TO PROCESS\\n        List<Point> points = buildPointsToProcess(arrival, load);\\n\\n        // PROCESS POINTS\\n        int[] count = new int[k];\\n        for (Point point : points) {\\n            processPoint(k, free, reqToServer, servers, count, point);\\n        }\\n\\n        // CALC ANS\\n        return findServersWithMaxReq(k, count);\\n    }\\n\\n    private void processPoint(int k, TreeSet<Integer> free, Map<Integer, Integer> reqToServer, Integer[] servers,\\n            int[] count, Point point) {\\n\\n        if (!point.start) {\\n\\n            // PROCESS END OF REQ\\n            if (reqToServer.containsKey(point.index)) {\\n                Integer s = reqToServer.get(point.index);\\n                reqToServer.remove(point.index);\\n                free.add(s);\\n            }\\n            return;\\n        }\\n\\n        if (free.isEmpty()) {\\n\\n            // DROP REQ\\n            return;\\n        }\\n\\n        // FIND A FREE SERVER TO PROCESS REQ\\n        int ri = point.index % k;\\n        Integer server;\\n        if (free.contains(servers[ri])) {\\n\\n            // CURR SERVER CAN HANDLE REQ\\n            server = servers[ri];\\n        } else {\\n\\n            // LOOK FOR FREE SERVER WITH HIGHER INDEX THAN s\\n            server = free.higher(servers[ri]);\\n            if (server == null) {\\n\\n                // LOOK FOR FREE SERVER WITH LOWEST INDEX\\n                server = free.higher(-1);\\n            }\\n        }\\n\\n        // SERVE REQUEST\\n        free.remove(server);\\n        count[server]++;\\n        reqToServer.put(point.index, server);\\n    }\\n\\n    private List<Point> buildPointsToProcess(int[] arrival, int[] load) {\\n        List<Point> points = new ArrayList<>();\\n        for (int i = 0; i < arrival.length; i++) {\\n            points.add(new Point(arrival[i], i, true));\\n            points.add(new Point(arrival[i] + load[i], i, false));\\n        }\\n        points.sort((p1, p2) -> {\\n            int compare = Integer.compare(p1.x, p2.x);\\n            if (compare != 0) {\\n                return compare;\\n            }\\n            if (!p1.start && p2.start) {\\n                return -1;\\n            }\\n            if (p1.start && !p2.start) {\\n                return 1;\\n            }\\n            return Integer.compare(p1.index, p2.index);\\n        });\\n        return points;\\n    }\\n\\n    private List<Integer> findServersWithMaxReq(int k, int[] count) {\\n\\n        // FIND MAX\\n        int maxc = Integer.MIN_VALUE;\\n        for (int i = 0; i < k; i++) {\\n            if (count[i] > maxc) {\\n                maxc = count[i];\\n            }\\n        }\\n\\n        // FIND ALL VALUES = MAX\\n        List<Integer> ans = new ArrayList<>();\\n        for (int i = 0; i < k; i++) {\\n            if (count[i] == maxc) {\\n                ans.add(i);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 878620,
                "title": "c-simple",
                "content": "```\\nstruct Node{\\n        int sid;\\n        int endTime;\\n    };\\n    \\n    struct CompareTime{\\n        bool operator()(const Node & lhs, const Node & rhs){\\n           return lhs.endTime > rhs.endTime; \\n        }\\n    };\\n    \\n    vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n        if(arrival.size() <= k){\\n            vector<int> ans;\\n            for(int i=0;i<min((int)arrival.size(), k);i++)\\n                ans.push_back(i);\\n            return ans;\\n        }\\n        vector<bool> available(k, true);\\n        priority_queue<Node, vector<Node>, CompareTime> pq;\\n        unordered_map<int, int> count;\\n        set<int> availableServers;\\n        \\n        for(int i=0;i<k;i++)\\n            availableServers.insert(i);\\n        \\n        int maxCount = -1;\\n        \\n        for(int i=0;i<arrival.size();i++){\\n            while(!pq.empty() && pq.top().endTime <= arrival[i]){\\n                availableServers.insert(pq.top().sid);\\n                available[pq.top().sid] = true;\\n                pq.pop();\\n            }\\n            if(available[i%k]){\\n                count[i%k]++;\\n                maxCount = max(maxCount, count[i%k]);\\n                available[i%k] = false;\\n                availableServers.erase(i%k);\\n                Node n;\\n                n.sid = i%k;\\n                n.endTime = arrival[i] + load[i];\\n                pq.push(n);\\n            }\\n            else if(!available[i%k] && !availableServers.empty()){\\n                int id = -1;\\n                auto it = availableServers.lower_bound(i%k);\\n                auto it2 = availableServers.lower_bound(INT_MAX);\\n                if(i%k < *it)\\n                    id = *it;\\n                if( availableServers.size() > 1 && *it == *it2 && ( i%k > *it)){\\n                    auto it3 = availableServers.begin();\\n                    id = *it3;\\n                }\\n                else if(availableServers.size() == 1 ){\\n                    auto it3 = availableServers.begin();\\n                    id = *it3;\\n                }\\n                if(id!= -1 && available[id]){\\n                    available[id] = false;\\n                    availableServers.erase(id);\\n                    count[id]++;\\n                    maxCount = max(maxCount, count[id]);\\n                    Node n;\\n                    n.sid = id;\\n                    n.endTime = arrival[i]+ load[i];\\n                    pq.push(n);\\n                }\\n            }\\n        }\\n        vector<int> ans;\\n        for(auto it = count.begin(); it!= count.end(); it++)\\n            if(it->second == maxCount)\\n                ans.push_back(it->first);\\n        return ans;\\n        \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nstruct Node{\\n        int sid;\\n        int endTime;\\n    };\\n    \\n    struct CompareTime{\\n        bool operator()(const Node & lhs, const Node & rhs){\\n           return lhs.endTime > rhs.endTime; \\n        }\\n    };\\n    \\n    vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n        if(arrival.size() <= k){\\n            vector<int> ans;\\n            for(int i=0;i<min((int)arrival.size(), k);i++)\\n                ans.push_back(i);\\n            return ans;\\n        }\\n        vector<bool> available(k, true);\\n        priority_queue<Node, vector<Node>, CompareTime> pq;\\n        unordered_map<int, int> count;\\n        set<int> availableServers;\\n        \\n        for(int i=0;i<k;i++)\\n            availableServers.insert(i);\\n        \\n        int maxCount = -1;\\n        \\n        for(int i=0;i<arrival.size();i++){\\n            while(!pq.empty() && pq.top().endTime <= arrival[i]){\\n                availableServers.insert(pq.top().sid);\\n                available[pq.top().sid] = true;\\n                pq.pop();\\n            }\\n            if(available[i%k]){\\n                count[i%k]++;\\n                maxCount = max(maxCount, count[i%k]);\\n                available[i%k] = false;\\n                availableServers.erase(i%k);\\n                Node n;\\n                n.sid = i%k;\\n                n.endTime = arrival[i] + load[i];\\n                pq.push(n);\\n            }\\n            else if(!available[i%k] && !availableServers.empty()){\\n                int id = -1;\\n                auto it = availableServers.lower_bound(i%k);\\n                auto it2 = availableServers.lower_bound(INT_MAX);\\n                if(i%k < *it)\\n                    id = *it;\\n                if( availableServers.size() > 1 && *it == *it2 && ( i%k > *it)){\\n                    auto it3 = availableServers.begin();\\n                    id = *it3;\\n                }\\n                else if(availableServers.size() == 1 ){\\n                    auto it3 = availableServers.begin();\\n                    id = *it3;\\n                }\\n                if(id!= -1 && available[id]){\\n                    available[id] = false;\\n                    availableServers.erase(id);\\n                    count[id]++;\\n                    maxCount = max(maxCount, count[id]);\\n                    Node n;\\n                    n.sid = id;\\n                    n.endTime = arrival[i]+ load[i];\\n                    pq.push(n);\\n                }\\n            }\\n        }\\n        vector<int> ans;\\n        for(auto it = count.begin(); it!= count.end(); it++)\\n            if(it->second == maxCount)\\n                ans.push_back(it->first);\\n        return ans;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 878508,
                "title": "java-two-treemap",
                "content": "```\\nclass Solution {\\n    public List<Integer> busiestServers(int k, int[] A, int[] load) {\\n        List<Integer>res=new ArrayList<>();    \\n        \\n        int servers[]=new int[k];\\n        TreeMap<Integer,List<Integer>>treemap=new TreeMap<>();\\n        TreeMap<Integer,Integer>treemap1=new TreeMap<>();\\n        \\n        for(int i=0;i<k;i++){\\n            treemap1.put(i,0);\\n        }\\n        \\n        \\n        for(int i=0;i<A.length;i++){\\n            int mod=i%k;\\n            int cur=A[i];\\n            \\n            Integer floor=treemap.floorKey(cur);\\n           \\n            if(floor!=null){\\n                List<Integer>clean=new ArrayList<>();\\n                \\n                for(Integer end:treemap.keySet()){\\n                    if(end>floor)break;\\n                    clean.add(end);\\n                    List<Integer>l=treemap.get(end);\\n                    for(int index:l){\\n                         treemap1.put(index,end);\\n                    }\\n                }\\n                \\n                for(Integer key:clean){\\n                    treemap.remove(key);\\n                }\\n            }\\n            \\n            Integer first=treemap1.ceilingKey(mod);\\n            if(first!=null){\\n                int index=first;\\n                servers[index]++;\\n                if(!treemap.containsKey(load[i]+A[i]))treemap.put(load[i]+A[i],new ArrayList<>());\\n                treemap.get(load[i]+A[i]).add(index);\\n                treemap1.remove(first);\\n                continue;\\n            }\\n            \\n            Integer second=treemap1.ceilingKey(0);\\n            if(second!=null){\\n                int index=second;\\n                servers[index]++;\\n                if(!treemap.containsKey(load[i]+A[i]))treemap.put(load[i]+A[i],new ArrayList<>());\\n                treemap.get(load[i]+A[i]).add(index);\\n                treemap1.remove(second);\\n  \\n            }\\n        }\\n        \\n        \\n        int max=0;\\n        for(int i:servers){\\n            max=Math.max(i,max);\\n        }\\n        for(int i=0;i<servers.length;i++){\\n            if(servers[i]==max)res.add(i);\\n        }\\n        return res;\\n    }\\n    \\n}\\n\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> busiestServers(int k, int[] A, int[] load) {\\n        List<Integer>res=new ArrayList<>();    \\n        \\n        int servers[]=new int[k];\\n        TreeMap<Integer,List<Integer>>treemap=new TreeMap<>();\\n        TreeMap<Integer,Integer>treemap1=new TreeMap<>();\\n        \\n        for(int i=0;i<k;i++){\\n            treemap1.put(i,0);\\n        }\\n        \\n        \\n        for(int i=0;i<A.length;i++){\\n            int mod=i%k;\\n            int cur=A[i];\\n            \\n            Integer floor=treemap.floorKey(cur);\\n           \\n            if(floor!=null){\\n                List<Integer>clean=new ArrayList<>();\\n                \\n                for(Integer end:treemap.keySet()){\\n                    if(end>floor)break;\\n                    clean.add(end);\\n                    List<Integer>l=treemap.get(end);\\n                    for(int index:l){\\n                         treemap1.put(index,end);\\n                    }\\n                }\\n                \\n                for(Integer key:clean){\\n                    treemap.remove(key);\\n                }\\n            }\\n            \\n            Integer first=treemap1.ceilingKey(mod);\\n            if(first!=null){\\n                int index=first;\\n                servers[index]++;\\n                if(!treemap.containsKey(load[i]+A[i]))treemap.put(load[i]+A[i],new ArrayList<>());\\n                treemap.get(load[i]+A[i]).add(index);\\n                treemap1.remove(first);\\n                continue;\\n            }\\n            \\n            Integer second=treemap1.ceilingKey(0);\\n            if(second!=null){\\n                int index=second;\\n                servers[index]++;\\n                if(!treemap.containsKey(load[i]+A[i]))treemap.put(load[i]+A[i],new ArrayList<>());\\n                treemap.get(load[i]+A[i]).add(index);\\n                treemap1.remove(second);\\n  \\n            }\\n        }\\n        \\n        \\n        int max=0;\\n        for(int i:servers){\\n            max=Math.max(i,max);\\n        }\\n        for(int i=0;i<servers.length;i++){\\n            if(servers[i]==max)res.add(i);\\n        }\\n        return res;\\n    }\\n    \\n}\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 878180,
                "title": "segment-tree-c-easy-explanation",
                "content": "```\\n#include <bits/stdc++.h>\\n#include<algorithm>\\n#include<string>\\nusing namespace std;\\n#define ll int\\n// #define int long long\\n#define ld long double\\n#define ff first\\n#define ss string \\n#define se second\\n#define endl \"\\\\n\"\\n#define ub upper_bound\\n#define lb lower_bound\\n#define clr(a,x) memset(a,x,sizeof(a))\\n#define alt(v) v.begin(),v.end()\\n#define ralt(v) v.rbegin(),v.rend()\\n#define pb emplace_back\\n#define mp make_pair\\nconst int N = 2e5+5;\\n\\n\\nll minseg[4*N];\\n\\n\\nvoid update(int nd,int ss,int se,int pos,ll val)\\n{\\n    if(ss > pos or se < pos)\\n        return;\\n    if(ss == se and se == pos)\\n    {\\n        minseg[nd] = val;\\n        return;\\n    }\\n    int mid = (ss+se)/2;\\n    update(2*nd,ss,mid,pos,val);\\n    update(2*nd+1,mid+1,se,pos,val);\\n    minseg[nd] = min(minseg[2*nd],minseg[2*nd+1]);\\n}\\n\\n// we find the smallest index j such that arr[j] <= k and j>=l.\\nint query(int nd,int ss,int se,ll k,int l)\\n{\\n    // the whole segment([ss,se]) not satisfy the condition j >= l and arr[j] <= k\\n    if(minseg[nd] > k or se < l)\\n        return -2;\\n    \\n    if(ss == se){\\n        if(minseg[nd] <= k)\\n            return se;\\n        // no element satisfy the given condition.\\n        return -1;\\n    }\\n    \\n    int mid = (ss+se)/2;\\n    int x = -2;\\n    // As we need smallest index so we go first left subtree then right if any element present\\n    // in left subtree that satisfy the given condition then we simply return that index otherwise\\n    // we go right subtree.\\n    x = query(2*nd,ss,mid,k,l);\\n    if(x != -2)\\n        return x;\\n    return query(2*nd+1,mid+1,se,k,l);\\n}\\n\\nclass Solution {\\npublic:\\n    vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) \\n    {   \\n        // Everytime we start itteration from i%k(curserver) th server as we indicate server from 1 to k(not 0 to k-1) \\n        // so we increase the curserver value  by 1 to get actual server.   \\n        \\n        // If the curserver is 4 then we start to find 1st free server 4 - > 5 -> 6 - > 7 -> 8....-> k-> 1-> 2-> 3 in this way.\\n        // if we not get any free server then simply skip that request.\\n        \\n        // For that we build a circular array of 2*k length and every position indicate (position % k) th server.\\n        // i.e position array actually look like as = [1,2,3,4,5...k,1,2,3....k]\\n        \\n        // In every position we kept the time position%k th server take to finish last request.As initially every server free so \\n        // we initialize the array by 0.\\n        \\n        // i.e array look like arr = [0,0,0,0,0..0] and indexarray = [1,2,3,..k,k+1,k+2,k+3..k+k]\\n        \\n        //  Everytime we try to find index j that follow the given condition : ->\\n        //  i.> j >= curserver(i.e. i%k + 1)\\n        //  ii.> arr[j] <= arrival[i] (i.e. j th server take atmost arrival[i] time to finish last request).\\n        \\n        // Afterthat curserver will be j%k (if the index j = k+5 we indicate that as 5 th server).\\n        \\n        // we increae the value of cnt_req[curserver] by 1 as 1 more request added to that server.\\n        \\n        // Afterthat we update the value of arr[curserver] and arr[curserver + k] by arrival[i] + load[i].\\n        // i.e. curserver % k th server and (curserver + k)%k server take (arrival[i] + load[i]) time to finish that request.\\n        \\n        // As initially all element in the array is 0 so we initialize every node in segment tree by 0.\\n        for(int i = 1; i <= 8*k; ++i)\\n            minseg[i] = 0;\\n        \\n        vector<int>cnt_req(k+1,0); // initial with 0\\n        // cnt_req[i] indicate how many request finish by ith server.\\n        \\n        for(int i = 0; i < arrival.size();++i)\\n        {\\n            int curserver = i%k + 1;\\n            // query return the free index that is the value of arr[index] <= arrival[i]\\n            // and index >= curserver, if no server then it\\'s simply return -1. \\n            curserver = query(1,1,2*k,arrival[i],curserver);\\n            \\n            // no free server exist.\\n            if(curserver < 0)\\n                continue;\\n            \\n            curserver %= k;\\n            if(curserver == 0)\\n                curserver = k;\\n            \\n            cnt_req[curserver]++;\\n            update(1,1,2*k,curserver,arrival[i] + load[i]);\\n            update(1,1,2*k,curserver + k,arrival[i] + load[i]);\\n        }\\n        \\n        // iterate on cnt_req and find all busiest server.\\n        int mxval = *max_element(alt(cnt_req));\\n        vector<int>ans;\\n        \\n        for(int i = 1; i <= k; ++i)\\n            if(cnt_req[i] == mxval)\\n                ans.pb(i-1); // as question say server indicate 0 to k-1.\\n    \\n        return ans;\\n        \\n    }\\n};\\n\\n```\\nTime - O(klogk)\\nIf any doubt regrading implementation and logic please comment below I am happy to help you.\\n",
                "solutionTags": [],
                "code": "```\\n#include <bits/stdc++.h>\\n#include<algorithm>\\n#include<string>\\nusing namespace std;\\n#define ll int\\n// #define int long long\\n#define ld long double\\n#define ff first\\n#define ss string \\n#define se second\\n#define endl \"\\\\n\"\\n#define ub upper_bound\\n#define lb lower_bound\\n#define clr(a,x) memset(a,x,sizeof(a))\\n#define alt(v) v.begin(),v.end()\\n#define ralt(v) v.rbegin(),v.rend()\\n#define pb emplace_back\\n#define mp make_pair\\nconst int N = 2e5+5;\\n\\n\\nll minseg[4*N];\\n\\n\\nvoid update(int nd,int ss,int se,int pos,ll val)\\n{\\n    if(ss > pos or se < pos)\\n        return;\\n    if(ss == se and se == pos)\\n    {\\n        minseg[nd] = val;\\n        return;\\n    }\\n    int mid = (ss+se)/2;\\n    update(2*nd,ss,mid,pos,val);\\n    update(2*nd+1,mid+1,se,pos,val);\\n    minseg[nd] = min(minseg[2*nd],minseg[2*nd+1]);\\n}\\n\\n// we find the smallest index j such that arr[j] <= k and j>=l.\\nint query(int nd,int ss,int se,ll k,int l)\\n{\\n    // the whole segment([ss,se]) not satisfy the condition j >= l and arr[j] <= k\\n    if(minseg[nd] > k or se < l)\\n        return -2;\\n    \\n    if(ss == se){\\n        if(minseg[nd] <= k)\\n            return se;\\n        // no element satisfy the given condition.\\n        return -1;\\n    }\\n    \\n    int mid = (ss+se)/2;\\n    int x = -2;\\n    // As we need smallest index so we go first left subtree then right if any element present\\n    // in left subtree that satisfy the given condition then we simply return that index otherwise\\n    // we go right subtree.\\n    x = query(2*nd,ss,mid,k,l);\\n    if(x != -2)\\n        return x;\\n    return query(2*nd+1,mid+1,se,k,l);\\n}\\n\\nclass Solution {\\npublic:\\n    vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) \\n    {   \\n        // Everytime we start itteration from i%k(curserver) th server as we indicate server from 1 to k(not 0 to k-1) \\n        // so we increase the curserver value  by 1 to get actual server.   \\n        \\n        // If the curserver is 4 then we start to find 1st free server 4 - > 5 -> 6 - > 7 -> 8....-> k-> 1-> 2-> 3 in this way.\\n        // if we not get any free server then simply skip that request.\\n        \\n        // For that we build a circular array of 2*k length and every position indicate (position % k) th server.\\n        // i.e position array actually look like as = [1,2,3,4,5...k,1,2,3....k]\\n        \\n        // In every position we kept the time position%k th server take to finish last request.As initially every server free so \\n        // we initialize the array by 0.\\n        \\n        // i.e array look like arr = [0,0,0,0,0..0] and indexarray = [1,2,3,..k,k+1,k+2,k+3..k+k]\\n        \\n        //  Everytime we try to find index j that follow the given condition : ->\\n        //  i.> j >= curserver(i.e. i%k + 1)\\n        //  ii.> arr[j] <= arrival[i] (i.e. j th server take atmost arrival[i] time to finish last request).\\n        \\n        // Afterthat curserver will be j%k (if the index j = k+5 we indicate that as 5 th server).\\n        \\n        // we increae the value of cnt_req[curserver] by 1 as 1 more request added to that server.\\n        \\n        // Afterthat we update the value of arr[curserver] and arr[curserver + k] by arrival[i] + load[i].\\n        // i.e. curserver % k th server and (curserver + k)%k server take (arrival[i] + load[i]) time to finish that request.\\n        \\n        // As initially all element in the array is 0 so we initialize every node in segment tree by 0.\\n        for(int i = 1; i <= 8*k; ++i)\\n            minseg[i] = 0;\\n        \\n        vector<int>cnt_req(k+1,0); // initial with 0\\n        // cnt_req[i] indicate how many request finish by ith server.\\n        \\n        for(int i = 0; i < arrival.size();++i)\\n        {\\n            int curserver = i%k + 1;\\n            // query return the free index that is the value of arr[index] <= arrival[i]\\n            // and index >= curserver, if no server then it\\'s simply return -1. \\n            curserver = query(1,1,2*k,arrival[i],curserver);\\n            \\n            // no free server exist.\\n            if(curserver < 0)\\n                continue;\\n            \\n            curserver %= k;\\n            if(curserver == 0)\\n                curserver = k;\\n            \\n            cnt_req[curserver]++;\\n            update(1,1,2*k,curserver,arrival[i] + load[i]);\\n            update(1,1,2*k,curserver + k,arrival[i] + load[i]);\\n        }\\n        \\n        // iterate on cnt_req and find all busiest server.\\n        int mxval = *max_element(alt(cnt_req));\\n        vector<int>ans;\\n        \\n        for(int i = 1; i <= k; ++i)\\n            if(cnt_req[i] == mxval)\\n                ans.pb(i-1); // as question say server indicate 0 to k-1.\\n    \\n        return ans;\\n        \\n    }\\n};\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 878101,
                "title": "use-set-and-priority-queue-to-record-the-id-of-server-idle-and-in-working",
                "content": "Use `\\tset<int> idle` to record the idle server id, and find the next usable one in `log(k)` time. i.e. first use `lower_bound` to search server those id is greater than or equal `i % p`. And if find none, just choose the smallest id.\\n\\nUse `priority_queue<pair<int, int>> work` to remember the server in working and the time it finish the current request. When a new requent arrives, we populate those server that will be idle at that time.\\n\\n``` c++\\nvector<int> busiestServers(int K, vector<int>& A, vector<int>& load)\\n{\\n  vector<int> req(K);\\n  set<int> idle;\\n  priority_queue<pair<int, int>> work;\\n  for (int i = 0; i < K; ++i)\\n    idle.insert(i);\\n\\n  int len = static_cast<int>(A.size());\\n  for (int i = 0; i < len; ++i)\\n  {\\n    int f = A[i];\\n    int t = f + load[i];\\n    int p = i % K;\\n    while (!work.empty())\\n    {\\n      auto ei = work.top();\\n      if (ei.first < -f)\\n        break;\\n      idle.insert(ei.second);\\n      work.pop();\\n    }\\n    if (idle.empty())\\n      continue;\\n    auto it = idle.lower_bound(p);\\n    if (it == idle.end())\\n      it = idle.begin();\\n    p = *it;\\n    idle.erase(it);\\n    work.push({ -t, p });\\n    req[p] += 1;\\n  }\\n\\n  int num = 0;\\n  vector<int> ans;\\n  for (int i = 0; i < K; ++i)\\n    num = max(num, req[i]);\\n  for (int i = 0; i < K; ++i)\\n  {\\n    if (req[i] == num)\\n      ans.push_back(i);\\n  }\\n  return ans;\\n}\\n```",
                "solutionTags": [],
                "code": "``` c++\\nvector<int> busiestServers(int K, vector<int>& A, vector<int>& load)\\n{\\n  vector<int> req(K);\\n  set<int> idle;\\n  priority_queue<pair<int, int>> work;\\n  for (int i = 0; i < K; ++i)\\n    idle.insert(i);\\n\\n  int len = static_cast<int>(A.size());\\n  for (int i = 0; i < len; ++i)\\n  {\\n    int f = A[i];\\n    int t = f + load[i];\\n    int p = i % K;\\n    while (!work.empty())\\n    {\\n      auto ei = work.top();\\n      if (ei.first < -f)\\n        break;\\n      idle.insert(ei.second);\\n      work.pop();\\n    }\\n    if (idle.empty())\\n      continue;\\n    auto it = idle.lower_bound(p);\\n    if (it == idle.end())\\n      it = idle.begin();\\n    p = *it;\\n    idle.erase(it);\\n    work.push({ -t, p });\\n    req[p] += 1;\\n  }\\n\\n  int num = 0;\\n  vector<int> ans;\\n  for (int i = 0; i < K; ++i)\\n    num = max(num, req[i]);\\n  for (int i = 0; i < K; ++i)\\n  {\\n    if (req[i] == num)\\n      ans.push_back(i);\\n  }\\n  return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 877970,
                "title": "simple-c-find-the-first-trailing-one",
                "content": "```\\nvector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n\\tvector<int> res;\\n\\tset<int> mySet;\\n\\tvector<int> cnt(k, 0);\\n\\tstd::set<int>::iterator it;\\n\\tint maxVal = 0;\\n\\n\\tfor (int i = 0; i < k; ++i) mySet.insert(i);\\n\\tpriority_queue<pair<int, int>, vector<pair<int, int>>, greater<>> myQueue;\\n\\n\\tfor (int i = 0; i < arrival.size(); ++i) {\\n\\n\\t\\twhile (!myQueue.empty() && myQueue.top().first <= arrival[i]) {\\n\\t\\t\\tmySet.insert(myQueue.top().second);\\n\\t\\t\\tmyQueue.pop();\\n\\t\\t}\\n\\n\\t\\tif (mySet.empty()) continue;\\n\\n\\t\\tit = mySet.lower_bound(i % k);\\n\\n\\t\\tif (it == mySet.end()) it = mySet.begin();\\n\\n\\t\\t++cnt[*it];\\n\\t\\tmaxVal = max(maxVal, cnt[*it]);\\n\\n\\t\\tmyQueue.push({arrival[i] + load[i], *it});\\n\\t\\tmySet.erase(it);\\n\\t}\\n\\n\\tfor (int i = 0; i < k; ++i) {\\n\\t\\tif (cnt[i] == maxVal) res.push_back(i);\\n\\t}\\n\\n\\treturn res;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n\\tvector<int> res;\\n\\tset<int> mySet;\\n\\tvector<int> cnt(k, 0);\\n\\tstd::set<int>::iterator it;\\n\\tint maxVal = 0;\\n\\n\\tfor (int i = 0; i < k; ++i) mySet.insert(i);\\n\\tpriority_queue<pair<int, int>, vector<pair<int, int>>, greater<>> myQueue;\\n\\n\\tfor (int i = 0; i < arrival.size(); ++i) {\\n\\n\\t\\twhile (!myQueue.empty() && myQueue.top().first <= arrival[i]) {\\n\\t\\t\\tmySet.insert(myQueue.top().second);\\n\\t\\t\\tmyQueue.pop();\\n\\t\\t}\\n\\n\\t\\tif (mySet.empty()) continue;\\n\\n\\t\\tit = mySet.lower_bound(i % k);\\n\\n\\t\\tif (it == mySet.end()) it = mySet.begin();\\n\\n\\t\\t++cnt[*it];\\n\\t\\tmaxVal = max(maxVal, cnt[*it]);\\n\\n\\t\\tmyQueue.push({arrival[i] + load[i], *it});\\n\\t\\tmySet.erase(it);\\n\\t}\\n\\n\\tfor (int i = 0; i < k; ++i) {\\n\\t\\tif (cnt[i] == maxVal) res.push_back(i);\\n\\t}\\n\\n\\treturn res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 877674,
                "title": "rust-translated-80ms-100",
                "content": "```rust\\nimpl Solution {\\n    pub fn busiest_servers(k: i32, arrival: Vec<i32>, load: Vec<i32>) -> Vec<i32> {\\n        use std::collections::{BTreeSet, BinaryHeap};\\n\\n        let mut freq = vec![0; k as usize];\\n        let mut max = 0;\\n        let mut free = BTreeSet::<i32>::new();\\n        let mut busy = BinaryHeap::<(i32, i32)>::new(); // (avail(x), x)\\n        for i in 0..k {\\n            free.insert(i as i32);\\n        }\\n\\n        for i in 0..arrival.len() {\\n            while !busy.is_empty() && -busy.peek().unwrap().0 <= arrival[i] {\\n                free.insert(busy.pop().unwrap().1);\\n            }\\n            if free.is_empty() {\\n                continue;\\n            }\\n            let pos = i % k as usize;\\n            if free.contains(&(pos as i32)) {\\n                free.remove(&(pos as i32));\\n                let avail = arrival[i] + load[i];\\n                busy.push((-avail, pos as i32));\\n                freq[pos as usize] += 1;\\n                if freq[pos] > max {\\n                    max = freq[pos];\\n                }\\n            } else {\\n                let mut next = free.range(pos as i32..).next();\\n                if next.is_none() {\\n                    next = free.range(0..).next();\\n                }\\n                let x = *next.unwrap();\\n                free.remove(&x);\\n                let avail = arrival[i] + load[i];\\n                busy.push((-avail, x));\\n                freq[x as usize] += 1;\\n                if freq[x as usize] > max {\\n                    max = freq[x as usize];\\n                }\\n            }\\n        }\\n\\n        let mut ans = vec![];\\n        for (i, &x) in freq.iter().enumerate() {\\n            if x == max {\\n                ans.push(i as i32)\\n            }\\n        }\\n        ans\\n    }\\n}\\n\\n#[cfg(test)]\\nmod tests {\\n    use super::*;\\n\\n    #[test]\\n    fn test_busiest_servers() {\\n        assert_eq!(\\n            Solution::busiest_servers(3, vec![1, 2, 3, 4, 5], vec![5, 2, 3, 3, 3]),\\n            vec![1]\\n        );\\n    }\\n\\n    #[test]\\n    fn test_busiest_servers_02() {\\n        assert_eq!(\\n            Solution::busiest_servers(3, vec![1, 2, 3, 4], vec![1, 2, 1, 2]),\\n            vec![0]\\n        );\\n    }\\n\\n    #[test]\\n    fn test_busiest_servers_03() {\\n        assert_eq!(\\n            Solution::busiest_servers(3, vec![1, 2, 3], vec![10, 12, 11]),\\n            vec![0, 1, 2]\\n        );\\n    }\\n\\n    #[test]\\n    fn test_busiest_servers_04() {\\n        assert_eq!(\\n            Solution::busiest_servers(3, vec![1, 2, 3, 4, 8, 9, 10], vec![5, 2, 10, 3, 1, 2, 2]),\\n            vec![1]\\n        );\\n    }\\n\\n    #[test]\\n    fn test_busiest_servers_05() {\\n        assert_eq!(Solution::busiest_servers(1, vec![1], vec![1]), vec![0]);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```rust\\nimpl Solution {\\n    pub fn busiest_servers(k: i32, arrival: Vec<i32>, load: Vec<i32>) -> Vec<i32> {\\n        use std::collections::{BTreeSet, BinaryHeap};\\n\\n        let mut freq = vec![0; k as usize];\\n        let mut max = 0;\\n        let mut free = BTreeSet::<i32>::new();\\n        let mut busy = BinaryHeap::<(i32, i32)>::new(); // (avail(x), x)\\n        for i in 0..k {\\n            free.insert(i as i32);\\n        }\\n\\n        for i in 0..arrival.len() {\\n            while !busy.is_empty() && -busy.peek().unwrap().0 <= arrival[i] {\\n                free.insert(busy.pop().unwrap().1);\\n            }\\n            if free.is_empty() {\\n                continue;\\n            }\\n            let pos = i % k as usize;\\n            if free.contains(&(pos as i32)) {\\n                free.remove(&(pos as i32));\\n                let avail = arrival[i] + load[i];\\n                busy.push((-avail, pos as i32));\\n                freq[pos as usize] += 1;\\n                if freq[pos] > max {\\n                    max = freq[pos];\\n                }\\n            } else {\\n                let mut next = free.range(pos as i32..).next();\\n                if next.is_none() {\\n                    next = free.range(0..).next();\\n                }\\n                let x = *next.unwrap();\\n                free.remove(&x);\\n                let avail = arrival[i] + load[i];\\n                busy.push((-avail, x));\\n                freq[x as usize] += 1;\\n                if freq[x as usize] > max {\\n                    max = freq[x as usize];\\n                }\\n            }\\n        }\\n\\n        let mut ans = vec![];\\n        for (i, &x) in freq.iter().enumerate() {\\n            if x == max {\\n                ans.push(i as i32)\\n            }\\n        }\\n        ans\\n    }\\n}\\n\\n#[cfg(test)]\\nmod tests {\\n    use super::*;\\n\\n    #[test]\\n    fn test_busiest_servers() {\\n        assert_eq!(\\n            Solution::busiest_servers(3, vec![1, 2, 3, 4, 5], vec![5, 2, 3, 3, 3]),\\n            vec![1]\\n        );\\n    }\\n\\n    #[test]\\n    fn test_busiest_servers_02() {\\n        assert_eq!(\\n            Solution::busiest_servers(3, vec![1, 2, 3, 4], vec![1, 2, 1, 2]),\\n            vec![0]\\n        );\\n    }\\n\\n    #[test]\\n    fn test_busiest_servers_03() {\\n        assert_eq!(\\n            Solution::busiest_servers(3, vec![1, 2, 3], vec![10, 12, 11]),\\n            vec![0, 1, 2]\\n        );\\n    }\\n\\n    #[test]\\n    fn test_busiest_servers_04() {\\n        assert_eq!(\\n            Solution::busiest_servers(3, vec![1, 2, 3, 4, 8, 9, 10], vec![5, 2, 10, 3, 1, 2, 2]),\\n            vec![1]\\n        );\\n    }\\n\\n    #[test]\\n    fn test_busiest_servers_05() {\\n        assert_eq!(Solution::busiest_servers(1, vec![1], vec![1]), vec![0]);\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 877415,
                "title": "detailed-explanation-with-print-statements-100-100-time-mem-python3",
                "content": "I included a whole bunch of Print statements, so that you can see the progression of the algorithm step by step. Obviously you need to comment those out if you want to submit this.\\n\\nHere\\'s how we solve this problem. The \"solution\" is actually very simple, the implementation is the hard part. The solution is for every arrival, choose the first server we encounter that is availble, starting from server (how many arrivals we\\'ve had)%k. The difficult part is doing this efficiently. The clue, is we require only two pieces of information\\n1. Figure out a way to maintain a list of all available servers at any time\\n2. Choose the element in that list that is first encountered\\n\\nTo do this, we maintain two data structures. The first, is a list of available servers. Ideally we want that this array is sorted in terms of which we would encounter first, so this way for every arrival we could just take its first element. That\\'s actually too hard to do; after every arrival, the ordering actually changes to send the latest server to the back of the line. Instead, we will settle for just sorting it normally, then use binary search to index into wherever we need. It\\'s an $O(log(m))$ penalty, for m the queue length.\\n\\nSecond, we maintain a heap of tuples (earilest server availability time, server number). For every arrival, this allows us to quickly extract all servers that are available. We just keep taking the server with earliset availability up until the current one. We then insert all of these using python\\'s binary search module \"bisect\" into the sorted array of available servers. Rinse and repeat.\\n\\nThe last parts concerning res, curr, and c are just to keep track of the busiest servers, there\\'s no deep insight there.\\n\\nI suggest trying out the code on some of the test cases to see how the algorithm works\\n\\n```\\n    def busiestServers(self, k: int, arrival: List[int], load: List[int]) -> List[int]:\\n        \\n        print(\\'*\\'*20)\\n        print(\\'Prints logs.\\\\n The \\\\\\'busy\\\\\\' server is formatted with entries\\\\n (earliest availability, server number)\\')\\n        print(f\\'There are {k} servers total, {len(arrival)} requests\\')\\n        print(\\'*\\'*20)\\n        \\n        import heapq, bisect\\n        res, curr, c = [], float(\\'-inf\\'), {i:0 for i in range(k)}\\n        q, nq = list(range(k)), []\\n        for m, z in enumerate(zip(arrival, load)):\\n            a, b = z\\n            while nq and nq[0][0] <= a:\\n                time, idx = heapq.heappop(nq)\\n                bisect.insort(q, idx)\\n            if q:\\n\\t\\t\\t\\n                print(\"start time:\", a, \"Preferred server:\",m%k)\\n                print(\"Available servers:\", q)\\n\\t\\t\\t\\t\\n                i = q.pop(bisect.bisect_left(q, m%k)%len(q))\\n\\t\\t\\t\\t\\n                print(\"Busy servers:\", nq)\\n                print(\"Choosing server\",i,\"...\\\\n\")\\n\\t\\t\\t\\t\\n                heapq.heappush(nq, (a+b,i))\\n                c[i] += 1\\n                if c[i] > curr:\\n                    res, curr = [i], c[i]\\n                elif c[i] == curr:\\n                    res.append(i)\\n\\t\\t\\t\\t\\t\\n        print(\\'-\\'*40)\\n        print(\\'Printing number of accepted requests per server...\\')\\n        print(c)\\n        return res\\n```\\n\\nAs an example output, suppose we give it the inputs:\\n\\nnum of servers: 3\\narrival times: [1,2,3,4,5]\\nload times: [5,2,3,3,3]\\n\\nThen we would output:\\n********************\\nPrints logs.\\n The \\'busy\\' server is formatted with entries\\n (earliest availability, server number)\\nThere are 3 servers total, 5 requests\\n********************\\nstart time: 1 Preferred server: 0\\nAvailable servers: [0, 1, 2]\\nBusy servers: []\\nChoosing server 0 ...\\n\\nstart time: 2 Preferred server: 1\\nAvailable servers: [1, 2]\\nBusy servers: [(6, 0)]\\nChoosing server 1 ...\\n\\nstart time: 3 Preferred server: 2\\nAvailable servers: [2]\\nBusy servers: [(4, 1), (6, 0)]\\nChoosing server 2 ...\\n\\nstart time: 4 Preferred server: 0\\nAvailable servers: [1]\\nBusy servers: [(6, 0), (6, 2)]\\nChoosing server 1 ...\\n\\n----------------------------------------\\nPrinting number of accepted requests per server...\\n{0: 1, 1: 2, 2: 1}\\n",
                "solutionTags": [],
                "code": "```\\n    def busiestServers(self, k: int, arrival: List[int], load: List[int]) -> List[int]:\\n        \\n        print(\\'*\\'*20)\\n        print(\\'Prints logs.\\\\n The \\\\\\'busy\\\\\\' server is formatted with entries\\\\n (earliest availability, server number)\\')\\n        print(f\\'There are {k} servers total, {len(arrival)} requests\\')\\n        print(\\'*\\'*20)\\n        \\n        import heapq, bisect\\n        res, curr, c = [], float(\\'-inf\\'), {i:0 for i in range(k)}\\n        q, nq = list(range(k)), []\\n        for m, z in enumerate(zip(arrival, load)):\\n            a, b = z\\n            while nq and nq[0][0] <= a:\\n                time, idx = heapq.heappop(nq)\\n                bisect.insort(q, idx)\\n            if q:\\n\\t\\t\\t\\n                print(\"start time:\", a, \"Preferred server:\",m%k)\\n                print(\"Available servers:\", q)\\n\\t\\t\\t\\t\\n                i = q.pop(bisect.bisect_left(q, m%k)%len(q))\\n\\t\\t\\t\\t\\n                print(\"Busy servers:\", nq)\\n                print(\"Choosing server\",i,\"...\\\\n\")\\n\\t\\t\\t\\t\\n                heapq.heappush(nq, (a+b,i))\\n                c[i] += 1\\n                if c[i] > curr:\\n                    res, curr = [i], c[i]\\n                elif c[i] == curr:\\n                    res.append(i)\\n\\t\\t\\t\\t\\t\\n        print(\\'-\\'*40)\\n        print(\\'Printing number of accepted requests per server...\\')\\n        print(c)\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 877353,
                "title": "java-o-nlogn-o-nlogk-with-explaination-and-comment",
                "content": "The idea is simulating the whole process. For the time when a job start and a end, we create a event, and sort these events. \\n\\n```Java\\nclass Solution {\\n    public List<Integer> busiestServers(int k, int[] a, int[] l) {\\n        TreeSet<Integer> servers = new TreeSet<>();  // the set stores availabe servers \\n        for (int i = 0; i < k; i++) {\\n            servers.add(i);\\n        }\\n        int[] jobs = new int[k];   // jobs[i] stores how many job ith server finished so far\\n        List<Event> events = new ArrayList<>();\\n        for (int i = 0; i < a.length; i++) {\\n            events.add(new Event(i, 1, a[i]));\\n            events.add(new Event(i, 0, a[i] + l[i]));\\n        }\\n        Collections.sort(events, (e1, e2) -> {\\n            return e1.time == e2.time ? e1.time - e2.time : e1.time - e2.time;   // we sort the the event by \\n\\t\\t\\t// the time stamp, when the timestamp is same, we put the ending event first, so we can free the server as soon as possible.\\n        });\\n        Map<Integer, Integer> idToServer = new HashMap<>();   // this stores mapping between job.id and server\\n        for (Event event : events) {\\n            if (event.start == 1) {\\n                if (servers.isEmpty()) {   // if no available server, we have to drop the job\\n                    continue;\\n                } else {\\n                    int server = nextServer(servers, event.id % k); // find next available server \\n                    idToServer.put(event.id, server);      // recording the mapping\\n                    jobs[server]++;\\n                    servers.remove(server);\\n                }\\n            } else {\\n                Integer server = idToServer.get(event.id);   // if server == null means the job was dropped.\\n                if (server != null) {\\n                    servers.add(server);    // add the server back to available servers.\\n                }\\n            }\\n        }\\n        int max = IntStream.of(jobs).max().getAsInt();\\n        List<Integer> ans = new ArrayList<>();\\n        for (int i = 0; i < jobs.length; i++) {\\n            if (jobs[i] == max) {\\n                ans.add(i);\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    int nextServer(TreeSet<Integer> servers, int id) {\\n        Integer nextServer = servers.ceiling(id);\\n        return nextServer != null ? nextServer : servers.first();\\n    }\\n    \\n    \\n    public static class Event {\\n        \\n        public int start; // 1 start 0 end\\n        \\n        public int time;\\n        \\n        public int id;\\n        \\n        public Event(int id, int start, int time) {\\n            this.start = start;\\n            this.time = time;\\n            this.id = id;\\n        }\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```Java\\nclass Solution {\\n    public List<Integer> busiestServers(int k, int[] a, int[] l) {\\n        TreeSet<Integer> servers = new TreeSet<>();  // the set stores availabe servers \\n        for (int i = 0; i < k; i++) {\\n            servers.add(i);\\n        }\\n        int[] jobs = new int[k];   // jobs[i] stores how many job ith server finished so far\\n        List<Event> events = new ArrayList<>();\\n        for (int i = 0; i < a.length; i++) {\\n            events.add(new Event(i, 1, a[i]));\\n            events.add(new Event(i, 0, a[i] + l[i]));\\n        }\\n        Collections.sort(events, (e1, e2) -> {\\n            return e1.time == e2.time ? e1.time - e2.time : e1.time - e2.time;   // we sort the the event by \\n\\t\\t\\t// the time stamp, when the timestamp is same, we put the ending event first, so we can free the server as soon as possible.\\n        });\\n        Map<Integer, Integer> idToServer = new HashMap<>();   // this stores mapping between job.id and server\\n        for (Event event : events) {\\n            if (event.start == 1) {\\n                if (servers.isEmpty()) {   // if no available server, we have to drop the job\\n                    continue;\\n                } else {\\n                    int server = nextServer(servers, event.id % k); // find next available server \\n                    idToServer.put(event.id, server);      // recording the mapping\\n                    jobs[server]++;\\n                    servers.remove(server);\\n                }\\n            } else {\\n                Integer server = idToServer.get(event.id);   // if server == null means the job was dropped.\\n                if (server != null) {\\n                    servers.add(server);    // add the server back to available servers.\\n                }\\n            }\\n        }\\n        int max = IntStream.of(jobs).max().getAsInt();\\n        List<Integer> ans = new ArrayList<>();\\n        for (int i = 0; i < jobs.length; i++) {\\n            if (jobs[i] == max) {\\n                ans.add(i);\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    int nextServer(TreeSet<Integer> servers, int id) {\\n        Integer nextServer = servers.ceiling(id);\\n        return nextServer != null ? nextServer : servers.first();\\n    }\\n    \\n    \\n    public static class Event {\\n        \\n        public int start; // 1 start 0 end\\n        \\n        public int time;\\n        \\n        public int id;\\n        \\n        public Event(int id, int start, int time) {\\n            this.start = start;\\n            this.time = time;\\n            this.id = id;\\n        }\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 877296,
                "title": "c-using-map-priority-queue-t-c-o-n-log-k-log-n",
                "content": "```\\n/*\\nfreeServers -> is used as find nearest element or exact value of (i % k)-> to achieve this we are using Lower_Bound\\n\\npq (min heap <arrival_time + load, serverNumber>) -> is used to remove expired element\\n\\t\\nmp -> is used to store frequency of the server(how many request served by each server)\\n*/\\n\\nclass Solution {\\npublic:\\n    vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n       \\n        map<int,int> mp;\\n        \\n        priority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int> > > pq;\\n       \\n        map<int,int> freeServers;\\n\\n        for(int i = 0; i < k; i++) freeServers[i]++;\\n        \\n        int len = arrival.size();\\n        \\n        int mx = 0;\\n        \\n        for(int i = 0; i < len; i++) {\\n            \\n            while(!pq.empty() && arrival[i] >= pq.top().first) {\\n                freeServers[pq.top().second]++;\\n                pq.pop();   \\n            }\\n            \\n            auto it =  freeServers.lower_bound(i % k);\\n            if(it == freeServers.end() && freeServers.size() > 0) {\\n                it = freeServers.begin();\\n            }\\n            \\n            if(it != freeServers.end()) {\\n                mp[it->first]++;\\n                mx = max(mx, mp[it->first]);\\n                pq.push({arrival[i] + load[i], it->first});\\n                freeServers.erase(it);\\n            }\\n        }\\n        \\n        vector<int> ans;\\n        \\n        for(auto it = mp.begin(); it != mp.end(); it++) {\\n            if(it->second == mx) {\\n                ans.push_back(it->first);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\nfreeServers -> is used as find nearest element or exact value of (i % k)-> to achieve this we are using Lower_Bound\\n\\npq (min heap <arrival_time + load, serverNumber>) -> is used to remove expired element\\n\\t\\nmp -> is used to store frequency of the server(how many request served by each server)\\n*/\\n\\nclass Solution {\\npublic:\\n    vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n       \\n        map<int,int> mp;\\n        \\n        priority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int> > > pq;\\n       \\n        map<int,int> freeServers;\\n\\n        for(int i = 0; i < k; i++) freeServers[i]++;\\n        \\n        int len = arrival.size();\\n        \\n        int mx = 0;\\n        \\n        for(int i = 0; i < len; i++) {\\n            \\n            while(!pq.empty() && arrival[i] >= pq.top().first) {\\n                freeServers[pq.top().second]++;\\n                pq.pop();   \\n            }\\n            \\n            auto it =  freeServers.lower_bound(i % k);\\n            if(it == freeServers.end() && freeServers.size() > 0) {\\n                it = freeServers.begin();\\n            }\\n            \\n            if(it != freeServers.end()) {\\n                mp[it->first]++;\\n                mx = max(mx, mp[it->first]);\\n                pq.push({arrival[i] + load[i], it->first});\\n                freeServers.erase(it);\\n            }\\n        }\\n        \\n        vector<int> ans;\\n        \\n        for(auto it = mp.begin(); it != mp.end(); it++) {\\n            if(it->second == mx) {\\n                ans.push_back(it->first);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 877202,
                "title": "easy-cpp-solution-using-min-heap-and-ordered-set",
                "content": "CPP solution using minheap and ordered set.\\n\\n```\\n\\n\\nclass Solution {\\npublic:\\n    \\n    int *counter;\\n\\n    \\n    struct compare{\\n        bool operator() (const pair<int,int> & p1,const pair<int,int> & p2 ){\\n             return p1.second > p2.second;\\n//             > gives minheap\\n//             < gives maxheap\\n        }\\n    };\\n    \\n    vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n    \\n//         the idea is to use a set for free servers\\n//         and a min Heap to store busy servers. \\n//         min heap is according to their min end times. -- but key is the serverid\\n        vector<int> ans;\\n        \\n        counter = new int[k];\\n        memset(counter, 0, sizeof(int)*k);\\n        \\n        int maxfound = INT_MIN;\\n        \\n        set<int> freeservers;\\n        priority_queue<pair<int,int>, vector< pair<int,int> >, compare> busy;\\n        \\n        for(int i=0;i<k;i++)\\n            freeservers.insert(i);\\n        \\n        for(int i=0; i<arrival.size();i++){\\n            \\n            \\n//             second is time, first is serverid -- in queue.\\n            \\n//             whatever is actually free.. put it in ther freeserver set.\\n            while(!busy.empty() && busy.top().second <= arrival[i]){\\n                freeservers.insert(busy.top().first);\\n                busy.pop();\\n            }\\n            \\n            \\n            if(freeservers.empty())\\n                continue;\\n            \\n//             get a free server. starting at i%k.\\n            // try right to i%k\\n            auto x = freeservers.lower_bound(i%k);\\n            if(x == freeservers.end()){\\n                // now pick the least available. -- which is the first element.\\n                x = freeservers.begin();\\n            }\\n            \\n            int usethis;\\n            usethis = *x;\\n        \\n            busy.push({usethis, arrival[i] + load[i]});\\n            freeservers.erase(usethis);\\n            counter[usethis] ++;\\n            \\n            maxfound = max(maxfound, counter[usethis]);\\n        }\\n        \\n        \\n        for(int i=0;i<k;i++){\\n            if(counter[i] == maxfound)\\n                ans.push_back(i);\\n        }\\n            \\n        delete [] counter;\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\n\\nclass Solution {\\npublic:\\n    \\n    int *counter;\\n\\n    \\n    struct compare{\\n        bool operator() (const pair<int,int> & p1,const pair<int,int> & p2 ){\\n             return p1.second > p2.second;\\n//             > gives minheap\\n//             < gives maxheap\\n        }\\n    };\\n    \\n    vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n    \\n//         the idea is to use a set for free servers\\n//         and a min Heap to store busy servers. \\n//         min heap is according to their min end times. -- but key is the serverid\\n        vector<int> ans;\\n        \\n        counter = new int[k];\\n        memset(counter, 0, sizeof(int)*k);\\n        \\n        int maxfound = INT_MIN;\\n        \\n        set<int> freeservers;\\n        priority_queue<pair<int,int>, vector< pair<int,int> >, compare> busy;\\n        \\n        for(int i=0;i<k;i++)\\n            freeservers.insert(i);\\n        \\n        for(int i=0; i<arrival.size();i++){\\n            \\n            \\n//             second is time, first is serverid -- in queue.\\n            \\n//             whatever is actually free.. put it in ther freeserver set.\\n            while(!busy.empty() && busy.top().second <= arrival[i]){\\n                freeservers.insert(busy.top().first);\\n                busy.pop();\\n            }\\n            \\n            \\n            if(freeservers.empty())\\n                continue;\\n            \\n//             get a free server. starting at i%k.\\n            // try right to i%k\\n            auto x = freeservers.lower_bound(i%k);\\n            if(x == freeservers.end()){\\n                // now pick the least available. -- which is the first element.\\n                x = freeservers.begin();\\n            }\\n            \\n            int usethis;\\n            usethis = *x;\\n        \\n            busy.push({usethis, arrival[i] + load[i]});\\n            freeservers.erase(usethis);\\n            counter[usethis] ++;\\n            \\n            maxfound = max(maxfound, counter[usethis]);\\n        }\\n        \\n        \\n        for(int i=0;i<k;i++){\\n            if(counter[i] == maxfound)\\n                ans.push_back(i);\\n        }\\n            \\n        delete [] counter;\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 877071,
                "title": "python-heap-sortedlist-o-nlog-k",
                "content": "Comments are mentioned below but the basic idea is to keep a sortedList (BST datastructure) for the available servers at all times and use a heap to add servers that become available again later on back into the available servers list and binary search the available servers to find the closest server to the present idx%k.\\n```\\nfrom sortedcontainers import SortedList\\nimport heapq\\n\\nclass Solution:\\n    def busiestServers(self, k, arrival, load):\\n        # This is a BST this way we can keep the available sorted so we can search through with binary search.\\n        avail = SortedList(range(k))\\n        inf = float(\\'inf\\')\\n        # Add infinity at the end to deal with the case that that all values are smaller than target so it is\\n        # FFF, which will return the last F but this will cause ambiguity with the case that FFT, so I added on\\n        # infinity so that these cases would not be ambiguous with FFFT and FFTT, so the FFFT will wrap around back to the\\n        # zeroth element in available servers.  While the other one will just retern the last element in available servers.\\n        avail.add(inf)\\n        count = [0] * k\\n        # The heap will allow us to add servers that become newly available again back into available servers BST\\n        heap = []\\n\\n        def possible(val, target):\\n            return val >= target\\n        # Binary search in the form of FFTT and we return the first occurrence of T.\\n        def binary_search(target, arr):\\n            lo, hi = 0, len(arr) - 1\\n            while lo < hi:\\n                mid = lo + hi >> 1\\n                if not possible(arr[mid], target):\\n                    lo = mid + 1\\n                else:\\n                    hi = mid\\n            return lo\\n\\n        for idx, (a, l) in enumerate(zip(arrival, load)):\\n            # Pop from heap if the expiration time is less than the current arrival time. \\n            # Then added to the sorted available servers list.  \\n            while heap and heap[0][0] <= a:\\n                _, index = heapq.heappop(heap)\\n                avail.add(index)\\n\\n            n = len(avail)\\n            # There are no servers available right now\\n            if n == 1:\\n                continue\\n            # The reason for mod with n-1 is because if the binary search returns the last value in the avail.\\n            # We want to wrap around back to the first element in the available servers.\\n            avail_idx = binary_search(idx % k, avail) % (n - 1)\\n\\n            server_idx = avail[avail_idx]\\n            expiration_time = a + l\\n            # push this into the heap with the server_idx saved, and the expiration time.\\n            heapq.heappush(heap, (expiration_time, server_idx))\\n            avail.remove(server_idx)\\n            count[server_idx] += 1\\n        ans = []\\n        goal = max(count)\\n        for i, val in enumerate(count):\\n            if val == goal:\\n                ans.append(i)\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nfrom sortedcontainers import SortedList\\nimport heapq\\n\\nclass Solution:\\n    def busiestServers(self, k, arrival, load):\\n        # This is a BST this way we can keep the available sorted so we can search through with binary search.\\n        avail = SortedList(range(k))\\n        inf = float(\\'inf\\')\\n        # Add infinity at the end to deal with the case that that all values are smaller than target so it is\\n        # FFF, which will return the last F but this will cause ambiguity with the case that FFT, so I added on\\n        # infinity so that these cases would not be ambiguous with FFFT and FFTT, so the FFFT will wrap around back to the\\n        # zeroth element in available servers.  While the other one will just retern the last element in available servers.\\n        avail.add(inf)\\n        count = [0] * k\\n        # The heap will allow us to add servers that become newly available again back into available servers BST\\n        heap = []\\n\\n        def possible(val, target):\\n            return val >= target\\n        # Binary search in the form of FFTT and we return the first occurrence of T.\\n        def binary_search(target, arr):\\n            lo, hi = 0, len(arr) - 1\\n            while lo < hi:\\n                mid = lo + hi >> 1\\n                if not possible(arr[mid], target):\\n                    lo = mid + 1\\n                else:\\n                    hi = mid\\n            return lo\\n\\n        for idx, (a, l) in enumerate(zip(arrival, load)):\\n            # Pop from heap if the expiration time is less than the current arrival time. \\n            # Then added to the sorted available servers list.  \\n            while heap and heap[0][0] <= a:\\n                _, index = heapq.heappop(heap)\\n                avail.add(index)\\n\\n            n = len(avail)\\n            # There are no servers available right now\\n            if n == 1:\\n                continue\\n            # The reason for mod with n-1 is because if the binary search returns the last value in the avail.\\n            # We want to wrap around back to the first element in the available servers.\\n            avail_idx = binary_search(idx % k, avail) % (n - 1)\\n\\n            server_idx = avail[avail_idx]\\n            expiration_time = a + l\\n            # push this into the heap with the server_idx saved, and the expiration time.\\n            heapq.heappush(heap, (expiration_time, server_idx))\\n            avail.remove(server_idx)\\n            count[server_idx] += 1\\n        ans = []\\n        goal = max(count)\\n        for i, val in enumerate(count):\\n            if val == goal:\\n                ans.append(i)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 876995,
                "title": "python-solution-with-two-heaps-rotated-key",
                "content": "The trick is to use `server + i - i % k + (k if server < i % k else 0)` to simulate the circular process.\\n\\n```\\nclass Solution:\\n    def busiestServers(self, k: int, arrival: List[int], load: List[int]) -> List[int]:\\n        count = [0] * k\\n        busyUntil = [0] * k\\n        busyHeap = [] # heap of servers with key being busyUntil[server]\\n        availableHeap = list((i, i) for i in range(k)) # heap of servers with key being the rotation index of server.\\n        heapify(availableHeap)\\n\\n        def getRotationKey(server, i):\\n            return server + i - i % k + (k if server < i % k else 0)\\n\\n        for i in range(len(arrival)):\\n            t = arrival[i]\\n            ld = load[i]\\n            \\n            while busyHeap and busyHeap[0][0] <= t:\\n                _, server = heappop(busyHeap)\\n                heappush(availableHeap, (getRotationKey(server, i), server))\\n                \\n            while availableHeap and availableHeap[0][0] < i:\\n                _, server = heappop(availableHeap)\\n                heappush(availableHeap, (getRotationKey(server, i), server))\\n\\n            if not availableHeap:\\n                continue\\n\\n            _, server = heappop(availableHeap)\\n            heappush(busyHeap, (t + ld, server))\\n            busyUntil[server] = t + ld\\n            count[server] += 1\\n            \\n        most = max(count)\\n        return [server for server, c in enumerate(count) if c == most]\\n\\t\\t\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def busiestServers(self, k: int, arrival: List[int], load: List[int]) -> List[int]:\\n        count = [0] * k\\n        busyUntil = [0] * k\\n        busyHeap = [] # heap of servers with key being busyUntil[server]\\n        availableHeap = list((i, i) for i in range(k)) # heap of servers with key being the rotation index of server.\\n        heapify(availableHeap)\\n\\n        def getRotationKey(server, i):\\n            return server + i - i % k + (k if server < i % k else 0)\\n\\n        for i in range(len(arrival)):\\n            t = arrival[i]\\n            ld = load[i]\\n            \\n            while busyHeap and busyHeap[0][0] <= t:\\n                _, server = heappop(busyHeap)\\n                heappush(availableHeap, (getRotationKey(server, i), server))\\n                \\n            while availableHeap and availableHeap[0][0] < i:\\n                _, server = heappop(availableHeap)\\n                heappush(availableHeap, (getRotationKey(server, i), server))\\n\\n            if not availableHeap:\\n                continue\\n\\n            _, server = heappop(availableHeap)\\n            heappush(busyHeap, (t + ld, server))\\n            busyUntil[server] = t + ld\\n            count[server] += 1\\n            \\n        most = max(count)\\n        return [server for server, c in enumerate(count) if c == most]\\n\\t\\t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 876983,
                "title": "c-easy-to-understand",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tstruct comp{\\n\\t\\t\\tbool operator()(const pair<int,int>& a, const pair<int,int>& b){\\n\\t\\t\\t\\treturn a.second > b.second;\\n\\t\\t\\t}\\n\\t\\t};\\n\\t\\tvector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n\\t\\t\\tpriority_queue< pair<int,int> ,vector<pair<int,int>>,comp> qu; // for busy server\\n\\t\\t\\tset<int> S; // for non-busy server\\n\\t\\t\\tfor(int i = 0;i < k; i++ ){\\n\\t\\t\\t\\tS.insert(i);\\n\\t\\t\\t}\\n\\t\\t\\tvector<int> ans;\\n\\t\\t\\tvector<int> server(k,0);\\n\\n\\t\\t\\tfor(int i = 0;i < arrival.size(); i++){\\n\\t\\t\\t\\tint ii = i % k;\\n\\t\\t\\t\\twhile(!qu.empty() && qu.top().second <= arrival[i]){\\n\\t\\t\\t\\t\\tS.insert(qu.top().first);\\n\\t\\t\\t\\t\\tqu.pop();\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(S.empty()) continue;\\n\\t\\t\\t\\tauto it = S.lower_bound(ii);\\n\\t\\t\\t\\tif( it == S.end() ){\\n\\t\\t\\t\\t\\tqu.push( make_pair( *S.begin(), arrival[i] + load[i] ) );\\n\\t\\t\\t\\t\\tserver[*S.begin()]++;\\n\\t\\t\\t\\t\\tS.erase(S.begin());\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\tqu.push( make_pair( *it, arrival[i] + load[i] ) );\\n\\t\\t\\t\\t\\tserver[*it]++;\\n\\t\\t\\t\\t\\tS.erase(*it);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tint big = 0;\\n\\t\\t\\tfor(int i = 0;i < k; i++){\\n\\t\\t\\t\\tbig = max(big,server[i]);\\n\\t\\t\\t}\\n\\t\\t\\tfor(int i = 0 ;i < k; i++){\\n\\t\\t\\t\\tif(server[i] == big)\\n\\t\\t\\t\\t\\tans.push_back( i );\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tstruct comp{\\n\\t\\t\\tbool operator()(const pair<int,int>& a, const pair<int,int>& b){\\n\\t\\t\\t\\treturn a.second > b.second;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 876978,
                "title": "same-implementation-but-one-solution-passes-the-other-doesn-t",
                "content": "During the contest, I came up with a solution for problem 4, but kept getting TLE. After the contest, I look at ASAPIN\\'s code (rank 1) and found that my solution and implementation is practically the same as his, yet his solution runs in <100ms for k = 8500, but mine runs in ~1500ms for the same input.\\n\\nMy solution (~1500ms for k = 8500):\\n```\\nclass Solution {\\npublic:\\n    vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n        int n = arrival.size();\\n        vector<int> cnt(k);\\n        priority_queue<pair<int, int>> end;\\n        set<int> nxt;\\n        for (int i = 0; i < k; i++) {\\n            nxt.insert(i);\\n        }\\n        \\n        for (int i = 0; i < n; i++) {\\n            while (!end.empty() && -(end.top().first) <= arrival[i]) {\\n                nxt.insert(end.top().second);\\n                end.pop();\\n            }\\n            if (nxt.empty()) continue;\\n            auto it = lower_bound(nxt.begin(), nxt.end(), i % k);\\n            if (it == nxt.end()) {\\n                it = nxt.begin();\\n            }\\n            int server = *it;\\n            end.push({-(arrival[i] + load[i]), server});\\n            //cout << i << \\' \\' << server << \\' \\' << (arrival[i] + load[i]) << endl;\\n            nxt.erase(it);\\n            cnt[server]++;\\n        }\\n        \\n        vector<int> ans;\\n        int mx = *max_element(cnt.begin(), cnt.end());\\n        for (int i = 0; i < k; i++) {\\n            if (cnt[i] == mx) {\\n                ans.push_back(i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nASAPIN\\'s code (<100ms for k = 8500)\\n```\\n#define fi first\\n#define se second\\n#define pb push_back\\n\\nclass Solution {\\npublic:\\n    vector<int> busiestServers(int k, vector<int>& a, vector<int>& b) {\\n        set<int> r;\\n        for(int i = 0; i < k; i++) r.insert(i);\\n        priority_queue<pair<int, int> > bsy;\\n        int Q = a.size();\\n        map<int, int> res;\\n        for(int i = 0; i < Q; i++) {\\n            int pos = i % k;\\n            int tim = a[i];\\n            int lod = b[i];\\n            while(!bsy.empty() && bsy.top().fi * -1 <= tim) {\\n                r.insert(bsy.top().se);\\n                bsy.pop();\\n            }\\n            if(r.empty()) continue;\\n            else {\\n                auto itr = r.lower_bound(pos);\\n                if(itr == r.end()) itr = r.begin();\\n                pos = *itr;\\n                r.erase(pos);\\n                res[pos] += 1;\\n                bsy.push(make_pair(-a[i] - b[i], pos));\\n            }\\n        }\\n        int mx = 0;\\n        for(auto it : res) {\\n            mx = max(mx, it.se);\\n        }\\n        vector<int> vec;\\n        for(auto it : res) {\\n            if(it.se == mx) vec.pb(it.fi);\\n        }\\n        return vec;\\n    }\\n};\\n```\\nCan someone explain why this is happening?",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n        int n = arrival.size();\\n        vector<int> cnt(k);\\n        priority_queue<pair<int, int>> end;\\n        set<int> nxt;\\n        for (int i = 0; i < k; i++) {\\n            nxt.insert(i);\\n        }\\n        \\n        for (int i = 0; i < n; i++) {\\n            while (!end.empty() && -(end.top().first) <= arrival[i]) {\\n                nxt.insert(end.top().second);\\n                end.pop();\\n            }\\n            if (nxt.empty()) continue;\\n            auto it = lower_bound(nxt.begin(), nxt.end(), i % k);\\n            if (it == nxt.end()) {\\n                it = nxt.begin();\\n            }\\n            int server = *it;\\n            end.push({-(arrival[i] + load[i]), server});\\n            //cout << i << \\' \\' << server << \\' \\' << (arrival[i] + load[i]) << endl;\\n            nxt.erase(it);\\n            cnt[server]++;\\n        }\\n        \\n        vector<int> ans;\\n        int mx = *max_element(cnt.begin(), cnt.end());\\n        for (int i = 0; i < k; i++) {\\n            if (cnt[i] == mx) {\\n                ans.push_back(i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\n#define fi first\\n#define se second\\n#define pb push_back\\n\\nclass Solution {\\npublic:\\n    vector<int> busiestServers(int k, vector<int>& a, vector<int>& b) {\\n        set<int> r;\\n        for(int i = 0; i < k; i++) r.insert(i);\\n        priority_queue<pair<int, int> > bsy;\\n        int Q = a.size();\\n        map<int, int> res;\\n        for(int i = 0; i < Q; i++) {\\n            int pos = i % k;\\n            int tim = a[i];\\n            int lod = b[i];\\n            while(!bsy.empty() && bsy.top().fi * -1 <= tim) {\\n                r.insert(bsy.top().se);\\n                bsy.pop();\\n            }\\n            if(r.empty()) continue;\\n            else {\\n                auto itr = r.lower_bound(pos);\\n                if(itr == r.end()) itr = r.begin();\\n                pos = *itr;\\n                r.erase(pos);\\n                res[pos] += 1;\\n                bsy.push(make_pair(-a[i] - b[i], pos));\\n            }\\n        }\\n        int mx = 0;\\n        for(auto it : res) {\\n            mx = max(mx, it.se);\\n        }\\n        vector<int> vec;\\n        for(auto it : res) {\\n            if(it.se == mx) vec.pb(it.fi);\\n        }\\n        return vec;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 876931,
                "title": "c-356ms-100-o-n-log-k-easy-segment-tree",
                "content": "Practice problem on CodeForces EDU - [https://codeforces.com/edu/course/2/lesson/4/2/practice/contest/273278/problem/D](http://)\\n\\nUsing time in -ve because it I already have above implemented Segment Tree and It\\'s easier for me to work with max queries.\\n\\n```\\nstatic auto speedup = []() {\\n    ios::sync_with_stdio(false);\\n    cin.tie(nullptr);\\n    cout.tie(nullptr);\\n    return nullptr;\\n}();\\n\\n\\nclass segtree{\\npublic:\\n    int n;\\n    vector<int> arr;\\n    bool q;\\n    int merge(int a, int b){\\n        return max(a, b);\\n    }\\n    \\n    segtree(int n){\\n        this->n=n;\\n        int x=1;\\n        while (x<n) x*=2;\\n        arr.assign(2*x, INT_MIN);\\n    }\\n    \\n    void build(vector<int>& v, int x, int left, int right){\\n        if (left+1==right){\\n            arr[x]=v[left];\\n            return;\\n        }\\n        int mid=left+(right-left)/2;\\n        build(v, 2*x+1, left, mid);\\n        build(v, 2*x+2, mid, right);\\n        arr[x]=merge(arr[2*x+1], arr[2*x+2]);\\n    }\\n    \\n    void build(vector<int>& v){\\n        build(v, 0, 0, n);\\n    };\\n    \\n    void set(int i, int val){\\n        set(i, val, 0, n, 0);\\n        return;\\n    }\\n    \\n    void set(int i, int val, int left, int right, int x){\\n        if (left+1==right) {\\n            arr[x]=val;\\n            return;\\n        }\\n        int mid=left+(right-left)/2;\\n        if (i<mid) set(i, val, left, mid, 2*x+1);\\n        else set(i, val, mid, right, 2*x+2);\\n        arr[x]=merge(arr[2*x+1], arr[2*x+2]);\\n        return;\\n    }\\n    int lbound(int l, int k){\\n        q=true;\\n        int rex=lbound(l, k, 0, 0, n);\\n        if (q) return -1;\\n        return rex;\\n    }\\n    \\n    int lbound(int l, int k, int x, int left, int right){\\n        if (left+1==right){\\n            q=false;\\n            return left;\\n        }\\n        int mid=left+(right-left)/2;\\n        int a, b;\\n        if (arr[2*x+1]>=k && l<mid) {\\n            a=lbound(l, k, 2*x+1, left, mid);\\n            if (!q) return a;\\n        }\\n        if (q && arr[2*x+2]>=k) return lbound(l, k, 2*x+2, mid, right);\\n        return -1;\\n    }\\n    \\n};\\n\\nclass Solution {\\npublic:\\n    vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n        vector<int> fr(k, 0);\\n        int n=arrival.size();\\n        vector<int> nums(k, 0);\\n        segtree st=segtree(k);\\n        st.build(nums);\\n        int y, z, maxfr;     // maxfr = current max frequency of any server\\n        for (int i=0; i<n; ++i){\\n            y=-arrival[i];                             // using -ve arrival time because time when server is free is also -ve\\n            z=st.lbound(i%k,  y);                // min indice z>=i%k such that nums[z]>=nums[i%k]\\n            if (z==-1) z=st.lbound(0, y);\\n            if (z!=-1){\\n                fr[z]++;\\n                maxfr=max(maxfr, fr[z]);\\n                st.set(z, y-load[i]);\\n            }\\n        }\\n        \\n        vector<int> ans;\\n        ans.reserve(k);\\n        for (int i=0; i<k; ++i){\\n            if (fr[i]==maxfr){\\n                ans.push_back(i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nstatic auto speedup = []() {\\n    ios::sync_with_stdio(false);\\n    cin.tie(nullptr);\\n    cout.tie(nullptr);\\n    return nullptr;\\n}();\\n\\n\\nclass segtree{\\npublic:\\n    int n;\\n    vector<int> arr;\\n    bool q;\\n    int merge(int a, int b){\\n        return max(a, b);\\n    }\\n    \\n    segtree(int n){\\n        this->n=n;\\n        int x=1;\\n        while (x<n) x*=2;\\n        arr.assign(2*x, INT_MIN);\\n    }\\n    \\n    void build(vector<int>& v, int x, int left, int right){\\n        if (left+1==right){\\n            arr[x]=v[left];\\n            return;\\n        }\\n        int mid=left+(right-left)/2;\\n        build(v, 2*x+1, left, mid);\\n        build(v, 2*x+2, mid, right);\\n        arr[x]=merge(arr[2*x+1], arr[2*x+2]);\\n    }\\n    \\n    void build(vector<int>& v){\\n        build(v, 0, 0, n);\\n    };\\n    \\n    void set(int i, int val){\\n        set(i, val, 0, n, 0);\\n        return;\\n    }\\n    \\n    void set(int i, int val, int left, int right, int x){\\n        if (left+1==right) {\\n            arr[x]=val;\\n            return;\\n        }\\n        int mid=left+(right-left)/2;\\n        if (i<mid) set(i, val, left, mid, 2*x+1);\\n        else set(i, val, mid, right, 2*x+2);\\n        arr[x]=merge(arr[2*x+1], arr[2*x+2]);\\n        return;\\n    }\\n    int lbound(int l, int k){\\n        q=true;\\n        int rex=lbound(l, k, 0, 0, n);\\n        if (q) return -1;\\n        return rex;\\n    }\\n    \\n    int lbound(int l, int k, int x, int left, int right){\\n        if (left+1==right){\\n            q=false;\\n            return left;\\n        }\\n        int mid=left+(right-left)/2;\\n        int a, b;\\n        if (arr[2*x+1]>=k && l<mid) {\\n            a=lbound(l, k, 2*x+1, left, mid);\\n            if (!q) return a;\\n        }\\n        if (q && arr[2*x+2]>=k) return lbound(l, k, 2*x+2, mid, right);\\n        return -1;\\n    }\\n    \\n};\\n\\nclass Solution {\\npublic:\\n    vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n        vector<int> fr(k, 0);\\n        int n=arrival.size();\\n        vector<int> nums(k, 0);\\n        segtree st=segtree(k);\\n        st.build(nums);\\n        int y, z, maxfr;     // maxfr = current max frequency of any server\\n        for (int i=0; i<n; ++i){\\n            y=-arrival[i];                             // using -ve arrival time because time when server is free is also -ve\\n            z=st.lbound(i%k,  y);                // min indice z>=i%k such that nums[z]>=nums[i%k]\\n            if (z==-1) z=st.lbound(0, y);\\n            if (z!=-1){\\n                fr[z]++;\\n                maxfr=max(maxfr, fr[z]);\\n                st.set(z, y-load[i]);\\n            }\\n        }\\n        \\n        vector<int> ans;\\n        ans.reserve(k);\\n        for (int i=0; i<k; ++i){\\n            if (fr[i]==maxfr){\\n                ans.push_back(i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 876912,
                "title": "java-o-nk-103-108-test-cases-passed",
                "content": "```\\nclass Solution {\\n    public List<Integer> busiestServers(int k, int[] arrival, int[] load) {\\n        List<Integer> out = new ArrayList<>();\\n        Map<Integer, Node> map = new HashMap<>();\\n        \\n        for (int i=0;i<arrival.length;i++) {\\n            int server = i%k;\\n            if (!map.containsKey(server)) {\\n                map.put(server, new Node(arrival[i],load[i],1));\\n            } else {\\n                int origServer = server;\\n                boolean flag = false;\\n                while(map.get(server)!=null && map.get(server).start+map.get(server).load>arrival[i]) {\\n                    server = (server+1)%k;\\n                    if (server == origServer) {\\n                        flag = true;\\n                        break;\\n                    }\\n                }\\n                if (!flag) {\\n                    int cnt = map.get(server).cnt;\\n                     map.put(server, new Node(arrival[i],load[i], cnt+1));\\n                }\\n            }\\n        }\\n        int busy = -1;\\n        for (Map.Entry<Integer, Node> e: map.entrySet()) {\\n            busy = Math.max(busy, e.getValue().cnt);\\n        }\\n        \\n        for (Map.Entry<Integer, Node> e: map.entrySet()) {\\n            if (busy == e.getValue().cnt)\\n                out.add(e.getKey());\\n        }\\n        \\n        return out;\\n    }\\n}\\nclass Node {\\n    int start;\\n    int load;\\n    int cnt;\\n    public Node(int start, int load, int cnt) {\\n        this.start = start;\\n        this.load = load;\\n        this.cnt = cnt;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> busiestServers(int k, int[] arrival, int[] load) {\\n        List<Integer> out = new ArrayList<>();\\n        Map<Integer, Node> map = new HashMap<>();\\n        \\n        for (int i=0;i<arrival.length;i++) {\\n            int server = i%k;\\n            if (!map.containsKey(server)) {\\n                map.put(server, new Node(arrival[i],load[i],1));\\n            } else {\\n                int origServer = server;\\n                boolean flag = false;\\n                while(map.get(server)!=null && map.get(server).start+map.get(server).load>arrival[i]) {\\n                    server = (server+1)%k;\\n                    if (server == origServer) {\\n                        flag = true;\\n                        break;\\n                    }\\n                }\\n                if (!flag) {\\n                    int cnt = map.get(server).cnt;\\n                     map.put(server, new Node(arrival[i],load[i], cnt+1));\\n                }\\n            }\\n        }\\n        int busy = -1;\\n        for (Map.Entry<Integer, Node> e: map.entrySet()) {\\n            busy = Math.max(busy, e.getValue().cnt);\\n        }\\n        \\n        for (Map.Entry<Integer, Node> e: map.entrySet()) {\\n            if (busy == e.getValue().cnt)\\n                out.add(e.getKey());\\n        }\\n        \\n        return out;\\n    }\\n}\\nclass Node {\\n    int start;\\n    int load;\\n    int cnt;\\n    public Node(int start, int load, int cnt) {\\n        this.start = start;\\n        this.load = load;\\n        this.cnt = cnt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 876897,
                "title": "please-tell-me-why-my-java-oop-approach-fails-sample-cases-passed",
                "content": "```\\nclass Solution {\\n    \\n    List<Server> servers = new ArrayList();\\n    int k;\\n    \\n    public List<Integer> busiestServers(int k, int[] arrival, int[] load) {\\n        this.k = k;\\n        \\n        for (int i = 0; i < k; i++) {\\n            servers.add(new Server(i));\\n        }\\n        \\n        int last = arrival[0];\\n        for (int i = 0; i < arrival.length; i++) {\\n            if (i == 0) {\\n                addLoad(i, load[i]);\\n            } else {\\n                incrementAll(arrival[i] - last);\\n                last = arrival[i];\\n                addLoad(i, load[i]);\\n            }\\n        }\\n        \\n        printAll();\\n        \\n        return getBusiest();\\n    }\\n    \\n    List<Integer> getBusiest() {\\n        int max = Integer.MIN_VALUE;\\n        \\n        for (Server s : servers) {\\n            max = Math.max(max, s.count);\\n        }\\n        \\n        List<Integer> list = new ArrayList();\\n        \\n        for (Server s : servers) {\\n            if (s.count == max) {\\n                list.add(s.index);\\n            }\\n        }\\n        \\n        return list;\\n    }\\n    \\n    void incrementAll(int times) {\\n        for (Server s : servers) {\\n            s.increment(times);\\n        }\\n    }\\n    \\n    void addLoad(int index, int load) {\\n        if (servers.get(index % k).isIdle()) {\\n            servers.get(index % k).addLoad(load);\\n            return;\\n        }\\n        \\n        for (Server s : servers) {\\n            if (s.isIdle()) {\\n                s.addLoad(load);\\n                break;\\n            }\\n        }\\n    }\\n    \\n    void printAll() {\\n        System.out.println(servers.toString());\\n    }\\n    \\n    class Server {\\n        int index;\\n        int load;\\n        int count;\\n        \\n        Server(int index) {\\n            this.index = index;\\n        }\\n        \\n        boolean isIdle() {\\n            return load == 0;\\n        }\\n        \\n        void addLoad(int load) {\\n            this.load = load;\\n            count++;\\n        }\\n        \\n        void increment(int times) {\\n            load = Math.max(0, load - times);\\n        }\\n        \\n        @Override\\n        public String toString() {\\n            return String.format(\"%d, count=%d\", index, count);\\n        }\\n    }\\n}\\n```\\n\\nSomehow it fails on this input\\n```\\n7\\n[1,3,4,5,6,11,12,13,15,19,20,21,23,25,31,32]\\n[9,16,14,1,5,15,6,10,1,1,7,5,11,4,4,6]\\n\\nOutput:\\n[0,2,3]\\nExpected:\\n[0]\\nStdout:\\n[0, count=3, 1, count=2, 2, count=3, 3, count=3, 4, count=2, 5, count=1, 6, count=2]\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    List<Server> servers = new ArrayList();\\n    int k;\\n    \\n    public List<Integer> busiestServers(int k, int[] arrival, int[] load) {\\n        this.k = k;\\n        \\n        for (int i = 0; i < k; i++) {\\n            servers.add(new Server(i));\\n        }\\n        \\n        int last = arrival[0];\\n        for (int i = 0; i < arrival.length; i++) {\\n            if (i == 0) {\\n                addLoad(i, load[i]);\\n            } else {\\n                incrementAll(arrival[i] - last);\\n                last = arrival[i];\\n                addLoad(i, load[i]);\\n            }\\n        }\\n        \\n        printAll();\\n        \\n        return getBusiest();\\n    }\\n    \\n    List<Integer> getBusiest() {\\n        int max = Integer.MIN_VALUE;\\n        \\n        for (Server s : servers) {\\n            max = Math.max(max, s.count);\\n        }\\n        \\n        List<Integer> list = new ArrayList();\\n        \\n        for (Server s : servers) {\\n            if (s.count == max) {\\n                list.add(s.index);\\n            }\\n        }\\n        \\n        return list;\\n    }\\n    \\n    void incrementAll(int times) {\\n        for (Server s : servers) {\\n            s.increment(times);\\n        }\\n    }\\n    \\n    void addLoad(int index, int load) {\\n        if (servers.get(index % k).isIdle()) {\\n            servers.get(index % k).addLoad(load);\\n            return;\\n        }\\n        \\n        for (Server s : servers) {\\n            if (s.isIdle()) {\\n                s.addLoad(load);\\n                break;\\n            }\\n        }\\n    }\\n    \\n    void printAll() {\\n        System.out.println(servers.toString());\\n    }\\n    \\n    class Server {\\n        int index;\\n        int load;\\n        int count;\\n        \\n        Server(int index) {\\n            this.index = index;\\n        }\\n        \\n        boolean isIdle() {\\n            return load == 0;\\n        }\\n        \\n        void addLoad(int load) {\\n            this.load = load;\\n            count++;\\n        }\\n        \\n        void increment(int times) {\\n            load = Math.max(0, load - times);\\n        }\\n        \\n        @Override\\n        public String toString() {\\n            return String.format(\"%d, count=%d\", index, count);\\n        }\\n    }\\n}\\n```\n```\\n7\\n[1,3,4,5,6,11,12,13,15,19,20,21,23,25,31,32]\\n[9,16,14,1,5,15,6,10,1,1,7,5,11,4,4,6]\\n\\nOutput:\\n[0,2,3]\\nExpected:\\n[0]\\nStdout:\\n[0, count=3, 1, count=2, 2, count=3, 3, count=3, 4, count=2, 5, count=1, 6, count=2]\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1567081,
                "content": [
                    {
                        "username": "potpie",
                        "content": "Input: k = 3, arrival = [1,2,3,4,8,9,10], load = [5,2,10,3,1,2,2]\\nOutput: [1]\\n\\nWhy not output is [0, 1]?\\n\\nServers that will handle each request are as follows:\\n0 1 2 1 0 1 0"
                    },
                    {
                        "username": "densestvoid",
                        "content": "I\\'m guessing you did the same thing I initially did, which is track the last server that processed a request and try the next one. The description specifically says for the ith request, try to assign it to the i%kth server, and then try i+1, i+2... So the servers that should handle each request is as follows: 0 1 2 1 1 0 1"
                    },
                    {
                        "username": "U_U",
                        "content": "Recently, I feel it\\'s easy to get TLE using C++ for any problem with the solution NlogN( n is around 10^5). \\nYou have to pay attention to the implementatoin.\\n\\nFor example, this question:\\nusing \\npriority_queue<pair<int, int64_t>, vector<pair<int, int64_t>>, Comparator> Q is certainly faster than\\npriority_queue<vector<int64_t>,   vector<int64_t>, Comparator> Q;\\nBut it  shouldn\\'t be the key to solve this question. \\n\\nMaybe leetcode should change data range to 2 * 10^4 for this kind of problem?\\nI don\\'t have the similar problem on other platforms. Some other platforms offer 2 seconds for 10^5 for C++.\\nI am talking about several questions in last 6 months. \\n\\nAnyone feels the same?\\nSure, if the solution is expect to be the segment tree, that would be another story."
                    },
                    {
                        "username": "SigmaCoder106",
                        "content": "A bit simpler version of  [2402. Meeting Rooms III](https://leetcode.com/problems/meeting-rooms-iii/)\\n\\n> Take care of Integer Overflow!\\n> Think about how you can optimize the process of finding the next available server! ;)"
                    },
                    {
                        "username": "spravinkumar9952",
                        "content": "Why  `lower_bound(available.begin(), available.end())` gives TLE but  `available.lower_bound(i%k)` got Accepted ?\\n\\n`lower_bound(available.begin(), available.end())`  => TLE\\n```\\nclass Solution {\\npublic:\\n    vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n        int N = arrival.size();\\n\\n        priority_queue<pair<int, int> , vector<pair<int, int>>, greater<>> pq;\\n        set<int> available;\\n        \\n        for(int i=0; i<k; i++){\\n            available.insert(i);\\n        }\\n\\n        vector<int> count(k);\\n        \\n        for(int i=0; i<N; i++){\\n            int start = arrival[i], end = load[i];\\n            \\n            while(!pq.empty() && pq.top().first <= start){\\n                available.insert(pq.top().second);\\n                pq.pop();\\n            }\\n\\n            if(available.size()==0)\\n                continue;\\n\\n            auto it = lower_bound(available.begin(), available.end());\\n            int ind = 0;\\n            if(it==available.end())\\n                ind = *available.begin();\\n            else \\n                ind = *it;\\n\\n            available.erase(ind);\\n            pq.emplace(start+end, ind);\\n            count[ind]++;\\n        }\\n\\n        vector<int> ans;\\n        int mx = *max_element(count.begin(), count.end());\\n        for(int i=0; i<k; i++){\\n            if(count[i]==mx){\\n                ans.push_back(i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n`available.lower_bound(i%k)` => Accepted \\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n        int N = arrival.size();\\n\\n        priority_queue<pair<int, int> , vector<pair<int, int>>, greater<>> pq;\\n        set<int> available;\\n        \\n        for(int i=0; i<k; i++){\\n            available.insert(i);\\n        }\\n\\n        vector<int> count(k);\\n        \\n        for(int i=0; i<N; i++){\\n            int start = arrival[i], end = load[i];\\n            \\n            while(!pq.empty() && pq.top().first <= start){\\n                available.insert(pq.top().second);\\n                pq.pop();\\n            }\\n\\n            if(available.size()==0)\\n                continue;\\n\\n            auto it = available.lower_bound(i%k);\\n            int ind = 0;\\n            if(it==available.end())\\n                ind = *available.begin();\\n            else \\n                ind = *it;\\n\\n            available.erase(ind);\\n            pq.emplace(start+end, ind);\\n            count[ind]++;\\n        }\\n\\n        vector<int> ans;\\n        int mx = *max_element(count.begin(), count.end());\\n        for(int i=0; i<k; i++){\\n            if(count[i]==mx){\\n                ans.push_back(i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nCan any one explain me why this happens ? "
                    }
                ]
            },
            {
                "id": 1570188,
                "content": [
                    {
                        "username": "potpie",
                        "content": "Input: k = 3, arrival = [1,2,3,4,8,9,10], load = [5,2,10,3,1,2,2]\\nOutput: [1]\\n\\nWhy not output is [0, 1]?\\n\\nServers that will handle each request are as follows:\\n0 1 2 1 0 1 0"
                    },
                    {
                        "username": "densestvoid",
                        "content": "I\\'m guessing you did the same thing I initially did, which is track the last server that processed a request and try the next one. The description specifically says for the ith request, try to assign it to the i%kth server, and then try i+1, i+2... So the servers that should handle each request is as follows: 0 1 2 1 1 0 1"
                    },
                    {
                        "username": "U_U",
                        "content": "Recently, I feel it\\'s easy to get TLE using C++ for any problem with the solution NlogN( n is around 10^5). \\nYou have to pay attention to the implementatoin.\\n\\nFor example, this question:\\nusing \\npriority_queue<pair<int, int64_t>, vector<pair<int, int64_t>>, Comparator> Q is certainly faster than\\npriority_queue<vector<int64_t>,   vector<int64_t>, Comparator> Q;\\nBut it  shouldn\\'t be the key to solve this question. \\n\\nMaybe leetcode should change data range to 2 * 10^4 for this kind of problem?\\nI don\\'t have the similar problem on other platforms. Some other platforms offer 2 seconds for 10^5 for C++.\\nI am talking about several questions in last 6 months. \\n\\nAnyone feels the same?\\nSure, if the solution is expect to be the segment tree, that would be another story."
                    },
                    {
                        "username": "SigmaCoder106",
                        "content": "A bit simpler version of  [2402. Meeting Rooms III](https://leetcode.com/problems/meeting-rooms-iii/)\\n\\n> Take care of Integer Overflow!\\n> Think about how you can optimize the process of finding the next available server! ;)"
                    },
                    {
                        "username": "spravinkumar9952",
                        "content": "Why  `lower_bound(available.begin(), available.end())` gives TLE but  `available.lower_bound(i%k)` got Accepted ?\\n\\n`lower_bound(available.begin(), available.end())`  => TLE\\n```\\nclass Solution {\\npublic:\\n    vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n        int N = arrival.size();\\n\\n        priority_queue<pair<int, int> , vector<pair<int, int>>, greater<>> pq;\\n        set<int> available;\\n        \\n        for(int i=0; i<k; i++){\\n            available.insert(i);\\n        }\\n\\n        vector<int> count(k);\\n        \\n        for(int i=0; i<N; i++){\\n            int start = arrival[i], end = load[i];\\n            \\n            while(!pq.empty() && pq.top().first <= start){\\n                available.insert(pq.top().second);\\n                pq.pop();\\n            }\\n\\n            if(available.size()==0)\\n                continue;\\n\\n            auto it = lower_bound(available.begin(), available.end());\\n            int ind = 0;\\n            if(it==available.end())\\n                ind = *available.begin();\\n            else \\n                ind = *it;\\n\\n            available.erase(ind);\\n            pq.emplace(start+end, ind);\\n            count[ind]++;\\n        }\\n\\n        vector<int> ans;\\n        int mx = *max_element(count.begin(), count.end());\\n        for(int i=0; i<k; i++){\\n            if(count[i]==mx){\\n                ans.push_back(i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n`available.lower_bound(i%k)` => Accepted \\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n        int N = arrival.size();\\n\\n        priority_queue<pair<int, int> , vector<pair<int, int>>, greater<>> pq;\\n        set<int> available;\\n        \\n        for(int i=0; i<k; i++){\\n            available.insert(i);\\n        }\\n\\n        vector<int> count(k);\\n        \\n        for(int i=0; i<N; i++){\\n            int start = arrival[i], end = load[i];\\n            \\n            while(!pq.empty() && pq.top().first <= start){\\n                available.insert(pq.top().second);\\n                pq.pop();\\n            }\\n\\n            if(available.size()==0)\\n                continue;\\n\\n            auto it = available.lower_bound(i%k);\\n            int ind = 0;\\n            if(it==available.end())\\n                ind = *available.begin();\\n            else \\n                ind = *it;\\n\\n            available.erase(ind);\\n            pq.emplace(start+end, ind);\\n            count[ind]++;\\n        }\\n\\n        vector<int> ans;\\n        int mx = *max_element(count.begin(), count.end());\\n        for(int i=0; i<k; i++){\\n            if(count[i]==mx){\\n                ans.push_back(i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nCan any one explain me why this happens ? "
                    }
                ]
            },
            {
                "id": 1931671,
                "content": [
                    {
                        "username": "potpie",
                        "content": "Input: k = 3, arrival = [1,2,3,4,8,9,10], load = [5,2,10,3,1,2,2]\\nOutput: [1]\\n\\nWhy not output is [0, 1]?\\n\\nServers that will handle each request are as follows:\\n0 1 2 1 0 1 0"
                    },
                    {
                        "username": "densestvoid",
                        "content": "I\\'m guessing you did the same thing I initially did, which is track the last server that processed a request and try the next one. The description specifically says for the ith request, try to assign it to the i%kth server, and then try i+1, i+2... So the servers that should handle each request is as follows: 0 1 2 1 1 0 1"
                    },
                    {
                        "username": "U_U",
                        "content": "Recently, I feel it\\'s easy to get TLE using C++ for any problem with the solution NlogN( n is around 10^5). \\nYou have to pay attention to the implementatoin.\\n\\nFor example, this question:\\nusing \\npriority_queue<pair<int, int64_t>, vector<pair<int, int64_t>>, Comparator> Q is certainly faster than\\npriority_queue<vector<int64_t>,   vector<int64_t>, Comparator> Q;\\nBut it  shouldn\\'t be the key to solve this question. \\n\\nMaybe leetcode should change data range to 2 * 10^4 for this kind of problem?\\nI don\\'t have the similar problem on other platforms. Some other platforms offer 2 seconds for 10^5 for C++.\\nI am talking about several questions in last 6 months. \\n\\nAnyone feels the same?\\nSure, if the solution is expect to be the segment tree, that would be another story."
                    },
                    {
                        "username": "SigmaCoder106",
                        "content": "A bit simpler version of  [2402. Meeting Rooms III](https://leetcode.com/problems/meeting-rooms-iii/)\\n\\n> Take care of Integer Overflow!\\n> Think about how you can optimize the process of finding the next available server! ;)"
                    },
                    {
                        "username": "spravinkumar9952",
                        "content": "Why  `lower_bound(available.begin(), available.end())` gives TLE but  `available.lower_bound(i%k)` got Accepted ?\\n\\n`lower_bound(available.begin(), available.end())`  => TLE\\n```\\nclass Solution {\\npublic:\\n    vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n        int N = arrival.size();\\n\\n        priority_queue<pair<int, int> , vector<pair<int, int>>, greater<>> pq;\\n        set<int> available;\\n        \\n        for(int i=0; i<k; i++){\\n            available.insert(i);\\n        }\\n\\n        vector<int> count(k);\\n        \\n        for(int i=0; i<N; i++){\\n            int start = arrival[i], end = load[i];\\n            \\n            while(!pq.empty() && pq.top().first <= start){\\n                available.insert(pq.top().second);\\n                pq.pop();\\n            }\\n\\n            if(available.size()==0)\\n                continue;\\n\\n            auto it = lower_bound(available.begin(), available.end());\\n            int ind = 0;\\n            if(it==available.end())\\n                ind = *available.begin();\\n            else \\n                ind = *it;\\n\\n            available.erase(ind);\\n            pq.emplace(start+end, ind);\\n            count[ind]++;\\n        }\\n\\n        vector<int> ans;\\n        int mx = *max_element(count.begin(), count.end());\\n        for(int i=0; i<k; i++){\\n            if(count[i]==mx){\\n                ans.push_back(i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n`available.lower_bound(i%k)` => Accepted \\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n        int N = arrival.size();\\n\\n        priority_queue<pair<int, int> , vector<pair<int, int>>, greater<>> pq;\\n        set<int> available;\\n        \\n        for(int i=0; i<k; i++){\\n            available.insert(i);\\n        }\\n\\n        vector<int> count(k);\\n        \\n        for(int i=0; i<N; i++){\\n            int start = arrival[i], end = load[i];\\n            \\n            while(!pq.empty() && pq.top().first <= start){\\n                available.insert(pq.top().second);\\n                pq.pop();\\n            }\\n\\n            if(available.size()==0)\\n                continue;\\n\\n            auto it = available.lower_bound(i%k);\\n            int ind = 0;\\n            if(it==available.end())\\n                ind = *available.begin();\\n            else \\n                ind = *it;\\n\\n            available.erase(ind);\\n            pq.emplace(start+end, ind);\\n            count[ind]++;\\n        }\\n\\n        vector<int> ans;\\n        int mx = *max_element(count.begin(), count.end());\\n        for(int i=0; i<k; i++){\\n            if(count[i]==mx){\\n                ans.push_back(i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nCan any one explain me why this happens ? "
                    }
                ]
            },
            {
                "id": 1677199,
                "content": [
                    {
                        "username": "potpie",
                        "content": "Input: k = 3, arrival = [1,2,3,4,8,9,10], load = [5,2,10,3,1,2,2]\\nOutput: [1]\\n\\nWhy not output is [0, 1]?\\n\\nServers that will handle each request are as follows:\\n0 1 2 1 0 1 0"
                    },
                    {
                        "username": "densestvoid",
                        "content": "I\\'m guessing you did the same thing I initially did, which is track the last server that processed a request and try the next one. The description specifically says for the ith request, try to assign it to the i%kth server, and then try i+1, i+2... So the servers that should handle each request is as follows: 0 1 2 1 1 0 1"
                    },
                    {
                        "username": "U_U",
                        "content": "Recently, I feel it\\'s easy to get TLE using C++ for any problem with the solution NlogN( n is around 10^5). \\nYou have to pay attention to the implementatoin.\\n\\nFor example, this question:\\nusing \\npriority_queue<pair<int, int64_t>, vector<pair<int, int64_t>>, Comparator> Q is certainly faster than\\npriority_queue<vector<int64_t>,   vector<int64_t>, Comparator> Q;\\nBut it  shouldn\\'t be the key to solve this question. \\n\\nMaybe leetcode should change data range to 2 * 10^4 for this kind of problem?\\nI don\\'t have the similar problem on other platforms. Some other platforms offer 2 seconds for 10^5 for C++.\\nI am talking about several questions in last 6 months. \\n\\nAnyone feels the same?\\nSure, if the solution is expect to be the segment tree, that would be another story."
                    },
                    {
                        "username": "SigmaCoder106",
                        "content": "A bit simpler version of  [2402. Meeting Rooms III](https://leetcode.com/problems/meeting-rooms-iii/)\\n\\n> Take care of Integer Overflow!\\n> Think about how you can optimize the process of finding the next available server! ;)"
                    },
                    {
                        "username": "spravinkumar9952",
                        "content": "Why  `lower_bound(available.begin(), available.end())` gives TLE but  `available.lower_bound(i%k)` got Accepted ?\\n\\n`lower_bound(available.begin(), available.end())`  => TLE\\n```\\nclass Solution {\\npublic:\\n    vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n        int N = arrival.size();\\n\\n        priority_queue<pair<int, int> , vector<pair<int, int>>, greater<>> pq;\\n        set<int> available;\\n        \\n        for(int i=0; i<k; i++){\\n            available.insert(i);\\n        }\\n\\n        vector<int> count(k);\\n        \\n        for(int i=0; i<N; i++){\\n            int start = arrival[i], end = load[i];\\n            \\n            while(!pq.empty() && pq.top().first <= start){\\n                available.insert(pq.top().second);\\n                pq.pop();\\n            }\\n\\n            if(available.size()==0)\\n                continue;\\n\\n            auto it = lower_bound(available.begin(), available.end());\\n            int ind = 0;\\n            if(it==available.end())\\n                ind = *available.begin();\\n            else \\n                ind = *it;\\n\\n            available.erase(ind);\\n            pq.emplace(start+end, ind);\\n            count[ind]++;\\n        }\\n\\n        vector<int> ans;\\n        int mx = *max_element(count.begin(), count.end());\\n        for(int i=0; i<k; i++){\\n            if(count[i]==mx){\\n                ans.push_back(i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n`available.lower_bound(i%k)` => Accepted \\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> busiestServers(int k, vector<int>& arrival, vector<int>& load) {\\n        int N = arrival.size();\\n\\n        priority_queue<pair<int, int> , vector<pair<int, int>>, greater<>> pq;\\n        set<int> available;\\n        \\n        for(int i=0; i<k; i++){\\n            available.insert(i);\\n        }\\n\\n        vector<int> count(k);\\n        \\n        for(int i=0; i<N; i++){\\n            int start = arrival[i], end = load[i];\\n            \\n            while(!pq.empty() && pq.top().first <= start){\\n                available.insert(pq.top().second);\\n                pq.pop();\\n            }\\n\\n            if(available.size()==0)\\n                continue;\\n\\n            auto it = available.lower_bound(i%k);\\n            int ind = 0;\\n            if(it==available.end())\\n                ind = *available.begin();\\n            else \\n                ind = *it;\\n\\n            available.erase(ind);\\n            pq.emplace(start+end, ind);\\n            count[ind]++;\\n        }\\n\\n        vector<int> ans;\\n        int mx = *max_element(count.begin(), count.end());\\n        for(int i=0; i<k; i++){\\n            if(count[i]==mx){\\n                ans.push_back(i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nCan any one explain me why this happens ? "
                    }
                ]
            }
        ]
    }
]