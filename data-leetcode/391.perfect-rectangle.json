[
    {
        "title": "Perfect Rectangle",
        "question_content": "Given an array rectangles where rectangles[i] = [xi, yi, ai, bi] represents an axis-aligned rectangle. The bottom-left point of the rectangle is (xi, yi) and the top-right point of it is (ai, bi).\nReturn true if all the rectangles together form an exact cover of a rectangular region.\n&nbsp;\nExample 1:\n\nInput: rectangles = [[1,1,3,3],[3,1,4,2],[3,2,4,4],[1,3,2,4],[2,3,3,4]]\nOutput: true\nExplanation: All 5 rectangles together form an exact cover of a rectangular region.\n\nExample 2:\n\nInput: rectangles = [[1,1,2,3],[1,3,2,4],[3,1,4,2],[3,2,4,4]]\nOutput: false\nExplanation: Because there is a gap between the two rectangular regions.\n\nExample 3:\n\nInput: rectangles = [[1,1,3,3],[3,1,4,2],[1,3,2,4],[2,2,4,4]]\nOutput: false\nExplanation: Because two of the rectangles overlap with each other.\n\n&nbsp;\nConstraints:\n\n\t1 <= rectangles.length <= 2 * 104\n\trectangles[i].length == 4\n\t-105 <= xi, yi, ai, bi <= 105",
        "solutions": [
            {
                "id": 87181,
                "title": "really-easy-understanding-solution-o-n-java",
                "content": "The right answer must satisfy two conditions:\\n1. the large rectangle area should be equal to the sum of small rectangles\\n2. count of all the points should be even, and that of all the four corner points should be one\\n\\n```\\npublic boolean isRectangleCover(int[][] rectangles) {\\n\\n        if (rectangles.length == 0 || rectangles[0].length == 0) return false;\\n\\n        int x1 = Integer.MAX_VALUE;\\n        int x2 = Integer.MIN_VALUE;\\n        int y1 = Integer.MAX_VALUE;\\n        int y2 = Integer.MIN_VALUE;\\n        \\n        HashSet<String> set = new HashSet<String>();\\n        int area = 0;\\n        \\n        for (int[] rect : rectangles) {\\n            x1 = Math.min(rect[0], x1);\\n            y1 = Math.min(rect[1], y1);\\n            x2 = Math.max(rect[2], x2);\\n            y2 = Math.max(rect[3], y2);\\n            \\n            area += (rect[2] - rect[0]) * (rect[3] - rect[1]);\\n            \\n            String s1 = rect[0] + \" \" + rect[1];\\n            String s2 = rect[0] + \" \" + rect[3];\\n            String s3 = rect[2] + \" \" + rect[3];\\n            String s4 = rect[2] + \" \" + rect[1];\\n            \\n            if (!set.add(s1)) set.remove(s1);\\n            if (!set.add(s2)) set.remove(s2);\\n            if (!set.add(s3)) set.remove(s3);\\n            if (!set.add(s4)) set.remove(s4);\\n        }\\n        \\n        if (!set.contains(x1 + \" \" + y1) || !set.contains(x1 + \" \" + y2) || !set.contains(x2 + \" \" + y1) || !set.contains(x2 + \" \" + y2) || set.size() != 4) return false;\\n        \\n        return area == (x2-x1) * (y2-y1);\\n    }\\n````",
                "solutionTags": [],
                "code": "```\\npublic boolean isRectangleCover(int[][] rectangles) {\\n\\n        if (rectangles.length == 0 || rectangles[0].length == 0) return false;\\n\\n        int x1 = Integer.MAX_VALUE;\\n        int x2 = Integer.MIN_VALUE;\\n        int y1 = Integer.MAX_VALUE;\\n        int y2 = Integer.MIN_VALUE;\\n        \\n        HashSet<String> set = new HashSet<String>();\\n        int area = 0;\\n        \\n        for (int[] rect : rectangles) {\\n            x1 = Math.min(rect[0], x1);\\n            y1 = Math.min(rect[1], y1);\\n            x2 = Math.max(rect[2], x2);\\n            y2 = Math.max(rect[3], y2);\\n            \\n            area += (rect[2] - rect[0]) * (rect[3] - rect[1]);\\n            \\n            String s1 = rect[0] + \" \" + rect[1];\\n            String s2 = rect[0] + \" \" + rect[3];\\n            String s3 = rect[2] + \" \" + rect[3];\\n            String s4 = rect[2] + \" \" + rect[1];\\n            \\n            if (!set.add(s1)) set.remove(s1);\\n            if (!set.add(s2)) set.remove(s2);\\n            if (!set.add(s3)) set.remove(s3);\\n            if (!set.add(s4)) set.remove(s4);\\n        }\\n        \\n        if (!set.contains(x1 + \" \" + y1) || !set.contains(x1 + \" \" + y2) || !set.contains(x2 + \" \" + y1) || !set.contains(x2 + \" \" + y2) || set.size() != 4) return false;\\n        \\n        return area == (x2-x1) * (y2-y1);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 87180,
                "title": "o-n-solution-by-counting-corners-with-detailed-explaination",
                "content": "This is an expanded version of [my earlier post](https://discuss.leetcode.com/topic/55874/o-log-n-problem-2-and-o-n-problem-3-solution/3) under the contest discussion board.\\nThe following code passes through not only the OJ but also various test cases others have pointed out.\\n\\n#### Idea\\n![0_1472399247817_perfect_rectangle.jpg](/uploads/files/1472399247905-perfect_rectangle.jpg) \\n\\nConsider how the corners of all rectangles appear in the large rectangle if there's a perfect rectangular cover.\\n**Rule 1:** The local shape of the corner has to follow one of the three following patterns\\n* Corner of the large rectangle (blue): it occurs only once among all rectangles\\n* T-junctions (green): it occurs twice among all rectangles\\n* Cross (red): it occurs four times among all rectangles\\n\\n**Rule 2:** A point can only be the top-left corner of at most one sub-rectangle. Similarly it can be the top-right/bottom-left/bottom-right corner of  at most one sub-rectangle. Otherwise overlaps occur.\\n\\n#### Proof of correctness\\nObviously, any perfect cover satisfies the above rules. So the main question is whether there exists an input which satisfy the above rules, yet does not compose a rectangle.\\n\\nFirst, ***any overlap is not allowed based on the above rules*** because\\n- aligned overlap like [[0, 0, 1, 1], [0, 0, 2, 2]] are rejected by Rule 2.\\n- unaligned overlap will generate a corner in the interior of another sub-rectangle, so it will be rejected by Rule 1.\\n\\nSecond, consider the shape of boundary for the combined shape. The cross pattern does not create boundary. The corner pattern generates a straight angle on the boundary, and the T-junction generates a straight border. \\n***So the shape of the union of rectangles has to be rectangle(s).***\\n\\nFinally, if there are more than two non-overlapping rectangles, at least 8 corners will be found, and cannot be matched to the 4 bounding box corners (be reminded we have shown that there is no chance of overlapping). \\n***So the cover has to be a single rectangle*** if all above rules are satisfied.\\n\\n#### Algorithm\\n* **Step1:** Based on the above idea we maintain a mapping from (x, y)->mask by scanning the sub-rectangles from beginning to end. \\n    - (x, y) corresponds to corners of sub-rectangles\\n    - mask is a 4-bit binary mask. Each bit indicates whether there have been a sub-rectangle with a top-left/top-right/bottom-left/bottom-right corner at (x, y). If we see a conflict while updating mask, it suffice to return a false during the scan.\\n    - In the meantime we obtain the bounding box of all rectangles (which potentially be the rectangle cover) by getting the upper/lower bound of x/y values.\\n\\n* **Step 2:** Once the scan is done, we can just browse through the unordered_map to check the whether ***the mask corresponds to a T junction / cross, or corner if it is indeed a bounding box corner***.\\n(note: my earlier implementation uses counts of bits in mask to justify corners, and this would not work with certain cases as @StefanPochmann points out).\\n\\n#### Complexity\\nThe scan in step 1 is O(n) because it loop through rectangles and inside the loop it updates bounding box and unordered_map in O(1) time.\\n\\nStep2 visits 1 corner at a time with O(1) computations for at most 4n corners (actually much less because either corner overlap or early stopping occurs). So it's also O(n).\\n```\\n// pos encoding: 1 - TL 2- TR 4- BL 8-BR\\n// return false if a conflict in mask occurs (i.e. there used to be a rectangle with corner (x, y) at pos\\ninline bool insert_corner(unordered_map<int, unordered_map<int, int>>& corner_count, int x, int y, int pos) {\\n    int& m = corner_count[x][y];\\n    if (m & pos) return false;\\n    m |= pos;\\n    return true;\\n}\\n\\nbool isRectangleCover(vector<vector<int>>& rectangles) {\\n    // step 1: counting\\n    unordered_map<int, unordered_map<int, int>> corner_count;\\n    int minx = INT_MAX, maxx=INT_MIN, miny=INT_MAX, maxy=INT_MIN;\\n    for (auto& rect : rectangles) {\\n        minx = min(minx, rect[0]);\\n        maxx = max(maxx, rect[2]);\\n        miny = min(miny, rect[1]);\\n        maxy = max(maxy, rect[3]);\\n        if (!insert_corner(corner_count, rect[0], rect[1], 1)) return false;\\n        if (!insert_corner(corner_count, rect[2], rect[1], 2)) return false;\\n        if (!insert_corner(corner_count, rect[0], rect[3], 4)) return false;\\n        if (!insert_corner(corner_count, rect[2], rect[3], 8)) return false;\\n    }\\n    \\n    //step2: checking\\n    bool valid_corner[16] = {false};\\n    bool valid_interior[16] = {false};\\n    valid_corner[1] = valid_corner[2] = valid_corner[4] = valid_corner[8] = true;\\n    valid_interior[3] = valid_interior[5] = valid_interior[10] = valid_interior[12] = valid_interior[15] = true;\\n    \\n    for (auto itx = corner_count.begin(); itx != corner_count.end(); ++itx) {\\n        int x = itx->first;\\n        for (auto ity = itx->second.begin(); ity != itx->second.end(); ++ity) {\\n            int y = ity->first;\\n            int mask = ity->second;\\n            if (((x != minx && x != maxx) || (y != miny && y != maxy)) && !valid_interior[mask]) \\n                return false;\\n        }\\n    }\\n    return true;\\n}\\n```\\n\\nThe above code may be refined by changing the 2D unordered_map to 1D. But such improvements has no effect on complexity.\\n```\\nstruct pairhash {//double hash function for pair key\\npublic:\\n    template <typename T, typename U>\\n    size_t operator()(const pair<T, U> &rhs) const {\\n        size_t l = hash<T>()(rhs.first);\\n        size_t r = hash<U>()(rhs.second);\\n        return l + 0x9e3779b9 + (r << 6) + (r >> 2);\\n    }\\n};\\n\\nbool isRectangleCover(vector<vector<int>>& rectangles) {\\n    // step 1: counting\\n    unordered_map<pair<int, int>, int, pairhash> corner_count;\\n    int minx = INT_MAX, maxx=INT_MIN, miny=INT_MAX, maxy=INT_MIN;\\n    for (auto& rect : rectangles) {\\n        minx = min(minx, rect[0]);\\n        maxx = max(maxx, rect[2]);\\n        miny = min(miny, rect[1]);\\n        maxy = max(maxy, rect[3]);\\n        \\n        int& m1 = corner_count[make_pair(rect[0], rect[1])]; \\n        if (m1 & 1) return false; else m1 |= 1;\\n        int& m2 = corner_count[make_pair(rect[2], rect[1])];\\n        if (m2 & 2) return false; else m2 |= 2;\\n        int& m3 = corner_count[make_pair(rect[0], rect[3])]; \\n        if (m3 & 4) return false; else m3 |= 4;\\n        int& m4 = corner_count[make_pair(rect[2], rect[3])]; \\n        if (m4 & 8) return false; else m4 |= 8;\\n    }\\n    \\n    //step2: checking\\n    for (const auto& kv: corner_count) {\\n        pair<int, int> pos; int mask;\\n        tie(pos, mask) = kv;\\n        if ((pos.first != minx && pos.first != maxx) || (pos.second != miny && pos.second != maxy)) {\\n            if (mask != 3 && mask != 5 && mask != 10 && mask != 12 && mask != 15) return false;\\n        }\\n    }\\n    return true;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n// pos encoding: 1 - TL 2- TR 4- BL 8-BR\\n// return false if a conflict in mask occurs (i.e. there used to be a rectangle with corner (x, y) at pos\\ninline bool insert_corner(unordered_map<int, unordered_map<int, int>>& corner_count, int x, int y, int pos) {\\n    int& m = corner_count[x][y];\\n    if (m & pos) return false;\\n    m |= pos;\\n    return true;\\n}\\n\\nbool isRectangleCover(vector<vector<int>>& rectangles) {\\n    // step 1: counting\\n    unordered_map<int, unordered_map<int, int>> corner_count;\\n    int minx = INT_MAX, maxx=INT_MIN, miny=INT_MAX, maxy=INT_MIN;\\n    for (auto& rect : rectangles) {\\n        minx = min(minx, rect[0]);\\n        maxx = max(maxx, rect[2]);\\n        miny = min(miny, rect[1]);\\n        maxy = max(maxy, rect[3]);\\n        if (!insert_corner(corner_count, rect[0], rect[1], 1)) return false;\\n        if (!insert_corner(corner_count, rect[2], rect[1], 2)) return false;\\n        if (!insert_corner(corner_count, rect[0], rect[3], 4)) return false;\\n        if (!insert_corner(corner_count, rect[2], rect[3], 8)) return false;\\n    }\\n    \\n    //step2: checking\\n    bool valid_corner[16] = {false};\\n    bool valid_interior[16] = {false};\\n    valid_corner[1] = valid_corner[2] = valid_corner[4] = valid_corner[8] = true;\\n    valid_interior[3] = valid_interior[5] = valid_interior[10] = valid_interior[12] = valid_interior[15] = true;\\n    \\n    for (auto itx = corner_count.begin(); itx != corner_count.end(); ++itx) {\\n        int x = itx->first;\\n        for (auto ity = itx->second.begin(); ity != itx->second.end(); ++ity) {\\n            int y = ity->first;\\n            int mask = ity->second;\\n            if (((x != minx && x != maxx) || (y != miny && y != maxy)) && !valid_interior[mask]) \\n                return false;\\n        }\\n    }\\n    return true;\\n}\\n```\n```\\nstruct pairhash {//double hash function for pair key\\npublic:\\n    template <typename T, typename U>\\n    size_t operator()(const pair<T, U> &rhs) const {\\n        size_t l = hash<T>()(rhs.first);\\n        size_t r = hash<U>()(rhs.second);\\n        return l + 0x9e3779b9 + (r << 6) + (r >> 2);\\n    }\\n};\\n\\nbool isRectangleCover(vector<vector<int>>& rectangles) {\\n    // step 1: counting\\n    unordered_map<pair<int, int>, int, pairhash> corner_count;\\n    int minx = INT_MAX, maxx=INT_MIN, miny=INT_MAX, maxy=INT_MIN;\\n    for (auto& rect : rectangles) {\\n        minx = min(minx, rect[0]);\\n        maxx = max(maxx, rect[2]);\\n        miny = min(miny, rect[1]);\\n        maxy = max(maxy, rect[3]);\\n        \\n        int& m1 = corner_count[make_pair(rect[0], rect[1])]; \\n        if (m1 & 1) return false; else m1 |= 1;\\n        int& m2 = corner_count[make_pair(rect[2], rect[1])];\\n        if (m2 & 2) return false; else m2 |= 2;\\n        int& m3 = corner_count[make_pair(rect[0], rect[3])]; \\n        if (m3 & 4) return false; else m3 |= 4;\\n        int& m4 = corner_count[make_pair(rect[2], rect[3])]; \\n        if (m4 & 8) return false; else m4 |= 8;\\n    }\\n    \\n    //step2: checking\\n    for (const auto& kv: corner_count) {\\n        pair<int, int> pos; int mask;\\n        tie(pos, mask) = kv;\\n        if ((pos.first != minx && pos.first != maxx) || (pos.second != miny && pos.second != maxy)) {\\n            if (mask != 3 && mask != 5 && mask != 10 && mask != 12 && mask != 15) return false;\\n        }\\n    }\\n    return true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 87188,
                "title": "o-n-log-n-sweep-line-solution",
                "content": "Standard sweep line solution. \\nBasic idea:\\nSort by x-coordinate.\\nInsert y-interval into TreeSet, and check if there are intersections.\\nDelete y-interval.\\n\\n```\\npublic class Event implements Comparable<Event> {\\n\\tint time;\\n\\tint[] rect;\\n\\n\\tpublic Event(int time, int[] rect) {\\n\\t\\tthis.time = time;\\n\\t\\tthis.rect = rect;\\n\\t}\\n\\t\\n\\tpublic int compareTo(Event that) {\\n\\t\\tif (this.time != that.time) return this.time - that.time;\\n\\t\\telse return this.rect[0] - that.rect[0];\\n\\t}\\n}\\n\\npublic boolean isRectangleCover(int[][] rectangles) {\\n\\tPriorityQueue<Event> pq = new PriorityQueue<Event> ();\\n        // border of y-intervals\\n\\tint[] border= {Integer.MAX_VALUE, Integer.MIN_VALUE};\\n\\tfor (int[] rect : rectangles) {\\n\\t\\tEvent e1 = new Event(rect[0], rect);\\n\\t\\tEvent e2 = new Event(rect[2], rect);\\n\\t\\tpq.add(e1);\\n\\t\\tpq.add(e2);\\n\\t\\tif (rect[1] < border[0]) border[0] = rect[1];\\n\\t\\tif (rect[3] > border[1]) border[1] = rect[3];\\n\\t}\\n\\tTreeSet<int[]> set = new TreeSet<int[]> (new Comparator<int[]> () {\\n\\t\\t@Override\\n                // if two y-intervals intersects, return 0\\n\\t\\tpublic int compare (int[] rect1, int[] rect2) {\\n\\t\\t\\tif (rect1[3] <= rect2[1]) return -1;\\n\\t\\t\\telse if (rect2[3] <= rect1[1]) return 1;\\n\\t\\t\\telse return 0;\\n\\t\\t}\\n\\t});\\n\\tint yRange = 0;\\n\\twhile (!pq.isEmpty()) {\\n\\t\\tint time = pq.peek().time;\\n\\t\\twhile (!pq.isEmpty() && pq.peek().time == time) {\\n\\t\\t\\tEvent e = pq.poll();\\n\\t\\t\\tint[] rect = e.rect;\\n\\t\\t\\tif (time == rect[2]) {\\n\\t\\t\\t\\tset.remove(rect);\\n\\t\\t\\t\\tyRange -= rect[3] - rect[1];\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tif (!set.add(rect)) return false;\\n\\t\\t\\t\\tyRange += rect[3] - rect[1];\\n\\t\\t\\t}\\n\\t\\t}\\n                // check intervals' range\\n\\t\\tif (!pq.isEmpty() && yRange != border[1] - border[0]) {\\n                        return false;\\n\\t\\t\\t//if (set.isEmpty()) return false;\\n\\t\\t\\t//if (yRange != border[1] - border[0]) return false;\\n\\t\\t}\\n\\t}\\n\\treturn true;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Event implements Comparable<Event> {\\n\\tint time;\\n\\tint[] rect;\\n\\n\\tpublic Event(int time, int[] rect) {\\n\\t\\tthis.time = time;\\n\\t\\tthis.rect = rect;\\n\\t}\\n\\t\\n\\tpublic int compareTo(Event that) {\\n\\t\\tif (this.time != that.time) return this.time - that.time;\\n\\t\\telse return this.rect[0] - that.rect[0];\\n\\t}\\n}\\n\\npublic boolean isRectangleCover(int[][] rectangles) {\\n\\tPriorityQueue<Event> pq = new PriorityQueue<Event> ();\\n        // border of y-intervals\\n\\tint[] border= {Integer.MAX_VALUE, Integer.MIN_VALUE};\\n\\tfor (int[] rect : rectangles) {\\n\\t\\tEvent e1 = new Event(rect[0], rect);\\n\\t\\tEvent e2 = new Event(rect[2], rect);\\n\\t\\tpq.add(e1);\\n\\t\\tpq.add(e2);\\n\\t\\tif (rect[1] < border[0]) border[0] = rect[1];\\n\\t\\tif (rect[3] > border[1]) border[1] = rect[3];\\n\\t}\\n\\tTreeSet<int[]> set = new TreeSet<int[]> (new Comparator<int[]> () {\\n\\t\\t@Override\\n                // if two y-intervals intersects, return 0\\n\\t\\tpublic int compare (int[] rect1, int[] rect2) {\\n\\t\\t\\tif (rect1[3] <= rect2[1]) return -1;\\n\\t\\t\\telse if (rect2[3] <= rect1[1]) return 1;\\n\\t\\t\\telse return 0;\\n\\t\\t}\\n\\t});\\n\\tint yRange = 0;\\n\\twhile (!pq.isEmpty()) {\\n\\t\\tint time = pq.peek().time;\\n\\t\\twhile (!pq.isEmpty() && pq.peek().time == time) {\\n\\t\\t\\tEvent e = pq.poll();\\n\\t\\t\\tint[] rect = e.rect;\\n\\t\\t\\tif (time == rect[2]) {\\n\\t\\t\\t\\tset.remove(rect);\\n\\t\\t\\t\\tyRange -= rect[3] - rect[1];\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tif (!set.add(rect)) return false;\\n\\t\\t\\t\\tyRange += rect[3] - rect[1];\\n\\t\\t\\t}\\n\\t\\t}\\n                // check intervals' range\\n\\t\\tif (!pq.isEmpty() && yRange != border[1] - border[0]) {\\n                        return false;\\n\\t\\t\\t//if (set.isEmpty()) return false;\\n\\t\\t\\t//if (yRange != border[1] - border[0]) return false;\\n\\t\\t}\\n\\t}\\n\\treturn true;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 87201,
                "title": "might-be-the-simplest-o-n-solution-only-count-corners-no-area-no-maxmin-with-comments",
                "content": "Key idea: a perfect rectangle must have 4 corners\\n```\\npublic boolean isRectangleCover(int[][] rectangles) {\\n        Set<String> set = new HashSet<>();\\n        for(int[] rec: rectangles){\\n            //b = bottom, l = left, r = right, t = top\\n            //create corners with type\\n            String bl = rec[0]+\",\"+rec[1]+\"bl\";\\n            String br = rec[2]+\",\"+rec[1]+\"br\";\\n            String tl = rec[0]+\",\"+rec[3]+\"tl\";\\n            String tr = rec[2]+\",\"+rec[3]+\"tr\";\\n            //if these corners already exist, return false\\n            if(!set.add(bl) || !set.add(br) || !set.add(tl) || !set.add(tr)) return false;\\n            //if these 4 corners and previously added corners form a line, remove them\\n            if(set.remove(rec[0]+\",\"+rec[1]+\"tl\")) set.remove(bl);\\n            else if(set.remove(rec[0]+\",\"+rec[1]+\"br\")) set.remove(bl);\\n            if(set.remove(rec[2]+\",\"+rec[1]+\"bl\")) set.remove(br);\\n            else if(set.remove(rec[2]+\",\"+rec[1]+\"tr\")) set.remove(br);\\n            if(set.remove(rec[0]+\",\"+rec[3]+\"tr\")) set.remove(tl);\\n            else if(set.remove(rec[0]+\",\"+rec[3]+\"bl\")) set.remove(tl);\\n            if(set.remove(rec[2]+\",\"+rec[3]+\"tl\")) set.remove(tr);\\n            else if(set.remove(rec[2]+\",\"+rec[3]+\"br\")) set.remove(tr);\\n        }\\n        //a perfect rectangle contains 4 corners\\n        return set.size()==4;\\n    }\\n```\\nA reference pic for the removal part:\\n![0_1478591653852_QQ\\u622a\\u56fe20161105154102.png](/uploads/files/1478591653850-qq\\u622a\\u56fe20161105154102.png) \\nClean and simple, please upvote, thanks!",
                "solutionTags": [],
                "code": "```\\npublic boolean isRectangleCover(int[][] rectangles) {\\n        Set<String> set = new HashSet<>();\\n        for(int[] rec: rectangles){\\n            //b = bottom, l = left, r = right, t = top\\n            //create corners with type\\n            String bl = rec[0]+\",\"+rec[1]+\"bl\";\\n            String br = rec[2]+\",\"+rec[1]+\"br\";\\n            String tl = rec[0]+\",\"+rec[3]+\"tl\";\\n            String tr = rec[2]+\",\"+rec[3]+\"tr\";\\n            //if these corners already exist, return false\\n            if(!set.add(bl) || !set.add(br) || !set.add(tl) || !set.add(tr)) return false;\\n            //if these 4 corners and previously added corners form a line, remove them\\n            if(set.remove(rec[0]+\",\"+rec[1]+\"tl\")) set.remove(bl);\\n            else if(set.remove(rec[0]+\",\"+rec[1]+\"br\")) set.remove(bl);\\n            if(set.remove(rec[2]+\",\"+rec[1]+\"bl\")) set.remove(br);\\n            else if(set.remove(rec[2]+\",\"+rec[1]+\"tr\")) set.remove(br);\\n            if(set.remove(rec[0]+\",\"+rec[3]+\"tr\")) set.remove(tl);\\n            else if(set.remove(rec[0]+\",\"+rec[3]+\"bl\")) set.remove(tl);\\n            if(set.remove(rec[2]+\",\"+rec[3]+\"tl\")) set.remove(tr);\\n            else if(set.remove(rec[2]+\",\"+rec[3]+\"br\")) set.remove(tr);\\n        }\\n        //a perfect rectangle contains 4 corners\\n        return set.size()==4;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 87189,
                "title": "short-corner-xor-solution",
                "content": "    def isRectangleCover(self, rectangles):\\n        area = 0\\n        corners = set()\\n        a, c = lambda: (X - x) * (Y - y), lambda: {(x, y), (x, Y), (X, y), (X, Y)}\\n        for x, y, X, Y in rectangles:\\n            area += a()\\n            corners ^= c()\\n        x, y, X, Y = (f(z) for f, z in zip((min, min, max, max), zip(*rectangles)))\\n        return area == a() and corners == c()\\n\\nEquivalent to what others have done, just relatively short. I check that the sum of areas matches the rectangular hull's area and that the corners appearing an odd number of times are exactly the hull's corners. I have a rough idea for a proof, might try finishing it later...",
                "solutionTags": [],
                "code": "    def isRectangleCover(self, rectangles):\\n        area = 0\\n        corners = set()\\n        a, c = lambda: (X - x) * (Y - y), lambda: {(x, y), (x, Y), (X, y), (X, Y)}\\n        for x, y, X, Y in rectangles:\\n            area += a()\\n            corners ^= c()\\n        x, y, X, Y = (f(z) for f, z in zip((min, min, max, max), zip(*rectangles)))\\n        return area == a() and corners == c()\\n\\nEquivalent to what others have done, just relatively short. I check that the sum of areas matches the rectangular hull's area and that the corners appearing an odd number of times are exactly the hull's corners. I have a rough idea for a proof, might try finishing it later...",
                "codeTag": "Python3"
            },
            {
                "id": 968076,
                "title": "python-fast-and-clear-solution-with-explanation",
                "content": "We need to check two things:\\n- the external corners must appear only once, and the ones inside have to be an even number (we filter them with xor).\\n- the total area of all the rectangles together, has to be equal to the area created by the external corners\\n```\\nclass Solution:\\n    def isRectangleCover(self, rectangles: List[List[int]]) -> bool:\\n        \\n        area = 0\\n        corners = set()\\n        a = lambda: (Y-y) * (X-x)\\n        \\n        for x, y, X, Y in rectangles:\\n            area += a()\\n            corners ^= {(x,y), (x,Y), (X,y), (X,Y)}\\n\\n        if len(corners) != 4: return False\\n        x, y = min(corners, key=lambda x: x[0] + x[1])\\n        X, Y = max(corners, key=lambda x: x[0] + x[1])\\n        return a() == area\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isRectangleCover(self, rectangles: List[List[int]]) -> bool:\\n        \\n        area = 0\\n        corners = set()\\n        a = lambda: (Y-y) * (X-x)\\n        \\n        for x, y, X, Y in rectangles:\\n            area += a()\\n            corners ^= {(x,y), (x,Y), (X,y), (X,Y)}\\n\\n        if len(corners) != 4: return False\\n        x, y = min(corners, key=lambda x: x[0] + x[1])\\n        X, Y = max(corners, key=lambda x: x[0] + x[1])\\n        return a() == area\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1655115,
                "title": "c-a-useful-representation-o-n",
                "content": "Let\\'s say that the rectangles form a **picture** (including the information that whether each **grid** is covered and how much times the grid is covered. A **grid** is an ```1*1``` area where all the vertex of the area have integer coordinates). We want to use a set of values of points to represent this picture. \\nWe may record the value of each points of the picture. When the picture is empty we say that the value of each point is 0. For each rectangle added to this picture, say ```rectangles[i] = [xi, yi, ai, bi]``` is added, we do the following operations:\\npoint ```[xi, yi]``` has its value +1;\\npoint ```[xi, bi]``` has its value -1;\\npoint ```[ai, yi]``` has its value -1;\\npoint ```[ai, bi]``` has its value +1;\\nAfter adding all the rectangles, the result is the set of values of points representing this picture. Let\\'s call it the **value representation** of this picture. For example, for the examples given in the problem, the value representation should be as follows:\\nFor **example 1**:\\npoint ```[1,1]``` has value 1\\npoint ```[1,4]``` has value -1\\npoint ```[4,1]``` has value -1\\npoint ```[4,4]``` has value 1\\nall other points have value 0\\n\\nFor **example 3**:\\npoint ```[1,1]``` has value 1\\npoint ```[1,4]``` has value -1\\npoint ```[4,1]``` has value -1\\npoint ```[4,4]``` has value 1\\npoint ```[2,2]``` has value 1\\npoint ```[2,3]``` has value -1\\npoint ```[3,2]``` has value -1\\npoint ```[3,3]``` has value 1\\nall other points have value 0\\n\\nThe value representation has an important property that it\\'s determined by the final picture and is independent of how you added each part of the picture. It\\'s because that the value representation of a whole rectangle is the same as the value representation of all grids of the rectangle combined. Therefore, to see whether the picture is a perfect rectangle becomes very easy: We just see whether there are only 4 points having nonzero value and whether their values are +1 or -1.\\n\\nUse structure like unordered_map, the complexity is O(n). The following code is easy to understand but costs O(n logn) because I used map rather than unordered_map, since there\\'s no default hash for pair<int, int>:\\n```\\nclass Solution {\\npublic:\\n    bool isRectangleCover(vector<vector<int>>& rectangles) {\\n        map<pair<int, int>, int> mark;\\n        for(vector<int>& x:rectangles){\\n            mark[{x[0], x[1]}]++;\\n            mark[{x[0], x[3]}]--;\\n            mark[{x[2], x[1]}]--;\\n            mark[{x[2], x[3]}]++;\\n        }\\n        int n_mark=0;\\n        for(auto ptr=mark.begin();ptr!=mark.end();ptr++)\\n            if(ptr->second!=0){\\n                if(abs(ptr->second)!=1) return false;\\n                n_mark++;\\n            }\\n        return n_mark==4;\\n    }\\n};\\n```\\n\\nAnd the following is the true O(n) solution:\\n```\\nclass Solution {\\npublic:\\n    bool isRectangleCover(vector<vector<int>>& rectangles) {\\n        unordered_map<long long, int> mark;\\n        const long long N=1000000;\\n        for(vector<int>& x:rectangles){\\n            int x1=x[0];\\n            int y1=x[1];\\n            int x2=x[2];\\n            int y2=x[3];\\n            mark[x1*N+y1]++;\\n            mark[x1*N+y2]--;\\n            mark[x2*N+y1]--;\\n            mark[x2*N+y2]++;\\n        }\\n        int n_mark=0;\\n        for(auto ptr=mark.begin();ptr!=mark.end();ptr++)\\n            if(ptr->second!=0){\\n                if(abs(ptr->second)!=1) return false;\\n                n_mark++;\\n            }\\n        return n_mark==4;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```1*1```\n```rectangles[i] = [xi, yi, ai, bi]```\n```[xi, yi]```\n```[xi, bi]```\n```[ai, yi]```\n```[ai, bi]```\n```[1,1]```\n```[1,4]```\n```[4,1]```\n```[4,4]```\n```[1,1]```\n```[1,4]```\n```[4,1]```\n```[4,4]```\n```[2,2]```\n```[2,3]```\n```[3,2]```\n```[3,3]```\n```\\nclass Solution {\\npublic:\\n    bool isRectangleCover(vector<vector<int>>& rectangles) {\\n        map<pair<int, int>, int> mark;\\n        for(vector<int>& x:rectangles){\\n            mark[{x[0], x[1]}]++;\\n            mark[{x[0], x[3]}]--;\\n            mark[{x[2], x[1]}]--;\\n            mark[{x[2], x[3]}]++;\\n        }\\n        int n_mark=0;\\n        for(auto ptr=mark.begin();ptr!=mark.end();ptr++)\\n            if(ptr->second!=0){\\n                if(abs(ptr->second)!=1) return false;\\n                n_mark++;\\n            }\\n        return n_mark==4;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool isRectangleCover(vector<vector<int>>& rectangles) {\\n        unordered_map<long long, int> mark;\\n        const long long N=1000000;\\n        for(vector<int>& x:rectangles){\\n            int x1=x[0];\\n            int y1=x[1];\\n            int x2=x[2];\\n            int y2=x[3];\\n            mark[x1*N+y1]++;\\n            mark[x1*N+y2]--;\\n            mark[x2*N+y1]--;\\n            mark[x2*N+y2]++;\\n        }\\n        int n_mark=0;\\n        for(auto ptr=mark.begin();ptr!=mark.end();ptr++)\\n            if(ptr->second!=0){\\n                if(abs(ptr->second)!=1) return false;\\n                n_mark++;\\n            }\\n        return n_mark==4;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 87186,
                "title": "easy-understanding-o-n-python-solution",
                "content": "**EDIT:** original code works fine on Python (but not Python3). make some change so that it\\'ll work both on Python2 and Python3.\\n\\n--\\n\\nSave area and all FOUR corners for each sub-rectangle:\\n1. sum of area of all sub-rectangle == area of maximum rectangle.\\n2. each corner should only appear either TWO or FOUR times, except four corners of big rectangle.\\n```\\nclass Solution(object):\\n    def isRectangleCover(self, rectangles):\\n        def recordCorner(point):\\n            if point in corners:\\n                corners[point] += 1\\n            else:\\n                corners[point] = 1\\n\\n        corners = {}                                # record all corners \\n        L, B, R, T, area = float(\\'inf\\'), float(\\'inf\\'), -float(\\'inf\\'), -float(\\'inf\\'), 0\\n\\n        for sub in rectangles:\\n            L, B, R, T = min(L, sub[0]), min(B, sub[1]), max(R, sub[2]), max(T, sub[3])\\n            ax, ay, bx, by = sub[:]\\n            area += (bx-ax)*(by-ay)                 # sum up the area of each sub-rectangle\\n            # map(recordCorner, [(ax, ay), (bx, by), (ax, by), (bx, ay)])      # works on python2, but not python3\\n\\t\\t\\tfor px in [(ax, ay), (bx, by), (ax, by), (bx, ay)]:\\n\\t\\t\\t\\trecordCorner(px)\\n\\n        if area != (T-B)*(R-L): return False        # check the area\\n\\n        big_four = [(L,B),(R,T),(L,T),(R,B)]\\n\\n        for bf in big_four:                         # check corners of big rectangle\\n            if bf not in corners or corners[bf] != 1:\\n                return False\\n\\n        for key in corners:                         # check existing \"inner\" points\\n            if corners[key]%2 and key not in big_four:\\n                return False\\n\\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def isRectangleCover(self, rectangles):\\n        def recordCorner(point):\\n            if point in corners:\\n                corners[point] += 1\\n            else:\\n                corners[point] = 1\\n\\n        corners = {}                                # record all corners \\n        L, B, R, T, area = float(\\'inf\\'), float(\\'inf\\'), -float(\\'inf\\'), -float(\\'inf\\'), 0\\n\\n        for sub in rectangles:\\n            L, B, R, T = min(L, sub[0]), min(B, sub[1]), max(R, sub[2]), max(T, sub[3])\\n            ax, ay, bx, by = sub[:]\\n            area += (bx-ax)*(by-ay)                 # sum up the area of each sub-rectangle\\n            # map(recordCorner, [(ax, ay), (bx, by), (ax, by), (bx, ay)])      # works on python2, but not python3\\n\\t\\t\\tfor px in [(ax, ay), (bx, by), (ax, by), (bx, ay)]:\\n\\t\\t\\t\\trecordCorner(px)\\n\\n        if area != (T-B)*(R-L): return False        # check the area\\n\\n        big_four = [(L,B),(R,T),(L,T),(R,B)]\\n\\n        for bf in big_four:                         # check corners of big rectangle\\n            if bf not in corners or corners[bf] != 1:\\n                return False\\n\\n        for key in corners:                         # check existing \"inner\" points\\n            if corners[key]%2 and key not in big_four:\\n                return False\\n\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 300215,
                "title": "8-line-concise-python-solution-beats-99",
                "content": "\\'\\'\\'\\nclass Solution:\\n\\n    def isRectangleCover(self, rectangles):\\n        corner=set()\\n        a,b,c,d,area=float(\\'inf\\'),float(\\'inf\\'),float(\\'-inf\\'),float(\\'-inf\\'),0\\n        for x1,y1,x2,y2 in rectangles:\\n            if x1<=a and y1<=b: a,b=x1,y1\\n            if x2>=c and y2>=d: c,d=x2,y2\\n            area+=(x2-x1)*(y2-y1)\\n            corner^={(x1,y1),(x2,y2),(x1,y2),(x2,y1)}\\n        return corner=={(a,b),(c,d),(a,d),(c,b)} and area==(c-a)*(d-b)\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "class Solution:\\n\\n    def isRectangleCover(self, rectangles):\\n        corner=set()\\n        a,b,c,d,area=float(\\'inf\\'),float(\\'inf\\'),float(\\'-inf\\'),float(\\'-inf\\'),0\\n        for x1,y1,x2,y2 in rectangles:\\n            if x1<=a and y1<=b: a,b=x1,y1\\n            if x2>=c and y2>=d: c,d=x2,y2\\n            area+=(x2-x1)*(y2-y1)\\n            corner^={(x1,y1),(x2,y2),(x1,y2),(x2,y1)}",
                "codeTag": "Java"
            },
            {
                "id": 87206,
                "title": "c-o-nlogn-solution-using-multiset-and-o-n-solution-using-unordered-map",
                "content": "O(nlogn) solution: check if areas equal, and also make sure no overlap exists:\\n\\nRegarding how the multiset is used to detect the overlapping:\\nThe trick is really inside the comparator: I used ```return a.second <= b.first;``` inside comparator. What it does is to make multiset treat overlapping elements as the same (equal) elements, and others as not equal (smaller/bigger).\\n\\ne.g.\\nSay we have ```a = [2,6]``` and ```b = [6,8]```, comparator will obviously return ```true``` for ```a.second <= b.first```, thus multiset will take ```a``` as the smaller element.\\nIn another case say we have ```a=[2,6]``` and ```b=[5,8]```, comparator will return ```false``` for both ```a.second <= b.first``` and ```b.second <= a.first```. As a result, multiset will treat ```a``` and ```b``` as same value. This is because by definition, the function will treat two elements as the same if both ```comp(a, b)``` and ```comp(b, a)``` return ```false```.\\n\\nGiven above, if the multiset.find() has found an element that's already in the multiset, we know there's overlapping existing.\\n```\\nclass Solution {\\nprivate:\\n    struct comp {\\n        bool operator () (const pair<int, int>& a, const pair<int, int>& b) { return a.second <= b.first; }\\n    };\\n    \\npublic:\\n    bool isRectangleCover(vector<vector<int>>& rectangles) {\\n        int area = 0, xmin = INT_MAX, ymin = INT_MAX, xmax = INT_MIN, ymax = INT_MIN;\\n        vector<vector<int>> verticalEdges;  // x, insertion/deletion event, ysmall, ylarge\\n        multiset<pair<int, int>, comp> s;   // for detecting overlaps\\n        \\n        // Calculate area, and configure verticalEdges\\n        for (auto v : rectangles) {\\n            area += (v[2] - v[0]) * (v[3] - v[1]);\\n            xmin = min(xmin, v[0]), ymin = min(ymin, v[1]), xmax = max(xmax, v[2]), ymax = max(ymax, v[3]);\\n            verticalEdges.push_back({v[0], 1, v[1], v[3]}), verticalEdges.push_back({v[2], -1, v[1], v[3]});\\n        }\\n        if (area != (xmax - xmin) * (ymax - ymin)) { return false; }\\n        \\n        // Check if any overlap exists\\n        sort(verticalEdges.begin(), verticalEdges.end());\\n        for (auto v : verticalEdges) {\\n            auto it = s.find(make_pair(v[2], v[3]));\\n            if (v[1] > 0) {                             // left edge, insertion event\\n                if (it != s.end()) { return false; }    // found an overlap\\n                s.insert(make_pair(v[2], v[3]));\\n            } else {                                    // right edge, deletion event\\n                s.erase(it);\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```\\n\\n\\nAnd here's another O(n) solution inspired by @hxtang : check if areas equal, and points appeared odd times are the large rectangles's four corners exactly:\\n\\n```\\n    struct pairhash {   //double hash function for pair key\\n        template <typename T, typename U>\\n        size_t operator()(const pair<T, U> &p) const {\\n            size_t l = hash<T>()(p.first), r = hash<U>()(p.second);\\n            return l + 0x9e3779b9 + (r << 6) + (r >> 2);\\n        }\\n    };\\n    \\n    bool isRectangleCover(vector<vector<int>>& rectangles) {\\n        int area = 0, xmin = INT_MAX, ymin = INT_MAX, xmax = INT_MIN, ymax = INT_MIN;\\n        unordered_map<pair<int, int>, int, pairhash> m;\\n        \\n        // Calculate area, and count points of appearances\\n        vector<pair<int, int>> points = {{0, 1}, {0, 3}, {2, 3}, {2, 1}};\\n        for (auto v : rectangles) {\\n            for (auto point : points) {\\n                if (++m[make_pair(v[point.first], v[point.second])] > 4) { return false; }\\n            }\\n            area += (v[2] - v[0]) * (v[3] - v[1]);\\n            xmin = min(xmin, v[0]), ymin = min(ymin, v[1]), xmax = max(xmax, v[2]), ymax = max(ymax, v[3]);\\n        }\\n        if (area != (xmax - xmin) * (ymax - ymin)) { return false; }\\n        \\n        // Check if points appearing odd number of times are exactly large rectangles' 4 corners\\n        unordered_set<pair<int, int>, pairhash> s = {{xmin, ymin}, {xmin, ymax}, {xmax, ymax}, {xmax, ymin}};\\n        for (auto it = m.begin(); it != m.end(); it++) {\\n            if (it->second & 1 == 1) {\\n                if (s.count(it->first) > 0) {\\n                    s.erase(it->first); \\n                } else {\\n                    return false;\\n                }\\n            }\\n        }\\n        return s.empty();\\n    }\\n```",
                "solutionTags": [],
                "code": "```return a.second <= b.first;```\n```a = [2,6]```\n```b = [6,8]```\n```true```\n```a.second <= b.first```\n```a```\n```a=[2,6]```\n```b=[5,8]```\n```false```\n```a.second <= b.first```\n```b.second <= a.first```\n```a```\n```b```\n```comp(a, b)```\n```comp(b, a)```\n```false```\n```\\nclass Solution {\\nprivate:\\n    struct comp {\\n        bool operator () (const pair<int, int>& a, const pair<int, int>& b) { return a.second <= b.first; }\\n    };\\n    \\npublic:\\n    bool isRectangleCover(vector<vector<int>>& rectangles) {\\n        int area = 0, xmin = INT_MAX, ymin = INT_MAX, xmax = INT_MIN, ymax = INT_MIN;\\n        vector<vector<int>> verticalEdges;  // x, insertion/deletion event, ysmall, ylarge\\n        multiset<pair<int, int>, comp> s;   // for detecting overlaps\\n        \\n        // Calculate area, and configure verticalEdges\\n        for (auto v : rectangles) {\\n            area += (v[2] - v[0]) * (v[3] - v[1]);\\n            xmin = min(xmin, v[0]), ymin = min(ymin, v[1]), xmax = max(xmax, v[2]), ymax = max(ymax, v[3]);\\n            verticalEdges.push_back({v[0], 1, v[1], v[3]}), verticalEdges.push_back({v[2], -1, v[1], v[3]});\\n        }\\n        if (area != (xmax - xmin) * (ymax - ymin)) { return false; }\\n        \\n        // Check if any overlap exists\\n        sort(verticalEdges.begin(), verticalEdges.end());\\n        for (auto v : verticalEdges) {\\n            auto it = s.find(make_pair(v[2], v[3]));\\n            if (v[1] > 0) {                             // left edge, insertion event\\n                if (it != s.end()) { return false; }    // found an overlap\\n                s.insert(make_pair(v[2], v[3]));\\n            } else {                                    // right edge, deletion event\\n                s.erase(it);\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```\n```\\n    struct pairhash {   //double hash function for pair key\\n        template <typename T, typename U>\\n        size_t operator()(const pair<T, U> &p) const {\\n            size_t l = hash<T>()(p.first), r = hash<U>()(p.second);\\n            return l + 0x9e3779b9 + (r << 6) + (r >> 2);\\n        }\\n    };\\n    \\n    bool isRectangleCover(vector<vector<int>>& rectangles) {\\n        int area = 0, xmin = INT_MAX, ymin = INT_MAX, xmax = INT_MIN, ymax = INT_MIN;\\n        unordered_map<pair<int, int>, int, pairhash> m;\\n        \\n        // Calculate area, and count points of appearances\\n        vector<pair<int, int>> points = {{0, 1}, {0, 3}, {2, 3}, {2, 1}};\\n        for (auto v : rectangles) {\\n            for (auto point : points) {\\n                if (++m[make_pair(v[point.first], v[point.second])] > 4) { return false; }\\n            }\\n            area += (v[2] - v[0]) * (v[3] - v[1]);\\n            xmin = min(xmin, v[0]), ymin = min(ymin, v[1]), xmax = max(xmax, v[2]), ymax = max(ymax, v[3]);\\n        }\\n        if (area != (xmax - xmin) * (ymax - ymin)) { return false; }\\n        \\n        // Check if points appearing odd number of times are exactly large rectangles' 4 corners\\n        unordered_set<pair<int, int>, pairhash> s = {{xmin, ymin}, {xmin, ymax}, {xmax, ymax}, {xmax, ymin}};\\n        for (auto it = m.begin(); it != m.end(); it++) {\\n            if (it->second & 1 == 1) {\\n                if (s.count(it->first) > 0) {\\n                    s.erase(it->first); \\n                } else {\\n                    return false;\\n                }\\n            }\\n        }\\n        return s.empty();\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1229993,
                "title": "python-solution-with-detailed-explanation",
                "content": "* The first idea came to my mind is comparing the sum of area of all small rectangles with the area of the big rectangle. If there is no overlapped area, this method works well. However, if the empty area is equal to the overlapped area, we will get the wrong answer.\\n* Then the key point becomes whether there are overlapped areas. It\\'s not hard to find that if all the rectangles together form an exact cover of a rectangular, every corner point of a rectangle is shared by 2 or 4  small rectangles, except the 4 corner points of the big rectangle.\\n* So we traverse all the rectangles, if the corner point exits, delete it from the set(O(1)), else add it to the set. If there are 4 corner points, it means no overlapped area is found, and we can compare the total area.\\n* sort the last 4 corner points, the first point is the bottom left point, and the last point is the top right point.\\n\\nclass Solution:\\n\\n    def isRectangleCover(self, rectangles: List[List[int]]) -> bool:\\n        area = 0\\n        corner_point = set()\\n\\n        for x,y,a,b in rectangles:\\n            area+=(a-x)*(b-y)\\n            for points in [(x,y),(x,b),(a,y),(a,b)]:\\n                if points in corner_point:\\n                    corner_point.remove(points)\\n                else:\\n                    corner_point.add(points)\\n\\n        if len(corner_point)!=4: # a rectangle should only have 4 corner points\\n            return False\\n        # check the area is equal or not \\n        corner_point = sorted(list(corner_point), key = lambda x:(x[0], x[1]))\\n        return area == ((corner_point[-1][0]-corner_point[0][0])*(corner_point[-1][1]-corner_point[0][1]))",
                "solutionTags": [
                    "Python"
                ],
                "code": "* The first idea came to my mind is comparing the sum of area of all small rectangles with the area of the big rectangle. If there is no overlapped area, this method works well. However, if the empty area is equal to the overlapped area, we will get the wrong answer.\\n* Then the key point becomes whether there are overlapped areas. It\\'s not hard to find that if all the rectangles together form an exact cover of a rectangular, every corner point of a rectangle is shared by 2 or 4  small rectangles, except the 4 corner points of the big rectangle.\\n* So we traverse all the rectangles, if the corner point exits, delete it from the set(O(1)), else add it to the set. If there are 4 corner points, it means no overlapped area is found, and we can compare the total area.\\n* sort the last 4 corner points, the first point is the bottom left point, and the last point is the top right point.\\n\\nclass Solution:\\n\\n    def isRectangleCover(self, rectangles: List[List[int]]) -> bool:\\n        area = 0\\n        corner_point = set()\\n\\n        for x,y,a,b in rectangles:\\n            area+=(a-x)*(b-y)\\n            for points in [(x,y),(x,b),(a,y),(a,b)]:\\n                if points in corner_point:\\n                    corner_point.remove(points)\\n                else:\\n                    corner_point.add(points)\\n\\n        if len(corner_point)!=4: # a rectangle should only have 4 corner points\\n            return False\\n        # check the area is equal or not \\n        corner_point = sorted(list(corner_point), key = lambda x:(x[0], x[1]))\\n        return area == ((corner_point[-1][0]-corner_point[0][0])*(corner_point[-1][1]-corner_point[0][1]))",
                "codeTag": "Java"
            },
            {
                "id": 360601,
                "title": "python-solution",
                "content": "```\\nclass Solution(object):\\n    def isRectangleCover(self, rectangles):\\n        \"\"\"\\n        :type rectangles: List[List[int]]\\n        :rtype: bool\\n        \"\"\"\\n        hs = set()\\n        area = 0\\n        for rec in rectangles:\\n            top_left = (rec[0], rec[1])\\n            top_right = (rec[0], rec[3])\\n            bottom_left = (rec[2], rec[1])\\n            bottom_right = (rec[2], rec[3])\\n            area += (rec[2] - rec[0]) * (rec[3] - rec[1])\\n            for i in [top_left, top_right, bottom_left, bottom_right]:\\n                if i not in hs:\\n                    hs.add(i)\\n                else:\\n                    hs.remove(i)\\n        if len(hs) != 4:\\n            return False\\n        hs = sorted(hs)\\n        first = hs.pop(0)\\n        last = hs.pop()\\n        return area == (last[0] - first[0]) * (last[1] - first[1])\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution(object):\\n    def isRectangleCover(self, rectangles):\\n        \"\"\"\\n        :type rectangles: List[List[int]]\\n        :rtype: bool\\n        \"\"\"\\n        hs = set()\\n        area = 0\\n        for rec in rectangles:\\n            top_left = (rec[0], rec[1])\\n            top_right = (rec[0], rec[3])\\n            bottom_left = (rec[2], rec[1])\\n            bottom_right = (rec[2], rec[3])\\n            area += (rec[2] - rec[0]) * (rec[3] - rec[1])\\n            for i in [top_left, top_right, bottom_left, bottom_right]:\\n                if i not in hs:\\n                    hs.add(i)\\n                else:\\n                    hs.remove(i)\\n        if len(hs) != 4:\\n            return False\\n        hs = sorted(hs)\\n        first = hs.pop(0)\\n        last = hs.pop()\\n        return area == (last[0] - first[0]) * (last[1] - first[1])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 87207,
                "title": "short-java-solution-with-explanation-updated",
                "content": "If all rectangles can form an exact rectangular area, they should follow these conditions:\\n1. The sum of area of all small rectangles should equal to the area of large rectangle.\\n2. At any position except outer four corners, the amount of overlapping corners should be even (2, 4).\\n3. Corners that overlap at the same point should be different type (top-left, top-right, bottom-left, bottom-right).\\n\\nSo, I used\\n1. Four int variables to record the boundaries of large rectangle and then calculate the area.\\n2. A hashmap that maps corner with its type.\\n3. Four numbers (1, 2, 4, 8) to represent four types of corner. Then use bit manipulation to modify and check.\\n\\nO(n) time complexity, O(n) space, 112 ms run time.\\nSpecial credit to @wu474purdue-edu \\n```\\npublic class Solution {\\n    Map<String, Integer> map = new HashMap<String, Integer>();\\n    public boolean isRectangleCover(int[][] rectangles) {\\n        if (rectangles.length == 0 || rectangles[0].length == 0) return false;\\n        int lx = Integer.MAX_VALUE, ly = lx, rx = Integer.MIN_VALUE, ry = rx, sum = 0;\\n        for (int[] rec : rectangles) {\\n            lx = Math.min(lx, rec[0]);\\n            ly = Math.min(ly, rec[1]);\\n            rx = Math.max(rx, rec[2]);\\n            ry = Math.max(ry, rec[3]);\\n            sum += (rec[2] - rec[0]) * (rec[3] - rec[1]);\\n            //bottom-left\\n            if (overlap(rec[0] + \" \" + rec[1], 1)) return false;\\n            //top-left\\n            if (overlap(rec[0] + \" \" + rec[3], 2)) return false;\\n            //bottom-right\\n            if (overlap(rec[2] + \" \" + rec[1], 4)) return false;\\n            //top-right\\n            if (overlap(rec[2] + \" \" + rec[3], 8)) return false;\\n        }\\n        int count = 0;\\n        Iterator<Integer> iter = map.values().iterator();\\n        while (iter.hasNext()) {\\n            Integer i = iter.next();\\n            if (i != 15 && i != 12 && i != 10 && i != 9 && i != 6 && i != 5 && i != 3) count++;\\n        }\\n        return count == 4 && sum == (rx - lx) * (ry - ly);\\n    }\\n    \\n    private boolean overlap(String corner, Integer type) {\\n        Integer temp = map.get(corner);\\n        if (temp == null) temp = type;\\n        else if ((temp & type) != 0) return true;\\n        else temp |= type;\\n        map.put(corner, temp);\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    Map<String, Integer> map = new HashMap<String, Integer>();\\n    public boolean isRectangleCover(int[][] rectangles) {\\n        if (rectangles.length == 0 || rectangles[0].length == 0) return false;\\n        int lx = Integer.MAX_VALUE, ly = lx, rx = Integer.MIN_VALUE, ry = rx, sum = 0;\\n        for (int[] rec : rectangles) {\\n            lx = Math.min(lx, rec[0]);\\n            ly = Math.min(ly, rec[1]);\\n            rx = Math.max(rx, rec[2]);\\n            ry = Math.max(ry, rec[3]);\\n            sum += (rec[2] - rec[0]) * (rec[3] - rec[1]);\\n            //bottom-left\\n            if (overlap(rec[0] + \" \" + rec[1], 1)) return false;\\n            //top-left\\n            if (overlap(rec[0] + \" \" + rec[3], 2)) return false;\\n            //bottom-right\\n            if (overlap(rec[2] + \" \" + rec[1], 4)) return false;\\n            //top-right\\n            if (overlap(rec[2] + \" \" + rec[3], 8)) return false;\\n        }\\n        int count = 0;\\n        Iterator<Integer> iter = map.values().iterator();\\n        while (iter.hasNext()) {\\n            Integer i = iter.next();\\n            if (i != 15 && i != 12 && i != 10 && i != 9 && i != 6 && i != 5 && i != 3) count++;\\n        }\\n        return count == 4 && sum == (rx - lx) * (ry - ly);\\n    }\\n    \\n    private boolean overlap(String corner, Integer type) {\\n        Integer temp = map.get(corner);\\n        if (temp == null) temp = type;\\n        else if ((temp & type) != 0) return true;\\n        else temp |= type;\\n        map.put(corner, temp);\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2987814,
                "title": "c-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf it is a valid rectangle, all interior points should have count 0, bootom left most and top right most point should have value 1, and top left and bottom right should have count -1. If it is different than this, it is not a perfect rectangle.\\n\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n public:\\n  bool isRectangleCover(vector<vector<int>>& rectangles) {\\n    int n = rectangles.size();\\n\\n    if (n == 1) return true;\\n\\n    // maps all points to a respective calculation. If it is a valid rectangle,\\n    // all interior points should have count 0, bootom left most and top right\\n    // most point should have value 1, and top left and bottom right should have\\n    // count -1. If it is different than this, it is not a perfect rectangle.\\n    map<pair<int, int>, int> pointCounts;\\n\\n    for (auto& rect : rectangles) {\\n      pointCounts[{rect[0], rect[1]}]++;\\n      pointCounts[{rect[2], rect[3]}]++;\\n      pointCounts[{rect[0], rect[3]}]--;\\n      pointCounts[{rect[2], rect[1]}]--;\\n    }\\n\\n    int numMarks = 0;\\n\\n    for (auto it = pointCounts.begin(); it != pointCounts.end(); it++) {\\n      if (it->second != 0) {\\n\\n        // this condition is added because in not perfect \\n        // rectangles, overlapping corners will cause the absolute\\n        // value of that corner to go beyond 1\\n        if (abs(it->second) != 1) return false;\\n\\n        numMarks++;\\n      }\\n    }\\n\\n    return numMarks == 4;\\n  }\\n};\\n```\\n\\n\\nEdit: Added comment for != 1 case.",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n public:\\n  bool isRectangleCover(vector<vector<int>>& rectangles) {\\n    int n = rectangles.size();\\n\\n    if (n == 1) return true;\\n\\n    // maps all points to a respective calculation. If it is a valid rectangle,\\n    // all interior points should have count 0, bootom left most and top right\\n    // most point should have value 1, and top left and bottom right should have\\n    // count -1. If it is different than this, it is not a perfect rectangle.\\n    map<pair<int, int>, int> pointCounts;\\n\\n    for (auto& rect : rectangles) {\\n      pointCounts[{rect[0], rect[1]}]++;\\n      pointCounts[{rect[2], rect[3]}]++;\\n      pointCounts[{rect[0], rect[3]}]--;\\n      pointCounts[{rect[2], rect[1]}]--;\\n    }\\n\\n    int numMarks = 0;\\n\\n    for (auto it = pointCounts.begin(); it != pointCounts.end(); it++) {\\n      if (it->second != 0) {\\n\\n        // this condition is added because in not perfect \\n        // rectangles, overlapping corners will cause the absolute\\n        // value of that corner to go beyond 1\\n        if (abs(it->second) != 1) return false;\\n\\n        numMarks++;\\n      }\\n    }\\n\\n    return numMarks == 4;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 87196,
                "title": "clean-c-sweep-line-solution",
                "content": "A naive solution to the problem is to check rectangles pairwisely for overlap. Then compare the sum of areas of all rectangles to the area of its bounding box.\\n\\nBut the pairwise comparison is too slow. This is where the sweep line solution comes in to quickly check overlap of many rectangles. This is by scanning vertical edges of rectangles in the order of x, and maintaining an ordered list of y-intervals. Left edges are inserted into the intervals before which interval overlap is checked. Right edges are removed from the intervals.\\n\\nA complication here is that right edges should be processed before all left edges. I deal this problem by mapping x coordinate to time t with: t = 2x+1 for left edges and t = 2x for right edges.\\n```\\nstruct interval {\\n    int start;\\n    int end;\\n    interval(int start_, int end_) : start(start_), end(end_) {};\\n};\\n\\nstruct edge {\\n    int t;\\n    interval i;\\n    edge(int t_, interval i_) : t(t_), i(i_) {};\\n};\\n\\nstruct interval_cmp {\\n   bool operator()(interval i1, interval i2) { return i1.start < i2.start; }; \\n};\\n\\nstruct edge_cmp {\\n   bool operator()(edge e1, edge e2) { return e1.t > e2.t; }; \\n};\\n\\nbool isRectangleCover(vector<vector<int>>& rectangles) {\\n    priority_queue<edge, vector<edge>, edge_cmp>  q;\\n    set<interval, interval_cmp> active_intervals;\\n    \\n    int minx = INT_MAX, miny = INT_MAX, maxx = INT_MIN, maxy = INT_MIN;\\n    int area = 0;\\n    for (const auto& rect : rectangles) {\\n        area += (rect[2]-rect[0])* (rect[3]-rect[1]);\\n        minx = min(rect[0], minx);\\n        miny = min(rect[1], miny);\\n        maxx = max(rect[2], maxx);\\n        maxy = max(rect[3], maxy);\\n        q.emplace(rect[0]*2+1, interval(rect[1], rect[3]));\\n        q.emplace(rect[2]*2  , interval(rect[1], rect[3]));\\n    }\\n    \\n    while (!q.empty()) {\\n        int t = q.top().t;\\n        interval i = q.top().i;\\n        if (t % 2) { //insert interval\\n            auto it = active_intervals.lower_bound(i);\\n            if (it != active_intervals.begin() && prev(it)->end > i.start) return false;\\n            if (it != active_intervals.end() && it->start < i.end) return false;\\n            active_intervals.insert(it, i);\\n        }\\n        else { //remove interval\\n            active_intervals.erase(i);\\n        }\\n        q.pop();\\n    }\\n    return area == (maxx-minx) * (maxy - miny);\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nstruct interval {\\n    int start;\\n    int end;\\n    interval(int start_, int end_) : start(start_), end(end_) {};\\n};\\n\\nstruct edge {\\n    int t;\\n    interval i;\\n    edge(int t_, interval i_) : t(t_), i(i_) {};\\n};\\n\\nstruct interval_cmp {\\n   bool operator()(interval i1, interval i2) { return i1.start < i2.start; }; \\n};\\n\\nstruct edge_cmp {\\n   bool operator()(edge e1, edge e2) { return e1.t > e2.t; }; \\n};\\n\\nbool isRectangleCover(vector<vector<int>>& rectangles) {\\n    priority_queue<edge, vector<edge>, edge_cmp>  q;\\n    set<interval, interval_cmp> active_intervals;\\n    \\n    int minx = INT_MAX, miny = INT_MAX, maxx = INT_MIN, maxy = INT_MIN;\\n    int area = 0;\\n    for (const auto& rect : rectangles) {\\n        area += (rect[2]-rect[0])* (rect[3]-rect[1]);\\n        minx = min(rect[0], minx);\\n        miny = min(rect[1], miny);\\n        maxx = max(rect[2], maxx);\\n        maxy = max(rect[3], maxy);\\n        q.emplace(rect[0]*2+1, interval(rect[1], rect[3]));\\n        q.emplace(rect[2]*2  , interval(rect[1], rect[3]));\\n    }\\n    \\n    while (!q.empty()) {\\n        int t = q.top().t;\\n        interval i = q.top().i;\\n        if (t % 2) { //insert interval\\n            auto it = active_intervals.lower_bound(i);\\n            if (it != active_intervals.begin() && prev(it)->end > i.start) return false;\\n            if (it != active_intervals.end() && it->start < i.end) return false;\\n            active_intervals.insert(it, i);\\n        }\\n        else { //remove interval\\n            active_intervals.erase(i);\\n        }\\n        q.pop();\\n    }\\n    return area == (maxx-minx) * (maxy - miny);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2992766,
                "title": "easy-c-solution-o-n-using-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nJust used map to keep the count of edges.\\nIncreasing the count of bottom left and top right vertices.\\nDecreasing the count of bottom right and top left vertices.\\nAt Last We sum all the values of map.\\nIf the value is 4 then return true as four vertices are there, else return false. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCreate a map with key as pair of int and int(pair<int,int>);\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N);\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isRectangleCover(vector<vector<int>>& rectangles) {\\n        map<pair<int,int>,int>m;\\n        for(auto it:rectangles){\\n            m[{it[0],it[1]}]++;\\n            m[{it[2],it[3]}]++;\\n            m[{it[0],it[3]}]--;\\n            m[{it[2],it[1]}]--;\\n        }\\n        int cnt=0;\\n        for( auto it=m.begin();it!=m.end();it++){\\n            if(abs(it->second)==1){\\n                cnt++;\\n            }\\n            else if(abs(it->second)!=1&&it->second!=0){\\n                return false;\\n            }\\n        }\\n        return cnt==4;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isRectangleCover(vector<vector<int>>& rectangles) {\\n        map<pair<int,int>,int>m;\\n        for(auto it:rectangles){\\n            m[{it[0],it[1]}]++;\\n            m[{it[2],it[3]}]++;\\n            m[{it[0],it[3]}]--;\\n            m[{it[2],it[1]}]--;\\n        }\\n        int cnt=0;\\n        for( auto it=m.begin();it!=m.end();it++){\\n            if(abs(it->second)==1){\\n                cnt++;\\n            }\\n            else if(abs(it->second)!=1&&it->second!=0){\\n                return false;\\n            }\\n        }\\n        return cnt==4;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 150830,
                "title": "python-no-bit-vroom-vroom",
                "content": "Beats 100%, inspired by StefanPochmann\\'s solution:\\n\\n```\\nclass Solution:\\n    def isRectangleCover(self, rectangles):\\n        \\n        size = 0\\n        corners = set()\\n        \\n        for x, y, X, Y in rectangles:\\n            fours = [(x, y), (x, Y), (X, y), (X, Y)]\\n            for point in fours:\\n                if point not in corners:\\n                    corners.add(point)\\n                else:\\n                    corners.remove(point)\\n            size += (Y - y) * (X - x)\\n            \\n        if len(corners) != 4:\\n            return False\\n  \\n        corners = sorted(corners, key=lambda x: (x[0], x[1]))\\n        \\n        if (corners[3][0] - corners[1][0]) * (corners[3][1] - corners[2][1]) != size:\\n            return False\\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isRectangleCover(self, rectangles):\\n        \\n        size = 0\\n        corners = set()\\n        \\n        for x, y, X, Y in rectangles:\\n            fours = [(x, y), (x, Y), (X, y), (X, Y)]\\n            for point in fours:\\n                if point not in corners:\\n                    corners.add(point)\\n                else:\\n                    corners.remove(point)\\n            size += (Y - y) * (X - x)\\n            \\n        if len(corners) != 4:\\n            return False\\n  \\n        corners = sorted(corners, key=lambda x: (x[0], x[1]))\\n        \\n        if (corners[3][0] - corners[1][0]) * (corners[3][1] - corners[2][1]) != size:\\n            return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3029525,
                "title": "c-maths-beginner-friendly-easy-explanation-with-intution-map",
                "content": "```cpp\\nclass Solution {\\npublic:\\n    /*\\n        The intution to solve this question is that storing the points in a map, the bottom left point and top right is incremented and bottom right \\n\\t\\tand top left is decremented which as whole cancels the inner points. If the absolute sum of all the points comes out to be 4 the return true\\n            \\n        P[0][3]       P[2][3]\\n            ---------\\n            |       |\\n            |       |   \\n            |       |\\n            ---------\\n        P[0][1]       P[2][1]\\n    */\\n    bool isRectangleCover(vector<vector<int>>& Pts) {\\n        map<pair<int, int>, int> mp;\\n        int count = 0;\\n        for(auto P : Pts){\\n            mp[{P[0], P[1]}]++;\\n            mp[{P[2], P[3]}]++;\\n            mp[{P[0], P[3]}]--;\\n            mp[{P[2], P[1]}]--;\\n        }\\n        for(auto itr : mp)count += abs(itr.second);\\n        return count == 4;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Geometry"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    /*\\n        The intution to solve this question is that storing the points in a map, the bottom left point and top right is incremented and bottom right \\n\\t\\tand top left is decremented which as whole cancels the inner points. If the absolute sum of all the points comes out to be 4 the return true\\n            \\n        P[0][3]       P[2][3]\\n            ---------\\n            |       |\\n            |       |   \\n            |       |\\n            ---------\\n        P[0][1]       P[2][1]\\n    */\\n    bool isRectangleCover(vector<vector<int>>& Pts) {\\n        map<pair<int, int>, int> mp;\\n        int count = 0;\\n        for(auto P : Pts){\\n            mp[{P[0], P[1]}]++;\\n            mp[{P[2], P[3]}]++;\\n            mp[{P[0], P[3]}]--;\\n            mp[{P[2], P[1]}]--;\\n        }\\n        for(auto itr : mp)count += abs(itr.second);\\n        return count == 4;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 87223,
                "title": "concise-15-lines-o-n-c-solution",
                "content": "Concise O(N) solution. Idea from @hxtang \\nhttps://discuss.leetcode.com/topic/55923/o-n-solution-by-counting-corners-with-detailed-explaination\\n```\\nbool isRectangleCover(vector<vector<int>>& rectangles) {\\n        unordered_map<string,int> mp;\\n        string corners[4];\\n        for(auto v: rectangles)\\n            for(int i = 0; i<4; ++i){\\n                corners[i] = to_string(v[i/2*2]) + \",\" + to_string(v[(i%2)*2+1]);\\n                if(mp[corners[i]] & int(pow(2,i))) return false;\\n                else mp[corners[i]] |= int(pow(2,i));\\n            }\\n        int corner = 0;\\n        for(auto i=mp.begin(); i!=mp.end(); ++i){\\n            int val = i->second;\\n            if(!(val & (val-1)) && (++corner >4)) return false;\\n            if((val & (val-1)) && !(val == 3 || val==12 || val==10 || val==5 || val==15)) return false;\\n        }\\n        return true;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nbool isRectangleCover(vector<vector<int>>& rectangles) {\\n        unordered_map<string,int> mp;\\n        string corners[4];\\n        for(auto v: rectangles)\\n            for(int i = 0; i<4; ++i){\\n                corners[i] = to_string(v[i/2*2]) + \",\" + to_string(v[(i%2)*2+1]);\\n                if(mp[corners[i]] & int(pow(2,i))) return false;\\n                else mp[corners[i]] |= int(pow(2,i));\\n            }\\n        int corner = 0;\\n        for(auto i=mp.begin(); i!=mp.end(); ++i){\\n            int val = i->second;\\n            if(!(val & (val-1)) && (++corner >4)) return false;\\n            if((val & (val-1)) && !(val == 3 || val==12 || val==10 || val==5 || val==15)) return false;\\n        }\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2989119,
                "title": "java-easy-understanding-simple-maths",
                "content": "**THE INTUITION BEHIND THE APPROACH IS SIMPLE MATH. MANUALLY FINDING ALL COORDINATES OF EACH RECTANGLE AND FINDING COORDINATES OF RECTANGLE IN WHOLE AND IF THEY ARE EQUAL THEN RETURN TRUE OR RETURN FALSE.**\\n```\\nclass Solution {\\n    public boolean isRectangleCover(int[][] rectangles) {\\n        HashSet<String> hs=new HashSet<>();\\n        int area=0;\\n        int minX=Integer.MAX_VALUE;\\n        int minY=Integer.MAX_VALUE;\\n        int maxA=Integer.MIN_VALUE;\\n        int maxB=Integer.MIN_VALUE;\\n        for(int i=0;i<rectangles.length;i++){\\n            int x=rectangles[i][0];\\n            int y=rectangles[i][1];\\n            int a=rectangles[i][2];\\n            int b=rectangles[i][3];\\n            area+=Math.abs(y-b)*Math.abs(x-a);\\n            minX=Math.min(minX,x);\\n            minY=Math.min(minY,y);\\n            maxA=Math.max(maxA,a);\\n            maxB=Math.max(maxB,b);\\n            String bottomLeft=x+\":\"+y;\\n            String bottomRight=a+\":\"+y;\\n            String topLeft=x+\":\"+b;\\n            String topRight=a+\":\"+b;\\n            if(!hs.contains(bottomLeft))\\n                hs.add(bottomLeft);\\n            else\\n                hs.remove(bottomLeft);\\n            if(!hs.contains(bottomRight))\\n                hs.add(bottomRight);\\n            else\\n                hs.remove(bottomRight);\\n            if(!hs.contains(topLeft))\\n                hs.add(topLeft);\\n            else\\n                hs.remove(topLeft);\\n            if(!hs.contains(topRight))\\n                hs.add(topRight);\\n            else\\n                hs.remove(topRight);\\n        }\\n        String FullbottomLeft=minX+\":\"+minY;\\n        String FullbottomRight=maxA+\":\"+minY;\\n        String FulltopLeft=minX+\":\"+maxB;\\n        String FulltopRight=maxA+\":\"+maxB;\\n        if(!(hs.size()==4) || !hs.contains(FullbottomLeft) || !hs.contains(FullbottomRight) || !hs.contains(FulltopRight) || !hs.contains(FulltopLeft))\\n            return false;\\n        int newarea=Math.abs(minX-maxA)*Math.abs(minY-maxB);\\n        if(newarea==area)\\n            return true;\\n        return false;\\n        \\n    }\\n}\\n```\\n**IF YOU LIKED THE APPROACH PLEASE UPVOTE \\uD83D\\uDE4F\\uD83D\\uDE4F\\uD83D\\uDE4F**",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isRectangleCover(int[][] rectangles) {\\n        HashSet<String> hs=new HashSet<>();\\n        int area=0;\\n        int minX=Integer.MAX_VALUE;\\n        int minY=Integer.MAX_VALUE;\\n        int maxA=Integer.MIN_VALUE;\\n        int maxB=Integer.MIN_VALUE;\\n        for(int i=0;i<rectangles.length;i++){\\n            int x=rectangles[i][0];\\n            int y=rectangles[i][1];\\n            int a=rectangles[i][2];\\n            int b=rectangles[i][3];\\n            area+=Math.abs(y-b)*Math.abs(x-a);\\n            minX=Math.min(minX,x);\\n            minY=Math.min(minY,y);\\n            maxA=Math.max(maxA,a);\\n            maxB=Math.max(maxB,b);\\n            String bottomLeft=x+\":\"+y;\\n            String bottomRight=a+\":\"+y;\\n            String topLeft=x+\":\"+b;\\n            String topRight=a+\":\"+b;\\n            if(!hs.contains(bottomLeft))\\n                hs.add(bottomLeft);\\n            else\\n                hs.remove(bottomLeft);\\n            if(!hs.contains(bottomRight))\\n                hs.add(bottomRight);\\n            else\\n                hs.remove(bottomRight);\\n            if(!hs.contains(topLeft))\\n                hs.add(topLeft);\\n            else\\n                hs.remove(topLeft);\\n            if(!hs.contains(topRight))\\n                hs.add(topRight);\\n            else\\n                hs.remove(topRight);\\n        }\\n        String FullbottomLeft=minX+\":\"+minY;\\n        String FullbottomRight=maxA+\":\"+minY;\\n        String FulltopLeft=minX+\":\"+maxB;\\n        String FulltopRight=maxA+\":\"+maxB;\\n        if(!(hs.size()==4) || !hs.contains(FullbottomLeft) || !hs.contains(FullbottomRight) || !hs.contains(FulltopRight) || !hs.contains(FulltopLeft))\\n            return false;\\n        int newarea=Math.abs(minX-maxA)*Math.abs(minY-maxB);\\n        if(newarea==area)\\n            return true;\\n        return false;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2027717,
                "title": "python-o-n-solution",
                "content": "* Coordinates with even number of occurrences must be removed from set \\n*  Coordinates with odd number of occurrences must only appear four times as they represent four corners in the perfect square\\n*  Area of small rectangles add up to the area of the large rectangle\\n\\n```\\nclass Solution(object):\\n    def isRectangleCover(self, rectangles):\\n        \"\"\"\\n        :type rectangles: List[List[int]]\\n        :rtype: bool\\n        \"\"\"\\n        area = 0\\n        corners = set()\\n        for x1, y1, x2, y2 in rectangles:\\n            bottom_left = (x1,y1) \\n            upper_left = (x1,y2)\\n            bottom_right = (x2,y1)\\n            upper_right = (x2,y2)\\n            corners ^= {bottom_left, upper_left, bottom_right, upper_right}\\n            area += (y2 - y1) * (x2 - x1)\\n            \\n        if len(corners) != 4:\\n            return False \\n        \\n        \\n        else:\\n            bottom_left = min(corners, key = lambda x: x[0] + x[1])\\n            upper_right = max(corners, key = lambda x: x[0] + x[1])\\n            return area == (upper_right[1] - bottom_left[1]) * (upper_right[0] - bottom_left[0])\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Math",
                    "Geometry"
                ],
                "code": "```\\nclass Solution(object):\\n    def isRectangleCover(self, rectangles):\\n        \"\"\"\\n        :type rectangles: List[List[int]]\\n        :rtype: bool\\n        \"\"\"\\n        area = 0\\n        corners = set()\\n        for x1, y1, x2, y2 in rectangles:\\n            bottom_left = (x1,y1) \\n            upper_left = (x1,y2)\\n            bottom_right = (x2,y1)\\n            upper_right = (x2,y2)\\n            corners ^= {bottom_left, upper_left, bottom_right, upper_right}\\n            area += (y2 - y1) * (x2 - x1)\\n            \\n        if len(corners) != 4:\\n            return False \\n        \\n        \\n        else:\\n            bottom_left = min(corners, key = lambda x: x[0] + x[1])\\n            upper_right = max(corners, key = lambda x: x[0] + x[1])\\n            return area == (upper_right[1] - bottom_left[1]) * (upper_right[0] - bottom_left[0])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1959356,
                "title": "java-beats-100-00-memory-speed-0ms-april-2022",
                "content": "\\n\\tclass Solution {\\n\\n    public boolean isRectangleCover(int[][] rectangles) {\\n        //base check\\n        if (rectangles.length == 0 || rectangles[0].length == 0) return false;\\n        Set<String> points = new HashSet<String>();\\n        int area = 0;\\n        //full rectangle coordinates\\n        int minX = Integer.MAX_VALUE;\\n        int minY = Integer.MAX_VALUE;\\n        int maxA = Integer.MIN_VALUE;\\n        int maxB = Integer.MIN_VALUE;\\n        //iterate all the rectangles\\n        for (int[] r : rectangles){\\n            //get the points, find area and add to previous area\\n            int x = r[0];\\n            int y = r[1];\\n            int a = r[2];\\n            int b = r[3];\\n            area += (x-a) * (y-b);\\n            //record min and max points each time\\n            minX = Math.min(minX, x);\\n            minY = Math.min(minY, y);\\n            maxA = Math.max(maxA, a);\\n            maxB = Math.max(maxB, b);\\n            //get the string to store in the set\\n            String bottomLeft = getHash(x,y);\\n            String topLeft = getHash(x,b);\\n            String bottomRight = getHash(a,y);\\n            String topRight = getHash(a,b);\\n            //remove all intermediate points if it exists\\n            //finally only 4 coordinates will be left behind to form the full rectangle\\n            checkInSet(points, bottomLeft);\\n            checkInSet(points, topLeft);\\n            checkInSet(points, bottomRight);\\n            checkInSet(points, topRight);\\n        }\\n        //get the string to read from the set\\n        String fullBottomLeft = getHash(minX,minY);\\n        String fullTopLeft = getHash(minX,maxB);\\n        String fullBottomRight = getHash(maxA,minY);\\n        String fullTopRight = getHash(maxA,maxB);\\n        //make sure the size is 4 and all the coordinate has exists in the set\\n        if (points.size() != 4 || !points.contains(fullBottomLeft) \\n            || !points.contains(fullTopLeft) || !points.contains(fullBottomRight) || !points.contains(fullTopRight)) return false;\\n        //compute the full rectangle area\\n        int fullArea = (minX-maxA) * (minY-maxB);\\n        // this should be equal\\n        return area == fullArea;\\n    }\\n\\t// method to check if the hash value exist in the set or not\\n    // if it exists then it means its a duplicate coordinate of previous rectangle added, so remove it\\n    // finally the set will contain only 4 corner coordinates\\n    private void checkInSet(Set<String> points, String hash){\\n        if (!points.contains(hash)) points.add(hash);\\n        else points.remove(hash);\\n    }\\n    //helper to return simple hash to store in the set\\n    private String getHash(int x, int y){\\n        return x + \":\" + y;\\n    }\\n\\t}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\n    public boolean isRectangleCover(int[][] rectangles) {\\n        //base check\\n        if (rectangles.length == 0 || rectangles[0].length == 0) return false;\\n        Set<String> points = new HashSet<String>();\\n        int area = 0;\\n        //full rectangle coordinates\\n        int minX = Integer.MAX_VALUE;\\n        int minY = Integer.MAX_VALUE;\\n        int maxA = Integer.MIN_VALUE;\\n        int maxB = Integer.MIN_VALUE;\\n        //iterate all the rectangles\\n        for (int[] r : rectangles){\\n            //get the points, find area and add to previous area\\n            int x = r[0];\\n            int y = r[1];\\n            int a = r[2];\\n            int b = r[3];\\n            area += (x-a) * (y-b);\\n            //record min and max points each time\\n            minX = Math.min(minX, x);\\n            minY = Math.min(minY, y);\\n            maxA = Math.max(maxA, a);\\n            maxB = Math.max(maxB, b);\\n            //get the string to store in the set\\n            String bottomLeft = getHash(x,y);\\n            String topLeft = getHash(x,b);\\n            String bottomRight = getHash(a,y);\\n            String topRight = getHash(a,b);\\n            //remove all intermediate points if it exists\\n            //finally only 4 coordinates will be left behind to form the full rectangle\\n            checkInSet(points, bottomLeft);\\n            checkInSet(points, topLeft);\\n            checkInSet(points, bottomRight);\\n            checkInSet(points, topRight);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 524809,
                "title": "java-o-n-using-corner-counter-and-area-check",
                "content": "```\\npublic boolean isRectangleCover(int[][] rs) {\\n        Set<String> ps = new HashSet<>();\\n        int a = 0;\\n        int x1 = Integer.MAX_VALUE;\\n        int y1 = Integer.MAX_VALUE;\\n        int x2 = Integer.MIN_VALUE;\\n        int y2 = Integer.MIN_VALUE;\\n        for (int[] r : rs) {\\n            x1 = Math.min(x1, r[0]);\\n            y1 = Math.min(y1, r[1]);\\n            x2 = Math.max(x2, r[2]);\\n            y2 = Math.max(y2, r[3]);\\n            a += (r[2] - r[0]) * (r[3] - r[1]);\\n            String lb = r[0] + \" \" + r[1];\\n            String lu = r[0] + \" \" + r[3];\\n            String br = r[2] + \" \" + r[1];\\n            String ur = r[2] + \" \" + r[3];\\n            if (!ps.add(lb)) ps.remove(lb);\\n            if (!ps.add(lu)) ps.remove(lu);\\n            if (!ps.add(br)) ps.remove(br);\\n            if (!ps.add(ur)) ps.remove(ur);\\n        }\\n        \\n        if (!(ps.size() == 4)\\n            || !(ps.contains(x1 + \" \" + y1))\\n            || !(ps.contains(x1 + \" \" + y2))\\n            || !(ps.contains(x2 + \" \" + y1))\\n            || !(ps.contains(x2 + \" \" + y2))) return false;\\n        return a == (x1 - x2) * (y1 - y2);\\n    } \\n```\\nref \\n; https://leetcode.com/problems/perfect-rectangle/discuss/87180/O(n)-solution-by-counting-corners-with-detailed-explaination",
                "solutionTags": [],
                "code": "```\\npublic boolean isRectangleCover(int[][] rs) {\\n        Set<String> ps = new HashSet<>();\\n        int a = 0;\\n        int x1 = Integer.MAX_VALUE;\\n        int y1 = Integer.MAX_VALUE;\\n        int x2 = Integer.MIN_VALUE;\\n        int y2 = Integer.MIN_VALUE;\\n        for (int[] r : rs) {\\n            x1 = Math.min(x1, r[0]);\\n            y1 = Math.min(y1, r[1]);\\n            x2 = Math.max(x2, r[2]);\\n            y2 = Math.max(y2, r[3]);\\n            a += (r[2] - r[0]) * (r[3] - r[1]);\\n            String lb = r[0] + \" \" + r[1];\\n            String lu = r[0] + \" \" + r[3];\\n            String br = r[2] + \" \" + r[1];\\n            String ur = r[2] + \" \" + r[3];\\n            if (!ps.add(lb)) ps.remove(lb);\\n            if (!ps.add(lu)) ps.remove(lu);\\n            if (!ps.add(br)) ps.remove(br);\\n            if (!ps.add(ur)) ps.remove(ur);\\n        }\\n        \\n        if (!(ps.size() == 4)\\n            || !(ps.contains(x1 + \" \" + y1))\\n            || !(ps.contains(x1 + \" \" + y2))\\n            || !(ps.contains(x2 + \" \" + y1))\\n            || !(ps.contains(x2 + \" \" + y2))) return false;\\n        return a == (x1 - x2) * (y1 - y2);\\n    } \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 222332,
                "title": "simple-c-solution-with-coordinate-compression",
                "content": "You can search Google for details on coordinate compression.\\n\\nIt\\'s simply replacing every integer from 0.\\n\\nSuppose you have a point (100, 200, 200, 300), and then it compresses into (0, 1, 1, 2).\\n\\n```\\nclass Solution {\\npublic:\\n    bool isRectangleCover(vector<vector<int>>& rects) {\\n        // Compress Part\\n        map<int, int> compress;\\n        for (vector<int> rect : rects) {\\n            for (int n : rect){\\n                compress.insert({n, 0});\\n            }\\n        }\\n        int n = 0;\\n        for (auto it = compress.begin(); it != compress.end(); it++){\\n            it->second = n++;\\n        }\\n        \\n        int xMin = INT_MAX, yMin = INT_MAX, xMax = INT_MIN, yMax = INT_MIN;\\n        for (int i = 0; i < rects.size(); i++) {\\n            rects[i][0] = compress[rects[i][0]];\\n            rects[i][1] = compress[rects[i][1]];\\n            rects[i][2] = compress[rects[i][2]];\\n            rects[i][3] = compress[rects[i][3]];\\n            xMin = min(xMin, rects[i][0]);\\n            yMin = min(yMin, rects[i][1]);\\n            xMax = max(xMax, rects[i][2]);\\n            yMax = max(yMax, rects[i][3]);\\n        }\\n        \\n        vector<vector<bool>> covered(xMax, vector<bool>(yMax, false));\\n        \\n        // Check for Overlap\\n        for (vector<int> rect : rects) {\\n            for (int x = rect[0]; x < rect[2]; x++){\\n                for (int y = rect[1]; y < rect[3]; y++){\\n                    if (covered[x][y])  return false;\\n                    covered[x][y] = true;\\n                }\\n            }\\n        }\\n        \\n        // Check for Gap\\n        for (int x = xMin; x < xMax; x++){\\n            for (int y = yMin; y < yMax; y++){\\n                if (!covered[x][y]) return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isRectangleCover(vector<vector<int>>& rects) {\\n        // Compress Part\\n        map<int, int> compress;\\n        for (vector<int> rect : rects) {\\n            for (int n : rect){\\n                compress.insert({n, 0});\\n            }\\n        }\\n        int n = 0;\\n        for (auto it = compress.begin(); it != compress.end(); it++){\\n            it->second = n++;\\n        }\\n        \\n        int xMin = INT_MAX, yMin = INT_MAX, xMax = INT_MIN, yMax = INT_MIN;\\n        for (int i = 0; i < rects.size(); i++) {\\n            rects[i][0] = compress[rects[i][0]];\\n            rects[i][1] = compress[rects[i][1]];\\n            rects[i][2] = compress[rects[i][2]];\\n            rects[i][3] = compress[rects[i][3]];\\n            xMin = min(xMin, rects[i][0]);\\n            yMin = min(yMin, rects[i][1]);\\n            xMax = max(xMax, rects[i][2]);\\n            yMax = max(yMax, rects[i][3]);\\n        }\\n        \\n        vector<vector<bool>> covered(xMax, vector<bool>(yMax, false));\\n        \\n        // Check for Overlap\\n        for (vector<int> rect : rects) {\\n            for (int x = rect[0]; x < rect[2]; x++){\\n                for (int y = rect[1]; y < rect[3]; y++){\\n                    if (covered[x][y])  return false;\\n                    covered[x][y] = true;\\n                }\\n            }\\n        }\\n        \\n        // Check for Gap\\n        for (int x = xMin; x < xMax; x++){\\n            for (int y = yMin; y < yMax; y++){\\n                if (!covered[x][y]) return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 87210,
                "title": "simple-python-o-n-solution-by-cancelling-corners-explained",
                "content": "The idea is simple:\\nthere are 4 types of corners: 0: '\\u2517', 1: '\\u250f', 2: '\\u251b',  and 3: '\\u2513'.\\nAt the same point, corner 0 will cancel corner 1 or 2. Similarly, 1 will cancel 0 or 3, 2 will cancel 0 or 3, 3 will cancel 1 or 2.\\nAnd for all the given rectangles to form an exact cover of a rectangular region, all corners should be cancelled except for the 4 corners of the rectangular region.\\nWe can use a Set to keep track of the corners: for each rectangle we are given, we check all its 4 corners (4 types), if they can cancel a corner in the set, then cancel that corner; else we put them in the set. At the end, we should have a set with the  only 4 corners of the rectangular region in it, otherwise we return False.\\n```\\n    def isRectangleCover(self, rectangles):\\n        \"\"\"\\n        :type rectangles: List[List[int]]\\n        :rtype: bool\\n        \"\"\"\\n        points = set()\\n        min_x, min_y, max_x, max_y = rectangles[0]\\n        cancel = [(1, 2), (0, 3), (0, 3), (1, 2)]\\n\\n        for x1, y1, x2, y2 in rectangles:\\n            for x, y, d in [(x1, y1, 0), (x1, y2, 1), (x2, y1, 2), (x2, y2, 3)]:\\n                if (x, y, d) in points:  # there should be no same type of corner at the same point\\n                        return False\\n                c1, c2 = cancel[d]\\n                if (x, y, c1) in points:\\n                    points.remove((x, y, c1))\\n                    continue\\n                elif (x, y, c2) in points:\\n                    points.remove((x, y, c2))\\n                    continue\\n                else:\\n                    points.add((x, y, d))\\n\\n            min_x, min_y, max_x, max_y = min(min_x, x1), min(min_y, y1), max(max_x, x2), max(max_y, y2)\\n\\n        return points == {(min_x, min_y, 0), (min_x, max_y, 1), (max_x, min_y, 2), (max_x, max_y, 3)}\\n```",
                "solutionTags": [],
                "code": "```\\n    def isRectangleCover(self, rectangles):\\n        \"\"\"\\n        :type rectangles: List[List[int]]\\n        :rtype: bool\\n        \"\"\"\\n        points = set()\\n        min_x, min_y, max_x, max_y = rectangles[0]\\n        cancel = [(1, 2), (0, 3), (0, 3), (1, 2)]\\n\\n        for x1, y1, x2, y2 in rectangles:\\n            for x, y, d in [(x1, y1, 0), (x1, y2, 1), (x2, y1, 2), (x2, y2, 3)]:\\n                if (x, y, d) in points:  # there should be no same type of corner at the same point\\n                        return False\\n                c1, c2 = cancel[d]\\n                if (x, y, c1) in points:\\n                    points.remove((x, y, c1))\\n                    continue\\n                elif (x, y, c2) in points:\\n                    points.remove((x, y, c2))\\n                    continue\\n                else:\\n                    points.add((x, y, d))\\n\\n            min_x, min_y, max_x, max_y = min(min_x, x1), min(min_y, y1), max(max_x, x2), max(max_y, y2)\\n\\n        return points == {(min_x, min_y, 0), (min_x, max_y, 1), (max_x, min_y, 2), (max_x, max_y, 3)}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 87214,
                "title": "python-sweep-line-solution-using-bisect",
                "content": "\\n    def isRectangleCover(self, rectangles):\\n        area = 0\\n        minx,miny = sys.maxint,sys.maxint\\n        maxx,maxy = -sys.maxint,-sys.maxint\\n        vertical = []\\n        for x1,y1,x2,y2 in rectangles:\\n            minx,miny = min(x1,minx), min(y1,miny)\\n            maxx,maxy = max(x2,maxx), max(y2,maxy)\\n            area += (y2-y1)*(x2-x1)\\n            vertical.append((x1,1,y1,y2))\\n            vertical.append((x2,-1,y1,y2))\\n        if area != (maxx-minx)*(maxy-miny):\\n            return False\\n        e = []\\n        vertical.sort()\\n        for x,t,y1,y2 in vertical:\\n            if t > 0:\\n                i = bisect.bisect_left(e,(y1,y2))\\n                bisect.insort_left(e,(y1,y2))\\n                if i+1<len(e) and e[i][1]>e[i+1][0] or i>0 and e[i][0]<e[i-1][1]: return False\\n            else:\\n                e.remove((y1,y2))\\n        return True",
                "solutionTags": [],
                "code": "\\n    def isRectangleCover(self, rectangles):\\n        area = 0\\n        minx,miny = sys.maxint,sys.maxint\\n        maxx,maxy = -sys.maxint,-sys.maxint\\n        vertical = []\\n        for x1,y1,x2,y2 in rectangles:\\n            minx,miny = min(x1,minx), min(y1,miny)\\n            maxx,maxy = max(x2,maxx), max(y2,maxy)\\n            area += (y2-y1)*(x2-x1)\\n            vertical.append((x1,1,y1,y2))\\n            vertical.append((x2,-1,y1,y2))\\n        if area != (maxx-minx)*(maxy-miny):\\n            return False\\n        e = []\\n        vertical.sort()\\n        for x,t,y1,y2 in vertical:\\n            if t > 0:\\n                i = bisect.bisect_left(e,(y1,y2))\\n                bisect.insort_left(e,(y1,y2))\\n                if i+1<len(e) and e[i][1]>e[i+1][0] or i>0 and e[i][0]<e[i-1][1]: return False\\n            else:\\n                e.remove((y1,y2))\\n        return True",
                "codeTag": "Python3"
            },
            {
                "id": 3254768,
                "title": "391-time-95-62-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Initialize the area of all the rectangles to 0 and create a set to keep track of the corners of the rectangles.\\n```\\narea = 0\\ncorners = set()\\n```\\n2. Iterate over each rectangle in the input list and do the following:\\na. Add the area of the rectangle to the total area.\\nb. Check if each corner of the rectangle is unique. If it is, add it to the set of corners. If it is not, remove it from the set of corners.\\n```\\nfor x1, y1, x2, y2 in rectangles:\\n    area += (x2 - x1) * (y2 - y1)\\n    for corner in [(x1, y1), (x1, y2), (x2, y1), (x2, y2)]:\\n        if corner in corners:\\n            corners.remove(corner)\\n        else:\\n            corners.add(corner)\\n```\\n3. Check if all corners of the rectangles are unique. If they are not, return False.\\n```\\nif len(corners) != 4:\\n    return False\\n```\\n4. Find the coordinates of the union rectangle by finding the minimum and maximum x and y coordinates of all the corners.\\n```\\nx1, y1 = float(\"inf\"), float(\"inf\")\\nx2, y2 = float(\"-inf\"), float(\"-inf\")\\nfor x, y in corners:\\n    x1 = min(x1, x)\\n    y1 = min(y1, y)\\n    x2 = max(x2, x)\\n    y2 = max(y2, y)\\n```\\n5. Calculate the area of the union rectangle.\\n```\\nunion_area = (x2 - x1) * (y2 - y1)\\n```\\n6. Check if the total area of all the rectangles is equal to the area of the union rectangle. If it is not, return False.\\n```\\nif area != union_area:\\n    return False\\n```\\n7. Check if the total number of corners is equal to the sum of the areas of the rectangles divided by the area of a single rectangle. If it is not, return False.\\n```\\nreturn area == (x2 - x1) * (y2 - y1)\\n```\\n8. If all the above conditions are satisfied, return True.\\n# Complexity\\n- Time complexity:\\n95.62%\\n\\n- Space complexity:\\n43.3%\\n\\n# Code\\n```\\nclass Solution:\\n    def isRectangleCover(self, rectangles: List[List[int]]) -> bool:\\n        # calculate the area of all the rectangles\\n        area = 0\\n        corners = set()\\n        for x1, y1, x2, y2 in rectangles:\\n            area += (x2 - x1) * (y2 - y1)\\n            # check if each corner is unique\\n            for corner in [(x1, y1), (x1, y2), (x2, y1), (x2, y2)]:\\n                if corner in corners:\\n                    corners.remove(corner)\\n                else:\\n                    corners.add(corner)\\n        # check if all corners are unique\\n        if len(corners) != 4:\\n            return False\\n        # calculate the area of the union rectangle\\n        x1, y1 = float(\"inf\"), float(\"inf\")\\n        x2, y2 = float(\"-inf\"), float(\"-inf\")\\n        for x, y in corners:\\n            x1 = min(x1, x)\\n            y1 = min(y1, y)\\n            x2 = max(x2, x)\\n            y2 = max(y2, y)\\n        union_area = (x2 - x1) * (y2 - y1)\\n        # check if the total area of all the rectangles is equal to the area of the union rectangle\\n        if area != union_area:\\n            return False\\n        # check if the total number of corners is equal to the sum of the areas of the rectangles divided by the area of a single rectangle\\n        return area == (x2 - x1) * (y2 - y1)\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Line Sweep"
                ],
                "code": "```\\narea = 0\\ncorners = set()\\n```\n```\\nfor x1, y1, x2, y2 in rectangles:\\n    area += (x2 - x1) * (y2 - y1)\\n    for corner in [(x1, y1), (x1, y2), (x2, y1), (x2, y2)]:\\n        if corner in corners:\\n            corners.remove(corner)\\n        else:\\n            corners.add(corner)\\n```\n```\\nif len(corners) != 4:\\n    return False\\n```\n```\\nx1, y1 = float(\"inf\"), float(\"inf\")\\nx2, y2 = float(\"-inf\"), float(\"-inf\")\\nfor x, y in corners:\\n    x1 = min(x1, x)\\n    y1 = min(y1, y)\\n    x2 = max(x2, x)\\n    y2 = max(y2, y)\\n```\n```\\nunion_area = (x2 - x1) * (y2 - y1)\\n```\n```\\nif area != union_area:\\n    return False\\n```\n```\\nreturn area == (x2 - x1) * (y2 - y1)\\n```\n```\\nclass Solution:\\n    def isRectangleCover(self, rectangles: List[List[int]]) -> bool:\\n        # calculate the area of all the rectangles\\n        area = 0\\n        corners = set()\\n        for x1, y1, x2, y2 in rectangles:\\n            area += (x2 - x1) * (y2 - y1)\\n            # check if each corner is unique\\n            for corner in [(x1, y1), (x1, y2), (x2, y1), (x2, y2)]:\\n                if corner in corners:\\n                    corners.remove(corner)\\n                else:\\n                    corners.add(corner)\\n        # check if all corners are unique\\n        if len(corners) != 4:\\n            return False\\n        # calculate the area of the union rectangle\\n        x1, y1 = float(\"inf\"), float(\"inf\")\\n        x2, y2 = float(\"-inf\"), float(\"-inf\")\\n        for x, y in corners:\\n            x1 = min(x1, x)\\n            y1 = min(y1, y)\\n            x2 = max(x2, x)\\n            y2 = max(y2, y)\\n        union_area = (x2 - x1) * (y2 - y1)\\n        # check if the total area of all the rectangles is equal to the area of the union rectangle\\n        if area != union_area:\\n            return False\\n        # check if the total number of corners is equal to the sum of the areas of the rectangles divided by the area of a single rectangle\\n        return area == (x2 - x1) * (y2 - y1)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2286868,
                "title": "python3-short-very-easy-with-comments-o-n",
                "content": "def isRectangleCover(self, rectangles: List[List[int]]) -> bool:\\n        # simple problem -> Check if area of each adds up to the final one\\n        #                   -> If not no solution but if it does then you need to make sure the number of corners are 4 only.\\n        #                       -> If the corners are more than that that means some corners do not match with other ones to fit end to end\\n        area = 0\\n        corners = set()\\n        a = lambda: (Y - y) * (X - x)\\n        c = lambda k: k[0] + k[1]\\n        \\n        for x, y, X, Y in rectangles:\\n            area += a()\\n            corners ^= {(x, Y), (X, y), (x, y), (X, Y)}\\n        \\n        if len(corners) != 4:\\n            return False\\n        x, y = min(corners, key = c)\\n        X, Y = max(corners, key = c)\\n        return area == a()",
                "solutionTags": [
                    "Python3",
                    "Iterator"
                ],
                "code": "def isRectangleCover(self, rectangles: List[List[int]]) -> bool:\\n        # simple problem -> Check if area of each adds up to the final one\\n        #                   -> If not no solution but if it does then you need to make sure the number of corners are 4 only.\\n        #                       -> If the corners are more than that that means some corners do not match with other ones to fit end to end\\n        area = 0\\n        corners = set()\\n        a = lambda: (Y - y) * (X - x)\\n        c = lambda k: k[0] + k[1]\\n        \\n        for x, y, X, Y in rectangles:\\n            area += a()\\n            corners ^= {(x, Y), (X, y), (x, y), (X, Y)}\\n        \\n        if len(corners) != 4:\\n            return False\\n        x, y = min(corners, key = c)\\n        X, Y = max(corners, key = c)\\n        return area == a()",
                "codeTag": "Python3"
            },
            {
                "id": 1468211,
                "title": "easy-c-solution",
                "content": "Approach:\\n1). All end corners of greater rectangle should have count == 1 and every other point should have either 2 or 4 count \\n2). Area of greater rectangle should be sum of areas of all other rectangles \\n3).if there is a space between two rectangles there would be more corners with count == 1 and area will not be equal\\n\\n4)if there is overlapping the area would not be equal\\n\\n5)if there is overlaping and space between some combination of rectangles then first condition have to be false for area to be equal\\n\\n\\n```\\nclass Solution {\\n\\npublic:\\n    bool isRectangleCover(vector<vector<int>>& rectangles) {\\n        int area = 0;\\n        int vertex[] = {INT_MAX,INT_MAX,INT_MIN,INT_MIN};\\n                     // mnx ,  mny , mx , my           \\n        map<pair<int,int>,int>points;\\n        \\n        for(auto temp : rectangles){\\n            area += abs(temp[0] - temp[2]) * abs(temp[1] - temp[3]);\\n            \\n            points[{temp[0],temp[1]}] += 1;\\n            points[{temp[2],temp[3]}] += 1;\\n            points[{temp[0],temp[3]}] += 1;\\n            points[{temp[2],temp[1]}] += 1;\\n            \\n            vertex[0] = min(temp[0],vertex[0]);\\n            vertex[1] = min(temp[1],vertex[1]);\\n            vertex[2] = max(temp[2],vertex[2]);\\n            vertex[3] = max(temp[3],vertex[3]);\\n        }\\n        \\n        int true_area = abs(vertex[2]-vertex[0])*abs(vertex[3]-vertex[1]);\\n        \\n        vector<pair<int,int>>end_points;\\n        for(auto temp : points){\\n            if(temp.second == 1){\\n                end_points.push_back(temp.first);\\n            }else if(temp.second == 3){\\n                return false;\\n            }\\n        }\\n        \\n        int pairs[] = {0,1,0,3,2,1,2,3};\\n        \\n        for(int i = 0 ; i<8; i+=2){\\n            pair<int,int>corner = {vertex[pairs[i]],vertex[pairs[i+1]]};\\n            bool rec = false;\\n            for(auto temp : end_points){\\n                if(temp == corner){\\n                    rec = true;\\n                    break;\\n                }\\n            }\\n            if(!rec){\\n                return false;\\n            }\\n        }\\n        \\n        \\n        return (true_area == area && (int)end_points.size() == 4);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\npublic:\\n    bool isRectangleCover(vector<vector<int>>& rectangles) {\\n        int area = 0;\\n        int vertex[] = {INT_MAX,INT_MAX,INT_MIN,INT_MIN};\\n                     // mnx ,  mny , mx , my           \\n        map<pair<int,int>,int>points;\\n        \\n        for(auto temp : rectangles){\\n            area += abs(temp[0] - temp[2]) * abs(temp[1] - temp[3]);\\n            \\n            points[{temp[0],temp[1]}] += 1;\\n            points[{temp[2],temp[3]}] += 1;\\n            points[{temp[0],temp[3]}] += 1;\\n            points[{temp[2],temp[1]}] += 1;\\n            \\n            vertex[0] = min(temp[0],vertex[0]);\\n            vertex[1] = min(temp[1],vertex[1]);\\n            vertex[2] = max(temp[2],vertex[2]);\\n            vertex[3] = max(temp[3],vertex[3]);\\n        }\\n        \\n        int true_area = abs(vertex[2]-vertex[0])*abs(vertex[3]-vertex[1]);\\n        \\n        vector<pair<int,int>>end_points;\\n        for(auto temp : points){\\n            if(temp.second == 1){\\n                end_points.push_back(temp.first);\\n            }else if(temp.second == 3){\\n                return false;\\n            }\\n        }\\n        \\n        int pairs[] = {0,1,0,3,2,1,2,3};\\n        \\n        for(int i = 0 ; i<8; i+=2){\\n            pair<int,int>corner = {vertex[pairs[i]],vertex[pairs[i+1]]};\\n            bool rec = false;\\n            for(auto temp : end_points){\\n                if(temp == corner){\\n                    rec = true;\\n                    break;\\n                }\\n            }\\n            if(!rec){\\n                return false;\\n            }\\n        }\\n        \\n        \\n        return (true_area == area && (int)end_points.size() == 4);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1199162,
                "title": "java-solution-with-comment-explanation",
                "content": "```\\nclass Solution {\\n    public boolean isRectangleCover(int[][] rectangles) {\\n        //base check\\n        if (rectangles.length == 0 || rectangles[0].length == 0) return false;\\n        Set<String> points = new HashSet<String>();\\n        int area = 0;\\n        //full rectangle coordinates\\n        int minX = Integer.MAX_VALUE;\\n        int minY = Integer.MAX_VALUE;\\n        int maxA = Integer.MIN_VALUE;\\n        int maxB = Integer.MIN_VALUE;\\n        //iterate all the rectangles\\n        for (int[] r : rectangles){\\n            //get the points, find area and add to previous area\\n            int x = r[0];\\n            int y = r[1];\\n            int a = r[2];\\n            int b = r[3];\\n            area += (x-a) * (y-b);\\n            //record min and max points each time\\n            minX = Math.min(minX, x);\\n            minY = Math.min(minY, y);\\n            maxA = Math.max(maxA, a);\\n            maxB = Math.max(maxB, b);\\n            //get the string to store in the set\\n            String bottomLeft = getHash(x,y);\\n            String topLeft = getHash(x,b);\\n            String bottomRight = getHash(a,y);\\n            String topRight = getHash(a,b);\\n            //remove all intermediate points if it exists\\n            //finally only 4 coordinates will be left behind to form the full rectangle\\n            checkInSet(points, bottomLeft);\\n            checkInSet(points, topLeft);\\n            checkInSet(points, bottomRight);\\n            checkInSet(points, topRight);\\n        }\\n        //get the string to read from the set\\n        String fullBottomLeft = getHash(minX,minY);\\n        String fullTopLeft = getHash(minX,maxB);\\n        String fullBottomRight = getHash(maxA,minY);\\n        String fullTopRight = getHash(maxA,maxB);\\n        //make sure the size is 4 and all the coordinate has exists in the set\\n        if (points.size() != 4 || !points.contains(fullBottomLeft) \\n            || !points.contains(fullTopLeft) || !points.contains(fullBottomRight) || !points.contains(fullTopRight)) return false;\\n        //compute the full rectangle area\\n        int fullArea = (minX-maxA) * (minY-maxB);\\n        // this should be equal\\n        return area == fullArea;\\n    }\\n\\t// method to check if the hash value exist in the set or not\\n    // if it exists then it means its a duplicate coordinate of previous rectangle added, so remove it\\n    // finally the set will contain only 4 corner coordinates\\n    private void checkInSet(Set<String> points, String hash){\\n        if (!points.contains(hash)) points.add(hash);\\n        else points.remove(hash);\\n    }\\n    //helper to return simple hash to store in the set\\n    private String getHash(int x, int y){\\n        return x + \":\" + y;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isRectangleCover(int[][] rectangles) {\\n        //base check\\n        if (rectangles.length == 0 || rectangles[0].length == 0) return false;\\n        Set<String> points = new HashSet<String>();\\n        int area = 0;\\n        //full rectangle coordinates\\n        int minX = Integer.MAX_VALUE;\\n        int minY = Integer.MAX_VALUE;\\n        int maxA = Integer.MIN_VALUE;\\n        int maxB = Integer.MIN_VALUE;\\n        //iterate all the rectangles\\n        for (int[] r : rectangles){\\n            //get the points, find area and add to previous area\\n            int x = r[0];\\n            int y = r[1];\\n            int a = r[2];\\n            int b = r[3];\\n            area += (x-a) * (y-b);\\n            //record min and max points each time\\n            minX = Math.min(minX, x);\\n            minY = Math.min(minY, y);\\n            maxA = Math.max(maxA, a);\\n            maxB = Math.max(maxB, b);\\n            //get the string to store in the set\\n            String bottomLeft = getHash(x,y);\\n            String topLeft = getHash(x,b);\\n            String bottomRight = getHash(a,y);\\n            String topRight = getHash(a,b);\\n            //remove all intermediate points if it exists\\n            //finally only 4 coordinates will be left behind to form the full rectangle\\n            checkInSet(points, bottomLeft);\\n            checkInSet(points, topLeft);\\n            checkInSet(points, bottomRight);\\n            checkInSet(points, topRight);\\n        }\\n        //get the string to read from the set\\n        String fullBottomLeft = getHash(minX,minY);\\n        String fullTopLeft = getHash(minX,maxB);\\n        String fullBottomRight = getHash(maxA,minY);\\n        String fullTopRight = getHash(maxA,maxB);\\n        //make sure the size is 4 and all the coordinate has exists in the set\\n        if (points.size() != 4 || !points.contains(fullBottomLeft) \\n            || !points.contains(fullTopLeft) || !points.contains(fullBottomRight) || !points.contains(fullTopRight)) return false;\\n        //compute the full rectangle area\\n        int fullArea = (minX-maxA) * (minY-maxB);\\n        // this should be equal\\n        return area == fullArea;\\n    }\\n\\t// method to check if the hash value exist in the set or not\\n    // if it exists then it means its a duplicate coordinate of previous rectangle added, so remove it\\n    // finally the set will contain only 4 corner coordinates\\n    private void checkInSet(Set<String> points, String hash){\\n        if (!points.contains(hash)) points.add(hash);\\n        else points.remove(hash);\\n    }\\n    //helper to return simple hash to store in the set\\n    private String getHash(int x, int y){\\n        return x + \":\" + y;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 832927,
                "title": "javascript-100-o-n",
                "content": "Track corners, total area, and bounds. It\\'s valid if the only unique corners are the bounds and the areas of the bounds matches the area sum of each rect.\\n\\nI created `keyit` as a sliightly quicker alternative to strings for keeping track of unique coordinates. 1 / y creates unique decimals for all coords other than 0 (inf)\\n\\n```\\nconst isRectangleCover = rects => {\\n    const corners = new Set()\\n    let left = Infinity\\n    let right = 0\\n    let top = 0\\n    let bot = Infinity\\n    let area = 0\\n    const keyit = ( x, y ) => x + ( y === 0 ? 0 : .1 / y )\\n    const track = ( x, y ) => {\\n        const n = keyit( x, y )\\n\\n        if ( corners.has( n ) ) {\\n            corners.delete( n )\\n        } else {\\n            corners.add( n )\\n        }\\n    }\\n    \\n    for ( let i = 0; i < rects.length; i++ ) {\\n        const [ x1, y1, x2, y2 ] = rects[ i ]\\n        \\n        left = Math.min( left, x1 )\\n        top = Math.max( top, y2 )\\n        right = Math.max( right, x2 )\\n        bot = Math.min( bot, y1 )\\n        \\n        area += ( x2 - x1 ) * ( y2 - y1 )\\n\\n        track( x1, y1 )\\n        track( x1, y2 )\\n        track( x2, y1 )\\n        track( x2, y2 )\\n    }\\n\\n    return (\\n        area === ( top - bot ) * ( right - left )\\n        && 4 === corners.size\\n        && corners.has( keyit( left, bot ) )\\n        && corners.has( keyit( right, bot ) )\\n        && corners.has( keyit( left, top ) )\\n        && corners.has( keyit( right, top ) )\\n    )\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst isRectangleCover = rects => {\\n    const corners = new Set()\\n    let left = Infinity\\n    let right = 0\\n    let top = 0\\n    let bot = Infinity\\n    let area = 0\\n    const keyit = ( x, y ) => x + ( y === 0 ? 0 : .1 / y )\\n    const track = ( x, y ) => {\\n        const n = keyit( x, y )\\n\\n        if ( corners.has( n ) ) {\\n            corners.delete( n )\\n        } else {\\n            corners.add( n )\\n        }\\n    }\\n    \\n    for ( let i = 0; i < rects.length; i++ ) {\\n        const [ x1, y1, x2, y2 ] = rects[ i ]\\n        \\n        left = Math.min( left, x1 )\\n        top = Math.max( top, y2 )\\n        right = Math.max( right, x2 )\\n        bot = Math.min( bot, y1 )\\n        \\n        area += ( x2 - x1 ) * ( y2 - y1 )\\n\\n        track( x1, y1 )\\n        track( x1, y2 )\\n        track( x2, y1 )\\n        track( x2, y2 )\\n    }\\n\\n    return (\\n        area === ( top - bot ) * ( right - left )\\n        && 4 === corners.size\\n        && corners.has( keyit( left, bot ) )\\n        && corners.has( keyit( right, bot ) )\\n        && corners.has( keyit( left, top ) )\\n        && corners.has( keyit( right, top ) )\\n    )\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 527041,
                "title": "c-o-n-64-ms-97-solution-count-corners",
                "content": "To speed up code, need to use a different hash than string. I chose to use a prime hash on the coordinate values. Luckily no collisions.\\n\\n```\\nclass Solution {\\npublic:\\n    bool isRectangleCover(const vector<vector<int>>& rectangles) {\\n        int area = 0, x1 = INT32_MAX, x2 = INT32_MIN, y1 = INT32_MAX, y2 = INT32_MIN;\\n        unordered_set<int> s;\\n        for(const auto &r: rectangles) {\\n            x1 = min(x1, r[0]);\\n            y1 = min(y1, r[1]);\\n            x2 = max(x2, r[2]);\\n            y2 = max(y2, r[3]);\\n            area += (r[2]-r[0])*(r[3]-r[1]);\\n            int s1 = hash(r[0], r[1]),\\n               s2 = hash(r[0], r[3]),\\n               s3 = hash(r[2], r[1]),\\n               s4 = hash(r[2], r[3]);\\n            if(s.count(s1)) s.erase(s1);\\n            else s.insert(s1);\\n            if(s.count(s2)) s.erase(s2);\\n            else s.insert(s2);\\n            if(s.count(s3)) s.erase(s3);\\n            else s.insert(s3);\\n            if(s.count(s4)) s.erase(s4);\\n            else s.insert(s4);\\n        }\\n        return area == (x2-x1)*(y2-y1) && s.size() == 4 \\n            && s.count(hash(x1,y1))\\n            && s.count(hash(x1,y2))\\n            && s.count(hash(x2,y1)) \\n            && s.count(hash(x2,y2));\\n    }\\n    static inline int hash(const int& a, const int& b) {\\n        return a*7 + b*7*7*7;\\n    }\\n};\\n\\nauto gucciGang = []() {std::ios::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr);return 0;}();\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isRectangleCover(const vector<vector<int>>& rectangles) {\\n        int area = 0, x1 = INT32_MAX, x2 = INT32_MIN, y1 = INT32_MAX, y2 = INT32_MIN;\\n        unordered_set<int> s;\\n        for(const auto &r: rectangles) {\\n            x1 = min(x1, r[0]);\\n            y1 = min(y1, r[1]);\\n            x2 = max(x2, r[2]);\\n            y2 = max(y2, r[3]);\\n            area += (r[2]-r[0])*(r[3]-r[1]);\\n            int s1 = hash(r[0], r[1]),\\n               s2 = hash(r[0], r[3]),\\n               s3 = hash(r[2], r[1]),\\n               s4 = hash(r[2], r[3]);\\n            if(s.count(s1)) s.erase(s1);\\n            else s.insert(s1);\\n            if(s.count(s2)) s.erase(s2);\\n            else s.insert(s2);\\n            if(s.count(s3)) s.erase(s3);\\n            else s.insert(s3);\\n            if(s.count(s4)) s.erase(s4);\\n            else s.insert(s4);\\n        }\\n        return area == (x2-x1)*(y2-y1) && s.size() == 4 \\n            && s.count(hash(x1,y1))\\n            && s.count(hash(x1,y2))\\n            && s.count(hash(x2,y1)) \\n            && s.count(hash(x2,y2));\\n    }\\n    static inline int hash(const int& a, const int& b) {\\n        return a*7 + b*7*7*7;\\n    }\\n};\\n\\nauto gucciGang = []() {std::ios::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr);return 0;}();\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 87253,
                "title": "simple-java-solution-with-hashmap",
                "content": "To make a perfect rectangle, two conditions need to be met:\\n1. The total area of all sub-rectangles == (rightmost-leftmost)*(uppermost-lowermost);\\n2. For every side of each sub-rectangle, there should be one or more sub-rectangles with corresponding counter-sides, except for the outermost sides, i.e., for each top side, there should be corresponding bottom sides of other sub-rectangle(s) with the same values, and the right sides should have corresponding left ones . So we use four maps to store all sides(<Interval>) of the sub-rectangles, and for each key in topmap, except for the uppermost side of the parent-rectangle, there should be a same key in bottommap, and their values should be the same after merging.\\n\\n```\\npublic class Solution {\\n    public boolean isRectangleCover(int[][] rectangles) {\\n        long area=0;\\n        int up=Integer.MIN_VALUE, low = Integer.MAX_VALUE, rightest=Integer.MIN_VALUE, leftest=Integer.MAX_VALUE;\\n        HashMap<Integer,ArrayList<Interval>> topmap = new HashMap<>();\\n        HashMap<Integer,ArrayList<Interval>> bottommap = new HashMap<>();\\n        HashMap<Integer,ArrayList<Interval>> leftmap = new HashMap<>();\\n        HashMap<Integer,ArrayList<Interval>> rightmap = new HashMap<>();\\n        for(int i=0;i<rectangles.length;i++){\\n            int[] r1 = rectangles[i];\\n            int top = r1[3], right = r1[2], left = r1[0], bottom = r1[1];\\n            up = Math.max(top,up);\\n            low = Math.min(low, bottom);\\n            rightest = Math.max(right,rightest);\\n            leftest = Math.min(left, leftest);\\n            if (!topmap.containsKey(top))  topmap.put(top,new ArrayList<Interval>());\\n            topmap.get(top).add(new Interval(left,right));\\n            if (!bottommap.containsKey(bottom))  bottommap.put(bottom,new ArrayList<Interval>());\\n            bottommap.get(bottom).add(new Interval(left,right));\\n            if(!leftmap.containsKey(left)) leftmap.put(left,new ArrayList<Interval>());\\n            leftmap.get(left).add(new Interval(bottom,top));\\n            if(!rightmap.containsKey(right)) rightmap.put(right,new ArrayList<Interval>());\\n            rightmap.get(right).add(new Interval(bottom,top));\\n            area += (top-bottom)*(right-left);\\n        }\\n        if(area!=( rightest-leftest)*(up-low)) return false;\\n        if(bottommap.size()!=topmap.size()||leftmap.size()!=rightmap.size()) return false;\\n        return (compareMaps(bottommap,topmap,low) && compareMaps(rightmap,leftmap,rightest) ) ;\\n    }\\n    public boolean compareMaps(HashMap<Integer,ArrayList<Interval>> map1, HashMap<Integer,ArrayList<Interval>> map2, int side){\\n        for(int top: map1.keySet()  ){\\n            if(top==side) continue;\\n            List<Interval> mergedTopList = merge(map1.get(top));\\n            if(!map2.containsKey(top)) return false;\\n            List<Interval> mergedBottomeList = merge(map2.get(top));\\n            if(mergedBottomeList.size()!=mergedTopList.size()) return false;\\n            for(int i=0;i<mergedBottomeList.size();i++) {\\n                if(mergedBottomeList.get(i).start!=mergedTopList.get(i).start ||mergedBottomeList.get(i).end!=mergedTopList.get(i).end) return false;\\n            }\\n        }\\n        return true;\\n    }\\n    public List<Interval> merge(List<Interval> intervals) {\\n        List<Interval> res = new ArrayList<>();\\n        if(intervals==null||intervals.size()<2) return intervals;\\n        Collections.sort(intervals, new Comparator<Interval>(){public int compare(Interval i1, Interval i2) { return i1.start-i2.start; } } );\\n        int start = intervals.get(0).start, end=intervals.get(0).end;\\n        for(int i=1;i<intervals.size();i++){\\n            Interval cur = intervals.get(i);\\n            if(cur.start>end){\\n                res.add(new Interval(start, end) );\\n                start=cur.start;\\n            }\\n            if(cur.end>end) end=cur.end;\\n        }\\n        res.add(new Interval(start, end) ); \\n        return res;\\n    }\\n}\\nclass Interval {\\n    int start,end;\\n    Interval() { start = 0; end = 0; }\\n    Interval(int s, int e) { start = s; end = e; }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public boolean isRectangleCover(int[][] rectangles) {\\n        long area=0;\\n        int up=Integer.MIN_VALUE, low = Integer.MAX_VALUE, rightest=Integer.MIN_VALUE, leftest=Integer.MAX_VALUE;\\n        HashMap<Integer,ArrayList<Interval>> topmap = new HashMap<>();\\n        HashMap<Integer,ArrayList<Interval>> bottommap = new HashMap<>();\\n        HashMap<Integer,ArrayList<Interval>> leftmap = new HashMap<>();\\n        HashMap<Integer,ArrayList<Interval>> rightmap = new HashMap<>();\\n        for(int i=0;i<rectangles.length;i++){\\n            int[] r1 = rectangles[i];\\n            int top = r1[3], right = r1[2], left = r1[0], bottom = r1[1];\\n            up = Math.max(top,up);\\n            low = Math.min(low, bottom);\\n            rightest = Math.max(right,rightest);\\n            leftest = Math.min(left, leftest);\\n            if (!topmap.containsKey(top))  topmap.put(top,new ArrayList<Interval>());\\n            topmap.get(top).add(new Interval(left,right));\\n            if (!bottommap.containsKey(bottom))  bottommap.put(bottom,new ArrayList<Interval>());\\n            bottommap.get(bottom).add(new Interval(left,right));\\n            if(!leftmap.containsKey(left)) leftmap.put(left,new ArrayList<Interval>());\\n            leftmap.get(left).add(new Interval(bottom,top));\\n            if(!rightmap.containsKey(right)) rightmap.put(right,new ArrayList<Interval>());\\n            rightmap.get(right).add(new Interval(bottom,top));\\n            area += (top-bottom)*(right-left);\\n        }\\n        if(area!=( rightest-leftest)*(up-low)) return false;\\n        if(bottommap.size()!=topmap.size()||leftmap.size()!=rightmap.size()) return false;\\n        return (compareMaps(bottommap,topmap,low) && compareMaps(rightmap,leftmap,rightest) ) ;\\n    }\\n    public boolean compareMaps(HashMap<Integer,ArrayList<Interval>> map1, HashMap<Integer,ArrayList<Interval>> map2, int side){\\n        for(int top: map1.keySet()  ){\\n            if(top==side) continue;\\n            List<Interval> mergedTopList = merge(map1.get(top));\\n            if(!map2.containsKey(top)) return false;\\n            List<Interval> mergedBottomeList = merge(map2.get(top));\\n            if(mergedBottomeList.size()!=mergedTopList.size()) return false;\\n            for(int i=0;i<mergedBottomeList.size();i++) {\\n                if(mergedBottomeList.get(i).start!=mergedTopList.get(i).start ||mergedBottomeList.get(i).end!=mergedTopList.get(i).end) return false;\\n            }\\n        }\\n        return true;\\n    }\\n    public List<Interval> merge(List<Interval> intervals) {\\n        List<Interval> res = new ArrayList<>();\\n        if(intervals==null||intervals.size()<2) return intervals;\\n        Collections.sort(intervals, new Comparator<Interval>(){public int compare(Interval i1, Interval i2) { return i1.start-i2.start; } } );\\n        int start = intervals.get(0).start, end=intervals.get(0).end;\\n        for(int i=1;i<intervals.size();i++){\\n            Interval cur = intervals.get(i);\\n            if(cur.start>end){\\n                res.add(new Interval(start, end) );\\n                start=cur.start;\\n            }\\n            if(cur.end>end) end=cur.end;\\n        }\\n        res.add(new Interval(start, end) ); \\n        return res;\\n    }\\n}\\nclass Interval {\\n    int start,end;\\n    Interval() { start = 0; end = 0; }\\n    Interval(int s, int e) { start = s; end = e; }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3032618,
                "title": "best-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isRectangleCover(vector<vector<int>>& rectangles) {\\n        map<pair<int,int>,int>m;\\n        //In this problem we will count the number of edges after joining all\\n        //rectangles if atlast no of edges==4 then perfect rectangle\\n        //as when we will draw rectangle we can see that bottom left and top left\\n        //will concide so they can cancel extra inner points\\n        //similarly top right and bottom right \\n        //so we will add count of one and subtract count of another in each case \\n        for(auto P:rectangles)\\n        {\\n            m[{P[0],P[1]}]++;//bottom left\\n            m[{P[2],P[3]}]++;//top right\\n            m[{P[0],P[3]}]--;//top left\\n            m[{P[2],P[1]}]--;//bottom right\\n\\n        }\\n        int sum=0;\\n        for(auto it:m)\\n        {\\n            sum+=abs(it.second);//abs is used as edges which will not come inner will not cancel each other \\n            //but can come in negative due to -- in two case will also count as edge\\n\\n        }\\n        if(sum==4)\\n        return true;\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isRectangleCover(vector<vector<int>>& rectangles) {\\n        map<pair<int,int>,int>m;\\n        //In this problem we will count the number of edges after joining all\\n        //rectangles if atlast no of edges==4 then perfect rectangle\\n        //as when we will draw rectangle we can see that bottom left and top left\\n        //will concide so they can cancel extra inner points\\n        //similarly top right and bottom right \\n        //so we will add count of one and subtract count of another in each case \\n        for(auto P:rectangles)\\n        {\\n            m[{P[0],P[1]}]++;//bottom left\\n            m[{P[2],P[3]}]++;//top right\\n            m[{P[0],P[3]}]--;//top left\\n            m[{P[2],P[1]}]--;//bottom right\\n\\n        }\\n        int sum=0;\\n        for(auto it:m)\\n        {\\n            sum+=abs(it.second);//abs is used as edges which will not come inner will not cancel each other \\n            //but can come in negative due to -- in two case will also count as edge\\n\\n        }\\n        if(sum==4)\\n        return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2798460,
                "title": "c-easy-short",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isRectangleCover(vector<vector<int>>& rectangles) {\\n        unordered_map<long long, int> mark;\\n        const long long N=1000000;\\n        for(vector<int>& x:rectangles){\\n            int x1=x[0];\\n            int y1=x[1];\\n            int x2=x[2];\\n            int y2=x[3];\\n            mark[x1*N+y1]++;\\n            mark[x1*N+y2]--;\\n            mark[x2*N+y1]--;\\n            mark[x2*N+y2]++;\\n        }\\n        int n_mark=0;\\n        for(auto ptr=mark.begin();ptr!=mark.end();ptr++)\\n            if(ptr->second!=0){\\n                if(abs(ptr->second)!=1) return false;\\n                n_mark++;\\n            }\\n        return n_mark==4;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isRectangleCover(vector<vector<int>>& rectangles) {\\n        unordered_map<long long, int> mark;\\n        const long long N=1000000;\\n        for(vector<int>& x:rectangles){\\n            int x1=x[0];\\n            int y1=x[1];\\n            int x2=x[2];\\n            int y2=x[3];\\n            mark[x1*N+y1]++;\\n            mark[x1*N+y2]--;\\n            mark[x2*N+y1]--;\\n            mark[x2*N+y2]++;\\n        }\\n        int n_mark=0;\\n        for(auto ptr=mark.begin();ptr!=mark.end();ptr++)\\n            if(ptr->second!=0){\\n                if(abs(ptr->second)!=1) return false;\\n                n_mark++;\\n            }\\n        return n_mark==4;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2547795,
                "title": "python-solution",
                "content": "```\\nclass Solution:\\n    def isRectangleCover(self, rectangles: List[List[int]]) -> bool:\\n        \\n        area = 0\\n        corner_point = set()\\n\\n        for x,y,a,b in rectangles:\\n            area+=(a-x)*(b-y)\\n            for points in [(x,y),(x,b),(a,y),(a,b)]:\\n                if points in corner_point:\\n                    corner_point.remove(points)\\n                else:\\n                    corner_point.add(points)\\n\\n        if len(corner_point)!=4: # a rectangle should only have 4 corner points\\n            return False\\n        \\n        corner_point = sorted(list(corner_point), key = lambda x:(x[0], x[1]))\\n        return area == ((corner_point[-1][0]-corner_point[0][0])*(corner_point[-1][1]-corner_point[0][1]))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isRectangleCover(self, rectangles: List[List[int]]) -> bool:\\n        \\n        area = 0\\n        corner_point = set()\\n\\n        for x,y,a,b in rectangles:\\n            area+=(a-x)*(b-y)\\n            for points in [(x,y),(x,b),(a,y),(a,b)]:\\n                if points in corner_point:\\n                    corner_point.remove(points)\\n                else:\\n                    corner_point.add(points)\\n\\n        if len(corner_point)!=4: # a rectangle should only have 4 corner points\\n            return False\\n        \\n        corner_point = sorted(list(corner_point), key = lambda x:(x[0], x[1]))\\n        return area == ((corner_point[-1][0]-corner_point[0][0])*(corner_point[-1][1]-corner_point[0][1]))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1362012,
                "title": "c-solution-not-corner-count-multiple-illustrations",
                "content": "This algorithm owns a time complexity of O(nlogn)\\n\\n![image](https://assets.leetcode.com/users/images/1f310cf9-d7c5-4d6f-bb2c-4f499cbbb96f_1627221960.7418988.png)\\n\\n# Preparation\\n\\nFor sake of convenience, allow me to introduce some term first. Let\\'s call the x coordinate and y coordinate of the bottom left vertex bl_x and bl_y; the x y coordinates of the top right vertex tr_x and tr_y as shown in the following image.\\n![image](https://assets.leetcode.com/users/images/585157fe-4586-41f8-831a-4c99b96b6d96_1627260799.978835.png)\\n\\nGiven a series of rectangles, we should handle them one by one from left to right ( according to their bl_x value). If there\\'re multiple rectangles having identical bl_x, handle them from bottom to top (according to their bl_y value).\\nFor instance, in the following chart, we need to handle rectangles following the order 1, 2, 3, 4, 5, ... 13\\n![image](https://assets.leetcode.com/users/images/6cb4f81a-bee0-4d89-bc96-00b75fffb84e_1627260014.7014086.png)\\nThis can be easily achieved by sorting elements with a lambda expression.\\n```\\n sort(rectangles.begin(),rectangles.end(),[](const vector<int>& vec1, const vector<int>& vec2)->bool{\\n            if(vec1[0]<vec2[0]){return true;}\\n            else if(vec1[0] == vec2[0]){return vec1[1]<vec2[1];}\\n            else return false;\\n            });\\n```\\nFor simplicity, shift the perfect rectangle (if we manage to form one) to the origin - minus all x coordinate with bl_x of the bottom left rectange ( rectangle 1 ) and minus all y coordinate with bl_y of the bottom left one (rectangle 1).\\n\\n\\n\\n# Class hierarchy & general thinking\\n\\nTo solve this problem, my general idea is to build a class \"BarChart\", which saves the current \"bar chart\". Here\\'s an instance: \\nLet\\'s say we have handled rectangles 1 to 5, the BarChart should look like:\\n![image](https://assets.leetcode.com/users/images/9eec8ccf-7a31-46c6-a985-d6a3d71a246a_1627262597.9869173.png)\\nThe question is how to save this chart?\\n\\nMy solution is to use an ordered list<Bar>. The first bar starts from 0 and ends at 2, having a length of 4; the second bar starts at 2 ends at 3 and owns a length of 3; the last chart starts from 3, ends at 8, length = 6.\\n\\nSo the list is supposed to look like this:\\n![image](https://assets.leetcode.com/users/images/73e578d8-c9d9-4364-93f0-676605b2d54c_1627262970.8560154.png)\\nYou may have noticed that the rectangle 3, 5 and part of 2 form a \"big bar\". Indeed, we should \"merge\" bars when possible. The detail would be talked about in the following part. \\n\\n\\nThe BarChart class has a criticle function -- \"insert\"\\n```\\nbool BarChar::insert(int bl_x, int bl_y, int tr_x, int tr_y)\\n```\\nwhich takes a rectangle as input and insert it into our BarChart, if anything abnormal occurs like intersection or holes, return false indicating it\\'s impossible to form a perfect rectangle and return true if everything\\'s okay. Of course, merge bars when necessary after insertion.\\n\\nIn a nutshell, we insert all the rectangle following the aforementioned order and check the return bool of insert function, if all insertions are returning true, we just check whether the barchart so far has only one bar, i.e. a perfect rectangle.\\n\\n# Insert function\\nThe BarChart is initialized to contain only one bar starts at 0, ends at the largest tr_y coordinate amongest all rectangles(you need to iterate through all rectangles to find this value), and has a length 0.\\n\\nEverytime a new rectangle comes, iterate through the bar list and find the first one having with end > bl_y. \\nCheck whether the bl_y == bar.start, if not, we could directly say that it\\'s impossible to form a perfect rectangle.\\n![image](https://assets.leetcode.com/users/images/beb44566-e8bf-4f6c-aaea-98860f108349_1627265924.8831997.png)\\n\\n\\nThat\\'s because if bl_y > bar.start, since we handle rectangles from left to right from bottom to top, the rectangles comes afterwards can never perfectly patch the blue area shown in the picture. The best they can do is patching patially the area:\\n![image](https://assets.leetcode.com/users/images/44755a87-f210-47ae-a651-df52923554ac_1627265849.5993135.png)\\n\\n\\n(One thing you need to be careful is that it\\'s impossible the bl_y <  bar.start since the we find the \"first bar having bar.end > bl_y\".)\\n\\nSo if bl_y == bar.start, we should check whether bar.length == bl_x, if no, again it\\'s impossible to form a perfect rectangle for the same reason.\\n![image](https://assets.leetcode.com/users/images/0a140e90-afbe-4bc2-b681-3d4d634f98ae_1627266163.2775989.png)\\n\\nSo far, we have bl_x == bar.length and bl_y == bar.start, unfortunately, this leads to two circumstances:\\n1.tr_y == bar.end\\n![image](https://assets.leetcode.com/users/images/f6c82a39-2de2-422a-acca-7a75cea7d2ff_1627266547.7707896.png)\\nThis is perfect match! so the only thing we need to do is to prolong the bar.length;\\nthen, we should check if the bar could merge with another bar on the above or below. If so, do it.\\n\\n2.tr_y < bar.end\\n![image](https://assets.leetcode.com/users/images/a9ed86dd-ec0e-4584-bb49-b87fbf33dfba_1627267417.1413672.png)\\nA new bar (start = bar.start, end = tr_y, length = tr_x) should be insert into the list and the original bar.start should be modified into tr_y. The picture on the right is the outcome.\\nOnce more, we are supposed to check whether the green bar has a \"neighbor\" to merge with.\\n\\n3.tr_y > bar.end\\n![image](https://assets.leetcode.com/users/images/f8cc7eed-2621-44fa-9d77-4acecc24a41c_1627267955.650823.png)\\nActually why don\\'t we cut the green rectangle into two half and insert them separately? The first rectangle is a \"perfect match\" and we call \"insert\" for the second rectangle (recursion).\\n\\n# My code\\n\\n\\n```\\nstruct Bar{\\n    int start;\\n    int end;\\n    int length;\\n    Bar():start(0),end(0),length(0){}\\n    Bar(int b, int t, int l):start(b),end(t),length(l){}\\n};\\n\\n\\nstruct BarChart{\\n    list<Bar> chart;\\n    BarChart(int end){\\n        chart.push_back(Bar(0,end,0));\\n    }\\n    list<Bar>::iterator tryBelow(list<Bar>::iterator it){\\n        if(it == chart.begin())\\n            return it;\\n        list<Bar>::iterator ori = it;\\n        --it;\\n        if(it->length == ori->length){\\n            // merge\\n            it->end = ori->end;\\n            chart.erase(ori);\\n            return it;\\n        }\\n        // cannot merge\\n        return ori;\\n    }\\n\\n    list<Bar>::iterator tryAbove(list<Bar>::iterator it){\\n        list<Bar>::iterator ori = it;\\n        ++it;\\n        if(it == chart.end())\\n            return ori;\\n        if(it->length == ori->length){\\n            // merge\\n            it->start = ori->start;\\n            chart.erase(ori);\\n            return it;\\n        }\\n        return ori;\\n    }\\n\\n    bool insert(int bl_x, int bl_y, int tr_x, int tr_y){\\n        // find the first bar whose end > bl_y\\n        auto it = chart.begin();\\n        for(;it != chart.end();++it){\\n            if(it->end > bl_y)\\n                break;\\n        }\\n        // it cannot be chart.end()\\n        if(it == chart.end())\\n            cout<<\"it\\'s impossible\\\\n\";\\n        if(it->length != bl_x || it->start < bl_y)\\n            return false;\\n        // now it->start == bl_y\\n        if(it->end >= tr_y){\\n            // no need to split\\n            if(it->end == tr_y){\\n                // A\\n                it->length = tr_x;\\n                it = tryAbove(it);\\n                it = tryBelow(it);\\n                return true;\\n            }\\n            else{\\n                // C\\n                it->start = tr_y;\\n                auto it2 = chart.insert(it, Bar(bl_y,tr_y,tr_x));\\n                tryBelow(it2);\\n                return true;\\n            }\\n        }\\n        else{\\n            // you must split\\n            it->length = tr_x;\\n            return insert(bl_x,it->end,tr_x,tr_y);\\n        }\\n    }\\n    bool onePiece(){\\n        return chart.size() == 1;\\n    }\\n};\\n\\n\\n\\nclass Solution {\\npublic:\\n    bool isRectangleCover(vector<vector<int>>& rectangles) {\\n        int bl_x = INT_MAX;\\n        int bl_y = INT_MAX;\\n        int tr_x = INT_MIN;\\n        int tr_y = INT_MIN;\\n        for(int i=0;i<rectangles.size();++i){\\n            bl_x = min(bl_x,rectangles[i][0]);\\n            bl_y = min(bl_y,rectangles[i][1]);\\n            tr_x = max(tr_x,rectangles[i][2]);\\n            tr_y = max(tr_y,rectangles[i][3]);\\n        }\\n        sort(rectangles.begin(),rectangles.end(),[](const vector<int>& vec1, const vector<int>& vec2)->bool{\\n            if(vec1[0]<vec2[0]){return true;}\\n            else if(vec1[0] == vec2[0]){return vec1[1]<vec2[1];}\\n            else return false;\\n            });\\n        BarChart bc(tr_y-bl_y);\\n        for(int i=0;i<rectangles.size();++i){\\n            if(!bc.insert(rectangles[i][0]-bl_x,rectangles[i][1]-bl_y,rectangles[i][2]-bl_x,rectangles[i][3]-bl_y))\\n                return false;\\n        }\\n        return bc.onePiece();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n sort(rectangles.begin(),rectangles.end(),[](const vector<int>& vec1, const vector<int>& vec2)->bool{\\n            if(vec1[0]<vec2[0]){return true;}\\n            else if(vec1[0] == vec2[0]){return vec1[1]<vec2[1];}\\n            else return false;\\n            });\\n```\n```\\nbool BarChar::insert(int bl_x, int bl_y, int tr_x, int tr_y)\\n```\n```\\nstruct Bar{\\n    int start;\\n    int end;\\n    int length;\\n    Bar():start(0),end(0),length(0){}\\n    Bar(int b, int t, int l):start(b),end(t),length(l){}\\n};\\n\\n\\nstruct BarChart{\\n    list<Bar> chart;\\n    BarChart(int end){\\n        chart.push_back(Bar(0,end,0));\\n    }\\n    list<Bar>::iterator tryBelow(list<Bar>::iterator it){\\n        if(it == chart.begin())\\n            return it;\\n        list<Bar>::iterator ori = it;\\n        --it;\\n        if(it->length == ori->length){\\n            // merge\\n            it->end = ori->end;\\n            chart.erase(ori);\\n            return it;\\n        }\\n        // cannot merge\\n        return ori;\\n    }\\n\\n    list<Bar>::iterator tryAbove(list<Bar>::iterator it){\\n        list<Bar>::iterator ori = it;\\n        ++it;\\n        if(it == chart.end())\\n            return ori;\\n        if(it->length == ori->length){\\n            // merge\\n            it->start = ori->start;\\n            chart.erase(ori);\\n            return it;\\n        }\\n        return ori;\\n    }\\n\\n    bool insert(int bl_x, int bl_y, int tr_x, int tr_y){\\n        // find the first bar whose end > bl_y\\n        auto it = chart.begin();\\n        for(;it != chart.end();++it){\\n            if(it->end > bl_y)\\n                break;\\n        }\\n        // it cannot be chart.end()\\n        if(it == chart.end())\\n            cout<<\"it\\'s impossible\\\\n\";\\n        if(it->length != bl_x || it->start < bl_y)\\n            return false;\\n        // now it->start == bl_y\\n        if(it->end >= tr_y){\\n            // no need to split\\n            if(it->end == tr_y){\\n                // A\\n                it->length = tr_x;\\n                it = tryAbove(it);\\n                it = tryBelow(it);\\n                return true;\\n            }\\n            else{\\n                // C\\n                it->start = tr_y;\\n                auto it2 = chart.insert(it, Bar(bl_y,tr_y,tr_x));\\n                tryBelow(it2);\\n                return true;\\n            }\\n        }\\n        else{\\n            // you must split\\n            it->length = tr_x;\\n            return insert(bl_x,it->end,tr_x,tr_y);\\n        }\\n    }\\n    bool onePiece(){\\n        return chart.size() == 1;\\n    }\\n};\\n\\n\\n\\nclass Solution {\\npublic:\\n    bool isRectangleCover(vector<vector<int>>& rectangles) {\\n        int bl_x = INT_MAX;\\n        int bl_y = INT_MAX;\\n        int tr_x = INT_MIN;\\n        int tr_y = INT_MIN;\\n        for(int i=0;i<rectangles.size();++i){\\n            bl_x = min(bl_x,rectangles[i][0]);\\n            bl_y = min(bl_y,rectangles[i][1]);\\n            tr_x = max(tr_x,rectangles[i][2]);\\n            tr_y = max(tr_y,rectangles[i][3]);\\n        }\\n        sort(rectangles.begin(),rectangles.end(),[](const vector<int>& vec1, const vector<int>& vec2)->bool{\\n            if(vec1[0]<vec2[0]){return true;}\\n            else if(vec1[0] == vec2[0]){return vec1[1]<vec2[1];}\\n            else return false;\\n            });\\n        BarChart bc(tr_y-bl_y);\\n        for(int i=0;i<rectangles.size();++i){\\n            if(!bc.insert(rectangles[i][0]-bl_x,rectangles[i][1]-bl_y,rectangles[i][2]-bl_x,rectangles[i][3]-bl_y))\\n                return false;\\n        }\\n        return bc.onePiece();\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1118918,
                "title": "python-solution-count-corners",
                "content": "\\tx_min = y_min = float(\"inf\")\\n\\tx_max = y_max = float(\"-inf\")\\n\\tcorners = set()\\n\\tarea = 0\\n\\tfor x1, y1, x2, y2 in rectangles:\\n\\t\\tcorners ^= {(x1, y1), (x1, y2), (x2, y1), (x2, y2)}\\n\\t\\tx_min = min(x1, x_min)\\n\\t\\ty_min = min(y1, y_min)\\n\\t\\tx_max = max(x2, x_max)\\n\\t\\ty_max = max(y2, y_max)\\n\\t\\tarea += (x2 - x1) * (y2 - y1)\\n\\tif {(x_min, y_min), (x_min, y_max), (x_max, y_min), (x_max, y_max)} != corners:\\n\\t\\treturn False\\n\\treturn area == (x_max - x_min) * (y_max - y_min)",
                "solutionTags": [],
                "code": "\\tx_min = y_min = float(\"inf\")\\n\\tx_max = y_max = float(\"-inf\")\\n\\tcorners = set()\\n\\tarea = 0\\n\\tfor x1, y1, x2, y2 in rectangles:\\n\\t\\tcorners ^= {(x1, y1), (x1, y2), (x2, y1), (x2, y2)}\\n\\t\\tx_min = min(x1, x_min)\\n\\t\\ty_min = min(y1, y_min)\\n\\t\\tx_max = max(x2, x_max)\\n\\t\\ty_max = max(y2, y_max)\\n\\t\\tarea += (x2 - x1) * (y2 - y1)\\n\\tif {(x_min, y_min), (x_min, y_max), (x_max, y_min), (x_max, y_max)} != corners:\\n\\t\\treturn False\\n\\treturn area == (x_max - x_min) * (y_max - y_min)",
                "codeTag": "Unknown"
            },
            {
                "id": 906868,
                "title": "c-clean-and-easy-code",
                "content": "1- find the bottom left corner and the top right corners (the big rectangle)\\n2- Sum all the areas\\n3- Add the all the corners in a SET and remove the shared ones\\n4- Check if the coreners in the set are 4 and equal to the corners of the big rectangle\\n5- Check if areas are equals.\\n\\n```\\nclass Solution {\\npublic:\\n    bool isRectangleCover(vector<vector<int>>& rectangles) {\\n        vector<int> bigRec = rectangles[0];\\n        int area = 0;\\n        unordered_set<string> corners; \\n        pair<unordered_set<string>::iterator, bool> r;\\n        for(vector<int> rec: rectangles)\\n        {\\n            //Find the bottom left corner\\n            if(bigRec[0] + bigRec[1] > rec[0] + rec[1])\\n            {\\n                bigRec[0] =rec[0]; bigRec[1] = rec[1];\\n            }\\n            //Find the top right corner\\n            if(bigRec[2] + bigRec[3] < rec[2] + rec[3])\\n            {\\n                bigRec[2] = rec[2]; bigRec[3] = rec[3];\\n            }\\n            //Add all the corners and remove the shared ones\\n            for(int i=0; i<4; i++)\\n            {\\n                r = corners.insert(to_string(rec[(i>>1) * 2]) + \",\" + to_string(rec[(i & 1) * 2 + 1]));\\n                if(!r.second) corners.erase(r.first);\\n            }\\n            //Sum all the areas\\n            area +=  (rec[2] -  rec[0]) *  (rec[3] -  rec[1]);\\n        }\\n        //check if the set contain only the big rectangle corners\\n        if(corners.size()!=4) return false;\\n        for(int i=0; i<4; i++)\\n            if(corners.find(to_string(bigRec[(i>>1) * 2]) + \",\" + to_string(bigRec[(i & 1) * 2 + 1])) == corners.end())\\n               return false;\\n        \\n        //check if areas are equals\\n        return (area == (bigRec[2] - bigRec[0]) *  (bigRec[3] - bigRec[1]));\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isRectangleCover(vector<vector<int>>& rectangles) {\\n        vector<int> bigRec = rectangles[0];\\n        int area = 0;\\n        unordered_set<string> corners; \\n        pair<unordered_set<string>::iterator, bool> r;\\n        for(vector<int> rec: rectangles)\\n        {\\n            //Find the bottom left corner\\n            if(bigRec[0] + bigRec[1] > rec[0] + rec[1])\\n            {\\n                bigRec[0] =rec[0]; bigRec[1] = rec[1];\\n            }\\n            //Find the top right corner\\n            if(bigRec[2] + bigRec[3] < rec[2] + rec[3])\\n            {\\n                bigRec[2] = rec[2]; bigRec[3] = rec[3];\\n            }\\n            //Add all the corners and remove the shared ones\\n            for(int i=0; i<4; i++)\\n            {\\n                r = corners.insert(to_string(rec[(i>>1) * 2]) + \",\" + to_string(rec[(i & 1) * 2 + 1]));\\n                if(!r.second) corners.erase(r.first);\\n            }\\n            //Sum all the areas\\n            area +=  (rec[2] -  rec[0]) *  (rec[3] -  rec[1]);\\n        }\\n        //check if the set contain only the big rectangle corners\\n        if(corners.size()!=4) return false;\\n        for(int i=0; i<4; i++)\\n            if(corners.find(to_string(bigRec[(i>>1) * 2]) + \",\" + to_string(bigRec[(i & 1) * 2 + 1])) == corners.end())\\n               return false;\\n        \\n        //check if areas are equals\\n        return (area == (bigRec[2] - bigRec[0]) *  (bigRec[3] - bigRec[1]));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 897383,
                "title": "java-short-easy-o-n-log-n-treeset-intersection-dectect-solution-beats-99-78",
                "content": "**No need for corner point check or sweeping line. Only use treeset to detecet if 2 rectangles intesect and also calculate the area.**\\n\\n**The time complexity is O(n log n) because treeset add is O(log n). But this solution actually runs faster than those O(n) corner point dectet solutions.**\\n\\n**If you don\\'t understand how this is done. Here is some explanation about the compare function for Sets.**\\nhttps://stackoverflow.com/questions/31334698/understanding-treeset-when-compareto-returns-0\\n\\n**As java.util.TreeSet says:**\\n\\n*a TreeSet instance performs all element comparisons using its compareTo (or compare) method, so two elements that are deemed equal by this method are, from the standpoint of the set, equal*\\n\\nSo we can define the compare function so that it returns 0 if 2 rect intersect. In this way, if we want to add a rect which intersects with another one in the set. the set.add(this rect) will return false because the set thinks that you are adding a duplicate element. \\n\\n```\\nclass Solution {\\n    public boolean isRectangleCover(int[][] rectangles) {\\n        if (rectangles == null || rectangles.length == 0 || rectangles[0].length == 0) {\\n            return false;\\n        }\\n\\t\\t// Build special treeset whose compare function returns 0 if intersect.\\n        Set<int[]> set = new TreeSet<>((int[] a, int[] b) -> {\\n            if (a[3] <= b[1]) {\\n                return -1;\\n            } else if (a[1] >= b[3]) {\\n                return 1;\\n            } else if (a[2] <= b[0]) {\\n                return -1;\\n            } else if (a[0] >= b[2]) {\\n                return 1;\\n            } else return 0;\\n        });\\n        \\n        int area = 0;\\n        int up = Integer.MIN_VALUE;\\n        int down = Integer.MAX_VALUE;\\n        int left = Integer.MAX_VALUE;\\n        int right = Integer.MIN_VALUE;\\n        \\n        for (int[] rect : rectangles) {\\n            area += (rect[2] - rect[0]) * (rect[3] - rect[1]);\\n            up = Math.max(up, rect[3]);\\n            right = Math.max(right, rect[2]);\\n            down = Math.min(down, rect[1]);\\n            left = Math.min(left, rect[0]);\\n            if (!set.add(rect)) {\\n                return false;\\n            }\\n        }\\n        if (!(((up - down) * (right - left)) == area)) return false;\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isRectangleCover(int[][] rectangles) {\\n        if (rectangles == null || rectangles.length == 0 || rectangles[0].length == 0) {\\n            return false;\\n        }\\n\\t\\t// Build special treeset whose compare function returns 0 if intersect.\\n        Set<int[]> set = new TreeSet<>((int[] a, int[] b) -> {\\n            if (a[3] <= b[1]) {\\n                return -1;\\n            } else if (a[1] >= b[3]) {\\n                return 1;\\n            } else if (a[2] <= b[0]) {\\n                return -1;\\n            } else if (a[0] >= b[2]) {\\n                return 1;\\n            } else return 0;\\n        });\\n        \\n        int area = 0;\\n        int up = Integer.MIN_VALUE;\\n        int down = Integer.MAX_VALUE;\\n        int left = Integer.MAX_VALUE;\\n        int right = Integer.MIN_VALUE;\\n        \\n        for (int[] rect : rectangles) {\\n            area += (rect[2] - rect[0]) * (rect[3] - rect[1]);\\n            up = Math.max(up, rect[3]);\\n            right = Math.max(right, rect[2]);\\n            down = Math.min(down, rect[1]);\\n            left = Math.min(left, rect[0]);\\n            if (!set.add(rect)) {\\n                return false;\\n            }\\n        }\\n        if (!(((up - down) * (right - left)) == area)) return false;\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 651642,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isRectangleCover(const vector<vector<int>>& rectangles) {\\n        int area = 0, x1 = INT32_MAX, x2 = INT32_MIN, y1 = INT32_MAX, y2 = INT32_MIN;\\n        unordered_set<int> s;\\n        for(const auto &r: rectangles) {\\n            x1 = min(x1, r[0]);\\n            y1 = min(y1, r[1]);\\n            x2 = max(x2, r[2]);\\n            y2 = max(y2, r[3]);\\n            area += (r[2]-r[0])*(r[3]-r[1]);\\n            int s1 = hash(r[0], r[1]),\\n               s2 = hash(r[0], r[3]),\\n               s3 = hash(r[2], r[1]),\\n               s4 = hash(r[2], r[3]);\\n            if(s.count(s1)) s.erase(s1);\\n            else s.insert(s1);\\n            if(s.count(s2)) s.erase(s2);\\n            else s.insert(s2);\\n            if(s.count(s3)) s.erase(s3);\\n            else s.insert(s3);\\n            if(s.count(s4)) s.erase(s4);\\n            else s.insert(s4);\\n        }\\n        return area == (x2-x1)*(y2-y1) && s.size() == 4 \\n            && s.count(hash(x1,y1))\\n            && s.count(hash(x1,y2))\\n            && s.count(hash(x2,y1)) \\n            && s.count(hash(x2,y2));\\n    }\\n    static inline int hash(const int& a, const int& b) {\\n        return a*7 + b*7*7*7;\\n    }\\n};\\n\\nauto gucciGang = []() {std::ios::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr);return 0;}();\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isRectangleCover(const vector<vector<int>>& rectangles) {\\n        int area = 0, x1 = INT32_MAX, x2 = INT32_MIN, y1 = INT32_MAX, y2 = INT32_MIN;\\n        unordered_set<int> s;\\n        for(const auto &r: rectangles) {\\n            x1 = min(x1, r[0]);\\n            y1 = min(y1, r[1]);\\n            x2 = max(x2, r[2]);\\n            y2 = max(y2, r[3]);\\n            area += (r[2]-r[0])*(r[3]-r[1]);\\n            int s1 = hash(r[0], r[1]),\\n               s2 = hash(r[0], r[3]),\\n               s3 = hash(r[2], r[1]),\\n               s4 = hash(r[2], r[3]);\\n            if(s.count(s1)) s.erase(s1);\\n            else s.insert(s1);\\n            if(s.count(s2)) s.erase(s2);\\n            else s.insert(s2);\\n            if(s.count(s3)) s.erase(s3);\\n            else s.insert(s3);\\n            if(s.count(s4)) s.erase(s4);\\n            else s.insert(s4);\\n        }\\n        return area == (x2-x1)*(y2-y1) && s.size() == 4 \\n            && s.count(hash(x1,y1))\\n            && s.count(hash(x1,y2))\\n            && s.count(hash(x2,y1)) \\n            && s.count(hash(x2,y2));\\n    }\\n    static inline int hash(const int& a, const int& b) {\\n        return a*7 + b*7*7*7;\\n    }\\n};\\n\\nauto gucciGang = []() {std::ios::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr);return 0;}();\\n```",
                "codeTag": "C++"
            },
            {
                "id": 621401,
                "title": "easy-way",
                "content": "We find the total area of all the rectangles.\\nStore all the poins in a set .Sort them get first and last point \\nand calculate largest squares area (possible with these pts).if both equal return true\\n\\nBut the trick is whenever point is already in set then we remove that point\\nas every point other than corner 4 of merged rectangle should occur once rest all \\nshould be occuring twice in rectangle if it is actually mergable.\\nHence when size of pts set is not 4 we return False\\n\\t\\t\\n\\t\\tpts=set()\\n        area=0\\n        for rec in rectangles:\\n            btmLeft=(rec[0],rec[1])\\n            btmRight=(rec[2],rec[1])\\n            tpLeft=(rec[0],rec[3])\\n            tpRight=(rec[2],rec[3])\\n            for i in [btmLeft,btmRight,tpLeft,tpRight]:\\n                if i in pts:\\n                    pts.remove(i)\\n                else:\\n                    pts.add(i)\\n            \\n            area+=(rec[2]-rec[0])*(rec[3]-rec[1])\\n            print(area)\\n        \\n        if len(pts)!=4:\\n            return False\\n        pts=sorted(list(pts))\\n        \\n        f=pts.pop(0)\\n        l=pts.pop()\\n        print(area)\\n        return area==(l[1]-f[1])*(l[0]-f[0])\\n\\n    \\n",
                "solutionTags": [],
                "code": "We find the total area of all the rectangles.\\nStore all the poins in a set .Sort them get first and last point \\nand calculate largest squares area (possible with these pts).if both equal return true\\n\\nBut the trick is whenever point is already in set then we remove that point\\nas every point other than corner 4 of merged rectangle should occur once rest all \\nshould be occuring twice in rectangle if it is actually mergable.\\nHence when size of pts set is not 4 we return False\\n\\t\\t\\n\\t\\tpts=set()\\n        area=0\\n        for rec in rectangles:\\n            btmLeft=(rec[0],rec[1])\\n            btmRight=(rec[2],rec[1])\\n            tpLeft=(rec[0],rec[3])\\n            tpRight=(rec[2],rec[3])\\n            for i in [btmLeft,btmRight,tpLeft,tpRight]:\\n                if i in pts:\\n                    pts.remove(i)\\n                else:\\n                    pts.add(i)\\n            \\n            area+=(rec[2]-rec[0])*(rec[3]-rec[1])\\n            print(area)\\n        \\n        if len(pts)!=4:\\n            return False\\n        pts=sorted(list(pts))\\n        \\n        f=pts.pop(0)\\n        l=pts.pop()\\n        print(area)\\n        return area==(l[1]-f[1])*(l[0]-f[0])\\n\\n    \\n",
                "codeTag": "Python3"
            },
            {
                "id": 521508,
                "title": "python-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def isRectangleCover(self, rectangles: List[List[int]]) -> bool:\\n        \"\"\"\\n        Idea is from Huahua jiang,\\n        The main idea is that except the four corners of perfect square, all other corners of sub rectangles all\\n        appeare even times\\n        \"\"\"\\n        corners = set()\\n        area = 0\\n        for rect in rectangles:\\n            p1 = (rect[0], rect[1])\\n            p2 = (rect[0], rect[3])\\n            p3 = (rect[2], rect[1])\\n            p4 = (rect[2], rect[3])\\n            for p in [p1, p2, p3, p4]:\\n                if p in corners:\\n                    corners.remove(p)\\n                else:\\n                    corners.add(p)\\n            area += (p4[0] - p1[0]) * (p4[1] - p1[1])\\n        \\n        if len(corners) != 4:\\n            return False\\n        corners = sorted(list(corners))\\n        p1, p4 = corners[0], corners[-1]\\n        return area == (p4[0] - p1[0]) * (p4[1] - p1[1])",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isRectangleCover(self, rectangles: List[List[int]]) -> bool:\\n        \"\"\"\\n        Idea is from Huahua jiang,\\n        The main idea is that except the four corners of perfect square, all other corners of sub rectangles all\\n        appeare even times\\n        \"\"\"\\n        corners = set()\\n        area = 0\\n        for rect in rectangles:\\n            p1 = (rect[0], rect[1])\\n            p2 = (rect[0], rect[3])\\n            p3 = (rect[2], rect[1])\\n            p4 = (rect[2], rect[3])\\n            for p in [p1, p2, p3, p4]:\\n                if p in corners:\\n                    corners.remove(p)\\n                else:\\n                    corners.add(p)\\n            area += (p4[0] - p1[0]) * (p4[1] - p1[1])\\n        \\n        if len(corners) != 4:\\n            return False\\n        corners = sorted(list(corners))\\n        p1, p4 = corners[0], corners[-1]\\n        return area == (p4[0] - p1[0]) * (p4[1] - p1[1])",
                "codeTag": "Java"
            },
            {
                "id": 447112,
                "title": "runtime-31-ms-faster-than-95-34-memory-usage-46-6-mb-less-than-100-00",
                "content": "Solution is easy,\\n1.merge all points to make sure final result only has 4 points\\n2.calculate area with final 4 points and compare with all rectangle areas total\\n```\\nclass Solution {\\n    public boolean isRectangleCover(int[][] rectangles) {\\n        Set<Node> set=new HashSet<>();\\n        Set<Rectangle> rec=new HashSet<>();\\n        int area=0;\\n        for(int[] arr:rectangles){\\n            Rectangle r=new Rectangle(arr[0],arr[1],arr[2],arr[3]);\\n            if(!rec.add(r)) //resolve [[1,1,3,3],[1,1,3,3]] situation\\n                return false;\\n            \\n            area+=r.area();\\n            \\n            Node n1=new Node(arr[0],arr[1]);\\n            Node n2=new Node(arr[2],arr[3]);\\n            Node n3=new Node(arr[0],arr[3]);\\n            Node n4=new Node(arr[2],arr[1]);\\n            \\n            if(!set.add(n1)) set.remove(n1);\\n            if(!set.add(n2)) set.remove(n2);\\n            if(!set.add(n3)) set.remove(n3);\\n            if(!set.add(n4)) set.remove(n4);\\n        }\\n        if(set.size()!=4) return false;\\n        Node m=null;\\n        for(Node n:set){\\n            if(m==null) m=n;\\n            if(m.x!=n.x&&m.y!=n.y){\\n                int a=Math.abs(m.x-n.x);\\n                int b=Math.abs(m.y-n.y);\\n                return area==a*b;\\n            }\\n        }\\n        return false;\\n    }\\n}\\nclass Node{\\n    int x; int y;\\n    public Node(int x,int y){\\n        this.x=x; this.y=y;\\n    }\\n\\t@Override\\n    public boolean equals(Object o){\\n        if(o==this) return true;\\n        if(!(o instanceof Node)) return false;\\n        Node n = (Node)o;\\n        return (x==n.x&&y==n.y);\\n    }\\n\\t@Override\\n    public int hashCode(){\\n        int ret=13;\\n        ret=ret*31+x;\\n        ret=ret*31+y;\\n        return ret;\\n        //return Objects.hash(x,y);\\n    }\\n}\\nclass Rectangle{\\n    int x1; int y1; int x2; int y2;\\n    public Rectangle(int x1,int y1,int x2,int y2){\\n        this.x1=x1; this.y1=y1;\\n        this.x2=x2; this.y2=y2;\\n    }\\n    @Override\\n    public boolean equals(Object o){\\n        if(o==this) return true;\\n        if(!(o instanceof Rectangle)) return false;\\n        Rectangle n = (Rectangle)o;\\n        return (x1==n.x1&&y1==n.y1&&x2==n.x2&&y2==n.y2);\\n    }\\n    @Override\\n    public int hashCode(){\\n        int ret=13;\\n        ret=ret*31+x1;\\n        ret=ret*31+y1;\\n        ret=ret*31+x2;\\n        ret=ret*31+y2;\\n        return ret;\\n        //return Objects.hash(x1,x2,y1,y2);\\n    }\\n    public int area(){\\n        int a=Math.abs(x1-x2);\\n        int b=Math.abs(y1-y2);\\n        return a*b;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isRectangleCover(int[][] rectangles) {\\n        Set<Node> set=new HashSet<>();\\n        Set<Rectangle> rec=new HashSet<>();\\n        int area=0;\\n        for(int[] arr:rectangles){\\n            Rectangle r=new Rectangle(arr[0],arr[1],arr[2],arr[3]);\\n            if(!rec.add(r)) //resolve [[1,1,3,3],[1,1,3,3]] situation\\n                return false;\\n            \\n            area+=r.area();\\n            \\n            Node n1=new Node(arr[0],arr[1]);\\n            Node n2=new Node(arr[2],arr[3]);\\n            Node n3=new Node(arr[0],arr[3]);\\n            Node n4=new Node(arr[2],arr[1]);\\n            \\n            if(!set.add(n1)) set.remove(n1);\\n            if(!set.add(n2)) set.remove(n2);\\n            if(!set.add(n3)) set.remove(n3);\\n            if(!set.add(n4)) set.remove(n4);\\n        }\\n        if(set.size()!=4) return false;\\n        Node m=null;\\n        for(Node n:set){\\n            if(m==null) m=n;\\n            if(m.x!=n.x&&m.y!=n.y){\\n                int a=Math.abs(m.x-n.x);\\n                int b=Math.abs(m.y-n.y);\\n                return area==a*b;\\n            }\\n        }\\n        return false;\\n    }\\n}\\nclass Node{\\n    int x; int y;\\n    public Node(int x,int y){\\n        this.x=x; this.y=y;\\n    }\\n\\t@Override\\n    public boolean equals(Object o){\\n        if(o==this) return true;\\n        if(!(o instanceof Node)) return false;\\n        Node n = (Node)o;\\n        return (x==n.x&&y==n.y);\\n    }\\n\\t@Override\\n    public int hashCode(){\\n        int ret=13;\\n        ret=ret*31+x;\\n        ret=ret*31+y;\\n        return ret;\\n        //return Objects.hash(x,y);\\n    }\\n}\\nclass Rectangle{\\n    int x1; int y1; int x2; int y2;\\n    public Rectangle(int x1,int y1,int x2,int y2){\\n        this.x1=x1; this.y1=y1;\\n        this.x2=x2; this.y2=y2;\\n    }\\n    @Override\\n    public boolean equals(Object o){\\n        if(o==this) return true;\\n        if(!(o instanceof Rectangle)) return false;\\n        Rectangle n = (Rectangle)o;\\n        return (x1==n.x1&&y1==n.y1&&x2==n.x2&&y2==n.y2);\\n    }\\n    @Override\\n    public int hashCode(){\\n        int ret=13;\\n        ret=ret*31+x1;\\n        ret=ret*31+y1;\\n        ret=ret*31+x2;\\n        ret=ret*31+y2;\\n        return ret;\\n        //return Objects.hash(x1,x2,y1,y2);\\n    }\\n    public int area(){\\n        int a=Math.abs(x1-x2);\\n        int b=Math.abs(y1-y2);\\n        return a*b;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 423044,
                "title": "c-solution",
                "content": "```\\npublic class Solution \\n{\\n    public bool IsRectangleCover(int[][] rec) \\n    {\\n        var hashSet = new HashSet<string>();\\n        int  l = rec[0][0], b = rec[0][1], r = rec[0][2], t = rec[0][3], sum = 0;\\n        foreach(var elem in rec)\\n        {\\n            int x1 =  elem[0], y1 =  elem[1], x2 =  elem[2], y2 =  elem[3];\\n            l = Math.Min(l, x1); b = Math.Min(b, y1);\\n            r = Math.Max(r, x2); t = Math.Max(t, y2);\\n            string[] keys = new string[] {x1 + \":\" + y1, x1 + \":\" + y2, x2 + \":\" + y1, x2 + \":\" + y2};\\n            sum += (x2 - x1) * (y2 - y1);\\n            foreach(var key in keys)\\n            {\\n                if(hashSet.Contains(key))\\n                    hashSet.Remove(key);\\n                else\\n                    hashSet.Add(key);\\n            }\\n        }\\n        \\n        if(hashSet.Count != 4 || \\n           !hashSet.Contains(l + \":\" + b) || \\n           !hashSet.Contains(l + \":\" + t) || \\n           !hashSet.Contains(r + \":\" + b)|| \\n           !hashSet.Contains(r + \":\" + t))\\n            return false;\\n        \\n        return (r - l) * (t - b) == sum;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution \\n{\\n    public bool IsRectangleCover(int[][] rec) \\n    {\\n        var hashSet = new HashSet<string>();\\n        int  l = rec[0][0], b = rec[0][1], r = rec[0][2], t = rec[0][3], sum = 0;\\n        foreach(var elem in rec)\\n        {\\n            int x1 =  elem[0], y1 =  elem[1], x2 =  elem[2], y2 =  elem[3];\\n            l = Math.Min(l, x1); b = Math.Min(b, y1);\\n            r = Math.Max(r, x2); t = Math.Max(t, y2);\\n            string[] keys = new string[] {x1 + \":\" + y1, x1 + \":\" + y2, x2 + \":\" + y1, x2 + \":\" + y2};\\n            sum += (x2 - x1) * (y2 - y1);\\n            foreach(var key in keys)\\n            {\\n                if(hashSet.Contains(key))\\n                    hashSet.Remove(key);\\n                else\\n                    hashSet.Add(key);\\n            }\\n        }\\n        \\n        if(hashSet.Count != 4 || \\n           !hashSet.Contains(l + \":\" + b) || \\n           !hashSet.Contains(l + \":\" + t) || \\n           !hashSet.Contains(r + \":\" + b)|| \\n           !hashSet.Contains(r + \":\" + t))\\n            return false;\\n        \\n        return (r - l) * (t - b) == sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 87208,
                "title": "c-is-it-enough-to-check-unpaired-vertices-4-only",
                "content": "First there shouldn't be identical vertices (overlapping).\\nThen all paired vertices should make up either an edge (2 adjacent) or a plane (4 adjacent).\\nSo there should be, and must be, exactly 4 vertices not paired since they are the 4 corners of the perfect rectangle.\\n\\nIs this condition alone strong enough? Seems legit. Any counter testcases?\\n\\n*46 / 46 test cases passed*\\n*Status: Accepted*\\n*Runtime: 139 ms*\\n*Beats 99.82%*\\n```\\nclass Solution {\\npublic:\\n    bool isRectangleCover(vector<vector<int>>& rectangles) {\\n        unordered_map<unsigned long long, uint> map;\\n        map.reserve(rectangles.size()*4);\\n        for (auto& rec : rectangles) {\\n            unsigned long long xy[4];\\n            xy[0]= (unsigned long long)rec[0] << 32 | (uint)rec[1];\\n            xy[1]= (unsigned long long)rec[0] << 32 | (uint)rec[3];\\n            xy[2]= (unsigned long long)rec[2] << 32 | (uint)rec[3];\\n            xy[3]= (unsigned long long)rec[2] << 32 | (uint)rec[1];\\n            for (uint i = 0; i < 4; i++)  {\\n                uint pos = 1 << i; //1 Left Bottom, 2 Left Top, 4 Right Top, 8 Right Bottom\\n                uint& val = map[xy[i]];\\n                if (val & pos) return false;\\n                else val |= pos;\\n            }\\n        }\\n        uint cnt = 0;\\n        for (auto& p : map) {\\n            uint pos = p.second;\\n            if (!(pos == 1+2 || pos == 2+4 || pos == 4+8 || pos == 8+1 || pos == 1+2+4+8) && ++cnt > 4) return false;\\n        }\\n        return cnt == 4;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isRectangleCover(vector<vector<int>>& rectangles) {\\n        unordered_map<unsigned long long, uint> map;\\n        map.reserve(rectangles.size()*4);\\n        for (auto& rec : rectangles) {\\n            unsigned long long xy[4];\\n            xy[0]= (unsigned long long)rec[0] << 32 | (uint)rec[1];\\n            xy[1]= (unsigned long long)rec[0] << 32 | (uint)rec[3];\\n            xy[2]= (unsigned long long)rec[2] << 32 | (uint)rec[3];\\n            xy[3]= (unsigned long long)rec[2] << 32 | (uint)rec[1];\\n            for (uint i = 0; i < 4; i++)  {\\n                uint pos = 1 << i; //1 Left Bottom, 2 Left Top, 4 Right Top, 8 Right Bottom\\n                uint& val = map[xy[i]];\\n                if (val & pos) return false;\\n                else val |= pos;\\n            }\\n        }\\n        uint cnt = 0;\\n        for (auto& p : map) {\\n            uint pos = p.second;\\n            if (!(pos == 1+2 || pos == 2+4 || pos == 4+8 || pos == 8+1 || pos == 1+2+4+8) && ++cnt > 4) return false;\\n        }\\n        return cnt == 4;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 87230,
                "title": "sweep-line-degenerated-interval-tree-solution-o-nlogn",
                "content": "This algorithm needs a subroutine that judges whether rectangles overlap. This subroutine can be done by sweep line algorithm plus interval tree. The real interval tree data structure can store overlapping intervals, however, for this question, we only need a data structure that stores non-overlapping intervals. Once we insert an overlapping interval, we can terminate the algorithm by return false.\\n\\nThe above is the key point, other points are in the comments of source code.\\n\\n```\\npublic class Solution {\\n    public boolean isRectangleCover(int[][] rectangles) {\\n        if (rectangles == null || rectangles.length <= 1) {\\n            return true;\\n        }\\n        assert rectangles[0].length == 4;\\n        // find most left, most bottom point (minx, miny)\\n        Integer minx = rectangles[0][0];\\n        Integer miny = rectangles[0][1];\\n        int minxseen = Integer.MAX_VALUE;\\n        int minyseen = Integer.MAX_VALUE;\\n        for (int i = 1; i < rectangles.length; i++) {\\n            int[] rectangle = rectangles[i];\\n            if (minx != null && miny != null) {\\n                if (rectangle[0] <= minx && rectangle[1] <= miny) {\\n                    minx = rectangle[0];\\n                    miny = rectangle[1];\\n                } else if (!(rectangle[0] >= minx && rectangle[1] >= miny)) {\\n                    minx = null;\\n                    miny = null;\\n                }\\n            } else {\\n                minx = rectangle[0];\\n                miny = rectangle[1];\\n            }\\n            minxseen = Math.min(minxseen, rectangle[0]);\\n            minyseen = Math.min(minyseen, rectangle[1]);\\n        }\\n        if (minx == null || miny == null || minx > minxseen || miny > minyseen) {\\n            return false;\\n        }\\n        // find most right, most top point (maxx, maxy)\\n        Integer maxx = rectangles[0][2];\\n        Integer maxy = rectangles[0][3];\\n        int maxxseen = Integer.MIN_VALUE;\\n        int maxyseen = Integer.MIN_VALUE;\\n        for (int i = 1; i < rectangles.length; i++) {\\n            int[] rectangle = rectangles[i];\\n            if (maxx != null && maxy != null) {\\n                if (rectangle[2] >= maxx && rectangle[3] >= maxy) {\\n                    maxx = rectangle[2];\\n                    maxy = rectangle[3];\\n                } else if (!(rectangle[2] <= maxx && rectangle[3] <= maxy)) {\\n                    maxx = null;\\n                    maxy = null;\\n                }\\n            } else {\\n                maxx = rectangle[2];\\n                maxy = rectangle[3];\\n            }\\n            maxxseen = Math.max(maxxseen, rectangle[2]);\\n            maxyseen = Math.max(maxyseen, rectangle[3]);\\n        }\\n        if (maxx == null || maxy == null || maxx < maxxseen || maxy < maxyseen) {\\n            return false;\\n        }\\n        // expected area\\n        int expectArea = (maxx - minx) * (maxy - miny);\\n        // real area\\n        int realArea = 0;\\n        for (int[] rectangle : rectangles) {\\n            realArea += (rectangle[2] - rectangle[0]) * (rectangle[3] - rectangle[1]);\\n        }\\n        // filter\\n        if (expectArea != realArea) {\\n            return false;\\n        }\\n        // if overlap, then false; otherwise, true\\n        List<Interval> intervals = new ArrayList<>();\\n        for (int[] rectangle : rectangles) {\\n            Interval left = new Interval(rectangle[0], rectangle[1], rectangle[3] - 1, true);\\n            Interval right = new Interval(rectangle[2] - 1, rectangle[1], rectangle[3] - 1, false);\\n            intervals.add(left);\\n            intervals.add(right);\\n        }\\n        Collections.sort(intervals, new Comparator<Interval>() {\\n            @Override\\n            public int compare(Interval itv1, Interval itv2) {\\n                if (itv1.x != itv2.x) {\\n                    return itv1.x - itv2.x;\\n                } else if (itv1.left == itv2.left) {\\n                    return 0;\\n                } else if (itv1.left) {\\n                    return -1;\\n                } else {\\n                    return 1;\\n                }\\n            }\\n        });\\n        Set<Interval> bst = new TreeSet<>(new Comparator<Interval>() {\\n            @Override\\n            public int compare(Interval itv1, Interval itv2) {\\n                if (itv1.y2 < itv2.y1) {\\n                    return -1;\\n                } else if (itv1.y1 > itv2.y2) {\\n                    return 1;\\n                } else {\\n                    return 0;\\n                }\\n            }\\n        });\\n        for (Interval interval : intervals) {\\n            if (interval.left) {\\n                if (!bst.add(interval)) {\\n                    return false;\\n                }\\n            } else {\\n                bst.remove(interval);\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    class Interval {\\n        int x;\\n        int y1;\\n        int y2;\\n        boolean left;\\n        public Interval(int x, int y1, int y2, boolean left) {\\n            this.x = x;\\n            this.y1 = y1;\\n            this.y2 = y2;\\n            this.left = left;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public boolean isRectangleCover(int[][] rectangles) {\\n        if (rectangles == null || rectangles.length <= 1) {\\n            return true;\\n        }\\n        assert rectangles[0].length == 4;\\n        // find most left, most bottom point (minx, miny)\\n        Integer minx = rectangles[0][0];\\n        Integer miny = rectangles[0][1];\\n        int minxseen = Integer.MAX_VALUE;\\n        int minyseen = Integer.MAX_VALUE;\\n        for (int i = 1; i < rectangles.length; i++) {\\n            int[] rectangle = rectangles[i];\\n            if (minx != null && miny != null) {\\n                if (rectangle[0] <= minx && rectangle[1] <= miny) {\\n                    minx = rectangle[0];\\n                    miny = rectangle[1];\\n                } else if (!(rectangle[0] >= minx && rectangle[1] >= miny)) {\\n                    minx = null;\\n                    miny = null;\\n                }\\n            } else {\\n                minx = rectangle[0];\\n                miny = rectangle[1];\\n            }\\n            minxseen = Math.min(minxseen, rectangle[0]);\\n            minyseen = Math.min(minyseen, rectangle[1]);\\n        }\\n        if (minx == null || miny == null || minx > minxseen || miny > minyseen) {\\n            return false;\\n        }\\n        // find most right, most top point (maxx, maxy)\\n        Integer maxx = rectangles[0][2];\\n        Integer maxy = rectangles[0][3];\\n        int maxxseen = Integer.MIN_VALUE;\\n        int maxyseen = Integer.MIN_VALUE;\\n        for (int i = 1; i < rectangles.length; i++) {\\n            int[] rectangle = rectangles[i];\\n            if (maxx != null && maxy != null) {\\n                if (rectangle[2] >= maxx && rectangle[3] >= maxy) {\\n                    maxx = rectangle[2];\\n                    maxy = rectangle[3];\\n                } else if (!(rectangle[2] <= maxx && rectangle[3] <= maxy)) {\\n                    maxx = null;\\n                    maxy = null;\\n                }\\n            } else {\\n                maxx = rectangle[2];\\n                maxy = rectangle[3];\\n            }\\n            maxxseen = Math.max(maxxseen, rectangle[2]);\\n            maxyseen = Math.max(maxyseen, rectangle[3]);\\n        }\\n        if (maxx == null || maxy == null || maxx < maxxseen || maxy < maxyseen) {\\n            return false;\\n        }\\n        // expected area\\n        int expectArea = (maxx - minx) * (maxy - miny);\\n        // real area\\n        int realArea = 0;\\n        for (int[] rectangle : rectangles) {\\n            realArea += (rectangle[2] - rectangle[0]) * (rectangle[3] - rectangle[1]);\\n        }\\n        // filter\\n        if (expectArea != realArea) {\\n            return false;\\n        }\\n        // if overlap, then false; otherwise, true\\n        List<Interval> intervals = new ArrayList<>();\\n        for (int[] rectangle : rectangles) {\\n            Interval left = new Interval(rectangle[0], rectangle[1], rectangle[3] - 1, true);\\n            Interval right = new Interval(rectangle[2] - 1, rectangle[1], rectangle[3] - 1, false);\\n            intervals.add(left);\\n            intervals.add(right);\\n        }\\n        Collections.sort(intervals, new Comparator<Interval>() {\\n            @Override\\n            public int compare(Interval itv1, Interval itv2) {\\n                if (itv1.x != itv2.x) {\\n                    return itv1.x - itv2.x;\\n                } else if (itv1.left == itv2.left) {\\n                    return 0;\\n                } else if (itv1.left) {\\n                    return -1;\\n                } else {\\n                    return 1;\\n                }\\n            }\\n        });\\n        Set<Interval> bst = new TreeSet<>(new Comparator<Interval>() {\\n            @Override\\n            public int compare(Interval itv1, Interval itv2) {\\n                if (itv1.y2 < itv2.y1) {\\n                    return -1;\\n                } else if (itv1.y1 > itv2.y2) {\\n                    return 1;\\n                } else {\\n                    return 0;\\n                }\\n            }\\n        });\\n        for (Interval interval : intervals) {\\n            if (interval.left) {\\n                if (!bst.add(interval)) {\\n                    return false;\\n                }\\n            } else {\\n                bst.remove(interval);\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    class Interval {\\n        int x;\\n        int y1;\\n        int y2;\\n        boolean left;\\n        public Interval(int x, int y1, int y2, boolean left) {\\n            this.x = x;\\n            this.y1 = y1;\\n            this.y2 = y2;\\n            this.left = left;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 87231,
                "title": "java-o-n-dfs-solution-updated",
                "content": "By considering this problem as to connect rectangles, we start from the bottom left corner one. Then, the other three corners of this rectangle are the connecting points with the other rectangles since we want to form a perfect **BIG** rectangle **puzzle** at the end. This **puzzle** consist of **every** **SMALL** rectangles as its puzzle pieces.\\nTherefore, at the end of DFS function, if there are any rectangles left, it means that these pieces **can not** fit into the puzzle.\\n\\nWith this approach, we only need one hash table to store all rectangles using rectangles' bottom-left  x,y as key. And then, use this key connecting with other rectangles. \\n\\n*** Update ***\\nFound counterexample for the previous solution. This is an updated version which incorporates corner counts. However, it seems to be overkill.      \\n\\n```\\npublic class Solution {\\n    \\n    long encode(int[] point) {\\n        return ((long)point[0] << 32) + (long)point[1];\\n    }\\n    void addPoint(long key, Set<Long> conners){\\n        if (conners.contains(key)) conners.remove(key);\\n        else conners.add(key);\\n    }\\n    boolean DFS(int x, int y, HashMap<Long,int[]> rects) {\\n        Stack<int[]> points = new Stack<int[]>();\\n        Set<Long> conners = new HashSet<Long>();\\n        points.push(new int[]{x,y});\\n        while ( ! points.isEmpty() ) {\\n            long key =  encode(points.pop());\\n            if ( rects.containsKey(key)) {\\n                int[] rect = rects.remove(key);\\n                addPoint(key, conners);\\n                addPoint(encode(new int[]{rect[2],rect[3]}),conners);\\n                addPoint(encode(new int[]{rect[0],rect[3]}),conners);\\n                addPoint(encode(new int[]{rect[2],rect[1]}),conners);\\n                points.push(new int[]{rect[2],rect[3]}); \\n                points.push(new int[]{rect[0],rect[3]});\\n                points.push(new int[]{rect[2],rect[1]});\\n            } \\n        }\\n        return conners.size() == 4;\\n    }\\n    public boolean isRectangleCover(int[][] rectangles) {\\n        if (rectangles==null) return false;\\n        long sum = 0;\\n        int top = Integer.MIN_VALUE, bottom = Integer.MAX_VALUE, left = Integer.MAX_VALUE, right = Integer.MIN_VALUE;\\n        HashMap<Long,int[]> rects = new HashMap<>();\\n        for (int[] rect : rectangles) {\\n            long key = encode(new int[]{rect[0],rect[1]});\\n            if ( rects.containsKey(key) ) return false;\\n            rects.put(key, rect);\\n            left = Math.min(left, rect[0]);\\n            right = Math.max(right, rect[2]);\\n            bottom = Math.min(bottom,rect[1]);\\n            top = Math.max(top, rect[3]);\\n            sum += ((long)rect[2]-(long)rect[0]) * ((long)rect[3]-(long)rect[1]); \\n        }\\n        if ( sum != ((long)top-(long)bottom) * ((long)right-(long)left)) return false;\\n        if (! DFS(left, bottom, rects)) return false;\\n        return rects.isEmpty();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    \\n    long encode(int[] point) {\\n        return ((long)point[0] << 32) + (long)point[1];\\n    }\\n    void addPoint(long key, Set<Long> conners){\\n        if (conners.contains(key)) conners.remove(key);\\n        else conners.add(key);\\n    }\\n    boolean DFS(int x, int y, HashMap<Long,int[]> rects) {\\n        Stack<int[]> points = new Stack<int[]>();\\n        Set<Long> conners = new HashSet<Long>();\\n        points.push(new int[]{x,y});\\n        while ( ! points.isEmpty() ) {\\n            long key =  encode(points.pop());\\n            if ( rects.containsKey(key)) {\\n                int[] rect = rects.remove(key);\\n                addPoint(key, conners);\\n                addPoint(encode(new int[]{rect[2],rect[3]}),conners);\\n                addPoint(encode(new int[]{rect[0],rect[3]}),conners);\\n                addPoint(encode(new int[]{rect[2],rect[1]}),conners);\\n                points.push(new int[]{rect[2],rect[3]}); \\n                points.push(new int[]{rect[0],rect[3]});\\n                points.push(new int[]{rect[2],rect[1]});\\n            } \\n        }\\n        return conners.size() == 4;\\n    }\\n    public boolean isRectangleCover(int[][] rectangles) {\\n        if (rectangles==null) return false;\\n        long sum = 0;\\n        int top = Integer.MIN_VALUE, bottom = Integer.MAX_VALUE, left = Integer.MAX_VALUE, right = Integer.MIN_VALUE;\\n        HashMap<Long,int[]> rects = new HashMap<>();\\n        for (int[] rect : rectangles) {\\n            long key = encode(new int[]{rect[0],rect[1]});\\n            if ( rects.containsKey(key) ) return false;\\n            rects.put(key, rect);\\n            left = Math.min(left, rect[0]);\\n            right = Math.max(right, rect[2]);\\n            bottom = Math.min(bottom,rect[1]);\\n            top = Math.max(top, rect[3]);\\n            sum += ((long)rect[2]-(long)rect[0]) * ((long)rect[3]-(long)rect[1]); \\n        }\\n        if ( sum != ((long)top-(long)bottom) * ((long)right-(long)left)) return false;\\n        if (! DFS(left, bottom, rects)) return false;\\n        return rects.isEmpty();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3032013,
                "title": "map-c-30days6companies-line-sweeping-algorithm-explanation-with-comments",
                "content": "**Intution :** \\n\\t\\t If we keep adding the bottom left and top right corners, at the end we should get only 4 corners in the map otherwise answer will be false\\n An edge case is given of overalpping rectangles, to solve it we can simply check whether all the corners have an absolute value of 1 or not\\n \\n \\n **Approach :**\\n          We will maintain a map of pairs to store the coordinates given, bottom left coordinate and top right coordinate will be incremented in the map while the top left and bottom right will be decremented. Doing this, will leave us the non cancelled coordinates in the end !!!\\n\\t\\t\\n**Time Complexity : O(nlogn)**\\n\\n**CPP Solution**\\n```\\nclass Solution {\\npublic:\\n    bool isRectangleCover(vector<vector<int>>& rectangles) {\\n        map<pair<int, int>, int> m;\\n    \\n        for(auto r : rectangles) {\\n            \\n            // We will add the coordinates of left bottom corner and top right corner\\n            // We will also subtract the top left corner and bottom right corner\\n            m[{r[0], r[1]}]++;\\n            m[{r[2], r[3]}]++;\\n            m[{r[0], r[3]}]--;\\n            m[{r[2], r[1]}]--;\\n            \\n            // When the number of points become zero, we will remove the points\\n            \\n            if(m[{r[0], r[3]}] == 0) m.erase({r[0], r[3]});\\n            if(m[{r[2], r[1]}] == 0) m.erase({r[2], r[1]});\\n            if(m[{r[0], r[1]}] == 0) m.erase({r[0], r[1]});\\n            if(m[{r[2], r[3]}] == 0) m.erase({r[2], r[3]});\\n            \\n        }\\n        \\n        // Now, the points remaining in the map will be the corners, so if there are less than or more than 4 cornersm, answer will be false\\n        \\n        if(m.size() != 4) return false;\\n        \\n        // If two rectangle overlaps, still we are suppose to return false, so we are checking whether all points are 1 or not\\n        for(auto i : m) {\\n            if(abs(i.second) != 1) return false;\\n        }\\n        \\n        return true;\\n        \\n    }\\n};\\n```\\n\\n\\nHope it would have halped !!!\\nThank You !!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isRectangleCover(vector<vector<int>>& rectangles) {\\n        map<pair<int, int>, int> m;\\n    \\n        for(auto r : rectangles) {\\n            \\n            // We will add the coordinates of left bottom corner and top right corner\\n            // We will also subtract the top left corner and bottom right corner\\n            m[{r[0], r[1]}]++;\\n            m[{r[2], r[3]}]++;\\n            m[{r[0], r[3]}]--;\\n            m[{r[2], r[1]}]--;\\n            \\n            // When the number of points become zero, we will remove the points\\n            \\n            if(m[{r[0], r[3]}] == 0) m.erase({r[0], r[3]});\\n            if(m[{r[2], r[1]}] == 0) m.erase({r[2], r[1]});\\n            if(m[{r[0], r[1]}] == 0) m.erase({r[0], r[1]});\\n            if(m[{r[2], r[3]}] == 0) m.erase({r[2], r[3]});\\n            \\n        }\\n        \\n        // Now, the points remaining in the map will be the corners, so if there are less than or more than 4 cornersm, answer will be false\\n        \\n        if(m.size() != 4) return false;\\n        \\n        // If two rectangle overlaps, still we are suppose to return false, so we are checking whether all points are 1 or not\\n        for(auto i : m) {\\n            if(abs(i.second) != 1) return false;\\n        }\\n        \\n        return true;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3004478,
                "title": "o-n-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe idea for this problem is to check if a set of rectangles can be covered by a single rectangle.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTo do this, we can use the following steps:\\n\\n- If the input list of rectangles is empty, return False.\\n- If the input list has a single rectangle, return True.\\n- Initialize variables to store the minimum and maximum x and y coordinates of the rectangles, and the area of the rectangles.\\n- Iterate over the rectangles and update the minimum and maximum x and y coordinates and the area of the rectangles.\\n- Initialize a set to store the points of the rectangles.\\n- Iterate over the rectangles again and add the points to the set. If a point is already in the set, remove it. Otherwise, add it to the set.\\n- Return True if the area of the rectangles is equal to the area of the bounding rectangle and the set of points is equal to the four corner points of the bounding rectangle, otherwise return False.\\n\\n# Complexity\\n- Time complexity: $O(n)$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nWe need to perform a single pass through the input list of rectangles.\\n\\n\\n- Space complexity: $O(n)$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nWe need to store the points of the rectangles in a set, which takes $O(n)$ space.\\n# Code\\n```\\nclass Solution:\\n    def isRectangleCover(self, rectangles: List[List[int]]) -> bool:\\n        if not rectangles:\\n            return False\\n        if len(rectangles) == 1:\\n            return True\\n        x1 = y1 = float(\\'inf\\')\\n        x2 = y2 = float(\\'-inf\\')\\n        area = 0\\n        points = set()\\n        for x, y, xx, yy in rectangles:\\n            x1 = min(x1, x)\\n            y1 = min(y1, y)\\n            x2 = max(x2, xx)\\n            y2 = max(y2, yy)\\n            area += (xx - x) * (yy - y)\\n            p1 = (x, y)\\n            p2 = (xx, y)\\n            p3 = (xx, yy)\\n            p4 = (x, yy)\\n            for p in (p1, p2, p3, p4):\\n                if p in points:\\n                    points.remove(p)\\n                else:\\n                    points.add(p)\\n        return area == (x2 - x1) * (y2 - y1) and points == {(x1, y1), (x1, y2), (x2, y1), (x2, y2)}\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isRectangleCover(self, rectangles: List[List[int]]) -> bool:\\n        if not rectangles:\\n            return False\\n        if len(rectangles) == 1:\\n            return True\\n        x1 = y1 = float(\\'inf\\')\\n        x2 = y2 = float(\\'-inf\\')\\n        area = 0\\n        points = set()\\n        for x, y, xx, yy in rectangles:\\n            x1 = min(x1, x)\\n            y1 = min(y1, y)\\n            x2 = max(x2, xx)\\n            y2 = max(y2, yy)\\n            area += (xx - x) * (yy - y)\\n            p1 = (x, y)\\n            p2 = (xx, y)\\n            p3 = (xx, yy)\\n            p4 = (x, yy)\\n            for p in (p1, p2, p3, p4):\\n                if p in points:\\n                    points.remove(p)\\n                else:\\n                    points.add(p)\\n        return area == (x2 - x1) * (y2 - y1) and points == {(x1, y1), (x1, y2), (x2, y1), (x2, y2)}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2890213,
                "title": "c-code-easy-to-understand",
                "content": "# Please upvote if you like this solution\\n\\n# Intuition\\nArea of all rectangele should be equal to area of total rectangle\\n\\n# Approach\\nHere we have to store all the four sides of all the rectangle and if some points repeats then we have remove that point and then we have to check if total area is equal to the sum of area of all the rectangles\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isRectangleCover(vector<vector<int>> &rectangles)\\n    if (rectangles.size() == 0 || rectangles[0].size() == 0)\\n    {\\n        {\\n            return false;\\n        }\\n    \\n        int x1 = INT_MAX;\\n        int x2 = INT_MIN;\\n        int y1 = INT_MAX;\\n        int y2 = INT_MIN;\\n    \\n        unordered_set<string> set;\\n        long long area = 0;\\n    \\n        for (auto rect : rectangles)\\n        {\\n            x1 = min(rect[0], x1);\\n            y1 = min(rect[1], y1);\\n            x2 = max(rect[2], x2);\\n            y2 = max(rect[3], y2);\\n    \\n            area += ((long long)(rect[2] - rect[0])) * ((long long)(rect[3] - rect[1]));\\n    \\n            string s1 = to_string(rect[0]) + \" \" + to_string(rect[1]);\\n            string s2 = to_string(rect[0]) + \" \" + to_string(rect[3]);\\n            string s3 = to_string(rect[2]) + \" \" + to_string(rect[3]);\\n            string s4 = to_string(rect[2]) + \" \" + to_string(rect[1]);\\n    \\n            if (set.find(s1) != set.end())\\n            {\\n                set.erase(s1);\\n            }\\n            else\\n            {\\n                set.insert(s1);\\n            }\\n            if (set.find(s2) != set.end())\\n            {\\n                set.erase(s2);\\n            }\\n            else\\n            {\\n                set.insert(s2);\\n            }\\n            if (set.find(s3) != set.end())\\n            {\\n                set.erase(s3);\\n            }\\n            else\\n            {\\n                set.insert(s3);\\n            }\\n            if (set.find(s4) != set.end())\\n            {\\n                set.erase(s4);\\n            }\\n            else\\n            {\\n                set.insert(s4);\\n            }\\n        }\\n    \\n        if (set.find(to_string(x1) + \" \" + to_string(y1)) == set.end() || set.find(to_string(x1) + \" \" + to_string(y2)) == set.end() || set.find(to_string(x2) + \" \" + to_string(y1)) == set.end() || set.find(to_string(x2) + \" \" + to_string(y2)) == set.end() || set.size() != 4)\\n        {\\n            return false;\\n        }\\n    \\n        return area == ((long long)(x2 - x1)) * ((long long)(y2 - y1));\\n     }\\n};\\n    ```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math",
                    "Brainteaser",
                    "Geometry"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isRectangleCover(vector<vector<int>> &rectangles)\\n    if (rectangles.size() == 0 || rectangles[0].size() == 0)\\n    {\\n        {\\n            return false;\\n        }\\n    \\n        int x1 = INT_MAX;\\n        int x2 = INT_MIN;\\n        int y1 = INT_MAX;\\n        int y2 = INT_MIN;\\n    \\n        unordered_set<string> set;\\n        long long area = 0;\\n    \\n        for (auto rect : rectangles)\\n        {\\n            x1 = min(rect[0], x1);\\n            y1 = min(rect[1], y1);\\n            x2 = max(rect[2], x2);\\n            y2 = max(rect[3], y2);\\n    \\n            area += ((long long)(rect[2] - rect[0])) * ((long long)(rect[3] - rect[1]));\\n    \\n            string s1 = to_string(rect[0]) + \" \" + to_string(rect[1]);\\n            string s2 = to_string(rect[0]) + \" \" + to_string(rect[3]);\\n            string s3 = to_string(rect[2]) + \" \" + to_string(rect[3]);\\n            string s4 = to_string(rect[2]) + \" \" + to_string(rect[1]);\\n    \\n            if (set.find(s1) != set.end())\\n            {\\n                set.erase(s1);\\n            }\\n            else\\n            {\\n                set.insert(s1);\\n            }\\n            if (set.find(s2) != set.end())\\n            {\\n                set.erase(s2);\\n            }\\n            else\\n            {\\n                set.insert(s2);\\n            }\\n            if (set.find(s3) != set.end())\\n            {\\n                set.erase(s3);\\n            }\\n            else\\n            {\\n                set.insert(s3);\\n            }\\n            if (set.find(s4) != set.end())\\n            {\\n                set.erase(s4);\\n            }\\n            else\\n            {\\n                set.insert(s4);\\n            }\\n        }\\n    \\n        if (set.find(to_string(x1) + \" \" + to_string(y1)) == set.end() || set.find(to_string(x1) + \" \" + to_string(y2)) == set.end() || set.find(to_string(x2) + \" \" + to_string(y1)) == set.end() || set.find(to_string(x2) + \" \" + to_string(y2)) == set.end() || set.size() != 4)\\n        {\\n            return false;\\n        }\\n    \\n        return area == ((long long)(x2 - x1)) * ((long long)(y2 - y1));\\n     }\\n};\\n    ```",
                "codeTag": "Java"
            },
            {
                "id": 2544525,
                "title": "concise-c-using-map",
                "content": "The key is: all the points (except the four outmost corner points) should appear even times, and the four corner points should appear once.\\n```\\n    bool isRectangleCover(vector<vector<int>>& rectangles) {\\n        map<pair<int, int>, int> count;\\n        for(vector<int> &rect : rectangles){\\n            count[{rect[0], rect[1]}]++;\\n            count[{rect[0], rect[3]}]--;\\n            count[{rect[2], rect[1]}]--;\\n            count[{rect[2], rect[3]}]++;\\n        }\\n        int corners = 0;\\n        for(auto &cnt : count){\\n            corners += abs(cnt.second);\\n        }\\n        return corners == 4;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n    bool isRectangleCover(vector<vector<int>>& rectangles) {\\n        map<pair<int, int>, int> count;\\n        for(vector<int> &rect : rectangles){\\n            count[{rect[0], rect[1]}]++;\\n            count[{rect[0], rect[3]}]--;\\n            count[{rect[2], rect[1]}]--;\\n            count[{rect[2], rect[3]}]++;\\n        }\\n        int corners = 0;\\n        for(auto &cnt : count){\\n            corners += abs(cnt.second);\\n        }\\n        return corners == 4;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1890955,
                "title": "perfect-rectangle-solution-java",
                "content": "class Solution {\\n  public boolean isRectangleCover(int[][] rectangles) {\\n    int area = 0;\\n    int x1 = Integer.MAX_VALUE;\\n    int y1 = Integer.MAX_VALUE;\\n    int x2 = Integer.MIN_VALUE;\\n    int y2 = Integer.MIN_VALUE;\\n    Set<String> corners = new HashSet<>();\\n\\n    for (int[] r : rectangles) {\\n      area += (r[2] - r[0]) * (r[3] - r[1]);\\n      x1 = Math.min(x1, r[0]);\\n      y1 = Math.min(y1, r[1]);\\n      x2 = Math.max(x2, r[2]);\\n      y2 = Math.max(y2, r[3]);\\n\\n      // four points of current rectangle\\n      String[] points = new String[] {\\n        r[0] + \" \" + r[1],\\n        r[0] + \" \" + r[3],\\n        r[2] + \" \" + r[1],\\n        r[2] + \" \" + r[3]\\n      };\\n      for (final String point : points)\\n        if (!corners.add(point))\\n          corners.remove(point);\\n    }\\n\\n    if (corners.size() != 4)\\n      return false;\\n    if (!corners.contains(x1 + \" \" + y1) ||\\n        !corners.contains(x1 + \" \" + y2) ||\\n        !corners.contains(x2 + \" \" + y1) ||\\n        !corners.contains(x2 + \" \" + y2))\\n      return false;\\n\\n    return area == (x2 - x1) * (y2 - y1);\\n  }\\n}\\n",
                "solutionTags": [
                    "Array"
                ],
                "code": "class Solution {\\n  public boolean isRectangleCover(int[][] rectangles) {\\n    int area = 0;\\n    int x1 = Integer.MAX_VALUE;\\n    int y1 = Integer.MAX_VALUE;\\n    int x2 = Integer.MIN_VALUE;\\n    int y2 = Integer.MIN_VALUE;\\n    Set<String> corners = new HashSet<>();\\n\\n    for (int[] r : rectangles) {\\n      area += (r[2] - r[0]) * (r[3] - r[1]);\\n      x1 = Math.min(x1, r[0]);\\n      y1 = Math.min(y1, r[1]);\\n      x2 = Math.max(x2, r[2]);\\n      y2 = Math.max(y2, r[3]);\\n\\n      // four points of current rectangle\\n      String[] points = new String[] {\\n        r[0] + \" \" + r[1],\\n        r[0] + \" \" + r[3],\\n        r[2] + \" \" + r[1],\\n        r[2] + \" \" + r[3]\\n      }",
                "codeTag": "Java"
            },
            {
                "id": 1789040,
                "title": "python-crystal-clear-dead-simple-in-7-terse-lines-merge-count-intersections-o-n",
                "content": "```python\\ndef isRectangleCover(self, rectangles):\\n    cnt = collections.defaultdict(lambda: [0, 0, 0, 0])\\n    for x, y, a, b in rectangles:\\n        for i, p in enumerate([(x, y), (x, b), (a, b), (a, y)]):\\n            j, k = i - 1, (i + 1) % 4\\n            if   cnt[p][j]: cnt[p][j] -= 1\\n            elif cnt[p][k]: cnt[p][k] -= 1\\n            else:           cnt[p][i] += 1\\n    return sum(itertools.chain(*cnt.values())) == 4\\n```\\nIdea `@orthogonal1`  in 7 lines below,\\n```python\\ndef isRectangleCover(self, rectangles):\\n    cnt = collections.defaultdict(int)\\n    for x, y, a, b in rectangles:\\n        cnt[x, y] += 1\\n        cnt[x, b] -= 1\\n        cnt[a, b] += 1\\n        cnt[a, y] -= 1\\n    return sum(map(abs, cnt.values())) == 4\\n```",
                "solutionTags": [],
                "code": "```python\\ndef isRectangleCover(self, rectangles):\\n    cnt = collections.defaultdict(lambda: [0, 0, 0, 0])\\n    for x, y, a, b in rectangles:\\n        for i, p in enumerate([(x, y), (x, b), (a, b), (a, y)]):\\n            j, k = i - 1, (i + 1) % 4\\n            if   cnt[p][j]: cnt[p][j] -= 1\\n            elif cnt[p][k]: cnt[p][k] -= 1\\n            else:           cnt[p][i] += 1\\n    return sum(itertools.chain(*cnt.values())) == 4\\n```\n```python\\ndef isRectangleCover(self, rectangles):\\n    cnt = collections.defaultdict(int)\\n    for x, y, a, b in rectangles:\\n        cnt[x, y] += 1\\n        cnt[x, b] -= 1\\n        cnt[a, b] += 1\\n        cnt[a, y] -= 1\\n    return sum(map(abs, cnt.values())) == 4\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1583071,
                "title": "java-runtime-faster-than-94-55-memory-usage-less-than-99-09",
                "content": "```\\nclass Solution {\\n    public boolean isRectangleCover(int[][] rectangles) {\\n        Set<Point> container = new HashSet<>();\\n        // add each rectangle area to totalArea\\n        int totalArea = 0;\\n        // A rectangle has four points, if a point appears twice, it will be deleted it from the set\\n        for (int[] rectangle : rectangles) {\\n            totalArea += (rectangle[2] - rectangle[0]) * (rectangle[3] - rectangle[1]);\\n            Point p1 = new Point(rectangle[0], rectangle[1]);\\n            Point p2 = new Point(rectangle[2], rectangle[1]);\\n            Point p3 = new Point(rectangle[2], rectangle[3]);\\n            Point p4 = new Point(rectangle[0], rectangle[3]);\\n            if (container.contains(p1)) container.remove(p1);\\n            else container.add(p1);\\n            if (container.contains(p2)) container.remove(p2);\\n            else container.add(p2);\\n            if (container.contains(p3)) container.remove(p3);\\n            else container.add(p3);\\n            if (container.contains(p4)) container.remove(p4);\\n            else container.add(p4);\\n        }\\n        // A perfect rectangle must has four points\\n        if (container.size() != 4) return false;\\n\\n        // these four points represent the last perfect rectangle, check this rectangle area to the totalArea\\n        int minX = Integer.MAX_VALUE, maxX = Integer.MIN_VALUE, minY = Integer.MAX_VALUE, maxY = Integer.MIN_VALUE;\\n        Iterator<Point> iter = container.iterator();\\n        while (iter.hasNext()) {\\n            Point p = iter.next();\\n            minX = Math.min(minX, p.x);\\n            maxX = Math.max(maxX, p.x);\\n            minY = Math.min(minY, p.y);\\n            maxY = Math.max(maxY, p.y);\\n        }\\n        return totalArea == (maxX - minX) * (maxY - minY);\\n    }\\n\\n    private class Point {\\n        int x, y;\\n\\n        public Point(int x, int y) {\\n            this.x = x;\\n            this.y = y;\\n        }\\n\\n        @Override\\n        public boolean equals(Object o) {\\n            if (this == o) return true;\\n            if (o == null || getClass() != o.getClass()) return false;\\n            Point Point = (Point) o;\\n            return x == Point.x &&\\n                    y == Point.y;\\n        }\\n\\n        @Override\\n        public int hashCode() {\\n            return Objects.hash(x, y);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isRectangleCover(int[][] rectangles) {\\n        Set<Point> container = new HashSet<>();\\n        // add each rectangle area to totalArea\\n        int totalArea = 0;\\n        // A rectangle has four points, if a point appears twice, it will be deleted it from the set\\n        for (int[] rectangle : rectangles) {\\n            totalArea += (rectangle[2] - rectangle[0]) * (rectangle[3] - rectangle[1]);\\n            Point p1 = new Point(rectangle[0], rectangle[1]);\\n            Point p2 = new Point(rectangle[2], rectangle[1]);\\n            Point p3 = new Point(rectangle[2], rectangle[3]);\\n            Point p4 = new Point(rectangle[0], rectangle[3]);\\n            if (container.contains(p1)) container.remove(p1);\\n            else container.add(p1);\\n            if (container.contains(p2)) container.remove(p2);\\n            else container.add(p2);\\n            if (container.contains(p3)) container.remove(p3);\\n            else container.add(p3);\\n            if (container.contains(p4)) container.remove(p4);\\n            else container.add(p4);\\n        }\\n        // A perfect rectangle must has four points\\n        if (container.size() != 4) return false;\\n\\n        // these four points represent the last perfect rectangle, check this rectangle area to the totalArea\\n        int minX = Integer.MAX_VALUE, maxX = Integer.MIN_VALUE, minY = Integer.MAX_VALUE, maxY = Integer.MIN_VALUE;\\n        Iterator<Point> iter = container.iterator();\\n        while (iter.hasNext()) {\\n            Point p = iter.next();\\n            minX = Math.min(minX, p.x);\\n            maxX = Math.max(maxX, p.x);\\n            minY = Math.min(minY, p.y);\\n            maxY = Math.max(maxY, p.y);\\n        }\\n        return totalArea == (maxX - minX) * (maxY - minY);\\n    }\\n\\n    private class Point {\\n        int x, y;\\n\\n        public Point(int x, int y) {\\n            this.x = x;\\n            this.y = y;\\n        }\\n\\n        @Override\\n        public boolean equals(Object o) {\\n            if (this == o) return true;\\n            if (o == null || getClass() != o.getClass()) return false;\\n            Point Point = (Point) o;\\n            return x == Point.x &&\\n                    y == Point.y;\\n        }\\n\\n        @Override\\n        public int hashCode() {\\n            return Objects.hash(x, y);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1280125,
                "title": "391-stack-all-small-rectangles-verify-no-overlaps-gaps",
                "content": "---\\n\\nVery very difficult :)\\nTotally took life of out me to understand :)\\n\\nNeeds a lot of analysis on paper\\n\\n---\\n\\n**Algo:**\\n- Bruteforce (2nd solution)\\n  - Never passed\\n    - Passsed small tests (correctness)\\n    - Din\\'t pass large tests as it is too slow (performance)\\n      - So can be wrong solution too \\n- Optimal (1st solution)\\n  - Main core of this problem is two things\\n    - Are the rectangles stacking on each other porperly?\\n      - No overlaps (duplicate cell)\\n      - No gaps (missing cell/ hole)\\n  - After all stacking on each other is done, are are top of matching the largest rectangular region possible?\\n- So much time went in to understand that small logic :D, I din\\'t even check how the other answer (counting the points) work :D\\n\\nHope it is simple to understand.\\n\\n---\\n\\n**Optimal**\\n\\n```\\nvar isRectangleCover = function(R) {\\n    // left to right, bottom to top (so sort on bottom first, then left)\\n    R.sort(([left1, bottom1], [left2, bottom2]) => bottom1 - bottom2 || left1 - left2);\\n\\n    // Find all corners\\n    let leftMost = Infinity,\\n        bottomMost = Infinity,\\n        rightMost = -Infinity,\\n        topMost = -Infinity;\\n    for (let [left, bottom, right, top] of R) {\\n        leftMost = Math.min(leftMost, left);\\n        bottomMost = Math.min(bottomMost, bottom);\\n        rightMost = Math.max(rightMost, right);\\n        topMost = Math.max(topMost, top);\\n    }\\n\\n    // All calculations are with-respect-to large rectangle\\n    let CH = new Array(rightMost - leftMost).fill(0);\\n    for (let [left, bottom, right, top] of R) {\\n        const baseHeight = bottom - bottomMost; //        how high base is\\n        const ceilHeight = top - bottomMost; //           how high ceil is\\n        for (let tempLeft = left; tempLeft < right; tempLeft++) {\\n            if (CH[tempLeft - leftMost] != baseHeight)\\n                return false; // > is a duplicate cell < is a gap/ missing cell/ hole\\n            CH[tempLeft - leftMost] = ceilHeight;\\n        }\\n    }\\n\\n    const rectHeight = topMost - bottomMost;\\n    for (let ceilHeight of CH) {\\n        if (ceilHeight !== rectHeight)\\n            return false;\\n    }\\n    return true;\\n}\\n```\\n\\n---\\n\\n**A brute force** that dint pass - so it is possible that it is wrong\\n\\n```\\nvar isRectangleCover = function(R) {\\n    let leftMost = Infinity,\\n        bottomMost = Infinity,\\n        rightMost = -Infinity,\\n        topMost = -Infinity;\\n\\n    let set = new Set();\\n    for (let [x1, y1, x2, y2] of R)\\n        for (let x = x1; x < x2; x++)\\n            for (let y = y1; y < y2; y++) {\\n                if (\\n                    x != x2 &&\\n                    y != y2 &&\\n                    set.has(x + \\',\\' + y)\\n                )\\n                    return false\\n\\n                set.add(x + \\',\\' + y)\\n\\n                if (x < leftMost) leftMost = x;\\n                if (y < bottomMost) bottomMost = y;\\n                if (x > rightMost) rightMost = x;\\n                if (y > topMost) topMost = y;\\n            }\\n\\n    for (let x = leftMost; x <= rightMost; x++)\\n        for (let y = bottomMost; y <= topMost; y++)\\n            if (!set.has(x + \\',\\' + y))\\n                return false\\n\\n    return true;\\n};\\n```\\n\\n---\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar isRectangleCover = function(R) {\\n    // left to right, bottom to top (so sort on bottom first, then left)\\n    R.sort(([left1, bottom1], [left2, bottom2]) => bottom1 - bottom2 || left1 - left2);\\n\\n    // Find all corners\\n    let leftMost = Infinity,\\n        bottomMost = Infinity,\\n        rightMost = -Infinity,\\n        topMost = -Infinity;\\n    for (let [left, bottom, right, top] of R) {\\n        leftMost = Math.min(leftMost, left);\\n        bottomMost = Math.min(bottomMost, bottom);\\n        rightMost = Math.max(rightMost, right);\\n        topMost = Math.max(topMost, top);\\n    }\\n\\n    // All calculations are with-respect-to large rectangle\\n    let CH = new Array(rightMost - leftMost).fill(0);\\n    for (let [left, bottom, right, top] of R) {\\n        const baseHeight = bottom - bottomMost; //        how high base is\\n        const ceilHeight = top - bottomMost; //           how high ceil is\\n        for (let tempLeft = left; tempLeft < right; tempLeft++) {\\n            if (CH[tempLeft - leftMost] != baseHeight)\\n                return false; // > is a duplicate cell < is a gap/ missing cell/ hole\\n            CH[tempLeft - leftMost] = ceilHeight;\\n        }\\n    }\\n\\n    const rectHeight = topMost - bottomMost;\\n    for (let ceilHeight of CH) {\\n        if (ceilHeight !== rectHeight)\\n            return false;\\n    }\\n    return true;\\n}\\n```\n```\\nvar isRectangleCover = function(R) {\\n    let leftMost = Infinity,\\n        bottomMost = Infinity,\\n        rightMost = -Infinity,\\n        topMost = -Infinity;\\n\\n    let set = new Set();\\n    for (let [x1, y1, x2, y2] of R)\\n        for (let x = x1; x < x2; x++)\\n            for (let y = y1; y < y2; y++) {\\n                if (\\n                    x != x2 &&\\n                    y != y2 &&\\n                    set.has(x + \\',\\' + y)\\n                )\\n                    return false\\n\\n                set.add(x + \\',\\' + y)\\n\\n                if (x < leftMost) leftMost = x;\\n                if (y < bottomMost) bottomMost = y;\\n                if (x > rightMost) rightMost = x;\\n                if (y > topMost) topMost = y;\\n            }\\n\\n    for (let x = leftMost; x <= rightMost; x++)\\n        for (let y = bottomMost; y <= topMost; y++)\\n            if (!set.has(x + \\',\\' + y))\\n                return false\\n\\n    return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1215533,
                "title": "simple-c-o-n-solution-using-area-and-corner-count",
                "content": "Criteria 1:- A rectangle must have exact 4 corner points. \\n\\tSo, we use set to do that. We simply remove the point if it is already present or else put it in set. But in case where there is complete overlap it might fail.\\n\\tFor ex:- {{1,1,2,2},{1,1,2,2},{3,3,4,4}}. It seems to have 4 points({{3,3},{3,4},{4,3},{4,4}}) in the set at the end of the operation and satisfies the criteria. But due to overlap of rectangle should return false.Hence it fails for this test case. There for we use the 2nd criteria as well.\\n\\t2nd criteria is required only if according to 1st criteria we have 4 points left in the set.\\nCriteria 2:- Let S=sum the area of all the rectangles that have been given.\\n\\tAnd, P=area of rectangle left at the end in the set.\\n\\tIf(S==P) return true or else return false.\\n```\\nusing pii=pair<int,int>;\\nclass Solution {\\npublic:\\n    bool isRectangleCover(vector<vector<int>>& rectangles) {\\n        set<pii> s;\\n        vector<pii> v(4);\\n        long long area=0,c=0;\\n        for(auto a:rectangles){\\n            v[0]={a[0],a[1]};\\n            v[1]={a[2],a[3]};\\n            v[2]={a[0],a[3]};\\n            v[3]={a[2],a[1]};\\n            for(auto b:v){\\n                if(s.find(b)==s.end())\\n                    s.insert(b);\\n                else\\n                    s.erase(b);\\n            }\\n            area+=(long long)((a[3]-a[1])*(a[2]-a[0]));\\n        }\\n        int i=0;\\n        if(s.size()==4){\\n            for(auto a:s){\\n                v[i]=a;\\n                i++;\\n            }\\n            c=(long long)((v[3].second-v[0].second)*(v[3].first-v[0].first));\\n            if(area==c)\\n                return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nusing pii=pair<int,int>;\\nclass Solution {\\npublic:\\n    bool isRectangleCover(vector<vector<int>>& rectangles) {\\n        set<pii> s;\\n        vector<pii> v(4);\\n        long long area=0,c=0;\\n        for(auto a:rectangles){\\n            v[0]={a[0],a[1]};\\n            v[1]={a[2],a[3]};\\n            v[2]={a[0],a[3]};\\n            v[3]={a[2],a[1]};\\n            for(auto b:v){\\n                if(s.find(b)==s.end())\\n                    s.insert(b);\\n                else\\n                    s.erase(b);\\n            }\\n            area+=(long long)((a[3]-a[1])*(a[2]-a[0]));\\n        }\\n        int i=0;\\n        if(s.size()==4){\\n            for(auto a:s){\\n                v[i]=a;\\n                i++;\\n            }\\n            c=(long long)((v[3].second-v[0].second)*(v[3].first-v[0].first));\\n            if(area==c)\\n                return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1094374,
                "title": "naive-line-sweep-java-ac-with-segment-tree",
                "content": "This is a general solution of line sweep without building the segment tree, horizontal line sweep order is from smallest y to biggest y, for each round of sweep (each horizontal line) we update the segments which will be used to calculate the width of the area. Without any optimization on this general line sweep implementation, time complexity degraded from `O(nlogn)` to `O(n^2)`.\\n\\nin the end we compare the three values:\\n`outerRectangleArea`: area of rectangle defined by bottom left point and top right point\\n`allRectangleAreas`: all the rectangle areas summed (overlapping area calculated multiple times)\\n`targetRectangleArea`: line sweep get the covered area (overlapping area calculated once)\\n\\nworst performance (`O(n^2)`) comes from this scenario:\\n![image](https://assets.leetcode.com/users/images/3a3ba310-f284-41bd-9a29-a0ce46ea8f83_1614931745.2962854.png)\\n\\none optimization direction of the below code would be getting the width in `O(1)` time\\n\\n```java\\nclass Solution {\\n    public boolean isRectangleCover(int[][] rectangles) {\\n        Set<Integer> xLabels = new HashSet<>();\\n        List<YLine> yLines = new ArrayList<>();\\n\\n        // perfect rectangle defined by bottomLeft and topRight point, will be used for calculating targetRectangleArea\\n        int[] outerRectangleArea = {Integer.MAX_VALUE, Integer.MAX_VALUE, Integer.MIN_VALUE, Integer.MIN_VALUE};\\n\\n        // store all the rectangle areas, there could be overlapping part\\n        int[] allRectangleAreas = new int[1];\\n\\n        preprocessingRectangles(rectangles, yLines, xLabels, outerRectangleArea, allRectangleAreas);\\n\\n        int targetRectangleArea = calculateRectangleArea(outerRectangleArea);\\n        if (targetRectangleArea != allRectangleAreas[0]) return false;\\n\\n        List<Integer> xPoints = new ArrayList<>(xLabels);\\n        Collections.sort(yLines);\\n        Collections.sort(xPoints);\\n\\n        SegmentTree segmentTree = new SegmentTree(xPoints);\\n\\n        int coveredArea = 0;\\n        for(int i = 0; i < yLines.size() - 1; i++) {\\n            YLine curYLine = yLines.get(i), nextYLine = yLines.get(i + 1);\\n            segmentTree.updateValue(curYLine.xs, curYLine.xe, curYLine.type.value);\\n            int height = nextYLine.y - curYLine.y, width = segmentTree.getWidth();\\n            coveredArea += width * height;\\n        }\\n\\n        return targetRectangleArea == coveredArea;\\n    }\\n\\n    private void preprocessingRectangles(int[][] rectangles,\\n                                         List<YLine> yLines,\\n                                         Set<Integer> xLabels,\\n                                         int[] outerAreaRectangle,\\n                                         int[] allRectangleAreas) {\\n        for (int[] rectangle: rectangles) {\\n            int x1 = rectangle[0], x2 = rectangle[2];\\n            int y1 = rectangle[1], y2 = rectangle[3];\\n\\n            xLabels.add(x1);\\n            xLabels.add(x2);\\n\\n            yLines.add(new YLine(y1, x1, x2, TYPE.START));\\n            yLines.add(new YLine(y2, x1, x2, TYPE.END));\\n\\n            outerAreaRectangle[0] = Math.min(outerAreaRectangle[0], Math.min(x1, x2));\\n            outerAreaRectangle[1] = Math.min(outerAreaRectangle[1], Math.min(y1, y2));\\n            outerAreaRectangle[2] = Math.max(outerAreaRectangle[2], Math.max(x1, x2));\\n            outerAreaRectangle[3] = Math.max(outerAreaRectangle[3], Math.max(y1, y2));\\n\\n            allRectangleAreas[0] += calculateRectangleArea(new int[]{x1, y1, x2, y2});\\n        }\\n    }\\n\\n    private int calculateRectangleArea(int[] rectangle) {\\n        return (rectangle[3] - rectangle[1]) *(rectangle[2] - rectangle[0]);\\n    }\\n\\n    class YLine implements Comparable<YLine> {\\n        int y;\\n        int xs, xe; // start and end on x-axis\\n        TYPE type; // START: into the rectangle, END: out of the rectangle\\n        public YLine(int y, int xs, int xe, TYPE type) {\\n            this.y = y;\\n            this.xs = xs;\\n            this.xe = xe;\\n            this.type = type;\\n        }\\n        public int compareTo(YLine that) {\\n            if (this.y == that.y) {\\n                return this.xs - that.xs;\\n            }\\n            return this.y - that.y;\\n        }\\n    }\\n\\n    enum TYPE {\\n        START(1), END(-1);\\n\\n        public final int value;\\n\\n        private TYPE(int value) {\\n            this.value = value;\\n        }\\n    }\\n\\n    class SegmentTreeNode {\\n        int start, end, value;\\n        SegmentTreeNode left, right;\\n        public SegmentTreeNode(int start, int end) {\\n            this.start = start;\\n            this.end = end;\\n        }\\n    }\\n\\n    class SegmentTree {\\n        SegmentTreeNode root;\\n        public SegmentTree(List<Integer> xLabels) {\\n            this.root = constructSegmentTree(xLabels, 0, xLabels.size() - 1);\\n        }\\n\\n        private SegmentTreeNode constructSegmentTree(List<Integer> xLabels, int start, int end) {\\n            if (start >= end) return null;\\n            if (start + 1 == end) {\\n                return new SegmentTreeNode(xLabels.get(start), xLabels.get(end));\\n            }\\n\\n            SegmentTreeNode root = new SegmentTreeNode(xLabels.get(start), xLabels.get(end));\\n\\n            int mid = start + (end - start) / 2;\\n            root.left = constructSegmentTree(xLabels, start, mid);\\n            root.right = constructSegmentTree(xLabels, mid, end);\\n\\n            return root;\\n        }\\n\\n        private void updateValue(int start, int end, int value) {\\n            updateValue(this.root, start, end, value);\\n        }\\n\\n        private void updateValue(SegmentTreeNode root, int start, int end, int value) {\\n            if (root.start == start && root.end == end) {\\n                root.value += value;\\n            } else if (root.left != null && root.left.end >= end) {\\n                updateValue(root.left, start, end, value);\\n            } else if (root.right != null && root.right.start <= start) {\\n                updateValue(root.right, start, end, value);\\n            } else {\\n                updateValue(root.left, start, root.left.end, value);\\n                updateValue(root.right, root.right.start, end, value);\\n            }\\n        }\\n\\n        public int getWidth() {\\n            return getWidth(this.root);\\n        }\\n\\n        private int getWidth(SegmentTreeNode root) {\\n            if (root == null) return 0;\\n            if (root.value > 0) return root.end - root.start;\\n            int left = getWidth(root.left);\\n            int right = getWidth(root.right);\\n            return left + right;\\n        }\\n    }\\n}\\n```\\n\\n",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public boolean isRectangleCover(int[][] rectangles) {\\n        Set<Integer> xLabels = new HashSet<>();\\n        List<YLine> yLines = new ArrayList<>();\\n\\n        // perfect rectangle defined by bottomLeft and topRight point, will be used for calculating targetRectangleArea\\n        int[] outerRectangleArea = {Integer.MAX_VALUE, Integer.MAX_VALUE, Integer.MIN_VALUE, Integer.MIN_VALUE};\\n\\n        // store all the rectangle areas, there could be overlapping part\\n        int[] allRectangleAreas = new int[1];\\n\\n        preprocessingRectangles(rectangles, yLines, xLabels, outerRectangleArea, allRectangleAreas);\\n\\n        int targetRectangleArea = calculateRectangleArea(outerRectangleArea);\\n        if (targetRectangleArea != allRectangleAreas[0]) return false;\\n\\n        List<Integer> xPoints = new ArrayList<>(xLabels);\\n        Collections.sort(yLines);\\n        Collections.sort(xPoints);\\n\\n        SegmentTree segmentTree = new SegmentTree(xPoints);\\n\\n        int coveredArea = 0;\\n        for(int i = 0; i < yLines.size() - 1; i++) {\\n            YLine curYLine = yLines.get(i), nextYLine = yLines.get(i + 1);\\n            segmentTree.updateValue(curYLine.xs, curYLine.xe, curYLine.type.value);\\n            int height = nextYLine.y - curYLine.y, width = segmentTree.getWidth();\\n            coveredArea += width * height;\\n        }\\n\\n        return targetRectangleArea == coveredArea;\\n    }\\n\\n    private void preprocessingRectangles(int[][] rectangles,\\n                                         List<YLine> yLines,\\n                                         Set<Integer> xLabels,\\n                                         int[] outerAreaRectangle,\\n                                         int[] allRectangleAreas) {\\n        for (int[] rectangle: rectangles) {\\n            int x1 = rectangle[0], x2 = rectangle[2];\\n            int y1 = rectangle[1], y2 = rectangle[3];\\n\\n            xLabels.add(x1);\\n            xLabels.add(x2);\\n\\n            yLines.add(new YLine(y1, x1, x2, TYPE.START));\\n            yLines.add(new YLine(y2, x1, x2, TYPE.END));\\n\\n            outerAreaRectangle[0] = Math.min(outerAreaRectangle[0], Math.min(x1, x2));\\n            outerAreaRectangle[1] = Math.min(outerAreaRectangle[1], Math.min(y1, y2));\\n            outerAreaRectangle[2] = Math.max(outerAreaRectangle[2], Math.max(x1, x2));\\n            outerAreaRectangle[3] = Math.max(outerAreaRectangle[3], Math.max(y1, y2));\\n\\n            allRectangleAreas[0] += calculateRectangleArea(new int[]{x1, y1, x2, y2});\\n        }\\n    }\\n\\n    private int calculateRectangleArea(int[] rectangle) {\\n        return (rectangle[3] - rectangle[1]) *(rectangle[2] - rectangle[0]);\\n    }\\n\\n    class YLine implements Comparable<YLine> {\\n        int y;\\n        int xs, xe; // start and end on x-axis\\n        TYPE type; // START: into the rectangle, END: out of the rectangle\\n        public YLine(int y, int xs, int xe, TYPE type) {\\n            this.y = y;\\n            this.xs = xs;\\n            this.xe = xe;\\n            this.type = type;\\n        }\\n        public int compareTo(YLine that) {\\n            if (this.y == that.y) {\\n                return this.xs - that.xs;\\n            }\\n            return this.y - that.y;\\n        }\\n    }\\n\\n    enum TYPE {\\n        START(1), END(-1);\\n\\n        public final int value;\\n\\n        private TYPE(int value) {\\n            this.value = value;\\n        }\\n    }\\n\\n    class SegmentTreeNode {\\n        int start, end, value;\\n        SegmentTreeNode left, right;\\n        public SegmentTreeNode(int start, int end) {\\n            this.start = start;\\n            this.end = end;\\n        }\\n    }\\n\\n    class SegmentTree {\\n        SegmentTreeNode root;\\n        public SegmentTree(List<Integer> xLabels) {\\n            this.root = constructSegmentTree(xLabels, 0, xLabels.size() - 1);\\n        }\\n\\n        private SegmentTreeNode constructSegmentTree(List<Integer> xLabels, int start, int end) {\\n            if (start >= end) return null;\\n            if (start + 1 == end) {\\n                return new SegmentTreeNode(xLabels.get(start), xLabels.get(end));\\n            }\\n\\n            SegmentTreeNode root = new SegmentTreeNode(xLabels.get(start), xLabels.get(end));\\n\\n            int mid = start + (end - start) / 2;\\n            root.left = constructSegmentTree(xLabels, start, mid);\\n            root.right = constructSegmentTree(xLabels, mid, end);\\n\\n            return root;\\n        }\\n\\n        private void updateValue(int start, int end, int value) {\\n            updateValue(this.root, start, end, value);\\n        }\\n\\n        private void updateValue(SegmentTreeNode root, int start, int end, int value) {\\n            if (root.start == start && root.end == end) {\\n                root.value += value;\\n            } else if (root.left != null && root.left.end >= end) {\\n                updateValue(root.left, start, end, value);\\n            } else if (root.right != null && root.right.start <= start) {\\n                updateValue(root.right, start, end, value);\\n            } else {\\n                updateValue(root.left, start, root.left.end, value);\\n                updateValue(root.right, root.right.start, end, value);\\n            }\\n        }\\n\\n        public int getWidth() {\\n            return getWidth(this.root);\\n        }\\n\\n        private int getWidth(SegmentTreeNode root) {\\n            if (root == null) return 0;\\n            if (root.value > 0) return root.end - root.start;\\n            int left = getWidth(root.left);\\n            int right = getWidth(root.right);\\n            return left + right;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 781190,
                "title": "java-sweep-line",
                "content": "```\\nclass Solution {\\n    public boolean isRectangleCover(int[][] rectangles) {\\n        PriorityQueue<Event> pq = new PriorityQueue<Event> (new Comparator<Event>(){\\n            public int compare(Event a, Event b) {\\n                if (a.time != b.time) { // x\\u5750\\u6807\\u4E0D\\u4E00\\u6837\\uFF0C\\u5C0F\\u7684\\u5728\\u524D\\n                    return a.time - b.time;\\n                }else { // \\u5982\\u679Cx\\u5750\\u6807\\u4E00\\u6837\\uFF0C\\u5148\\u51FA\\u73B0\\u7684 rec \\u5728\\u524D\\n                    return a.rect[0] - b.rect[0]; \\n                }\\n            }\\n        });\\n        // border of y-intervals\\n        int[] border= {Integer.MAX_VALUE, Integer.MIN_VALUE};\\n        for (int[] rect : rectangles) {\\n            Event e1 = new Event(rect[0], rect);\\n            Event e2 = new Event(rect[2], rect);\\n            pq.add(e1);\\n            pq.add(e2);\\n            // \\u5BFB\\u627E y \\u7684 range\\n            if (rect[1] < border[0]) border[0] = rect[1];\\n            if (rect[3] > border[1]) border[1] = rect[3];\\n        }\\n        TreeSet<int[]> set = new TreeSet<int[]> (new Comparator<int[]> () {\\n            @Override        \\n            public int compare (int[] rect1, int[] rect2) {\\n                if (rect1[3] <= rect2[1]) return -1; // rec1\\u5728rec2 \\u4E0B\\u9762\\n                else if (rect2[3] <= rect1[1]) return 1; // rec2 \\u5728rec1 \\u4E0B\\u9762\\n                else return 0; // if two y-intervals intersects, return 0\\n            }\\n        });\\n        int yRange = 0;\\n        while (!pq.isEmpty()) {\\n            int time = pq.peek().time;\\n            while (!pq.isEmpty() && pq.peek().time == time) {\\n                Event e = pq.poll();\\n                int[] rect = e.rect;\\n                if (time == rect[2]) { // \\u4E00\\u4E2A\\u6B63\\u65B9\\u5F62\\u7684\\u7ED3\\u675F\\n                    set.remove(rect);\\n                    yRange -= rect[3] - rect[1];\\n                } else {                // \\u4E00\\u4E2A\\u6B63\\u65B9\\u5F62\\u7684\\u5F00\\u59CB\\n                    if (!set.add(rect)) return false; // \\u5982\\u679C\\u6709\\u91CD\\u53E0\\uFF0C\\u8FD4\\u56DEfalse\\n                    yRange += rect[3] - rect[1];\\n                }\\n            }\\n            if (!pq.isEmpty()){ // \\u8FD8\\u4E0D\\u662F\\u6700\\u540E\\u4E00\\u4E2A\\u70B9\\n                if (yRange != border[1] - border[0]){\\n                    return false;\\n                }\\n            } else{ // \\u662F\\u6700\\u540E\\u4E00\\u4E2A\\u70B9\\n                if (yRange!=0){\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n    static class Event  {\\n\\t    int time;\\n\\t    int[] rect;\\n\\n        public Event(int time, int[] rect) {\\n            this.time = time;\\n            this.rect = rect;\\n        }\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isRectangleCover(int[][] rectangles) {\\n        PriorityQueue<Event> pq = new PriorityQueue<Event> (new Comparator<Event>(){\\n            public int compare(Event a, Event b) {\\n                if (a.time != b.time) { // x\\u5750\\u6807\\u4E0D\\u4E00\\u6837\\uFF0C\\u5C0F\\u7684\\u5728\\u524D\\n                    return a.time - b.time;\\n                }else { // \\u5982\\u679Cx\\u5750\\u6807\\u4E00\\u6837\\uFF0C\\u5148\\u51FA\\u73B0\\u7684 rec \\u5728\\u524D\\n                    return a.rect[0] - b.rect[0]; \\n                }\\n            }\\n        });\\n        // border of y-intervals\\n        int[] border= {Integer.MAX_VALUE, Integer.MIN_VALUE};\\n        for (int[] rect : rectangles) {\\n            Event e1 = new Event(rect[0], rect);\\n            Event e2 = new Event(rect[2], rect);\\n            pq.add(e1);\\n            pq.add(e2);\\n            // \\u5BFB\\u627E y \\u7684 range\\n            if (rect[1] < border[0]) border[0] = rect[1];\\n            if (rect[3] > border[1]) border[1] = rect[3];\\n        }\\n        TreeSet<int[]> set = new TreeSet<int[]> (new Comparator<int[]> () {\\n            @Override        \\n            public int compare (int[] rect1, int[] rect2) {\\n                if (rect1[3] <= rect2[1]) return -1; // rec1\\u5728rec2 \\u4E0B\\u9762\\n                else if (rect2[3] <= rect1[1]) return 1; // rec2 \\u5728rec1 \\u4E0B\\u9762\\n                else return 0; // if two y-intervals intersects, return 0\\n            }\\n        });\\n        int yRange = 0;\\n        while (!pq.isEmpty()) {\\n            int time = pq.peek().time;\\n            while (!pq.isEmpty() && pq.peek().time == time) {\\n                Event e = pq.poll();\\n                int[] rect = e.rect;\\n                if (time == rect[2]) { // \\u4E00\\u4E2A\\u6B63\\u65B9\\u5F62\\u7684\\u7ED3\\u675F\\n                    set.remove(rect);\\n                    yRange -= rect[3] - rect[1];\\n                } else {                // \\u4E00\\u4E2A\\u6B63\\u65B9\\u5F62\\u7684\\u5F00\\u59CB\\n                    if (!set.add(rect)) return false; // \\u5982\\u679C\\u6709\\u91CD\\u53E0\\uFF0C\\u8FD4\\u56DEfalse\\n                    yRange += rect[3] - rect[1];\\n                }\\n            }\\n            if (!pq.isEmpty()){ // \\u8FD8\\u4E0D\\u662F\\u6700\\u540E\\u4E00\\u4E2A\\u70B9\\n                if (yRange != border[1] - border[0]){\\n                    return false;\\n                }\\n            } else{ // \\u662F\\u6700\\u540E\\u4E00\\u4E2A\\u70B9\\n                if (yRange!=0){\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n    static class Event  {\\n\\t    int time;\\n\\t    int[] rect;\\n\\n        public Event(int time, int[] rect) {\\n            this.time = time;\\n            this.rect = rect;\\n        }\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 491251,
                "title": "simple-java-solution",
                "content": "```\\npublic boolean isRectangleCover(int[][] rectangles) {\\n        int x1=Integer.MAX_VALUE;\\n        int y1=Integer.MAX_VALUE;\\n        int x2=Integer.MIN_VALUE;\\n        int y2=Integer.MIN_VALUE;\\n        int totalArea=0;\\n        Set<String> set = new HashSet<String>();\\n        for(int[] rectangle:rectangles){\\n            x1 = Math.min(rectangle[0], x1);\\n            y1 = Math.min(rectangle[1], y1);\\n            x2 = Math.max(rectangle[2], x2);\\n            y2 = Math.max(rectangle[3], y2);\\n            totalArea += (rectangle[2]-rectangle[0])*(rectangle[3]-rectangle[1]);\\n            String oneCorner = rectangle[0] +\" \"+ rectangle[1];\\n            String twoCorner = rectangle[0] +\" \"+ rectangle[3];\\n            String threeCorner = rectangle[2] +\" \"+ rectangle[1];\\n            String fourCorner = rectangle[2] +\" \"+ rectangle[3];\\n            if(!set.add(oneCorner)) set.remove(oneCorner);\\n            if(!set.add(twoCorner)) set.remove(twoCorner);\\n            if(!set.add(threeCorner)) set.remove(threeCorner);\\n            if(!set.add(fourCorner)) set.remove(fourCorner);\\n        }\\n        System.out.println(set.contains(x2 +\" \"+ y1));\\n         System.out.println(set.contains(x1 +\" \"+ y1));\\n         System.out.println(set.contains(x2 +\" \"+ y2));\\n         System.out.println(set.contains(x1 +\" \"+ y2));\\n         System.out.println(((y2-y1)));\\n    \\n        if(set.contains(x1 +\" \"+ y1) && \\n           set.contains(x1 +\" \"+ y2) && \\n           set.contains(x2 +\" \"+ y1) && \\n           set.contains(x2 +\" \"+ y2) && \\n           set.size()==4 && totalArea == (x2-x1)*(y2-y1)) {\\n            return true;\\n        }\\n        \\n        return false;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic boolean isRectangleCover(int[][] rectangles) {\\n        int x1=Integer.MAX_VALUE;\\n        int y1=Integer.MAX_VALUE;\\n        int x2=Integer.MIN_VALUE;\\n        int y2=Integer.MIN_VALUE;\\n        int totalArea=0;\\n        Set<String> set = new HashSet<String>();\\n        for(int[] rectangle:rectangles){\\n            x1 = Math.min(rectangle[0], x1);\\n            y1 = Math.min(rectangle[1], y1);\\n            x2 = Math.max(rectangle[2], x2);\\n            y2 = Math.max(rectangle[3], y2);\\n            totalArea += (rectangle[2]-rectangle[0])*(rectangle[3]-rectangle[1]);\\n            String oneCorner = rectangle[0] +\" \"+ rectangle[1];\\n            String twoCorner = rectangle[0] +\" \"+ rectangle[3];\\n            String threeCorner = rectangle[2] +\" \"+ rectangle[1];\\n            String fourCorner = rectangle[2] +\" \"+ rectangle[3];\\n            if(!set.add(oneCorner)) set.remove(oneCorner);\\n            if(!set.add(twoCorner)) set.remove(twoCorner);\\n            if(!set.add(threeCorner)) set.remove(threeCorner);\\n            if(!set.add(fourCorner)) set.remove(fourCorner);\\n        }\\n        System.out.println(set.contains(x2 +\" \"+ y1));\\n         System.out.println(set.contains(x1 +\" \"+ y1));\\n         System.out.println(set.contains(x2 +\" \"+ y2));\\n         System.out.println(set.contains(x1 +\" \"+ y2));\\n         System.out.println(((y2-y1)));\\n    \\n        if(set.contains(x1 +\" \"+ y1) && \\n           set.contains(x1 +\" \"+ y2) && \\n           set.contains(x2 +\" \"+ y1) && \\n           set.contains(x2 +\" \"+ y2) && \\n           set.size()==4 && totalArea == (x2-x1)*(y2-y1)) {\\n            return true;\\n        }\\n        \\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 314270,
                "title": "c-clear-o-n-solution-beats-96",
                "content": "```\\nstatic const auto ___ = [](){\\n    std::cout.sync_with_stdio(false);\\n    cin.tie(0);\\n    return 0;\\n}();\\nclass Solution {\\npublic:\\n    bool isRectangleCover(vector<vector<int>>& rectangles) {\\n        unordered_map <int,int> m1; \\n\\t\\t// store the count of appearance bottomleft/topright points\\n        unordered_map <int,int> m2;\\n\\t\\t// store the count of appearance bottomright/topleft points\\n        for(auto r:rectangles){\\n            put(m1,r[0],r[1]);\\n            put(m1,r[2],r[3]);\\n            put(m2,r[0],r[3]);\\n            put(m2,r[2],r[1]);\\n        }\\n        int count=0;\\n        for(auto i:m1){\\n\\t\\t\\t//only allow 2 pairs of unmatch: the corners of the entire rectangle \\n            if(m2.find(i.first)==m2.end()){\\n                if(i.second>1)\\n                    return false;\\n                count++;\\n                if(count>2)\\n                    return false;\\n            }\\n            else if(m2[i.first]!=i.second){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    inline void put(unordered_map<int,int> &mymap,int a1,int a2){\\n\\t//Notice the abs(rectangles[i][j]) is less than 20000, we can use a1*20000+a2 as the key.\\n        if(mymap.find(a1*20000+a2)!=mymap.end())\\n                mymap[a1*20000+a2]++;\\n        else mymap.insert(pair<double,int>(a1*20000+a2,1));\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nstatic const auto ___ = [](){\\n    std::cout.sync_with_stdio(false);\\n    cin.tie(0);\\n    return 0;\\n}();\\nclass Solution {\\npublic:\\n    bool isRectangleCover(vector<vector<int>>& rectangles) {\\n        unordered_map <int,int> m1; \\n\\t\\t// store the count of appearance bottomleft/topright points\\n        unordered_map <int,int> m2;\\n\\t\\t// store the count of appearance bottomright/topleft points\\n        for(auto r:rectangles){\\n            put(m1,r[0],r[1]);\\n            put(m1,r[2],r[3]);\\n            put(m2,r[0],r[3]);\\n            put(m2,r[2],r[1]);\\n        }\\n        int count=0;\\n        for(auto i:m1){\\n\\t\\t\\t//only allow 2 pairs of unmatch: the corners of the entire rectangle \\n            if(m2.find(i.first)==m2.end()){\\n                if(i.second>1)\\n                    return false;\\n                count++;\\n                if(count>2)\\n                    return false;\\n            }\\n            else if(m2[i.first]!=i.second){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    inline void put(unordered_map<int,int> &mymap,int a1,int a2){\\n\\t//Notice the abs(rectangles[i][j]) is less than 20000, we can use a1*20000+a2 as the key.\\n        if(mymap.find(a1*20000+a2)!=mymap.end())\\n                mymap[a1*20000+a2]++;\\n        else mymap.insert(pair<double,int>(a1*20000+a2,1));\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 87211,
                "title": "javascript-beats-90-o-n-time-o-n-space",
                "content": "Adapted and simplified from [Might be the simplest O(n) solution, only count corners,no area, no maxmin(with comments)](https://discuss.leetcode.com/topic/66413/might-be-the-simplest-o-n-solution-only-count-corners-no-area-no-maxmin-with-comments).\\n\\nWe keep four sets that collectively act like a difference set -- one for each type (direction) of corner.\\n\\nFor every corner that we consider, we check to see if another corner has the same coordinates.\\n\\nIf a same-position corner of the same type exists, there is an overlap, and we produce an error.\\nIf a same-position corner that shares exactly one face exists, we can delete the corner (rectangle merge).\\nIf a same-position corner shares the coordinates but neither face, we can add our corner, increasing the number of corners required to clear those coordinates to 2.\\n\\nIf no corner is in the same position, we add the corner.\\n\\nAfter all corners have been considered, we have a rectangle cover if each set contains exactly one corner.\\n\\n```js\\nlet corner = (x, y) => `${ x } ${ y }`\\n\\nlet isRectangleCover = rectangles => {\\n    let tls = new Set\\n    let trs = new Set\\n    let bls = new Set\\n    let brs = new Set\\n    \\n    for (let [l, b, r, t] of rectangles) {\\n        let tl = corner(t, l)\\n        let tr = corner(t, r)\\n        let bl = corner(b, l)\\n        let br = corner(b, r)\\n        \\n        if (tls.has(tl) || trs.has(tr) || bls.has(bl) || brs.has(br)) return false\\n        \\n        if (!bls.delete(tl) && !trs.delete(tl)) tls.add(tl)\\n        if (!brs.delete(tr) && !tls.delete(tr)) trs.add(tr)\\n        if (!brs.delete(bl) && !tls.delete(bl)) bls.add(bl)\\n        if (!bls.delete(br) && !trs.delete(br)) brs.add(br)\\n    }\\n    \\n    return tls.size === 1 && trs.size === 1 && bls.size === 1 && brs.size === 1\\n};\\n```",
                "solutionTags": [],
                "code": "```js\\nlet corner = (x, y) => `${ x } ${ y }`\\n\\nlet isRectangleCover = rectangles => {\\n    let tls = new Set\\n    let trs = new Set\\n    let bls = new Set\\n    let brs = new Set\\n    \\n    for (let [l, b, r, t] of rectangles) {\\n        let tl = corner(t, l)\\n        let tr = corner(t, r)\\n        let bl = corner(b, l)\\n        let br = corner(b, r)\\n        \\n        if (tls.has(tl) || trs.has(tr) || bls.has(bl) || brs.has(br)) return false\\n        \\n        if (!bls.delete(tl) && !trs.delete(tl)) tls.add(tl)\\n        if (!brs.delete(tr) && !tls.delete(tr)) trs.add(tr)\\n        if (!brs.delete(bl) && !tls.delete(bl)) bls.add(bl)\\n        if (!bls.delete(br) && !trs.delete(br)) brs.add(br)\\n    }\\n    \\n    return tls.size === 1 && trs.size === 1 && bls.size === 1 && brs.size === 1\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 87228,
                "title": "o-n-java-solution-with-213-ms-runtime",
                "content": "```\\npublic class Solution {\\n    class Point{\\n        int x;\\n        int y;\\n        int index;\\n        Point (int x, int y, int index){\\n            this.x =x;\\n            this.y = y;\\n            this.index = index;\\n        }\\n        \\n        @Override\\n        public boolean equals(Object o){\\n            if(o instanceof Point){\\n                Point b = (Point)o;\\n                return this.x == b.x && this.y == b.y;\\n            }\\n            return false;\\n        }\\n        \\n        @Override \\n        public int hashCode(){\\n            return (new Integer(x).hashCode() + new Integer(y).hashCode());\\n        }\\n    }\\n    public boolean isRectangleCover(int[][] rectangles) {\\n        if(rectangles.length <=1){\\n            return true;\\n        }\\n        \\n        int sum = 0;\\n        int minX = Integer.MAX_VALUE;\\n        int minY = Integer.MAX_VALUE;\\n        int maxX = Integer.MIN_VALUE;\\n        int maxY = Integer.MIN_VALUE;\\n        HashMap<Point,Integer> hm = new HashMap<>();\\n        for (int[] rect : rectangles){\\n            Point p1 = new Point(rect[0],rect[1],1);\\n            Point p2 = new Point(rect[2],rect[3],2);\\n            Point p3 = new Point(rect[0],rect[3],3);\\n            Point p4 = new Point(rect[2],rect[1],4);\\n            sum += (rect[2] - rect[0])*(rect[3]-rect[1]);\\n            \\n            minX = Math.min(minX,rect[0]);\\n            minY = Math.min(minY,rect[1]);\\n            \\n            maxX = Math.max(maxX,rect[2]);\\n            maxY = Math.max(maxY,rect[3]);\\n            \\n            Point[] points = {p1,p2,p3,p4};\\n            for(Point p : points){\\n                if(hm.containsKey(p) && hm.get(p) != p.index){\\n                    hm.remove(p);\\n                }\\n                else{\\n                    hm.put(p,p.index);\\n                }\\n            }\\n        }\\n        return (hm.size() ==4) && (sum == (maxX-minX)*(maxY-minY));\\n        \\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    class Point{\\n        int x;\\n        int y;\\n        int index;\\n        Point (int x, int y, int index){\\n            this.x =x;\\n            this.y = y;\\n            this.index = index;\\n        }\\n        \\n        @Override\\n        public boolean equals(Object o){\\n            if(o instanceof Point){\\n                Point b = (Point)o;\\n                return this.x == b.x && this.y == b.y;\\n            }\\n            return false;\\n        }\\n        \\n        @Override \\n        public int hashCode(){\\n            return (new Integer(x).hashCode() + new Integer(y).hashCode());\\n        }\\n    }\\n    public boolean isRectangleCover(int[][] rectangles) {\\n        if(rectangles.length <=1){\\n            return true;\\n        }\\n        \\n        int sum = 0;\\n        int minX = Integer.MAX_VALUE;\\n        int minY = Integer.MAX_VALUE;\\n        int maxX = Integer.MIN_VALUE;\\n        int maxY = Integer.MIN_VALUE;\\n        HashMap<Point,Integer> hm = new HashMap<>();\\n        for (int[] rect : rectangles){\\n            Point p1 = new Point(rect[0],rect[1],1);\\n            Point p2 = new Point(rect[2],rect[3],2);\\n            Point p3 = new Point(rect[0],rect[3],3);\\n            Point p4 = new Point(rect[2],rect[1],4);\\n            sum += (rect[2] - rect[0])*(rect[3]-rect[1]);\\n            \\n            minX = Math.min(minX,rect[0]);\\n            minY = Math.min(minY,rect[1]);\\n            \\n            maxX = Math.max(maxX,rect[2]);\\n            maxY = Math.max(maxY,rect[3]);\\n            \\n            Point[] points = {p1,p2,p3,p4};\\n            for(Point p : points){\\n                if(hm.containsKey(p) && hm.get(p) != p.index){\\n                    hm.remove(p);\\n                }\\n                else{\\n                    hm.put(p,p.index);\\n                }\\n            }\\n        }\\n        return (hm.size() ==4) && (sum == (maxX-minX)*(maxY-minY));\\n        \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 87239,
                "title": "c-o-n-solution",
                "content": "All sub rectangles should follow the conditions:\\n1. The sum of all rectangles area is equal to the perfect rectangle area.\\n2. There are 4 vertices of a rectangle. Each vertex can be classified into 3 cases, depending on its position.\\n    a. The vertex lies in the corner of the perfect rectangle.\\n    b. The vertex lies in the edge of the perfect rectangle.\\n    c. The vertex is inside the perfect rectangle.\\n\\nScan each vertex and find out which case it belongs to by function getVertexPos(int x, int y) , and store the vertex in the map and count it in function checkVertexinMap(int x, int y, VertexPos v). At last each vertex belongs to one or more subrectangles depending on its case.\\n\\nFor case a, each vertex belongs to only 1 sub rectangle.\\nFor case b, each vertex belongs to 2 rectangles.\\nFor case c, each vertex belongs to 2 or 4 rectangles.\\n\\n```\\nclass Solution {\\npublic:\\n    Solution(){\\n        vector<int> tmp(4,0);\\n        perfect_rect = tmp;\\n    }\\n    bool isRectangleCover(vector<vector<int>>& rectangles) {\\n        int minsum(INT_MAX),maxsum(INT_MIN);\\n        int subrectarea = 0;\\n        \\n        for(vector<int> rect : rectangles){\\n            subrectarea += area(rect);\\n            if(rect[0]+rect[1] < minsum){\\n                perfect_rect[0] = rect[0];\\n                perfect_rect[1] = rect[1];\\n                minsum = rect[0]+rect[1];\\n            }\\n            if(rect[2]+rect[3] > maxsum){\\n                perfect_rect[2] = rect[2];\\n                perfect_rect[3] = rect[3];\\n                maxsum = rect[2]+rect[3];\\n            }\\n        }\\n        if(subrectarea != area(perfect_rect))\\n            return false;\\n         \\n        for(vector<int> rect : rectangles){\\n            VertexPos E;\\n            E = getVertexPos(rect[0],rect[1]);\\n            if(!checkVertexinMap(rect[0],rect[1],E))\\n                return false;\\n            E = getVertexPos(rect[2],rect[1]);\\n            if(!checkVertexinMap(rect[2],rect[1],E))\\n                return false;\\n            E = getVertexPos(rect[0],rect[3]);\\n            if(!checkVertexinMap(rect[0],rect[3],E))\\n                return false;\\n            E = getVertexPos(rect[2],rect[3]);\\n            if(!checkVertexinMap(rect[2],rect[3],E))\\n                return false;\\n        }\\n        \\n        for(auto it=EdgeMap.begin(); it!=EdgeMap.end(); it++)\\n            if(it->second != 2)\\n                return false;\\n        \\n        for(auto it=InsideMap.begin(); it!=InsideMap.end(); it++)\\n            if(it->second != 2 && it->second != 4)\\n                return false;\\n\\n        return true;\\n    }\\n    \\nprivate:\\n    vector<int> perfect_rect;\\n    enum VertexPos{Corner,Edge,Inside};\\n    unordered_map<string,int> CornerMap; // all values should be 1\\n    unordered_map<string,int> EdgeMap;   // all values should be 2\\n    unordered_map<string,int> InsideMap; // all values should be 2 or 4\\n    \\n    \\n    bool checkVertexinMap(int x, int y, VertexPos v){\\n        string s = to_string(x) + \" \" + to_string(y);\\n        if(v == Corner){\\n            CornerMap[s]++;\\n            if(CornerMap[s]>1)\\n                return false;\\n        }\\n        else if(v == Edge){\\n            EdgeMap[s]++;\\n            if(EdgeMap[s]>2)\\n                return false;\\n        }\\n        else{\\n            InsideMap[s]++;\\n            if(InsideMap[s]>4)\\n                return false;\\n        }\\n        return true;\\n    }\\n    \\n    //get the vertex position\\n    VertexPos getVertexPos(int x, int y){\\n        int num = 0;\\n        if(x ==perfect_rect[0] || x == perfect_rect[2])\\n            num++;\\n        if(y == perfect_rect[1] || y == perfect_rect[3])\\n            num++;\\n        if(num==0)\\n            return Inside;\\n        else if(num==1)\\n            return Edge;\\n        return Corner;\\n    }\\n    \\n    int area(const vector<int>& rect){\\n        return (rect[2]-rect[0])*(rect[3]-rect[1]);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    Solution(){\\n        vector<int> tmp(4,0);\\n        perfect_rect = tmp;\\n    }\\n    bool isRectangleCover(vector<vector<int>>& rectangles) {\\n        int minsum(INT_MAX),maxsum(INT_MIN);\\n        int subrectarea = 0;\\n        \\n        for(vector<int> rect : rectangles){\\n            subrectarea += area(rect);\\n            if(rect[0]+rect[1] < minsum){\\n                perfect_rect[0] = rect[0];\\n                perfect_rect[1] = rect[1];\\n                minsum = rect[0]+rect[1];\\n            }\\n            if(rect[2]+rect[3] > maxsum){\\n                perfect_rect[2] = rect[2];\\n                perfect_rect[3] = rect[3];\\n                maxsum = rect[2]+rect[3];\\n            }\\n        }\\n        if(subrectarea != area(perfect_rect))\\n            return false;\\n         \\n        for(vector<int> rect : rectangles){\\n            VertexPos E;\\n            E = getVertexPos(rect[0],rect[1]);\\n            if(!checkVertexinMap(rect[0],rect[1],E))\\n                return false;\\n            E = getVertexPos(rect[2],rect[1]);\\n            if(!checkVertexinMap(rect[2],rect[1],E))\\n                return false;\\n            E = getVertexPos(rect[0],rect[3]);\\n            if(!checkVertexinMap(rect[0],rect[3],E))\\n                return false;\\n            E = getVertexPos(rect[2],rect[3]);\\n            if(!checkVertexinMap(rect[2],rect[3],E))\\n                return false;\\n        }\\n        \\n        for(auto it=EdgeMap.begin(); it!=EdgeMap.end(); it++)\\n            if(it->second != 2)\\n                return false;\\n        \\n        for(auto it=InsideMap.begin(); it!=InsideMap.end(); it++)\\n            if(it->second != 2 && it->second != 4)\\n                return false;\\n\\n        return true;\\n    }\\n    \\nprivate:\\n    vector<int> perfect_rect;\\n    enum VertexPos{Corner,Edge,Inside};\\n    unordered_map<string,int> CornerMap; // all values should be 1\\n    unordered_map<string,int> EdgeMap;   // all values should be 2\\n    unordered_map<string,int> InsideMap; // all values should be 2 or 4\\n    \\n    \\n    bool checkVertexinMap(int x, int y, VertexPos v){\\n        string s = to_string(x) + \" \" + to_string(y);\\n        if(v == Corner){\\n            CornerMap[s]++;\\n            if(CornerMap[s]>1)\\n                return false;\\n        }\\n        else if(v == Edge){\\n            EdgeMap[s]++;\\n            if(EdgeMap[s]>2)\\n                return false;\\n        }\\n        else{\\n            InsideMap[s]++;\\n            if(InsideMap[s]>4)\\n                return false;\\n        }\\n        return true;\\n    }\\n    \\n    //get the vertex position\\n    VertexPos getVertexPos(int x, int y){\\n        int num = 0;\\n        if(x ==perfect_rect[0] || x == perfect_rect[2])\\n            num++;\\n        if(y == perfect_rect[1] || y == perfect_rect[3])\\n            num++;\\n        if(num==0)\\n            return Inside;\\n        else if(num==1)\\n            return Edge;\\n        return Corner;\\n    }\\n    \\n    int area(const vector<int>& rect){\\n        return (rect[2]-rect[0])*(rect[3]-rect[1]);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 87236,
                "title": "python-solution-based-on-hxtang-s-idea",
                "content": "The basic idea is from: [hxtang's Solution](https://discuss.leetcode.com/topic/55923/o-n-solution-by-counting-corners-with-detailed-explaination)\\n\\n**Python Code:**\\n```\\nclass Solution(object):\\n    def isRectangleCover(self, rectangles):\\n        \"\"\"\\n        :type rectangles: List[List[int]]\\n        :rtype: bool\\n        \"\"\"\\n        left = min(x[0] for x in rectangles)\\n        bottom = min(x[1] for x in rectangles)\\n        right = max(x[2] for x in rectangles)\\n        top = max(x[3] for x in rectangles)\\n\\n        points = collections.defaultdict(int)\\n        for l, b, r, t in rectangles:\\n            A, B, C, D = (l, b), (r, b), (r, t), (l, t)\\n            for p, q in zip((A, B, C, D), (1, 2, 4, 8)):\\n                if points[p] & q: return False\\n                points[p] |= q\\n\\n        for px, py in points:\\n            if left < px < right or bottom < py < top:\\n                if points[(px, py)] not in (3, 6, 9, 12, 15):\\n                    return False\\n        return True\\n\\n```\\n\\nFurther explanations: http://bookshadow.com/weblog/2016/08/28/leetcode-perfect-rectangle/",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def isRectangleCover(self, rectangles):\\n        \"\"\"\\n        :type rectangles: List[List[int]]\\n        :rtype: bool\\n        \"\"\"\\n        left = min(x[0] for x in rectangles)\\n        bottom = min(x[1] for x in rectangles)\\n        right = max(x[2] for x in rectangles)\\n        top = max(x[3] for x in rectangles)\\n\\n        points = collections.defaultdict(int)\\n        for l, b, r, t in rectangles:\\n            A, B, C, D = (l, b), (r, b), (r, t), (l, t)\\n            for p, q in zip((A, B, C, D), (1, 2, 4, 8)):\\n                if points[p] & q: return False\\n                points[p] |= q\\n\\n        for px, py in points:\\n            if left < px < right or bottom < py < top:\\n                if points[(px, py)] not in (3, 6, 9, 12, 15):\\n                    return False\\n        return True\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3524958,
                "title": "java-solution-with-comments",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isRectangleCover(int[][] rectangles) {\\n        //base check\\n        if (rectangles.length == 0 || rectangles[0].length == 0) return false;\\n        Set<String> points = new HashSet<String>();\\n        int area = 0;\\n        //full rectangle coordinates\\n        int minX = Integer.MAX_VALUE;\\n        int minY = Integer.MAX_VALUE;\\n        int maxA = Integer.MIN_VALUE;\\n        int maxB = Integer.MIN_VALUE;\\n        //iterate all the rectangles\\n        for (int[] r : rectangles){\\n            //get the points, find area and add to previous area\\n            int x = r[0];\\n            int y = r[1];\\n            int a = r[2];\\n            int b = r[3];\\n            area += (x-a) * (y-b);\\n            //record min and max points each time\\n            minX = Math.min(minX, x);\\n            minY = Math.min(minY, y);\\n            maxA = Math.max(maxA, a);\\n            maxB = Math.max(maxB, b);\\n            //get the string to store in the set\\n            String bottomLeft = getHash(x,y);\\n            String topLeft = getHash(x,b);\\n            String bottomRight = getHash(a,y);\\n            String topRight = getHash(a,b);\\n            //remove all intermediate points if it exists\\n            //finally only 4 coordinates will be left behind to form the full rectangle\\n            checkInSet(points, bottomLeft);\\n            checkInSet(points, topLeft);\\n            checkInSet(points, bottomRight);\\n            checkInSet(points, topRight);\\n        }\\n        //get the string to read from the set\\n        String fullBottomLeft = getHash(minX,minY);\\n        String fullTopLeft = getHash(minX,maxB);\\n        String fullBottomRight = getHash(maxA,minY);\\n        String fullTopRight = getHash(maxA,maxB);\\n        //make sure the size is 4 and all the coordinate has exists in the set\\n        if (points.size() != 4 || !points.contains(fullBottomLeft) \\n            || !points.contains(fullTopLeft) || !points.contains(fullBottomRight) || !points.contains(fullTopRight)) return false;\\n        //compute the full rectangle area\\n        int fullArea = (minX-maxA) * (minY-maxB);\\n        // this should be equal\\n        return area == fullArea;\\n    }\\n\\t// method to check if the hash value exist in the set or not\\n    // if it exists then it means its a duplicate coordinate of previous rectangle added, so remove it\\n    // finally the set will contain only 4 corner coordinates\\n    private void checkInSet(Set<String> points, String hash){\\n        if (!points.contains(hash)) points.add(hash);\\n        else points.remove(hash);\\n    }\\n    //helper to return simple hash to store in the set\\n    private String getHash(int x, int y){\\n        return x + \":\" + y;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Line Sweep"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isRectangleCover(int[][] rectangles) {\\n        //base check\\n        if (rectangles.length == 0 || rectangles[0].length == 0) return false;\\n        Set<String> points = new HashSet<String>();\\n        int area = 0;\\n        //full rectangle coordinates\\n        int minX = Integer.MAX_VALUE;\\n        int minY = Integer.MAX_VALUE;\\n        int maxA = Integer.MIN_VALUE;\\n        int maxB = Integer.MIN_VALUE;\\n        //iterate all the rectangles\\n        for (int[] r : rectangles){\\n            //get the points, find area and add to previous area\\n            int x = r[0];\\n            int y = r[1];\\n            int a = r[2];\\n            int b = r[3];\\n            area += (x-a) * (y-b);\\n            //record min and max points each time\\n            minX = Math.min(minX, x);\\n            minY = Math.min(minY, y);\\n            maxA = Math.max(maxA, a);\\n            maxB = Math.max(maxB, b);\\n            //get the string to store in the set\\n            String bottomLeft = getHash(x,y);\\n            String topLeft = getHash(x,b);\\n            String bottomRight = getHash(a,y);\\n            String topRight = getHash(a,b);\\n            //remove all intermediate points if it exists\\n            //finally only 4 coordinates will be left behind to form the full rectangle\\n            checkInSet(points, bottomLeft);\\n            checkInSet(points, topLeft);\\n            checkInSet(points, bottomRight);\\n            checkInSet(points, topRight);\\n        }\\n        //get the string to read from the set\\n        String fullBottomLeft = getHash(minX,minY);\\n        String fullTopLeft = getHash(minX,maxB);\\n        String fullBottomRight = getHash(maxA,minY);\\n        String fullTopRight = getHash(maxA,maxB);\\n        //make sure the size is 4 and all the coordinate has exists in the set\\n        if (points.size() != 4 || !points.contains(fullBottomLeft) \\n            || !points.contains(fullTopLeft) || !points.contains(fullBottomRight) || !points.contains(fullTopRight)) return false;\\n        //compute the full rectangle area\\n        int fullArea = (minX-maxA) * (minY-maxB);\\n        // this should be equal\\n        return area == fullArea;\\n    }\\n\\t// method to check if the hash value exist in the set or not\\n    // if it exists then it means its a duplicate coordinate of previous rectangle added, so remove it\\n    // finally the set will contain only 4 corner coordinates\\n    private void checkInSet(Set<String> points, String hash){\\n        if (!points.contains(hash)) points.add(hash);\\n        else points.remove(hash);\\n    }\\n    //helper to return simple hash to store in the set\\n    private String getHash(int x, int y){\\n        return x + \":\" + y;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2666778,
                "title": "python-soluton",
                "content": "```\\nclass Solution:\\n    def isRectangleCover(self, rectangles: List[List[int]]) -> bool:\\n        xs=[]\\n        ys=[]\\n        \\n        for sx,sy,ex,ey in rectangles:\\n            xs.append(sx)\\n            xs.append(ex)\\n            \\n            ys.append(sy)\\n            ys.append(ey)\\n            \\n        xlookup={x:i for i,x in enumerate(sorted(set(xs)))}\\n        ylookup={y:i for i,y in enumerate(sorted(set(ys)))}\\n        \\n        N=len(xlookup)-1\\n        M=len(ylookup)-1\\n        grid=[[0]*M for _ in range(N)]\\n        \\n        for sx,sy,ex,ey in rectangles:\\n            for cx in range(xlookup[sx],xlookup[ex]):\\n                for cy in range(ylookup[sy],ylookup[ey]):\\n                    grid[cx][cy]+=1\\n                    \\n        for row in grid:\\n            for cell in row:\\n                if cell!=1:\\n                    return False\\n                \\n        return True",
                "solutionTags": [
                    "Python3"
                ],
                "code": "class Solution:\\n    def isRectangleCover(self, rectangles: List[List[int]]) -> bool:\\n        xs=[]\\n        ys=[]\\n        \\n        for sx,sy,ex,ey in rectangles:\\n            xs.append(sx)\\n            xs.append(ex)\\n            \\n            ys.append(sy)\\n            ys.append(ey)\\n            \\n        xlookup={x:i for i,x in enumerate(sorted(set(xs)))}",
                "codeTag": "Java"
            },
            {
                "id": 2290366,
                "title": "python",
                "content": "```\\nclass Solution:\\n    def isRectangleCover(self,rectangles: List[List[int]]) -> bool:\\n        X1, Y1 = float(\\'inf\\'), float(\\'inf\\')\\n        X2, Y2 = -float(\\'inf\\'), -float(\\'inf\\')\\n\\n        points = set()\\n        actual_area = 0\\n        for x1, y1, x2, y2 in rectangles:\\n            # find the vertex\\n            X1, Y1 = min(X1, x1), min(Y1, y1)\\n            X2, Y2 = max(X2, x2), max(Y2, y2)\\n            # adding the area of the rectangles\\n            actual_area += (x2 - x1) * (y2 - y1)\\n            # record the vertices\\n            p1, p2 = (x1, y1), (x1, y2)\\n            p3, p4 = (x2, y1), (x2, y2)\\n            for p in [p1, p2, p3, p4]:\\n                if p in points: points.remove(p)\\n                else:           points.add(p)\\n        # check if the area match the vertices\\n        expected_area = (X2 - X1) * (Y2 - Y1)\\n        if actual_area != expected_area:\\n            return False\\n        # check if the vertices left are 4 \\n        if len(points) != 4:       return False\\n        # False if the vertice is not in points\\n        if (X1, Y1) not in points: return False\\n        if (X1, Y2) not in points: return False\\n        if (X2, Y1) not in points: return False\\n        if (X2, Y2) not in points: return False\\n        # True ow \\n        return True",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isRectangleCover(self,rectangles: List[List[int]]) -> bool:\\n        X1, Y1 = float(\\'inf\\'), float(\\'inf\\')\\n        X2, Y2 = -float(\\'inf\\'), -float(\\'inf\\')\\n\\n        points = set()\\n        actual_area = 0\\n        for x1, y1, x2, y2 in rectangles:\\n            # find the vertex\\n            X1, Y1 = min(X1, x1), min(Y1, y1)\\n            X2, Y2 = max(X2, x2), max(Y2, y2)\\n            # adding the area of the rectangles\\n            actual_area += (x2 - x1) * (y2 - y1)\\n            # record the vertices\\n            p1, p2 = (x1, y1), (x1, y2)\\n            p3, p4 = (x2, y1), (x2, y2)\\n            for p in [p1, p2, p3, p4]:\\n                if p in points: points.remove(p)\\n                else:           points.add(p)\\n        # check if the area match the vertices\\n        expected_area = (X2 - X1) * (Y2 - Y1)\\n        if actual_area != expected_area:\\n            return False\\n        # check if the vertices left are 4 \\n        if len(points) != 4:       return False\\n        # False if the vertice is not in points\\n        if (X1, Y1) not in points: return False\\n        if (X1, Y2) not in points: return False\\n        if (X2, Y1) not in points: return False\\n        if (X2, Y2) not in points: return False\\n        # True ow \\n        return True",
                "codeTag": "Java"
            },
            {
                "id": 2283755,
                "title": "python-solution",
                "content": "```\\nclass Solution:\\n    def isRectangleCover(self, rectangles: List[List[int]]) -> bool:\\n        a1, b1 = float(\\'inf\\'), float(\\'inf\\')\\n        a2, b2 = float(\\'-inf\\'), float(\\'-inf\\')\\n        area = 0\\n        points = set()\\n        for x1, y1, x2, y2 in rectangles:\\n            area += (y2-y1) * (x2-x1)\\n            a1, b1 = min(a1, x1), min(b1, y1)\\n            a2, b2 = max(a2, x2), max(b2, y2)\\n            p1, p2, p3, p4 = (x1, y1), (x1, y2), (x2, y1), (x2, y2)\\n            for p in [p1, p2, p3, p4]:\\n                if p in points:\\n                    points.remove(p)\\n                else:\\n                    points.add(p)\\n                    \\n        if len(points) != 4:\\n            return False\\n        \\n        if (a1, b1) not in points or (a2, b2) not in points or (a1, b2) not in points or (a2, b1)not in points:\\n            return False\\n        \\n        if area != (b2-b1) * (a2-a1):\\n            return False\\n        \\n        \\n        \\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isRectangleCover(self, rectangles: List[List[int]]) -> bool:\\n        a1, b1 = float(\\'inf\\'), float(\\'inf\\')\\n        a2, b2 = float(\\'-inf\\'), float(\\'-inf\\')\\n        area = 0\\n        points = set()\\n        for x1, y1, x2, y2 in rectangles:\\n            area += (y2-y1) * (x2-x1)\\n            a1, b1 = min(a1, x1), min(b1, y1)\\n            a2, b2 = max(a2, x2), max(b2, y2)\\n            p1, p2, p3, p4 = (x1, y1), (x1, y2), (x2, y1), (x2, y2)\\n            for p in [p1, p2, p3, p4]:\\n                if p in points:\\n                    points.remove(p)\\n                else:\\n                    points.add(p)\\n                    \\n        if len(points) != 4:\\n            return False\\n        \\n        if (a1, b1) not in points or (a2, b2) not in points or (a1, b2) not in points or (a2, b1)not in points:\\n            return False\\n        \\n        if area != (b2-b1) * (a2-a1):\\n            return False\\n        \\n        \\n        \\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2257655,
                "title": "c-two-methods-segment-tree-count-corners",
                "content": "* Method 1: Segment Tree + Calculate total area\\n\\t* Time Complexity: O(nlogn)\\n\\t* Space Complexity: O(2e5)\\n```c++\\nclass Solution {\\n public:\\n  bool isRectangleCover(vector<vector<int>>& rectangles) {\\n    SegmentTree<STMax> st(2e5 + 1);\\n    sort(rectangles.begin(), rectangles.end(), [](auto& lhs, auto& rhs) -> bool {\\n      if (lhs[1] != rhs[1]) return lhs[1] < rhs[1];\\n      return lhs[0] < rhs[0];\\n    });\\n\\n    int min_x = rectangles[0][0];\\n    int min_y = rectangles[0][1];\\n    int max_a = rectangles[0][2];\\n    int max_b = rectangles[0][3];\\n    long long sum = 1ll * (max_a - min_x) * (max_b - min_y);\\n    st.update(min_x + 1e5 + 1, max_a + 1e5, max_b);\\n    for (int i = 1; i < rectangles.size(); ++i) {\\n      if (rectangles[i][0] < min_x) return false;\\n      int max_height = st.query(rectangles[i][0] + 1e5 + 1, rectangles[i][2] + 1e5);\\n      if (max_height > rectangles[i][1]) return false;\\n      max_a = max(max_a, rectangles[i][2]);\\n      max_b = max(max_b, rectangles[i][3]);\\n      sum += 1ll * (rectangles[i][2] - rectangles[i][0]) * (rectangles[i][3] - rectangles[i][1]);\\n      st.update(rectangles[i][0] + 1e5 + 1, rectangles[i][2] + 1e5, rectangles[i][3]);\\n    }\\n    return sum == 1ll * (max_a - min_x) * (max_b - min_y);\\n  }\\n};\\n```\\n\\n* Method 2: Count Corners\\n\\t* Time Complexity: O(n)\\n\\t* Space Complexity: O(n)\\n```c++\\ntemplate <class T1, class T2>\\nstruct hash<pair<T1, T2>> {\\n  size_t operator()(const pair<T1, T2>& t) const {\\n    auto hash1 = hash<T1>{}(t.first);\\n    auto hash2 = hash<T2>{}(t.second);\\n    return hash1 + 0x9e3779b9 + (hash2 << 6) + (hash2 >> 2);\\n  }\\n};\\n\\nclass Solution {\\n public:\\n  bool isRectangleCover(vector<vector<int>>& rectangles) {\\n    array<pair<int, int>, 4> corners;\\n    unordered_set<pair<pair<int, int>, int>> h;\\n    for (int i = 0; i < rectangles.size(); ++i) {\\n      corners = {{{rectangles[i][0], rectangles[i][1]},\\n                  {rectangles[i][2], rectangles[i][1]},\\n                  {rectangles[i][2], rectangles[i][3]},\\n                  {rectangles[i][0], rectangles[i][3]}}};\\n      for (int j = 0; j < 4; ++j) {\\n        if (h.count({corners[j], j})) return false;\\n        auto it = h.find({corners[j], (j + 1) % 4});\\n        it = it == h.end() ? h.find({corners[j], (j + 3) % 4}) : it;\\n        if (it != h.end())\\n          h.erase(it);\\n        else\\n          h.insert({corners[j], j});\\n      }\\n    }\\n    return h.size() == 4;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Tree"
                ],
                "code": "```c++\\nclass Solution {\\n public:\\n  bool isRectangleCover(vector<vector<int>>& rectangles) {\\n    SegmentTree<STMax> st(2e5 + 1);\\n    sort(rectangles.begin(), rectangles.end(), [](auto& lhs, auto& rhs) -> bool {\\n      if (lhs[1] != rhs[1]) return lhs[1] < rhs[1];\\n      return lhs[0] < rhs[0];\\n    });\\n\\n    int min_x = rectangles[0][0];\\n    int min_y = rectangles[0][1];\\n    int max_a = rectangles[0][2];\\n    int max_b = rectangles[0][3];\\n    long long sum = 1ll * (max_a - min_x) * (max_b - min_y);\\n    st.update(min_x + 1e5 + 1, max_a + 1e5, max_b);\\n    for (int i = 1; i < rectangles.size(); ++i) {\\n      if (rectangles[i][0] < min_x) return false;\\n      int max_height = st.query(rectangles[i][0] + 1e5 + 1, rectangles[i][2] + 1e5);\\n      if (max_height > rectangles[i][1]) return false;\\n      max_a = max(max_a, rectangles[i][2]);\\n      max_b = max(max_b, rectangles[i][3]);\\n      sum += 1ll * (rectangles[i][2] - rectangles[i][0]) * (rectangles[i][3] - rectangles[i][1]);\\n      st.update(rectangles[i][0] + 1e5 + 1, rectangles[i][2] + 1e5, rectangles[i][3]);\\n    }\\n    return sum == 1ll * (max_a - min_x) * (max_b - min_y);\\n  }\\n};\\n```\n```c++\\ntemplate <class T1, class T2>\\nstruct hash<pair<T1, T2>> {\\n  size_t operator()(const pair<T1, T2>& t) const {\\n    auto hash1 = hash<T1>{}(t.first);\\n    auto hash2 = hash<T2>{}(t.second);\\n    return hash1 + 0x9e3779b9 + (hash2 << 6) + (hash2 >> 2);\\n  }\\n};\\n\\nclass Solution {\\n public:\\n  bool isRectangleCover(vector<vector<int>>& rectangles) {\\n    array<pair<int, int>, 4> corners;\\n    unordered_set<pair<pair<int, int>, int>> h;\\n    for (int i = 0; i < rectangles.size(); ++i) {\\n      corners = {{{rectangles[i][0], rectangles[i][1]},\\n                  {rectangles[i][2], rectangles[i][1]},\\n                  {rectangles[i][2], rectangles[i][3]},\\n                  {rectangles[i][0], rectangles[i][3]}}};\\n      for (int j = 0; j < 4; ++j) {\\n        if (h.count({corners[j], j})) return false;\\n        auto it = h.find({corners[j], (j + 1) % 4});\\n        it = it == h.end() ? h.find({corners[j], (j + 3) % 4}) : it;\\n        if (it != h.end())\\n          h.erase(it);\\n        else\\n          h.insert({corners[j], j});\\n      }\\n    }\\n    return h.size() == 4;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1636446,
                "title": "simple-java-solution-using-area-and-edges-count",
                "content": "class Solution {\\n    public boolean isRectangleCover(int[][] rectangles) {\\n        \\n        Map<Integer, Map<Integer,Integer>> map = new HashMap<>();\\n        int minX, minY, maxX, maxY;\\n        long sumOfAreas = 0;\\n        Map<Integer,Integer> temp = null;\\n        minX = rectangles[0][0];minY = rectangles[0][1];\\n        maxX = rectangles[0][2];maxY = rectangles[0][3];\\n        for(int i=0;i< rectangles.length;i++){\\n            minX = Math.min(minX, rectangles[i][0]);\\n            minY = Math.min(minY, rectangles[i][1]);\\n            maxX = Math.max(maxX, rectangles[i][2]);\\n            maxY = Math.max(maxY, rectangles[i][3]);\\n            sumOfAreas += Math.abs(rectangles[i][0]-rectangles[i][2])\\n                *Math.abs(rectangles[i][1]-rectangles[i][3]);\\n            int x1 = rectangles[i][0];\\n            int y1 = rectangles[i][1];\\n            int a1 = rectangles[i][2];\\n            int b1 = rectangles[i][3];\\n            \\n            temp = map.getOrDefault(x1, new HashMap<Integer,Integer>());\\n            temp.put(y1, temp.getOrDefault(y1,0)+1);\\n            temp.put(b1, temp.getOrDefault(b1,0)+1);\\n            map.put(x1, temp);\\n            \\n            temp = map.getOrDefault(a1, new HashMap<Integer,Integer>());\\n            temp.put(y1, temp.getOrDefault(y1,0)+1);\\n            temp.put(b1, temp.getOrDefault(b1,0)+1);\\n            map.put(a1, temp);\\n            \\n        }\\n        \\n        if(!(map.get(minX)!=null && map.get(minX).get(maxY) != null && map.get(minX).get(maxY)==1)){\\n           // System.out.println(\"1\");\\n            return false;\\n        }\\n        \\n        if(!(map.get(maxX)!=null && map.get(maxX).get(minY) != null\\n             && map.get(maxX).get(minY)==1)){\\n          //  System.out.println(\"2\");\\n            return false;\\n        }\\n        \\n        for (Map.Entry<Integer, Map<Integer,Integer>> entry : map.entrySet()){\\n            for (Map.Entry<Integer,Integer> entry1 : entry.getValue().entrySet()){\\n                \\n                if(entry.getKey()==minX && entry1.getKey()==minY) continue;\\n                if(entry.getKey()==minX && entry1.getKey()==maxY) continue;\\n                if(entry.getKey()==maxX && entry1.getKey()==minY) continue;\\n                if(entry.getKey()==maxX && entry1.getKey()==maxY) continue;\\n                      \\n                if(!(entry1.getValue()==2 || entry1.getValue()==4)){\\n                    System.out.println(entry.getKey()+ \" \"+entry1.getKey()+\" \"+entry1.getValue());\\n                    return false;\\n                }\\n            }\\n        }\\n        \\n        long totalArea = Math.abs(maxY-minY)*Math.abs(maxX-minX);\\n        System.out.println(totalArea+ \" \"+ sumOfAreas);\\n        return sumOfAreas == totalArea;\\n\\n    }\\n}\\n\\n",
                "solutionTags": [],
                "code": "class Solution {\\n    public boolean isRectangleCover(int[][] rectangles) {\\n        \\n        Map<Integer, Map<Integer,Integer>> map = new HashMap<>();\\n        int minX, minY, maxX, maxY;\\n        long sumOfAreas = 0;\\n        Map<Integer,Integer> temp = null;\\n        minX = rectangles[0][0];minY = rectangles[0][1];\\n        maxX = rectangles[0][2];maxY = rectangles[0][3];\\n        for(int i=0;i< rectangles.length;i++){\\n            minX = Math.min(minX, rectangles[i][0]);\\n            minY = Math.min(minY, rectangles[i][1]);\\n            maxX = Math.max(maxX, rectangles[i][2]);\\n            maxY = Math.max(maxY, rectangles[i][3]);\\n            sumOfAreas += Math.abs(rectangles[i][0]-rectangles[i][2])\\n                *Math.abs(rectangles[i][1]-rectangles[i][3]);\\n            int x1 = rectangles[i][0];\\n            int y1 = rectangles[i][1];\\n            int a1 = rectangles[i][2];\\n            int b1 = rectangles[i][3];\\n            \\n            temp = map.getOrDefault(x1, new HashMap<Integer,Integer>());\\n            temp.put(y1, temp.getOrDefault(y1,0)+1);\\n            temp.put(b1, temp.getOrDefault(b1,0)+1);\\n            map.put(x1, temp);\\n            \\n            temp = map.getOrDefault(a1, new HashMap<Integer,Integer>());\\n            temp.put(y1, temp.getOrDefault(y1,0)+1);\\n            temp.put(b1, temp.getOrDefault(b1,0)+1);\\n            map.put(a1, temp);\\n            \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1620062,
                "title": "python-o-n-check-areas-then-check-point-counts",
                "content": "1. Area of targeted final rectangle has to be equal to sum of small recatngles areas.\\n2. Corner points have to appear only once.\\n3. Other points have to come in pairs.\\n```\\nclass Solution:\\n    def calculate_total_area(self, corners):        \\n        LB, LT, RB, RT = corners     \\n        return abs(LB[0]-RB[0]) * abs(LB[1]-LT[1])\\n        \\n    def calculate_all_rects_area(self, rects):\\n        return sum(abs(x-x2)*abs(y-y2) for x,y,x2,y2 in rects)\\n    \\n    def get_corner_points(self, rectangles):\\n        x = y = math.inf\\n        x2 = y2 = -math.inf            \\n        for dx, dy, dx2, dy2 in rectangles:\\n            x, y = min(x, dx, dx2), min(y, dy, dy2)             \\n            x2, y2 = max(x2, dx, dx2), max(y2, dy, dy2)                              \\n        return ((x, y), (x, y2), (x2, y), (x2, y2))\\n                                    \\n    def isRectangleCover(self, rectangles: List[List[int]]) -> bool:        \\n        corners = self.get_corner_points(rectangles)\\n        \\n        if self.calculate_total_area(corners) != self.calculate_all_rects_area(rectangles): \\n            return False\\n        \\n        point_count = defaultdict(int)\\n        \\n        for x,y, x2,y2 in rectangles:\\n            point_count[(x,y)] += 1\\n            point_count[(x2,y2)] += 1                                            \\n            point_count[(x,y2)] += 1\\n            point_count[(x2,y)] += 1  \\n                         \\n        for pair, v in point_count.items():\\n            if pair in corners:\\n                if v != 1:\\n                    return False\\n            else:\\n                if v % 2 == 1: \\n                    return False\\n        \\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def calculate_total_area(self, corners):        \\n        LB, LT, RB, RT = corners     \\n        return abs(LB[0]-RB[0]) * abs(LB[1]-LT[1])\\n        \\n    def calculate_all_rects_area(self, rects):\\n        return sum(abs(x-x2)*abs(y-y2) for x,y,x2,y2 in rects)\\n    \\n    def get_corner_points(self, rectangles):\\n        x = y = math.inf\\n        x2 = y2 = -math.inf            \\n        for dx, dy, dx2, dy2 in rectangles:\\n            x, y = min(x, dx, dx2), min(y, dy, dy2)             \\n            x2, y2 = max(x2, dx, dx2), max(y2, dy, dy2)                              \\n        return ((x, y), (x, y2), (x2, y), (x2, y2))\\n                                    \\n    def isRectangleCover(self, rectangles: List[List[int]]) -> bool:        \\n        corners = self.get_corner_points(rectangles)\\n        \\n        if self.calculate_total_area(corners) != self.calculate_all_rects_area(rectangles): \\n            return False\\n        \\n        point_count = defaultdict(int)\\n        \\n        for x,y, x2,y2 in rectangles:\\n            point_count[(x,y)] += 1\\n            point_count[(x2,y2)] += 1                                            \\n            point_count[(x,y2)] += 1\\n            point_count[(x2,y)] += 1  \\n                         \\n        for pair, v in point_count.items():\\n            if pair in corners:\\n                if v != 1:\\n                    return False\\n            else:\\n                if v % 2 == 1: \\n                    return False\\n        \\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1580967,
                "title": "c-sweep-line-odt-old-driver-tree-o-n-log-n",
                "content": "Use ODT to split a node or merge nodes to maintain the rightest value on each vertical segment.\\n\\n# How does classical ODT work?\\n\\ndefine segment structure: [left, right, val]\\n\\n## split(position)\\nto split the segment which contains the given position\\n```C++\\ntree = [0,10,val1], [10,20,val2]\\n\\nsplit(5)\\ntree = [0,5,val1], [5,10,val1], [10,20,val2]\\n\\nsplit(10)\\ntree = [0,5,val1], [5,10,val1], [10,20,val2]\\n// because 10 is currently a cutting boundary, it doesn\\'t do anything.\\n```\\n\\n## assign(l, r, val)\\nsplit tree by position `l` and `r`, and then remove the old segments from l to r. At the end, reassigns segment[l, r] = val\\n```C++\\ntree = [0,10,val1], [10,20,val2]\\n\\n\\nassign(5, 15, val3)\\n\\nstep1: split(5), split(15)\\ntree = [0,5,val1], [5,10,val1], [10,15,val2], [15,20,val2]\\n\\nstep2: remove segments from 5 to 15\\ntree = [0,5,val1], [15,20,val2]\\n\\nstep3: assign segment[5, 15] = val3\\ntree = [0,5,val1], [5,15,val3], [15,20,val2]\\n```\\n\\nFor convenience, we can check the val during removing old segments to make sure the new rectangles is close to the old rectangles.\\n\\n\\n# Code, C++\\n```C++\\nusing pii = pair<int, int>;\\n\\nclass ODT {\\npublic:\\n    map<int, pii> _tree;\\n    ODT(int l, int r, int val) {\\n        _tree.clear();\\n        _tree[l] = {r, val};\\n        _tree[r] = {r, val};\\n    }\\n    \\n    void split(int pos) {\\n        auto iter = _tree.lower_bound(pos);\\n        if (iter == _tree.end() || iter->first == pos) return;\\n        iter--;\\n        int l, r, val;\\n        l = iter->first;\\n        r = iter->second.first;\\n        val = iter->second.second;\\n        \\n        _tree.erase(iter);\\n        _tree[l] = {pos, val};\\n        _tree[pos] = {r, val};\\n    }\\n    \\n    bool assign(int l, int r, int minval, int maxval) {\\n        split(l);\\n        split(r);\\n        auto iter1 = _tree.lower_bound(l);\\n        auto iter2 = _tree.lower_bound(r);\\n\\n        int prel, prer, preval;\\n        while(iter1 != iter2) {\\n            if(minval != iter1->second.second) {\\n                return false;\\n            }\\n            iter1 = _tree.erase(iter1);\\n        }\\n        _tree[l] = {r, maxval};\\n        return true;\\n    }\\n};\\n\\n\\nclass Solution {\\npublic:\\n    bool isRectangleCover(vector<vector<int>>& rectangles) {\\n        int l = INT_MAX, r = INT_MIN, u = INT_MIN, d = INT_MAX;\\n        for(auto& vec : rectangles) {\\n            l = min(l, vec[0]);\\n            d = min(d, vec[1]);\\n            r = max(r, vec[2]);\\n            u = max(u, vec[3]);\\n        }\\n\\n        int x1, y1, x2, y2;\\n        ODT odt = ODT(d, u, l);\\n        \\n        sort(rectangles.begin(), rectangles.end());\\n        for(auto& vec : rectangles) {\\n            x1 = vec[0];\\n            y1 = vec[1];\\n            x2 = vec[2];\\n            y2 = vec[3];\\n            \\n            if(!odt.assign(y1, y2, x1, x2)) {\\n                return false;\\n            }\\n        }\\n\\n        return odt.assign(d, u, r, r);\\n    }\\n};\\n```\\n\\n# Reference\\n- 699. Falling Squares\\n- 218. The Skyline Problem",
                "solutionTags": [],
                "code": "```C++\\ntree = [0,10,val1], [10,20,val2]\\n\\nsplit(5)\\ntree = [0,5,val1], [5,10,val1], [10,20,val2]\\n\\nsplit(10)\\ntree = [0,5,val1], [5,10,val1], [10,20,val2]\\n// because 10 is currently a cutting boundary, it doesn\\'t do anything.\\n```\n```C++\\ntree = [0,10,val1], [10,20,val2]\\n\\n\\nassign(5, 15, val3)\\n\\nstep1: split(5), split(15)\\ntree = [0,5,val1], [5,10,val1], [10,15,val2], [15,20,val2]\\n\\nstep2: remove segments from 5 to 15\\ntree = [0,5,val1], [15,20,val2]\\n\\nstep3: assign segment[5, 15] = val3\\ntree = [0,5,val1], [5,15,val3], [15,20,val2]\\n```\n```C++\\nusing pii = pair<int, int>;\\n\\nclass ODT {\\npublic:\\n    map<int, pii> _tree;\\n    ODT(int l, int r, int val) {\\n        _tree.clear();\\n        _tree[l] = {r, val};\\n        _tree[r] = {r, val};\\n    }\\n    \\n    void split(int pos) {\\n        auto iter = _tree.lower_bound(pos);\\n        if (iter == _tree.end() || iter->first == pos) return;\\n        iter--;\\n        int l, r, val;\\n        l = iter->first;\\n        r = iter->second.first;\\n        val = iter->second.second;\\n        \\n        _tree.erase(iter);\\n        _tree[l] = {pos, val};\\n        _tree[pos] = {r, val};\\n    }\\n    \\n    bool assign(int l, int r, int minval, int maxval) {\\n        split(l);\\n        split(r);\\n        auto iter1 = _tree.lower_bound(l);\\n        auto iter2 = _tree.lower_bound(r);\\n\\n        int prel, prer, preval;\\n        while(iter1 != iter2) {\\n            if(minval != iter1->second.second) {\\n                return false;\\n            }\\n            iter1 = _tree.erase(iter1);\\n        }\\n        _tree[l] = {r, maxval};\\n        return true;\\n    }\\n};\\n\\n\\nclass Solution {\\npublic:\\n    bool isRectangleCover(vector<vector<int>>& rectangles) {\\n        int l = INT_MAX, r = INT_MIN, u = INT_MIN, d = INT_MAX;\\n        for(auto& vec : rectangles) {\\n            l = min(l, vec[0]);\\n            d = min(d, vec[1]);\\n            r = max(r, vec[2]);\\n            u = max(u, vec[3]);\\n        }\\n\\n        int x1, y1, x2, y2;\\n        ODT odt = ODT(d, u, l);\\n        \\n        sort(rectangles.begin(), rectangles.end());\\n        for(auto& vec : rectangles) {\\n            x1 = vec[0];\\n            y1 = vec[1];\\n            x2 = vec[2];\\n            y2 = vec[3];\\n            \\n            if(!odt.assign(y1, y2, x1, x2)) {\\n                return false;\\n            }\\n        }\\n\\n        return odt.assign(d, u, r, r);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1562296,
                "title": "python-n-log-n-intersection-checking-for-all-horizontal-lines",
                "content": "If our rectangles do not have intersection, we can record which minimal rectangle can cover it (by finding min, max `x`, and `y` coordinates). If the area of such rectangle is equal to sum of areas of our rectangles we return True.\\n\\nHow to check for intersections in n * logn? Let\\'s record all `y` coordinates of our rectangles, and go through each such horizontal coordinate (line) one at a time form bottom to top. At each such coordinate we have rectangles that \"starts\" (we start intersecting them with the horizontal line) and those which \"ends\". We can record them as intervals in `x` coordinates of those rectangles. If at some point we get two intervals intersecting that will correspond to intersecting of rectangles at that horizontal line. Otherwise there is no intersection. Done.\\n\\n\\n```\\nfrom sortedcontainers import SortedList\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def isRectangleCover(self, rectangles):\\n        ys_start = defaultdict(list)\\n        ys_end = defaultdict(list)\\n        ys = set()\\n        INF = 10 ** 9\\n\\n        total_area = 0\\n        min_x, min_y, max_x, max_y = rectangles[0]\\n        for i, r in enumerate(rectangles):\\n            x1, y1, x2, y2 = r\\n            ys_start[y1].append(i)\\n            ys_end[y2].append(i)\\n            ys.add(y1)\\n            ys.add(y2)\\n\\n            total_area += (x2 - x1) * (y2 - y1)\\n            min_x = min(min_x, x1)\\n            max_x = max(max_x, x2)\\n            min_y = min(min_y, y1)\\n            max_y = max(max_y, y2)\\n\\n        ys = sorted(list(ys))\\n        intervals = SortedList()\\n        expected_area = (max_x - min_x) * (max_y - min_y)\\n        if expected_area != total_area:\\n            return False\\n\\n        def has_intersection(left, right):\\n            ind_left = intervals.bisect_left((left, -INF))\\n            ind_right = intervals.bisect_left((right, -INF))\\n\\n            return ind_left != ind_right or (ind_left != 0 and intervals[ind_left - 1][1] > left)\\n\\n        for y in ys:\\n            for end in ys_end[y]:\\n                x1, _, x2, __ = rectangles[end]\\n                intervals.remove((x1, x2))\\n            for start in ys_start[y]:\\n                x1, _, x2, __ = rectangles[start]\\n                if has_intersection(x1, x2):\\n                    return False\\n                intervals.add((x1, x2))\\n\\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\nfrom sortedcontainers import SortedList\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def isRectangleCover(self, rectangles):\\n        ys_start = defaultdict(list)\\n        ys_end = defaultdict(list)\\n        ys = set()\\n        INF = 10 ** 9\\n\\n        total_area = 0\\n        min_x, min_y, max_x, max_y = rectangles[0]\\n        for i, r in enumerate(rectangles):\\n            x1, y1, x2, y2 = r\\n            ys_start[y1].append(i)\\n            ys_end[y2].append(i)\\n            ys.add(y1)\\n            ys.add(y2)\\n\\n            total_area += (x2 - x1) * (y2 - y1)\\n            min_x = min(min_x, x1)\\n            max_x = max(max_x, x2)\\n            min_y = min(min_y, y1)\\n            max_y = max(max_y, y2)\\n\\n        ys = sorted(list(ys))\\n        intervals = SortedList()\\n        expected_area = (max_x - min_x) * (max_y - min_y)\\n        if expected_area != total_area:\\n            return False\\n\\n        def has_intersection(left, right):\\n            ind_left = intervals.bisect_left((left, -INF))\\n            ind_right = intervals.bisect_left((right, -INF))\\n\\n            return ind_left != ind_right or (ind_left != 0 and intervals[ind_left - 1][1] > left)\\n\\n        for y in ys:\\n            for end in ys_end[y]:\\n                x1, _, x2, __ = rectangles[end]\\n                intervals.remove((x1, x2))\\n            for start in ys_start[y]:\\n                x1, _, x2, __ = rectangles[start]\\n                if has_intersection(x1, x2):\\n                    return False\\n                intervals.add((x1, x2))\\n\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1461563,
                "title": "o-n-corner-based-bfs-solution",
                "content": "Observation: \\n\\n1. Corners of rectangle should be connected to corners of another rectangle(Exception: corner of the rectangular region)\\n2. There is no corner with same corrdination and same direction.\\n3. To avoid Overlap situation, connect the rectangle one by one.  If rectangle is overlapped by another rectangle, it will not be connected.\\n![image](https://assets.leetcode.com/users/images/57176880-383c-4d7b-bc63-7362fc2fd58e_1631547687.5097837.png)\\n\\n\\n```\\npublic class Solution {\\n    public class Point\\n    {\\n        public int y,x;\\n         public override bool Equals(Object p)\\n        {\\n        \\n             Point obj = (Point) p;\\n             \\n             if ( obj.y == y && obj.x == x )\\n                 return true;\\n           \\n             return false;\\n        }\\n\\n\\n  \\n        public override int GetHashCode()\\n        {\\n            \\n                return y*100000+ x;\\n           \\n        }\\n    }\\n    Dictionary<(Point,int),int> dict;\\n    Point wrt,wlb,wlt,wrb;\\n    public bool IsRectangleCover(int[][] rect) {\\n         \\n        dict = new Dictionary<(Point,int),int>();\\n        bool[] used= new bool[rect.Length];\\n        Point rt,lb,lt,rb;\\n        for ( int i=0; i< rect.Length; i++)\\n        {\\n            lb = new Point(){ x = rect[i][0], y = rect[i][1] };\\n            rt = new Point(){ x= rect[i][2], y= rect[i][3] };\\n            lt = new Point(){ x= rect[i][0], y= rect[i][3] };\\n            rb = new Point(){ x= rect[i][2], y= rect[i][1] };\\n             \\n            if ( wlb == null )\\n                wlb = new Point(){ x = lb.x, y =lb.y };\\n            else\\n            {\\n                if ( wlb.y > lb.y)\\n                {\\n                    wlb.y = lb.y;\\n                    wlb.x = lb.x;\\n                }else if ( wlb.y == lb.y)\\n                {\\n                    if ( wlb.x > lb.x )\\n                    {\\n                        wlb.x = lb.x;\\n                    }\\n                }\\n            }\\n            \\n            if ( wrt == null )\\n                 wrt = new Point(){ x = rt.x, y =rt.y }; \\n            else\\n            {\\n                \\n                if ( wrt.y < rt.y)\\n                {\\n                    wrt.y = rt.y;\\n                    wrt.x = rt.x;\\n                }else if ( wrt.y == rt.y)\\n                {\\n                    if ( wrt.x < rt.x )\\n                    {\\n                        wrt.x = rt.x;\\n                    }\\n                }\\n                \\n            }\\n            \\n            \\n            if (dict.ContainsKey((lb,0)))\\n                return false;\\n            if (dict.ContainsKey((lt,1)))\\n                return false;\\n            if (dict.ContainsKey((rt,2)))\\n                return false;\\n            if (dict.ContainsKey((rb,3)))\\n                return false;\\n            \\n            dict[(lb,0)] = i;\\n            dict[(lt,1)] = i;\\n            dict[(rt,2)] = i;\\n            dict[(rb,3)] = i;\\n            \\n            \\n        }\\n        \\n \\n        \\n        wlt = new Point(){ y= wrt.y, x = wlb.x};\\n        wrb = new Point(){ y = wlb.y, x=wrt.x };\\n        \\n        \\n        Queue<(Point,int)> queue = new Queue<(Point,int)>();\\n        \\n        queue.Enqueue( (wlb,0));\\n        \\n        int cnt,tmp;\\n        while ( queue.Count > 0 )\\n        {\\n            (Point,int) node = queue.Dequeue();\\n            //Console.Out.WriteLine(node.Item1.y + \" \" +node.Item1.x );\\n            int i = dict[node];\\n            used[i] = true;\\n            lb = new Point(){ x = rect[i][0], y = rect[i][1] };\\n            rt = new Point(){ x= rect[i][2], y= rect[i][3] };\\n            lt = new Point(){ x= rect[i][0], y= rect[i][3] };\\n            rb = new Point(){ x= rect[i][2], y= rect[i][1] };\\n            \\n            \\n            if (checkPointIsFailure(lb) || checkPointIsFailure(rt) || checkPointIsFailure(lt) || checkPointIsFailure(rb) )\\n                return false;\\n            \\n            if ( !rb.Equals(wrb))\\n            {\\n                cnt =0;\\n                if ( dict.ContainsKey((rb,0) ) )\\n                {\\n                    tmp = dict[(rb,0)];\\n                    if ( !used[tmp] )\\n                    {\\n                        used[tmp] = true;\\n                        queue.Enqueue((rb,0));\\n                    }\\n                    cnt++;\\n                }\\n                if ( dict.ContainsKey((rb,2) ) )\\n                {\\n                    tmp = dict[(rb,2)];\\n                    if ( !used[tmp] )\\n                    {\\n                        used[tmp] = true;\\n                        queue.Enqueue((rb,2));\\n                    }\\n                    cnt++;\\n                }\\n                if ( dict.ContainsKey((rb,1) ) )\\n                {\\n                    tmp = dict[(rb,1)];\\n                    if ( !used[tmp] )\\n                    {\\n                        used[tmp] = true;\\n                        queue.Enqueue((rb,1));\\n                    }\\n                    \\n                    if ( cnt != 2 )\\n                        return false;\\n                       cnt++;\\n             \\n                }\\n                if ( cnt == 2 || cnt == 0)\\n                    return false;\\n                 \\n            }\\n            if ( !rt.Equals(wrt))\\n            {\\n                cnt =0;\\n                if ( dict.ContainsKey((rt,1) ) )\\n                {\\n                    tmp = dict[(rt,1)];\\n                    if ( !used[tmp] )\\n                    {\\n                        used[tmp] = true;\\n                        queue.Enqueue((rt,1));\\n                    }\\n                    cnt++;\\n                }\\n                if ( dict.ContainsKey((rt,3) ) )\\n                {\\n                    tmp = dict[(rt,3)];\\n                    if ( !used[tmp] )\\n                    {\\n                        used[tmp] = true;\\n                        queue.Enqueue((rt,3));\\n                    }\\n                    cnt++;\\n                }\\n                if ( dict.ContainsKey((rt,0) ) )\\n                {\\n                    tmp = dict[(rt,0)];\\n                    if ( !used[tmp] )\\n                    {\\n                        used[tmp] = true;\\n                        queue.Enqueue((rt,0));\\n                    }\\n                    \\n                    if ( cnt != 2 )\\n                        return false;\\n                    \\n                       cnt++;\\n                }\\n                 if ( cnt == 2 || cnt == 0)\\n                    return false;\\n            }\\n            if ( !lb.Equals(wlb))\\n            {\\n                cnt =0;\\n                if ( dict.ContainsKey((lb,1) ) )\\n                {\\n                    tmp = dict[(lb,1)];\\n                    if ( !used[tmp] )\\n                    {\\n                        used[tmp] = true;\\n                        queue.Enqueue((lb,1));\\n                    }\\n                    cnt++;\\n                }\\n                if ( dict.ContainsKey((lb,3) ) )\\n                {\\n                    tmp = dict[(lb,3)];\\n                    if ( !used[tmp] )\\n                    {\\n                        used[tmp] = true;\\n                        queue.Enqueue((lb,3));\\n                    }\\n                    cnt++;\\n                }\\n                if ( dict.ContainsKey((lb,2) ) )\\n                {\\n                    tmp = dict[(lb,2)];\\n                    if ( !used[tmp] )\\n                    {\\n                        used[tmp] = true;\\n                        queue.Enqueue((lb,2));\\n                    }\\n                    \\n                    if ( cnt != 2 )\\n                        return false;\\n                    cnt++;\\n             \\n                }\\n                 if ( cnt == 2 || cnt == 0)\\n                    return false;\\n            }\\n            if ( !lt.Equals(wlt))\\n            {\\n                 cnt =0;\\n                if ( dict.ContainsKey((lt,0) ) )\\n                {\\n                    tmp = dict[(lt,0)];\\n                    if ( !used[tmp] )\\n                    {\\n                        used[tmp] = true;\\n                        queue.Enqueue((lt,0));\\n                    }\\n                    cnt++;\\n                }\\n                if ( dict.ContainsKey((lt,2) ) )\\n                {\\n                    tmp = dict[(lt,2)];\\n                    if ( !used[tmp] )\\n                    {\\n                        used[tmp] = true;\\n                        queue.Enqueue((lt,2));\\n                    }\\n                    cnt++;\\n                }\\n                if ( dict.ContainsKey((lt,3) ) )\\n                {\\n                    tmp = dict[(lt,3)];\\n                    if ( !used[tmp] )\\n                    {\\n                        used[tmp] = true;\\n                        queue.Enqueue((lt,3));\\n                    }\\n                    \\n                    if ( cnt != 2 )\\n                        return false;\\n                    cnt++;\\n             \\n                }\\n                 if ( cnt == 2 || cnt == 0)\\n                    return false;\\n            }\\n            \\n            \\n        }\\n        \\n        for ( int i=0; i<rect.Length; i++ )\\n        {\\n            if (!used[i])\\n                return false;\\n        }\\n        \\n        return true;\\n        \\n        \\n    }\\n    \\n    public bool checkPointIsFailure(Point p)\\n    {\\n        if ( p.x > wrb.x || p.x < wlb.x || p.y > wrt.y || p.y < wlb.y)\\n            return true;\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public class Point\\n    {\\n        public int y,x;\\n         public override bool Equals(Object p)\\n        {\\n        \\n             Point obj = (Point) p;\\n             \\n             if ( obj.y == y && obj.x == x )\\n                 return true;\\n           \\n             return false;\\n        }\\n\\n\\n  \\n        public override int GetHashCode()\\n        {\\n            \\n                return y*100000+ x;\\n           \\n        }\\n    }\\n    Dictionary<(Point,int),int> dict;\\n    Point wrt,wlb,wlt,wrb;\\n    public bool IsRectangleCover(int[][] rect) {\\n         \\n        dict = new Dictionary<(Point,int),int>();\\n        bool[] used= new bool[rect.Length];\\n        Point rt,lb,lt,rb;\\n        for ( int i=0; i< rect.Length; i++)\\n        {\\n            lb = new Point(){ x = rect[i][0], y = rect[i][1] };\\n            rt = new Point(){ x= rect[i][2], y= rect[i][3] };\\n            lt = new Point(){ x= rect[i][0], y= rect[i][3] };\\n            rb = new Point(){ x= rect[i][2], y= rect[i][1] };\\n             \\n            if ( wlb == null )\\n                wlb = new Point(){ x = lb.x, y =lb.y };\\n            else\\n            {\\n                if ( wlb.y > lb.y)\\n                {\\n                    wlb.y = lb.y;\\n                    wlb.x = lb.x;\\n                }else if ( wlb.y == lb.y)\\n                {\\n                    if ( wlb.x > lb.x )\\n                    {\\n                        wlb.x = lb.x;\\n                    }\\n                }\\n            }\\n            \\n            if ( wrt == null )\\n                 wrt = new Point(){ x = rt.x, y =rt.y }; \\n            else\\n            {\\n                \\n                if ( wrt.y < rt.y)\\n                {\\n                    wrt.y = rt.y;\\n                    wrt.x = rt.x;\\n                }else if ( wrt.y == rt.y)\\n                {\\n                    if ( wrt.x < rt.x )\\n                    {\\n                        wrt.x = rt.x;\\n                    }\\n                }\\n                \\n            }\\n            \\n            \\n            if (dict.ContainsKey((lb,0)))\\n                return false;\\n            if (dict.ContainsKey((lt,1)))\\n                return false;\\n            if (dict.ContainsKey((rt,2)))\\n                return false;\\n            if (dict.ContainsKey((rb,3)))\\n                return false;\\n            \\n            dict[(lb,0)] = i;\\n            dict[(lt,1)] = i;\\n            dict[(rt,2)] = i;\\n            dict[(rb,3)] = i;\\n            \\n            \\n        }\\n        \\n \\n        \\n        wlt = new Point(){ y= wrt.y, x = wlb.x};\\n        wrb = new Point(){ y = wlb.y, x=wrt.x };\\n        \\n        \\n        Queue<(Point,int)> queue = new Queue<(Point,int)>();\\n        \\n        queue.Enqueue( (wlb,0));\\n        \\n        int cnt,tmp;\\n        while ( queue.Count > 0 )\\n        {\\n            (Point,int) node = queue.Dequeue();\\n            //Console.Out.WriteLine(node.Item1.y + \" \" +node.Item1.x );\\n            int i = dict[node];\\n            used[i] = true;\\n            lb = new Point(){ x = rect[i][0], y = rect[i][1] };\\n            rt = new Point(){ x= rect[i][2], y= rect[i][3] };\\n            lt = new Point(){ x= rect[i][0], y= rect[i][3] };\\n            rb = new Point(){ x= rect[i][2], y= rect[i][1] };\\n            \\n            \\n            if (checkPointIsFailure(lb) || checkPointIsFailure(rt) || checkPointIsFailure(lt) || checkPointIsFailure(rb) )\\n                return false;\\n            \\n            if ( !rb.Equals(wrb))\\n            {\\n                cnt =0;\\n                if ( dict.ContainsKey((rb,0) ) )\\n                {\\n                    tmp = dict[(rb,0)];\\n                    if ( !used[tmp] )\\n                    {\\n                        used[tmp] = true;\\n                        queue.Enqueue((rb,0));\\n                    }\\n                    cnt++;\\n                }\\n                if ( dict.ContainsKey((rb,2) ) )\\n                {\\n                    tmp = dict[(rb,2)];\\n                    if ( !used[tmp] )\\n                    {\\n                        used[tmp] = true;\\n                        queue.Enqueue((rb,2));\\n                    }\\n                    cnt++;\\n                }\\n                if ( dict.ContainsKey((rb,1) ) )\\n                {\\n                    tmp = dict[(rb,1)];\\n                    if ( !used[tmp] )\\n                    {\\n                        used[tmp] = true;\\n                        queue.Enqueue((rb,1));\\n                    }\\n                    \\n                    if ( cnt != 2 )\\n                        return false;\\n                       cnt++;\\n             \\n                }\\n                if ( cnt == 2 || cnt == 0)\\n                    return false;\\n                 \\n            }\\n            if ( !rt.Equals(wrt))\\n            {\\n                cnt =0;\\n                if ( dict.ContainsKey((rt,1) ) )\\n                {\\n                    tmp = dict[(rt,1)];\\n                    if ( !used[tmp] )\\n                    {\\n                        used[tmp] = true;\\n                        queue.Enqueue((rt,1));\\n                    }\\n                    cnt++;\\n                }\\n                if ( dict.ContainsKey((rt,3) ) )\\n                {\\n                    tmp = dict[(rt,3)];\\n                    if ( !used[tmp] )\\n                    {\\n                        used[tmp] = true;\\n                        queue.Enqueue((rt,3));\\n                    }\\n                    cnt++;\\n                }\\n                if ( dict.ContainsKey((rt,0) ) )\\n                {\\n                    tmp = dict[(rt,0)];\\n                    if ( !used[tmp] )\\n                    {\\n                        used[tmp] = true;\\n                        queue.Enqueue((rt,0));\\n                    }\\n                    \\n                    if ( cnt != 2 )\\n                        return false;\\n                    \\n                       cnt++;\\n                }\\n                 if ( cnt == 2 || cnt == 0)\\n                    return false;\\n            }\\n            if ( !lb.Equals(wlb))\\n            {\\n                cnt =0;\\n                if ( dict.ContainsKey((lb,1) ) )\\n                {\\n                    tmp = dict[(lb,1)];\\n                    if ( !used[tmp] )\\n                    {\\n                        used[tmp] = true;\\n                        queue.Enqueue((lb,1));\\n                    }\\n                    cnt++;\\n                }\\n                if ( dict.ContainsKey((lb,3) ) )\\n                {\\n                    tmp = dict[(lb,3)];\\n                    if ( !used[tmp] )\\n                    {\\n                        used[tmp] = true;\\n                        queue.Enqueue((lb,3));\\n                    }\\n                    cnt++;\\n                }\\n                if ( dict.ContainsKey((lb,2) ) )\\n                {\\n                    tmp = dict[(lb,2)];\\n                    if ( !used[tmp] )\\n                    {\\n                        used[tmp] = true;\\n                        queue.Enqueue((lb,2));\\n                    }\\n                    \\n                    if ( cnt != 2 )\\n                        return false;\\n                    cnt++;\\n             \\n                }\\n                 if ( cnt == 2 || cnt == 0)\\n                    return false;\\n            }\\n            if ( !lt.Equals(wlt))\\n            {\\n                 cnt =0;\\n                if ( dict.ContainsKey((lt,0) ) )\\n                {\\n                    tmp = dict[(lt,0)];\\n                    if ( !used[tmp] )\\n                    {\\n                        used[tmp] = true;\\n                        queue.Enqueue((lt,0));\\n                    }\\n                    cnt++;\\n                }\\n                if ( dict.ContainsKey((lt,2) ) )\\n                {\\n                    tmp = dict[(lt,2)];\\n                    if ( !used[tmp] )\\n                    {\\n                        used[tmp] = true;\\n                        queue.Enqueue((lt,2));\\n                    }\\n                    cnt++;\\n                }\\n                if ( dict.ContainsKey((lt,3) ) )\\n                {\\n                    tmp = dict[(lt,3)];\\n                    if ( !used[tmp] )\\n                    {\\n                        used[tmp] = true;\\n                        queue.Enqueue((lt,3));\\n                    }\\n                    \\n                    if ( cnt != 2 )\\n                        return false;\\n                    cnt++;\\n             \\n                }\\n                 if ( cnt == 2 || cnt == 0)\\n                    return false;\\n            }\\n            \\n            \\n        }\\n        \\n        for ( int i=0; i<rect.Length; i++ )\\n        {\\n            if (!used[i])\\n                return false;\\n        }\\n        \\n        return true;\\n        \\n        \\n    }\\n    \\n    public bool checkPointIsFailure(Point p)\\n    {\\n        if ( p.x > wrb.x || p.x < wlb.x || p.y > wrt.y || p.y < wlb.y)\\n            return true;\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1439728,
                "title": "line-sweep-solution",
                "content": "First we sort all rectangles from bottom to top ,from left to right. First we sweep along x-axis, use an ordered array *rng* to store y-axis ranges with its end row(y1, y2, x2). Every iteration we meet a new x index *curr*, we first check whether rng can fill to *curr*. Then insort all ranges into *rng*. Finally, we need further check *rng* .\\n```\\nfrom bisect import insort\\n\\nclass Solution:\\n    def isRectangleCover(self, rectangles: List[List[int]]) -> bool:\\n        if len(rectangles) == 1: return True\\n        rectangles.sort()\\n        sx, sy, ex, ey = rectangles[0]\\n        for x1, y1, x2, y2 in rectangles:\\n            sx, sy = min(sx, x1), min(sy, y1)\\n            ex, ey = max(ex, x2), max(ey, y2)\\n        rng = []\\n        idx, lastr = 0, sx\\n        while idx < len(rectangles):\\n            curr = rectangles[idx][0]\\n            if curr > lastr:\\n                rmidx = []\\n                lastc = sy\\n                for i, (sc, rc, er) in enumerate(rng):\\n                    if sc != lastc or rc > ey or er < curr: return False\\n                    if er == curr: rmidx.append(i)\\n                    lastc = rc\\n                if lastc != ey: return False\\n                for r in rmidx[::-1]: rng.pop(r)\\n            while idx < len(rectangles) and rectangles[idx][0] == curr:\\n                insort(rng, (rectangles[idx][1], rectangles[idx][3], rectangles[idx][2]))\\n                idx += 1\\n            lastr = curr\\n        lastc = sy\\n        for i, (sc, rc, er) in enumerate(rng):\\n            if sc != lastc or rc > ey or er != ex: return False\\n            lastc = rc\\n        return lastc == ey\\n```",
                "solutionTags": [],
                "code": "```\\nfrom bisect import insort\\n\\nclass Solution:\\n    def isRectangleCover(self, rectangles: List[List[int]]) -> bool:\\n        if len(rectangles) == 1: return True\\n        rectangles.sort()\\n        sx, sy, ex, ey = rectangles[0]\\n        for x1, y1, x2, y2 in rectangles:\\n            sx, sy = min(sx, x1), min(sy, y1)\\n            ex, ey = max(ex, x2), max(ey, y2)\\n        rng = []\\n        idx, lastr = 0, sx\\n        while idx < len(rectangles):\\n            curr = rectangles[idx][0]\\n            if curr > lastr:\\n                rmidx = []\\n                lastc = sy\\n                for i, (sc, rc, er) in enumerate(rng):\\n                    if sc != lastc or rc > ey or er < curr: return False\\n                    if er == curr: rmidx.append(i)\\n                    lastc = rc\\n                if lastc != ey: return False\\n                for r in rmidx[::-1]: rng.pop(r)\\n            while idx < len(rectangles) and rectangles[idx][0] == curr:\\n                insort(rng, (rectangles[idx][1], rectangles[idx][3], rectangles[idx][2]))\\n                idx += 1\\n            lastr = curr\\n        lastc = sy\\n        for i, (sc, rc, er) in enumerate(rng):\\n            if sc != lastc or rc > ey or er != ex: return False\\n            lastc = rc\\n        return lastc == ey\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1090517,
                "title": "python-3",
                "content": "```\\ndef isRectangleCover(self, rectangles: List[List[int]]) -> bool:\\n        d = collections.defaultdict(int)\\n        lt, bt = float(\\'inf\\'), float(\\'inf\\')\\n        rt, tp = float(\\'-inf\\'), float(\\'-inf\\')\\n        tmp = list(map(lambda x: (x[0], x[1], x[2], x[3]), rectangles))\\n        if len(set(tmp)) != len(rectangles):\\n            return False\\n        s = 0\\n        for l, b, r, t in rectangles:\\n            s += (t - b) * (r - l)\\n            lt = min(lt, l)\\n            rt = max(rt, r)\\n            bt = min(bt, b)\\n            tp = max(tp, t)\\n            d[(l, b)] += 1\\n            d[(l, t)] += 1\\n            d[(r, b)] += 1\\n            d[(r, t)] += 1\\n        if s != (rt - lt) * (tp - bt):\\n            return False\\n        res = [x for x in d if d[x] == 1]\\n        if len(res) != 4 or set([(lt, bt), (lt, tp), (rt, bt), (rt, tp)]) != set(res):\\n            return False\\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\ndef isRectangleCover(self, rectangles: List[List[int]]) -> bool:\\n        d = collections.defaultdict(int)\\n        lt, bt = float(\\'inf\\'), float(\\'inf\\')\\n        rt, tp = float(\\'-inf\\'), float(\\'-inf\\')\\n        tmp = list(map(lambda x: (x[0], x[1], x[2], x[3]), rectangles))\\n        if len(set(tmp)) != len(rectangles):\\n            return False\\n        s = 0\\n        for l, b, r, t in rectangles:\\n            s += (t - b) * (r - l)\\n            lt = min(lt, l)\\n            rt = max(rt, r)\\n            bt = min(bt, b)\\n            tp = max(tp, t)\\n            d[(l, b)] += 1\\n            d[(l, t)] += 1\\n            d[(r, b)] += 1\\n            d[(r, t)] += 1\\n        if s != (rt - lt) * (tp - bt):\\n            return False\\n        res = [x for x in d if d[x] == 1]\\n        if len(res) != 4 or set([(lt, bt), (lt, tp), (rt, bt), (rt, tp)]) != set(res):\\n            return False\\n        return True\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 953946,
                "title": "evolve-from-intuition",
                "content": "The idea is simple. The following two conditions are suffient to garantee a perfect rectangle.\\n* Total area equals to cover area.\\n* None of the rectangles overlap.\\n1. Brute force O(n^2). Check every pair of rectangles to detect overlap.\\n```\\n\\tpublic boolean isRectangleCover(int[][] rectangles) {\\n        int llx = Integer.MAX_VALUE, lly = Integer.MAX_VALUE, urx = 0, ury=0, area = 0;\\n        for(int[] rectangle:rectangles) {\\n            llx = Math.min(llx, rectangle[0]);\\n            lly = Math.min(lly, rectangle[1]);\\n            urx = Math.max(urx, rectangle[2]);\\n            ury = Math.max(ury, rectangle[3]);\\n            area += compArea(rectangle[0], rectangle[1],rectangle[2],rectangle[3]);\\n        }\\n        if(area!=compArea(llx,lly,urx,ury))\\n            return false;\\n        int n = rectangles.length;\\n        for(int i=0;i<n;i++)\\n            for(int j=i+1;j<n;j++)\\n                if(isRectOvlp(rectangles[i],rectangles[j]))\\n                    return false;\\n        return true;\\n    }\\n    private int compArea(int llx, int lly, int urx, int ury) {\\n        return (urx-llx)*(ury-lly);\\n    }\\n    private boolean isRectOvlp(int[] rect1, int[] rect2) {\\n        return isSegmentOvlp(rect1[0],rect1[2],rect2[0],rect2[2]) && isSegmentOvlp(rect1[1],rect1[3],rect2[1],rect2[3]);\\n    }\\n    private boolean isSegmentOvlp(int s1, int e1, int s2, int e2) {\\n        return s2<e1 && s1<e2;        \\n    }\\n```\\n2. Sweep line O(nlogn)\\n```\\n\\tpublic boolean isRectangleCover(int[][] rectangles) {\\n        int llx = Integer.MAX_VALUE, lly = Integer.MAX_VALUE, urx = 0, ury=0, area = 0, n = rectangles.length;;\\n        int[][] vertEdges = new int[2*n][];\\n        for(int i=0;i<n;i++) {\\n            int[] rectangle = rectangles[i];\\n            llx = Math.min(llx, rectangle[0]);\\n            lly = Math.min(lly, rectangle[1]);\\n            urx = Math.max(urx, rectangle[2]);\\n            ury = Math.max(ury, rectangle[3]);\\n            area += compArea(rectangle[0], rectangle[1],rectangle[2],rectangle[3]);\\n            vertEdges[2*i]= new int[]{rectangle[0],1,rectangle[1],rectangle[3]}; //right edge before left edge\\n            vertEdges[2*i+1]= new int[]{rectangle[2],0,rectangle[1],rectangle[3]};\\n        }\\n        if(area!=compArea(llx,lly,urx,ury))\\n            return false;\\n        Arrays.sort(vertEdges, (a,b)->(a[0]==b[0]?a[1]-b[1]:a[0]-b[0]));\\n        Set<int[]> sweptVertEdges= new TreeSet<>((a,b)->{\\n            if(a[0]>=b[1]) return 1;\\n            if(a[1]<=b[0]) return -1;\\n            return 0;\\n        });\\n        for(int[] vertEdge:vertEdges) {\\n            int[] ySeg = {vertEdge[2],vertEdge[3]};\\n            if(vertEdge[1]==0) {\\n                sweptVertEdges.remove(ySeg);\\n                continue;\\n            }\\n            if(!sweptVertEdges.add(ySeg)) \\n                return false;\\n        }\\n        return true;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n\\tpublic boolean isRectangleCover(int[][] rectangles) {\\n        int llx = Integer.MAX_VALUE, lly = Integer.MAX_VALUE, urx = 0, ury=0, area = 0;\\n        for(int[] rectangle:rectangles) {\\n            llx = Math.min(llx, rectangle[0]);\\n            lly = Math.min(lly, rectangle[1]);\\n            urx = Math.max(urx, rectangle[2]);\\n            ury = Math.max(ury, rectangle[3]);\\n            area += compArea(rectangle[0], rectangle[1],rectangle[2],rectangle[3]);\\n        }\\n        if(area!=compArea(llx,lly,urx,ury))\\n            return false;\\n        int n = rectangles.length;\\n        for(int i=0;i<n;i++)\\n            for(int j=i+1;j<n;j++)\\n                if(isRectOvlp(rectangles[i],rectangles[j]))\\n                    return false;\\n        return true;\\n    }\\n    private int compArea(int llx, int lly, int urx, int ury) {\\n        return (urx-llx)*(ury-lly);\\n    }\\n    private boolean isRectOvlp(int[] rect1, int[] rect2) {\\n        return isSegmentOvlp(rect1[0],rect1[2],rect2[0],rect2[2]) && isSegmentOvlp(rect1[1],rect1[3],rect2[1],rect2[3]);\\n    }\\n    private boolean isSegmentOvlp(int s1, int e1, int s2, int e2) {\\n        return s2<e1 && s1<e2;        \\n    }\\n```\n```\\n\\tpublic boolean isRectangleCover(int[][] rectangles) {\\n        int llx = Integer.MAX_VALUE, lly = Integer.MAX_VALUE, urx = 0, ury=0, area = 0, n = rectangles.length;;\\n        int[][] vertEdges = new int[2*n][];\\n        for(int i=0;i<n;i++) {\\n            int[] rectangle = rectangles[i];\\n            llx = Math.min(llx, rectangle[0]);\\n            lly = Math.min(lly, rectangle[1]);\\n            urx = Math.max(urx, rectangle[2]);\\n            ury = Math.max(ury, rectangle[3]);\\n            area += compArea(rectangle[0], rectangle[1],rectangle[2],rectangle[3]);\\n            vertEdges[2*i]= new int[]{rectangle[0],1,rectangle[1],rectangle[3]}; //right edge before left edge\\n            vertEdges[2*i+1]= new int[]{rectangle[2],0,rectangle[1],rectangle[3]};\\n        }\\n        if(area!=compArea(llx,lly,urx,ury))\\n            return false;\\n        Arrays.sort(vertEdges, (a,b)->(a[0]==b[0]?a[1]-b[1]:a[0]-b[0]));\\n        Set<int[]> sweptVertEdges= new TreeSet<>((a,b)->{\\n            if(a[0]>=b[1]) return 1;\\n            if(a[1]<=b[0]) return -1;\\n            return 0;\\n        });\\n        for(int[] vertEdge:vertEdges) {\\n            int[] ySeg = {vertEdge[2],vertEdge[3]};\\n            if(vertEdge[1]==0) {\\n                sweptVertEdges.remove(ySeg);\\n                continue;\\n            }\\n            if(!sweptVertEdges.add(ySeg)) \\n                return false;\\n        }\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 867159,
                "title": "rust-16ms-2mb-time-o-n-space-o-n",
                "content": "```\\n\\nuse std::cmp::{max, min};\\nuse std::collections::HashSet;\\nuse std::i32::{MAX, MIN};\\nimpl Solution {\\n    // Time O(N) Space O(N)\\n    // reference https://www.youtube.com/watch?v=8JM_dyOu_JY\\n    pub fn is_rectangle_cover(rectangles: Vec<Vec<i32>>) -> bool {\\n      let mut corners = HashSet::new();\\n      let mut area = 0;\\n\\n      for rect in rectangles.iter() {\\n        let p1 = (rect[0], rect[1]);\\n        let p2 = (rect[2], rect[1]);\\n        let p3 = (rect[2], rect[3]);\\n        let p4 = (rect[0], rect[3]);\\n\\n        for p in vec![p1, p2, p3, p4] {\\n          if !corners.insert(p) {\\n            corners.remove(&p);\\n          }\\n        }\\n\\n        area += (p3.0 - p1.0) * (p3.1 - p1.1);\\n      }\\n\\n      if corners.len() != 4 {\\n        return false;\\n      }\\n\\n      let (mut x1, mut y1, mut x2, mut y2) = (MAX, MAX, MIN, MIN);\\n      for p in corners.iter(){\\n        x1 = min(p.0, x1);\\n        y1 = min(p.1, y1);\\n        \\n        x2 = max(p.0, x2);\\n        y2 = max(p.1, y2);\\n      }\\n\\n      area == (x2 - x1 ) * (y2 - y1)\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nuse std::cmp::{max, min};\\nuse std::collections::HashSet;\\nuse std::i32::{MAX, MIN};\\nimpl Solution {\\n    // Time O(N) Space O(N)\\n    // reference https://www.youtube.com/watch?v=8JM_dyOu_JY\\n    pub fn is_rectangle_cover(rectangles: Vec<Vec<i32>>) -> bool {\\n      let mut corners = HashSet::new();\\n      let mut area = 0;\\n\\n      for rect in rectangles.iter() {\\n        let p1 = (rect[0], rect[1]);\\n        let p2 = (rect[2], rect[1]);\\n        let p3 = (rect[2], rect[3]);\\n        let p4 = (rect[0], rect[3]);\\n\\n        for p in vec![p1, p2, p3, p4] {\\n          if !corners.insert(p) {\\n            corners.remove(&p);\\n          }\\n        }\\n\\n        area += (p3.0 - p1.0) * (p3.1 - p1.1);\\n      }\\n\\n      if corners.len() != 4 {\\n        return false;\\n      }\\n\\n      let (mut x1, mut y1, mut x2, mut y2) = (MAX, MAX, MIN, MIN);\\n      for p in corners.iter(){\\n        x1 = min(p.0, x1);\\n        y1 = min(p.1, y1);\\n        \\n        x2 = max(p.0, x2);\\n        y2 = max(p.1, y2);\\n      }\\n\\n      area == (x2 - x1 ) * (y2 - y1)\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 866727,
                "title": "golang-counting-corners-o-n-beats-100",
                "content": "```\\nfunc isRectangleCover(rects [][]int) bool {\\n    \\n    type pt struct { x, y int }\\n    \\n    var (\\n        left, right, top, bottom int\\n        area int    \\n        \\n        set = make(map[pt]int)\\n    )    \\n    \\n    for i, r := range rects {\\n        x, y, xx, yy := r[0], r[1], r[2], r[3]\\n        if i == 0 || x < left {\\n            left = x\\n        }\\n        if i == 0 || y < bottom {\\n            bottom = y\\n        }\\n        if i == 0 || xx > right {\\n            right = xx\\n        }\\n        if i == 0 || yy > top {\\n            top = yy\\n        }\\n        area += (xx-x)*(yy-y)\\n        \\n        set[pt{x,y}]++\\n        if set[pt{x,y}] == 2 {\\n            delete(set, pt{x,y})\\n        }\\n        set[pt{x,yy}]++\\n        if set[pt{x,yy}] == 2 {\\n            delete(set, pt{x,yy})\\n        }\\n        set[pt{xx,y}]++\\n        if set[pt{xx,y}] == 2 {\\n            delete(set,pt{xx,y})\\n        }\\n        set[pt{xx,yy}]++\\n        if set[pt{xx,yy}] == 2 {\\n            delete(set, pt{xx,yy})\\n        }\\n    }\\n    \\n    return len(set) == 4 &&\\n        set[pt{left, bottom}] == 1 &&\\n        set[pt{left, top}] == 1 &&\\n        set[pt{right, bottom}] == 1 &&\\n        set[pt{right, top}] == 1 &&\\n        area == (right-left)*(top-bottom)    \\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc isRectangleCover(rects [][]int) bool {\\n    \\n    type pt struct { x, y int }\\n    \\n    var (\\n        left, right, top, bottom int\\n        area int    \\n        \\n        set = make(map[pt]int)\\n    )    \\n    \\n    for i, r := range rects {\\n        x, y, xx, yy := r[0], r[1], r[2], r[3]\\n        if i == 0 || x < left {\\n            left = x\\n        }\\n        if i == 0 || y < bottom {\\n            bottom = y\\n        }\\n        if i == 0 || xx > right {\\n            right = xx\\n        }\\n        if i == 0 || yy > top {\\n            top = yy\\n        }\\n        area += (xx-x)*(yy-y)\\n        \\n        set[pt{x,y}]++\\n        if set[pt{x,y}] == 2 {\\n            delete(set, pt{x,y})\\n        }\\n        set[pt{x,yy}]++\\n        if set[pt{x,yy}] == 2 {\\n            delete(set, pt{x,yy})\\n        }\\n        set[pt{xx,y}]++\\n        if set[pt{xx,y}] == 2 {\\n            delete(set,pt{xx,y})\\n        }\\n        set[pt{xx,yy}]++\\n        if set[pt{xx,yy}] == 2 {\\n            delete(set, pt{xx,yy})\\n        }\\n    }\\n    \\n    return len(set) == 4 &&\\n        set[pt{left, bottom}] == 1 &&\\n        set[pt{left, top}] == 1 &&\\n        set[pt{right, bottom}] == 1 &&\\n        set[pt{right, top}] == 1 &&\\n        area == (right-left)*(top-bottom)    \\n    \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 841569,
                "title": "cpp-heap-beats-85-19-o-n",
                "content": "Runtime: 232 ms, faster than 85.19% of C++ online submissions for Perfect Rectangle.\\nMemory Usage: 27.2 MB, less than 97.53% of C++ online submissions for Perfect Rectangle.\\n\\n```cpp\\nstruct Rect {\\n  int l; // left\\n  int b; // bottom\\n  int r; // right\\n  int t; // top\\n  Rect(const vector<int> &vec) {\\n    l = vec[0];\\n    b = vec[1];\\n    r = vec[2];\\n    t = vec[3];\\n  }\\n  Rect(int _l, int _b, int _r, int _t) {\\n    l = _l;\\n    b = _b;\\n    r = _r;\\n    t = _t;\\n  }\\n};\\n\\nstruct Comp {\\n  bool operator()(const Rect &x, const Rect &y) {\\n    return x.l > y.l || (x.l == y.l && x.b > y.b)\\n        || (x.l == y.l && x.b == y.b && x.r > y.r)\\n        || (x.l == y.l && x.b == y.b && x.r == y.r && x.t > y.t);\\n  }\\n};\\n\\nclass Solution {\\npublic:\\n  bool isRectangleCover(vector<vector<int>> &rectangles) {\\n    priority_queue<Rect, vector<Rect>, Comp> pq;\\n    for (auto &vec : rectangles) pq.push(Rect(vec)); // minimum heap\\n    \\n    Rect *last = nullptr;\\n    while (!pq.empty()) {\\n      auto r1 = pq.top();\\n      pq.pop();\\n\\n      while (!pq.empty() && pq.top().b == r1.t) { // merge rectangles from bottom to top\\n        auto r2 = pq.top();\\n        pq.pop();\\n\\t\\t// merge 2 neighboring rectangles into one, and push the extra part back to heap\\n        if (r1.r < r2.r) { \\n          pq.push(Rect(r1.r, r2.b, r2.r, r2.t));\\n          r1.t = r2.t;\\n        } else if (r1.r > r2.r) {\\n          pq.push(Rect(r2.r, r1.b, r1.r, r2.b));\\n          r1.t = r2.t;\\n          r1.r = r2.r;\\n        } else {\\n          r1.t = r2.t;\\n        }\\n      }\\n\\n      // check rectangles from left to right\\n      if (!last) {\\n        last = new Rect(r1);\\n      } else {\\n        if (last->r != r1.l || last->b != r1.b || last->t != r1.t) { // check if overlaping, same top and same bottom\\n          delete last;\\n          return false;\\n        }\\n        *last = r1;\\n      }\\n    }\\n\\n    delete last;\\n    return true;\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nstruct Rect {\\n  int l; // left\\n  int b; // bottom\\n  int r; // right\\n  int t; // top\\n  Rect(const vector<int> &vec) {\\n    l = vec[0];\\n    b = vec[1];\\n    r = vec[2];\\n    t = vec[3];\\n  }\\n  Rect(int _l, int _b, int _r, int _t) {\\n    l = _l;\\n    b = _b;\\n    r = _r;\\n    t = _t;\\n  }\\n};\\n\\nstruct Comp {\\n  bool operator()(const Rect &x, const Rect &y) {\\n    return x.l > y.l || (x.l == y.l && x.b > y.b)\\n        || (x.l == y.l && x.b == y.b && x.r > y.r)\\n        || (x.l == y.l && x.b == y.b && x.r == y.r && x.t > y.t);\\n  }\\n};\\n\\nclass Solution {\\npublic:\\n  bool isRectangleCover(vector<vector<int>> &rectangles) {\\n    priority_queue<Rect, vector<Rect>, Comp> pq;\\n    for (auto &vec : rectangles) pq.push(Rect(vec)); // minimum heap\\n    \\n    Rect *last = nullptr;\\n    while (!pq.empty()) {\\n      auto r1 = pq.top();\\n      pq.pop();\\n\\n      while (!pq.empty() && pq.top().b == r1.t) { // merge rectangles from bottom to top\\n        auto r2 = pq.top();\\n        pq.pop();\\n\\t\\t// merge 2 neighboring rectangles into one, and push the extra part back to heap\\n        if (r1.r < r2.r) { \\n          pq.push(Rect(r1.r, r2.b, r2.r, r2.t));\\n          r1.t = r2.t;\\n        } else if (r1.r > r2.r) {\\n          pq.push(Rect(r2.r, r1.b, r1.r, r2.b));\\n          r1.t = r2.t;\\n          r1.r = r2.r;\\n        } else {\\n          r1.t = r2.t;\\n        }\\n      }\\n\\n      // check rectangles from left to right\\n      if (!last) {\\n        last = new Rect(r1);\\n      } else {\\n        if (last->r != r1.l || last->b != r1.b || last->t != r1.t) { // check if overlaping, same top and same bottom\\n          delete last;\\n          return false;\\n        }\\n        *last = r1;\\n      }\\n    }\\n\\n    delete last;\\n    return true;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 741393,
                "title": "java-o-n-solution",
                "content": "Solution based on https://leetcode.com/problems/perfect-rectangle/discuss/87180/O(n)-solution-by-counting-corners-with-detailed-explaination\\n\\n```\\nclass Solution {\\n    public boolean isRectangleCover(int[][] rectangles) {\\n        Set<String> res = new HashSet<>();\\n        \\n        int bottomLeftX = Integer.MAX_VALUE;\\n        int bottomLeftY = Integer.MAX_VALUE;\\n        int topRightX = Integer.MIN_VALUE;\\n        int topRightY = Integer.MIN_VALUE;\\n        int area = 0;\\n        \\n        for(int[] rect : rectangles){\\n            bottomLeftX = Math.min(bottomLeftX, rect[0]);\\n            bottomLeftY = Math.min(bottomLeftY, rect[1]);\\n            topRightX = Math.max(topRightX, rect[2]);\\n            topRightY = Math.max(topRightY, rect[3]);\\n            \\n            area += (rect[2] - rect[0]) * (rect[3] - rect[1]);\\n            \\n            String bottomLeft = rect[0] + \":\" + rect[1];\\n            String bottomRight = rect[2] + \":\" + rect[1];\\n            String topLeft = rect[0] + \":\" + rect[3];\\n            String topRight = rect[2] + \":\" + rect[3];\\n            if(!res.add(bottomLeft)) res.remove(bottomLeft);\\n            if(!res.add(bottomRight)) res.remove(bottomRight);\\n            if(!res.add(topLeft)) res.remove(topLeft);\\n            if(!res.add(topRight)) res.remove(topRight);\\n        }\\n        \\n        if(!res.contains(bottomLeftX + \":\" + bottomLeftY) \\n            || !res.contains(topRightX + \":\" + bottomLeftY)\\n            || !res.contains(bottomLeftX + \":\" + topRightY)\\n            || !res.contains(topRightX + \":\" + topRightY)\\n            || res.size() != 4) return false;\\n        \\n        return area == (topRightX - bottomLeftX) * (topRightY - bottomLeftY);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isRectangleCover(int[][] rectangles) {\\n        Set<String> res = new HashSet<>();\\n        \\n        int bottomLeftX = Integer.MAX_VALUE;\\n        int bottomLeftY = Integer.MAX_VALUE;\\n        int topRightX = Integer.MIN_VALUE;\\n        int topRightY = Integer.MIN_VALUE;\\n        int area = 0;\\n        \\n        for(int[] rect : rectangles){\\n            bottomLeftX = Math.min(bottomLeftX, rect[0]);\\n            bottomLeftY = Math.min(bottomLeftY, rect[1]);\\n            topRightX = Math.max(topRightX, rect[2]);\\n            topRightY = Math.max(topRightY, rect[3]);\\n            \\n            area += (rect[2] - rect[0]) * (rect[3] - rect[1]);\\n            \\n            String bottomLeft = rect[0] + \":\" + rect[1];\\n            String bottomRight = rect[2] + \":\" + rect[1];\\n            String topLeft = rect[0] + \":\" + rect[3];\\n            String topRight = rect[2] + \":\" + rect[3];\\n            if(!res.add(bottomLeft)) res.remove(bottomLeft);\\n            if(!res.add(bottomRight)) res.remove(bottomRight);\\n            if(!res.add(topLeft)) res.remove(topLeft);\\n            if(!res.add(topRight)) res.remove(topRight);\\n        }\\n        \\n        if(!res.contains(bottomLeftX + \":\" + bottomLeftY) \\n            || !res.contains(topRightX + \":\" + bottomLeftY)\\n            || !res.contains(bottomLeftX + \":\" + topRightY)\\n            || !res.contains(topRightX + \":\" + topRightY)\\n            || res.size() != 4) return false;\\n        \\n        return area == (topRightX - bottomLeftX) * (topRightY - bottomLeftY);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 724904,
                "title": "python-o-nlogn-using-sweep-line-and-bst",
                "content": "The idea is to use veritcal sweep line, sweeping through all the vertical edges of the rectangles. There are two things we need to check: 1) For each vertical line, does our input fully span the range [minY, maxY]? and 2) Is there any overlapping vertical ranges?\\n\\n\\nFor 2) we can use a BST to represent the list of current ranges. We try to insert a range into the list, if there is an overlap we return False right away.  Note that to be able to do this we also need to make sure that closing edges always come before opening edges, if they share the same x-value. \\n\\nFor 1) we can use a set s to mark all the x-coordinates that are fully covered. If in any step when we are at x, we realize that the list of current ranges fully span [minY, maxY], then we add x to the set s. Later when we go to x\\' which is the next greater coordinate of x, we check if x is already in the set. If not, then there must be a hole in vertical line x, so we return False immediately.\\n\\nTime Complexity: O(NlogN). Space: O(N)\\n```\\nfrom sortedcontainers import SortedList\\nclass Event:\\n    def __init__(self, idx, cat):\\n        self.idx = idx\\n        self.cat = cat\\nclass Solution:\\n    def isRectangleCover(self, rectangles: List[List[int]]) -> bool:\\n        def cmp_x(e):\\n            return rectangles[e.idx][2] if e.cat else rectangles[e.idx][0]\\n        def cmp_y(e):\\n            return rectangles[e.idx][3] if e.cat else rectangles[e.idx][1]\\n        eventV = []\\n        n = len(rectangles)\\n        minY, maxY = float(\\'inf\\'), float(\\'-inf\\')\\n        minX, maxX = float(\\'inf\\'), float(\\'-inf\\')\\n        sum_area = 0\\n        print(n)\\n        for i, rec in enumerate(rectangles):\\n            a, b, x, y = rec\\n            minX = min(minX, a)\\n            maxX = max(maxX, x)\\n            minY = min(minY, b)\\n            maxY = max(maxY, y)\\n            # sum_area += (y - b)*(x - a)\\n            eventV.append(Event(i, 0)) #0: open(bot left)\\n            eventV.append(Event(i, 1)) #1: close(top right)\\n        eventV = sorted(eventV, key = lambda x: (cmp_x(x), -x.cat)) #close comes first\\n        #this will check if there is a hole somewhere\\n        # area = (maxX - minX) * (maxY - minY)\\n        # if sum_area != area:\\n        #     return False\\n        e = SortedList() #List of segments\\n        fully_covered = set()\\n        pastx = float(\\'inf\\')\\n        for i in range(2*n): \\n            c = eventV[i]\\n            rec = rectangles[c.idx]\\n            y1, y2 = rec[1], rec[3]\\n            if c.cat == 0: #open\\n                x = rec[0] #x of this event\\n                k = e.bisect_left((y1, y2))\\n                if (0 < k < len(e)) and (y1 < e[k - 1][1] or y2 > e[k][0]):\\n                    print(\\'Overlap\\')\\n                    return False \\n                if k == 0 and (len(e) > 0 and y2 > e[0][0]):\\n                    print(\\'Overlap\\')\\n                    return False\\n                if k == len(e) and (len(e) > 0 and y1 < e[-1][1]):\\n                    print(\\'Overlap\\')\\n                    return False\\n                e.add((y1, y2)) #add this y-segment\\n            else:\\n                x = rec[2] #x of this event\\n                e.remove((y1, y2)) #remove this y-segment\\n            if x > pastx and pastx not in fully_covered:\\n                print(\\'Last x was not fully covered\\')\\n                return False\\n            if e and e[-1][1] == maxY and e[0][0] == minY: #cover full range\\n                fully_covered.add(x)\\n            pastx = x\\n        return True         \\n```",
                "solutionTags": [],
                "code": "```\\nfrom sortedcontainers import SortedList\\nclass Event:\\n    def __init__(self, idx, cat):\\n        self.idx = idx\\n        self.cat = cat\\nclass Solution:\\n    def isRectangleCover(self, rectangles: List[List[int]]) -> bool:\\n        def cmp_x(e):\\n            return rectangles[e.idx][2] if e.cat else rectangles[e.idx][0]\\n        def cmp_y(e):\\n            return rectangles[e.idx][3] if e.cat else rectangles[e.idx][1]\\n        eventV = []\\n        n = len(rectangles)\\n        minY, maxY = float(\\'inf\\'), float(\\'-inf\\')\\n        minX, maxX = float(\\'inf\\'), float(\\'-inf\\')\\n        sum_area = 0\\n        print(n)\\n        for i, rec in enumerate(rectangles):\\n            a, b, x, y = rec\\n            minX = min(minX, a)\\n            maxX = max(maxX, x)\\n            minY = min(minY, b)\\n            maxY = max(maxY, y)\\n            # sum_area += (y - b)*(x - a)\\n            eventV.append(Event(i, 0)) #0: open(bot left)\\n            eventV.append(Event(i, 1)) #1: close(top right)\\n        eventV = sorted(eventV, key = lambda x: (cmp_x(x), -x.cat)) #close comes first\\n        #this will check if there is a hole somewhere\\n        # area = (maxX - minX) * (maxY - minY)\\n        # if sum_area != area:\\n        #     return False\\n        e = SortedList() #List of segments\\n        fully_covered = set()\\n        pastx = float(\\'inf\\')\\n        for i in range(2*n): \\n            c = eventV[i]\\n            rec = rectangles[c.idx]\\n            y1, y2 = rec[1], rec[3]\\n            if c.cat == 0: #open\\n                x = rec[0] #x of this event\\n                k = e.bisect_left((y1, y2))\\n                if (0 < k < len(e)) and (y1 < e[k - 1][1] or y2 > e[k][0]):\\n                    print(\\'Overlap\\')\\n                    return False \\n                if k == 0 and (len(e) > 0 and y2 > e[0][0]):\\n                    print(\\'Overlap\\')\\n                    return False\\n                if k == len(e) and (len(e) > 0 and y1 < e[-1][1]):\\n                    print(\\'Overlap\\')\\n                    return False\\n                e.add((y1, y2)) #add this y-segment\\n            else:\\n                x = rec[2] #x of this event\\n                e.remove((y1, y2)) #remove this y-segment\\n            if x > pastx and pastx not in fully_covered:\\n                print(\\'Last x was not fully covered\\')\\n                return False\\n            if e and e[-1][1] == maxY and e[0][0] == minY: #cover full range\\n                fully_covered.add(x)\\n            pastx = x\\n        return True         \\n```",
                "codeTag": "Java"
            },
            {
                "id": 645475,
                "title": "c-solution-counting-corners",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tbool isRectangleCover(vector<vector<int>>& rectangles) {\\n\\t\\t\\tset<pair<int,int>> Set;\\n\\t\\t\\tint area=0;\\n\\t\\t\\tfor(auto& x:rectangles)\\n\\t\\t\\t{\\n\\t\\t\\t\\tpair<int,int> p1{x[0],x[1]};\\n\\t\\t\\t\\tpair<int,int> p2{x[2],x[3]};\\n\\t\\t\\t\\tpair<int,int> p3{x[0],x[3]};\\n\\t\\t\\t\\tpair<int,int> p4{x[2],x[1]};\\n\\n\\t\\t\\t\\tarea+=(x[2]-x[0])*(x[3]-x[1]);\\n\\n\\t\\t\\t\\tif(Set.count(p1))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tSet.erase(p1);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tSet.insert(p1);\\n\\t\\t\\t\\t}\\n\\n\\n\\t\\t\\t\\tif(Set.count(p2))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tSet.erase(p2);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tSet.insert(p2);\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif(Set.count(p3))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tSet.erase(p3);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tSet.insert(p3);\\n\\t\\t\\t\\t}\\n\\n\\n\\t\\t\\t\\tif(Set.count(p4))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tSet.erase(p4);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tSet.insert(p4);\\n\\t\\t\\t\\t}\\n\\n\\n\\n\\t\\t\\t}\\n\\t\\t\\treturn Set.size()==4 && area==((*Set.rbegin()).second-(*Set.begin()).second)*((*Set.rbegin()).first-(*Set.begin()).first);\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tbool isRectangleCover(vector<vector<int>>& rectangles) {\\n\\t\\t\\tset<pair<int,int>> Set;\\n\\t\\t\\tint area=0;\\n\\t\\t\\tfor(auto& x:rectangles)\\n\\t\\t\\t{\\n\\t\\t\\t\\tpair<int,int> p1{x[0],x[1]}",
                "codeTag": "Java"
            },
            {
                "id": 627309,
                "title": "c-using-sortedset-simple-solution",
                "content": "```\\npublic bool IsRectangleCover(int[][] rectangles) {\\n        var ss = new SortedSet<(int, int)>(new myCompare());\\n        int area = 0;\\n        for(int i = 0; i < rectangles.Length; i ++) {\\n            if(!ss.Add((rectangles[i][0], rectangles[i][1]))) ss.Remove((rectangles[i][0], rectangles[i][1]));\\n            if(!ss.Add((rectangles[i][0], rectangles[i][3]))) ss.Remove((rectangles[i][0], rectangles[i][3]));\\n            if(!ss.Add((rectangles[i][2], rectangles[i][3]))) ss.Remove((rectangles[i][2], rectangles[i][3]));\\n            if(!ss.Add((rectangles[i][2], rectangles[i][1]))) ss.Remove((rectangles[i][2], rectangles[i][1]));\\n            area += (rectangles[i][2] - rectangles[i][0]) * (rectangles[i][3] - rectangles[i][1]);\\n        }\\n        if(ss.Count != 4) return false;\\n        return area == (ss.Max.Item1 - ss.Min.Item1) * (ss.Max.Item2 - ss.Min.Item2);\\n    }\\n    public class myCompare: IComparer<(int, int)> {\\n        public int Compare((int, int) a, (int, int) b) {\\n            return a.Item1 == b.Item1 ? a.Item2 - b.Item2 : a.Item1 - b.Item1;\\n        }\\n    }",
                "solutionTags": [],
                "code": "```\\npublic bool IsRectangleCover(int[][] rectangles) {\\n        var ss = new SortedSet<(int, int)>(new myCompare());\\n        int area = 0;\\n        for(int i = 0; i < rectangles.Length; i ++) {\\n            if(!ss.Add((rectangles[i][0], rectangles[i][1]))) ss.Remove((rectangles[i][0], rectangles[i][1]));\\n            if(!ss.Add((rectangles[i][0], rectangles[i][3]))) ss.Remove((rectangles[i][0], rectangles[i][3]));\\n            if(!ss.Add((rectangles[i][2], rectangles[i][3]))) ss.Remove((rectangles[i][2], rectangles[i][3]));\\n            if(!ss.Add((rectangles[i][2], rectangles[i][1]))) ss.Remove((rectangles[i][2], rectangles[i][1]));\\n            area += (rectangles[i][2] - rectangles[i][0]) * (rectangles[i][3] - rectangles[i][1]);\\n        }\\n        if(ss.Count != 4) return false;\\n        return area == (ss.Max.Item1 - ss.Min.Item1) * (ss.Max.Item2 - ss.Min.Item2);\\n    }\\n    public class myCompare: IComparer<(int, int)> {\\n        public int Compare((int, int) a, (int, int) b) {\\n            return a.Item1 == b.Item1 ? a.Item2 - b.Item2 : a.Item1 - b.Item1;\\n        }\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 616525,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isRectangleCover(const vector<vector<int>>& rectangles) {\\n        int area = 0, x1 = INT32_MAX, x2 = INT32_MIN, y1 = INT32_MAX, y2 = INT32_MIN;\\n        unordered_set<int> s;\\n        for(const auto &r: rectangles) {\\n            x1 = min(x1, r[0]);\\n            y1 = min(y1, r[1]);\\n            x2 = max(x2, r[2]);\\n            y2 = max(y2, r[3]);\\n            area += (r[2]-r[0])*(r[3]-r[1]);\\n            int s1 = hash(r[0], r[1]),\\n               s2 = hash(r[0], r[3]),\\n               s3 = hash(r[2], r[1]),\\n               s4 = hash(r[2], r[3]);\\n            if(s.count(s1)) s.erase(s1);\\n            else s.insert(s1);\\n            if(s.count(s2)) s.erase(s2);\\n            else s.insert(s2);\\n            if(s.count(s3)) s.erase(s3);\\n            else s.insert(s3);\\n            if(s.count(s4)) s.erase(s4);\\n            else s.insert(s4);\\n        }\\n        return area == (x2-x1)*(y2-y1) && s.size() == 4 \\n            && s.count(hash(x1,y1))\\n            && s.count(hash(x1,y2))\\n            && s.count(hash(x2,y1)) \\n            && s.count(hash(x2,y2));\\n    }\\n    static inline int hash(const int& a, const int& b) {\\n        return a*7 + b*7*7*7;\\n    }\\n};\\n\\nauto gucciGang = []() {std::ios::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr);return 0;}();\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isRectangleCover(const vector<vector<int>>& rectangles) {\\n        int area = 0, x1 = INT32_MAX, x2 = INT32_MIN, y1 = INT32_MAX, y2 = INT32_MIN;\\n        unordered_set<int> s;\\n        for(const auto &r: rectangles) {\\n            x1 = min(x1, r[0]);\\n            y1 = min(y1, r[1]);\\n            x2 = max(x2, r[2]);\\n            y2 = max(y2, r[3]);\\n            area += (r[2]-r[0])*(r[3]-r[1]);\\n            int s1 = hash(r[0], r[1]),\\n               s2 = hash(r[0], r[3]),\\n               s3 = hash(r[2], r[1]),\\n               s4 = hash(r[2], r[3]);\\n            if(s.count(s1)) s.erase(s1);\\n            else s.insert(s1);\\n            if(s.count(s2)) s.erase(s2);\\n            else s.insert(s2);\\n            if(s.count(s3)) s.erase(s3);\\n            else s.insert(s3);\\n            if(s.count(s4)) s.erase(s4);\\n            else s.insert(s4);\\n        }\\n        return area == (x2-x1)*(y2-y1) && s.size() == 4 \\n            && s.count(hash(x1,y1))\\n            && s.count(hash(x1,y2))\\n            && s.count(hash(x2,y1)) \\n            && s.count(hash(x2,y2));\\n    }\\n    static inline int hash(const int& a, const int& b) {\\n        return a*7 + b*7*7*7;\\n    }\\n};\\n\\nauto gucciGang = []() {std::ios::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr);return 0;}();\\n```",
                "codeTag": "C++"
            },
            {
                "id": 516719,
                "title": "swift-solution-double-100-00",
                "content": "```swift\\nstruct Point: Hashable {\\n    let x: Int\\n    let y: Int\\n}\\n\\nclass Solution {\\n    \\n    private func getCornerPoints(of rectangle: [Int]) -> [Point] {\\n        return [Point(x: rectangle[0], y:rectangle[1]), Point(x:rectangle[0], y:rectangle[3]), \\n                Point(x: rectangle[2], y:rectangle[3]), Point(x:rectangle[2], y:rectangle[1])]\\n    }\\n    \\n    func isRectangleCover(_ rectangles: [[Int]]) -> Bool {\\n        var sets: Set<Point> = []\\n        var rectangleUnitCount = 0\\n        \\n        for rectangle in rectangles {\\n            let corners = getCornerPoints(of: rectangle)\\n            corners.forEach { corner in\\n                if sets.contains(corner) {\\n                    sets.remove(corner)\\n                } else {\\n                    sets.insert(corner)\\n                }\\n            }\\n            rectangleUnitCount += (corners[2].x - corners[0].x) * (corners[2].y - corners[0].y)\\n        }\\n        \\n        guard sets.count == 4 else {\\n            return false\\n        }\\n        \\n        let sortedPoints = sets.sorted(by: { ($0.x + $0.y) < ($1.x + $1.y) })\\n        \\n        guard let leftBottom = sortedPoints.first, \\n        let rightTop = sortedPoints.last else { return false }\\n              \\n        return (rightTop.x - leftBottom.x) * (rightTop.y - leftBottom.y) == rectangleUnitCount\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```swift\\nstruct Point: Hashable {\\n    let x: Int\\n    let y: Int\\n}\\n\\nclass Solution {\\n    \\n    private func getCornerPoints(of rectangle: [Int]) -> [Point] {\\n        return [Point(x: rectangle[0], y:rectangle[1]), Point(x:rectangle[0], y:rectangle[3]), \\n                Point(x: rectangle[2], y:rectangle[3]), Point(x:rectangle[2], y:rectangle[1])]\\n    }\\n    \\n    func isRectangleCover(_ rectangles: [[Int]]) -> Bool {\\n        var sets: Set<Point> = []\\n        var rectangleUnitCount = 0\\n        \\n        for rectangle in rectangles {\\n            let corners = getCornerPoints(of: rectangle)\\n            corners.forEach { corner in\\n                if sets.contains(corner) {\\n                    sets.remove(corner)\\n                } else {\\n                    sets.insert(corner)\\n                }\\n            }\\n            rectangleUnitCount += (corners[2].x - corners[0].x) * (corners[2].y - corners[0].y)\\n        }\\n        \\n        guard sets.count == 4 else {\\n            return false\\n        }\\n        \\n        let sortedPoints = sets.sorted(by: { ($0.x + $0.y) < ($1.x + $1.y) })\\n        \\n        guard let leftBottom = sortedPoints.first, \\n        let rightTop = sortedPoints.last else { return false }\\n              \\n        return (rightTop.x - leftBottom.x) * (rightTop.y - leftBottom.y) == rectangleUnitCount\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 500909,
                "title": "c-line-sweep",
                "content": "Similar to Skyline problem, line sweep can be used here.\\nO(nlog(n)) for sorting. The rest is O(n)\\n\\n```\\npublic class Solution {\\n    public bool IsRectangleCover(int[][] rectangles) {\\n        // Line sweep, similar to skyline problem\\n        // Event= [x,y1,y2,openClose] (openClose = 1 (Open) or -1 (Close))\\n        var events = rectangles.Select(x=> new List<int[]>{\\n            new int[]{x[0],x[1],x[3],1},\\n            new int[]{x[2],x[1],x[3],-1}\\n        }).SelectMany(y=>y)\\n          .GroupBy(z=>z[0])\\n          .OrderBy(w=>w.Key)\\n          .Select(v=>v.ToList())\\n          .ToList();\\n        \\n        // Make sure the first and last event create exact same height after merge\\n        var first = Height(events[0]);\\n        var last = Height(events.Last());\\n        if(!SameHeight(first, last) || first.Count!=2){\\n            return false;\\n        }\\n        \\n        for(var i=1; i<events.Count-1; i++){\\n            var positiveHeight = Height(events[i].Where(x=>x[3]>0).ToList());\\n            var negativeHeight = Height(events[i].Where(x=>x[3]<0).ToList());\\n            if(!SameHeight(positiveHeight, negativeHeight)){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    bool SameHeight(List<int> x, List<int> y){\\n        return x.Any() && y.Any() && Enumerable.SequenceEqual(x,y);\\n    }\\n    \\n    // Return a list of merged y intervals\\n    // For instance, [1,3], [3,4] , [5,7],[7,10], [12,13] ==> [1,4], [5,10], [12,13]\\n    List<int> Height(List<int[]> points){\\n        var ret = new List<int>();\\n        if(!points.Any()) return ret;\\n        points = points.OrderBy(x=>x[1]).ToList();\\n        Console.WriteLine(string.Join(\",\", points.Select(x=>$\"[{x[0]},{x[1]},{x[2]}]\")));\\n        for(var i=0; i<points.Count; ){\\n            var j = i+1;\\n            while(j<points.Count){\\n                if(points[j][1]==points[j-1][2]){\\n                    j++;\\n                }\\n                else if(points[j][1]<points[j-1][2]){\\n                    // Overlapped happen, return empty result\\n                    return new List<int>();\\n                }\\n                else{\\n                    break;\\n                }\\n            }\\n            ret.Add(points[i][1]);\\n            ret.Add(points[j-1][2]);\\n            i = j;\\n        }\\n        return ret;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public bool IsRectangleCover(int[][] rectangles) {\\n        // Line sweep, similar to skyline problem\\n        // Event= [x,y1,y2,openClose] (openClose = 1 (Open) or -1 (Close))\\n        var events = rectangles.Select(x=> new List<int[]>{\\n            new int[]{x[0],x[1],x[3],1},\\n            new int[]{x[2],x[1],x[3],-1}\\n        }).SelectMany(y=>y)\\n          .GroupBy(z=>z[0])\\n          .OrderBy(w=>w.Key)\\n          .Select(v=>v.ToList())\\n          .ToList();\\n        \\n        // Make sure the first and last event create exact same height after merge\\n        var first = Height(events[0]);\\n        var last = Height(events.Last());\\n        if(!SameHeight(first, last) || first.Count!=2){\\n            return false;\\n        }\\n        \\n        for(var i=1; i<events.Count-1; i++){\\n            var positiveHeight = Height(events[i].Where(x=>x[3]>0).ToList());\\n            var negativeHeight = Height(events[i].Where(x=>x[3]<0).ToList());\\n            if(!SameHeight(positiveHeight, negativeHeight)){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    bool SameHeight(List<int> x, List<int> y){\\n        return x.Any() && y.Any() && Enumerable.SequenceEqual(x,y);\\n    }\\n    \\n    // Return a list of merged y intervals\\n    // For instance, [1,3], [3,4] , [5,7],[7,10], [12,13] ==> [1,4], [5,10], [12,13]\\n    List<int> Height(List<int[]> points){\\n        var ret = new List<int>();\\n        if(!points.Any()) return ret;\\n        points = points.OrderBy(x=>x[1]).ToList();\\n        Console.WriteLine(string.Join(\",\", points.Select(x=>$\"[{x[0]},{x[1]},{x[2]}]\")));\\n        for(var i=0; i<points.Count; ){\\n            var j = i+1;\\n            while(j<points.Count){\\n                if(points[j][1]==points[j-1][2]){\\n                    j++;\\n                }\\n                else if(points[j][1]<points[j-1][2]){\\n                    // Overlapped happen, return empty result\\n                    return new List<int>();\\n                }\\n                else{\\n                    break;\\n                }\\n            }\\n            ret.Add(points[i][1]);\\n            ret.Add(points[j-1][2]);\\n            i = j;\\n        }\\n        return ret;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 496330,
                "title": "golang",
                "content": "https://leetcode.com/problems/perfect-rectangle/discuss/87180/O(n)-solution-by-counting-corners-with-detailed-explaination\\n```\\nfunc isRectangleCover(rectangles [][]int) bool {\\n\\tarea := 0\\n\\tmnx, mxx, mny, mxy := math.MaxInt32, math.MinInt32, math.MaxInt32, math.MinInt32\\n\\tcountMap := make(map[string]int)\\n\\tfor _, r := range rectangles {\\n\\t\\tarea += (r[2] - r[0]) * (r[3] - r[1])\\n\\t\\tmnx, mxx, mny, mxy = min(mnx, r[0]), max(mxx, r[2]), min(mny, r[1]), max(mxy, r[3])\\n\\t\\tcountMap[fmt.Sprintf(\"%d-%d\", r[0], r[1])]++\\n\\t\\tcountMap[fmt.Sprintf(\"%d-%d\", r[0], r[3])]++\\n\\t\\tcountMap[fmt.Sprintf(\"%d-%d\", r[2], r[1])]++\\n\\t\\tcountMap[fmt.Sprintf(\"%d-%d\", r[2], r[3])]++\\n\\t}\\n\\n\\tsingleDot := 0\\n\\tfor _, v := range countMap {\\n\\t\\tif v == 1 {\\n\\t\\t\\tsingleDot++\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tif v != 2 && v != 4 {\\n\\t\\t\\treturn false\\n\\t\\t}\\n\\t}\\n\\treturn (mxx-mnx)*(mxy-mny) == area && singleDot == 4 &&\\n\\t\\tcountMap[fmt.Sprintf(\"%d-%d\", mnx, mny)] == 1 &&\\n\\t\\tcountMap[fmt.Sprintf(\"%d-%d\", mnx, mxy)] == 1 &&\\n\\t\\tcountMap[fmt.Sprintf(\"%d-%d\", mxx, mny)] == 1 &&\\n\\t\\tcountMap[fmt.Sprintf(\"%d-%d\", mxx, mxy)] == 1\\n}\\n\\nfunc max(x, y int) int {\\n\\tif x > y {\\n\\t\\treturn x\\n\\t}\\n\\n\\treturn y\\n}\\n\\nfunc min(x, y int) int {\\n\\tif x < y {\\n\\t\\treturn x\\n\\t}\\n\\n\\treturn y\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc isRectangleCover(rectangles [][]int) bool {\\n\\tarea := 0\\n\\tmnx, mxx, mny, mxy := math.MaxInt32, math.MinInt32, math.MaxInt32, math.MinInt32\\n\\tcountMap := make(map[string]int)\\n\\tfor _, r := range rectangles {\\n\\t\\tarea += (r[2] - r[0]) * (r[3] - r[1])\\n\\t\\tmnx, mxx, mny, mxy = min(mnx, r[0]), max(mxx, r[2]), min(mny, r[1]), max(mxy, r[3])\\n\\t\\tcountMap[fmt.Sprintf(\"%d-%d\", r[0], r[1])]++\\n\\t\\tcountMap[fmt.Sprintf(\"%d-%d\", r[0], r[3])]++\\n\\t\\tcountMap[fmt.Sprintf(\"%d-%d\", r[2], r[1])]++\\n\\t\\tcountMap[fmt.Sprintf(\"%d-%d\", r[2], r[3])]++\\n\\t}\\n\\n\\tsingleDot := 0\\n\\tfor _, v := range countMap {\\n\\t\\tif v == 1 {\\n\\t\\t\\tsingleDot++\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tif v != 2 && v != 4 {\\n\\t\\t\\treturn false\\n\\t\\t}\\n\\t}\\n\\treturn (mxx-mnx)*(mxy-mny) == area && singleDot == 4 &&\\n\\t\\tcountMap[fmt.Sprintf(\"%d-%d\", mnx, mny)] == 1 &&\\n\\t\\tcountMap[fmt.Sprintf(\"%d-%d\", mnx, mxy)] == 1 &&\\n\\t\\tcountMap[fmt.Sprintf(\"%d-%d\", mxx, mny)] == 1 &&\\n\\t\\tcountMap[fmt.Sprintf(\"%d-%d\", mxx, mxy)] == 1\\n}\\n\\nfunc max(x, y int) int {\\n\\tif x > y {\\n\\t\\treturn x\\n\\t}\\n\\n\\treturn y\\n}\\n\\nfunc min(x, y int) int {\\n\\tif x < y {\\n\\t\\treturn x\\n\\t}\\n\\n\\treturn y\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 469050,
                "title": "count-points-and-compare-area",
                "content": "with a hashmap cc\\n```\\nfor pt in all points:\\n\\tcc[pt] +=1\\n```\\n\\nreturn \\n1.(number of points where cc[pt] == 1) == 4 \\n2.and areacovered by these 4 == area of all rectangles cumulated \\n3.and all the other points have an even number of occurence \\n\\n\\n```\\nclass Solution(object):\\n    def isRectangleCover(self, rectangles):\\n        cc = collections.Counter()\\n        area = 0\\n        for r in rectangles:\\n            u,v = tuple(r[:2]), tuple(r[2:])\\n            cc[u] +=1\\n            cc[v] +=1\\n            cc[(u[0],v[1])] +=1\\n            cc[(v[0],u[1])] +=1\\n            area += (v[1] - u[1]) * (v[0] - u[0]) \\n        \\n        cb,ca = {k:cc[k] for k in cc if cc[k] == 1}, {k:cc[k] for k in cc if cc[k] %2 == 0}\\n        if (len(cb) != 4) or (len(ca) + len(cb) != len(cc)): return False\\n        keys = sorted(cb.keys())\\n        return (keys[1][1] - keys[0][1]) *(keys[2][0] - keys[0][0]) ==area\\n```",
                "solutionTags": [],
                "code": "```\\nfor pt in all points:\\n\\tcc[pt] +=1\\n```\n```\\nclass Solution(object):\\n    def isRectangleCover(self, rectangles):\\n        cc = collections.Counter()\\n        area = 0\\n        for r in rectangles:\\n            u,v = tuple(r[:2]), tuple(r[2:])\\n            cc[u] +=1\\n            cc[v] +=1\\n            cc[(u[0],v[1])] +=1\\n            cc[(v[0],u[1])] +=1\\n            area += (v[1] - u[1]) * (v[0] - u[0]) \\n        \\n        cb,ca = {k:cc[k] for k in cc if cc[k] == 1}, {k:cc[k] for k in cc if cc[k] %2 == 0}\\n        if (len(cb) != 4) or (len(ca) + len(cb) != len(cc)): return False\\n        keys = sorted(cb.keys())\\n        return (keys[1][1] - keys[0][1]) *(keys[2][0] - keys[0][0]) ==area\\n```",
                "codeTag": "Java"
            },
            {
                "id": 297537,
                "title": "java-76-ms-faster-than-21-62-52-6-mb-less-than-64-29",
                "content": "```\\nclass Solution {\\n    public boolean isRectangleCover(int[][] rectangles) {\\n        if (rectangles == null || rectangles.length == 0 || rectangles[0].length == 0) {\\n            return true;\\n        }\\n        Map<String, Set<Integer>> cnts = new HashMap<>();\\n        for (int[] rec : rectangles) {\\n            String[] ps = getPoints(rec);\\n            for (int i = 0; i < 4; ++i) {\\n                String p = ps[i];\\n                if (!cnts.containsKey(p)) {\\n                    cnts.put(p, new HashSet<>());\\n                }\\n                if (cnts.get(p).contains(i)) {\\n                    return false;\\n                }\\n                cnts.get(p).add(i);\\n            }\\n        }\\n        int corners = 0;\\n        for (String key : cnts.keySet()) {\\n            if (checkTwo(cnts.get(key)) || cnts.get(key).size() == 3 || cnts.get(key).size() > 4) {\\n                return false;\\n            }\\n            if (cnts.get(key).size() == 1) {\\n                ++corners;\\n            }\\n            if (corners > 4) {\\n                return false;\\n            }\\n        }\\n        return corners == 4;\\n    }\\n    \\n    private boolean checkTwo(Set<Integer> set) {\\n        if (set.size() != 2) {\\n            return false;\\n        }\\n        int sum = 0;\\n        for (int num : set) {\\n            sum += num;\\n        }\\n        return sum == 3;\\n    }\\n    \\n    private String[] getPoints(int[] rec) {\\n        Point[] p = new Point[4];\\n        for (int i = 0; i < 4; ++i) {\\n            p[i] = new Point(rec[i / 2 * 2], rec[1 + 2 * (i % 2)]);\\n        }\\n        Arrays.sort(p, new PointComparator());\\n        String[] res = new String[4];\\n        for (int i = 0; i < 4; ++i) {\\n            res[i] = p[i].x + \",\" + p[i].y;\\n        }\\n        return res;\\n    }\\n    \\n    private class PointComparator implements Comparator<Point> {\\n        public int compare(Point a, Point b) {\\n            if (a.x == b.x) {\\n                return a.y - b.y;\\n            } else {\\n                return a.x - b.x;\\n            }\\n        }\\n    }\\n    \\n    private class Point {\\n        int x;\\n        int y;\\n        \\n        Point(int x, int y) {\\n            this.x = x;\\n            this.y = y;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isRectangleCover(int[][] rectangles) {\\n        if (rectangles == null || rectangles.length == 0 || rectangles[0].length == 0) {\\n            return true;\\n        }\\n        Map<String, Set<Integer>> cnts = new HashMap<>();\\n        for (int[] rec : rectangles) {\\n            String[] ps = getPoints(rec);\\n            for (int i = 0; i < 4; ++i) {\\n                String p = ps[i];\\n                if (!cnts.containsKey(p)) {\\n                    cnts.put(p, new HashSet<>());\\n                }\\n                if (cnts.get(p).contains(i)) {\\n                    return false;\\n                }\\n                cnts.get(p).add(i);\\n            }\\n        }\\n        int corners = 0;\\n        for (String key : cnts.keySet()) {\\n            if (checkTwo(cnts.get(key)) || cnts.get(key).size() == 3 || cnts.get(key).size() > 4) {\\n                return false;\\n            }\\n            if (cnts.get(key).size() == 1) {\\n                ++corners;\\n            }\\n            if (corners > 4) {\\n                return false;\\n            }\\n        }\\n        return corners == 4;\\n    }\\n    \\n    private boolean checkTwo(Set<Integer> set) {\\n        if (set.size() != 2) {\\n            return false;\\n        }\\n        int sum = 0;\\n        for (int num : set) {\\n            sum += num;\\n        }\\n        return sum == 3;\\n    }\\n    \\n    private String[] getPoints(int[] rec) {\\n        Point[] p = new Point[4];\\n        for (int i = 0; i < 4; ++i) {\\n            p[i] = new Point(rec[i / 2 * 2], rec[1 + 2 * (i % 2)]);\\n        }\\n        Arrays.sort(p, new PointComparator());\\n        String[] res = new String[4];\\n        for (int i = 0; i < 4; ++i) {\\n            res[i] = p[i].x + \",\" + p[i].y;\\n        }\\n        return res;\\n    }\\n    \\n    private class PointComparator implements Comparator<Point> {\\n        public int compare(Point a, Point b) {\\n            if (a.x == b.x) {\\n                return a.y - b.y;\\n            } else {\\n                return a.x - b.x;\\n            }\\n        }\\n    }\\n    \\n    private class Point {\\n        int x;\\n        int y;\\n        \\n        Point(int x, int y) {\\n            this.x = x;\\n            this.y = y;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 283340,
                "title": "c-o-n-log-n",
                "content": "```\\n#include<bits/stdc++.h>\\nusing namespace std;\\nstruct rectangle{\\n    int x1, y1, x2, y2;\\n    rectangle(int x1, int y1, int x2, int y2){\\n        this->x1 = x1;\\n        this->y1 = y1;\\n        this->x2 = x2;\\n        this->y2 = y2;\\n    }\\n\\n    rectangle(vector<int> rect){\\n        x1 = rect[0];\\n        y1 = rect[1];\\n        x2 = rect[2];\\n        y2 = rect[3];\\n    }\\n\\n\\n    bool operator < (const rectangle & r) const {\\n        return y2 <= r.y1;\\n    }\\n\\n    bool operator == (const rectangle & r) const {\\n        return is_intersected(y1, y2, r.y1, r.y2);\\n    }\\n\\n    void print(){\\n    \\tprintf(\"(%d %d) --> (%d %d)\\\\n\", x1, y1, x2, y2);\\n    }\\n\\nprivate:\\n\\n    bool is_intersected(int s1l, int s1r, int s2l, int s2r) const {\\n        return max(s1l, s2l) < min(s1r, s2r);\\n    }\\n};\\n\\n\\nclass Solution {\\n    bool is_intersected(const vector<vector<int>>& rectangles){\\n        map<int, vector<rectangle> > starts, ends;\\n        set<int> xes;\\n        set<rectangle> st;\\n        for(vector<int> rect: rectangles){\\n            int x1 = rect[0];\\n            int x2 = rect[2];\\n            starts[x1].push_back(rectangle(rect));\\n            ends[x2].push_back(rectangle(rect));\\n            xes.insert(x1);\\n            xes.insert(x2);\\n        }\\n        for(int x: xes){\\n            // remove ends\\n            for(rectangle rect: ends[x]){\\n                st.erase(rect);\\n            }\\n            // add starts and check\\n            for(rectangle rect: starts[x]){\\n                if(st.find(rect) != st.end()){\\n                \\treturn true;\\n                }\\n                st.insert(rect);\\n            }\\n        }\\n        return false;\\n    }\\n\\n    int shap_area(const vector<vector<int>>& rectangles){\\n        int mnx = rectangles[0][0], mny = rectangles[0][1], mxx= rectangles[0][2], mxy = rectangles[0][3];\\n        for(int i = 0; i < rectangles.size(); i++){\\n            mnx = min(mnx, rectangles[i][0]);\\n            mny = min(mny, rectangles[i][1]);\\n            mxx = max(mxx, rectangles[i][2]);\\n            mxy = max(mxy, rectangles[i][3]);\\n        }\\n        return (mxx - mnx) * (mxy - mny);\\n    }\\n\\n    int unites_area(const vector<vector<int>>& rectangles){\\n        int sum = 0;\\n        for(int i = 0; i < rectangles.size(); i++){\\n            sum += (rectangles[i][2] - rectangles[i][0]) *   (rectangles[i][3] - rectangles[i][1]);\\n        }\\n        return sum;\\n    }\\n\\npublic:\\n    bool isRectangleCover(vector<vector<int>>& rectangles) {\\n        if(is_intersected(rectangles) || shap_area(rectangles) != unites_area(rectangles) ){\\n            return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#include<bits/stdc++.h>\\nusing namespace std;\\nstruct rectangle{\\n    int x1, y1, x2, y2;\\n    rectangle(int x1, int y1, int x2, int y2){\\n        this->x1 = x1;\\n        this->y1 = y1;\\n        this->x2 = x2;\\n        this->y2 = y2;\\n    }\\n\\n    rectangle(vector<int> rect){\\n        x1 = rect[0];\\n        y1 = rect[1];\\n        x2 = rect[2];\\n        y2 = rect[3];\\n    }\\n\\n\\n    bool operator < (const rectangle & r) const {\\n        return y2 <= r.y1;\\n    }\\n\\n    bool operator == (const rectangle & r) const {\\n        return is_intersected(y1, y2, r.y1, r.y2);\\n    }\\n\\n    void print(){\\n    \\tprintf(\"(%d %d) --> (%d %d)\\\\n\", x1, y1, x2, y2);\\n    }\\n\\nprivate:\\n\\n    bool is_intersected(int s1l, int s1r, int s2l, int s2r) const {\\n        return max(s1l, s2l) < min(s1r, s2r);\\n    }\\n};\\n\\n\\nclass Solution {\\n    bool is_intersected(const vector<vector<int>>& rectangles){\\n        map<int, vector<rectangle> > starts, ends;\\n        set<int> xes;\\n        set<rectangle> st;\\n        for(vector<int> rect: rectangles){\\n            int x1 = rect[0];\\n            int x2 = rect[2];\\n            starts[x1].push_back(rectangle(rect));\\n            ends[x2].push_back(rectangle(rect));\\n            xes.insert(x1);\\n            xes.insert(x2);\\n        }\\n        for(int x: xes){\\n            // remove ends\\n            for(rectangle rect: ends[x]){\\n                st.erase(rect);\\n            }\\n            // add starts and check\\n            for(rectangle rect: starts[x]){\\n                if(st.find(rect) != st.end()){\\n                \\treturn true;\\n                }\\n                st.insert(rect);\\n            }\\n        }\\n        return false;\\n    }\\n\\n    int shap_area(const vector<vector<int>>& rectangles){\\n        int mnx = rectangles[0][0], mny = rectangles[0][1], mxx= rectangles[0][2], mxy = rectangles[0][3];\\n        for(int i = 0; i < rectangles.size(); i++){\\n            mnx = min(mnx, rectangles[i][0]);\\n            mny = min(mny, rectangles[i][1]);\\n            mxx = max(mxx, rectangles[i][2]);\\n            mxy = max(mxy, rectangles[i][3]);\\n        }\\n        return (mxx - mnx) * (mxy - mny);\\n    }\\n\\n    int unites_area(const vector<vector<int>>& rectangles){\\n        int sum = 0;\\n        for(int i = 0; i < rectangles.size(); i++){\\n            sum += (rectangles[i][2] - rectangles[i][0]) *   (rectangles[i][3] - rectangles[i][1]);\\n        }\\n        return sum;\\n    }\\n\\npublic:\\n    bool isRectangleCover(vector<vector<int>>& rectangles) {\\n        if(is_intersected(rectangles) || shap_area(rectangles) != unites_area(rectangles) ){\\n            return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 277529,
                "title": "python-o-n",
                "content": "\\u9664\\u4E86\\u5927\\u77E9\\u5F62\\u56DB\\u4E2A\\u70B9\\u4EE5\\u5916\\uFF0C\\u5176\\u4ED6\\u6240\\u6709\\u9876\\u70B9\\u51FA\\u73B0\\u7684\\u6B21\\u6570\\u90FD\\u5E94\\u8BE5\\u662F2\\u62164\\u6B21\\u3002\\n```\\nclass Solution(object):\\n    def isRectangleCover(self, rectangles):\\n        \"\"\"\\n        :type rectangles: List[List[int]]\\n        :rtype: bool\\n        \"\"\"\\n        ma, mb, mc, md = float(\\'inf\\'), float(\\'inf\\'), float(\\'-inf\\'), float(\\'-inf\\')\\n        count = collections.defaultdict(int)\\n        expected = calculated = 0\\n        for a,b,c,d in rectangles:\\n            ma = min(ma, a)\\n            mb = min(mb, b)\\n            mc = max(mc, c)\\n            md = max(md, d)\\n            count[(a,b)] += 1\\n            count[(c,d)] += 1\\n            count[(a,d)] += 1\\n            count[(c,b)] += 1\\n            expected += (c-a)*(d-b)\\n        calculated = (mc-ma)*(md-mb)\\n            \\n        allow = {(ma,mb), (ma,md), (mc,md), (mc,mb)}\\n        for point in count:\\n            if count[point]!=2 and count[point]!=4:\\n                if point not in allow:\\n                    return False\\n        return expected == calculated and len(set([tuple(n) for n in rectangles])) == len(rectangles)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def isRectangleCover(self, rectangles):\\n        \"\"\"\\n        :type rectangles: List[List[int]]\\n        :rtype: bool\\n        \"\"\"\\n        ma, mb, mc, md = float(\\'inf\\'), float(\\'inf\\'), float(\\'-inf\\'), float(\\'-inf\\')\\n        count = collections.defaultdict(int)\\n        expected = calculated = 0\\n        for a,b,c,d in rectangles:\\n            ma = min(ma, a)\\n            mb = min(mb, b)\\n            mc = max(mc, c)\\n            md = max(md, d)\\n            count[(a,b)] += 1\\n            count[(c,d)] += 1\\n            count[(a,d)] += 1\\n            count[(c,b)] += 1\\n            expected += (c-a)*(d-b)\\n        calculated = (mc-ma)*(md-mb)\\n            \\n        allow = {(ma,mb), (ma,md), (mc,md), (mc,mb)}\\n        for point in count:\\n            if count[point]!=2 and count[point]!=4:\\n                if point not in allow:\\n                    return False\\n        return expected == calculated and len(set([tuple(n) for n in rectangles])) == len(rectangles)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 185555,
                "title": "betas-100-python3",
                "content": "# 100.00%\nclass Solution:\n    def isRectangleCover(self, rectangles):\n        \"\"\"\n        :type rectangles: List[List[int]]\n        :rtype: bool\n        \"\"\"\n        filters = set()\n        vet_angs = set()\n        all_points = set()\n\n        for points in rectangles:\n            i, j, k, l = points\n            v_a1 = (i, l)\n            v_a2 = (k, j)\n            p1 = (i, j)\n            p2 = (k, l)\n            vet_angs.add(v_a1)\n            vet_angs.add(v_a2)\n            all_points.add(p1)\n            all_points.add(p2)\n            fp = (i, j, k)\n            if fp not in filters:\n                filters.add(fp)\n            else:\n                return False\n        return len(all_points.difference(vet_angs)) == 2",
                "solutionTags": [],
                "code": "class Solution:\n    def isRectangleCover(self, rectangles):\n        filters = set()\n        vet_angs = set()\n        all_points = set()\n            i, j, k, l = points\n            v_a1 = (i, l)\n            v_a2 = (k, j)\n            p1 = (i, j)\n            p2 = (k, l)\n            vet_angs.add(v_a1)\n            vet_angs.add(v_a2)\n            all_points.add(p1)\n            all_points.add(p2)\n            fp = (i, j, k)\n                filters.add(fp)\n        return len(all_points.difference(vet_angs)) == 2",
                "codeTag": "Java"
            },
            {
                "id": 175999,
                "title": "java-nlogn-solution-but-beats-98",
                "content": "```\nclass Solution{\n\tclass Rect {\n\t\tpublic Rect(int t, int r) {\n\t\t\tthis.t = t; this.r = r;\n\t\t}\n\t\tint t;\n\t\tint r;\n\t}\n    public boolean isRectangleCover(int[][] rectangles) {\n    \tArrays.sort(rectangles, new Comparator<int[]>(){\n\t\t\t@Override\n\t\t\tpublic int compare(int[] r0, int[] r1) {\n\t\t\t\tint d = r0[0] - r1[0];\n\t\t\t\tif( d != 0 )\n\t\t\t\t\treturn d;\n\t\t\t\treturn r0[1] - r1[1];\n\t\t\t}\n    \t\t\n    \t});\n    \tint L = rectangles[0][0];\n    \tint B = rectangles[0][1];\n    \tint T = B;\n    \tfor(int[] e : rectangles) {\n    \t\tif( e[0] > L )\n    \t\t\tbreak;\n    \t\tT = Math.max(T, e[3]);\n    \t}\n    \tTreeMap<Integer, Rect> map = new TreeMap<>();\n    \tmap.put(B, new Rect(T, L));\n    \tfor(int[] e : rectangles) {\n    \t\tfinal int l = e[0], b = e[1], r = e[2], t = e[3];\n    \t\tRect rect = map.get(b);\n    \t\tif( rect == null )\n    \t\t\treturn false;\n    \t\tif( rect.t < t || rect.r != l )\n    \t\t\treturn false;\n    \t\tMap.Entry<Integer, Rect> below = map.lowerEntry(b);\n    \t\tif( below != null && below.getValue().r != r )\n    \t\t\tbelow = null;\n    \t\tif( t < rect.t ) {\n\t\t\t\tmap.put(t, new Rect(rect.t, rect.r));\n    \t\t\tif( below == null ) {\n    \t\t\t\trect.t = t;\n    \t\t\t\trect.r = r;\n    \t\t\t}\n    \t\t\telse {\n    \t\t\t\tbelow.getValue().t = t;\n    \t\t\t\tmap.remove(b);\n    \t\t\t}\n    \t\t} else {\n    \t\t\tMap.Entry<Integer, Rect> above = map.higherEntry(b);\n    \t\t\tif( above != null && above.getValue().r != r )\n        \t\t\tabove = null;\n    \t\t\trect.r = r;\n    \t\t\tif( below != null ) {\n    \t\t\t\tbelow.getValue().t = t;\n    \t\t\t\tmap.remove(b);\n    \t\t\t\tif( above != null ) {\n    \t\t\t\t\tbelow.getValue().t = above.getValue().t;\n    \t\t\t\t\tmap.remove(above.getKey());\n    \t\t\t\t}\n    \t\t\t} else if( above != null ) {\n    \t\t\t\trect.t = above.getValue().t;\n    \t\t\t\tmap.remove(above.getKey());\n    \t\t\t}\n    \t\t}\n    \t}\n    \treturn map.size() == 1;\n    }\n}\n```",
                "solutionTags": [],
                "code": "```\nclass Solution{\n\tclass Rect {\n\t\tpublic Rect(int t, int r) {\n\t\t\tthis.t = t; this.r = r;\n\t\t}\n\t\tint t;\n\t\tint r;\n\t}\n    public boolean isRectangleCover(int[][] rectangles) {\n    \tArrays.sort(rectangles, new Comparator<int[]>(){\n\t\t\t@Override\n\t\t\tpublic int compare(int[] r0, int[] r1) {\n\t\t\t\tint d = r0[0] - r1[0];\n\t\t\t\tif( d != 0 )\n\t\t\t\t\treturn d;\n\t\t\t\treturn r0[1] - r1[1];\n\t\t\t}\n    \t\t\n    \t});\n    \tint L = rectangles[0][0];\n    \tint B = rectangles[0][1];\n    \tint T = B;\n    \tfor(int[] e : rectangles) {\n    \t\tif( e[0] > L )\n    \t\t\tbreak;\n    \t\tT = Math.max(T, e[3]);\n    \t}\n    \tTreeMap<Integer, Rect> map = new TreeMap<>();\n    \tmap.put(B, new Rect(T, L));\n    \tfor(int[] e : rectangles) {\n    \t\tfinal int l = e[0], b = e[1], r = e[2], t = e[3];\n    \t\tRect rect = map.get(b);\n    \t\tif( rect == null )\n    \t\t\treturn false;\n    \t\tif( rect.t < t || rect.r != l )\n    \t\t\treturn false;\n    \t\tMap.Entry<Integer, Rect> below = map.lowerEntry(b);\n    \t\tif( below != null && below.getValue().r != r )\n    \t\t\tbelow = null;\n    \t\tif( t < rect.t ) {\n\t\t\t\tmap.put(t, new Rect(rect.t, rect.r));\n    \t\t\tif( below == null ) {\n    \t\t\t\trect.t = t;\n    \t\t\t\trect.r = r;\n    \t\t\t}\n    \t\t\telse {\n    \t\t\t\tbelow.getValue().t = t;\n    \t\t\t\tmap.remove(b);\n    \t\t\t}\n    \t\t} else {\n    \t\t\tMap.Entry<Integer, Rect> above = map.higherEntry(b);\n    \t\t\tif( above != null && above.getValue().r != r )\n        \t\t\tabove = null;\n    \t\t\trect.r = r;\n    \t\t\tif( below != null ) {\n    \t\t\t\tbelow.getValue().t = t;\n    \t\t\t\tmap.remove(b);\n    \t\t\t\tif( above != null ) {\n    \t\t\t\t\tbelow.getValue().t = above.getValue().t;\n    \t\t\t\t\tmap.remove(above.getKey());\n    \t\t\t\t}\n    \t\t\t} else if( above != null ) {\n    \t\t\t\trect.t = above.getValue().t;\n    \t\t\t\tmap.remove(above.getKey());\n    \t\t\t}\n    \t\t}\n    \t}\n    \treturn map.size() == 1;\n    }\n}\n```",
                "codeTag": "Java"
            },
            {
                "id": 111903,
                "title": "counting-corners-and-checking-overlapping-cases-java-o-n-solution",
                "content": "construct a map of x -> (y -> relative coordinates). Each (x, y) pair has only top right, top left, down right, down left (in below code: 2*i + 1=>1,3,5,7) 4 choices. \\n\\n1) If it has the same coordinates for more than once, then there is an overlap;\\n2) If it appears to have only 3 coordinates, it means there is a concave and so it can not be a rectangle. \\n\\nIf it has only 1 coordinates, we put the pair into final corner candidate set. Finally we need to check whether the area size is the same by putting all rectangles together and by constructing from our corner points. If not then there is overlap.\\n\\n```\\nclass Solution {\\n    public boolean isRectangleCover(int[][] rectangles) {\\n        \\n        Map<Integer, Map<Integer, List<Integer>>> map = new HashMap<>(); // x -> (y -> coordinate position)\\n        int area = 0;\\n        for(int[] rec: rectangles) {\\n            for(int i: Arrays.asList(0, 2)) {\\n                if(!map.containsKey(rec[i])) map.put(rec[i], new HashMap<>());\\n        \\n                if(!map.get(rec[i]).containsKey(rec[1])) map.get(rec[i]).put(rec[1], new ArrayList<Integer>());\\n                if(map.get(rec[i]).get(rec[1]).contains(2*i + 1)) return false;\\n                map.get(rec[i]).get(rec[1]).add(2*i + 1);\\n            \\n                if(!map.get(rec[i]).containsKey(rec[3])) map.get(rec[i]).put(rec[3], new ArrayList<Integer>());\\n                if(map.get(rec[i]).get(rec[3]).contains(2*i + 3)) return false;\\n                map.get(rec[i]).get(rec[3]).add(2*i + 3);\\n            }\\n            area += (rec[2] - rec[0]) * (rec[3] - rec[1]);\\n        }\\n        //checking\\n        Set<Integer> set = new HashSet<Integer>();\\n        int xcount = 0;\\n        Set<Integer> xset = new HashSet<Integer>();\\n        Set<Integer> yset = new HashSet<Integer>();\\n        for(Map.Entry<Integer, Map<Integer, List<Integer>>> entry: map.entrySet()) {\\n            for(Map.Entry<Integer, List<Integer>> ypoints: entry.getValue().entrySet()) {\\n                int ycount = ypoints.getValue().size();\\n                if(ycount == 3) return false;\\n                if(ycount == 2 || ycount == 4) continue;\\n                if(xcount == 4) return false;\\n                xcount ++;\\n                xset.add(entry.getKey());\\n                yset.add(ypoints.getKey());\\n                if(!set.add(ypoints.getKey())) set.remove(ypoints.getKey());\\n            }\\n        }\\n        int x = 0, y = 0, c1 = 0, c2 = 0;\\n        for(int x1: xset) {\\n            x = c1 == 0? x1: Math.abs(x - x1);\\n            c1 ++;\\n        }\\n        for(int y1: yset) {\\n            y = c2 == 0? y1: Math.abs(y - y1);\\n            c2 ++;\\n        }\\n        return set.size() == 0 && area == x * y;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isRectangleCover(int[][] rectangles) {\\n        \\n        Map<Integer, Map<Integer, List<Integer>>> map = new HashMap<>(); // x -> (y -> coordinate position)\\n        int area = 0;\\n        for(int[] rec: rectangles) {\\n            for(int i: Arrays.asList(0, 2)) {\\n                if(!map.containsKey(rec[i])) map.put(rec[i], new HashMap<>());\\n        \\n                if(!map.get(rec[i]).containsKey(rec[1])) map.get(rec[i]).put(rec[1], new ArrayList<Integer>());\\n                if(map.get(rec[i]).get(rec[1]).contains(2*i + 1)) return false;\\n                map.get(rec[i]).get(rec[1]).add(2*i + 1);\\n            \\n                if(!map.get(rec[i]).containsKey(rec[3])) map.get(rec[i]).put(rec[3], new ArrayList<Integer>());\\n                if(map.get(rec[i]).get(rec[3]).contains(2*i + 3)) return false;\\n                map.get(rec[i]).get(rec[3]).add(2*i + 3);\\n            }\\n            area += (rec[2] - rec[0]) * (rec[3] - rec[1]);\\n        }\\n        //checking\\n        Set<Integer> set = new HashSet<Integer>();\\n        int xcount = 0;\\n        Set<Integer> xset = new HashSet<Integer>();\\n        Set<Integer> yset = new HashSet<Integer>();\\n        for(Map.Entry<Integer, Map<Integer, List<Integer>>> entry: map.entrySet()) {\\n            for(Map.Entry<Integer, List<Integer>> ypoints: entry.getValue().entrySet()) {\\n                int ycount = ypoints.getValue().size();\\n                if(ycount == 3) return false;\\n                if(ycount == 2 || ycount == 4) continue;\\n                if(xcount == 4) return false;\\n                xcount ++;\\n                xset.add(entry.getKey());\\n                yset.add(ypoints.getKey());\\n                if(!set.add(ypoints.getKey())) set.remove(ypoints.getKey());\\n            }\\n        }\\n        int x = 0, y = 0, c1 = 0, c2 = 0;\\n        for(int x1: xset) {\\n            x = c1 == 0? x1: Math.abs(x - x1);\\n            c1 ++;\\n        }\\n        for(int y1: yset) {\\n            y = c2 == 0? y1: Math.abs(y - y1);\\n            c2 ++;\\n        }\\n        return set.size() == 0 && area == x * y;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 87182,
                "title": "share-my-sweeping-line-solution-accidentally-better-than-100",
                "content": "Here is the idea:\\nWe sweep line from smallest x to largest x. We treat all the lines as intervals. When we reach end of any rectangle, it actually means we are removing an interval. If that is inside the big rectangle, that means some other small rectangles should begin with the ended interval. \\nSo, given x, there is a bunch of small intervals that end there, we merge them into *remove*. If it is valid big rectangle, there should be a bunch of small intervals start at that x. If we merge them into *insert*. Then, these 2 vectors should be same. \\nOf course, the 1st intervals should always be inserting interval, and the last intervals should always be the removing intervals. \\n```\\nclass Solution {\\npublic:\\n    bool isRectangleCover(vector<vector<int>>& rectangles) {\\n        map<int, vector<pair<int, int>>> insertIntervals;\\n        map<int, vector<pair<int, int>>> removeIntervals;\\n        for(int i=0; i<rectangles.size(); i++){\\n            insertIntervals[rectangles[i][0]].emplace_back(rectangles[i][1], rectangles[i][3]);\\n            removeIntervals[rectangles[i][2]].emplace_back(rectangles[i][1], rectangles[i][3]);\\n        }\\n\\n        auto it1 = insertIntervals.begin();\\n        vector<pair<int,int>> tI;\\n        if (merge(it1->second, tI) == false || tI.size()>1)\\n            return false; //check the 1st line, return false if we have more than 1 intervals. \\n        insertIntervals.erase(it1);  //erase the first line. \\n        \\n        auto it2 = removeIntervals.begin();\\n        while(it2 != removeIntervals.end()){\\n            /* Idea: when we scan and we remove a bunch of intervals, we need to insert a bunch of intervals, they should be same. Only for the last set of removeIntervals there is no insertInterval*/\\n            vector<pair<int, int>> remove;\\n            if(merge(it2->second, remove) == false)\\n                return false;\\n            if(insertIntervals.find(it2->first) == insertIntervals.end()){\\n                if(removeIntervals.size()!=1) //only for the last interval the insertIntervals will not find it. \\n                    return false;\\n            }\\n            else{//insertIntervals has it, it should be same as removeIntervals\\n                vector<pair<int, int>> insert;\\n                if(merge(insertIntervals[it2->first], insert) == false)\\n                    return false;\\n                if(remove != insert) //compare vectors directly.\\n                    return false;\\n                insertIntervals.erase(it2->first);\\n            }\\n            removeIntervals.erase(it2);\\n            it2 = removeIntervals.begin();\\n            //clear the removeIntervals 1 by 1.\\n        }\\n        //the insertIntervals should be empty, because each removeIntervals should remove 1 interval\\n        return insertIntervals.size()==0;\\n    }\\n    \\n    struct less_than_key\\n    {\\n        inline bool operator() (const pair<int,int>& struct1, const pair<int,int>& struct2)\\n        {\\n            return (struct1.first < struct2.first);\\n        }\\n    };\\n    \\n    /* Merge vector of pair into another vector of pair. They should be adjacent but no intersection */\\n    bool merge(vector<pair<int, int>> &pairs, vector<pair<int, int>> &tI){\\n        std::sort(pairs.begin(), pairs.end(), less_than_key());\\n        int curStart = pairs[0].first;\\n        for(int i=1; i<pairs.size(); i++){\\n            if(pairs[i].first < pairs[i-1].second){//there is intersection, return false\\n                return false;\\n            }\\n            if(pairs[i].first > pairs[i-1].second){\\n                tI.emplace_back(curStart, pairs[i-1].second);\\n                curStart = pairs[i].first;\\n            }\\n        }\\n        tI.emplace_back(curStart, pairs[pairs.size()-1].second);\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isRectangleCover(vector<vector<int>>& rectangles) {\\n        map<int, vector<pair<int, int>>> insertIntervals;\\n        map<int, vector<pair<int, int>>> removeIntervals;\\n        for(int i=0; i<rectangles.size(); i++){\\n            insertIntervals[rectangles[i][0]].emplace_back(rectangles[i][1], rectangles[i][3]);\\n            removeIntervals[rectangles[i][2]].emplace_back(rectangles[i][1], rectangles[i][3]);\\n        }\\n\\n        auto it1 = insertIntervals.begin();\\n        vector<pair<int,int>> tI;\\n        if (merge(it1->second, tI) == false || tI.size()>1)\\n            return false; //check the 1st line, return false if we have more than 1 intervals. \\n        insertIntervals.erase(it1);  //erase the first line. \\n        \\n        auto it2 = removeIntervals.begin();\\n        while(it2 != removeIntervals.end()){\\n            /* Idea: when we scan and we remove a bunch of intervals, we need to insert a bunch of intervals, they should be same. Only for the last set of removeIntervals there is no insertInterval*/\\n            vector<pair<int, int>> remove;\\n            if(merge(it2->second, remove) == false)\\n                return false;\\n            if(insertIntervals.find(it2->first) == insertIntervals.end()){\\n                if(removeIntervals.size()!=1) //only for the last interval the insertIntervals will not find it. \\n                    return false;\\n            }\\n            else{//insertIntervals has it, it should be same as removeIntervals\\n                vector<pair<int, int>> insert;\\n                if(merge(insertIntervals[it2->first], insert) == false)\\n                    return false;\\n                if(remove != insert) //compare vectors directly.\\n                    return false;\\n                insertIntervals.erase(it2->first);\\n            }\\n            removeIntervals.erase(it2);\\n            it2 = removeIntervals.begin();\\n            //clear the removeIntervals 1 by 1.\\n        }\\n        //the insertIntervals should be empty, because each removeIntervals should remove 1 interval\\n        return insertIntervals.size()==0;\\n    }\\n    \\n    struct less_than_key\\n    {\\n        inline bool operator() (const pair<int,int>& struct1, const pair<int,int>& struct2)\\n        {\\n            return (struct1.first < struct2.first);\\n        }\\n    };\\n    \\n    /* Merge vector of pair into another vector of pair. They should be adjacent but no intersection */\\n    bool merge(vector<pair<int, int>> &pairs, vector<pair<int, int>> &tI){\\n        std::sort(pairs.begin(), pairs.end(), less_than_key());\\n        int curStart = pairs[0].first;\\n        for(int i=1; i<pairs.size(); i++){\\n            if(pairs[i].first < pairs[i-1].second){//there is intersection, return false\\n                return false;\\n            }\\n            if(pairs[i].first > pairs[i-1].second){\\n                tI.emplace_back(curStart, pairs[i-1].second);\\n                curStart = pairs[i].first;\\n            }\\n        }\\n        tI.emplace_back(curStart, pairs[pairs.size()-1].second);\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 87190,
                "title": "short-c-sweep-line",
                "content": "```\\n    bool isRectangleCover(vector<vector<int>>& rectangles) {\\n        vector<vector<int>> edges;\\n        int minx=INT_MAX, miny=INT_MAX, maxx=INT_MIN, maxy=INT_MIN;\\n        int sum = 0;\\n        for(auto &a:rectangles) {\\n            edges.push_back({a[0],1,a[1],a[3]});\\n            edges.push_back({a[2],-1,a[1],a[3]});\\n            sum+=(a[2]-a[0])*(a[3]-a[1]);\\n            minx = min(minx, a[0]);\\n            maxx = max(maxx, a[2]);\\n            miny = min(miny, a[1]);\\n            maxy = max(maxy, a[3]);\\n        }\\n        sort(edges.begin(), edges.end());\\n        set<pair<int,int>> st;\\n        for(auto &a:edges) {\\n            if(a[1]<0) st.erase({a[2],a[3]});\\n            else {\\n                auto it = st.lower_bound({a[2],a[3]});\\n                if(it!=st.end() && it->first<a[3]) return false;\\n                if(it!=st.begin() && (--it)->second>a[2]) return false;\\n                st.insert({a[2],a[3]});\\n            }\\n        }\\n        return sum==(maxy-miny)*(maxx-minx);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    bool isRectangleCover(vector<vector<int>>& rectangles) {\\n        vector<vector<int>> edges;\\n        int minx=INT_MAX, miny=INT_MAX, maxx=INT_MIN, maxy=INT_MIN;\\n        int sum = 0;\\n        for(auto &a:rectangles) {\\n            edges.push_back({a[0],1,a[1],a[3]});\\n            edges.push_back({a[2],-1,a[1],a[3]});\\n            sum+=(a[2]-a[0])*(a[3]-a[1]);\\n            minx = min(minx, a[0]);\\n            maxx = max(maxx, a[2]);\\n            miny = min(miny, a[1]);\\n            maxy = max(maxy, a[3]);\\n        }\\n        sort(edges.begin(), edges.end());\\n        set<pair<int,int>> st;\\n        for(auto &a:edges) {\\n            if(a[1]<0) st.erase({a[2],a[3]});\\n            else {\\n                auto it = st.lower_bound({a[2],a[3]});\\n                if(it!=st.end() && it->first<a[3]) return false;\\n                if(it!=st.begin() && (--it)->second>a[2]) return false;\\n                st.insert({a[2],a[3]});\\n            }\\n        }\\n        return sum==(maxy-miny)*(maxx-minx);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 87212,
                "title": "java-o-n-solution-updated",
                "content": "*Original post was not correct. See reply below for a corrected solution.*\\n<hr>\\nThe idea is that, a perfect **m** x **n** rectangle can resemble integer 1 - m*n. The small pieces of rectangles need to sum up to exact the same number, just as one single rectangle does. \\n\\nBoth ```sum``` methods below are O(1), so the whole solution is O(n) time. \\n\\nNote that I didn't consider integer overflow (the sum could be quite big). The solution can pass the current OJ, and it can instead use a float otherwise. \\n\\n```\\npublic class Solution {\\n    \\n    int m=0, n=0;\\n    \\n    public boolean isRectangleCover(int[][] rectangles) {\\n        // finding bottom-left and top-right most corners\\n        int minx = Integer.MAX_VALUE, miny = Integer.MAX_VALUE, // bottom-left most \\n            maxx = Integer.MIN_VALUE, maxy = Integer.MIN_VALUE; // top-right most\\n            \\n        for (int[] rec : rectangles) {\\n            minx = Math.min(minx, rec[0]);\\n            miny = Math.min(miny, rec[1]);\\n            maxx = Math.max(maxx, rec[2]);\\n            maxy = Math.max(maxy, rec[3]);\\n        }\\n        \\n        m = maxx-minx; n = maxy-miny;\\n        \\n        int count = 0;\\n        for (int[] rec : rectangles) {\\n            count += sum(rec[0]-minx, rec[1]-miny, rec[2]-minx, rec[3]-miny);\\n        }\\n        \\n        return count == sum(0, 0, m, n);\\n    }\\n    \\n    private int sum(int i1, int j1, int i2, int j2) { // bottom-left (i1, j1), top-right (i2, j2)\\n        return sum(i2, j2) - sum(i1, j2) - sum(i2, j1) + sum(i1, j1);\\n    }\\n    \\n    private int sum(int i, int j) { // top-right (i, j)\\n        return (1 + i*j) * i*j / 2;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```sum```\n```\\npublic class Solution {\\n    \\n    int m=0, n=0;\\n    \\n    public boolean isRectangleCover(int[][] rectangles) {\\n        // finding bottom-left and top-right most corners\\n        int minx = Integer.MAX_VALUE, miny = Integer.MAX_VALUE, // bottom-left most \\n            maxx = Integer.MIN_VALUE, maxy = Integer.MIN_VALUE; // top-right most\\n            \\n        for (int[] rec : rectangles) {\\n            minx = Math.min(minx, rec[0]);\\n            miny = Math.min(miny, rec[1]);\\n            maxx = Math.max(maxx, rec[2]);\\n            maxy = Math.max(maxy, rec[3]);\\n        }\\n        \\n        m = maxx-minx; n = maxy-miny;\\n        \\n        int count = 0;\\n        for (int[] rec : rectangles) {\\n            count += sum(rec[0]-minx, rec[1]-miny, rec[2]-minx, rec[3]-miny);\\n        }\\n        \\n        return count == sum(0, 0, m, n);\\n    }\\n    \\n    private int sum(int i1, int j1, int i2, int j2) { // bottom-left (i1, j1), top-right (i2, j2)\\n        return sum(i2, j2) - sum(i1, j2) - sum(i2, j1) + sum(i1, j1);\\n    }\\n    \\n    private int sum(int i, int j) { // top-right (i, j)\\n        return (1 + i*j) * i*j / 2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 87217,
                "title": "my-o-n-python-solution",
                "content": "```\\nclass Solution(object):\\n    def isRectangleCover(self, rectangles):\\n        if not rectangles: return False\\n        directions = collections.defaultdict(lambda: [0, 0, 0, 0])\\n        left, right, high, low = rectangles[0][0], rectangles[0][2], rectangles[0][3], rectangles[0][1]\\n        area = 0\\n        for x1, y1, x2, y2 in rectangles:\\n            left = min(left, x1)\\n            right = max(right,x2)\\n            high = max(high, y2)\\n            low = min(low, y1)\\n            area += (y2 - y1)*(x2 - x1)\\n            directions[(x1, y1)][0] += 1\\n            directions[(x1, y2)][1] += 1\\n            directions[(x2, y2)][2] += 1\\n            directions[(x2, y1)][3] += 1\\n            \\n        if area != (right - left) * (high - low):\\n            return False\\n        for key in directions:\\n            if key not in [(left, low), (left, high), (right, low), (right, high)] and directions[key] not in [[1, 1, 1, 1], [1, 1, 0, 0], [0, 1, 1, 0], [0, 0, 1, 1], [1, 0, 0, 1]]:\\n                return False\\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def isRectangleCover(self, rectangles):\\n        if not rectangles: return False\\n        directions = collections.defaultdict(lambda: [0, 0, 0, 0])\\n        left, right, high, low = rectangles[0][0], rectangles[0][2], rectangles[0][3], rectangles[0][1]\\n        area = 0\\n        for x1, y1, x2, y2 in rectangles:\\n            left = min(left, x1)\\n            right = max(right,x2)\\n            high = max(high, y2)\\n            low = min(low, y1)\\n            area += (y2 - y1)*(x2 - x1)\\n            directions[(x1, y1)][0] += 1\\n            directions[(x1, y2)][1] += 1\\n            directions[(x2, y2)][2] += 1\\n            directions[(x2, y1)][3] += 1\\n            \\n        if area != (right - left) * (high - low):\\n            return False\\n        for key in directions:\\n            if key not in [(left, low), (left, high), (right, low), (right, high)] and directions[key] not in [[1, 1, 1, 1], [1, 1, 0, 0], [0, 1, 1, 0], [0, 0, 1, 1], [1, 0, 0, 1]]:\\n                return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 87221,
                "title": "o-n-72-ile",
                "content": "1) There should be exactly 4 points that occur once.\\n2) The area should make sense. (overlap cases)\\n3) Same rectangle should not occur more than once. ( this one fooled my program once. because all points are same, it bypasses case 1, and since the area is added twice, the missing portions get accounted for.)\\n```\\nclass Solution {\\npublic:\\nstruct pairhash {\\n    inline long long operator()(const std::pair<int,int> & v) const {\\n        return v.first*31+v.second;\\n    }\\n};\\n    \\n    bool isRectangleCover(vector<vector<int>>& rectangles) {\\n        unordered_map<pair<int,int>, int,pairhash>umap;\\n        int totalA = 0;\\n        auto prev = vector<int>();\\n        //find points and add.\\n        for(auto &x : rectangles)\\n        {\\n            totalA += area(x); //add to the total area.\\n\\n            if(x == prev) return false; // check if the rectangle repeated. If it did, return false.\\n            prev = x;\\n            //cout << area(x) << endl;\\n            searchAndAdd(x[0],x[1],umap);\\n            searchAndAdd(x[2],x[3],umap);\\n            searchAndAdd(x[2],x[1],umap);\\n            searchAndAdd(x[0],x[3],umap);\\n\\n        }\\n        vector<pair<int,int>> sol;\\n        for(auto &x : umap)\\n        {\\n            if(x.second == 2)sol.push_back(x.first); //iterate the map once. and pull out the points which occured once.\\n        }\\n        if(sol.size() != 4) return false;\\n        sort(sol.begin(), sol.end());\\n        vector<int>a{sol[0].first,sol[0].second,sol[3].first,sol[3].second};\\n        auto fArea = area(a);\\n\\n        if(totalA != fArea) return false;\\n        return true;\\n    }\\n    inline int area(vector<int>&x)\\n    {\\n        return abs((x[0] - x[2]) * (x[3] - x[1]));\\n    }\\n    void searchAndAdd(int &x, int &y,  unordered_map<pair<int,int>, int, pairhash> &umap)\\n    {\\n//count the instances of the coordinate.\\n        auto a = make_pair(x,y);\\n        if(umap.find(a) != umap.end()) // contains! it.\\n        {\\n            umap[a] += 1;\\n        }\\n        else\\n        {\\n            umap[a] = 2;\\n        }\\n    }\\n    \\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\nstruct pairhash {\\n    inline long long operator()(const std::pair<int,int> & v) const {\\n        return v.first*31+v.second;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 87237,
                "title": "perfect-rectangle",
                "content": "class Solution {\\npublic:\\n    bool isRectangleCover(vector<vector<int>>& rectangles) {\\n        \\n        \\n        \\n        bool flag = 0;\\n\\tbool temp_flag = 1;\\n\\tint count = rectangles.size();\\n\\tint total_area = 0;\\n\\tint temp_area = 0;\\n\\tint left_x = rectangles[0][0], left_y = rectangles[0][1], right_x = rectangles[0][2], right_y = rectangles[0][3];\\n\\t//int temp_x = rectangles[0][2], temp_y = rectangles[0][3];\\n\\tint temp_x = 0, temp_y = 0;\\n\\tif (count>1){\\n\\n\\t\\tfor (int i = 0; i < count; i++){\\n\\t\\t\\tif (temp_flag){\\n\\t\\t\\t\\t//if (rectangles[i][0] < temp_x && temp_x < rectangles[i][2]) a = 1;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tfor (int j = 0; j < count; j++){\\n\\t\\t\\t\\t\\tif (i != j){\\n\\t\\t\\t\\t\\t\\tif ((rectangles[j][0] < rectangles[i][2] && rectangles[i][2] <= rectangles[j][2]) && (rectangles[j][1] < rectangles[i][3] && rectangles[i][3] <= rectangles[j][3])) temp_flag = 0;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\n\\n\\n\\t\\t\\t\\ttemp_area += (rectangles[i][2] - rectangles[i][0])*(rectangles[i][3] - rectangles[i][1]);\\n\\t\\t\\t\\tif (rectangles[i][0] < left_x) left_x = rectangles[i][0];//\\u5de6\\u4e0bx\\n\\t\\t\\t\\t//else left_x = rectangles[i + 1][0];\\n\\t\\t\\t\\tif (rectangles[i][1] < left_y) left_y = rectangles[i][1];//\\u5de6\\u4e0by\\n\\t\\t\\t\\t//else left_y = rectangles[i + 1][1];\\n\\t\\t\\t\\tif (rectangles[i][2] > right_x) right_x = rectangles[i][2];//\\u53f3\\u4e0ax\\n\\t\\t\\t\\t//else right_x = rectangles[i + 1][2];\\n\\t\\t\\t\\tif (rectangles[i][3] > right_y) right_y = rectangles[i][3];//\\u53f3\\u4e0ay\\n\\t\\t\\t\\t//else right_y = rectangles[i + 1][3];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t//temp_area += (rectangles[count-1][2] - rectangles[count-1][0])*(rectangles[count-1][3] - rectangles[count-1][1]);\\n\\t\\ttotal_area = (right_x - left_x)*(right_y - left_y);\\n\\t}\\n\\telse if (count == 1) flag = 1;\\n\\n\\n\\tif (total_area == temp_area && temp_flag == 1) flag = 1;\\n\\n\\treturn flag;\\n        \\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool isRectangleCover(vector<vector<int>>& rectangles) {\\n        \\n        \\n        \\n        bool flag = 0;\\n\\tbool temp_flag = 1;\\n\\tint count = rectangles.size();\\n\\tint total_area = 0;\\n\\tint temp_area = 0;\\n\\tint left_x = rectangles[0][0], left_y = rectangles[0][1], right_x = rectangles[0][2], right_y = rectangles[0][3];\\n\\t//int temp_x = rectangles[0][2], temp_y = rectangles[0][3];\\n\\tint temp_x = 0, temp_y = 0;\\n\\tif (count>1){\\n\\n\\t\\tfor (int i = 0; i < count; i++){\\n\\t\\t\\tif (temp_flag){\\n\\t\\t\\t\\t//if (rectangles[i][0] < temp_x && temp_x < rectangles[i][2]) a = 1;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tfor (int j = 0; j < count; j++){\\n\\t\\t\\t\\t\\tif (i != j){\\n\\t\\t\\t\\t\\t\\tif ((rectangles[j][0] < rectangles[i][2] && rectangles[i][2] <= rectangles[j][2]) && (rectangles[j][1] < rectangles[i][3] && rectangles[i][3] <= rectangles[j][3])) temp_flag = 0;\\n\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 87234,
                "title": "easy-to-understand-o-n-log-n-solution-in-c",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isRectangleCover(vector<vector<int>>& rectangles) {\\n        \\n        sort(rectangles.begin(), rectangles.end());\\n        \\n        int n= rectangles.size();\\n        int x0, y0, x1, y1;\\n        int xmax = INT_MIN, ymax = INT_MIN, xmin = INT_MAX, ymin = INT_MAX;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            xmax = max(xmax, rectangles[i][2]);\\n            ymax = max(ymax, rectangles[i][3]);\\n            xmin = min(xmin, rectangles[i][0]);\\n            ymin = min(ymin, rectangles[i][1]);\\n        }\\n        \\n        int area = 0;\\n        int totalarea = (xmax-xmin)*(ymax-ymin);\\n        \\n        set<pair<int, int>> mymap;\\n        \\n        pair<int, int> p00, p10, p01, p11;\\n        \\n        int i=0;\\n // insert the first rectangle into the set\\n        x0 = rectangles[i][0];\\n        y0 = rectangles[i][1];\\n        x1 = rectangles[i][2];\\n        y1 = rectangles[i][3];\\n        \\n        p00 = make_pair(x0,y0);\\n        p01 = make_pair(x0,y1);\\n        p10 = make_pair(x1,y0);\\n        p11 = make_pair(x1,y1);\\n        \\n        mymap.insert(p00); mymap.insert(p01); mymap.insert(p10); mymap.insert(p11);\\n        area += (x1-x0)*(y1-y0);\\n        \\n        for(i=1;i<n;i++)\\n        {\\n        x0 = rectangles[i][0];\\n        y0 = rectangles[i][1];\\n        x1 = rectangles[i][2];\\n        y1 = rectangles[i][3];\\n        \\n        p00 = make_pair(x0,y0);\\n        p01 = make_pair(x0,y1);\\n        p10 = make_pair(x1,y0);\\n        p11 = make_pair(x1,y1);\\n        \\n        area += (x1-x0)*(y1-y0);\\n        \\n        if(mymap.find(p00) == mymap.end()) return false;\\n        mymap.erase(p00);\\n        if(mymap.find(p01) != mymap.end()) mymap.erase(p01);\\n        else mymap.insert(p01);\\n        if(mymap.find(p10) != mymap.end()) mymap.erase(p10);\\n        else mymap.insert(p10);\\n        if(mymap.find(p11) != mymap.end()) mymap.erase(p11);\\n        else mymap.insert(p11);\\n        }\\n\\n        p00 = make_pair(xmin,ymin);\\n        p01 = make_pair(xmin,ymax);\\n        p10 = make_pair(xmax,ymin);\\n        p11 = make_pair(xmax,ymax);\\n        \\n        if((mymap.find(p00) == mymap.end())or(mymap.find(p01) == mymap.end())) return false;\\n        if((mymap.find(p10) == mymap.end())or(mymap.find(p11) == mymap.end())) return false;\\n\\n        return ((mymap.size() == 4) and (area == totalarea));\\n        \\n    }\\n};\\n```\\nThe main idea is that we maintain the boundary coordinates of the region formed so far in a set data structure. We can sort the array to see the operations more clearly. Whenever we add a new rectangle, we need to check that its bottom left vertex matches with a vertex in our set and then we remove it from the set.If it does not match we directly return false. We also need to check for other vertices and remove them if they exist or add them to the set if they don't.\\n\\nFinally, after we processes all vertices we need to check if we are left with a rectangle. In order for this to happen, the set size must be exactly 4. Our algorithm does not handle the cases when there is an overlap, but a simple area counter can detect such cases. We now have a complete O(n log(n)) algorithm.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isRectangleCover(vector<vector<int>>& rectangles) {\\n        \\n        sort(rectangles.begin(), rectangles.end());\\n        \\n        int n= rectangles.size();\\n        int x0, y0, x1, y1;\\n        int xmax = INT_MIN, ymax = INT_MIN, xmin = INT_MAX, ymin = INT_MAX;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            xmax = max(xmax, rectangles[i][2]);\\n            ymax = max(ymax, rectangles[i][3]);\\n            xmin = min(xmin, rectangles[i][0]);\\n            ymin = min(ymin, rectangles[i][1]);\\n        }\\n        \\n        int area = 0;\\n        int totalarea = (xmax-xmin)*(ymax-ymin);\\n        \\n        set<pair<int, int>> mymap;\\n        \\n        pair<int, int> p00, p10, p01, p11;\\n        \\n        int i=0;\\n // insert the first rectangle into the set\\n        x0 = rectangles[i][0];\\n        y0 = rectangles[i][1];\\n        x1 = rectangles[i][2];\\n        y1 = rectangles[i][3];\\n        \\n        p00 = make_pair(x0,y0);\\n        p01 = make_pair(x0,y1);\\n        p10 = make_pair(x1,y0);\\n        p11 = make_pair(x1,y1);\\n        \\n        mymap.insert(p00); mymap.insert(p01); mymap.insert(p10); mymap.insert(p11);\\n        area += (x1-x0)*(y1-y0);\\n        \\n        for(i=1;i<n;i++)\\n        {\\n        x0 = rectangles[i][0];\\n        y0 = rectangles[i][1];\\n        x1 = rectangles[i][2];\\n        y1 = rectangles[i][3];\\n        \\n        p00 = make_pair(x0,y0);\\n        p01 = make_pair(x0,y1);\\n        p10 = make_pair(x1,y0);\\n        p11 = make_pair(x1,y1);\\n        \\n        area += (x1-x0)*(y1-y0);\\n        \\n        if(mymap.find(p00) == mymap.end()) return false;\\n        mymap.erase(p00);\\n        if(mymap.find(p01) != mymap.end()) mymap.erase(p01);\\n        else mymap.insert(p01);\\n        if(mymap.find(p10) != mymap.end()) mymap.erase(p10);\\n        else mymap.insert(p10);\\n        if(mymap.find(p11) != mymap.end()) mymap.erase(p11);\\n        else mymap.insert(p11);\\n        }\\n\\n        p00 = make_pair(xmin,ymin);\\n        p01 = make_pair(xmin,ymax);\\n        p10 = make_pair(xmax,ymin);\\n        p11 = make_pair(xmax,ymax);\\n        \\n        if((mymap.find(p00) == mymap.end())or(mymap.find(p01) == mymap.end())) return false;\\n        if((mymap.find(p10) == mymap.end())or(mymap.find(p11) == mymap.end())) return false;\\n\\n        return ((mymap.size() == 4) and (area == totalarea));\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 87222,
                "title": "java-use-sort-o-nlogn-time-complexity-with-detailed-explanation",
                "content": "Hope it helpful!\\n\\nThe rough idea includes two steps:\\n1) Check Overlapping of all rectangles, if overlapping, `return false`\\n2) no overlapping, find the `bottom-left point`t and `up-right point` of the possible biggest merged rectangle. We can calculate its `area`.\\n   if `area == sum(all input rectangles' area)`, return `true`. Or `false`.\\n\\nLet's to explain the first step, How to check overlapping?\\nWe need to check `x-axis` and `y-axis` separately. \\nFor `x-aixs`: \\nsort the input in `ascending` order according to the `left-line` of rectangle. Then if `current rectangle's left line < pre-rectangles' right line` && `((current rectangle's up-line < pre-rectangles' up-line &&  current rectangle's up-line > pre-rectangles' bottom-line) || (current rectangle's bottom-line < pre-rectangles' up-line &&  current rectangle's bottom-line > pre-rectangles' bottom-line))`(this condition checks the situation that current rectangle on top of previous one or below bottom of previous one), it means current rectangle `overlaps `previous one.\\n\\nFor `y-axis', it's the same as `x-axis`:\\n\\nsort the input in `ascending` order according to the `bottom-line` of rectangle. Then if `current rectangle's bottom line < pre-rectangles' up line` && `((current rectangle's left-line < pre-rectangles' right-line &&  current rectangle's left-line > pre-rectangles' left-line) || (current rectangle's right-line < pre-rectangles' right-line &&  current rectangle's right-line > pre-rectangles' left-line))`(this condition checks the situation that current rectangle on left of previous one or on right of previous one), it means current rectangle `overlaps` previous one.\\n\\nThe second Step:\\nMost important thing is to find left-bottom point and up-right point.\\nWe need to find four points at first: \\nleft-most, bottom-most, right-most, up-most\\nThe `left-most` and `bottom-most` must be the same point, and The `right-most` and `up-most` must be the same point. If not, it can not be a perfect rectangle.\\n\\n\\n   ```\\npublic boolean isRectangleCover(int[][] rectangles) {\\n        if (rectangles == null || rectangles.length == 0) {\\n            return false;\\n        }\\n        int n = rectangles.length;\\n        List<int[]> list = new ArrayList<>();\\n        for (int[] rec: rectangles) {\\n            list.add(rec);\\n        }\\n        Collections.sort(list, new Comparator<int[]>() { // sort list to check x-axis\\n            @Override\\n            public int compare(int[] o1, int[] o2) {\\n                return o1[0] - o2[0];\\n            }\\n        });\\n        for (int i = 1; i < list.size(); i++) {\\n            int[] pre = list.get(i - 1);\\n            int[] cur = list.get(i);\\n            if (cur[0] < pre[2] && ((cur[1] < pre[3] && cur[1] > pre[1]) || (cur[3] < pre[3] && cur[3] > pre[1]))) { // overlap\\n                return false;\\n            }\\n        }\\n        Collections.sort(list, new Comparator<int[]>() { // sort list to check y-axis\\n            @Override\\n            public int compare(int[] o1, int[] o2) {\\n                return o1[1] - o2[1];\\n            }\\n        });\\n        long area = 0;\\n        int[] leftPoint = {Integer.MAX_VALUE, Integer.MAX_VALUE};\\n        int[] bottomPoint = {Integer.MAX_VALUE, Integer.MAX_VALUE};\\n        int[] rightPoint = {Integer.MIN_VALUE, Integer.MIN_VALUE};\\n        int[] upPoint = {Integer.MIN_VALUE, Integer.MIN_VALUE};\\n\\n        int[] pre = new int[4];\\n        for (int i = 0; i < list.size(); i++) { // we find four points when we check overlapping\\n            int[] cur = list.get(i);\\n            if (i > 0 && cur[1] < pre[3] && ((cur[0] < pre[2] && cur[0] > pre[0]) || (cur[2] < pre[2] && cur[2] > pre[0]))) { // overlap\\n                return false;\\n            }\\n            int[] rec = cur;\\n            if (rec[0] < leftPoint[0] || (rec[0] == leftPoint[0] && rec[1] < leftPoint[1])) {\\n                leftPoint = new int[] {rec[0], rec[1]};\\n            }\\n            if (rec[1] < bottomPoint[1] || (rec[1] == bottomPoint[1] && rec[0] < bottomPoint[0])) {\\n                bottomPoint = new int[] {rec[0], rec[1]};\\n            }\\n            if (rec[2] > rightPoint[0] || (rec[2] == rightPoint[0] && rec[3] > rightPoint[1])) {\\n\\n                rightPoint = new int[] {rec[2], rec[3]};\\n            }\\n            if (rec[3] > upPoint[1] || (rec[3] == upPoint[1] && rec[2] > upPoint[0])) {\\n                upPoint = new int[] {rec[2], rec[3]};\\n            }\\n            area += (rec[3] - rec[1]) * (rec[2] - rec[0]);\\n            pre = cur;\\n        }\\n\\n        if (leftPoint[0] != bottomPoint[0] || leftPoint[1] != bottomPoint[1] || rightPoint[0] != upPoint[0] || rightPoint[1] != upPoint[1]) {\\n//check left point == bottom point && up point == right point\\n            return false;\\n        }\\n\\n// check area\\n        return area == (long) (rightPoint[1] - leftPoint[1]) * (long) (rightPoint[0] - leftPoint[0]);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic boolean isRectangleCover(int[][] rectangles) {\\n        if (rectangles == null || rectangles.length == 0) {\\n            return false;\\n        }\\n        int n = rectangles.length;\\n        List<int[]> list = new ArrayList<>();\\n        for (int[] rec: rectangles) {\\n            list.add(rec);\\n        }\\n        Collections.sort(list, new Comparator<int[]>() { // sort list to check x-axis\\n            @Override\\n            public int compare(int[] o1, int[] o2) {\\n                return o1[0] - o2[0];\\n            }\\n        });\\n        for (int i = 1; i < list.size(); i++) {\\n            int[] pre = list.get(i - 1);\\n            int[] cur = list.get(i);\\n            if (cur[0] < pre[2] && ((cur[1] < pre[3] && cur[1] > pre[1]) || (cur[3] < pre[3] && cur[3] > pre[1]))) { // overlap\\n                return false;\\n            }\\n        }\\n        Collections.sort(list, new Comparator<int[]>() { // sort list to check y-axis\\n            @Override\\n            public int compare(int[] o1, int[] o2) {\\n                return o1[1] - o2[1];\\n            }\\n        });\\n        long area = 0;\\n        int[] leftPoint = {Integer.MAX_VALUE, Integer.MAX_VALUE};\\n        int[] bottomPoint = {Integer.MAX_VALUE, Integer.MAX_VALUE};\\n        int[] rightPoint = {Integer.MIN_VALUE, Integer.MIN_VALUE};\\n        int[] upPoint = {Integer.MIN_VALUE, Integer.MIN_VALUE};\\n\\n        int[] pre = new int[4];\\n        for (int i = 0; i < list.size(); i++) { // we find four points when we check overlapping\\n            int[] cur = list.get(i);\\n            if (i > 0 && cur[1] < pre[3] && ((cur[0] < pre[2] && cur[0] > pre[0]) || (cur[2] < pre[2] && cur[2] > pre[0]))) { // overlap\\n                return false;\\n            }\\n            int[] rec = cur;\\n            if (rec[0] < leftPoint[0] || (rec[0] == leftPoint[0] && rec[1] < leftPoint[1])) {\\n                leftPoint = new int[] {rec[0], rec[1]};\\n            }\\n            if (rec[1] < bottomPoint[1] || (rec[1] == bottomPoint[1] && rec[0] < bottomPoint[0])) {\\n                bottomPoint = new int[] {rec[0], rec[1]};\\n            }\\n            if (rec[2] > rightPoint[0] || (rec[2] == rightPoint[0] && rec[3] > rightPoint[1])) {\\n\\n                rightPoint = new int[] {rec[2], rec[3]};\\n            }\\n            if (rec[3] > upPoint[1] || (rec[3] == upPoint[1] && rec[2] > upPoint[0])) {\\n                upPoint = new int[] {rec[2], rec[3]};\\n            }\\n            area += (rec[3] - rec[1]) * (rec[2] - rec[0]);\\n            pre = cur;\\n        }\\n\\n        if (leftPoint[0] != bottomPoint[0] || leftPoint[1] != bottomPoint[1] || rightPoint[0] != upPoint[0] || rightPoint[1] != upPoint[1]) {\\n//check left point == bottom point && up point == right point\\n            return false;\\n        }\\n\\n// check area\\n        return area == (long) (rightPoint[1] - leftPoint[1]) * (long) (rightPoint[0] - leftPoint[0]);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4095048,
                "title": "linear-time-soln-java-hyder-nabi",
                "content": "# Java Code\\n```\\nclass Solution {\\n    public boolean isRectangleCover(int[][] rectangles) {\\n        Set<String> set = new HashSet<> ();\\n      \\n        int x1 = Integer.MAX_VALUE;\\n        int x2 = Integer.MIN_VALUE;\\n        int x3 = Integer.MAX_VALUE;\\n        int x4 = Integer.MIN_VALUE;\\n\\n        int area = 0;\\n\\n        for(int r[] : rectangles) {\\n          x1 = Math.min(x1, r[0]);\\n          x2 = Math.max(x2, r[2]);\\n          x3 = Math.min(x3, r[1]);\\n          x4 = Math.max(x4, r[3]);\\n\\n          area += (r[2] - r[0]) * (r[3] - r[1]);\\n\\n          String s1 = r[0]+\"\"+r[1];\\n          String s2 = r[0]+\"\"+r[3];\\n          String s3 = r[2]+\"\"+r[3];\\n          String s4 = r[2]+\"\"+r[1];\\n\\n          if(!set.add(s1)){\\n            set.remove(s1);\\n          }\\n          \\n          if(!set.add(s2)){\\n            set.remove(s2);\\n          }\\n\\n          if(!set.add(s3)){\\n            set.remove(s3);\\n          }\\n\\n          if(!set.add(s4)){\\n            set.remove(s4);\\n          }\\n        }\\n\\n        if(!set.contains(x1+\"\"+x3) || !set.contains(x1+\"\"+x4) || !set.contains(x2+\"\"+x3) || !set.contains(x2+\"\"+x4) || set.size() != 4) return false;\\n\\n        return area == (x2-x1) * (x4-x3);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isRectangleCover(int[][] rectangles) {\\n        Set<String> set = new HashSet<> ();\\n      \\n        int x1 = Integer.MAX_VALUE;\\n        int x2 = Integer.MIN_VALUE;\\n        int x3 = Integer.MAX_VALUE;\\n        int x4 = Integer.MIN_VALUE;\\n\\n        int area = 0;\\n\\n        for(int r[] : rectangles) {\\n          x1 = Math.min(x1, r[0]);\\n          x2 = Math.max(x2, r[2]);\\n          x3 = Math.min(x3, r[1]);\\n          x4 = Math.max(x4, r[3]);\\n\\n          area += (r[2] - r[0]) * (r[3] - r[1]);\\n\\n          String s1 = r[0]+\"\"+r[1];\\n          String s2 = r[0]+\"\"+r[3];\\n          String s3 = r[2]+\"\"+r[3];\\n          String s4 = r[2]+\"\"+r[1];\\n\\n          if(!set.add(s1)){\\n            set.remove(s1);\\n          }\\n          \\n          if(!set.add(s2)){\\n            set.remove(s2);\\n          }\\n\\n          if(!set.add(s3)){\\n            set.remove(s3);\\n          }\\n\\n          if(!set.add(s4)){\\n            set.remove(s4);\\n          }\\n        }\\n\\n        if(!set.contains(x1+\"\"+x3) || !set.contains(x1+\"\"+x4) || !set.contains(x2+\"\"+x3) || !set.contains(x2+\"\"+x4) || set.size() != 4) return false;\\n\\n        return area == (x2-x1) * (x4-x3);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4077349,
                "title": "391-perfect-rectangle",
                "content": "# Intuition\\nThe intuition behind the code is to determine if a given list of rectangles can form an exact cover of a rectangular region. To do this, we need to check two conditions:\\n\\nThe total area covered by all the small rectangles should be equal to the area of the overall bounding rectangle.\\nThe corner points of the small rectangles, after eliminating any repeated points, should match the corner points of the expected overall bounding rectangle. \\n\\n# Approach\\nInitialize variables to keep track of the overall bounding rectangle\\'s bottom-left and top-right corners (min_x, min_y, max_x, max_y).\\n\\nInitialize a set called corners to keep track of corner points. For each rectangle, add its four corner points to the set, and if a point is already in the set, remove it (as it will appear an even number of times).\\n\\nCalculate the total area covered by all small rectangles (total_area) by summing up the areas of each rectangle.\\n\\nCalculate the area of the expected overall bounding rectangle (expected_area) based on the min and max coordinates.\\n\\nCreate a set called expected_corners to store the expected corner points of the overall bounding rectangle.\\n\\nCheck if the total area (total_area) matches the expected area (expected_area) and if the remaining corner points in the set corners match the expected corner points in the set expected_corners.\\n\\nReturn True if both conditions are satisfied; otherwise, return False.\\n\\n# Complexity\\n- Time complexity:\\n$$O(N)$$\\n\\n- Space complexity:\\n$$O(N)$$\\n\\n# Code\\n```\\nclass Solution(object):\\n    def isRectangleCover(self, rectangles):\\n        \"\"\"\\n        :type rectangles: List[List[int]]\\n        :rtype: bool\\n        \"\"\"\\n        if not rectangles:\\n            return False\\n\\n        min_x = min(rectangle[0] for rectangle in rectangles)\\n        min_y = min(rectangle[1] for rectangle in rectangles)\\n        max_x = max(rectangle[2] for rectangle in rectangles)\\n        max_y = max(rectangle[3] for rectangle in rectangles)\\n\\n        total_area = 0\\n        corners = set()\\n\\n        for rectangle in rectangles:\\n            total_area += (rectangle[2] - rectangle[0]) * (rectangle[3] - rectangle[1])\\n\\n            # Add the four corner points of each rectangle to the set\\n            corners ^= {(rectangle[0], rectangle[1]), (rectangle[2], rectangle[1]),\\n                        (rectangle[0], rectangle[3]), (rectangle[2], rectangle[3])}\\n\\n        expected_area = (max_x - min_x) * (max_y - min_y)\\n        expected_corners = {(min_x, min_y), (max_x, min_y), (min_x, max_y), (max_x, max_y)}\\n\\n        return total_area == expected_area and corners == expected_corners\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def isRectangleCover(self, rectangles):\\n        \"\"\"\\n        :type rectangles: List[List[int]]\\n        :rtype: bool\\n        \"\"\"\\n        if not rectangles:\\n            return False\\n\\n        min_x = min(rectangle[0] for rectangle in rectangles)\\n        min_y = min(rectangle[1] for rectangle in rectangles)\\n        max_x = max(rectangle[2] for rectangle in rectangles)\\n        max_y = max(rectangle[3] for rectangle in rectangles)\\n\\n        total_area = 0\\n        corners = set()\\n\\n        for rectangle in rectangles:\\n            total_area += (rectangle[2] - rectangle[0]) * (rectangle[3] - rectangle[1])\\n\\n            # Add the four corner points of each rectangle to the set\\n            corners ^= {(rectangle[0], rectangle[1]), (rectangle[2], rectangle[1]),\\n                        (rectangle[0], rectangle[3]), (rectangle[2], rectangle[3])}\\n\\n        expected_area = (max_x - min_x) * (max_y - min_y)\\n        expected_corners = {(min_x, min_y), (max_x, min_y), (min_x, max_y), (max_x, max_y)}\\n\\n        return total_area == expected_area and corners == expected_corners\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4037339,
                "title": "python-o-n-easy-explanation-diagrams-breakdown-by-code-section",
                "content": "(read on a standalone page [here](https://hakanalpay.com/leetcode/391-perfect-rectangle))\\n\\n### Problem Insight:\\n\\n1. The combined area of all small rectangles should equal the area of the large rectangle.\\n\\n![Group 8.jpg](https://assets.leetcode.com/users/images/c89c1ba0-dcba-4787-a40a-cc936e3a9c47_1694551363.5751398.jpeg)\\n\\n\\n2. The corners of the large rectangle should appear only once, while all other points where rectangles meet should appear an even number of times.\\n\\n![Group 7.jpg](https://assets.leetcode.com/users/images/f93f7ed9-a3a5-4795-b0dc-944c4eca0ca8_1694551348.6423934.jpeg)\\n\\n\\n### Solution Breakdown:\\n\\n1. **Initialization**:\\n   ```python\\n   x1, y1 = float(\\'inf\\'), float(\\'inf\\')\\n   x2, y2 = float(\\'-inf\\'), float(\\'-inf\\')\\n   corners = set()\\n   area = 0\\n   ```\\n   - `x1`, `y1`: Bottom-left corner of the large rectangle.\\n   - `x2`, `y2`: Top-right corner of the large rectangle.\\n   - `corners`: A set to store the corners of all rectangles.\\n   - `area`: To store the total area covered by all small rectangles.\\n\\n2. **Iterate over each rectangle**:\\n   ```python\\n   for rect in rectangles:\\n   ```\\n   For each rectangle, the code does the following:\\n\\n   a. **Updates the potential corners of the large rectangle**:\\n      ```python\\n      x1 = min(rect[0], x1)\\n      y1 = min(rect[1], y1)\\n      x2 = max(rect[2], x2)\\n      y2 = max(rect[3], y2)\\n      ```\\n      - This updates the minimum values for the bottom-left corner and the maximum values for the top-right corner.\\n\\n![Group 6.jpg](https://assets.leetcode.com/users/images/19b0dc90-96b1-421c-9071-156494a5a06f_1694551316.8918238.jpeg)\\n\\n\\nb. **Updates the total area**:\\n  - Adds the area of the current rectangle to the total area.\\n```python\\narea += (rect[2] - rect[0]) * (rect[3] - rect[1])\\n```\\n\\nc. **Handles the corners of the current rectangle**:\\n- The four corners of the current rectangle are created as tuples.\\n- The loop checks each corner: \\n    - If the corner is already in the `corners` set, it is removed.\\n    - If it\\'s not, it\\'s added to the set. \\n- This ensures that corners appearing twice are eliminated from the set.\\n  ```\\n  for point in [(rect[0], rect[1]), (rect[0], rect[3]), (rect[2], rect[3]), (rect[2], rect[1])]:\\n      if point in corners:\\n          corners.remove(point)\\n      else:\\n          corners.add(point)\\n  ```\\n\\n3. **Final Checks**:\\n\\n   a. **Check the four corners of the large rectangle**:\\n      ```python\\n      if {(x1, y1), (x1, y2), (x2, y1), (x2, y2)} != corners:\\n          return False\\n      ```\\n      - This checks if the set contains only the four corners of the large rectangle. If there are other corners left in the set, or if any of these four corners are missing, it returns `False`.\\n\\n   b. **Check the area**:\\n      ```python\\n      return area == (x2 - x1) * (y2 - y1)\\n      ```\\n      - Ensures that the combined area of all small rectangles equals the area of the large rectangle.\\n\\n### Summary:\\n\\nIn this Python solution, we utilize the properties of sets and the efficiency and clarity of tuples to determine if the given rectangles can form a large rectangle without overlaps or gaps. The logic is similar to [hu19\\'s Java solution](https://leetcode.com/problems/perfect-rectangle/solutions/87181/really-easy-understanding-solution-o-n-java/), but the use of tuples makes the code more concise and readable.\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def isRectangleCover(self, rectangles: List[List[int]]) -> bool:\\n      if not rectangles:\\n          return False\\n\\n      x1, y1 = float(\\'inf\\'), float(\\'inf\\')\\n      x2, y2 = float(\\'-inf\\'), float(\\'-inf\\')\\n      corners = set()\\n      area = 0\\n\\n      for rect in rectangles:\\n          x1 = min(rect[0], x1)\\n          y1 = min(rect[1], y1)\\n          x2 = max(rect[2], x2)\\n          y2 = max(rect[3], y2)\\n          \\n          area += (rect[2] - rect[0]) * (rect[3] - rect[1])\\n          \\n          for point in [(rect[0], rect[1]), (rect[0], rect[3]), (rect[2], rect[3]), (rect[2], rect[1])]:\\n              if point in corners:\\n                  corners.remove(point)\\n              else:\\n                  corners.add(point)\\n\\n      if {(x1, y1), (x1, y2), (x2, y1), (x2, y2)} != corners:\\n          return False\\n\\n      return area == (x2 - x1) * (y2 - y1)\\n\\n```\\n\\n### Time Complexity:\\n\\n1. **Iterating over each rectangle**:\\n   ```python\\n   for rect in rectangles:\\n   ```\\n   This loop iterates `n` times, where `n` is the number of rectangles. Within this loop:\\n\\n   a. **Updating the potential corners of the large rectangle and the total area**:\\n      These operations are \\\\(O(1)\\\\) for each rectangle.\\n      \\n   b. **Handling the corners of the current rectangle**:\\n      ```python\\n      for point in [(rect[0], rect[1]), (rect[0], rect[3]), (rect[2], rect[3]), (rect[2], rect[1])]:\\n      ```\\n      This loop iterates 4 times (a constant time). Inside this loop, adding a point to a set or removing a point from a set are both \\\\(O(1)\\\\) operations.\\n\\n   Thus, the operations inside the main loop are \\\\(O(1)\\\\), making the overall time complexity of the main loop \\\\(O(n)\\\\).\\n\\n2. **Final Checks**:\\n   Checking the four corners of the large rectangle and checking the area are both \\\\(O(1)\\\\) operations.\\n\\nCombining the above, the overall time complexity is \\\\(O(n)\\\\).\\n\\n### Space Complexity:\\n\\n1. **Storing the corners**:\\n   ```python\\n   corners = set()\\n   ```\\n   In the worst case, if every rectangle is disjoint from the others, there would be 4 corners for each rectangle, so the space required would be \\\\(O(4n)\\\\) or \\\\(O(n)\\\\).\\n\\n2. **Other variables**: `x1`, `x2`, `y1`, `y2`, and `area` all occupy constant space, \\\\(O(1)\\\\).\\n\\nThus, the overall space complexity is \\\\(O(n)\\\\).\\n\\nIn conclusion, both the time complexity and the space complexity of the Python solution are \\\\(O(n)\\\\).\\n\\n### Acknowledgements\\n\\nThanks to [hu19](https://leetcode.com/hu19/) for his solution :)\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\n   x1, y1 = float(\\'inf\\'), float(\\'inf\\')\\n   x2, y2 = float(\\'-inf\\'), float(\\'-inf\\')\\n   corners = set()\\n   area = 0\\n   ```\n```python\\n   for rect in rectangles:\\n   ```\n```python\\n      x1 = min(rect[0], x1)\\n      y1 = min(rect[1], y1)\\n      x2 = max(rect[2], x2)\\n      y2 = max(rect[3], y2)\\n      ```\n```python\\narea += (rect[2] - rect[0]) * (rect[3] - rect[1])\\n```\n```\\n  for point in [(rect[0], rect[1]), (rect[0], rect[3]), (rect[2], rect[3]), (rect[2], rect[1])]:\\n      if point in corners:\\n          corners.remove(point)\\n      else:\\n          corners.add(point)\\n  ```\n```python\\n      if {(x1, y1), (x1, y2), (x2, y1), (x2, y2)} != corners:\\n          return False\\n      ```\n```python\\n      return area == (x2 - x1) * (y2 - y1)\\n      ```\n```\\nclass Solution:\\n    def isRectangleCover(self, rectangles: List[List[int]]) -> bool:\\n      if not rectangles:\\n          return False\\n\\n      x1, y1 = float(\\'inf\\'), float(\\'inf\\')\\n      x2, y2 = float(\\'-inf\\'), float(\\'-inf\\')\\n      corners = set()\\n      area = 0\\n\\n      for rect in rectangles:\\n          x1 = min(rect[0], x1)\\n          y1 = min(rect[1], y1)\\n          x2 = max(rect[2], x2)\\n          y2 = max(rect[3], y2)\\n          \\n          area += (rect[2] - rect[0]) * (rect[3] - rect[1])\\n          \\n          for point in [(rect[0], rect[1]), (rect[0], rect[3]), (rect[2], rect[3]), (rect[2], rect[1])]:\\n              if point in corners:\\n                  corners.remove(point)\\n              else:\\n                  corners.add(point)\\n\\n      if {(x1, y1), (x1, y2), (x2, y1), (x2, y2)} != corners:\\n          return False\\n\\n      return area == (x2 - x1) * (y2 - y1)\\n\\n```\n```python\\n   for rect in rectangles:\\n   ```\n```python\\n      for point in [(rect[0], rect[1]), (rect[0], rect[3]), (rect[2], rect[3]), (rect[2], rect[1])]:\\n      ```\n```python\\n   corners = set()\\n   ```",
                "codeTag": "Java"
            },
            {
                "id": 3914383,
                "title": "27-line-very-intuitive-and-easy-to-understand-solution-o-n-including-thought-process",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIt is obvious that we should focus on corners, but how? For a Perfect Rectangle, there are four corners: upper-left, upper-right, bottom-left, bottom-right. The points here are only used once. \\n<br>For other points, they should be used by **X** times, **X%2 == 0**\\n\\nAlso notice, that for a point, it acts as \\n(bottom-right, bottom-left) or \\n(bottom-left, upper-left) or\\n(upper-right, upper-left) or\\n(upper-right, bottom-right) or\\na combination of the above\\n\\nSo if we use a hashmap to maintain a counter for each point, and for each bottom-left/upper-right, we decrement the counter, for each bottom-right/upper-left we increment the counter, then the counter should remain zero in the end. (not including the four corners of the perfect rectangle)\\n\\nThen we only need to check the hashmap **H**, for each point **(x,y)**, if **H(x, y) != 0**\\n\\nThe code is easy to understand, so I stop here. :)\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ntype Pair struct {\\n    x, y int\\n}\\nfunc isRectangleCover(rectangles [][]int) bool {\\n    m := make(map[Pair]int)\\n    for i := range(rectangles) {\\n        x, y := rectangles[i][0], rectangles[i][1]\\n        a, b := rectangles[i][2], rectangles[i][3]\\n        m[Pair{x: x, y: y}]--\\n        m[Pair{x: x, y: b}]++\\n        m[Pair{x: a, y: y}]++\\n        m[Pair{x: a, y: b}]--\\n    }\\n    count := 0\\n    for _,value := range(m) {\\n        if (value != 0) {\\n            if (value < 0) {\\n                count+= (0-value)\\n            } else {\\n                count+= (value-0)\\n            }\\n        }\\n    }\\n    res := false\\n    if (count == 4) { res = true }\\n    return res\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Hash Table"
                ],
                "code": "```\\ntype Pair struct {\\n    x, y int\\n}\\nfunc isRectangleCover(rectangles [][]int) bool {\\n    m := make(map[Pair]int)\\n    for i := range(rectangles) {\\n        x, y := rectangles[i][0], rectangles[i][1]\\n        a, b := rectangles[i][2], rectangles[i][3]\\n        m[Pair{x: x, y: y}]--\\n        m[Pair{x: x, y: b}]++\\n        m[Pair{x: a, y: y}]++\\n        m[Pair{x: a, y: b}]--\\n    }\\n    count := 0\\n    for _,value := range(m) {\\n        if (value != 0) {\\n            if (value < 0) {\\n                count+= (0-value)\\n            } else {\\n                count+= (value-0)\\n            }\\n        }\\n    }\\n    res := false\\n    if (count == 4) { res = true }\\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3899326,
                "title": "solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n public:\\n  bool isRectangleCover(vector<vector<int>>& rectangles) {\\n    int64_t area = 0; // Change this to a 64-bit integer\\n    int x1 = INT_MAX;\\n    int y1 = INT_MAX;\\n    int x2 = INT_MIN;\\n    int y2 = INT_MIN;\\n    unordered_map<string, int> corners;\\n\\n    for (const vector<int>& r : rectangles) {\\n      area += (int64_t)(r[2] - r[0]) * (r[3] - r[1]); // Cast to 64-bit integer\\n      x1 = min(x1, r[0]);\\n      y1 = min(y1, r[1]);\\n      x2 = max(x2, r[2]);\\n      y2 = max(y2, r[3]);\\n\\n      // Four points of current rectangle\\n      const vector<string> points{to_string(r[0]) + \" \" + to_string(r[1]),\\n                                  to_string(r[0]) + \" \" + to_string(r[3]),\\n                                  to_string(r[2]) + \" \" + to_string(r[1]),\\n                                  to_string(r[2]) + \" \" + to_string(r[3])};\\n      for (const string& point : points)\\n        corners[point]++;\\n    }\\n\\n    int oddCorners = 0;\\n    for (const auto& entry : corners) {\\n      if (entry.second % 2 != 0) oddCorners++;\\n    }\\n\\n    if (oddCorners != 4)\\n      return false;\\n    if (corners[to_string(x1) + \" \" + to_string(y1)] % 2 == 0 ||\\n        corners[to_string(x1) + \" \" + to_string(y2)] % 2 == 0 ||\\n        corners[to_string(x2) + \" \" + to_string(y1)] % 2 == 0 ||\\n        corners[to_string(x2) + \" \" + to_string(y2)] % 2 == 0)\\n      return false;\\n\\n    return area == (int64_t)(x2 - x1) * (y2 - y1); // Cast to 64-bit integer\\n  }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n public:\\n  bool isRectangleCover(vector<vector<int>>& rectangles) {\\n    int64_t area = 0; // Change this to a 64-bit integer\\n    int x1 = INT_MAX;\\n    int y1 = INT_MAX;\\n    int x2 = INT_MIN;\\n    int y2 = INT_MIN;\\n    unordered_map<string, int> corners;\\n\\n    for (const vector<int>& r : rectangles) {\\n      area += (int64_t)(r[2] - r[0]) * (r[3] - r[1]); // Cast to 64-bit integer\\n      x1 = min(x1, r[0]);\\n      y1 = min(y1, r[1]);\\n      x2 = max(x2, r[2]);\\n      y2 = max(y2, r[3]);\\n\\n      // Four points of current rectangle\\n      const vector<string> points{to_string(r[0]) + \" \" + to_string(r[1]),\\n                                  to_string(r[0]) + \" \" + to_string(r[3]),\\n                                  to_string(r[2]) + \" \" + to_string(r[1]),\\n                                  to_string(r[2]) + \" \" + to_string(r[3])};\\n      for (const string& point : points)\\n        corners[point]++;\\n    }\\n\\n    int oddCorners = 0;\\n    for (const auto& entry : corners) {\\n      if (entry.second % 2 != 0) oddCorners++;\\n    }\\n\\n    if (oddCorners != 4)\\n      return false;\\n    if (corners[to_string(x1) + \" \" + to_string(y1)] % 2 == 0 ||\\n        corners[to_string(x1) + \" \" + to_string(y2)] % 2 == 0 ||\\n        corners[to_string(x2) + \" \" + to_string(y1)] % 2 == 0 ||\\n        corners[to_string(x2) + \" \" + to_string(y2)] % 2 == 0)\\n      return false;\\n\\n    return area == (int64_t)(x2 - x1) * (y2 - y1); // Cast to 64-bit integer\\n  }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3893609,
                "title": "java-treeset-solution-line-sweep",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(N*log(n))\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\n\\n\\nclass Solution {\\n\\tstatic int len;\\n\\tpublic boolean isRectangleCover(int[][] rectangles) {\\n\\n\\t\\tlen=0;\\n\\t\\tint n = rectangles.length;\\n\\t\\tint[][] events = new int[2*n][4];\\n\\n\\t\\tint i=0;\\n\\t\\tfor (int[]a:rectangles){\\n\\t\\t\\tevents[i] = new int[]{a[0],1,a[1],a[3]};\\n\\t\\t\\ti++;\\n\\t\\t\\tevents[i] = new int[]{a[2],0,a[1],a[3]};\\n\\t\\t\\ti++;\\n\\t\\t}\\n\\n\\n\\t\\n\\n\\t\\tArrays.sort(events, new Comparator<int[]>() {\\n\\t\\t\\t@Override\\n\\t\\t\\tpublic int compare(int[] o1, int[] o2) {\\n\\t\\t\\t\\tif (o1[0]!=o2[0]){\\n\\t\\t\\t\\t\\treturn o1[0]-o2[0];\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn o1[1]-o2[1];\\n\\t\\t\\t}\\n\\t\\t});\\n\\n\\t\\tTreeSet<int[]> open = new TreeSet<>(new Comparator<int[]>() {\\n\\t\\t\\t@Override\\n\\t\\t\\tpublic int compare(int[] o1, int[] o2) {\\n\\t\\t\\t\\tif (o1[0]!=o2[0]){\\n\\t\\t\\t\\t\\treturn o1[0]-o2[0];\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn o1[1]-o2[1];\\n\\t\\t\\t}\\n\\t\\t});\\n\\n\\t\\tint prev=0;\\n\\n\\t\\tfor (int i1=0;i1<2*n;i1++) {\\n\\n\\t\\t\\tint j = i1;\\n\\t\\t\\t\\t\\n\\t\\t\\twhile (i1 < 2 * n && events[i1][0] == events[j][0]) {\\n\\n\\n\\n\\t\\t\\t\\tif (events[i1][1] == 0) {\\n\\t\\t\\t\\t\\topen.remove(new int[]{events[i1][2], events[i1][3]});\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tif(open.contains(new int[]{events[i1][2], events[i1][3]})){\\n\\t\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\topen.add(new int[]{events[i1][2], events[i1][3]});\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\ti1++;\\n\\t\\t\\t}\\n\\t\\t\\ti1--;\\n\\n\\n\\t\\t\\t\\n\\t\\t\\tif(i1<2*n-1&&open.size()==0){\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\n\\t\\t\\tboolean b = check(open);\\n\\t\\t\\tif (!b){\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn true;\\n\\n\\t}\\n\\n\\tpublic boolean check(TreeSet<int[]>set){\\n\\n\\t\\tif(set.size()==0){\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t\\tint prv = set.first()[0];\\n\\t\\tint first = prv;\\n\\t\\tint curr=0;\\n\\n\\n\\t\\tfor (int[]a:set){\\n\\t\\t\\tif (prv!=a[0]){\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t\\tcurr +=a[1]-a[0];\\n\\t\\t\\tprv = a[1];\\n\\t\\t}\\n\\n\\t\\tif (len==0){\\n\\t\\t\\tlen = prv-first;\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t\\tif (len==curr){\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t\\treturn false;\\n\\t}\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\n\\nclass Solution {\\n\\tstatic int len;\\n\\tpublic boolean isRectangleCover(int[][] rectangles) {\\n\\n\\t\\tlen=0;\\n\\t\\tint n = rectangles.length;\\n\\t\\tint[][] events = new int[2*n][4];\\n\\n\\t\\tint i=0;\\n\\t\\tfor (int[]a:rectangles){\\n\\t\\t\\tevents[i] = new int[]{a[0],1,a[1],a[3]};\\n\\t\\t\\ti++;\\n\\t\\t\\tevents[i] = new int[]{a[2],0,a[1],a[3]};\\n\\t\\t\\ti++;\\n\\t\\t}\\n\\n\\n\\t\\n\\n\\t\\tArrays.sort(events, new Comparator<int[]>() {\\n\\t\\t\\t@Override\\n\\t\\t\\tpublic int compare(int[] o1, int[] o2) {\\n\\t\\t\\t\\tif (o1[0]!=o2[0]){\\n\\t\\t\\t\\t\\treturn o1[0]-o2[0];\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn o1[1]-o2[1];\\n\\t\\t\\t}\\n\\t\\t});\\n\\n\\t\\tTreeSet<int[]> open = new TreeSet<>(new Comparator<int[]>() {\\n\\t\\t\\t@Override\\n\\t\\t\\tpublic int compare(int[] o1, int[] o2) {\\n\\t\\t\\t\\tif (o1[0]!=o2[0]){\\n\\t\\t\\t\\t\\treturn o1[0]-o2[0];\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn o1[1]-o2[1];\\n\\t\\t\\t}\\n\\t\\t});\\n\\n\\t\\tint prev=0;\\n\\n\\t\\tfor (int i1=0;i1<2*n;i1++) {\\n\\n\\t\\t\\tint j = i1;\\n\\t\\t\\t\\t\\n\\t\\t\\twhile (i1 < 2 * n && events[i1][0] == events[j][0]) {\\n\\n\\n\\n\\t\\t\\t\\tif (events[i1][1] == 0) {\\n\\t\\t\\t\\t\\topen.remove(new int[]{events[i1][2], events[i1][3]});\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tif(open.contains(new int[]{events[i1][2], events[i1][3]})){\\n\\t\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\topen.add(new int[]{events[i1][2], events[i1][3]});\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\ti1++;\\n\\t\\t\\t}\\n\\t\\t\\ti1--;\\n\\n\\n\\t\\t\\t\\n\\t\\t\\tif(i1<2*n-1&&open.size()==0){\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\n\\t\\t\\tboolean b = check(open);\\n\\t\\t\\tif (!b){\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn true;\\n\\n\\t}\\n\\n\\tpublic boolean check(TreeSet<int[]>set){\\n\\n\\t\\tif(set.size()==0){\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t\\tint prv = set.first()[0];\\n\\t\\tint first = prv;\\n\\t\\tint curr=0;\\n\\n\\n\\t\\tfor (int[]a:set){\\n\\t\\t\\tif (prv!=a[0]){\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t\\tcurr +=a[1]-a[0];\\n\\t\\t\\tprv = a[1];\\n\\t\\t}\\n\\n\\t\\tif (len==0){\\n\\t\\t\\tlen = prv-first;\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t\\tif (len==curr){\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t\\treturn false;\\n\\t}\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3793927,
                "title": "perfect-rectangle-leetcode",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool isRectangleCover(vector<vector<int>>& rectangles) {\\n        // solving this question with map:-\\n        map<pair<int,int>,int>m;\\n        for(auto it:rectangles){\\n            m[{it[0],it[1]}]++;\\n            m[{it[2],it[3]}]++;\\n            m[{it[0],it[3]}]--;\\n            m[{it[2],it[1]}]--;\\n        }\\n        int cnt=0;\\n        for( auto it=m.begin();it!=m.end();it++){\\n            if(abs(it->second)==1){\\n                cnt++;\\n            }\\n            else if(abs(it->second)!=1&&it->second!=0){\\n                return false;\\n            }\\n        }\\n        return cnt==4;\\n    }\\n// By ~ Shubham Verma\\n};\\n```\\n![UPVOTE.png](https://assets.leetcode.com/users/images/faa73586-ddaa-482b-8264-d23463594fb7_1689877427.4044847.png)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isRectangleCover(vector<vector<int>>& rectangles) {\\n        // solving this question with map:-\\n        map<pair<int,int>,int>m;\\n        for(auto it:rectangles){\\n            m[{it[0],it[1]}]++;\\n            m[{it[2],it[3]}]++;\\n            m[{it[0],it[3]}]--;\\n            m[{it[2],it[1]}]--;\\n        }\\n        int cnt=0;\\n        for( auto it=m.begin();it!=m.end();it++){\\n            if(abs(it->second)==1){\\n                cnt++;\\n            }\\n            else if(abs(it->second)!=1&&it->second!=0){\\n                return false;\\n            }\\n        }\\n        return cnt==4;\\n    }\\n// By ~ Shubham Verma\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3788745,
                "title": "c-o-nlogn-multi-set",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    static bool compare(vector<int>& r1,vector<int>& r2) {\\n        if (r1 [0] == r2[0]) {\\n            return r1[2] < r2[2];\\n        }\\n        return r1[0] < r2[0];\\n    }\\n\\n    static bool compare2(vector<int>& r1,vector<int>& r2) {\\n        if (r1 [0] == r2[0]) {\\n            return r1[1] < r2[1];\\n        }\\n        return r1[0] < r2[0];\\n    }\\n\\n\\n    bool checkPositionsAndArea(vector<vector<int>> rectangles) {\\n        sort(rectangles.begin(), rectangles.end(), compare2);\\n\\n        long long minX = INT_MAX, minY = INT_MAX;\\n        long long maxX = INT_MIN, maxY = INT_MIN;\\n        long long curStartx, curStarty, curEndx, curEndy;\\n\\n        int prevStartx, prevStarty;\\n        int prevEndx, prevEndy;\\n\\n        set<pair<int, int > > s; \\n        long long area = 0;\\n        \\n        for (int i = 0 ; i < rectangles.size(); i++) {\\n\\n            curStartx = rectangles[i][0];\\n            curStarty = rectangles[i][1];\\n            curEndx = rectangles[i][2];\\n            curEndy = rectangles[i][3];\\n            minX = min(minX, curStartx);\\n            maxX = max(maxX, curEndx);\\n            minY = min(minY, curStarty);\\n            maxY = max(maxY, curEndy);\\n\\n            if (i != 0) {\\n                if(s.find({curStartx, curStarty}) != s.end()) {\\n                    // if a rectangle started in the position, remove it from set to check for duplicates.\\n                    s.erase({curStartx, curStarty});\\n                } else {\\n                    return false;\\n                }\\n            }\\n            // New rectangles should only start in these positions\\n            s.insert({curStartx, curEndy});\\n            s.insert({curEndx, curStarty});\\n            area = area +  abs(curEndx - curStartx) * abs(curEndy - curStarty);\\n        }\\n        if (area == (maxY - minY) * (maxX-minX)) {\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n\\n    bool checkForIntersections(vector<vector<int>> rectangles) {\\n        multiset<int> maxHeights;\\n        vector<vector<int> > v;\\n        int curStartx, curStarty, curEndx, curEndy;\\n\\n        for(int i = 0 ; i < rectangles.size(); i++) {\\n            v.push_back({rectangles[i][0], i, 1});\\n            v.push_back({rectangles[i][2], i, 0});\\n        }\\n\\n        sort(v.begin(), v.end(), compare);\\n\\n\\n        for(int i = 0; i < v.size(); i++) {\\n            int j = v[i][1];\\n            curStartx = rectangles[j][0];\\n            curStarty = rectangles[j][1];\\n            curEndx = rectangles[j][2];\\n            curEndy = rectangles[j][3];\\n            \\n\\n            if (v[i][2] == 0) {\\n                multiset<int>::iterator itr = maxHeights.find(rectangles[j][1]);\\n                maxHeights.erase(itr);\\n                continue;\\n            } else {\\n                if(maxHeights.size() > 0) {\\n                    multiset<int>::iterator itr = maxHeights.lower_bound(curStarty);\\n                    if (itr != maxHeights.end()) {\\n                        int maxHeight = (*itr);\\n                        if (curEndy > maxHeight) {\\n                            return false;\\n                        }\\n                    }\\n                } \\n                maxHeights.insert(rectangles[j][1]);\\n            }\\n\\n        }\\n        return true;\\n    }\\n\\n    bool isRectangleCover(vector<vector<int>>& rectangles) {\\n\\n        bool isValid = checkPositionsAndArea(rectangles);\\n        if (!isValid) {\\n            return false;\\n        }\\n\\n        isValid = checkForIntersections(rectangles);\\n        if(!isValid) {\\n            return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    static bool compare(vector<int>& r1,vector<int>& r2) {\\n        if (r1 [0] == r2[0]) {\\n            return r1[2] < r2[2];\\n        }\\n        return r1[0] < r2[0];\\n    }\\n\\n    static bool compare2(vector<int>& r1,vector<int>& r2) {\\n        if (r1 [0] == r2[0]) {\\n            return r1[1] < r2[1];\\n        }\\n        return r1[0] < r2[0];\\n    }\\n\\n\\n    bool checkPositionsAndArea(vector<vector<int>> rectangles) {\\n        sort(rectangles.begin(), rectangles.end(), compare2);\\n\\n        long long minX = INT_MAX, minY = INT_MAX;\\n        long long maxX = INT_MIN, maxY = INT_MIN;\\n        long long curStartx, curStarty, curEndx, curEndy;\\n\\n        int prevStartx, prevStarty;\\n        int prevEndx, prevEndy;\\n\\n        set<pair<int, int > > s; \\n        long long area = 0;\\n        \\n        for (int i = 0 ; i < rectangles.size(); i++) {\\n\\n            curStartx = rectangles[i][0];\\n            curStarty = rectangles[i][1];\\n            curEndx = rectangles[i][2];\\n            curEndy = rectangles[i][3];\\n            minX = min(minX, curStartx);\\n            maxX = max(maxX, curEndx);\\n            minY = min(minY, curStarty);\\n            maxY = max(maxY, curEndy);\\n\\n            if (i != 0) {\\n                if(s.find({curStartx, curStarty}) != s.end()) {\\n                    // if a rectangle started in the position, remove it from set to check for duplicates.\\n                    s.erase({curStartx, curStarty});\\n                } else {\\n                    return false;\\n                }\\n            }\\n            // New rectangles should only start in these positions\\n            s.insert({curStartx, curEndy});\\n            s.insert({curEndx, curStarty});\\n            area = area +  abs(curEndx - curStartx) * abs(curEndy - curStarty);\\n        }\\n        if (area == (maxY - minY) * (maxX-minX)) {\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n\\n    bool checkForIntersections(vector<vector<int>> rectangles) {\\n        multiset<int> maxHeights;\\n        vector<vector<int> > v;\\n        int curStartx, curStarty, curEndx, curEndy;\\n\\n        for(int i = 0 ; i < rectangles.size(); i++) {\\n            v.push_back({rectangles[i][0], i, 1});\\n            v.push_back({rectangles[i][2], i, 0});\\n        }\\n\\n        sort(v.begin(), v.end(), compare);\\n\\n\\n        for(int i = 0; i < v.size(); i++) {\\n            int j = v[i][1];\\n            curStartx = rectangles[j][0];\\n            curStarty = rectangles[j][1];\\n            curEndx = rectangles[j][2];\\n            curEndy = rectangles[j][3];\\n            \\n\\n            if (v[i][2] == 0) {\\n                multiset<int>::iterator itr = maxHeights.find(rectangles[j][1]);\\n                maxHeights.erase(itr);\\n                continue;\\n            } else {\\n                if(maxHeights.size() > 0) {\\n                    multiset<int>::iterator itr = maxHeights.lower_bound(curStarty);\\n                    if (itr != maxHeights.end()) {\\n                        int maxHeight = (*itr);\\n                        if (curEndy > maxHeight) {\\n                            return false;\\n                        }\\n                    }\\n                } \\n                maxHeights.insert(rectangles[j][1]);\\n            }\\n\\n        }\\n        return true;\\n    }\\n\\n    bool isRectangleCover(vector<vector<int>>& rectangles) {\\n\\n        bool isValid = checkPositionsAndArea(rectangles);\\n        if (!isValid) {\\n            return false;\\n        }\\n\\n        isValid = checkForIntersections(rectangles);\\n        if(!isValid) {\\n            return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3788744,
                "title": "c-o-nlogn-multi-set",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    static bool compare(vector<int>& r1,vector<int>& r2) {\\n        if (r1 [0] == r2[0]) {\\n            return r1[2] < r2[2];\\n        }\\n        return r1[0] < r2[0];\\n    }\\n\\n    static bool compare2(vector<int>& r1,vector<int>& r2) {\\n        if (r1 [0] == r2[0]) {\\n            return r1[1] < r2[1];\\n        }\\n        return r1[0] < r2[0];\\n    }\\n\\n\\n    bool checkPositionsAndArea(vector<vector<int>> rectangles) {\\n        sort(rectangles.begin(), rectangles.end(), compare2);\\n\\n        long long minX = INT_MAX, minY = INT_MAX;\\n        long long maxX = INT_MIN, maxY = INT_MIN;\\n        long long curStartx, curStarty, curEndx, curEndy;\\n\\n        int prevStartx, prevStarty;\\n        int prevEndx, prevEndy;\\n\\n        set<pair<int, int > > s; \\n        long long area = 0;\\n        \\n        for (int i = 0 ; i < rectangles.size(); i++) {\\n\\n            curStartx = rectangles[i][0];\\n            curStarty = rectangles[i][1];\\n            curEndx = rectangles[i][2];\\n            curEndy = rectangles[i][3];\\n            minX = min(minX, curStartx);\\n            maxX = max(maxX, curEndx);\\n            minY = min(minY, curStarty);\\n            maxY = max(maxY, curEndy);\\n\\n            if (i != 0) {\\n                if(s.find({curStartx, curStarty}) != s.end()) {\\n                    // if a rectangle started in the position, remove it from set to check for duplicates.\\n                    s.erase({curStartx, curStarty});\\n                } else {\\n                    return false;\\n                }\\n            }\\n            // New rectangles should only start in these positions\\n            s.insert({curStartx, curEndy});\\n            s.insert({curEndx, curStarty});\\n            area = area +  abs(curEndx - curStartx) * abs(curEndy - curStarty);\\n        }\\n        if (area == (maxY - minY) * (maxX-minX)) {\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n\\n    bool checkForIntersections(vector<vector<int>> rectangles) {\\n        multiset<int> maxHeights;\\n        vector<vector<int> > v;\\n        int curStartx, curStarty, curEndx, curEndy;\\n\\n        for(int i = 0 ; i < rectangles.size(); i++) {\\n            v.push_back({rectangles[i][0], i, 1});\\n            v.push_back({rectangles[i][2], i, 0});\\n        }\\n\\n        sort(v.begin(), v.end(), compare);\\n\\n\\n        for(int i = 0; i < v.size(); i++) {\\n            int j = v[i][1];\\n            curStartx = rectangles[j][0];\\n            curStarty = rectangles[j][1];\\n            curEndx = rectangles[j][2];\\n            curEndy = rectangles[j][3];\\n            \\n\\n            if (v[i][2] == 0) {\\n                multiset<int>::iterator itr = maxHeights.find(rectangles[j][1]);\\n                maxHeights.erase(itr);\\n                continue;\\n            } else {\\n                if(maxHeights.size() > 0) {\\n                    multiset<int>::iterator itr = maxHeights.lower_bound(curStarty);\\n                    if (itr != maxHeights.end()) {\\n                        int maxHeight = (*itr);\\n                        if (curEndy > maxHeight) {\\n                            return false;\\n                        }\\n                    }\\n                } \\n                maxHeights.insert(rectangles[j][1]);\\n            }\\n\\n        }\\n        return true;\\n    }\\n\\n    bool isRectangleCover(vector<vector<int>>& rectangles) {\\n\\n        bool isValid = checkPositionsAndArea(rectangles);\\n        if (!isValid) {\\n            return false;\\n        }\\n\\n        isValid = checkForIntersections(rectangles);\\n        if(!isValid) {\\n            return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    static bool compare(vector<int>& r1,vector<int>& r2) {\\n        if (r1 [0] == r2[0]) {\\n            return r1[2] < r2[2];\\n        }\\n        return r1[0] < r2[0];\\n    }\\n\\n    static bool compare2(vector<int>& r1,vector<int>& r2) {\\n        if (r1 [0] == r2[0]) {\\n            return r1[1] < r2[1];\\n        }\\n        return r1[0] < r2[0];\\n    }\\n\\n\\n    bool checkPositionsAndArea(vector<vector<int>> rectangles) {\\n        sort(rectangles.begin(), rectangles.end(), compare2);\\n\\n        long long minX = INT_MAX, minY = INT_MAX;\\n        long long maxX = INT_MIN, maxY = INT_MIN;\\n        long long curStartx, curStarty, curEndx, curEndy;\\n\\n        int prevStartx, prevStarty;\\n        int prevEndx, prevEndy;\\n\\n        set<pair<int, int > > s; \\n        long long area = 0;\\n        \\n        for (int i = 0 ; i < rectangles.size(); i++) {\\n\\n            curStartx = rectangles[i][0];\\n            curStarty = rectangles[i][1];\\n            curEndx = rectangles[i][2];\\n            curEndy = rectangles[i][3];\\n            minX = min(minX, curStartx);\\n            maxX = max(maxX, curEndx);\\n            minY = min(minY, curStarty);\\n            maxY = max(maxY, curEndy);\\n\\n            if (i != 0) {\\n                if(s.find({curStartx, curStarty}) != s.end()) {\\n                    // if a rectangle started in the position, remove it from set to check for duplicates.\\n                    s.erase({curStartx, curStarty});\\n                } else {\\n                    return false;\\n                }\\n            }\\n            // New rectangles should only start in these positions\\n            s.insert({curStartx, curEndy});\\n            s.insert({curEndx, curStarty});\\n            area = area +  abs(curEndx - curStartx) * abs(curEndy - curStarty);\\n        }\\n        if (area == (maxY - minY) * (maxX-minX)) {\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n\\n    bool checkForIntersections(vector<vector<int>> rectangles) {\\n        multiset<int> maxHeights;\\n        vector<vector<int> > v;\\n        int curStartx, curStarty, curEndx, curEndy;\\n\\n        for(int i = 0 ; i < rectangles.size(); i++) {\\n            v.push_back({rectangles[i][0], i, 1});\\n            v.push_back({rectangles[i][2], i, 0});\\n        }\\n\\n        sort(v.begin(), v.end(), compare);\\n\\n\\n        for(int i = 0; i < v.size(); i++) {\\n            int j = v[i][1];\\n            curStartx = rectangles[j][0];\\n            curStarty = rectangles[j][1];\\n            curEndx = rectangles[j][2];\\n            curEndy = rectangles[j][3];\\n            \\n\\n            if (v[i][2] == 0) {\\n                multiset<int>::iterator itr = maxHeights.find(rectangles[j][1]);\\n                maxHeights.erase(itr);\\n                continue;\\n            } else {\\n                if(maxHeights.size() > 0) {\\n                    multiset<int>::iterator itr = maxHeights.lower_bound(curStarty);\\n                    if (itr != maxHeights.end()) {\\n                        int maxHeight = (*itr);\\n                        if (curEndy > maxHeight) {\\n                            return false;\\n                        }\\n                    }\\n                } \\n                maxHeights.insert(rectangles[j][1]);\\n            }\\n\\n        }\\n        return true;\\n    }\\n\\n    bool isRectangleCover(vector<vector<int>>& rectangles) {\\n\\n        bool isValid = checkPositionsAndArea(rectangles);\\n        if (!isValid) {\\n            return false;\\n        }\\n\\n        isValid = checkForIntersections(rectangles);\\n        if(!isValid) {\\n            return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3772379,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isRectangleCover(int[][] rectangles) {\\n        //X1,Y1\\u662F\\u5DE6\\u4E0B\\u89D2,X2,Y2 is up right corner\\n        int X1 = Integer.MAX_VALUE, Y1 = Integer.MAX_VALUE, X2 = Integer.MIN_VALUE, Y2 = Integer.MIN_VALUE;\\n        Set<String> points = new HashSet<>();\\n        int actual_area = 0;\\n        for(int[] item : rectangles){\\n            int x1 = item[0], y1 = item[1], x2 = item[2], y2 = item[3];\\n            X1 = Math.min(X1, x1);Y1 = Math.min(Y1, y1);\\n            X2 = Math.max(X2, x2);Y2 = Math.max(Y2, y2);\\n            actual_area += (x2-x1)*(y2-y1);\\n            int[] p1 = new int[]{x1,y1};//bottom left\\n            int[] p2 = new int[]{x1,y2};//up left\\n            int[] p3 = new int[]{x2,y1};//bottom right\\n            int[] p4 = new int[]{x2,y2};//up right\\n            //traverse all the points and count how many times they appear, the perfect rectangle\\'s corners should appear only once and other inside points should occur an even number of times\\n            for(int[] p : new int[][]{p1,p2,p3,p4}){\\n                String s = p[0] + \",\" + p[1];\\n                if(points.contains(s)){\\n                    points.remove(s);\\n                }else{\\n                    points.add(s);\\n                }\\n            }\\n\\n            //so after the for loop, there should be only four points in the set, the four corners\\n        }\\n        int expected_area = (X2-X1)*(Y2-Y1);\\n        if(actual_area != expected_area){\\n            return false;\\n        }\\n        //the remaining four points should be the exact four points X1Y1X2Y2, because some rectangles might pile up in the same position,that they contains the corner\\n        if(points.size() != 4) return false;\\n        String s1 = X1 + \",\" + Y1;\\n        String s2 = X1 + \",\" + Y2;\\n        String s3 = X2 + \",\" + Y1;\\n        String s4 = X2 + \",\" + Y2;\\n        if(!points.contains(s1)) return false;\\n        if(!points.contains(s2)) return false;\\n        if(!points.contains(s3)) return false;\\n        if(!points.contains(s4)) return false;\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isRectangleCover(int[][] rectangles) {\\n        //X1,Y1\\u662F\\u5DE6\\u4E0B\\u89D2,X2,Y2 is up right corner\\n        int X1 = Integer.MAX_VALUE, Y1 = Integer.MAX_VALUE, X2 = Integer.MIN_VALUE, Y2 = Integer.MIN_VALUE;\\n        Set<String> points = new HashSet<>();\\n        int actual_area = 0;\\n        for(int[] item : rectangles){\\n            int x1 = item[0], y1 = item[1], x2 = item[2], y2 = item[3];\\n            X1 = Math.min(X1, x1);Y1 = Math.min(Y1, y1);\\n            X2 = Math.max(X2, x2);Y2 = Math.max(Y2, y2);\\n            actual_area += (x2-x1)*(y2-y1);\\n            int[] p1 = new int[]{x1,y1};//bottom left\\n            int[] p2 = new int[]{x1,y2};//up left\\n            int[] p3 = new int[]{x2,y1};//bottom right\\n            int[] p4 = new int[]{x2,y2};//up right\\n            //traverse all the points and count how many times they appear, the perfect rectangle\\'s corners should appear only once and other inside points should occur an even number of times\\n            for(int[] p : new int[][]{p1,p2,p3,p4}){\\n                String s = p[0] + \",\" + p[1];\\n                if(points.contains(s)){\\n                    points.remove(s);\\n                }else{\\n                    points.add(s);\\n                }\\n            }\\n\\n            //so after the for loop, there should be only four points in the set, the four corners\\n        }\\n        int expected_area = (X2-X1)*(Y2-Y1);\\n        if(actual_area != expected_area){\\n            return false;\\n        }\\n        //the remaining four points should be the exact four points X1Y1X2Y2, because some rectangles might pile up in the same position,that they contains the corner\\n        if(points.size() != 4) return false;\\n        String s1 = X1 + \",\" + Y1;\\n        String s2 = X1 + \",\" + Y2;\\n        String s3 = X2 + \",\" + Y1;\\n        String s4 = X2 + \",\" + Y2;\\n        if(!points.contains(s1)) return false;\\n        if(!points.contains(s2)) return false;\\n        if(!points.contains(s3)) return false;\\n        if(!points.contains(s4)) return false;\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3747869,
                "title": "fill-in-area-with-available-rectangles",
                "content": "The solution below, attempts to fill in given area using available rectangles. If avaialble rectangle is oversized, we trim it, and add back smaller leftovers (up to 3) into a list of available rectangles.\\nWhen rectangle is smaller than the area we are trying to fill in, we are are recursively trying to fill in remaining area by breaking it down into 3 pieces: right, top, right-top \\n\\n```\\nclass Solution:\\n    def isRectangleCover(self, rectangles: List[List[int]]) -> bool:\\n        # Build available rectangles lookup by bottom left corner\\n        lookup = dict()\\n        for r in rectangles:\\n            x_y = (r[0], r[1])\\n            if x_y in lookup: return False\\n            lookup[x_y] = r\\n            \\n        # implement function that checks if given area can be filled in\\n        # using remaing rectangles.\\n        # 1. Pop rectangle that goes into left bottom corner\\n        # 2. If it overfills the area, trim it and add leftovers back into remaining rectangles\\n        # 3. Fill in any remaining area to the top, right, and to the right-top \\n        def fill_in(x, y, a, b):\\n            if (x, y) not in lookup: return False\\n            rx, ry, ra, rb = lookup.pop((x, y))\\n\\t\\t\\t\\n            # trim\\n            if rb > b: lookup[(x, b)] = (x, b, min(a, ra), rb)\\n            if ra > a: lookup[(a, y)] = (a, y, ra, min(b, rb))\\n            if ra > a and rb > b: lookup[(a, b)] = (a, b, ra, rb)\\n            \\n            # fill in\\n\\t\\t    #  _________________\\t\\n            #  |         |      |\\n\\t\\t\\t#  |      1  |   3  |\\n\\t\\t\\t#  |---------|------|\\n\\t\\t\\t#  |         |   2  |\\n\\t\\t\\t#  |_________|______|\\n            res = True\\n            if rb < b: res &= fill_in(x, rb, min(a, ra), b) # fill in 1\\n            if ra < a: res &= fill_in(ra, y, a, min(b, rb)) # fill in 2\\n            if ra < a and rb < b: res &= fill_in(ra, rb, a, b) # fill in 3\\n                \\n            return res\\n                \\n        # Find largest possible area that can be covered by given rectangles and fill it in\\n        # If it can be filled in, there should be no remaining rectangles left\\n        bottom_left = min((x, y) for x, y, _, _ in rectangles)\\n        top_right = max((a, b) for _, _, a, b in rectangles)\\n        \\n        return fill_in(*bottom_left, *top_right) and not lookup\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isRectangleCover(self, rectangles: List[List[int]]) -> bool:\\n        # Build available rectangles lookup by bottom left corner\\n        lookup = dict()\\n        for r in rectangles:\\n            x_y = (r[0], r[1])\\n            if x_y in lookup: return False\\n            lookup[x_y] = r\\n            \\n        # implement function that checks if given area can be filled in\\n        # using remaing rectangles.\\n        # 1. Pop rectangle that goes into left bottom corner\\n        # 2. If it overfills the area, trim it and add leftovers back into remaining rectangles\\n        # 3. Fill in any remaining area to the top, right, and to the right-top \\n        def fill_in(x, y, a, b):\\n            if (x, y) not in lookup: return False\\n            rx, ry, ra, rb = lookup.pop((x, y))\\n\\t\\t\\t\\n            # trim\\n            if rb > b: lookup[(x, b)] = (x, b, min(a, ra), rb)\\n            if ra > a: lookup[(a, y)] = (a, y, ra, min(b, rb))\\n            if ra > a and rb > b: lookup[(a, b)] = (a, b, ra, rb)\\n            \\n            # fill in\\n\\t\\t    #  _________________\\t\\n            #  |         |      |\\n\\t\\t\\t#  |      1  |   3  |\\n\\t\\t\\t#  |---------|------|\\n\\t\\t\\t#  |         |   2  |\\n\\t\\t\\t#  |_________|______|\\n            res = True\\n            if rb < b: res &= fill_in(x, rb, min(a, ra), b) # fill in 1\\n            if ra < a: res &= fill_in(ra, y, a, min(b, rb)) # fill in 2\\n            if ra < a and rb < b: res &= fill_in(ra, rb, a, b) # fill in 3\\n                \\n            return res\\n                \\n        # Find largest possible area that can be covered by given rectangles and fill it in\\n        # If it can be filled in, there should be no remaining rectangles left\\n        bottom_left = min((x, y) for x, y, _, _ in rectangles)\\n        top_right = max((a, b) for _, _, a, b in rectangles)\\n        \\n        return fill_in(*bottom_left, *top_right) and not lookup\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3747692,
                "title": "clean-python-sweel-line-o-n-log-n",
                "content": "In this solution I wanted to practice sweep line algorithm. Even though most solutions count corners, this solution beats 20% of them. The idea is to sweep the plane from left to right with an imaginary line parallel to y axis.\\n\\n1. We create a list of \"events\" that will occur with this imaginary line. \\n1.1. When the sweep line encounters a new rectangle we need to add a new interval covered by this rectangle, corresponding tuples are marked with True field(third in the tuple). Events where we would need to remove corresponding interval are marked with False. \\n1.2. Zero-th element of the tuple is the x-coordinate of the event so we can sort them in order.\\n1.3. First element of the tuple is the y-coordinate of the rectangle so that when we process a set of events occuring at the same x we can maintain interval arrays sorted and do inserts to them in O(1).\\n1.4. Last element of the tuple is the index of the rectangle in the array of rectangles so that we can retrieve the top and bottom y coordinates.\\n2. We sort events by x coordinate, thus allowing sweep from left to right.\\n3. The first encounter of the sweep line would be the leftmost borders of leftmost rectangles. Each of these rectangles projects to an interval on the said line. Processing of this first encounter happens in `if len(yrange) == 1` operator. There we simply check that the set of added intervals when merged gives a single continuous range. If there are other errors such as overlapping intervals they will reveal themselves later.\\n4. As we process all other events we follow a simple algorithm: for each value of x we accumulate all the added intervals (because of the newly encountered rectangles) and all the deleted intervals. Then we merge the corresponding sets to bring them to a unified form (see https://leetcode.com/problems/merge-intervals/ ). The merging can be done in O(n) because arrays are sorted(follows from events tuple array being sorted). These unified forms should simply be equal for each value of x. \\n5. At the maximum x we make sure that all deleted rectangles are equal to the rectangle\\'s yrange.\\n\\n# Code\\n```\\ndef isRectangleCover(self, rectangles: List[List[int]]) -> bool:\\n\\tevents = []\\n\\tfor i, r in enumerate(rectangles):\\n\\t\\tevents += [(r[0], r[1], True, i), (r[2], r[1], False, i)]\\n\\tevents.sort()\\n\\n\\ti = 0\\n\\n\\tyrange = []\\n\\twhile i < len(events):\\n\\t\\tx = events[i][0]\\n\\t\\tadd_intervals = []\\n\\t\\tdel_intervals = []\\n\\t\\twhile i < len(events) and events[i][0] == x:\\n\\t\\t\\t\\tr = rectangles[events[i][3]]\\n\\t\\t\\t\\tinterval = [r[1], r[3]]\\n\\t\\t\\t\\tif events[i][2]:\\n\\t\\t\\t\\t\\tadd_intervals.append(interval)\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tdel_intervals.append(interval)\\n\\t\\t\\t\\ti = i + 1\\n\\t\\tif yrange == []:\\n\\t\\t\\tself.merge_ints(add_intervals, yrange)\\n\\t\\t\\tif len(yrange) != 1:\\n\\t\\t\\t\\treturn False\\n\\t\\t\\tcontinue\\n\\t\\tadd_merged = []\\n\\t\\tdel_merged = []\\n\\t\\tif (not self.merge_ints(add_intervals, add_merged) or\\n\\t\\t\\t\\tnot self.merge_ints(del_intervals, del_merged) or\\n\\t\\t\\t\\t(i != len(events) and del_merged != add_merged) or\\n\\t\\t\\t\\t(i == len(events) and del_merged != yrange)):\\n\\t\\t\\treturn False\\n\\n\\treturn True\\n\\ndef merge_ints(self, intervals: List[List[int]], merged: List[List[int]]) -> bool:\\n\\tfor interval in intervals:\\n\\t\\t\\tif not merged or merged[-1][1] < interval[0]:\\n\\t\\t\\t\\tmerged.append([interval[0], interval[1]])\\n\\t\\t\\telif merged[-1][1] == interval[0]:\\n\\t\\t\\t\\tmerged[-1][1] = max(merged[-1][1], interval[1])\\n\\t\\t\\telse:\\n\\t\\t\\t\\treturn False\\n\\treturn True\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndef isRectangleCover(self, rectangles: List[List[int]]) -> bool:\\n\\tevents = []\\n\\tfor i, r in enumerate(rectangles):\\n\\t\\tevents += [(r[0], r[1], True, i), (r[2], r[1], False, i)]\\n\\tevents.sort()\\n\\n\\ti = 0\\n\\n\\tyrange = []\\n\\twhile i < len(events):\\n\\t\\tx = events[i][0]\\n\\t\\tadd_intervals = []\\n\\t\\tdel_intervals = []\\n\\t\\twhile i < len(events) and events[i][0] == x:\\n\\t\\t\\t\\tr = rectangles[events[i][3]]\\n\\t\\t\\t\\tinterval = [r[1], r[3]]\\n\\t\\t\\t\\tif events[i][2]:\\n\\t\\t\\t\\t\\tadd_intervals.append(interval)\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tdel_intervals.append(interval)\\n\\t\\t\\t\\ti = i + 1\\n\\t\\tif yrange == []:\\n\\t\\t\\tself.merge_ints(add_intervals, yrange)\\n\\t\\t\\tif len(yrange) != 1:\\n\\t\\t\\t\\treturn False\\n\\t\\t\\tcontinue\\n\\t\\tadd_merged = []\\n\\t\\tdel_merged = []\\n\\t\\tif (not self.merge_ints(add_intervals, add_merged) or\\n\\t\\t\\t\\tnot self.merge_ints(del_intervals, del_merged) or\\n\\t\\t\\t\\t(i != len(events) and del_merged != add_merged) or\\n\\t\\t\\t\\t(i == len(events) and del_merged != yrange)):\\n\\t\\t\\treturn False\\n\\n\\treturn True\\n\\ndef merge_ints(self, intervals: List[List[int]], merged: List[List[int]]) -> bool:\\n\\tfor interval in intervals:\\n\\t\\t\\tif not merged or merged[-1][1] < interval[0]:\\n\\t\\t\\t\\tmerged.append([interval[0], interval[1]])\\n\\t\\t\\telif merged[-1][1] == interval[0]:\\n\\t\\t\\t\\tmerged[-1][1] = max(merged[-1][1], interval[1])\\n\\t\\t\\telse:\\n\\t\\t\\t\\treturn False\\n\\treturn True\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3738241,
                "title": "java-solution-in-o-n",
                "content": "# Intuition\\nThe key idea is that in a perfect rectangle, all interior points should have a count of 0, and the corners should have counts of 1 or -1.\\n\\nBy iterating through all the rectangles, we keep track of the counts of each corner point encountered.\\n\\n# Approach\\nThe code first checks if the number of rectangles is 1. If so, it directly returns true because a single rectangle is always a perfect rectangle.\\n\\nIt creates a Map called pointCounts to store the count of points encountered while processing the rectangles. The key of the map is a Pair object representing the coordinates of the point, and the value is the count.\\n\\nThe code iterates through each rectangle in the input array. For each rectangle, it creates four Pair objects representing the bottom left, top right, bottom right, and top left points.\\n\\nIt increments the count for the bottom left and top right points, and decrements the count for the bottom right and top left points in the pointCounts map.\\n\\nAfter processing all the rectangles, the code checks the pointCounts map. If the count for any point is non-zero, it means it is an interior point or a corner point of multiple rectangles. In a perfect rectangle, all interior points should have a count of 0, and corners should have counts of 1 or -1.\\n\\nThe code also checks if the absolute value of the count is not more than 1. This condition ensures that overlapping corners of non-perfect rectangles do not affect the result.\\n\\nIf any of the above conditions fail, the code returns false as it indicates that the rectangles cannot form a perfect rectangle.\\n\\nFinally, the code checks if the number of marked points is 4, which corresponds to the four corners of the outer rectangle. If it is 4, it means the rectangles form a perfect rectangle, and it returns true.\\n\\n# Complexity\\n- Time complexity:\\n    O(n)\\n\\n- Space complexity:\\n    O(n)\\n# Code\\n```\\nimport java.util.HashMap;\\nimport java.util.Map;\\n\\nclass Solution {\\n    public boolean isRectangleCover(int[][] rectangles) {\\n        int n = rectangles.length;\\n\\n        if (n == 1) {\\n            return true;\\n        }\\n\\n        // Maps all points to a respective calculation. If it is a valid rectangle,\\n        // all interior points should have count 0, bottom left most and top right\\n        // most point should have value 1, and top left and bottom right should have\\n        // count -1. If it is different than this, it is not a perfect rectangle.\\n        Map<Pair, Integer> pointCounts = new HashMap<>();\\n\\n        for (int[] rect : rectangles) {\\n            Pair bottomLeft = new Pair(rect[0], rect[1]);\\n            Pair topRight = new Pair(rect[2], rect[3]);\\n            Pair bottomRight = new Pair(rect[2], rect[1]);\\n            Pair topLeft = new Pair(rect[0], rect[3]);\\n\\n            // Increment count for bottom left and top right points\\n            pointCounts.put(bottomLeft, pointCounts.getOrDefault(bottomLeft, 0) + 1);\\n            pointCounts.put(topRight, pointCounts.getOrDefault(topRight, 0) + 1);\\n            \\n            // Decrement count for bottom right and top left points\\n            pointCounts.put(bottomRight, pointCounts.getOrDefault(bottomRight, 0) - 1);\\n            pointCounts.put(topLeft, pointCounts.getOrDefault(topLeft, 0) - 1);\\n        }\\n\\n        int numMarks = 0;\\n\\n        for (Map.Entry<Pair, Integer> entry : pointCounts.entrySet()) {\\n            if (entry.getValue() != 0) {\\n\\n                // This condition is added because in non-perfect rectangles,\\n                // overlapping corners will cause the absolute value of that corner to go beyond 1.\\n                if (Math.abs(entry.getValue()) != 1) {\\n                    return false;\\n                }\\n\\n                numMarks++;\\n            }\\n        }\\n\\n        // Check if the number of marked points is 4, indicating a perfect rectangle\\n        return numMarks == 4;\\n    }\\n\\n    // Helper class to represent a pair of integers\\n    private class Pair {\\n        int first;\\n        int second;\\n\\n        public Pair(int first, int second) {\\n            this.first = first;\\n            this.second = second;\\n        }\\n\\n        // Override the equals() method to compare Pair objects\\n        @Override\\n        public boolean equals(Object obj) {\\n            if (this == obj) {\\n                return true;\\n            }\\n            if (obj == null || getClass() != obj.getClass()) {\\n                return false;\\n            }\\n            Pair other = (Pair) obj;\\n            return first == other.first && second == other.second;\\n        }\\n\\n        // Override the hashCode() method for proper hashing in the HashMap\\n        @Override\\n        public int hashCode() {\\n            return 31 * first + second;\\n        }\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.HashMap;\\nimport java.util.Map;\\n\\nclass Solution {\\n    public boolean isRectangleCover(int[][] rectangles) {\\n        int n = rectangles.length;\\n\\n        if (n == 1) {\\n            return true;\\n        }\\n\\n        // Maps all points to a respective calculation. If it is a valid rectangle,\\n        // all interior points should have count 0, bottom left most and top right\\n        // most point should have value 1, and top left and bottom right should have\\n        // count -1. If it is different than this, it is not a perfect rectangle.\\n        Map<Pair, Integer> pointCounts = new HashMap<>();\\n\\n        for (int[] rect : rectangles) {\\n            Pair bottomLeft = new Pair(rect[0], rect[1]);\\n            Pair topRight = new Pair(rect[2], rect[3]);\\n            Pair bottomRight = new Pair(rect[2], rect[1]);\\n            Pair topLeft = new Pair(rect[0], rect[3]);\\n\\n            // Increment count for bottom left and top right points\\n            pointCounts.put(bottomLeft, pointCounts.getOrDefault(bottomLeft, 0) + 1);\\n            pointCounts.put(topRight, pointCounts.getOrDefault(topRight, 0) + 1);\\n            \\n            // Decrement count for bottom right and top left points\\n            pointCounts.put(bottomRight, pointCounts.getOrDefault(bottomRight, 0) - 1);\\n            pointCounts.put(topLeft, pointCounts.getOrDefault(topLeft, 0) - 1);\\n        }\\n\\n        int numMarks = 0;\\n\\n        for (Map.Entry<Pair, Integer> entry : pointCounts.entrySet()) {\\n            if (entry.getValue() != 0) {\\n\\n                // This condition is added because in non-perfect rectangles,\\n                // overlapping corners will cause the absolute value of that corner to go beyond 1.\\n                if (Math.abs(entry.getValue()) != 1) {\\n                    return false;\\n                }\\n\\n                numMarks++;\\n            }\\n        }\\n\\n        // Check if the number of marked points is 4, indicating a perfect rectangle\\n        return numMarks == 4;\\n    }\\n\\n    // Helper class to represent a pair of integers\\n    private class Pair {\\n        int first;\\n        int second;\\n\\n        public Pair(int first, int second) {\\n            this.first = first;\\n            this.second = second;\\n        }\\n\\n        // Override the equals() method to compare Pair objects\\n        @Override\\n        public boolean equals(Object obj) {\\n            if (this == obj) {\\n                return true;\\n            }\\n            if (obj == null || getClass() != obj.getClass()) {\\n                return false;\\n            }\\n            Pair other = (Pair) obj;\\n            return first == other.first && second == other.second;\\n        }\\n\\n        // Override the hashCode() method for proper hashing in the HashMap\\n        @Override\\n        public int hashCode() {\\n            return 31 * first + second;\\n        }\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3737036,
                "title": "solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def isRectangleCover(self, rectangles: List[List[int]]) -> bool:\\n        X1, Y1 = float(\\'inf\\'), float(\\'inf\\')\\n        X2, Y2 = -float(\\'inf\\'), -float(\\'inf\\')\\n        \\n        points = set()\\n        actual_area = 0\\n        for x1, y1, x2, y2 in rectangles:\\n            # \\u8BA1\\u7B97\\u5B8C\\u7F8E\\u77E9\\u5F62\\u7684\\u7406\\u8BBA\\u9876\\u70B9\\u5750\\u6807\\n            X1, Y1 = min(X1, x1), min(Y1, y1)\\n            X2, Y2 = max(X2, x2), max(Y2, y2)\\n            # \\u7D2F\\u52A0\\u5C0F\\u77E9\\u5F62\\u7684\\u9762\\u79EF\\n            actual_area += (x2 - x1) * (y2 - y1)\\n            # \\u8BB0\\u5F55\\u6700\\u7EC8\\u5F62\\u6210\\u7684\\u56FE\\u5F62\\u4E2D\\u7684\\u9876\\u70B9\\n            p1, p2 = (x1, y1), (x1, y2)\\n            p3, p4 = (x2, y1), (x2, y2)\\n            for p in [p1, p2, p3, p4]:\\n                if p in points: points.remove(p)\\n                else:           points.add(p)\\n        # \\u5224\\u65AD\\u9762\\u79EF\\u662F\\u5426\\u76F8\\u540C\\n        expected_area = (X2 - X1) * (Y2 - Y1)\\n        if actual_area != expected_area:\\n            return False\\n        # \\u5224\\u65AD\\u6700\\u7EC8\\u7559\\u4E0B\\u7684\\u9876\\u70B9\\u4E2A\\u6570\\u662F\\u5426\\u4E3A 4\\n        if len(points) != 4:       return False\\n        # \\u5224\\u65AD\\u7559\\u4E0B\\u7684 4 \\u4E2A\\u9876\\u70B9\\u662F\\u5426\\u662F\\u5B8C\\u7F8E\\u77E9\\u5F62\\u7684\\u9876\\u70B9\\n        if (X1, Y1) not in points: return False\\n        if (X1, Y2) not in points: return False\\n        if (X2, Y1) not in points: return False\\n        if (X2, Y2) not in points: return False\\n        # \\u9762\\u79EF\\u548C\\u9876\\u70B9\\u90FD\\u5BF9\\u5E94\\uFF0C\\u8BF4\\u660E\\u77E9\\u5F62\\u7B26\\u5408\\u9898\\u610F\\n        return True\\n            \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isRectangleCover(self, rectangles: List[List[int]]) -> bool:\\n        X1, Y1 = float(\\'inf\\'), float(\\'inf\\')\\n        X2, Y2 = -float(\\'inf\\'), -float(\\'inf\\')\\n        \\n        points = set()\\n        actual_area = 0\\n        for x1, y1, x2, y2 in rectangles:\\n            # \\u8BA1\\u7B97\\u5B8C\\u7F8E\\u77E9\\u5F62\\u7684\\u7406\\u8BBA\\u9876\\u70B9\\u5750\\u6807\\n            X1, Y1 = min(X1, x1), min(Y1, y1)\\n            X2, Y2 = max(X2, x2), max(Y2, y2)\\n            # \\u7D2F\\u52A0\\u5C0F\\u77E9\\u5F62\\u7684\\u9762\\u79EF\\n            actual_area += (x2 - x1) * (y2 - y1)\\n            # \\u8BB0\\u5F55\\u6700\\u7EC8\\u5F62\\u6210\\u7684\\u56FE\\u5F62\\u4E2D\\u7684\\u9876\\u70B9\\n            p1, p2 = (x1, y1), (x1, y2)\\n            p3, p4 = (x2, y1), (x2, y2)\\n            for p in [p1, p2, p3, p4]:\\n                if p in points: points.remove(p)\\n                else:           points.add(p)\\n        # \\u5224\\u65AD\\u9762\\u79EF\\u662F\\u5426\\u76F8\\u540C\\n        expected_area = (X2 - X1) * (Y2 - Y1)\\n        if actual_area != expected_area:\\n            return False\\n        # \\u5224\\u65AD\\u6700\\u7EC8\\u7559\\u4E0B\\u7684\\u9876\\u70B9\\u4E2A\\u6570\\u662F\\u5426\\u4E3A 4\\n        if len(points) != 4:       return False\\n        # \\u5224\\u65AD\\u7559\\u4E0B\\u7684 4 \\u4E2A\\u9876\\u70B9\\u662F\\u5426\\u662F\\u5B8C\\u7F8E\\u77E9\\u5F62\\u7684\\u9876\\u70B9\\n        if (X1, Y1) not in points: return False\\n        if (X1, Y2) not in points: return False\\n        if (X2, Y1) not in points: return False\\n        if (X2, Y2) not in points: return False\\n        # \\u9762\\u79EF\\u548C\\u9876\\u70B9\\u90FD\\u5BF9\\u5E94\\uFF0C\\u8BF4\\u660E\\u77E9\\u5F62\\u7B26\\u5408\\u9898\\u610F\\n        return True\\n            \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3732171,
                "title": "perfect-rectangle",
                "content": "# Intuition\\nAll rectangles form an exact rectangle cover if:\\n1. The area of the rectangle cover is equal to the area of all rectangles.\\n2. Any point should appear even times as (a corner of a small triangle), otherwise there will be overlaps or gaps. So we can maintain a set to store the corner points. If the number of a point is even, this point will be removed from the set. At last, there should be only 4 points in the set.\\n3. The 4 points should be exactly the 4 corners of the rectangle cover.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def isRectangleCover(self, rectangles: List[List[int]]) -> bool:\\n        points = set()\\n        X1, Y1 = float(\\'inf\\'), float(\\'inf\\')\\n        X2, Y2 = -float(\\'inf\\'), -float(\\'inf\\')\\n\\n        for x1, y1, x2, y2 in rectangles:\\n            X1 = min(x1, X1)\\n            Y1 = min(y1, Y1)\\n            X2 = max(x2, X2)\\n            Y2 = max(y2, Y2)\\n        \\n        size = (X2 - X1) * (Y2 - Y1)\\n        actual_size = 0\\n\\n        for x1, y1, x2, y2 in rectangles:\\n            p_list = [(x1, y1), (x2, y1), (x1, y2), (x2, y2)]\\n            for p in p_list:\\n                if p not in points:\\n                    points.add(p)\\n                else:\\n                    points.remove(p)\\n            actual_size += (x2 - x1) * (y2 - y1)\\n        \\n        if actual_size != size:\\n            return False\\n        \\n        if len(points) != 4:\\n            return False\\n\\n        if ((X1, Y1) not in points) or ((X1, Y2) not in points) or ((X2, Y1) not in points) or ((X2, Y2) not in points):\\n            return False\\n        \\n        return True\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isRectangleCover(self, rectangles: List[List[int]]) -> bool:\\n        points = set()\\n        X1, Y1 = float(\\'inf\\'), float(\\'inf\\')\\n        X2, Y2 = -float(\\'inf\\'), -float(\\'inf\\')\\n\\n        for x1, y1, x2, y2 in rectangles:\\n            X1 = min(x1, X1)\\n            Y1 = min(y1, Y1)\\n            X2 = max(x2, X2)\\n            Y2 = max(y2, Y2)\\n        \\n        size = (X2 - X1) * (Y2 - Y1)\\n        actual_size = 0\\n\\n        for x1, y1, x2, y2 in rectangles:\\n            p_list = [(x1, y1), (x2, y1), (x1, y2), (x2, y2)]\\n            for p in p_list:\\n                if p not in points:\\n                    points.add(p)\\n                else:\\n                    points.remove(p)\\n            actual_size += (x2 - x1) * (y2 - y1)\\n        \\n        if actual_size != size:\\n            return False\\n        \\n        if len(points) != 4:\\n            return False\\n\\n        if ((X1, Y1) not in points) or ((X1, Y2) not in points) or ((X2, Y1) not in points) or ((X2, Y2) not in points):\\n            return False\\n        \\n        return True\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3731543,
                "title": "391-perfect-rectangle-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe right answer must satisfy two conditions:\\n\\n1. the large rectangle area should be equal to the sum of small rectangles\\n2. count of all the points should be even, and that of all the four corner points should be one\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. calculate the left lower point (X1, Y1) and right upper point (X2, Y2) of the large rectangle\\n2. record the points: if the point doesn\\'t exist, add it; else remove it\\n3. judge two conditions: large area == sum of small areas?\\nthere are only 4 points (i.e. 4 points of the large rectangle) in the point set.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n# Code\\n```\\nclass Solution {\\n    public boolean isRectangleCover(int[][] rectangles) {\\n        int n = rectangles.length;\\n        int X1 = Integer.MAX_VALUE, Y1 = Integer.MAX_VALUE;\\n        int X2 = Integer.MIN_VALUE, Y2 = Integer.MIN_VALUE;\\n        HashSet<String> set = new HashSet<>();\\n        int area = 0;\\n        for (int[] rec : rectangles){\\n            X1 = Math.min(X1, rec[0]);\\n            Y1 = Math.min(Y1, rec[1]);\\n            X2 = Math.max(X2, rec[2]);\\n            Y2 = Math.max(Y2, rec[3]);\\n            area += (rec[2] - rec[0]) * (rec[3] - rec[1]);\\n            String s1 = rec[0] + \" \" + rec[1];\\n            String s2 = rec[0] + \" \" + rec[3];\\n            String s3 = rec[2] + \" \" + rec[1];\\n            String s4 = rec[2] + \" \" + rec[3];\\n            if (!set.add(s1)) set.remove(s1);\\n            if (!set.add(s2)) set.remove(s2);\\n            if (!set.add(s3)) set.remove(s3);\\n            if (!set.add(s4)) set.remove(s4);\\n        }\\n        if (!set.contains(X1 + \" \" + Y1) || !set.contains(X1 + \" \" + Y2) || !set.contains(X2 + \" \" + Y1) || !set.contains(X2 + \" \" + Y2) || set.size() != 4) return false;\\n        return area == (X2 - X1) * (Y2 - Y1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isRectangleCover(int[][] rectangles) {\\n        int n = rectangles.length;\\n        int X1 = Integer.MAX_VALUE, Y1 = Integer.MAX_VALUE;\\n        int X2 = Integer.MIN_VALUE, Y2 = Integer.MIN_VALUE;\\n        HashSet<String> set = new HashSet<>();\\n        int area = 0;\\n        for (int[] rec : rectangles){\\n            X1 = Math.min(X1, rec[0]);\\n            Y1 = Math.min(Y1, rec[1]);\\n            X2 = Math.max(X2, rec[2]);\\n            Y2 = Math.max(Y2, rec[3]);\\n            area += (rec[2] - rec[0]) * (rec[3] - rec[1]);\\n            String s1 = rec[0] + \" \" + rec[1];\\n            String s2 = rec[0] + \" \" + rec[3];\\n            String s3 = rec[2] + \" \" + rec[1];\\n            String s4 = rec[2] + \" \" + rec[3];\\n            if (!set.add(s1)) set.remove(s1);\\n            if (!set.add(s2)) set.remove(s2);\\n            if (!set.add(s3)) set.remove(s3);\\n            if (!set.add(s4)) set.remove(s4);\\n        }\\n        if (!set.contains(X1 + \" \" + Y1) || !set.contains(X1 + \" \" + Y2) || !set.contains(X2 + \" \" + Y1) || !set.contains(X2 + \" \" + Y2) || set.size() != 4) return false;\\n        return area == (X2 - X1) * (Y2 - Y1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3730512,
                "title": "math",
                "content": "# Intuition\\n\\u8FD9\\u9898\\u5C5E\\u4E8E\\u96BE\\u8005\\u4E0D\\u4F1A\\u4F1A\\u8005\\u4E0D\\u96BE\\u3002\\n\\u4E3B\\u8981\\u4ECE\\u4E24\\u4E2A\\u89D2\\u5EA6\\u5165\\u624B\\uFF0C\\u4E00\\u4E2A\\u662F\\u9762\\u79EF\\uFF0C\\u4E00\\u4E2A\\u662F\\u9876\\u70B9\\u4E2A\\u6570\\u3002\\n\\n- \\u9996\\u5148\\u5404\\u4E2A\\u5C0F\\u77E9\\u5F62\\u5982\\u679C\\u80FD\\u7EC4\\u6210perfect rectangle\\uFF0C\\u90A3\\u4E48\\u603B\\u9762\\u79EF\\u548C\\u4E00\\u5B9A\\u7B49\\u4E8E\\u65B0\\u7684\\u77E9\\u5F62\\u7684\\u9762\\u79EF\\u3002\\u53EF\\u4EE5\\u5F88\\u5BB9\\u6613\\u5730\\u627E\\u5230\\u5DE6\\u4E0B\\u89D2\\u548C\\u53F3\\u4E0A\\u89D2\\u7684\\u70B9\\u7684x\\uFF0Cy\\u5750\\u6807\\u3002\\n- \\u4F46\\u662F\\u8FD9\\u8FD8\\u662F\\u4E0D\\u591F\\u7684\\uFF0C\\u56E0\\u4E3A\\u53EF\\u80FD\\u5B58\\u5728\\u4E24\\u4E2A\\u77E9\\u5F62\\u9762\\u79EF\\u91CD\\u5408\\u7684\\u60C5\\u51B5\\n- \\u73B0\\u5728\\u5C31\\u518D\\u9700\\u8981\\u6839\\u636E\\u9876\\u70B9\\u5224\\u65AD\\u4E86\\uFF0C\\u6BCF\\u4E2A\\u5C0F\\u77E9\\u5F62\\u76844\\u4E2A\\u9876\\u70B9\\u90FD\\u53EF\\u4EE5\\u505A\\u8BB0\\u5F55\\uFF0C\\u5982\\u679C\\u6700\\u7EC8\\u80FD\\u7EC4\\u6210perfect rectangle\\u90A3\\u4E48\\u4E00\\u5B9A\\u53EA\\u67094\\u4E2A\\u9876\\u70B9\\u51FA\\u73B0\\u5947\\u6570\\u6B21\\u3002\\u8FD9\\u91CC\\u53EF\\u4EE5\\u5DE7\\u7528set\\uFF0C\\u51FA\\u73B0\\u8FC7\\u5C31remove\\uFF0C\\u53CD\\u6B63\\u5219add\\uFF0C\\u6700\\u540E\\u53EA\\u8981\\u5224\\u65ADsize\\u5373\\u53EF\\n- \\u8FD9\\u91CC\\u4ECD\\u7136\\u662F\\u4E0D\\u591F\\u7684\\uFF0C\\u8FD8\\u9700\\u8981\\u8FDB\\u4E00\\u6B65\\u5224\\u5B9A\\u6700\\u540E\\u7684\\u8FD94\\u4E2A\\u70B9\\u7EC4\\u6210\\u7684\\u603B\\u9762\\u79EF\\u662F\\u4E0D\\u662F\\u8DDF\\u603Barea\\u76F8\\u540C\\u6216\\u8005\\u4E5F\\u53EF\\u4EE5\\u5224\\u5B9A\\u4E4B\\u524D\\u7684\\u5DE6\\u4E0B\\u89D2\\u548C\\u53F3\\u4E0A\\u89D2\\u7684\\u4E24\\u4E2A\\u70B9\\u662F\\u4E0D\\u662F\\u5728set\\u91CC\\u9762\\u3002\\n\\n# Code\\n```\\nclass Solution {\\n    data class Point(val x: Int, val y: Int)\\n    fun isRectangleCover(rectangles: Array<IntArray>): Boolean {\\n        var x1 = Int.MAX_VALUE\\n        var y1 = Int.MAX_VALUE\\n        var x2 = Int.MIN_VALUE\\n        var y2 = Int.MIN_VALUE\\n\\n        var area = 0\\n        val points = mutableSetOf<Point>()\\n\\n        for ((x, y, a, b) in rectangles) {\\n            x1 = Math.min(x1, x)\\n            y1 = Math.min(y1, y)\\n            x2 = Math.max(x2, a)\\n            y2 = Math.max(y2, b)\\n\\n            area += (a - x) * (b - y)\\n\\n            checkPoint(Point(x, y), points)\\n            checkPoint(Point(x, b), points)\\n            checkPoint(Point(a, y), points)\\n            checkPoint(Point(a, b), points)\\n        }\\n\\n        if (area != (x2 - x1) * (y2 - y1) || points.size != 4) return false\\n        return Point(x1, y1) in points && Point(x2, y2) in points\\n    }\\n\\n    fun checkPoint(p: Point, points: MutableSet<Point>) {\\n        if (p in points) {\\n            points.remove(p)\\n        } else {\\n            points.add(p)\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    data class Point(val x: Int, val y: Int)\\n    fun isRectangleCover(rectangles: Array<IntArray>): Boolean {\\n        var x1 = Int.MAX_VALUE\\n        var y1 = Int.MAX_VALUE\\n        var x2 = Int.MIN_VALUE\\n        var y2 = Int.MIN_VALUE\\n\\n        var area = 0\\n        val points = mutableSetOf<Point>()\\n\\n        for ((x, y, a, b) in rectangles) {\\n            x1 = Math.min(x1, x)\\n            y1 = Math.min(y1, y)\\n            x2 = Math.max(x2, a)\\n            y2 = Math.max(y2, b)\\n\\n            area += (a - x) * (b - y)\\n\\n            checkPoint(Point(x, y), points)\\n            checkPoint(Point(x, b), points)\\n            checkPoint(Point(a, y), points)\\n            checkPoint(Point(a, b), points)\\n        }\\n\\n        if (area != (x2 - x1) * (y2 - y1) || points.size != 4) return false\\n        return Point(x1, y1) in points && Point(x2, y2) in points\\n    }\\n\\n    fun checkPoint(p: Point, points: MutableSet<Point>) {\\n        if (p in points) {\\n            points.remove(p)\\n        } else {\\n            points.add(p)\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3729658,
                "title": "c-faster-than-81-86",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe will count the corners for each rectangle and use map to store the corners at each coordiante.  \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. use unordered_map to store coordinate and a number to represent bits cooresponding to each corner. We will times 10^6 to the first coordiante and plus the second coordinate(because the absolute value on the axis of coordinate will not overpass 10^5). Then the short value represents the corners. \\nleft bottom corner: bit[3]--8\\nleft upper corner: bit[2]--4\\nright upper corner: bit[1]--2\\nright bottom corner: bit[0]--1\\n2. return false if the corner has already existed\\n3. for each pair stored in map, find whether the corners can match a corner. The cases are listed in the code. Count the corners if the number of corners equal to 1\\n4. return whether the number of corners equals to 4. \\n\\n# Complexity\\n- Time complexity:\\n- O(n). We will iterate each coordinate in the vector\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(n): store each coordinate and its corners in the map. \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isRectangleCover(vector<vector<int>>& rectangles) {\\n        unordered_map<long long, short>hash_rec;\\n        long long coordinate;\\n        for(vector<int> rectangle:rectangles){\\n            // left bottom corner\\n            coordinate=1LL*rectangle[0]*1e6+rectangle[1];\\n            if(!hash_rec.count(coordinate)){\\n                hash_rec[coordinate]=8;\\n            }\\n            else if ((hash_rec[coordinate]&8)!=0){\\n                return false;\\n            }\\n            hash_rec[coordinate]|=8;\\n\\n            // left upper corner\\n            coordinate=1LL*rectangle[0]*1e6+rectangle[3];\\n            if(!hash_rec.count(coordinate)){\\n                hash_rec[coordinate]=4;\\n            }\\n            else if ((hash_rec[coordinate]&4)!=0){\\n                return false;\\n            }\\n            hash_rec[coordinate]|=4;\\n\\n            // right upper corner\\n            coordinate=1LL*rectangle[2]*1e6+rectangle[3];\\n            if(!hash_rec.count(coordinate)){\\n                hash_rec[coordinate]=2;\\n            }\\n            else if ((hash_rec[coordinate]&2)!=0){\\n                return false;\\n            }\\n            hash_rec[coordinate]|=2;\\n\\n            // right bottom corner\\n            coordinate=1LL*rectangle[2]*1e6+rectangle[1];\\n            if(!hash_rec.count(coordinate)){\\n                hash_rec[coordinate]=1;\\n            }\\n            else if ((hash_rec[coordinate]&1)!=0){\\n                return false;\\n            }\\n            hash_rec[coordinate]|=1;\\n        }\\n        int corner_count=0;\\n        // map<pair<int,int>, int>::iterator it=hash_rec.begin();\\n        for(auto it:hash_rec){\\n            switch(it.second){\\n                case 8: case 4: case 2: case 1:\\n                    corner_count += 1;\\n                    break;\\n                case 14: case 13: case 11: case 10: case 7: case 5:\\n                    return false;\\n                default:\\n                    break;\\n            }\\n            if(corner_count>4){\\n                return false;\\n            }\\n        }\\n        return corner_count==4;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isRectangleCover(vector<vector<int>>& rectangles) {\\n        unordered_map<long long, short>hash_rec;\\n        long long coordinate;\\n        for(vector<int> rectangle:rectangles){\\n            // left bottom corner\\n            coordinate=1LL*rectangle[0]*1e6+rectangle[1];\\n            if(!hash_rec.count(coordinate)){\\n                hash_rec[coordinate]=8;\\n            }\\n            else if ((hash_rec[coordinate]&8)!=0){\\n                return false;\\n            }\\n            hash_rec[coordinate]|=8;\\n\\n            // left upper corner\\n            coordinate=1LL*rectangle[0]*1e6+rectangle[3];\\n            if(!hash_rec.count(coordinate)){\\n                hash_rec[coordinate]=4;\\n            }\\n            else if ((hash_rec[coordinate]&4)!=0){\\n                return false;\\n            }\\n            hash_rec[coordinate]|=4;\\n\\n            // right upper corner\\n            coordinate=1LL*rectangle[2]*1e6+rectangle[3];\\n            if(!hash_rec.count(coordinate)){\\n                hash_rec[coordinate]=2;\\n            }\\n            else if ((hash_rec[coordinate]&2)!=0){\\n                return false;\\n            }\\n            hash_rec[coordinate]|=2;\\n\\n            // right bottom corner\\n            coordinate=1LL*rectangle[2]*1e6+rectangle[1];\\n            if(!hash_rec.count(coordinate)){\\n                hash_rec[coordinate]=1;\\n            }\\n            else if ((hash_rec[coordinate]&1)!=0){\\n                return false;\\n            }\\n            hash_rec[coordinate]|=1;\\n        }\\n        int corner_count=0;\\n        // map<pair<int,int>, int>::iterator it=hash_rec.begin();\\n        for(auto it:hash_rec){\\n            switch(it.second){\\n                case 8: case 4: case 2: case 1:\\n                    corner_count += 1;\\n                    break;\\n                case 14: case 13: case 11: case 10: case 7: case 5:\\n                    return false;\\n                default:\\n                    break;\\n            }\\n            if(corner_count>4){\\n                return false;\\n            }\\n        }\\n        return corner_count==4;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3727970,
                "title": "java-07062023",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public boolean isRectangleCover(int[][] rectangles) {\\n        int X1 = Integer.MAX_VALUE, Y1 = Integer.MAX_VALUE;\\n        int X2 = Integer.MIN_VALUE, Y2 = Integer.MIN_VALUE;\\n        int totalArea = 0;\\n        // to record vertices\\n        HashSet<String> vertices = new HashSet<>();\\n        for (int[] rectangle : rectangles) {\\n            // Remove point if already in vertices set, add it if not in\\n            String x1y1 = String.valueOf(rectangle[0]) + String.valueOf(rectangle[1]);\\n            String x2y2 = String.valueOf(rectangle[2]) + String.valueOf(rectangle[3]);\\n            String x1y2 = String.valueOf(rectangle[0]) + String.valueOf(rectangle[3]);\\n            String x2y1 = String.valueOf(rectangle[2]) + String.valueOf(rectangle[1]);\\n\\n            if (!vertices.contains(x1y1)) {\\n                vertices.add(x1y1);\\n            } else {\\n                vertices.remove(x1y1);\\n            }\\n            if (!vertices.contains(x2y2)) {\\n                vertices.add(x2y2);\\n            } else {\\n                vertices.remove(x2y2);\\n            }\\n            if (!vertices.contains(x1y2)) {\\n                vertices.add(x1y2);\\n            } else {\\n                vertices.remove(x1y2);\\n            }\\n            if (!vertices.contains(x2y1)) {\\n                vertices.add(x2y1);\\n            } else {\\n                vertices.remove(x2y1);\\n            }\\n            X1 = Math.min(X1, rectangle[0]);\\n            Y1 = Math.min(Y1, rectangle[1]);\\n            X2 = Math.max(X2, rectangle[2]);\\n            Y2 = Math.max(Y2, rectangle[3]);\\n            totalArea += (rectangle[2]-rectangle[0]) * (rectangle[3]-rectangle[1]);\\n        }\\n        String x1y1 = String.valueOf(X1) + String.valueOf(Y1);\\n        if (!vertices.contains(x1y1)) return false;\\n        String x2y2 = String.valueOf(X2) + String.valueOf(Y2);\\n        if (!vertices.contains(x2y2)) return false;\\n        String x1y2 = String.valueOf(X1) + String.valueOf(Y2);\\n        if (!vertices.contains(x1y2)) return false;\\n        String x2y1 = String.valueOf(X2) + String.valueOf(Y1);\\n        if (!vertices.contains(x2y1)) return false;\\n\\n        return vertices.size() == 4 && (X2-X1) * (Y2-Y1) == totalArea;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isRectangleCover(int[][] rectangles) {\\n        int X1 = Integer.MAX_VALUE, Y1 = Integer.MAX_VALUE;\\n        int X2 = Integer.MIN_VALUE, Y2 = Integer.MIN_VALUE;\\n        int totalArea = 0;\\n        // to record vertices\\n        HashSet<String> vertices = new HashSet<>();\\n        for (int[] rectangle : rectangles) {\\n            // Remove point if already in vertices set, add it if not in\\n            String x1y1 = String.valueOf(rectangle[0]) + String.valueOf(rectangle[1]);\\n            String x2y2 = String.valueOf(rectangle[2]) + String.valueOf(rectangle[3]);\\n            String x1y2 = String.valueOf(rectangle[0]) + String.valueOf(rectangle[3]);\\n            String x2y1 = String.valueOf(rectangle[2]) + String.valueOf(rectangle[1]);\\n\\n            if (!vertices.contains(x1y1)) {\\n                vertices.add(x1y1);\\n            } else {\\n                vertices.remove(x1y1);\\n            }\\n            if (!vertices.contains(x2y2)) {\\n                vertices.add(x2y2);\\n            } else {\\n                vertices.remove(x2y2);\\n            }\\n            if (!vertices.contains(x1y2)) {\\n                vertices.add(x1y2);\\n            } else {\\n                vertices.remove(x1y2);\\n            }\\n            if (!vertices.contains(x2y1)) {\\n                vertices.add(x2y1);\\n            } else {\\n                vertices.remove(x2y1);\\n            }\\n            X1 = Math.min(X1, rectangle[0]);\\n            Y1 = Math.min(Y1, rectangle[1]);\\n            X2 = Math.max(X2, rectangle[2]);\\n            Y2 = Math.max(Y2, rectangle[3]);\\n            totalArea += (rectangle[2]-rectangle[0]) * (rectangle[3]-rectangle[1]);\\n        }\\n        String x1y1 = String.valueOf(X1) + String.valueOf(Y1);\\n        if (!vertices.contains(x1y1)) return false;\\n        String x2y2 = String.valueOf(X2) + String.valueOf(Y2);\\n        if (!vertices.contains(x2y2)) return false;\\n        String x1y2 = String.valueOf(X1) + String.valueOf(Y2);\\n        if (!vertices.contains(x1y2)) return false;\\n        String x2y1 = String.valueOf(X2) + String.valueOf(Y1);\\n        if (!vertices.contains(x2y1)) return false;\\n\\n        return vertices.size() == 4 && (X2-X1) * (Y2-Y1) == totalArea;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3501957,
                "title": "swift-solution-find-point-not-repeated",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n1. Find four non-repeating points.\\n2. Sum the areas of each rectangle.\\n3. Calculate the area of the rectangle forme by step 1 four points.\\n4. Compare if it is equal to the sum obtained in step 2.\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution {\\n    func isRectangleCover(_ rectangles: [[Int]]) -> Bool {\\n        var corners: Set<[Int]> = []\\n        var areas = 0\\n        \\n        rectangles.forEach { point in\\n            let bottomLeft = [point[0], point[1]]\\n            let topLeft = [point[0], point[3]]\\n            let topRight = [point[2], point[3]]\\n            let bottomRight = [point[2], point[1]]\\n            \\n            if !corners.insert(bottomLeft).inserted {\\n                corners.remove(bottomLeft)\\n            }\\n            if !corners.insert(topLeft).inserted {\\n                corners.remove(topLeft)\\n            }\\n            if !corners.insert(topRight).inserted {\\n                corners.remove(topRight)\\n            }\\n            if !corners.insert(bottomRight).inserted {\\n                corners.remove(bottomRight)\\n            }\\n            let area = (topLeft[1] - bottomLeft[1]) * (bottomRight[0] - bottomLeft[0])\\n            areas += area\\n        }\\n        \\n        if corners.count != 4 {\\n            return false\\n        }\\n        \\n        let p1 = corners.removeFirst()\\n        let p2 = corners.removeFirst()\\n        let p3 = corners.removeFirst()\\n        let p4 = corners.removeFirst()\\n        let minx = min(p1[0], p2[0], p3[0], p4[0])\\n        let miny = min(p1[1], p2[1], p3[1], p4[1])\\n        let maxX = max(p1[0], p2[0], p3[0], p4[0])\\n        let maxY = max(p1[1], p2[1], p3[1], p4[1])\\n        let bigArea = (maxX - minx) * (maxY - miny)\\n        \\n        return bigArea == areas\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func isRectangleCover(_ rectangles: [[Int]]) -> Bool {\\n        var corners: Set<[Int]> = []\\n        var areas = 0\\n        \\n        rectangles.forEach { point in\\n            let bottomLeft = [point[0], point[1]]\\n            let topLeft = [point[0], point[3]]\\n            let topRight = [point[2], point[3]]\\n            let bottomRight = [point[2], point[1]]\\n            \\n            if !corners.insert(bottomLeft).inserted {\\n                corners.remove(bottomLeft)\\n            }\\n            if !corners.insert(topLeft).inserted {\\n                corners.remove(topLeft)\\n            }\\n            if !corners.insert(topRight).inserted {\\n                corners.remove(topRight)\\n            }\\n            if !corners.insert(bottomRight).inserted {\\n                corners.remove(bottomRight)\\n            }\\n            let area = (topLeft[1] - bottomLeft[1]) * (bottomRight[0] - bottomLeft[0])\\n            areas += area\\n        }\\n        \\n        if corners.count != 4 {\\n            return false\\n        }\\n        \\n        let p1 = corners.removeFirst()\\n        let p2 = corners.removeFirst()\\n        let p3 = corners.removeFirst()\\n        let p4 = corners.removeFirst()\\n        let minx = min(p1[0], p2[0], p3[0], p4[0])\\n        let miny = min(p1[1], p2[1], p3[1], p4[1])\\n        let maxX = max(p1[0], p2[0], p3[0], p4[0])\\n        let maxY = max(p1[1], p2[1], p3[1], p4[1])\\n        let bigArea = (maxX - minx) * (maxY - miny)\\n        \\n        return bigArea == areas\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3464939,
                "title": "scala-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nobject Solution {\\n    def isRectangleCover(rectangles: Array[Array[Int]]): Boolean = {\\n      if(rectangles.map(_.mkString(\"\",\",\",\"\")).toSet.size != rectangles.size) return false\\n      val acc = rectangles.flatMap(r => Array((r(0), r(1)), (r(2), r(1)), (r(2), r(3)), (r(0), r(3)))).groupBy(identity).mapValues(_.size).filter(_._2 == 1)\\n      if(acc.size != 4) return false\\n      val x = acc.keySet.toList.map(_._1)\\n      val y = acc.keySet.toList.map(_._2)\\n      rectangles.foldLeft(0)((acc, cur) =>{\\n        (cur(2) - cur(0)) * (cur(3) - cur(1)) + acc\\n      }) == (x.max - x.min) * (y.max - y.min)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n    def isRectangleCover(rectangles: Array[Array[Int]]): Boolean = {\\n      if(rectangles.map(_.mkString(\"\",\",\",\"\")).toSet.size != rectangles.size) return false\\n      val acc = rectangles.flatMap(r => Array((r(0), r(1)), (r(2), r(1)), (r(2), r(3)), (r(0), r(3)))).groupBy(identity).mapValues(_.size).filter(_._2 == 1)\\n      if(acc.size != 4) return false\\n      val x = acc.keySet.toList.map(_._1)\\n      val y = acc.keySet.toList.map(_._2)\\n      rectangles.foldLeft(0)((acc, cur) =>{\\n        (cur(2) - cur(0)) * (cur(3) - cur(1)) + acc\\n      }) == (x.max - x.min) * (y.max - y.min)\\n    }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3447098,
                "title": "python-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def isRectangleCover(self, rects: List[List[int]]) -> bool:\\n        area = 0\\n        corners = {}\\n        for x1, y1, x2, y2 in rects:\\n            area += (x2-x1)*(y2-y1)\\n            for corner in (x1, y1), (x1, y2), (x2, y1), (x2, y2):\\n                if corner not in corners:\\n                    corners[corner] = True\\n                else:\\n                    del corners[corner]\\n        \\n        if len(corners) != 4:\\n            return False\\n\\n        c = set(corners.keys())\\n        x1, y1 = min(c)\\n        x2, y2 = max(c)\\n\\n        return area == (x2-x1)*(y2-y1) and c == {(x1, y1), (x1, y2), (x2, y1), (x2, y2)}\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isRectangleCover(self, rects: List[List[int]]) -> bool:\\n        area = 0\\n        corners = {}\\n        for x1, y1, x2, y2 in rects:\\n            area += (x2-x1)*(y2-y1)\\n            for corner in (x1, y1), (x1, y2), (x2, y1), (x2, y2):\\n                if corner not in corners:\\n                    corners[corner] = True\\n                else:\\n                    del corners[corner]\\n        \\n        if len(corners) != 4:\\n            return False\\n\\n        c = set(corners.keys())\\n        x1, y1 = min(c)\\n        x2, y2 = max(c)\\n\\n        return area == (x2-x1)*(y2-y1) and c == {(x1, y1), (x1, y2), (x2, y1), (x2, y2)}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3424311,
                "title": "java-o-n",
                "content": "# Intuition\\n\\n-check that all rects are within the borders\\n-check that its corner apears twice or 4 times, adding one to the outer 4 corners in order to generalize that rule.\\n-assert that the area of the big rect match the sum of the smaller\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isRectangleCover(int[][] rectangles) {\\n        HashMap corners = new HashMap<String,Integer>();\\n        int [] topRight=rectangles[0];\\n        int[] btLeft = rectangles[0];\\n        int area = 0;\\n        for (int[] rect:rectangles){\\n            if (rect[0]<btLeft[0]) btLeft=rect;\\n            if (rect[0]==btLeft[0] && rect[1]<btLeft[1]) btLeft=rect;\\n\\n            if (rect[2]>topRight[2]) topRight=rect;\\n            if (rect[2]==topRight[2] && rect[3]>topRight[3]) topRight=rect;\\n            \\n            String corner1=\"\"+rect[0]+\",\"+rect[1];\\n            String corner2=\"\"+rect[2]+\",\"+rect[3];\\n            String corner3=\"\"+rect[0]+\",\"+rect[3];\\n            String corner4=\"\"+rect[2]+\",\"+rect[1];\\n            if (corners.containsKey(corner1)) corners.put(corner1,(int)(corners.get(corner1))+1);\\n            else corners.put(corner1,1);\\n            if (corners.containsKey(corner2)) corners.put(corner2,(int)(corners.get(corner2))+1);\\n            else corners.put(corner2,1);\\n            if (corners.containsKey(corner3)) corners.put(corner3,(int)(corners.get(corner3))+1);\\n            else corners.put(corner3,1);\\n            if (corners.containsKey(corner4)) corners.put(corner4,(int)(corners.get(corner4))+1);\\n            else corners.put(corner4,1);       \\n            area += (rect[2]-rect[0]) * (rect[3]-rect[1]);\\n        }\\n\\n        //assert -no rect goes lower than btLeft -no rect goes up from  topRight\\n        for (int[] rect:rectangles){\\n            if (rect[1]<btLeft[1]) return false;\\n            if (rect[3]>topRight[3]) return false;\\n        }\\n\\n        // now only need to check for overlap - we going to add a big rect including the full area, and now for each rect all 4 corners should be shared with 1 rect each, so each corner apears twice in the corners map.\\n        String corner1=\"\"+btLeft[0]+\",\"+btLeft[1];\\n        String corner2=\"\"+topRight[2]+\",\"+topRight[3];\\n        String corner3=\"\"+btLeft[0]+\",\"+topRight[3];\\n        String corner4=\"\"+topRight[2]+\",\"+btLeft[1];\\n        if (!corners.containsKey(corner1)||!corners.containsKey(corner2)||!corners.containsKey(corner3)||!corners.containsKey(corner4)) return false;\\n        corners.put(corner1,(int)(corners.get(corner1))+1);\\n        corners.put(corner2,(int)(corners.get(corner2))+1);\\n        corners.put(corner3,(int)(corners.get(corner3))+1);\\n        corners.put(corner4,(int)(corners.get(corner4))+1);\\n\\n        for (Object num : corners.values()){\\n            if ((int)num!=2&&(int)num!=4) return false;\\n        }\\n\\n        if(area!=(topRight[2]-btLeft[0])*(topRight[3]-btLeft[1])) return false;\\n\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isRectangleCover(int[][] rectangles) {\\n        HashMap corners = new HashMap<String,Integer>();\\n        int [] topRight=rectangles[0];\\n        int[] btLeft = rectangles[0];\\n        int area = 0;\\n        for (int[] rect:rectangles){\\n            if (rect[0]<btLeft[0]) btLeft=rect;\\n            if (rect[0]==btLeft[0] && rect[1]<btLeft[1]) btLeft=rect;\\n\\n            if (rect[2]>topRight[2]) topRight=rect;\\n            if (rect[2]==topRight[2] && rect[3]>topRight[3]) topRight=rect;\\n            \\n            String corner1=\"\"+rect[0]+\",\"+rect[1];\\n            String corner2=\"\"+rect[2]+\",\"+rect[3];\\n            String corner3=\"\"+rect[0]+\",\"+rect[3];\\n            String corner4=\"\"+rect[2]+\",\"+rect[1];\\n            if (corners.containsKey(corner1)) corners.put(corner1,(int)(corners.get(corner1))+1);\\n            else corners.put(corner1,1);\\n            if (corners.containsKey(corner2)) corners.put(corner2,(int)(corners.get(corner2))+1);\\n            else corners.put(corner2,1);\\n            if (corners.containsKey(corner3)) corners.put(corner3,(int)(corners.get(corner3))+1);\\n            else corners.put(corner3,1);\\n            if (corners.containsKey(corner4)) corners.put(corner4,(int)(corners.get(corner4))+1);\\n            else corners.put(corner4,1);       \\n            area += (rect[2]-rect[0]) * (rect[3]-rect[1]);\\n        }\\n\\n        //assert -no rect goes lower than btLeft -no rect goes up from  topRight\\n        for (int[] rect:rectangles){\\n            if (rect[1]<btLeft[1]) return false;\\n            if (rect[3]>topRight[3]) return false;\\n        }\\n\\n        // now only need to check for overlap - we going to add a big rect including the full area, and now for each rect all 4 corners should be shared with 1 rect each, so each corner apears twice in the corners map.\\n        String corner1=\"\"+btLeft[0]+\",\"+btLeft[1];\\n        String corner2=\"\"+topRight[2]+\",\"+topRight[3];\\n        String corner3=\"\"+btLeft[0]+\",\"+topRight[3];\\n        String corner4=\"\"+topRight[2]+\",\"+btLeft[1];\\n        if (!corners.containsKey(corner1)||!corners.containsKey(corner2)||!corners.containsKey(corner3)||!corners.containsKey(corner4)) return false;\\n        corners.put(corner1,(int)(corners.get(corner1))+1);\\n        corners.put(corner2,(int)(corners.get(corner2))+1);\\n        corners.put(corner3,(int)(corners.get(corner3))+1);\\n        corners.put(corner4,(int)(corners.get(corner4))+1);\\n\\n        for (Object num : corners.values()){\\n            if ((int)num!=2&&(int)num!=4) return false;\\n        }\\n\\n        if(area!=(topRight[2]-btLeft[0])*(topRight[3]-btLeft[1])) return false;\\n\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3374460,
                "title": "geometry-and-set",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def isRectangleCover(self, rectangles: List[List[int]]) -> bool:\\n        # the idea is to count overlap points, if there are 4 non-overlap points and \\n        # there is no overlap odd numbers of points, we can check the area of all rectangles\\n        # with the 4 unique points formed rectangles.\\n        area, count = 0, defaultdict(int)\\n        for x, y, a, b in rectangles:\\n            for pointX, pointY in [[x, y], [a, b], [x, b], [a, y]]:\\n                count[(pointX, pointY)] += 1\\n            area += (a - x) * (b - y)\\n        s =set()\\n        for item, v in count.items():\\n            if v == 1:\\n                s.add(item)\\n            if v > 2 and v % 2 == 1: # case 48\\n                return False\\n        if len(s) != 4:\\n            return False\\n\\n        max_x, max_y, min_x, min_y = -inf, -inf, inf, inf\\n        for x, y in s:\\n            max_x = max(max_x, x)\\n            min_x = min(min_x, x)\\n            max_y = max(max_y, y)\\n            min_y = min(min_y, y)\\n        return area == (max_y - min_y) * (max_x - min_x)\\n# using set:\\nclass Solution:\\n    def isRectangleCover(self, rectangles: List[List[int]]) -> bool:\\n        # the idea is to count overlap points, if there are 4 non-overlap points and \\n        # there is no overlap odd numbers of points, we can check the area of all rectangles\\n        # with the 4 unique points formed rectangles.\\n        area, s = 0, set()\\n        for x, y, a, b in rectangles:\\n            for pointX, pointY in [[x, y], [a, b], [x, b], [a, y]]:\\n                if (pointX, pointY) in s:\\n                    s.remove((pointX, pointY))\\n                else:\\n                    s.add((pointX, pointY))\\n            area += (a - x) * (b - y)\\n        if len(s) != 4: return False\\n\\n        max_x, max_y, min_x, min_y = -inf, -inf, inf, inf\\n        for x, y in s:\\n            max_x = max(max_x, x)\\n            min_x = min(min_x, x)\\n            max_y = max(max_y, y)\\n            min_y = min(min_y, y)\\n        return area == (max_y - min_y) * (max_x - min_x)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isRectangleCover(self, rectangles: List[List[int]]) -> bool:\\n        # the idea is to count overlap points, if there are 4 non-overlap points and \\n        # there is no overlap odd numbers of points, we can check the area of all rectangles\\n        # with the 4 unique points formed rectangles.\\n        area, count = 0, defaultdict(int)\\n        for x, y, a, b in rectangles:\\n            for pointX, pointY in [[x, y], [a, b], [x, b], [a, y]]:\\n                count[(pointX, pointY)] += 1\\n            area += (a - x) * (b - y)\\n        s =set()\\n        for item, v in count.items():\\n            if v == 1:\\n                s.add(item)\\n            if v > 2 and v % 2 == 1: # case 48\\n                return False\\n        if len(s) != 4:\\n            return False\\n\\n        max_x, max_y, min_x, min_y = -inf, -inf, inf, inf\\n        for x, y in s:\\n            max_x = max(max_x, x)\\n            min_x = min(min_x, x)\\n            max_y = max(max_y, y)\\n            min_y = min(min_y, y)\\n        return area == (max_y - min_y) * (max_x - min_x)\\n# using set:\\nclass Solution:\\n    def isRectangleCover(self, rectangles: List[List[int]]) -> bool:\\n        # the idea is to count overlap points, if there are 4 non-overlap points and \\n        # there is no overlap odd numbers of points, we can check the area of all rectangles\\n        # with the 4 unique points formed rectangles.\\n        area, s = 0, set()\\n        for x, y, a, b in rectangles:\\n            for pointX, pointY in [[x, y], [a, b], [x, b], [a, y]]:\\n                if (pointX, pointY) in s:\\n                    s.remove((pointX, pointY))\\n                else:\\n                    s.add((pointX, pointY))\\n            area += (a - x) * (b - y)\\n        if len(s) != 4: return False\\n\\n        max_x, max_y, min_x, min_y = -inf, -inf, inf, inf\\n        for x, y in s:\\n            max_x = max(max_x, x)\\n            min_x = min(min_x, x)\\n            max_y = max(max_y, y)\\n            min_y = min(min_y, y)\\n        return area == (max_y - min_y) * (max_x - min_x)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3361006,
                "title": "clean-version",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFind 4 corner and this 4 corner must be and only be the extrem value.\\nThen the 4 corners area is the total area. That is true;\\nOtherwise, false.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isRectangleCover(int[][] rectangles) {\\n        int minX = Integer.MAX_VALUE;\\n        int maxX = Integer.MIN_VALUE;\\n        int minY = Integer.MAX_VALUE;\\n        int maxY = Integer.MIN_VALUE;\\n        int area = 0;\\n        HashSet<String> store = new HashSet<>();\\n        \\n        for(int[] a: rectangles)\\n        {\\n            int x1 = a[0];\\n            int y1 = a[1];\\n            int x2 = a[2];\\n            int y2 = a[3];\\n\\n            minX = Math.min(minX, x1);\\n            minY = Math.min(minY, y1);\\n            maxX = Math.max(maxX, x2);\\n            maxY = Math.max(maxY, y2);\\n            \\n            area += (x2-x1)*(y2-y1);\\n            \\n            String p1 = x1+\" \"+y1;\\n            String p2 = x2+\" \"+y2;\\n            String p3 = x1+\" \"+y2;\\n            String p4 = x2+\" \"+y1;\\n            if(store.contains(p1))\\n                store.remove(p1);\\n            else\\n                store.add(p1);\\n            if(store.contains(p2))\\n                store.remove(p2);\\n            else\\n                store.add(p2);\\n            if(store.contains(p3))\\n                store.remove(p3);\\n            else\\n                store.add(p3);\\n            if(store.contains(p4))\\n                store.remove(p4);\\n            else\\n                store.add(p4);\\n        }\\n\\n        String p1 = minX+\" \"+minY;\\n        String p2 = minX+\" \"+maxY;\\n        String p3 = maxX+\" \"+minY;\\n        String p4 = maxX+\" \"+maxY;\\n        if(store.size() !=4 || !store.contains(p1) || !store.contains(p2) || !store.contains(p3) || !store.contains(p4))\\n            return false;\\n        \\n        return area == (maxX-minX)*(maxY-minY);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isRectangleCover(int[][] rectangles) {\\n        int minX = Integer.MAX_VALUE;\\n        int maxX = Integer.MIN_VALUE;\\n        int minY = Integer.MAX_VALUE;\\n        int maxY = Integer.MIN_VALUE;\\n        int area = 0;\\n        HashSet<String> store = new HashSet<>();\\n        \\n        for(int[] a: rectangles)\\n        {\\n            int x1 = a[0];\\n            int y1 = a[1];\\n            int x2 = a[2];\\n            int y2 = a[3];\\n\\n            minX = Math.min(minX, x1);\\n            minY = Math.min(minY, y1);\\n            maxX = Math.max(maxX, x2);\\n            maxY = Math.max(maxY, y2);\\n            \\n            area += (x2-x1)*(y2-y1);\\n            \\n            String p1 = x1+\" \"+y1;\\n            String p2 = x2+\" \"+y2;\\n            String p3 = x1+\" \"+y2;\\n            String p4 = x2+\" \"+y1;\\n            if(store.contains(p1))\\n                store.remove(p1);\\n            else\\n                store.add(p1);\\n            if(store.contains(p2))\\n                store.remove(p2);\\n            else\\n                store.add(p2);\\n            if(store.contains(p3))\\n                store.remove(p3);\\n            else\\n                store.add(p3);\\n            if(store.contains(p4))\\n                store.remove(p4);\\n            else\\n                store.add(p4);\\n        }\\n\\n        String p1 = minX+\" \"+minY;\\n        String p2 = minX+\" \"+maxY;\\n        String p3 = maxX+\" \"+minY;\\n        String p4 = maxX+\" \"+maxY;\\n        if(store.size() !=4 || !store.contains(p1) || !store.contains(p2) || !store.contains(p3) || !store.contains(p4))\\n            return false;\\n        \\n        return area == (maxX-minX)*(maxY-minY);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3354369,
                "title": "python-exact-cover-rectangle",
                "content": "# Intuition\\nTo check if the given rectangles form an exact cover of a rectangular region, we need to make sure that:\\n\\n1. All rectangles together completely cover the rectangular region.\\n2. No part of the rectangular region is covered twice or more.\\n# Approach\\nWe can keep track of the area of the union of all rectangles, as well as the area of each individual rectangle. If the sum of individual rectangles\\' areas is equal to the area of the union, and there is no overlap between any pair of rectangles, then the rectangles form an exact cover of a rectangular region.\\n\\nTo check for overlap, we can use a set to keep track of all points that are covered by more than one rectangle. If at any point we find a point that is already in the set, it means that there is overlap, and we can return false.\\n# Complexity\\n- Time complexity:\\nO(nlogn), where n is the number of rectangles. This is because we need to sort the rectangles by their x and y coordinates.\\n- Space complexity:\\nO(n), to store the set of overlapping points.\\n# Code\\n```\\nclass Solution:\\n    def isRectangleCover(self, rectangles: List[List[int]]) -> bool:\\n        def check_rectangle(rect):\\n            nonlocal vertices\\n            for vertex in rect:\\n                if vertex not in vertices:\\n                    vertices.add(vertex)\\n                else:\\n                    vertices.remove(vertex)\\n            \\n            return True\\n\\n        vertices = set()\\n        area = 0\\n        \\n        for rect in rectangles:\\n            area += (rect[2] - rect[0]) * (rect[3] - rect[1])\\n            if not check_rectangle([(rect[0], rect[1]), (rect[0], rect[3]), (rect[2], rect[3]), (rect[2], rect[1])]):\\n                return False\\n        \\n        if len(vertices) != 4:\\n            return False\\n        \\n        x1, y1 = min(vertices)\\n        x2, y2 = max(vertices)\\n        return area == (x2 - x1) * (y2 - y1)\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isRectangleCover(self, rectangles: List[List[int]]) -> bool:\\n        def check_rectangle(rect):\\n            nonlocal vertices\\n            for vertex in rect:\\n                if vertex not in vertices:\\n                    vertices.add(vertex)\\n                else:\\n                    vertices.remove(vertex)\\n            \\n            return True\\n\\n        vertices = set()\\n        area = 0\\n        \\n        for rect in rectangles:\\n            area += (rect[2] - rect[0]) * (rect[3] - rect[1])\\n            if not check_rectangle([(rect[0], rect[1]), (rect[0], rect[3]), (rect[2], rect[3]), (rect[2], rect[1])]):\\n                return False\\n        \\n        if len(vertices) != 4:\\n            return False\\n        \\n        x1, y1 = min(vertices)\\n        x2, y2 = max(vertices)\\n        return area == (x2 - x1) * (y2 - y1)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3349638,
                "title": "go-o-n-o-n",
                "content": "```\\nfunc isRectangleCover(rectangles [][]int) bool {\\n    area := 0\\n    border := make(map[point]bool)\\n    for _, r := range rectangles {\\n        area += (r[2]-r[0])*(r[3]-r[1])\\n        for _, p := range [4]point{point{r[0], r[1]},\\n                                   point{r[0], r[3]},\\n                                   point{r[2], r[1]},\\n                                   point{r[2], r[3]}} {\\n            if border[p] {\\n                delete(border, p) \\n            } else {\\n                border[p] = true\\n            }\\n        }\\n    }\\n    if len(border) != 4 {\\n        return false\\n    }\\n    min_point := point{100000, 100000}\\n    max_point := point{-100000, -100000}\\n    for point := range border {\\n        if min_point.x > point.x {\\n            min_point.x = point.x\\n        }\\n        if min_point.y > point.y {\\n            min_point.y = point.y\\n        }\\n        if max_point.x < point.x {\\n            max_point.x = point.x\\n        }\\n        if max_point.y < point.y {\\n            max_point.y = point.y\\n        }\\n    }\\n    if area != (max_point.x-min_point.x)*(max_point.y-min_point.y) {\\n        return false\\n    }\\n    return true\\n}\\n\\ntype point struct {\\n    x int\\n    y int\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Line Sweep"
                ],
                "code": "```\\nfunc isRectangleCover(rectangles [][]int) bool {\\n    area := 0\\n    border := make(map[point]bool)\\n    for _, r := range rectangles {\\n        area += (r[2]-r[0])*(r[3]-r[1])\\n        for _, p := range [4]point{point{r[0], r[1]},\\n                                   point{r[0], r[3]},\\n                                   point{r[2], r[1]},\\n                                   point{r[2], r[3]}} {\\n            if border[p] {\\n                delete(border, p) \\n            } else {\\n                border[p] = true\\n            }\\n        }\\n    }\\n    if len(border) != 4 {\\n        return false\\n    }\\n    min_point := point{100000, 100000}\\n    max_point := point{-100000, -100000}\\n    for point := range border {\\n        if min_point.x > point.x {\\n            min_point.x = point.x\\n        }\\n        if min_point.y > point.y {\\n            min_point.y = point.y\\n        }\\n        if max_point.x < point.x {\\n            max_point.x = point.x\\n        }\\n        if max_point.y < point.y {\\n            max_point.y = point.y\\n        }\\n    }\\n    if area != (max_point.x-min_point.x)*(max_point.y-min_point.y) {\\n        return false\\n    }\\n    return true\\n}\\n\\ntype point struct {\\n    x int\\n    y int\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3341747,
                "title": "solution",
                "content": "```C++ []\\n#define MOD 113\\n#define P 31\\n\\nclass Solution {\\n    int corners[MOD];\\n    int sum = 0;\\n    inline long long area(const vector<int> &r) {\\n        return (long long)(r[2] - r[0]) * (r[3] - r[1]);\\n    }\\n    inline void add(const pair<int, int> &p) {\\n        int& v = corners[((p.first * P + p.second) % MOD + MOD) % MOD];\\n        v ^= 1;\\n        sum += (v == 1 ? 1 : -1);\\n    }\\npublic:\\n    bool isRectangleCover(const vector<vector<int>>& rectangles) {\\n        long long sum_area = 0;\\n        int x0 = 1e5, y0 = 1e5, x1 = -1e5, y1 = -1e5;\\n\\n        for (const auto &r : rectangles) {\\n            sum_area += area(r);\\n            x0 = (x0 < r[0] ? x0 : r[0]);\\n            y0 = (y0 < r[1] ? y0 : r[1]);\\n            x1 = (x1 > r[2] ? x1 : r[2]);\\n            y1 = (y1 > r[3] ? y1 : r[3]);\\n            add({r[0], r[1]});\\n            add({r[2], r[3]});\\n            add({r[0], r[3]});\\n            add({r[2], r[1]});\\n        }\\n        add({x0, y0});\\n        add({x1, y0});\\n        add({x0, y1});\\n        add({x1, y1});\\n        // cout << x0 << \" \" << y0 << \" \" << x1 << \" \" << y1 << \"\\\\n\";\\n        return area({x0, y0, x1, y1}) == sum_area && sum == 0;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def isRectangleCover(self, rectangles: list[list[int]]) -> bool:\\n        area = 0\\n        corners = set()\\n\\n        for x, y, a, b in rectangles:\\n            area += (b - y) * (a - x)\\n            corners ^= {(x, y), (x, b), (a, y), (a, b)}\\n\\n        if len(corners) != 4: return False\\n        \\n        x, y = min(corners)\\n        a, b = max(corners)\\n        return (b - y) * (a - x) == area\\n```\\n\\n```Java []\\nclass Solution {\\n    public boolean isRectangleCover(int[][] rectangles) {\\n        if (rectangles == null || rectangles.length == 0 || rectangles[0].length == 0) {\\n            return false;\\n        }\\n        Set<int[]> set = new TreeSet<>((int[] a, int[] b) -> {\\n            if (a[3] <= b[1]) {\\n                return -1;\\n            } else if (a[1] >= b[3]) {\\n                return 1;\\n            } else if (a[2] <= b[0]) {\\n                return -1;\\n            } else if (a[0] >= b[2]) {\\n                return 1;\\n            } else return 0;\\n        });\\n        int area = 0;\\n        int up = Integer.MIN_VALUE;\\n        int down = Integer.MAX_VALUE;\\n        int left = Integer.MAX_VALUE;\\n        int right = Integer.MIN_VALUE;\\n        \\n        for (int[] rect : rectangles) {\\n            area += (rect[2] - rect[0]) * (rect[3] - rect[1]);\\n            up = Math.max(up, rect[3]);\\n            right = Math.max(right, rect[2]);\\n            down = Math.min(down, rect[1]);\\n            left = Math.min(left, rect[0]);\\n            if (!set.add(rect)) {\\n                return false;\\n            }\\n        }\\n        if (!(((up - down) * (right - left)) == area)) return false;\\n        return true;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\n#define MOD 113\\n#define P 31\\n\\nclass Solution {\\n    int corners[MOD];\\n    int sum = 0;\\n    inline long long area(const vector<int> &r) {\\n        return (long long)(r[2] - r[0]) * (r[3] - r[1]);\\n    }\\n    inline void add(const pair<int, int> &p) {\\n        int& v = corners[((p.first * P + p.second) % MOD + MOD) % MOD];\\n        v ^= 1;\\n        sum += (v == 1 ? 1 : -1);\\n    }\\npublic:\\n    bool isRectangleCover(const vector<vector<int>>& rectangles) {\\n        long long sum_area = 0;\\n        int x0 = 1e5, y0 = 1e5, x1 = -1e5, y1 = -1e5;\\n\\n        for (const auto &r : rectangles) {\\n            sum_area += area(r);\\n            x0 = (x0 < r[0] ? x0 : r[0]);\\n            y0 = (y0 < r[1] ? y0 : r[1]);\\n            x1 = (x1 > r[2] ? x1 : r[2]);\\n            y1 = (y1 > r[3] ? y1 : r[3]);\\n            add({r[0], r[1]});\\n            add({r[2], r[3]});\\n            add({r[0], r[3]});\\n            add({r[2], r[1]});\\n        }\\n        add({x0, y0});\\n        add({x1, y0});\\n        add({x0, y1});\\n        add({x1, y1});\\n        // cout << x0 << \" \" << y0 << \" \" << x1 << \" \" << y1 << \"\\\\n\";\\n        return area({x0, y0, x1, y1}) == sum_area && sum == 0;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def isRectangleCover(self, rectangles: list[list[int]]) -> bool:\\n        area = 0\\n        corners = set()\\n\\n        for x, y, a, b in rectangles:\\n            area += (b - y) * (a - x)\\n            corners ^= {(x, y), (x, b), (a, y), (a, b)}\\n\\n        if len(corners) != 4: return False\\n        \\n        x, y = min(corners)\\n        a, b = max(corners)\\n        return (b - y) * (a - x) == area\\n```\n```Java []\\nclass Solution {\\n    public boolean isRectangleCover(int[][] rectangles) {\\n        if (rectangles == null || rectangles.length == 0 || rectangles[0].length == 0) {\\n            return false;\\n        }\\n        Set<int[]> set = new TreeSet<>((int[] a, int[] b) -> {\\n            if (a[3] <= b[1]) {\\n                return -1;\\n            } else if (a[1] >= b[3]) {\\n                return 1;\\n            } else if (a[2] <= b[0]) {\\n                return -1;\\n            } else if (a[0] >= b[2]) {\\n                return 1;\\n            } else return 0;\\n        });\\n        int area = 0;\\n        int up = Integer.MIN_VALUE;\\n        int down = Integer.MAX_VALUE;\\n        int left = Integer.MAX_VALUE;\\n        int right = Integer.MIN_VALUE;\\n        \\n        for (int[] rect : rectangles) {\\n            area += (rect[2] - rect[0]) * (rect[3] - rect[1]);\\n            up = Math.max(up, rect[3]);\\n            right = Math.max(right, rect[2]);\\n            down = Math.min(down, rect[1]);\\n            left = Math.min(left, rect[0]);\\n            if (!set.add(rect)) {\\n                return false;\\n            }\\n        }\\n        if (!(((up - down) * (right - left)) == area)) return false;\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3305820,
                "title": "perfect-rectangle-golang",
                "content": "# Intuition\\nFind the max and min 4 points.\\n- Check the expected area\\n- Check whether the shape only have 4 points. (When a point is the vertex of odd number of rectangles, it is a point for the final shape)\\n- Check whether the 4 points matches the previous vertex.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nAs descibed in `Intuition`\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunc isRectangleCover(rectangles [][]int) bool {\\n    X1, Y1 := math.MaxInt32, math.MaxInt32\\n    X2, Y2 := -math.MaxInt32, -math.MaxInt32\\n    // keep track of whether points is\\n    points := make(map[[2]int]bool)\\n    actualArea := 0\\n\\n    for _, rect := range rectangles {\\n        x1, y1, x2, y2 := rect[0], rect[1], rect[2], rect[3]\\n        // possibly the maximum area of the rectangle\\n        X1, Y1 = min(X1, x1), min(Y1, y1)\\n        X2, Y2 = max(X2, x2), max(Y2, y2)\\n        \\n        actualArea += (x2 - x1) * (y2 - y1)\\n        p1, p2 := [2]int{x1, y1}, [2]int{x1, y2}\\n        p3, p4 := [2]int{x2, y1}, [2]int{x2, y2}\\n        for _, p := range [...] [2]int{p1, p2, p3, p4} {\\n            if _, ok := points[p]; ok {\\n                delete(points, p)\\n            } else {\\n                points[p] = true\\n            }\\n        }\\n    }\\n\\n    // area match\\n    expectedArea := (X2 - X1) * (Y2 - Y1)\\n    if actualArea != expectedArea {\\n        return false\\n    }\\n\\n    // 4 points\\n    if len(points) != 4 {\\n        return false\\n    }\\n\\n    // point matches\\n    if _, ok := points[[2]int{X1, Y1}]; !ok {\\n        return false\\n    }\\n    if _, ok := points[[2]int{X1, Y2}]; !ok {\\n        return false\\n    }\\n    if _, ok := points[[2]int{X2, Y1}]; !ok {\\n        return false\\n    }\\n    if _, ok := points[[2]int{X2, Y2}]; !ok {\\n        return false\\n    }\\n\\n    return true\\n}\\n\\nfunc min(x, y int) int {\\n    if x < y {\\n        return x\\n    }\\n    return y\\n}\\n\\nfunc max(x, y int) int {\\n    if x > y {\\n        return x\\n    }\\n    return y\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc isRectangleCover(rectangles [][]int) bool {\\n    X1, Y1 := math.MaxInt32, math.MaxInt32\\n    X2, Y2 := -math.MaxInt32, -math.MaxInt32\\n    // keep track of whether points is\\n    points := make(map[[2]int]bool)\\n    actualArea := 0\\n\\n    for _, rect := range rectangles {\\n        x1, y1, x2, y2 := rect[0], rect[1], rect[2], rect[3]\\n        // possibly the maximum area of the rectangle\\n        X1, Y1 = min(X1, x1), min(Y1, y1)\\n        X2, Y2 = max(X2, x2), max(Y2, y2)\\n        \\n        actualArea += (x2 - x1) * (y2 - y1)\\n        p1, p2 := [2]int{x1, y1}, [2]int{x1, y2}\\n        p3, p4 := [2]int{x2, y1}, [2]int{x2, y2}\\n        for _, p := range [...] [2]int{p1, p2, p3, p4} {\\n            if _, ok := points[p]; ok {\\n                delete(points, p)\\n            } else {\\n                points[p] = true\\n            }\\n        }\\n    }\\n\\n    // area match\\n    expectedArea := (X2 - X1) * (Y2 - Y1)\\n    if actualArea != expectedArea {\\n        return false\\n    }\\n\\n    // 4 points\\n    if len(points) != 4 {\\n        return false\\n    }\\n\\n    // point matches\\n    if _, ok := points[[2]int{X1, Y1}]; !ok {\\n        return false\\n    }\\n    if _, ok := points[[2]int{X1, Y2}]; !ok {\\n        return false\\n    }\\n    if _, ok := points[[2]int{X2, Y1}]; !ok {\\n        return false\\n    }\\n    if _, ok := points[[2]int{X2, Y2}]; !ok {\\n        return false\\n    }\\n\\n    return true\\n}\\n\\nfunc min(x, y int) int {\\n    if x < y {\\n        return x\\n    }\\n    return y\\n}\\n\\nfunc max(x, y int) int {\\n    if x > y {\\n        return x\\n    }\\n    return y\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3257935,
                "title": "intuitive-c-approach",
                "content": "# Intuition\\nA perfect rectangle must have the following characteristics,\\n1. area enclosed by the 4 most outside points = sum of all rectangle areas\\n2. all inner points will be cancled (they appear in even number of times)\\n3. eventually, there will only left with 4 outer points, and they are the 4 most outside points\\n\\n# Complexity\\n- Time complexity: O(N)\\n\\n- Space complexity: O(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isRectangleCover(vector<vector<int>>& rectangles) {\\n        if (rectangles.size() == 0) {\\n            return false;\\n        } else if (rectangles.size() == 1) {\\n            return true;\\n        }\\n        // The 4 most outside points\\n        int x = rectangles[0][0];\\n        int y = rectangles[0][1];\\n        int a = rectangles[0][2];\\n        int b = rectangles[0][3];\\n        int area = 0;\\n        // Set of all outer points\\n        unordered_set<string> points;\\n        for (vector<int> rectangle : rectangles) {\\n            x = min(x, rectangle[0]);\\n            y = min(y, rectangle[1]);\\n            a = max(a, rectangle[2]);\\n            b = max(b, rectangle[3]);\\n            area += (rectangle[2] - rectangle[0]) * (rectangle[3] - rectangle[1]);\\n            vector<string> currPoints;\\n            currPoints.push_back(to_string(rectangle[0]) + \".\" + to_string(rectangle[1]));\\n            currPoints.push_back(to_string(rectangle[0]) + \".\" + to_string(rectangle[3]));\\n            currPoints.push_back(to_string(rectangle[2]) + \".\" + to_string(rectangle[1]));\\n            currPoints.push_back(to_string(rectangle[2]) + \".\" + to_string(rectangle[3]));\\n            for (string currPoint : currPoints) {\\n                if (points.count(currPoint)) {\\n                    points.erase(currPoint);\\n                } else {\\n                    points.insert(currPoint);\\n                }\\n            }\\n        }\\n        if (points.size() != 4) {\\n            return false;\\n        }\\n        string point1 = to_string(x) + \".\" + to_string(y);\\n        string point2 = to_string(x) + \".\" + to_string(b);\\n        string point3 = to_string(a) + \".\" + to_string(y);\\n        string point4 = to_string(a) + \".\" + to_string(b);\\n        return points.count(point1) && points.count(point2) && points.count(point3) && points.count(point4) && area == (a - x) * (b - y);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isRectangleCover(vector<vector<int>>& rectangles) {\\n        if (rectangles.size() == 0) {\\n            return false;\\n        } else if (rectangles.size() == 1) {\\n            return true;\\n        }\\n        // The 4 most outside points\\n        int x = rectangles[0][0];\\n        int y = rectangles[0][1];\\n        int a = rectangles[0][2];\\n        int b = rectangles[0][3];\\n        int area = 0;\\n        // Set of all outer points\\n        unordered_set<string> points;\\n        for (vector<int> rectangle : rectangles) {\\n            x = min(x, rectangle[0]);\\n            y = min(y, rectangle[1]);\\n            a = max(a, rectangle[2]);\\n            b = max(b, rectangle[3]);\\n            area += (rectangle[2] - rectangle[0]) * (rectangle[3] - rectangle[1]);\\n            vector<string> currPoints;\\n            currPoints.push_back(to_string(rectangle[0]) + \".\" + to_string(rectangle[1]));\\n            currPoints.push_back(to_string(rectangle[0]) + \".\" + to_string(rectangle[3]));\\n            currPoints.push_back(to_string(rectangle[2]) + \".\" + to_string(rectangle[1]));\\n            currPoints.push_back(to_string(rectangle[2]) + \".\" + to_string(rectangle[3]));\\n            for (string currPoint : currPoints) {\\n                if (points.count(currPoint)) {\\n                    points.erase(currPoint);\\n                } else {\\n                    points.insert(currPoint);\\n                }\\n            }\\n        }\\n        if (points.size() != 4) {\\n            return false;\\n        }\\n        string point1 = to_string(x) + \".\" + to_string(y);\\n        string point2 = to_string(x) + \".\" + to_string(b);\\n        string point3 = to_string(a) + \".\" + to_string(y);\\n        string point4 = to_string(a) + \".\" + to_string(b);\\n        return points.count(point1) && points.count(point2) && points.count(point3) && points.count(point4) && area == (a - x) * (b - y);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3249678,
                "title": "python-approach",
                "content": "# Intuition\\nThe main point here is to compare the corner and area. The area is the same as the rectangle area, which will pass. The second point is the corner, and if we meet the corner once, we record the corner. If we meet it the second time, we delete the corner. The similar continues; if we meet the corner the third time, we record. Ultimately, we will check if it only left four corners, the four corners of a rectangle. More details will be aside from the code.\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution:\\n    def isRectangleCover(self, rectangles: List[List[int]]) -> bool:\\n        \\n        area = 0\\n        corners = set()\\n        a = lambda: (Y-y) * (X-x)\\n        \\n        for x, y, X, Y in rectangles:\\n            # check the area\\n            area += a()\\n            # check the corner\\n            corners ^= {(x,y), (x,Y), (X,y), (X,Y)}\\n\\n        # compare the results\\n        if len(corners) != 4: return False\\n        x, y = min(corners, key=lambda x: x[0] + x[1])\\n        X, Y = max(corners, key=lambda x: x[0] + x[1])\\n        return a() == area\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isRectangleCover(self, rectangles: List[List[int]]) -> bool:\\n        \\n        area = 0\\n        corners = set()\\n        a = lambda: (Y-y) * (X-x)\\n        \\n        for x, y, X, Y in rectangles:\\n            # check the area\\n            area += a()\\n            # check the corner\\n            corners ^= {(x,y), (x,Y), (X,y), (X,Y)}\\n\\n        # compare the results\\n        if len(corners) != 4: return False\\n        x, y = min(corners, key=lambda x: x[0] + x[1])\\n        X, Y = max(corners, key=lambda x: x[0] + x[1])\\n        return a() == area\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3249086,
                "title": "perfect-rectangle",
                "content": "# Intuition\\n1\\u9762\\u79EF+2\\u9876\\u70B9\\n\\n# Approach\\n1\\u5916\\u9762\\u7684\\u5B8C\\u7F8E\\u77E9\\u9635\\u7684\\u9762\\u79EF\\u4E00\\u5B9A\\u7B49\\u4E8E\\u6240\\u6709\\u5C0F\\u77E9\\u9635\\u7684\\u548C\\n2\\u9664\\u4E86\\u5B8C\\u7F8E\\u77E9\\u9635\\u7684\\u56DB\\u4E2A\\u5916\\u56F4\\u9876\\u70B9\\uFF0C\\u77E9\\u9635\\u5185\\u90E8\\u7684\\u9876\\u70B9\\u4E00\\u5B9A\\u662F\\u88AB\\u5076\\u6570\\u4E2A\\u5C0F\\u77E9\\u9635\\u5171\\u7528\\u7684\\n2\\u5982\\u679C\\u6709\\u4E00\\u4E2A\\u5185\\u90E8\\u9876\\u70B9\\u6211\\u4EEC\\u53EAprocess\\u4E86\\u4E00\\u6B21\\uFF0C\\u90A3\\u4E48\\u8981\\u4E48\\u51FA\\u73B0\\u4E86\\u7F3A\\u53E3/\\u91CD\\u53E0\\n\\nmisc\\uFF1A\\u6211\\u628A\\u9876\\u70B9\\uFF081\\uFF0C1\\uFF09=> 1*10 + 1 => \\u201811\\u2018\\uFF0C\\u5B9E\\u9645\\u4E0A\\u7528\\u4E00\\u4E2Amake_pair(1,1)\\u5E94\\u8BE5\\u4E5F\\u662F\\u53EF\\u4EE5\\u7684\\n\\n# Complexity\\n- Time complexity: $$O(n)$$ \\n\\n- Space complexity: $$O(n)$$ \\n\\nwhere n is the number of rectangles\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isRectangleCover(vector<vector<int>>& rectangles) {\\n        // initialize the coordinates for the cover\\n        long X1 = INT_MAX, Y1 = INT_MAX;\\n        long X2 = INT_MIN, Y2 = INT_MIN;\\n\\n        // might need to change int to long to prevent integer overflow\\n        double area_sum = 0.0;\\n\\n        // initialize a hashset to keep track of the coordinates\\n        unordered_set<string> vertices;\\n\\n        // collect the right coordinates for cover\\n        for (const auto& rectangle: rectangles) {\\n            long x1 = rectangle[0];\\n            long y1 = rectangle[1];\\n            long x2 = rectangle[2];\\n            long y2 = rectangle[3];\\n            \\n            vector<long> coords = {x1*10+y1, x1*10+y2, x2*10+y1, x2*10+y2};\\n\\n            for (long coord: coords) {\\n                string coord_str = to_string(coord);\\n                if (vertices.count(coord_str)) {\\n                    vertices.erase(coord_str);\\n                }\\n                else {\\n                    vertices.insert(coord_str);\\n                }\\n            }\\n            \\n            // (x1,y1) left bottom\\n            X1 = min(X1, x1);\\n            Y1 = min(Y1, y1);\\n            // (X2,Y2) right top\\n            X2 = max(X2, x2);\\n            Y2 = max(Y2, y2);\\n\\n            area_sum += (x2-x1) * (y2-y1);\\n        }\\n\\n        double expected_sum = (X2-X1) * (Y2-Y1);\\n\\n        // check area\\n        if (expected_sum != area_sum) {\\n            return false;\\n        }\\n\\n        // only corner vertices can be in vertices\\n        if (vertices.size() != 4) {\\n            return false;\\n        }\\n\\n        unordered_set<string> cover_vertices = {\\n            to_string(X1*10 + Y1),\\n            to_string(X1*10 + Y2),\\n            to_string(X2*10 + Y1),\\n            to_string(X2*10 + Y2),\\n        };\\n\\n        for (const string& vertice: vertices) {\\n            if (cover_vertices.count(vertice) == 0) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isRectangleCover(vector<vector<int>>& rectangles) {\\n        // initialize the coordinates for the cover\\n        long X1 = INT_MAX, Y1 = INT_MAX;\\n        long X2 = INT_MIN, Y2 = INT_MIN;\\n\\n        // might need to change int to long to prevent integer overflow\\n        double area_sum = 0.0;\\n\\n        // initialize a hashset to keep track of the coordinates\\n        unordered_set<string> vertices;\\n\\n        // collect the right coordinates for cover\\n        for (const auto& rectangle: rectangles) {\\n            long x1 = rectangle[0];\\n            long y1 = rectangle[1];\\n            long x2 = rectangle[2];\\n            long y2 = rectangle[3];\\n            \\n            vector<long> coords = {x1*10+y1, x1*10+y2, x2*10+y1, x2*10+y2};\\n\\n            for (long coord: coords) {\\n                string coord_str = to_string(coord);\\n                if (vertices.count(coord_str)) {\\n                    vertices.erase(coord_str);\\n                }\\n                else {\\n                    vertices.insert(coord_str);\\n                }\\n            }\\n            \\n            // (x1,y1) left bottom\\n            X1 = min(X1, x1);\\n            Y1 = min(Y1, y1);\\n            // (X2,Y2) right top\\n            X2 = max(X2, x2);\\n            Y2 = max(Y2, y2);\\n\\n            area_sum += (x2-x1) * (y2-y1);\\n        }\\n\\n        double expected_sum = (X2-X1) * (Y2-Y1);\\n\\n        // check area\\n        if (expected_sum != area_sum) {\\n            return false;\\n        }\\n\\n        // only corner vertices can be in vertices\\n        if (vertices.size() != 4) {\\n            return false;\\n        }\\n\\n        unordered_set<string> cover_vertices = {\\n            to_string(X1*10 + Y1),\\n            to_string(X1*10 + Y2),\\n            to_string(X2*10 + Y1),\\n            to_string(X2*10 + Y2),\\n        };\\n\\n        for (const string& vertice: vertices) {\\n            if (cover_vertices.count(vertice) == 0) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3247689,
                "title": "areas-and-vertex",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isRectangleCover(int[][] rectangles) {\\n        int X1 = Integer.MAX_VALUE;\\n        int Y1 = Integer.MAX_VALUE;\\n        int X2 = Integer.MIN_VALUE;\\n        int Y2 = Integer.MIN_VALUE;\\n\\n        HashSet<String> points = new HashSet<>();\\n        int areas = 0;\\n        for (int[] p : rectangles){\\n            int x1 = p[0]; int y1 = p[1]; int x2 = p[2]; int y2 = p[3];\\n            X1 = Math.min(X1,x1); Y1 = Math.min(Y1, y1);\\n            X2 = Math.max(X2,x2); Y2 = Math.max(Y2, y2);\\n\\n            areas += (x2-x1) * (y2-y1);\\n\\n            String p1 = x1 + \",\" + y1; String p2 = x1 + \",\" + y2;\\n            String p3 = x2 + \",\" + y1; String p4 = x2 + \",\" + y2;\\n            for(String v : new String[]{p1,p2,p3,p4}){\\n                if (points.contains(v)){\\n                    points.remove(v);\\n                }else{\\n                    points.add(v);\\n                }\\n            }\\n        }\\n\\n        int expectedAreas = (X2-X1)*(Y2-Y1);\\n\\n        if (expectedAreas != areas) return false;\\n        if (points.size() != 4) return false;\\n        \\n        String s1 = X1 + \",\" + Y1; String s2 = X1 + \",\" + Y2;\\n        String s3 = X2 + \",\" + Y1; String s4 = X2 + \",\" + Y2;\\n        if (!points.contains(s1)) return false;\\n        if (!points.contains(s2)) return false;\\n        if (!points.contains(s3)) return false;\\n        if (!points.contains(s4)) return false;\\n\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isRectangleCover(int[][] rectangles) {\\n        int X1 = Integer.MAX_VALUE;\\n        int Y1 = Integer.MAX_VALUE;\\n        int X2 = Integer.MIN_VALUE;\\n        int Y2 = Integer.MIN_VALUE;\\n\\n        HashSet<String> points = new HashSet<>();\\n        int areas = 0;\\n        for (int[] p : rectangles){\\n            int x1 = p[0]; int y1 = p[1]; int x2 = p[2]; int y2 = p[3];\\n            X1 = Math.min(X1,x1); Y1 = Math.min(Y1, y1);\\n            X2 = Math.max(X2,x2); Y2 = Math.max(Y2, y2);\\n\\n            areas += (x2-x1) * (y2-y1);\\n\\n            String p1 = x1 + \",\" + y1; String p2 = x1 + \",\" + y2;\\n            String p3 = x2 + \",\" + y1; String p4 = x2 + \",\" + y2;\\n            for(String v : new String[]{p1,p2,p3,p4}){\\n                if (points.contains(v)){\\n                    points.remove(v);\\n                }else{\\n                    points.add(v);\\n                }\\n            }\\n        }\\n\\n        int expectedAreas = (X2-X1)*(Y2-Y1);\\n\\n        if (expectedAreas != areas) return false;\\n        if (points.size() != 4) return false;\\n        \\n        String s1 = X1 + \",\" + Y1; String s2 = X1 + \",\" + Y2;\\n        String s3 = X2 + \",\" + Y1; String s4 = X2 + \",\" + Y2;\\n        if (!points.contains(s1)) return false;\\n        if (!points.contains(s2)) return false;\\n        if (!points.contains(s3)) return false;\\n        if (!points.contains(s4)) return false;\\n\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3246097,
                "title": "points-and-area",
                "content": "# Intuition\\n\\u8FD9\\u9898\\u5C5E\\u4E8E\\u96BE\\u8005\\u4E0D\\u4F1A\\u4F1A\\u8005\\u4E0D\\u96BE\\u3002\\n\\u4E3B\\u8981\\u4ECE\\u4E24\\u4E2A\\u89D2\\u5EA6\\u5165\\u624B\\uFF0C\\u4E00\\u4E2A\\u662F\\u9762\\u79EF\\uFF0C\\u4E00\\u4E2A\\u662F\\u9876\\u70B9\\u4E2A\\u6570\\u3002\\n* \\u9996\\u5148\\u5404\\u4E2A\\u5C0F\\u77E9\\u5F62\\u5982\\u679C\\u80FD\\u7EC4\\u6210perfect rectangle\\uFF0C\\u90A3\\u4E48\\u603B\\u9762\\u79EF\\u548C\\u4E00\\u5B9A\\u7B49\\u4E8E\\u65B0\\u7684\\u77E9\\u5F62\\u7684\\u9762\\u79EF\\u3002\\u53EF\\u4EE5\\u5F88\\u5BB9\\u6613\\u5730\\u627E\\u5230\\u5DE6\\u4E0B\\u89D2\\u548C\\u53F3\\u4E0A\\u89D2\\u7684\\u70B9\\u7684x\\uFF0Cy\\u5750\\u6807\\u3002\\n* \\u4F46\\u662F\\u8FD9\\u8FD8\\u662F\\u4E0D\\u591F\\u7684\\uFF0C\\u56E0\\u4E3A\\u53EF\\u80FD\\u5B58\\u5728\\u4E24\\u4E2A\\u77E9\\u5F62\\u9762\\u79EF\\u91CD\\u5408\\u7684\\u60C5\\u51B5\\n* \\u73B0\\u5728\\u5C31\\u518D\\u9700\\u8981\\u6839\\u636E\\u9876\\u70B9\\u5224\\u65AD\\u4E86\\uFF0C\\u6BCF\\u4E2A\\u5C0F\\u77E9\\u5F62\\u76844\\u4E2A\\u9876\\u70B9\\u90FD\\u53EF\\u4EE5\\u505A\\u8BB0\\u5F55\\uFF0C\\u5982\\u679C\\u6700\\u7EC8\\u80FD\\u7EC4\\u6210perfect rectangle\\u90A3\\u4E48\\u4E00\\u5B9A\\u53EA\\u67094\\u4E2A\\u9876\\u70B9\\u51FA\\u73B0\\u5947\\u6570\\u6B21\\u3002\\u8FD9\\u91CC\\u53EF\\u4EE5\\u5DE7\\u7528set\\uFF0C\\u51FA\\u73B0\\u8FC7\\u5C31remove\\uFF0C\\u53CD\\u6B63\\u5219add\\uFF0C\\u6700\\u540E\\u53EA\\u8981\\u5224\\u65ADsize\\u5373\\u53EF\\n* \\u8FD9\\u91CC\\u4ECD\\u7136\\u662F\\u4E0D\\u591F\\u7684\\uFF0C\\u8FD8\\u9700\\u8981\\u8FDB\\u4E00\\u6B65\\u5224\\u5B9A\\u6700\\u540E\\u7684\\u8FD94\\u4E2A\\u70B9\\u7EC4\\u6210\\u7684\\u603B\\u9762\\u79EF\\u662F\\u4E0D\\u662F\\u8DDF\\u603Barea\\u76F8\\u540C\\u6216\\u8005\\u4E5F\\u53EF\\u4EE5\\u5224\\u5B9A\\u4E4B\\u524D\\u7684\\u5DE6\\u4E0B\\u89D2\\u548C\\u53F3\\u4E0A\\u89D2\\u7684\\u4E24\\u4E2A\\u70B9\\u662F\\u4E0D\\u662F\\u5728set\\u91CC\\u9762\\u3002\\n\\n# Code\\n```\\nclass Solution {\\n    data class Point(val x: Int, val y: Int)\\n    fun isRectangleCover(rectangles: Array<IntArray>): Boolean {\\n        var x1 = Int.MAX_VALUE\\n        var y1 = Int.MAX_VALUE\\n        var x2 = Int.MIN_VALUE\\n        var y2 = Int.MIN_VALUE\\n\\n        var area = 0\\n        val points = mutableSetOf<Point>()\\n\\n        for ((x, y, a, b) in rectangles) {\\n            x1 = Math.min(x1, x)\\n            y1 = Math.min(y1, y)\\n            x2 = Math.max(x2, a)\\n            y2 = Math.max(y2, b)\\n\\n            area += (a - x) * (b - y)\\n\\n            checkPoint(Point(x, y), points)\\n            checkPoint(Point(x, b), points)\\n            checkPoint(Point(a, y), points)\\n            checkPoint(Point(a, b), points)\\n        }\\n\\n        if (area != (x2 - x1) * (y2 - y1) || points.size != 4) return false\\n        return Point(x1, y1) in points && Point(x2, y2) in points\\n    }\\n\\n    fun checkPoint(p: Point, points: MutableSet<Point>) {\\n        if (p in points) {\\n            points.remove(p)\\n        } else {\\n            points.add(p)\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    data class Point(val x: Int, val y: Int)\\n    fun isRectangleCover(rectangles: Array<IntArray>): Boolean {\\n        var x1 = Int.MAX_VALUE\\n        var y1 = Int.MAX_VALUE\\n        var x2 = Int.MIN_VALUE\\n        var y2 = Int.MIN_VALUE\\n\\n        var area = 0\\n        val points = mutableSetOf<Point>()\\n\\n        for ((x, y, a, b) in rectangles) {\\n            x1 = Math.min(x1, x)\\n            y1 = Math.min(y1, y)\\n            x2 = Math.max(x2, a)\\n            y2 = Math.max(y2, b)\\n\\n            area += (a - x) * (b - y)\\n\\n            checkPoint(Point(x, y), points)\\n            checkPoint(Point(x, b), points)\\n            checkPoint(Point(a, y), points)\\n            checkPoint(Point(a, b), points)\\n        }\\n\\n        if (area != (x2 - x1) * (y2 - y1) || points.size != 4) return false\\n        return Point(x1, y1) in points && Point(x2, y2) in points\\n    }\\n\\n    fun checkPoint(p: Point, points: MutableSet<Point>) {\\n        if (p in points) {\\n            points.remove(p)\\n        } else {\\n            points.add(p)\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3245247,
                "title": "java-03012023",
                "content": "# Approach\\nNote how we record veritces\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isRectangleCover(int[][] rectangles) {\\n        int X1 = Integer.MAX_VALUE, Y1 = Integer.MAX_VALUE;\\n        int X2 = Integer.MIN_VALUE, Y2 = Integer.MIN_VALUE;\\n        int totalArea = 0;\\n        // to record vertices\\n        HashSet<String> vertices = new HashSet<>();\\n        for (int[] rectangle : rectangles) {\\n            // Remove point if already in vertices set, add it if not in\\n            String x1y1 = String.valueOf(rectangle[0]) + String.valueOf(rectangle[1]);\\n            String x2y2 = String.valueOf(rectangle[2]) + String.valueOf(rectangle[3]);\\n            String x1y2 = String.valueOf(rectangle[0]) + String.valueOf(rectangle[3]);\\n            String x2y1 = String.valueOf(rectangle[2]) + String.valueOf(rectangle[1]);\\n\\n            if (!vertices.contains(x1y1)) {\\n                vertices.add(x1y1);\\n            } else {\\n                vertices.remove(x1y1);\\n            }\\n            if (!vertices.contains(x2y2)) {\\n                vertices.add(x2y2);\\n            } else {\\n                vertices.remove(x2y2);\\n            }\\n            if (!vertices.contains(x1y2)) {\\n                vertices.add(x1y2);\\n            } else {\\n                vertices.remove(x1y2);\\n            }\\n            if (!vertices.contains(x2y1)) {\\n                vertices.add(x2y1);\\n            } else {\\n                vertices.remove(x2y1);\\n            }\\n            X1 = Math.min(X1, rectangle[0]);\\n            Y1 = Math.min(Y1, rectangle[1]);\\n            X2 = Math.max(X2, rectangle[2]);\\n            Y2 = Math.max(Y2, rectangle[3]);\\n            totalArea += (rectangle[2]-rectangle[0]) * (rectangle[3]-rectangle[1]);\\n        }\\n        System.out.println(X1);\\n        System.out.println(Y1);\\n        System.out.println(X2);\\n        System.out.println(Y2);\\n        System.out.println(vertices.size());\\n        String x1y1 = String.valueOf(X1) + String.valueOf(Y1);\\n        if (!vertices.contains(x1y1)) return false;\\n        String x2y2 = String.valueOf(X2) + String.valueOf(Y2);\\n        if (!vertices.contains(x2y2)) return false;\\n        String x1y2 = String.valueOf(X1) + String.valueOf(Y2);\\n        if (!vertices.contains(x1y2)) return false;\\n        String x2y1 = String.valueOf(X2) + String.valueOf(Y1);\\n        if (!vertices.contains(x2y1)) return false;\\n\\n        return vertices.size() == 4 && (X2-X1) * (Y2-Y1) == totalArea;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isRectangleCover(int[][] rectangles) {\\n        int X1 = Integer.MAX_VALUE, Y1 = Integer.MAX_VALUE;\\n        int X2 = Integer.MIN_VALUE, Y2 = Integer.MIN_VALUE;\\n        int totalArea = 0;\\n        // to record vertices\\n        HashSet<String> vertices = new HashSet<>();\\n        for (int[] rectangle : rectangles) {\\n            // Remove point if already in vertices set, add it if not in\\n            String x1y1 = String.valueOf(rectangle[0]) + String.valueOf(rectangle[1]);\\n            String x2y2 = String.valueOf(rectangle[2]) + String.valueOf(rectangle[3]);\\n            String x1y2 = String.valueOf(rectangle[0]) + String.valueOf(rectangle[3]);\\n            String x2y1 = String.valueOf(rectangle[2]) + String.valueOf(rectangle[1]);\\n\\n            if (!vertices.contains(x1y1)) {\\n                vertices.add(x1y1);\\n            } else {\\n                vertices.remove(x1y1);\\n            }\\n            if (!vertices.contains(x2y2)) {\\n                vertices.add(x2y2);\\n            } else {\\n                vertices.remove(x2y2);\\n            }\\n            if (!vertices.contains(x1y2)) {\\n                vertices.add(x1y2);\\n            } else {\\n                vertices.remove(x1y2);\\n            }\\n            if (!vertices.contains(x2y1)) {\\n                vertices.add(x2y1);\\n            } else {\\n                vertices.remove(x2y1);\\n            }\\n            X1 = Math.min(X1, rectangle[0]);\\n            Y1 = Math.min(Y1, rectangle[1]);\\n            X2 = Math.max(X2, rectangle[2]);\\n            Y2 = Math.max(Y2, rectangle[3]);\\n            totalArea += (rectangle[2]-rectangle[0]) * (rectangle[3]-rectangle[1]);\\n        }\\n        System.out.println(X1);\\n        System.out.println(Y1);\\n        System.out.println(X2);\\n        System.out.println(Y2);\\n        System.out.println(vertices.size());\\n        String x1y1 = String.valueOf(X1) + String.valueOf(Y1);\\n        if (!vertices.contains(x1y1)) return false;\\n        String x2y2 = String.valueOf(X2) + String.valueOf(Y2);\\n        if (!vertices.contains(x2y2)) return false;\\n        String x1y2 = String.valueOf(X1) + String.valueOf(Y2);\\n        if (!vertices.contains(x1y2)) return false;\\n        String x2y1 = String.valueOf(X2) + String.valueOf(Y1);\\n        if (!vertices.contains(x2y1)) return false;\\n\\n        return vertices.size() == 4 && (X2-X1) * (Y2-Y1) == totalArea;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3218263,
                "title": "python-simple-maths",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def isRectangleCover(self, rectangles):\\n        total, ans = 0, set()\\n\\n        for i,j,k,l in rectangles:\\n            total += (l-j)*(k-i)\\n            ans ^= {(i,j),(i,l),(k,l),(k,j)}\\n\\n        if len(ans) != 4:\\n            return False\\n\\n        x,y = min(ans, key = lambda x: x[0] + x[1])\\n        X,Y = max(ans, key = lambda x: x[0] + x[1])\\n\\n        return (X-x)*(Y-y) == total\\n\\n        \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isRectangleCover(self, rectangles):\\n        total, ans = 0, set()\\n\\n        for i,j,k,l in rectangles:\\n            total += (l-j)*(k-i)\\n            ans ^= {(i,j),(i,l),(k,l),(k,j)}\\n\\n        if len(ans) != 4:\\n            return False\\n\\n        x,y = min(ans, key = lambda x: x[0] + x[1])\\n        X,Y = max(ans, key = lambda x: x[0] + x[1])\\n\\n        return (X-x)*(Y-y) == total\\n\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3126298,
                "title": "ruby-solution-inspired-by-labuladong-partially",
                "content": "```\\ndef is_rectangle_cover(rectangles)\\n  require \\'set\\'\\n  yy = xx = -2 ** 32\\n  x = y = 2 ** 32\\n  area = 0\\n  vertex = Set.new\\n  rectangles.each do |x1, y1, x2, y2|\\n    area += (x2 - x1) * (y2 - y1)\\n    x = [x, x1].min\\n    y = [y, y1].min\\n    xx = [xx, x2].max\\n    yy = [yy, y2].max\\n    [[x1, y1], [x1, y2], [x2, y1], [x2, y2]].each do |p|\\n      if vertex.include?(p)\\n        vertex.delete(p)\\n      else\\n        vertex.add(p)\\n      end\\n    end\\n  end\\n  ideal_vertexes = Set.new([[x, y], [xx, yy], [x, yy], [xx, y]])\\n  area == (xx - x) * (yy - y) && ideal_vertexes == vertex\\nend\\n```",
                "solutionTags": [],
                "code": "```\\ndef is_rectangle_cover(rectangles)\\n  require \\'set\\'\\n  yy = xx = -2 ** 32\\n  x = y = 2 ** 32\\n  area = 0\\n  vertex = Set.new\\n  rectangles.each do |x1, y1, x2, y2|\\n    area += (x2 - x1) * (y2 - y1)\\n    x = [x, x1].min\\n    y = [y, y1].min\\n    xx = [xx, x2].max\\n    yy = [yy, y2].max\\n    [[x1, y1], [x1, y2], [x2, y1], [x2, y2]].each do |p|\\n      if vertex.include?(p)\\n        vertex.delete(p)\\n      else\\n        vertex.add(p)\\n      end\\n    end\\n  end\\n  ideal_vertexes = Set.new([[x, y], [xx, yy], [x, yy], [xx, y]])\\n  area == (xx - x) * (yy - y) && ideal_vertexes == vertex\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3125812,
                "title": "how-to-beat-a-100",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n<!-- Check  -->\\n\\n# Approach\\nTo optimize lets make our own hash map on an array.\\nUse prime numbers to make good hash function.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$ \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n$$O(mod)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#define MOD 113\\n#define P 31\\nclass Solution {\\n    bool corners[MOD];\\n    int sum = 0;\\n    inline long long area(const vector<int> &r) {\\n        return (long long)(r[2] - r[0]) * (r[3] - r[1]);\\n    }\\n    inline void add(const pair<int, int> &p) {\\n        bool& v = corners[((p.first * P + p.second) % MOD + MOD) % MOD];\\n        v ^= 1;\\n        sum += (v ? 1 : -1);\\n    }\\npublic:\\n    bool isRectangleCover(const vector<vector<int>>& rectangles) {\\n        long long sum_area = 0;\\n        int x0 = 1e5, y0 = 1e5, x1 = -1e5, y1 = -1e5;\\n\\n        for (const auto &r : rectangles) {\\n            sum_area += area(r);\\n            x0 = (x0 < r[0] ? x0 : r[0]);\\n            y0 = (y0 < r[1] ? y0 : r[1]);\\n            x1 = (x1 > r[2] ? x1 : r[2]);\\n            y1 = (y1 > r[3] ? y1 : r[3]);\\n            add({r[0], r[1]});\\n            add({r[2], r[3]});\\n            add({r[0], r[3]});\\n            add({r[2], r[1]});\\n        }\\n        \\n        add({x0, y0});\\n        add({x1, y0});\\n        add({x0, y1});\\n        add({x1, y1});\\n        // cout << x0 << \" \" << y0 << \" \" << x1 << \" \" << y1 << \"\\\\n\";\\n        return area({x0, y0, x1, y1}) == sum_area && sum == 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\n#define MOD 113\\n#define P 31\\nclass Solution {\\n    bool corners[MOD];\\n    int sum = 0;\\n    inline long long area(const vector<int> &r) {\\n        return (long long)(r[2] - r[0]) * (r[3] - r[1]);\\n    }\\n    inline void add(const pair<int, int> &p) {\\n        bool& v = corners[((p.first * P + p.second) % MOD + MOD) % MOD];\\n        v ^= 1;\\n        sum += (v ? 1 : -1);\\n    }\\npublic:\\n    bool isRectangleCover(const vector<vector<int>>& rectangles) {\\n        long long sum_area = 0;\\n        int x0 = 1e5, y0 = 1e5, x1 = -1e5, y1 = -1e5;\\n\\n        for (const auto &r : rectangles) {\\n            sum_area += area(r);\\n            x0 = (x0 < r[0] ? x0 : r[0]);\\n            y0 = (y0 < r[1] ? y0 : r[1]);\\n            x1 = (x1 > r[2] ? x1 : r[2]);\\n            y1 = (y1 > r[3] ? y1 : r[3]);\\n            add({r[0], r[1]});\\n            add({r[2], r[3]});\\n            add({r[0], r[3]});\\n            add({r[2], r[1]});\\n        }\\n        \\n        add({x0, y0});\\n        add({x1, y0});\\n        add({x0, y1});\\n        add({x1, y1});\\n        // cout << x0 << \" \" << y0 << \" \" << x1 << \" \" << y1 << \"\\\\n\";\\n        return area({x0, y0, x1, y1}) == sum_area && sum == 0;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3105634,
                "title": "swift-solution-basic-approach",
                "content": "# Approach\\n1. Find the coordinates of the bottom-left and top-right corners of the rectangle that contains all the smaller rectangles.\\n2. Calculate the total area of all the smaller rectangles.\\n3. Iterate through all the smaller rectangles, and:\\n    - Calculate the area of each smaller rectangle.\\n    - Check if each corner of the smaller rectangle is in the set of corners. If it is, remove it; if it isn\\'t, add it.\\n4. Check if the set of corners contains the four corners of the big rectangle, and that the total area of all the smaller rectangles is equal to the area of the big rectangle.\\n\\n# Complexity\\n> Time complexity: O(n)\\n> Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution {\\n    func isRectangleCover(_ rectangles: [[Int]]) -> Bool {\\n        var x1 = Int.max\\n        var y1 = Int.max\\n        var x2 = Int.min\\n        var y2 = Int.min\\n        var area = 0\\n        var set = Set<String>()\\n        for rec in rectangles {\\n            x1 = min(x1, rec[0])\\n            y1 = min(y1, rec[1])\\n            x2 = max(x2, rec[2])\\n            y2 = max(y2, rec[3])\\n            area += (rec[2] - rec[0]) * (rec[3] - rec[1])\\n            let s1 = \"\\\\(rec[0]) \\\\(rec[1])\"\\n            let s2 = \"\\\\(rec[0]) \\\\(rec[3])\"\\n            let s3 = \"\\\\(rec[2]) \\\\(rec[3])\"\\n            let s4 = \"\\\\(rec[2]) \\\\(rec[1])\"\\n            if !set.insert(s1).inserted {\\n                set.remove(s1)\\n            }\\n            if !set.insert(s2).inserted {\\n                set.remove(s2)\\n            }\\n            if !set.insert(s3).inserted {\\n                set.remove(s3)\\n            }\\n            if !set.insert(s4).inserted {\\n                set.remove(s4)\\n            }\\n        }\\n        if !set.contains(\"\\\\(x1) \\\\(y1)\") || !set.contains(\"\\\\(x1) \\\\(y2)\") || !set.contains(\"\\\\(x2) \\\\(y1)\") || !set.contains(\"\\\\(x2) \\\\(y2)\") || set.count != 4 {\\n            return false\\n        }\\n        return area == (x2 - x1) * (y2 - y1)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func isRectangleCover(_ rectangles: [[Int]]) -> Bool {\\n        var x1 = Int.max\\n        var y1 = Int.max\\n        var x2 = Int.min\\n        var y2 = Int.min\\n        var area = 0\\n        var set = Set<String>()\\n        for rec in rectangles {\\n            x1 = min(x1, rec[0])\\n            y1 = min(y1, rec[1])\\n            x2 = max(x2, rec[2])\\n            y2 = max(y2, rec[3])\\n            area += (rec[2] - rec[0]) * (rec[3] - rec[1])\\n            let s1 = \"\\\\(rec[0]) \\\\(rec[1])\"\\n            let s2 = \"\\\\(rec[0]) \\\\(rec[3])\"\\n            let s3 = \"\\\\(rec[2]) \\\\(rec[3])\"\\n            let s4 = \"\\\\(rec[2]) \\\\(rec[1])\"\\n            if !set.insert(s1).inserted {\\n                set.remove(s1)\\n            }\\n            if !set.insert(s2).inserted {\\n                set.remove(s2)\\n            }\\n            if !set.insert(s3).inserted {\\n                set.remove(s3)\\n            }\\n            if !set.insert(s4).inserted {\\n                set.remove(s4)\\n            }\\n        }\\n        if !set.contains(\"\\\\(x1) \\\\(y1)\") || !set.contains(\"\\\\(x1) \\\\(y2)\") || !set.contains(\"\\\\(x2) \\\\(y1)\") || !set.contains(\"\\\\(x2) \\\\(y2)\") || set.count != 4 {\\n            return false\\n        }\\n        return area == (x2 - x1) * (y2 - y1)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3044118,
                "title": "c",
                "content": "(```)  class Solution {\\npublic:\\n    bool isRectangleCover(vector<vector<int>>& rectangles) \\n    {\\n        map<pair<int,int>,int> mp;\\n        \\n        int count = 0;\\n        \\n        for(auto &x: rectangles) \\n        {\\n            mp[{x[0],x[1]}]++;\\n            mp[{x[2],x[3]}]++;\\n            mp[{x[0],x[3]}]--;\\n            mp[{x[2],x[1]}]--;\\n        } \\n        \\n        for(auto it = mp.begin(); it != mp.end(); it++)\\n        {\\n            if(it->second != 0)\\n            {\\n                if(abs(it->second) != 1)\\n                {\\n                    return false;\\n                }\\n                else\\n                {\\n                    count++;\\n                }\\n            }\\n            \\n            \\n        }\\n        \\n        return count == 4;\\n            \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool isRectangleCover(vector<vector<int>>& rectangles) \\n    {\\n        map<pair<int,int>,int> mp;\\n        \\n        int count = 0;\\n        \\n        for(auto &x: rectangles) \\n        {\\n            mp[{x[0],x[1]}",
                "codeTag": "Java"
            },
            {
                "id": 3041463,
                "title": "c-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    long long mod=1e9+7;\\n    int xma=INT_MIN,yma=INT_MIN,xmi=INT_MAX,ymi=INT_MAX;\\n    int picaro=0,dem=0;\\n    long long count=0,a,b;\\n    map<pair<int,int>,unordered_map<int,int>> kt; \\n    int checkcrossing(int x,int y,int z)\\n    {\\n        if(kt[{x,y}].count(z)==0)\\n        {\\n            kt[{x,y}][z]=1;\\n            if(kt[{x,y}].size()==1) dem++;\\n            if(kt[{x,y}].size()==2) dem--;\\n            return 0;\\n        }\\n        return 1;\\n    }\\n    bool isRectangleCover(vector<vector<int>>& rectangles) {\\n        for(int i=0;i<=rectangles.size()-1;i++)\\n        {\\n            xma=max(xma,rectangles[i][2]);\\n            xmi=min(xmi,rectangles[i][0]);\\n            yma=max(yma,rectangles[i][3]);\\n            ymi=min(ymi,rectangles[i][1]);\\n            a=rectangles[i][3]-rectangles[i][1];\\n            a=a*(rectangles[i][2]-rectangles[i][0])%mod;\\n            count=(count+a)%mod;\\n            picaro=max(picaro,checkcrossing(rectangles[i][0],rectangles[i][3],1));\\n            picaro=max(picaro,checkcrossing(rectangles[i][0],rectangles[i][1],2));\\n            picaro=max(picaro,checkcrossing(rectangles[i][2],rectangles[i][1],3));\\n            picaro=max(picaro,checkcrossing(rectangles[i][2],rectangles[i][3],4));\\n            if(picaro==1) return false;\\n        }\\n        b=xma-xmi;\\n        b=b*(yma-ymi)%mod;\\n        // cout << b << \"  \" << count;\\n        if(b<count) return false;\\n        if(dem==4) return true;\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long mod=1e9+7;\\n    int xma=INT_MIN,yma=INT_MIN,xmi=INT_MAX,ymi=INT_MAX;\\n    int picaro=0,dem=0;\\n    long long count=0,a,b;\\n    map<pair<int,int>,unordered_map<int,int>> kt; \\n    int checkcrossing(int x,int y,int z)\\n    {\\n        if(kt[{x,y}].count(z)==0)\\n        {\\n            kt[{x,y}][z]=1;\\n            if(kt[{x,y}].size()==1) dem++;\\n            if(kt[{x,y}].size()==2) dem--;\\n            return 0;\\n        }\\n        return 1;\\n    }\\n    bool isRectangleCover(vector<vector<int>>& rectangles) {\\n        for(int i=0;i<=rectangles.size()-1;i++)\\n        {\\n            xma=max(xma,rectangles[i][2]);\\n            xmi=min(xmi,rectangles[i][0]);\\n            yma=max(yma,rectangles[i][3]);\\n            ymi=min(ymi,rectangles[i][1]);\\n            a=rectangles[i][3]-rectangles[i][1];\\n            a=a*(rectangles[i][2]-rectangles[i][0])%mod;\\n            count=(count+a)%mod;\\n            picaro=max(picaro,checkcrossing(rectangles[i][0],rectangles[i][3],1));\\n            picaro=max(picaro,checkcrossing(rectangles[i][0],rectangles[i][1],2));\\n            picaro=max(picaro,checkcrossing(rectangles[i][2],rectangles[i][1],3));\\n            picaro=max(picaro,checkcrossing(rectangles[i][2],rectangles[i][3],4));\\n            if(picaro==1) return false;\\n        }\\n        b=xma-xmi;\\n        b=b*(yma-ymi)%mod;\\n        // cout << b << \"  \" << count;\\n        if(b<count) return false;\\n        if(dem==4) return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3024862,
                "title": "c-good-code-quality-easy-to-understand-based-on-math-s-and-geometry",
                "content": "**Explanation:**\\nTwo points to observe:\\n1) Sum of all the small rectangles area should be equal to large rectangle area.\\n2) A rectangular cover should only have 4 corner points.\\n\\n**Approach:**\\nWe are maintaining 4 variables maxX,minX,maxY,minY to maintain minimum X,Y and maximum X,Y points of the\\nbigger rectangle that will be the final cover.\\nWe will use a set to store these co-ordinates and whenever we found a co-ordinate that is already in set\\nit simply means that the rectangle is touching another rectangle.\\nFinally check the sum of area to be equal to larger rectangle.\\n\\n**Algorithm:**\\nRun a loop through all the rectangles to process them.\\nMaximise and minimize the larger rectangle co-ordinates accordingly.\\nAdd the sum of all rectangle area.\\nAdd or remove corners from the set accordingly.\\nLastly check the conditions if corners of bigger rectangle is present or not. If not return false.\\nFinally check area of smaller rectangels equal to larger rectangle and return the result.\\n\\n```\\nclass Solution {\\npublic:\\n    bool isRectangleCover(vector<vector<int>>& rectangles) {\\n        if(rectangles.size()==1) return true;\\n        set<pair<int,int>> corners;\\n        int x1,x2,y1,y2;\\n        long long area=0;\\n        int maxX=INT_MIN,minX=INT_MAX,maxY=INT_MIN,minY=INT_MAX;\\n        for(vector<int> rectangle : rectangles){\\n            x1=rectangle[0];\\n            y1=rectangle[1];\\n            x2=rectangle[2];\\n            y2=rectangle[3];\\n            maxX=max(maxX,x2);\\n            maxY=max(maxY,y2);\\n            minX=min(minX,x1);\\n            minY=min(minY,y1);\\n            area+=(x2-x1)*(y2-y1);\\n            pair<int,int> corner1={x1,y1};\\n            pair<int,int> corner2={x2,y2};\\n            pair<int,int> corner3={x1,y2};\\n            pair<int,int> corner4={x2,y1};\\n            \\n            if(corners.count(corner1)){\\n                corners.erase(corner1);\\n            }else{\\n                corners.insert(corner1);\\n            }\\n\\n            if(corners.count(corner2)){\\n                corners.erase(corner2);\\n            }else{\\n                corners.insert(corner2);\\n            }\\n\\n            if(corners.count(corner3)){\\n                corners.erase(corner3);\\n            }else{\\n                corners.insert(corner3);\\n            }\\n\\n            if(corners.count(corner4)){\\n                corners.erase(corner4);\\n            }else{\\n                corners.insert(corner4);\\n            } \\n        }\\n        if(corners.size()!=4 || !corners.count({minX,minY}) || !corners.count({minX,maxY}) || !corners.count({maxX,minY}) || !corners.count({maxX,maxY})){\\n            return false;\\n        }\\n        \\n        return area == (maxX-minX)*(maxY-minY);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math",
                    "Geometry",
                    "Line Sweep"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isRectangleCover(vector<vector<int>>& rectangles) {\\n        if(rectangles.size()==1) return true;\\n        set<pair<int,int>> corners;\\n        int x1,x2,y1,y2;\\n        long long area=0;\\n        int maxX=INT_MIN,minX=INT_MAX,maxY=INT_MIN,minY=INT_MAX;\\n        for(vector<int> rectangle : rectangles){\\n            x1=rectangle[0];\\n            y1=rectangle[1];\\n            x2=rectangle[2];\\n            y2=rectangle[3];\\n            maxX=max(maxX,x2);\\n            maxY=max(maxY,y2);\\n            minX=min(minX,x1);\\n            minY=min(minY,y1);\\n            area+=(x2-x1)*(y2-y1);\\n            pair<int,int> corner1={x1,y1};\\n            pair<int,int> corner2={x2,y2};\\n            pair<int,int> corner3={x1,y2};\\n            pair<int,int> corner4={x2,y1};\\n            \\n            if(corners.count(corner1)){\\n                corners.erase(corner1);\\n            }else{\\n                corners.insert(corner1);\\n            }\\n\\n            if(corners.count(corner2)){\\n                corners.erase(corner2);\\n            }else{\\n                corners.insert(corner2);\\n            }\\n\\n            if(corners.count(corner3)){\\n                corners.erase(corner3);\\n            }else{\\n                corners.insert(corner3);\\n            }\\n\\n            if(corners.count(corner4)){\\n                corners.erase(corner4);\\n            }else{\\n                corners.insert(corner4);\\n            } \\n        }\\n        if(corners.size()!=4 || !corners.count({minX,minY}) || !corners.count({minX,maxY}) || !corners.count({maxX,minY}) || !corners.count({maxX,maxY})){\\n            return false;\\n        }\\n        \\n        return area == (maxX-minX)*(maxY-minY);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3024861,
                "title": "c-good-code-quality-easy-to-understand-based-on-math-s-and-geometry",
                "content": "**Explanation:**\\nTwo points to observe:\\n1) Sum of all the small rectangles area should be equal to large rectangle area.\\n2) A rectangular cover should only have 4 corner points.\\n\\n**Approach:**\\nWe are maintaining 4 variables maxX,minX,maxY,minY to maintain minimum X,Y and maximum X,Y points of the\\nbigger rectangle that will be the final cover.\\nWe will use a set to store these co-ordinates and whenever we found a co-ordinate that is already in set\\nit simply means that the rectangle is touching another rectangle.\\nFinally check the sum of area to be equal to larger rectangle.\\n\\n**Algorithm:**\\nRun a loop through all the rectangles to process them.\\nMaximise and minimize the larger rectangle co-ordinates accordingly.\\nAdd the sum of all rectangle area.\\nAdd or remove corners from the set accordingly.\\nLastly check the conditions if corners of bigger rectangle is present or not. If not return false.\\nFinally check area of smaller rectangels equal to larger rectangle and return the result.\\n\\n```\\nclass Solution {\\npublic:\\n    bool isRectangleCover(vector<vector<int>>& rectangles) {\\n        if(rectangles.size()==1) return true;\\n        set<pair<int,int>> corners;\\n        int x1,x2,y1,y2;\\n        long long area=0;\\n        int maxX=INT_MIN,minX=INT_MAX,maxY=INT_MIN,minY=INT_MAX;\\n        for(vector<int> rectangle : rectangles){\\n            x1=rectangle[0];\\n            y1=rectangle[1];\\n            x2=rectangle[2];\\n            y2=rectangle[3];\\n            maxX=max(maxX,x2);\\n            maxY=max(maxY,y2);\\n            minX=min(minX,x1);\\n            minY=min(minY,y1);\\n            area+=(x2-x1)*(y2-y1);\\n            pair<int,int> corner1={x1,y1};\\n            pair<int,int> corner2={x2,y2};\\n            pair<int,int> corner3={x1,y2};\\n            pair<int,int> corner4={x2,y1};\\n            \\n            if(corners.count(corner1)){\\n                corners.erase(corner1);\\n            }else{\\n                corners.insert(corner1);\\n            }\\n\\n            if(corners.count(corner2)){\\n                corners.erase(corner2);\\n            }else{\\n                corners.insert(corner2);\\n            }\\n\\n            if(corners.count(corner3)){\\n                corners.erase(corner3);\\n            }else{\\n                corners.insert(corner3);\\n            }\\n\\n            if(corners.count(corner4)){\\n                corners.erase(corner4);\\n            }else{\\n                corners.insert(corner4);\\n            } \\n        }\\n        if(corners.size()!=4 || !corners.count({minX,minY}) || !corners.count({minX,maxY}) || !corners.count({maxX,minY}) || !corners.count({maxX,maxY})){\\n            return false;\\n        }\\n        \\n        return area == (maxX-minX)*(maxY-minY);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math",
                    "Geometry",
                    "Line Sweep"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isRectangleCover(vector<vector<int>>& rectangles) {\\n        if(rectangles.size()==1) return true;\\n        set<pair<int,int>> corners;\\n        int x1,x2,y1,y2;\\n        long long area=0;\\n        int maxX=INT_MIN,minX=INT_MAX,maxY=INT_MIN,minY=INT_MAX;\\n        for(vector<int> rectangle : rectangles){\\n            x1=rectangle[0];\\n            y1=rectangle[1];\\n            x2=rectangle[2];\\n            y2=rectangle[3];\\n            maxX=max(maxX,x2);\\n            maxY=max(maxY,y2);\\n            minX=min(minX,x1);\\n            minY=min(minY,y1);\\n            area+=(x2-x1)*(y2-y1);\\n            pair<int,int> corner1={x1,y1};\\n            pair<int,int> corner2={x2,y2};\\n            pair<int,int> corner3={x1,y2};\\n            pair<int,int> corner4={x2,y1};\\n            \\n            if(corners.count(corner1)){\\n                corners.erase(corner1);\\n            }else{\\n                corners.insert(corner1);\\n            }\\n\\n            if(corners.count(corner2)){\\n                corners.erase(corner2);\\n            }else{\\n                corners.insert(corner2);\\n            }\\n\\n            if(corners.count(corner3)){\\n                corners.erase(corner3);\\n            }else{\\n                corners.insert(corner3);\\n            }\\n\\n            if(corners.count(corner4)){\\n                corners.erase(corner4);\\n            }else{\\n                corners.insert(corner4);\\n            } \\n        }\\n        if(corners.size()!=4 || !corners.count({minX,minY}) || !corners.count({minX,maxY}) || !corners.count({maxX,minY}) || !corners.count({maxX,maxY})){\\n            return false;\\n        }\\n        \\n        return area == (maxX-minX)*(maxY-minY);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3015822,
                "title": "c-detailed-explanation-o-n",
                "content": "# Intution\\n- There was no specific algorithm which hit my find , I just did hit and trial on various test cases and just reached the conclusion.\\n- Though Line Sweep is stated in the related topics but I was not able to comprehend it. *Please do state in the comments if anyone understood it.*\\n# Approach\\n- Approach is stated along with the code\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    // We will store the x coordinates and y coordinates of the points in the pair\\n    // We will store the number of times a point is encountered in the map\\n     bool isRectangleCover(vector<vector<int>> &rectangles)\\n    {\\n        // This function checks whether a set of rectangles form a rectangle. It does this by keeping track of the number of times each point appears in the set of rectangles.\\n\\n        int n = rectangles.size();\\n\\n        if (n == 1)\\n            // If there is only one rectangle, we will return true\\n            return true;\\n\\n        map<pair<int, int>, int> PointEnumerations;\\n        // If the point is encountered once, it means that the point is a corner of a rectangle\\n        // If the point is encountered twice, it means that the point is a corner of two rectangles\\n        // If the point is encountered thrice, it means that the point is a corner of three rectangles\\n        // If the point is encountered four times, it means that the point is a corner of four rectangles\\n        for (auto &rect : rectangles)\\n        {\\n            PointEnumerations[{rect[0], rect[1]}]++;\\n            // Incrementing the bottom left corner of the rectangle\\n            PointEnumerations[{rect[2], rect[3]}]++;\\n            // Incrementing the top right corner of the rectangle\\n            PointEnumerations[{rect[0], rect[3]}]--;\\n            // Decrementing the top left corner of the rectangle\\n            PointEnumerations[{rect[2], rect[1]}]--;\\n            // Decrementing the bottom right corner of the rectangle\\n        }\\n\\n        int CornerPointEncounters = 0;\\n        // We will store the number of points that are encountered once\\n        // We will iterate over the map and check if the number of times a point is encountered is equal to one or not\\n\\n        for (auto PointSet = PointEnumerations.begin(); PointSet != PointEnumerations.end(); PointSet++)\\n        {\\n            if (PointSet->second != 0)\\n            {\\n                // Points which are 0 are the interior points of the rectangles in a perfect reactangle.\\n                // We will not consider these points\\n                // We will only consider the corner points\\n                if (abs(PointSet->second) != 1)\\n                    // We are using abs because the total count of bottom-left and top right corner points will be 1 each respectively for perfect rectangle\\n                    // The total count of top-left and bottom-right corner points will be -1 each respectively for perfect rectangle\\n                    //  If the number of times a point is encountered is not equal to one, we will return false\\n                    return false;\\n\\n                CornerPointEncounters++;\\n                // We will increment the number of points that are encountered once\\n            }\\n        }\\n\\n        return CornerPointEncounters == 4;\\n        // If the number of points that are encountered once is not equal to four, we will return false\\n        // If the number of points that are encountered once is equal to four, we will return true\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Brainteaser"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // We will store the x coordinates and y coordinates of the points in the pair\\n    // We will store the number of times a point is encountered in the map\\n     bool isRectangleCover(vector<vector<int>> &rectangles)\\n    {\\n        // This function checks whether a set of rectangles form a rectangle. It does this by keeping track of the number of times each point appears in the set of rectangles.\\n\\n        int n = rectangles.size();\\n\\n        if (n == 1)\\n            // If there is only one rectangle, we will return true\\n            return true;\\n\\n        map<pair<int, int>, int> PointEnumerations;\\n        // If the point is encountered once, it means that the point is a corner of a rectangle\\n        // If the point is encountered twice, it means that the point is a corner of two rectangles\\n        // If the point is encountered thrice, it means that the point is a corner of three rectangles\\n        // If the point is encountered four times, it means that the point is a corner of four rectangles\\n        for (auto &rect : rectangles)\\n        {\\n            PointEnumerations[{rect[0], rect[1]}]++;\\n            // Incrementing the bottom left corner of the rectangle\\n            PointEnumerations[{rect[2], rect[3]}]++;\\n            // Incrementing the top right corner of the rectangle\\n            PointEnumerations[{rect[0], rect[3]}]--;\\n            // Decrementing the top left corner of the rectangle\\n            PointEnumerations[{rect[2], rect[1]}]--;\\n            // Decrementing the bottom right corner of the rectangle\\n        }\\n\\n        int CornerPointEncounters = 0;\\n        // We will store the number of points that are encountered once\\n        // We will iterate over the map and check if the number of times a point is encountered is equal to one or not\\n\\n        for (auto PointSet = PointEnumerations.begin(); PointSet != PointEnumerations.end(); PointSet++)\\n        {\\n            if (PointSet->second != 0)\\n            {\\n                // Points which are 0 are the interior points of the rectangles in a perfect reactangle.\\n                // We will not consider these points\\n                // We will only consider the corner points\\n                if (abs(PointSet->second) != 1)\\n                    // We are using abs because the total count of bottom-left and top right corner points will be 1 each respectively for perfect rectangle\\n                    // The total count of top-left and bottom-right corner points will be -1 each respectively for perfect rectangle\\n                    //  If the number of times a point is encountered is not equal to one, we will return false\\n                    return false;\\n\\n                CornerPointEncounters++;\\n                // We will increment the number of points that are encountered once\\n            }\\n        }\\n\\n        return CornerPointEncounters == 4;\\n        // If the number of points that are encountered once is not equal to four, we will return false\\n        // If the number of points that are encountered once is equal to four, we will return true\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3008606,
                "title": "c-solutions-easy-to-understand",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool isRectangleCover(vector<vector<int>>& val) {\\n        // here 2 properties should satisfy area of bigger rect. should be equal to the sum of smaller ones \\n        // inner points should occur in even multiples \\n\\n        if (val.size() == 0 || val[0].size() == 0) return false;\\n\\n        long x1 = INT_MAX, y1 = INT_MAX; \\n        long x2 = INT_MIN, y2 = INT_MIN; \\n\\n        long long area =0;\\n        \\n        set<pair<int, int>> uset;\\n\\n        for(int i =0 ; i< val.size();i++){\\n            vector<int> rect = val[i];\\n            x1 = min((long)x1 , (long)rect[0]);\\n            y1 = min((long)y1 , (long)rect[1]);\\n            x2 = max((long)x2 , (long)rect[2]);\\n            y2 = max((long)y2 , (long)rect[3]);\\n\\n            long long a = (rect[2] - rect[0]);\\n            long long b = (rect[3] - rect[1]);\\n            area += a*b;\\n\\n            if (uset.find({rect[0], rect[1]}) != uset.end()) uset.erase({rect[0], rect[1]});  // bottom left corner\\n            else uset.insert({rect[0], rect[1]});\\n\\n            if (uset.find({rect[0], rect[3]}) != uset.end()) uset.erase({rect[0], rect[3]});  // top left corner\\n            else uset.insert({rect[0], rect[3]});\\n\\n            if (uset.find({rect[2], rect[1]}) != uset.end()) uset.erase({rect[2], rect[1]});  // bottom right corner\\n            else uset.insert({rect[2], rect[1]});\\n\\n            if (uset.find({rect[2], rect[3]}) != uset.end()) uset.erase({rect[2], rect[3]});  // top right corner\\n            else uset.insert({rect[2], rect[3]});\\n\\n        } \\n        if(uset.find({x1,y1}) != uset.end() \\n        && uset.find({x1,y2}) != uset.end() \\n        && uset.find({x2,y1}) != uset.end() \\n        && uset.find({x2,y2})!= uset.end() \\n        && uset.size() == 4 && area == (x2-x1) * (y2-y1)) \\n        return true;\\n\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isRectangleCover(vector<vector<int>>& val) {\\n        // here 2 properties should satisfy area of bigger rect. should be equal to the sum of smaller ones \\n        // inner points should occur in even multiples \\n\\n        if (val.size() == 0 || val[0].size() == 0) return false;\\n\\n        long x1 = INT_MAX, y1 = INT_MAX; \\n        long x2 = INT_MIN, y2 = INT_MIN; \\n\\n        long long area =0;\\n        \\n        set<pair<int, int>> uset;\\n\\n        for(int i =0 ; i< val.size();i++){\\n            vector<int> rect = val[i];\\n            x1 = min((long)x1 , (long)rect[0]);\\n            y1 = min((long)y1 , (long)rect[1]);\\n            x2 = max((long)x2 , (long)rect[2]);\\n            y2 = max((long)y2 , (long)rect[3]);\\n\\n            long long a = (rect[2] - rect[0]);\\n            long long b = (rect[3] - rect[1]);\\n            area += a*b;\\n\\n            if (uset.find({rect[0], rect[1]}) != uset.end()) uset.erase({rect[0], rect[1]});  // bottom left corner\\n            else uset.insert({rect[0], rect[1]});\\n\\n            if (uset.find({rect[0], rect[3]}) != uset.end()) uset.erase({rect[0], rect[3]});  // top left corner\\n            else uset.insert({rect[0], rect[3]});\\n\\n            if (uset.find({rect[2], rect[1]}) != uset.end()) uset.erase({rect[2], rect[1]});  // bottom right corner\\n            else uset.insert({rect[2], rect[1]});\\n\\n            if (uset.find({rect[2], rect[3]}) != uset.end()) uset.erase({rect[2], rect[3]});  // top right corner\\n            else uset.insert({rect[2], rect[3]});\\n\\n        } \\n        if(uset.find({x1,y1}) != uset.end() \\n        && uset.find({x1,y2}) != uset.end() \\n        && uset.find({x2,y1}) != uset.end() \\n        && uset.find({x2,y2})!= uset.end() \\n        && uset.size() == 4 && area == (x2-x1) * (y2-y1)) \\n        return true;\\n\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2997237,
                "title": "beat-71-9-with-photo-and-detailed-explanation-line-sweep-monotonic-stack-c-implementation",
                "content": "# Intuition\\n### A warm reminder: Use multiset instead of set\\n\\nThe line sweep algorithm is simple here. If not knowing much about line sweep the 850 Rectangle Area II is also a good question to practice. Tho I used 2d Segment Tree for that questions and quite brute force jajaja. Ok. Let come into this question.\\n\\nBy using Line Sweep. We first sort the data in Y axis from bottom to top. The data will be presented in this way [y-coordinate, startOfRect, rectX1, rectX2]. So during line sweep, we could not where the rectangle start and where it end. The logic of line sweep we apply here is to find out whether all the end of rectangles on this y-axis is the start of other rectangles on this y-axis. \\n\\nFor example, consider the below image demonstrating a specific line in the graph. On this line/ this y-axis, we have orange and pink rectangles will be ended and we have new blue and green rectangles to be started. The only methods that it is a filled rectangle on this line is that.\\n1. There will not be overlapped between (green and blue) or (orange and pink). \\n2. Their X sum is the same.\\n\\n![Screenshot 2023-01-04 at 17.56.13.png](https://assets.leetcode.com/users/images/39a9988c-0445-4032-8b05-10493e243b7d_1672826203.434944.png)\\n\\nOnce every line/ y-axis is filled, we could say that the whole rectangle is a non-overlapped and fully filled rectangle.\\n- Notic: Here we could use Line-Sweep to check all the lines/ y-axis.\\n\\n### However, on each line how do we check whether fulfil the requirement?\\n- Monotonic Stack.\\n\\nSince overlapped is not allowed -> Monotonic stack could confirm each value is larger than the before value.\\nAt last all we need is to pop to stack and check whether they are the same. \\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isRectangleCover(vector<vector<int>>& rectangles) {\\n        multiset<vector<int>> events;\\n        int minPt(INT_MAX), maxPt(INT_MIN);\\n        for (auto &rect: rectangles){\\n            events.insert({rect[1], 1, rect[0], rect[2]});\\n            events.insert({rect[3], 0, rect[0], rect[2]});\\n            minPt = min(minPt, rect[0]);\\n            maxPt = max(maxPt, rect[2]);\\n        }\\n        int beginY((*events.begin())[0]), crtY((*events.begin())[0]);\\n        stack<int> tmp, tmp2;\\n        tmp.push(INT_MIN);\\n        tmp2.push(INT_MIN);\\n        for (auto &a: events){\\n            if (a[0] == beginY){\\n                if (a[1] == 1 && a[2] == minPt) minPt = a[3];\\n                else return false;\\n                continue;\\n            }\\n\\n            if (a[0] == crtY){\\n                if (a[1] == 0) {\\n                    if (a[2] == tmp.top()) {\\n                        tmp.pop();\\n                        tmp.push(a[3]);\\n                    }else if (a[2] > tmp.top()){\\n                        tmp.push(a[2]);\\n                        tmp.push(a[3]);\\n                    }else return false;\\n                }\\n                else {\\n                    if (a[2] == tmp2.top()) {\\n                        tmp2.pop();\\n                        tmp2.push(a[3]);\\n                    }else if (a[2] > tmp2.top()){\\n                        tmp2.push(a[2]);\\n                        tmp2.push(a[3]);\\n                    }else return false;\\n                }\\n            }else{\\n                while (!tmp.empty() && !tmp2.empty()){\\n                    if (tmp.top() == tmp2.top()){\\n                        tmp.pop();\\n                        tmp2.pop();\\n                    }else return false;\\n                }\\n                if (tmp.empty() && tmp2.empty() && a[1] == 0){\\n                    crtY = a[0];\\n                    tmp.push(INT_MIN);\\n                    tmp2.push(INT_MIN);\\n                    tmp.push(a[2]);\\n                    tmp.push(a[3]);\\n                }else return false;\\n            }\\n        }\\n        if (minPt != maxPt) return false;\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Line Sweep",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isRectangleCover(vector<vector<int>>& rectangles) {\\n        multiset<vector<int>> events;\\n        int minPt(INT_MAX), maxPt(INT_MIN);\\n        for (auto &rect: rectangles){\\n            events.insert({rect[1], 1, rect[0], rect[2]});\\n            events.insert({rect[3], 0, rect[0], rect[2]});\\n            minPt = min(minPt, rect[0]);\\n            maxPt = max(maxPt, rect[2]);\\n        }\\n        int beginY((*events.begin())[0]), crtY((*events.begin())[0]);\\n        stack<int> tmp, tmp2;\\n        tmp.push(INT_MIN);\\n        tmp2.push(INT_MIN);\\n        for (auto &a: events){\\n            if (a[0] == beginY){\\n                if (a[1] == 1 && a[2] == minPt) minPt = a[3];\\n                else return false;\\n                continue;\\n            }\\n\\n            if (a[0] == crtY){\\n                if (a[1] == 0) {\\n                    if (a[2] == tmp.top()) {\\n                        tmp.pop();\\n                        tmp.push(a[3]);\\n                    }else if (a[2] > tmp.top()){\\n                        tmp.push(a[2]);\\n                        tmp.push(a[3]);\\n                    }else return false;\\n                }\\n                else {\\n                    if (a[2] == tmp2.top()) {\\n                        tmp2.pop();\\n                        tmp2.push(a[3]);\\n                    }else if (a[2] > tmp2.top()){\\n                        tmp2.push(a[2]);\\n                        tmp2.push(a[3]);\\n                    }else return false;\\n                }\\n            }else{\\n                while (!tmp.empty() && !tmp2.empty()){\\n                    if (tmp.top() == tmp2.top()){\\n                        tmp.pop();\\n                        tmp2.pop();\\n                    }else return false;\\n                }\\n                if (tmp.empty() && tmp2.empty() && a[1] == 0){\\n                    crtY = a[0];\\n                    tmp.push(INT_MIN);\\n                    tmp2.push(INT_MIN);\\n                    tmp.push(a[2]);\\n                    tmp.push(a[3]);\\n                }else return false;\\n            }\\n        }\\n        if (minPt != maxPt) return false;\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1744185,
                "content": [
                    {
                        "username": "shriyansnaik",
                        "content": "Thought process/Key points\\n1. A rectangle has 4 corners. All corners must appear even number of times(because if the figure is a proper rectangle then all the corners will be contiguous) except for the corners.\\n2. Sum of areas of all small rectangles must equal to the big rectangle.\\n3. The bottom-left and the top right corners of the rectangle can be found by looking at the min and max of all points. Use that to figure out all 4 corners of rectangle. Then check if the corners left(after eliminating the corners that occur even number of times) are the ones that should be the corners (which can be figured out from the bottom-left and top-right corners).\\n"
                    },
                    {
                        "username": "Sanzee",
                        "content": "Sometimes It is important to know the input range and properties of the input variables.\\nFor example:\\n1. How many rectangle can be there in worst case.\\n2. are the co-ordinates can be negative?!\\n3. what is the range of the x,y values for each rectangle.\\n"
                    },
                    {
                        "username": "SudhakarMunjuluri",
                        "content": "Could some one please explain me this question\\n\\nI do not even understand how the rectangles were drawn using the given co-ordinates\\n\\nWhat is confusing me is bottom-left and top-right, if i implement what ever the way I could not draw as shown in the example diagram.\\n\\nThanks a lot"
                    },
                    {
                        "username": "panzy",
                        "content": "It took me a whole day to implement a fast enough algorithm to incrementally merge all the rectangles (the idea was that if in the end there is only one rectangle left then it\\'s perfect), only to find it\\'s based on a wrong idea :(\\n\\n![image](https://assets.leetcode.com/users/images/78ea2ba6-9ef9-4cf2-828b-a1dbd179c655_1609701387.5382698.png)\\n\\n(source: https://www.geogebra.org/m/z3skhnf6)\\n"
                    },
                    {
                        "username": "reeshu54raj",
                        "content": "Can anyone explain me how to start thinking for this question. I can\\'t even start my approach. "
                    },
                    {
                        "username": "Finesse",
                        "content": "Try sorting the given rectangles. Then fill the area with the rectangles from left to right and check for mismatches."
                    },
                    {
                        "username": "lilydenris",
                        "content": "First observation is there will be four point has count of 1 and other points have even count.\\n\\nThis is not enough, a counter example is two rectangles overlap exactly and another rectangle on the side.\\n[[0,0,1,1],[0,0,2,1],[1,0,2,1],[0,2,2,3]]\\n\\nOk, to deal with overlapping, we add a check to make sure all small rectangles add up to the same area of the big one.\\n\\nThis is still not enough to solve above use case. The problem is the four point cannot be any point, has to be the four of big one.\\n"
                    },
                    {
                        "username": "MackLykyn",
                        "content": "can anyone recode my code actually my code is correct but it\\'s just time complexity 42 out of 49 is correct `your inline code...your inline code...`class Solution(object):\\n    def isRectangleCover(self, rectangles):\\n        \"\"\"\\n        :type rectangles: List[List[int]]\\n        :rtype: bool\\n        \"\"\"\\n        xm = ym = 10**6\\n        am = bm = 0\\n        for i in rectangles:\\n            if i[0] < xm:\\n                xm = i[0]\\n            if i[1] < ym:\\n                ym = i[1]\\n            if i[2] > am:\\n                am = i[2]\\n            if i[3] > bm:\\n                bm = i[3]\\n        ml = {}\\n        for i in range(xm, am):\\n            for j in range(ym, bm):\\n                ml[str(i)+\" \"+str(j)] = True\\n        lm = {}\\n        for i in rectangles:\\n            for j in range(i[0], i[2]):\\n                for k in range(i[1], i[3]):\\n                    if str(j) + \" \" + str(k) not in lm:\\n                        lm[str(j) + \" \" + str(k)] = True\\n                    else:\\n                        lm[str(j) + \" \" + str(k)] = False\\n        return ml == lm"
                    },
                    {
                        "username": "user9086f",
                        "content": "Can there be a case where there can be identical rectangles ? "
                    },
                    {
                        "username": "Electron1997",
                        "content": "Yes, there is at least one such test case"
                    },
                    {
                        "username": "nikhilreddydev",
                        "content": "How the area haven't overflown with long long?\n\nMaximum area of a largest rectangle should not have been fit in a long?"
                    },
                    {
                        "username": "wodxuming",
                        "content": "\\xB7\\xB7\\xB7\\nclass Solution:\\n    def isRectangleCover(self, rectangles: List[List[int]]) -> bool:\\n        X1, Y1 = float(\\'inf\\'), float(\\'inf\\')\\n        X2, Y2 = -float(\\'inf\\'), -float(\\'inf\\')\\n        \\n        points = set()\\n        actual_area = 0\\n        for x1, y1, x2, y2 in rectangles:\\n            \\n            X1, Y1 = min(X1, x1), min(Y1, y1)\\n            X2, Y2 = max(X2, x2), max(Y2, y2)\\n            \\n            actual_area += (x2 - x1) * (y2 - y1)\\n            \\n            p1, p2 = (x1, y1), (x1, y2)\\n            p3, p4 = (x2, y1), (x2, y2)\\n            for p in [p1, p2, p3, p4]:\\n                if p in points: points.remove(p)\\n                else:           points.add(p)\\n        \\n        expected_area = (X2 - X1) * (Y2 - Y1)\\n        if actual_area != expected_area:\\n            return False\\n        \\n        if len(points) != 4:       return False\\n        \\n        if (X1, Y1) not in points: return False\\n        if (X1, Y2) not in points: return False\\n        if (X2, Y1) not in points: return False\\n        if (X2, Y2) not in points: return False\\n        \\n        return True\\n\\n\\xB7\\xB7\\xB7"
                    },
                    {
                        "username": "jlidbeck",
                        "content": "\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion tab."
                    }
                ]
            },
            {
                "id": 1567502,
                "content": [
                    {
                        "username": "shriyansnaik",
                        "content": "Thought process/Key points\\n1. A rectangle has 4 corners. All corners must appear even number of times(because if the figure is a proper rectangle then all the corners will be contiguous) except for the corners.\\n2. Sum of areas of all small rectangles must equal to the big rectangle.\\n3. The bottom-left and the top right corners of the rectangle can be found by looking at the min and max of all points. Use that to figure out all 4 corners of rectangle. Then check if the corners left(after eliminating the corners that occur even number of times) are the ones that should be the corners (which can be figured out from the bottom-left and top-right corners).\\n"
                    },
                    {
                        "username": "Sanzee",
                        "content": "Sometimes It is important to know the input range and properties of the input variables.\\nFor example:\\n1. How many rectangle can be there in worst case.\\n2. are the co-ordinates can be negative?!\\n3. what is the range of the x,y values for each rectangle.\\n"
                    },
                    {
                        "username": "SudhakarMunjuluri",
                        "content": "Could some one please explain me this question\\n\\nI do not even understand how the rectangles were drawn using the given co-ordinates\\n\\nWhat is confusing me is bottom-left and top-right, if i implement what ever the way I could not draw as shown in the example diagram.\\n\\nThanks a lot"
                    },
                    {
                        "username": "panzy",
                        "content": "It took me a whole day to implement a fast enough algorithm to incrementally merge all the rectangles (the idea was that if in the end there is only one rectangle left then it\\'s perfect), only to find it\\'s based on a wrong idea :(\\n\\n![image](https://assets.leetcode.com/users/images/78ea2ba6-9ef9-4cf2-828b-a1dbd179c655_1609701387.5382698.png)\\n\\n(source: https://www.geogebra.org/m/z3skhnf6)\\n"
                    },
                    {
                        "username": "reeshu54raj",
                        "content": "Can anyone explain me how to start thinking for this question. I can\\'t even start my approach. "
                    },
                    {
                        "username": "Finesse",
                        "content": "Try sorting the given rectangles. Then fill the area with the rectangles from left to right and check for mismatches."
                    },
                    {
                        "username": "lilydenris",
                        "content": "First observation is there will be four point has count of 1 and other points have even count.\\n\\nThis is not enough, a counter example is two rectangles overlap exactly and another rectangle on the side.\\n[[0,0,1,1],[0,0,2,1],[1,0,2,1],[0,2,2,3]]\\n\\nOk, to deal with overlapping, we add a check to make sure all small rectangles add up to the same area of the big one.\\n\\nThis is still not enough to solve above use case. The problem is the four point cannot be any point, has to be the four of big one.\\n"
                    },
                    {
                        "username": "MackLykyn",
                        "content": "can anyone recode my code actually my code is correct but it\\'s just time complexity 42 out of 49 is correct `your inline code...your inline code...`class Solution(object):\\n    def isRectangleCover(self, rectangles):\\n        \"\"\"\\n        :type rectangles: List[List[int]]\\n        :rtype: bool\\n        \"\"\"\\n        xm = ym = 10**6\\n        am = bm = 0\\n        for i in rectangles:\\n            if i[0] < xm:\\n                xm = i[0]\\n            if i[1] < ym:\\n                ym = i[1]\\n            if i[2] > am:\\n                am = i[2]\\n            if i[3] > bm:\\n                bm = i[3]\\n        ml = {}\\n        for i in range(xm, am):\\n            for j in range(ym, bm):\\n                ml[str(i)+\" \"+str(j)] = True\\n        lm = {}\\n        for i in rectangles:\\n            for j in range(i[0], i[2]):\\n                for k in range(i[1], i[3]):\\n                    if str(j) + \" \" + str(k) not in lm:\\n                        lm[str(j) + \" \" + str(k)] = True\\n                    else:\\n                        lm[str(j) + \" \" + str(k)] = False\\n        return ml == lm"
                    },
                    {
                        "username": "user9086f",
                        "content": "Can there be a case where there can be identical rectangles ? "
                    },
                    {
                        "username": "Electron1997",
                        "content": "Yes, there is at least one such test case"
                    },
                    {
                        "username": "nikhilreddydev",
                        "content": "How the area haven't overflown with long long?\n\nMaximum area of a largest rectangle should not have been fit in a long?"
                    },
                    {
                        "username": "wodxuming",
                        "content": "\\xB7\\xB7\\xB7\\nclass Solution:\\n    def isRectangleCover(self, rectangles: List[List[int]]) -> bool:\\n        X1, Y1 = float(\\'inf\\'), float(\\'inf\\')\\n        X2, Y2 = -float(\\'inf\\'), -float(\\'inf\\')\\n        \\n        points = set()\\n        actual_area = 0\\n        for x1, y1, x2, y2 in rectangles:\\n            \\n            X1, Y1 = min(X1, x1), min(Y1, y1)\\n            X2, Y2 = max(X2, x2), max(Y2, y2)\\n            \\n            actual_area += (x2 - x1) * (y2 - y1)\\n            \\n            p1, p2 = (x1, y1), (x1, y2)\\n            p3, p4 = (x2, y1), (x2, y2)\\n            for p in [p1, p2, p3, p4]:\\n                if p in points: points.remove(p)\\n                else:           points.add(p)\\n        \\n        expected_area = (X2 - X1) * (Y2 - Y1)\\n        if actual_area != expected_area:\\n            return False\\n        \\n        if len(points) != 4:       return False\\n        \\n        if (X1, Y1) not in points: return False\\n        if (X1, Y2) not in points: return False\\n        if (X2, Y1) not in points: return False\\n        if (X2, Y2) not in points: return False\\n        \\n        return True\\n\\n\\xB7\\xB7\\xB7"
                    },
                    {
                        "username": "jlidbeck",
                        "content": "\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion tab."
                    }
                ]
            },
            {
                "id": 1574359,
                "content": [
                    {
                        "username": "shriyansnaik",
                        "content": "Thought process/Key points\\n1. A rectangle has 4 corners. All corners must appear even number of times(because if the figure is a proper rectangle then all the corners will be contiguous) except for the corners.\\n2. Sum of areas of all small rectangles must equal to the big rectangle.\\n3. The bottom-left and the top right corners of the rectangle can be found by looking at the min and max of all points. Use that to figure out all 4 corners of rectangle. Then check if the corners left(after eliminating the corners that occur even number of times) are the ones that should be the corners (which can be figured out from the bottom-left and top-right corners).\\n"
                    },
                    {
                        "username": "Sanzee",
                        "content": "Sometimes It is important to know the input range and properties of the input variables.\\nFor example:\\n1. How many rectangle can be there in worst case.\\n2. are the co-ordinates can be negative?!\\n3. what is the range of the x,y values for each rectangle.\\n"
                    },
                    {
                        "username": "SudhakarMunjuluri",
                        "content": "Could some one please explain me this question\\n\\nI do not even understand how the rectangles were drawn using the given co-ordinates\\n\\nWhat is confusing me is bottom-left and top-right, if i implement what ever the way I could not draw as shown in the example diagram.\\n\\nThanks a lot"
                    },
                    {
                        "username": "panzy",
                        "content": "It took me a whole day to implement a fast enough algorithm to incrementally merge all the rectangles (the idea was that if in the end there is only one rectangle left then it\\'s perfect), only to find it\\'s based on a wrong idea :(\\n\\n![image](https://assets.leetcode.com/users/images/78ea2ba6-9ef9-4cf2-828b-a1dbd179c655_1609701387.5382698.png)\\n\\n(source: https://www.geogebra.org/m/z3skhnf6)\\n"
                    },
                    {
                        "username": "reeshu54raj",
                        "content": "Can anyone explain me how to start thinking for this question. I can\\'t even start my approach. "
                    },
                    {
                        "username": "Finesse",
                        "content": "Try sorting the given rectangles. Then fill the area with the rectangles from left to right and check for mismatches."
                    },
                    {
                        "username": "lilydenris",
                        "content": "First observation is there will be four point has count of 1 and other points have even count.\\n\\nThis is not enough, a counter example is two rectangles overlap exactly and another rectangle on the side.\\n[[0,0,1,1],[0,0,2,1],[1,0,2,1],[0,2,2,3]]\\n\\nOk, to deal with overlapping, we add a check to make sure all small rectangles add up to the same area of the big one.\\n\\nThis is still not enough to solve above use case. The problem is the four point cannot be any point, has to be the four of big one.\\n"
                    },
                    {
                        "username": "MackLykyn",
                        "content": "can anyone recode my code actually my code is correct but it\\'s just time complexity 42 out of 49 is correct `your inline code...your inline code...`class Solution(object):\\n    def isRectangleCover(self, rectangles):\\n        \"\"\"\\n        :type rectangles: List[List[int]]\\n        :rtype: bool\\n        \"\"\"\\n        xm = ym = 10**6\\n        am = bm = 0\\n        for i in rectangles:\\n            if i[0] < xm:\\n                xm = i[0]\\n            if i[1] < ym:\\n                ym = i[1]\\n            if i[2] > am:\\n                am = i[2]\\n            if i[3] > bm:\\n                bm = i[3]\\n        ml = {}\\n        for i in range(xm, am):\\n            for j in range(ym, bm):\\n                ml[str(i)+\" \"+str(j)] = True\\n        lm = {}\\n        for i in rectangles:\\n            for j in range(i[0], i[2]):\\n                for k in range(i[1], i[3]):\\n                    if str(j) + \" \" + str(k) not in lm:\\n                        lm[str(j) + \" \" + str(k)] = True\\n                    else:\\n                        lm[str(j) + \" \" + str(k)] = False\\n        return ml == lm"
                    },
                    {
                        "username": "user9086f",
                        "content": "Can there be a case where there can be identical rectangles ? "
                    },
                    {
                        "username": "Electron1997",
                        "content": "Yes, there is at least one such test case"
                    },
                    {
                        "username": "nikhilreddydev",
                        "content": "How the area haven't overflown with long long?\n\nMaximum area of a largest rectangle should not have been fit in a long?"
                    },
                    {
                        "username": "wodxuming",
                        "content": "\\xB7\\xB7\\xB7\\nclass Solution:\\n    def isRectangleCover(self, rectangles: List[List[int]]) -> bool:\\n        X1, Y1 = float(\\'inf\\'), float(\\'inf\\')\\n        X2, Y2 = -float(\\'inf\\'), -float(\\'inf\\')\\n        \\n        points = set()\\n        actual_area = 0\\n        for x1, y1, x2, y2 in rectangles:\\n            \\n            X1, Y1 = min(X1, x1), min(Y1, y1)\\n            X2, Y2 = max(X2, x2), max(Y2, y2)\\n            \\n            actual_area += (x2 - x1) * (y2 - y1)\\n            \\n            p1, p2 = (x1, y1), (x1, y2)\\n            p3, p4 = (x2, y1), (x2, y2)\\n            for p in [p1, p2, p3, p4]:\\n                if p in points: points.remove(p)\\n                else:           points.add(p)\\n        \\n        expected_area = (X2 - X1) * (Y2 - Y1)\\n        if actual_area != expected_area:\\n            return False\\n        \\n        if len(points) != 4:       return False\\n        \\n        if (X1, Y1) not in points: return False\\n        if (X1, Y2) not in points: return False\\n        if (X2, Y1) not in points: return False\\n        if (X2, Y2) not in points: return False\\n        \\n        return True\\n\\n\\xB7\\xB7\\xB7"
                    },
                    {
                        "username": "jlidbeck",
                        "content": "\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion tab."
                    }
                ]
            },
            {
                "id": 1574767,
                "content": [
                    {
                        "username": "shriyansnaik",
                        "content": "Thought process/Key points\\n1. A rectangle has 4 corners. All corners must appear even number of times(because if the figure is a proper rectangle then all the corners will be contiguous) except for the corners.\\n2. Sum of areas of all small rectangles must equal to the big rectangle.\\n3. The bottom-left and the top right corners of the rectangle can be found by looking at the min and max of all points. Use that to figure out all 4 corners of rectangle. Then check if the corners left(after eliminating the corners that occur even number of times) are the ones that should be the corners (which can be figured out from the bottom-left and top-right corners).\\n"
                    },
                    {
                        "username": "Sanzee",
                        "content": "Sometimes It is important to know the input range and properties of the input variables.\\nFor example:\\n1. How many rectangle can be there in worst case.\\n2. are the co-ordinates can be negative?!\\n3. what is the range of the x,y values for each rectangle.\\n"
                    },
                    {
                        "username": "SudhakarMunjuluri",
                        "content": "Could some one please explain me this question\\n\\nI do not even understand how the rectangles were drawn using the given co-ordinates\\n\\nWhat is confusing me is bottom-left and top-right, if i implement what ever the way I could not draw as shown in the example diagram.\\n\\nThanks a lot"
                    },
                    {
                        "username": "panzy",
                        "content": "It took me a whole day to implement a fast enough algorithm to incrementally merge all the rectangles (the idea was that if in the end there is only one rectangle left then it\\'s perfect), only to find it\\'s based on a wrong idea :(\\n\\n![image](https://assets.leetcode.com/users/images/78ea2ba6-9ef9-4cf2-828b-a1dbd179c655_1609701387.5382698.png)\\n\\n(source: https://www.geogebra.org/m/z3skhnf6)\\n"
                    },
                    {
                        "username": "reeshu54raj",
                        "content": "Can anyone explain me how to start thinking for this question. I can\\'t even start my approach. "
                    },
                    {
                        "username": "Finesse",
                        "content": "Try sorting the given rectangles. Then fill the area with the rectangles from left to right and check for mismatches."
                    },
                    {
                        "username": "lilydenris",
                        "content": "First observation is there will be four point has count of 1 and other points have even count.\\n\\nThis is not enough, a counter example is two rectangles overlap exactly and another rectangle on the side.\\n[[0,0,1,1],[0,0,2,1],[1,0,2,1],[0,2,2,3]]\\n\\nOk, to deal with overlapping, we add a check to make sure all small rectangles add up to the same area of the big one.\\n\\nThis is still not enough to solve above use case. The problem is the four point cannot be any point, has to be the four of big one.\\n"
                    },
                    {
                        "username": "MackLykyn",
                        "content": "can anyone recode my code actually my code is correct but it\\'s just time complexity 42 out of 49 is correct `your inline code...your inline code...`class Solution(object):\\n    def isRectangleCover(self, rectangles):\\n        \"\"\"\\n        :type rectangles: List[List[int]]\\n        :rtype: bool\\n        \"\"\"\\n        xm = ym = 10**6\\n        am = bm = 0\\n        for i in rectangles:\\n            if i[0] < xm:\\n                xm = i[0]\\n            if i[1] < ym:\\n                ym = i[1]\\n            if i[2] > am:\\n                am = i[2]\\n            if i[3] > bm:\\n                bm = i[3]\\n        ml = {}\\n        for i in range(xm, am):\\n            for j in range(ym, bm):\\n                ml[str(i)+\" \"+str(j)] = True\\n        lm = {}\\n        for i in rectangles:\\n            for j in range(i[0], i[2]):\\n                for k in range(i[1], i[3]):\\n                    if str(j) + \" \" + str(k) not in lm:\\n                        lm[str(j) + \" \" + str(k)] = True\\n                    else:\\n                        lm[str(j) + \" \" + str(k)] = False\\n        return ml == lm"
                    },
                    {
                        "username": "user9086f",
                        "content": "Can there be a case where there can be identical rectangles ? "
                    },
                    {
                        "username": "Electron1997",
                        "content": "Yes, there is at least one such test case"
                    },
                    {
                        "username": "nikhilreddydev",
                        "content": "How the area haven't overflown with long long?\n\nMaximum area of a largest rectangle should not have been fit in a long?"
                    },
                    {
                        "username": "wodxuming",
                        "content": "\\xB7\\xB7\\xB7\\nclass Solution:\\n    def isRectangleCover(self, rectangles: List[List[int]]) -> bool:\\n        X1, Y1 = float(\\'inf\\'), float(\\'inf\\')\\n        X2, Y2 = -float(\\'inf\\'), -float(\\'inf\\')\\n        \\n        points = set()\\n        actual_area = 0\\n        for x1, y1, x2, y2 in rectangles:\\n            \\n            X1, Y1 = min(X1, x1), min(Y1, y1)\\n            X2, Y2 = max(X2, x2), max(Y2, y2)\\n            \\n            actual_area += (x2 - x1) * (y2 - y1)\\n            \\n            p1, p2 = (x1, y1), (x1, y2)\\n            p3, p4 = (x2, y1), (x2, y2)\\n            for p in [p1, p2, p3, p4]:\\n                if p in points: points.remove(p)\\n                else:           points.add(p)\\n        \\n        expected_area = (X2 - X1) * (Y2 - Y1)\\n        if actual_area != expected_area:\\n            return False\\n        \\n        if len(points) != 4:       return False\\n        \\n        if (X1, Y1) not in points: return False\\n        if (X1, Y2) not in points: return False\\n        if (X2, Y1) not in points: return False\\n        if (X2, Y2) not in points: return False\\n        \\n        return True\\n\\n\\xB7\\xB7\\xB7"
                    },
                    {
                        "username": "jlidbeck",
                        "content": "\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion tab."
                    }
                ]
            },
            {
                "id": 1740044,
                "content": [
                    {
                        "username": "shriyansnaik",
                        "content": "Thought process/Key points\\n1. A rectangle has 4 corners. All corners must appear even number of times(because if the figure is a proper rectangle then all the corners will be contiguous) except for the corners.\\n2. Sum of areas of all small rectangles must equal to the big rectangle.\\n3. The bottom-left and the top right corners of the rectangle can be found by looking at the min and max of all points. Use that to figure out all 4 corners of rectangle. Then check if the corners left(after eliminating the corners that occur even number of times) are the ones that should be the corners (which can be figured out from the bottom-left and top-right corners).\\n"
                    },
                    {
                        "username": "Sanzee",
                        "content": "Sometimes It is important to know the input range and properties of the input variables.\\nFor example:\\n1. How many rectangle can be there in worst case.\\n2. are the co-ordinates can be negative?!\\n3. what is the range of the x,y values for each rectangle.\\n"
                    },
                    {
                        "username": "SudhakarMunjuluri",
                        "content": "Could some one please explain me this question\\n\\nI do not even understand how the rectangles were drawn using the given co-ordinates\\n\\nWhat is confusing me is bottom-left and top-right, if i implement what ever the way I could not draw as shown in the example diagram.\\n\\nThanks a lot"
                    },
                    {
                        "username": "panzy",
                        "content": "It took me a whole day to implement a fast enough algorithm to incrementally merge all the rectangles (the idea was that if in the end there is only one rectangle left then it\\'s perfect), only to find it\\'s based on a wrong idea :(\\n\\n![image](https://assets.leetcode.com/users/images/78ea2ba6-9ef9-4cf2-828b-a1dbd179c655_1609701387.5382698.png)\\n\\n(source: https://www.geogebra.org/m/z3skhnf6)\\n"
                    },
                    {
                        "username": "reeshu54raj",
                        "content": "Can anyone explain me how to start thinking for this question. I can\\'t even start my approach. "
                    },
                    {
                        "username": "Finesse",
                        "content": "Try sorting the given rectangles. Then fill the area with the rectangles from left to right and check for mismatches."
                    },
                    {
                        "username": "lilydenris",
                        "content": "First observation is there will be four point has count of 1 and other points have even count.\\n\\nThis is not enough, a counter example is two rectangles overlap exactly and another rectangle on the side.\\n[[0,0,1,1],[0,0,2,1],[1,0,2,1],[0,2,2,3]]\\n\\nOk, to deal with overlapping, we add a check to make sure all small rectangles add up to the same area of the big one.\\n\\nThis is still not enough to solve above use case. The problem is the four point cannot be any point, has to be the four of big one.\\n"
                    },
                    {
                        "username": "MackLykyn",
                        "content": "can anyone recode my code actually my code is correct but it\\'s just time complexity 42 out of 49 is correct `your inline code...your inline code...`class Solution(object):\\n    def isRectangleCover(self, rectangles):\\n        \"\"\"\\n        :type rectangles: List[List[int]]\\n        :rtype: bool\\n        \"\"\"\\n        xm = ym = 10**6\\n        am = bm = 0\\n        for i in rectangles:\\n            if i[0] < xm:\\n                xm = i[0]\\n            if i[1] < ym:\\n                ym = i[1]\\n            if i[2] > am:\\n                am = i[2]\\n            if i[3] > bm:\\n                bm = i[3]\\n        ml = {}\\n        for i in range(xm, am):\\n            for j in range(ym, bm):\\n                ml[str(i)+\" \"+str(j)] = True\\n        lm = {}\\n        for i in rectangles:\\n            for j in range(i[0], i[2]):\\n                for k in range(i[1], i[3]):\\n                    if str(j) + \" \" + str(k) not in lm:\\n                        lm[str(j) + \" \" + str(k)] = True\\n                    else:\\n                        lm[str(j) + \" \" + str(k)] = False\\n        return ml == lm"
                    },
                    {
                        "username": "user9086f",
                        "content": "Can there be a case where there can be identical rectangles ? "
                    },
                    {
                        "username": "Electron1997",
                        "content": "Yes, there is at least one such test case"
                    },
                    {
                        "username": "nikhilreddydev",
                        "content": "How the area haven't overflown with long long?\n\nMaximum area of a largest rectangle should not have been fit in a long?"
                    },
                    {
                        "username": "wodxuming",
                        "content": "\\xB7\\xB7\\xB7\\nclass Solution:\\n    def isRectangleCover(self, rectangles: List[List[int]]) -> bool:\\n        X1, Y1 = float(\\'inf\\'), float(\\'inf\\')\\n        X2, Y2 = -float(\\'inf\\'), -float(\\'inf\\')\\n        \\n        points = set()\\n        actual_area = 0\\n        for x1, y1, x2, y2 in rectangles:\\n            \\n            X1, Y1 = min(X1, x1), min(Y1, y1)\\n            X2, Y2 = max(X2, x2), max(Y2, y2)\\n            \\n            actual_area += (x2 - x1) * (y2 - y1)\\n            \\n            p1, p2 = (x1, y1), (x1, y2)\\n            p3, p4 = (x2, y1), (x2, y2)\\n            for p in [p1, p2, p3, p4]:\\n                if p in points: points.remove(p)\\n                else:           points.add(p)\\n        \\n        expected_area = (X2 - X1) * (Y2 - Y1)\\n        if actual_area != expected_area:\\n            return False\\n        \\n        if len(points) != 4:       return False\\n        \\n        if (X1, Y1) not in points: return False\\n        if (X1, Y2) not in points: return False\\n        if (X2, Y1) not in points: return False\\n        if (X2, Y2) not in points: return False\\n        \\n        return True\\n\\n\\xB7\\xB7\\xB7"
                    },
                    {
                        "username": "jlidbeck",
                        "content": "\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion tab."
                    }
                ]
            },
            {
                "id": 1575608,
                "content": [
                    {
                        "username": "shriyansnaik",
                        "content": "Thought process/Key points\\n1. A rectangle has 4 corners. All corners must appear even number of times(because if the figure is a proper rectangle then all the corners will be contiguous) except for the corners.\\n2. Sum of areas of all small rectangles must equal to the big rectangle.\\n3. The bottom-left and the top right corners of the rectangle can be found by looking at the min and max of all points. Use that to figure out all 4 corners of rectangle. Then check if the corners left(after eliminating the corners that occur even number of times) are the ones that should be the corners (which can be figured out from the bottom-left and top-right corners).\\n"
                    },
                    {
                        "username": "Sanzee",
                        "content": "Sometimes It is important to know the input range and properties of the input variables.\\nFor example:\\n1. How many rectangle can be there in worst case.\\n2. are the co-ordinates can be negative?!\\n3. what is the range of the x,y values for each rectangle.\\n"
                    },
                    {
                        "username": "SudhakarMunjuluri",
                        "content": "Could some one please explain me this question\\n\\nI do not even understand how the rectangles were drawn using the given co-ordinates\\n\\nWhat is confusing me is bottom-left and top-right, if i implement what ever the way I could not draw as shown in the example diagram.\\n\\nThanks a lot"
                    },
                    {
                        "username": "panzy",
                        "content": "It took me a whole day to implement a fast enough algorithm to incrementally merge all the rectangles (the idea was that if in the end there is only one rectangle left then it\\'s perfect), only to find it\\'s based on a wrong idea :(\\n\\n![image](https://assets.leetcode.com/users/images/78ea2ba6-9ef9-4cf2-828b-a1dbd179c655_1609701387.5382698.png)\\n\\n(source: https://www.geogebra.org/m/z3skhnf6)\\n"
                    },
                    {
                        "username": "reeshu54raj",
                        "content": "Can anyone explain me how to start thinking for this question. I can\\'t even start my approach. "
                    },
                    {
                        "username": "Finesse",
                        "content": "Try sorting the given rectangles. Then fill the area with the rectangles from left to right and check for mismatches."
                    },
                    {
                        "username": "lilydenris",
                        "content": "First observation is there will be four point has count of 1 and other points have even count.\\n\\nThis is not enough, a counter example is two rectangles overlap exactly and another rectangle on the side.\\n[[0,0,1,1],[0,0,2,1],[1,0,2,1],[0,2,2,3]]\\n\\nOk, to deal with overlapping, we add a check to make sure all small rectangles add up to the same area of the big one.\\n\\nThis is still not enough to solve above use case. The problem is the four point cannot be any point, has to be the four of big one.\\n"
                    },
                    {
                        "username": "MackLykyn",
                        "content": "can anyone recode my code actually my code is correct but it\\'s just time complexity 42 out of 49 is correct `your inline code...your inline code...`class Solution(object):\\n    def isRectangleCover(self, rectangles):\\n        \"\"\"\\n        :type rectangles: List[List[int]]\\n        :rtype: bool\\n        \"\"\"\\n        xm = ym = 10**6\\n        am = bm = 0\\n        for i in rectangles:\\n            if i[0] < xm:\\n                xm = i[0]\\n            if i[1] < ym:\\n                ym = i[1]\\n            if i[2] > am:\\n                am = i[2]\\n            if i[3] > bm:\\n                bm = i[3]\\n        ml = {}\\n        for i in range(xm, am):\\n            for j in range(ym, bm):\\n                ml[str(i)+\" \"+str(j)] = True\\n        lm = {}\\n        for i in rectangles:\\n            for j in range(i[0], i[2]):\\n                for k in range(i[1], i[3]):\\n                    if str(j) + \" \" + str(k) not in lm:\\n                        lm[str(j) + \" \" + str(k)] = True\\n                    else:\\n                        lm[str(j) + \" \" + str(k)] = False\\n        return ml == lm"
                    },
                    {
                        "username": "user9086f",
                        "content": "Can there be a case where there can be identical rectangles ? "
                    },
                    {
                        "username": "Electron1997",
                        "content": "Yes, there is at least one such test case"
                    },
                    {
                        "username": "nikhilreddydev",
                        "content": "How the area haven't overflown with long long?\n\nMaximum area of a largest rectangle should not have been fit in a long?"
                    },
                    {
                        "username": "wodxuming",
                        "content": "\\xB7\\xB7\\xB7\\nclass Solution:\\n    def isRectangleCover(self, rectangles: List[List[int]]) -> bool:\\n        X1, Y1 = float(\\'inf\\'), float(\\'inf\\')\\n        X2, Y2 = -float(\\'inf\\'), -float(\\'inf\\')\\n        \\n        points = set()\\n        actual_area = 0\\n        for x1, y1, x2, y2 in rectangles:\\n            \\n            X1, Y1 = min(X1, x1), min(Y1, y1)\\n            X2, Y2 = max(X2, x2), max(Y2, y2)\\n            \\n            actual_area += (x2 - x1) * (y2 - y1)\\n            \\n            p1, p2 = (x1, y1), (x1, y2)\\n            p3, p4 = (x2, y1), (x2, y2)\\n            for p in [p1, p2, p3, p4]:\\n                if p in points: points.remove(p)\\n                else:           points.add(p)\\n        \\n        expected_area = (X2 - X1) * (Y2 - Y1)\\n        if actual_area != expected_area:\\n            return False\\n        \\n        if len(points) != 4:       return False\\n        \\n        if (X1, Y1) not in points: return False\\n        if (X1, Y2) not in points: return False\\n        if (X2, Y1) not in points: return False\\n        if (X2, Y2) not in points: return False\\n        \\n        return True\\n\\n\\xB7\\xB7\\xB7"
                    },
                    {
                        "username": "jlidbeck",
                        "content": "\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion tab."
                    }
                ]
            },
            {
                "id": 1931685,
                "content": [
                    {
                        "username": "shriyansnaik",
                        "content": "Thought process/Key points\\n1. A rectangle has 4 corners. All corners must appear even number of times(because if the figure is a proper rectangle then all the corners will be contiguous) except for the corners.\\n2. Sum of areas of all small rectangles must equal to the big rectangle.\\n3. The bottom-left and the top right corners of the rectangle can be found by looking at the min and max of all points. Use that to figure out all 4 corners of rectangle. Then check if the corners left(after eliminating the corners that occur even number of times) are the ones that should be the corners (which can be figured out from the bottom-left and top-right corners).\\n"
                    },
                    {
                        "username": "Sanzee",
                        "content": "Sometimes It is important to know the input range and properties of the input variables.\\nFor example:\\n1. How many rectangle can be there in worst case.\\n2. are the co-ordinates can be negative?!\\n3. what is the range of the x,y values for each rectangle.\\n"
                    },
                    {
                        "username": "SudhakarMunjuluri",
                        "content": "Could some one please explain me this question\\n\\nI do not even understand how the rectangles were drawn using the given co-ordinates\\n\\nWhat is confusing me is bottom-left and top-right, if i implement what ever the way I could not draw as shown in the example diagram.\\n\\nThanks a lot"
                    },
                    {
                        "username": "panzy",
                        "content": "It took me a whole day to implement a fast enough algorithm to incrementally merge all the rectangles (the idea was that if in the end there is only one rectangle left then it\\'s perfect), only to find it\\'s based on a wrong idea :(\\n\\n![image](https://assets.leetcode.com/users/images/78ea2ba6-9ef9-4cf2-828b-a1dbd179c655_1609701387.5382698.png)\\n\\n(source: https://www.geogebra.org/m/z3skhnf6)\\n"
                    },
                    {
                        "username": "reeshu54raj",
                        "content": "Can anyone explain me how to start thinking for this question. I can\\'t even start my approach. "
                    },
                    {
                        "username": "Finesse",
                        "content": "Try sorting the given rectangles. Then fill the area with the rectangles from left to right and check for mismatches."
                    },
                    {
                        "username": "lilydenris",
                        "content": "First observation is there will be four point has count of 1 and other points have even count.\\n\\nThis is not enough, a counter example is two rectangles overlap exactly and another rectangle on the side.\\n[[0,0,1,1],[0,0,2,1],[1,0,2,1],[0,2,2,3]]\\n\\nOk, to deal with overlapping, we add a check to make sure all small rectangles add up to the same area of the big one.\\n\\nThis is still not enough to solve above use case. The problem is the four point cannot be any point, has to be the four of big one.\\n"
                    },
                    {
                        "username": "MackLykyn",
                        "content": "can anyone recode my code actually my code is correct but it\\'s just time complexity 42 out of 49 is correct `your inline code...your inline code...`class Solution(object):\\n    def isRectangleCover(self, rectangles):\\n        \"\"\"\\n        :type rectangles: List[List[int]]\\n        :rtype: bool\\n        \"\"\"\\n        xm = ym = 10**6\\n        am = bm = 0\\n        for i in rectangles:\\n            if i[0] < xm:\\n                xm = i[0]\\n            if i[1] < ym:\\n                ym = i[1]\\n            if i[2] > am:\\n                am = i[2]\\n            if i[3] > bm:\\n                bm = i[3]\\n        ml = {}\\n        for i in range(xm, am):\\n            for j in range(ym, bm):\\n                ml[str(i)+\" \"+str(j)] = True\\n        lm = {}\\n        for i in rectangles:\\n            for j in range(i[0], i[2]):\\n                for k in range(i[1], i[3]):\\n                    if str(j) + \" \" + str(k) not in lm:\\n                        lm[str(j) + \" \" + str(k)] = True\\n                    else:\\n                        lm[str(j) + \" \" + str(k)] = False\\n        return ml == lm"
                    },
                    {
                        "username": "user9086f",
                        "content": "Can there be a case where there can be identical rectangles ? "
                    },
                    {
                        "username": "Electron1997",
                        "content": "Yes, there is at least one such test case"
                    },
                    {
                        "username": "nikhilreddydev",
                        "content": "How the area haven't overflown with long long?\n\nMaximum area of a largest rectangle should not have been fit in a long?"
                    },
                    {
                        "username": "wodxuming",
                        "content": "\\xB7\\xB7\\xB7\\nclass Solution:\\n    def isRectangleCover(self, rectangles: List[List[int]]) -> bool:\\n        X1, Y1 = float(\\'inf\\'), float(\\'inf\\')\\n        X2, Y2 = -float(\\'inf\\'), -float(\\'inf\\')\\n        \\n        points = set()\\n        actual_area = 0\\n        for x1, y1, x2, y2 in rectangles:\\n            \\n            X1, Y1 = min(X1, x1), min(Y1, y1)\\n            X2, Y2 = max(X2, x2), max(Y2, y2)\\n            \\n            actual_area += (x2 - x1) * (y2 - y1)\\n            \\n            p1, p2 = (x1, y1), (x1, y2)\\n            p3, p4 = (x2, y1), (x2, y2)\\n            for p in [p1, p2, p3, p4]:\\n                if p in points: points.remove(p)\\n                else:           points.add(p)\\n        \\n        expected_area = (X2 - X1) * (Y2 - Y1)\\n        if actual_area != expected_area:\\n            return False\\n        \\n        if len(points) != 4:       return False\\n        \\n        if (X1, Y1) not in points: return False\\n        if (X1, Y2) not in points: return False\\n        if (X2, Y1) not in points: return False\\n        if (X2, Y2) not in points: return False\\n        \\n        return True\\n\\n\\xB7\\xB7\\xB7"
                    },
                    {
                        "username": "jlidbeck",
                        "content": "\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion tab."
                    }
                ]
            },
            {
                "id": 1751630,
                "content": [
                    {
                        "username": "shriyansnaik",
                        "content": "Thought process/Key points\\n1. A rectangle has 4 corners. All corners must appear even number of times(because if the figure is a proper rectangle then all the corners will be contiguous) except for the corners.\\n2. Sum of areas of all small rectangles must equal to the big rectangle.\\n3. The bottom-left and the top right corners of the rectangle can be found by looking at the min and max of all points. Use that to figure out all 4 corners of rectangle. Then check if the corners left(after eliminating the corners that occur even number of times) are the ones that should be the corners (which can be figured out from the bottom-left and top-right corners).\\n"
                    },
                    {
                        "username": "Sanzee",
                        "content": "Sometimes It is important to know the input range and properties of the input variables.\\nFor example:\\n1. How many rectangle can be there in worst case.\\n2. are the co-ordinates can be negative?!\\n3. what is the range of the x,y values for each rectangle.\\n"
                    },
                    {
                        "username": "SudhakarMunjuluri",
                        "content": "Could some one please explain me this question\\n\\nI do not even understand how the rectangles were drawn using the given co-ordinates\\n\\nWhat is confusing me is bottom-left and top-right, if i implement what ever the way I could not draw as shown in the example diagram.\\n\\nThanks a lot"
                    },
                    {
                        "username": "panzy",
                        "content": "It took me a whole day to implement a fast enough algorithm to incrementally merge all the rectangles (the idea was that if in the end there is only one rectangle left then it\\'s perfect), only to find it\\'s based on a wrong idea :(\\n\\n![image](https://assets.leetcode.com/users/images/78ea2ba6-9ef9-4cf2-828b-a1dbd179c655_1609701387.5382698.png)\\n\\n(source: https://www.geogebra.org/m/z3skhnf6)\\n"
                    },
                    {
                        "username": "reeshu54raj",
                        "content": "Can anyone explain me how to start thinking for this question. I can\\'t even start my approach. "
                    },
                    {
                        "username": "Finesse",
                        "content": "Try sorting the given rectangles. Then fill the area with the rectangles from left to right and check for mismatches."
                    },
                    {
                        "username": "lilydenris",
                        "content": "First observation is there will be four point has count of 1 and other points have even count.\\n\\nThis is not enough, a counter example is two rectangles overlap exactly and another rectangle on the side.\\n[[0,0,1,1],[0,0,2,1],[1,0,2,1],[0,2,2,3]]\\n\\nOk, to deal with overlapping, we add a check to make sure all small rectangles add up to the same area of the big one.\\n\\nThis is still not enough to solve above use case. The problem is the four point cannot be any point, has to be the four of big one.\\n"
                    },
                    {
                        "username": "MackLykyn",
                        "content": "can anyone recode my code actually my code is correct but it\\'s just time complexity 42 out of 49 is correct `your inline code...your inline code...`class Solution(object):\\n    def isRectangleCover(self, rectangles):\\n        \"\"\"\\n        :type rectangles: List[List[int]]\\n        :rtype: bool\\n        \"\"\"\\n        xm = ym = 10**6\\n        am = bm = 0\\n        for i in rectangles:\\n            if i[0] < xm:\\n                xm = i[0]\\n            if i[1] < ym:\\n                ym = i[1]\\n            if i[2] > am:\\n                am = i[2]\\n            if i[3] > bm:\\n                bm = i[3]\\n        ml = {}\\n        for i in range(xm, am):\\n            for j in range(ym, bm):\\n                ml[str(i)+\" \"+str(j)] = True\\n        lm = {}\\n        for i in rectangles:\\n            for j in range(i[0], i[2]):\\n                for k in range(i[1], i[3]):\\n                    if str(j) + \" \" + str(k) not in lm:\\n                        lm[str(j) + \" \" + str(k)] = True\\n                    else:\\n                        lm[str(j) + \" \" + str(k)] = False\\n        return ml == lm"
                    },
                    {
                        "username": "user9086f",
                        "content": "Can there be a case where there can be identical rectangles ? "
                    },
                    {
                        "username": "Electron1997",
                        "content": "Yes, there is at least one such test case"
                    },
                    {
                        "username": "nikhilreddydev",
                        "content": "How the area haven't overflown with long long?\n\nMaximum area of a largest rectangle should not have been fit in a long?"
                    },
                    {
                        "username": "wodxuming",
                        "content": "\\xB7\\xB7\\xB7\\nclass Solution:\\n    def isRectangleCover(self, rectangles: List[List[int]]) -> bool:\\n        X1, Y1 = float(\\'inf\\'), float(\\'inf\\')\\n        X2, Y2 = -float(\\'inf\\'), -float(\\'inf\\')\\n        \\n        points = set()\\n        actual_area = 0\\n        for x1, y1, x2, y2 in rectangles:\\n            \\n            X1, Y1 = min(X1, x1), min(Y1, y1)\\n            X2, Y2 = max(X2, x2), max(Y2, y2)\\n            \\n            actual_area += (x2 - x1) * (y2 - y1)\\n            \\n            p1, p2 = (x1, y1), (x1, y2)\\n            p3, p4 = (x2, y1), (x2, y2)\\n            for p in [p1, p2, p3, p4]:\\n                if p in points: points.remove(p)\\n                else:           points.add(p)\\n        \\n        expected_area = (X2 - X1) * (Y2 - Y1)\\n        if actual_area != expected_area:\\n            return False\\n        \\n        if len(points) != 4:       return False\\n        \\n        if (X1, Y1) not in points: return False\\n        if (X1, Y2) not in points: return False\\n        if (X2, Y1) not in points: return False\\n        if (X2, Y2) not in points: return False\\n        \\n        return True\\n\\n\\xB7\\xB7\\xB7"
                    },
                    {
                        "username": "jlidbeck",
                        "content": "\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion tab."
                    }
                ]
            },
            {
                "id": 1713853,
                "content": [
                    {
                        "username": "shriyansnaik",
                        "content": "Thought process/Key points\\n1. A rectangle has 4 corners. All corners must appear even number of times(because if the figure is a proper rectangle then all the corners will be contiguous) except for the corners.\\n2. Sum of areas of all small rectangles must equal to the big rectangle.\\n3. The bottom-left and the top right corners of the rectangle can be found by looking at the min and max of all points. Use that to figure out all 4 corners of rectangle. Then check if the corners left(after eliminating the corners that occur even number of times) are the ones that should be the corners (which can be figured out from the bottom-left and top-right corners).\\n"
                    },
                    {
                        "username": "Sanzee",
                        "content": "Sometimes It is important to know the input range and properties of the input variables.\\nFor example:\\n1. How many rectangle can be there in worst case.\\n2. are the co-ordinates can be negative?!\\n3. what is the range of the x,y values for each rectangle.\\n"
                    },
                    {
                        "username": "SudhakarMunjuluri",
                        "content": "Could some one please explain me this question\\n\\nI do not even understand how the rectangles were drawn using the given co-ordinates\\n\\nWhat is confusing me is bottom-left and top-right, if i implement what ever the way I could not draw as shown in the example diagram.\\n\\nThanks a lot"
                    },
                    {
                        "username": "panzy",
                        "content": "It took me a whole day to implement a fast enough algorithm to incrementally merge all the rectangles (the idea was that if in the end there is only one rectangle left then it\\'s perfect), only to find it\\'s based on a wrong idea :(\\n\\n![image](https://assets.leetcode.com/users/images/78ea2ba6-9ef9-4cf2-828b-a1dbd179c655_1609701387.5382698.png)\\n\\n(source: https://www.geogebra.org/m/z3skhnf6)\\n"
                    },
                    {
                        "username": "reeshu54raj",
                        "content": "Can anyone explain me how to start thinking for this question. I can\\'t even start my approach. "
                    },
                    {
                        "username": "Finesse",
                        "content": "Try sorting the given rectangles. Then fill the area with the rectangles from left to right and check for mismatches."
                    },
                    {
                        "username": "lilydenris",
                        "content": "First observation is there will be four point has count of 1 and other points have even count.\\n\\nThis is not enough, a counter example is two rectangles overlap exactly and another rectangle on the side.\\n[[0,0,1,1],[0,0,2,1],[1,0,2,1],[0,2,2,3]]\\n\\nOk, to deal with overlapping, we add a check to make sure all small rectangles add up to the same area of the big one.\\n\\nThis is still not enough to solve above use case. The problem is the four point cannot be any point, has to be the four of big one.\\n"
                    },
                    {
                        "username": "MackLykyn",
                        "content": "can anyone recode my code actually my code is correct but it\\'s just time complexity 42 out of 49 is correct `your inline code...your inline code...`class Solution(object):\\n    def isRectangleCover(self, rectangles):\\n        \"\"\"\\n        :type rectangles: List[List[int]]\\n        :rtype: bool\\n        \"\"\"\\n        xm = ym = 10**6\\n        am = bm = 0\\n        for i in rectangles:\\n            if i[0] < xm:\\n                xm = i[0]\\n            if i[1] < ym:\\n                ym = i[1]\\n            if i[2] > am:\\n                am = i[2]\\n            if i[3] > bm:\\n                bm = i[3]\\n        ml = {}\\n        for i in range(xm, am):\\n            for j in range(ym, bm):\\n                ml[str(i)+\" \"+str(j)] = True\\n        lm = {}\\n        for i in rectangles:\\n            for j in range(i[0], i[2]):\\n                for k in range(i[1], i[3]):\\n                    if str(j) + \" \" + str(k) not in lm:\\n                        lm[str(j) + \" \" + str(k)] = True\\n                    else:\\n                        lm[str(j) + \" \" + str(k)] = False\\n        return ml == lm"
                    },
                    {
                        "username": "user9086f",
                        "content": "Can there be a case where there can be identical rectangles ? "
                    },
                    {
                        "username": "Electron1997",
                        "content": "Yes, there is at least one such test case"
                    },
                    {
                        "username": "nikhilreddydev",
                        "content": "How the area haven't overflown with long long?\n\nMaximum area of a largest rectangle should not have been fit in a long?"
                    },
                    {
                        "username": "wodxuming",
                        "content": "\\xB7\\xB7\\xB7\\nclass Solution:\\n    def isRectangleCover(self, rectangles: List[List[int]]) -> bool:\\n        X1, Y1 = float(\\'inf\\'), float(\\'inf\\')\\n        X2, Y2 = -float(\\'inf\\'), -float(\\'inf\\')\\n        \\n        points = set()\\n        actual_area = 0\\n        for x1, y1, x2, y2 in rectangles:\\n            \\n            X1, Y1 = min(X1, x1), min(Y1, y1)\\n            X2, Y2 = max(X2, x2), max(Y2, y2)\\n            \\n            actual_area += (x2 - x1) * (y2 - y1)\\n            \\n            p1, p2 = (x1, y1), (x1, y2)\\n            p3, p4 = (x2, y1), (x2, y2)\\n            for p in [p1, p2, p3, p4]:\\n                if p in points: points.remove(p)\\n                else:           points.add(p)\\n        \\n        expected_area = (X2 - X1) * (Y2 - Y1)\\n        if actual_area != expected_area:\\n            return False\\n        \\n        if len(points) != 4:       return False\\n        \\n        if (X1, Y1) not in points: return False\\n        if (X1, Y2) not in points: return False\\n        if (X2, Y1) not in points: return False\\n        if (X2, Y2) not in points: return False\\n        \\n        return True\\n\\n\\xB7\\xB7\\xB7"
                    },
                    {
                        "username": "jlidbeck",
                        "content": "\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion tab."
                    }
                ]
            },
            {
                "id": 1637152,
                "content": [
                    {
                        "username": "shriyansnaik",
                        "content": "Thought process/Key points\\n1. A rectangle has 4 corners. All corners must appear even number of times(because if the figure is a proper rectangle then all the corners will be contiguous) except for the corners.\\n2. Sum of areas of all small rectangles must equal to the big rectangle.\\n3. The bottom-left and the top right corners of the rectangle can be found by looking at the min and max of all points. Use that to figure out all 4 corners of rectangle. Then check if the corners left(after eliminating the corners that occur even number of times) are the ones that should be the corners (which can be figured out from the bottom-left and top-right corners).\\n"
                    },
                    {
                        "username": "Sanzee",
                        "content": "Sometimes It is important to know the input range and properties of the input variables.\\nFor example:\\n1. How many rectangle can be there in worst case.\\n2. are the co-ordinates can be negative?!\\n3. what is the range of the x,y values for each rectangle.\\n"
                    },
                    {
                        "username": "SudhakarMunjuluri",
                        "content": "Could some one please explain me this question\\n\\nI do not even understand how the rectangles were drawn using the given co-ordinates\\n\\nWhat is confusing me is bottom-left and top-right, if i implement what ever the way I could not draw as shown in the example diagram.\\n\\nThanks a lot"
                    },
                    {
                        "username": "panzy",
                        "content": "It took me a whole day to implement a fast enough algorithm to incrementally merge all the rectangles (the idea was that if in the end there is only one rectangle left then it\\'s perfect), only to find it\\'s based on a wrong idea :(\\n\\n![image](https://assets.leetcode.com/users/images/78ea2ba6-9ef9-4cf2-828b-a1dbd179c655_1609701387.5382698.png)\\n\\n(source: https://www.geogebra.org/m/z3skhnf6)\\n"
                    },
                    {
                        "username": "reeshu54raj",
                        "content": "Can anyone explain me how to start thinking for this question. I can\\'t even start my approach. "
                    },
                    {
                        "username": "Finesse",
                        "content": "Try sorting the given rectangles. Then fill the area with the rectangles from left to right and check for mismatches."
                    },
                    {
                        "username": "lilydenris",
                        "content": "First observation is there will be four point has count of 1 and other points have even count.\\n\\nThis is not enough, a counter example is two rectangles overlap exactly and another rectangle on the side.\\n[[0,0,1,1],[0,0,2,1],[1,0,2,1],[0,2,2,3]]\\n\\nOk, to deal with overlapping, we add a check to make sure all small rectangles add up to the same area of the big one.\\n\\nThis is still not enough to solve above use case. The problem is the four point cannot be any point, has to be the four of big one.\\n"
                    },
                    {
                        "username": "MackLykyn",
                        "content": "can anyone recode my code actually my code is correct but it\\'s just time complexity 42 out of 49 is correct `your inline code...your inline code...`class Solution(object):\\n    def isRectangleCover(self, rectangles):\\n        \"\"\"\\n        :type rectangles: List[List[int]]\\n        :rtype: bool\\n        \"\"\"\\n        xm = ym = 10**6\\n        am = bm = 0\\n        for i in rectangles:\\n            if i[0] < xm:\\n                xm = i[0]\\n            if i[1] < ym:\\n                ym = i[1]\\n            if i[2] > am:\\n                am = i[2]\\n            if i[3] > bm:\\n                bm = i[3]\\n        ml = {}\\n        for i in range(xm, am):\\n            for j in range(ym, bm):\\n                ml[str(i)+\" \"+str(j)] = True\\n        lm = {}\\n        for i in rectangles:\\n            for j in range(i[0], i[2]):\\n                for k in range(i[1], i[3]):\\n                    if str(j) + \" \" + str(k) not in lm:\\n                        lm[str(j) + \" \" + str(k)] = True\\n                    else:\\n                        lm[str(j) + \" \" + str(k)] = False\\n        return ml == lm"
                    },
                    {
                        "username": "user9086f",
                        "content": "Can there be a case where there can be identical rectangles ? "
                    },
                    {
                        "username": "Electron1997",
                        "content": "Yes, there is at least one such test case"
                    },
                    {
                        "username": "nikhilreddydev",
                        "content": "How the area haven't overflown with long long?\n\nMaximum area of a largest rectangle should not have been fit in a long?"
                    },
                    {
                        "username": "wodxuming",
                        "content": "\\xB7\\xB7\\xB7\\nclass Solution:\\n    def isRectangleCover(self, rectangles: List[List[int]]) -> bool:\\n        X1, Y1 = float(\\'inf\\'), float(\\'inf\\')\\n        X2, Y2 = -float(\\'inf\\'), -float(\\'inf\\')\\n        \\n        points = set()\\n        actual_area = 0\\n        for x1, y1, x2, y2 in rectangles:\\n            \\n            X1, Y1 = min(X1, x1), min(Y1, y1)\\n            X2, Y2 = max(X2, x2), max(Y2, y2)\\n            \\n            actual_area += (x2 - x1) * (y2 - y1)\\n            \\n            p1, p2 = (x1, y1), (x1, y2)\\n            p3, p4 = (x2, y1), (x2, y2)\\n            for p in [p1, p2, p3, p4]:\\n                if p in points: points.remove(p)\\n                else:           points.add(p)\\n        \\n        expected_area = (X2 - X1) * (Y2 - Y1)\\n        if actual_area != expected_area:\\n            return False\\n        \\n        if len(points) != 4:       return False\\n        \\n        if (X1, Y1) not in points: return False\\n        if (X1, Y2) not in points: return False\\n        if (X2, Y1) not in points: return False\\n        if (X2, Y2) not in points: return False\\n        \\n        return True\\n\\n\\xB7\\xB7\\xB7"
                    },
                    {
                        "username": "jlidbeck",
                        "content": "\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion tab."
                    }
                ]
            },
            {
                "id": 1744185,
                "content": [
                    {
                        "username": "shriyansnaik",
                        "content": "Thought process/Key points\\n1. A rectangle has 4 corners. All corners must appear even number of times(because if the figure is a proper rectangle then all the corners will be contiguous) except for the corners.\\n2. Sum of areas of all small rectangles must equal to the big rectangle.\\n3. The bottom-left and the top right corners of the rectangle can be found by looking at the min and max of all points. Use that to figure out all 4 corners of rectangle. Then check if the corners left(after eliminating the corners that occur even number of times) are the ones that should be the corners (which can be figured out from the bottom-left and top-right corners).\\n"
                    },
                    {
                        "username": "Sanzee",
                        "content": "Sometimes It is important to know the input range and properties of the input variables.\\nFor example:\\n1. How many rectangle can be there in worst case.\\n2. are the co-ordinates can be negative?!\\n3. what is the range of the x,y values for each rectangle.\\n"
                    },
                    {
                        "username": "SudhakarMunjuluri",
                        "content": "Could some one please explain me this question\\n\\nI do not even understand how the rectangles were drawn using the given co-ordinates\\n\\nWhat is confusing me is bottom-left and top-right, if i implement what ever the way I could not draw as shown in the example diagram.\\n\\nThanks a lot"
                    },
                    {
                        "username": "panzy",
                        "content": "It took me a whole day to implement a fast enough algorithm to incrementally merge all the rectangles (the idea was that if in the end there is only one rectangle left then it\\'s perfect), only to find it\\'s based on a wrong idea :(\\n\\n![image](https://assets.leetcode.com/users/images/78ea2ba6-9ef9-4cf2-828b-a1dbd179c655_1609701387.5382698.png)\\n\\n(source: https://www.geogebra.org/m/z3skhnf6)\\n"
                    },
                    {
                        "username": "reeshu54raj",
                        "content": "Can anyone explain me how to start thinking for this question. I can\\'t even start my approach. "
                    },
                    {
                        "username": "Finesse",
                        "content": "Try sorting the given rectangles. Then fill the area with the rectangles from left to right and check for mismatches."
                    },
                    {
                        "username": "lilydenris",
                        "content": "First observation is there will be four point has count of 1 and other points have even count.\\n\\nThis is not enough, a counter example is two rectangles overlap exactly and another rectangle on the side.\\n[[0,0,1,1],[0,0,2,1],[1,0,2,1],[0,2,2,3]]\\n\\nOk, to deal with overlapping, we add a check to make sure all small rectangles add up to the same area of the big one.\\n\\nThis is still not enough to solve above use case. The problem is the four point cannot be any point, has to be the four of big one.\\n"
                    },
                    {
                        "username": "MackLykyn",
                        "content": "can anyone recode my code actually my code is correct but it\\'s just time complexity 42 out of 49 is correct `your inline code...your inline code...`class Solution(object):\\n    def isRectangleCover(self, rectangles):\\n        \"\"\"\\n        :type rectangles: List[List[int]]\\n        :rtype: bool\\n        \"\"\"\\n        xm = ym = 10**6\\n        am = bm = 0\\n        for i in rectangles:\\n            if i[0] < xm:\\n                xm = i[0]\\n            if i[1] < ym:\\n                ym = i[1]\\n            if i[2] > am:\\n                am = i[2]\\n            if i[3] > bm:\\n                bm = i[3]\\n        ml = {}\\n        for i in range(xm, am):\\n            for j in range(ym, bm):\\n                ml[str(i)+\" \"+str(j)] = True\\n        lm = {}\\n        for i in rectangles:\\n            for j in range(i[0], i[2]):\\n                for k in range(i[1], i[3]):\\n                    if str(j) + \" \" + str(k) not in lm:\\n                        lm[str(j) + \" \" + str(k)] = True\\n                    else:\\n                        lm[str(j) + \" \" + str(k)] = False\\n        return ml == lm"
                    },
                    {
                        "username": "user9086f",
                        "content": "Can there be a case where there can be identical rectangles ? "
                    },
                    {
                        "username": "Electron1997",
                        "content": "Yes, there is at least one such test case"
                    },
                    {
                        "username": "nikhilreddydev",
                        "content": "How the area haven't overflown with long long?\n\nMaximum area of a largest rectangle should not have been fit in a long?"
                    },
                    {
                        "username": "wodxuming",
                        "content": "\\xB7\\xB7\\xB7\\nclass Solution:\\n    def isRectangleCover(self, rectangles: List[List[int]]) -> bool:\\n        X1, Y1 = float(\\'inf\\'), float(\\'inf\\')\\n        X2, Y2 = -float(\\'inf\\'), -float(\\'inf\\')\\n        \\n        points = set()\\n        actual_area = 0\\n        for x1, y1, x2, y2 in rectangles:\\n            \\n            X1, Y1 = min(X1, x1), min(Y1, y1)\\n            X2, Y2 = max(X2, x2), max(Y2, y2)\\n            \\n            actual_area += (x2 - x1) * (y2 - y1)\\n            \\n            p1, p2 = (x1, y1), (x1, y2)\\n            p3, p4 = (x2, y1), (x2, y2)\\n            for p in [p1, p2, p3, p4]:\\n                if p in points: points.remove(p)\\n                else:           points.add(p)\\n        \\n        expected_area = (X2 - X1) * (Y2 - Y1)\\n        if actual_area != expected_area:\\n            return False\\n        \\n        if len(points) != 4:       return False\\n        \\n        if (X1, Y1) not in points: return False\\n        if (X1, Y2) not in points: return False\\n        if (X2, Y1) not in points: return False\\n        if (X2, Y2) not in points: return False\\n        \\n        return True\\n\\n\\xB7\\xB7\\xB7"
                    },
                    {
                        "username": "jlidbeck",
                        "content": "\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion tab."
                    }
                ]
            },
            {
                "id": 1567502,
                "content": [
                    {
                        "username": "shriyansnaik",
                        "content": "Thought process/Key points\\n1. A rectangle has 4 corners. All corners must appear even number of times(because if the figure is a proper rectangle then all the corners will be contiguous) except for the corners.\\n2. Sum of areas of all small rectangles must equal to the big rectangle.\\n3. The bottom-left and the top right corners of the rectangle can be found by looking at the min and max of all points. Use that to figure out all 4 corners of rectangle. Then check if the corners left(after eliminating the corners that occur even number of times) are the ones that should be the corners (which can be figured out from the bottom-left and top-right corners).\\n"
                    },
                    {
                        "username": "Sanzee",
                        "content": "Sometimes It is important to know the input range and properties of the input variables.\\nFor example:\\n1. How many rectangle can be there in worst case.\\n2. are the co-ordinates can be negative?!\\n3. what is the range of the x,y values for each rectangle.\\n"
                    },
                    {
                        "username": "SudhakarMunjuluri",
                        "content": "Could some one please explain me this question\\n\\nI do not even understand how the rectangles were drawn using the given co-ordinates\\n\\nWhat is confusing me is bottom-left and top-right, if i implement what ever the way I could not draw as shown in the example diagram.\\n\\nThanks a lot"
                    },
                    {
                        "username": "panzy",
                        "content": "It took me a whole day to implement a fast enough algorithm to incrementally merge all the rectangles (the idea was that if in the end there is only one rectangle left then it\\'s perfect), only to find it\\'s based on a wrong idea :(\\n\\n![image](https://assets.leetcode.com/users/images/78ea2ba6-9ef9-4cf2-828b-a1dbd179c655_1609701387.5382698.png)\\n\\n(source: https://www.geogebra.org/m/z3skhnf6)\\n"
                    },
                    {
                        "username": "reeshu54raj",
                        "content": "Can anyone explain me how to start thinking for this question. I can\\'t even start my approach. "
                    },
                    {
                        "username": "Finesse",
                        "content": "Try sorting the given rectangles. Then fill the area with the rectangles from left to right and check for mismatches."
                    },
                    {
                        "username": "lilydenris",
                        "content": "First observation is there will be four point has count of 1 and other points have even count.\\n\\nThis is not enough, a counter example is two rectangles overlap exactly and another rectangle on the side.\\n[[0,0,1,1],[0,0,2,1],[1,0,2,1],[0,2,2,3]]\\n\\nOk, to deal with overlapping, we add a check to make sure all small rectangles add up to the same area of the big one.\\n\\nThis is still not enough to solve above use case. The problem is the four point cannot be any point, has to be the four of big one.\\n"
                    },
                    {
                        "username": "MackLykyn",
                        "content": "can anyone recode my code actually my code is correct but it\\'s just time complexity 42 out of 49 is correct `your inline code...your inline code...`class Solution(object):\\n    def isRectangleCover(self, rectangles):\\n        \"\"\"\\n        :type rectangles: List[List[int]]\\n        :rtype: bool\\n        \"\"\"\\n        xm = ym = 10**6\\n        am = bm = 0\\n        for i in rectangles:\\n            if i[0] < xm:\\n                xm = i[0]\\n            if i[1] < ym:\\n                ym = i[1]\\n            if i[2] > am:\\n                am = i[2]\\n            if i[3] > bm:\\n                bm = i[3]\\n        ml = {}\\n        for i in range(xm, am):\\n            for j in range(ym, bm):\\n                ml[str(i)+\" \"+str(j)] = True\\n        lm = {}\\n        for i in rectangles:\\n            for j in range(i[0], i[2]):\\n                for k in range(i[1], i[3]):\\n                    if str(j) + \" \" + str(k) not in lm:\\n                        lm[str(j) + \" \" + str(k)] = True\\n                    else:\\n                        lm[str(j) + \" \" + str(k)] = False\\n        return ml == lm"
                    },
                    {
                        "username": "user9086f",
                        "content": "Can there be a case where there can be identical rectangles ? "
                    },
                    {
                        "username": "Electron1997",
                        "content": "Yes, there is at least one such test case"
                    },
                    {
                        "username": "nikhilreddydev",
                        "content": "How the area haven't overflown with long long?\n\nMaximum area of a largest rectangle should not have been fit in a long?"
                    },
                    {
                        "username": "wodxuming",
                        "content": "\\xB7\\xB7\\xB7\\nclass Solution:\\n    def isRectangleCover(self, rectangles: List[List[int]]) -> bool:\\n        X1, Y1 = float(\\'inf\\'), float(\\'inf\\')\\n        X2, Y2 = -float(\\'inf\\'), -float(\\'inf\\')\\n        \\n        points = set()\\n        actual_area = 0\\n        for x1, y1, x2, y2 in rectangles:\\n            \\n            X1, Y1 = min(X1, x1), min(Y1, y1)\\n            X2, Y2 = max(X2, x2), max(Y2, y2)\\n            \\n            actual_area += (x2 - x1) * (y2 - y1)\\n            \\n            p1, p2 = (x1, y1), (x1, y2)\\n            p3, p4 = (x2, y1), (x2, y2)\\n            for p in [p1, p2, p3, p4]:\\n                if p in points: points.remove(p)\\n                else:           points.add(p)\\n        \\n        expected_area = (X2 - X1) * (Y2 - Y1)\\n        if actual_area != expected_area:\\n            return False\\n        \\n        if len(points) != 4:       return False\\n        \\n        if (X1, Y1) not in points: return False\\n        if (X1, Y2) not in points: return False\\n        if (X2, Y1) not in points: return False\\n        if (X2, Y2) not in points: return False\\n        \\n        return True\\n\\n\\xB7\\xB7\\xB7"
                    },
                    {
                        "username": "jlidbeck",
                        "content": "\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion tab."
                    }
                ]
            },
            {
                "id": 1574359,
                "content": [
                    {
                        "username": "shriyansnaik",
                        "content": "Thought process/Key points\\n1. A rectangle has 4 corners. All corners must appear even number of times(because if the figure is a proper rectangle then all the corners will be contiguous) except for the corners.\\n2. Sum of areas of all small rectangles must equal to the big rectangle.\\n3. The bottom-left and the top right corners of the rectangle can be found by looking at the min and max of all points. Use that to figure out all 4 corners of rectangle. Then check if the corners left(after eliminating the corners that occur even number of times) are the ones that should be the corners (which can be figured out from the bottom-left and top-right corners).\\n"
                    },
                    {
                        "username": "Sanzee",
                        "content": "Sometimes It is important to know the input range and properties of the input variables.\\nFor example:\\n1. How many rectangle can be there in worst case.\\n2. are the co-ordinates can be negative?!\\n3. what is the range of the x,y values for each rectangle.\\n"
                    },
                    {
                        "username": "SudhakarMunjuluri",
                        "content": "Could some one please explain me this question\\n\\nI do not even understand how the rectangles were drawn using the given co-ordinates\\n\\nWhat is confusing me is bottom-left and top-right, if i implement what ever the way I could not draw as shown in the example diagram.\\n\\nThanks a lot"
                    },
                    {
                        "username": "panzy",
                        "content": "It took me a whole day to implement a fast enough algorithm to incrementally merge all the rectangles (the idea was that if in the end there is only one rectangle left then it\\'s perfect), only to find it\\'s based on a wrong idea :(\\n\\n![image](https://assets.leetcode.com/users/images/78ea2ba6-9ef9-4cf2-828b-a1dbd179c655_1609701387.5382698.png)\\n\\n(source: https://www.geogebra.org/m/z3skhnf6)\\n"
                    },
                    {
                        "username": "reeshu54raj",
                        "content": "Can anyone explain me how to start thinking for this question. I can\\'t even start my approach. "
                    },
                    {
                        "username": "Finesse",
                        "content": "Try sorting the given rectangles. Then fill the area with the rectangles from left to right and check for mismatches."
                    },
                    {
                        "username": "lilydenris",
                        "content": "First observation is there will be four point has count of 1 and other points have even count.\\n\\nThis is not enough, a counter example is two rectangles overlap exactly and another rectangle on the side.\\n[[0,0,1,1],[0,0,2,1],[1,0,2,1],[0,2,2,3]]\\n\\nOk, to deal with overlapping, we add a check to make sure all small rectangles add up to the same area of the big one.\\n\\nThis is still not enough to solve above use case. The problem is the four point cannot be any point, has to be the four of big one.\\n"
                    },
                    {
                        "username": "MackLykyn",
                        "content": "can anyone recode my code actually my code is correct but it\\'s just time complexity 42 out of 49 is correct `your inline code...your inline code...`class Solution(object):\\n    def isRectangleCover(self, rectangles):\\n        \"\"\"\\n        :type rectangles: List[List[int]]\\n        :rtype: bool\\n        \"\"\"\\n        xm = ym = 10**6\\n        am = bm = 0\\n        for i in rectangles:\\n            if i[0] < xm:\\n                xm = i[0]\\n            if i[1] < ym:\\n                ym = i[1]\\n            if i[2] > am:\\n                am = i[2]\\n            if i[3] > bm:\\n                bm = i[3]\\n        ml = {}\\n        for i in range(xm, am):\\n            for j in range(ym, bm):\\n                ml[str(i)+\" \"+str(j)] = True\\n        lm = {}\\n        for i in rectangles:\\n            for j in range(i[0], i[2]):\\n                for k in range(i[1], i[3]):\\n                    if str(j) + \" \" + str(k) not in lm:\\n                        lm[str(j) + \" \" + str(k)] = True\\n                    else:\\n                        lm[str(j) + \" \" + str(k)] = False\\n        return ml == lm"
                    },
                    {
                        "username": "user9086f",
                        "content": "Can there be a case where there can be identical rectangles ? "
                    },
                    {
                        "username": "Electron1997",
                        "content": "Yes, there is at least one such test case"
                    },
                    {
                        "username": "nikhilreddydev",
                        "content": "How the area haven't overflown with long long?\n\nMaximum area of a largest rectangle should not have been fit in a long?"
                    },
                    {
                        "username": "wodxuming",
                        "content": "\\xB7\\xB7\\xB7\\nclass Solution:\\n    def isRectangleCover(self, rectangles: List[List[int]]) -> bool:\\n        X1, Y1 = float(\\'inf\\'), float(\\'inf\\')\\n        X2, Y2 = -float(\\'inf\\'), -float(\\'inf\\')\\n        \\n        points = set()\\n        actual_area = 0\\n        for x1, y1, x2, y2 in rectangles:\\n            \\n            X1, Y1 = min(X1, x1), min(Y1, y1)\\n            X2, Y2 = max(X2, x2), max(Y2, y2)\\n            \\n            actual_area += (x2 - x1) * (y2 - y1)\\n            \\n            p1, p2 = (x1, y1), (x1, y2)\\n            p3, p4 = (x2, y1), (x2, y2)\\n            for p in [p1, p2, p3, p4]:\\n                if p in points: points.remove(p)\\n                else:           points.add(p)\\n        \\n        expected_area = (X2 - X1) * (Y2 - Y1)\\n        if actual_area != expected_area:\\n            return False\\n        \\n        if len(points) != 4:       return False\\n        \\n        if (X1, Y1) not in points: return False\\n        if (X1, Y2) not in points: return False\\n        if (X2, Y1) not in points: return False\\n        if (X2, Y2) not in points: return False\\n        \\n        return True\\n\\n\\xB7\\xB7\\xB7"
                    },
                    {
                        "username": "jlidbeck",
                        "content": "\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion tab."
                    }
                ]
            },
            {
                "id": 1574767,
                "content": [
                    {
                        "username": "shriyansnaik",
                        "content": "Thought process/Key points\\n1. A rectangle has 4 corners. All corners must appear even number of times(because if the figure is a proper rectangle then all the corners will be contiguous) except for the corners.\\n2. Sum of areas of all small rectangles must equal to the big rectangle.\\n3. The bottom-left and the top right corners of the rectangle can be found by looking at the min and max of all points. Use that to figure out all 4 corners of rectangle. Then check if the corners left(after eliminating the corners that occur even number of times) are the ones that should be the corners (which can be figured out from the bottom-left and top-right corners).\\n"
                    },
                    {
                        "username": "Sanzee",
                        "content": "Sometimes It is important to know the input range and properties of the input variables.\\nFor example:\\n1. How many rectangle can be there in worst case.\\n2. are the co-ordinates can be negative?!\\n3. what is the range of the x,y values for each rectangle.\\n"
                    },
                    {
                        "username": "SudhakarMunjuluri",
                        "content": "Could some one please explain me this question\\n\\nI do not even understand how the rectangles were drawn using the given co-ordinates\\n\\nWhat is confusing me is bottom-left and top-right, if i implement what ever the way I could not draw as shown in the example diagram.\\n\\nThanks a lot"
                    },
                    {
                        "username": "panzy",
                        "content": "It took me a whole day to implement a fast enough algorithm to incrementally merge all the rectangles (the idea was that if in the end there is only one rectangle left then it\\'s perfect), only to find it\\'s based on a wrong idea :(\\n\\n![image](https://assets.leetcode.com/users/images/78ea2ba6-9ef9-4cf2-828b-a1dbd179c655_1609701387.5382698.png)\\n\\n(source: https://www.geogebra.org/m/z3skhnf6)\\n"
                    },
                    {
                        "username": "reeshu54raj",
                        "content": "Can anyone explain me how to start thinking for this question. I can\\'t even start my approach. "
                    },
                    {
                        "username": "Finesse",
                        "content": "Try sorting the given rectangles. Then fill the area with the rectangles from left to right and check for mismatches."
                    },
                    {
                        "username": "lilydenris",
                        "content": "First observation is there will be four point has count of 1 and other points have even count.\\n\\nThis is not enough, a counter example is two rectangles overlap exactly and another rectangle on the side.\\n[[0,0,1,1],[0,0,2,1],[1,0,2,1],[0,2,2,3]]\\n\\nOk, to deal with overlapping, we add a check to make sure all small rectangles add up to the same area of the big one.\\n\\nThis is still not enough to solve above use case. The problem is the four point cannot be any point, has to be the four of big one.\\n"
                    },
                    {
                        "username": "MackLykyn",
                        "content": "can anyone recode my code actually my code is correct but it\\'s just time complexity 42 out of 49 is correct `your inline code...your inline code...`class Solution(object):\\n    def isRectangleCover(self, rectangles):\\n        \"\"\"\\n        :type rectangles: List[List[int]]\\n        :rtype: bool\\n        \"\"\"\\n        xm = ym = 10**6\\n        am = bm = 0\\n        for i in rectangles:\\n            if i[0] < xm:\\n                xm = i[0]\\n            if i[1] < ym:\\n                ym = i[1]\\n            if i[2] > am:\\n                am = i[2]\\n            if i[3] > bm:\\n                bm = i[3]\\n        ml = {}\\n        for i in range(xm, am):\\n            for j in range(ym, bm):\\n                ml[str(i)+\" \"+str(j)] = True\\n        lm = {}\\n        for i in rectangles:\\n            for j in range(i[0], i[2]):\\n                for k in range(i[1], i[3]):\\n                    if str(j) + \" \" + str(k) not in lm:\\n                        lm[str(j) + \" \" + str(k)] = True\\n                    else:\\n                        lm[str(j) + \" \" + str(k)] = False\\n        return ml == lm"
                    },
                    {
                        "username": "user9086f",
                        "content": "Can there be a case where there can be identical rectangles ? "
                    },
                    {
                        "username": "Electron1997",
                        "content": "Yes, there is at least one such test case"
                    },
                    {
                        "username": "nikhilreddydev",
                        "content": "How the area haven't overflown with long long?\n\nMaximum area of a largest rectangle should not have been fit in a long?"
                    },
                    {
                        "username": "wodxuming",
                        "content": "\\xB7\\xB7\\xB7\\nclass Solution:\\n    def isRectangleCover(self, rectangles: List[List[int]]) -> bool:\\n        X1, Y1 = float(\\'inf\\'), float(\\'inf\\')\\n        X2, Y2 = -float(\\'inf\\'), -float(\\'inf\\')\\n        \\n        points = set()\\n        actual_area = 0\\n        for x1, y1, x2, y2 in rectangles:\\n            \\n            X1, Y1 = min(X1, x1), min(Y1, y1)\\n            X2, Y2 = max(X2, x2), max(Y2, y2)\\n            \\n            actual_area += (x2 - x1) * (y2 - y1)\\n            \\n            p1, p2 = (x1, y1), (x1, y2)\\n            p3, p4 = (x2, y1), (x2, y2)\\n            for p in [p1, p2, p3, p4]:\\n                if p in points: points.remove(p)\\n                else:           points.add(p)\\n        \\n        expected_area = (X2 - X1) * (Y2 - Y1)\\n        if actual_area != expected_area:\\n            return False\\n        \\n        if len(points) != 4:       return False\\n        \\n        if (X1, Y1) not in points: return False\\n        if (X1, Y2) not in points: return False\\n        if (X2, Y1) not in points: return False\\n        if (X2, Y2) not in points: return False\\n        \\n        return True\\n\\n\\xB7\\xB7\\xB7"
                    },
                    {
                        "username": "jlidbeck",
                        "content": "\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion tab."
                    }
                ]
            },
            {
                "id": 1740044,
                "content": [
                    {
                        "username": "shriyansnaik",
                        "content": "Thought process/Key points\\n1. A rectangle has 4 corners. All corners must appear even number of times(because if the figure is a proper rectangle then all the corners will be contiguous) except for the corners.\\n2. Sum of areas of all small rectangles must equal to the big rectangle.\\n3. The bottom-left and the top right corners of the rectangle can be found by looking at the min and max of all points. Use that to figure out all 4 corners of rectangle. Then check if the corners left(after eliminating the corners that occur even number of times) are the ones that should be the corners (which can be figured out from the bottom-left and top-right corners).\\n"
                    },
                    {
                        "username": "Sanzee",
                        "content": "Sometimes It is important to know the input range and properties of the input variables.\\nFor example:\\n1. How many rectangle can be there in worst case.\\n2. are the co-ordinates can be negative?!\\n3. what is the range of the x,y values for each rectangle.\\n"
                    },
                    {
                        "username": "SudhakarMunjuluri",
                        "content": "Could some one please explain me this question\\n\\nI do not even understand how the rectangles were drawn using the given co-ordinates\\n\\nWhat is confusing me is bottom-left and top-right, if i implement what ever the way I could not draw as shown in the example diagram.\\n\\nThanks a lot"
                    },
                    {
                        "username": "panzy",
                        "content": "It took me a whole day to implement a fast enough algorithm to incrementally merge all the rectangles (the idea was that if in the end there is only one rectangle left then it\\'s perfect), only to find it\\'s based on a wrong idea :(\\n\\n![image](https://assets.leetcode.com/users/images/78ea2ba6-9ef9-4cf2-828b-a1dbd179c655_1609701387.5382698.png)\\n\\n(source: https://www.geogebra.org/m/z3skhnf6)\\n"
                    },
                    {
                        "username": "reeshu54raj",
                        "content": "Can anyone explain me how to start thinking for this question. I can\\'t even start my approach. "
                    },
                    {
                        "username": "Finesse",
                        "content": "Try sorting the given rectangles. Then fill the area with the rectangles from left to right and check for mismatches."
                    },
                    {
                        "username": "lilydenris",
                        "content": "First observation is there will be four point has count of 1 and other points have even count.\\n\\nThis is not enough, a counter example is two rectangles overlap exactly and another rectangle on the side.\\n[[0,0,1,1],[0,0,2,1],[1,0,2,1],[0,2,2,3]]\\n\\nOk, to deal with overlapping, we add a check to make sure all small rectangles add up to the same area of the big one.\\n\\nThis is still not enough to solve above use case. The problem is the four point cannot be any point, has to be the four of big one.\\n"
                    },
                    {
                        "username": "MackLykyn",
                        "content": "can anyone recode my code actually my code is correct but it\\'s just time complexity 42 out of 49 is correct `your inline code...your inline code...`class Solution(object):\\n    def isRectangleCover(self, rectangles):\\n        \"\"\"\\n        :type rectangles: List[List[int]]\\n        :rtype: bool\\n        \"\"\"\\n        xm = ym = 10**6\\n        am = bm = 0\\n        for i in rectangles:\\n            if i[0] < xm:\\n                xm = i[0]\\n            if i[1] < ym:\\n                ym = i[1]\\n            if i[2] > am:\\n                am = i[2]\\n            if i[3] > bm:\\n                bm = i[3]\\n        ml = {}\\n        for i in range(xm, am):\\n            for j in range(ym, bm):\\n                ml[str(i)+\" \"+str(j)] = True\\n        lm = {}\\n        for i in rectangles:\\n            for j in range(i[0], i[2]):\\n                for k in range(i[1], i[3]):\\n                    if str(j) + \" \" + str(k) not in lm:\\n                        lm[str(j) + \" \" + str(k)] = True\\n                    else:\\n                        lm[str(j) + \" \" + str(k)] = False\\n        return ml == lm"
                    },
                    {
                        "username": "user9086f",
                        "content": "Can there be a case where there can be identical rectangles ? "
                    },
                    {
                        "username": "Electron1997",
                        "content": "Yes, there is at least one such test case"
                    },
                    {
                        "username": "nikhilreddydev",
                        "content": "How the area haven't overflown with long long?\n\nMaximum area of a largest rectangle should not have been fit in a long?"
                    },
                    {
                        "username": "wodxuming",
                        "content": "\\xB7\\xB7\\xB7\\nclass Solution:\\n    def isRectangleCover(self, rectangles: List[List[int]]) -> bool:\\n        X1, Y1 = float(\\'inf\\'), float(\\'inf\\')\\n        X2, Y2 = -float(\\'inf\\'), -float(\\'inf\\')\\n        \\n        points = set()\\n        actual_area = 0\\n        for x1, y1, x2, y2 in rectangles:\\n            \\n            X1, Y1 = min(X1, x1), min(Y1, y1)\\n            X2, Y2 = max(X2, x2), max(Y2, y2)\\n            \\n            actual_area += (x2 - x1) * (y2 - y1)\\n            \\n            p1, p2 = (x1, y1), (x1, y2)\\n            p3, p4 = (x2, y1), (x2, y2)\\n            for p in [p1, p2, p3, p4]:\\n                if p in points: points.remove(p)\\n                else:           points.add(p)\\n        \\n        expected_area = (X2 - X1) * (Y2 - Y1)\\n        if actual_area != expected_area:\\n            return False\\n        \\n        if len(points) != 4:       return False\\n        \\n        if (X1, Y1) not in points: return False\\n        if (X1, Y2) not in points: return False\\n        if (X2, Y1) not in points: return False\\n        if (X2, Y2) not in points: return False\\n        \\n        return True\\n\\n\\xB7\\xB7\\xB7"
                    },
                    {
                        "username": "jlidbeck",
                        "content": "\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion tab."
                    }
                ]
            },
            {
                "id": 1575608,
                "content": [
                    {
                        "username": "shriyansnaik",
                        "content": "Thought process/Key points\\n1. A rectangle has 4 corners. All corners must appear even number of times(because if the figure is a proper rectangle then all the corners will be contiguous) except for the corners.\\n2. Sum of areas of all small rectangles must equal to the big rectangle.\\n3. The bottom-left and the top right corners of the rectangle can be found by looking at the min and max of all points. Use that to figure out all 4 corners of rectangle. Then check if the corners left(after eliminating the corners that occur even number of times) are the ones that should be the corners (which can be figured out from the bottom-left and top-right corners).\\n"
                    },
                    {
                        "username": "Sanzee",
                        "content": "Sometimes It is important to know the input range and properties of the input variables.\\nFor example:\\n1. How many rectangle can be there in worst case.\\n2. are the co-ordinates can be negative?!\\n3. what is the range of the x,y values for each rectangle.\\n"
                    },
                    {
                        "username": "SudhakarMunjuluri",
                        "content": "Could some one please explain me this question\\n\\nI do not even understand how the rectangles were drawn using the given co-ordinates\\n\\nWhat is confusing me is bottom-left and top-right, if i implement what ever the way I could not draw as shown in the example diagram.\\n\\nThanks a lot"
                    },
                    {
                        "username": "panzy",
                        "content": "It took me a whole day to implement a fast enough algorithm to incrementally merge all the rectangles (the idea was that if in the end there is only one rectangle left then it\\'s perfect), only to find it\\'s based on a wrong idea :(\\n\\n![image](https://assets.leetcode.com/users/images/78ea2ba6-9ef9-4cf2-828b-a1dbd179c655_1609701387.5382698.png)\\n\\n(source: https://www.geogebra.org/m/z3skhnf6)\\n"
                    },
                    {
                        "username": "reeshu54raj",
                        "content": "Can anyone explain me how to start thinking for this question. I can\\'t even start my approach. "
                    },
                    {
                        "username": "Finesse",
                        "content": "Try sorting the given rectangles. Then fill the area with the rectangles from left to right and check for mismatches."
                    },
                    {
                        "username": "lilydenris",
                        "content": "First observation is there will be four point has count of 1 and other points have even count.\\n\\nThis is not enough, a counter example is two rectangles overlap exactly and another rectangle on the side.\\n[[0,0,1,1],[0,0,2,1],[1,0,2,1],[0,2,2,3]]\\n\\nOk, to deal with overlapping, we add a check to make sure all small rectangles add up to the same area of the big one.\\n\\nThis is still not enough to solve above use case. The problem is the four point cannot be any point, has to be the four of big one.\\n"
                    },
                    {
                        "username": "MackLykyn",
                        "content": "can anyone recode my code actually my code is correct but it\\'s just time complexity 42 out of 49 is correct `your inline code...your inline code...`class Solution(object):\\n    def isRectangleCover(self, rectangles):\\n        \"\"\"\\n        :type rectangles: List[List[int]]\\n        :rtype: bool\\n        \"\"\"\\n        xm = ym = 10**6\\n        am = bm = 0\\n        for i in rectangles:\\n            if i[0] < xm:\\n                xm = i[0]\\n            if i[1] < ym:\\n                ym = i[1]\\n            if i[2] > am:\\n                am = i[2]\\n            if i[3] > bm:\\n                bm = i[3]\\n        ml = {}\\n        for i in range(xm, am):\\n            for j in range(ym, bm):\\n                ml[str(i)+\" \"+str(j)] = True\\n        lm = {}\\n        for i in rectangles:\\n            for j in range(i[0], i[2]):\\n                for k in range(i[1], i[3]):\\n                    if str(j) + \" \" + str(k) not in lm:\\n                        lm[str(j) + \" \" + str(k)] = True\\n                    else:\\n                        lm[str(j) + \" \" + str(k)] = False\\n        return ml == lm"
                    },
                    {
                        "username": "user9086f",
                        "content": "Can there be a case where there can be identical rectangles ? "
                    },
                    {
                        "username": "Electron1997",
                        "content": "Yes, there is at least one such test case"
                    },
                    {
                        "username": "nikhilreddydev",
                        "content": "How the area haven't overflown with long long?\n\nMaximum area of a largest rectangle should not have been fit in a long?"
                    },
                    {
                        "username": "wodxuming",
                        "content": "\\xB7\\xB7\\xB7\\nclass Solution:\\n    def isRectangleCover(self, rectangles: List[List[int]]) -> bool:\\n        X1, Y1 = float(\\'inf\\'), float(\\'inf\\')\\n        X2, Y2 = -float(\\'inf\\'), -float(\\'inf\\')\\n        \\n        points = set()\\n        actual_area = 0\\n        for x1, y1, x2, y2 in rectangles:\\n            \\n            X1, Y1 = min(X1, x1), min(Y1, y1)\\n            X2, Y2 = max(X2, x2), max(Y2, y2)\\n            \\n            actual_area += (x2 - x1) * (y2 - y1)\\n            \\n            p1, p2 = (x1, y1), (x1, y2)\\n            p3, p4 = (x2, y1), (x2, y2)\\n            for p in [p1, p2, p3, p4]:\\n                if p in points: points.remove(p)\\n                else:           points.add(p)\\n        \\n        expected_area = (X2 - X1) * (Y2 - Y1)\\n        if actual_area != expected_area:\\n            return False\\n        \\n        if len(points) != 4:       return False\\n        \\n        if (X1, Y1) not in points: return False\\n        if (X1, Y2) not in points: return False\\n        if (X2, Y1) not in points: return False\\n        if (X2, Y2) not in points: return False\\n        \\n        return True\\n\\n\\xB7\\xB7\\xB7"
                    },
                    {
                        "username": "jlidbeck",
                        "content": "\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion tab."
                    }
                ]
            },
            {
                "id": 1931685,
                "content": [
                    {
                        "username": "shriyansnaik",
                        "content": "Thought process/Key points\\n1. A rectangle has 4 corners. All corners must appear even number of times(because if the figure is a proper rectangle then all the corners will be contiguous) except for the corners.\\n2. Sum of areas of all small rectangles must equal to the big rectangle.\\n3. The bottom-left and the top right corners of the rectangle can be found by looking at the min and max of all points. Use that to figure out all 4 corners of rectangle. Then check if the corners left(after eliminating the corners that occur even number of times) are the ones that should be the corners (which can be figured out from the bottom-left and top-right corners).\\n"
                    },
                    {
                        "username": "Sanzee",
                        "content": "Sometimes It is important to know the input range and properties of the input variables.\\nFor example:\\n1. How many rectangle can be there in worst case.\\n2. are the co-ordinates can be negative?!\\n3. what is the range of the x,y values for each rectangle.\\n"
                    },
                    {
                        "username": "SudhakarMunjuluri",
                        "content": "Could some one please explain me this question\\n\\nI do not even understand how the rectangles were drawn using the given co-ordinates\\n\\nWhat is confusing me is bottom-left and top-right, if i implement what ever the way I could not draw as shown in the example diagram.\\n\\nThanks a lot"
                    },
                    {
                        "username": "panzy",
                        "content": "It took me a whole day to implement a fast enough algorithm to incrementally merge all the rectangles (the idea was that if in the end there is only one rectangle left then it\\'s perfect), only to find it\\'s based on a wrong idea :(\\n\\n![image](https://assets.leetcode.com/users/images/78ea2ba6-9ef9-4cf2-828b-a1dbd179c655_1609701387.5382698.png)\\n\\n(source: https://www.geogebra.org/m/z3skhnf6)\\n"
                    },
                    {
                        "username": "reeshu54raj",
                        "content": "Can anyone explain me how to start thinking for this question. I can\\'t even start my approach. "
                    },
                    {
                        "username": "Finesse",
                        "content": "Try sorting the given rectangles. Then fill the area with the rectangles from left to right and check for mismatches."
                    },
                    {
                        "username": "lilydenris",
                        "content": "First observation is there will be four point has count of 1 and other points have even count.\\n\\nThis is not enough, a counter example is two rectangles overlap exactly and another rectangle on the side.\\n[[0,0,1,1],[0,0,2,1],[1,0,2,1],[0,2,2,3]]\\n\\nOk, to deal with overlapping, we add a check to make sure all small rectangles add up to the same area of the big one.\\n\\nThis is still not enough to solve above use case. The problem is the four point cannot be any point, has to be the four of big one.\\n"
                    },
                    {
                        "username": "MackLykyn",
                        "content": "can anyone recode my code actually my code is correct but it\\'s just time complexity 42 out of 49 is correct `your inline code...your inline code...`class Solution(object):\\n    def isRectangleCover(self, rectangles):\\n        \"\"\"\\n        :type rectangles: List[List[int]]\\n        :rtype: bool\\n        \"\"\"\\n        xm = ym = 10**6\\n        am = bm = 0\\n        for i in rectangles:\\n            if i[0] < xm:\\n                xm = i[0]\\n            if i[1] < ym:\\n                ym = i[1]\\n            if i[2] > am:\\n                am = i[2]\\n            if i[3] > bm:\\n                bm = i[3]\\n        ml = {}\\n        for i in range(xm, am):\\n            for j in range(ym, bm):\\n                ml[str(i)+\" \"+str(j)] = True\\n        lm = {}\\n        for i in rectangles:\\n            for j in range(i[0], i[2]):\\n                for k in range(i[1], i[3]):\\n                    if str(j) + \" \" + str(k) not in lm:\\n                        lm[str(j) + \" \" + str(k)] = True\\n                    else:\\n                        lm[str(j) + \" \" + str(k)] = False\\n        return ml == lm"
                    },
                    {
                        "username": "user9086f",
                        "content": "Can there be a case where there can be identical rectangles ? "
                    },
                    {
                        "username": "Electron1997",
                        "content": "Yes, there is at least one such test case"
                    },
                    {
                        "username": "nikhilreddydev",
                        "content": "How the area haven't overflown with long long?\n\nMaximum area of a largest rectangle should not have been fit in a long?"
                    },
                    {
                        "username": "wodxuming",
                        "content": "\\xB7\\xB7\\xB7\\nclass Solution:\\n    def isRectangleCover(self, rectangles: List[List[int]]) -> bool:\\n        X1, Y1 = float(\\'inf\\'), float(\\'inf\\')\\n        X2, Y2 = -float(\\'inf\\'), -float(\\'inf\\')\\n        \\n        points = set()\\n        actual_area = 0\\n        for x1, y1, x2, y2 in rectangles:\\n            \\n            X1, Y1 = min(X1, x1), min(Y1, y1)\\n            X2, Y2 = max(X2, x2), max(Y2, y2)\\n            \\n            actual_area += (x2 - x1) * (y2 - y1)\\n            \\n            p1, p2 = (x1, y1), (x1, y2)\\n            p3, p4 = (x2, y1), (x2, y2)\\n            for p in [p1, p2, p3, p4]:\\n                if p in points: points.remove(p)\\n                else:           points.add(p)\\n        \\n        expected_area = (X2 - X1) * (Y2 - Y1)\\n        if actual_area != expected_area:\\n            return False\\n        \\n        if len(points) != 4:       return False\\n        \\n        if (X1, Y1) not in points: return False\\n        if (X1, Y2) not in points: return False\\n        if (X2, Y1) not in points: return False\\n        if (X2, Y2) not in points: return False\\n        \\n        return True\\n\\n\\xB7\\xB7\\xB7"
                    },
                    {
                        "username": "jlidbeck",
                        "content": "\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion tab."
                    }
                ]
            },
            {
                "id": 1751630,
                "content": [
                    {
                        "username": "shriyansnaik",
                        "content": "Thought process/Key points\\n1. A rectangle has 4 corners. All corners must appear even number of times(because if the figure is a proper rectangle then all the corners will be contiguous) except for the corners.\\n2. Sum of areas of all small rectangles must equal to the big rectangle.\\n3. The bottom-left and the top right corners of the rectangle can be found by looking at the min and max of all points. Use that to figure out all 4 corners of rectangle. Then check if the corners left(after eliminating the corners that occur even number of times) are the ones that should be the corners (which can be figured out from the bottom-left and top-right corners).\\n"
                    },
                    {
                        "username": "Sanzee",
                        "content": "Sometimes It is important to know the input range and properties of the input variables.\\nFor example:\\n1. How many rectangle can be there in worst case.\\n2. are the co-ordinates can be negative?!\\n3. what is the range of the x,y values for each rectangle.\\n"
                    },
                    {
                        "username": "SudhakarMunjuluri",
                        "content": "Could some one please explain me this question\\n\\nI do not even understand how the rectangles were drawn using the given co-ordinates\\n\\nWhat is confusing me is bottom-left and top-right, if i implement what ever the way I could not draw as shown in the example diagram.\\n\\nThanks a lot"
                    },
                    {
                        "username": "panzy",
                        "content": "It took me a whole day to implement a fast enough algorithm to incrementally merge all the rectangles (the idea was that if in the end there is only one rectangle left then it\\'s perfect), only to find it\\'s based on a wrong idea :(\\n\\n![image](https://assets.leetcode.com/users/images/78ea2ba6-9ef9-4cf2-828b-a1dbd179c655_1609701387.5382698.png)\\n\\n(source: https://www.geogebra.org/m/z3skhnf6)\\n"
                    },
                    {
                        "username": "reeshu54raj",
                        "content": "Can anyone explain me how to start thinking for this question. I can\\'t even start my approach. "
                    },
                    {
                        "username": "Finesse",
                        "content": "Try sorting the given rectangles. Then fill the area with the rectangles from left to right and check for mismatches."
                    },
                    {
                        "username": "lilydenris",
                        "content": "First observation is there will be four point has count of 1 and other points have even count.\\n\\nThis is not enough, a counter example is two rectangles overlap exactly and another rectangle on the side.\\n[[0,0,1,1],[0,0,2,1],[1,0,2,1],[0,2,2,3]]\\n\\nOk, to deal with overlapping, we add a check to make sure all small rectangles add up to the same area of the big one.\\n\\nThis is still not enough to solve above use case. The problem is the four point cannot be any point, has to be the four of big one.\\n"
                    },
                    {
                        "username": "MackLykyn",
                        "content": "can anyone recode my code actually my code is correct but it\\'s just time complexity 42 out of 49 is correct `your inline code...your inline code...`class Solution(object):\\n    def isRectangleCover(self, rectangles):\\n        \"\"\"\\n        :type rectangles: List[List[int]]\\n        :rtype: bool\\n        \"\"\"\\n        xm = ym = 10**6\\n        am = bm = 0\\n        for i in rectangles:\\n            if i[0] < xm:\\n                xm = i[0]\\n            if i[1] < ym:\\n                ym = i[1]\\n            if i[2] > am:\\n                am = i[2]\\n            if i[3] > bm:\\n                bm = i[3]\\n        ml = {}\\n        for i in range(xm, am):\\n            for j in range(ym, bm):\\n                ml[str(i)+\" \"+str(j)] = True\\n        lm = {}\\n        for i in rectangles:\\n            for j in range(i[0], i[2]):\\n                for k in range(i[1], i[3]):\\n                    if str(j) + \" \" + str(k) not in lm:\\n                        lm[str(j) + \" \" + str(k)] = True\\n                    else:\\n                        lm[str(j) + \" \" + str(k)] = False\\n        return ml == lm"
                    },
                    {
                        "username": "user9086f",
                        "content": "Can there be a case where there can be identical rectangles ? "
                    },
                    {
                        "username": "Electron1997",
                        "content": "Yes, there is at least one such test case"
                    },
                    {
                        "username": "nikhilreddydev",
                        "content": "How the area haven't overflown with long long?\n\nMaximum area of a largest rectangle should not have been fit in a long?"
                    },
                    {
                        "username": "wodxuming",
                        "content": "\\xB7\\xB7\\xB7\\nclass Solution:\\n    def isRectangleCover(self, rectangles: List[List[int]]) -> bool:\\n        X1, Y1 = float(\\'inf\\'), float(\\'inf\\')\\n        X2, Y2 = -float(\\'inf\\'), -float(\\'inf\\')\\n        \\n        points = set()\\n        actual_area = 0\\n        for x1, y1, x2, y2 in rectangles:\\n            \\n            X1, Y1 = min(X1, x1), min(Y1, y1)\\n            X2, Y2 = max(X2, x2), max(Y2, y2)\\n            \\n            actual_area += (x2 - x1) * (y2 - y1)\\n            \\n            p1, p2 = (x1, y1), (x1, y2)\\n            p3, p4 = (x2, y1), (x2, y2)\\n            for p in [p1, p2, p3, p4]:\\n                if p in points: points.remove(p)\\n                else:           points.add(p)\\n        \\n        expected_area = (X2 - X1) * (Y2 - Y1)\\n        if actual_area != expected_area:\\n            return False\\n        \\n        if len(points) != 4:       return False\\n        \\n        if (X1, Y1) not in points: return False\\n        if (X1, Y2) not in points: return False\\n        if (X2, Y1) not in points: return False\\n        if (X2, Y2) not in points: return False\\n        \\n        return True\\n\\n\\xB7\\xB7\\xB7"
                    },
                    {
                        "username": "jlidbeck",
                        "content": "\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion tab."
                    }
                ]
            },
            {
                "id": 1713853,
                "content": [
                    {
                        "username": "shriyansnaik",
                        "content": "Thought process/Key points\\n1. A rectangle has 4 corners. All corners must appear even number of times(because if the figure is a proper rectangle then all the corners will be contiguous) except for the corners.\\n2. Sum of areas of all small rectangles must equal to the big rectangle.\\n3. The bottom-left and the top right corners of the rectangle can be found by looking at the min and max of all points. Use that to figure out all 4 corners of rectangle. Then check if the corners left(after eliminating the corners that occur even number of times) are the ones that should be the corners (which can be figured out from the bottom-left and top-right corners).\\n"
                    },
                    {
                        "username": "Sanzee",
                        "content": "Sometimes It is important to know the input range and properties of the input variables.\\nFor example:\\n1. How many rectangle can be there in worst case.\\n2. are the co-ordinates can be negative?!\\n3. what is the range of the x,y values for each rectangle.\\n"
                    },
                    {
                        "username": "SudhakarMunjuluri",
                        "content": "Could some one please explain me this question\\n\\nI do not even understand how the rectangles were drawn using the given co-ordinates\\n\\nWhat is confusing me is bottom-left and top-right, if i implement what ever the way I could not draw as shown in the example diagram.\\n\\nThanks a lot"
                    },
                    {
                        "username": "panzy",
                        "content": "It took me a whole day to implement a fast enough algorithm to incrementally merge all the rectangles (the idea was that if in the end there is only one rectangle left then it\\'s perfect), only to find it\\'s based on a wrong idea :(\\n\\n![image](https://assets.leetcode.com/users/images/78ea2ba6-9ef9-4cf2-828b-a1dbd179c655_1609701387.5382698.png)\\n\\n(source: https://www.geogebra.org/m/z3skhnf6)\\n"
                    },
                    {
                        "username": "reeshu54raj",
                        "content": "Can anyone explain me how to start thinking for this question. I can\\'t even start my approach. "
                    },
                    {
                        "username": "Finesse",
                        "content": "Try sorting the given rectangles. Then fill the area with the rectangles from left to right and check for mismatches."
                    },
                    {
                        "username": "lilydenris",
                        "content": "First observation is there will be four point has count of 1 and other points have even count.\\n\\nThis is not enough, a counter example is two rectangles overlap exactly and another rectangle on the side.\\n[[0,0,1,1],[0,0,2,1],[1,0,2,1],[0,2,2,3]]\\n\\nOk, to deal with overlapping, we add a check to make sure all small rectangles add up to the same area of the big one.\\n\\nThis is still not enough to solve above use case. The problem is the four point cannot be any point, has to be the four of big one.\\n"
                    },
                    {
                        "username": "MackLykyn",
                        "content": "can anyone recode my code actually my code is correct but it\\'s just time complexity 42 out of 49 is correct `your inline code...your inline code...`class Solution(object):\\n    def isRectangleCover(self, rectangles):\\n        \"\"\"\\n        :type rectangles: List[List[int]]\\n        :rtype: bool\\n        \"\"\"\\n        xm = ym = 10**6\\n        am = bm = 0\\n        for i in rectangles:\\n            if i[0] < xm:\\n                xm = i[0]\\n            if i[1] < ym:\\n                ym = i[1]\\n            if i[2] > am:\\n                am = i[2]\\n            if i[3] > bm:\\n                bm = i[3]\\n        ml = {}\\n        for i in range(xm, am):\\n            for j in range(ym, bm):\\n                ml[str(i)+\" \"+str(j)] = True\\n        lm = {}\\n        for i in rectangles:\\n            for j in range(i[0], i[2]):\\n                for k in range(i[1], i[3]):\\n                    if str(j) + \" \" + str(k) not in lm:\\n                        lm[str(j) + \" \" + str(k)] = True\\n                    else:\\n                        lm[str(j) + \" \" + str(k)] = False\\n        return ml == lm"
                    },
                    {
                        "username": "user9086f",
                        "content": "Can there be a case where there can be identical rectangles ? "
                    },
                    {
                        "username": "Electron1997",
                        "content": "Yes, there is at least one such test case"
                    },
                    {
                        "username": "nikhilreddydev",
                        "content": "How the area haven't overflown with long long?\n\nMaximum area of a largest rectangle should not have been fit in a long?"
                    },
                    {
                        "username": "wodxuming",
                        "content": "\\xB7\\xB7\\xB7\\nclass Solution:\\n    def isRectangleCover(self, rectangles: List[List[int]]) -> bool:\\n        X1, Y1 = float(\\'inf\\'), float(\\'inf\\')\\n        X2, Y2 = -float(\\'inf\\'), -float(\\'inf\\')\\n        \\n        points = set()\\n        actual_area = 0\\n        for x1, y1, x2, y2 in rectangles:\\n            \\n            X1, Y1 = min(X1, x1), min(Y1, y1)\\n            X2, Y2 = max(X2, x2), max(Y2, y2)\\n            \\n            actual_area += (x2 - x1) * (y2 - y1)\\n            \\n            p1, p2 = (x1, y1), (x1, y2)\\n            p3, p4 = (x2, y1), (x2, y2)\\n            for p in [p1, p2, p3, p4]:\\n                if p in points: points.remove(p)\\n                else:           points.add(p)\\n        \\n        expected_area = (X2 - X1) * (Y2 - Y1)\\n        if actual_area != expected_area:\\n            return False\\n        \\n        if len(points) != 4:       return False\\n        \\n        if (X1, Y1) not in points: return False\\n        if (X1, Y2) not in points: return False\\n        if (X2, Y1) not in points: return False\\n        if (X2, Y2) not in points: return False\\n        \\n        return True\\n\\n\\xB7\\xB7\\xB7"
                    },
                    {
                        "username": "jlidbeck",
                        "content": "\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion tab."
                    }
                ]
            },
            {
                "id": 1637152,
                "content": [
                    {
                        "username": "shriyansnaik",
                        "content": "Thought process/Key points\\n1. A rectangle has 4 corners. All corners must appear even number of times(because if the figure is a proper rectangle then all the corners will be contiguous) except for the corners.\\n2. Sum of areas of all small rectangles must equal to the big rectangle.\\n3. The bottom-left and the top right corners of the rectangle can be found by looking at the min and max of all points. Use that to figure out all 4 corners of rectangle. Then check if the corners left(after eliminating the corners that occur even number of times) are the ones that should be the corners (which can be figured out from the bottom-left and top-right corners).\\n"
                    },
                    {
                        "username": "Sanzee",
                        "content": "Sometimes It is important to know the input range and properties of the input variables.\\nFor example:\\n1. How many rectangle can be there in worst case.\\n2. are the co-ordinates can be negative?!\\n3. what is the range of the x,y values for each rectangle.\\n"
                    },
                    {
                        "username": "SudhakarMunjuluri",
                        "content": "Could some one please explain me this question\\n\\nI do not even understand how the rectangles were drawn using the given co-ordinates\\n\\nWhat is confusing me is bottom-left and top-right, if i implement what ever the way I could not draw as shown in the example diagram.\\n\\nThanks a lot"
                    },
                    {
                        "username": "panzy",
                        "content": "It took me a whole day to implement a fast enough algorithm to incrementally merge all the rectangles (the idea was that if in the end there is only one rectangle left then it\\'s perfect), only to find it\\'s based on a wrong idea :(\\n\\n![image](https://assets.leetcode.com/users/images/78ea2ba6-9ef9-4cf2-828b-a1dbd179c655_1609701387.5382698.png)\\n\\n(source: https://www.geogebra.org/m/z3skhnf6)\\n"
                    },
                    {
                        "username": "reeshu54raj",
                        "content": "Can anyone explain me how to start thinking for this question. I can\\'t even start my approach. "
                    },
                    {
                        "username": "Finesse",
                        "content": "Try sorting the given rectangles. Then fill the area with the rectangles from left to right and check for mismatches."
                    },
                    {
                        "username": "lilydenris",
                        "content": "First observation is there will be four point has count of 1 and other points have even count.\\n\\nThis is not enough, a counter example is two rectangles overlap exactly and another rectangle on the side.\\n[[0,0,1,1],[0,0,2,1],[1,0,2,1],[0,2,2,3]]\\n\\nOk, to deal with overlapping, we add a check to make sure all small rectangles add up to the same area of the big one.\\n\\nThis is still not enough to solve above use case. The problem is the four point cannot be any point, has to be the four of big one.\\n"
                    },
                    {
                        "username": "MackLykyn",
                        "content": "can anyone recode my code actually my code is correct but it\\'s just time complexity 42 out of 49 is correct `your inline code...your inline code...`class Solution(object):\\n    def isRectangleCover(self, rectangles):\\n        \"\"\"\\n        :type rectangles: List[List[int]]\\n        :rtype: bool\\n        \"\"\"\\n        xm = ym = 10**6\\n        am = bm = 0\\n        for i in rectangles:\\n            if i[0] < xm:\\n                xm = i[0]\\n            if i[1] < ym:\\n                ym = i[1]\\n            if i[2] > am:\\n                am = i[2]\\n            if i[3] > bm:\\n                bm = i[3]\\n        ml = {}\\n        for i in range(xm, am):\\n            for j in range(ym, bm):\\n                ml[str(i)+\" \"+str(j)] = True\\n        lm = {}\\n        for i in rectangles:\\n            for j in range(i[0], i[2]):\\n                for k in range(i[1], i[3]):\\n                    if str(j) + \" \" + str(k) not in lm:\\n                        lm[str(j) + \" \" + str(k)] = True\\n                    else:\\n                        lm[str(j) + \" \" + str(k)] = False\\n        return ml == lm"
                    },
                    {
                        "username": "user9086f",
                        "content": "Can there be a case where there can be identical rectangles ? "
                    },
                    {
                        "username": "Electron1997",
                        "content": "Yes, there is at least one such test case"
                    },
                    {
                        "username": "nikhilreddydev",
                        "content": "How the area haven't overflown with long long?\n\nMaximum area of a largest rectangle should not have been fit in a long?"
                    },
                    {
                        "username": "wodxuming",
                        "content": "\\xB7\\xB7\\xB7\\nclass Solution:\\n    def isRectangleCover(self, rectangles: List[List[int]]) -> bool:\\n        X1, Y1 = float(\\'inf\\'), float(\\'inf\\')\\n        X2, Y2 = -float(\\'inf\\'), -float(\\'inf\\')\\n        \\n        points = set()\\n        actual_area = 0\\n        for x1, y1, x2, y2 in rectangles:\\n            \\n            X1, Y1 = min(X1, x1), min(Y1, y1)\\n            X2, Y2 = max(X2, x2), max(Y2, y2)\\n            \\n            actual_area += (x2 - x1) * (y2 - y1)\\n            \\n            p1, p2 = (x1, y1), (x1, y2)\\n            p3, p4 = (x2, y1), (x2, y2)\\n            for p in [p1, p2, p3, p4]:\\n                if p in points: points.remove(p)\\n                else:           points.add(p)\\n        \\n        expected_area = (X2 - X1) * (Y2 - Y1)\\n        if actual_area != expected_area:\\n            return False\\n        \\n        if len(points) != 4:       return False\\n        \\n        if (X1, Y1) not in points: return False\\n        if (X1, Y2) not in points: return False\\n        if (X2, Y1) not in points: return False\\n        if (X2, Y2) not in points: return False\\n        \\n        return True\\n\\n\\xB7\\xB7\\xB7"
                    },
                    {
                        "username": "jlidbeck",
                        "content": "\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion tab."
                    }
                ]
            }
        ]
    }
]