[
    {
        "title": "Longest Palindromic Substring",
        "question_content": "Given a string s, return the longest palindromic substring in s.\n&nbsp;\nExample 1:\n\nInput: s = \"babad\"\nOutput: \"bab\"\nExplanation: \"aba\" is also a valid answer.\n\nExample 2:\n\nInput: s = \"cbbd\"\nOutput: \"bb\"\n\n&nbsp;\nConstraints:\n\n\t1 <= s.length <= 1000\n\ts consist of only digits and English letters.",
        "solutions": [
            {
                "id": 2928,
                "title": "very-simple-clean-java-solution",
                "content": "The performance is pretty good, surprisingly.\\n\\n    public class Solution {\\n\\tprivate int lo, maxLen;\\n\\t\\n    public String longestPalindrome(String s) {\\n    \\tint len = s.length();\\n    \\tif (len < 2)\\n    \\t\\treturn s;\\n    \\t\\n        for (int i = 0; i < len-1; i++) {\\n         \\textendPalindrome(s, i, i);  //assume odd length, try to extend Palindrome as possible\\n         \\textendPalindrome(s, i, i+1); //assume even length.\\n        }\\n        return s.substring(lo, lo + maxLen);\\n    }\\n\\n\\tprivate void extendPalindrome(String s, int j, int k) {\\n\\t\\twhile (j >= 0 && k < s.length() && s.charAt(j) == s.charAt(k)) {\\n\\t\\t\\tj--;\\n\\t\\t\\tk++;\\n\\t\\t}\\n\\t\\tif (maxLen < k - j - 1) {\\n\\t\\t\\tlo = j + 1;\\n\\t\\t\\tmaxLen = k - j - 1;\\n\\t\\t}\\n\\t}}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\tprivate int lo, maxLen;\\n\\t\\n    public String longestPalindrome(String s) {\\n    \\tint len = s.length();\\n    \\tif (len < 2)\\n    \\t\\treturn s;\\n    \\t\\n        for (int i = 0; i < len-1; i++) {\\n         \\textendPalindrome(s, i, i);  //assume odd length, try to extend Palindrome as possible\\n         \\textendPalindrome(s, i, i+1); //assume even length.\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 151144,
                "title": "bottom-up-dp-two-pointers",
                "content": "Intuitively, we list all the substrings, pick those palindromic, and get the longest one. This approach takes O(n^3) time complexity, where n is the length of `s`.\\n\\n# Dynamic Programming\\nThe problem can be broken down into subproblems which are reused several times. Overlapping subproblems lead us to Dynamic Programming.\\n\\nWe decompose the problem as follows:\\n\\n- State variable\\nThe `start` index and `end` index of a substring can identify a state, which **influences our decision**.\\nSo the state variable is `state(start, end)` indicates whether `s[start, end]` inclusive is palindromic\\n\\n- Goal state\\n`max(end - start + 1)` for all `state(start, end) = true`\\n\\n- State transition\\n```\\nfor start = end (e.g. \\'a\\'), state(start, end) is True\\nfor start + 1 = end (e.g. \\'aa\\'), state(start, end) is True if s[start] = s[end]\\nfor start + 2 = end (e.g. \\'aba\\'),  state(start, end) is True if s[start] = s[end] and state(start + 1, end - 1)\\nfor start + 3 = end (e.g. \\'abba\\'),  state(start, end) is True if s[start] = s[end] and state(start + 1, end - 1)\\n...\\n```\\n\\nThis approach takes O(n^2) time complexity, O(n^2) space complexity, where n is the length of `s`.\\n\\n```\\nclass Solution:\\n    def longestPalindrome(self, s: str) -> str:\\n        n = len(s)\\n        dp = [[False] * n for _ in range(n)]\\n        for i in range(n):\\n            dp[i][i] = True\\n        longest_palindrome_start, longest_palindrome_len = 0, 1\\n\\n        for end in range(0, n):\\n            for start in range(end - 1, -1, -1):\\n                # print(\\'start: %s, end: %s\\' % (start, end))\\n                if s[start] == s[end]:\\n                    if end - start == 1 or dp[start + 1][end - 1]:\\n                        dp[start][end] = True\\n                        palindrome_len = end - start + 1\\n                        if longest_palindrome_len < palindrome_len:\\n                            longest_palindrome_start = start\\n                            longest_palindrome_len = palindrome_len\\n        return s[longest_palindrome_start: longest_palindrome_start + longest_palindrome_len]\\n```\\n\\n# Two pointers\\nThis approach takes O(n^2) time complexity, O(1) space complexity, where n is the length of `s`.\\n\\nFor each character `s[i]`, we get the first character to its right which isn\\'t equal to `s[i]`.\\nThen `s[i, right - 1]` inclusive are equal characters e.g. \"aaa\".\\nThen we make `left = i - 1`, while s[left] == s[right], s[left, right] inclusive is palindrome, and we keep extending both ends by `left -= 1, right += 1`.\\nFinally we update the tracked longest palindrome if needed.\\n\\n```\\nclass Solution:\\n    def longestPalindrome(self, s: str) -> str:\\n        n = len(s)\\n        longest_palindrome_start, longest_palindrome_len = 0, 1\\n\\n        for i in range(0, n):\\n            right = i\\n            while right < n and s[i] == s[right]:\\n                right += 1\\n            # s[i, right - 1] inclusive are equal characters e.g. \"aaa\"\\n            \\n            # while s[left] == s[right], s[left, right] inclusive is palindrome e.g. \"baaab\"\\n            left = i - 1\\n            while left >= 0 and right < n and s[left] == s[right]:\\n                left -= 1\\n                right += 1\\n            \\n            # s[left + 1, right - 1] inclusive is palindromic\\n            palindrome_len = right - left - 1\\n            if palindrome_len > longest_palindrome_len:\\n                longest_palindrome_len = palindrome_len\\n                longest_palindrome_start = left + 1\\n            \\n        return s[longest_palindrome_start: longest_palindrome_start + longest_palindrome_len]\\n         \\n```\\n",
                "solutionTags": [],
                "code": "```\\nfor start = end (e.g. \\'a\\'), state(start, end) is True\\nfor start + 1 = end (e.g. \\'aa\\'), state(start, end) is True if s[start] = s[end]\\nfor start + 2 = end (e.g. \\'aba\\'),  state(start, end) is True if s[start] = s[end] and state(start + 1, end - 1)\\nfor start + 3 = end (e.g. \\'abba\\'),  state(start, end) is True if s[start] = s[end] and state(start + 1, end - 1)\\n...\\n```\n```\\nclass Solution:\\n    def longestPalindrome(self, s: str) -> str:\\n        n = len(s)\\n        dp = [[False] * n for _ in range(n)]\\n        for i in range(n):\\n            dp[i][i] = True\\n        longest_palindrome_start, longest_palindrome_len = 0, 1\\n\\n        for end in range(0, n):\\n            for start in range(end - 1, -1, -1):\\n                # print(\\'start: %s, end: %s\\' % (start, end))\\n                if s[start] == s[end]:\\n                    if end - start == 1 or dp[start + 1][end - 1]:\\n                        dp[start][end] = True\\n                        palindrome_len = end - start + 1\\n                        if longest_palindrome_len < palindrome_len:\\n                            longest_palindrome_start = start\\n                            longest_palindrome_len = palindrome_len\\n        return s[longest_palindrome_start: longest_palindrome_start + longest_palindrome_len]\\n```\n```\\nclass Solution:\\n    def longestPalindrome(self, s: str) -> str:\\n        n = len(s)\\n        longest_palindrome_start, longest_palindrome_len = 0, 1\\n\\n        for i in range(0, n):\\n            right = i\\n            while right < n and s[i] == s[right]:\\n                right += 1\\n            # s[i, right - 1] inclusive are equal characters e.g. \"aaa\"\\n            \\n            # while s[left] == s[right], s[left, right] inclusive is palindrome e.g. \"baaab\"\\n            left = i - 1\\n            while left >= 0 and right < n and s[left] == s[right]:\\n                left -= 1\\n                right += 1\\n            \\n            # s[left + 1, right - 1] inclusive is palindromic\\n            palindrome_len = right - left - 1\\n            if palindrome_len > longest_palindrome_len:\\n                longest_palindrome_len = palindrome_len\\n                longest_palindrome_start = left + 1\\n            \\n        return s[longest_palindrome_start: longest_palindrome_start + longest_palindrome_len]\\n         \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2954,
                "title": "python-easy-to-understand-solution-with-comments-from-middle-to-two-ends",
                "content": "        \\n    def longestPalindrome(self, s):\\n        res = \"\"\\n        for i in xrange(len(s)):\\n            # odd case, like \"aba\"\\n            tmp = self.helper(s, i, i)\\n            if len(tmp) > len(res):\\n                res = tmp\\n            # even case, like \"abba\"\\n            tmp = self.helper(s, i, i+1)\\n            if len(tmp) > len(res):\\n                res = tmp\\n        return res\\n     \\n    # get the longest palindrome, l, r are the middle indexes   \\n    # from inner to outer\\n    def helper(self, s, l, r):\\n        while l >= 0 and r < len(s) and s[l] == s[r]:\\n            l -= 1; r += 1\\n        return s[l+1:r]",
                "solutionTags": [
                    "Python"
                ],
                "code": "        \\n    def longestPalindrome(self, s):\\n        res = \"\"\\n        for i in xrange(len(s)):\\n            # odd case, like \"aba\"\\n            tmp = self.helper(s, i, i)\\n            if len(tmp) > len(res):\\n                res = tmp\\n            # even case, like \"abba\"\\n            tmp = self.helper(s, i, i+1)\\n            if len(tmp) > len(res):\\n                res = tmp\\n        return res\\n     \\n    # get the longest palindrome, l, r are the middle indexes   \\n    # from inner to outer\\n    def helper(self, s, l, r):\\n        while l >= 0 and r < len(s) and s[l] == s[r]:\\n            l -= 1; r += 1\\n        return s[l+1:r]",
                "codeTag": "Python3"
            },
            {
                "id": 2921,
                "title": "share-my-java-solution-using-dynamic-programming",
                "content": "`dp(i, j)` represents whether `s(i ... j)` can form a palindromic substring, `dp(i, j)` is true when `s(i)` equals to `s(j)` and `s(i+1 ... j-1)` is a palindromic substring. When we found a palindrome, check if it's the longest one. Time complexity O(n^2).\\n\\n    public String longestPalindrome(String s) {\\n      int n = s.length();\\n      String res = null;\\n        \\n      boolean[][] dp = new boolean[n][n];\\n        \\n      for (int i = n - 1; i >= 0; i--) {\\n        for (int j = i; j < n; j++) {\\n          dp[i][j] = s.charAt(i) == s.charAt(j) && (j - i < 3 || dp[i + 1][j - 1]);\\n                \\n          if (dp[i][j] && (res == null || j - i + 1 > res.length())) {\\n            res = s.substring(i, j + 1);\\n          }\\n        }\\n      }\\n        \\n      return res;\\n    }",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "`dp(i, j)` represents whether `s(i ... j)` can form a palindromic substring, `dp(i, j)` is true when `s(i)` equals to `s(j)` and `s(i+1 ... j-1)` is a palindromic substring. When we found a palindrome, check if it's the longest one. Time complexity O(n^2).\\n\\n    public String longestPalindrome(String s) {\\n      int n = s.length();\\n      String res = null;\\n        \\n      boolean[][] dp = new boolean[n][n];\\n        \\n      for (int i = n - 1; i >= 0; i--) {\\n        for (int j = i; j < n; j++) {\\n          dp[i][j] = s.charAt(i) == s.charAt(j) && (j - i < 3 || dp[i + 1][j - 1]);\\n                \\n          if (dp[i][j] && (res == null || j - i + 1 > res.length())) {\\n            res = s.substring(i, j + 1);\\n          }\\n        }\\n      }\\n        \\n      return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 900639,
                "title": "python-solution-with-detailed-explanation-using-dp",
                "content": "####  Approach (implemented Dp rules)\\n* #####             Definition : the row and col in the dp table represent the slicing index on the string s  (inclusive)\\n* #####                 example s = \\'babad\\'  -- > dp[2][3] = s[2:3] = ba\\n#####             Steps : \\n* #####             Fill the diagonal with True, b/c every single character by itself is palindrom \\n* #####             Don\\'t traverse in the bottom part of the diagonal \\n\\t* #####                 Becuase, that represent reverse slicing (which is not valid)\\n#####             \\n* #####             Iterate backward starting from the most right bottom cell to top (only on the right side of the digonal) \\n\\t* #####                 How ? \\n\\t\\t* ##### \\t\\tStart itertating backward for the outer loop (i) and for the inner loop (j) iterate forward starting from the index of outer loop ) : see the code (the for loops) \\n#####                 \\n* #####                 - Pick character from the input string based on the at i and j position, If the characters matches : you need to check two conditions\\n\\t* #####                     1. If the length of the sub_string is just one (a letter matching is good to be a palindrom)\\n\\t* #####                     2. But if the length of the sub_string is > 1 \\n\\t\\t* #####                         - You need to check if the inner sub_sting is also palindrom\\n\\t\\t* #####                             - How ?\\n\\t\\t\\t* #####                                 - You go to the left bottom corner and check if it is True \\n\\t\\t\\t* #####                                     - Left bottom corrner represent the inner sub_string of the current_sub_string \\n\\t\\t\\t\\t* #####                                         -Eg. if  dp[i][j]= cur_sub_string = \\'ababa\\' --> True because dp[i+1][j-1] is True\\n\\t\\t\\t\\t* #####                                                  dp[i+1][j-1] = \\'bab\\' = True\\n\\t\\t\\t\\t* #####                                          .Howerver if  dp[i][j]= cur_sub_string = \\'abaca\\'  --> False because  dp[i+1][j-1] is False\\n\\t\\t\\t\\t* #####                                                  dp[i+1][j-1] = \\'bac\\' = False  --> not palindrom \\n\\t\\t* #####                                                  \\n\\t\\t* #####                         If dp[i+1][j-1] == True:\\n\\t\\t\\t* #####                             Ok that means the current sub_string is also palindrom                      \\n\\t\\t* #####                             - Now compare the length of the current_palindrom sub_string with the prvious longest one and take the max\\n* #####                 - Else : the characters don\\'t match\\n\\t* #####                     Just pass\\n* #####             - Finally return the maximum number in the dp\\n* ##### If this solution/explanation helps you, don\\'t forget to upvote as appreciation\\n\\n```\\ndef longestPalindrome(self, s):\\n        longest_palindrom = \\'\\'\\n        dp = [[0]*len(s) for _ in range(len(s))]\\n        #filling out the diagonal by 1\\n        for i in range(len(s)):\\n            dp[i][i] = True\\n            longest_palindrom = s[i]\\n\\t\\t\\t\\n        # filling the dp table\\n        for i in range(len(s)-1,-1,-1):\\n\\t\\t\\t\\t# j starts from the i location : to only work on the upper side of the diagonal \\n            for j in range(i+1,len(s)):  \\n                if s[i] == s[j]:  #if the chars mathces\\n                    # if len slicied sub_string is just one letter if the characters are equal, we can say they are palindomr dp[i][j] =True \\n                    #if the slicied sub_string is longer than 1, then we should check if the inner string is also palindrom (check dp[i+1][j-1] is True)\\n                    if j-i ==1 or dp[i+1][j-1] is True:\\n                        dp[i][j] = True\\n                        # we also need to keep track of the maximum palindrom sequence \\n                        if len(longest_palindrom) < len(s[i:j+1]):\\n                            longest_palindrom = s[i:j+1]\\n                \\n        return longest_palindrom\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\ndef longestPalindrome(self, s):\\n        longest_palindrom = \\'\\'\\n        dp = [[0]*len(s) for _ in range(len(s))]\\n        #filling out the diagonal by 1\\n        for i in range(len(s)):\\n            dp[i][i] = True\\n            longest_palindrom = s[i]\\n\\t\\t\\t\\n        # filling the dp table\\n        for i in range(len(s)-1,-1,-1):\\n\\t\\t\\t\\t# j starts from the i location : to only work on the upper side of the diagonal \\n            for j in range(i+1,len(s)):  \\n                if s[i] == s[j]:  #if the chars mathces\\n                    # if len slicied sub_string is just one letter if the characters are equal, we can say they are palindomr dp[i][j] =True \\n                    #if the slicied sub_string is longer than 1, then we should check if the inner string is also palindrom (check dp[i+1][j-1] is True)\\n                    if j-i ==1 or dp[i+1][j-1] is True:\\n                        dp[i][j] = True\\n                        # we also need to keep track of the maximum palindrom sequence \\n                        if len(longest_palindrom) < len(s[i:j+1]):\\n                            longest_palindrom = s[i:j+1]\\n                \\n        return longest_palindrom\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3202985,
                "title": "best-c-3-solution-dp-string-brute-force-optimize-one-stop-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can solve this question using Multiple Approaches. (Here I have explained all the possible solutions of this problem).\\n\\n1. Solved using string(Three Nested Loop). Brute Force Approach.\\n2. Solved using string(TwoNested Loop). Brute Force Approach.\\n3. Solved using Dynamic Programming Approach(tabulation). Optimized Approach.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can easily understand the All the approaches by seeing the code which is easy to understand with comments.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTime complexity is given in code comment.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSpace complexity is given in code comment.\\n\\n# Code\\n```\\n/*\\n\\n    Time Complexity : O(N^3), Here three nested loop creates the time complexity. Where N is the size of the\\n    string(s).\\n\\n    Space Complexity : O(1), Constant space.\\n\\n    Solved using string(Three Nested Loop). Brute Force Approach.\\n\\n    Note : this may give TLE.\\n\\n*/\\n\\n\\n/***************************************** Approach 1 *****************************************/\\n\\nclass Solution {\\nprivate: \\n    bool check(string &s, int i, int j){\\n        while(i<j){\\n            if(s[i] != s[j]){\\n                return false;\\n            }\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }            \\npublic:\\n    string longestPalindrome(string s) {\\n        int n = s.size();\\n        int starting_index = 0;\\n        int max_len = 0;\\n        for(int i=0; i<n; i++){\\n            for(int j=i; j<n; j++){\\n                if(check(s, i, j)){\\n                    if(j-i+1 > max_len){\\n                        max_len = j-i+1;\\n                        starting_index = i;\\n                    }\\n                }\\n            }\\n        }\\n        return s.substr(starting_index, max_len);\\n    }\\n}; \\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(N^2), Here Two nested loop creates the time complexity. Where N is the size of the\\n    string(s).\\n\\n    Space Complexity : O(N^2*N), vector(substring) space.\\n\\n    Solved using string(TwoNested Loop). Brute Force Approach.\\n\\n    Note : this may give TLE.\\n\\n*/\\n\\n\\n/***************************************** Approach 2 *****************************************/\\n\\nclass Solution { \\nprivate: \\n    bool check(string &s, int i, int j){\\n        while(i<j){\\n            if(s[i] != s[j]){\\n                return false;\\n            }\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\npublic:\\n    string longestPalindrome(string s) {\\n        int n = s.size();\\n        vector<string> substring;\\n        for(int i=0; i<n; i++){\\n            string temp = \"\";\\n            for(int j=i; j<n; j++){\\n                temp += s[j];\\n                substring.push_back(temp);\\n            }\\n        }\\n        int max_len = 0;\\n        string finalans = substring[0];\\n        int m = substring.size();\\n        for(int i=0; i<m; i++){\\n            int s = substring[i].size();\\n            if(check(substring[i], 0, s-1)){\\n                if(s > max_len){\\n                    max_len = s;\\n                    finalans = substring[i];\\n                }\\n            }       \\n        }\\n        return finalans;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(N^2), The time complexity of the above code is O(N^2) because we are traversing over all\\n    the substrings and then checking each substring if it is a palindrome or not. There are N^2 substrings and\\n    checking a substring takes O(1) time, so total time complexity is O(N^2).\\n\\n    Space Complexity : (N^2), The space complexity of the above code is O(N^2) because we are using the dp array\\n    in which we are storing whether a substring is a palindrome or not.\\n\\n    Solved using Dynamic Programming Approach(tabulation). Optimized Approach.\\n\\n*/\\n\\n\\n/***************************************** Approach 3 *****************************************/\\n\\nclass Solution {\\nprivate: \\n    bool solve(vector<vector<bool>> &dp, int i, int j, string &s){\\n        if(i == j){\\n            return dp[i][j] = true;\\n        }\\n        if(j-i == 1){\\n            if(s[i] == s[j]){\\n                return dp[i][j] = true;\\n            }\\n            else{\\n                return dp[i][j] = false;\\n            }\\n        }\\n        if(s[i] == s[j] && dp[i+1][j-1] == true){\\n            return dp[i][j] = true;\\n        } else {\\n            return dp[i][j] = false;\\n        }\\n    }\\npublic:\\n    string longestPalindrome(string s) {\\n        int n = s.size();\\n        int startIndex = 0; int maxlen = 0;\\n        vector<vector<bool>> dp(n, vector<bool>(n, false));\\n        for(int g=0; g<n; g++){\\n            for(int i=0, j=g; j<n; i++, j++){\\n                solve(dp, i, j, s);\\n                if(dp[i][j] == true){\\n                    if(j-i+1 > maxlen){\\n                        startIndex = i;\\n                        maxlen = j-i+1;\\n                    }\\n                }\\n            }\\n        }\\n        return s.substr(startIndex, maxlen);\\n    }\\n};\\n\\n```\\n\\n***IF YOU LIKE THE SOLUTION THEN PLEASE UPVOTE MY SOLUTION BECAUSE IT GIVES ME MOTIVATION TO REGULARLY POST THE SOLUTION.***\\n\\n![WhatsApp Image 2023-02-10 at 19.01.02.jpeg](https://assets.leetcode.com/users/images/0a95fea4-64f4-4502-82aa-41db6d77c05c_1676054939.8270252.jpeg)",
                "solutionTags": [
                    "C++",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```\\n/*\\n\\n    Time Complexity : O(N^3), Here three nested loop creates the time complexity. Where N is the size of the\\n    string(s).\\n\\n    Space Complexity : O(1), Constant space.\\n\\n    Solved using string(Three Nested Loop). Brute Force Approach.\\n\\n    Note : this may give TLE.\\n\\n*/\\n\\n\\n/***************************************** Approach 1 *****************************************/\\n\\nclass Solution {\\nprivate: \\n    bool check(string &s, int i, int j){\\n        while(i<j){\\n            if(s[i] != s[j]){\\n                return false;\\n            }\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }            \\npublic:\\n    string longestPalindrome(string s) {\\n        int n = s.size();\\n        int starting_index = 0;\\n        int max_len = 0;\\n        for(int i=0; i<n; i++){\\n            for(int j=i; j<n; j++){\\n                if(check(s, i, j)){\\n                    if(j-i+1 > max_len){\\n                        max_len = j-i+1;\\n                        starting_index = i;\\n                    }\\n                }\\n            }\\n        }\\n        return s.substr(starting_index, max_len);\\n    }\\n}; \\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(N^2), Here Two nested loop creates the time complexity. Where N is the size of the\\n    string(s).\\n\\n    Space Complexity : O(N^2*N), vector(substring) space.\\n\\n    Solved using string(TwoNested Loop). Brute Force Approach.\\n\\n    Note : this may give TLE.\\n\\n*/\\n\\n\\n/***************************************** Approach 2 *****************************************/\\n\\nclass Solution { \\nprivate: \\n    bool check(string &s, int i, int j){\\n        while(i<j){\\n            if(s[i] != s[j]){\\n                return false;\\n            }\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\npublic:\\n    string longestPalindrome(string s) {\\n        int n = s.size();\\n        vector<string> substring;\\n        for(int i=0; i<n; i++){\\n            string temp = \"\";\\n            for(int j=i; j<n; j++){\\n                temp += s[j];\\n                substring.push_back(temp);\\n            }\\n        }\\n        int max_len = 0;\\n        string finalans = substring[0];\\n        int m = substring.size();\\n        for(int i=0; i<m; i++){\\n            int s = substring[i].size();\\n            if(check(substring[i], 0, s-1)){\\n                if(s > max_len){\\n                    max_len = s;\\n                    finalans = substring[i];\\n                }\\n            }       \\n        }\\n        return finalans;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(N^2), The time complexity of the above code is O(N^2) because we are traversing over all\\n    the substrings and then checking each substring if it is a palindrome or not. There are N^2 substrings and\\n    checking a substring takes O(1) time, so total time complexity is O(N^2).\\n\\n    Space Complexity : (N^2), The space complexity of the above code is O(N^2) because we are using the dp array\\n    in which we are storing whether a substring is a palindrome or not.\\n\\n    Solved using Dynamic Programming Approach(tabulation). Optimized Approach.\\n\\n*/\\n\\n\\n/***************************************** Approach 3 *****************************************/\\n\\nclass Solution {\\nprivate: \\n    bool solve(vector<vector<bool>> &dp, int i, int j, string &s){\\n        if(i == j){\\n            return dp[i][j] = true;\\n        }\\n        if(j-i == 1){\\n            if(s[i] == s[j]){\\n                return dp[i][j] = true;\\n            }\\n            else{\\n                return dp[i][j] = false;\\n            }\\n        }\\n        if(s[i] == s[j] && dp[i+1][j-1] == true){\\n            return dp[i][j] = true;\\n        } else {\\n            return dp[i][j] = false;\\n        }\\n    }\\npublic:\\n    string longestPalindrome(string s) {\\n        int n = s.size();\\n        int startIndex = 0; int maxlen = 0;\\n        vector<vector<bool>> dp(n, vector<bool>(n, false));\\n        for(int g=0; g<n; g++){\\n            for(int i=0, j=g; j<n; i++, j++){\\n                solve(dp, i, j, s);\\n                if(dp[i][j] == true){\\n                    if(j-i+1 > maxlen){\\n                        startIndex = i;\\n                        maxlen = j-i+1;\\n                    }\\n                }\\n            }\\n        }\\n        return s.substr(startIndex, maxlen);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 844586,
                "title": "very-easy-to-understand-well-commented-2-approaches-thinking-process",
                "content": "**Subscribe to my youtube channel for tech related content:** [here](https://www.youtube.com/c/VishalRajput_1)\\n\\n```\\n// https://leetcode.com/problems/longest-palindromic-substring/\\n\\n/*\\nSolution 1: Brute Force Approach (Give TLE)\\n\\nGenerate all substring and check it is palindrome or not.\\nIf it is palindrome then check it is longest or not.\\n\\nTime Complexity - O(N^3),  O(N^2) to generate all substring and O(N) to check it is palindrome or not.\\nSpace complexity - O(1).\\n*/\\n\\nclass Solution\\n{\\npublic:\\n    bool isPalindrome(string s)\\n    {\\n        int i = 0, j = s.size() - 1;\\n\\n        while (i < j)\\n        {\\n            if (s[i++] != s[j--])\\n                return false;\\n        }\\n        return true;\\n    }\\n\\n    string longestPalindrome(string s)\\n    {\\n        int n = s.size();\\n        if (n == 0)\\n            return \"\";\\n\\n        if (n == 1)\\n            return s;\\n\\n        string result = \"\";\\n        for (int i = 0; i < n - 1; i++)\\n        {\\n            for (int j = 1; j <= n - i; j++)\\n            {\\n                if (isPalindrome(s.substr(i, j)))\\n                {\\n                    if (result.size() < j)\\n                        result = s.substr(i, j);\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n};\\n\\n/*\\nAbove Solution Give TLE....\\n\\nHow Can we optimise our code?\\n\\nGot it in above solution, we do unnecessary recompution while validating palindomes.\\nFor example : if we know string \"aba\" is palindrome then \"cabac\" must be palindrome as left and right are equal.\\n\\nSolution 2: Using DP\\n\\nP(i, j) == P(i+1, j-1) && s[i] == s[j];\\n\\nBase cases :\\n\\n//One character\\nP(i, i) = true;\\n\\n//Two character\\nP(i, i+1) = s[i] == s[i+1];\\n\\nTime Complexity - O(N^2), Space Complexity - O(N^2) (caching all substring)\\n*/\\n\\nclass Solution\\n{\\npublic:\\n    string longestPalindrome(string s)\\n    {\\n        int n = s.size();\\n        if (n == 0)\\n            return \"\";\\n\\n        // dp[i][j] will be \\'true\\' if the string from index i to j is a palindrome.\\n        bool dp[n][n];\\n\\n        //Initialize with false\\n\\n        memset(dp, 0, sizeof(dp));\\n\\n        //Every Single character is palindrome\\n        for (int i = 0; i < n; i++)\\n            dp[i][i] = true;\\n\\n        string ans = \"\";\\n        ans += s[0];\\n\\n        for (int i = n - 1; i >= 0; i--)\\n        {\\n            for (int j = i + 1; j < n; j++)\\n            {\\n                if (s[i] == s[j])\\n                {\\n                    //If it is of two character OR if its susbtring is palindrome.\\n                    if (j - i == 1 || dp[i + 1][j - 1])\\n                    {\\n                        //Then it will also a palindrome substring\\n                        dp[i][j] = true;\\n\\n                        //Check for Longest Palindrome substring\\n                        if (ans.size() < j - i + 1)\\n                            ans = s.substr(i, j - i + 1);\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**If you like the solution. Please Upvote :)**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n// https://leetcode.com/problems/longest-palindromic-substring/\\n\\n/*\\nSolution 1: Brute Force Approach (Give TLE)\\n\\nGenerate all substring and check it is palindrome or not.\\nIf it is palindrome then check it is longest or not.\\n\\nTime Complexity - O(N^3),  O(N^2) to generate all substring and O(N) to check it is palindrome or not.\\nSpace complexity - O(1).\\n*/\\n\\nclass Solution\\n{\\npublic:\\n    bool isPalindrome(string s)\\n    {\\n        int i = 0, j = s.size() - 1;\\n\\n        while (i < j)\\n        {\\n            if (s[i++] != s[j--])\\n                return false;\\n        }\\n        return true;\\n    }\\n\\n    string longestPalindrome(string s)\\n    {\\n        int n = s.size();\\n        if (n == 0)\\n            return \"\";\\n\\n        if (n == 1)\\n            return s;\\n\\n        string result = \"\";\\n        for (int i = 0; i < n - 1; i++)\\n        {\\n            for (int j = 1; j <= n - i; j++)\\n            {\\n                if (isPalindrome(s.substr(i, j)))\\n                {\\n                    if (result.size() < j)\\n                        result = s.substr(i, j);\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n};\\n\\n/*\\nAbove Solution Give TLE....\\n\\nHow Can we optimise our code?\\n\\nGot it in above solution, we do unnecessary recompution while validating palindomes.\\nFor example : if we know string \"aba\" is palindrome then \"cabac\" must be palindrome as left and right are equal.\\n\\nSolution 2: Using DP\\n\\nP(i, j) == P(i+1, j-1) && s[i] == s[j];\\n\\nBase cases :\\n\\n//One character\\nP(i, i) = true;\\n\\n//Two character\\nP(i, i+1) = s[i] == s[i+1];\\n\\nTime Complexity - O(N^2), Space Complexity - O(N^2) (caching all substring)\\n*/\\n\\nclass Solution\\n{\\npublic:\\n    string longestPalindrome(string s)\\n    {\\n        int n = s.size();\\n        if (n == 0)\\n            return \"\";\\n\\n        // dp[i][j] will be \\'true\\' if the string from index i to j is a palindrome.\\n        bool dp[n][n];\\n\\n        //Initialize with false\\n\\n        memset(dp, 0, sizeof(dp));\\n\\n        //Every Single character is palindrome\\n        for (int i = 0; i < n; i++)\\n            dp[i][i] = true;\\n\\n        string ans = \"\";\\n        ans += s[0];\\n\\n        for (int i = n - 1; i >= 0; i--)\\n        {\\n            for (int j = i + 1; j < n; j++)\\n            {\\n                if (s[i] == s[j])\\n                {\\n                    //If it is of two character OR if its susbtring is palindrome.\\n                    if (j - i == 1 || dp[i + 1][j - 1])\\n                    {\\n                        //Then it will also a palindrome substring\\n                        dp[i][j] = true;\\n\\n                        //Check for Longest Palindrome substring\\n                        if (ans.size() < j - i + 1)\\n                            ans = s.substr(i, j - i + 1);\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2923,
                "title": "simple-c-solution-8ms-13-lines",
                "content": "    string longestPalindrome(string s) {\\n        if (s.empty()) return \"\";\\n        if (s.size() == 1) return s;\\n        int min_start = 0, max_len = 1;\\n        for (int i = 0; i < s.size();) {\\n          if (s.size() - i <= max_len / 2) break;\\n          int j = i, k = i;\\n          while (k < s.size()-1 && s[k+1] == s[k]) ++k; // Skip duplicate characters.\\n          i = k+1;\\n          while (k < s.size()-1 && j > 0 && s[k + 1] == s[j - 1]) { ++k; --j; } // Expand.\\n          int new_len = k - j + 1;\\n          if (new_len > max_len) { min_start = j; max_len = new_len; }\\n        }\\n        return s.substr(min_start, max_len);\\n    }",
                "solutionTags": [],
                "code": "    string longestPalindrome(string s) {\\n        if (s.empty()) return \"\";\\n        if (s.size() == 1) return s;\\n        int min_start = 0, max_len = 1;\\n        for (int i = 0; i < s.size();) {\\n          if (s.size() - i <= max_len / 2) break;\\n          int j = i, k = i;\\n          while (k < s.size()-1 && s[k+1] == s[k]) ++k; // Skip duplicate characters.\\n          i = k+1;\\n          while (k < s.size()-1 && j > 0 && s[k + 1] == s[j - 1]) { ++k; --j; } // Expand.\\n          int new_len = k - j + 1;\\n          if (new_len > max_len) { min_start = j; max_len = new_len; }\\n        }\\n        return s.substr(min_start, max_len);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3401644,
                "title": "detailed-recursive-explaination-with-pictures-in-c-java-python-dp-two-pointers",
                "content": "# Approach\\n[![LPS0.png](https://assets.leetcode.com/users/images/8e1ed821-5202-4801-9654-396e22b3f4ff_1681148824.1879745.png)]()\\n\\n\\n\\n\\n\\n>The only tricky thing is that you have to be sure the right substring is returned in `expand()`. The loop ends only after expanding the range by 1 on both sides, so you have to remove those in the final returned string.\\n\\n>Here we basically choose each centre and try expanding from each and every specific node thus we call expand functionas `expand(i,i)` and `expand(i,i+1)` and later we apply two pointers on each node to find the longest palindrome \\n\\n\\n\\n\\n\\n\\n![LPS.png](https://assets.leetcode.com/users/images/775649b0-d6f7-4648-9d87-24d2f5dc4ccf_1681148838.335889.png)\\n\\n\\n\\n\\n\\n> In fact, we could solve it in $$O(n^2)$$ time using only constant space.\\n\\nWe observe that a palindrome mirrors around its center. Therefore, a palindrome can be expanded from its center, and there are only $$2n\\u22121$$  such centers.\\n\\nYou might be asking why there are $$2n - 1$$ but not $$n$$ centers? The reason is the center of a palindrome can be in between two letters. Such palindromes have even number of letters (such as \"abba\") and its center are between the two \\'b\\'s.\\n\\n\\n---\\n\\n# Code\\n\\n```C++ []\\nclass Solution {\\npublic:\\n    string ans = \"\";\\n    void expand(string &s , int left ,int right)\\n    {\\n        while(left >= 0 &&  right < s.size())\\n        {\\n            if(s[left] != s[right])\\n                break;\\n            left--,right++;\\n        }\\n        if(ans.size() < right - left )\\n            ans = s.substr(left + 1 , right - left - 1);\\n    }\\n    string longestPalindrome(string s) {\\n        for(int i = 0 ; i < s.size() ; i++)\\n        {\\n            expand(s , i , i);\\n            expand(s , i , i+1);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n```java []\\nclass Solution {\\n    int maxLen = 0;\\n    int lo = 0;\\n    public String longestPalindrome(String s) {\\n        char[] input = s.toCharArray();\\n        if(s.length() < 2) {\\n            return s;\\n        }\\n        \\n        for(int i = 0; i<input.length; i++) {\\n            expandPalindrome(input, i, i);\\n            expandPalindrome(input, i, i+1);\\n        }\\n        return s.substring(lo, lo+maxLen);\\n    }\\n    \\n    public void expandPalindrome(char[] s, int j, int k) {\\n        while(j >= 0 && k < s.length && s[j] == s[k]) {\\n            j--;\\n            k++;\\n        }\\n        if(maxLen < k - j - 1) {\\n            maxLen = k - j - 1;\\n            lo = j+1;\\n        }\\n    }\\n}\\n```\\n```python []\\nclass Solution:\\n    def longestPalindrome(self, s: str) -> str:\\n        ans=\\'\\'\\n        for i in range(len(s)):\\n            ans=max(ans,expand(s,i,i), expand(s,i,i+1), key=len)\\n        return ans\\n            \\ndef expand(s,i,j):\\n    while i>=0 and j<len(s) and s[i]==s[j]:\\n        i-=1\\n        j+=1\\n    return s[i+1:j]\\n```\\n```c []\\nint maxVal(int a, int b) {\\n    return a > b ? a : b;\\n}\\n\\nint extend(char *s, int start, int end) {\\n    int len = strlen(s);\\n    for(; start >= 0 && end < len; start--, end++) {\\n        if(*(s + start) != *(s + end))\\n            break;\\n    }\\n    return end - start - 1;\\n}\\n\\nchar * longestPalindrome(char * s){\\n    int max = 0, idx = 0, len = strlen(s);\\n    for(int i = 0; i < len; i++) {\\n        int len1 = extend(s, i, i);       /* For even string */\\n        int len2 = extend(s, i, i + 1);   /* For odd string  */\\n        if (max < maxVal(len1, len2)) {\\n            idx = (len1 > len2) ? (i - len1 / 2) : (i - len2 / 2 + 1);\\n            max = maxVal(len1, len2);\\n        }\\n    }\\n    char *res = malloc((max+1) *sizeof(char));\\n    memcpy(res, &s[idx], max);\\n    res[max] = \\'\\\\0\\';\\n    return res;\\n}\\n```\\n---\\n# Complexity\\n> **Time Complexity:** $$O(n^2)$$ as there is two recursion calls which are applied as two pointers so here Complexity would be$$ O(n^2).$$\\n\\n> **Space Complexity:** $$O(n)$$ which is nothing but the storage consumed in this process.\\n\\n---\\n**IF YOU LIKE THE SOLUTION THEN PLEASE UPVOTE MY SOLUTION BECAUSE IT GIVES ME MOTIVATION TO REGULARLY POST THE SOLUTION.**\\n\\n![UPVOTE.jpg](https://assets.leetcode.com/users/images/10486881-da0f-461b-911c-7ddd2e060d99_1681148844.162226.jpeg)\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    string ans = \"\";\\n    void expand(string &s , int left ,int right)\\n    {\\n        while(left >= 0 &&  right < s.size())\\n        {\\n            if(s[left] != s[right])\\n                break;\\n            left--,right++;\\n        }\\n        if(ans.size() < right - left )\\n            ans = s.substr(left + 1 , right - left - 1);\\n    }\\n    string longestPalindrome(string s) {\\n        for(int i = 0 ; i < s.size() ; i++)\\n        {\\n            expand(s , i , i);\\n            expand(s , i , i+1);\\n        }\\n        return ans;\\n    }\\n};\\n```\n```java []\\nclass Solution {\\n    int maxLen = 0;\\n    int lo = 0;\\n    public String longestPalindrome(String s) {\\n        char[] input = s.toCharArray();\\n        if(s.length() < 2) {\\n            return s;\\n        }\\n        \\n        for(int i = 0; i<input.length; i++) {\\n            expandPalindrome(input, i, i);\\n            expandPalindrome(input, i, i+1);\\n        }\\n        return s.substring(lo, lo+maxLen);\\n    }\\n    \\n    public void expandPalindrome(char[] s, int j, int k) {\\n        while(j >= 0 && k < s.length && s[j] == s[k]) {\\n            j--;\\n            k++;\\n        }\\n        if(maxLen < k - j - 1) {\\n            maxLen = k - j - 1;\\n            lo = j+1;\\n        }\\n    }\\n}\\n```\n```python []\\nclass Solution:\\n    def longestPalindrome(self, s: str) -> str:\\n        ans=\\'\\'\\n        for i in range(len(s)):\\n            ans=max(ans,expand(s,i,i), expand(s,i,i+1), key=len)\\n        return ans\\n            \\ndef expand(s,i,j):\\n    while i>=0 and j<len(s) and s[i]==s[j]:\\n        i-=1\\n        j+=1\\n    return s[i+1:j]\\n```\n```c []\\nint maxVal(int a, int b) {\\n    return a > b ? a : b;\\n}\\n\\nint extend(char *s, int start, int end) {\\n    int len = strlen(s);\\n    for(; start >= 0 && end < len; start--, end++) {\\n        if(*(s + start) != *(s + end))\\n            break;\\n    }\\n    return end - start - 1;\\n}\\n\\nchar * longestPalindrome(char * s){\\n    int max = 0, idx = 0, len = strlen(s);\\n    for(int i = 0; i < len; i++) {\\n        int len1 = extend(s, i, i);       /* For even string */\\n        int len2 = extend(s, i, i + 1);   /* For odd string  */\\n        if (max < maxVal(len1, len2)) {\\n            idx = (len1 > len2) ? (i - len1 / 2) : (i - len2 / 2 + 1);\\n            max = maxVal(len1, len2);\\n        }\\n    }\\n    char *res = malloc((max+1) *sizeof(char));\\n    memcpy(res, &s[idx], max);\\n    res[max] = \\'\\\\0\\';\\n    return res;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 147548,
                "title": "direct-c-dp",
                "content": "My code is based on the solution Approach3.\\n\\nFirst initialize a matrix P, which is used to store if the substring is palindromic. Now we should fill the block of \"S(i) = S(i)\" and \"S(i) = S(i+1)\", the basic case that **we can\\'t find any substring in it**. Then with this matrix, we can decide if a string is palindromic by if **its substring is palindromic** and if **its start letter equals end letter**.\\n\\nThe image below is a matrix for string \"abbc\". For example, start with the first \"b\" and end with \"c\" tells if substring \"bbc\" is palindromic. What we need to do next is filling the \"??\" block, only half of the matrix is used.\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/rongxiantian/image_1531322500.png)\\n\\nAfter initialization, we can decide if a string is palindromic by its substring and newly added letters, shown below.\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/rongxiantian/image_1531321812.png)\\nIf we want to decide the block pointed by the arrow(\\\\\"abb\\\\\"), we should look up [b,b], which is substring \"b\", and see if (\"a\"==\"b\"). As shown, \"a\"!=\"b\", so \"abb\" is not palindromic. \\n\\nAfter that, it seems like this:\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/rongxiantian/image_1531322028.png)\\n\\nLast, we have got this matrix, but we still need to find which is the longest palindromic substring.\\nMy method is only traversing it, return the longest substring. So the result in this example is \"bb\".\\n```\\nclass Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n        if(s.size()==0) return \"\";\\n        int i = 0, j = 0;\\n        int n = s.size();\\n        //initialize P[n][n], we only need half of P, and initialize it like: (e.g. : s=\"abbc\")\\n        bool P[n][n]={false};\\n        for(int x = 0;x<n;x++){\\n            P[x][x]=true;\\n            if(x==n-1) break;\\n            P[x][x+1] = (s[x]==s[x+1]);\\n        }\\n        //dp \\n        for(int i = n-3; i>=0; --i){\\n            for(int j = i+2;j<n; ++j){\\n                P[i][j] = (P[i+1][j-1] && s[i]==s[j]);     \\n            }\\n        }\\n        //get maxstr result\\n        int max = 0;\\n        string maxstr = \"\";\\n        for(int i=0;i<n;i++){\\n            for(int j=i;j<n;j++){\\n                if(P[i][j]==true and j-i+1>max){\\n                    max = j-i+1;\\n                    maxstr = s.substr(i,j-i+1);\\n                }\\n            }\\n        }\\n        return maxstr;\\n    }\\n};```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n        if(s.size()==0) return \"\";\\n        int i = 0, j = 0;\\n        int n = s.size();\\n        //initialize P[n][n], we only need half of P, and initialize it like: (e.g. : s=\"abbc\")\\n        bool P[n][n]={false};\\n        for(int x = 0;x<n;x++){\\n            P[x][x]=true;\\n            if(x==n-1) break;\\n            P[x][x+1] = (s[x]==s[x+1]);\\n        }\\n        //dp \\n        for(int i = n-3; i>=0; --i){\\n            for(int j = i+2;j<n; ++j){\\n                P[i][j] = (P[i+1][j-1] && s[i]==s[j]);     \\n            }\\n        }\\n        //get maxstr result\\n        int max = 0;\\n        string maxstr = \"\";\\n        for(int i=0;i<n;i++){\\n            for(int j=i;j<n;j++){\\n                if(P[i][j]==true and j-i+1>max){\\n                    max = j-i+1;\\n                    maxstr = s.substr(i,j-i+1);\\n                }\\n            }\\n        }\\n        return maxstr;\\n    }\\n};```",
                "codeTag": "Java"
            },
            {
                "id": 474664,
                "title": "commented-clean-python-dp-solution",
                "content": "```\\nclass Solution:\\n    def longestPalindrome(self, s: str) -> str:\\n        \\n        n = len(s)\\n        # Form a bottom-up dp 2d array\\n        # dp[i][j] will be \\'true\\' if the string from index i to j is a palindrome. \\n        dp = [[False] * n  for _ in range(n)]\\n        \\n        ans = \\'\\'\\n        # every string with one character is a palindrome\\n        for i in range(n):\\n            dp[i][i] = True\\n            ans = s[i]\\n            \\n        maxLen = 1\\n        for start in range(n-1, -1, -1):\\n            for end in range(start+1, n):             \\n\\t\\t\\t\\t# palindrome condition\\n                if s[start] == s[end]:\\n                    # if it\\'s a two char. string or if the remaining string is a palindrome too\\n                    if end - start == 1 or dp[start+1][end-1]:\\n                        dp[start][end] = True\\n                        if maxLen < end - start + 1:\\n                            maxLen = end - start + 1\\n                            ans = s[start: end+ 1]\\n        \\n        return ans\\n```\\nIf this solution helps you, don\\'t forget to upvote it.",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def longestPalindrome(self, s: str) -> str:\\n        \\n        n = len(s)\\n        # Form a bottom-up dp 2d array\\n        # dp[i][j] will be \\'true\\' if the string from index i to j is a palindrome. \\n        dp = [[False] * n  for _ in range(n)]\\n        \\n        ans = \\'\\'\\n        # every string with one character is a palindrome\\n        for i in range(n):\\n            dp[i][i] = True\\n            ans = s[i]\\n            \\n        maxLen = 1\\n        for start in range(n-1, -1, -1):\\n            for end in range(start+1, n):             \\n\\t\\t\\t\\t# palindrome condition\\n                if s[start] == s[end]:\\n                    # if it\\'s a two char. string or if the remaining string is a palindrome too\\n                    if end - start == 1 or dp[start+1][end-1]:\\n                        dp[start][end] = True\\n                        if maxLen < end - start + 1:\\n                            maxLen = end - start + 1\\n                            ans = s[start: end+ 1]\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2925,
                "title": "python-o-n-2-method-with-some-optimization-88ms",
                "content": "Basic thought is simple.  when you increase s by 1 character, you could only increase maxPalindromeLen by 1 or 2, and that new maxPalindrome includes this new character.  Proof: if on adding 1 character, maxPalindromeLen increased by 3 or more, say the new maxPalindromeLen  is Q, and the old maxPalindromeLen  is P, and Q>=P+3. Then it would mean, even without this new character, there would be a palindromic substring ending in the last character, whose length is at least Q-2. Since Q-2 would be >P, this contradicts the condition that P is the maxPalindromeLen without the additional character.\\n\\nSo, it becomes simple, you only need to scan from beginning to the end, adding one character at a time, keeping track of maxPalindromeLen, and for each added character, you check if the substrings ending with this new character, with length P+1 or P+2, are palindromes, and update accordingly.\\n\\nNow, this is O(n^2) as taking substrings and checking palindromicity seem O(n) time.  We can speed up it by realizing that strings are immutable, and there are memory slicing tricks will help to speed these operations up.  comparing string equality with \"==\" is O(1), and using slicing to substring and reverse is  \\u0336a\\u0336l\\u0336s\\u0336o\\u0336 \\u0336O\\u0336(\\u03361\\u0336)\\u0336 \\u0336(\\u0336n\\u0336o\\u0336t\\u0336 \\u0336t\\u0336o\\u0336t\\u0336a\\u0336l\\u0336l\\u0336y\\u0336 \\u0336s\\u0336u\\u0336r\\u0336e\\u0336 \\u0336a\\u0336b\\u0336o\\u0336u\\u0336t\\u0336 \\u0336t\\u0336h\\u0336e\\u0336 \\u0336s\\u0336l\\u0336i\\u0336c\\u0336i\\u0336n\\u0336g\\u0336 \\u0336t\\u0336h\\u0336o\\u0336u\\u0336g\\u0336h\\u0336.\\u0336 \\u0336 \\u0336I\\u0336 \\u0336t\\u0336h\\u0336i\\u0336n\\u0336k\\u0336 \\u0336i\\u0336t\\u0336 \\u0336i\\u0336s\\u0336 \\u0336O\\u0336(\\u03361\\u0336)\\u0336,\\u0336 \\u0336b\\u0336u\\u0336t\\u0336 \\u0336c\\u0336o\\u0336u\\u0336l\\u0336d\\u0336 \\u0336n\\u0336o\\u0336t\\u0336 \\u0336f\\u0336i\\u0336n\\u0336d\\u0336 \\u0336a\\u0336n\\u0336y\\u0336 \\u0336s\\u0336o\\u0336l\\u0336i\\u0336d\\u0336 \\u0336l\\u0336i\\u0336t\\u0336e\\u0336r\\u0336a\\u0336t\\u0336u\\u0336r\\u0336e\\u0336 \\u0336a\\u0336b\\u0336o\\u0336u\\u0336t\\u0336 \\u0336i\\u0336t\\u0336.\\u0336   O(n) (thanks to ChuntaoLu).  But as slicing is optimized by the interpreter's C code, it should run pretty fast.  I'm pretty new to Python.  Would appreciate you would give more insights or further optimization.\\n\\nThus, here is the O(n) method:\\n\\n\\tclass Solution:\\n\\t    # @return a string\\n\\t    def longestPalindrome(self, s):\\n\\t        if len(s)==0:\\n\\t        \\treturn 0\\n\\t        maxLen=1\\n\\t        start=0\\n\\t        for i in xrange(len(s)):\\n\\t        \\tif i-maxLen >=1 and s[i-maxLen-1:i+1]==s[i-maxLen-1:i+1][::-1]:\\n\\t        \\t\\tstart=i-maxLen-1\\n\\t        \\t\\tmaxLen+=2\\n\\t        \\t\\tcontinue\\n\\n\\t        \\tif i-maxLen >=0 and s[i-maxLen:i+1]==s[i-maxLen:i+1][::-1]:\\n\\t        \\t\\tstart=i-maxLen\\n\\t        \\t\\tmaxLen+=1\\n\\t        return s[start:start+maxLen]",
                "solutionTags": [],
                "code": "Basic thought is simple.  when you increase s by 1 character, you could only increase maxPalindromeLen by 1 or 2, and that new maxPalindrome includes this new character.  Proof: if on adding 1 character, maxPalindromeLen increased by 3 or more, say the new maxPalindromeLen  is Q, and the old maxPalindromeLen  is P, and Q>=P+3. Then it would mean, even without this new character, there would be a palindromic substring ending in the last character, whose length is at least Q-2. Since Q-2 would be >P, this contradicts the condition that P is the maxPalindromeLen without the additional character.\\n\\nSo, it becomes simple, you only need to scan from beginning to the end, adding one character at a time, keeping track of maxPalindromeLen, and for each added character, you check if the substrings ending with this new character, with length P+1 or P+2, are palindromes, and update accordingly.\\n\\nNow, this is O(n^2) as taking substrings and checking palindromicity seem O(n) time.  We can speed up it by realizing that strings are immutable, and there are memory slicing tricks will help to speed these operations up.  comparing string equality with \"==\" is O(1), and using slicing to substring and reverse is  \\u0336a\\u0336l\\u0336s\\u0336o\\u0336 \\u0336O\\u0336(\\u03361\\u0336)\\u0336 \\u0336(\\u0336n\\u0336o\\u0336t\\u0336 \\u0336t\\u0336o\\u0336t\\u0336a\\u0336l\\u0336l\\u0336y\\u0336 \\u0336s\\u0336u\\u0336r\\u0336e\\u0336 \\u0336a\\u0336b\\u0336o\\u0336u\\u0336t\\u0336 \\u0336t\\u0336h\\u0336e\\u0336 \\u0336s\\u0336l\\u0336i\\u0336c\\u0336i\\u0336n\\u0336g\\u0336 \\u0336t\\u0336h\\u0336o\\u0336u\\u0336g\\u0336h\\u0336.\\u0336 \\u0336 \\u0336I\\u0336 \\u0336t\\u0336h\\u0336i\\u0336n\\u0336k\\u0336 \\u0336i\\u0336t\\u0336 \\u0336i\\u0336s\\u0336 \\u0336O\\u0336(\\u03361\\u0336)\\u0336,\\u0336 \\u0336b\\u0336u\\u0336t\\u0336 \\u0336c\\u0336o\\u0336u\\u0336l\\u0336d\\u0336 \\u0336n\\u0336o\\u0336t\\u0336 \\u0336f\\u0336i\\u0336n\\u0336d\\u0336 \\u0336a\\u0336n\\u0336y\\u0336 \\u0336s\\u0336o\\u0336l\\u0336i\\u0336d\\u0336 \\u0336l\\u0336i\\u0336t\\u0336e\\u0336r\\u0336a\\u0336t\\u0336u\\u0336r\\u0336e\\u0336 \\u0336a\\u0336b\\u0336o\\u0336u\\u0336t\\u0336 \\u0336i\\u0336t\\u0336.\\u0336   O(n) (thanks to ChuntaoLu).  But as slicing is optimized by the interpreter's C code, it should run pretty fast.  I'm pretty new to Python.  Would appreciate you would give more insights or further optimization.\\n\\nThus, here is the O(n) method:\\n\\n\\tclass Solution:\\n\\t    # @return a string\\n\\t    def longestPalindrome(self, s):\\n\\t        if len(s)==0:\\n\\t        \\treturn 0\\n\\t        maxLen=1\\n\\t        start=0\\n\\t        for i in xrange(len(s)):\\n\\t        \\tif i-maxLen >=1 and s[i-maxLen-1:i+1]==s[i-maxLen-1:i+1][::-1]:\\n\\t        \\t\\tstart=i-maxLen-1\\n\\t        \\t\\tmaxLen+=2\\n\\t        \\t\\tcontinue\\n\\n\\t        \\tif i-maxLen >=0 and s[i-maxLen:i+1]==s[i-maxLen:i+1][::-1]:\\n\\t        \\t\\tstart=i-maxLen\\n\\t        \\t\\tmaxLen+=1\\n\\t        return s[start:start+maxLen]",
                "codeTag": "Java"
            },
            {
                "id": 1125024,
                "title": "detailed-analysis-and-explanation",
                "content": "I had trouble understanding this question, as I am not much good when it comes to DP, and also because no solution offered enough explanation for DP newbies, so here I am going to try my best to explain it in detail.\\n\\n**Question Interpretation:** To solve a question , we first have to understand it! \\nHere we are being asked to calculate longest substring which is a Palindrome(Palindrome is a string which is read same forwards and backwards), among all the Palindromes that exist!!\\n\\n**Intuition:** Now, we can solve this question in two ways that come at first glance:\\n* Use `Brute Force` : Check for every corresponding element in string the longest palindrome possible and do it till the end.\\n* `DP`: Since we are essentially looping over every element in `Brute Force`, maybe we can somehow use the result from our previous iteration to simplify the current one, right?? This gives us a nudge to look for a pattern and hence we go for DP.\\n\\n**Analysis:**\\nLets see both the approaches one by one !!!\\n\\n1.)`Brute Force:` Instead of directly going to code and finding a problem later, lets stop and think about the concept we intend to use here .\\n\\n*Concept:* We will go through **all** possible element in string and find the longest palindrome amongst them.\\n\\n*Review:* To calculate **all** the possible substrings in a string of length `n` ,number of combinations generated are:\\n`1+2+3+4+..........n`=`n(n-1)/2`. \\n`==>` To check all the substrings for Palindrome, we will have to go through **all the `n` characters**\\n`==>` **Total** Combinations: `n*n(n-1)/2`= `O(n^3)`\\n\\n*Conclusion:* Since the time complexity is `O(n^3)`, hence we will not discuss on this approach, and our energy would be better spent looking at `DP` solution .\\n\\n2.)`DP:` Instead of going through all the previous Palindromes again and again, how about we save them somewhere and calculate the new ones based on them, but how do we d that? Lets see it below \\n \\n*Concept:* To check a Palindrome of length ,say `l`,  we just have to check if \\ni.) `s[first character]==s[last character]`\\nii.) `s[first character+1, last charcter -1]` is a Palindrome\\n\\nFor example : say s=\" balab\"\\nNow, to check , if \"s\" is Palindrome or not, we just have to look at\\ni.) `s[first character]==s[last character]` -> b==b -> True\\nii.)`s[first character+1, last charcter -1]` is a Palindrome --> \"aba\" is a Palindrome??\\nTo check for \"aba\", a==a--> True , and \"b\" is a Palindrome(of length 1)\\n==> `s` is a Plaindrome\\n\\n*Review:* We will make a table `dp` containing if the string from `left` to `right` is a Pal. or not, and to do that, we will fill in the table with `1` or `0`.\\nLets look at an example of how the table looks like for `s:\"geeks\"`\\n![image](https://assets.leetcode.com/users/images/cccbc507-96ac-45d8-a3fb-9658fc007fc7_1616569419.1798341.png)\\n\\nFor `s:geeks:` \\n`dp[i][i]`=1, as single letters are always Palindromes\\n`dp[1][2]` : string from starting position 1 to ending position 2 are Pal. or not (since \"ee\" is, hence we fill the table with \"1\") \\nand likewise for others.\\n\\nThis reduces our time from `O(n^3)` to `O(n^2)` as we dont have to check every possible combination now, instead we can directly check the value being 1 or 0.\\n\\n**Code:**\\n```\\nclass Solution {\\npublic:\\n     string longestPalindrome(string s) \\n{   \\n    int len = s.size();\\n    int dp[len][len];\\n    memset(dp,0,sizeof(dp));\\n    int end=1;\\n    int start=0;\\n\\t\\n    for(int i=0;i<len;i++)\\n    {\\n        dp[i][i] = 1;\\n    }\\n    for(int i=0;i<len-1;i++)\\n    {\\n        if(s[i]==s[i+1])\\n        { dp[i][i+1]=1;start=i;end=2;}\\n    }\\n    \\n    for(int j=2;j<len;j++)\\n    {\\n        for(int i=0;i< len-j;i++)\\n        {  \\n            int left=i; //start point\\n            int right = i+j;  //ending point\\n            \\n            if(dp[left+1][right-1]==1 && s[left]==s[right]) \\n            {\\n                dp[left][right]=1; start=i; end=j+1; \\n            }        \\n        }\\n    }\\n   return s.substr(start, end);\\n}\\n};\\n```\\n\\nIf you liked this post, please **UPVOTE** \\nHappy coding :))",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n     string longestPalindrome(string s) \\n{   \\n    int len = s.size();\\n    int dp[len][len];\\n    memset(dp,0,sizeof(dp));\\n    int end=1;\\n    int start=0;\\n\\t\\n    for(int i=0;i<len;i++)\\n    {\\n        dp[i][i] = 1;\\n    }\\n    for(int i=0;i<len-1;i++)\\n    {\\n        if(s[i]==s[i+1])\\n        { dp[i][i+1]=1;start=i;end=2;}\\n    }\\n    \\n    for(int j=2;j<len;j++)\\n    {\\n        for(int i=0;i< len-j;i++)\\n        {  \\n            int left=i; //start point\\n            int right = i+j;  //ending point\\n            \\n            if(dp[left+1][right-1]==1 && s[left]==s[right]) \\n            {\\n                dp[left][right]=1; start=i; end=j+1; \\n            }        \\n        }\\n    }\\n   return s.substr(start, end);\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3060,
                "title": "ac-relatively-short-and-very-clear-java-solution",
                "content": "**Key idea, every time we move to right, we only need to consider whether using this new character as tail could produce new palindrome string of length (current length +1) or (current length +2)**\\n\\n    public class Solution {\\n        public String longestPalindrome(String s) {\\n            String res = \"\";\\n            int currLength = 0;\\n            for(int i=0;i<s.length();i++){\\n                if(isPalindrome(s,i-currLength-1,i)){\\n                    res = s.substring(i-currLength-1,i+1);\\n                    currLength = currLength+2;\\n                }\\n                else if(isPalindrome(s,i-currLength,i)){\\n                    res = s.substring(i-currLength,i+1);\\n                    currLength = currLength+1;\\n                }\\n            }\\n            return res;\\n        }\\n        \\n        public boolean isPalindrome(String s, int begin, int end){\\n            if(begin<0) return false;\\n            while(begin<end){\\n            \\tif(s.charAt(begin++)!=s.charAt(end--)) return false;\\n            }\\n            return true;\\n        }\\n    }\\n\\nFor friends who are confused about the key idea to check only new palindrome with length = current length +2 or +1, I add some more explanation here.\\n\\n    Example: \"xxxbcbxxxxxa\", (x is random character, not all x are equal) now we \\n              are dealing with the last character 'a'. The current longest palindrome\\n              is \"bcb\" with length 3.\\n    1. check \"xxxxa\" so if it is palindrome we could get a new palindrome of length 5.\\n    2. check \"xxxa\" so if it is palindrome we could get a new palindrome of length 4.\\n    3. do NOT check \"xxa\" or any shorter string since the length of the new string is \\n       no bigger than current longest length.\\n    4. do NOT check \"xxxxxa\" or any longer string because if \"xxxxxa\" is palindrome \\n       then \"xxxx\" got  from cutting off the head and tail is also palindrom. It has \\n       length > 3 which is impossible.'",
                "solutionTags": [],
                "code": "class Solution {\\n        public String longestPalindrome(String s) {\\n            String res = \"\";\\n            int currLength = 0;\\n            for(int i=0;i<s.length();i++){\\n                if(isPalindrome(s,i-currLength-1,i)){\\n                    res = s.substring(i-currLength-1,i+1);\\n                    currLength = currLength+2;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 650496,
                "title": "all-approaches-code-in-java-including-manacher-s-algorithm-explanation",
                "content": "# Approach 1: Longest Common Substring\\nBased on dynamic programming.\\n```java\\nclass Solution {\\n    public String longestPalindrome(String s) {\\n        int len = s.length();\\n\\n        if (len == 0) {\\n            return \"\";\\n        }\\n\\n        char[] sChars = s.toCharArray();\\n\\n        /*\\n         * length of common string found\\n         * set dp[i][j] to 0 if s[i - 1] != s[j];\\n         */\\n        int[][] dp = new int[2][len + 1];\\n        int currRow = 0;\\n        int maxLen = 0;\\n        int start = 0;\\n\\n        /*\\n         * find longest common string between s and s\\' (reversed s)\\n         * for orginal string, from sChars[0] to sChars[len - 1]\\n         * for reversed view, from sChars[len - 1] to sChars[0];\\n         */\\n        for (int i = 0; i <= len; i++) {\\n            for (int j = len; j >= 0; j--) {\\n                if (i == 0 || j == len) {\\n                    dp[currRow][j] = 0;\\n                } else if (sChars[i - 1] == sChars[j]) {\\n                    dp[currRow][j] = dp[1 - currRow][j + 1] + 1;\\n                    int currLen = dp[currRow][j];\\n\\n                    /*\\n                     * 1. longest common substring length\\n                     * 2. skip those common substrings doesn\\'t \"produced\" by reverse.\\n                     */\\n                    if (i - 1 == j + currLen - 1 && i - currLen == j && currLen > maxLen) {\\n                        start = j;\\n                        maxLen = currLen;\\n                    }\\n                } else {\\n                    dp[currRow][j] = 0;\\n                }\\n            }\\n\\n            // * switch the working row of dp[][] to the next row (i)\\n            currRow = 1 - currRow;\\n        }\\n\\n        return s.substring(start, start + maxLen);\\n    }\\n}\\n```\\n**Space Complexity: O(n)**\\n\\n---\\n\\n# Approach 2: Brute Force (962ms)\\n```java\\nclass Solution {\\n    public String longestPalindrome(String s) {\\n        char[] charArray = s.toCharArray();\\n        int start = 0;\\n        int maxLen = 0;\\n        for (int i = 0; i < charArray.length; i++) {\\n            for (int len = 0; i + len < charArray.length; len++) {\\n                if (isPalindrome(charArray, i, len) && len + 1 > maxLen) {\\n                    maxLen = len + 1;\\n                    start = i;\\n                }\\n            }\\n        }\\n\\n        return s.substring(start, start + maxLen);\\n    }\\n\\n    public boolean isPalindrome(char[] charArray, int start, int len) {\\n        while (len > 0) {\\n            if (charArray[start] != charArray[start + len]) {\\n                return false;\\n            }\\n\\n            start++;\\n            len -= 2;\\n        }\\n\\n        return true;\\n    }\\n}\\n```\\n\\n---\\n# Approach 3: Dynamic Programming\\n![image](https://assets.leetcode.com/users/guangxuli/image_1590367788.png)\\n\\n![image](https://assets.leetcode.com/users/guangxuli/image_1590369367.png)\\n\\n```java\\nclass Solution {\\n    public String longestPalindrome(String s) {\\n        char[] sChars = s.toCharArray();\\n\\n        int m = s.length();\\n\\n        // * dp[i][len + 1] means substring starting from i with length of len;\\n        boolean[][] dp = new boolean[m][2];\\n        int currCol = 0;\\n\\n        int maxLen = 0;\\n        int ans = 0; // record start index of s\\n\\n        for (int len = 0; len < m; len++) {\\n            for (int start = 0; start + len < m; start++) {\\n                int end = start + len;\\n                if (len == 0) {\\n                    dp[start][currCol] = true;\\n                } else if (len == 1) {\\n                    dp[start][currCol] = (sChars[start] == sChars[end]);\\n                } else {\\n                    dp[start][currCol] = (sChars[start] == sChars[end] && dp[start + 1][currCol]);\\n                }\\n\\n                if (dp[start][currCol] && len + 1 > maxLen) {\\n                    ans = start;\\n                    maxLen = len + 1;\\n                }\\n            }\\n\\n            currCol = 1 - currCol;\\n        }\\n\\n        return maxLen == 0 ? \"\" : s.substring(ans, ans + maxLen);\\n    }\\n}\\n```\\n\\n**Space complexity: O(n).** It uses **O(2n)** space to store the table.\\n\\n---\\n# Approach 4: Expand Around Center\\n```java\\nclass Solution {\\n    public String longestPalindrome(String s) {\\n        if (s.length() == 0) {\\n            return \"\";\\n        }\\n\\n        char[] sChars = s.toCharArray();\\n\\n        int start = 0;\\n        int end = 0;\\n\\n        for (int i = 0; i < sChars.length; i++) {\\n            int len = Math.max(expand(sChars, i, i), expand(sChars, i, i + 1));\\n\\n            if (len > end - start + 1) {\\n                start = i - (len - 1) / 2;\\n                end = i + len / 2;\\n            }\\n        }\\n\\n        return s.substring(start, end + 1);\\n    }\\n\\n    public int expand(char[] sChars, int i, int j) {\\n        while (i >= 0 && j < sChars.length && sChars[i] == sChars[j]) {\\n            i--;\\n            j++;\\n        }\\n        return j - i - 1;\\n    }\\n}\\n```\\n\\n---\\n# Approach 5: Manacher\\'s Algorithm\\n## **!!!Based on the solution video on [leetcode-cn.com](https://leetcode-cn.com/problems/longest-palindromic-substring/solution/zui-chang-hui-wen-zi-chuan-by-leetcode-solution/)**\\n## **The copyright belongs to the original author**\\nIn **Approach 4**, we do lots of comparisons which is unnecessary. Manacher\\'s algorithm achieves the time complexity O(n) by skip the unnecessary comparisons.\\n**e.g.**\\n![image](https://assets.leetcode.com/users/guangxuli/image_1590367962.png)\\n\\nFor indice **8** which is **a**, we don\\'t need to do the `expandAroundCenter` since we have learned from indice **2**, that the expand length is 0. And to make it true, the indice **8** and indice **2** should be in the **same palindrome**. Meanwhile they have the **same distance** to the center of the palindrome.\\n\\n***We could divide the problem into several cases.***\\np[i] means the expand length of substring with the center of indice i .\\n`[a, a, b, c, b, a, d] => p[3] = 2`\\n\\n**1. `i + p[mirror] < maxRight`**\\n![image](https://assets.leetcode.com/users/guangxuli/image_1590368349.png)\\n**2. `i + p[mirror] == maxRight`**\\n![image](https://assets.leetcode.com/users/guangxuli/image_1590368448.png)\\n**3. `i + p[mirror] > maxRight`**\\n![image](https://assets.leetcode.com/users/guangxuli/image_1590368458.png)\\n```java\\nif i >= maxRight\\n    expand the substring with the center of i\\nelse if i + p[mirror] < maxRight\\n    p[i] = p[mirror]\\nelse if i + p[mirror] == maxRight\\n    p[i] = p[mirror] = maxRight - i\\n    expand the substring with the center of i, beginning from maxRight\\nelse\\n    p[i] = maxRight - i\\n```\\n\\n**We actually could make the code more concise:**\\n```java\\nif i < maxRight\\n    p[i] = min(p[mirror], maxRight - i)\\n    \\nexpand substring with center of i, beginning from i + p[i]\\n```\\n\\n*The algorithm only solve the string with **odd** size, so we add **\\'#\\'** to the string to make the size of string **always be odd**.*\\n```java\\nclass Solution {\\n    public String longestPalindrome(String s) {\\n\\n        // code line +8 to line +15\\n        int strLen = 2 * s.length() + 3;\\n        char[] sChars = new char[strLen];\\n\\n        /*\\n         * To ignore special cases at the beginning and end of the array\\n         * \"abc\" -> @ # a # b # c # $\\n         * \"\" -> @#$\\n         * \"a\" -> @ # a # $\\n         */\\n        sChars[0] = \\'@\\';\\n        sChars[strLen - 1] = \\'$\\';\\n        int t = 1;\\n        for (char c : s.toCharArray()) {\\n            sChars[t++] = \\'#\\';\\n            sChars[t++] = c;\\n        }\\n        sChars[t] = \\'#\\';\\n\\n        int maxLen = 0;\\n        int start = 0;\\n        int maxRight = 0;\\n        int center = 0;\\n        int[] p = new int[strLen]; // i\\'s radius, which not includes i\\n        for (int i = 1; i < strLen - 1; i++) {\\n            if (i < maxRight) {\\n                p[i] = Math.min(maxRight - i, p[2 * center - i]);\\n            }\\n\\n            // expand center\\n            while (sChars[i + p[i] + 1] == sChars[i - p[i] - 1]) {\\n                p[i]++;\\n            }\\n\\n            // update center and its bound\\n            if (i + p[i] > maxRight) {\\n                center = i;\\n                maxRight = i + p[i];\\n            }\\n\\n            // update ans\\n            if (p[i] > maxLen) {\\n                start = (i - p[i] - 1) / 2;\\n                maxLen = p[i];\\n            }\\n        }\\n\\n        return s.substring(start, start + maxLen);\\n    }\\n}\\n```\\n\\n**Time complexity: O(n)**\\n**Space complexity: O(n)** We need **O(n)** space to form **p[i]**.",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```java\\nclass Solution {\\n    public String longestPalindrome(String s) {\\n        int len = s.length();\\n\\n        if (len == 0) {\\n            return \"\";\\n        }\\n\\n        char[] sChars = s.toCharArray();\\n\\n        /*\\n         * length of common string found\\n         * set dp[i][j] to 0 if s[i - 1] != s[j];\\n         */\\n        int[][] dp = new int[2][len + 1];\\n        int currRow = 0;\\n        int maxLen = 0;\\n        int start = 0;\\n\\n        /*\\n         * find longest common string between s and s\\' (reversed s)\\n         * for orginal string, from sChars[0] to sChars[len - 1]\\n         * for reversed view, from sChars[len - 1] to sChars[0];\\n         */\\n        for (int i = 0; i <= len; i++) {\\n            for (int j = len; j >= 0; j--) {\\n                if (i == 0 || j == len) {\\n                    dp[currRow][j] = 0;\\n                } else if (sChars[i - 1] == sChars[j]) {\\n                    dp[currRow][j] = dp[1 - currRow][j + 1] + 1;\\n                    int currLen = dp[currRow][j];\\n\\n                    /*\\n                     * 1. longest common substring length\\n                     * 2. skip those common substrings doesn\\'t \"produced\" by reverse.\\n                     */\\n                    if (i - 1 == j + currLen - 1 && i - currLen == j && currLen > maxLen) {\\n                        start = j;\\n                        maxLen = currLen;\\n                    }\\n                } else {\\n                    dp[currRow][j] = 0;\\n                }\\n            }\\n\\n            // * switch the working row of dp[][] to the next row (i)\\n            currRow = 1 - currRow;\\n        }\\n\\n        return s.substring(start, start + maxLen);\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public String longestPalindrome(String s) {\\n        char[] charArray = s.toCharArray();\\n        int start = 0;\\n        int maxLen = 0;\\n        for (int i = 0; i < charArray.length; i++) {\\n            for (int len = 0; i + len < charArray.length; len++) {\\n                if (isPalindrome(charArray, i, len) && len + 1 > maxLen) {\\n                    maxLen = len + 1;\\n                    start = i;\\n                }\\n            }\\n        }\\n\\n        return s.substring(start, start + maxLen);\\n    }\\n\\n    public boolean isPalindrome(char[] charArray, int start, int len) {\\n        while (len > 0) {\\n            if (charArray[start] != charArray[start + len]) {\\n                return false;\\n            }\\n\\n            start++;\\n            len -= 2;\\n        }\\n\\n        return true;\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public String longestPalindrome(String s) {\\n        char[] sChars = s.toCharArray();\\n\\n        int m = s.length();\\n\\n        // * dp[i][len + 1] means substring starting from i with length of len;\\n        boolean[][] dp = new boolean[m][2];\\n        int currCol = 0;\\n\\n        int maxLen = 0;\\n        int ans = 0; // record start index of s\\n\\n        for (int len = 0; len < m; len++) {\\n            for (int start = 0; start + len < m; start++) {\\n                int end = start + len;\\n                if (len == 0) {\\n                    dp[start][currCol] = true;\\n                } else if (len == 1) {\\n                    dp[start][currCol] = (sChars[start] == sChars[end]);\\n                } else {\\n                    dp[start][currCol] = (sChars[start] == sChars[end] && dp[start + 1][currCol]);\\n                }\\n\\n                if (dp[start][currCol] && len + 1 > maxLen) {\\n                    ans = start;\\n                    maxLen = len + 1;\\n                }\\n            }\\n\\n            currCol = 1 - currCol;\\n        }\\n\\n        return maxLen == 0 ? \"\" : s.substring(ans, ans + maxLen);\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public String longestPalindrome(String s) {\\n        if (s.length() == 0) {\\n            return \"\";\\n        }\\n\\n        char[] sChars = s.toCharArray();\\n\\n        int start = 0;\\n        int end = 0;\\n\\n        for (int i = 0; i < sChars.length; i++) {\\n            int len = Math.max(expand(sChars, i, i), expand(sChars, i, i + 1));\\n\\n            if (len > end - start + 1) {\\n                start = i - (len - 1) / 2;\\n                end = i + len / 2;\\n            }\\n        }\\n\\n        return s.substring(start, end + 1);\\n    }\\n\\n    public int expand(char[] sChars, int i, int j) {\\n        while (i >= 0 && j < sChars.length && sChars[i] == sChars[j]) {\\n            i--;\\n            j++;\\n        }\\n        return j - i - 1;\\n    }\\n}\\n```\n```java\\nif i >= maxRight\\n    expand the substring with the center of i\\nelse if i + p[mirror] < maxRight\\n    p[i] = p[mirror]\\nelse if i + p[mirror] == maxRight\\n    p[i] = p[mirror] = maxRight - i\\n    expand the substring with the center of i, beginning from maxRight\\nelse\\n    p[i] = maxRight - i\\n```\n```java\\nif i < maxRight\\n    p[i] = min(p[mirror], maxRight - i)\\n    \\nexpand substring with center of i, beginning from i + p[i]\\n```\n```java\\nclass Solution {\\n    public String longestPalindrome(String s) {\\n\\n        // code line +8 to line +15\\n        int strLen = 2 * s.length() + 3;\\n        char[] sChars = new char[strLen];\\n\\n        /*\\n         * To ignore special cases at the beginning and end of the array\\n         * \"abc\" -> @ # a # b # c # $\\n         * \"\" -> @#$\\n         * \"a\" -> @ # a # $\\n         */\\n        sChars[0] = \\'@\\';\\n        sChars[strLen - 1] = \\'$\\';\\n        int t = 1;\\n        for (char c : s.toCharArray()) {\\n            sChars[t++] = \\'#\\';\\n            sChars[t++] = c;\\n        }\\n        sChars[t] = \\'#\\';\\n\\n        int maxLen = 0;\\n        int start = 0;\\n        int maxRight = 0;\\n        int center = 0;\\n        int[] p = new int[strLen]; // i\\'s radius, which not includes i\\n        for (int i = 1; i < strLen - 1; i++) {\\n            if (i < maxRight) {\\n                p[i] = Math.min(maxRight - i, p[2 * center - i]);\\n            }\\n\\n            // expand center\\n            while (sChars[i + p[i] + 1] == sChars[i - p[i] - 1]) {\\n                p[i]++;\\n            }\\n\\n            // update center and its bound\\n            if (i + p[i] > maxRight) {\\n                center = i;\\n                maxRight = i + p[i];\\n            }\\n\\n            // update ans\\n            if (p[i] > maxLen) {\\n                start = (i - p[i] - 1) / 2;\\n                maxLen = p[i];\\n            }\\n        }\\n\\n        return s.substring(start, start + maxLen);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3337,
                "title": "manacher-algorithm-in-python-o-n",
                "content": "    class Solution:\\n        #Manacher algorithm\\n        #http://en.wikipedia.org/wiki/Longest_palindromic_substring\\n        \\n        def longestPalindrome(self, s):\\n            # Transform S into T.\\n            # For example, S = \"abba\", T = \"^#a#b#b#a#$\".\\n            # ^ and $ signs are sentinels appended to each end to avoid bounds checking\\n            T = '#'.join('^{}$'.format(s))\\n            n = len(T)\\n            P = [0] * n\\n            C = R = 0\\n            for i in range (1, n-1):\\n                P[i] = (R > i) and min(R - i, P[2*C - i]) # equals to i' = C - (i-C)\\n                # Attempt to expand palindrome centered at i\\n                while T[i + 1 + P[i]] == T[i - 1 - P[i]]:\\n                    P[i] += 1\\n        \\n                # If palindrome centered at i expand past R,\\n                # adjust center based on expanded palindrome.\\n                if i + P[i] > R:\\n                    C, R = i, i + P[i]\\n        \\n            # Find the maximum element in P.\\n            maxLen, centerIndex = max((n, i) for i, n in enumerate(P))\\n            return s[(centerIndex  - maxLen)//2: (centerIndex  + maxLen)//2]\\n\\nBased on this  article: http://articles.leetcode.com/2011/11/longest-palindromic-substring-part-ii.html",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution:\\n        #Manacher algorithm\\n        #http://en.wikipedia.org/wiki/Longest_palindromic_substring\\n        \\n        def longestPalindrome(self, s):\\n            # Transform S into T.\\n            # For example, S = \"abba\", T = \"^#a#b#b#a#$\".\\n            # ^ and $ signs are sentinels appended to each end to avoid bounds checking\\n            T = '#'.join('^{}",
                "codeTag": "Java"
            },
            {
                "id": 2926,
                "title": "8-line-javascript-solution",
                "content": "**Updated: July 17 2021**\\n\\n```\\nfunction longestPalindrome(s) {\\n  let ll = 0, rr = 0;\\n  \\n  for (let i = 0; i < s.length; i++)\\n    for (let j of [i, i+1])\\n      for (l = i, r = j; s[l] && s[l] === s[r]; l--, r++)\\n        [ll, rr] = (r-l+1) > (rr-ll+1) ? [l, r] : [ll, rr];\\n  \\n  return s.substring(ll, rr+1);\\n}\\n```\\n**With Comment**\\n```\\nfunction longestPalindrome(s) {\\n  // ll: Left index of the longest palindrome.\\n  // rr: Right index of the longest palindrome.\\n  let ll = 0, rr = 0;\\n\\n  // Iterate all palindromes with center indices\\n  // [..., i, ...] or [... i, i+1, ...]\\n  for (let i = 0; i < s.length; i++) {\\n    for (let j of [i, i+1]) {\\n      for (l = i, r = j; s[l] && s[l] === s[r]; l--, r++)\\n\\n        // Found a new palindrome [l, ..., i, j, ..., r]\\n        // Update the ll, rr if the newly found palindrome is longer than the\\n        // existing one.\\n        [ll, rr] = (r-l+1) > (rr-ll+1) ? [l, r] : [ll, rr];\\n    }\\n  }\\n  return s.substring(ll, rr+1);\\n}\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nfunction longestPalindrome(s) {\\n  let ll = 0, rr = 0;\\n  \\n  for (let i = 0; i < s.length; i++)\\n    for (let j of [i, i+1])\\n      for (l = i, r = j; s[l] && s[l] === s[r]; l--, r++)\\n        [ll, rr] = (r-l+1) > (rr-ll+1) ? [l, r] : [ll, rr];\\n  \\n  return s.substring(ll, rr+1);\\n}\\n```\n```\\nfunction longestPalindrome(s) {\\n  // ll: Left index of the longest palindrome.\\n  // rr: Right index of the longest palindrome.\\n  let ll = 0, rr = 0;\\n\\n  // Iterate all palindromes with center indices\\n  // [..., i, ...] or [... i, i+1, ...]\\n  for (let i = 0; i < s.length; i++) {\\n    for (let j of [i, i+1]) {\\n      for (l = i, r = j; s[l] && s[l] === s[r]; l--, r++)\\n\\n        // Found a new palindrome [l, ..., i, j, ..., r]\\n        // Update the ll, rr if the newly found palindrome is longer than the\\n        // existing one.\\n        [ll, rr] = (r-l+1) > (rr-ll+1) ? [l, r] : [ll, rr];\\n    }\\n  }\\n  return s.substring(ll, rr+1);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 578435,
                "title": "evolution-from-recursion-to-top-down-dp-to-bottoms-up-dp-easy-understanding-code",
                "content": "#### Recursion\\n\\n```\\nclass Solution {\\n    public String longestPalindrome(String s) {\\n        \\n        int len = s.length();\\n        \\n        int maxLen = 0;\\n        String res = \"\";\\n        \\n        \\n        for (int left = 0; left < len; left++){\\n            for (int right = left; right < len; right++){\\n                \\n             if (s.charAt(left) == s.charAt(right) && isPalin(s,left + 1, right -1)){\\n                if (maxLen < right - left + 1) {\\n                    maxLen = right - left + 1;\\n                    res = s.substring(left, right + 1);\\n                    }\\n                }   \\n            }\\n        }\\n        \\n        return res;\\n    }\\n    \\n    \\n    public boolean isPalin(String s, int left, int right){\\n        \\n        if (left >= right){\\n            return true;\\n        }\\n        \\n        if (s.charAt(left) != s.charAt(right)) {\\n            return false;\\n        }\\n        \\n        if (right - left <= 2){\\n            return true;\\n        }\\n        \\n        return isPalin(s,left + 1, right - 1);\\n        \\n    }\\n    \\n}\\n```\\n\\n#### Top Down\\n```\\nclass Solution {\\n    \\n    Boolean[][] memo ;\\n    \\n    public String longestPalindrome(String s) {\\n        \\n        int len = s.length();\\n        \\n        int maxLen = 0;\\n        String res = \"\";\\n        memo = new Boolean[len][len];\\n        \\n        for (int left = 0; left < len; left++){\\n            for (int right = left; right < len; right++){\\n                \\n             if (s.charAt(left) == s.charAt(right) && isPalin(s,left + 1, right -1)){\\n                if (maxLen < right - left + 1) {\\n                    maxLen = right - left + 1;\\n                    res = s.substring(left, right + 1);\\n                    }\\n                }   \\n            }\\n        }\\n        \\n        return res;\\n    }\\n    \\n    \\n    public boolean isPalin(String s, int left, int right){\\n        \\n        if (left >= right){\\n            return true;\\n        }\\n        \\n        if (memo[left][right] != null){\\n            return memo[left][right] ;\\n        }\\n        \\n        if (s.charAt(left) != s.charAt(right)) {\\n            memo[left][right] = false;\\n            return memo[left][right];\\n        }\\n        \\n        if (right - left <= 2){\\n            memo[left][right] = true;\\n            return memo[left][right];\\n        }\\n        \\n        memo[left][right] = isPalin(s,left + 1, right - 1);\\n        return memo[left][right];\\n        \\n    }\\n    \\n}\\n```\\n\\n#### Bottoms Up DP\\n\\n\\n```\\nclass Solution {\\n    \\n    boolean[][] memo ;\\n    \\n    public String longestPalindrome(String s) {\\n        \\n        int len = s.length();\\n        \\n        int maxLen = 0;\\n        String res = \"\";\\n        memo = new boolean[len][len];\\n        \\n        for (int left = len -1; left >= 0; left--){ // notice this goes backwards\\n            for (int right = left; right < len; right++){\\n                \\n             if (s.charAt(left) == s.charAt(right)){\\n                 \\n                if (right - left <=2){\\n                    memo[left][right] = true;\\n                } else{\\n                    memo[left][right] = memo[left + 1][right - 1]; \\n                }\\n             }\\n    \\n            if (memo[left][right]  && maxLen < right - left + 1) {\\n                maxLen = right - left + 1;\\n                res = s.substring(left, right + 1);\\n                }\\n            }   \\n            \\n        }\\n        \\n        return res;\\n    }\\n    \\n}\\n```\\n\\n\\nWhile converting a Top Down to A Bottoms up solution, it is important to make sure the outermost loop is reversed. \\n\\nDuring the top down, the order of execution is reverse. So to make sure this also happens in bottoms up, it is important to reverse the direction.\\n\\nThis is true for ALL dynamic programming problems.\\n\\nAnother hint is because the main equation has `memo[left][right] = memo[left + 1][right - 1]; `\\n\\nThis means, before `left` can be computed `left+1` must be precomputed. So left goes from `n,n-1,...0`.\\n\\nAlso, before `right` can be computed `right-1` must be precomputed.So right goes `0,1,2....n`.\\n\\nHope it helps.",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public String longestPalindrome(String s) {\\n        \\n        int len = s.length();\\n        \\n        int maxLen = 0;\\n        String res = \"\";\\n        \\n        \\n        for (int left = 0; left < len; left++){\\n            for (int right = left; right < len; right++){\\n                \\n             if (s.charAt(left) == s.charAt(right) && isPalin(s,left + 1, right -1)){\\n                if (maxLen < right - left + 1) {\\n                    maxLen = right - left + 1;\\n                    res = s.substring(left, right + 1);\\n                    }\\n                }   \\n            }\\n        }\\n        \\n        return res;\\n    }\\n    \\n    \\n    public boolean isPalin(String s, int left, int right){\\n        \\n        if (left >= right){\\n            return true;\\n        }\\n        \\n        if (s.charAt(left) != s.charAt(right)) {\\n            return false;\\n        }\\n        \\n        if (right - left <= 2){\\n            return true;\\n        }\\n        \\n        return isPalin(s,left + 1, right - 1);\\n        \\n    }\\n    \\n}\\n```\n```\\nclass Solution {\\n    \\n    Boolean[][] memo ;\\n    \\n    public String longestPalindrome(String s) {\\n        \\n        int len = s.length();\\n        \\n        int maxLen = 0;\\n        String res = \"\";\\n        memo = new Boolean[len][len];\\n        \\n        for (int left = 0; left < len; left++){\\n            for (int right = left; right < len; right++){\\n                \\n             if (s.charAt(left) == s.charAt(right) && isPalin(s,left + 1, right -1)){\\n                if (maxLen < right - left + 1) {\\n                    maxLen = right - left + 1;\\n                    res = s.substring(left, right + 1);\\n                    }\\n                }   \\n            }\\n        }\\n        \\n        return res;\\n    }\\n    \\n    \\n    public boolean isPalin(String s, int left, int right){\\n        \\n        if (left >= right){\\n            return true;\\n        }\\n        \\n        if (memo[left][right] != null){\\n            return memo[left][right] ;\\n        }\\n        \\n        if (s.charAt(left) != s.charAt(right)) {\\n            memo[left][right] = false;\\n            return memo[left][right];\\n        }\\n        \\n        if (right - left <= 2){\\n            memo[left][right] = true;\\n            return memo[left][right];\\n        }\\n        \\n        memo[left][right] = isPalin(s,left + 1, right - 1);\\n        return memo[left][right];\\n        \\n    }\\n    \\n}\\n```\n```\\nclass Solution {\\n    \\n    boolean[][] memo ;\\n    \\n    public String longestPalindrome(String s) {\\n        \\n        int len = s.length();\\n        \\n        int maxLen = 0;\\n        String res = \"\";\\n        memo = new boolean[len][len];\\n        \\n        for (int left = len -1; left >= 0; left--){ // notice this goes backwards\\n            for (int right = left; right < len; right++){\\n                \\n             if (s.charAt(left) == s.charAt(right)){\\n                 \\n                if (right - left <=2){\\n                    memo[left][right] = true;\\n                } else{\\n                    memo[left][right] = memo[left + 1][right - 1]; \\n                }\\n             }\\n    \\n            if (memo[left][right]  && maxLen < right - left + 1) {\\n                maxLen = right - left + 1;\\n                res = s.substring(left, right + 1);\\n                }\\n            }   \\n            \\n        }\\n        \\n        return res;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 468326,
                "title": "clean-python-3-solution-faster-than-85-memory-usage-less-than-100",
                "content": "```\\nclass Solution:\\n    def longestPalindrome(self, s: str) -> str:\\n        p = \\'\\'\\n        for i in range(len(s)):\\n            p1 = self.get_palindrome(s, i, i+1)\\n            p2 = self.get_palindrome(s, i, i)\\n            p = max([p, p1, p2], key=len)\\n        return p\\n    \\n    def get_palindrome(self, s: str, l: int, r: int) -> str:\\n        while l >= 0 and r < len(s) and s[l] == s[r]:\\n            l -= 1\\n            r += 1\\n        return s[l+1:r]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestPalindrome(self, s: str) -> str:\\n        p = \\'\\'\\n        for i in range(len(s)):\\n            p1 = self.get_palindrome(s, i, i+1)\\n            p2 = self.get_palindrome(s, i, i)\\n            p = max([p, p1, p2], key=len)\\n        return p\\n    \\n    def get_palindrome(self, s: str, l: int, r: int) -> str:\\n        while l >= 0 and r < len(s) and s[l] == s[r]:\\n            l -= 1\\n            r += 1\\n        return s[l+1:r]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2929,
                "title": "accepted-4ms-c-solution",
                "content": "    class Solution {\\n    public:\\n        std::string longestPalindrome(std::string s) {\\n            if (s.size() < 2)\\n                return s;\\n            int len = s.size(), max_left = 0, max_len = 1, left, right;\\n            for (int start = 0; start < len && len - start > max_len / 2;) {\\n                left = right = start;\\n                while (right < len - 1 && s[right + 1] == s[right])\\n                    ++right;\\n                start = right + 1;\\n                while (right < len - 1 && left > 0 && s[right + 1] == s[left - 1]) {\\n                    ++right;\\n                    --left;\\n                }\\n                if (max_len < right - left + 1) {\\n                    max_left = left;\\n                    max_len = right - left + 1;\\n                }\\n            }\\n            return s.substr(max_left, max_len);\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        std::string longestPalindrome(std::string s) {\\n            if (s.size() < 2)\\n                return s;\\n            int len = s.size(), max_left = 0, max_len = 1, left, right;\\n            for (int start = 0; start < len && len - start > max_len / 2;) {\\n                left = right = start;\\n                while (right < len - 1 && s[right + 1] == s[right])\\n                    ++right;\\n                start = right + 1;\\n                while (right < len - 1 && left > 0 && s[right + 1] == s[left - 1]) {\\n                    ++right;\\n                    --left;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 121496,
                "title": "python-dp-solution",
                "content": "```\\nclass Solution(object):\\n    def longestPalindrome(self, s):\\n        ans = \\'\\'\\n        max_len = 0\\n        n = len(s)\\n        DP = [[0] * n for _ in xrange(n)]\\n        for i in xrange(n):\\n            DP[i][i] = True\\n            max_len = 1\\n            ans = s[i]\\n        for i in xrange(n-1):\\n            if s[i] == s[i+1]:\\n                DP[i][i+1] = True\\n                ans = s[i:i+2]\\n                max_len = 2\\n        for j in xrange(n):\\n            for i in xrange(0, j-1):\\n                if s[i] == s[j] and DP[i+1][j-1]:\\n                    DP[i][j] = True\\n                    if max_len < j - i + 1:\\n                        ans = s[i:j+1]\\n                        max_len = j - i + 1\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def longestPalindrome(self, s):\\n        ans = \\'\\'\\n        max_len = 0\\n        n = len(s)\\n        DP = [[0] * n for _ in xrange(n)]\\n        for i in xrange(n):\\n            DP[i][i] = True\\n            max_len = 1\\n            ans = s[i]\\n        for i in xrange(n-1):\\n            if s[i] == s[i+1]:\\n                DP[i][i+1] = True\\n                ans = s[i:i+2]\\n                max_len = 2\\n        for j in xrange(n):\\n            for i in xrange(0, j-1):\\n                if s[i] == s[j] and DP[i+1][j-1]:\\n                    DP[i][j] = True\\n                    if max_len < j - i + 1:\\n                        ans = s[i:j+1]\\n                        max_len = j - i + 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 548834,
                "title": "intuitive-javascript-solution-with-expand-around-center",
                "content": "```\\n/**\\n * @param {string} s\\n * @return {string}\\n */\\nvar longestPalindrome = function(s) {\\n    let longest = \\'\\';\\n    const findLongestPalindrome = (str, i, j) => {\\n        while(i >= 0 && j < str.length && str[i] === str[j]) {\\n            i -= 1;\\n            j += 1;\\n        }\\n        // slice the qualified substring from the second last iteration\\n        return str.slice(i + 1, j);\\n    }\\n    for (let i = 0; i < s.length; i++) {\\n        // palindrome can center around 1 or 2 letters\\n        const current1 = findLongestPalindrome(s, i, i);\\n        const current2 = findLongestPalindrome(s, i, i + 1);\\n        const longerPalindrome = \\n              current1.length > current2.length ? current1 : current2;\\n        if (longerPalindrome.length > longest.length) {\\n            longest = longerPalindrome;\\n        } \\n    }\\n    return longest;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {string}\\n */\\nvar longestPalindrome = function(s) {\\n    let longest = \\'\\';\\n    const findLongestPalindrome = (str, i, j) => {\\n        while(i >= 0 && j < str.length && str[i] === str[j]) {\\n            i -= 1;\\n            j += 1;\\n        }\\n        // slice the qualified substring from the second last iteration\\n        return str.slice(i + 1, j);\\n    }\\n    for (let i = 0; i < s.length; i++) {\\n        // palindrome can center around 1 or 2 letters\\n        const current1 = findLongestPalindrome(s, i, i);\\n        const current2 = findLongestPalindrome(s, i, i + 1);\\n        const longerPalindrome = \\n              current1.length > current2.length ? current1 : current2;\\n        if (longerPalindrome.length > longest.length) {\\n            longest = longerPalindrome;\\n        } \\n    }\\n    return longest;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1024769,
                "title": "python3-3-solutions-expand-from-the-middle-top-down-dp-bottom-up-dp-clean-concise",
                "content": "**\\u2714\\uFE0F Solution 1: Expand from the middle**\\n```python\\nclass Solution:\\n    def longestPalindrome(self, s: str) -> str:\\n        n = len(s)\\n        \\n        def longestPalindrome(l, r):\\n            while l >= 0 and r < n and s[l] == s[r]:\\n                l -= 1\\n                r += 1\\n            l += 1\\n            r -= 1\\n            return r - l + 1, l\\n        \\n        maxLen = 0\\n        startIdx = -1\\n        for i in range(n):\\n            length, start = longestPalindrome(i, i)  # Odd length palindrome, center at s[i]\\n            if maxLen < length:\\n                maxLen = length\\n                startIdx = start\\n                \\n            length, start = longestPalindrome(i, i+1)  # Even length palindrome, center at s[i], s[i+1]\\n            if maxLen < length:\\n                maxLen = length\\n                startIdx = start\\n            \\n        return s[startIdx : startIdx + maxLen]\\n```\\n**Complexity**\\n- Time: `O(N^2)`, where `N <= 1000` is length of string `s`.\\n- Extra Space (without counting output as space): `O(1)`\\n\\n---\\n**\\u274C  Solution 2: Top down DP (Time is too strict!)**\\n```python\\nclass Solution:\\n    def longestPalindrome(self, s: str) -> str:\\n        @lru_cache(None)\\n        def isPalindrome(l, r):\\n            if l >= r: return True\\n            if s[l] != s[r]: return False\\n            return isPalindrome(l + 1, r - 1)\\n\\n        maxLen = startIdx = 0\\n        n = len(s)\\n        for i in range(n):\\n            for j in range(i, n):\\n                if isPalindrome(i, j):\\n                    newLen = j - i + 1\\n                    if newLen > maxLen:\\n                        maxLen = newLen\\n                        startIdx = i\\n\\n        return s[startIdx:startIdx + maxLen]\\n```\\n**Complexity**\\n- Time: `O(N^2)`, where `N <= 1000` is length of string `s`.\\n- Space: `O(N^2)`\\n\\n---\\n**\\u2714\\uFE0F Solution 3: Bottom up DP**\\n```python\\nclass Solution:\\n    def longestPalindrome(self, s: str) -> str:\\n        n = len(s)\\n        dp = [[False] * n for _ in range(n)]\\n\\n        maxLen = startIdx = 0\\n        for i in range(n - 1, -1, -1):\\n            for j in range(i, n):\\n                if i == j:\\n                    dp[i][j] = True\\n                elif s[i] == s[j]:\\n                    dp[i][j] = (i+1 == j) or dp[i + 1][j - 1]\\n\\n                if dp[i][j]:\\n                    newLen = j - i + 1\\n                    if newLen > maxLen:\\n                        maxLen = newLen\\n                        startIdx = i\\n\\n        return s[startIdx:startIdx + maxLen]\\n```\\n**Complexity**\\n- Time: `O(N^2)`, where `N <= 1000` is length of string `s`.\\n- Space: `O(N^2)`",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```python\\nclass Solution:\\n    def longestPalindrome(self, s: str) -> str:\\n        n = len(s)\\n        \\n        def longestPalindrome(l, r):\\n            while l >= 0 and r < n and s[l] == s[r]:\\n                l -= 1\\n                r += 1\\n            l += 1\\n            r -= 1\\n            return r - l + 1, l\\n        \\n        maxLen = 0\\n        startIdx = -1\\n        for i in range(n):\\n            length, start = longestPalindrome(i, i)  # Odd length palindrome, center at s[i]\\n            if maxLen < length:\\n                maxLen = length\\n                startIdx = start\\n                \\n            length, start = longestPalindrome(i, i+1)  # Even length palindrome, center at s[i], s[i+1]\\n            if maxLen < length:\\n                maxLen = length\\n                startIdx = start\\n            \\n        return s[startIdx : startIdx + maxLen]\\n```\n```python\\nclass Solution:\\n    def longestPalindrome(self, s: str) -> str:\\n        @lru_cache(None)\\n        def isPalindrome(l, r):\\n            if l >= r: return True\\n            if s[l] != s[r]: return False\\n            return isPalindrome(l + 1, r - 1)\\n\\n        maxLen = startIdx = 0\\n        n = len(s)\\n        for i in range(n):\\n            for j in range(i, n):\\n                if isPalindrome(i, j):\\n                    newLen = j - i + 1\\n                    if newLen > maxLen:\\n                        maxLen = newLen\\n                        startIdx = i\\n\\n        return s[startIdx:startIdx + maxLen]\\n```\n```python\\nclass Solution:\\n    def longestPalindrome(self, s: str) -> str:\\n        n = len(s)\\n        dp = [[False] * n for _ in range(n)]\\n\\n        maxLen = startIdx = 0\\n        for i in range(n - 1, -1, -1):\\n            for j in range(i, n):\\n                if i == j:\\n                    dp[i][j] = True\\n                elif s[i] == s[j]:\\n                    dp[i][j] = (i+1 == j) or dp[i + 1][j - 1]\\n\\n                if dp[i][j]:\\n                    newLen = j - i + 1\\n                    if newLen > maxLen:\\n                        maxLen = newLen\\n                        startIdx = i\\n\\n        return s[startIdx:startIdx + maxLen]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2156659,
                "title": "python-easy-o-1-space-approach",
                "content": "The following solution is kinda brute force approach. We expand the string around a given index.\\n> eg: input string : **ababd**\\n\\nLet\\'s say we expand around position `2`. The longest pallindrome that we can from position `2` is `bab`. But if we expand from a single character position, we would always end up with an odd length pallindrome. To find an even length pallindrome, we need to expand around two positions.\\n\\n>eg: input string : **abaabd**\\n\\nLet\\'s say we expand around position `2` and `3`.  The longest pallindrome that we can form from these positions  is `baab`. So we ended up with a longer pallindrome compared to the previous find.\\n\\nWe will use the above logic to find possible even and odd lengthed pallindromes from all positions in the string.\\nBelow is my implementation for the same:\\n```\\nclass Solution:\\n    def longestPalindrome(self, s: str) -> str:\\n        n=len(s)\\n        def expand_pallindrome(i,j):            \\n            while 0<=i<=j<n and s[i]==s[j]:\\n                i-=1\\n                j+=1                            \\n            return (i+1, j)\\n        \\n        res=(0,0)\\n        for i in range(n):\\n            b1 = expand_pallindrome(i,i)\\n            b2 = expand_pallindrome(i,i+1)            \\n            res=max(res, b1, b2,key=lambda x: x[1]-x[0]+1) # find max based on the length of the pallindrome strings.\\n                    \\n        return s[res[0]:res[1]]    \\n```\\n\\nA more concise variation: \\n```\\nclass Solution:\\n    def longestPalindrome(self, s: str) -> str:\\n        n=len(s)\\n        def expand_center(i,j):            \\n            while 0<=i<=j<n and s[i]==s[j]:\\n                i-=1\\n                j+=1                \\n            \\n            return (i+1, j)                \\n        \\n        res=max([expand_center(i,i+offset) for i in range(n) for offset in range(2)], key=lambda x: x[1]-x[0]+1)\\n        \\n        return s[res[0]:res[1]]\\n```\\n\\n**Time - O(n * n)** where `n` is the length of the input string\\n**Space - O(1)**\\n\\n---\\n\\n***Please upvote if you find it useful***",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestPalindrome(self, s: str) -> str:\\n        n=len(s)\\n        def expand_pallindrome(i,j):            \\n            while 0<=i<=j<n and s[i]==s[j]:\\n                i-=1\\n                j+=1                            \\n            return (i+1, j)\\n        \\n        res=(0,0)\\n        for i in range(n):\\n            b1 = expand_pallindrome(i,i)\\n            b2 = expand_pallindrome(i,i+1)            \\n            res=max(res, b1, b2,key=lambda x: x[1]-x[0]+1) # find max based on the length of the pallindrome strings.\\n                    \\n        return s[res[0]:res[1]]    \\n```\n```\\nclass Solution:\\n    def longestPalindrome(self, s: str) -> str:\\n        n=len(s)\\n        def expand_center(i,j):            \\n            while 0<=i<=j<n and s[i]==s[j]:\\n                i-=1\\n                j+=1                \\n            \\n            return (i+1, j)                \\n        \\n        res=max([expand_center(i,i+offset) for i in range(n) for offset in range(2)], key=lambda x: x[1]-x[0]+1)\\n        \\n        return s[res[0]:res[1]]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 428331,
                "title": "javascript-dp",
                "content": "Idea comes from optimizing recursive solution by remembering previous result. Let\\'s say we have a 2D array `dp`. In each cell, it indicates whether `range(i, j)` can become a palindrome or not, where  `i`, `j` denotes start and end index of the given string `s`. We can build upon base cases and expand from there:\\n* base case with one character - `dp[i][i] = true` when `i === j`\\n* base case with two characters - `dp[i][i+1] = true` when `s[i] === s[i+1]`\\n* expand case with three or more characters - `dp[i][j] = dp[i+1][j-1] && s[i] === s[j]`\\n\\n```\\nHere\\'s an example of dp with \"babad\" after two base cases\\n\\u250C\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2510\\n\\u2502 (index) \\u2502   0   \\u2502   1   \\u2502   2   \\u2502   3   \\u2502   4   \\u2502   5   \\u2502\\n\\u251C\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2524\\n\\u2502    0    \\u2502 true  \\u2502 false \\u2502 false \\u2502 false \\u2502 false \\u2502 false \\u2502\\n\\u2502    1    \\u2502 false \\u2502 true  \\u2502 false \\u2502 false \\u2502 false \\u2502 false \\u2502\\n\\u2502    2    \\u2502 false \\u2502 false \\u2502 true  \\u2502 false \\u2502 false \\u2502 false \\u2502\\n\\u2502    3    \\u2502 false \\u2502 false \\u2502 false \\u2502 true  \\u2502 false \\u2502 false \\u2502\\n\\u2502    4    \\u2502 false \\u2502 false \\u2502 false \\u2502 false \\u2502 true  \\u2502 false \\u2502\\n\\u2502    5    \\u2502 false \\u2502 false \\u2502 false \\u2502 false \\u2502 false \\u2502 false \\u2502\\n\\u2514\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2518\\n```\\n```\\n// 2D DP\\nvar longestPalindrome = function(s) {\\n    \\n\\tif(s.length <= 1) return s;\\n\\t\\n\\t// construct a 2D array\\n    const dp = [...new Array(s.length + 1)].map(_ => new Array(s.length + 1).fill(false));\\n\\t\\n    let lps = \\'\\';\\n    \\n\\t// base case for one character\\n    for(let i = 0; i < s.length; i++) {\\n        dp[i][i] = true;\\n        lps = s[i];\\n    }\\n    \\n\\t// base case for two characters\\n    for(let i = 0; i < s.length; i++) {\\n        if(s[i] === s[i + 1]) dp[i][i+1] = true;\\n        if(dp[i][i+1]) lps = s.substring(i, i + 2);\\n    }\\n\\n    // expand to three or more characters\\n    for(let i = s.length - 1; i >= 0; i--) {\\n        for(let j = i + 2; j < s.length; j++) {\\n            dp[i][j] = dp[i+1][j-1] && s[i] === s[j];\\n            if(dp[i][j]) lps = lps.length < (j - i + 1) ? s.substring(i, j + 1) : lps;\\n        }\\n    }\\n    \\n    return lps;\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\nHere\\'s an example of dp with \"babad\" after two base cases\\n\\u250C\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u252C\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2510\\n\\u2502 (index) \\u2502   0   \\u2502   1   \\u2502   2   \\u2502   3   \\u2502   4   \\u2502   5   \\u2502\\n\\u251C\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u253C\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2524\\n\\u2502    0    \\u2502 true  \\u2502 false \\u2502 false \\u2502 false \\u2502 false \\u2502 false \\u2502\\n\\u2502    1    \\u2502 false \\u2502 true  \\u2502 false \\u2502 false \\u2502 false \\u2502 false \\u2502\\n\\u2502    2    \\u2502 false \\u2502 false \\u2502 true  \\u2502 false \\u2502 false \\u2502 false \\u2502\\n\\u2502    3    \\u2502 false \\u2502 false \\u2502 false \\u2502 true  \\u2502 false \\u2502 false \\u2502\\n\\u2502    4    \\u2502 false \\u2502 false \\u2502 false \\u2502 false \\u2502 true  \\u2502 false \\u2502\\n\\u2502    5    \\u2502 false \\u2502 false \\u2502 false \\u2502 false \\u2502 false \\u2502 false \\u2502\\n\\u2514\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2534\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2500\\u2518\\n```\n```\\n// 2D DP\\nvar longestPalindrome = function(s) {\\n    \\n\\tif(s.length <= 1) return s;\\n\\t\\n\\t// construct a 2D array\\n    const dp = [...new Array(s.length + 1)].map(_ => new Array(s.length + 1).fill(false));\\n\\t\\n    let lps = \\'\\';\\n    \\n\\t// base case for one character\\n    for(let i = 0; i < s.length; i++) {\\n        dp[i][i] = true;\\n        lps = s[i];\\n    }\\n    \\n\\t// base case for two characters\\n    for(let i = 0; i < s.length; i++) {\\n        if(s[i] === s[i + 1]) dp[i][i+1] = true;\\n        if(dp[i][i+1]) lps = s.substring(i, i + 2);\\n    }\\n\\n    // expand to three or more characters\\n    for(let i = s.length - 1; i >= 0; i--) {\\n        for(let j = i + 2; j < s.length; j++) {\\n            dp[i][j] = dp[i+1][j-1] && s[i] === s[j];\\n            if(dp[i][j]) lps = lps.length < (j - i + 1) ? s.substring(i, j + 1) : lps;\\n        }\\n    }\\n    \\n    return lps;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 812245,
                "title": "simple-c-dp-code-with-comments",
                "content": "```\\nstring longestPalindrome(string s) {\\n        if(s.size() == 0) return \"\";\\n        int n = s.size();\\n        int table[n][n];\\n        memset(table,-1,sizeof(table)); //Initializing table with -1\\n        for (int i = 0; i < n; ++i) \\n            table[i][i] = 1;  //Filling up the table\\n        int maxLen = 1;\\n        int start = 0; \\n        for (int i = 0; i < n - 1; ++i) { //checking for substring of length 2.\\n            if (s[i] == s[i + 1]) { \\n                table[i][i + 1] = 1; \\n                start = i;  //Updating the start\\n                maxLen = 2; \\n            } \\n        }\\n        for(int k=3;k<=n;k++){ //Checking for length greater than 2 and k is length of substring \\n            for(int i=0;i<n - k + 1;i++){\\n                int j = i + k - 1; //Initializing the end Index i.e j = i + k - 1\\n                if(table[i+1][j-1] == 1 && s[i] == s[j]){ //Checking for the conditions i.e checking for sub-string from ith index to jth index.\\n                    table[i][j] = 1;\\n                    if (k > maxLen) { //Updating the maxLen\\n                        start = i;  //Updating the start\\n                        maxLen = k; \\n                    } \\n                }\\n            }\\n        }\\n        return s.substr(start, maxLen);\\n    }\\n```\\n\\n`T.C - O(N^2)`\\n\\n**Do Upvote if you find it Useful.**\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```\\nstring longestPalindrome(string s) {\\n        if(s.size() == 0) return \"\";\\n        int n = s.size();\\n        int table[n][n];\\n        memset(table,-1,sizeof(table)); //Initializing table with -1\\n        for (int i = 0; i < n; ++i) \\n            table[i][i] = 1;  //Filling up the table\\n        int maxLen = 1;\\n        int start = 0; \\n        for (int i = 0; i < n - 1; ++i) { //checking for substring of length 2.\\n            if (s[i] == s[i + 1]) { \\n                table[i][i + 1] = 1; \\n                start = i;  //Updating the start\\n                maxLen = 2; \\n            } \\n        }\\n        for(int k=3;k<=n;k++){ //Checking for length greater than 2 and k is length of substring \\n            for(int i=0;i<n - k + 1;i++){\\n                int j = i + k - 1; //Initializing the end Index i.e j = i + k - 1\\n                if(table[i+1][j-1] == 1 && s[i] == s[j]){ //Checking for the conditions i.e checking for sub-string from ith index to jth index.\\n                    table[i][j] = 1;\\n                    if (k > maxLen) { //Updating the maxLen\\n                        start = i;  //Updating the start\\n                        maxLen = k; \\n                    } \\n                }\\n            }\\n        }\\n        return s.substr(start, maxLen);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2987,
                "title": "clean-java-solution-using-dp-yet-the-time-complexity-is-o-n-2",
                "content": "    public class Solution {\\n        public String longestPalindrome(String s) {\\n            if(s == null || s.length() == 0) {\\n                return \"\";\\n            }\\n            int len = s.length();\\n            boolean[][] dp = new boolean[len][len];\\n            int start = 0;\\n            int end = 0;\\n            int max = 0;\\n            for(int i = 0; i < s.length(); i++) {\\n                for(int j = 0; j <= i; j++) {\\n                    if(s.charAt(i) == s.charAt(j) && (i - j <= 2 || dp[j+1][i-1])) {\\n                        dp[j][i] = true;\\n                    }\\n                    if(dp[j][i] && max < i - j + 1) {\\n                        max = i - j + 1;\\n                        start = j;\\n                        end = i;\\n                    }\\n                }\\n            }\\n            return s.substring(start, end + 1);\\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n        public String longestPalindrome(String s) {\\n            if(s == null || s.length() == 0) {\\n                return \"\";\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2156691,
                "title": "simple-dp-solution-java-explained",
                "content": "### Logic:\\nThe dynamic programmic approach to this question is quite simple actually! For any given substring, we can confirm if it is a palindrome in `O(1)` time if:\\n1. The characters at the ends of the substring are the same.\\n2. If the inner substring is a palindrome.\\n\\nObserve this relationship below:\\n![image](https://assets.leetcode.com/users/images/861e5558-0a38-4d01-bc08-aeb135cb80bd_1655340599.097208.png)\\n\\n___\\n### Algorithm:\\nOur outter loop will represent our length - 1, `len`.\\nOur inner loop will represent our left pointer, `i`.\\nTherefore, our right pointer will be represented by `i+len`. This makes our logic a bit easier:\\n* Our base cases are when `len` is 0 or 1 (i.e. when the length of the substring is of length 1 or 2). In these situations, DP won\\'t work. Thankfully, all we need to check for is whether `s.charAt(i) == s.charAt(i + len)`. \\n* For `len > 1`, we would also need to check whether the inner substring is a palindrome as illustrated above. Therefore, we\\'ll also check if `dp[i+1][i+len-1]` is true.\\n\\nThere are a few ways we could keep track of our longest substring. We could just assign a new substring whenever our current window length is greater than the current string\\'s length. However, assigning a new substring on each update takes `O(n)` time at worst. Therefore, we\\'ll just keep track of the indices of our longest substring using `start` and `end` and we\\'ll only convert this into a substring at the end.\\n\\nAwesome, we now have everything we need to start coding!\\n___\\n### Code:\\nIf you have any questions, suggestions or improvements, feel free to let me know. Thanks for reading!\\n```java\\npublic String longestPalindrome(String s) {\\n\\tint n = s.length(), start = 0, end = 0;\\n\\tboolean[][] dp = new boolean[n][n];\\n\\n\\tfor (int len=0; len<n; len++) {\\n\\t\\tfor (int i=0; i+len<n; i++) {\\n\\t\\t\\tdp[i][i+len] = s.charAt(i) == s.charAt(i+len) && (len < 2 || dp[i+1][i+len-1]);\\n\\t\\t\\tif (dp[i][i+len] && len > end - start) {\\n\\t\\t\\t\\tstart = i;\\n\\t\\t\\t\\tend = i + len;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn s.substring(start, end + 1);\\n}\\n```\\n**Time Complexity:** `O(n^2)`\\n**Space Complexity:** `O(n^2)`\\n> Note: DP is NOT a space-optimal solution. However, I believe the dynamic relationship is quite an important relationship to know when tackling palindrome questions as it quite heavilly applies to questions outside this one. If you use DP in an interview for this question, that should be more than enough to pass the question :)",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```java\\npublic String longestPalindrome(String s) {\\n\\tint n = s.length(), start = 0, end = 0;\\n\\tboolean[][] dp = new boolean[n][n];\\n\\n\\tfor (int len=0; len<n; len++) {\\n\\t\\tfor (int i=0; i+len<n; i++) {\\n\\t\\t\\tdp[i][i+len] = s.charAt(i) == s.charAt(i+len) && (len < 2 || dp[i+1][i+len-1]);\\n\\t\\t\\tif (dp[i][i+len] && len > end - start) {\\n\\t\\t\\t\\tstart = i;\\n\\t\\t\\t\\tend = i + len;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn s.substring(start, end + 1);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2671545,
                "title": "c-easy-fast-and-short-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int check(string &s, int L, int R)\\n    {\\n        while(L>=0 and R<s.length() and s[L]==s[R])\\n        {\\n            L--;\\n            R++;\\n        }\\n        return R-L-1;\\n    }\\n    \\n    string longestPalindrome(string s) {\\n        \\n        int ans = 0, st=0;\\n        int n = s.length();\\n        \\n        for(int i = 0;i<n;i++)\\n        {\\n            int len1 = check(s, i,i);\\n            int len2 = check(s, i, i+1);\\n            \\n            int len = max(len1, len2);\\n            \\n            if(len> ans)\\n            {\\n                ans = len;\\n                st = i-(len-1)/2;\\n            }\\n        }\\n        return s.substr(st, ans);\\n    }\\n};\\n```\\n**UPVOTE**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int check(string &s, int L, int R)\\n    {\\n        while(L>=0 and R<s.length() and s[L]==s[R])\\n        {\\n            L--;\\n            R++;\\n        }\\n        return R-L-1;\\n    }\\n    \\n    string longestPalindrome(string s) {\\n        \\n        int ans = 0, st=0;\\n        int n = s.length();\\n        \\n        for(int i = 0;i<n;i++)\\n        {\\n            int len1 = check(s, i,i);\\n            int len2 = check(s, i, i+1);\\n            \\n            int len = max(len1, len2);\\n            \\n            if(len> ans)\\n            {\\n                ans = len;\\n                st = i-(len-1)/2;\\n            }\\n        }\\n        return s.substr(st, ans);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 354582,
                "title": "java-easy-to-understand-dp-solution-with-comments",
                "content": "```\\npublic class Solution {\\n\\n    public String longestPalindrome(String s) {\\n        if (s.length() == 0) {\\n            return \"\";\\n        }\\n\\t\\t//Dp array for substring palindrome\\n        boolean[][] dp = new boolean[s.length()][s.length()];\\n        int start = 0, end = 0;\\n\\n        for (int i = 0; i < s.length(); ++i) {\\n            for (int j = i; j >= 0; --j) {\\n                boolean startEqEnd = s.charAt(j) == s.charAt(i);\\n\\n                if (i == j) {\\n                    //If the same char: \\'a\\' is palindrome\\n                    dp[i][j] = true;\\n                } else if (i - j == 1) {\\n                    //If length 2: \\'ab\\' is palindrome when \\'a\\' == \\'b\\'\\n                    dp[i][j] = startEqEnd;\\n                } else if (startEqEnd && dp[i - 1][j + 1]) {\\n                    //Otherwise: string is palindrome if s(i) == s(j) and substring s(j + 1, i - 1) is palindrome\\n                    dp[i][j] = true;\\n                }\\n\\n                if (dp[i][j] && i - j > end - start ) {\\n                    end = i;\\n                    start = j;\\n                }\\n            }\\n        }\\n\\n        return s.substring(start, end + 1);\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\npublic class Solution {\\n\\n    public String longestPalindrome(String s) {\\n        if (s.length() == 0) {\\n            return \"\";\\n        }\\n\\t\\t//Dp array for substring palindrome\\n        boolean[][] dp = new boolean[s.length()][s.length()];\\n        int start = 0, end = 0;\\n\\n        for (int i = 0; i < s.length(); ++i) {\\n            for (int j = i; j >= 0; --j) {\\n                boolean startEqEnd = s.charAt(j) == s.charAt(i);\\n\\n                if (i == j) {\\n                    //If the same char: \\'a\\' is palindrome\\n                    dp[i][j] = true;\\n                } else if (i - j == 1) {\\n                    //If length 2: \\'ab\\' is palindrome when \\'a\\' == \\'b\\'\\n                    dp[i][j] = startEqEnd;\\n                } else if (startEqEnd && dp[i - 1][j + 1]) {\\n                    //Otherwise: string is palindrome if s(i) == s(j) and substring s(j + 1, i - 1) is palindrome\\n                    dp[i][j] = true;\\n                }\\n\\n                if (dp[i][j] && i - j > end - start ) {\\n                    end = i;\\n                    start = j;\\n                }\\n            }\\n        }\\n\\n        return s.substring(start, end + 1);\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 873279,
                "title": "c-solutions-expand-around-center-dp-manacher",
                "content": "**C++:**\\n\\n**4 Solutions:**\\n\\n**(1) Expand around center:**\\n\\n```\\nvoid isPalindrome(const string& s,const int& length,int left,int right, int& start, int& maxlen){\\n\\twhile(left>=0 && right<length && s[left]==s[right]) --left,++right;\\n\\tif(maxlen < right-left-1)   maxlen = right-left-1, start = left+1;\\n}\\nstring longestPalindrome(string s) {\\n\\tint n = s.size(),start=0,maxlen=0;\\n\\tif(n<2) return s;\\n\\tfor(int i=0;i<n-1;++i){\\n\\t\\tisPalindrome(s,n,i,i,start,maxlen); //aba\\n\\t\\tisPalindrome(s,n,i,i+1,start,maxlen); //noon\\n\\t}\\n\\treturn s.substr(start,maxlen);\\n}\\n```\\n**(2) Expand around center optimization:**\\n```\\nstring longestPalindrome(string s) {\\n\\tint n = s.size(),start=0,maxlen=0;\\n\\tint left=0,right=0;\\n\\tif(n<2) return s;\\n\\tfor(int i=0;i<n-1;){\\n\\t\\tleft=i, right=i;\\n\\t\\twhile(right<n && s[right]==s[right+1]) ++right;\\n\\t\\ti=right+1;\\n\\t\\twhile(left>=0 && right<n && s[left]==s[right]) --left,++right;\\n\\t\\tif(maxlen < right-left-1)   maxlen = right-left-1, start = left+1;         \\n\\t}\\n\\treturn s.substr(start,maxlen);\\n}\\n```\\n**(3) Dynamic Programming**\\n```\\nstring longestPalindrome(string s) {\\n\\tconst int n = s.size();\\n\\tif(n==0) return \"\";\\n\\tint dp[n][n], maxlen =1 , left=0;// maxlen = 1 when only one word\\n\\tmemset(dp,0,n*n*sizeof(int));\\n\\tfor(int i=0;i<n;++i){\\n\\t\\tdp[i][i] = 1;\\n\\t\\tfor(int j=0;j<i;++j){\\n\\t\\t\\tdp[j][i] = (s[j]==s[i]  && (i-j< 2 || dp[j+1][i-1]));\\n\\t\\t\\tif(dp[j][i] && maxlen < i-j+1){\\n\\t\\t\\t\\tleft = j;\\n\\t\\t\\t\\tmaxlen = i-j+1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn s.substr(left,maxlen);\\n}\\n```\\n**(4) Manacher\\'s Algo**\\n\\nGraph:\\n\\n`- - - - -  imirror - - - - -  Center - - - - - i - - - - - right - - - - - `\\n\\n```\\nstring longestPalindrome(string s) {\\n\\tstring t =\"#\";//transform s to t\\n\\tfor (int i=0;i<s.size();++i)\\n\\t\\tt+=s[i], t+=\\'#\\';\\n\\tconst int t_len = t.size();\\n\\tint p[t_len]; //array to record longest palindrome length\\n\\tint center=0, right=0;//right index of the longest palindrome\\n\\tint rescenter=0, maxlen=0; //longest palindrome\\'s center and length\\n\\tmemset(p,0,t_len*sizeof(int));\\n\\tfor (int i = 1; i < t_len-1; ++i) {\\n\\t\\tint imirror = 2*center-i; //imirror-center = center-i\\n\\t\\tp[i]=right>i?min(p[imirror], right-i):0;\\n\\t\\twhile(i>p[i] && i+p[i]+1<t_len && t[i+p[i]+1]==t[i-p[i]-1]) //expand palindrome center at i\\n\\t\\t\\t++p[i];\\n\\t\\tif(right<i+p[i])\\n\\t\\t\\tright=i+p[i], center=i;\\n\\t\\tif(maxlen<p[i])\\n\\t\\t\\tmaxlen=p[i], rescenter=i;    \\n\\t}\\n\\treturn s.substr((rescenter-maxlen)/2, maxlen);\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nvoid isPalindrome(const string& s,const int& length,int left,int right, int& start, int& maxlen){\\n\\twhile(left>=0 && right<length && s[left]==s[right]) --left,++right;\\n\\tif(maxlen < right-left-1)   maxlen = right-left-1, start = left+1;\\n}\\nstring longestPalindrome(string s) {\\n\\tint n = s.size(),start=0,maxlen=0;\\n\\tif(n<2) return s;\\n\\tfor(int i=0;i<n-1;++i){\\n\\t\\tisPalindrome(s,n,i,i,start,maxlen); //aba\\n\\t\\tisPalindrome(s,n,i,i+1,start,maxlen); //noon\\n\\t}\\n\\treturn s.substr(start,maxlen);\\n}\\n```\n```\\nstring longestPalindrome(string s) {\\n\\tint n = s.size(),start=0,maxlen=0;\\n\\tint left=0,right=0;\\n\\tif(n<2) return s;\\n\\tfor(int i=0;i<n-1;){\\n\\t\\tleft=i, right=i;\\n\\t\\twhile(right<n && s[right]==s[right+1]) ++right;\\n\\t\\ti=right+1;\\n\\t\\twhile(left>=0 && right<n && s[left]==s[right]) --left,++right;\\n\\t\\tif(maxlen < right-left-1)   maxlen = right-left-1, start = left+1;         \\n\\t}\\n\\treturn s.substr(start,maxlen);\\n}\\n```\n```\\nstring longestPalindrome(string s) {\\n\\tconst int n = s.size();\\n\\tif(n==0) return \"\";\\n\\tint dp[n][n], maxlen =1 , left=0;// maxlen = 1 when only one word\\n\\tmemset(dp,0,n*n*sizeof(int));\\n\\tfor(int i=0;i<n;++i){\\n\\t\\tdp[i][i] = 1;\\n\\t\\tfor(int j=0;j<i;++j){\\n\\t\\t\\tdp[j][i] = (s[j]==s[i]  && (i-j< 2 || dp[j+1][i-1]));\\n\\t\\t\\tif(dp[j][i] && maxlen < i-j+1){\\n\\t\\t\\t\\tleft = j;\\n\\t\\t\\t\\tmaxlen = i-j+1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn s.substr(left,maxlen);\\n}\\n```\n```\\nstring longestPalindrome(string s) {\\n\\tstring t =\"#\";//transform s to t\\n\\tfor (int i=0;i<s.size();++i)\\n\\t\\tt+=s[i], t+=\\'#\\';\\n\\tconst int t_len = t.size();\\n\\tint p[t_len]; //array to record longest palindrome length\\n\\tint center=0, right=0;//right index of the longest palindrome\\n\\tint rescenter=0, maxlen=0; //longest palindrome\\'s center and length\\n\\tmemset(p,0,t_len*sizeof(int));\\n\\tfor (int i = 1; i < t_len-1; ++i) {\\n\\t\\tint imirror = 2*center-i; //imirror-center = center-i\\n\\t\\tp[i]=right>i?min(p[imirror], right-i):0;\\n\\t\\twhile(i>p[i] && i+p[i]+1<t_len && t[i+p[i]+1]==t[i-p[i]-1]) //expand palindrome center at i\\n\\t\\t\\t++p[i];\\n\\t\\tif(right<i+p[i])\\n\\t\\t\\tright=i+p[i], center=i;\\n\\t\\tif(maxlen<p[i])\\n\\t\\t\\tmaxlen=p[i], rescenter=i;    \\n\\t}\\n\\treturn s.substr((rescenter-maxlen)/2, maxlen);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 422495,
                "title": "clean-and-minimal-c-solution-4ms-98-40-easy-to-understand-expanding-window",
                "content": "```\\nstring longestPalindrome(string s) {\\n    if (s.size() <= 1) return s;\\n    int maxIdx = 0;\\n    int maxLen = 1;\\n    int i = 0;\\n\\n    while (i < s.size()) {\\n        int start = i;\\n        int end = i;\\n\\n        // expand the window from the end if it\\'s an even palindrome\\n        while (end + 1 < s.size() && s[end] == s[end + 1]) { end++; }\\n        i = end + 1;\\n\\n        // expand the window from both sides until it\\'s not longer a palindrome\\n        while (start - 1 >= 0 && end + 1 < s.size() && s[start - 1] == s[end + 1]) {\\n            start--, end++;\\n        }\\n\\n        int currLen = end - start + 1;\\n        if (currLen > maxLen) {\\n            maxIdx = start;\\n            maxLen = currLen;\\n        }\\n    }\\n\\n    return s.substr(maxIdx, maxLen);\\n}\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nstring longestPalindrome(string s) {\\n    if (s.size() <= 1) return s;\\n    int maxIdx = 0;\\n    int maxLen = 1;\\n    int i = 0;\\n\\n    while (i < s.size()) {\\n        int start = i;\\n        int end = i;\\n\\n        // expand the window from the end if it\\'s an even palindrome\\n        while (end + 1 < s.size() && s[end] == s[end + 1]) { end++; }\\n        i = end + 1;\\n\\n        // expand the window from both sides until it\\'s not longer a palindrome\\n        while (start - 1 >= 0 && end + 1 < s.size() && s[start - 1] == s[end + 1]) {\\n            start--, end++;\\n        }\\n\\n        int currLen = end - start + 1;\\n        if (currLen > maxLen) {\\n            maxIdx = start;\\n            maxLen = currLen;\\n        }\\n    }\\n\\n    return s.substr(maxIdx, maxLen);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2967,
                "title": "22-line-c-manacher-u2019s-algorithm-o-n-solution",
                "content": "This implements the Manacher's Algorithm, which is illustrated here: http://articles.leetcode.com/2011/11/longest-palindromic-substring-part-ii.html. Although there are nested loops, there is shortcut in computation, so it is still O(n). \\n\\n\\n    class Solution {\\n    public:\\n        string longestPalindrome(string s) \\n        {\\n            string T;// Transform S to T\\n            for(int i=0;i<s.size();i++)\\n                T+=\"#\"+s.substr(i,1);\\n            T.push_back('#');\\n    \\n            vector<int> P(T.size(),0); // Array to record longest palindrome\\n            int center=0,boundary=0,maxLen=0,resCenter=0;\\n            for(int i=1;i<T.size()-1;i++) {\\n                int iMirror=2*center-i; // calc mirror i = center-(i-center)\\n                P[i]=(boundary>i)?min(boundary-i,P[iMirror]):0; // shortcut\\n                while(i-1-P[i]>=0&&i+1+P[i]<=T.size()-1&&T[i+1+P[i]] == T[i-1-P[i]]) // Attempt to expand palindrome centered at i\\n                    P[i]++;\\n                if(i+P[i]>boundary) { // update center and boundary\\n                    center = i;\\n                    boundary = i+P[i];\\n                }\\n                if(P[i]>maxLen) { // update result\\n                    maxLen = P[i];\\n                    resCenter = i;\\n                }    \\n            }\\n            return s.substr((resCenter - maxLen)/2, maxLen);\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        string longestPalindrome(string s) \\n        {\\n            string T;// Transform S to T\\n            for(int i=0;i<s.size();i++)\\n                T+=\"#\"+s.substr(i,1);\\n            T.push_back('#');\\n    \\n            vector<int> P(T.size(),0); // Array to record longest palindrome\\n            int center=0,boundary=0,maxLen=0,resCenter=0;\\n            for(int i=1;i<T.size()-1;i++) {\\n                int iMirror=2*center-i; // calc mirror i = center-(i-center)\\n                P[i]=(boundary>i)?min(boundary-i,P[iMirror]):0; // shortcut\\n                while(i-1-P[i]>=0&&i+1+P[i]<=T.size()-1&&T[i+1+P[i]] == T[i-1-P[i]]) // Attempt to expand palindrome centered at i\\n                    P[i]++;\\n                if(i+P[i]>boundary) { // update center and boundary\\n                    center = i;\\n                    boundary = i+P[i];\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2965,
                "title": "clean-and-simple-java-solution-with-comments",
                "content": "    public String longestPalindrome(String s) {\\n\\tif (s.isEmpty()) {\\n\\t\\treturn null;\\n\\t}\\n \\n\\tif (s.length() == 1) {\\n\\t\\treturn s;\\n\\t}\\n \\n\\tString longest = s.substring(0, 1);\\n\\tfor (int i = 0; i < s.length(); i++) {\\n\\t    \\n\\t\\t// get longest palindrome with center of i\\n\\t\\tString tmp = helper(s, i, i);\\n\\t    \\tif (tmp.length() > longest.length()) {\\n\\t\\t\\tlongest = tmp;\\n\\t    \\t}\\n\\t\\t\\n\\t\\t// get longest palindrome with center of i, i+1\\n\\t\\ttmp = helper(s, i, i + 1);\\n\\t\\t    if (tmp.length() > longest.length()) {\\n\\t\\t\\tlongest = tmp;\\n\\t\\t    }\\n\\t\\t}\\n \\treturn longest;}\\n\\n    public String helper(String s, int begin, int end) {\\n\\t \\n    while (begin >= 0 && end <= s.length() - 1 && s.charAt(begin) == s.charAt(end)) {\\n\\n\\t\\tbegin--;\\n\\n\\t\\tend++;\\n\\n\\t}\\n\\t\\n     return s.substring(begin + 1, end);\\n    }",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "    public String longestPalindrome(String s) {\\n\\tif (s.isEmpty()) {\\n\\t\\treturn null;\\n\\t}\\n \\n\\tif (s.length() == 1) {\\n\\t\\treturn s;\\n\\t}\\n \\n\\tString longest = s.substring(0, 1);\\n\\tfor (int i = 0; i < s.length(); i++) {\\n\\t    \\n\\t\\t// get longest palindrome with center of i\\n\\t\\tString tmp = helper(s, i, i);\\n\\t    \\tif (tmp.length() > longest.length()) {\\n\\t\\t\\tlongest = tmp;\\n\\t    \\t}\\n\\t\\t\\n\\t\\t// get longest palindrome with center of i, i+1\\n\\t\\ttmp = helper(s, i, i + 1);\\n\\t\\t    if (tmp.length() > longest.length()) {\\n\\t\\t\\tlongest = tmp;\\n\\t\\t    }\\n\\t\\t}\\n \\treturn longest;}\\n\\n    public String helper(String s, int begin, int end) {\\n\\t \\n    while (begin >= 0 && end <= s.length() - 1 && s.charAt(begin) == s.charAt(end)) {\\n\\n\\t\\tbegin--;\\n\\n\\t\\tend++;\\n\\n\\t}\\n\\t\\n     return s.substring(begin + 1, end);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 119765,
                "title": "python-dp-solution",
                "content": "Python dynamic programming solution. No optimizations.\\n```\\nclass Solution:\\n    def longestPalindrome(self, string):\\n        \"\"\" Dynamic programming algorithm. Based on idea that current\\n        substring(i, j) is a palindrome if substring(i + 1, j - 1) is\\n        a palindrome and Si == Sj, i.e. In other words, if we already know that\\n        current substring is a palindrome we need to add equal characters on both\\n        sides to make a longer palindrome.\\n\\n        Time complexity: O(n ^ 2). Space complexity: O(n ^ 2), where\\n        n is the length of the string.\\n        \"\"\"\\n        # initialize 2-D table for storing results\\n        n = len(string)\\n        results = [[False] * n for i in range(n)]\\n        x, y = 0, 0  # start, end of longest palindromic substring so far\\n\\n        # every 1-letter substring is a palindrome\\n        for i in range(n):\\n            results[i][i] = True\\n\\n        # 2-letter substring(i, j) is a palindrome if string[i] == string[j]\\n        for i in range(n - 1):\\n            if string[i] == string[i + 1]:\\n                results[i][i + 1] = True\\n                # change longest palindrome to the 1st 2-letter palindrome\\n                if not x and not y:\\n                    x, y = i, i + 1\\n\\n        # results[i][j] = True if results[i + 1][j - 1] == True\\n        # and string[i] == string[j]\\n        for k in range(2, n):\\n            for i in range(n - 2):\\n                j = i + k\\n                # break the loop if it exceeds the boundaries of the matrix\\n                if j == n:\\n                    break\\n                # check if current substring is a palindrome\\n                if results[i + 1][j - 1] and string[i] == string[j]:\\n                    results[i][j] = True\\n                    # len(substring(i, j)) > len(substring(x, y))\\n                    # this way we always choose 1st longest palindrome\\n                    if j - i > y - x:\\n                        x, y = i, j\\n\\n        return string[x:y + 1]\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def longestPalindrome(self, string):\\n        \"\"\" Dynamic programming algorithm. Based on idea that current\\n        substring(i, j) is a palindrome if substring(i + 1, j - 1) is\\n        a palindrome and Si == Sj, i.e. In other words, if we already know that\\n        current substring is a palindrome we need to add equal characters on both\\n        sides to make a longer palindrome.\\n\\n        Time complexity: O(n ^ 2). Space complexity: O(n ^ 2), where\\n        n is the length of the string.\\n        \"\"\"\\n        # initialize 2-D table for storing results\\n        n = len(string)\\n        results = [[False] * n for i in range(n)]\\n        x, y = 0, 0  # start, end of longest palindromic substring so far\\n\\n        # every 1-letter substring is a palindrome\\n        for i in range(n):\\n            results[i][i] = True\\n\\n        # 2-letter substring(i, j) is a palindrome if string[i] == string[j]\\n        for i in range(n - 1):\\n            if string[i] == string[i + 1]:\\n                results[i][i + 1] = True\\n                # change longest palindrome to the 1st 2-letter palindrome\\n                if not x and not y:\\n                    x, y = i, i + 1\\n\\n        # results[i][j] = True if results[i + 1][j - 1] == True\\n        # and string[i] == string[j]\\n        for k in range(2, n):\\n            for i in range(n - 2):\\n                j = i + k\\n                # break the loop if it exceeds the boundaries of the matrix\\n                if j == n:\\n                    break\\n                # check if current substring is a palindrome\\n                if results[i + 1][j - 1] and string[i] == string[j]:\\n                    results[i][j] = True\\n                    # len(substring(i, j)) > len(substring(x, y))\\n                    # this way we always choose 1st longest palindrome\\n                    if j - i > y - x:\\n                        x, y = i, j\\n\\n        return string[x:y + 1]\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3003,
                "title": "java-easy-understanding-solution-beats-97",
                "content": "    public String longestPalindrome(String s) {\\n        char[] ca = s.toCharArray();\\n        int rs = 0, re = 0;\\n        int max = 0;\\n        for(int i = 0; i < ca.length; i++) {\\n            if(isPalindrome(ca, i - max - 1, i)) {\\n                rs = i - max - 1; re = i;\\n                max += 2;\\n            } else if(isPalindrome(ca, i - max, i)) {\\n                rs = i - max; re = i;\\n                max += 1;\\n            }\\n        }\\n        return s.substring(rs, re + 1);\\n    }\\n    \\n    private boolean isPalindrome(char[] ca, int s, int e) {\\n        if(s < 0) return false;\\n        \\n        while(s < e) {\\n            if(ca[s++] != ca[e--]) return false;\\n        }\\n        return true;\\n    }",
                "solutionTags": [],
                "code": "    public String longestPalindrome(String s) {\\n        char[] ca = s.toCharArray();\\n        int rs = 0, re = 0;\\n        int max = 0;\\n        for(int i = 0; i < ca.length; i++) {\\n            if(isPalindrome(ca, i - max - 1, i)) {\\n                rs = i - max - 1; re = i;\\n                max += 2;\\n            } else if(isPalindrome(ca, i - max, i)) {\\n                rs = i - max; re = i;\\n                max += 1;\\n            }\\n        }\\n        return s.substring(rs, re + 1);\\n    }\\n    \\n    private boolean isPalindrome(char[] ca, int s, int e) {\\n        if(s < 0) return false;\\n        \\n        while(s < e) {\\n            if(ca[s++] != ca[e--]) return false;\\n        }\\n        return true;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3497051,
                "title": "c-java-python-javascript-detailed-explanation-easy-solution-3-approaches",
                "content": "# 1. Brute Force Approach\\n\\n# Intuition:\\nThe problem asks to find the longest palindrome in a given string. A palindrome is a string that is the same when read from both ends. For example, \"racecar\" is a palindrome because it is the same when read from left to right and right to left.\\n\\n# Approach:\\n1. We start by iterating through all possible substrings of the given string using two nested loops, i and j, where i represents the starting index and j represents the ending index of the substring.\\n2. For each substring, we check if it is a palindrome or not by using a helper function check(), which takes the starting and ending indices of the substring and returns true if it is a palindrome and false otherwise.\\n3. If the substring is a palindrome, we update the maximum length of palindromic substring seen so far and the starting index of this substring.\\n4. After iterating through all possible substrings, we return the longest palindromic substring.\\n\\n# Complexity:\\n- Time Complexity: The time complexity of the above solution is O(n^3) because we have two nested loops and for each substring, we check whether it\\'s a palindrome or not using another loop. In the worst case, the check function will be called for each substring, which takes O(n) time, making the overall time complexity O(n^3).\\n- Space Complexity: The space complexity of the solution is O(1) because we are not using any additional space apart from a few integer variables to keep track of the longest palindromic substring seen so far.\\n---\\n# C++\\n```\\nclass Solution {\\npublic:\\n    bool check(string &s, int i, int j){\\n        while(i<j){\\n            if(s[i] != s[j]){\\n                return false;\\n            }\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }            \\n    string longestPalindrome(string s) {\\n        int n = s.size();\\n        int starting_index = 0;\\n        int max_len = 0;\\n        for(int i=0; i<n; i++){\\n            for(int j=i; j<n; j++){\\n                if(check(s, i, j)){\\n                    if(j-i+1 > max_len){\\n                        max_len = j-i+1;\\n                        starting_index = i;\\n                    }\\n                }\\n            }\\n        }\\n        return s.substr(starting_index, max_len);\\n    }\\n}; \\n```\\n\\n---\\n# JAVA\\n```\\nclass Solution {\\n    public boolean check(String s, int i, int j){\\n        while(i<j){\\n            if(s.charAt(i) != s.charAt(j)){\\n                return false;\\n            }\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }            \\n    public String longestPalindrome(String s) {\\n        int n = s.length();\\n        int starting_index = 0;\\n        int max_len = 0;\\n        for(int i=0; i<n; i++){\\n            for(int j=i; j<n; j++){\\n                if(check(s, i, j)){\\n                    if(j-i+1 > max_len){\\n                        max_len = j-i+1;\\n                        starting_index = i;\\n                    }\\n                }\\n            }\\n        }\\n        return s.substring(starting_index, starting_index+max_len);\\n    }\\n}\\n```\\n---\\n# Python\\n```\\nclass Solution(object):\\n    def check(self, s, i, j):\\n        while i<j:\\n            if s[i] != s[j]:\\n                return False\\n            i += 1\\n            j -= 1\\n        return True\\n    \\n    def longestPalindrome(self, s):\\n        n = len(s)\\n        starting_index = 0\\n        max_len = 0\\n        for i in range(n):\\n            for j in range(i, n):\\n                if self.check(s, i, j):\\n                    if j-i+1 > max_len:\\n                        max_len = j-i+1\\n                        starting_index = i\\n        return s[starting_index:starting_index+max_len]\\n\\n```\\n---\\n# JavaScript\\n```\\nvar check = function(s, i, j) {\\n    while (i < j) {\\n        if (s[i] !== s[j]) {\\n            return false;\\n        }\\n        i++;\\n        j--;\\n    }\\n    return true;\\n}\\n\\nvar longestPalindrome = function(s) {\\n    const n = s.length;\\n    let starting_index = 0;\\n    let max_len = 0;\\n    for (let i = 0; i < n; i++) {\\n        for (let j = i; j < n; j++) {\\n            if (check(s, i, j)) {\\n                if (j - i + 1 > max_len) {\\n                    max_len = j - i + 1;\\n                    starting_index = i;\\n                }\\n            }\\n        }\\n    }\\n    return s.substring(starting_index, starting_index + max_len);\\n}\\n```\\n\\n---\\n# 2. Better Approach\\n# Intuition:\\nA Better approach is to use dynamic programming to solve the problem. We can define a two-dimensional boolean array dp where dp[i][j] represents whether the substring s[i:j+1] is a palindrome or not. We can then fill in the dp array starting with substrings of length 1 and 2, and then use these values to fill in the values for longer substrings. We can keep track of the longest palindrome substring found so far and return it at the end.\\n\\n\\n# Approach:\\n\\n1. Create a two-dimensional boolean array dp of size n x n, where n is the length of the input string s. Initialize all values of dp to false.\\n\\n2. Iterate over the string s and mark all substrings of length 1 as palindromes, i.e., set dp[i][i] to true for all i from 0 to n-1. Also, initialize a string variable ans to the first character of the input string s and a variable maxLength to 1.\\n\\n3. For substrings of length 2 and greater, iterate over all possible substring lengths len from 2 to n. For each length, iterate over all possible starting indices i from 0 to n-len. Calculate the ending index j as j = i + len - 1.\\n\\n4. If s[i] == s[j], then check if the substring s[i+1:j] is a palindrome by checking if dp[i+1][j-1] is true. If it is true or len == 2, then set dp[i][j] to true and update ans and maxLength if the current substring is longer than the current longest palindrome substring.\\n\\n5. After filling in the dp array, return the string variable ans, which contains the longest palindrome substring found.\\n\\n\\n# Complexity:\\n\\n- Time Complexity: O(n^2) where n is the length of the input string. This is because we are filling in a two-dimensional boolean array of size n x n and checking each substring only once.\\n\\n- Space Complexity: O(n^2) where n is the length of the input string. This is because we are using a two-dimensional boolean array of size n x n to store the intermediate results.\\n\\n# C++\\n```\\nclass Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n        int n = s.size();\\n        vector<vector<bool>> dp(n, vector<bool>(n, false));\\n        string ans = \"\";\\n        int maxLength = 0;\\n        \\n        // Base case: all substrings of length 1 are palindromes\\n        for (int i = 0; i < n; i++) {\\n            dp[i][i] = true;\\n            ans = s[i];\\n            maxLength = 1;\\n        }\\n        \\n        // Fill in the dp table for substrings of length 2 and greater\\n        for (int len = 2; len <= n; len++) {\\n            for (int i = 0; i < n-len+1; i++) {\\n                int j = i+len-1;\\n                if (s[i] == s[j]) {\\n                    if (len == 2 || dp[i+1][j-1]) {\\n                        dp[i][j] = true;\\n                        if (len > maxLength) {\\n                            ans = s.substr(i, len);\\n                            maxLength = len;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n---\\n# Python\\n```\\nclass Solution(object):\\n    def longestPalindrome(self, s):\\n        n = len(s)\\n        dp = [[False for i in range(n)] for j in range(n)]\\n        ans = \"\"\\n        maxLength = 0\\n        \\n        # Base case: all substrings of length 1 are palindromes\\n        for i in range(n):\\n            dp[i][i] = True\\n            ans = s[i]\\n            maxLength = 1\\n        \\n        # Fill in the dp table for substrings of length 2 and greater\\n        for length in range(2, n+1):\\n            for i in range(n-length+1):\\n                j = i+length-1\\n                if s[i] == s[j]:\\n                    if length == 2 or dp[i+1][j-1]:\\n                        dp[i][j] = True\\n                        if length > maxLength:\\n                            ans = s[i:i+length]\\n                            maxLength = length\\n        \\n        return ans\\n\\n```\\n---\\n# JAVA\\n```\\npublic class Solution {\\n    public String longestPalindrome(String s) {\\n        int n = s.length();\\n        boolean[][] dp = new boolean[n][n];\\n        String ans = \"\";\\n        int maxLength = 0;\\n\\n        // Base case: all substrings of length 1 are palindromes\\n        for (int i = 0; i < n; i++) {\\n            dp[i][i] = true;\\n            ans = s.substring(i, i+1);\\n            maxLength = 1;\\n        }\\n\\n        // Fill in the dp table for substrings of length 2 and greater\\n        for (int len = 2; len <= n; len++) {\\n            for (int i = 0; i < n-len+1; i++) {\\n                int j = i+len-1;\\n                if (s.charAt(i) == s.charAt(j)) {\\n                    if (len == 2 || dp[i+1][j-1]) {\\n                        dp[i][j] = true;\\n                        if (len > maxLength) {\\n                            ans = s.substring(i, i+len);\\n                            maxLength = len;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n\\n```\\n\\n---\\n# JavaScript\\n```\\nvar longestPalindrome = function(s) {\\n    var n = s.length;\\n    var dp = Array.from({length: n}, () => Array(n).fill(false));\\n    var ans = \"\";\\n    var maxLength = 0;\\n\\n    // Base case: all substrings of length 1 are palindromes\\n    for (var i = 0; i < n; i++) {\\n        dp[i][i] = true;\\n        ans = s[i];\\n        maxLength = 1;\\n    }\\n\\n    // Fill in the dp table for substrings of length 2 and greater\\n    for (var len = 2; len <= n; len++) {\\n        for (var i = 0; i < n-len+1; i++) {\\n            var j = i+len-1;\\n            if (s[i] == s[j]) {\\n                if (len == 2 || dp[i+1][j-1]) {\\n                    dp[i][j] = true;\\n                    if (len > maxLength) {\\n                        ans = s.substring(i, i+len);\\n                        maxLength = len;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    return ans;\\n};\\n\\n```\\n\\n---\\n\\n# 3. Optimal Approach\\n# Intuition:\\nThe given code aims to find the longest palindrome in a given string. It uses a two-pointer approach to expand around each center and checks if the characters on both sides are equal. The variable `minstart` keeps track of the starting index of the longest palindrome found so far, and `maxlen` stores its length.\\n\\n# Approach:\\n1. Initialize variables `minstart` and `maxlen` as 0 to keep track of the longest palindrome found so far.\\n2. Iterate over each character in the string using a variable `i`.\\n3. Check if the remaining length from `i` to the end of the string is less than half of the `maxlen`. If it is, there is no possibility of finding a longer palindrome, so we break out of the loop.\\n4. Set `l` and `r` as `i`, representing the left and right pointers of the potential palindrome.\\n5. While `r` is within the string bounds and the character at `r` is equal to the next character, increment `r`.\\n6. Update `i` to be `r + 1` since all the characters from `l` to `r` have been accounted for.\\n7. While `l` is greater than 0 and `r` is within the string bounds, and the characters at `l-1` and `r+1` are equal, decrement `l` and increment `r`.\\n8. Calculate the length of the potential palindrome using `newlen = r - l + 1`.\\n9. If `newlen` is greater than `maxlen`, update `maxlen` with `newlen` and `minstart` with `l`.\\n10. After the loop finishes, return the substring of `s` starting from `minstart` with length `maxlen`, which represents the longest palindrome found in the string.\\n\\n# Complexity:\\n- Time Complexity: The code uses a two-pointer approach to expand around each center, resulting in a linear time complexity of O(n), where n is the length of the string.\\n- Space Complexity: The code uses a constant amount of extra space, resulting in a space complexity of O(1).\\n# C++\\n```\\nclass Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n        int n = s.size();\\n        if (n == 0)\\n            return \"\";\\n        if (n == 1)\\n            return s;\\n        \\n        int minstart = 0, maxlen = 0;\\n        \\n        for (int i = 0; i < n; ) {\\n            if (n - i < maxlen / 2)\\n                break;\\n            \\n            int l = i, r = i;\\n            \\n            // Find the center of the palindrome\\n            while (r < n && s[r] == s[r + 1])\\n                r++;\\n            \\n            // Update the next starting point\\n            i = r + 1;\\n            \\n            // Expand around the center to find the longest palindrome\\n            while (l > 0 && r < n && s[l - 1] == s[r + 1]) {\\n                l--;\\n                r++;\\n            }\\n            \\n            int newlen = r - l + 1;\\n            if (newlen > maxlen) {\\n                maxlen = newlen;\\n                minstart = l;\\n            }\\n        }\\n        \\n        return s.substr(minstart, maxlen);\\n    }\\n};\\n```\\n# JAVA\\n```\\nclass Solution {\\n    public String longestPalindrome(String s) {\\n        int n = s.length();\\n        if (n == 0)\\n            return \"\";\\n        if (n == 1)\\n            return s;\\n        \\n        int minstart = 0, maxlen = 0;\\n        \\n        for (int i = 0; i < n; ) {\\n            if (n - i < maxlen / 2)\\n                break;\\n            \\n            int l = i, r = i;\\n            \\n            // Find the center of the palindrome\\n            while (r < n - 1 && s.charAt(r) == s.charAt(r + 1))\\n                r++;\\n            \\n            // Update the next starting point\\n            i = r + 1;\\n            \\n            // Expand around the center to find the longest palindrome\\n            while (l > 0 && r < n - 1 && s.charAt(l - 1) == s.charAt(r + 1)) {\\n                l--;\\n                r++;\\n            }\\n            \\n            int newlen = r - l + 1;\\n            if (newlen > maxlen) {\\n                maxlen = newlen;\\n                minstart = l;\\n            }\\n        }\\n        \\n        return s.substring(minstart, minstart + maxlen);\\n    }\\n}\\n\\n```\\n# Python\\n```\\nclass Solution(object):\\n    def longestPalindrome(self, s):\\n        n = len(s)\\n        if n == 0:\\n            return \"\"\\n        if n == 1:\\n            return s\\n        \\n        minstart = 0\\n        maxlen = 0\\n        \\n        i = 0\\n        while i < n:\\n            if n - i < maxlen / 2:\\n                break\\n            \\n            l = i\\n            r = i\\n            \\n            # Find the center of the palindrome\\n            while r < n - 1 and s[r] == s[r + 1]:\\n                r += 1\\n            \\n            # Update the next starting point\\n            i = r + 1\\n            \\n            # Expand around the center to find the longest palindrome\\n            while l > 0 and r < n - 1 and s[l - 1] == s[r + 1]:\\n                l -= 1\\n                r += 1\\n            \\n            newlen = r - l + 1\\n            if newlen > maxlen:\\n                maxlen = newlen\\n                minstart = l\\n        \\n        return s[minstart:minstart + maxlen]\\n\\n```\\n# JavaScript\\n```\\nvar longestPalindrome = function(s) {\\n    const n = s.length;\\n    if (n === 0)\\n        return \"\";\\n    if (n === 1)\\n        return s;\\n\\n    let minstart = 0, maxlen = 0;\\n\\n    let i = 0;\\n    while (i < n) {\\n        if (n - i < maxlen / 2)\\n            break;\\n\\n        let l = i, r = i;\\n\\n        // Find the center of the palindrome\\n        while (r < n - 1 && s[r] === s[r + 1])\\n            r++;\\n\\n        // Update the next starting point\\n        i = r + 1;\\n\\n        // Expand around the center to find the longest palindrome\\n        while (l > 0 && r < n - 1 && s[l - 1] === s[r + 1]) {\\n            l--;\\n            r++;\\n        }\\n\\n        const newlen = r - l + 1;\\n        if (newlen > maxlen) {\\n            maxlen = newlen;\\n            minstart = l;\\n        }\\n    }\\n\\n    return s.substring(minstart, minstart + maxlen);\\n}\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "JavaScript",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(string &s, int i, int j){\\n        while(i<j){\\n            if(s[i] != s[j]){\\n                return false;\\n            }\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }            \\n    string longestPalindrome(string s) {\\n        int n = s.size();\\n        int starting_index = 0;\\n        int max_len = 0;\\n        for(int i=0; i<n; i++){\\n            for(int j=i; j<n; j++){\\n                if(check(s, i, j)){\\n                    if(j-i+1 > max_len){\\n                        max_len = j-i+1;\\n                        starting_index = i;\\n                    }\\n                }\\n            }\\n        }\\n        return s.substr(starting_index, max_len);\\n    }\\n}; \\n```\n```\\nclass Solution {\\n    public boolean check(String s, int i, int j){\\n        while(i<j){\\n            if(s.charAt(i) != s.charAt(j)){\\n                return false;\\n            }\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }            \\n    public String longestPalindrome(String s) {\\n        int n = s.length();\\n        int starting_index = 0;\\n        int max_len = 0;\\n        for(int i=0; i<n; i++){\\n            for(int j=i; j<n; j++){\\n                if(check(s, i, j)){\\n                    if(j-i+1 > max_len){\\n                        max_len = j-i+1;\\n                        starting_index = i;\\n                    }\\n                }\\n            }\\n        }\\n        return s.substring(starting_index, starting_index+max_len);\\n    }\\n}\\n```\n```\\nclass Solution(object):\\n    def check(self, s, i, j):\\n        while i<j:\\n            if s[i] != s[j]:\\n                return False\\n            i += 1\\n            j -= 1\\n        return True\\n    \\n    def longestPalindrome(self, s):\\n        n = len(s)\\n        starting_index = 0\\n        max_len = 0\\n        for i in range(n):\\n            for j in range(i, n):\\n                if self.check(s, i, j):\\n                    if j-i+1 > max_len:\\n                        max_len = j-i+1\\n                        starting_index = i\\n        return s[starting_index:starting_index+max_len]\\n\\n```\n```\\nvar check = function(s, i, j) {\\n    while (i < j) {\\n        if (s[i] !== s[j]) {\\n            return false;\\n        }\\n        i++;\\n        j--;\\n    }\\n    return true;\\n}\\n\\nvar longestPalindrome = function(s) {\\n    const n = s.length;\\n    let starting_index = 0;\\n    let max_len = 0;\\n    for (let i = 0; i < n; i++) {\\n        for (let j = i; j < n; j++) {\\n            if (check(s, i, j)) {\\n                if (j - i + 1 > max_len) {\\n                    max_len = j - i + 1;\\n                    starting_index = i;\\n                }\\n            }\\n        }\\n    }\\n    return s.substring(starting_index, starting_index + max_len);\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n        int n = s.size();\\n        vector<vector<bool>> dp(n, vector<bool>(n, false));\\n        string ans = \"\";\\n        int maxLength = 0;\\n        \\n        // Base case: all substrings of length 1 are palindromes\\n        for (int i = 0; i < n; i++) {\\n            dp[i][i] = true;\\n            ans = s[i];\\n            maxLength = 1;\\n        }\\n        \\n        // Fill in the dp table for substrings of length 2 and greater\\n        for (int len = 2; len <= n; len++) {\\n            for (int i = 0; i < n-len+1; i++) {\\n                int j = i+len-1;\\n                if (s[i] == s[j]) {\\n                    if (len == 2 || dp[i+1][j-1]) {\\n                        dp[i][j] = true;\\n                        if (len > maxLength) {\\n                            ans = s.substr(i, len);\\n                            maxLength = len;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution(object):\\n    def longestPalindrome(self, s):\\n        n = len(s)\\n        dp = [[False for i in range(n)] for j in range(n)]\\n        ans = \"\"\\n        maxLength = 0\\n        \\n        # Base case: all substrings of length 1 are palindromes\\n        for i in range(n):\\n            dp[i][i] = True\\n            ans = s[i]\\n            maxLength = 1\\n        \\n        # Fill in the dp table for substrings of length 2 and greater\\n        for length in range(2, n+1):\\n            for i in range(n-length+1):\\n                j = i+length-1\\n                if s[i] == s[j]:\\n                    if length == 2 or dp[i+1][j-1]:\\n                        dp[i][j] = True\\n                        if length > maxLength:\\n                            ans = s[i:i+length]\\n                            maxLength = length\\n        \\n        return ans\\n\\n```\n```\\npublic class Solution {\\n    public String longestPalindrome(String s) {\\n        int n = s.length();\\n        boolean[][] dp = new boolean[n][n];\\n        String ans = \"\";\\n        int maxLength = 0;\\n\\n        // Base case: all substrings of length 1 are palindromes\\n        for (int i = 0; i < n; i++) {\\n            dp[i][i] = true;\\n            ans = s.substring(i, i+1);\\n            maxLength = 1;\\n        }\\n\\n        // Fill in the dp table for substrings of length 2 and greater\\n        for (int len = 2; len <= n; len++) {\\n            for (int i = 0; i < n-len+1; i++) {\\n                int j = i+len-1;\\n                if (s.charAt(i) == s.charAt(j)) {\\n                    if (len == 2 || dp[i+1][j-1]) {\\n                        dp[i][j] = true;\\n                        if (len > maxLength) {\\n                            ans = s.substring(i, i+len);\\n                            maxLength = len;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n\\n```\n```\\nvar longestPalindrome = function(s) {\\n    var n = s.length;\\n    var dp = Array.from({length: n}, () => Array(n).fill(false));\\n    var ans = \"\";\\n    var maxLength = 0;\\n\\n    // Base case: all substrings of length 1 are palindromes\\n    for (var i = 0; i < n; i++) {\\n        dp[i][i] = true;\\n        ans = s[i];\\n        maxLength = 1;\\n    }\\n\\n    // Fill in the dp table for substrings of length 2 and greater\\n    for (var len = 2; len <= n; len++) {\\n        for (var i = 0; i < n-len+1; i++) {\\n            var j = i+len-1;\\n            if (s[i] == s[j]) {\\n                if (len == 2 || dp[i+1][j-1]) {\\n                    dp[i][j] = true;\\n                    if (len > maxLength) {\\n                        ans = s.substring(i, i+len);\\n                        maxLength = len;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    return ans;\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n        int n = s.size();\\n        if (n == 0)\\n            return \"\";\\n        if (n == 1)\\n            return s;\\n        \\n        int minstart = 0, maxlen = 0;\\n        \\n        for (int i = 0; i < n; ) {\\n            if (n - i < maxlen / 2)\\n                break;\\n            \\n            int l = i, r = i;\\n            \\n            // Find the center of the palindrome\\n            while (r < n && s[r] == s[r + 1])\\n                r++;\\n            \\n            // Update the next starting point\\n            i = r + 1;\\n            \\n            // Expand around the center to find the longest palindrome\\n            while (l > 0 && r < n && s[l - 1] == s[r + 1]) {\\n                l--;\\n                r++;\\n            }\\n            \\n            int newlen = r - l + 1;\\n            if (newlen > maxlen) {\\n                maxlen = newlen;\\n                minstart = l;\\n            }\\n        }\\n        \\n        return s.substr(minstart, maxlen);\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public String longestPalindrome(String s) {\\n        int n = s.length();\\n        if (n == 0)\\n            return \"\";\\n        if (n == 1)\\n            return s;\\n        \\n        int minstart = 0, maxlen = 0;\\n        \\n        for (int i = 0; i < n; ) {\\n            if (n - i < maxlen / 2)\\n                break;\\n            \\n            int l = i, r = i;\\n            \\n            // Find the center of the palindrome\\n            while (r < n - 1 && s.charAt(r) == s.charAt(r + 1))\\n                r++;\\n            \\n            // Update the next starting point\\n            i = r + 1;\\n            \\n            // Expand around the center to find the longest palindrome\\n            while (l > 0 && r < n - 1 && s.charAt(l - 1) == s.charAt(r + 1)) {\\n                l--;\\n                r++;\\n            }\\n            \\n            int newlen = r - l + 1;\\n            if (newlen > maxlen) {\\n                maxlen = newlen;\\n                minstart = l;\\n            }\\n        }\\n        \\n        return s.substring(minstart, minstart + maxlen);\\n    }\\n}\\n\\n```\n```\\nclass Solution(object):\\n    def longestPalindrome(self, s):\\n        n = len(s)\\n        if n == 0:\\n            return \"\"\\n        if n == 1:\\n            return s\\n        \\n        minstart = 0\\n        maxlen = 0\\n        \\n        i = 0\\n        while i < n:\\n            if n - i < maxlen / 2:\\n                break\\n            \\n            l = i\\n            r = i\\n            \\n            # Find the center of the palindrome\\n            while r < n - 1 and s[r] == s[r + 1]:\\n                r += 1\\n            \\n            # Update the next starting point\\n            i = r + 1\\n            \\n            # Expand around the center to find the longest palindrome\\n            while l > 0 and r < n - 1 and s[l - 1] == s[r + 1]:\\n                l -= 1\\n                r += 1\\n            \\n            newlen = r - l + 1\\n            if newlen > maxlen:\\n                maxlen = newlen\\n                minstart = l\\n        \\n        return s[minstart:minstart + maxlen]\\n\\n```\n```\\nvar longestPalindrome = function(s) {\\n    const n = s.length;\\n    if (n === 0)\\n        return \"\";\\n    if (n === 1)\\n        return s;\\n\\n    let minstart = 0, maxlen = 0;\\n\\n    let i = 0;\\n    while (i < n) {\\n        if (n - i < maxlen / 2)\\n            break;\\n\\n        let l = i, r = i;\\n\\n        // Find the center of the palindrome\\n        while (r < n - 1 && s[r] === s[r + 1])\\n            r++;\\n\\n        // Update the next starting point\\n        i = r + 1;\\n\\n        // Expand around the center to find the longest palindrome\\n        while (l > 0 && r < n - 1 && s[l - 1] === s[r + 1]) {\\n            l--;\\n            r++;\\n        }\\n\\n        const newlen = r - l + 1;\\n        if (newlen > maxlen) {\\n            maxlen = newlen;\\n            minstart = l;\\n        }\\n    }\\n\\n    return s.substring(minstart, minstart + maxlen);\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1640332,
                "title": "accepted-solution-for-swift",
                "content": "<blockquote>\\n<b>Disclaimer:</b> By using any content from this post or thread, you release the author(s) from all liability and warranty of any kind. You are free to use the content freely and as you see fit. Any suggestions for improvement are welcome and greatly appreciated! Happy coding!\\n</blockquote>\\n\\n```swift\\nclass Solution {\\n    func longestPalindrome(_ s: String) -> String {\\n        let len = s.count, arr = Array(s)\\n        if len <= 1 { return s }\\n        var lhs = 0, rhs = 0, dp = Array(repeating: Array(repeating: false, count: len), count: len)\\n        for i in 1..<len {\\n            for j in 0..<i where arr[j] == arr[i] && (dp[j+1][i-1] || i - j <= 2) {\\n                dp[j][i] = true\\n                if i - j > rhs - lhs {\\n                    lhs = j\\n                    rhs = i\\n                }\\n            }\\n        }\\n        return String(arr[lhs...rhs])\\n    }\\n}\\n```\\n\\n---\\n\\n<p>\\n<details>\\n<summary>\\n<img src=\"https://git.io/JDblm\" height=\"24\">\\n<b>TEST CASES</b>\\n</summary>\\n\\n<p><pre>\\n<b>Result:</b> Executed 2 tests, with 0 failures (0 unexpected) in 0.008 (0.010) seconds\\n</pre></p>\\n\\n```swift\\nclass Tests {\\n    \\n    private typealias sol = Solution\\n    \\n    static func test0() {\\n        let value = sol().longestPalindrome(\"babad\")\\n        print(value == \"bab\")\\n    }\\n    \\n    static func test1() {\\n        let value = sol().longestPalindrome(\"cbbd\")\\n        print(value == \"bb\")\\n    }\\n}\\n\\nTests.test0()\\nTests.test1()\\n```\\n\\n</details>\\n</p>",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func longestPalindrome(_ s: String) -> String {\\n        let len = s.count, arr = Array(s)\\n        if len <= 1 { return s }\\n        var lhs = 0, rhs = 0, dp = Array(repeating: Array(repeating: false, count: len), count: len)\\n        for i in 1..<len {\\n            for j in 0..<i where arr[j] == arr[i] && (dp[j+1][i-1] || i - j <= 2) {\\n                dp[j][i] = true\\n                if i - j > rhs - lhs {\\n                    lhs = j\\n                    rhs = i\\n                }\\n            }\\n        }\\n        return String(arr[lhs...rhs])\\n    }\\n}\\n```\n```swift\\nclass Tests {\\n    \\n    private typealias sol = Solution\\n    \\n    static func test0() {\\n        let value = sol().longestPalindrome(\"babad\")\\n        print(value == \"bab\")\\n    }\\n    \\n    static func test1() {\\n        let value = sol().longestPalindrome(\"cbbd\")\\n        print(value == \"bb\")\\n    }\\n}\\n\\nTests.test0()\\nTests.test1()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1245748,
                "title": "c-clean-top-down",
                "content": "```\\nclass Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n        int memo[1001][1001];\\n        memset(memo, -1, sizeof(memo));\\n        vector<int> answer = {0, 0, 1};\\n        helper(0, s.size() - 1, s, memo, answer);\\n        return s.substr(answer[0], answer[2]);\\n    }\\n    \\n    bool helper(int l, int r, string &s, int memo[][1001], vector<int> &answer) {\\n\\t\\t// Check if [ L ... R ] is already calculated before\\n        if (memo[l][r] != -1) {\\n            return memo[l][r];         \\n        }\\n        \\n\\t\\t// Base case, every single letter or empty string is also a palindrome\\n        if (l >= r) {\\n            return true;\\n        }\\n        \\n        // Possible palindrome beginning\\n        bool found = false;\\n        if (s[l] == s[r]) {\\n            found = true && helper(l + 1, r - 1, s, memo, answer);\\n        }\\n        \\n        // Try other possibilities\\n        helper(l + 1, r , s, memo, answer);\\n        helper(l, r - 1, s, memo, answer);\\n        \\n        // Update longest palindrome position and width\\n        if (found && (r - l + 1) > answer[2]) {\\n            answer = {l, r, (r - l + 1)};\\n        }\\n        \\n        // Memoization\\n        memo[l][r] = found;\\n        \\n        return found;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n        int memo[1001][1001];\\n        memset(memo, -1, sizeof(memo));\\n        vector<int> answer = {0, 0, 1};\\n        helper(0, s.size() - 1, s, memo, answer);\\n        return s.substr(answer[0], answer[2]);\\n    }\\n    \\n    bool helper(int l, int r, string &s, int memo[][1001], vector<int> &answer) {\\n\\t\\t// Check if [ L ... R ] is already calculated before\\n        if (memo[l][r] != -1) {\\n            return memo[l][r];         \\n        }\\n        \\n\\t\\t// Base case, every single letter or empty string is also a palindrome\\n        if (l >= r) {\\n            return true;\\n        }\\n        \\n        // Possible palindrome beginning\\n        bool found = false;\\n        if (s[l] == s[r]) {\\n            found = true && helper(l + 1, r - 1, s, memo, answer);\\n        }\\n        \\n        // Try other possibilities\\n        helper(l + 1, r , s, memo, answer);\\n        helper(l, r - 1, s, memo, answer);\\n        \\n        // Update longest palindrome position and width\\n        if (found && (r - l + 1) > answer[2]) {\\n            answer = {l, r, (r - l + 1)};\\n        }\\n        \\n        // Memoization\\n        memo[l][r] = found;\\n        \\n        return found;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1024308,
                "title": "python-clean-o-n-2-solution-explained",
                "content": "Let us look at possible places of middle of our palindrome and expand to the left and to the right until we either reached on of the ends of symbols are not equal. Also, because we need to return not only length of longest palindromic substring, but substring itself, our `helper` function will return this string.\\n\\nNote also, that there are two different type of palindromes:\\n1. With odd length, we use `helper(k, k)` for them.\\n2. With even length, we use `helper(k, k+1)` for them.\\n\\n**Complexity** There will be `2n - 1` possible centers and `O(n)` comparison for each of them, so final time complexity is `O(n^2)`. Space complexity is `O(n)`\\n\\n**Further discussion** there is also classical dynamic programming for this problem with also `O(n^2)` complexity, however in practice it can work much slower if we do not do optimiaztions: reason that it will be indeed `n^2` operations, whereas on our approach here we do a lot of early stoppings. There is also ofcourse Manacher\\'s algorithm with complexity `O(n)`, which sometimes useful for competitions, and you should have code avaliable somewhere, but which is in my opitions out of scope for middle difficulty problem.\\n\\n```\\nclass Solution:\\n    def longestPalindrome(self, s):\\n        n, ans = len(s), \"\"\\n        def helper(i, j):\\n            while i >= 0 and j < n and s[i] == s[j]:\\n                i, j = i - 1, j + 1\\n            return s[i + 1:j]\\n        \\n        for k in range(n):\\n            ans = max(helper(k, k), helper(k, k + 1), ans, key=len)\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def longestPalindrome(self, s):\\n        n, ans = len(s), \"\"\\n        def helper(i, j):\\n            while i >= 0 and j < n and s[i] == s[j]:\\n                i, j = i - 1, j + 1\\n            return s[i + 1:j]\\n        \\n        for k in range(n):\\n            ans = max(helper(k, k), helper(k, k + 1), ans, key=len)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 759291,
                "title": "straight-forward-short-and-clean-python-dp-with-detailed-simple-explanation",
                "content": "The main things to explain here:\\nWe are iterating through our string looking for palindromes, we fill in a dp table with what we find and use it for reference:\\n<table style=\"width:100%\">\\n  <tr>\\n  <th></th>\\n    <th>a</th>\\n    <th>b</th>\\n    <th>a</th>\\n  </tr>\\n  <tr>\\n    <td><b>a</b></td>\\n    <td>t</td>\\n    <td>f</td>\\n\\t<td>t</td>\\n  </tr>\\n  <tr>\\n    <td><b>b</b></td>\\n    <td>0</td>\\n    <td>t</td>\\n\\t<td>f</td>\\n  </tr>\\n    <tr>\\n    <td><b>a</b></td>\\n    <td>0</td>\\n    <td>0</td>\\n\\t<td>t</td>\\n  </tr>\\n</table>\\n\\nWe start our iterations from the bottom (reverse the range - range(n-1, -1, -1)), and build our solution up (bottom up).\\nOur diagonal is always true as it means it\\'s always 1 letter (you could think of the letters as idx\\'s also (0,0), (1,1) etc.). \\nBottom row: is \\'a\\' a pal? True.\\nMiddle row: is \\'b\\' a pal? True, is \\'ba\\' a pal? False.\\nTop row: is \\'a\\' a pal? True, is \\'ab\\' a pal? False, is \\'aba\\' a pal? True.\\n\\n The logic for recording the longest palindromes:\\n*  ((j - i + 1) <= 3 if the length of the str is < 3\\n\\t*  eg. aba i= 0, j = 2, 2 - 0 + 1 = 3, here we dont care about the middle letter, and we know s[i] == s[j].\\n\\t*  eg. ab i= 0, j = 1, 1 - 0 + 1 = 2 this isn\\'t valid? But we already know s[i] != s[j] so wouldn\\'t have made it to this check.\\n*  OR dp[i + 1][j - 1] - the last str before the current was a palindrome.\\n\\nWe store the palindromes we find along with their length in ans and return the str associated with the max len.\\n```\\nclass Solution:\\n    def longestPalindrome(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: str\\n        \"\"\"\\n\\t\\tn = len(s)\\n        if n < 2: return s\\n        dp, ans = [[0]*n for _ in range(n)], {}\\n        for i in range(n-1, -1, -1):\\n            for j in range(i, n):\\n                if s[i] == s[j] and ((j - i + 1) <= 3 or dp[i + 1][j - 1]):\\n                    dp[i][j] = True\\n                    ans[j-i+1] = s[i:j+1]\\n                else:\\n                    dp[i][j] = False\\n        return ans[max(ans)]\\n```\\n\\nA very similar way to approach it:\\n```\\nclass Solution:\\n    def longestPalindrome(self, s: str) -> str:\\n        \\n        if len(s) < 2: \\n            return s[0] if s else \\'\\'\\n        dp = [[False] * len(s) for _ in range(len(s))]\\n        max_seen = 1\\n        mv = s[0]\\n        for i in range(len(s)):\\n            for j in range(i):\\n                if s[i] == s[j] and ((i-j+1) <= 3 or dp[i-1][j+1]):\\n                    dp[i][j] = True\\n                    if i-j+1 >= max_seen:\\n                        max_seen = i-j+1\\n                        mv = s[j:i+1]\\n\\n        return mv\\n```\\nOR\\n```\\nclass Solution:\\n    def longestPalindrome(self, s: str) -> str:\\n        \\n        dp = [[False]*len(s) for _ in range(len(s))]\\n        longest = \\'\\'\\n        \\n        for i in range(len(s)):\\n            for j in range(i+1):\\n                if s[i] == s[j] and ((i+1-j) <= 3 or dp[i-1][j+1]):\\n                    dp[i][j] = True\\n                    if i+1-j > len(longest):\\n                        longest = s[j:i+1]\\n        return longest\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def longestPalindrome(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: str\\n        \"\"\"\\n\\t\\tn = len(s)\\n        if n < 2: return s\\n        dp, ans = [[0]*n for _ in range(n)], {}\\n        for i in range(n-1, -1, -1):\\n            for j in range(i, n):\\n                if s[i] == s[j] and ((j - i + 1) <= 3 or dp[i + 1][j - 1]):\\n                    dp[i][j] = True\\n                    ans[j-i+1] = s[i:j+1]\\n                else:\\n                    dp[i][j] = False\\n        return ans[max(ans)]\\n```\n```\\nclass Solution:\\n    def longestPalindrome(self, s: str) -> str:\\n        \\n        if len(s) < 2: \\n            return s[0] if s else \\'\\'\\n        dp = [[False] * len(s) for _ in range(len(s))]\\n        max_seen = 1\\n        mv = s[0]\\n        for i in range(len(s)):\\n            for j in range(i):\\n                if s[i] == s[j] and ((i-j+1) <= 3 or dp[i-1][j+1]):\\n                    dp[i][j] = True\\n                    if i-j+1 >= max_seen:\\n                        max_seen = i-j+1\\n                        mv = s[j:i+1]\\n\\n        return mv\\n```\n```\\nclass Solution:\\n    def longestPalindrome(self, s: str) -> str:\\n        \\n        dp = [[False]*len(s) for _ in range(len(s))]\\n        longest = \\'\\'\\n        \\n        for i in range(len(s)):\\n            for j in range(i+1):\\n                if s[i] == s[j] and ((i+1-j) <= 3 or dp[i-1][j+1]):\\n                    dp[i][j] = True\\n                    if i+1-j > len(longest):\\n                        longest = s[j:i+1]\\n        return longest\\n```",
                "codeTag": "Java"
            },
            {
                "id": 751188,
                "title": "simple-easy-to-follow-python",
                "content": "This solution is currently at 948 ms for time and  13.7 mb for space (i.e. beats 83% of  run and 92.90% of space among the submissions) as of 07/23/2020. I think I will just stick with this for my interview. I have tried to write good comments. Let me know if you couldn\\'t understand any part of it. \\n\\n```\\nclass Solution:\\n    def longestPalindrome(self, s: str) -> str:\\n        result = \"\"\\n        \\n        for i in range(len(s)):\\n            # this is for odd length palindrome\\n            word1 = self.checkPalindrome(s, i, i)\\n            # this is for even length palindrome\\n            word2 = self.checkPalindrome(s, i, i+1)\\n            \\n            #word1 will be max length word from word1 and word2\\n            word1 = word1 if len(word1) >= len(word2) else word2 \\n            \\n            # compare word1 with our result\\n            result = word1 if len(word1) >= len(result) else result\\n            \\n        return result\\n    \\n    def checkPalindrome(self, s, lo, hi):\\n        # expand as long as \\'lo\\' can grow to the left\\n        # and \\'hi\\' and grow to the right and chracters at those index match\\n        while lo>=0 and hi<len(s) and s[lo]==s[hi]:\\n            lo -= 1\\n            hi += 1\\n        \\n        # return the slice from original string that starts from our last matched index of lo and hi. We don\\'t increament hi because python slice goes up to ending index-1\\n        return s[lo+1:hi]\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def longestPalindrome(self, s: str) -> str:\\n        result = \"\"\\n        \\n        for i in range(len(s)):\\n            # this is for odd length palindrome\\n            word1 = self.checkPalindrome(s, i, i)\\n            # this is for even length palindrome\\n            word2 = self.checkPalindrome(s, i, i+1)\\n            \\n            #word1 will be max length word from word1 and word2\\n            word1 = word1 if len(word1) >= len(word2) else word2 \\n            \\n            # compare word1 with our result\\n            result = word1 if len(word1) >= len(result) else result\\n            \\n        return result\\n    \\n    def checkPalindrome(self, s, lo, hi):\\n        # expand as long as \\'lo\\' can grow to the left\\n        # and \\'hi\\' and grow to the right and chracters at those index match\\n        while lo>=0 and hi<len(s) and s[lo]==s[hi]:\\n            lo -= 1\\n            hi += 1\\n        \\n        # return the slice from original string that starts from our last matched index of lo and hi. We don\\'t increament hi because python slice goes up to ending index-1\\n        return s[lo+1:hi]\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 128054,
                "title": "java-beats-98-and-javascript-beats-100-o-n-manacher-s-algorithm-with-detailed-explanation",
                "content": "# Longest Palindromic Substring (LPS)\\n**Problem**\\n\\n* *Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000.*\\n\\nThis post explains Manacher\\u2019s Algorithm, a dynamic programming algorithm used to solve LPS problem. Manacher\\u2019s Algorithm reuses results from previous palindromic checks to reduce complexity. Each palindromic checks has an O(1) time complexity, so the total complexity is O(n). The algorithm uses O(n) extra space.\\n\\n**Table of Contents**\\n1. Java Code\\n1. Java Code with inline, detailed explanation\\n1. JavaScript Code\\n1. JavaScript Code with inline, detailed explanation\\n# Java Code\\n```\\n    public String longestPalindrome(String s) {\\n        char[] newStr = new char[s.length() * 2 + 1];\\n        newStr[0] = \\'#\\';\\n        for (int i = 0; i < s.length(); i++) {\\n            newStr[2 * i + 1] = s.charAt(i);\\n            newStr[2 * i + 2] = \\'#\\';\\n        }\\n        int[] dp = new int[newStr.length];\\n        int friendCenter = 0, friendRadius = 0, lpsCenter = 0, lpsRadius = 0;\\n        for (int i = 0; i < newStr.length; i++) {\\n            dp[i] = friendCenter + friendRadius > i ? Math.min(dp[friendCenter * 2 - i], (friendCenter + friendRadius) - i) : 1;\\n            while (i + dp[i] < newStr.length && i - dp[i] >= 0 && newStr[i + dp[i]] == newStr[i - dp[i]]) dp[i]++;\\n            if (friendCenter + friendRadius < i + dp[i]) {\\n                friendCenter = i;\\n                friendRadius = dp[i];\\n            }\\n            if (lpsRadius < dp[i]) {\\n                lpsCenter = i;\\n                lpsRadius = dp[i];\\n            }\\n        }\\n        return s.substring((lpsCenter - lpsRadius + 1) / 2, (lpsCenter + lpsRadius - 1) / 2);\\n    }\\n```\\n# Java Explanation\\n```\\n    public String longestPalindrome(String s) {\\n        /* Preprocess s: insert \\'#\\' between characters, so we don\\'t need to worry about even or odd length palindromes. */\\n        char[] newStr = new char[s.length() * 2 + 1];\\n        newStr[0] = \\'#\\';\\n        for (int i = 0; i < s.length(); i++) {\\n            newStr[2 * i + 1] = s.charAt(i);\\n            newStr[2 * i + 2] = \\'#\\';\\n        }\\n        /* Process newStr */\\n        /* dp[i] is the length of LPS centered at i */\\n        int[] dp = new int[newStr.length];\\n        /**\\n         * For better understanding, here we define \"friend substring\", or \"friend\":\\n         * \"friend substring\" has the largest end-index in all checked substrings that\\n         * are palindromes. We start at friendCenter = 0 and update it in each cycles.\\n         */\\n        int friendCenter = 0, friendRadius = 0, lpsCenter = 0, lpsRadius = 0;\\n        /* j is the symmetry of i with respect to friendCenter */\\n        int j;\\n        for (int i = 0; i < newStr.length; i++) {\\n            /* Calculate dp[i] */\\n            if (friendCenter + friendRadius > i) {\\n                /**\\n                 * This is the most important part of the algorithm.\\n                 * \\n                 * Normally we start from dp[i] = 1 and then try to expand dp[i] by doing brute-force palindromic\\n                 * checks. However, if i is in the range of friend (friendCenter + friendRadius > i), we can expect\\n                 * dp[i] = dp[j] because friend is a palindrome. This only works within the range of friend, so the\\n                 * max value of dp[i] we can trust is (friendEnd - i).\\n                 * \\n                 * Here is an example:\\n                 *\\n                 *     friendStart   j             friendCenter  i     friendEnd                         \\n                 *               |   |             |             |     |\\n                 * String: - - d c b a b c d - - - - - - - d c b a b c ? - - - - - - - -\\n                 *               [--------friend (palindrome)--------]\\n                 *\\n                 * In this example, (friendEnd - i) = 3, so we can only be certain that radius <= 3 part around i\\n                 * is a palindrome (i.e. \"cbabc\" part). We still need to check the character at \"?\".\\n                 */\\n                j = friendCenter - (i - friendCenter);\\n                dp[i] = Math.min(dp[j], (friendCenter + friendRadius) - i);\\n            }\\n            else {\\n                /* Calculate from scratch */\\n                dp[i] = 1;\\n            }\\n            /* Check palindrome and expand dp[i] */\\n            while (i + dp[i] < newStr.length && i - dp[i] >= 0&& newStr[i + dp[i]] == newStr[i - dp[i]])\\n                dp[i]++;\\n            /* Check if i should become the new friend */\\n            if (friendCenter + friendRadius < i + dp[i]) {\\n                friendCenter = i;\\n                friendRadius = dp[i];\\n            }\\n            /* Update longest palindrome */\\n            if (lpsRadius < dp[i]) {\\n                lpsCenter = i;\\n                lpsRadius = dp[i];\\n            }\\n        }\\n        return s.substring((lpsCenter - lpsRadius + 1) / 2, (lpsCenter + lpsRadius - 1) / 2);\\n    }\\n```\\n# JavaScript Code\\n```\\nvar longestPalindrome = function(s) {\\n    var newStr = \"#\" + s.split(\"\").join(\"#\") + \"#\";\\n    var dp = [], friendCenter = 0, friendRadius = 0, lpsCenter = 0, lpsRadius = 0;\\n    for (var i = 0; i < newStr.length; i++) {\\n        dp[i] = friendCenter + friendRadius > i ? Math.min(dp[friendCenter * 2 - i], (friendCenter + friendRadius) - i) : 1;\\n        while (i + dp[i] < newStr.length && i - dp[i] >= 0 && newStr[i + dp[i]] == newStr[i - dp[i]]) dp[i]++;\\n        friendRadius = friendCenter + friendRadius < i + dp[i] ? (function () {friendCenter = i; return dp[i];})() : friendRadius;\\n        lpsRadius = lpsRadius < dp[i] ? (function () {lpsCenter = i; return dp[i];})() : lpsRadius;\\n    }\\n    return s.substring((lpsCenter - lpsRadius + 1) / 2, (lpsCenter + lpsRadius - 1) / 2);\\n};\\n```\\n# JavaScript Explanation\\n```\\nvar longestPalindrome = function(s) {\\n    /* Preprocess s: insert \\'#\\' between characters, so we don\\'t need to worry about even or odd length palindromes. */\\n    var newStr = \"#\";\\n    for (var i = 0; i < s.length; i++) newStr += s.charAt(i) + \"#\";\\n    /* Process newStr */\\n    /* dp[i] is the length of LPS centered at i */\\n    var dp = [];\\n    /**\\n     * For better understanding, here we define \"friend substring\", or \"friend\":\\n     * \"friend substring\" has the largest end-index in all checked substrings that\\n     * are palindromes. We start at friendCenter = 0 and update it in each cycles.\\n     */\\n    var friendCenter = 0, friendRadius = 0, lpsCenter = 0, lpsRadius = 0;\\n    /* j is the symmetry of i with respect to friendCenter */\\n    var j;\\n    for (var i = 0; i < newStr.length; i++) {\\n        /* Calculate dp[i] */\\n        if (friendCenter + friendRadius > i) {\\n            /**\\n             * This is the most important part of the algorithm.\\n             * \\n             * Normally we start from dp[i] = 1 and then try to expand dp[i] by doing brute-force palindromic\\n             * checks. However, if i is in the range of friend (friendCenter + friendRadius > i), we can expect\\n             * dp[i] = dp[j] because friend is a palindrome. This only works within the range of friend, so the\\n             * max dp[i] we can trust = (friendEnd - i).\\n             * \\n             * Here is an example:\\n             *\\n             *     friendStart   j             friendCenter  i     friendEnd                         \\n             *               |   |             |             |     |\\n             * String: - - d c b a b c d - - - - - - - d c b a b c ? - - - - - - - -\\n             *               [--------friend (palindrome)--------]\\n             *\\n             * In this example, (friendEnd - i) = 3, so we can only be certain that radius <= 3 part around i\\n             * is a palindrome (i.e. \"cbabc\" part). We still need to check the character at \"?\".\\n             */\\n            j = friendCenter - (i - friendCenter);\\n            dp[i] = Math.min(dp[j], (friendCenter + friendRadius) - i);\\n        }\\n        else {\\n            /* Calculate from scratch */\\n            dp[i] = 1;\\n        }\\n        /* Check palindrome and expand dp[i] */\\n        while (i + dp[i] < newStr.length && i - dp[i] >= 0 && newStr[i + dp[i]] == newStr[i - dp[i]]) dp[i]++;\\n        /* Check if i should become the new friend */\\n        if (friendCenter + friendRadius < i + dp[i]) {\\n            friendCenter = i;\\n            friendRadius = dp[i];\\n        }\\n        /* Update longest palindromic substring */\\n        if (lpsRadius < dp[i]) {\\n            lpsRadius = dp[i];\\n            lpsCenter = i;\\n        }\\n    }\\n    return s.substring((lpsCenter - lpsRadius + 1) / 2, (lpsCenter + lpsRadius - 1) / 2);\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\n    public String longestPalindrome(String s) {\\n        char[] newStr = new char[s.length() * 2 + 1];\\n        newStr[0] = \\'#\\';\\n        for (int i = 0; i < s.length(); i++) {\\n            newStr[2 * i + 1] = s.charAt(i);\\n            newStr[2 * i + 2] = \\'#\\';\\n        }\\n        int[] dp = new int[newStr.length];\\n        int friendCenter = 0, friendRadius = 0, lpsCenter = 0, lpsRadius = 0;\\n        for (int i = 0; i < newStr.length; i++) {\\n            dp[i] = friendCenter + friendRadius > i ? Math.min(dp[friendCenter * 2 - i], (friendCenter + friendRadius) - i) : 1;\\n            while (i + dp[i] < newStr.length && i - dp[i] >= 0 && newStr[i + dp[i]] == newStr[i - dp[i]]) dp[i]++;\\n            if (friendCenter + friendRadius < i + dp[i]) {\\n                friendCenter = i;\\n                friendRadius = dp[i];\\n            }\\n            if (lpsRadius < dp[i]) {\\n                lpsCenter = i;\\n                lpsRadius = dp[i];\\n            }\\n        }\\n        return s.substring((lpsCenter - lpsRadius + 1) / 2, (lpsCenter + lpsRadius - 1) / 2);\\n    }\\n```\n```\\n    public String longestPalindrome(String s) {\\n        /* Preprocess s: insert \\'#\\' between characters, so we don\\'t need to worry about even or odd length palindromes. */\\n        char[] newStr = new char[s.length() * 2 + 1];\\n        newStr[0] = \\'#\\';\\n        for (int i = 0; i < s.length(); i++) {\\n            newStr[2 * i + 1] = s.charAt(i);\\n            newStr[2 * i + 2] = \\'#\\';\\n        }\\n        /* Process newStr */\\n        /* dp[i] is the length of LPS centered at i */\\n        int[] dp = new int[newStr.length];\\n        /**\\n         * For better understanding, here we define \"friend substring\", or \"friend\":\\n         * \"friend substring\" has the largest end-index in all checked substrings that\\n         * are palindromes. We start at friendCenter = 0 and update it in each cycles.\\n         */\\n        int friendCenter = 0, friendRadius = 0, lpsCenter = 0, lpsRadius = 0;\\n        /* j is the symmetry of i with respect to friendCenter */\\n        int j;\\n        for (int i = 0; i < newStr.length; i++) {\\n            /* Calculate dp[i] */\\n            if (friendCenter + friendRadius > i) {\\n                /**\\n                 * This is the most important part of the algorithm.\\n                 * \\n                 * Normally we start from dp[i] = 1 and then try to expand dp[i] by doing brute-force palindromic\\n                 * checks. However, if i is in the range of friend (friendCenter + friendRadius > i), we can expect\\n                 * dp[i] = dp[j] because friend is a palindrome. This only works within the range of friend, so the\\n                 * max value of dp[i] we can trust is (friendEnd - i).\\n                 * \\n                 * Here is an example:\\n                 *\\n                 *     friendStart   j             friendCenter  i     friendEnd                         \\n                 *               |   |             |             |     |\\n                 * String: - - d c b a b c d - - - - - - - d c b a b c ? - - - - - - - -\\n                 *               [--------friend (palindrome)--------]\\n                 *\\n                 * In this example, (friendEnd - i) = 3, so we can only be certain that radius <= 3 part around i\\n                 * is a palindrome (i.e. \"cbabc\" part). We still need to check the character at \"?\".\\n                 */\\n                j = friendCenter - (i - friendCenter);\\n                dp[i] = Math.min(dp[j], (friendCenter + friendRadius) - i);\\n            }\\n            else {\\n                /* Calculate from scratch */\\n                dp[i] = 1;\\n            }\\n            /* Check palindrome and expand dp[i] */\\n            while (i + dp[i] < newStr.length && i - dp[i] >= 0&& newStr[i + dp[i]] == newStr[i - dp[i]])\\n                dp[i]++;\\n            /* Check if i should become the new friend */\\n            if (friendCenter + friendRadius < i + dp[i]) {\\n                friendCenter = i;\\n                friendRadius = dp[i];\\n            }\\n            /* Update longest palindrome */\\n            if (lpsRadius < dp[i]) {\\n                lpsCenter = i;\\n                lpsRadius = dp[i];\\n            }\\n        }\\n        return s.substring((lpsCenter - lpsRadius + 1) / 2, (lpsCenter + lpsRadius - 1) / 2);\\n    }\\n```\n```\\nvar longestPalindrome = function(s) {\\n    var newStr = \"#\" + s.split(\"\").join(\"#\") + \"#\";\\n    var dp = [], friendCenter = 0, friendRadius = 0, lpsCenter = 0, lpsRadius = 0;\\n    for (var i = 0; i < newStr.length; i++) {\\n        dp[i] = friendCenter + friendRadius > i ? Math.min(dp[friendCenter * 2 - i], (friendCenter + friendRadius) - i) : 1;\\n        while (i + dp[i] < newStr.length && i - dp[i] >= 0 && newStr[i + dp[i]] == newStr[i - dp[i]]) dp[i]++;\\n        friendRadius = friendCenter + friendRadius < i + dp[i] ? (function () {friendCenter = i; return dp[i];})() : friendRadius;\\n        lpsRadius = lpsRadius < dp[i] ? (function () {lpsCenter = i; return dp[i];})() : lpsRadius;\\n    }\\n    return s.substring((lpsCenter - lpsRadius + 1) / 2, (lpsCenter + lpsRadius - 1) / 2);\\n};\\n```\n```\\nvar longestPalindrome = function(s) {\\n    /* Preprocess s: insert \\'#\\' between characters, so we don\\'t need to worry about even or odd length palindromes. */\\n    var newStr = \"#\";\\n    for (var i = 0; i < s.length; i++) newStr += s.charAt(i) + \"#\";\\n    /* Process newStr */\\n    /* dp[i] is the length of LPS centered at i */\\n    var dp = [];\\n    /**\\n     * For better understanding, here we define \"friend substring\", or \"friend\":\\n     * \"friend substring\" has the largest end-index in all checked substrings that\\n     * are palindromes. We start at friendCenter = 0 and update it in each cycles.\\n     */\\n    var friendCenter = 0, friendRadius = 0, lpsCenter = 0, lpsRadius = 0;\\n    /* j is the symmetry of i with respect to friendCenter */\\n    var j;\\n    for (var i = 0; i < newStr.length; i++) {\\n        /* Calculate dp[i] */\\n        if (friendCenter + friendRadius > i) {\\n            /**\\n             * This is the most important part of the algorithm.\\n             * \\n             * Normally we start from dp[i] = 1 and then try to expand dp[i] by doing brute-force palindromic\\n             * checks. However, if i is in the range of friend (friendCenter + friendRadius > i), we can expect\\n             * dp[i] = dp[j] because friend is a palindrome. This only works within the range of friend, so the\\n             * max dp[i] we can trust = (friendEnd - i).\\n             * \\n             * Here is an example:\\n             *\\n             *     friendStart   j             friendCenter  i     friendEnd                         \\n             *               |   |             |             |     |\\n             * String: - - d c b a b c d - - - - - - - d c b a b c ? - - - - - - - -\\n             *               [--------friend (palindrome)--------]\\n             *\\n             * In this example, (friendEnd - i) = 3, so we can only be certain that radius <= 3 part around i\\n             * is a palindrome (i.e. \"cbabc\" part). We still need to check the character at \"?\".\\n             */\\n            j = friendCenter - (i - friendCenter);\\n            dp[i] = Math.min(dp[j], (friendCenter + friendRadius) - i);\\n        }\\n        else {\\n            /* Calculate from scratch */\\n            dp[i] = 1;\\n        }\\n        /* Check palindrome and expand dp[i] */\\n        while (i + dp[i] < newStr.length && i - dp[i] >= 0 && newStr[i + dp[i]] == newStr[i - dp[i]]) dp[i]++;\\n        /* Check if i should become the new friend */\\n        if (friendCenter + friendRadius < i + dp[i]) {\\n            friendCenter = i;\\n            friendRadius = dp[i];\\n        }\\n        /* Update longest palindromic substring */\\n        if (lpsRadius < dp[i]) {\\n            lpsRadius = dp[i];\\n            lpsCenter = i;\\n        }\\n    }\\n    return s.substring((lpsCenter - lpsRadius + 1) / 2, (lpsCenter + lpsRadius - 1) / 2);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 417359,
                "title": "java-dp-solutions-with-illustration-t-t",
                "content": "Reference: [LeetCode](https://leetcode.com/problems/longest-palindromic-substring/)\\nDifficulty: <span class=\"orange\">Medium</span>\\n\\n\\n\\n## Problem\\n\\n> Given a string `s`, find the longest palindromic substring in `s`. You may assume that the maximum length of `s` is `1000`.\\n\\n\\n**Example:** \\n\\n```java\\nInput: \"babad\"\\nOutput: \"bab\"\\nNote: \"aba\" is also a valid answer.\\n\\nInput: \"cbbd\"\\nOutput: \"bb\"\\n```\\n\\n\\n## Analysis\\n\\n### Brute-Force\\n\\nFor each character `i`, we examine all substrings starting from index `i` and check if they are palindromic.\\n\\n```java\\npublic String longestPalindrome(String s) {\\n  if (s == null || s.length() == 0) {\\n    return \"\";\\n  }\\n  int n = s.length();\\n  String maxStr = \"\";\\n  for (int i = 0; i < n; ++i) {\\n    for (int j = i; j < n; ++j) {\\n      if (isValid(s, i, j) == true) {\\n        if (j - i + 1 > maxStr.length()) { // update maxStr\\n          maxStr = s.substring(i, j + 1);\\n        }\\n      }\\n    }\\n  }\\n  return maxStr;\\n}\\n\\nprivate boolean isValid(String s, int lo, int hi) {\\n  int n = hi - lo + 1;\\n  for (int i = 0; i < n / 2; ++i) {\\n    if (s.charAt(lo + i) != s.charAt(hi - i)) {\\n      return false;\\n    }\\n  }\\n  return true;\\n}\\n```\\n\\n**Time:** `O(N^3)`\\n**Space:** `O(1)`\\n\\n\\n\\n### Expansion From the Center\\n\\n\\n\\n```java\\npublic String longestPalindrome(String s) {\\n  if (s == null || s.length() == 0) {\\n    return \"\";\\n  }\\n  int n = s.length();\\n  StringBuilder longest = new StringBuilder();\\n  for (int i = 0; i < n; ++i) {\\n    findPalindrome(s, i, i, longest); // odd\\n    findPalindrome(s, i, i + 1, longest); // even\\n  }\\n  return longest.toString();\\n}\\n  \\nprivate void findPalindrome(String s, int lo, int hi, StringBuilder longest) {\\n  int n = s.length();\\n  StringBuilder sb = new StringBuilder();\\n  while (lo >= 0 && hi < n && s.charAt(lo) == s.charAt(hi)) {\\n    if (lo == hi) {\\n      sb.append(s.charAt(lo));\\n    } else {\\n      sb.insert(0, s.charAt(lo));\\n      sb.append(s.charAt(hi));\\n    }\\n    --lo;\\n    ++hi;\\n  }\\n  if (sb.length() > longest.length()) {\\n    longest.delete(0, longest.length());\\n    longest.append(sb);\\n  }\\n}\\n```\\n\\n**Time:** `O(N^2)`\\n**Space:** `O(N)`\\n\\n\\n\\n\\n### DP\\n\\nBased on the brute-force solution, we can improve on it by avoiding unnecessary re-computation while validating palindromes. Consider the case `ababa`. If we already knew that `bab` is a palindrome, it is obvious that `ababa` must be a palindrome since the two end letters are the same.\\n\\nSo we can define `dp[i][j]` as `true` if the substring `S(i, j)` is a palindrome.\\n\\nThe recurrence is then obvious: `dp[i][j]` = (`dp[i + 1][j - 1]` && `Si == Sj`)\\n\\nThe base cases are: `dp[i][i]` = `true`, `dp[i][i + 1] = (Si == Si+1)`.\\n\\n![](https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/10ayv.jpg)\\n\\n**Note:** Determining ranges of `i` and `j` would be easy if you pick a starting point in the graph to get some intuition. For example, in this case `j` starts from `i + 2`.\\n\\n```java\\npublic String longestPalindrome(String s) {\\n  if (s == null || s.length() == 0) {\\n    return \"\";\\n  }\\n  int n = s.length();\\n  boolean[][] dp = generateDP(s);\\n  // Check each substring\\n  int maxLen = 0;\\n  int[] maxIdx = new int[] { 0, 0 };\\n  for (int i = 0; i < n; ++i) {\\n    for (int j = i; j < n; ++j) {\\n      if (dp[i][j] == true) {\\n        if (j - i + 1 > maxLen) {\\n          maxLen = j - i + 1;\\n          maxIdx[0] = i;\\n          maxIdx[1] = j;\\n        }\\n      }\\n    }\\n  }\\n  return s.substring(maxIdx[0], maxIdx[1] + 1);\\n}\\n\\nprivate boolean[][] generateDP(String s) {\\n  int n = s.length();\\n  boolean[][] dp = new boolean[n][n];\\n  // Init\\n  for (int i = 0; i < n; ++i) { // diagonal\\n    dp[i][i] = true;\\n  }\\n  for (int i = 0; i < n - 1; ++i) { // one line below diagonal\\n    dp[i][i + 1] = (s.charAt(i) == s.charAt(i + 1));\\n  }\\n  // DP\\n  for (int i = n - 3; i >= 0; --i) {\\n    for (int j = i + 2; j < n; ++j) {\\n      dp[i][j] = dp[i + 1][j - 1] && s.charAt(i) == s.charAt(j);\\n    }\\n  }\\n  return dp;\\n}\\n```\\n\\n**Time:** `O(N^2)`\\n**Space:** `O(N^2)`\\n",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```java\\nInput: \"babad\"\\nOutput: \"bab\"\\nNote: \"aba\" is also a valid answer.\\n\\nInput: \"cbbd\"\\nOutput: \"bb\"\\n```\n```java\\npublic String longestPalindrome(String s) {\\n  if (s == null || s.length() == 0) {\\n    return \"\";\\n  }\\n  int n = s.length();\\n  String maxStr = \"\";\\n  for (int i = 0; i < n; ++i) {\\n    for (int j = i; j < n; ++j) {\\n      if (isValid(s, i, j) == true) {\\n        if (j - i + 1 > maxStr.length()) { // update maxStr\\n          maxStr = s.substring(i, j + 1);\\n        }\\n      }\\n    }\\n  }\\n  return maxStr;\\n}\\n\\nprivate boolean isValid(String s, int lo, int hi) {\\n  int n = hi - lo + 1;\\n  for (int i = 0; i < n / 2; ++i) {\\n    if (s.charAt(lo + i) != s.charAt(hi - i)) {\\n      return false;\\n    }\\n  }\\n  return true;\\n}\\n```\n```java\\npublic String longestPalindrome(String s) {\\n  if (s == null || s.length() == 0) {\\n    return \"\";\\n  }\\n  int n = s.length();\\n  StringBuilder longest = new StringBuilder();\\n  for (int i = 0; i < n; ++i) {\\n    findPalindrome(s, i, i, longest); // odd\\n    findPalindrome(s, i, i + 1, longest); // even\\n  }\\n  return longest.toString();\\n}\\n  \\nprivate void findPalindrome(String s, int lo, int hi, StringBuilder longest) {\\n  int n = s.length();\\n  StringBuilder sb = new StringBuilder();\\n  while (lo >= 0 && hi < n && s.charAt(lo) == s.charAt(hi)) {\\n    if (lo == hi) {\\n      sb.append(s.charAt(lo));\\n    } else {\\n      sb.insert(0, s.charAt(lo));\\n      sb.append(s.charAt(hi));\\n    }\\n    --lo;\\n    ++hi;\\n  }\\n  if (sb.length() > longest.length()) {\\n    longest.delete(0, longest.length());\\n    longest.append(sb);\\n  }\\n}\\n```\n```java\\npublic String longestPalindrome(String s) {\\n  if (s == null || s.length() == 0) {\\n    return \"\";\\n  }\\n  int n = s.length();\\n  boolean[][] dp = generateDP(s);\\n  // Check each substring\\n  int maxLen = 0;\\n  int[] maxIdx = new int[] { 0, 0 };\\n  for (int i = 0; i < n; ++i) {\\n    for (int j = i; j < n; ++j) {\\n      if (dp[i][j] == true) {\\n        if (j - i + 1 > maxLen) {\\n          maxLen = j - i + 1;\\n          maxIdx[0] = i;\\n          maxIdx[1] = j;\\n        }\\n      }\\n    }\\n  }\\n  return s.substring(maxIdx[0], maxIdx[1] + 1);\\n}\\n\\nprivate boolean[][] generateDP(String s) {\\n  int n = s.length();\\n  boolean[][] dp = new boolean[n][n];\\n  // Init\\n  for (int i = 0; i < n; ++i) { // diagonal\\n    dp[i][i] = true;\\n  }\\n  for (int i = 0; i < n - 1; ++i) { // one line below diagonal\\n    dp[i][i + 1] = (s.charAt(i) == s.charAt(i + 1));\\n  }\\n  // DP\\n  for (int i = n - 3; i >= 0; --i) {\\n    for (int j = i + 2; j < n; ++j) {\\n      dp[i][j] = dp[i + 1][j - 1] && s.charAt(i) == s.charAt(j);\\n    }\\n  }\\n  return dp;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1801960,
                "title": "java-multiple-approach-with-explanation",
                "content": "## Please upvote if you like the solution\\n\\n```\\nclass Solution {\\n    \\n    /***\\n     *          **************** Approach - 1 ********************\\n     *\\n     *   In this approach we will try to solve it using Dynamic Programming\\n     */\\n\\n\\n    /***\\n     *     We can take an 2D boolean array, where we will be storing from position -> to position whether the string is palindrome or not\\n     *     Both row and column wise we will be keeping the same String like below. But Column wise we want to denote it as END position\\n     *     and Row wise Start position\\n     *\\n     *     Any position will denote the (row, col) starting from position (row number) till position (col number)\\n     *     Like position (1,3) denotes from position 1 to position 3 whether the string is palindrome or not\\n     *\\n     *     So we won\\'t be considering the position below the diagonal line, because for those position\\n     *     row number > col number meaning start is > end meaning those are not valid position.\\n     *\\n     *    Case-1 : For Gap-0, i.e. position [(0,0), (1,1), (2,2)] values are always TRUE.\\n     *             Because start and end position is same. So, it consists of one character only.\\n     *\\n     *    Case-2 : For Gap-1, i.e. position (0,1), (1,2), (2,3) & (3,4) Compare the Start position and End position.\\n     *             Because there are only two characters are there.\\n     *\\n     *    Case-3 : For all rest of the position check the start and end position if true check for middle part of the string.\\n     *             like for position (1,3) check whether the start and end is same or not, meaning character at position 1\\n     *             and position 3 is same or not.\\n     *             If same, check the middle part of the string i.e. check for (start+1) till (End -1) position.\\n     *             in this case we have to check whether the middle part of the String i.e. (2,2) is\\n     *             palindrome or not.\\n     *\\n     *             To check that middle portions result we can check the left diagonal value i.e. for (i,j) check for (i+1 , j -1)\\n     *             i.e. for pos (1,3) check the position (2,2)\\n     *\\n     *\\n     *                          END --->\\n     *               0        1       2         3         4\\n     *               b        a       b         a         d\\n     *     -------------------------------------------------------\\n     *       0  b   T(b)   F(ab)   T(bab)   F(baba)    F(babad)\\n     *\\n     *   S   1  a          T(a)     F(ab)   T(aba)     F(abad)\\n     *   T\\n     *   A   2  b                   T(b)    F(ba)      F(bad)\\n     *   R\\n     *   T   3  a                           T(a)       F(ad)\\n     *\\n     *       4  d                                      T(d)\\n     *\\n     *\\n     *\\n     *\\n     *\\n     */\\n    public String longestPalindrome1(String str) {\\n\\n        boolean[][] dp = new boolean[str.length()][str.length()];\\n        int start = 0, end = 0;\\n\\n        /**\\n         * The loop should be Diagonal wise Starting with gap = 0 till string length\\n         * First loop it should cover [(0,0), (1,1), (2,2), (3,3), (4,4)]\\n         * Second Loop - (0,1), (1,2), (2,3) & (3,4)\\n         *\\n         * Like this diagonally it should travel and solve the problem.\\n         */\\n        for (int gap = 0; gap < str.length(); gap++) {\\n            for (int i = 0, j = gap; j < dp[0].length; i++, j++) {\\n\\n                /**\\n                 *    Case-1 : For Gap-0, i.e. position [(0,0), (1,1), (2,2)] values are always TRUE.\\n                 *             Because start and end position is same. So, it consists of one character only.\\n                 */\\n                if (gap == 0) {\\n                    dp[i][j] = true;\\n                    continue;\\n                }\\n                /**\\n                 *    Case-2 : For Gap-1, i.e. position (0,1), (1,2), (2,3) & (3,4) Compare the Start position and End position.\\n                 *             Because there are only two characters are there.\\n                 */\\n                if (gap == 1 && str.charAt(i) == str.charAt(j)) {\\n                    dp[i][j] = true;\\n                }\\n                /**\\n                 *  Case-3 : For all rest of the position check the start and end position\\n                 *           If true check for middle part of the string i.e. check for (start+1) till (End -1) position.\\n                 *           Which can be obtained from left diagonal value i.e. for (i,j) check for (i+1 , j -1)\\n                 */\\n                else if (str.charAt(i) == str.charAt(j) && dp[i + 1][j - 1] == true) {\\n                    dp[i][j] = true;\\n                }\\n\\n                /**\\n                 * Keeping track of the Start end End position of the Palindromic String.\\n                 * As Gap is increasing we are not doing any comparison with the previous range.\\n                 * With increasing of the Gap value if the substring is palindrome then it will be\\n                 * the bigger substring.\\n                 */\\n                if (dp[i][j]) {\\n                    start = i;\\n                    end = j;\\n                }\\n\\n            }\\n        }\\n\\n        return str.substring(start, end + 1);\\n    }\\n\\n\\n    /***\\n     *                  *****************   Approach - 2   ********************\\n     *\\n     *  The intention is by taking each position as its probable middle position of the substring, we will try to expand the\\n     *  search by both the direction.\\n     *  Like for any position we will try to expand the the value in the both side and validate whether its a palindrome or not.\\n     *     Expand Start   <--   (position)   --> Expand End\\n     */\\n\\n    int start, end, maxLength = Integer.MIN_VALUE;\\n\\n    public String longestPalindrome(String inputStr) {\\n\\n        /**\\n         * Base case :\\n         * If the string is Empty or single character string then return it.\\n         */\\n        if (inputStr.length() < 2) {\\n            return inputStr;\\n        }\\n\\n        for (int index = 0; index < inputStr.length() - 1; index++) {\\n            /**\\n             * we are calling the same function twice because we are not sure\\n             * the substring size will be of even or odd.\\n             *\\n             * If odd then we will be getting a middle point like for the String\\n             * \"abcdcba\" middle will be 3 i.e. character \\'d\\'\\n             *\\n             * but for the even number the middle will be 2 position like for\\n             * the String \"xyzzyx\" middle will be 2 and 3 position\\n             *\\n             */\\n            expandSearch(inputStr, index, index);\\n            expandSearch(inputStr, index, index + 1);\\n        }\\n\\n        return inputStr.substring(start, end);\\n    }\\n\\n    private void expandSearch(String inputStr, int startPosition, int endPosition) {\\n\\n        while (startPosition >= 0 && endPosition < inputStr.length()\\n                && inputStr.charAt(startPosition) == inputStr.charAt(endPosition)) {\\n\\n            startPosition--;\\n            endPosition++;\\n        }\\n\\n        int substringLength = endPosition - startPosition - 1;\\n\\n        /**\\n         * Keeping track of the max SubString length and corresponding start and end\\n         */\\n        if (substringLength > maxLength) {\\n            this.start = startPosition + 1;\\n            end = endPosition;\\n            this.maxLength = substringLength;\\n        }\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    \\n    /***\\n     *          **************** Approach - 1 ********************\\n     *\\n     *   In this approach we will try to solve it using Dynamic Programming\\n     */\\n\\n\\n    /***\\n     *     We can take an 2D boolean array, where we will be storing from position -> to position whether the string is palindrome or not\\n     *     Both row and column wise we will be keeping the same String like below. But Column wise we want to denote it as END position\\n     *     and Row wise Start position\\n     *\\n     *     Any position will denote the (row, col) starting from position (row number) till position (col number)\\n     *     Like position (1,3) denotes from position 1 to position 3 whether the string is palindrome or not\\n     *\\n     *     So we won\\'t be considering the position below the diagonal line, because for those position\\n     *     row number > col number meaning start is > end meaning those are not valid position.\\n     *\\n     *    Case-1 : For Gap-0, i.e. position [(0,0), (1,1), (2,2)] values are always TRUE.\\n     *             Because start and end position is same. So, it consists of one character only.\\n     *\\n     *    Case-2 : For Gap-1, i.e. position (0,1), (1,2), (2,3) & (3,4) Compare the Start position and End position.\\n     *             Because there are only two characters are there.\\n     *\\n     *    Case-3 : For all rest of the position check the start and end position if true check for middle part of the string.\\n     *             like for position (1,3) check whether the start and end is same or not, meaning character at position 1\\n     *             and position 3 is same or not.\\n     *             If same, check the middle part of the string i.e. check for (start+1) till (End -1) position.\\n     *             in this case we have to check whether the middle part of the String i.e. (2,2) is\\n     *             palindrome or not.\\n     *\\n     *             To check that middle portions result we can check the left diagonal value i.e. for (i,j) check for (i+1 , j -1)\\n     *             i.e. for pos (1,3) check the position (2,2)\\n     *\\n     *\\n     *                          END --->\\n     *               0        1       2         3         4\\n     *               b        a       b         a         d\\n     *     -------------------------------------------------------\\n     *       0  b   T(b)   F(ab)   T(bab)   F(baba)    F(babad)\\n     *\\n     *   S   1  a          T(a)     F(ab)   T(aba)     F(abad)\\n     *   T\\n     *   A   2  b                   T(b)    F(ba)      F(bad)\\n     *   R\\n     *   T   3  a                           T(a)       F(ad)\\n     *\\n     *       4  d                                      T(d)\\n     *\\n     *\\n     *\\n     *\\n     *\\n     */\\n    public String longestPalindrome1(String str) {\\n\\n        boolean[][] dp = new boolean[str.length()][str.length()];\\n        int start = 0, end = 0;\\n\\n        /**\\n         * The loop should be Diagonal wise Starting with gap = 0 till string length\\n         * First loop it should cover [(0,0), (1,1), (2,2), (3,3), (4,4)]\\n         * Second Loop - (0,1), (1,2), (2,3) & (3,4)\\n         *\\n         * Like this diagonally it should travel and solve the problem.\\n         */\\n        for (int gap = 0; gap < str.length(); gap++) {\\n            for (int i = 0, j = gap; j < dp[0].length; i++, j++) {\\n\\n                /**\\n                 *    Case-1 : For Gap-0, i.e. position [(0,0), (1,1), (2,2)] values are always TRUE.\\n                 *             Because start and end position is same. So, it consists of one character only.\\n                 */\\n                if (gap == 0) {\\n                    dp[i][j] = true;\\n                    continue;\\n                }\\n                /**\\n                 *    Case-2 : For Gap-1, i.e. position (0,1), (1,2), (2,3) & (3,4) Compare the Start position and End position.\\n                 *             Because there are only two characters are there.\\n                 */\\n                if (gap == 1 && str.charAt(i) == str.charAt(j)) {\\n                    dp[i][j] = true;\\n                }\\n                /**\\n                 *  Case-3 : For all rest of the position check the start and end position\\n                 *           If true check for middle part of the string i.e. check for (start+1) till (End -1) position.\\n                 *           Which can be obtained from left diagonal value i.e. for (i,j) check for (i+1 , j -1)\\n                 */\\n                else if (str.charAt(i) == str.charAt(j) && dp[i + 1][j - 1] == true) {\\n                    dp[i][j] = true;\\n                }\\n\\n                /**\\n                 * Keeping track of the Start end End position of the Palindromic String.\\n                 * As Gap is increasing we are not doing any comparison with the previous range.\\n                 * With increasing of the Gap value if the substring is palindrome then it will be\\n                 * the bigger substring.\\n                 */\\n                if (dp[i][j]) {\\n                    start = i;\\n                    end = j;\\n                }\\n\\n            }\\n        }\\n\\n        return str.substring(start, end + 1);\\n    }\\n\\n\\n    /***\\n     *                  *****************   Approach - 2   ********************\\n     *\\n     *  The intention is by taking each position as its probable middle position of the substring, we will try to expand the\\n     *  search by both the direction.\\n     *  Like for any position we will try to expand the the value in the both side and validate whether its a palindrome or not.\\n     *     Expand Start   <--   (position)   --> Expand End\\n     */\\n\\n    int start, end, maxLength = Integer.MIN_VALUE;\\n\\n    public String longestPalindrome(String inputStr) {\\n\\n        /**\\n         * Base case :\\n         * If the string is Empty or single character string then return it.\\n         */\\n        if (inputStr.length() < 2) {\\n            return inputStr;\\n        }\\n\\n        for (int index = 0; index < inputStr.length() - 1; index++) {\\n            /**\\n             * we are calling the same function twice because we are not sure\\n             * the substring size will be of even or odd.\\n             *\\n             * If odd then we will be getting a middle point like for the String\\n             * \"abcdcba\" middle will be 3 i.e. character \\'d\\'\\n             *\\n             * but for the even number the middle will be 2 position like for\\n             * the String \"xyzzyx\" middle will be 2 and 3 position\\n             *\\n             */\\n            expandSearch(inputStr, index, index);\\n            expandSearch(inputStr, index, index + 1);\\n        }\\n\\n        return inputStr.substring(start, end);\\n    }\\n\\n    private void expandSearch(String inputStr, int startPosition, int endPosition) {\\n\\n        while (startPosition >= 0 && endPosition < inputStr.length()\\n                && inputStr.charAt(startPosition) == inputStr.charAt(endPosition)) {\\n\\n            startPosition--;\\n            endPosition++;\\n        }\\n\\n        int substringLength = endPosition - startPosition - 1;\\n\\n        /**\\n         * Keeping track of the max SubString length and corresponding start and end\\n         */\\n        if (substringLength > maxLength) {\\n            this.start = startPosition + 1;\\n            end = endPosition;\\n            this.maxLength = substringLength;\\n        }\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 618232,
                "title": "approach-1-using-longest-common-substring-concept",
                "content": "I know it\\'s not the best sol. But when I read Qs, the first sol. came into my mind is by using Longest common substring., because i Haven\\'t read Manacher Algorithm yet. And my sol got wrong answer. Same mistake as described in solution. So, here is the approach 1 sol.. Check whenever you got maximum substring whether it is palindrome or not. if yes update it.. otherwise skip it.\\n```\\nclass Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n        int n=s.length();\\n        string s2=s;\\n        reverse(s2.begin(),s2.end());\\n        return LCSS(s,s2,n);\\n    }\\n    string LCSS(string s1, string s2, int n)\\n    {\\n        string ans;\\n        int DP[n+1][n+1],max=0;\\n        for(int i=0; i<=n; ++i)\\n        {\\n            for(int j=0; j<=n; ++j)\\n            {\\n                if(i==0 || j==0)\\n                    DP[i][j]=0;\\n                else if(s1[i-1]==s2[j-1])\\n                {\\n                    DP[i][j]=1+DP[i-1][j-1];\\n                    if(DP[i][j]>max)\\n                    {\\n                        string temp=s1.substr(i-DP[i][j],DP[i][j]);\\n                        string revtemp=temp;\\n                        reverse(revtemp.begin(),revtemp.end());\\n                            if(revtemp==temp)\\n                            {\\n                                max=DP[i][j];\\n                                ans=temp;\\n                            }\\n                    }\\n                }\\n                else\\n                    DP[i][j]=0;\\n                \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n        int n=s.length();\\n        string s2=s;\\n        reverse(s2.begin(),s2.end());\\n        return LCSS(s,s2,n);\\n    }\\n    string LCSS(string s1, string s2, int n)\\n    {\\n        string ans;\\n        int DP[n+1][n+1],max=0;\\n        for(int i=0; i<=n; ++i)\\n        {\\n            for(int j=0; j<=n; ++j)\\n            {\\n                if(i==0 || j==0)\\n                    DP[i][j]=0;\\n                else if(s1[i-1]==s2[j-1])\\n                {\\n                    DP[i][j]=1+DP[i-1][j-1];\\n                    if(DP[i][j]>max)\\n                    {\\n                        string temp=s1.substr(i-DP[i][j],DP[i][j]);\\n                        string revtemp=temp;\\n                        reverse(revtemp.begin(),revtemp.end());\\n                            if(revtemp==temp)\\n                            {\\n                                max=DP[i][j];\\n                                ans=temp;\\n                            }\\n                    }\\n                }\\n                else\\n                    DP[i][j]=0;\\n                \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 337068,
                "title": "c-0ms-clean-code-based-on-expanding-window",
                "content": "C++ 0ms beats 100%\\n\\n```\\nclass Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n        \\n        // edge cases\\n        if(s.length() == 0 || s.length() == 1) return s;\\n        \\n        // to hold max len and its starting index\\n        int maxLenBeginIndex = 0;\\n        int maxLen = 1;\\n        \\n        int mid = 0;\\n        while(mid < s.length()){\\n            \\n            // calculating middle window\\n            \\n            int midBegin = mid;\\n            int midEnd = mid;\\n            \\n            // handling even length palindromes; the middlemost chars will trivially match in even length case\\n            // so expand the middle window as long as possible\\n            while( midEnd + 1 < s.length() && s[midEnd] == s[midEnd + 1]){ midEnd++ ; }\\n            \\n            // for next iteration\\n            mid = midEnd + 1;\\n            \\n            // starting comparison in left and right windows\\n            \\n            // in case of odd len palindrome; both start from mid;\\n            // in case of even; midBegin and midEnd handles it all\\n            int leftWindow = midBegin;\\n            int rightWindow = midEnd;\\n            \\n            // expand the windows left and right simultaneously\\n            while(leftWindow - 1 >= 0 && rightWindow + 1 < s.length() && s[leftWindow - 1] == s[rightWindow + 1]){\\n                    leftWindow--;\\n                    rightWindow++;\\n            }\\n            \\n            // update maxLen is currLen > maxLen\\n            int currLen = rightWindow - leftWindow + 1;\\n            if( currLen  > maxLen ){\\n                maxLenBeginIndex = leftWindow;\\n                maxLen = currLen;\\n            }\\n        }\\n        \\n        return s.substr(maxLenBeginIndex, maxLen);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n        \\n        // edge cases\\n        if(s.length() == 0 || s.length() == 1) return s;\\n        \\n        // to hold max len and its starting index\\n        int maxLenBeginIndex = 0;\\n        int maxLen = 1;\\n        \\n        int mid = 0;\\n        while(mid < s.length()){\\n            \\n            // calculating middle window\\n            \\n            int midBegin = mid;\\n            int midEnd = mid;\\n            \\n            // handling even length palindromes; the middlemost chars will trivially match in even length case\\n            // so expand the middle window as long as possible\\n            while( midEnd + 1 < s.length() && s[midEnd] == s[midEnd + 1]){ midEnd++ ; }\\n            \\n            // for next iteration\\n            mid = midEnd + 1;\\n            \\n            // starting comparison in left and right windows\\n            \\n            // in case of odd len palindrome; both start from mid;\\n            // in case of even; midBegin and midEnd handles it all\\n            int leftWindow = midBegin;\\n            int rightWindow = midEnd;\\n            \\n            // expand the windows left and right simultaneously\\n            while(leftWindow - 1 >= 0 && rightWindow + 1 < s.length() && s[leftWindow - 1] == s[rightWindow + 1]){\\n                    leftWindow--;\\n                    rightWindow++;\\n            }\\n            \\n            // update maxLen is currLen > maxLen\\n            int currLen = rightWindow - leftWindow + 1;\\n            if( currLen  > maxLen ){\\n                maxLenBeginIndex = leftWindow;\\n                maxLen = currLen;\\n            }\\n        }\\n        \\n        return s.substr(maxLenBeginIndex, maxLen);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2156669,
                "title": "c-dynamic-and-brute",
                "content": "**UPVOTE IF HELPFuuL**\\n\\nDYNAMIC APPROACH\\n\\n**PALINDROME in DP**->If its first and last elements are same and the substring after excluding the first and last character is a palindrome.\\n* Hence we can now reduce a bigger problem to smaller problem whose answer may be previously known.\\n\\n* Use a matrix where ```dp[ i ] [ j ]``` represents substring from ith pos to jth pos.\\n* All single characters are palindromes, thus substring with a length 1 are substring by default.\\n* substrings of length 2 are *palin* if both characters are same.\\n* \\nAnd for rest of lengths use the sub problem.\\n\\nNow we need longest so the palindromic substring with longest length is the substring.\\n\\n**BRUTE FORECE**\\n```\\nstring longestPalindrome(string s) {\\n\\n        int n=s.size();\\n        int res=1, start=0;\\n        string ans;\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            int l=i-1;\\n            int r=i+1;\\n            \\n            while(l>=0 && s[i]==s[l])\\n            {\\n                l--;\\n            }\\n            while(r<n && s[i]==s[r])\\n            {\\n                r++;\\n            }\\n            while(l>=0 && r<n && s[l]==s[r])\\n            {\\n                l--;\\n                r++;\\n            }\\n            int length=(r-1)-(l+1)+1;  \\n            if(length>res)\\n            {\\n                res=length;\\n                start=l+1;\\n            }\\n        }\\n        ans=s.substr(start,res);\\n        return ans;\\n}\\n```\\n\\n**DYNAMIC APPROACH**\\n```\\nclass Solution {\\n\\tpublic:\\n   \\tstring longestPalindrome(string s) {   \\n\\t    int n = s.size();\\n    \\tint dp[n][n];\\n    \\t\\n\\t    memset(dp,0,sizeof(dp));\\n    \\tint end=1;\\n    \\tint strt=0;\\n\\t\\n\\t    for(int i=0;i<n;i++){\\n\\t        dp[i][i] = 1;\\n    \\t}\\n\\t    for(int i=0;i<n-1;i++){\\n\\t        if(s[i]==s[i+1]){\\n    \\t    \\tdp[i][i+1]=1;\\n        \\t\\tstrt=i;end=2;\\n       \\t\\t}\\n\\t    }\\n    \\tfor(int j=2;j<n;j++){\\n\\t        for(int i=0;i< n-j;i++){  \\n           \\t\\tint lft=i;\\n            \\tint rght = i+j;\\n        \\t    \\n    \\t        if(dp[lft+1][rght-1]==1 && s[lft]==s[rght]) \\n\\t            {\\n                \\tdp[lft][rght]=1; strt=i; end=j+1; \\n            \\t}        \\n        \\t}\\n    \\t}\\n    return s.substr(strt, end);\\n\\t}\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/198452f0-bf71-403a-b5c8-ca932253ad55_1655339990.8810625.jpeg)\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```dp[ i ] [ j ]```\n```\\nstring longestPalindrome(string s) {\\n\\n        int n=s.size();\\n        int res=1, start=0;\\n        string ans;\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            int l=i-1;\\n            int r=i+1;\\n            \\n            while(l>=0 && s[i]==s[l])\\n            {\\n                l--;\\n            }\\n            while(r<n && s[i]==s[r])\\n            {\\n                r++;\\n            }\\n            while(l>=0 && r<n && s[l]==s[r])\\n            {\\n                l--;\\n                r++;\\n            }\\n            int length=(r-1)-(l+1)+1;  \\n            if(length>res)\\n            {\\n                res=length;\\n                start=l+1;\\n            }\\n        }\\n        ans=s.substr(start,res);\\n        return ans;\\n}\\n```\n```\\nclass Solution {\\n\\tpublic:\\n   \\tstring longestPalindrome(string s) {   \\n\\t    int n = s.size();\\n    \\tint dp[n][n];\\n    \\t\\n\\t    memset(dp,0,sizeof(dp));\\n    \\tint end=1;\\n    \\tint strt=0;\\n\\t\\n\\t    for(int i=0;i<n;i++){\\n\\t        dp[i][i] = 1;\\n    \\t}\\n\\t    for(int i=0;i<n-1;i++){\\n\\t        if(s[i]==s[i+1]){\\n    \\t    \\tdp[i][i+1]=1;\\n        \\t\\tstrt=i;end=2;\\n       \\t\\t}\\n\\t    }\\n    \\tfor(int j=2;j<n;j++){\\n\\t        for(int i=0;i< n-j;i++){  \\n           \\t\\tint lft=i;\\n            \\tint rght = i+j;\\n        \\t    \\n    \\t        if(dp[lft+1][rght-1]==1 && s[lft]==s[rght]) \\n\\t            {\\n                \\tdp[lft][rght]=1; strt=i; end=j+1; \\n            \\t}        \\n        \\t}\\n    \\t}\\n    return s.substr(strt, end);\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 236623,
                "title": "python-expand-around-center-with-explanation",
                "content": "```python\\ndef expand_and_count(s, start, end):\\n    while start >= 0 and end <= len(s) - 1 and s[start] == s[end]:\\n        start -= 1\\n        end += 1\\n        \\n    # The indices used for the below substring are:\\n    # start + 1: because we kept decreasing start by 1 before breaking the loop\\n    # end: because we kept increasing end by 1 before breaking the loop\\n    # and python substring excludes the end index\\n    return s[start + 1 : end]\\n\\nclass Solution(object):\\n    def longestPalindrome(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: str\\n        \"\"\"\\n        longest = \\'\\'\\n        \\n        for i in range(len(s)):\\n            # If palindrom starts with same index and expands\\n            # on both sides, it has odd number of letters\\n            odd = expand_and_count(s, i, i)\\n            # If palindrom starts with consecutive indices and expands\\n            # on both sides, it has even number of letters\\n            even = expand_and_count(s, i, i + 1)\\n            \\n            longer = \\'\\'\\n            \\n            if len(even) > len(odd):\\n                longer = even\\n            else:\\n                longer = odd\\n                \\n            if len(longer) > len(longest):\\n                longest = longer\\n                \\n        return longest\\n```",
                "solutionTags": [],
                "code": "```python\\ndef expand_and_count(s, start, end):\\n    while start >= 0 and end <= len(s) - 1 and s[start] == s[end]:\\n        start -= 1\\n        end += 1\\n        \\n    # The indices used for the below substring are:\\n    # start + 1: because we kept decreasing start by 1 before breaking the loop\\n    # end: because we kept increasing end by 1 before breaking the loop\\n    # and python substring excludes the end index\\n    return s[start + 1 : end]\\n\\nclass Solution(object):\\n    def longestPalindrome(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: str\\n        \"\"\"\\n        longest = \\'\\'\\n        \\n        for i in range(len(s)):\\n            # If palindrom starts with same index and expands\\n            # on both sides, it has odd number of letters\\n            odd = expand_and_count(s, i, i)\\n            # If palindrom starts with consecutive indices and expands\\n            # on both sides, it has even number of letters\\n            even = expand_and_count(s, i, i + 1)\\n            \\n            longer = \\'\\'\\n            \\n            if len(even) > len(odd):\\n                longer = even\\n            else:\\n                longer = odd\\n                \\n            if len(longer) > len(longest):\\n                longest = longer\\n                \\n        return longest\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1310663,
                "title": "easy-to-understand-dp-solution-in-c",
                "content": "```\\nclass Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n        int n=s.size();\\n        string res=\"\";\\n        int leni=1,lenj=1,i,j;\\n        int dp[n+1][n+1];\\n        for(i=0;i<n+1;i++)\\n        {\\n            dp[0][i]=1;\\n            dp[1][i]=1;\\n        }\\n        for(i=2;i<=n;i++)\\n        {\\n            for(j=i;j<=n;j++)\\n            {\\n                if(s[j-1]==s[j-i]&&dp[i-2][j-1]==1)\\n                    dp[i][j]=1,leni=i,lenj=j;\\n                else\\n                    dp[i][j]=0;\\n            }\\n        }\\n        for(i=lenj-leni;i<lenj;i++)\\n            res.push_back(s[i]);\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n        int n=s.size();\\n        string res=\"\";\\n        int leni=1,lenj=1,i,j;\\n        int dp[n+1][n+1];\\n        for(i=0;i<n+1;i++)\\n        {\\n            dp[0][i]=1;\\n            dp[1][i]=1;\\n        }\\n        for(i=2;i<=n;i++)\\n        {\\n            for(j=i;j<=n;j++)\\n            {\\n                if(s[j-1]==s[j-i]&&dp[i-2][j-1]==1)\\n                    dp[i][j]=1,leni=i,lenj=j;\\n                else\\n                    dp[i][j]=0;\\n            }\\n        }\\n        for(i=lenj-leni;i<lenj;i++)\\n            res.push_back(s[i]);\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1687940,
                "title": "simple-dp-solution-based-on-aditya-verma-s-video",
                "content": "```\\nclass Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n        string s1=s;\\n        reverse(s.begin(),s.end());\\n        string ans;\\n       int n=s.size();\\n        int res=0;\\n      int dp[n+1][n+1];\\n        for(int i=0;i<=n;i++){\\n            for(int j=0;j<=n;j++){\\n                if(i==0||j==0)\\n                    dp[i][j]=0;\\n               else if(s[i-1]==s1[j-1]){\\n                    dp[i][j]=dp[i-1][j-1]+1;\\n                   \\n                   \\n                }\\n                else\\n                    dp[i][j]=0;\\n                \\n                 if(dp[i][j]>res)\\n                    {\\n                        string temp=s.substr(i-dp[i][j],dp[i][j]);\\n                        string rev=temp;\\n                        reverse(rev.begin(),rev.end());\\n                        if(temp==rev){    //check if common substring is palindromic or not\\n                             ans=temp;\\n                        res=dp[i][j];\\n                        }\\n                           \\n                    }\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```\\n// if you like the solution plz upvote",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n        string s1=s;\\n        reverse(s.begin(),s.end());\\n        string ans;\\n       int n=s.size();\\n        int res=0;\\n      int dp[n+1][n+1];\\n        for(int i=0;i<=n;i++){\\n            for(int j=0;j<=n;j++){\\n                if(i==0||j==0)\\n                    dp[i][j]=0;\\n               else if(s[i-1]==s1[j-1]){\\n                    dp[i][j]=dp[i-1][j-1]+1;\\n                   \\n                   \\n                }\\n                else\\n                    dp[i][j]=0;\\n                \\n                 if(dp[i][j]>res)\\n                    {\\n                        string temp=s.substr(i-dp[i][j],dp[i][j]);\\n                        string rev=temp;\\n                        reverse(rev.begin(),rev.end());\\n                        if(temp==rev){    //check if common substring is palindromic or not\\n                             ans=temp;\\n                        res=dp[i][j];\\n                        }\\n                           \\n                    }\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1057629,
                "title": "python-super-simple-easy-understanding-solution-o-n-2",
                "content": "\\tclass Solution:\\n\\t\\tdef longestPalindrome(self, s: str) -> str:\\n\\t\\t\\tres = \"\"\\n\\t\\t\\tlength = len(s)\\n\\t\\t\\tdef helper(left: int, right: int):\\n\\t\\t\\t\\twhile left >= 0 and right < length and s[left] == s[right]:\\n\\t\\t\\t\\t\\tleft -= 1\\n\\t\\t\\t\\t\\tright += 1\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\treturn s[left + 1 : right]\\n\\t\\t\\t\\n\\t\\t\\t\\n\\t\\t\\tfor index in range(len(s)):\\n\\t\\t\\t\\tres = max(helper(index, index), helper(index, index + 1), res, key = len)\\n\\t\\t\\t\\t\\n\\t\\t\\treturn res",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef longestPalindrome(self, s: str) -> str:\\n\\t\\t\\tres = \"\"\\n\\t\\t\\tlength = len(s)\\n\\t\\t\\tdef helper(left: int, right: int):\\n\\t\\t\\t\\twhile left >= 0 and right < length and s[left] == s[right]:\\n\\t\\t\\t\\t\\tleft -= 1\\n\\t\\t\\t\\t\\tright += 1\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\treturn s[left + 1 : right]\\n\\t\\t\\t\\n\\t\\t\\t\\n\\t\\t\\tfor index in range(len(s)):\\n\\t\\t\\t\\tres = max(helper(index, index), helper(index, index + 1), res, key = len)\\n\\t\\t\\t\\t\\n\\t\\t\\treturn res",
                "codeTag": "Java"
            },
            {
                "id": 2157990,
                "title": "c-2-approaches-two-pointers-dp-simple-efficinet-solution-dlc-june-day-16",
                "content": "**Approach-1:** Use 2 pointers approach. \\nFor odd length palindromic substring, we start from same index and check for near characters\\nFor even length palindromic substring, start from adjacent index and check for near characters.\\n\\n**Time Complexity: O(2N^2)\\nSpace Complexity: O(1)**\\n\\n**Code:**\\n```\\nclass Solution {\\npublic:\\n    string longestPalindrome(string s) \\n    {\\n        int lenMax = 0;\\n        string res;\\n        \\n        for(int i=0; i<s.length(); i++)\\n        {\\n            string odd = pali_subs(s, i, i); //start from same index for odd length palindrome\\n            long_subs(odd, res, lenMax);\\n            string even = pali_subs(s, i, i+1); //start from adjacent index for even length palindrome\\n            long_subs(even, res, lenMax);\\n        }\\n        return res;\\n    }\\n\\t\\n\\tstring pali_subs(string &s, int L, int R)\\n    {\\n        int n=s.size();\\n        while(L>=0 && R<n) //iterate until L and R cross the boundary\\n        {\\n            if(s[L]!=s[R]) break;\\n            L--;\\n            R++;\\n        }\\n        return s.substr(L+1, R-1-L); //return palindromic substring\\n    }\\n    \\n    void long_subs(string &new_s, string &res, int &lenMax)\\n    {\\n        if(new_s.size()>lenMax) //if \\n        {\\n            res = new_s;\\n            lenMax = new_s.size();\\n        }\\n    }\\n};\\n```\\n**Please upvote if it helps \\u2764\\uFE0F\\uD83D\\uDE0A**\\n\\n**Approach-2:** Use DP and mark already covered small sub-string is palindromic or not and use it for other longer sub-string\\n\\n**Time Complexity: O(N^2)\\nSpace Complexity: O(n^2)**\\n\\n**Code:**\\n```\\nclass Solution \\n{\\npublic:\\n    string longestPalindrome(string s) \\n    {\\n        int n=s.size(); \\n        \\n        //dp[i][j] will be false if substring s[i..j] is not palindrome, Else true\\n        vector<vector<bool>> dp(n, vector<bool> (n,false));\\n        \\n        //All substrings of length 1 are palindromes\\n        for(int i=0; i<n; i++) dp[i][i]=true;\\n        \\n        int start=0, lenMax=1;\\n        \\n        // check for sub-string of length 2.\\n        for(int i=0; i<n-1; i++) \\n        {\\n            if(s[i]==s[i+1])\\n            {\\n                dp[i][i+1] = true;\\n                start = i;\\n                lenMax = 2;\\n            }\\n        }\\n        \\n        // Check for sub-string of length greater than 2.\\n        for(int k=3; k<=n; k++)  // k is length of substring\\n        {\\n            for(int i=0; i<n-k+1; i++) // Fix the starting index\\n            {\\n                int j=i+k-1; // Get the ending index of substring from starting index i and length k\\n                \\n                // checking for sub-string from ith index to jth index if s[i+1] to s[j-1] is a palindrome\\n                if(dp[i+1][j-1]==true && s[i]==s[j])\\n                {\\n                    dp[i][j] = true;\\n                    \\n                    if(k>lenMax)\\n                    {\\n                        lenMax = k;\\n                        start=i;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return s.substr(start, lenMax); //print sub-string from start to lenMax\\n    }\\n};\\n```\\n\\n**Please upvote if it helps \\u2764\\uFE0F\\uD83D\\uDE0A**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string longestPalindrome(string s) \\n    {\\n        int lenMax = 0;\\n        string res;\\n        \\n        for(int i=0; i<s.length(); i++)\\n        {\\n            string odd = pali_subs(s, i, i); //start from same index for odd length palindrome\\n            long_subs(odd, res, lenMax);\\n            string even = pali_subs(s, i, i+1); //start from adjacent index for even length palindrome\\n            long_subs(even, res, lenMax);\\n        }\\n        return res;\\n    }\\n\\t\\n\\tstring pali_subs(string &s, int L, int R)\\n    {\\n        int n=s.size();\\n        while(L>=0 && R<n) //iterate until L and R cross the boundary\\n        {\\n            if(s[L]!=s[R]) break;\\n            L--;\\n            R++;\\n        }\\n        return s.substr(L+1, R-1-L); //return palindromic substring\\n    }\\n    \\n    void long_subs(string &new_s, string &res, int &lenMax)\\n    {\\n        if(new_s.size()>lenMax) //if \\n        {\\n            res = new_s;\\n            lenMax = new_s.size();\\n        }\\n    }\\n};\\n```\n```\\nclass Solution \\n{\\npublic:\\n    string longestPalindrome(string s) \\n    {\\n        int n=s.size(); \\n        \\n        //dp[i][j] will be false if substring s[i..j] is not palindrome, Else true\\n        vector<vector<bool>> dp(n, vector<bool> (n,false));\\n        \\n        //All substrings of length 1 are palindromes\\n        for(int i=0; i<n; i++) dp[i][i]=true;\\n        \\n        int start=0, lenMax=1;\\n        \\n        // check for sub-string of length 2.\\n        for(int i=0; i<n-1; i++) \\n        {\\n            if(s[i]==s[i+1])\\n            {\\n                dp[i][i+1] = true;\\n                start = i;\\n                lenMax = 2;\\n            }\\n        }\\n        \\n        // Check for sub-string of length greater than 2.\\n        for(int k=3; k<=n; k++)  // k is length of substring\\n        {\\n            for(int i=0; i<n-k+1; i++) // Fix the starting index\\n            {\\n                int j=i+k-1; // Get the ending index of substring from starting index i and length k\\n                \\n                // checking for sub-string from ith index to jth index if s[i+1] to s[j-1] is a palindrome\\n                if(dp[i+1][j-1]==true && s[i]==s[j])\\n                {\\n                    dp[i][j] = true;\\n                    \\n                    if(k>lenMax)\\n                    {\\n                        lenMax = k;\\n                        start=i;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return s.substr(start, lenMax); //print sub-string from start to lenMax\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1381108,
                "title": "c-solution-for-5-longest-palindromic-substring-using-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    string longest_common_substring(string str1, string str2) \\n    {   \\n        int s1 = str1.size(); int s2 = str2.size();\\n        int dp[s1+1][s2+1];\\n        string res ; int max = 0 ;\\n\\n        for(int i=0; i<=s1; i++)\\n        {\\n            for(int j=0; j<=s2; j++)\\n            {   if(i==0 || j==0){ dp[i][j] = 0;}\\n             \\n                else if(str1[i-1] == str2[j-1])\\n                {\\n                    dp[i][j] = 1 + dp[i-1][j-1];\\n                    \\n                    if(dp[i][j]>max)\\n                    {\\n                        string temp = str1.substr(i-dp[i][j], dp[i][j]) ;\\n                        \\n                        string revtemp = string(temp.rbegin(),temp.rend());\\n                        if(revtemp==temp)\\n                        {\\n                            max = dp[i][j] ;\\n                            res = temp ;\\n                        }\\n                    }\\n                }\\n                else\\n                { dp[i][j] = 0 ; }\\n            }\\n        }\\n\\n        return res;\\n    }\\n    string longestPalindrome(string s)\\n    {\\n        string srev = string(s.rbegin(),s.rend());\\n        return longest_common_substring(s, srev); \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string longest_common_substring(string str1, string str2) \\n    {   \\n        int s1 = str1.size(); int s2 = str2.size();\\n        int dp[s1+1][s2+1];\\n        string res ; int max = 0 ;\\n\\n        for(int i=0; i<=s1; i++)\\n        {\\n            for(int j=0; j<=s2; j++)\\n            {   if(i==0 || j==0){ dp[i][j] = 0;}\\n             \\n                else if(str1[i-1] == str2[j-1])\\n                {\\n                    dp[i][j] = 1 + dp[i-1][j-1];\\n                    \\n                    if(dp[i][j]>max)\\n                    {\\n                        string temp = str1.substr(i-dp[i][j], dp[i][j]) ;\\n                        \\n                        string revtemp = string(temp.rbegin(),temp.rend());\\n                        if(revtemp==temp)\\n                        {\\n                            max = dp[i][j] ;\\n                            res = temp ;\\n                        }\\n                    }\\n                }\\n                else\\n                { dp[i][j] = 0 ; }\\n            }\\n        }\\n\\n        return res;\\n    }\\n    string longestPalindrome(string s)\\n    {\\n        string srev = string(s.rbegin(),s.rend());\\n        return longest_common_substring(s, srev); \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1137306,
                "title": "2-explained-solutions-for-your-coding-interview",
                "content": "First Solution - Brute Force:\\nbasically trying every possible substring in the string:\\n\\n```\\nvar longestPalindrome = function (s) {\\n  for (let j = s.length - 1; j >= 0; j--) {\\n    let i = 0,\\n      k = j;\\n    while (k < s.length) {\\n      let substr = s.substring(i, k + 1);\\n      if (isPalindrome(substr)) return substr;\\n      i++, k++;\\n    }\\n  }\\n  return \"\";\\n};\\n\\nfunction isPalindrome(str) {\\n  let l = 0,\\n    r = str.length - 1;\\n  while (l < r) {\\n    if (str[l] !== str[r]) return false;\\n    l++, r--;\\n  }\\n  return true;\\n}\\n```\\n\\nSecond Solution - Optimized:\\nFor each char in str, consider it were the middle, then try to expand the substring as long as left and right sides are equal\\n\\n```\\nvar longestPalindrome = function (s) {\\n      let res = \\'\\';\\n      for(let i = 0; i < s.length; i++){\\n          // Odd - if there is only 1 char in the middle, like \\'bob\\'\\n          let lOdd = i, rOdd = i;\\n          expandAroundCenter(lOdd, rOdd)\\n          //Even - 2 chars in the middle, like \\'kbbk\\'\\n          let lEven = i, rEven = i + 1;\\n          expandAroundCenter(lEven, rEven);\\n      }\\n    // helper\\n      function expandAroundCenter(left, right){\\n        while(left >= 0 && right < s.length && s[left] === s[right]){\\n          let subStr = s.substring(left, right + 1);\\n          if(subStr.length > res.length){\\n            res = subStr;\\n          }\\n          left--;\\n          right++;\\n        }\\n      }\\n      return res;\\n};\\n  ```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar longestPalindrome = function (s) {\\n  for (let j = s.length - 1; j >= 0; j--) {\\n    let i = 0,\\n      k = j;\\n    while (k < s.length) {\\n      let substr = s.substring(i, k + 1);\\n      if (isPalindrome(substr)) return substr;\\n      i++, k++;\\n    }\\n  }\\n  return \"\";\\n};\\n\\nfunction isPalindrome(str) {\\n  let l = 0,\\n    r = str.length - 1;\\n  while (l < r) {\\n    if (str[l] !== str[r]) return false;\\n    l++, r--;\\n  }\\n  return true;\\n}\\n```\n```\\nvar longestPalindrome = function (s) {\\n      let res = \\'\\';\\n      for(let i = 0; i < s.length; i++){\\n          // Odd - if there is only 1 char in the middle, like \\'bob\\'\\n          let lOdd = i, rOdd = i;\\n          expandAroundCenter(lOdd, rOdd)\\n          //Even - 2 chars in the middle, like \\'kbbk\\'\\n          let lEven = i, rEven = i + 1;\\n          expandAroundCenter(lEven, rEven);\\n      }\\n    // helper\\n      function expandAroundCenter(left, right){\\n        while(left >= 0 && right < s.length && s[left] === s[right]){\\n          let subStr = s.substring(left, right + 1);\\n          if(subStr.length > res.length){\\n            res = subStr;\\n          }\\n          left--;\\n          right++;\\n        }\\n      }\\n      return res;\\n};\\n  ```",
                "codeTag": "Unknown"
            },
            {
                "id": 801301,
                "title": "java-easy-to-understand-expand-from-mid-to-end",
                "content": "**Please upvote if helpful!!**\\n\\n```\\nclass Solution {\\n   public String longestPalindrome(String s) {\\n\\n        if (s.length() <= 1) return s;\\n\\n        String result = \"\";\\n        for (int i = 0; i < s.length(); i++) {\\n\\n            String odd = expandRange(s, i, i);\\n\\n            if (odd.length() > result.length()) {\\n                result = odd;\\n            }\\n\\n            String even = expandRange(s, i, i + 1);\\n\\n            if (even.length() > result.length()) {\\n                result = even;\\n            }\\n        }\\n\\n        return result;\\n    }\\n\\n\\n    private String expandRange(String s, int left, int right) {\\n\\n        String string = s;\\n        while (left >= 0 && right < s.length() && s.charAt(left) == s.charAt(right)) {\\n            left--;\\n            right++;\\n        }\\n        return string.substring(left + 1, right); //left + 1 because after 0 the left will be -1 and the substring method begin index is inclusive.\\n        // we need not do to right + 1 because right will point  to s.length when it reaches end of string and the substring method end index is exclusive.\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n   public String longestPalindrome(String s) {\\n\\n        if (s.length() <= 1) return s;\\n\\n        String result = \"\";\\n        for (int i = 0; i < s.length(); i++) {\\n\\n            String odd = expandRange(s, i, i);\\n\\n            if (odd.length() > result.length()) {\\n                result = odd;\\n            }\\n\\n            String even = expandRange(s, i, i + 1);\\n\\n            if (even.length() > result.length()) {\\n                result = even;\\n            }\\n        }\\n\\n        return result;\\n    }\\n\\n\\n    private String expandRange(String s, int left, int right) {\\n\\n        String string = s;\\n        while (left >= 0 && right < s.length() && s.charAt(left) == s.charAt(right)) {\\n            left--;\\n            right++;\\n        }\\n        return string.substring(left + 1, right); //left + 1 because after 0 the left will be -1 and the substring method begin index is inclusive.\\n        // we need not do to right + 1 because right will point  to s.length when it reaches end of string and the substring method end index is exclusive.\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 288371,
                "title": "python-solution-by-using-dynamic-programming",
                "content": "```python\\nclass Solution(object):\\n    def longestPalindrome(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: str\\n        \"\"\"\\n        #1. create a 2D array, size is len(s) * len(s)\\n        dp = [[False]*len(s) for _ in range(len(s))]\\n        \\n        #2. initial lcs related char index\\n        lcsStartIndex = 0\\n        lcsEndIndex = 0\\n        \\n        #3. dp algo\\n        \"\"\"\\n            a b a\\n            0 1 2\\n        a 0 T X X\\n        b 1 F T X\\n        a 2 T F T\\n        \"\"\"\\n        for i in range(len(s)):\\n            #what we need is only the left bottom part\\n            start = i\\n            end = i\\n            while start >= 0:\\n                #case1. if sub-string is \\'a\\'\\n                if start == end:\\n                    dp[start][end] = True\\n                #case2. if sub-string is \\'ab\\'\\n                #We need this case because start + 1 may larger than end - 1 if using case3 directly\\n                elif start + 1 == end:\\n                    dp[start][end] = s[start] == s[end]\\n                #case3. if sub-string is \\'aba\\' \\'abac\\' ..etc, i.e. len(sub) >= 3\\n                else:\\n                    dp[start][end] = dp[start+1][end-1] and (s[start] == s[end])\\n            \\n                #if dp[start][end] is palidromic, check is it longer than current solution\\n                if dp[start][end] and (end - start + 1) > (lcsEndIndex - lcsStartIndex + 1):\\n                    lcsStartIndex = start\\n                    lcsEndIndex = end\\n                \\n                start = start - 1\\n        \\n        return s[lcsStartIndex:lcsEndIndex+1]\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```python\\nclass Solution(object):\\n    def longestPalindrome(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: str\\n        \"\"\"\\n        #1. create a 2D array, size is len(s) * len(s)\\n        dp = [[False]*len(s) for _ in range(len(s))]\\n        \\n        #2. initial lcs related char index\\n        lcsStartIndex = 0\\n        lcsEndIndex = 0\\n        \\n        #3. dp algo\\n        \"\"\"\\n            a b a\\n            0 1 2\\n        a 0 T X X\\n        b 1 F T X\\n        a 2 T F T\\n        \"\"\"\\n        for i in range(len(s)):\\n            #what we need is only the left bottom part\\n            start = i\\n            end = i\\n            while start >= 0:\\n                #case1. if sub-string is \\'a\\'\\n                if start == end:\\n                    dp[start][end] = True\\n                #case2. if sub-string is \\'ab\\'\\n                #We need this case because start + 1 may larger than end - 1 if using case3 directly\\n                elif start + 1 == end:\\n                    dp[start][end] = s[start] == s[end]\\n                #case3. if sub-string is \\'aba\\' \\'abac\\' ..etc, i.e. len(sub) >= 3\\n                else:\\n                    dp[start][end] = dp[start+1][end-1] and (s[start] == s[end])\\n            \\n                #if dp[start][end] is palidromic, check is it longer than current solution\\n                if dp[start][end] and (end - start + 1) > (lcsEndIndex - lcsStartIndex + 1):\\n                    lcsStartIndex = start\\n                    lcsEndIndex = end\\n                \\n                start = start - 1\\n        \\n        return s[lcsStartIndex:lcsEndIndex+1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1110760,
                "title": "clean-python-not-fastest",
                "content": "```python\\nclass Solution:    \\n    def isPalindrome(self, s: str) -> bool:\\n        return s == s[::-1]\\n    \\n    def longestPalindrome(self, s: str) -> str:\\n        # so I want to create frames of different lengths\\n        # that will move along a string\\n        # so if string is abba\\n        # the first frame is abba\\n        # the second iteration be: abb, bba\\n        # third iteration be: ab, bb, ba\\n        # we start with widest frame, because we are after longest\\n        # palindromic substring\\n        # right off the bat check if the input itself is a non empty palindromic string\\n        if not s:\\n            raise Exception(\"You werent supposed to be null\")\\n            \\n        if self.isPalindrome(s):\\n            return s\\n                \\n        for i in range(len(s), 0, -1):\\n            for j in range(0, len(s)-i+1): \\n                candidate = s[j:j+i]\\n                if self.isPalindrome(candidate):\\n                    return candidate\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:    \\n    def isPalindrome(self, s: str) -> bool:\\n        return s == s[::-1]\\n    \\n    def longestPalindrome(self, s: str) -> str:\\n        # so I want to create frames of different lengths\\n        # that will move along a string\\n        # so if string is abba\\n        # the first frame is abba\\n        # the second iteration be: abb, bba\\n        # third iteration be: ab, bb, ba\\n        # we start with widest frame, because we are after longest\\n        # palindromic substring\\n        # right off the bat check if the input itself is a non empty palindromic string\\n        if not s:\\n            raise Exception(\"You werent supposed to be null\")\\n            \\n        if self.isPalindrome(s):\\n            return s\\n                \\n        for i in range(len(s), 0, -1):\\n            for j in range(0, len(s)-i+1): \\n                candidate = s[j:j+i]\\n                if self.isPalindrome(candidate):\\n                    return candidate\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3308,
                "title": "easy-java-solution-with-o-1-space-and-o-n-2-time",
                "content": "The basic idea is to traverse all the palindromes with its pivot range from the first char of string s to the last char of string s (consider both even length and odd length situation). Use StringBuilder to minimize the space complexity. Here is the code, feast yourself:\\n\\n    public class Solution {\\n    StringBuilder longest = new StringBuilder(\"\");\\n    \\n    public String longestPalindrome(String s) {\\n        if (s.length() <= 1) return s;\\n        \\n        for (int i = 0; i < s.length(); i++) {\\n            expand(s, longest, i, i); //odd\\n            expand(s, longest, i, i + 1); //even\\n        }\\n        \\n        return longest.toString();\\n    }\\n    \\n    private void expand(String s, StringBuilder longest, int i, int j) {\\n        while (i >= 0 && j < s.length()) {\\n            if (s.charAt(i) == s.charAt(j)) {\\n                if (j - i + 1 > longest.length()) {\\n                    longest.delete(0, longest.length());\\n                    longest.append(s.substring(i, j + 1));\\n                }\\n                i--;\\n                j++;\\n            }\\n            else\\n                break;\\n        }\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    StringBuilder longest = new StringBuilder(\"\");\\n    \\n    public String longestPalindrome(String s) {\\n        if (s.length() <= 1) return s;\\n        \\n        for (int i = 0; i < s.length(); i++) {\\n            expand(s, longest, i, i); //odd\\n            expand(s, longest, i, i + 1); //even\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2881157,
                "title": "js-easy-solution",
                "content": "```\\nvar longestPalindrome = function(s) {\\n    let res = \"\";\\n    let max = 0;\\n\\n    for(let i = 0; i < s.length; i++){\\n        for(let j = 0; j <= 1; j++){\\n            let l = i;\\n            let r = i + j;\\n\\n            while(l >= 0 && r < s.length && s[l] === s[r]){\\n                let len = r - l + 1;\\n                if(len > max){\\n                    res = s.substring(l, r + 1);\\n                    max = len;\\n                }\\n                l--;\\n                r++;\\n            }\\n        }\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar longestPalindrome = function(s) {\\n    let res = \"\";\\n    let max = 0;\\n\\n    for(let i = 0; i < s.length; i++){\\n        for(let j = 0; j <= 1; j++){\\n            let l = i;\\n            let r = i + j;\\n\\n            while(l >= 0 && r < s.length && s[l] === s[r]){\\n                let len = r - l + 1;\\n                if(len > max){\\n                    res = s.substring(l, r + 1);\\n                    max = len;\\n                }\\n                l--;\\n                r++;\\n            }\\n        }\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1317343,
                "title": "easy-c-solution-using-dp",
                "content": "```\\nclass Solution \\n{\\npublic:\\n    string longestPalindrome(string s)\\n    {\\n        int n=s.length(),start=0,len=0,dp[n][n];\\n        memset(dp,false,sizeof(dp));\\n        for(int i=0;i<n;i++)\\n        {\\n            dp[i][i]=true;\\n            len=1;\\n            start=i;\\n        }\\n        for(int i=0;i<n-1;i++)\\n        {\\n            if(s[i]==s[i+1])\\n            {\\n                dp[i][i+1]=true;\\n                start=i;\\n                len=2;\\n            }\\n        }\\n        for(int k=3;k<=n;k++)\\n        {\\n            for(int i=0;i<=n-k;i++)\\n            {\\n                int j=i+k-1;\\n                if(s[i]==s[j] && dp[i+1][j-1])\\n                {\\n                    dp[i][j]=true;\\n                    start=i;\\n                    len=max(len,k);\\n                }\\n            }\\n        }\\n        return s.substr(start,len);\\n    }\\n};\\n```\\n***Please upvote if you have got any help from my code. Thank you.***",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    string longestPalindrome(string s)\\n    {\\n        int n=s.length(),start=0,len=0,dp[n][n];\\n        memset(dp,false,sizeof(dp));\\n        for(int i=0;i<n;i++)\\n        {\\n            dp[i][i]=true;\\n            len=1;\\n            start=i;\\n        }\\n        for(int i=0;i<n-1;i++)\\n        {\\n            if(s[i]==s[i+1])\\n            {\\n                dp[i][i+1]=true;\\n                start=i;\\n                len=2;\\n            }\\n        }\\n        for(int k=3;k<=n;k++)\\n        {\\n            for(int i=0;i<=n-k;i++)\\n            {\\n                int j=i+k-1;\\n                if(s[i]==s[j] && dp[i+1][j-1])\\n                {\\n                    dp[i][j]=true;\\n                    start=i;\\n                    len=max(len,k);\\n                }\\n            }\\n        }\\n        return s.substr(start,len);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 241980,
                "title": "concise-c-solution",
                "content": "This is my concise C solution. Please comment your thought\\n```\\nchar* longestPalindrome(char* s) {\\n    char *start, *end;\\n    char *p = s, *subStart = s;\\n    int maxLen = 1;\\n    while(*p){\\n        start = p; end = p;\\n        \\n        while(*(end+1) && *(end+1) == *end){\\n            end++; // skip duplicates\\n        }\\n        p = end + 1;\\n        \\n        while(*(end + 1) && (start > s) && *(end + 1) == *(start - 1)){\\n            start--;\\n            end++;\\n        }\\n        if(end - start + 1 > maxLen){\\n            maxLen = end - start + 1;\\n            subStart = start;\\n        }\\n    }\\n    \\n    char *rst = (char *) calloc(maxLen + 1, sizeof(char));\\n    strncpy(rst, subStart, maxLen);\\n    return rst;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nchar* longestPalindrome(char* s) {\\n    char *start, *end;\\n    char *p = s, *subStart = s;\\n    int maxLen = 1;\\n    while(*p){\\n        start = p; end = p;\\n        \\n        while(*(end+1) && *(end+1) == *end){\\n            end++; // skip duplicates\\n        }\\n        p = end + 1;\\n        \\n        while(*(end + 1) && (start > s) && *(end + 1) == *(start - 1)){\\n            start--;\\n            end++;\\n        }\\n        if(end - start + 1 > maxLen){\\n            maxLen = end - start + 1;\\n            subStart = start;\\n        }\\n    }\\n    \\n    char *rst = (char *) calloc(maxLen + 1, sizeof(char));\\n    strncpy(rst, subStart, maxLen);\\n    return rst;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 408930,
                "title": "java-simple-and-concise-solution-with-detailed-explanation",
                "content": "```\\n\\t\\t// core logic: with one character and 2 characters as center, find the palindrome for each case, and whenever you encounter the longest palindrome, update it\\n        // two cases are needed to handle the odd and even cases separately\\n        private static String longestPalindrome(String s) {\\n            if (s == null || s.length() <= 1 || s.equals(\"\")) {\\n                return s;\\n            }\\n    \\n            String longest = s.substring(0, 1);\\n            for (int i = 0; i < s.length(); i++) {\\n                String temp = palindromeHelper(s, i, i);  // odd length\\n                if (temp.length() > longest.length()) {\\n                    longest = temp;\\n                }\\n    \\n                temp = palindromeHelper(s, i, i + 1);  // even length\\n                if (temp.length() > longest.length()) {\\n                    longest = temp;\\n                }\\n            }\\n            return longest;\\n        }\\n    \\n        // given a string and the CENTER(S) of the palindrome (i and i+1), find the longest possible palindrome\\n        // from center, go left and right till characters are same and return the longest palindromic substring\\n        private static String palindromeHelper(String string, int begin, int end) {\\n            while (begin >= 0 && end < string.length() && string.charAt(begin) == string.charAt(end)) {\\n                begin--;\\n                end++;\\n            }\\n            return string.substring(begin + 1, end);\\n        }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\t\\t// core logic: with one character and 2 characters as center, find the palindrome for each case, and whenever you encounter the longest palindrome, update it\\n        // two cases are needed to handle the odd and even cases separately\\n        private static String longestPalindrome(String s) {\\n            if (s == null || s.length() <= 1 || s.equals(\"\")) {\\n                return s;\\n            }\\n    \\n            String longest = s.substring(0, 1);\\n            for (int i = 0; i < s.length(); i++) {\\n                String temp = palindromeHelper(s, i, i);  // odd length\\n                if (temp.length() > longest.length()) {\\n                    longest = temp;\\n                }\\n    \\n                temp = palindromeHelper(s, i, i + 1);  // even length\\n                if (temp.length() > longest.length()) {\\n                    longest = temp;\\n                }\\n            }\\n            return longest;\\n        }\\n    \\n        // given a string and the CENTER(S) of the palindrome (i and i+1), find the longest possible palindrome\\n        // from center, go left and right till characters are same and return the longest palindromic substring\\n        private static String palindromeHelper(String string, int begin, int end) {\\n            while (begin >= 0 && end < string.length() && string.charAt(begin) == string.charAt(end)) {\\n                begin--;\\n                end++;\\n            }\\n            return string.substring(begin + 1, end);\\n        }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3190,
                "title": "11-line-python-solution-112ms",
                "content": "Just a Python version of this brilliant [C++ solution][1]. `while k < lenS - 1 and s[k] == s[k + 1]: k += 1` is very efficient and can handle both odd-length (`abbba`) and even-length (`abbbba`).\\n\\n    def longestPalindrome(self, s):\\n        lenS = len(s)\\n        if lenS <= 1: return s\\n        minStart, maxLen, i = 0, 1, 0\\n        while i < lenS:\\n            if lenS - i <= maxLen / 2: break\\n            j, k = i, i\\n            while k < lenS - 1 and s[k] == s[k + 1]: k += 1\\n            i = k + 1\\n            while k < lenS - 1 and j and s[k + 1] == s[j - 1]:  k, j = k + 1, j - 1\\n            if k - j + 1 > maxLen: minStart, maxLen = j, k - j + 1\\n        return s[minStart: minStart + maxLen]\\n\\n\\n  [1]: https://leetcode.com/discuss/32204/simple-c-solution-8ms-13-lines",
                "solutionTags": [
                    "Python"
                ],
                "code": "Just a Python version of this brilliant [C++ solution][1]. `while k < lenS - 1 and s[k] == s[k + 1]: k += 1` is very efficient and can handle both odd-length (`abbba`) and even-length (`abbbba`).\\n\\n    def longestPalindrome(self, s):\\n        lenS = len(s)\\n        if lenS <= 1: return s\\n        minStart, maxLen, i = 0, 1, 0\\n        while i < lenS:\\n            if lenS - i <= maxLen / 2: break\\n            j, k = i, i\\n            while k < lenS - 1 and s[k] == s[k + 1]: k += 1\\n            i = k + 1\\n            while k < lenS - 1 and j and s[k + 1] == s[j - 1]:  k, j = k + 1, j - 1\\n            if k - j + 1 > maxLen: minStart, maxLen = j, k - j + 1\\n        return s[minStart: minStart + maxLen]\\n\\n\\n  [1]: https://leetcode.com/discuss/32204/simple-c-solution-8ms-13-lines",
                "codeTag": "Python3"
            },
            {
                "id": 1262830,
                "title": "2-simple-c-approaches-dp-and-2-pointer-with-explanation",
                "content": "**Please upvote this post to motivate me in my quest of documenting leetcode solutions.**\\n```\\n// M-1 DP\\n// TC = SC = O(n^2)\\nclass Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n        int n = s.length();\\n        if(n==1) return s;\\n        vector<vector<bool>> dp(n, vector<bool>(n, false));\\n        // max length of the pallindromic substring\\n        int max_length = 0;\\n        // starting index of the max length pallindromic substring\\n        int start_index = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            dp[i][i] = true;\\n        }\\n        // check sub-strings of size 2\\n        for(int i = 0; i < n - 1; i++)\\n        {\\n            if(s[i] == s[i+1])\\n            {\\n                dp[i][i+1] = true;\\n                max_length = 2;\\n                start_index = i;\\n            }\\n        }\\n        // check sub-strings of size > 2\\n        // here k denotes the size of the sub-strings i.e. from 3 to n\\n        for(int k = 3; k <= n; k++)\\n        {\\n            for(int i = 0; i <= n - k; i++)\\n            {\\n                // i and j points to the starting & ending indices of the substring of size k\\n                int j = i + k - 1;\\n                if(s[i] == s[j] && dp[i+1][j-1] == true)\\n                {\\n                    dp[i][j] = true;\\n                    max_length = max(k, max_length);\\n                    start_index = i;\\n                }\\n            }\\n        }\\n        string ans = \"\";\\n        // if there is no pallindromic substring present of size >= 2 \\n        if(max_length == 0)\\n        {\\n            ans += s[0];\\n            return ans;\\n        }\\n        for(int i = start_index; i < start_index + max_length; i++)\\n        {\\n            ans += s[i];\\n        }\\n        return ans;\\n    }\\n};\\n\\n// M-2 \\n// TC = O(n^2) SC = O(1)\\nclass Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n        int n = s.length();\\n        if(n==1) return s;\\n        string ans = \"\";\\n        // low and high points to the starting & ending indices of the pallindromic substrings \\n        int low, high;\\n        // starting index of the max length pallindromic substring\\n        int start_index;\\n        // max length of the pallindromic substring\\n        int max_length = 0;\\n        for(int i = 1; i < n; i++)\\n        {\\n            // for odd length substrings\\n            // choose i as epicenter and move left and right checking the string is pallindrome or not\\n            low = i - 1;\\n            high = i + 1;\\n            while(low >= 0 && high < n && s[low] == s[high])\\n            {\\n                if(max_length < high - low + 1)\\n                {\\n                    max_length = high - low + 1;\\n                    start_index = low;\\n                }\\n                --low;\\n                ++high;\\n            }\\n            // for even length substrings\\n            // choose i-1 and i as epicenters and move left and right checking the string is pallindrome or not\\n            low = i - 1;\\n            high = i;\\n            while(low >= 0 && high < n && s[low] == s[high])\\n            {\\n                if(max_length < high - low + 1)\\n                {\\n                    max_length = high - low + 1;\\n                    start_index = low;\\n                }\\n                --low;\\n                ++high;\\n            }\\n        }\\n        // if there is no pallindromic substring present of size >= 2 \\n        if(max_length == 0)\\n        {\\n            ans += s[0];\\n            return ans;\\n        }\\n        for(int i = start_index; i < start_index + max_length; i++)\\n        {\\n            ans += s[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers",
                    "Dynamic Programming"
                ],
                "code": "```\\n// M-1 DP\\n// TC = SC = O(n^2)\\nclass Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n        int n = s.length();\\n        if(n==1) return s;\\n        vector<vector<bool>> dp(n, vector<bool>(n, false));\\n        // max length of the pallindromic substring\\n        int max_length = 0;\\n        // starting index of the max length pallindromic substring\\n        int start_index = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            dp[i][i] = true;\\n        }\\n        // check sub-strings of size 2\\n        for(int i = 0; i < n - 1; i++)\\n        {\\n            if(s[i] == s[i+1])\\n            {\\n                dp[i][i+1] = true;\\n                max_length = 2;\\n                start_index = i;\\n            }\\n        }\\n        // check sub-strings of size > 2\\n        // here k denotes the size of the sub-strings i.e. from 3 to n\\n        for(int k = 3; k <= n; k++)\\n        {\\n            for(int i = 0; i <= n - k; i++)\\n            {\\n                // i and j points to the starting & ending indices of the substring of size k\\n                int j = i + k - 1;\\n                if(s[i] == s[j] && dp[i+1][j-1] == true)\\n                {\\n                    dp[i][j] = true;\\n                    max_length = max(k, max_length);\\n                    start_index = i;\\n                }\\n            }\\n        }\\n        string ans = \"\";\\n        // if there is no pallindromic substring present of size >= 2 \\n        if(max_length == 0)\\n        {\\n            ans += s[0];\\n            return ans;\\n        }\\n        for(int i = start_index; i < start_index + max_length; i++)\\n        {\\n            ans += s[i];\\n        }\\n        return ans;\\n    }\\n};\\n\\n// M-2 \\n// TC = O(n^2) SC = O(1)\\nclass Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n        int n = s.length();\\n        if(n==1) return s;\\n        string ans = \"\";\\n        // low and high points to the starting & ending indices of the pallindromic substrings \\n        int low, high;\\n        // starting index of the max length pallindromic substring\\n        int start_index;\\n        // max length of the pallindromic substring\\n        int max_length = 0;\\n        for(int i = 1; i < n; i++)\\n        {\\n            // for odd length substrings\\n            // choose i as epicenter and move left and right checking the string is pallindrome or not\\n            low = i - 1;\\n            high = i + 1;\\n            while(low >= 0 && high < n && s[low] == s[high])\\n            {\\n                if(max_length < high - low + 1)\\n                {\\n                    max_length = high - low + 1;\\n                    start_index = low;\\n                }\\n                --low;\\n                ++high;\\n            }\\n            // for even length substrings\\n            // choose i-1 and i as epicenters and move left and right checking the string is pallindrome or not\\n            low = i - 1;\\n            high = i;\\n            while(low >= 0 && high < n && s[low] == s[high])\\n            {\\n                if(max_length < high - low + 1)\\n                {\\n                    max_length = high - low + 1;\\n                    start_index = low;\\n                }\\n                --low;\\n                ++high;\\n            }\\n        }\\n        // if there is no pallindromic substring present of size >= 2 \\n        if(max_length == 0)\\n        {\\n            ans += s[0];\\n            return ans;\\n        }\\n        for(int i = start_index; i < start_index + max_length; i++)\\n        {\\n            ans += s[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1888698,
                "title": "100-fastest-typescript-solution",
                "content": "```\\nfunction longestPalindrome(s: string): string {\\n  if (!s || s.length <= 1) { return s }\\n  let longestPalindrome = s.substring(0, 1)\\n\\n  for (let i = 0; i < s.length; i++) {\\n    [expand(s, i, i), expand(s, i, i + 1)].forEach((maybeLongest) => {\\n      if (maybeLongest.length > longestPalindrome.length) {\\n          longestPalindrome = maybeLongest\\n      }\\n    })\\n  }\\n\\n  return longestPalindrome\\n}\\n\\nfunction expand(s: string, begin: number, end: number): string {\\n  while (begin >= 0 && end <= s.length - 1 && s[begin] === s[end]) {\\n    begin--\\n    end++\\n  }\\n\\n  return s.substring(begin + 1, end)\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nfunction longestPalindrome(s: string): string {\\n  if (!s || s.length <= 1) { return s }\\n  let longestPalindrome = s.substring(0, 1)\\n\\n  for (let i = 0; i < s.length; i++) {\\n    [expand(s, i, i), expand(s, i, i + 1)].forEach((maybeLongest) => {\\n      if (maybeLongest.length > longestPalindrome.length) {\\n          longestPalindrome = maybeLongest\\n      }\\n    })\\n  }\\n\\n  return longestPalindrome\\n}\\n\\nfunction expand(s: string, begin: number, end: number): string {\\n  while (begin >= 0 && end <= s.length - 1 && s[begin] === s[end]) {\\n    begin--\\n    end++\\n  }\\n\\n  return s.substring(begin + 1, end)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1416561,
                "title": "simple-javascript-solution",
                "content": "```\\nvar longestPalindrome = function(s) {\\n    let longest = \\'\\';\\n    \\n    for (let i=0; i<s.length; i++){\\n        expandCheck(i, i);\\n        expandCheck(i, i+1);\\n    }\\n    \\n    function expandCheck(l, r){\\n        while (l>=0 && r<s.length && s[l]===s[r]){\\n            if (r-l+1 > longest.length){\\n                longest = s.slice(l, r+1);\\n            }\\n            l--;\\n            r++;\\n        }\\n    }\\n    \\n    return longest;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar longestPalindrome = function(s) {\\n    let longest = \\'\\';\\n    \\n    for (let i=0; i<s.length; i++){\\n        expandCheck(i, i);\\n        expandCheck(i, i+1);\\n    }\\n    \\n    function expandCheck(l, r){\\n        while (l>=0 && r<s.length && s[l]===s[r]){\\n            if (r-l+1 > longest.length){\\n                longest = s.slice(l, r+1);\\n            }\\n            l--;\\n            r++;\\n        }\\n    }\\n    \\n    return longest;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 262528,
                "title": "longest-palindromic-substring-c-clean-solution",
                "content": "```\\npublic class Solution {\\n    public string LongestPalindrome(string s) {\\n        int maxLength = 0, startIndex = 0;\\n        for (int i = 0; i < s.Length; i++) {\\n            int start = i, end = i;\\n            while(end < s.Length-1 && s[start] == s[end+1])\\n                end++;\\n            \\n            while(end < s.Length-1 && start > 0 && s[start-1] == s[end+1]) {\\n                start--; \\n                end++;\\n            }\\n            if(maxLength < end - start + 1) {\\n                maxLength = end - start + 1;\\n                startIndex = start;\\n            }\\n        }\\n        return s.Substring(startIndex, maxLength);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public string LongestPalindrome(string s) {\\n        int maxLength = 0, startIndex = 0;\\n        for (int i = 0; i < s.Length; i++) {\\n            int start = i, end = i;\\n            while(end < s.Length-1 && s[start] == s[end+1])\\n                end++;\\n            \\n            while(end < s.Length-1 && start > 0 && s[start-1] == s[end+1]) {\\n                start--; \\n                end++;\\n            }\\n            if(maxLength < end - start + 1) {\\n                maxLength = end - start + 1;\\n                startIndex = start;\\n            }\\n        }\\n        return s.Substring(startIndex, maxLength);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 162231,
                "title": "go-solution",
                "content": "```\\nfunc longestPalindrome(s string) string {\\n    var max string\\n    for i := 0; i < len(s); i++ {\\n        max = maxPalindrome(s, i, i, max)\\n        max = maxPalindrome(s, i, i+1, max)\\n    }\\n    return max\\n}\\n\\nfunc maxPalindrome(s string, i, j int, max string) string {\\n    var sub string\\n    for i >= 0 && j < len(s) && s[i] == s[j] {\\n        sub = s[i:j+1]\\n        i--\\n        j++\\n    }\\n    if len(max) < len(sub) {\\n        return sub\\n    }\\n    return max\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc longestPalindrome(s string) string {\\n    var max string\\n    for i := 0; i < len(s); i++ {\\n        max = maxPalindrome(s, i, i, max)\\n        max = maxPalindrome(s, i, i+1, max)\\n    }\\n    return max\\n}\\n\\nfunc maxPalindrome(s string, i, j int, max string) string {\\n    var sub string\\n    for i >= 0 && j < len(s) && s[i] == s[j] {\\n        sub = s[i:j+1]\\n        i--\\n        j++\\n    }\\n    if len(max) < len(sub) {\\n        return sub\\n    }\\n    return max\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3851503,
                "title": "c-dp-o-n-2",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUsing bottom-up approach and The main idea behind this is to divide string into smaller palindromic substrings and build up the solution iteratively from smaller palindromes to larger ones.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Initializing variables `start` with 0 (Starting index of the longest palindromic substring) and `longlen` with 1, which will contain the length of longest palindromic substring.\\n2. Initially, All substrings of length 1 are palindromic so mark them true.\\n3. then, check Check for substrings of length 2, if `ith` and `i+1th` matches then update `start` with i and `longlen` will be 2.\\n4. Now, Check for substrings of length 3 or more. in this we\\'ll check if the substring from `i` to `j` is a palindrome where `j` is ending index of current substring. \\n5. and then if substring is palindrome then update maxLength`longlen` n `start`.\\n6. Finally, return the string starting from `start`th index till length of `longlen` from Original string , which will contain the longest palindromic substring in the input string.\\n\\n# Complexity\\n- Time complexity:\\ncode uses two nested loops to iterate.\\nO(n^2).\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\ncode uses a 2D boolean table dp of size n x n.\\ntherefore, O(n^2).\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n//bottom-up approach\\nclass Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n        int n = s.size();\\n        int start = 0; // Starting index of the longest palindromic substring\\n        int longlen = 1; // Length of the longest palindromic substring (initialize to 1, as each character is a palindrome by itself)\\n        \\n        // Create a table to store the results of subproblems\\n        vector<vector<bool>> t(n, vector<bool>(n, false));\\n        \\n        // All substrings of length 1 are palindromic\\n        for (int i = 0; i < n; i++)\\n            t[i][i] = true;\\n        \\n        // Check for substrings of length 2\\n        for (int i = 0; i < n - 1; i++) \\n        {\\n            if (s[i] == s[i + 1])\\n            {\\n                t[i][i+1] = true;\\n                start = i;\\n                longlen = 2;\\n            }\\n        }\\n        \\n        // Check for substrings of length 3 or more\\n        for (int l = 3; l <= n; l++) \\n        {\\n            for (int i = 0; i < n - l + 1; i++) \\n            {\\n                int j = i + l - 1; // Ending index of the current substring\\n                // Check if the substring from i to j is a palindrome\\n                if (s[i] == s[j] && t[i + 1][j - 1]) \\n                {\\n                    t[i][j] = true;\\n                    if (l > longlen) \\n                    {\\n                        longlen = l;\\n                        start = i;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        //Extract the longest palindromic substring from original string\\n        return s.substr(start, longlen);\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```\\n//bottom-up approach\\nclass Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n        int n = s.size();\\n        int start = 0; // Starting index of the longest palindromic substring\\n        int longlen = 1; // Length of the longest palindromic substring (initialize to 1, as each character is a palindrome by itself)\\n        \\n        // Create a table to store the results of subproblems\\n        vector<vector<bool>> t(n, vector<bool>(n, false));\\n        \\n        // All substrings of length 1 are palindromic\\n        for (int i = 0; i < n; i++)\\n            t[i][i] = true;\\n        \\n        // Check for substrings of length 2\\n        for (int i = 0; i < n - 1; i++) \\n        {\\n            if (s[i] == s[i + 1])\\n            {\\n                t[i][i+1] = true;\\n                start = i;\\n                longlen = 2;\\n            }\\n        }\\n        \\n        // Check for substrings of length 3 or more\\n        for (int l = 3; l <= n; l++) \\n        {\\n            for (int i = 0; i < n - l + 1; i++) \\n            {\\n                int j = i + l - 1; // Ending index of the current substring\\n                // Check if the substring from i to j is a palindrome\\n                if (s[i] == s[j] && t[i + 1][j - 1]) \\n                {\\n                    t[i][j] = true;\\n                    if (l > longlen) \\n                    {\\n                        longlen = l;\\n                        start = i;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        //Extract the longest palindromic substring from original string\\n        return s.substr(start, longlen);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1738430,
                "title": "c-solution-using-2-loops-o-n-time-complexity",
                "content": "> **If you\\u2019re interested in coding you can join my Discord Server, link in the comment section. Also if you find any mistake please let me know. Thank you!\\u2764\\uFE0F**\\n> \\n\\n---\\n\\n## Explanation:\\n\\n### Solution 01\\n\\n- Here the palindrome could have odd or even length.\\n- For odd length, there must be a central element. For even the elements will be side by side.\\n- So we calculate both cases for all elements:\\n    - **For odd**: we took left & right as same elements(central) **`l = i, r = i`**\\n    - if elements in both indexes are the same we\\u2019ll increase `r` & decrease `l` by 1.\\n    - when we find both are not same, we\\u2019ll calculate the length **`length = r-l-1`**\\n    - if the length is greater than mx, then we\\u2019ll store start and end point of this length.\\n    - **For even**: same approach, just here we\\u2019ll take l & r next to each other. **`l = i, r = i+1`**\\n- Return substring from start to max length.\\n- **Time complexity:** O(n^2).\\n\\n---\\n\\n## Code:\\n\\n```cpp\\n//Solution 01:\\n****class Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n        int n = s.size();\\n        int start = 0, end = 0, mx = INT_MIN;\\n        \\n        if(n<=1) return s;\\n        \\n        for(int i=0; i<n-1; i++){\\n            int l = i, r = i;\\n            while(l >= 0 && r < n && s[l]==s[r]){\\n                l--; r++;\\n            }\\n            int length = r-l-1;\\n            if(length > mx){\\n                mx = length;\\n                start = l+1;\\n                end = r-1;\\n            }\\n        }\\n        \\n        for(int i=0; i<n-1; i++){\\n            int l = i, r = i+1;\\n            while(l >= 0 && r < n && s[l]==s[r]){\\n                l--; r++;\\n            }\\n            int length = r-l-1;\\n            if(length > mx){\\n                mx = length;\\n                start = l+1;\\n                end = r-1;\\n            }\\n        }\\n        \\n        return s.substr(start, mx);\\n    }\\n};\\n```\\n\\n---\\n\\n> **Please upvote this solution**\\n>",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\n//Solution 01:\\n****class Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n        int n = s.size();\\n        int start = 0, end = 0, mx = INT_MIN;\\n        \\n        if(n<=1) return s;\\n        \\n        for(int i=0; i<n-1; i++){\\n            int l = i, r = i;\\n            while(l >= 0 && r < n && s[l]==s[r]){\\n                l--; r++;\\n            }\\n            int length = r-l-1;\\n            if(length > mx){\\n                mx = length;\\n                start = l+1;\\n                end = r-1;\\n            }\\n        }\\n        \\n        for(int i=0; i<n-1; i++){\\n            int l = i, r = i+1;\\n            while(l >= 0 && r < n && s[l]==s[r]){\\n                l--; r++;\\n            }\\n            int length = r-l-1;\\n            if(length > mx){\\n                mx = length;\\n                start = l+1;\\n                end = r-1;\\n            }\\n        }\\n        \\n        return s.substr(start, mx);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1539190,
                "title": "java-tc-o-n-2-sc-o-1-two-optimized-solutions-with-early-exit-condition",
                "content": "**In this solution using a 1D array to track the resultant string\\'s start point and length**\\n\\n```java\\n/**\\n * Optimized Solution for continuous repeating characters.\\n * Expand Palindrome around center.\\n *\\n * Time Complexity: O(N^2)\\n *\\n * Space Complexity: O(1)\\n *\\n * N = Length of the input string s.\\n */\\nclass Solution {\\n    public String longestPalindrome(String s) {\\n        if (s == null) {\\n            throw new IllegalArgumentException(\"Input is null\");\\n        }\\n\\n        int len = s.length();\\n        if (len <= 1) {\\n            return s;\\n        }\\n\\n        int[] maxStartOffset = new int[] { 0, 1 };\\n        int i = 0;\\n\\t\\t\\n        while (i < len) {\\n            int start = i++;\\n\\t\\t\\t// Finding the continuous repeating characters\\n            // We can optimize by finding all such chars and treat them as the palindrome\\n            // center for the next expandPalindrome call.\\n            while (i < len && s.charAt(i) == s.charAt(start)) {\\n                i++;\\n            }\\n            // Expanding palindrome around the center defined by [start, i-1]\\n            expandPalindrome(s, start - 1, i, maxStartOffset);\\n\\n            // Early Exit Condition\\n            // Remaining Characters = len - i - 1\\n            // Longest palindrome possible using remaining chars = (len - i - 1) * 2\\n            // We can safely exit if current maxStartOffset[1] >= (len - i - 1) * 2\\n            if (maxStartOffset[1] >= (len - i - 1) * 2) {\\n                break;\\n            }\\n        }\\n\\n        return s.substring(maxStartOffset[0], maxStartOffset[0] + maxStartOffset[1]);\\n    }\\n\\n    private void expandPalindrome(String s, int left, int right, int[] maxStartOffset) {\\n        while (left >= 0 && right < s.length() && s.charAt(left) == s.charAt(right)) {\\n            left--;\\n            right++;\\n        }\\n        if (right - left - 1 > maxStartOffset[1]) {\\n            maxStartOffset[0] = left + 1;\\n            maxStartOffset[1] = right - left - 1;\\n        }\\n    }\\n}\\n```\\n\\n---\\n**In this solution helper returning the length of the palindrome. We are NOT using a 1D array to track the result string**\\n\\n```java\\n/**\\n * Optimized Solution for continuous repeating characters.\\n * Expand Palindrome around center.\\n * Helper function returns the length of the palindrome.\\n *\\n * Time Complexity: O(N^2)\\n *\\n * Space Complexity: O(1)\\n *\\n * N = Length of the input string s.\\n */\\nclass Solution {\\n    public String longestPalindrome(String s) {\\n        if (s == null) {\\n            throw new IllegalArgumentException(\"Input is null\");\\n        }\\n\\n        int len = s.length();\\n        if (len <= 1) {\\n            return s;\\n        }\\n\\n        int maxStart = 0;\\n        int maxLen = 0;\\n\\n        int i = 0;\\n        while (i < len) {\\n            int start = i++;\\n\\t\\t\\t// Finding the continuous repeating characters\\n            // We can optimize by finding all such chars and treat them as the palindrome\\n            // center for the next expandPalindrome call.\\n            while (i < len && s.charAt(i) == s.charAt(start)) {\\n                i++;\\n            }\\n            // Expanding palindrome around the center defined by [start, i-1]\\n            int newLen = expandPalindrome(s, start - 1, i);\\n\\t\\t\\t\\n            if (newLen > maxLen) {\\n                maxLen = newLen;\\n                // Center of the palindrome: (start + i - 1) / 2\\n                // Subtracting half of newLen from center to get the start index.\\n                maxStart = (start + i - 1) / 2 - (newLen - 1) / 2;\\n            }\\n\\n            // Early Exit Condition\\n            // Remaining Characters = len - i - 1\\n            // Longest palindrome possible using remaining chars = (len - i - 1) * 2\\n            // We can safely exit if current maxLen >= (len - i - 1) * 2\\n            if (maxLen >= (len - i - 1) * 2) {\\n                break;\\n            }\\n        }\\n\\n        return s.substring(maxStart, maxStart + maxLen);\\n    }\\n\\n    private int expandPalindrome(String s, int left, int right) {\\n        while (left >= 0 && right < s.length() && s.charAt(left) == s.charAt(right)) {\\n            left--;\\n            right++;\\n        }\\n        return right - left - 1;\\n    }\\n}\\n```\\n\\n---\\n\\nSolutions to other Palindrome questions on LeetCode:\\n- [9. Palindrome Number](https://leetcode.com/problems/palindrome-number/discuss/1527951/Java-or-TC:-O((log10-N)2)-or-SC:-O(1)-or-Optimal-Reverse-Half-and-Compare)\\n- [125. Valid Palindrome](https://leetcode.com/problems/valid-palindrome/discuss/1496675/Java-or-TC:-O(N)-or-SC:-O(1)-or-One-Pass-Solution-using-two-pointers)\\n- [266. Palindrome Permutation](https://leetcode.com/problems/palindrome-permutation/discuss/1527941/Java-or-TC:-O(N)-or-SC:-O(N)-or-Early-Exit-and-Space-Optimized-HashSet-solution)\\n- [267. Palindrome Permutation II](https://leetcode.com/problems/palindrome-permutation-ii/discuss/1527948/Java-or-TC:-O(N*(N2)!)-or-SC:-O(N)-or-Optimal-Backtracking-using-CountMap)\\n- [647. Palindromic Substrings](https://leetcode.com/problems/palindromic-substrings/discuss/1539193/Java-or-TC:-O(N2)-or-SC:-O(1)-or-Optimized-solution-for-continuous-repeating-chars)\\n",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```java\\n/**\\n * Optimized Solution for continuous repeating characters.\\n * Expand Palindrome around center.\\n *\\n * Time Complexity: O(N^2)\\n *\\n * Space Complexity: O(1)\\n *\\n * N = Length of the input string s.\\n */\\nclass Solution {\\n    public String longestPalindrome(String s) {\\n        if (s == null) {\\n            throw new IllegalArgumentException(\"Input is null\");\\n        }\\n\\n        int len = s.length();\\n        if (len <= 1) {\\n            return s;\\n        }\\n\\n        int[] maxStartOffset = new int[] { 0, 1 };\\n        int i = 0;\\n\\t\\t\\n        while (i < len) {\\n            int start = i++;\\n\\t\\t\\t// Finding the continuous repeating characters\\n            // We can optimize by finding all such chars and treat them as the palindrome\\n            // center for the next expandPalindrome call.\\n            while (i < len && s.charAt(i) == s.charAt(start)) {\\n                i++;\\n            }\\n            // Expanding palindrome around the center defined by [start, i-1]\\n            expandPalindrome(s, start - 1, i, maxStartOffset);\\n\\n            // Early Exit Condition\\n            // Remaining Characters = len - i - 1\\n            // Longest palindrome possible using remaining chars = (len - i - 1) * 2\\n            // We can safely exit if current maxStartOffset[1] >= (len - i - 1) * 2\\n            if (maxStartOffset[1] >= (len - i - 1) * 2) {\\n                break;\\n            }\\n        }\\n\\n        return s.substring(maxStartOffset[0], maxStartOffset[0] + maxStartOffset[1]);\\n    }\\n\\n    private void expandPalindrome(String s, int left, int right, int[] maxStartOffset) {\\n        while (left >= 0 && right < s.length() && s.charAt(left) == s.charAt(right)) {\\n            left--;\\n            right++;\\n        }\\n        if (right - left - 1 > maxStartOffset[1]) {\\n            maxStartOffset[0] = left + 1;\\n            maxStartOffset[1] = right - left - 1;\\n        }\\n    }\\n}\\n```\n```java\\n/**\\n * Optimized Solution for continuous repeating characters.\\n * Expand Palindrome around center.\\n * Helper function returns the length of the palindrome.\\n *\\n * Time Complexity: O(N^2)\\n *\\n * Space Complexity: O(1)\\n *\\n * N = Length of the input string s.\\n */\\nclass Solution {\\n    public String longestPalindrome(String s) {\\n        if (s == null) {\\n            throw new IllegalArgumentException(\"Input is null\");\\n        }\\n\\n        int len = s.length();\\n        if (len <= 1) {\\n            return s;\\n        }\\n\\n        int maxStart = 0;\\n        int maxLen = 0;\\n\\n        int i = 0;\\n        while (i < len) {\\n            int start = i++;\\n\\t\\t\\t// Finding the continuous repeating characters\\n            // We can optimize by finding all such chars and treat them as the palindrome\\n            // center for the next expandPalindrome call.\\n            while (i < len && s.charAt(i) == s.charAt(start)) {\\n                i++;\\n            }\\n            // Expanding palindrome around the center defined by [start, i-1]\\n            int newLen = expandPalindrome(s, start - 1, i);\\n\\t\\t\\t\\n            if (newLen > maxLen) {\\n                maxLen = newLen;\\n                // Center of the palindrome: (start + i - 1) / 2\\n                // Subtracting half of newLen from center to get the start index.\\n                maxStart = (start + i - 1) / 2 - (newLen - 1) / 2;\\n            }\\n\\n            // Early Exit Condition\\n            // Remaining Characters = len - i - 1\\n            // Longest palindrome possible using remaining chars = (len - i - 1) * 2\\n            // We can safely exit if current maxLen >= (len - i - 1) * 2\\n            if (maxLen >= (len - i - 1) * 2) {\\n                break;\\n            }\\n        }\\n\\n        return s.substring(maxStart, maxStart + maxLen);\\n    }\\n\\n    private int expandPalindrome(String s, int left, int right) {\\n        while (left >= 0 && right < s.length() && s.charAt(left) == s.charAt(right)) {\\n            left--;\\n            right++;\\n        }\\n        return right - left - 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1283151,
                "title": "c-easy-to-understand-o-nxn-time-complexity-fast-and-efficient-solution",
                "content": "***Please upvote to motivate me in my quest of documenting all leetcode solutions. HAPPY CODING:)\\nAny suggestions and improvements are always welcome***\\n\\n**Time complexity O(nxn)       Space complexity O(1)**\\n```\\nclass Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n        string str;\\n        int len=0;\\n        int start=0;\\n   for(int i=0;i<s.length();i++)\\n   {\\n       int len1=expandFromCenter(s,i,i);\\n       int len2=expandFromCenter(s,i,i+1);\\n       \\n       if(len<max(len1,len2))\\n       {\\n           len=max(len1,len2);\\n           start=i-(len-1)/2;\\n       }  \\n   }\\n     return s.substr(start,len);   \\n   }\\n    int expandFromCenter(string &s,int left,int right)\\n    {\\n        if(s.length()<1||left>right)\\n         return 0;\\n        while(left>=0&&right<s.length()&&s[left]==s[right])\\n        {\\n            left--;\\n            right++;\\n        } \\n        return right-left-1;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n        string str;\\n        int len=0;\\n        int start=0;\\n   for(int i=0;i<s.length();i++)\\n   {\\n       int len1=expandFromCenter(s,i,i);\\n       int len2=expandFromCenter(s,i,i+1);\\n       \\n       if(len<max(len1,len2))\\n       {\\n           len=max(len1,len2);\\n           start=i-(len-1)/2;\\n       }",
                "codeTag": "Java"
            },
            {
                "id": 1122735,
                "title": "lcs-improved-with-reversing-and-finding-palindrome-c-doc",
                "content": "**Introdution:** We will reverse and find the longest plaindrome. I am writing this solution to help anyone who is willing to find how this solution works.\\n\\n**Prerequisite:** Longest Common Subsequence Algorithm[DP]. Here is an easy to understand video of LCS:  https://www.youtube.com/watch?v=sSno9rV8Rhg\\n\\n**What about the reverse copy flaw?** OK so this is why you are here. Let\\'s take a lot of examples here.\\n\\n1. s = \"abacdfgdcaba\" and s\\' = \"abacdgfdcaba\". So in this our code will find an answer as \"abacd\" which is correct by LCS point of view but wrong from what we want to do. Lets see.\\n2. So in the reverse string, the starting \\'a\\' in the substring is at index 1(indexing is 1 oriented). Let\\'s find out what it\\'s index was in the original string which is s. OK it\\'s index was 12.\\n3. So in the reverse string, the ending \\'d\\' in the substring is at index 5. Let\\'s find out what it\\'s index was in the original string which is s. OK it\\'s idnex was 8.\\n4. So we see that we are comparing a string which is 8->12(in original of reverse) with a string which is 1->5(in original). If it were a valid substring, it should be on the same index.\\n5. Think this, can it be like \"abcghhcba\" and the substring be \"abc\". No because that is not at the same spot so how it\\'s reverse matters. We want to see the in-place reverse string. Get it? \"aba\" is \"aba\" cool but \"abc\" is not. It\\'s reverse exist which is somewhere but it cannot be a candidate for the plaindrome.\\n6. This situation arrises because of the reverse and LCS. LCS just cares about finding common anywhere. We want common at the same index for it to be a plaindrome.\\n\\n**Let\\'s take a genuine example and clear this**\\n\\n1. s=\"abb\" s\\'=\"bba\". I took it simple but it doesn\\'t matter. \\n2. So our code find \"bb\" as a substring.\\n3. So the start of the first \\'b\\' in the reverse string is 1. The index of it in the original string was 3\\n4. So the start of the second \\'b\\' in the reverse string is 2. The index of it in the original string was 2\\n5. So we are comparing a string of 2->3 with our original string also from 3->2 so this means that this is a genuine solution.\\n6. It\\'s just like \"abcbg\", (substring is \"bab\") then first b is at index 2 and last b is at index 4 then reverse would be \"gbcba\" the first b is at index 4 and the last at 2. They interchange position but index(start and end) don\\'t change.  If they change, there is somthing fishy.\\n\\n**Code:** \\n\\n```\\nclass Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n        int start = -1; //This is the start of the substring in s(the starting index from 0)\\n        int end = -1; //This is the end of the substring in s(the ending index from 0)\\n        int ans = 0; //This is the length of the longest palindrome\\n        /*\\n        If string is \"abcbr\" then start = 1 and end = 3 and longest palindrome is bcb\\n        */\\n        string srev = string(s.rbegin(),s.rend()); //We reverse the given string and store it\\n        /*\\n        1. Let\\'s create the LCS array. \\n        2. In this array, arr[index1][index2] tells us what is the length of the longest subarray\\n           till index1-1 in string s and index2-1 in string srev.\\n        3. The indexing in this dp array is done 1 based so in string \"abcs\", the index 0 element \\n           which is \\'a\\' is actually represented by 1 because we need 0 index to store the initial values\\n           which is 0 for all row and all columns of 0 index. This is explained in the video above by \\n           Abdul Bari Sir.\\n        */\\n        int arr[s.size()+1][s.size()+1];\\n        for(int i=0;i<=s.size();i++) {\\n            //So the outer loop which is i is representing the original string which is: s\\n            for(int j=0;j<=s.size();j++) {\\n                //The inner loop which is j is representing the original string which is: srev\\n                \\n                /*\\n                1. If the index is 0 which actually signifies the empty string or taking no value till now\\n                   in the string, we make it 0. Because no string means clearly no value.\\n                2. In this, if the current values in the 2 string are not equal we make the current item\\n                   to be 0 because we need substring and it has to be continuous.\\n                */\\n                if((i==0 || j==0) || (s[i-1]!=srev[j-1])) arr[i][j] = 0; \\n                \\n                else{  //If the values are equal that is s[i-1]==srev[j-1]\\n                    arr[i][j]=arr[i-1][j-1]+1; //Lets add one to the value till previous\\n                    /*\\n                    1. OK so here is where the original error correction starts.\\n                    2. What is there exists a copy and get matched?\\n                    3. Then we have to see just 1 thing, if the index of the reversed string matched the index of the unreverse string.\\n                    4. I have explained it above.\\n                    5. ob = original begin\\n                    6. oe = original end\\n                    7. revbo = reverse begin original\\n                    8. reveo = revree end original\\n                    */\\n                    int ob = i-arr[i][j]; \\n                    int oe = i-1;\\n                    int revbo = s.size()-(j-arr[i][j])-1;\\n                    int reveo = s.size()-(j-1)-1;\\n                    /*\\n                    1. So if the string is not a coincidence and is a genuine answer, that is, ob == reveo and oe == revbo, lets check\\n                       if this substring is the longest by comparing its size.\\n                    2. If its genuine and longer than what we have so far, let\\'s take it.\\n                    3. Mark the end and start so that we can construct this string at the end as we need string not the size.\\n                    */\\n                    if(ob == reveo && oe == revbo && arr[i][j] > ans){ \\n                        ans = arr[i][j];\\n                        start = i-arr[i][j];\\n                        end = i-1;\\n                    }\\n                }\\n            }\\n        }\\n        if(start == -1){ start=0; end=0; } //So if there was nothing then a single character is the longest substring\\n        /*\\n        1. Making a variable temp and finding all the value of the string from the index we stored.\\n        */\\n        string temp = \"\";\\n        for(int i=start;i<=end;i++) temp+=s[i];\\n        /*\\n        1. Return this string and we are done\\n        */\\n        return temp;\\n    }\\n};\\n```\\n\\n**PS:** \\n1. Some of the people may thing that let\\'s create an array of string and just add values and so but lemme tell you that it will give you TLE in cpp. Because simply you are doing a lot of string operations. For anyone interested I am giving the code of the string array as well, looks simple but string operations are heavy. \\n```\\nclass Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n        string ans = \"\";\\n        string srev = string(s.rbegin(),s.rend());\\n        string arr[s.size()+1][s.size()+1];\\n        for(int i=0;i<=s.size();i++) {\\n            for(int j=0;j<=s.size();j++) {\\n                if((i==0 || j==0) || (s[i-1]!=srev[j-1])) arr[i][j] = \"\";\\n                else{ \\n                    arr[i][j]=arr[i-1][j-1]+s[i-1];\\n                    int ob = i-arr[i][j].size();\\n                    int oe = i-1;\\n                    int revbo = s.size()-(j-arr[i][j].size())-1;\\n                    int reveo = s.size()-(j-1)-1;\\n                    if(ob == reveo && oe == revbo && arr[i][j].size() > ans.size()) ans = arr[i][j]; \\n                }\\n            }\\n        }\\n        if(ans == \"\" && s != \"\") ans=s[0];\\n        return ans;\\n    }\\n};\\n```\\n2. I know there can be optimisations but I tried to make it verbose instead of short and professional. \\n3. Thank you if you make it till here. I really appreciate it.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n        int start = -1; //This is the start of the substring in s(the starting index from 0)\\n        int end = -1; //This is the end of the substring in s(the ending index from 0)\\n        int ans = 0; //This is the length of the longest palindrome\\n        /*\\n        If string is \"abcbr\" then start = 1 and end = 3 and longest palindrome is bcb\\n        */\\n        string srev = string(s.rbegin(),s.rend()); //We reverse the given string and store it\\n        /*\\n        1. Let\\'s create the LCS array. \\n        2. In this array, arr[index1][index2] tells us what is the length of the longest subarray\\n           till index1-1 in string s and index2-1 in string srev.\\n        3. The indexing in this dp array is done 1 based so in string \"abcs\", the index 0 element \\n           which is \\'a\\' is actually represented by 1 because we need 0 index to store the initial values\\n           which is 0 for all row and all columns of 0 index. This is explained in the video above by \\n           Abdul Bari Sir.\\n        */\\n        int arr[s.size()+1][s.size()+1];\\n        for(int i=0;i<=s.size();i++) {\\n            //So the outer loop which is i is representing the original string which is: s\\n            for(int j=0;j<=s.size();j++) {\\n                //The inner loop which is j is representing the original string which is: srev\\n                \\n                /*\\n                1. If the index is 0 which actually signifies the empty string or taking no value till now\\n                   in the string, we make it 0. Because no string means clearly no value.\\n                2. In this, if the current values in the 2 string are not equal we make the current item\\n                   to be 0 because we need substring and it has to be continuous.\\n                */\\n                if((i==0 || j==0) || (s[i-1]!=srev[j-1])) arr[i][j] = 0; \\n                \\n                else{  //If the values are equal that is s[i-1]==srev[j-1]\\n                    arr[i][j]=arr[i-1][j-1]+1; //Lets add one to the value till previous\\n                    /*\\n                    1. OK so here is where the original error correction starts.\\n                    2. What is there exists a copy and get matched?\\n                    3. Then we have to see just 1 thing, if the index of the reversed string matched the index of the unreverse string.\\n                    4. I have explained it above.\\n                    5. ob = original begin\\n                    6. oe = original end\\n                    7. revbo = reverse begin original\\n                    8. reveo = revree end original\\n                    */\\n                    int ob = i-arr[i][j]; \\n                    int oe = i-1;\\n                    int revbo = s.size()-(j-arr[i][j])-1;\\n                    int reveo = s.size()-(j-1)-1;\\n                    /*\\n                    1. So if the string is not a coincidence and is a genuine answer, that is, ob == reveo and oe == revbo, lets check\\n                       if this substring is the longest by comparing its size.\\n                    2. If its genuine and longer than what we have so far, let\\'s take it.\\n                    3. Mark the end and start so that we can construct this string at the end as we need string not the size.\\n                    */\\n                    if(ob == reveo && oe == revbo && arr[i][j] > ans){ \\n                        ans = arr[i][j];\\n                        start = i-arr[i][j];\\n                        end = i-1;\\n                    }\\n                }\\n            }\\n        }\\n        if(start == -1){ start=0; end=0; } //So if there was nothing then a single character is the longest substring\\n        /*\\n        1. Making a variable temp and finding all the value of the string from the index we stored.\\n        */\\n        string temp = \"\";\\n        for(int i=start;i<=end;i++) temp+=s[i];\\n        /*\\n        1. Return this string and we are done\\n        */\\n        return temp;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n        string ans = \"\";\\n        string srev = string(s.rbegin(),s.rend());\\n        string arr[s.size()+1][s.size()+1];\\n        for(int i=0;i<=s.size();i++) {\\n            for(int j=0;j<=s.size();j++) {\\n                if((i==0 || j==0) || (s[i-1]!=srev[j-1])) arr[i][j] = \"\";\\n                else{ \\n                    arr[i][j]=arr[i-1][j-1]+s[i-1];\\n                    int ob = i-arr[i][j].size();\\n                    int oe = i-1;\\n                    int revbo = s.size()-(j-arr[i][j].size())-1;\\n                    int reveo = s.size()-(j-1)-1;\\n                    if(ob == reveo && oe == revbo && arr[i][j].size() > ans.size()) ans = arr[i][j]; \\n                }\\n            }\\n        }\\n        if(ans == \"\" && s != \"\") ans=s[0];\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 678400,
                "title": "ac-python-dp-o-n-space-manacher",
                "content": "Dynamic Programming, O(n) Space\\n```\\ndef longestPalindrome(self, s: str) -> str:\\n\\tif not s: return s\\n\\tn, l, r = len(s), 0, 0\\n\\tdp = [[True]*n, [False]*n]    # dp[0]: old letters palindromes, dp[1]: even letters palindromes\\n\\tfor i in range(n-1):\\n\\t\\tif s[i] == s[i+1]:\\n\\t\\t\\tdp[1][i] = True\\n\\t\\t\\tl, r = i, i+1                        \\n\\tfor m in range(2, n):         # m letters palindromes\\n\\t\\tfor i in range(n-m):\\n\\t\\t\\tj = i+m\\n\\t\\t\\tx, k = m%2, i+m//2\\n\\t\\t\\tdp[x][k] = dp[x][k] and s[i] == s[j]\\n\\t\\t\\tif dp[x][k] and j-i > r-l:\\n\\t\\t\\t\\tl, r = i, j\\n\\treturn s[l:r+1]\\n```\\nDynamic Programming, O(n^2) Space\\n```\\ndef longestPalindrome(self, s: str) -> str:\\n\\tif not s: return s\\n\\tn, l, r = len(s), 0, 0\\n\\tdp = [[False]*n for _ in range(n)]\\n\\tdp[-1][-1] = True\\n\\tfor i in range(n-1):\\n\\t\\tdp[i][i] = True\\n\\t\\tif s[i] == s[i+1]:\\n\\t\\t\\tdp[i][i+1] = True\\n\\t\\t\\tl, r = i, i+1                        \\n\\tfor m in range(2, n):\\n\\t\\tfor i in range(n-m):\\n\\t\\t\\tj = i+m\\n\\t\\t\\tdp[i][j] = dp[i+1][j-1] and s[i] == s[j]\\n\\t\\t\\tif dp[i][j] and j-i > r-l:\\n\\t\\t\\t\\tl, r = i, j\\n\\treturn s[l:r+1]\\n```\\nCenter Expansion, O(1) Space\\n```\\ndef longestPalindrome(self, s: str) -> str:\\n\\tdef check(l, r):\\n\\t\\twhile 0 <= l and r < n and s[l] == s[r]: \\n\\t\\t\\tl -= 1\\n\\t\\t\\tr += 1\\n\\t\\treturn l, r\\n\\n\\tn, L, R = len(s), 0, 0\\n\\tfor i in range(2*n-1):\\n\\t\\tif i%2: l, r = check((i-1)//2, (i+1)//2)\\n\\t\\telse: l, r = check(i//2, i//2)\\n\\t\\tif r-l > R-L: L, R = l, r                \\n\\treturn s[L+1:R]\\n```\\nCenter Expansion, most efficient one except Manacher by my own test\\n```\\ndef longestPalindrome(self, s: str) -> str:\\n\\tt = \\'^#\\'+\\'#\\'.join(s)+\\'#$\\'\\n\\tc = r = 0                             # center and radius\\n\\tfor i in range(1,len(t)-1):\\n\\t\\tj = 1 if t[i] == \\'#\\' else 2       # skip \\'#\\' and check letters only\\n\\t\\twhile  t[i-j] == t[i+j]: j += 2\\n\\t\\tif j > r: c, r = i, j\\n\\treturn s[(c-r+1)//2:(c+r-1)//2]\\n```\\n Manacher\\'s algorithm\\n```\\ndef longestPalindrome(self, s: str) -> str:               \\n\\tt = \\'^#\\'+\\'#\\'.join(s)+\\'#$\\'\\n\\tn = len(t)\\n\\tp = [0]*n\\n\\tc = r = cm = rm = 0\\n\\tfor i in range (1, n-1):\\n\\t\\tp[i] = min(r-i, p[2*c-i]) if r > i else 0\\n\\t\\twhile t[i-p[i]-1] == t[i+p[i]+1]: p[i] += 1\\n\\t\\tif p[i]+i > r: c, r = i, p[i]+i\\n\\t\\tif p[i] > rm: cm, rm = i, p[i]\\n\\treturn s[(cm-rm)//2:(cm+rm)//2]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\ndef longestPalindrome(self, s: str) -> str:\\n\\tif not s: return s\\n\\tn, l, r = len(s), 0, 0\\n\\tdp = [[True]*n, [False]*n]    # dp[0]: old letters palindromes, dp[1]: even letters palindromes\\n\\tfor i in range(n-1):\\n\\t\\tif s[i] == s[i+1]:\\n\\t\\t\\tdp[1][i] = True\\n\\t\\t\\tl, r = i, i+1                        \\n\\tfor m in range(2, n):         # m letters palindromes\\n\\t\\tfor i in range(n-m):\\n\\t\\t\\tj = i+m\\n\\t\\t\\tx, k = m%2, i+m//2\\n\\t\\t\\tdp[x][k] = dp[x][k] and s[i] == s[j]\\n\\t\\t\\tif dp[x][k] and j-i > r-l:\\n\\t\\t\\t\\tl, r = i, j\\n\\treturn s[l:r+1]\\n```\n```\\ndef longestPalindrome(self, s: str) -> str:\\n\\tif not s: return s\\n\\tn, l, r = len(s), 0, 0\\n\\tdp = [[False]*n for _ in range(n)]\\n\\tdp[-1][-1] = True\\n\\tfor i in range(n-1):\\n\\t\\tdp[i][i] = True\\n\\t\\tif s[i] == s[i+1]:\\n\\t\\t\\tdp[i][i+1] = True\\n\\t\\t\\tl, r = i, i+1                        \\n\\tfor m in range(2, n):\\n\\t\\tfor i in range(n-m):\\n\\t\\t\\tj = i+m\\n\\t\\t\\tdp[i][j] = dp[i+1][j-1] and s[i] == s[j]\\n\\t\\t\\tif dp[i][j] and j-i > r-l:\\n\\t\\t\\t\\tl, r = i, j\\n\\treturn s[l:r+1]\\n```\n```\\ndef longestPalindrome(self, s: str) -> str:\\n\\tdef check(l, r):\\n\\t\\twhile 0 <= l and r < n and s[l] == s[r]: \\n\\t\\t\\tl -= 1\\n\\t\\t\\tr += 1\\n\\t\\treturn l, r\\n\\n\\tn, L, R = len(s), 0, 0\\n\\tfor i in range(2*n-1):\\n\\t\\tif i%2: l, r = check((i-1)//2, (i+1)//2)\\n\\t\\telse: l, r = check(i//2, i//2)\\n\\t\\tif r-l > R-L: L, R = l, r                \\n\\treturn s[L+1:R]\\n```\n```\\ndef longestPalindrome(self, s: str) -> str:\\n\\tt = \\'^#\\'+\\'#\\'.join(s)+\\'#$\\'\\n\\tc = r = 0                             # center and radius\\n\\tfor i in range(1,len(t)-1):\\n\\t\\tj = 1 if t[i] == \\'#\\' else 2       # skip \\'#\\' and check letters only\\n\\t\\twhile  t[i-j] == t[i+j]: j += 2\\n\\t\\tif j > r: c, r = i, j\\n\\treturn s[(c-r+1)//2:(c+r-1)//2]\\n```\n```\\ndef longestPalindrome(self, s: str) -> str:               \\n\\tt = \\'^#\\'+\\'#\\'.join(s)+\\'#$\\'\\n\\tn = len(t)\\n\\tp = [0]*n\\n\\tc = r = cm = rm = 0\\n\\tfor i in range (1, n-1):\\n\\t\\tp[i] = min(r-i, p[2*c-i]) if r > i else 0\\n\\t\\twhile t[i-p[i]-1] == t[i+p[i]+1]: p[i] += 1\\n\\t\\tif p[i]+i > r: c, r = i, p[i]+i\\n\\t\\tif p[i] > rm: cm, rm = i, p[i]\\n\\treturn s[(cm-rm)//2:(cm+rm)//2]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 410963,
                "title": "python-beats-93-solution-with-illustrations",
                "content": "l = left bound\\nr = right bound\\n```\\n    def longestPalindrome(self, s: str) -> str:\\n        if len(s) < 2:\\n            return s\\n        start = 0\\n        maxLen = 1\\n        i = 0\\n\\n        while i < len(s):\\n            l = i\\n            r = i\\n            while r < len(s) - 1 and s[r] == s[r+1]:\\n                r += 1\\n            i = r + 1\\n            while r < len(s)-1 and l > 0 and s[r+1] == s[l-1]:\\n                l -= 1\\n                r += 1\\n            if maxLen < r - l + 1:\\n                start = l\\n                maxLen = r - l + 1\\n        return s[start: start + maxLen]\\n```\\n\\nIllustration of the idea:\\n```\\nFirst cycle:\\n// 0 1 2 3 4 5\\n// c b a a b c\\n// i\\u2192i             i = r + 1 = 0 + 1\\n// l               l-1 < 0, nothing to compare so we go to the next cycle\\n// r               r+1\\n\\nSecond cycle:\\n// 0 1 2 3 4 5\\n// c b a a b c\\n//   i\\u2192i             i = r + 1 = 1 + 1 = 2\\n// l                 l-1 = 0\\n//     r             r+1 = 2\\n// \\n// Comparing:\\n// c _ a             c!=a, nothing happend. Going next\\n\\nThird cycle (interesting part):\\n// 0 1 2 3 4 5\\n// c b a a b c\\n//     i\\u2192i\\u2192i         i = r + 1 = 3 + 1 = 4\\n//   l               l-1 = 1\\n//     r\\u2192r\\u2192r         because of s[r] == s[r+1], eg a == a, we increment r+=1. Final r = (r + 1) + 1 = 2 + 1 + 1 = 4\\n//\\n// Comparing:\\n// b _ b             b == b, then: l -= 1, r += 1\\n//\\n// c b a a b c\\n// l\\u2190                l -= 1\\n//          \\u2192r       r += 1\\n// Comparing:\\n// c _ c             c == c\\n\\nResult: cbaabc\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n    def longestPalindrome(self, s: str) -> str:\\n        if len(s) < 2:\\n            return s\\n        start = 0\\n        maxLen = 1\\n        i = 0\\n\\n        while i < len(s):\\n            l = i\\n            r = i\\n            while r < len(s) - 1 and s[r] == s[r+1]:\\n                r += 1\\n            i = r + 1\\n            while r < len(s)-1 and l > 0 and s[r+1] == s[l-1]:\\n                l -= 1\\n                r += 1\\n            if maxLen < r - l + 1:\\n                start = l\\n                maxLen = r - l + 1\\n        return s[start: start + maxLen]\\n```\n```\\nFirst cycle:\\n// 0 1 2 3 4 5\\n// c b a a b c\\n// i\\u2192i             i = r + 1 = 0 + 1\\n// l               l-1 < 0, nothing to compare so we go to the next cycle\\n// r               r+1\\n\\nSecond cycle:\\n// 0 1 2 3 4 5\\n// c b a a b c\\n//   i\\u2192i             i = r + 1 = 1 + 1 = 2\\n// l                 l-1 = 0\\n//     r             r+1 = 2\\n// \\n// Comparing:\\n// c _ a             c!=a, nothing happend. Going next\\n\\nThird cycle (interesting part):\\n// 0 1 2 3 4 5\\n// c b a a b c\\n//     i\\u2192i\\u2192i         i = r + 1 = 3 + 1 = 4\\n//   l               l-1 = 1\\n//     r\\u2192r\\u2192r         because of s[r] == s[r+1], eg a == a, we increment r+=1. Final r = (r + 1) + 1 = 2 + 1 + 1 = 4\\n//\\n// Comparing:\\n// b _ b             b == b, then: l -= 1, r += 1\\n//\\n// c b a a b c\\n// l\\u2190                l -= 1\\n//          \\u2192r       r += 1\\n// Comparing:\\n// c _ c             c == c\\n\\nResult: cbaabc\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 110368,
                "title": "accepted-c-easy-to-understand-solution-with-explanation",
                "content": "```\\n    public class Solution \\n    {\\n        private int startIndex;\\n        private int length;\\n\\n        public string LongestPalindrome(string s)\\n        {            \\n            for (int i = 0; i < s.Length; i++)\\n            {                \\n                //For odd length.\\n                this.ExtendPallindrome(s, i, i);\\n\\n                //For even length.\\n                this.ExtendPallindrome(s, i, i + 1);\\n            }\\n\\n            return s.Substring(this.startIndex, this.length);\\n        }\\n\\n        private void ExtendPallindrome(string s, int start, int end)\\n        {\\n            while (start >= 0 && end < s.Length && s[start] == s[end])\\n            {\\n                start--;\\n                end++;\\n            }\\n\\n            //When calculating newLength;\\n            //we will have to compensate for one reduction in start and one increment in end;\\n            //because of the while loop above.           \\n            // ~ end - start -1\\n            int newLength = ((end - 1) - (start + 1)) + 1;\\n\\n            if (this.length < newLength)\\n            {\\n                //When calculating startIndex; we will have to compensate for the reduction in start.\\n                this.startIndex = start + 1;\\n                this.length = newLength;\\n            }            \\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public class Solution \\n    {\\n        private int startIndex;\\n        private int length;\\n\\n        public string LongestPalindrome(string s)\\n        {            \\n            for (int i = 0; i < s.Length; i++)\\n            {                \\n                //For odd length.\\n                this.ExtendPallindrome(s, i, i);\\n\\n                //For even length.\\n                this.ExtendPallindrome(s, i, i + 1);\\n            }\\n\\n            return s.Substring(this.startIndex, this.length);\\n        }\\n\\n        private void ExtendPallindrome(string s, int start, int end)\\n        {\\n            while (start >= 0 && end < s.Length && s[start] == s[end])\\n            {\\n                start--;\\n                end++;\\n            }\\n\\n            //When calculating newLength;\\n            //we will have to compensate for one reduction in start and one increment in end;\\n            //because of the while loop above.           \\n            // ~ end - start -1\\n            int newLength = ((end - 1) - (start + 1)) + 1;\\n\\n            if (this.length < newLength)\\n            {\\n                //When calculating startIndex; we will have to compensate for the reduction in start.\\n                this.startIndex = start + 1;\\n                this.length = newLength;\\n            }            \\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2715886,
                "title": "java-very-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public String longestPalindrome(String s) {\\n        int start=0;\\n        int end=0;\\n        int low,high;\\n        int n=s.length();\\n        for(int i=0;i<n;i++)\\n        {\\n            // even length\\n            low=i;\\n            high=i+1;\\n            \\n            while(low>=0 && high<n && s.charAt(low)==s.charAt(high))\\n            {\\n                if((end-start)<(high-low))\\n                {\\n                    start=low;\\n                    end=high;\\n                }\\n                low--;\\n                high++;\\n            }\\n            \\n            // Odd length\\n            \\n            low=i;\\n            high=i+2;\\n            while(low>=0 && high<n && s.charAt(low)==s.charAt(high))\\n            {\\n                if((end-start)<(high-low))\\n                {\\n                    start=low;\\n                    end=high;\\n                }\\n                low--;\\n                high++;\\n            }\\n        }\\n        return s.substring(start,end+1);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String longestPalindrome(String s) {\\n        int start=0;\\n        int end=0;\\n        int low,high;\\n        int n=s.length();\\n        for(int i=0;i<n;i++)\\n        {\\n            // even length\\n            low=i;\\n            high=i+1;\\n            \\n            while(low>=0 && high<n && s.charAt(low)==s.charAt(high))\\n            {\\n                if((end-start)<(high-low))\\n                {\\n                    start=low;\\n                    end=high;\\n                }\\n                low--;\\n                high++;\\n            }\\n            \\n            // Odd length\\n            \\n            low=i;\\n            high=i+2;\\n            while(low>=0 && high<n && s.charAt(low)==s.charAt(high))\\n            {\\n                if((end-start)<(high-low))\\n                {\\n                    start=low;\\n                    end=high;\\n                }\\n                low--;\\n                high++;\\n            }\\n        }\\n        return s.substring(start,end+1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 653617,
                "title": "using-recursion-and-memoization-top-down-approach",
                "content": "```\\nclass Solution {\\n    \\n    int max = Integer.MIN_VALUE;\\n    String ans = \"\";\\n    \\n    boolean recur(String s, int i, int j, int[][] dp){\\n        \\n        if(i>j) {   \\n            return true;\\n        }\\n        if(i==j) {\\n            dp[i][j] = 1;\\n            if(j-i+1 > max){\\n                max = j-i+1;\\n                ans = s.substring(i, j+1);\\n            }\\n            \\n            return true;\\n        }\\n        \\n        if(dp[i][j] != -1) return dp[i][j]==0?false:true;\\n        \\n        \\n        \\n        if(s.charAt(i)==s.charAt(j) && recur(s, i+1, j-1, dp)){\\n            \\n            dp[i][j] = 1;\\n            if(j-i+1 > max){\\n                max = j-i+1;\\n                ans = s.substring(i, j+1);\\n            }\\n            \\n        }\\n        else{\\n            dp[i][j] = 0;\\n            recur(s, i+1, j, dp);\\n            recur(s, i, j-1, dp);\\n\\n        }\\n        \\n        return dp[i][j]==0?false:true;\\n        \\n        \\n    }\\n    \\n    \\n    \\n    public String longestPalindrome(String s) {\\n        \\n        \\n        int n = s.length();\\n        \\n        int[][] dp = new int[n+1][n+1];\\n        \\n        for(int i=0;i<=n;i++){\\n            Arrays.fill(dp[i], -1);\\n        }\\n        recur(s, 0, n-1, dp);\\n        \\n        return ans;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    int max = Integer.MIN_VALUE;\\n    String ans = \"\";\\n    \\n    boolean recur(String s, int i, int j, int[][] dp){\\n        \\n        if(i>j) {   \\n            return true;\\n        }\\n        if(i==j) {\\n            dp[i][j] = 1;\\n            if(j-i+1 > max){\\n                max = j-i+1;\\n                ans = s.substring(i, j+1);\\n            }\\n            \\n            return true;\\n        }\\n        \\n        if(dp[i][j] != -1) return dp[i][j]==0?false:true;\\n        \\n        \\n        \\n        if(s.charAt(i)==s.charAt(j) && recur(s, i+1, j-1, dp)){\\n            \\n            dp[i][j] = 1;\\n            if(j-i+1 > max){\\n                max = j-i+1;\\n                ans = s.substring(i, j+1);\\n            }\\n            \\n        }\\n        else{\\n            dp[i][j] = 0;\\n            recur(s, i+1, j, dp);\\n            recur(s, i, j-1, dp);\\n\\n        }\\n        \\n        return dp[i][j]==0?false:true;\\n        \\n        \\n    }\\n    \\n    \\n    \\n    public String longestPalindrome(String s) {\\n        \\n        \\n        int n = s.length();\\n        \\n        int[][] dp = new int[n+1][n+1];\\n        \\n        for(int i=0;i<=n;i++){\\n            Arrays.fill(dp[i], -1);\\n        }\\n        recur(s, 0, n-1, dp);\\n        \\n        return ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 110375,
                "title": "java-dp-solution-with-optimization-in-space-from-o-n-2-to-o-n-time-o-n-2-with-very-clear-explanations",
                "content": "**The original DP solution: time O(n^2), space O(n^2)**\\nsome comments:\\n* The outer for-loop's index i goes from n-1 to 0, and the inner for-loop's index j goes from i to n-1, the making i occurs before j, thus we use `dp[i][j]` to represent if the substring `s(i,j)` is a palindrome.\\n* to check if substring `s(i,j)` is a palindrome, we first make sure the two characters at `s(i)` and `s(j)` equal, then there are two cases to consider:\\n    * if `j - i < 3`, which means that the substring's length is less than 3 (e.g. \"aba\", \"ab\", \"a\"), then `s(i,j)` is a palindrome.\\n    * if the \"inner\" substring `s(i+1, j-1)`, without the two characters at `s(i)` and `s(j)` is a palindrome, or `dp[i+1][j-1]`, then `s(i,j)` is a palindrome.\\n    * when j = 0, j - i is always less than 3, so we never have an index out of bound exception for `dp[i+1][j-1]`\\n* Then we check if `dp[i][j]` is true, or if `s(i,j)` is a palindrome, and compare its length with the length of the temporary result, and update the result with the longer one.\\n```\\npublic String longestPalindrome(String s) {\\n        int n = s.length();\\n        String result = \"\";\\n        boolean[][] dp = new boolean[n][n];\\n        \\n        // i goes from n - 1 to 0, j goes from i to n - 1, to make sure i occurs before j\\n        for (int i = n - 1; i >= 0; i--) {\\n            for (int j = i; j < n; j++) {\\n                dp[i][j] = s.charAt(i) == s.charAt(j) && (j - i < 3 || dp[i+1][j-1]);\\n                // if dp[i][j] is true\\uff0cupdate result\\n                if(dp[i][j] && (result.equals(\"\") || j - i + 1 > result.length())) {\\n                    result = s.substring(i, j+1); // j+1 not j, since substring includes j\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n```\\nMy thoughs on optimization of space complexity:\\n\\nWe only use `dp[i+1][j-1]` to update `dp[i][j]`. We could try reducing the 2D array to 1D array.\\nSince the outer for loop is `for (int i = n - 1; i >= 0; i--)` (the index i has a decreasing order), we could notice that we only need to maintain a 1D array for index j, or using `dp[j-1]` to update dp[j]. To do so, we need the inner for loop's index j to also go backward from n-1 to i. In this way, **when we use `dp[j-1]` to update `dp[j]`, `dp[j-1]` is actually the same as 2D array's `dp[i+1][j-1]`, where i+1 is from the last for loop. The reason for index j's decreasing order is to make sure we do not modify the value of `dp[j-1]` before we use `dp[j-1]` to update `dp[j]`.**\\n\\n**The optimized DP solution: time O(n^2), space O(n)**\\n```java\\npublic static String longestPalindrome(String s) {\\n        int n = s.length();\\n        String result = \"\";\\n        boolean[] dp = new boolean[n];\\n\\n        for (int i = n - 1; i >= 0; i--) {\\n            for (int j = n - 1; j >= i; j--) { // decreasing order\\n                // dp[j-1] is the same as dp[i+1][i-1]\\n               // since both dp[j-1] and dp[i+1][j-1] are from the last iteration of the outer loop\\n                dp[j] = s.charAt(i) == s.charAt(j) && (j - i < 3 || dp[j-1]);\\n                if(dp[j] && (result.equals(\"\") || j - i + 1 > result.length())) {\\n                    result = s.substring(i, j+1);\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic String longestPalindrome(String s) {\\n        int n = s.length();\\n        String result = \"\";\\n        boolean[][] dp = new boolean[n][n];\\n        \\n        // i goes from n - 1 to 0, j goes from i to n - 1, to make sure i occurs before j\\n        for (int i = n - 1; i >= 0; i--) {\\n            for (int j = i; j < n; j++) {\\n                dp[i][j] = s.charAt(i) == s.charAt(j) && (j - i < 3 || dp[i+1][j-1]);\\n                // if dp[i][j] is true\\uff0cupdate result\\n                if(dp[i][j] && (result.equals(\"\") || j - i + 1 > result.length())) {\\n                    result = s.substring(i, j+1); // j+1 not j, since substring includes j\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n```\n```java\\npublic static String longestPalindrome(String s) {\\n        int n = s.length();\\n        String result = \"\";\\n        boolean[] dp = new boolean[n];\\n\\n        for (int i = n - 1; i >= 0; i--) {\\n            for (int j = n - 1; j >= i; j--) { // decreasing order\\n                // dp[j-1] is the same as dp[i+1][i-1]\\n               // since both dp[j-1] and dp[i+1][j-1] are from the last iteration of the outer loop\\n                dp[j] = s.charAt(i) == s.charAt(j) && (j - i < 3 || dp[j-1]);\\n                if(dp[j] && (result.equals(\"\") || j - i + 1 > result.length())) {\\n                    result = s.substring(i, j+1);\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4001583,
                "title": "simple-and-best-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n# Expand around Center Approach\\nUse each character of input as middle, and expand both side to find the palindrome.\\nKeep track of length and starting index of longest palindrome found.\\n\\n# Upvote if it helped \\uD83D\\uDE0A\\n\\n# Approach\\n\\n1. Initialize two variables: `start` to keep track of the starting index of the longest palindrome found so far, and `max` to keep track of its length. Initially, both are set to 0.\\n\\n2. Check the length of the input string `s`. If it has a length less than 2, return it immediately as it\\'s already a palindrome (or an empty string).\\n\\n3. Convert the input string `s` into a character array `chars` to make it easier to manipulate.\\n\\n4. Iterate through each character in the string using a for loop. For each character at index `i`, do the following:\\n\\n   - **Find odd-length palindromes**: Call the `findPalindrome` function with the current character as both the left and right center (i.e., `findPalindrome(chars, i, i)`). This function will expand outwards from this center to find the longest palindrome centered at this character.\\n\\n   - **Find even-length palindromes**: Call the `findPalindrome` function with the current character and the next character as the left and right centers (i.e., `findPalindrome(chars, i, i+1)`). This covers the case of even-length palindromes.\\n\\n5. The `findPalindrome` function takes a character array `chars` and two indices `j` and `k` as input. It uses these indices to expand outwards from the center and checks if the characters at `j` and `k` are equal. If they are equal, it means a longer palindrome is found, so it expands further by incrementing `k` and decrementing `j`. This process continues until the characters at `j` and `k` are no longer equal or until `j` becomes negative or `k` goes beyond the length of the string.\\n\\n6. Inside the `findPalindrome` function, if a palindrome longer than the previously recorded maximum is found, it updates the `max` variable with the new length and the `start` variable with the new starting index of the longest palindrome.\\n\\n7. After iterating through the entire string and calling `findPalindrome` for all possible centers, the `start` and `max` variables will hold the starting index and length of the longest palindromic substring in the input string.\\n\\n8. Finally, use the `start` and `max` values to extract the longest palindromic substring from the original input string `s` and return it.\\n# Example\\n\\n**Example Input String**: \"babad\"\\n\\n1. character array: `chars = [\\'b\\', \\'a\\', \\'b\\', \\'a\\', \\'d\\']`.\\n\\n2. Iterate through the characters in the string:\\n\\n   - **Iteration 1 (i = 0, char = \\'b\\')**:\\n\\n     - Find odd-length palindrome by calling `findPalindrome(chars, 0, 0)`. The center is \\'b\\'.\\n\\n       - Expand outwards: \\'b\\' == \\'b\\'.\\n\\n       - Continue expanding: \\'a\\' != \\'d\\'. Stop.\\n\\n     - Find even-length palindrome by calling `findPalindrome(chars, 0, 1)`. The centers are \\'b\\' and \\'a\\'.\\n\\n       - Expand outwards: \\'b\\' != \\'a\\'. Stop.\\n\\n   - **Iteration 2 (i = 1, char = \\'a\\')**:\\n\\n     - Find odd-length palindrome by calling `findPalindrome(chars, 1, 1)`. The center is \\'a\\'.\\n\\n       - Expand outwards: \\'a\\' == \\'a\\'.\\n\\n       - Continue expanding: \\'b\\' != \\'d\\'. Stop.\\n\\n     - Find even-length palindrome by calling `findPalindrome(chars, 1, 2)`. The centers are \\'a\\' and \\'b\\'.\\n\\n       - Expand outwards: \\'a\\' != \\'b\\'. Stop.\\n\\n   - **Iteration 3 (i = 2, char = \\'b\\')**:\\n\\n     - Find odd-length palindrome by calling `findPalindrome(chars, 2, 2)`. The center is \\'b\\'.\\n\\n       - Expand outwards: \\'b\\' == \\'b\\'.\\n\\n       - Continue expanding: \\'a\\' == \\'a\\'.\\n\\n       - Continue expanding: \\'b\\' != \\'d\\'. Stop.\\n\\n     - Find even-length palindrome by calling `findPalindrome(chars, 2, 3)`. The centers are \\'b\\' and \\'a\\'.\\n\\n       - Expand outwards: \\'b\\' != \\'a\\'. Stop.\\n\\n   - **Iteration 4 (i = 3, char = \\'a\\')**:\\n\\n     - Find odd-length palindrome by calling `findPalindrome(chars, 3, 3)`. The center is \\'a\\'.\\n\\n       - Expand outwards: \\'a\\' == \\'a\\'.\\n\\n       - Continue expanding: \\'b\\' != \\'d\\'. Stop.\\n\\n     - Find even-length palindrome by calling `findPalindrome(chars, 3, 4)`. The centers are \\'a\\' and \\'d\\'.\\n\\n       - Expand outwards: \\'a\\' != \\'d\\'. Stop.\\n\\n   - **Iteration 5 (i = 4, char = \\'d\\')**:\\n\\n     - Find odd-length palindrome by calling `findPalindrome(chars, 4, 4)`. The center is \\'d\\'.\\n\\n       - Expand outwards: \\'d\\' == \\'d\\'.\\n\\n       - No more characters to expand. Stop.\\n\\n     - Find even-length palindrome by calling `findPalindrome(chars, 4, 5)`. The centers are \\'d\\' and out of bounds.\\n\\n       - Out of bounds, so stop.\\n\\n3. After completing the iterations, the `max` variable holds the length of the longest palindrome found (3), and the `start` variable holds the starting index of that palindrome (1).\\n\\n4. Return the substring of the input string using `start` and `max`, which is \"bab\". This is the longest palindromic substring.\\n\\nSo, in this example, the algorithm correctly identifies \"bab\" as the longest palindromic substring, which is both odd and even in length. The algorithm efficiently explores all possible centers to find palindromes and keeps track of the longest one encountered.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n*n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution {\\n    int start = 0; // Initialize the start index for the longest palindrome.\\n    int max = 0;   // Initialize the length of the longest palindrome.\\n\\n    public String longestPalindrome(String s) {\\n        if(s.length() < 2)\\n            return s; \\n\\n        char[] chars = s.toCharArray();\\n\\n        for(int i = 0; i < chars.length; i++){\\n            // Find odd length palindrome\\n            findPalindrome(chars, i, i); // current character as the center of the palindrome\\n\\n            // Find even length palindrome\\n            findPalindrome(chars, i, i+1); // current character and the next character as the centers of the palindrome.\\n        }\\n        \\n        // Return the longest palindromic substring by using the start and max indices.\\n        return s.substring(start, start + max);\\n    }\\n\\n    private void findPalindrome(char[] chars, int j, int k){\\n        // Expand the palindrome by checking characters at indices j and k.\\n        while( j >= 0 && k < chars.length && chars[j] == chars[k]){\\n            j--;\\n            k++;\\n        }\\n        \\n        // Check if the current palindrome length is greater than the previously recorded maximum.\\n        if(max < k - j - 1){\\n            max = k - j - 1;   // Update the length of the longest palindrome.\\n            start = j + 1;     // Update the start index of the longest palindrome.\\n        }\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Two Pointers",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    int start = 0; // Initialize the start index for the longest palindrome.\\n    int max = 0;   // Initialize the length of the longest palindrome.\\n\\n    public String longestPalindrome(String s) {\\n        if(s.length() < 2)\\n            return s; \\n\\n        char[] chars = s.toCharArray();\\n\\n        for(int i = 0; i < chars.length; i++){\\n            // Find odd length palindrome\\n            findPalindrome(chars, i, i); // current character as the center of the palindrome\\n\\n            // Find even length palindrome\\n            findPalindrome(chars, i, i+1); // current character and the next character as the centers of the palindrome.\\n        }\\n        \\n        // Return the longest palindromic substring by using the start and max indices.\\n        return s.substring(start, start + max);\\n    }\\n\\n    private void findPalindrome(char[] chars, int j, int k){\\n        // Expand the palindrome by checking characters at indices j and k.\\n        while( j >= 0 && k < chars.length && chars[j] == chars[k]){\\n            j--;\\n            k++;\\n        }\\n        \\n        // Check if the current palindrome length is greater than the previously recorded maximum.\\n        if(max < k - j - 1){\\n            max = k - j - 1;   // Update the length of the longest palindrome.\\n            start = j + 1;     // Update the start index of the longest palindrome.\\n        }\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3779484,
                "title": "java-solution-using-2-pointers-without-dp",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public String longestPalindrome(String s) {\\n       int start = 0, end = 0;\\n       for(int i = 0; i < s.length(); i ++) {\\n           char c = s.charAt(i);\\n           int left = i;\\n           int right = i;\\n           while(left >= 0 && s.charAt(left) == c) left --;\\n           while(right < s.length() && s.charAt(right) == c) right ++;\\n           while(left >= 0 && right < s.length()) {\\n               if(s.charAt(left) != s.charAt(right)) break;\\n               left --;\\n               right ++;\\n           }\\n           left += 1;\\n           if(end - start < right - left) {\\n               start = left;\\n               end = right;\\n           }\\n       } \\n       return s.substring(start, end);\\n    }\\n}\\n```\\n# PLEASE UPVOTE IF IT WAS HELPFULL",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public String longestPalindrome(String s) {\\n       int start = 0, end = 0;\\n       for(int i = 0; i < s.length(); i ++) {\\n           char c = s.charAt(i);\\n           int left = i;\\n           int right = i;\\n           while(left >= 0 && s.charAt(left) == c) left --;\\n           while(right < s.length() && s.charAt(right) == c) right ++;\\n           while(left >= 0 && right < s.length()) {\\n               if(s.charAt(left) != s.charAt(right)) break;\\n               left --;\\n               right ++;\\n           }\\n           left += 1;\\n           if(end - start < right - left) {\\n               start = left;\\n               end = right;\\n           }\\n       } \\n       return s.substring(start, end);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2156653,
                "title": "python-dynamic-and-brute",
                "content": "**UPVOTE IF HELPFuuL**\\n\\nDYNAMIC APPROACH\\n\\n**PALINDROME in DP**->If its first and last elements are same and the substring after excluding the first and last character is a palindrome.\\n* Hence we can now reduce a bigger problem to smaller problem whose answer may be previously known.\\n\\n* Use a matrix where ```dp[ i ] [ j ]``` represents substring from ith pos to jth pos.\\n* All single characters are palindromes, thus substring with a length 1 are substring by default.\\n* substrings of length 2 are *palin* if both characters are same.\\n* \\nAnd for rest of lengths use the sub problem.\\n\\nNow we need longest so the palindromic substring with longest length is the substring.\\n\\n**BRUTE FORECE**\\n```\\nclass Solution:\\n   \\n    def longestPalindrome(self, s: str) -> str:\\n        res=s[0]\\n        nn=len(res)\\n        n=len(s)\\n        for i in range(1,n-1):\\n            \\n            kk=s[i]\\n            z=1\\n            while ((i-z)>=0) and ((i+z)<n) and (s[i-z]==s[i+z]):\\n                kk=s[i-z]+kk+s[i-z]\\n                z+=1\\n            \\n            if len(kk)>nn:\\n                res=kk\\n                nn=len(res)\\n        for i in range(0,n-1):\\n            if s[i]==s[i+1]:\\n                \\n                kk=s[i]+s[i+1]\\n                z=1\\n                while ((i-z)>=0) and ((i+z+1)<n) and (s[i-z]==s[i+z+1]):\\n                    kk=s[i-z]+kk+s[i-z]\\n                    z+=1\\n                if len(kk)>nn:\\n                    res=kk\\n                    nn=len(res)\\n        return res\\n```\\n\\n**UPVOTE IF HELPFuuL**\\n\\n**DYNAMIC APPROACH**\\n\\n```\\nclass Solution:\\n   def longestPalindrome(self, s):\\n        res = \\'\\'\\n        dp = [[0]*len(s) for i in range(len(s))]\\n        \\n        for i in range(len(s)):\\n            dp[i][i] = True\\n            res = s[i]\\n\\t\\t\\t\\n        for i in range(len(s)-1,-1,-1):\\n            for j in range(i+1,len(s)):  \\n                \\n                if s[i] == s[j]:\\n                    if j-i ==1 or dp[i+1][j-1] is True:\\n                        dp[i][j] = True\\n                        \\n                        if len(res) < len(s[i:j+1]):\\n                            res = s[i:j+1]\\n                \\n        return res\\n```\\n![image](https://assets.leetcode.com/users/images/0007f2ce-d76f-46e8-b520-794d74ca5506_1655338899.7001777.jpeg)\\n",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```dp[ i ] [ j ]```\n```\\nclass Solution:\\n   \\n    def longestPalindrome(self, s: str) -> str:\\n        res=s[0]\\n        nn=len(res)\\n        n=len(s)\\n        for i in range(1,n-1):\\n            \\n            kk=s[i]\\n            z=1\\n            while ((i-z)>=0) and ((i+z)<n) and (s[i-z]==s[i+z]):\\n                kk=s[i-z]+kk+s[i-z]\\n                z+=1\\n            \\n            if len(kk)>nn:\\n                res=kk\\n                nn=len(res)\\n        for i in range(0,n-1):\\n            if s[i]==s[i+1]:\\n                \\n                kk=s[i]+s[i+1]\\n                z=1\\n                while ((i-z)>=0) and ((i+z+1)<n) and (s[i-z]==s[i+z+1]):\\n                    kk=s[i-z]+kk+s[i-z]\\n                    z+=1\\n                if len(kk)>nn:\\n                    res=kk\\n                    nn=len(res)\\n        return res\\n```\n```\\nclass Solution:\\n   def longestPalindrome(self, s):\\n        res = \\'\\'\\n        dp = [[0]*len(s) for i in range(len(s))]\\n        \\n        for i in range(len(s)):\\n            dp[i][i] = True\\n            res = s[i]\\n\\t\\t\\t\\n        for i in range(len(s)-1,-1,-1):\\n            for j in range(i+1,len(s)):  \\n                \\n                if s[i] == s[j]:\\n                    if j-i ==1 or dp[i+1][j-1] is True:\\n                        dp[i][j] = True\\n                        \\n                        if len(res) < len(s[i:j+1]):\\n                            res = s[i:j+1]\\n                \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2156645,
                "title": "java-dynamic-and-brute",
                "content": "**UPVOTE IF HELPFuuL**\\n\\n\\nDYNAMIC APPROACH\\n\\n**PALINDROME in DP**->If its first and last elements are same and the substring after excluding the first and last character is a palindrome.\\n* Hence we can now reduce a bigger problem to smaller problem whose answer may be previously known.\\n\\n* Use a matrix where ```dp[ i ] [ j ]``` represents substring from ith pos to jth pos.\\n* All single characters are palindromes, thus substring with a length 1 are substring by default.\\n* substrings of length 2 are *palin* if both characters are same.\\n* \\nAnd for rest of lengths use the sub problem.\\n\\nNow we need longest so the palindromic substring with longest length is the substring.\\n\\n**BRUTE FORCE**\\n```\\npublic class Solution \\n{\\n\\tprivate int lo, result;\\n\\n\\tpublic String longestPalindrome(String s) {\\n\\t\\tint len = s.length();\\n\\t\\tif (len < 2)\\n\\t\\t\\treturn s;\\n\\t\\n\\t    for (int i = 0; i < len-1; i++) {\\n    \\t \\tsolve(s, i, i);\\n     \\t\\tsolve(s, i, i+1);\\n\\t    }\\n    \\treturn s.substring(lo, lo + result);\\n\\t}\\n\\n\\tprivate void solve(String s, int j, int k) {\\n\\t\\twhile (j >= 0 && k < s.length() && s.charAt(j) == s.charAt(k)) {\\n\\t\\t\\tj--;\\n\\t\\t\\tk++;\\n\\t\\t}\\n\\t\\tif (result < k - j - 1) {\\n\\t\\t\\tlo = j + 1;\\n\\t\\t\\tresult = k - j - 1;\\n\\t\\t}\\n\\t}\\n}\\n```\\n**UPVOTE IF HELPFuuL**\\n\\n**DYNAMIC APPROACH**\\n\\n```\\npublic class Solution \\n{\\n\\tpublic String longestPalindrome(String s) {\\n    \\tint n = s.length();\\n    \\tString res = null;\\n    \\n    \\tboolean[][] dp = new boolean[n][n];\\n    \\n  \\t    for (int i = n - 1; i >= 0; i--) {\\n        \\tfor (int j = i; j < n; j++) {\\n        \\t\\tdp[i][j] = s.charAt(i) == s.charAt(j) && (j - i < 3 || dp[i + 1][j - 1]);\\n            \\n      \\t\\t\\tif (dp[i][j] && (res == null || j - i + 1 > res.length())) {\\n        \\t\\t\\tres = s.substring(i, j + 1);\\n    \\t\\t\\t}\\n    \\t\\t}\\n\\t\\t}\\n    \\n  \\t\\treturn res;\\n\\t}\\n}\\n```\\n![image](https://assets.leetcode.com/users/images/8f6a9e7e-d3c7-4609-8809-cc35b600da80_1655338676.7202148.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```dp[ i ] [ j ]```\n```\\npublic class Solution \\n{\\n\\tprivate int lo, result;\\n\\n\\tpublic String longestPalindrome(String s) {\\n\\t\\tint len = s.length();\\n\\t\\tif (len < 2)\\n\\t\\t\\treturn s;\\n\\t\\n\\t    for (int i = 0; i < len-1; i++) {\\n    \\t \\tsolve(s, i, i);\\n     \\t\\tsolve(s, i, i+1);\\n\\t    }\\n    \\treturn s.substring(lo, lo + result);\\n\\t}\\n\\n\\tprivate void solve(String s, int j, int k) {\\n\\t\\twhile (j >= 0 && k < s.length() && s.charAt(j) == s.charAt(k)) {\\n\\t\\t\\tj--;\\n\\t\\t\\tk++;\\n\\t\\t}\\n\\t\\tif (result < k - j - 1) {\\n\\t\\t\\tlo = j + 1;\\n\\t\\t\\tresult = k - j - 1;\\n\\t\\t}\\n\\t}\\n}\\n```\n```\\npublic class Solution \\n{\\n\\tpublic String longestPalindrome(String s) {\\n    \\tint n = s.length();\\n    \\tString res = null;\\n    \\n    \\tboolean[][] dp = new boolean[n][n];\\n    \\n  \\t    for (int i = n - 1; i >= 0; i--) {\\n        \\tfor (int j = i; j < n; j++) {\\n        \\t\\tdp[i][j] = s.charAt(i) == s.charAt(j) && (j - i < 3 || dp[i + 1][j - 1]);\\n            \\n      \\t\\t\\tif (dp[i][j] && (res == null || j - i + 1 > res.length())) {\\n        \\t\\t\\tres = s.substring(i, j + 1);\\n    \\t\\t\\t}\\n    \\t\\t}\\n\\t\\t}\\n    \\n  \\t\\treturn res;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1056859,
                "title": "recursion-a-few-dp-variants",
                "content": "1. recursion, O(2^n)\\n```\\nclass Solution {\\n    public String longestPalindrome(String s) {\\n        return longRecur(s,0,s.length()-1);\\n    }\\n    \\n    String longRecur(String str,int s,int e) \\n        if(s==e) return String.valueOf(str.charAt(s)); //base\\n        if(s>e) return \"\";\\n        \\n        //case 1\\n        if(str.charAt(s) == str.charAt(e)) {\\n            String both = longRecur(str,s+1,e-1);\\n            if(both.length() ==  e-1-(s+1)+1) //check if the remaining string is also a palindrome\\n                return str.charAt(s) + both + str.charAt(e);\\n        }\\n        \\n        //case2\\n        String left = longRecur(str,s+1,e);\\n        String right = longRecur(str,s,e-1);\\n        if(left.length() > right.length()) return left;\\n        else return right;\\n    }\\n}\\n```\\n\\n2. recursion + memo =  top-down dp (I\\'m adding this as requested)\\n```\\nclass Solution {\\n    \\n    public String longestPalindrome(String s) {\\n        return longRecur(s,0,s.length()-1, new String[s.length()][s.length()]);\\n    }\\n    \\n    private String longRecur(String str,int s,int e, String[][] memo) {\\n        //base\\n        if(s==e) return String.valueOf(str.charAt(s)); \\n        if(s>e) return \"\";\\n        \\n        if(memo[s][e]!=null) return memo[s][e];\\n    \\n        //case 1\\n        if(str.charAt(s) == str.charAt(e)) {\\n            String both = longRecur(str,s+1,e-1,memo);\\n            if(both.length() ==  e-1-(s+1)+1) { //check if the remaining string is also a palindrome\\n                String ret = str.charAt(s) + both + str.charAt(e);\\n                memo[s][e] = ret;\\n                return ret;\\n            }\\n        }\\n        \\n        //case2\\n        String left = longRecur(str,s+1,e,memo);\\n        String right = longRecur(str,s,e-1,memo);\\n    \\n        if(left.length() > right.length()) {\\n            memo[s][e] = left;\\n            return left;\\n        } else {\\n            memo[s][e] = right;\\n            return right;\\n        }\\n    }\\n}\\n```\\n\\nthere could be a few bottom-up dp variants.\\n\\n\\n\\n3. dp, using String[][] longestPalindrome\\n\\twe can directly store strings into the matrix. \\n\\tit\\'s a direct conversion of the recursion solution above.\\n\\ttime O(n^2), space O(n^2) \\n\\tbut then since it\\'s directly handling strings it\\'s relatively slower than other dp variants below.\\n\\n```\\nclass Solution {\\n    \\n    public String longestPalindrome(String str) {\\n        \\n        int n = str.length();\\n        String[][] dp = new String[n][n]; //longestPalindrome\\n\\n\\t\\t//init the matrix\\n        for(int i =0;i<n;i++) \\n            for(int j=0;j<n;j++) \\n               dp[i][j] =\"\";\\n         \\n        //base\\n        for(int i=0;i<n;i++) \\n            dp[i][i] = String.valueOf(str.charAt(i));\\n        \\n        //fill in the upper right half\\n        for(int s=n-1; s>=0; s--)  {\\n            for(int e = s+1; e<n; e++) {\\n                if(str.charAt(s) == str.charAt(e)) {\\n                  String both = dp[s+1][e-1];\\n                    if( both.length() ==  e-1-(s+1)+1) {\\n                        dp[s][e] = str.charAt(s) + both + str.charAt(e);\\n                        continue;\\n                    }\\n                }\\n    \\n                String left = dp[s+1][e];\\n                String right = dp[s][e-1];\\n                if(left.length() > right.length()) dp[s][e] = left;\\n                else dp[s][e] = right;\\n            }\\n        }\\n        return dp[0][n-1]; \\n    }\\n} \\n```\\n\\n4. dp, using int[][] maxLength (i.e. the length of the longest palindrome)\\ninstead of handling strings directly, we can just keep track of maxLen and return the substring at the end.\\ntime O(n^2), space O(n^2) \\n\\n```\\nclass Solution {\\n    \\n    public String longestPalindrome(String str) {\\n        \\n        int n = str.length();\\n        int[][] dp = new int[n][n]; //means the length of the longest palindrom of str.substring(i,j+1)\\n        for(int i=0;i<n;i++)//base\\n            dp[i][i] = 1;\\n        int maxLen=1, maxStart =0;\\n\\n        for(int s = n-1;s>=0;s--) {\\n            for(int e=s+1;e<n;e++) {\\n                \\n                if(str.charAt(s) ==str.charAt(e)) {\\n                    if(dp[s+1][e-1] == e-1 -(s+1)+1) {\\n                        dp[s][e] = dp[s+1][e-1] +2;\\n                        int len = e-s+1;\\n                        if(maxLen<len) {\\n                            maxLen = len;\\n                            maxStart = s;\\n                        } \\n                        continue;\\n                    }\\n                }\\n                 \\n                int left = dp[s+1][e];\\n                int right = dp[s][e-1];\\n                dp[s][e] = Math.max(left,right);\\n            }\\n        }\\n        return str.substring(maxStart,maxStart+maxLen);\\n    }\\n} \\n```\\n\\n\\n5. dp, using boolean[][] isPalindrome\\nit\\'s the simplest form\\ntime O(n^2), space O(n^2) \\n\\n```\\nclass Solution {\\n    \\n    public String longestPalindrome(String str) {\\n        \\n        int n = str.length();\\n        boolean[][] dp = new boolean[n][n];  //means if str.substring(i,j+1) is palindrome. \\n        int maxLen=1,maxStart=0;\\n        //base\\n        for(int i=0;i<n;i++)\\n            dp[i][i] = true;\\n \\n        for(int s = n-1;s>=0;s--) {\\n            for(int e=s+1;e<n;e++) {   \\n                if(str.charAt(s) ==str.charAt(e)) {\\n                    if(dp[s+1][e-1] || e-1-(s+1)+1==0 ) { // e-1-(s+1)+1==0 means smaller_str.length()==0\\n                        dp[s][e] = true;\\n                        int len = e-s+1;\\n                        if(maxLen<len) {\\n                           maxLen = len;\\n                           maxStart =s;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return str.substring(maxStart,maxStart+maxLen);\\n    }\\n} \\n```\\nnote that \\nboolean[][] isPalindrome above  is the dp of the following \\n```\\n\\n  boolean isPalindrome(String str, int s, int e) {\\n\\t    while(s<=e){\\n\\t\\t\\tif(str.charAt(s)!=str.charAt(e)) return false;\\n\\t\\t\\ts++;\\n\\t\\t\\te--;\\n\\t\\t}\\n\\t\\treturn true;\\n  }\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String longestPalindrome(String s) {\\n        return longRecur(s,0,s.length()-1);\\n    }\\n    \\n    String longRecur(String str,int s,int e) \\n        if(s==e) return String.valueOf(str.charAt(s)); //base\\n        if(s>e) return \"\";\\n        \\n        //case 1\\n        if(str.charAt(s) == str.charAt(e)) {\\n            String both = longRecur(str,s+1,e-1);\\n            if(both.length() ==  e-1-(s+1)+1) //check if the remaining string is also a palindrome\\n                return str.charAt(s) + both + str.charAt(e);\\n        }\\n        \\n        //case2\\n        String left = longRecur(str,s+1,e);\\n        String right = longRecur(str,s,e-1);\\n        if(left.length() > right.length()) return left;\\n        else return right;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    \\n    public String longestPalindrome(String s) {\\n        return longRecur(s,0,s.length()-1, new String[s.length()][s.length()]);\\n    }\\n    \\n    private String longRecur(String str,int s,int e, String[][] memo) {\\n        //base\\n        if(s==e) return String.valueOf(str.charAt(s)); \\n        if(s>e) return \"\";\\n        \\n        if(memo[s][e]!=null) return memo[s][e];\\n    \\n        //case 1\\n        if(str.charAt(s) == str.charAt(e)) {\\n            String both = longRecur(str,s+1,e-1,memo);\\n            if(both.length() ==  e-1-(s+1)+1) { //check if the remaining string is also a palindrome\\n                String ret = str.charAt(s) + both + str.charAt(e);\\n                memo[s][e] = ret;\\n                return ret;\\n            }\\n        }\\n        \\n        //case2\\n        String left = longRecur(str,s+1,e,memo);\\n        String right = longRecur(str,s,e-1,memo);\\n    \\n        if(left.length() > right.length()) {\\n            memo[s][e] = left;\\n            return left;\\n        } else {\\n            memo[s][e] = right;\\n            return right;\\n        }\\n    }\\n}\\n```\n```\\nclass Solution {\\n    \\n    public String longestPalindrome(String str) {\\n        \\n        int n = str.length();\\n        String[][] dp = new String[n][n]; //longestPalindrome\\n\\n\\t\\t//init the matrix\\n        for(int i =0;i<n;i++) \\n            for(int j=0;j<n;j++) \\n               dp[i][j] =\"\";\\n         \\n        //base\\n        for(int i=0;i<n;i++) \\n            dp[i][i] = String.valueOf(str.charAt(i));\\n        \\n        //fill in the upper right half\\n        for(int s=n-1; s>=0; s--)  {\\n            for(int e = s+1; e<n; e++) {\\n                if(str.charAt(s) == str.charAt(e)) {\\n                  String both = dp[s+1][e-1];\\n                    if( both.length() ==  e-1-(s+1)+1) {\\n                        dp[s][e] = str.charAt(s) + both + str.charAt(e);\\n                        continue;\\n                    }\\n                }\\n    \\n                String left = dp[s+1][e];\\n                String right = dp[s][e-1];\\n                if(left.length() > right.length()) dp[s][e] = left;\\n                else dp[s][e] = right;\\n            }\\n        }\\n        return dp[0][n-1]; \\n    }\\n} \\n```\n```\\nclass Solution {\\n    \\n    public String longestPalindrome(String str) {\\n        \\n        int n = str.length();\\n        int[][] dp = new int[n][n]; //means the length of the longest palindrom of str.substring(i,j+1)\\n        for(int i=0;i<n;i++)//base\\n            dp[i][i] = 1;\\n        int maxLen=1, maxStart =0;\\n\\n        for(int s = n-1;s>=0;s--) {\\n            for(int e=s+1;e<n;e++) {\\n                \\n                if(str.charAt(s) ==str.charAt(e)) {\\n                    if(dp[s+1][e-1] == e-1 -(s+1)+1) {\\n                        dp[s][e] = dp[s+1][e-1] +2;\\n                        int len = e-s+1;\\n                        if(maxLen<len) {\\n                            maxLen = len;\\n                            maxStart = s;\\n                        } \\n                        continue;\\n                    }\\n                }\\n                 \\n                int left = dp[s+1][e];\\n                int right = dp[s][e-1];\\n                dp[s][e] = Math.max(left,right);\\n            }\\n        }\\n        return str.substring(maxStart,maxStart+maxLen);\\n    }\\n} \\n```\n```\\nclass Solution {\\n    \\n    public String longestPalindrome(String str) {\\n        \\n        int n = str.length();\\n        boolean[][] dp = new boolean[n][n];  //means if str.substring(i,j+1) is palindrome. \\n        int maxLen=1,maxStart=0;\\n        //base\\n        for(int i=0;i<n;i++)\\n            dp[i][i] = true;\\n \\n        for(int s = n-1;s>=0;s--) {\\n            for(int e=s+1;e<n;e++) {   \\n                if(str.charAt(s) ==str.charAt(e)) {\\n                    if(dp[s+1][e-1] || e-1-(s+1)+1==0 ) { // e-1-(s+1)+1==0 means smaller_str.length()==0\\n                        dp[s][e] = true;\\n                        int len = e-s+1;\\n                        if(maxLen<len) {\\n                           maxLen = len;\\n                           maxStart =s;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return str.substring(maxStart,maxStart+maxLen);\\n    }\\n} \\n```\n```\\n\\n  boolean isPalindrome(String str, int s, int e) {\\n\\t    while(s<=e){\\n\\t\\t\\tif(str.charAt(s)!=str.charAt(e)) return false;\\n\\t\\t\\ts++;\\n\\t\\t\\te--;\\n\\t\\t}\\n\\t\\treturn true;\\n  }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 880368,
                "title": "fast-and-simple-solution-on-swift-95-speed-95-memory",
                "content": "Fast and simple solution.\\n\\n`Your runtime beats 95.90 % of swift submissions.`\\n`Your memory usage beats 95.58 % of swift submissions.`\\n\\nHow to define if the string is palindrome?\\n\\n**Brief description:**\\nFrom some point in the middle of the string let\\'s start cheking if the two next chars from the left and right are equal.\\nIf they are equal then continue checking next two chars:\\n\\n```\\n// odd palindrome  - \"cabac\"\\n// even palindrome - \"cabbac\"\\n\\n// odd  fcbaBadca      even  adSBAABSfd\\n//         -x-                   x-\\n//        --x--                 -x--\\n//       ---x---               --x---\\n```\\n\\nThat\\'s how we can find a palindrome at any point of the string.\\n\\n**Then:**\\nCheck until next two side chars are different(1) or we go out of the string size(2).\\nStore palindrom start and finish indexes.\\nIn case of (1) move to another starting point and continue to search a bigger palindrome.\\nIn cease of (2) end of the search.\\n\\n**Result:**\\nOutput found string.\\n\\n**Solution:**\\n\\n```\\nclass Solution {\\n\\t// Store input string as array.\\n    private var array: [Character]!\\n\\n\\t// Store biggest palindrome info.\\n    private var maxSize = 0\\n    private var bestStart = 0\\n    private var bestFinish = 0\\n\\n    func longestPalindrome(_ s: String) -> String {\\n        array = Array(s) // Make an aray out of the input string.\\n        guard array.count > 1 else { return s } // Check edge case.\\n\\t\\t\\n\\t\\t// Let\\'s start from the middle of the string,\\n\\t\\t//   since it\\'s the best place for a big palindrome.\\n        let middle = Int(array.count / 2)\\n\\t\\t\\n\\t\\t// And continue to search in two directions: to the left and right side:\\n\\t\\t//                           start \\n\\t\\t//                  <-L        |          R->\\n\\t\\t// \"dfjhasdliudfhnasudkhcfaiehncfnusejagxfkuyseagjfuygaefgvaskuyfc\"\\n        var lStart = middle\\n        var rStart = middle + 1\\n\\t\\t\\n\\t\\t// Check if we should continue our search.\\n        while worthCheck(from: lStart) {\\n            check(lStart)  // Check left direction.\\n            lStart -= 1    // Make a step to the left.\\n            check(rStart)  // Check right direcion.\\n            rStart += 1    // Make step to the right.\\n        }\\n        return String(array[bestStart...bestFinish]) // Output the result.\\n    }\\n\\n    /// Is it possible to find a bigger palindrome in the array starting from `index` point?\\n    private func worthCheck(from index: Int) -> Bool {\\n        guard 0 <= index else { return false } // out of array\\n\\t\\t\\n\\t\\t// If we 2 chars from the string edge then max palindrom \\n\\t\\t//   we can found is size 5\\n\\t\\t//   but if we already have found palindrome with size 7\\n\\t\\t//   then it\\'s not worth to spend time on this search any more.\\n\\t\\t\\n\\t\\t// char count from start of the string\\n        let charCount = index + 1\\n        let maxPotentialSizeOfPalindrome = charCount * 2 + 1\\n\\t\\t// check if there space for big enough palindrome.\\n        return maxPotentialSizeOfPalindrome > maxSize\\n    }\\n\\n    private func check(_ startIndex: Int) {\\n\\t\\t// let\\'s search odd and even palindromes\\n        check(startIndex, odd: false) // like \"abba\"\\n        check(startIndex, odd: true)  // like \"aba\"\\n    }\\n\\n    private func check(_ startIndex: Int, odd: Bool) {\\n\\t\\t// Search progression example\\n\\t\\t//   s - start point\\n\\t\\t//   l - left index, start of potential palindrome\\n\\t\\t//   r - right index, end of potential palindrome\\n\\t\\t\\n        // odd  fcbaBadca      even  adSBAABSfd\\n        //         lsr                   sr\\n        //        l-s-r                 ls-r\\n        //       l--s--r               l-s--r\\n\\n        var offset = 1\\n        let oddity = (odd ? 0 : 1) // Shift `lhs` index one step to the left to find `even` palindrome.\\n        repeat {\\n\\t\\t    // Calc left and right indexes.\\n            let lhs = startIndex - offset + oddity\\n            let rhs = startIndex + offset\\n\\t\\t\\t\\n            guard 0 <= lhs, rhs < array.count,   // Check if we are still in the array.\\n                  array[lhs] == array[rhs]       // Check if side chars are equal.\\n            else { break }                       // If this is not a palindrome then break the search.\\n\\t\\t\\t\\n\\t\\t\\t// Let\\'s check if we\\'ve found a biggest palindrome then before and store it.\\n            let lenght = rhs - lhs\\n            if lenght > maxSize {\\n                maxSize = lenght\\n                bestStart = lhs\\n                bestFinish = rhs\\n            }\\n\\t\\t\\t// Increase offset for left and right index and repeat.\\n\\t\\t\\toffset += 1\\n        } while true\\n    }\\n}\\n```\\n\\nThanks for reading and please feel free to comment.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\n// odd palindrome  - \"cabac\"\\n// even palindrome - \"cabbac\"\\n\\n// odd  fcbaBadca      even  adSBAABSfd\\n//         -x-                   x-\\n//        --x--                 -x--\\n//       ---x---               --x---\\n```\n```\\nclass Solution {\\n\\t// Store input string as array.\\n    private var array: [Character]!\\n\\n\\t// Store biggest palindrome info.\\n    private var maxSize = 0\\n    private var bestStart = 0\\n    private var bestFinish = 0\\n\\n    func longestPalindrome(_ s: String) -> String {\\n        array = Array(s) // Make an aray out of the input string.\\n        guard array.count > 1 else { return s } // Check edge case.\\n\\t\\t\\n\\t\\t// Let\\'s start from the middle of the string,\\n\\t\\t//   since it\\'s the best place for a big palindrome.\\n        let middle = Int(array.count / 2)\\n\\t\\t\\n\\t\\t// And continue to search in two directions: to the left and right side:\\n\\t\\t//                           start \\n\\t\\t//                  <-L        |          R->\\n\\t\\t// \"dfjhasdliudfhnasudkhcfaiehncfnusejagxfkuyseagjfuygaefgvaskuyfc\"\\n        var lStart = middle\\n        var rStart = middle + 1\\n\\t\\t\\n\\t\\t// Check if we should continue our search.\\n        while worthCheck(from: lStart) {\\n            check(lStart)  // Check left direction.\\n            lStart -= 1    // Make a step to the left.\\n            check(rStart)  // Check right direcion.\\n            rStart += 1    // Make step to the right.\\n        }\\n        return String(array[bestStart...bestFinish]) // Output the result.\\n    }\\n\\n    /// Is it possible to find a bigger palindrome in the array starting from `index` point?\\n    private func worthCheck(from index: Int) -> Bool {\\n        guard 0 <= index else { return false } // out of array\\n\\t\\t\\n\\t\\t// If we 2 chars from the string edge then max palindrom \\n\\t\\t//   we can found is size 5\\n\\t\\t//   but if we already have found palindrome with size 7\\n\\t\\t//   then it\\'s not worth to spend time on this search any more.\\n\\t\\t\\n\\t\\t// char count from start of the string\\n        let charCount = index + 1\\n        let maxPotentialSizeOfPalindrome = charCount * 2 + 1\\n\\t\\t// check if there space for big enough palindrome.\\n        return maxPotentialSizeOfPalindrome > maxSize\\n    }\\n\\n    private func check(_ startIndex: Int) {\\n\\t\\t// let\\'s search odd and even palindromes\\n        check(startIndex, odd: false) // like \"abba\"\\n        check(startIndex, odd: true)  // like \"aba\"\\n    }\\n\\n    private func check(_ startIndex: Int, odd: Bool) {\\n\\t\\t// Search progression example\\n\\t\\t//   s - start point\\n\\t\\t//   l - left index, start of potential palindrome\\n\\t\\t//   r - right index, end of potential palindrome\\n\\t\\t\\n        // odd  fcbaBadca      even  adSBAABSfd\\n        //         lsr                   sr\\n        //        l-s-r                 ls-r\\n        //       l--s--r               l-s--r\\n\\n        var offset = 1\\n        let oddity = (odd ? 0 : 1) // Shift `lhs` index one step to the left to find `even` palindrome.\\n        repeat {\\n\\t\\t    // Calc left and right indexes.\\n            let lhs = startIndex - offset + oddity\\n            let rhs = startIndex + offset\\n\\t\\t\\t\\n            guard 0 <= lhs, rhs < array.count,   // Check if we are still in the array.\\n                  array[lhs] == array[rhs]       // Check if side chars are equal.\\n            else { break }                       // If this is not a palindrome then break the search.\\n\\t\\t\\t\\n\\t\\t\\t// Let\\'s check if we\\'ve found a biggest palindrome then before and store it.\\n            let lenght = rhs - lhs\\n            if lenght > maxSize {\\n                maxSize = lenght\\n                bestStart = lhs\\n                bestFinish = rhs\\n            }\\n\\t\\t\\t// Increase offset for left and right index and repeat.\\n\\t\\t\\toffset += 1\\n        } while true\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 643461,
                "title": "java-dp-solution-with-clear-explanation",
                "content": "```\\nclass Solution {\\n    // Dynanmic programming solution\\n    // Time complexity O(n^2) denotes 2 the nested for loops, rest of the operations inside the forloop is just O(1)\\n    // Space complexity is O(n^2) for the table initialization\\n    // \\n    public String longestPalindrome(String s) {\\n        // base case\\n        if(s.length() == 0){\\n            return s;\\n        }\\n        \\n        \\n        // intialize a 2d table, which stores if substring of ij is a palindrome\\n        int n = s.length();\\n        boolean table[][] = new boolean[n][n];\\n        \\n        // All substrings of length 1 is palindromes\\n        int maxLength = 1;\\n        for(int i = 0; i < n; ++i) {\\n            table[i][i] = true;\\n        }\\n        \\n        // check for substrings of length 2, duplicates in this case;\\n        int start = 0;\\n        for(int i = 0; i < n - 1; i++) {\\n            if(s.charAt(i) == s.charAt(i+1)) {\\n                table[i][i+1] = true;\\n                // the start index of the longest palidrome, because there might be mutiple solution, we just keep the start index of the last longest palidrome\\n                start = i;\\n                maxLength = 2;\\n            }\\n        }\\n        \\n        // check for substrings greater than 2;\\n        for(int length = 3; length <= n; length++) {\\n            \\n            // aaaaa and we are looking for substring length 3, then the max possible index is 2, as we refer index 2 3 4;\\n            for(int i = 0; i < n -length + 1; i++) {\\n                // get the end index of the substring\\n                int j = i + length - 1;\\n                // since the table is populated for index 3 we first check if the substring(i+1, j-1) is a palindome and then if character i == chracter j;\\n                if(table[i+1][j-1] == true && s.charAt(i) == s.charAt(j)) {\\n                    table[i][j] = true;\\n                    \\n                    // we want to update maxlength to k because k is the longest palidrome \\n                    if(length > maxLength) {\\n                        maxLength = length;\\n                        start = i;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return s.substring(start, start + maxLength);\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    // Dynanmic programming solution\\n    // Time complexity O(n^2) denotes 2 the nested for loops, rest of the operations inside the forloop is just O(1)\\n    // Space complexity is O(n^2) for the table initialization\\n    // \\n    public String longestPalindrome(String s) {\\n        // base case\\n        if(s.length() == 0){\\n            return s;\\n        }\\n        \\n        \\n        // intialize a 2d table, which stores if substring of ij is a palindrome\\n        int n = s.length();\\n        boolean table[][] = new boolean[n][n];\\n        \\n        // All substrings of length 1 is palindromes\\n        int maxLength = 1;\\n        for(int i = 0; i < n; ++i) {\\n            table[i][i] = true;\\n        }\\n        \\n        // check for substrings of length 2, duplicates in this case;\\n        int start = 0;\\n        for(int i = 0; i < n - 1; i++) {\\n            if(s.charAt(i) == s.charAt(i+1)) {\\n                table[i][i+1] = true;\\n                // the start index of the longest palidrome, because there might be mutiple solution, we just keep the start index of the last longest palidrome\\n                start = i;\\n                maxLength = 2;\\n            }\\n        }\\n        \\n        // check for substrings greater than 2;\\n        for(int length = 3; length <= n; length++) {\\n            \\n            // aaaaa and we are looking for substring length 3, then the max possible index is 2, as we refer index 2 3 4;\\n            for(int i = 0; i < n -length + 1; i++) {\\n                // get the end index of the substring\\n                int j = i + length - 1;\\n                // since the table is populated for index 3 we first check if the substring(i+1, j-1) is a palindome and then if character i == chracter j;\\n                if(table[i+1][j-1] == true && s.charAt(i) == s.charAt(j)) {\\n                    table[i][j] = true;\\n                    \\n                    // we want to update maxlength to k because k is the longest palidrome \\n                    if(length > maxLength) {\\n                        maxLength = length;\\n                        start = i;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return s.substring(start, start + maxLength);\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 406383,
                "title": "swift-dp-solution-easy-to-understand",
                "content": "```\\nfunc longestPalindrome(_ s: String) -> String {\\n\\tguard s.count > 1 else {\\n\\t\\treturn s\\n\\t}\\n\\n\\tlet s = Array(s)\\n\\n\\tvar isPalindrome = Array(repeating: Array(repeating: false, count: s.count), count: s.count)\\n\\n\\tvar left = 0\\n\\tvar right = 0\\n\\n\\tfor j in 1..<s.count {\\n\\t\\tfor i in 0..<j {\\n\\n\\t\\t\\t// Rules\\n\\t\\t\\t// 1. If s[i] == s[j] and the length of the word is 2 or less then its a palindrome\\n\\t\\t\\t// 2. If s[i] == s[j] and the inner word is a palindrome then s[i...j] is a palindrome\\n\\t\\t\\tif s[i] == s[j] && (isPalindrome[i + 1][j - 1] || j - i <= 2) {\\n\\t\\t\\t\\tisPalindrome[i][j] = true\\n\\t\\t\\t\\tif j - i > right - left {\\n\\t\\t\\t\\t\\tleft = i\\n\\t\\t\\t\\t\\tright = j\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn String(s[left...right])\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc longestPalindrome(_ s: String) -> String {\\n\\tguard s.count > 1 else {\\n\\t\\treturn s\\n\\t}\\n\\n\\tlet s = Array(s)\\n\\n\\tvar isPalindrome = Array(repeating: Array(repeating: false, count: s.count), count: s.count)\\n\\n\\tvar left = 0\\n\\tvar right = 0\\n\\n\\tfor j in 1..<s.count {\\n\\t\\tfor i in 0..<j {\\n\\n\\t\\t\\t// Rules\\n\\t\\t\\t// 1. If s[i] == s[j] and the length of the word is 2 or less then its a palindrome\\n\\t\\t\\t// 2. If s[i] == s[j] and the inner word is a palindrome then s[i...j] is a palindrome\\n\\t\\t\\tif s[i] == s[j] && (isPalindrome[i + 1][j - 1] || j - i <= 2) {\\n\\t\\t\\t\\tisPalindrome[i][j] = true\\n\\t\\t\\t\\tif j - i > right - left {\\n\\t\\t\\t\\t\\tleft = i\\n\\t\\t\\t\\t\\tright = j\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn String(s[left...right])\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 197753,
                "title": "easy-and-simple-c-4ms-no-special-case",
                "content": "No need to be complicated.\\nSame solution for all situations.\\n\\n```\\nclass Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n        int maxlen = -1, start = 0;\\n        for(int i = 0;i < s.size();++i) {\\n            int left = i, right = i;\\n            while(s[right+1] == s[left]) {//Skip same char in the middle\\n                right++;\\n                i++;\\n            }\\n            while(left -1 >= 0 && right + 1 < s.size() && s[right+1] == s[left-1]) {//Handle expand\\n                left--;\\n                right++;\\n            }\\n            if(right-left+1 > maxlen) {//record max pos\\n                maxlen = right-left+1;\\n                start = left;\\n            }\\n        }\\n        return s.substr(start, maxlen);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n        int maxlen = -1, start = 0;\\n        for(int i = 0;i < s.size();++i) {\\n            int left = i, right = i;\\n            while(s[right+1] == s[left]) {//Skip same char in the middle\\n                right++;\\n                i++;\\n            }\\n            while(left -1 >= 0 && right + 1 < s.size() && s[right+1] == s[left-1]) {//Handle expand\\n                left--;\\n                right++;\\n            }\\n            if(right-left+1 > maxlen) {//record max pos\\n                maxlen = right-left+1;\\n                start = left;\\n            }\\n        }\\n        return s.substr(start, maxlen);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3098,
                "title": "my-simple-c-solution",
                "content": "    class Solution {\\n    public:\\n    string longestPalindrome(string s) {\\n        if(s.length()==0||s.length()==1)return s;\\n        string max=\"\"+s[0];\\n        for(int i=0;i< s.length()-1; i++){\\n            string first=helper(s, i, i);\\n            if(first.length() > max.length())max=first;\\n            \\n            string second=helper(s, i, i+1);\\n            if(second.length() > max.length())max=second;\\n        }\\n        return max;\\n    }\\n    \\n    string helper(string s, int left, int right){\\n        while(left >=0 && right <s.length() && s[right]==s[left]){\\n            left--;\\n            right++;\\n        }\\n        return s.substr(left+1, right-1-left);\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n    string longestPalindrome(string s) {\\n        if(s.length()==0||s.length()==1)return s;\\n        string max=\"\"+s[0];\\n        for(int i=0;i< s.length()-1; i++){\\n            string first=helper(s, i, i);\\n            if(first.length() > max.length())max=first;\\n            \\n            string second=helper(s, i, i+1);\\n            if(second.length() > max.length())max=second;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3245,
                "title": "c-o-n-n-time-constant-space-and-o-n-manacher-s-algorithm",
                "content": "    \\n    string longestPalindrome(string s) {\\n        const int size_s = s.size();\\n        int max_s = 0, max_l = 0;\\n        for (int i = 0; i < size_s;) {\\n            int start = i, end = i;\\n            while (end + 1 < size_s && s[end] == s[end+1]) end++;\\n            i = end + 1;\\n            while (start - 1 >= 0 && end + 1 < size_s && s[start-1] == s[end+1]) {\\n                start--;\\n                end++;\\n            }\\n            if (end - start + 1 > max_l) {\\n                max_l = end - start + 1;\\n                max_s = start;\\n            }\\n        }\\n        return s.substr(max_s, max_l);\\n    }\\n\\n  // Manacher's Algorithm\\n\\n        string longestPalindrome(string s) {\\n        if (s.empty()) return \"\";\\n        string prep = \"#\";\\n        for (auto ch : s) { prep += ch; prep += \"#\";}\\n        const int size_p = prep.size();\\n        vector<int> dp(size_p, 0);\\n        int center = 0, bCur = 0;\\n        for (int i = 0; i < size_p; i++) {\\n            int mirror = center - (i - center);\\n            dp[i] = bCur <= i ? 0 : min(bCur - i, dp[mirror]);\\n            int start = i - dp[i], end = i + dp[i];\\n            while (start - 1 >= 0 && end + 1 < size_p && prep[start - 1] == prep[end + 1]) {\\n                --start;\\n                ++end; \\n                ++dp[i];\\n            }\\n            if (i + dp[i] > bCur) {\\n                bCur = i + dp[i];\\n                center = i;\\n            }\\n        }\\n        center = max_element(dp.begin(), dp.end()) - dp.begin();\\n        return s.substr((center - dp[center])/2, dp[center]);\\n    }",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "    \\n    string longestPalindrome(string s) {\\n        const int size_s = s.size();\\n        int max_s = 0, max_l = 0;\\n        for (int i = 0; i < size_s;) {\\n            int start = i, end = i;\\n            while (end + 1 < size_s && s[end] == s[end+1]) end++;\\n            i = end + 1;\\n            while (start - 1 >= 0 && end + 1 < size_s && s[start-1] == s[end+1]) {\\n                start--;\\n                end++;\\n            }\\n            if (end - start + 1 > max_l) {\\n                max_l = end - start + 1;\\n                max_s = start;\\n            }\\n        }\\n        return s.substr(max_s, max_l);\\n    }\\n\\n  // Manacher's Algorithm\\n\\n        string longestPalindrome(string s) {\\n        if (s.empty()) return \"\";\\n        string prep = \"#\";\\n        for (auto ch : s) { prep += ch; prep += \"#\";}\\n        const int size_p = prep.size();\\n        vector<int> dp(size_p, 0);\\n        int center = 0, bCur = 0;\\n        for (int i = 0; i < size_p; i++) {\\n            int mirror = center - (i - center);\\n            dp[i] = bCur <= i ? 0 : min(bCur - i, dp[mirror]);\\n            int start = i - dp[i], end = i + dp[i];\\n            while (start - 1 >= 0 && end + 1 < size_p && prep[start - 1] == prep[end + 1]) {\\n                --start;\\n                ++end; \\n                ++dp[i];\\n            }\\n            if (i + dp[i] > bCur) {\\n                bCur = i + dp[i];\\n                center = i;\\n            }\\n        }\\n        center = max_element(dp.begin(), dp.end()) - dp.begin();\\n        return s.substr((center - dp[center])/2, dp[center]);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2157014,
                "title": "python-2-approaches-with-explanation",
                "content": "### Introduction\\n\\nGiven a string `s`, we want to find the longest substring in `s` that is a palindrome.\\nWe can define a palindrome to be the following: **a string with a centre position (which may or may not point to a character in the string) that has a substring `sub` on its left and the reversed substring `sub[::-1]` on its right**. Some examples are shown below:\\n\\n```text\\nOdd-length palindromes (spaced out for clarity)\\n    \"a b c d e d c b a\"   \"r a c e c a r\"\\n             ^                   ^\\n\\nEven-length palindromes (spaced out for clarity)\\n    \" a b c d d b c a\"   \"t o o t\"\\n             ^               ^\\n```\\n\\n---\\n\\n### Approach 1\\n\\nBased on the definition above, we can try to find these centre positions in substrings of `s`, since these centre positions will eventually lead us to find the longest palindromic substring. One way is to space out `s` as we did above and check each index. As we noted above, if the index points to a character, then the resulting palindrome is odd-length; if the index points to a space, then the resulting palindrome is even-length.\\n\\nWe can optimise this approach by performing both odd-length and even-length checks on the same index as we iterate through them. At index `i`, **we first assert that `s[i]` is a palindrome of length 1, and iteratively check its adjacent characters for equality until we hit the end(s) of `s`**.\\n\\n```text\\ns = \"abcdedcba\"\\n                      i = 0                 i = 1                 i = 2                 i = 3                 i = 4\\n               \"a b c d e d c b a\"   \"a b c d e d c b a\"   \"a b c d e d c b a\"   \"a b c d e d c b a\"   \"a b c d e d c b a\"\\n                ^                     # ^ #                   # ^ #                   # ^ #             ^ ^ ^ ^ ^ ^ ^ ^ ^\\npalindromes:           \"a\"                   \"b\"                   \"c\"                   \"d\"               \"abcdedcba\"\\n```\\n\\nChecking for even-length palindromes is slightly tricker; **at index `i`, we assert that the (nonexistent) index between `i-1` and `i` is a palindrome of length 0, and we perform the same iteration as described above**.\\n\\n```text\\ns = \"toot\"\\n                 i = 0       i = 1       i = 2\\n               \"t o o t\"   \"t o o t\"   \"t o o t\"\\n               ^            #^#         ^ ^^^ ^\\npalindromes:      \"\"          \"\"        \"toot\"\\n```\\n\\nAfter checking for the longest odd-length and even-length palindromes at index `i`, we store the longest found palindrome to be returned.\\n\\n```python\\nclass Solution:\\n    def longestPalindrome(self, s: str) -> str:\\n        \"\"\"\\n        Consider each character in s as the centre of a palindrome.\\n        Check for the longest possible odd-length and even-length palindrome; store the longest palindrome\\n        \"\"\"\\n        # res is the starting index of the longest palindrome\\n        # len_res is the length of the longest palindrome\\n        # len_s is the length of the given string\\n        res, len_res, len_s = 0, 0, len(s)\\n        for i in range(len_s):\\n            # check for palindromes with odd number of characters centred around s[i]\\n            # i.e., s[i] -> s[i-1:i+2] -> s[i-2:i+3] -> ...\\n            # odd is the starting index of the current palindrome with odd number of characters\\n            # len_odd is the length of the current palindrome with odd number of characters\\n            odd, len_odd = i, 1\\n            for j in range(min(i, len_s-i-1)):   # checking indexes [0, i) and [i+1, len_s); take the smaller range\\n                if s[i-j-1] != s[i+j+1]:         # if the two characters adjacent to the ends of the current palindrome are not equal,\\n                    break                        #   a longer palindrome does not exist; break out of the loop\\n                odd, len_odd = odd-1, len_odd+2  # else, a longer palindrome exists; update odd and len_odd to point to that palindrome\\n            # check for palindromes with even number of characters centred around s[i-1:i+1]\\n            # i.e., s[i-1:i+1] -> s[i-2:i+2] -> s[i-3:i+3] -> ...\\n            # even is the starting index of the current palindrome with even number of characters\\n            # len_even is the length of the current palindrome with even number of characters\\n            even, len_even = i, 0\\n            for j in range(min(i, len_s-i)):         # checking indexes [0, i) and [i, len_s); take the smaller range\\n                if s[i-j-1] != s[i+j]:               # if the two characters adjacent to the ends of the current palindrome are not equal,\\n                    break                            #   a longer palindrome does not exist; break out of the loop\\n                even, len_even = even-1, len_even+2  # else, a longer palindrome exists; update even and len_even to point to that palindrome\\n            # update res and len_res to point to the longest palindrome found so far\\n            len_res, res = max((len_res, res), (len_odd, odd), (len_even, even))\\n        return s[res:res+len_res]\\n```\\n\\n**TC: O(n<sup>2</sup>)**; in the worst case, we are iterating through the entirety of `s` in the inner for loop.\\n**SC: O(1)**; no additional data structures used.\\n\\n---\\n\\n### Approach 2: Manacher\\'s algorithm\\n\\nI happened to chance upon [this post](https://leetcode.com/problems/longest-palindromic-substring/discuss/2156882/Manacher\\'s-algorithm) that implemented the [Manacher\\'s algorithm](https://en.wikipedia.org/wiki/Longest_palindromic_substring#Manacher\\'s_algorithm), which basically makes use of DP to compute if there is a palindrome at each index.\\n\\nUnfortunately, there\\'s not much explanation I can give since I do not understand the approach too well yet. If you can explain it to me, please let me know in the comments :)\\n\\n```python\\nclass Solution:\\n    def longestPalindrome(self, s: str) -> str:\\n        \"\"\"\\n        Manacher\\'s Algorithm for longest palindromic substrings (LPS)\\n        \"\"\"\\n        # Transform S into T\\n        # For example, S = \"abba\", T = \"^#a#b#b#a#$\"\\n        # ^ and $ signs are sentinels appended to each end to avoid bounds checking\\n        T = \\'#\\'.join(\\'^{}$\\'.format(s))\\n        n = len(T)\\n        P = [0]*n\\n        C = R = 0\\n        for i in range (1, n-1):\\n            P[i] = (R > i) and min(R-i, P[2*C-i]) # equals to i\\' = C - (i-C)\\n            # Attempt to expand palindrome centered at i\\n            while T[i+1+P[i]] == T[i-1-P[i]]:\\n                P[i] += 1\\n            # If palindrome centered at i expand past R,\\n            # adjust center based on expanded palindrome\\n            if i+P[i] > R:\\n                C, R = i, i+P[i]\\n        # Find the maximum element in P\\n        maxLen, centerIndex = max((n, i) for i, n in enumerate(P))\\n        return s[(centerIndex-maxLen)//2: (centerIndex+maxLen)//2]\\n```\\n\\n**TC: O(n)**; please read the article linked above for explanation.\\n**SC: O(n)**; DP array used.\\n\\n---\\n\\nPlease upvote if this has helped you! Appreciate any comments as well :)",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```text\\nOdd-length palindromes (spaced out for clarity)\\n    \"a b c d e d c b a\"   \"r a c e c a r\"\\n             ^                   ^\\n\\nEven-length palindromes (spaced out for clarity)\\n    \" a b c d d b c a\"   \"t o o t\"\\n             ^               ^\\n```\n```text\\ns = \"abcdedcba\"\\n                      i = 0                 i = 1                 i = 2                 i = 3                 i = 4\\n               \"a b c d e d c b a\"   \"a b c d e d c b a\"   \"a b c d e d c b a\"   \"a b c d e d c b a\"   \"a b c d e d c b a\"\\n                ^                     # ^ #                   # ^ #                   # ^ #             ^ ^ ^ ^ ^ ^ ^ ^ ^\\npalindromes:           \"a\"                   \"b\"                   \"c\"                   \"d\"               \"abcdedcba\"\\n```\n```text\\ns = \"toot\"\\n                 i = 0       i = 1       i = 2\\n               \"t o o t\"   \"t o o t\"   \"t o o t\"\\n               ^            #^#         ^ ^^^ ^\\npalindromes:      \"\"          \"\"        \"toot\"\\n```\n```python\\nclass Solution:\\n    def longestPalindrome(self, s: str) -> str:\\n        \"\"\"\\n        Consider each character in s as the centre of a palindrome.\\n        Check for the longest possible odd-length and even-length palindrome; store the longest palindrome\\n        \"\"\"\\n        # res is the starting index of the longest palindrome\\n        # len_res is the length of the longest palindrome\\n        # len_s is the length of the given string\\n        res, len_res, len_s = 0, 0, len(s)\\n        for i in range(len_s):\\n            # check for palindromes with odd number of characters centred around s[i]\\n            # i.e., s[i] -> s[i-1:i+2] -> s[i-2:i+3] -> ...\\n            # odd is the starting index of the current palindrome with odd number of characters\\n            # len_odd is the length of the current palindrome with odd number of characters\\n            odd, len_odd = i, 1\\n            for j in range(min(i, len_s-i-1)):   # checking indexes [0, i) and [i+1, len_s); take the smaller range\\n                if s[i-j-1] != s[i+j+1]:         # if the two characters adjacent to the ends of the current palindrome are not equal,\\n                    break                        #   a longer palindrome does not exist; break out of the loop\\n                odd, len_odd = odd-1, len_odd+2  # else, a longer palindrome exists; update odd and len_odd to point to that palindrome\\n            # check for palindromes with even number of characters centred around s[i-1:i+1]\\n            # i.e., s[i-1:i+1] -> s[i-2:i+2] -> s[i-3:i+3] -> ...\\n            # even is the starting index of the current palindrome with even number of characters\\n            # len_even is the length of the current palindrome with even number of characters\\n            even, len_even = i, 0\\n            for j in range(min(i, len_s-i)):         # checking indexes [0, i) and [i, len_s); take the smaller range\\n                if s[i-j-1] != s[i+j]:               # if the two characters adjacent to the ends of the current palindrome are not equal,\\n                    break                            #   a longer palindrome does not exist; break out of the loop\\n                even, len_even = even-1, len_even+2  # else, a longer palindrome exists; update even and len_even to point to that palindrome\\n            # update res and len_res to point to the longest palindrome found so far\\n            len_res, res = max((len_res, res), (len_odd, odd), (len_even, even))\\n        return s[res:res+len_res]\\n```\n```python\\nclass Solution:\\n    def longestPalindrome(self, s: str) -> str:\\n        \"\"\"\\n        Manacher\\'s Algorithm for longest palindromic substrings (LPS)\\n        \"\"\"\\n        # Transform S into T\\n        # For example, S = \"abba\", T = \"^#a#b#b#a#$\"\\n        # ^ and $ signs are sentinels appended to each end to avoid bounds checking\\n        T = \\'#\\'.join(\\'^{}$\\'.format(s))\\n        n = len(T)\\n        P = [0]*n\\n        C = R = 0\\n        for i in range (1, n-1):\\n            P[i] = (R > i) and min(R-i, P[2*C-i]) # equals to i\\' = C - (i-C)\\n            # Attempt to expand palindrome centered at i\\n            while T[i+1+P[i]] == T[i-1-P[i]]:\\n                P[i] += 1\\n            # If palindrome centered at i expand past R,\\n            # adjust center based on expanded palindrome\\n            if i+P[i] > R:\\n                C, R = i, i+P[i]\\n        # Find the maximum element in P\\n        maxLen, centerIndex = max((n, i) for i, n in enumerate(P))\\n        return s[(centerIndex-maxLen)//2: (centerIndex+maxLen)//2]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1541249,
                "title": "o-n-using-an-eertree",
                "content": "Solve this problem using a Palindrome Tree, aka an EERTREE! An EERTREE works a lot like a Trie and despite being very obscure and recent, it\\'s quite elegant to solve this problem.\\n\\nSince for a string of length N there are only up to N distinct palindromes, we can represent each one as a node in a Tree.\\n\\nTaking advantage of a palindrome\\'s recursive structure, we create dictionary links to show that one palindrome is just another palindrome with 1 letter concatenated on both sides.  For example, if we had some node that represents the palindrome `\\'aba\\'` and another palindrome `\\'babab\\'`, then we could show that:\\n\\n`aba ----b----> babab`\\n\\nMore formally, the palindrome `X` has an edge labeled `c` to palindrome `Y` when `Y = cXc`.\\n\\nIn addition, you also have one suffix link for each node, which point to it\\'s longest proper suffix that is a palindrome. In other words, `ababa` would point to `aba` because that is the longest proper suffix that is also a palindrome. This is useful because if I am considering the longest palindrome ending at position `i`, I can just find the longest palindrome ending at position `i-1` and descend down the suffix links until I find a palindrome that has a `S[i]` right before it.\\n\\nFor example, let\\'s say I had the string `xabacabac` and I am trying to find the longest palindrome ending at the last character. If I know the longest palindrome ending at the character before it is `abacaba` then I just have to check the first palindrome `X` that matches `cXc`.\\n\\n`x[abacaba]c` has `x` right before it which is not equal to `c`, so I go to it\\'s next longest palindromic suffix `aba`\\n\\n`xabac[aba]c` has `c` right before it which is equal to `c` so we have found the palindrome `c[aba]c = cabac`\\n\\nAs for the initialization of our EERTREE, we have 2 nodes to handle the 1 letter and 2 letter palindrome case.\\nThere is the empty string `E` of length 0, such that `cEc = cc`\\nThere is the empty string `I` of length -1, such that `cIc = c`\\n\\nHere\\'s the paper on it:\\nhttps://arxiv.org/abs/1506.04862\\n\\nHere\\'s a helpful medium article on learning the basics of it:\\nhttps://medium.com/@alessiopiergiacomi/eertree-or-palindromic-tree-82453e75025b\\n\\n```\\nclass Node:\\n    def __init__(self, len, sfx = None):\\n        self.len = len\\n        self.sfx = sfx\\n        self.next = {}\\n        \\nclass Solution:\\n    def longestPalindrome(self, s: str) -> str:\\n        curr = empty = Node(0, Node(-1))\\n        ans_len = ans_idx = 0\\n        for i, c in enumerate(s):\\n            while i <= curr.len or s[i-1-curr.len] != c:\\n                curr = curr.sfx\\n            if c in curr.next:\\n                curr = curr.next[c]\\n                continue\\n            node = curr.next[c] = Node(curr.len+2, empty)\\n            if node.len > ans_len:\\n                ans_len, ans_idx = node.len, i-node.len+1\\n            if node.len > 1:\\n                curr = curr.sfx\\n                while i <= curr.len or s[i-1-curr.len] != c:\\n                    curr = curr.sfx\\n                node.sfx = curr.next[c]\\n            curr = node\\n        return s[ans_idx:ans_idx+ans_len]\\n```",
                "solutionTags": [
                    "Python3",
                    "Tree"
                ],
                "code": "```\\nclass Node:\\n    def __init__(self, len, sfx = None):\\n        self.len = len\\n        self.sfx = sfx\\n        self.next = {}\\n        \\nclass Solution:\\n    def longestPalindrome(self, s: str) -> str:\\n        curr = empty = Node(0, Node(-1))\\n        ans_len = ans_idx = 0\\n        for i, c in enumerate(s):\\n            while i <= curr.len or s[i-1-curr.len] != c:\\n                curr = curr.sfx\\n            if c in curr.next:\\n                curr = curr.next[c]\\n                continue\\n            node = curr.next[c] = Node(curr.len+2, empty)\\n            if node.len > ans_len:\\n                ans_len, ans_idx = node.len, i-node.len+1\\n            if node.len > 1:\\n                curr = curr.sfx\\n                while i <= curr.len or s[i-1-curr.len] != c:\\n                    curr = curr.sfx\\n                node.sfx = curr.next[c]\\n            curr = node\\n        return s[ans_idx:ans_idx+ans_len]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1243668,
                "title": "longest-palindromic-substring",
                "content": "```\\nclass Solution:\\n    def longestPalindrome(self, s: str) -> str:\\n        n = len(s)\\n        res = s[0]\\n        for i in range(1, n):\\n            # even palindrome check\\n\\t\\t\\t# example --> \\'abba\\' -> mid = right \\'b\\', left = left \\'b\\'. starting from these two positions\\n\\t\\t\\t# now keep stretching until the characters dont match. \\n\\t\\t\\t# finally check if the string got is max\\n            mid = i\\n            left = i-1\\n            while mid < n and left >=0 and s[mid] == s[left]:\\n                mid += 1\\n                left -= 1\\n            res = max(res, s[left+1:mid], key=lambda x: len(x))\\n            # odd palindrome check\\n\\t\\t\\t# example --> cabad, if i points to b, then left points to left \\'a\\' or i-1\\n\\t\\t\\t# and right points to right \\'a\\' or i+1.\\n\\t\\t\\t# now stretch until the characters dont match and find max\\n            left = i-1\\n            right = i+1\\n            while left >=0 and right < n and s[left] == s[right]:\\n                left -= 1\\n                right += 1\\n            res = max(res, s[left+1:right], key=lambda x: len(x))\\n        return res\\n            \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def longestPalindrome(self, s: str) -> str:\\n        n = len(s)\\n        res = s[0]\\n        for i in range(1, n):\\n            # even palindrome check\\n\\t\\t\\t# example --> \\'abba\\' -> mid = right \\'b\\', left = left \\'b\\'. starting from these two positions\\n\\t\\t\\t# now keep stretching until the characters dont match. \\n\\t\\t\\t# finally check if the string got is max\\n            mid = i\\n            left = i-1\\n            while mid < n and left >=0 and s[mid] == s[left]:\\n                mid += 1\\n                left -= 1\\n            res = max(res, s[left+1:mid], key=lambda x: len(x))\\n            # odd palindrome check\\n\\t\\t\\t# example --> cabad, if i points to b, then left points to left \\'a\\' or i-1\\n\\t\\t\\t# and right points to right \\'a\\' or i+1.\\n\\t\\t\\t# now stretch until the characters dont match and find max\\n            left = i-1\\n            right = i+1\\n            while left >=0 and right < n and s[left] == s[right]:\\n                left -= 1\\n                right += 1\\n            res = max(res, s[left+1:right], key=lambda x: len(x))\\n        return res\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1124502,
                "title": "faster-than-92-45-12ms-memory-less-than-95-26-o-n-2-longest-palindromic-substring",
                "content": "Dear All,\\n\\nPlease find below my best solution of Longest Palindromic Substring. \\nHere we have O(n^2) Time Complexity and no extra memory required except several variables.\\nSolution contains comments with some test cases for your better understanding of algorithm.\\n```\\nclass Solution \\n{\\nprivate:\\n    int getPalindromLength(string& s, int left, int right)\\n    {\\n        // Move left and right bounds only while they within string size and characters of both are equal\\n        while( left >= 0 && right < s.length() && s[left] == s[right] )\\n        {\\n            --left;\\n            ++right;\\n        }\\n        // Return length between left and right bounds\\n        return right - left - 1;\\n    }\\npublic:\\n    string longestPalindrome(string s) \\n    {   \\n        // In case string contain only one character - this is a Palindrome\\n        if(s.length() == 1) { return s; }\\n        \\n        // Left and right bounds - between them Palindrom located\\n        int leftIndex, rightIndex;\\n        leftIndex = rightIndex = 0;\\n        \\n        // Imagine that each character is a middle of Palindrome and checking neighbors to find max length\\n        for(int i = 0; i < s.length(); ++i )\\n        {\\n            // Count length for current index\\n            int currentLength = getPalindromLength(s, i, i);\\n            // Count length for current-next index - required for pair characters( example: \"aa\", \"baa\", \"baac\" )\\n            int pairLength = getPalindromLength(s, i, i+1);\\n            // Take current max length between previous two\\n            int maxLength = currentLength >= pairLength ? currentLength : pairLength;\\n            // Only if maxLength more than previous found length - update left and right bounds\\n            if ( maxLength > rightIndex - leftIndex )\\n            {\\n                // Left bound - from current index(because it\\'s middle of Palindrome) deduct (found length - 1) / 2\\n                // TestCase1: current index 3, length = 5. 3 - (5-1)/2 = 3 - 2 = 1. Since 3 is a middle, left bound should be two positions back\\n                // TestCase2: current index 6, length = 4. 6 - (4-1)/2 = 6 - 1 = 5. Since 6 is a middle, left bound should be one positions back\\n                leftIndex = i - (maxLength - 1) / 2;\\n                // Right bound - to current index(because it\\'s middle of Palindrome) add found length / 2\\n                // TestCase1: current index 3, length = 5. 3 + 5/2 = 3 + 2 = 5. Since 3 is a middle, right bound should be two positions ahead\\n                // TestCase2: current index 6, length = 4. 6 + 4/2 = 6 + 2 = 8. Since 6 is a middle, right bound should be two positions ahead\\n                rightIndex = i + maxLength / 2;\\n                // TestCase1: leftIndex = 1, rightIndex = 5. Between those bounds Palindrome located\\n                // TestCase2: leftIndex = 5, rightIndex = 8. Between those bounds Palindrome located\\n            }\\n        }\\n        \\n        // Return Palindrome. substr first parameter indicates from which position starts, second parameter indicates how many characters take\\n        // TestCase1: substr(1, 5) - from index 1 take 5 characters\\n        // TestCase2: substr(5, 4) - from index 5 take 4 characters\\n        return s.substr(leftIndex, rightIndex - leftIndex + 1);\\n    }\\n};\\n```\\n\\nPlease find below my first brute force solution with terrible Time and Space complexity but very easy to understand and probably will help you to have clear picture how issue can be solved. As in previous code containes comments for your better understanding.\\n```\\nclass Solution \\n{\\npublic:\\n    string longestPalindrome(string s) \\n    {   \\n        if(s.length() == 1) { return s; }\\n        // Result string\\n        string palindrome = \"\";\\n        \\n        // Loop by left bound\\n        for(int left = 0; left < s.length(); ++left)\\n        {\\n            // Loop by right bound - from the end of string till face same character as at left bound index\\n            for(int right = s.length() - 1; right > left; --right )\\n            {\\n                // Continue only if characters at current left and right are equal AND current palindrome less then possible next\\n                if( s[left] == s[right] && ( right - left + 1 > palindrome.length() ) )\\n                {\\n                    // Put substring from left to right - second parameter shows how many character should be takken\\n                    string tempPalindrome = s.substr(left, right - left + 1);\\n                    // Create reversed string from substring. rbegin() - reverse iterator and indicates to last character, rend() - indicates to first.\\n                    string reversed(tempPalindrome.rbegin(), tempPalindrome.rend());\\n                    // If substring and reversed string of substring is equal - substring is a polindome\\n                    if(tempPalindrome == reversed)\\n                    {\\n                        palindrome = tempPalindrome;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        // If Palindromes haven\\'t found yet - return first character\\n        if(palindrome.length() == 0) { palindrome = s[0]; }\\n        return palindrome;\\n        \\n    }\\n};\\n```\\n\\nIf we will compare two solution we will see huge time and space difference:\\nBest solution:\\nRuntime: 12 ms\\nMemory Usage: 6.9 MB\\n\\nBrute force solution:\\nRuntime: 1616 ms\\nMemory Usage: 637.5 MB\\n\\nThis once again proves the importance of choosing an efficient algorithm =)\\n\\nIf you know how to improve the code(Besides Manacher\\'s Algorithm) - please let me know I will be very grateful.\\nIf you like solution please vote - I will be pleased.\\n\\nThanks and have a good day.\\n\\nBest Regards, Yevhen.",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution \\n{\\nprivate:\\n    int getPalindromLength(string& s, int left, int right)\\n    {\\n        // Move left and right bounds only while they within string size and characters of both are equal\\n        while( left >= 0 && right < s.length() && s[left] == s[right] )\\n        {\\n            --left;\\n            ++right;\\n        }\\n        // Return length between left and right bounds\\n        return right - left - 1;\\n    }\\npublic:\\n    string longestPalindrome(string s) \\n    {   \\n        // In case string contain only one character - this is a Palindrome\\n        if(s.length() == 1) { return s; }\\n        \\n        // Left and right bounds - between them Palindrom located\\n        int leftIndex, rightIndex;\\n        leftIndex = rightIndex = 0;\\n        \\n        // Imagine that each character is a middle of Palindrome and checking neighbors to find max length\\n        for(int i = 0; i < s.length(); ++i )\\n        {\\n            // Count length for current index\\n            int currentLength = getPalindromLength(s, i, i);\\n            // Count length for current-next index - required for pair characters( example: \"aa\", \"baa\", \"baac\" )\\n            int pairLength = getPalindromLength(s, i, i+1);\\n            // Take current max length between previous two\\n            int maxLength = currentLength >= pairLength ? currentLength : pairLength;\\n            // Only if maxLength more than previous found length - update left and right bounds\\n            if ( maxLength > rightIndex - leftIndex )\\n            {\\n                // Left bound - from current index(because it\\'s middle of Palindrome) deduct (found length - 1) / 2\\n                // TestCase1: current index 3, length = 5. 3 - (5-1)/2 = 3 - 2 = 1. Since 3 is a middle, left bound should be two positions back\\n                // TestCase2: current index 6, length = 4. 6 - (4-1)/2 = 6 - 1 = 5. Since 6 is a middle, left bound should be one positions back\\n                leftIndex = i - (maxLength - 1) / 2;\\n                // Right bound - to current index(because it\\'s middle of Palindrome) add found length / 2\\n                // TestCase1: current index 3, length = 5. 3 + 5/2 = 3 + 2 = 5. Since 3 is a middle, right bound should be two positions ahead\\n                // TestCase2: current index 6, length = 4. 6 + 4/2 = 6 + 2 = 8. Since 6 is a middle, right bound should be two positions ahead\\n                rightIndex = i + maxLength / 2;\\n                // TestCase1: leftIndex = 1, rightIndex = 5. Between those bounds Palindrome located\\n                // TestCase2: leftIndex = 5, rightIndex = 8. Between those bounds Palindrome located\\n            }\\n        }\\n        \\n        // Return Palindrome. substr first parameter indicates from which position starts, second parameter indicates how many characters take\\n        // TestCase1: substr(1, 5) - from index 1 take 5 characters\\n        // TestCase2: substr(5, 4) - from index 5 take 4 characters\\n        return s.substr(leftIndex, rightIndex - leftIndex + 1);\\n    }\\n};\\n```\n```\\nclass Solution \\n{\\npublic:\\n    string longestPalindrome(string s) \\n    {   \\n        if(s.length() == 1) { return s; }\\n        // Result string\\n        string palindrome = \"\";\\n        \\n        // Loop by left bound\\n        for(int left = 0; left < s.length(); ++left)\\n        {\\n            // Loop by right bound - from the end of string till face same character as at left bound index\\n            for(int right = s.length() - 1; right > left; --right )\\n            {\\n                // Continue only if characters at current left and right are equal AND current palindrome less then possible next\\n                if( s[left] == s[right] && ( right - left + 1 > palindrome.length() ) )\\n                {\\n                    // Put substring from left to right - second parameter shows how many character should be takken\\n                    string tempPalindrome = s.substr(left, right - left + 1);\\n                    // Create reversed string from substring. rbegin() - reverse iterator and indicates to last character, rend() - indicates to first.\\n                    string reversed(tempPalindrome.rbegin(), tempPalindrome.rend());\\n                    // If substring and reversed string of substring is equal - substring is a polindome\\n                    if(tempPalindrome == reversed)\\n                    {\\n                        palindrome = tempPalindrome;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        // If Palindromes haven\\'t found yet - return first character\\n        if(palindrome.length() == 0) { palindrome = s[0]; }\\n        return palindrome;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 753169,
                "title": "evolve-from-brute-force-to-dp",
                "content": "1. Brute force O(n^3). Iterate from long substring to short substring and terminate on first palindrome. For length i, the start index includes until n-i. Ex, for length n, we start at 0.\\n```\\n\\tpublic String longestPalindrome(String s) {\\n        int n=s.length();\\n        for(int i=n;i>0;i--) \\n\\t\\t\\tfor(int j=0;j<=n-i;j++) \\n\\t\\t\\t\\tif(isPal(j,i+j-1,s)) \\n\\t\\t\\t\\t\\treturn s.substring(j,j+i); \\n        return \"\";\\n    }\\n    private boolean isPal(int i, int j, String s) {\\n        if(i>=j) return true;\\n        return s.charAt(i)==s.charAt(j)&&isPal(i+1,j-1,s);\\n    }\\n```\\n2. Memoization O(n^2). There are n^2 substrings. It takes O(n^2) for isPal() to check palindrome and cache it for all substrings. mem[][] should be filled in the middle of the for loop. Then isPal becomes constant. There are n^2 calls to isPal.\\n```\\n\\tpublic String longestPalindrome(String s) {\\n        int n=s.length();\\n        Boolean[][] mem=new Boolean[n][n];\\n        for(int i=n;i>0;i--) for(int j=0;j<=n-i;j++) if(isPal(j,i+j-1,s,mem)) return s.substring(j,j+i); \\n        return \"\";\\n    }\\n    private boolean isPal(int i, int j, String s, Boolean[][] mem) {\\n        if(i>=j) return true;\\n        if(mem[i][j]!=null) return mem[i][j];\\n        return mem[i][j]=s.charAt(i)==s.charAt(j)&&isPal(i+1,j-1,s,mem);\\n    }\\n```\\n3. dp O(n^2)\\n```\\n\\tpublic String longestPalindrome(String s) {\\n        int n=s.length(),len=1,start=0;\\n        boolean[][] isPal=new boolean[n][n];\\n        for(int i=0;i<n;i++) isPal[i][i]=true;\\n        for(int l=2;l<=n;l++) \\n            for(int i=0;i<=n-l;i++) {\\n                int j=i+l-1;\\n                isPal[i][j]=s.charAt(i)==s.charAt(j)&&(l<3||isPal[i+1][j-1]); \\n                if(l>len&&isPal[i][j]) {\\n                    len=l;\\n                    start=i;\\n                }\\n            }\\n        return s.substring(start,start+len);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n\\tpublic String longestPalindrome(String s) {\\n        int n=s.length();\\n        for(int i=n;i>0;i--) \\n\\t\\t\\tfor(int j=0;j<=n-i;j++) \\n\\t\\t\\t\\tif(isPal(j,i+j-1,s)) \\n\\t\\t\\t\\t\\treturn s.substring(j,j+i); \\n        return \"\";\\n    }\\n    private boolean isPal(int i, int j, String s) {\\n        if(i>=j) return true;\\n        return s.charAt(i)==s.charAt(j)&&isPal(i+1,j-1,s);\\n    }\\n```\n```\\n\\tpublic String longestPalindrome(String s) {\\n        int n=s.length();\\n        Boolean[][] mem=new Boolean[n][n];\\n        for(int i=n;i>0;i--) for(int j=0;j<=n-i;j++) if(isPal(j,i+j-1,s,mem)) return s.substring(j,j+i); \\n        return \"\";\\n    }\\n    private boolean isPal(int i, int j, String s, Boolean[][] mem) {\\n        if(i>=j) return true;\\n        if(mem[i][j]!=null) return mem[i][j];\\n        return mem[i][j]=s.charAt(i)==s.charAt(j)&&isPal(i+1,j-1,s,mem);\\n    }\\n```\n```\\n\\tpublic String longestPalindrome(String s) {\\n        int n=s.length(),len=1,start=0;\\n        boolean[][] isPal=new boolean[n][n];\\n        for(int i=0;i<n;i++) isPal[i][i]=true;\\n        for(int l=2;l<=n;l++) \\n            for(int i=0;i<=n-l;i++) {\\n                int j=i+l-1;\\n                isPal[i][j]=s.charAt(i)==s.charAt(j)&&(l<3||isPal[i+1][j-1]); \\n                if(l>len&&isPal[i][j]) {\\n                    len=l;\\n                    start=i;\\n                }\\n            }\\n        return s.substring(start,start+len);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 614215,
                "title": "0ms-solution-in-go",
                "content": "```\\nfunc longestPalindrome(s string) string {\\n\\tll := len(s)\\n\\tif ll == 0 {\\n\\t\\treturn \"\"\\n\\t}\\n\\n\\tvar l, r, pl, pr int\\n\\tfor r < ll {\\n\\t\\t// gobble up dup chars\\n\\t\\tfor r+1 < ll && s[l] == s[r+1] {\\n\\t\\t\\tr++\\n\\t\\t}\\n\\t\\t// find size of this palindrome\\n\\t\\tfor l-1 >= 0 && r+1 < ll && s[l-1] == s[r+1] {\\n\\t\\t\\tl--\\n\\t\\t\\tr++\\n\\t\\t}\\n\\t\\tif r-l > pr-pl {\\n\\t\\t\\tpl, pr = l, r\\n\\t\\t}\\n\\t\\t// reset to next mid point\\n\\t\\tl = (l+r)/2 + 1\\n\\t\\tr = l\\n\\t}\\n\\treturn s[pl : pr+1]\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc longestPalindrome(s string) string {\\n\\tll := len(s)\\n\\tif ll == 0 {\\n\\t\\treturn \"\"\\n\\t}\\n\\n\\tvar l, r, pl, pr int\\n\\tfor r < ll {\\n\\t\\t// gobble up dup chars\\n\\t\\tfor r+1 < ll && s[l] == s[r+1] {\\n\\t\\t\\tr++\\n\\t\\t}\\n\\t\\t// find size of this palindrome\\n\\t\\tfor l-1 >= 0 && r+1 < ll && s[l-1] == s[r+1] {\\n\\t\\t\\tl--\\n\\t\\t\\tr++\\n\\t\\t}\\n\\t\\tif r-l > pr-pl {\\n\\t\\t\\tpl, pr = l, r\\n\\t\\t}\\n\\t\\t// reset to next mid point\\n\\t\\tl = (l+r)/2 + 1\\n\\t\\tr = l\\n\\t}\\n\\treturn s[pl : pr+1]\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 571191,
                "title": "javascript-98-faster",
                "content": "## Solution 1\\n```javascript\\nvar longestPalindrome = function(s) {\\n    let maxSub = \\'\\';\\n    \\n    const bubbleFromCenter = (left, right) => {\\n        while(left >= 0 && right < s.length && s[left] === s[right]) {\\n            left--;\\n            right++;\\n        }\\n        return s.slice(left+1, right)\\n    }\\n    \\n    for(let i = 0; i < s.length; i++) {\\n        const sub1 = bubbleFromCenter(i, i);\\n        const sub2 = bubbleFromCenter(i, i+1);\\n        const sub = sub1.length > sub2.length ? sub1 : sub2\\n        if(sub.length > maxSub.length) {\\n            maxSub = sub\\n        }\\n    }\\n    return maxSub\\n};\\n```\\n\\n## Solution 2: Cleaned up\\n```javascript\\nvar longestPalindrome = function(s) {\\n    let maxPal = \\'\\';\\n    \\n    for(let i = 0; i < s.length; i++) {\\n        bubble(i, i); // odd palindrome\\n        bubble(i, i+1); // even palindrome\\n    }\\n    \\n    function bubble(left, right) {\\n\\n        while(left >= 0 && s[left] === s[right]) {\\n            left--;\\n            right++;\\n        }\\n        left++;\\n        right--;\\n        \\n        if(maxPal.length < right-left+1) {\\n            maxPal = s.slice(left, right+1)\\n        }\\n    }\\n    return maxPal;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nvar longestPalindrome = function(s) {\\n    let maxSub = \\'\\';\\n    \\n    const bubbleFromCenter = (left, right) => {\\n        while(left >= 0 && right < s.length && s[left] === s[right]) {\\n            left--;\\n            right++;\\n        }\\n        return s.slice(left+1, right)\\n    }\\n    \\n    for(let i = 0; i < s.length; i++) {\\n        const sub1 = bubbleFromCenter(i, i);\\n        const sub2 = bubbleFromCenter(i, i+1);\\n        const sub = sub1.length > sub2.length ? sub1 : sub2\\n        if(sub.length > maxSub.length) {\\n            maxSub = sub\\n        }\\n    }\\n    return maxSub\\n};\\n```\n```javascript\\nvar longestPalindrome = function(s) {\\n    let maxPal = \\'\\';\\n    \\n    for(let i = 0; i < s.length; i++) {\\n        bubble(i, i); // odd palindrome\\n        bubble(i, i+1); // even palindrome\\n    }\\n    \\n    function bubble(left, right) {\\n\\n        while(left >= 0 && s[left] === s[right]) {\\n            left--;\\n            right++;\\n        }\\n        left++;\\n        right--;\\n        \\n        if(maxPal.length < right-left+1) {\\n            maxPal = s.slice(left, right+1)\\n        }\\n    }\\n    return maxPal;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 309720,
                "title": "python-dp",
                "content": "```\\nclass Solution(object):\\n    def longestPalindrome(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: str\\n        \"\"\"\\n        if not s or len(s) == 0:\\n            return \\'\\'\\n        \\n        n = len(s)\\n        dp = [[False for i in range(n)] for j in range(n)]\\n        for i in range(n):\\n            dp[i][i] = True\\n        ans = s[0:1]\\n        for i in range(n):\\n            for j in range(i-1, -1, -1):\\n                if s[i] == s[j] and (i-j<2 or dp[j+1][i-1]):\\n                    dp[j][i] = True\\n                    if i - j + 1 > len(ans):\\n                        ans = s[j:i+1]\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def longestPalindrome(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: str\\n        \"\"\"\\n        if not s or len(s) == 0:\\n            return \\'\\'\\n        \\n        n = len(s)\\n        dp = [[False for i in range(n)] for j in range(n)]\\n        for i in range(n):\\n            dp[i][i] = True\\n        ans = s[0:1]\\n        for i in range(n):\\n            for j in range(i-1, -1, -1):\\n                if s[i] == s[j] and (i-j<2 or dp[j+1][i-1]):\\n                    dp[j][i] = True\\n                    if i - j + 1 > len(ans):\\n                        ans = s[j:i+1]\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 157861,
                "title": "python3-dp-solution-with-lots-of-comments",
                "content": "Not the most efficient algorithm to this problem, but great for understanding dynamic programming concepts :)\\n`        \\n        # Edge case: Given empty string\\n       str_len = len(s)\\n\\t\\t\\t if str_len == 0:\\n            return \"\"\\n                \\n        # Initialize DP table (dimensions: str_len x str_len)\\n        memo = [[0 for i in range(str_len)] for j in range(str_len)]\\n        \\n        start = 0 # Starting index of the longest palindrome\\n        max_len = 1 # Length of the longest palindrome\\n        \\n        # Fill DP table for single char palindromes\\n        for i in range(str_len):\\n            memo[i][i] = True\\n            \\n        # Fill DP table for 2 char long palindromes\\n        for i in range(str_len - 1):\\n            j = i + 1\\n            if s[i] == s[j]:\\n                memo[i][j] = True\\n                start = i\\n                max_len = 2\\n            else:\\n                memo[i][j] = False\\n        \\n        \\n        # Fill DP table for palindromes of every other length\\n        # starting from 3\\n        length = 3\\n        while length <= str_len:\\n            for i in range(str_len - 2):\\n                j = i + (length - 1)\\n                if j < str_len: # if calculated j is a valid value\\n                    if s[i] == s[j] and memo[i+1][j-1]:\\n                        memo[i][j] = True\\n                        start = i\\n                        max_len = length\\n                    else:\\n                        memo[i][j] = False\\n            length += 1\\n        \\n        solution = s[start: start + max_len]\\n        \\n        return solution\\n`",
                "solutionTags": [],
                "code": "Not the most efficient algorithm to this problem, but great for understanding dynamic programming concepts :)\\n`        \\n        # Edge case: Given empty string\\n       str_len = len(s)\\n\\t\\t\\t if str_len == 0:\\n            return \"\"\\n                \\n        # Initialize DP table (dimensions: str_len x str_len)\\n        memo = [[0 for i in range(str_len)] for j in range(str_len)]\\n        \\n        start = 0 # Starting index of the longest palindrome\\n        max_len = 1 # Length of the longest palindrome\\n        \\n        # Fill DP table for single char palindromes\\n        for i in range(str_len):\\n            memo[i][i] = True\\n            \\n        # Fill DP table for 2 char long palindromes\\n        for i in range(str_len - 1):\\n            j = i + 1\\n            if s[i] == s[j]:\\n                memo[i][j] = True\\n                start = i\\n                max_len = 2\\n            else:\\n                memo[i][j] = False\\n        \\n        \\n        # Fill DP table for palindromes of every other length\\n        # starting from 3\\n        length = 3\\n        while length <= str_len:\\n            for i in range(str_len - 2):\\n                j = i + (length - 1)\\n                if j < str_len: # if calculated j is a valid value\\n                    if s[i] == s[j] and memo[i+1][j-1]:\\n                        memo[i][j] = True\\n                        start = i\\n                        max_len = length\\n                    else:\\n                        memo[i][j] = False\\n            length += 1\\n        \\n        solution = s[start: start + max_len]\\n        \\n        return solution\\n`",
                "codeTag": "Unknown"
            },
            {
                "id": 3109163,
                "title": "easily-understandable-solution-beats-90-83",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n   \\npublic:\\n    string longestPalindrome(string s) {\\n         if(s.length()<=1){\\n        return s;\\n    }\\n        int max_length=1;\\n        int n=s.length();\\n        int st=0, en=0;\\n        for(int i=0;i<n-1;i++){\\n            int l=i ,r=i;\\n            while(l>=0 && r<n){\\n                if(s[l]==s[r]){\\n                    l--;r++;\\n                }else{break;}\\n                    \\n            }\\n            int len=r-l-1;\\n            if(len>max_length){\\n                max_length=len;\\n                st=l+1;\\n                en=r-1;   \\n            }\\n        }\\n        for(int i=0;i<n-1;i++){\\n            int l=i ,r=i+1;\\n            while(l>=0 && r<n){\\n                if(s[l]==s[r]){\\n                    l--;r++;\\n                }else{break;}\\n                    \\n            }\\n            int len=r-l-1;\\n            if(len>max_length){\\n                max_length=len;\\n                st=l+1;\\n                en=r-1;            \\n            }\\n        }\\n        cout<<st<<\" \"<<en<<\" \"<<max_length;\\n        return s.substr(st,max_length);\\n    }\\n};\\n```\\nPlease upvote to motivate me to write more solutions",
                "solutionTags": [
                    "C++",
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n   \\npublic:\\n    string longestPalindrome(string s) {\\n         if(s.length()<=1){\\n        return s;\\n    }\\n        int max_length=1;\\n        int n=s.length();\\n        int st=0, en=0;\\n        for(int i=0;i<n-1;i++){\\n            int l=i ,r=i;\\n            while(l>=0 && r<n){\\n                if(s[l]==s[r]){\\n                    l--;r++;\\n                }else{break;}\\n                    \\n            }\\n            int len=r-l-1;\\n            if(len>max_length){\\n                max_length=len;\\n                st=l+1;\\n                en=r-1;   \\n            }\\n        }\\n        for(int i=0;i<n-1;i++){\\n            int l=i ,r=i+1;\\n            while(l>=0 && r<n){\\n                if(s[l]==s[r]){\\n                    l--;r++;\\n                }else{break;}\\n                    \\n            }\\n            int len=r-l-1;\\n            if(len>max_length){\\n                max_length=len;\\n                st=l+1;\\n                en=r-1;            \\n            }\\n        }\\n        cout<<st<<\" \"<<en<<\" \"<<max_length;\\n        return s.substr(st,max_length);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1566634,
                "title": "ruby-solution-that-times-out-but-i-don-t-care",
                "content": "Heres my solution. It times out but more and more I believe leetcode is just not for ruby. The only ruby solution I saw on here that passes is so unreadable it makes my eyebsalls bleed which, I feel, defeats the purpose of using ruby.\\n```\\ndef longest_palindrome(s)\\n    return s if palindrome?(s)\\n    \\n    s.size.downto(1).each do |x|\\n        (0..s.size-x).each do |q|\\n            str = s[q..q+x-1]\\n            return str if palindrome?(str)\\n        end\\n    end    \\nend\\n\\ndef palindrome?(s)\\n    return s.reverse == s\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\ndef longest_palindrome(s)\\n    return s if palindrome?(s)\\n    \\n    s.size.downto(1).each do |x|\\n        (0..s.size-x).each do |q|\\n            str = s[q..q+x-1]\\n            return str if palindrome?(str)\\n        end\\n    end    \\nend\\n\\ndef palindrome?(s)\\n    return s.reverse == s\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1338509,
                "title": "python-two-pointer-easy2understand-solution",
                "content": "\\n    def longestPalindrome(self, s: str) -> str:\\n        # init res\\n        res = \"\"\\n        \\n        for i in range(len(s)):\\n            \\n            # odd -> helper, update\\n            tmp = self.helper(i, i, s)\\n            if len(res) < len(tmp):\\n                res = tmp\\n                \\n            # even -> helper, update\\n            tmp = self.helper(i, i + 1, s)\\n            if len(res) < len(tmp):\\n                res = tmp\\n        \\n        # return res\\n        return res\\n        \\n    def helper(self, l, r, s):\\n        \\n        # if inbound and palindrome, move left left and right right\\n        while (l >= 0 and r < len(s) and s[l] == s[r]):\\n            l -= 1\\n            r += 1\\n            \\n        # return \\n        return s[l + 1: r]",
                "solutionTags": [
                    "Python",
                    "Two Pointers"
                ],
                "code": "\\n    def longestPalindrome(self, s: str) -> str:\\n        # init res\\n        res = \"\"\\n        \\n        for i in range(len(s)):\\n            \\n            # odd -> helper, update\\n            tmp = self.helper(i, i, s)\\n            if len(res) < len(tmp):\\n                res = tmp\\n                \\n            # even -> helper, update\\n            tmp = self.helper(i, i + 1, s)\\n            if len(res) < len(tmp):\\n                res = tmp\\n        \\n        # return res\\n        return res\\n        \\n    def helper(self, l, r, s):\\n        \\n        # if inbound and palindrome, move left left and right right\\n        while (l >= 0 and r < len(s) and s[l] == s[r]):\\n            l -= 1\\n            r += 1\\n            \\n        # return \\n        return s[l + 1: r]",
                "codeTag": "Python3"
            },
            {
                "id": 1177813,
                "title": "python-solution",
                "content": "```\\n\\ttemp = \\'\\'\\n\\tmaxp = \\'\\'\\n\\n\\tfor i in range(len(s)):\\n\\t\\ttemp += s[i]\\n\\t\\tfor j in range(len(temp)):\\n\\t\\t\\tif temp[j] == s[i] and s[j:i+1] == s[j:i+1][::-1] and len(s[j:i+1]) > len(maxp):\\n\\t\\t\\t\\tmaxp = s[j:i+1]\\n\\t\\t\\t\\tbreak\\n\\n\\treturn maxp\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n\\ttemp = \\'\\'\\n\\tmaxp = \\'\\'\\n\\n\\tfor i in range(len(s)):\\n\\t\\ttemp += s[i]\\n\\t\\tfor j in range(len(temp)):\\n\\t\\t\\tif temp[j] == s[i] and s[j:i+1] == s[j:i+1][::-1] and len(s[j:i+1]) > len(maxp):\\n\\t\\t\\t\\tmaxp = s[j:i+1]\\n\\t\\t\\t\\tbreak\\n\\n\\treturn maxp\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 291864,
                "title": "js-solution",
                "content": "Leetcode - Longest palindromic substring\\n(1) for each 1 unit or 2 units, we expand\\n(2) we judge whether the expanded two chars are the same\\n(3) if the expanded chars are the same, we expand again\\n(4) else we calculate the length by (right - left - 1), and compare it with the current max\\n\\n```\\n\\n\\nvar longestPalindrome = function(s) {\\n    var str = \\'\\';\\n    for (let i = 0; i < s.length; i++) {\\n        for (let j = 0; j < 2; j++) {\\n            var left = i;\\n            var right = left + j;\\n            while (s[left] && s[left] === s[right]) {\\n                left--;\\n                right++;\\n            }\\n            if (right - left - 1 > str.length) {\\n                str = s.slice(left + 1, right);\\n            }\\n        }\\n    }\\n    return str;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\n\\nvar longestPalindrome = function(s) {\\n    var str = \\'\\';\\n    for (let i = 0; i < s.length; i++) {\\n        for (let j = 0; j < 2; j++) {\\n            var left = i;\\n            var right = left + j;\\n            while (s[left] && s[left] === s[right]) {\\n                left--;\\n                right++;\\n            }\\n            if (right - left - 1 > str.length) {\\n                str = s.slice(left + 1, right);\\n            }\\n        }\\n    }\\n    return str;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2781660,
                "title": "two-pointer-approach-java-solution",
                "content": "```\\nclass Solution {\\n    public String longestPalindrome(String s) {\\n        //Approach : treat each character as mid of the palindromic string and check if its left and right character are same or not if they are same then decrement left and increment right and after checking it for each charater determine maximum length which is maximum length of palindromic string \\n        // To get palindromic substring return substring from start to start + maximum length\\n        int n = s.length();\\n        if(n <= 1) return s;\\n        int maxLen = 1;\\n        int start = 0;\\n        //for odd length \\n        for(int i=0;i<n;i++){\\n            int l = i;\\n            int r = i;\\n            while(l >= 0 && r < n && s.charAt(l) == s.charAt(r)){\\n                l--;\\n                r++;\\n            }\\n            int len = r-l-1;\\n            if(len > maxLen){\\n                maxLen = len;\\n                start = l+1;\\n            }\\n        }\\n        //for Even length \\n        for(int i=0;i<n;i++){\\n            int l = i;\\n            int r = i+1;\\n            while(l >= 0 && r<n && s.charAt(l) == s.charAt(r)){\\n                l--;\\n                r++;\\n            }\\n            int len = r-l-1;\\n            if(len > maxLen){\\n                maxLen = len;\\n                start = l+1;\\n            }\\n        }\\n        return s.substring(start,start+maxLen);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String longestPalindrome(String s) {\\n        //Approach : treat each character as mid of the palindromic string and check if its left and right character are same or not if they are same then decrement left and increment right and after checking it for each charater determine maximum length which is maximum length of palindromic string \\n        // To get palindromic substring return substring from start to start + maximum length\\n        int n = s.length();\\n        if(n <= 1) return s;\\n        int maxLen = 1;\\n        int start = 0;\\n        //for odd length \\n        for(int i=0;i<n;i++){\\n            int l = i;\\n            int r = i;\\n            while(l >= 0 && r < n && s.charAt(l) == s.charAt(r)){\\n                l--;\\n                r++;\\n            }\\n            int len = r-l-1;\\n            if(len > maxLen){\\n                maxLen = len;\\n                start = l+1;\\n            }\\n        }\\n        //for Even length \\n        for(int i=0;i<n;i++){\\n            int l = i;\\n            int r = i+1;\\n            while(l >= 0 && r<n && s.charAt(l) == s.charAt(r)){\\n                l--;\\n                r++;\\n            }\\n            int len = r-l-1;\\n            if(len > maxLen){\\n                maxLen = len;\\n                start = l+1;\\n            }\\n        }\\n        return s.substring(start,start+maxLen);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2157058,
                "title": "c-easy-to-understand-explained-have-a-look",
                "content": "**Dekho for every possible substring we will check for the pallindrome and the largest substring will be our ans...**\\n\\n\\nclass Solution {\\npublic:\\n      \\n\\t  // dp vector for memoization\\n      vector<vector<int>>dp;\\n    \\n\\t//function to check for pallindrome\\n    int ispalli(string &s,int i,int j)\\n    {\\n      if(i>=j)\\n      {\\n          return 1;\\n      }\\n        if(dp[i][j]!=-1)\\n        {\\n            return dp[i][j];\\n        }\\n        if(s[i]==s[j])\\n        {\\n            return dp[i][j]=ispalli(s,i+1,j-1);\\n        }\\n        return dp[i][j]= 0;\\n    }\\n    string longestPalindrome(string  s) {\\n        int n=s.length();\\n        int mx=0;\\n        string ans; // storing ans\\n\\t\\t//resizing our dp\\n        dp.resize(n,vector<int>(n,-1));\\n        for(int i=0;i<n;++i)\\n        {\\n            for(int j=i;j<n;++j)\\n            { \\n\\t\\t\\t//if string from i to j is  a pallindrome and its length is max so then just store it as ans\\n\\t\\t\\t\\n                if(ispalli(s,i,j))\\n                {\\n                    if(j-i+1>mx)\\n                    {\\n                        mx=j-i+1;\\n                        ans=s.substr(i,j-i+1);\\n                    }\\n                }\\n            }\\n        }\\n        return ans; //just return the ans\\n    }\\n};\\n**Kindly Upvote if it helped**",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n      \\n\\t  // dp vector for memoization\\n      vector<vector<int>>dp;\\n    \\n\\t//function to check for pallindrome\\n    int ispalli(string &s,int i,int j)\\n    {\\n      if(i>=j)\\n      {\\n          return 1;\\n      }",
                "codeTag": "Java"
            },
            {
                "id": 1596345,
                "title": "c-solution-from-center-to-outwards",
                "content": "```\\npublic class Solution {\\n    public string LongestPalindrome(string s) {\\n        if(s==\"\" || s.Length<=1)\\n            return s;\\n        int length = 0, start = 0;\\n        for(int i=0; i<s.Length; i++)\\n        {\\n            int evenLength = PalindromeLength(s, i, i+1);\\n            int oddLength = PalindromeLength(s, i, i);\\n            int currentLength = Math.Max(evenLength, oddLength);\\n            \\n            if(currentLength>length)\\n            {\\n                length = currentLength;\\n                start = i-(length-1)/2;\\n            }\\n        }\\n        \\n        return s.Substring(start, length);\\n    }\\n    \\n    private int PalindromeLength(string s, int left, int right){\\n        while(left>=0 && right<s.Length && s[left] == s[right])\\n        {\\n            left--;\\n            right++;\\n        }\\n        return right-left-1; // (right+1) - (left-1) - 1\\n    }\\n}\\n```\\n\\nRuntime: 88 ms, faster than 89.71% of C# online submissions for Longest Palindromic Substring.\\nMemory Usage: 37.4 MB, less than 47.93% of C# online submissions for Longest Palindromic Substring.",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public string LongestPalindrome(string s) {\\n        if(s==\"\" || s.Length<=1)\\n            return s;\\n        int length = 0, start = 0;\\n        for(int i=0; i<s.Length; i++)\\n        {\\n            int evenLength = PalindromeLength(s, i, i+1);\\n            int oddLength = PalindromeLength(s, i, i);\\n            int currentLength = Math.Max(evenLength, oddLength);\\n            \\n            if(currentLength>length)\\n            {\\n                length = currentLength;\\n                start = i-(length-1)/2;\\n            }\\n        }\\n        \\n        return s.Substring(start, length);\\n    }\\n    \\n    private int PalindromeLength(string s, int left, int right){\\n        while(left>=0 && right<s.Length && s[left] == s[right])\\n        {\\n            left--;\\n            right++;\\n        }\\n        return right-left-1; // (right+1) - (left-1) - 1\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 915789,
                "title": "dp-java-easy-to-understand-explain-with-visualization-and-share-my-notes",
                "content": "I don\\'t think the explaination in the solution is easy to understand so I created this graph. I\\'m using **Approach 3: Dynamic Programming** in the solution board btw. Hope this helps you understand the approach and my code below.\\n\\nOnly those in pink are from `dp[i][j] = dp[i+1][j-1]`. Others are corner cases that we need to consider (which makes it hard since there are SO MANY).\\n\\n![image](https://assets.leetcode.com/users/images/09d6ade5-323a-4bef-abad-444cf5b7640b_1604022898.182215.png)\\n\\n\\n```\\nclass Solution {\\n    public String longestPalindrome(String s) {\\n        int n = s.length();\\n        if (n < 2) return s;\\n            \\n        int maxLength = 1;\\n        int start = 0;\\n        char[] charArray = s.toCharArray();\\n        boolean[][] dp = new boolean[n][n];\\n        \\n        for (int i = 0; i < n; i++) {\\n            dp[i][i] = true;\\n        }\\n        \\n        for (int j = 1; j < n; j++) {\\n            for (int i = 0; i < j; i++) {\\n                if (charArray[i] == charArray[j]) {\\n                    if (j - i < 3) {\\n                        dp[i][j] = true;\\n                    } else {\\n                        dp[i][j] = dp[i+1][j-1];\\n                    }\\n                } else {\\n                    dp[i][j] = false;\\n                }\\n                \\n                if (dp[i][j]) {\\n                    if (maxLength < j-i+1) {\\n                        maxLength = j-i+1;\\n                        start = i;\\n                    }\\n                }\\n            }\\n\\n        }\\n        return s.substring(start, start+maxLength);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String longestPalindrome(String s) {\\n        int n = s.length();\\n        if (n < 2) return s;\\n            \\n        int maxLength = 1;\\n        int start = 0;\\n        char[] charArray = s.toCharArray();\\n        boolean[][] dp = new boolean[n][n];\\n        \\n        for (int i = 0; i < n; i++) {\\n            dp[i][i] = true;\\n        }\\n        \\n        for (int j = 1; j < n; j++) {\\n            for (int i = 0; i < j; i++) {\\n                if (charArray[i] == charArray[j]) {\\n                    if (j - i < 3) {\\n                        dp[i][j] = true;\\n                    } else {\\n                        dp[i][j] = dp[i+1][j-1];\\n                    }\\n                } else {\\n                    dp[i][j] = false;\\n                }\\n                \\n                if (dp[i][j]) {\\n                    if (maxLength < j-i+1) {\\n                        maxLength = j-i+1;\\n                        start = i;\\n                    }\\n                }\\n            }\\n\\n        }\\n        return s.substring(start, start+maxLength);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 476222,
                "title": "simple-c-solution-using-bottom-up-dp-detailed-explanation",
                "content": "```\\n/*\\n    https://leetcode.com/problems/longest-palindromic-substring/submissions/\\n    \\n    Using Tabular approach for finding all palindromic substrings. Then using that info\\n    find the longest palindrome.\\n    TC: O(N^2)\\n    SC: O(N^2)\\n*/\\nclass Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n        if(s.size() == 0)\\n            return \"\";\\n        \\n        const int N = s.size();\\n        // dp(i, j): indicates if string[i:j] is palindromic or not\\n        vector<vector<bool> > dp(N, vector<bool>(N, false));\\n        int max_len = 0, start = 0;\\n        \\n        // each single char is a palindrome\\n        for(int i = 0; i < N; i++)\\n            dp[i][i] = true;\\n        // A single character is always a palindrome,\\n        // so we take the first as the longest palindrome initially\\n        max_len = 1, start = 0;\\n        \\n        for(int l = 1; l < N; l++) {\\n            for(int i = 0; i < N - l; i++) {\\n                int j = i + l;\\n                // when there are only 2 chars, just check the first and last chars\\n                if(j - i + 1 == 2)\\n                    dp[i][j] = s[i] == s[j];\\n                else {\\n                    // current s[i:j] can only be palindromic iff\\n                    // first and last chars are same and the substring s[i+1:j-1]\\n                    // is also palindromic\\n                    dp[i][j] = (s[i] == s[j] && dp[i+1][j-1]) == true;\\n                }\\n                // update max length\\n                if(dp[i][j] && (j - i + 1) > max_len) \\n                    max_len = j - i + 1, start = i;\\n            }\\n        }\\n        \\n        return s.substr(start, max_len);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n/*\\n    https://leetcode.com/problems/longest-palindromic-substring/submissions/\\n    \\n    Using Tabular approach for finding all palindromic substrings. Then using that info\\n    find the longest palindrome.\\n    TC: O(N^2)\\n    SC: O(N^2)\\n*/\\nclass Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n        if(s.size() == 0)\\n            return \"\";\\n        \\n        const int N = s.size();\\n        // dp(i, j): indicates if string[i:j] is palindromic or not\\n        vector<vector<bool> > dp(N, vector<bool>(N, false));\\n        int max_len = 0, start = 0;\\n        \\n        // each single char is a palindrome\\n        for(int i = 0; i < N; i++)\\n            dp[i][i] = true;\\n        // A single character is always a palindrome,\\n        // so we take the first as the longest palindrome initially\\n        max_len = 1, start = 0;\\n        \\n        for(int l = 1; l < N; l++) {\\n            for(int i = 0; i < N - l; i++) {\\n                int j = i + l;\\n                // when there are only 2 chars, just check the first and last chars\\n                if(j - i + 1 == 2)\\n                    dp[i][j] = s[i] == s[j];\\n                else {\\n                    // current s[i:j] can only be palindromic iff\\n                    // first and last chars are same and the substring s[i+1:j-1]\\n                    // is also palindromic\\n                    dp[i][j] = (s[i] == s[j] && dp[i+1][j-1]) == true;\\n                }\\n                // update max length\\n                if(dp[i][j] && (j - i + 1) > max_len) \\n                    max_len = j - i + 1, start = i;\\n            }\\n        }\\n        \\n        return s.substr(start, max_len);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 467258,
                "title": "straight-forward-solution-with-slice-windows",
                "content": "Not the fastest at 52ms but low memory profile 1.9Mb.\\n```\\n    pub fn longest_palindrome(s: String) -> String {\\n        let mut window_size = s.len();\\n        while window_size > 0 {\\n             match s.as_bytes()\\n                    .windows(window_size)\\n                    .find(|slice| { let iter = slice.iter();\\n                                        iter.clone().eq(iter.clone().rev()) // cloning iterators is cheap\\n                                }\\n                        ) {\\n                             Some(slice) => return String::from_utf8(slice.to_vec()).unwrap_or(\"\".to_string()),\\n                             None => window_size -= 1, // if no slice window of this size is a palindrome, try the next smallest window size\\n                        }\\n        }\\n        \"\".to_string() // if no slice is found or if len was zero, return empty string\\n    }\\n\\t```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\n    pub fn longest_palindrome(s: String) -> String {\\n        let mut window_size = s.len();\\n        while window_size > 0 {\\n             match s.as_bytes()\\n                    .windows(window_size)\\n                    .find(|slice| { let iter = slice.iter();\\n                                        iter.clone().eq(iter.clone().rev()) // cloning iterators is cheap\\n                                }\\n                        ) {\\n                             Some(slice) => return String::from_utf8(slice.to_vec()).unwrap_or(\"\".to_string()),\\n                             None => window_size -= 1, // if no slice window of this size is a palindrome, try the next smallest window size\\n                        }\\n        }\\n        \"\".to_string() // if no slice is found or if len was zero, return empty string\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 368409,
                "title": "solution-in-python-3-six-lines-o-n-2-speed-o-1-space-with-explanation-beats-90",
                "content": "_Explanation:_\\n\\nThis method uses an expand around center approach. The program iterates through each central point of a potential palindrome. moving left to right in the original input string. It then expands outward (left and right) from the center point and checks if the two characters match. This is done by moving _a_ to the left by one and moving _b_ to the right by one. It keeps doing this until they don\\'t match (i.e. ```s[a] == s[b]``` fails to be true) or either end of the input string is reached. This expansion of the palindrome from its center outward occurs inside of the while loop. Once the while loop exits, we have expanded as far as we could and the length of the palindrome is equal to (b - a - 1). The length of this palindrome is then compared to the current maximum length achieved, stored in M. If it is longer than M, (b - a - 1) becomes the new M (i.e. M = b - a - 1) and the leftmost index of this longest palindrome is stored in x (i.e. x = a + 1).\\n\\nPerhaps the most important (and most challenging) part of the program occurs in the structure of the inner for loop: ```for a,b in [(i,i),(i,i+1)]``` This part may take a little explanation to fully understand. A palindrome can be centered in one of two places. The palindrome _dad_ is centered on one of its letters, specifcally the letter _a_. If you had to pick two indices to describe where the palindrome _dad_ is centered you would say that it was centered at the indices 1 and 1, since 1 is the index of _a_. In general such palindromes (palindromes with an odd number of elements) are centered at (_i_,_i_) for some index _i_. The other type of palindrome, _abba_ is centered in between two identical letters, specifcally it is centered between the letters _b_ and _b_. If you had to pick two indices to describe where the palindrome _abba_ is centered you would say that it was centered at the indices 1 and 2, since 1 and 2 are the indices of the central two _b_\\'s. In general such palindromes (palindromes with an even number of elements) are centered at (_i_,_i+1_) for some index _i_. To correctly look at all the palindrome substrings, for each index _i_ in the for loop we have to consider both centeral pivoting points. This is why the inner for loop iterates through both (_i_,_i_) and (_i_,_i+1_).\\n\\nThe program ends by returning the longest palindrome. This is done by splicing it based on the leftmost index (i.e.  x) of where the palindrome starts and the maximum recorded length (i.e. M).\\n\\n_Glossary of Variables:_\\nL = length of original input string\\nM = length of current longest palindromic substring\\nx = leftmost (starting) index of current longest palindromic substring\\na = number of units left of center of palindrome\\nb = number of units right of center of palindrome\\n```\\nclass Solution:\\n    def longestPalindrome(self, s: str) -> str:\\n\\t    L, M, x = len(s), 0, 0\\n\\t    for i in range(L):\\n\\t    \\tfor a,b in [(i,i),(i,i+1)]:\\n\\t    \\t\\twhile a >= 0 and b < L and s[a] == s[b]: a -= 1; b += 1\\n\\t    \\t\\tif b - a - 1 > M: M, x = b - a - 1, a + 1\\n\\t    return s[x:x+M]\\n\\t\\t\\n\\n- Junaid Mansuri\\n(LeetCode ID)@hotmail.com",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```s[a] == s[b]```\n```for a,b in [(i,i),(i,i+1)]```",
                "codeTag": "Unknown"
            },
            {
                "id": 174086,
                "title": "swift-solution-100-passed",
                "content": "We iterate over the string and use two pointers from the leftmost to the rightmost. Both pointers move further inward and comparisons occur. Currently the method below does every combination possible and determines if the current string index is a palindrome. If so, we store the inital place of the palindrome as well as the end. If not a palindrome, we clear the temp and continue the loop.  \\n\\n```\\n\\nclass Solution {\\n    func longestPalindrome(_ s: String) -> String {\\n\\t\\t\\n    /*If Empty or equal to one we return*/\\n        if(s.count == 0){return \"\"} \\n        if(s.count == 1){return s}\\n\\t\\t\\t\\t\\n\\t/*Start and End represent the palindrome with the longest length. */\\n        var start = 0, end = start, stringArray = Array(s), max = 0\\n\\t\\t\\t\\t\\n        for i in 0..<s.count{\\n\\t\\t\\t\\t\\n\\t/*Left and Right  pointers move inward (Sandwich principle).*/\\n            var left = i, right = s.count-1, tempStart = left, tempEnd = right\\n\\t\\t\\t\\t\\t\\t\\n            while(left<right){\\n\\t/*If values at the Left and Right index are equal then we temporarily store index if greater than max*/\\n                if(stringArray[left] == stringArray[right]){\\n                    if((right - left) > max){\\n                        max = (right - left)\\n                        tempStart = left\\n                        tempEnd = right\\n                    }\\n                    left+=1\\n                    right-=1\\n                }\\n                else{//Reset temp variables and the current max\\n                    left = i\\n                    right = tempEnd - 1\\n                    tempStart = left\\n                    tempEnd = right\\n                    max = 0\\n                }\\n            }\\n            if((tempEnd - tempStart) > (end - start)){//Store temp variables and continue loop\\n                end = tempEnd\\n                start = tempStart\\n            }\\n        }\\n        return (String(stringArray[start...end]).count > 1) ? String(stringArray[start...end]) : String(s.first!)\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\n    func longestPalindrome(_ s: String) -> String {\\n\\t\\t\\n    /*If Empty or equal to one we return*/\\n        if(s.count == 0){return \"\"} \\n        if(s.count == 1){return s}\\n\\t\\t\\t\\t\\n\\t/*Start and End represent the palindrome with the longest length. */\\n        var start = 0, end = start, stringArray = Array(s), max = 0\\n\\t\\t\\t\\t\\n        for i in 0..<s.count{\\n\\t\\t\\t\\t\\n\\t/*Left and Right  pointers move inward (Sandwich principle).*/\\n            var left = i, right = s.count-1, tempStart = left, tempEnd = right\\n\\t\\t\\t\\t\\t\\t\\n            while(left<right){\\n\\t/*If values at the Left and Right index are equal then we temporarily store index if greater than max*/\\n                if(stringArray[left] == stringArray[right]){\\n                    if((right - left) > max){\\n                        max = (right - left)\\n                        tempStart = left\\n                        tempEnd = right\\n                    }\\n                    left+=1\\n                    right-=1\\n                }\\n                else{//Reset temp variables and the current max\\n                    left = i\\n                    right = tempEnd - 1\\n                    tempStart = left\\n                    tempEnd = right\\n                    max = 0\\n                }\\n            }\\n            if((tempEnd - tempStart) > (end - start)){//Store temp variables and continue loop\\n                end = tempEnd\\n                start = tempStart\\n            }\\n        }\\n        return (String(stringArray[start...end]).count > 1) ? String(stringArray[start...end]) : String(s.first!)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3216,
                "title": "sharing-my-8ms-c-solution",
                "content": "    class Solution {\\n    public:\\n        string longestPalindrome(string s) {\\n            int n = s.length(), i;\\n            if(n<2)\\n                return s;\\n                \\n            int leftMost=0, rightMost=0;\\n            i = 0;\\n            int start, end;\\n            while(i<n)\\n            {\\n                start = i;\\n                end = i;\\n                i++;\\n                while(i<n && s[i]==s[start])\\n                {\\n                    i++;\\n                }\\n                end = i-1;\\n                \\n                while(start-1>=0 && end+1<n && s[start-1]==s[end+1])\\n                {\\n                    start--;\\n                    end++;\\n                }\\n                \\n                if(rightMost-leftMost <= end-start)\\n                {\\n                    leftMost = start;\\n                    rightMost = end;\\n                }\\n            }\\n            \\n            return s.substr(leftMost, rightMost-leftMost+1);\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        string longestPalindrome(string s) {\\n            int n = s.length(), i;\\n            if(n<2)\\n                return s;\\n                \\n            int leftMost=0, rightMost=0;\\n            i = 0;\\n            int start, end;\\n            while(i<n)\\n            {\\n                start = i;\\n                end = i;\\n                i++;\\n                while(i<n && s[i]==s[start])\\n                {\\n                    i++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3225,
                "title": "be-careful-of-substring-function-java-o-n-2-may-got-tle",
                "content": "My TLE code:\\n\\n    public String longestPalindrome(String s) {\\n        if(s == null || s.length() <= 1) {\\n            return s;\\n        }\\n        int len = s.length();\\n        String subString = \"\";\\n        // palindrome[i][j] : substring(i,j) is palindrome or not?\\n        boolean[][] palindrome = new boolean[len][len];\\n        // calculate palindrome[][]\\n        for(int i=0;i<len;i++) {\\n            palindrome[i][i] = true;\\n        }\\n        for(int i=1;i<len;i++) {\\n            if(s.charAt(i-1) == s.charAt(i)) {\\n                palindrome[i-1][i] = true;\\n                subString = s.substring(i-1, i+1);\\n            }\\n        }\\n        for(int k=2;k<len;k++) {\\n            for(int i=0;i+k<len;i++) {\\n                int j = i+k;\\n                if(s.charAt(i) == s.charAt(j) && palindrome[i+1][j-1]) {\\n                    palindrome[i][j] = true;\\n                    subString = s.substring(i, j+1);\\n                }\\n            }\\n        }\\n        return subString;\\n    }\\n\\nI find that substring is time-consuming.\\nSo My Accepted code is here:\\n\\n    public String longestPalindrome(String s) {\\n        if(s == null || s.length() <= 1) {\\n            return s;\\n        }\\n        int len = s.length();\\n        int start = 0, end = 0;\\n        // palindrome[i][j] : substring(i,j) is palindrome or not?\\n        boolean[][] palindrome = new boolean[len][len];\\n        // length = 1\\n        for(int i=0;i<len;i++) {\\n            palindrome[i][i] = true;\\n        }\\n        // length = 2\\n        for(int i=1;i<len;i++) {\\n            if(s.charAt(i-1) == s.charAt(i)) {\\n                palindrome[i-1][i] = true;\\n                start = i-1; end = i+1;\\n            }\\n        }\\n        // length = k (k=2..len)\\n        for(int k=2;k<len;k++) {\\n            for(int i=0;i+k<len;i++) {\\n                int j = i+k;\\n                if(s.charAt(i) == s.charAt(j) && palindrome[i+1][j-1]) {\\n                    palindrome[i][j] = true;\\n                    start = i; end = j+1;\\n                }\\n            }\\n        }\\n        return s.substring(start, end);\\n    }\\n\\nI hope I can help you!",
                "solutionTags": [],
                "code": "My TLE code:\\n\\n    public String longestPalindrome(String s) {\\n        if(s == null || s.length() <= 1) {\\n            return s;\\n        }\\n        int len = s.length();\\n        String subString = \"\";\\n        // palindrome[i][j] : substring(i,j) is palindrome or not?\\n        boolean[][] palindrome = new boolean[len][len];\\n        // calculate palindrome[][]\\n        for(int i=0;i<len;i++) {\\n            palindrome[i][i] = true;\\n        }\\n        for(int i=1;i<len;i++) {\\n            if(s.charAt(i-1) == s.charAt(i)) {\\n                palindrome[i-1][i] = true;\\n                subString = s.substring(i-1, i+1);\\n            }\\n        }\\n        for(int k=2;k<len;k++) {\\n            for(int i=0;i+k<len;i++) {\\n                int j = i+k;\\n                if(s.charAt(i) == s.charAt(j) && palindrome[i+1][j-1]) {\\n                    palindrome[i][j] = true;\\n                    subString = s.substring(i, j+1);\\n                }\\n            }\\n        }\\n        return subString;\\n    }\\n\\nI find that substring is time-consuming.\\nSo My Accepted code is here:\\n\\n    public String longestPalindrome(String s) {\\n        if(s == null || s.length() <= 1) {\\n            return s;\\n        }\\n        int len = s.length();\\n        int start = 0, end = 0;\\n        // palindrome[i][j] : substring(i,j) is palindrome or not?\\n        boolean[][] palindrome = new boolean[len][len];\\n        // length = 1\\n        for(int i=0;i<len;i++) {\\n            palindrome[i][i] = true;\\n        }\\n        // length = 2\\n        for(int i=1;i<len;i++) {\\n            if(s.charAt(i-1) == s.charAt(i)) {\\n                palindrome[i-1][i] = true;\\n                start = i-1; end = i+1;\\n            }\\n        }\\n        // length = k (k=2..len)\\n        for(int k=2;k<len;k++) {\\n            for(int i=0;i+k<len;i++) {\\n                int j = i+k;\\n                if(s.charAt(i) == s.charAt(j) && palindrome[i+1][j-1]) {\\n                    palindrome[i][j] = true;\\n                    start = i; end = j+1;\\n                }\\n            }\\n        }\\n        return s.substring(start, end);\\n    }\\n\\nI hope I can help you!",
                "codeTag": "Unknown"
            },
            {
                "id": 3239,
                "title": "a-very-brief-o-n-time-o-1-space-solution-ac",
                "content": " suppose\\n       \\n      string(i,l) is a substring of s where i is the start index and l is the length \\n\\n      S(n) is the longest palindrome for substring of s with indice from 0 to n\\n\\nif S(n-1) = string(i,l)\\n\\nthen S(n) =\\n \\n1. string(n-l, l+1) if string(n-l, l+1) is palindrome\\n2. string(n-l-1, l+2) if string(n-l-1, l+2) is palindrome\\n3. S(n) otherwise\\n\\n\\n----------\\n\\n\\n        int i = 0;\\n        int l = 0;\\n        int n = s.length();\\n        for(int j=0;j<n;j++){\\n            if(isPalindrome(s, j-l, j)){\\n                i = j-l;\\n                l = l+1;\\n            }else if(j-l-1>=0 && isPalindrome(s, j-l-1, j)){\\n                i = j-l-1;\\n                l = l+2;\\n            }\\n        }\\n            \\n        return new String(s.getBytes(), i, l)\\n\\n\\n\\n      \\n\\n;",
                "solutionTags": [
                    "Java"
                ],
                "code": " suppose\\n       \\n      string(i,l) is a substring of s where i is the start index and l is the length \\n\\n      S(n) is the longest palindrome for substring of s with indice from 0 to n\\n\\nif S(n-1) = string(i,l)\\n\\nthen S(n) =\\n \\n1. string(n-l, l+1) if string(n-l, l+1) is palindrome\\n2. string(n-l-1, l+2) if string(n-l-1, l+2) is palindrome\\n3. S(n) otherwise\\n\\n\\n----------\\n\\n\\n        int i = 0;\\n        int l = 0;\\n        int n = s.length();\\n        for(int j=0;j<n;j++){\\n            if(isPalindrome(s, j-l, j)){\\n                i = j-l;\\n                l = l+1;\\n            }else if(j-l-1>=0 && isPalindrome(s, j-l-1, j)){\\n                i = j-l-1;\\n                l = l+2;\\n            }\\n        }\\n            \\n        return new String(s.getBytes(), i, l)\\n\\n\\n\\n      \\n\\n;",
                "codeTag": "Unknown"
            },
            {
                "id": 3852152,
                "title": "dp-lps-template-friendly",
                "content": "# Intuition\\n\\n\\n# Approach\\n- for a string s of length greater than 2 to be palindrome there are two conditons:\\n    1. s[start]=s[end]\\n    2. substring(start+1,end-1) should also be a palindrome\\n\\n- for example, string s=ababa\\ns[start]=a \\ns[end]=a\\nsubstring from start+1 to end-1 i.e. bab is also palindrome.\\nSo string s is plaindrome.\\n\\n- Create a 2d vector to store whether from index i to j of string is palindrome or not.\\n- Here i and j represent start and end index of string respectively.\\n- Base cases:\\nsubstring string of length 1 is always a palindrome so mark dp[i][j]=1 for j-i==0(length 1).\\nthe above condition only work if the length is greater than 2 so also precalculate for substring of length 2 whether it is palindrome or not.\\n- Now start filling 2d vector column wise for substring of length 3 or more with the two palindrome conditions.Colmum wise because for substring (0,4) one need (1,3) hence column wise.\\n- Now find the maximum length substring from 2d vector.\\n\\n\\n\\n \\n\\n# Complexity\\n- Time complexity:\\nO(n^2)\\n\\n- Space complexity:\\nO(n^2)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n        int n=s.size();\\n        vector<vector<int>>dp(n,vector<int>(n,0));\\n\\n        //base case\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if((j-i)==0||(j-i)==1)//substr of length 1 or 2\\n                {\\n                    if(s[i]==s[j])\\n                    {\\n                        dp[i][j]=1;\\n                    }\\n                    else\\n                    {\\n                        dp[i][j]=0;\\n                    }\\n                }\\n            }\\n        }\\n\\n        // to be a palindrom conditions\\n        //s[i]==s[j]\\n        //substr(i+1,j-1) is also palindrome\\n\\n\\n\\n        //fill it column wise\\n        for(int j=0;j<n;j++)\\n        {\\n            for(int i=0;i<n;i++)\\n            {\\n                if((j-i)>1)//substr of length 2 or more //upper triangle only bcz i <j\\n                {\\n                    if(s[i]==s[j]&&dp[i+1][j-1]==1)\\n                    {\\n                        dp[i][j]=1;\\n                    }\\n                    else\\n                    {\\n                        dp[i][j]=0;\\n                    }\\n                }\\n            }\\n        }\\n\\n        int start=0;\\n        int maxi=1;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(dp[i][j]==1)\\n                {\\n                    if(maxi<=j-i+1)\\n                    {\\n                        maxi=j-i+1;\\n                        start=i;\\n                    }\\n                }\\n            }\\n        }\\n        return s.substr(start,maxi);        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n        int n=s.size();\\n        vector<vector<int>>dp(n,vector<int>(n,0));\\n\\n        //base case\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if((j-i)==0||(j-i)==1)//substr of length 1 or 2\\n                {\\n                    if(s[i]==s[j])\\n                    {\\n                        dp[i][j]=1;\\n                    }\\n                    else\\n                    {\\n                        dp[i][j]=0;\\n                    }\\n                }\\n            }\\n        }\\n\\n        // to be a palindrom conditions\\n        //s[i]==s[j]\\n        //substr(i+1,j-1) is also palindrome\\n\\n\\n\\n        //fill it column wise\\n        for(int j=0;j<n;j++)\\n        {\\n            for(int i=0;i<n;i++)\\n            {\\n                if((j-i)>1)//substr of length 2 or more //upper triangle only bcz i <j\\n                {\\n                    if(s[i]==s[j]&&dp[i+1][j-1]==1)\\n                    {\\n                        dp[i][j]=1;\\n                    }\\n                    else\\n                    {\\n                        dp[i][j]=0;\\n                    }\\n                }\\n            }\\n        }\\n\\n        int start=0;\\n        int maxi=1;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(dp[i][j]==1)\\n                {\\n                    if(maxi<=j-i+1)\\n                    {\\n                        maxi=j-i+1;\\n                        start=i;\\n                    }\\n                }\\n            }\\n        }\\n        return s.substr(start,maxi);        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3339551,
                "title": "simple-and-easy-solution-in-java",
                "content": "##### For odd length palindromes, the basic idea is to fix the center of the palindrome and expand outwards until the palindrome is no longer valid. Here is an algorithmic approach:\\n\\n1. Initialize two pointers, left and right, to the center of the string.\\n2. While the characters at indices left and right are equal, increment left and decrement right.\\n3. The length of the longest palindrome centered at the current index is 2 * (center - left) - 1.\\n4. Keep track of the maximum length palindrome and its center.\\n\\n##### For even length palindromes, the basic idea is to fix the two centers of the palindrome and expand outwards until the palindrome is no longer valid. Here is an algorithmic approach:\\n\\n1. Initialize two pointers, left and right, to the center of the string.\\n2. While the characters at indices left and right are equal, increment left and decrement right.\\n3. The length of the longest palindrome centered at the current index is 2 * (center - left) - 1.\\n4. Keep track of the maximum length palindrome and its center.\\n5. Initialize two pointers, left and right, to the center of the string and its right neighbor.\\n6. While the characters at indices left and right are equal, increment left and decrement right.\\n7. The length of the longest palindrome centered at the current index is 2 * (center - left) - 1.\\n8. Keep track of the maximum length palindrome and its center.\\n##### By combining these two approaches, we can find the longest palindromic substring in a given string. The time complexity of this algorithm is O(n^2) since we need to check each possible center of the palindrome. However, there are more efficient algorithms such as Manacher\\'s algorithm that can solve this problem in O(n) time complexity.\\n\\n# Code\\n```\\nclass Solution {\\n    public String longestPalindrome(String str) {\\n        int s=0, e=0;\\n        for(int i=0; i<str.length(); i++){\\n            int odd=pal(str,i,i);\\n            int even=pal(str,i,i+1);\\n            int len=Math.max(odd,even);\\n\\n            if(len>e-s){\\n                s=i-(len-1)/2;\\n                e=i+len/2;\\n            }\\n        }\\n        return str.substring(s,e+1);\\n    }\\n\\n    public int pal(String str, int s, int e){\\n        while(s>=0 && e<str.length() && str.charAt(s)==str.charAt(e)){\\n            s--;\\n            e++;\\n        }\\n        return e-s-1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String longestPalindrome(String str) {\\n        int s=0, e=0;\\n        for(int i=0; i<str.length(); i++){\\n            int odd=pal(str,i,i);\\n            int even=pal(str,i,i+1);\\n            int len=Math.max(odd,even);\\n\\n            if(len>e-s){\\n                s=i-(len-1)/2;\\n                e=i+len/2;\\n            }\\n        }\\n        return str.substring(s,e+1);\\n    }\\n\\n    public int pal(String str, int s, int e){\\n        while(s>=0 && e<str.length() && str.charAt(s)==str.charAt(e)){\\n            s--;\\n            e++;\\n        }\\n        return e-s-1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2142969,
                "title": "dynamic-programming-solution-with-comments-c-o-n-2",
                "content": "```\\n// For more clarrification on this approach use the video link : https://www.youtube.com/watch?v=UflHuQj6MVA\\n// I used that video for learning and is not my youtube video neither I am promoting any channel.\\n\\nclass Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n        \\n        \\n        // DP soln\\n        int n = s.length();\\n        \\n        \\n        // If string length is 1 then return string itself.\\n        if(n == 1)\\n            return s;\\n        \\n        // Matrix of size nxn whose rows represents start indx and col represents end indx of any substring.\\n        vector<vector<int>> dp(n,vector<int>(n,0));\\n        \\n        \\n        // This arr of size 2 will keep record of i, j index of longest palindrome substring.\\n        int arr[2] = {-1,-1};\\n        \\n        \\n        // Mark all diagonal elements in matrix as 1. Bcoz single substr of length 1 itself is palindrome\\n        for(int i=0;i<n;i++)\\n            dp[i][i] = 1;\\n        \\n        \\n        // Mark all 2 length substr as 1 if their both characters are equal.\\n        for(int i=0;i<n-1;i++)\\n        {\\n            if(s[i] == s[i+1])\\n            {\\n                arr[0] = i;\\n                arr[1] = i+1;\\n                dp[i][i+1] = 1;\\n            }\\n        }\\n        \\n        \\n        int diff = 2;\\n        \\n        // Traverse diagonally in each iteration.\\n        while(diff < n)\\n        {\\n            for(int i=0,j=i+diff;j<n;i++,j++)\\n            {\\n                if(s[i] == s[j] && dp[i+1][j-1] == 1)\\n                {\\n                    dp[i][j] = 1;\\n                    if(j-i > arr[1]-arr[0])\\n                    {\\n                        arr[0] = i;\\n                        arr[1] = j;\\n                    }\\n                }\\n            }\\n            diff++;\\n        }\\n            \\n        \\n        // If index is -1 in arr, it means no palindrome found so return any single length string. Here I returned first character of given string.\\n        if(arr[0] == -1)\\n            return s.substr(0,1);\\n        \\n        \\n        // Otherwise return substring between i and j index values stored in arr.\\n        return s.substr(arr[0],arr[1]-arr[0]+1);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\n// For more clarrification on this approach use the video link : https://www.youtube.com/watch?v=UflHuQj6MVA\\n// I used that video for learning and is not my youtube video neither I am promoting any channel.\\n\\nclass Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n        \\n        \\n        // DP soln\\n        int n = s.length();\\n        \\n        \\n        // If string length is 1 then return string itself.\\n        if(n == 1)\\n            return s;\\n        \\n        // Matrix of size nxn whose rows represents start indx and col represents end indx of any substring.\\n        vector<vector<int>> dp(n,vector<int>(n,0));\\n        \\n        \\n        // This arr of size 2 will keep record of i, j index of longest palindrome substring.\\n        int arr[2] = {-1,-1};\\n        \\n        \\n        // Mark all diagonal elements in matrix as 1. Bcoz single substr of length 1 itself is palindrome\\n        for(int i=0;i<n;i++)\\n            dp[i][i] = 1;\\n        \\n        \\n        // Mark all 2 length substr as 1 if their both characters are equal.\\n        for(int i=0;i<n-1;i++)\\n        {\\n            if(s[i] == s[i+1])\\n            {\\n                arr[0] = i;\\n                arr[1] = i+1;\\n                dp[i][i+1] = 1;\\n            }\\n        }\\n        \\n        \\n        int diff = 2;\\n        \\n        // Traverse diagonally in each iteration.\\n        while(diff < n)\\n        {\\n            for(int i=0,j=i+diff;j<n;i++,j++)\\n            {\\n                if(s[i] == s[j] && dp[i+1][j-1] == 1)\\n                {\\n                    dp[i][j] = 1;\\n                    if(j-i > arr[1]-arr[0])\\n                    {\\n                        arr[0] = i;\\n                        arr[1] = j;\\n                    }\\n                }\\n            }\\n            diff++;\\n        }\\n            \\n        \\n        // If index is -1 in arr, it means no palindrome found so return any single length string. Here I returned first character of given string.\\n        if(arr[0] == -1)\\n            return s.substr(0,1);\\n        \\n        \\n        // Otherwise return substring between i and j index values stored in arr.\\n        return s.substr(arr[0],arr[1]-arr[0]+1);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1926046,
                "title": "easy-c-o-n-2-time-and-o-1-space-explained",
                "content": "### Approach:\\n\\nThe algorithm below is very simple and easy to understand. The idea is to ***fix a center and expand in both directions*** to get longer palindromes and keep track of the start and end position of longest palindrome seen so far.\\n\\n**Time Complexity :** Outer loop runs for n times and we have two inner loops which run for n times. \\n              ` n*(n+n)=>O(n^2)`\\n\\t\\t\\t  \\n**Space Cpmplexity :**  O(1)\\n\\n***l*** : This points to the left most index of pallindrom string.\\n***h*** : This points to the right most index of pallindrom string.\\n\\n***start*** : This points to the starting position of current maximum length pallindromic string.\\n***end*** : This points to the end position of current maximum length pallindromic string.\\n\\n\\n\\n```\\nstring longestPalindrome(string s) {\\n        int start=0;\\n        int end=0;\\n        int n=s.size();\\n        for(int i=1;i<n;i++)\\n        {\\n\\t\\t\\n\\t\\t    // for even length palindroms\\n            int l=i-1;           \\n            int h=i;\\n            while(l>=0 && h<n && s[l]==s[h])   //if both left and right is same then expand the length by of pallindrom by moving l and h accordingly\\n            {\\n                if(end-start < h-l )           // if current length of pallindrom is greater than previous the update sart and end accordingly\\n                {\\n                    start=l;\\n                    end=h;\\n                }\\n                l--;\\n                h++;\\n            }\\n            \\n\\t\\t\\t//for odd length palindroms\\n            l=i-1;\\n            h=i+1;\\n            while(l>=0 && h<n && s[l]==s[h])\\n            {\\n                if(end-start < h-l )\\n                {\\n                    start=l;\\n                    end=h;\\n                }\\n                l--;\\n                h++;\\n            }\\n        }\\n        \\n        string ans=\"\";\\n        for(int i=start;i<=end;i++)\\n            ans+=s[i];\\n        \\n        return ans;\\n    }\\n```\\n\\nDo ***Upvote***, if it helped. **:)**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nstring longestPalindrome(string s) {\\n        int start=0;\\n        int end=0;\\n        int n=s.size();\\n        for(int i=1;i<n;i++)\\n        {\\n\\t\\t\\n\\t\\t    // for even length palindroms\\n            int l=i-1;           \\n            int h=i;\\n            while(l>=0 && h<n && s[l]==s[h])   //if both left and right is same then expand the length by of pallindrom by moving l and h accordingly\\n            {\\n                if(end-start < h-l )           // if current length of pallindrom is greater than previous the update sart and end accordingly\\n                {\\n                    start=l;\\n                    end=h;\\n                }\\n                l--;\\n                h++;\\n            }\\n            \\n\\t\\t\\t//for odd length palindroms\\n            l=i-1;\\n            h=i+1;\\n            while(l>=0 && h<n && s[l]==s[h])\\n            {\\n                if(end-start < h-l )\\n                {\\n                    start=l;\\n                    end=h;\\n                }\\n                l--;\\n                h++;\\n            }\\n        }\\n        \\n        string ans=\"\";\\n        for(int i=start;i<=end;i++)\\n            ans+=s[i];\\n        \\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1777358,
                "title": "cpp-dynamic-programming-recursive-approach-and-memoization",
                "content": "**Iterative**\\n```\\nclass Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n        \\n        int n=s.length();\\n        vector<vector<int>> dp(n,vector<int>(n,-1));\\n        int maxLen=1;\\n        int start=0;\\n        \\n        for(int i=0;i<n-1;i++){\\n            dp[i][i]=1;\\n            dp[i][i+1]=(s[i]==s[i+1]);\\n            if(dp[i][i+1] and maxLen==1){\\n                maxLen=2;\\n                start=i;\\n            }\\n        }\\n        // Fill details diagonaly\\n\\t\\t// Make 2d matrix of NxN and then think yourself how can you make use of previous answers\\n        dp[n-1][n-1]=1;\\n        for(int k=2;k<n;k++){ \\n                int i=0,j=k;\\n                while(i<n-k and j<n){\\n                        dp[i][j]=(s[i]==s[j] and dp[i+1][j-1]);\\n                        int len=j-i+1;\\n                        if(dp[i][j] and len>maxLen){\\n                            maxLen=len;\\n                            start=i;\\n                        }\\n                    i++,j++;\\n                }   \\n            }\\n        \\n        return s.substr(start,maxLen);\\n        \\n    }\\n};\\n/*\\nPlease upvote if you like it.\\n*/\\n```\\n\\n**Recursive**\\n```\\n class Solution {\\npublic:\\n    vector<vector<int>> dp;\\n    int ans=1;\\n    int start=0;\\n    string str;\\n    bool lps(int i,int j){\\n        if(i>j) return false;\\n        if(i==j){\\n            return dp[i][j]=1;\\n        }\\n        \\n        if(dp[i][j]!=-1) return dp[i][j];\\n        \\n        if(str[i]==str[j] and (i==j-1 or lps(i+1,j-1))){\\n            dp[i][j]=1;\\n            int len=j-i+1;\\n            if(len>ans){\\n                ans=len;\\n                start=i;\\n            }\\n        }\\n        \\n        lps(i,j-1);\\n        lps(i+1,j);\\n        if(dp[i][j]==-1) dp[i][j]=0;\\n        return dp[i][j];\\n    }\\n    string longestPalindrome(string s) {\\n        int n=s.length();\\n        str=s;\\n        dp.resize(n+1,vector<int>(n+1,-1));\\n        lps(0,s.length()-1);\\n        return s.substr(start,ans);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n        \\n        int n=s.length();\\n        vector<vector<int>> dp(n,vector<int>(n,-1));\\n        int maxLen=1;\\n        int start=0;\\n        \\n        for(int i=0;i<n-1;i++){\\n            dp[i][i]=1;\\n            dp[i][i+1]=(s[i]==s[i+1]);\\n            if(dp[i][i+1] and maxLen==1){\\n                maxLen=2;\\n                start=i;\\n            }\\n        }\\n        // Fill details diagonaly\\n\\t\\t// Make 2d matrix of NxN and then think yourself how can you make use of previous answers\\n        dp[n-1][n-1]=1;\\n        for(int k=2;k<n;k++){ \\n                int i=0,j=k;\\n                while(i<n-k and j<n){\\n                        dp[i][j]=(s[i]==s[j] and dp[i+1][j-1]);\\n                        int len=j-i+1;\\n                        if(dp[i][j] and len>maxLen){\\n                            maxLen=len;\\n                            start=i;\\n                        }\\n                    i++,j++;\\n                }   \\n            }\\n        \\n        return s.substr(start,maxLen);\\n        \\n    }\\n};\\n/*\\nPlease upvote if you like it.\\n*/\\n```\n```\\n class Solution {\\npublic:\\n    vector<vector<int>> dp;\\n    int ans=1;\\n    int start=0;\\n    string str;\\n    bool lps(int i,int j){\\n        if(i>j) return false;\\n        if(i==j){\\n            return dp[i][j]=1;\\n        }\\n        \\n        if(dp[i][j]!=-1) return dp[i][j];\\n        \\n        if(str[i]==str[j] and (i==j-1 or lps(i+1,j-1))){\\n            dp[i][j]=1;\\n            int len=j-i+1;\\n            if(len>ans){\\n                ans=len;\\n                start=i;\\n            }\\n        }\\n        \\n        lps(i,j-1);\\n        lps(i+1,j);\\n        if(dp[i][j]==-1) dp[i][j]=0;\\n        return dp[i][j];\\n    }\\n    string longestPalindrome(string s) {\\n        int n=s.length();\\n        str=s;\\n        dp.resize(n+1,vector<int>(n+1,-1));\\n        lps(0,s.length()-1);\\n        return s.substr(start,ans);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 830244,
                "title": "c-solution-better-than-90-time-and-99-8-space-complexity",
                "content": "The strings \\'aa\\' and \\'aba\\' are palindomes. The main idea is to find all palidromes with the length 2 and 3. When we find a palidrome, the algorythm goes to the left and to the right in the same time.  \\nWe should reuse already calculated palindrome. So if **s[left - 1] != s[right + 1]** it\\'s not a palindrome. \\nExpample: \\n\\ns = \\'camppmdt\\'\\n\\nFirst we find `pp` as palindrome. That we check `s[left - 1] == s[right + 1]` yes, so the palindrome is `mppm`, than we decrise `left` and increase `rigth` pointers and check again. `a != d` so we stop searching and goes farther. In this moment, the longest palindrom is `mppm`\\n\\n\\n\\n```\\n\\n public string LongestPalindrome(string s)\\n        {\\n            if (s.Length < 2) return s;\\n\\n            (int start, int end) longest = (0, 0);\\n            \\n            for (var i = 0; i < s.Length - 1; i++)\\n            {\\n                if (s[i] == s[i + 1])\\n                {\\n                    var res = LongestPalindrome(s, i, i + 1);\\n                    longest = res.end - res.start > longest.end - longest.start ? res : longest;\\n                }\\n\\n                if (i + 2 < s.Length && s[i] == s[i + 2])\\n                {\\n                    var res = LongestPalindrome(s, i, i + 2);\\n                    longest = res.end - res.start > longest.end - longest.start ? res : longest;\\n                }\\n            }\\n\\n            return (longest.start == 0 && longest.end == 0) ? \\n                s[0].ToString() : \\n                s.Substring(longest.start, longest.end - longest.start + 1);\\n        }\\n\\n        private (int start, int end) LongestPalindrome(string s, int start, int end)\\n        { \\n            while (start >= 0 && end < s.Length && s[start] == s[end])\\n            {\\n                start--;\\n                end++;\\n            }\\n\\n            return (start + 1, end - 1);\\n        }\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\n\\n public string LongestPalindrome(string s)\\n        {\\n            if (s.Length < 2) return s;\\n\\n            (int start, int end) longest = (0, 0);\\n            \\n            for (var i = 0; i < s.Length - 1; i++)\\n            {\\n                if (s[i] == s[i + 1])\\n                {\\n                    var res = LongestPalindrome(s, i, i + 1);\\n                    longest = res.end - res.start > longest.end - longest.start ? res : longest;\\n                }\\n\\n                if (i + 2 < s.Length && s[i] == s[i + 2])\\n                {\\n                    var res = LongestPalindrome(s, i, i + 2);\\n                    longest = res.end - res.start > longest.end - longest.start ? res : longest;\\n                }\\n            }\\n\\n            return (longest.start == 0 && longest.end == 0) ? \\n                s[0].ToString() : \\n                s.Substring(longest.start, longest.end - longest.start + 1);\\n        }\\n\\n        private (int start, int end) LongestPalindrome(string s, int start, int end)\\n        { \\n            while (start >= 0 && end < s.Length && s[start] == s[end])\\n            {\\n                start--;\\n                end++;\\n            }\\n\\n            return (start + 1, end - 1);\\n        }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 536012,
                "title": "java-dp-solution",
                "content": "```\\nclass Solution {\\n    public String longestPalindrome(String s) {\\n        String ans = \"\";\\n        if(s.length() == 0) return ans;\\n        int n = s.length(), start = 0, end = 0, maxLen = 0;\\n        boolean[][] DP = new boolean[n][n];\\n        for(int i = n - 1; i >= 0; i--) {\\n            for(int j = i; j < n; j++) {\\n                DP[i][j] = s.charAt(i) == s.charAt(j) && (j - i < 3 || DP[i+1][j-1]);\\n                if(DP[i][j] && (j - i > end - start)) {\\n                    start = i;\\n                    end = j;\\n                }  \\n            }\\n        }\\n        return s.substring(start, end+1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public String longestPalindrome(String s) {\\n        String ans = \"\";\\n        if(s.length() == 0) return ans;\\n        int n = s.length(), start = 0, end = 0, maxLen = 0;\\n        boolean[][] DP = new boolean[n][n];\\n        for(int i = n - 1; i >= 0; i--) {\\n            for(int j = i; j < n; j++) {\\n                DP[i][j] = s.charAt(i) == s.charAt(j) && (j - i < 3 || DP[i+1][j-1]);\\n                if(DP[i][j] && (j - i > end - start)) {\\n                    start = i;\\n                    end = j;\\n                }  \\n            }\\n        }\\n        return s.substring(start, end+1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 181376,
                "title": "c-dp-simple",
                "content": "```\\nstring longestPalindrome(string s) {\\n        int l = s.size();\\n        int max = INT_MIN;\\n        int end = 0, start = 0;\\n        vector<vector<bool>> dp(l, vector<bool>(l));\\n        for (int i = l-1; i >= 0; i--) {\\n            for (int j = i; j < l; j++) {\\n                dp[i][j] = (s[i] == s[j]) && (j-i <= 1 || dp[i+1][j-1]);\\n                if (dp[i][j] && (j - i) > max) {\\n                    start = i;\\n                    end = j;\\n                    max = j-i;\\n                }\\n            }\\n        }\\n        return s.substr(start, max+1);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nstring longestPalindrome(string s) {\\n        int l = s.size();\\n        int max = INT_MIN;\\n        int end = 0, start = 0;\\n        vector<vector<bool>> dp(l, vector<bool>(l));\\n        for (int i = l-1; i >= 0; i--) {\\n            for (int j = i; j < l; j++) {\\n                dp[i][j] = (s[i] == s[j]) && (j-i <= 1 || dp[i+1][j-1]);\\n                if (dp[i][j] && (j - i) > max) {\\n                    start = i;\\n                    end = j;\\n                    max = j-i;\\n                }\\n            }\\n        }\\n        return s.substr(start, max+1);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 164362,
                "title": "javascript-simple-solution",
                "content": "```\\nvar longestPalindrome = function(s) {\\n    let res = \"\";\\n    let cur = \"\";\\n    for(let i = 0; i < s.length; i ++){\\n        for(let j = i; j < i + 2; j ++){\\n            let left = i;\\n            let right = j;\\n            while(s[left] && s[left] === s[right]){\\n                cur = s.substring(left, right + 1);\\n                if(cur.length > res.length) res = cur;\\n                left --;\\n                right ++;\\n            }\\n        }\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar longestPalindrome = function(s) {\\n    let res = \"\";\\n    let cur = \"\";\\n    for(let i = 0; i < s.length; i ++){\\n        for(let j = i; j < i + 2; j ++){\\n            let left = i;\\n            let right = j;\\n            while(s[left] && s[left] === s[right]){\\n                cur = s.substring(left, right + 1);\\n                if(cur.length > res.length) res = cur;\\n                left --;\\n                right ++;\\n            }\\n        }\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3057,
                "title": "beat-100-java-solution-and-easy-to-understand",
                "content": "    public String longestPalindrome(String s) {\\n        if(s==null){\\n            return \"\";\\n        }\\n       char[] arr = s.toCharArray();\\n\\t\\t  int max = 0;\\n\\t\\t  int maxi = 0;\\n\\t\\t  int maxj = 0;\\n\\t\\t  \\n\\t\\t  for(int i = 0; i< arr.length;){\\n\\t\\t\\t  int i1 = getFarestSameElementIndex(arr,i);\\n\\t\\t\\t  int dist = getDistance(arr,i,i1);\\n\\t\\t\\t  int index1 = i-dist;\\n\\t\\t\\t  int index2 = i1 + dist;\\n\\t\\t\\t  int l = index2 - index1;\\n\\t\\t\\t  if(l>max){\\n\\t\\t\\t          max = l;\\n\\t\\t\\t\\t  maxi = index1;\\n\\t\\t\\t\\t  maxj = index2;\\n\\t\\t\\t  }\\n\\t\\t\\t  i = i1+1;\\n\\t\\t  }\\n\\t\\t  \\n\\t\\t  return s.substring(maxi, maxj+1);\\n    }\\n    \\n    private int getDistance(char[] arr,int index1,int index2){\\n\\t\\tint i1 = index1-1;\\n\\t\\tint i2 = index2+1;\\n\\t\\tint dist = 0;\\n\\t\\twhile(i1>=0&&i2<arr.length){\\n\\t\\t\\tif(arr[i1]==arr[i2]){\\n\\t\\t\\t\\tdist++;\\n\\t\\t\\t}else{\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\ti1--;i2++;\\n\\t\\t}\\n\\t\\treturn dist;\\n\\t}\\n\\t\\n\\tprivate int getFarestSameElementIndex(char[] arr, int index){\\n\\t\\tfor(int i = index+1;i<arr.length;i++){\\n\\t\\t\\tif(arr[i]!=arr[index]){\\n\\t\\t\\t\\treturn i-1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn arr.length-1;\\n\\t}",
                "solutionTags": [],
                "code": "    public String longestPalindrome(String s) {\\n        if(s==null){\\n            return \"\";\\n        }\\n       char[] arr = s.toCharArray();\\n\\t\\t  int max = 0;\\n\\t\\t  int maxi = 0;\\n\\t\\t  int maxj = 0;\\n\\t\\t  \\n\\t\\t  for(int i = 0; i< arr.length;){\\n\\t\\t\\t  int i1 = getFarestSameElementIndex(arr,i);\\n\\t\\t\\t  int dist = getDistance(arr,i,i1);\\n\\t\\t\\t  int index1 = i-dist;\\n\\t\\t\\t  int index2 = i1 + dist;\\n\\t\\t\\t  int l = index2 - index1;\\n\\t\\t\\t  if(l>max){\\n\\t\\t\\t          max = l;\\n\\t\\t\\t\\t  maxi = index1;\\n\\t\\t\\t\\t  maxj = index2;\\n\\t\\t\\t  }\\n\\t\\t\\t  i = i1+1;\\n\\t\\t  }\\n\\t\\t  \\n\\t\\t  return s.substring(maxi, maxj+1);\\n    }\\n    \\n    private int getDistance(char[] arr,int index1,int index2){\\n\\t\\tint i1 = index1-1;\\n\\t\\tint i2 = index2+1;\\n\\t\\tint dist = 0;\\n\\t\\twhile(i1>=0&&i2<arr.length){\\n\\t\\t\\tif(arr[i1]==arr[i2]){\\n\\t\\t\\t\\tdist++;\\n\\t\\t\\t}else{\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\ti1--;i2++;\\n\\t\\t}\\n\\t\\treturn dist;\\n\\t}\\n\\t\\n\\tprivate int getFarestSameElementIndex(char[] arr, int index){\\n\\t\\tfor(int i = index+1;i<arr.length;i++){\\n\\t\\t\\tif(arr[i]!=arr[index]){\\n\\t\\t\\t\\treturn i-1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn arr.length-1;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 3862201,
                "title": "python3-easy-solution-beats-93-73-in-runtime",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n![image.png](https://assets.leetcode.com/users/images/dee0375c-f843-4849-a8e8-3fcc91fceee8_1691143738.456786.png)\\n\\nPlease  Upvote!!!!!!!!\\n# Code\\n```\\nclass Solution:\\n    def longestPalindrome(self, s: str) -> str:\\n        longest = \"\"\\n        for i in range(len(s)):\\n            left = i;right = i\\n            while left >= 0 and right < len(s) and s[left] == s[right]:left -= 1;right += 1\\n            palindrome = s[left+1:right]\\n            if len(palindrome) > len(longest):longest = palindrome\\n            left = i;right = i+1\\n            while left >= 0 and right < len(s) and s[left] == s[right]:left -= 1;right += 1\\n            palindrome = s[left+1:right]  \\n            if len(palindrome) > len(longest):longest = palindrome\\n        return longest\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestPalindrome(self, s: str) -> str:\\n        longest = \"\"\\n        for i in range(len(s)):\\n            left = i;right = i\\n            while left >= 0 and right < len(s) and s[left] == s[right]:left -= 1;right += 1\\n            palindrome = s[left+1:right]\\n            if len(palindrome) > len(longest):longest = palindrome\\n            left = i;right = i+1\\n            while left >= 0 and right < len(s) and s[left] == s[right]:left -= 1;right += 1\\n            palindrome = s[left+1:right]  \\n            if len(palindrome) > len(longest):longest = palindrome\\n        return longest\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2594234,
                "title": "accepted-solution-using-1-loops-o-n-time-complexity",
                "content": "**Read the approach below to understand the logic!**\\n\\n***Please upvote if you like it!!!***\\n\\n**Approach :-**\\n\\n* Here the palindrome could have odd or even length.\\n* For odd length, there must be a central element. For even the elements will be side by side.\\n* So we calculate both cases for all elements:\\n\\t* For odd: we took left & right as same elements(central) l = i, r = i\\n\\t* if elements in both indexes are the same we\\u2019ll increase r & decrease l by 1.\\n\\t* when we find both are not same, we\\u2019ll calculate the length length = r-l-1\\n\\t* if the length is greater than mx, then we\\u2019ll store start and end point of this length.\\n\\t* For even: same approach, just here we\\u2019ll take l & r next to each other. l = i, r = i+1\\n* Return substring from start to max length.\\n\\n**~Time complexity: O(n^2).**\\n**~Time complexity: O(1).**\\n\\n**Code**\\n```\\nclass Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n        int n=s.length();\\n        int mx=1;\\n        int start=0;\\n        for(int i=1;i<=n;i++){\\n            //Check for even string\\n            int l=i-1;\\n            int r=i;\\n            while(l>=0 && r<n && s[l]==s[r]){\\n                if(r-l+1>mx){\\n                    mx=r-l+1;\\n                    start=l;\\n                }\\n                l--;\\n                r++;\\n            }\\n            //Check for odd string\\n            l=i-1;\\n            r=i+1;\\n            while(l>=0 && r<n && s[l]==s[r]){\\n                if(r-l+1>mx){\\n                    mx=r-l+1;\\n                    start=l;\\n                }\\n                l--;\\n                r++;\\n            }\\n        }\\n        return s.substr(start,mx);\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n        int n=s.length();\\n        int mx=1;\\n        int start=0;\\n        for(int i=1;i<=n;i++){\\n            //Check for even string\\n            int l=i-1;\\n            int r=i;\\n            while(l>=0 && r<n && s[l]==s[r]){\\n                if(r-l+1>mx){\\n                    mx=r-l+1;\\n                    start=l;\\n                }\\n                l--;\\n                r++;\\n            }\\n            //Check for odd string\\n            l=i-1;\\n            r=i+1;\\n            while(l>=0 && r<n && s[l]==s[r]){\\n                if(r-l+1>mx){\\n                    mx=r-l+1;\\n                    start=l;\\n                }\\n                l--;\\n                r++;\\n            }\\n        }\\n        return s.substr(start,mx);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2019757,
                "title": "java-memoization-tabulation-both",
                "content": "*Please Upvote this post, if it\\'s help you...!!*\\n**Memoiziation Code:-**\\n```\\nclass Solution {\\n    \\n    public String longestPalindrome(String str) {\\n        int n = str.length();\\n        int [][] dp = new int[n][n];\\n        for(int [] d : dp){\\n            Arrays.fill(d, -1);\\n        }\\n        longestPalindromeSubstring_memo(str, 0, n-1, dp);\\n        return str.substring(stIdx, stIdx + max);\\n    }\\n    \\n    private int max = 0;\\n    private int stIdx = 0;\\n    public int longestPalindromeSubstring_memo(String s, int i, int j, int [][] dp){\\n        if(i >= j){\\n            dp[i][j] = i == j ? 1 : 0;\\n            if(dp[i][j] > max){\\n                max = dp[i][j];\\n                stIdx = i;\\n            }\\n            return dp[i][j];\\n        } \\n\\n        if(dp[i][j] != -1) return dp[i][j];\\n        int a = longestPalindromeSubstring_memo(s, i+1, j-1, dp);\\n        int b = longestPalindromeSubstring_memo(s, i+1, j, dp);\\n        int c = longestPalindromeSubstring_memo(s, i, j-1, dp);\\n\\n        if(s.charAt(i) == s.charAt(j)){\\n            if(i + 1 == j) {    // jab \"ee\" same hai lakin i+1, j-1 pe to 0 hoga to\\n                //  iswale case me kabhi 2 print hi nhi hoga\\n                dp[i][j] = 2;\\n            } else{\\n                dp[i][j] = a > 0 ? a + 2 : 0;\\n            }\\n\\n            if(dp[i][j] > max){\\n                max = dp[i][j];\\n                stIdx = i;\\n            }\\n            return dp[i][j];\\n        } else{\\n            return dp[i][j] = 0;\\n        }\\n    }\\n}\\n```\\n\\n**Tabulation Code:-**\\n```\\npublic String longestPlaindromicSubstring_tabu(String s) {\\n        int n = s.length(), len = 0;\\n        int[][] dp = new int[n][n];\\n        int count = 0;\\n        int I = 0;\\n        for (int gap = 0; gap < n; gap++) {\\n            for (int i = 0, j = gap; j < n; i++, j++) {\\n                if (gap == 0){\\n                    dp[i][j] = 1;\\n                    count++;\\n                }\\n\\n                else if (gap == 1 && s.charAt(i) == s.charAt(j)){\\n                    dp[i][j] = 2;\\n                    count++;\\n                }\\n                else {\\n                    if(s.charAt(i) == s.charAt(j) && dp[i + 1][j - 1] > 0){\\n                        dp[i][j] = dp[i+1][j-1] + 2;\\n                        count++;\\n                    } else {\\n                        dp[i][j] = 0;\\n                    }\\n                }\\n\\n                if(dp[i][j] > len){\\n                    len = dp[i][j];\\n                    I = i;\\n                }\\n            }\\n        }\\n        String str = s.substring(I, I + len);\\n        return str;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public String longestPalindrome(String str) {\\n        int n = str.length();\\n        int [][] dp = new int[n][n];\\n        for(int [] d : dp){\\n            Arrays.fill(d, -1);\\n        }\\n        longestPalindromeSubstring_memo(str, 0, n-1, dp);\\n        return str.substring(stIdx, stIdx + max);\\n    }\\n    \\n    private int max = 0;\\n    private int stIdx = 0;\\n    public int longestPalindromeSubstring_memo(String s, int i, int j, int [][] dp){\\n        if(i >= j){\\n            dp[i][j] = i == j ? 1 : 0;\\n            if(dp[i][j] > max){\\n                max = dp[i][j];\\n                stIdx = i;\\n            }\\n            return dp[i][j];\\n        } \\n\\n        if(dp[i][j] != -1) return dp[i][j];\\n        int a = longestPalindromeSubstring_memo(s, i+1, j-1, dp);\\n        int b = longestPalindromeSubstring_memo(s, i+1, j, dp);\\n        int c = longestPalindromeSubstring_memo(s, i, j-1, dp);\\n\\n        if(s.charAt(i) == s.charAt(j)){\\n            if(i + 1 == j) {    // jab \"ee\" same hai lakin i+1, j-1 pe to 0 hoga to\\n                //  iswale case me kabhi 2 print hi nhi hoga\\n                dp[i][j] = 2;\\n            } else{\\n                dp[i][j] = a > 0 ? a + 2 : 0;\\n            }\\n\\n            if(dp[i][j] > max){\\n                max = dp[i][j];\\n                stIdx = i;\\n            }\\n            return dp[i][j];\\n        } else{\\n            return dp[i][j] = 0;\\n        }\\n    }\\n}\\n```\n```\\npublic String longestPlaindromicSubstring_tabu(String s) {\\n        int n = s.length(), len = 0;\\n        int[][] dp = new int[n][n];\\n        int count = 0;\\n        int I = 0;\\n        for (int gap = 0; gap < n; gap++) {\\n            for (int i = 0, j = gap; j < n; i++, j++) {\\n                if (gap == 0){\\n                    dp[i][j] = 1;\\n                    count++;\\n                }\\n\\n                else if (gap == 1 && s.charAt(i) == s.charAt(j)){\\n                    dp[i][j] = 2;\\n                    count++;\\n                }\\n                else {\\n                    if(s.charAt(i) == s.charAt(j) && dp[i + 1][j - 1] > 0){\\n                        dp[i][j] = dp[i+1][j-1] + 2;\\n                        count++;\\n                    } else {\\n                        dp[i][j] = 0;\\n                    }\\n                }\\n\\n                if(dp[i][j] > len){\\n                    len = dp[i][j];\\n                    I = i;\\n                }\\n            }\\n        }\\n        String str = s.substring(I, I + len);\\n        return str;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1779328,
                "title": "csharp-88-ms-faster-than-91-77-clean-code",
                "content": "1. To search the Longest Palindromic Substring, traverses the string one time with For loop \\n2. For Every character try expanding both side (Left and right)with while loop until you get the palindrome.\\n3. Once found new palindrome with grater length, just override the previous palindrome in maxLengthStr variable.\\n4. first while loop is for searching Odd Palindrome Ex. \"aba\"\\n5. We will now search the Palindrome in case of even length Ex. \"bb\"\\n6. Both while loop has same code and that can be extracted in some other reusable function. For easy readability of code I have written like this.\\n7. At last return the maxLengthStr which would be containing Longest Palindromic Sub-string.\\n\\n```\\n\\n public static string LongestPalindrome(string s)\\n {\\n            int maxLength = 1;\\n            var maxLengthStr=\"\";\\n\\n            for (int i = 0; i < s.Length; i++)\\n            {\\n                //Odd Palindrom\\n                int L = i; int R = i;\\n                while (L>=0 && R<s.Length && s[L]== s[R])\\n                {\\n                    if (R - L + 1 > maxLength)\\n\\t\\t\\t\\t\\t{\\n                        maxLength = R - L + 1;\\n                        maxLengthStr = s.Substring(L, R - L + 1);\\n                    }\\n                    L--;\\n                    R++;\\n                }\\n\\n                //Even Palindrom\\n                L = i; R = i+1;\\n                while (L >= 0 && R < s.Length && s[L] == s[R])\\n                {\\n                    if (R - L + 1 > maxLength)\\n                    {\\n                        maxLength = R - L + 1;\\n                        maxLengthStr = s.Substring(L, R - L + 1);\\n                    }\\n                    L--;\\n                    R++;\\n                }\\n\\n            }\\n            return maxLengthStr;\\n }\\n```",
                "solutionTags": [
                    "C#",
                    "String"
                ],
                "code": "```\\n\\n public static string LongestPalindrome(string s)\\n {\\n            int maxLength = 1;\\n            var maxLengthStr=\"\";\\n\\n            for (int i = 0; i < s.Length; i++)\\n            {\\n                //Odd Palindrom\\n                int L = i; int R = i;\\n                while (L>=0 && R<s.Length && s[L]== s[R])\\n                {\\n                    if (R - L + 1 > maxLength)\\n\\t\\t\\t\\t\\t{\\n                        maxLength = R - L + 1;\\n                        maxLengthStr = s.Substring(L, R - L + 1);\\n                    }\\n                    L--;\\n                    R++;\\n                }\\n\\n                //Even Palindrom\\n                L = i; R = i+1;\\n                while (L >= 0 && R < s.Length && s[L] == s[R])\\n                {\\n                    if (R - L + 1 > maxLength)\\n                    {\\n                        maxLength = R - L + 1;\\n                        maxLengthStr = s.Substring(L, R - L + 1);\\n                    }\\n                    L--;\\n                    R++;\\n                }\\n\\n            }\\n            return maxLengthStr;\\n }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1743060,
                "title": "python-dp",
                "content": "**Runtime: 60 ms, faster than 99.88% of Python3 online submissions for Longest Palindromic Substring.**\\n`Approach 4` from solution is more general. However, due to the support of slice notation in python, slicing out a new string is fairly light weight and simply. So, instead of assuming every character in string is a middle point, tracking the maximum window size and expand backward is more efficient.\\n```\\nclass Solution:\\n    def longestPalindrome(self, s: str) -> str:\\n        if s == s[::-1]: return s\\n        \\n        start, size = 0, 1\\n        for i in range(1, len(s)):\\n            l, r = i - size, i + 1\\n            s1, s2 = s[l-1:r], s[l:r]\\n            \\n            if l - 1 >= 0 and s1 == s1[::-1]:\\n                start, size = l - 1, size + 2\\n            elif s2 == s2[::-1]:\\n                start, size = l, size + 1\\n                \\n        return s[start:start+size]\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def longestPalindrome(self, s: str) -> str:\\n        if s == s[::-1]: return s\\n        \\n        start, size = 0, 1\\n        for i in range(1, len(s)):\\n            l, r = i - size, i + 1\\n            s1, s2 = s[l-1:r], s[l:r]\\n            \\n            if l - 1 >= 0 and s1 == s1[::-1]:\\n                start, size = l - 1, size + 2\\n            elif s2 == s2[::-1]:\\n                start, size = l, size + 1\\n                \\n        return s[start:start+size]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1525967,
                "title": "o-n-2-time-and-o-1-space-python-solution-with-comments",
                "content": "This solution is inspired (same idea) from [@oldCodingFarmer solution](https://leetcode.com/problems/longest-palindromic-substring/discuss/2954/Python-easy-to-understand-solution-with-comments-(from-middle-to-two-ends).)\\n```\\n\\nclass Solution(object):\\n    def longestPalindrome(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: str\\n        \"\"\"\\n        \\n        #In this function l and r are the middle indecees, as palindrome is created from the middle, we expand from inner (middle) to outer\\n\\t\\t\\n        def helper(l, r):\\n            while l >= 0 and r < len(s) and s[l] == s[r]:\\n                l -= 1; r += 1\\n            return s[l+1:r] # l+1 because we take the previous sliceas when we exit the while loop it will no longer be palindromic\\n\\n        res = \"\"\\n        for i in range(len(s)):\\n            odd = helper(i, i) # odd case, like \"aba\"\\n            even = helper(i, i+1) # even case, like \"abba\"\\n            res=max(odd,res,even,key=lambda x: len(x)) #compare between odd,even and res according to the max length\\n\\n        return res\\n\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n\\nclass Solution(object):\\n    def longestPalindrome(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: str\\n        \"\"\"\\n        \\n        #In this function l and r are the middle indecees, as palindrome is created from the middle, we expand from inner (middle) to outer\\n\\t\\t\\n        def helper(l, r):\\n            while l >= 0 and r < len(s) and s[l] == s[r]:\\n                l -= 1; r += 1\\n            return s[l+1:r] # l+1 because we take the previous sliceas when we exit the while loop it will no longer be palindromic\\n\\n        res = \"\"\\n        for i in range(len(s)):\\n            odd = helper(i, i) # odd case, like \"aba\"\\n            even = helper(i, i+1) # even case, like \"abba\"\\n            res=max(odd,res,even,key=lambda x: len(x)) #compare between odd,even and res according to the max length\\n\\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1439171,
                "title": "c-longest-palindromic-substring-tabulation",
                "content": "```cpp\\nclass Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n        int n = s.size();\\n        int dp[n][n];\\n        memset(dp, 0, sizeof dp);\\n        \\n        int len = 0, start = 0;\\n        for (int g = 0; g < n; ++g) {\\n            for (int i = 0, j = g; j < n; ++i, ++j) {\\n                if (g == 0) dp[i][j] = true;\\n                else if (g == 1) dp[i][j] = s[i] == s[j];\\n                else dp[i][j] = s[i] == s[j] && dp[i + 1][j - 1];\\n                \\n                if (dp[i][j]) {\\n                    len = g + 1;\\n                    start = i;\\n                }\\n            }\\n        }\\n        \\n        return s.substr(start, len);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n        int n = s.size();\\n        int dp[n][n];\\n        memset(dp, 0, sizeof dp);\\n        \\n        int len = 0, start = 0;\\n        for (int g = 0; g < n; ++g) {\\n            for (int i = 0, j = g; j < n; ++i, ++j) {\\n                if (g == 0) dp[i][j] = true;\\n                else if (g == 1) dp[i][j] = s[i] == s[j];\\n                else dp[i][j] = s[i] == s[j] && dp[i + 1][j - 1];\\n                \\n                if (dp[i][j]) {\\n                    len = g + 1;\\n                    start = i;\\n                }\\n            }\\n        }\\n        \\n        return s.substr(start, len);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 635659,
                "title": "the-art-of-dynamic-programming",
                "content": "[\\uD83C\\uDFA8 The ART of Dynamic Programming:](https://leetcode.com/discuss/general-discussion/712010/The-ART-of-Dynamic-Programming-An-Intuitive-Approach%3A-from-Apprentice-to-Master) we can use a \"best ending here\" at each `j`<sup>th</sup> ending index for each `i..j` candidate.  We start `i` and `j` as adjacent indices and expand `i` to-the-left (ie. away from `j`) one index as a time attempting to expand upon existing palindromes for the subproblem of `i..j`, ie. `i + 1..j - 1`.\\n\\nSo the base cases for each ending `j`<sup>th</sup> index is a diagonal line:\\n\\n```\\nN = 4\\n\\ndp = [[1,0,0,0],\\n      [0,1,0,0],\\n      [0,0,1,0],\\n      [0,0,0,1]]\\n```\\n\\nAnd the recurrence relation starts with `i` and `j` as adjacent indices and `i` iterates to-the-left in an attempt to expand existing palindromes ending at `j`:\\n\\n```\\nN = 4\\n\\ndp = [[j,0,0,0],\\n   \\uD83D\\uDC48 [i,j,0,0],\\n   \\uD83D\\uDC48 [i,i,j,0],\\n   \\uD83D\\uDC48 [i,i,i,j]]\\n```\\n\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun longestPalindrome(s: String): String {\\n        var N = s.length\\n        var dp = Array(N) { BooleanArray(N) { false } }\\n        for (i in 0 until N)\\n            dp[i][i] = true\\n        var best = \"${s[0]}\"\\n        for (j in 1 until N) {\\n            for (i in j - 1 downTo 0) {\\n                if (s[i] == s[j] && (i + 1 == j || dp[i + 1][j - 1])) {\\n                    dp[i][j] = true\\n                    if (best.length < j - i + 1)\\n                        best = s.substring(i, j + 1)\\n                }\\n            }\\n        }\\n        return best\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet longestPalindrome = s => {\\n    let N = s.length;\\n    let dp = [...Array(N)].map(_ => Array(N).fill(0));\\n    let best = s[0];\\n    for (let i = 0; i < N; ++i)\\n        dp[i][i] = 1;\\n    for (let j = 1; j < N; ++j) {\\n        for (let i = j - 1; 0 <= i; --i) {\\n            if (s[i] == s[j] && (i + 1 == j || dp[i + 1][j - 1])) {\\n                dp[i][j] = 1;\\n                if (best.length < j - i + 1)\\n                    best = s.substring(i, j + 1);\\n            }\\n        }\\n    }\\n    return best;\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def longestPalindrome(self, s: str) -> str:\\n        N = len(s)\\n        dp = [[False] * N for _ in range(N)]\\n        for i in range(N):\\n            dp[i][i] = True\\n        best = f\\'{s[0]}\\'\\n        for j in range(1, N):\\n            for i in range(j - 1, -1, -1):\\n                if s[i] == s[j] and (i + 1 == j or dp[i + 1][j - 1]):\\n                    dp[i][j] = True\\n                    if len(best) < j - i + 1:\\n                        best = s[i:j + 1]\\n        return best\\n```\\n\\n*Rust*\\n```\\ntype VC = Vec<char>;\\nimpl Solution {\\n    pub fn longest_palindrome(s: String) -> String {\\n        let N = s.len();\\n        let s: VC = s.chars().collect();\\n        let mut dp = vec![vec![false; N]; N];\\n        for i in 0..N {\\n            dp[i][i] = true;\\n        }\\n        let mut best: VC = vec![s[0]];\\n        for j in 1..N {\\n            for i in 0..j {\\n                dp[i][j] = s[i] == s[j] && (i + 1 == j || dp[i + 1][j - 1]);\\n                if dp[i][j] && best.len() < j - i + 1 {\\n                    best = s[i..=j].to_vec().into_iter().collect();\\n                }\\n            }\\n        }\\n        best.into_iter().collect()\\n    }\\n}\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    string longestPalindrome(string s) {\\n        int N = s.size();\\n        VVI dp(N, VI(N));\\n        for (auto i{ 0 }; i < N; ++i)\\n            dp[i][i] = 1;\\n        auto best = string(1, s[0]);\\n        for (auto j{ 1 }; j < N; ++j) {\\n            for (auto i{ j - 1 }; 0 <= i; --i) {\\n                if (s[i] == s[j] && (i + 1 == j || dp[i + 1][j - 1])) {\\n                    dp[i][j] = 1;\\n                    if (best.size() < j - i + 1)\\n                        best = s.substr(i, j - i + 1);\\n                }\\n            }\\n        }\\n        return best;\\n    }\\n};\\n```\\n\\n---\\n\\n**May 17<sup>th</sup>, 2020:**\\n\\n**Top-Down: TLE**\\n\\nReduce `s` from the outside-in, starting with the outter-most indexes `i = 0` and `j = N - 1`.  We have 3 use-cases to consider for finding the maximum palindrome for each substring of `s[i..j]`:\\n\\n* **Case 1:** the sub-problem without the character at index `i`\\n* **Case 2:** the sub-problem without the character at index `j`\\n* **Case 3:** the sub-problem without the character at index `i` and `j`\\n\\n**Base Case:** when i and j are the same index or adjacent indices (ie. `j - i < 2`)\\n\\n**Note:** Even with a memo this top-down solution will TLE.\\n\\n*Javascript*\\n```\\nlet longestPalindrome = s => {\\n    let N = s.length;\\n    if (!N) return \\'\\';\\n    let ans = s[0];\\n    let best = (i, j) => {\\n        if (ans.length < j - i + 1)      // +1 for i..j inclusive\\n            ans = s.substring(i, j + 1); // +1 for i..j inclusive \\uD83C\\uDFAF\\n    };\\n    let go = (i = 0, j = N - 1) => {\\n        if (j - i < 2) {\\n            if (s[i] == s[j]) {\\n                best(i, j);\\n                return true;\\n            }\\n            return false;\\n        }\\n        go(i + 1, j);           // case 1: the sub-problem without the character at index i\\n        go(i, j - 1);           // case 2: the sub-problem without the character at index j\\n        if (go(i + 1, j - 1)) { // case 3: the sub-problem without the character at index i and j\\n            if (s[i] == s[j]) {\\n                best(i, j);\\n                return true;\\n            }\\n        }\\n        return false;\\n    };\\n    go();\\n    return ans;\\n};\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n\\tstring longestPalindrome(string s) {\\n\\t\\tint N = s.size();\\n\\t\\tif (!N) return {};\\n\\t\\tstring ans{ s[0] };\\n\\t\\tgo(ans, s, 0, N - 1);\\n\\t\\treturn ans;\\n\\t}\\nprivate:\\n\\tbool go(string& ans, string& s, int i, int j) {\\n\\t\\tauto best = [&](auto i, auto j) {\\n\\t\\t\\tif (ans.size() < j - i + 1)        // +1 for i..j inclusive\\n\\t\\t\\t\\tans = s.substr(i, j - i + 1);  // +1 for i..j inclusive \\uD83C\\uDFAF\\n\\t\\t};\\n\\t\\tif (j - i < 2) {\\n\\t\\t\\tif (s[i] == s[j]) {\\n\\t\\t\\t\\tbest(i, j);\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\tgo(ans, s, i + 1, j);           // case 1: the sub-problem without the character at index i\\n\\t\\tgo(ans, s, i, j - 1);           // case 2: the sub-problem without the character at index j\\n\\t\\tif (go(ans, s, i + 1, j - 1)) { // case 3: the sub-problem without the character at index i and j\\n\\t\\t\\tif (s[i] == s[j]) {\\n\\t\\t\\t\\tbest(i, j);\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn false;\\n\\t}\\n};\\n```\\n\\n---\\n\\n**Bottom-Up DP: AC**\\n\\nSame dynamic programming idea as above, but flipped upside-down.  Start with the base cases (ie. palindromes of length 0 or 1) and generate larger palindromes based on the previously found palindromes.\\n\\nLet `dp[i][j]` be true if and only if there exists a palindrome from `s[i..j]` inclusive.\\n\\n* **Recurrence Relation:** `dp[i][j] = s[i] == s[j] && dp[i + 1][j - 1]`\\n\\nThis means that `s[i..j]` is a palindrome if the outter-most indices `i`,`j` contain the same character (ie. `s[i] == s[j]`) and the middle portion of `s` in-between the outter-most indices `i`,`j` is a palindrome.\\n\\n* **Base Case:** when i and j are the same index or adjacent indices (ie. `j - i < 2`)\\n\\n*Javascript*\\n```\\nlet longestPalindrome = s => {\\n    let N = s.length;\\n    if (!N) return \\'\\';\\n    let ans = s[0];\\n    let dp = [...Array(N)].map(row => Array(N).fill(false));\\n    for (let j = 1; j < N; ++j) {\\n        for (let i = j; i >= 0; --i) {\\n            dp[i][j] = s[i] == s[j] && (j - i < 2 || dp[i + 1][j - 1]);\\n            if (dp[i][j] && ans.length < j - i + 1)\\n                ans = s.substring(i, j + 1); // +1 for i..j inclusive \\uD83C\\uDFAF\\n        }\\n    }\\n    return ans;\\n};\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    string longestPalindrome(string s) {\\n        int N = s.size();\\n        if (!N) return {};\\n        VVI dp(N, VI(N));\\n        string ans{ s[0] };\\n        for (auto j{ 1 }; j < N; ++j) {\\n            for (auto i{ j }; i >= 0; --i) {\\n                dp[i][j] = s[i] == s[j] && (j - i < 2 || dp[i + 1][j - 1]);\\n                if (dp[i][j] && ans.size() < j - i + 1)\\n                    ans = s.substr(i, j - i + 1); // +1 for i..j inclusive \\uD83C\\uDFAF\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n---\\n\\n**Brute Force: AC**\\n\\nIteratively expand palindromes from their middle outwards.  There are 2 use cases to consider:\\n\\n* **Case 1:** odd length palindromes have a single middle index `i`\\n* **Case 2:** even length palindromes have two middle indexes `i` and `i + 1`\\n\\n*Javascript*\\n```\\nlet longestPalindrome = (s, ans = \\'\\') => {\\n    let N = s.length;\\n    if (!N) return ans;\\n    ans = s[0];\\n    let expand = (i, j) => {\\n        for (; 0 <= i && j < N && s[i] == s[j]; --i, ++j)\\n            if (ans.length < j - i + 1)\\n                ans = s.substring(i, j + 1); // +1 for i..j inclusive \\uD83C\\uDFAF\\n    };\\n    for (let i = 0; i + 1 < N; ++i)\\n        expand(i, i),     // case 1: odd length palindrome\\n        expand(i, i + 1); // case 2: even length palindrome\\n    return ans;\\n};\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    string longestPalindrome(string s, string ans = {}) {\\n        int N = s.size();\\n        if (!N) return {};\\n        ans = s[0];\\n        auto expand = [&](auto i, auto j) {\\n            for (; 0 <= i && j < N && s[i] == s[j]; --i, ++j)\\n                if (ans.size() < j - i + 1)\\n                    ans = s.substr(i, j - i + 1); // +1 for i..j inclusive \\uD83C\\uDFAF\\n        };\\n        for (auto i{ 0 }; i + 1 < N; ++i)\\n            expand(i, i),     // case 1: odd length palindrome\\n            expand(i, i + 1); // case 2: even length palindrome\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nN = 4\\n\\ndp = [[1,0,0,0],\\n      [0,1,0,0],\\n      [0,0,1,0],\\n      [0,0,0,1]]\\n```\n```\\nN = 4\\n\\ndp = [[j,0,0,0],\\n   \\uD83D\\uDC48 [i,j,0,0],\\n   \\uD83D\\uDC48 [i,i,j,0],\\n   \\uD83D\\uDC48 [i,i,i,j]]\\n```\n```\\nclass Solution {\\n    fun longestPalindrome(s: String): String {\\n        var N = s.length\\n        var dp = Array(N) { BooleanArray(N) { false } }\\n        for (i in 0 until N)\\n            dp[i][i] = true\\n        var best = \"${s[0]}\"\\n        for (j in 1 until N) {\\n            for (i in j - 1 downTo 0) {\\n                if (s[i] == s[j] && (i + 1 == j || dp[i + 1][j - 1])) {\\n                    dp[i][j] = true\\n                    if (best.length < j - i + 1)\\n                        best = s.substring(i, j + 1)\\n                }\\n            }\\n        }\\n        return best\\n    }\\n}\\n```\n```\\nlet longestPalindrome = s => {\\n    let N = s.length;\\n    let dp = [...Array(N)].map(_ => Array(N).fill(0));\\n    let best = s[0];\\n    for (let i = 0; i < N; ++i)\\n        dp[i][i] = 1;\\n    for (let j = 1; j < N; ++j) {\\n        for (let i = j - 1; 0 <= i; --i) {\\n            if (s[i] == s[j] && (i + 1 == j || dp[i + 1][j - 1])) {\\n                dp[i][j] = 1;\\n                if (best.length < j - i + 1)\\n                    best = s.substring(i, j + 1);\\n            }\\n        }\\n    }\\n    return best;\\n};\\n```\n```\\nclass Solution:\\n    def longestPalindrome(self, s: str) -> str:\\n        N = len(s)\\n        dp = [[False] * N for _ in range(N)]\\n        for i in range(N):\\n            dp[i][i] = True\\n        best = f\\'{s[0]}\\'\\n        for j in range(1, N):\\n            for i in range(j - 1, -1, -1):\\n                if s[i] == s[j] and (i + 1 == j or dp[i + 1][j - 1]):\\n                    dp[i][j] = True\\n                    if len(best) < j - i + 1:\\n                        best = s[i:j + 1]\\n        return best\\n```\n```\\ntype VC = Vec<char>;\\nimpl Solution {\\n    pub fn longest_palindrome(s: String) -> String {\\n        let N = s.len();\\n        let s: VC = s.chars().collect();\\n        let mut dp = vec![vec![false; N]; N];\\n        for i in 0..N {\\n            dp[i][i] = true;\\n        }\\n        let mut best: VC = vec![s[0]];\\n        for j in 1..N {\\n            for i in 0..j {\\n                dp[i][j] = s[i] == s[j] && (i + 1 == j || dp[i + 1][j - 1]);\\n                if dp[i][j] && best.len() < j - i + 1 {\\n                    best = s[i..=j].to_vec().into_iter().collect();\\n                }\\n            }\\n        }\\n        best.into_iter().collect()\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    string longestPalindrome(string s) {\\n        int N = s.size();\\n        VVI dp(N, VI(N));\\n        for (auto i{ 0 }; i < N; ++i)\\n            dp[i][i] = 1;\\n        auto best = string(1, s[0]);\\n        for (auto j{ 1 }; j < N; ++j) {\\n            for (auto i{ j - 1 }; 0 <= i; --i) {\\n                if (s[i] == s[j] && (i + 1 == j || dp[i + 1][j - 1])) {\\n                    dp[i][j] = 1;\\n                    if (best.size() < j - i + 1)\\n                        best = s.substr(i, j - i + 1);\\n                }\\n            }\\n        }\\n        return best;\\n    }\\n};\\n```\n```\\nlet longestPalindrome = s => {\\n    let N = s.length;\\n    if (!N) return \\'\\';\\n    let ans = s[0];\\n    let best = (i, j) => {\\n        if (ans.length < j - i + 1)      // +1 for i..j inclusive\\n            ans = s.substring(i, j + 1); // +1 for i..j inclusive \\uD83C\\uDFAF\\n    };\\n    let go = (i = 0, j = N - 1) => {\\n        if (j - i < 2) {\\n            if (s[i] == s[j]) {\\n                best(i, j);\\n                return true;\\n            }\\n            return false;\\n        }\\n        go(i + 1, j);           // case 1: the sub-problem without the character at index i\\n        go(i, j - 1);           // case 2: the sub-problem without the character at index j\\n        if (go(i + 1, j - 1)) { // case 3: the sub-problem without the character at index i and j\\n            if (s[i] == s[j]) {\\n                best(i, j);\\n                return true;\\n            }\\n        }\\n        return false;\\n    };\\n    go();\\n    return ans;\\n};\\n```\n```\\nclass Solution {\\npublic:\\n\\tstring longestPalindrome(string s) {\\n\\t\\tint N = s.size();\\n\\t\\tif (!N) return {};\\n\\t\\tstring ans{ s[0] };\\n\\t\\tgo(ans, s, 0, N - 1);\\n\\t\\treturn ans;\\n\\t}\\nprivate:\\n\\tbool go(string& ans, string& s, int i, int j) {\\n\\t\\tauto best = [&](auto i, auto j) {\\n\\t\\t\\tif (ans.size() < j - i + 1)        // +1 for i..j inclusive\\n\\t\\t\\t\\tans = s.substr(i, j - i + 1);  // +1 for i..j inclusive \\uD83C\\uDFAF\\n\\t\\t};\\n\\t\\tif (j - i < 2) {\\n\\t\\t\\tif (s[i] == s[j]) {\\n\\t\\t\\t\\tbest(i, j);\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\tgo(ans, s, i + 1, j);           // case 1: the sub-problem without the character at index i\\n\\t\\tgo(ans, s, i, j - 1);           // case 2: the sub-problem without the character at index j\\n\\t\\tif (go(ans, s, i + 1, j - 1)) { // case 3: the sub-problem without the character at index i and j\\n\\t\\t\\tif (s[i] == s[j]) {\\n\\t\\t\\t\\tbest(i, j);\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn false;\\n\\t}\\n};\\n```\n```\\nlet longestPalindrome = s => {\\n    let N = s.length;\\n    if (!N) return \\'\\';\\n    let ans = s[0];\\n    let dp = [...Array(N)].map(row => Array(N).fill(false));\\n    for (let j = 1; j < N; ++j) {\\n        for (let i = j; i >= 0; --i) {\\n            dp[i][j] = s[i] == s[j] && (j - i < 2 || dp[i + 1][j - 1]);\\n            if (dp[i][j] && ans.length < j - i + 1)\\n                ans = s.substring(i, j + 1); // +1 for i..j inclusive \\uD83C\\uDFAF\\n        }\\n    }\\n    return ans;\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    string longestPalindrome(string s) {\\n        int N = s.size();\\n        if (!N) return {};\\n        VVI dp(N, VI(N));\\n        string ans{ s[0] };\\n        for (auto j{ 1 }; j < N; ++j) {\\n            for (auto i{ j }; i >= 0; --i) {\\n                dp[i][j] = s[i] == s[j] && (j - i < 2 || dp[i + 1][j - 1]);\\n                if (dp[i][j] && ans.size() < j - i + 1)\\n                    ans = s.substr(i, j - i + 1); // +1 for i..j inclusive \\uD83C\\uDFAF\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nlet longestPalindrome = (s, ans = \\'\\') => {\\n    let N = s.length;\\n    if (!N) return ans;\\n    ans = s[0];\\n    let expand = (i, j) => {\\n        for (; 0 <= i && j < N && s[i] == s[j]; --i, ++j)\\n            if (ans.length < j - i + 1)\\n                ans = s.substring(i, j + 1); // +1 for i..j inclusive \\uD83C\\uDFAF\\n    };\\n    for (let i = 0; i + 1 < N; ++i)\\n        expand(i, i),     // case 1: odd length palindrome\\n        expand(i, i + 1); // case 2: even length palindrome\\n    return ans;\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    string longestPalindrome(string s, string ans = {}) {\\n        int N = s.size();\\n        if (!N) return {};\\n        ans = s[0];\\n        auto expand = [&](auto i, auto j) {\\n            for (; 0 <= i && j < N && s[i] == s[j]; --i, ++j)\\n                if (ans.size() < j - i + 1)\\n                    ans = s.substr(i, j - i + 1); // +1 for i..j inclusive \\uD83C\\uDFAF\\n        };\\n        for (auto i{ 0 }; i + 1 < N; ++i)\\n            expand(i, i),     // case 1: odd length palindrome\\n            expand(i, i + 1); // case 2: even length palindrome\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2983,
                "title": "anyone-pass-the-test-in-python",
                "content": "When I use  Java, it just runs fine and passes the tests. \\nBut when I use the same algorithm in Python, it timesout every time.\\nGot any idea?\\n\\npython code :\\n\\n    def longestPalindrome(self, s):\\n            if len(s) == 0:\\n                return 0\\n            n = len(s)\\n            dp = [[False for i in xrange(n)] for j in xrange(n)]\\n            start = 0\\n            longest_len = 0\\n            for i in xrange(n):\\n                dp[i][i] = True\\n    \\n            for length in xrange(2,n+1):\\n                for i in xrange(0, n-length+1):\\n                    j = i+length-1\\n                    if s[i] == s[j] and (dp[i+1][j-1] or i+1>j-1):\\n                        dp[i][j] = True\\n                        if length > longest_len:\\n                            longest_len = length\\n                            start = i\\n            return s[start:longest_len+1]\\n\\njava code:\\n\\n    public String longestPalindrome(String s) {\\n            if(s==null||s.length()==1) return s;\\n            char[] str = s.toCharArray();\\n            boolean[][] bPald = new boolean[s.length()][s.length()];\\n            int start =0,end,maxLength=Integer.MIN_VALUE;\\n            for(int i=0;i<s.length();i++){\\n                bPald[i][i]=true;\\n            }\\n            for(int i=2;i<=s.length();i++){\\n                for(int j=0;j<s.length()-i+1;j++){\\n                    end = j+i-1;\\n                    if((str[j]==str[end]&&(bPald[j+1][end-1]||(j+1>end-1)))){\\n                        bPald[j][end]=true;\\n                        if(i>maxLength){\\n                            start=j;\\n                            maxLength = i;\\n                        }\\n                    }\\n                }\\n            }\\n            return s.substring(start,start+maxLength);\\n        }",
                "solutionTags": [],
                "code": "When I use  Java, it just runs fine and passes the tests. \\nBut when I use the same algorithm in Python, it timesout every time.\\nGot any idea?\\n\\npython code :\\n\\n    def longestPalindrome(self, s):\\n            if len(s) == 0:\\n                return 0\\n            n = len(s)\\n            dp = [[False for i in xrange(n)] for j in xrange(n)]\\n            start = 0\\n            longest_len = 0\\n            for i in xrange(n):\\n                dp[i][i] = True\\n    \\n            for length in xrange(2,n+1):\\n                for i in xrange(0, n-length+1):\\n                    j = i+length-1\\n                    if s[i] == s[j] and (dp[i+1][j-1] or i+1>j-1):\\n                        dp[i][j] = True\\n                        if length > longest_len:\\n                            longest_len = length\\n                            start = i\\n            return s[start:longest_len+1]\\n\\njava code:\\n\\n    public String longestPalindrome(String s) {\\n            if(s==null||s.length()==1) return s;\\n            char[] str = s.toCharArray();\\n            boolean[][] bPald = new boolean[s.length()][s.length()];\\n            int start =0,end,maxLength=Integer.MIN_VALUE;\\n            for(int i=0;i<s.length();i++){\\n                bPald[i][i]=true;\\n            }\\n            for(int i=2;i<=s.length();i++){\\n                for(int j=0;j<s.length()-i+1;j++){\\n                    end = j+i-1;\\n                    if((str[j]==str[end]&&(bPald[j+1][end-1]||(j+1>end-1)))){\\n                        bPald[j][end]=true;\\n                        if(i>maxLength){\\n                            start=j;\\n                            maxLength = i;\\n                        }\\n                    }\\n                }\\n            }\\n            return s.substring(start,start+maxLength);\\n        }",
                "codeTag": "Python3"
            },
            {
                "id": 3086,
                "title": "clear-c-solution",
                "content": "    string longestPalindrome(string s) {\\n    \\tif (s.size() == 0 || s.size() == 1)\\n    \\t\\treturn s;\\n    \\tint start = 0, maxlen = 1;\\n        for(int i=0; i<s.size(); i++){\\n            int j=i, k=i;\\n            while(k<s.size()-1 && s[k] == s[k+1])\\n                k++;\\n            while(j>0 && k<s.size()-1 && s[j-1] == s[k+1]){\\n                k++;\\n                j--;\\n            }\\n            if(k-j+1 > maxlen){\\n                maxlen = k-j+1;\\n                start = j;\\n            }\\n        }\\n        return s.substr(start, maxlen);\\n    }",
                "solutionTags": [],
                "code": "    string longestPalindrome(string s) {\\n    \\tif (s.size() == 0 || s.size() == 1)\\n    \\t\\treturn s;\\n    \\tint start = 0, maxlen = 1;\\n        for(int i=0; i<s.size(); i++){\\n            int j=i, k=i;\\n            while(k<s.size()-1 && s[k] == s[k+1])\\n                k++;\\n            while(j>0 && k<s.size()-1 && s[j-1] == s[k+1]){\\n                k++;\\n                j--;\\n            }\\n            if(k-j+1 > maxlen){\\n                maxlen = k-j+1;\\n                start = j;\\n            }\\n        }\\n        return s.substr(start, maxlen);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3329,
                "title": "share-an-o-n-solution",
                "content": "    class Solution{\\n    public:\\n\\tstring longestPalindrome(string s){\\n\\t\\tint size=s.size(),i;\\n\\t\\tchar *t=new char[2*size+2],*q=t;\\n\\t\\tint *p=new int[2*size+1],mx=0,id=0,MAX=0,center=0;\\n\\t\\tfor(*q='#',i=0;i<size;++i,*++q='#')*++q=s[i];\\n\\n\\t\\tfor(*++q=0,p[0]=i=1;t[i];i++) {\\n\\t\\t\\tp[i]=mx>i?min(p[2*id-i],mx-i):1;\\n\\t\\t\\twhile(i+p[i]<=2*size+1 && t[i+p[i]]==t[i-p[i]])p[i]++;\\n\\t\\t\\tif(i+p[i]>mx)mx=i+p[i],id=i;\\n\\t\\t\\tif(p[i]>MAX)MAX=p[i],center=i;\\n\\t\\t}\\n\\t\\tdelete(p),delete(t);\\n\\t\\treturn s.substr((center-MAX+1)/2,MAX-1);\\n\\t}\\n    };\\n\\nImplement of the Manacher's algorithm, O(n) complexity, just 12ms!",
                "solutionTags": [],
                "code": "class Solution{\\n    public:\\n\\tstring longestPalindrome(string s){\\n\\t\\tint size=s.size(),i;\\n\\t\\tchar *t=new char[2*size+2],*q=t;\\n\\t\\tint *p=new int[2*size+1],mx=0,id=0,MAX=0,center=0;\\n\\t\\tfor(*q='#',i=0;i<size;++i,*++q='#')*++q=s[i];\\n\\n\\t\\tfor(*++q=0,p[0]=i=1;t[i];i++) {\\n\\t\\t\\tp[i]=mx>i?min(p[2*id-i],mx-i):1;\\n\\t\\t\\twhile(i+p[i]<=2*size+1 && t[i+p[i]]==t[i-p[i]])p[i]++;\\n\\t\\t\\tif(i+p[i]>mx)mx=i+p[i],id=i;\\n\\t\\t\\tif(p[i]>MAX)MAX=p[i],center=i;\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 3230,
                "title": "memory-limit-exceeded",
                "content": "I used DP to solve this problem. \\np[i][j] indicates whether sub string s[i...j] is a palindrome.\\nTo claim the two dimensional vector p[len][len], if I use \\n\\n    vector<vector<int> > p(len, vector<int>(len, 0));  \\n\\nIt will prompt \"Memory Limit Exceeded\"\\n\\nHowever, following works\\n\\n     int p[len][len];  \\n     memset(p, 0, len*len*sizeof(int));\\nCan anyone tell me the difference of the two? Many thanks in advance.",
                "solutionTags": [],
                "code": "I used DP to solve this problem. \\np[i][j] indicates whether sub string s[i...j] is a palindrome.\\nTo claim the two dimensional vector p[len][len], if I use \\n\\n    vector<vector<int> > p(len, vector<int>(len, 0));  \\n\\nIt will prompt \"Memory Limit Exceeded\"\\n\\nHowever, following works\\n\\n     int p[len][len];  \\n     memset(p, 0, len*len*sizeof(int));\\nCan anyone tell me the difference of the two? Many thanks in advance.",
                "codeTag": "Unknown"
            },
            {
                "id": 4094197,
                "title": "video-visualization-of-expand-from-centers-solution",
                "content": "https://youtu.be/E-tmN1OM9aA\\n\\nA brute force solution would first require generating every possible substring, which runs in O(n<sup>2</sup>) time.  Then, <i>for each</i> of those substrings, we have to check if they are a palindrome.  Since palindromes read the same forwards and backwards, we know that they have to be mirrored across the center.  So one way of testing for palindromes is to start in the middle of the string and work outwards, checking at each step to see if the characters are equal.  Since each palindrome check runs in O(n), the overall algorithm ends up running in O(n<sup>3</sup>) time.\\n\\nInstead, we can reduce this to O(n<sup>2</sup>) time by eliminating some redundant steps.  This is because we can find the longest palindromic substring for <i>all</i> substrings that have the <i>same</i> center in a single O(n) pass.  For example, if the string is `abcdedcfa`, and since we know that `e` is a palindrome by itself, then when we test `ded`, we don\\'t need to start from the center again.  We can only test the outer characters, the `d`.  And when we test `cdedc`, then since we know `ded` is a palindrome, again, we don\\'t need to start from the middle again.   We can just confirm that the `c`\\'s match up.\\n\\nNow if we expanded one more character, we would see that `b` does NOT equal `f`.  Not only does this mean that this substring is not a palindrome, it also means that all other longer palindromes centered on `e` won\\'t be palindromes either, so we don\\'t need to test the other substrings and we can just exit early.\\n\\nSo now the question is, how many different centers can a string have?  If the length of the substring is odd, then the center could be any of the characters.  If the length of the substring is even, then the center could lie <i>between</i> any two characters.  So in total, there are 2n - 1 centers (please see the video for a visualization of this).\\n\\nSo if visiting each center is O(n) and each palindrome check is O(n), then the algorithm now runs in O(n<sup>2</sup>) time.\\n\\n# Code\\n```\\nclass Solution:\\n    def longestPalindrome(self, s):\\n        def expand(l, r):\\n            while l >= 0 and r < len(s) and s[l] == s[r]:\\n                l -= 1\\n                r += 1\\n            return s[l+1:r]\\n\\n        result = \"\"\\n        for i in range(len(s)):\\n            sub1 = expand(i, i)\\n            if len(sub1) > len(result):\\n                result = sub1\\n            sub2 = expand(i, i+1)\\n            if len(sub2) > len(result):\\n                result = sub2\\n        return result\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def longestPalindrome(self, s):\\n        def expand(l, r):\\n            while l >= 0 and r < len(s) and s[l] == s[r]:\\n                l -= 1\\n                r += 1\\n            return s[l+1:r]\\n\\n        result = \"\"\\n        for i in range(len(s)):\\n            sub1 = expand(i, i)\\n            if len(sub1) > len(result):\\n                result = sub1\\n            sub2 = expand(i, i+1)\\n            if len(sub2) > len(result):\\n                result = sub2\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3985939,
                "title": "best-solution-on-leetcode",
                "content": "# **PLEASE UPVOTE MY SOLUTION IG YOU LIKE IT**\\n# **CONNECT WITH ME**\\n# **[https://www.linkedin.com/in/pratay-nandy-9ba57b229/]()**\\n# **[https://www.instagram.com/pratay_nandy/]()**\\n# Approach\\nInitialize start and maxLen variables to keep track of the starting index and maximum length of the palindromic substring found.\\n\\nLoop through each character c in the string s (from index 0 to n-1), treating it as the potential center of a palindrome.\\n\\nFor each center c, expand around it to find the longest palindromic substring. Check for both odd-length and even-length palindromes:\\n\\na. Odd-length palindrome: Expand around c by moving the left pointer left towards the left and the right pointer right towards the right, while checking if the characters at s[left] and s[right] are the same.\\n\\nb. Even-length palindrome: Expand around the center between c and c+1 by moving the left pointer left towards the left and the right pointer right towards the right, while checking if the characters at s[left] and s[right] are the same.\\n\\nCalculate the length of the palindrome found using right - left - 1.\\n\\nCompare the length of the current palindrome with the maxLen. If it\\'s greater, update maxLen and calculate the new start index of the longest palindrome.\\n\\nAfter iterating through all possible centers, use the start and maxLen to extract the longest palindromic substring using s.substr(start, maxLen).\\n\\nReturn the longest palindromic substring.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:0(n*n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:0(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n        int n = s.size();\\n        int start = 0, maxLen = 0;\\n\\n        for (int i = 0; i < n; i++) {\\n            // Check for odd length palindromes centered at i\\n            int len1 = expandAroundCenter(s, i, i);\\n            // Check for even length palindromes centered between i and i+1\\n            int len2 = expandAroundCenter(s, i, i + 1);\\n\\n            int len = max(len1, len2);\\n            if (len > maxLen) {\\n                maxLen = len;\\n                // Calculate starting index based on palindrome length\\n                start = i - (len - 1) / 2;\\n            }\\n        }\\n\\n        return s.substr(start, maxLen);\\n    }\\n\\nprivate:\\n    int expandAroundCenter(const string& s, int left, int right) {\\n        while (left >= 0 && right < s.size() && s[left] == s[right]) {\\n            left--;\\n            right++;\\n        }\\n        // Return the length of the palindrome found\\n        return right - left - 1;\\n    }\\n};\\n\\n```\\n\\n# Approach\\nint n = s.size();: This calculates the length of the input string s.\\n\\nstring ans; int maxi=0;: Initialize variables ans to store the longest palindromic substring found so far and maxi to store its length.\\n\\nvector<vector<int>> dp(n, vector<int>(n, 0));: Initialize a 2D vector dp of size n x n with all elements initially set to 0. The element dp[i][j] will store information about whether the substring from index i to index j is a palindrome and its length.\\n\\nThe nested loops using variables diff, i, and j iterate over different possible substrings of s.\\n\\ndiff represents the difference between j and i, indicating the length of the current substring being considered.\\n\\ni and j represent the starting and ending indices of the current substring under consideration.\\n\\nInside the loops, the code checks three cases to determine if the current substring is a palindrome:\\n\\nIf i and j are the same (i.e., single character), then the substring is a palindrome of length 1, so dp[i][j] is set to 1.\\n\\nIf the difference between j and i is 1 and the characters at these positions are the same, then the substring is a palindrome of length 2, so dp[i][j] is set to 2.\\n\\nFor other cases, the code checks if the characters at positions i and j are the same and if the substring within these positions (i+1 to j-1) is a palindrome. If both conditions are met, dp[i][j] is set to dp[i+1][j-1] + 2, indicating that the current substring is a palindrome of length dp[i+1][j-1] + 2.\\n\\nAfter updating dp[i][j], the code checks if the substring from index i to j is a palindrome (i.e., dp[i][j] is not 0) and if its length is greater than the current maxi. If both conditions are met, it updates maxi and sets ans to the substring using s.substr(i, maxi).\\n\\nFinally, the function returns the longest palindromic substring ans.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:0(n*n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:0(n*n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n        int n = s.size();\\n        string ans;\\n        int maxi=0;\\n        vector<vector<int>>dp(n,vector<int>(n,0));\\n        for(int diff=0;diff<n;diff++)\\n        {\\n            for(int i =0,j=i+diff;j<n;i++,j++)\\n            {\\n                if(i==j)\\n                {\\n                    // single letter is always a palindrome\\n                    dp[i][j]=1;\\n                }\\n                else if(diff==1)\\n                {\\n                    // if true then store 2 else 0 \\n                    dp[i][j]=(s[i]==s[j])?2:0;\\n                }\\n                else\\n                {\\n                    if(s[i]==s[j] && dp[i+1][j-1]!=0)\\n                    {\\n                        dp[i][j]=dp[i+1][j-1]+2;\\n                    }\\n                }\\n                if(dp[i][j] && j-i+1>maxi)\\n                {\\n                    maxi=j-i+1;\\n                    ans=s.substr(i,maxi);\\n                }\\n            }\\n        }\\n    return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n        int n = s.size();\\n        int start = 0, maxLen = 0;\\n\\n        for (int i = 0; i < n; i++) {\\n            // Check for odd length palindromes centered at i\\n            int len1 = expandAroundCenter(s, i, i);\\n            // Check for even length palindromes centered between i and i+1\\n            int len2 = expandAroundCenter(s, i, i + 1);\\n\\n            int len = max(len1, len2);\\n            if (len > maxLen) {\\n                maxLen = len;\\n                // Calculate starting index based on palindrome length\\n                start = i - (len - 1) / 2;\\n            }\\n        }\\n\\n        return s.substr(start, maxLen);\\n    }\\n\\nprivate:\\n    int expandAroundCenter(const string& s, int left, int right) {\\n        while (left >= 0 && right < s.size() && s[left] == s[right]) {\\n            left--;\\n            right++;\\n        }\\n        // Return the length of the palindrome found\\n        return right - left - 1;\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n        int n = s.size();\\n        string ans;\\n        int maxi=0;\\n        vector<vector<int>>dp(n,vector<int>(n,0));\\n        for(int diff=0;diff<n;diff++)\\n        {\\n            for(int i =0,j=i+diff;j<n;i++,j++)\\n            {\\n                if(i==j)\\n                {\\n                    // single letter is always a palindrome\\n                    dp[i][j]=1;\\n                }\\n                else if(diff==1)\\n                {\\n                    // if true then store 2 else 0 \\n                    dp[i][j]=(s[i]==s[j])?2:0;\\n                }\\n                else\\n                {\\n                    if(s[i]==s[j] && dp[i+1][j-1]!=0)\\n                    {\\n                        dp[i][j]=dp[i+1][j-1]+2;\\n                    }\\n                }\\n                if(dp[i][j] && j-i+1>maxi)\\n                {\\n                    maxi=j-i+1;\\n                    ans=s.substr(i,maxi);\\n                }\\n            }\\n        }\\n    return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3911431,
                "title": "python-beats-99-expanding-around-centers-approach-explained",
                "content": "# Intuition: Expanding Around Centers\\n\\nThe idea behind this approach is to consider every character in the string as a potential center of a palindrome and then expand around that center to find the longest palindromic substring.\\n\\nThere are two cases to consider for the center: \\n- One where the palindrome has an odd length (centered at a single character)\\n\\n![Image 002.png](https://assets.leetcode.com/users/images/ea3dbc12-fa80-4416-a2c4-413af3ecb415_1692270331.4220665.png)\\n\\n- Other where the palindrome has an even length (centered between two characters). \\n\\n![Image 001.png](https://assets.leetcode.com/users/images/30f5580c-2251-403f-90dd-606ee0f3b4d4_1692270361.2039485.png)\\n\\nBy considering both cases, the algorithm effectively explores all possible palindromic substrings.\\n\\n# Approach\\n1. The expandAroundCenter function is defined within the main function. This helper function takes two parameters, left and right, which represent the potential center indices of the palindrome being expanded. It tries to expand the palindrome by moving left to the left and right to the right while the characters at these indices are the same.\\n\\n1. The main function initializes an empty string longest to keep track of the longest palindromic substring found so far.\\n\\n1. It iterates through the characters of the input string s using a for loop. For each character at index i, it considers two possible cases for the center of the palindrome:\\n\\n1. Odd-length palindrome: The center is the character at index i.\\nEven-length palindrome: The center is between the characters at indices i and i + 1.\\n1. For each center, the expandAroundCenter function is called to find the longest palindromic substring that can be formed by expanding from that center.\\n\\n1. The lengths of the obtained palindromic substrings (palindrome1 and palindrome2) are compared with the length of the current longest palindromic substring. If the length of a newly found palindrome is greater, the longest is updated with that palindrome.\\n\\nFinally, the function returns the longest palindromic substring.\\n\\n# Complexity\\n- Time complexity:\\nThe main loop runs for each character in the string, and for each character, the expandAroundCenter function takes linear time to expand the palindrome. Hence, the total time complexity is O(N^2), where N is the length of the input string.\\n\\n- Space complexity:\\nThe space complexity is O(1) as no additional data structures are used that grow with the input size.\\n\\n# Code\\n```\\nclass Solution(object):\\n    def longestPalindrome(self, s):\\n        def expandAroundCenter(left, right):\\n            while left >= 0 and right < len(s) and s[left] == s[right]:\\n                left -= 1\\n                right += 1\\n            return s[left + 1:right]\\n\\n        longest = \"\"\\n        for i in range(len(s)):\\n            # Odd length palindrome\\n            palindrome1 = expandAroundCenter(i, i)\\n            # Even length palindrome\\n            palindrome2 = expandAroundCenter(i, i + 1)\\n\\n            if len(palindrome1) > len(longest):\\n                longest = palindrome1\\n            if len(palindrome2) > len(longest):\\n                longest = palindrome2\\n\\n        return longest\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution(object):\\n    def longestPalindrome(self, s):\\n        def expandAroundCenter(left, right):\\n            while left >= 0 and right < len(s) and s[left] == s[right]:\\n                left -= 1\\n                right += 1\\n            return s[left + 1:right]\\n\\n        longest = \"\"\\n        for i in range(len(s)):\\n            # Odd length palindrome\\n            palindrome1 = expandAroundCenter(i, i)\\n            # Even length palindrome\\n            palindrome2 = expandAroundCenter(i, i + 1)\\n\\n            if len(palindrome1) > len(longest):\\n                longest = palindrome1\\n            if len(palindrome2) > len(longest):\\n                longest = palindrome2\\n\\n        return longest\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3274605,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSolved using DP.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(s^2)\\n\\n# Code\\n```\\nclass Solution {\\n    public String longestPalindrome(String s) {\\n        boolean dp[][]=new boolean[s.length()][s.length()];\\n\\t\\tint a=0;\\n\\t\\tint b=0;\\n\\t\\tfor(int gap=0;gap<s.length();gap++) {\\n\\t\\t\\tfor(int i=0,j=gap;j<s.length();i++,j++) {\\n\\t\\t\\t\\tif(gap==0) {\\n\\t\\t\\t\\t\\tdp[i][j]=true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if(gap==1) {\\n\\t\\t\\t\\t\\tif(s.charAt(i)==s.charAt(j)) {\\n\\t\\t\\t\\t\\t\\tdp[i][j]=true;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\t\\tdp[i][j]=false;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\tif(s.charAt(i)==s.charAt(j) && dp[i+1][j-1]==true) {\\n\\t\\t\\t\\t\\t\\tdp[i][j]=true;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\t\\tdp[i][j]=false;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(dp[i][j]) {\\n\\t\\t\\t\\t\\ta=i;\\n\\t\\t\\t\\t\\tb=j;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn s.substring(a,b+1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String longestPalindrome(String s) {\\n        boolean dp[][]=new boolean[s.length()][s.length()];\\n\\t\\tint a=0;\\n\\t\\tint b=0;\\n\\t\\tfor(int gap=0;gap<s.length();gap++) {\\n\\t\\t\\tfor(int i=0,j=gap;j<s.length();i++,j++) {\\n\\t\\t\\t\\tif(gap==0) {\\n\\t\\t\\t\\t\\tdp[i][j]=true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if(gap==1) {\\n\\t\\t\\t\\t\\tif(s.charAt(i)==s.charAt(j)) {\\n\\t\\t\\t\\t\\t\\tdp[i][j]=true;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\t\\tdp[i][j]=false;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\tif(s.charAt(i)==s.charAt(j) && dp[i+1][j-1]==true) {\\n\\t\\t\\t\\t\\t\\tdp[i][j]=true;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\t\\tdp[i][j]=false;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(dp[i][j]) {\\n\\t\\t\\t\\t\\ta=i;\\n\\t\\t\\t\\t\\tb=j;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn s.substring(a,b+1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2718979,
                "title": "python-solution-readable-code-with-thorough-explanation",
                "content": "# Intuition\\nIt took me a while to understand the solutions that other people were offering and the reason was simple, it\\'s because they all have terrible coding practices. Code should be easily read regardless of the space and time efficiency. \\n\\nSo this wasn\\'t necessarily my intuition and I tweaked what I saw in a way that I could and hopefully you understand. The idea is to expand outwards from any given index and determine if those sets of indices create a palindrome.\\n\\n\\n# Approach\\nThe explanation for this is pretty simple. We start at index = 0 and iterate through all values until n. At each index we call the function expandOutwards that will check the values to the left and right of the provided indices. It will continue to do so until the longest palindrome within the given range is found. \\n\\nIf you\\'re wondering why we call expandOutwards twice, look at the difference in values passed. A palindrome can have an even or odd set of values, so if we only account for scenarios where only one occurs, we will only get half the answer. \\n\\n\\n# Complexity\\n- Time complexity:\\nThe worst case time complexity is O(n^2). As we may need to check all values in a string everytime. You could probably visual this with an input like \"aaaaaaaaa\", where all values are always equal, so it checks everything. Notice that our program needs to check a string n^2 that can be easily confirmed as a palindrome, possible room for improvement. \\n\\n- Space complexity:\\nThis one can be tricky, but our space complexity is O(n) worst case. Pay close attention to the variable temp, i and k. They are all allocated within a local space that iterates for at most n times. Because each iteration needs a new area in memory, the space each requires directly correlates to the size of the input. In reality the space complexity is closer to 5n, but we remove the constant and just say n. \\n\\n# Notes: \\nIf you have any questions or ways to improve this code, please discuss it below. Hopefully this helps someone. Best regards.\\n\\n# Code\\n```\\nclass Solution:\\n    def longestPalindrome(self, s: str) -> str:\\n        \\n        n = len(s) # Length of the input\\n\\n        if n == 1:\\n            return s\\n\\n        def expandOutwards(start, end):\\n\\n            i = start\\n            k = end\\n\\n            if s[i] != s[k]:\\n                return \"\"\\n\\n            while(i-1 >= 0 and k+1 < n and s[i-1] == s[k+1]): \\n                i-=1\\n                k+=1\\n\\n            return s[i:k+1]\\n\\n        pal1 = \"\"\\n        pal2 = \"\"\\n        longPal = \"\"\\n\\n        for i in range(0, n-1):\\n\\n            pal1 = expandOutwards(i, i)\\n            pal2 = expandOutwards(i, i+1)\\n\\n            # Conditional assignment statement\\n            temp = pal1 if len(pal1) > len(pal2) else pal2\\n\\n            if len(temp) > len(longPal):\\n                longPal = temp\\n        \\n        return longPal\\n\\n                \\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestPalindrome(self, s: str) -> str:\\n        \\n        n = len(s) # Length of the input\\n\\n        if n == 1:\\n            return s\\n\\n        def expandOutwards(start, end):\\n\\n            i = start\\n            k = end\\n\\n            if s[i] != s[k]:\\n                return \"\"\\n\\n            while(i-1 >= 0 and k+1 < n and s[i-1] == s[k+1]): \\n                i-=1\\n                k+=1\\n\\n            return s[i:k+1]\\n\\n        pal1 = \"\"\\n        pal2 = \"\"\\n        longPal = \"\"\\n\\n        for i in range(0, n-1):\\n\\n            pal1 = expandOutwards(i, i)\\n            pal2 = expandOutwards(i, i+1)\\n\\n            # Conditional assignment statement\\n            temp = pal1 if len(pal1) > len(pal2) else pal2\\n\\n            if len(temp) > len(longPal):\\n                longPal = temp\\n        \\n        return longPal\\n\\n                \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2628442,
                "title": "simple-recursive-memoization-code",
                "content": "class Solution {\\npublic:\\n\\n    int solve(const string &s,vector<vector<int>> &dp, int i, int j){\\n        \\n        if(i==j || i>j) return 1;   \\n        if(dp[i][j]!=-1)return dp[i][j];\\n        \\n        if(s[i]==s[j]) dp[i][j]=solve(s,dp,i+1,j-1);\\n        else dp[i][j]=0;\\n        \\n        solve(s,dp,i+1,j);\\n        solve(s,dp,i,j-1);\\n      \\n        return dp[i][j];  \\n    }\\n    \\n    string longestPalindrome(string s) {\\n        \\n        int n=s.length();\\n        vector<vector<int>> dp(n+1,vector<int>(n+1,-1));\\n\\n        solve(s,dp,0,n-1);\\n        int x=0,y=0;\\n        \\n        for(int i=0; i<=n; i++)\\n            for(int j=i+1; j<=n; j++)\\n                if(dp[i][j]==1 && j-i>y-x) x=i,y=j;\\n        \\n        return s.substr(x,y-x+1);\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int solve(const string &s,vector<vector<int>> &dp, int i, int j){\\n        \\n        if(i==j || i>j) return 1;   \\n        if(dp[i][j]!=-1)return dp[i][j];\\n        \\n        if(s[i]==s[j]) dp[i][j]=solve(s,dp,i+1,j-1);\\n        else dp[i][j]=0;\\n        \\n        solve(s,dp,i+1,j);\\n        solve(s,dp,i,j-1);\\n      \\n        return dp[i][j];  \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2176873,
                "title": "go-o-n-2-with-hashmap",
                "content": "```\\nfunc longestPalindrome(s string) string {\\n    if len(s) < 2 {return s}\\n    \\n    res := fmt.Sprintf(\"%c\", s[0])\\n    \\n    var isPalindromic func(string) bool\\n    isPalindromic = func(str string) bool {\\n        if len(str) < 2 {return true}\\n        \\n        l, r := 0, len(str) - 1\\n        \\n        for l < r {\\n            if str[l] != str[r] {\\n                return false\\n            }\\n            \\n            l++\\n            r--\\n        }\\n        \\n        return true\\n    }\\n    \\n    m := make(map[byte][]int)\\n    \\n    for i := 0; i < len(s); i++ {\\n        m[s[i]] = append(m[s[i]], i)\\n        \\n        if len(m[s[i]]) > 1 {\\n            for _, val := range m[s[i]] {\\n                if i != val && isPalindromic(s[val:i+1]) {\\n                    if i - val + 1 > len(res) {\\n                        res = s[val:i+1]\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    \\n    return res\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc longestPalindrome(s string) string {\\n    if len(s) < 2 {return s}\\n    \\n    res := fmt.Sprintf(\"%c\", s[0])\\n    \\n    var isPalindromic func(string) bool\\n    isPalindromic = func(str string) bool {\\n        if len(str) < 2 {return true}\\n        \\n        l, r := 0, len(str) - 1\\n        \\n        for l < r {\\n            if str[l] != str[r] {\\n                return false\\n            }\\n            \\n            l++\\n            r--\\n        }\\n        \\n        return true\\n    }\\n    \\n    m := make(map[byte][]int)\\n    \\n    for i := 0; i < len(s); i++ {\\n        m[s[i]] = append(m[s[i]], i)\\n        \\n        if len(m[s[i]]) > 1 {\\n            for _, val := range m[s[i]] {\\n                if i != val && isPalindromic(s[val:i+1]) {\\n                    if i - val + 1 > len(res) {\\n                        res = s[val:i+1]\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    \\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2169666,
                "title": "easy-c-solution-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n        int n = s.size();\\n        vector<vector<bool>> dp(s.size(), vector<bool>(n, false));\\n        int ans=0, start;\\n        for(int i=0; i<n; ++i)\\n            for(int j=0; j+i<n; ++j){\\n                if(i==0)    dp[j][j+i] = true;\\n                else if(i==1 and s[j]==s[j+i]) dp[j][j+i] = true;\\n                else if(i>1 and s[j]==s[j+i] and dp[j+1][j+i-1]) dp[j][j+i] = true;\\n                if(dp[j][j+i])  ans = i, start=j;\\n            }\\n        return s.substr(start,ans+1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n        int n = s.size();\\n        vector<vector<bool>> dp(s.size(), vector<bool>(n, false));\\n        int ans=0, start;\\n        for(int i=0; i<n; ++i)\\n            for(int j=0; j+i<n; ++j){\\n                if(i==0)    dp[j][j+i] = true;\\n                else if(i==1 and s[j]==s[j+i]) dp[j][j+i] = true;\\n                else if(i>1 and s[j]==s[j+i] and dp[j+1][j+i-1]) dp[j][j+i] = true;\\n                if(dp[j][j+i])  ans = i, start=j;\\n            }\\n        return s.substr(start,ans+1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2157123,
                "title": "longest-palindrome-map-different-approach",
                "content": "Hi All,\\n\\nThere are many dp solution for this problem, but I want to try without using dp so I went for Map implementation.\\n\\nBasic idea behind map implementation is any string of size one is a palindrome and a string can be palindrome only if has any previous occurance, so store the indexes of all the previous occurances in a map and check for palindrome.\\n\\n1. we can iterate through the given string once \\n2. read each charecter one by one and see if it has any previous occurance\\n3. if its not first occurance check if the substring is returning as palindrome\\n4. check the maximum length size and return the substring which has maximum length.\\n\\nKindly upvote if this is helpful or like my effort.. Happy learning..\\n\\n```\\npublic String longestPalindrome(String s) {\\n        int max = 0;\\n        String res = \"\";\\n        TreeMap<Character, List<Integer>> map = new TreeMap<>();\\n        for(int j=0; j<s.length(); j++){\\n        \\tchar ch = s.charAt(j);\\n        \\tList<Integer> list = new ArrayList<Integer>();\\n        \\tif(map.containsKey(ch)){\\n        \\t\\tlist.addAll(map.get(ch));\\n        \\t}\\n        \\tlist.add(j);\\n        \\tfor(int i:list){\\n        \\t\\tif(isPalindrome(s.substring(i, j+1))){\\n        \\t\\t\\tif(max<j-i+1){\\n        \\t\\t\\t\\tmax = j-i+1;\\n        \\t\\t\\t\\tres = s.substring(i, j+1);\\n        \\t\\t\\t}\\n        \\t\\t}\\n        \\t}\\n        \\tmap.put(ch, list);\\n        }\\n        return res;\\n    }\\n    \\n\\tprivate boolean isPalindrome(String ori) {\\n\\t\\tif(ori.length()==1)\\n\\t\\t\\treturn true;\\n\\t\\tfor(int i=0; i<ori.length()/2; i++)\\n\\t\\t\\tif(ori.charAt(i)!=ori.charAt(ori.length()-1-i))\\n\\t\\t\\t\\treturn false;\\n\\t\\treturn true;\\n\\t}",
                "solutionTags": [
                    "Java"
                ],
                "code": "Hi All,\\n\\nThere are many dp solution for this problem, but I want to try without using dp so I went for Map implementation.\\n\\nBasic idea behind map implementation is any string of size one is a palindrome and a string can be palindrome only if has any previous occurance, so store the indexes of all the previous occurances in a map and check for palindrome.\\n\\n1. we can iterate through the given string once \\n2. read each charecter one by one and see if it has any previous occurance\\n3. if its not first occurance check if the substring is returning as palindrome\\n4. check the maximum length size and return the substring which has maximum length.\\n\\nKindly upvote if this is helpful or like my effort.. Happy learning..\\n\\n```\\npublic String longestPalindrome(String s) {\\n        int max = 0;\\n        String res = \"\";\\n        TreeMap<Character, List<Integer>> map = new TreeMap<>();\\n        for(int j=0; j<s.length(); j++){\\n        \\tchar ch = s.charAt(j);\\n        \\tList<Integer> list = new ArrayList<Integer>();\\n        \\tif(map.containsKey(ch)){\\n        \\t\\tlist.addAll(map.get(ch));\\n        \\t}\\n        \\tlist.add(j);\\n        \\tfor(int i:list){\\n        \\t\\tif(isPalindrome(s.substring(i, j+1))){\\n        \\t\\t\\tif(max<j-i+1){\\n        \\t\\t\\t\\tmax = j-i+1;\\n        \\t\\t\\t\\tres = s.substring(i, j+1);\\n        \\t\\t\\t}\\n        \\t\\t}\\n        \\t}\\n        \\tmap.put(ch, list);\\n        }\\n        return res;\\n    }\\n    \\n\\tprivate boolean isPalindrome(String ori) {\\n\\t\\tif(ori.length()==1)\\n\\t\\t\\treturn true;\\n\\t\\tfor(int i=0; i<ori.length()/2; i++)\\n\\t\\t\\tif(ori.charAt(i)!=ori.charAt(ori.length()-1-i))\\n\\t\\t\\t\\treturn false;\\n\\t\\treturn true;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 1934817,
                "title": "manacher-s-algorithm-with-detailed-explanation-examples-derived-from-expanding-from-indices",
                "content": "The Idea of Manacher\\'s Algorithm is basically the same as expanding from each index but with memoization optimization .\\n\\nThus let\\'s first understand the unoptimized solution - expanding from each index.\\n# Expanding from each index\\n\\n## Step 1 - Insert bogus characters\\n\\nThe reason for inserting bogus characters is that we can cover both even and odd substring length with the same expanding algorithm to determine if current substring is palindromic.\\n\\n![image](https://assets.leetcode.com/users/images/90711e7d-ca57-4c81-8863-b8c1bf0cd9f0_1649640805.6467702.png)\\n\\n```\\n    // Step1 insert bogus character\\n    var buffer bytes.Buffer\\n    buffer.WriteByte(\\'*\\')\\n    for i := 0 ;i < len(s);i ++ {\\n        buffer.WriteByte(s[i])\\n        buffer.WriteByte(\\'*\\')\\n    }\\n    sp := buffer.String()\\n    /***\\n    with bugos characters inserted, we only have to conver the case of expanding from a single point\\n    This is because when expanding from \"*\" we are covering the even length case eg, \"a*b\"\\n    \\n    babad => *b*a*b*a*d*\\n    cbbd => *c*b*b*d*\\n    \\n    ***/\\n```\\n\\n## Step2 - Expanding from each index and look for palindromic substring\\n\\n* loop through our new string(with bogus)\\n* expand around each index to find the maximum radius  from that index.\\n* record the starting index and the radius if the radius is better than previous best radius.\\n\\n![image](https://assets.leetcode.com/users/images/7b607ef7-a679-416a-805e-a89061ffb9b1_1649641583.4892864.png)\\n\\n```\\n\\tcenter := 0\\n    radius := 0\\n    for center < len(sp) {\\n        for center-radius-1 >= 0 && center+radius+1 < len(sp){\\n            if sp[center-radius-1] == sp[center+radius+1] {\\n                radius++  \\n            } else {\\n                break\\n            }\\n        }\\n\\t\\t\\n        if radius >= max {\\n            max = radius\\n            maxIdx = center\\n        }\\n\\t\\t\\n        center++\\n        radius = 0\\n    }\\n```\\n---\\n## Step 3 - Construct our answer\\n#### Notice we use *i += 2*  when advancing the index to skip all \"*\" in the substring\\n```\\n\\tss := sp[maxIdx-max: maxIdx+max+1]\\n    buffer.Reset()\\n    for i := 1 ; i < len(ss); i+=2 {\\n        buffer.WriteByte(ss[i])\\n    }\\n\\t\\n    return buffer.String()\\n```\\n---\\n# Optimize with Cache\\n## Caching Previous Answers\\nInstead of simply replacing *maxIdx* and *maxRadius* each time, we will cache the *radius* of each index in a int array\\n\\nThis is a bit inefficient compare to our previous step 2, because we need to loop through our cache to find the maxIndex and maxRadius,\\nand we are using more space. But, it\\'s worth it, we will see why it is the case in the next step.\\n```\\n  \\n    dp := make([]int, len(sp))\\n    center := 0\\n    radius := 0\\n    for center < len(sp) {\\n        for center-radius-1 >= 0 && center+radius+1 < len(sp){\\n            if sp[center-radius-1] == sp[center+radius+1] {\\n                radius++  \\n            } else {\\n                break\\n            }\\n        }\\n        dp[center] = radius\\n        center++\\n        radius = 0\\n\\t}\\n\\tmax := 0\\n    maxIdx := 0\\n    for i := 0 ; i< len(dp); i++ {\\n        if dp[i] > max {\\n           max = dp[i]\\n           maxIdx = i\\n        }\\n    }\\n```\\n\\n\\n## Utilizing Previous Radius to Save Computation \\nAfter we successfully process some index (expand around i) and for this index we have a positive radius (meaning we have a palindromic substring) , we can easily determine (in some cases) the next few radius starting from *i +1* ending at *i + radius*\\n\\nLet\\'s consider this situation:\\n![image](https://assets.leetcode.com/users/images/70ff2759-b05f-4e92-8be9-ec2d2be0905d_1649643430.1442566.png)\\n\\nNotice how index 4 and 6, index 3 and 7 are mirrored.\\n![image](https://assets.leetcode.com/users/images/dc4618ab-f72e-4a91-935f-3fbb62821f1b_1649643704.2999575.png)\\n\\nThe question here is, can we determine index 6\\'s radius by utilizing index 4\\'s radius?\\nAnd can we get index 7\\'s radius by utilizing index 3\\'s radius?\\n\\nThe answer is yes. We need to consider three cases;\\n\\n----\\n\\n#### Let\\'s first consider index 6 with \\'a\\'\\n\\nAt index 4, we have radius of 0, that means the longest palindromic substring expanding from index 4 is \"a\" by its self\\n\\nAnd more importantly, the entire substring is contained by the palindromic substring starting from 3 ending at 7\\n\\n![image](https://assets.leetcode.com/users/images/0af9820e-49d4-4e3e-b8d3-081094ba9ce8_1649699043.7512739.png)\\n\\n\\nThus, with a bit more thinking we come to the conclusion, for some index i coming after center and before upperbound (inclusive), if the mirrored index of i has radius of R, and i + R <= upperBound, then Radius at i is equal to i\\'s mirror\\'s Radius.\\n\\n\\n----\\n\\n### Then consider index 7 with \\'c\\'\\n\\nAt index 3, we have the mirror of index 7.\\nIndex 3 expands to a palindromic substring with radius 3\\n![image](https://assets.leetcode.com/users/images/2c04b252-0733-41a1-8a2c-42df9f682f6a_1649644566.4374194.png)\\n\\nSince index 3 is the center of a palindromic string with radius 3\\nThus, the substring starting at 0 ending at 2, should be the mirror image of substring starting at 4 ending at 6\\n\\nIf index 7 is the center of a palindromic string with radius 3\\nThen, index 8 to 10 should be the mirror image of index 0 to 2\\n\\n\\n---\\n\\n### BUT \\nif that\\'s the cause, the Palindromic string centered at 5 should have a Radius of 5 instead what we actually have a Radius of 2.\\n\\n![image](https://assets.leetcode.com/users/images/1d5484be-5804-45d8-ad8b-6effce841355_1649644951.216274.png)\\n\\n\\n\\n![image](https://assets.leetcode.com/users/images/6b563c12-c4ce-49ab-8aa7-011f2852d3ad_1649699355.075187.png)\\n\\nWith further analysis we can come to the conclusion: for index i coming after the center and before the upperbound,\\nif the mirrored index has a radius that is greater than the distance from i to upperbound, then index i expands to a Palindromic string with radius *upperbound - i*\\n\\n----\\n### Therefore \\n\\nWhen  radius of mirror index does not equal to upperbound - i, we can get the Radius of Index i by looking at the Radius of Index i\\'s mirror.\\n\\npseudo code\\n```\\nif (RadiusOf(mirrorI) != upperBound - i) {\\n\\tRadiusOf(i) = MinOf( RadiusOf(mirrorI), upperBound - i)\\n}\\n```\\n\\n\\n### Finally we have the last case to consider\\n\\nWhen distance from i to upperbound is equal to the radius of the mirrored index of i, we can\\'t have a determinant answer for radius of i.\\n\\nConsider this example:\\n![image](https://assets.leetcode.com/users/images/d4d58735-3edb-4233-a195-94ee9a24f9ed_1649645497.2187436.png)\\n\\n\\nNotice the mirroed C has a radius of 1, which equals to the distance between the latter C and the upper bound.\\nIn this case, we can\\'t decide the Radius of the latter C.\\n\\n![image](https://assets.leetcode.com/users/images/1b788514-3be4-4aff-b8b8-087757ce6ae1_1649645788.2858694.png)\\n\\nThus in this case, we need to expand from the latter C to find out its Radius.\\nGood news is that we don\\'t have to start from Radius 0, we can simply start from Mirrored Radius or the distance between C and upperbound.\\n\\n---\\n\\n## Some Math\\n\\n![image](https://assets.leetcode.com/users/images/346ced13-8389-47a8-a008-1804a0aca792_1649646536.4637523.png)\\n\\n----\\nfor case 1 and 2, we just need to find MinOf( mmr, mirroredRadius), then increment center by 1, set radius to 0\\nfor case 3, we should increment the center index and let the radius = mmr\\n```\\n\\t    oldCenter, oldRadius := center,radius\\n        upperBound := oldCenter + oldRadius\\n        \\n        center++\\n        radius = 0\\n        for center <= upperBound {\\n            mirror := 2*oldCenter - center\\n            mmr := upperBound - center\\n            \\n            if dp[mirror] == mmr {\\n                radius = mmr\\n                break\\n            } \\n            \\n            dp[center] = minOf(dp[mirror], mmr)\\n            center++\\n        }\\n```\\n\\n## Conclusion\\nThe full solution (You can probably optimize this solution even more)\\n```\\nfunc longestPalindrome(s string) string {\\n    // Step 1\\n    var buffer bytes.Buffer\\n    buffer.WriteByte(\\'*\\')\\n    for i := 0 ;i < len(s);i ++ {\\n        buffer.WriteByte(s[i])\\n        buffer.WriteByte(\\'*\\')\\n    }\\n    sp := buffer.String()\\n    \\n    // Step2\\n    dp := make([]int, len(sp))\\n    center := 0\\n    radius := 0\\n    for center < len(sp) {\\n        for center-radius-1 >= 0 && center+radius+1 < len(sp){\\n            if sp[center-radius-1] == sp[center+radius+1] {\\n                radius++  \\n            } else {\\n                break\\n            }\\n        }\\n        dp[center] = radius\\n        \\n        oldCenter, oldRadius := center,radius\\n        upperBound := oldCenter+oldRadius\\n        \\n        center++\\n        radius = 0\\n        for center <= upperBound {\\n            mirror := 2*oldCenter - center\\n            mmr := upperBound - center\\n            \\n            if dp[mirror] == mmr {\\n                radius = mmr\\n                break\\n            } \\n            \\n            dp[center] = minOf(dp[mirror], mmr)\\n            center++\\n        }\\n    }\\n\\t\\n\\t//Step 3\\n    \\n    max := 0\\n    maxIdx := 0\\n    for i := 0 ; i< len(dp); i++ {\\n        if dp[i] > max {\\n            max = dp[i]\\n            maxIdx = i\\n        }\\n    }\\n    ss := sp[maxIdx-max: maxIdx+max+1]\\n    buffer.Reset()\\n    for i := 1 ; i < len(ss); i+=2 {\\n        buffer.WriteByte(ss[i])\\n    }\\n    return buffer.String()\\n}\\n\\nfunc minOf(a,b int) int {\\n    if a < b {\\n        return a\\n    }\\n    return b\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Dynamic Programming"
                ],
                "code": "```\\n    // Step1 insert bogus character\\n    var buffer bytes.Buffer\\n    buffer.WriteByte(\\'*\\')\\n    for i := 0 ;i < len(s);i ++ {\\n        buffer.WriteByte(s[i])\\n        buffer.WriteByte(\\'*\\')\\n    }\\n    sp := buffer.String()\\n    /***\\n    with bugos characters inserted, we only have to conver the case of expanding from a single point\\n    This is because when expanding from \"*\" we are covering the even length case eg, \"a*b\"\\n    \\n    babad => *b*a*b*a*d*\\n    cbbd => *c*b*b*d*\\n    \\n    ***/\\n```\n```\\n\\tcenter := 0\\n    radius := 0\\n    for center < len(sp) {\\n        for center-radius-1 >= 0 && center+radius+1 < len(sp){\\n            if sp[center-radius-1] == sp[center+radius+1] {\\n                radius++  \\n            } else {\\n                break\\n            }\\n        }\\n\\t\\t\\n        if radius >= max {\\n            max = radius\\n            maxIdx = center\\n        }\\n\\t\\t\\n        center++\\n        radius = 0\\n    }\\n```\n```\\n\\tss := sp[maxIdx-max: maxIdx+max+1]\\n    buffer.Reset()\\n    for i := 1 ; i < len(ss); i+=2 {\\n        buffer.WriteByte(ss[i])\\n    }\\n\\t\\n    return buffer.String()\\n```\n```\\n  \\n    dp := make([]int, len(sp))\\n    center := 0\\n    radius := 0\\n    for center < len(sp) {\\n        for center-radius-1 >= 0 && center+radius+1 < len(sp){\\n            if sp[center-radius-1] == sp[center+radius+1] {\\n                radius++  \\n            } else {\\n                break\\n            }\\n        }\\n        dp[center] = radius\\n        center++\\n        radius = 0\\n\\t}\\n\\tmax := 0\\n    maxIdx := 0\\n    for i := 0 ; i< len(dp); i++ {\\n        if dp[i] > max {\\n           max = dp[i]\\n           maxIdx = i\\n        }\\n    }\\n```\n```\\nif (RadiusOf(mirrorI) != upperBound - i) {\\n\\tRadiusOf(i) = MinOf( RadiusOf(mirrorI), upperBound - i)\\n}\\n```\n```\\n\\t    oldCenter, oldRadius := center,radius\\n        upperBound := oldCenter + oldRadius\\n        \\n        center++\\n        radius = 0\\n        for center <= upperBound {\\n            mirror := 2*oldCenter - center\\n            mmr := upperBound - center\\n            \\n            if dp[mirror] == mmr {\\n                radius = mmr\\n                break\\n            } \\n            \\n            dp[center] = minOf(dp[mirror], mmr)\\n            center++\\n        }\\n```\n```\\nfunc longestPalindrome(s string) string {\\n    // Step 1\\n    var buffer bytes.Buffer\\n    buffer.WriteByte(\\'*\\')\\n    for i := 0 ;i < len(s);i ++ {\\n        buffer.WriteByte(s[i])\\n        buffer.WriteByte(\\'*\\')\\n    }\\n    sp := buffer.String()\\n    \\n    // Step2\\n    dp := make([]int, len(sp))\\n    center := 0\\n    radius := 0\\n    for center < len(sp) {\\n        for center-radius-1 >= 0 && center+radius+1 < len(sp){\\n            if sp[center-radius-1] == sp[center+radius+1] {\\n                radius++  \\n            } else {\\n                break\\n            }\\n        }\\n        dp[center] = radius\\n        \\n        oldCenter, oldRadius := center,radius\\n        upperBound := oldCenter+oldRadius\\n        \\n        center++\\n        radius = 0\\n        for center <= upperBound {\\n            mirror := 2*oldCenter - center\\n            mmr := upperBound - center\\n            \\n            if dp[mirror] == mmr {\\n                radius = mmr\\n                break\\n            } \\n            \\n            dp[center] = minOf(dp[mirror], mmr)\\n            center++\\n        }\\n    }\\n\\t\\n\\t//Step 3\\n    \\n    max := 0\\n    maxIdx := 0\\n    for i := 0 ; i< len(dp); i++ {\\n        if dp[i] > max {\\n            max = dp[i]\\n            maxIdx = i\\n        }\\n    }\\n    ss := sp[maxIdx-max: maxIdx+max+1]\\n    buffer.Reset()\\n    for i := 1 ; i < len(ss); i+=2 {\\n        buffer.WriteByte(ss[i])\\n    }\\n    return buffer.String()\\n}\\n\\nfunc minOf(a,b int) int {\\n    if a < b {\\n        return a\\n    }\\n    return b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1485213,
                "title": "swift-solution",
                "content": "```\\nclass Solution {\\n    func longestPalindrome(_ s: String) -> String {\\n        var result = \"\"\\n        for index in 0 ..< s.count {\\n            let temp = getLongestPalindrome(i: index, s: s)\\n            if temp.count > result.count {\\n                result = temp\\n            }\\n        }\\n        return result\\n    }\\n\\n    func getLongestPalindrome(i: Int, s: String) -> String {\\n        var left = i\\n        var right = i\\n        let charArr = Array(s)\\n\\n        while (left - 1 >= 0 && charArr[left] == charArr[left - 1]) {\\n            left -= 1\\n        }\\n\\n        while (right + 1 < charArr.count && charArr[right] == charArr[right + 1]) {\\n            right += 1\\n        }\\n\\n        while (left - 1 >= 0 && right + 1 < charArr.count && charArr[left - 1] == charArr[right + 1]) {\\n            left -= 1\\n            right += 1\\n        }\\n\\n        return String(charArr[left ... right])\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func longestPalindrome(_ s: String) -> String {\\n        var result = \"\"\\n        for index in 0 ..< s.count {\\n            let temp = getLongestPalindrome(i: index, s: s)\\n            if temp.count > result.count {\\n                result = temp\\n            }\\n        }\\n        return result\\n    }\\n\\n    func getLongestPalindrome(i: Int, s: String) -> String {\\n        var left = i\\n        var right = i\\n        let charArr = Array(s)\\n\\n        while (left - 1 >= 0 && charArr[left] == charArr[left - 1]) {\\n            left -= 1\\n        }\\n\\n        while (right + 1 < charArr.count && charArr[right] == charArr[right + 1]) {\\n            right += 1\\n        }\\n\\n        while (left - 1 >= 0 && right + 1 < charArr.count && charArr[left - 1] == charArr[right + 1]) {\\n            left -= 1\\n            right += 1\\n        }\\n\\n        return String(charArr[left ... right])\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1224561,
                "title": "dynamic-programming-python-c-commented-solution",
                "content": "python\\n```\\nclass Solution:\\n    def longestPalindrome(self, s: str) -> str:\\n        # Dynamic Programming\\n        n = len(s)\\n        # Default to pick the first element if no palindrom found longer than 1\\n        longest, begin = 1, 0\\n        dp = [[None] * n for _ in range(n)]\\n        # All charactors itself is a palindrom:\\\\\\n        for i in range(n):\\n            dp[i][i] = True\\n        # Try all possible substring lengths\\n        for length in range(2, n + 1):\\n            # Try all starting point\\n            for start in range(n):\\n                # Get ending index\\n                end = start + length - 1\\n                # Check if end index is larger than the total length\\n                if end >= n:\\n                    break\\n                # s[start : end] will only be palindrom is the first and the last element is the same\\n                if s[start] != s[end]:\\n                    dp[start][end] = False\\n                else:\\n                    # s[start : end] will be a palendrom if [start + 1 : end - 1] is a panlindrom\\n                    if length <= 2:\\n                        dp[start][end] = True\\n                    else:\\n                        dp[start][end] = dp[start + 1][end - 1]\\n                # If s[start : end] is palindrom, compare the length with max length\\n                if dp[start][end]:\\n                    if length > longest:\\n                        longest = length\\n                        begin = start\\n        return s[begin : begin + longest]\\n```\\n\\nc\\n```\\nchar * longestPalindrome(char * s){\\n    // Dynamic Programming\\n    int n = strlen(s);\\n    // Default the begin and longest so that we can pick the first element if no palindrom longer than 1 charactor can be found\\n    int begin = 0;\\n    int longest = 1;\\n    // dp array\\n    bool dp[n][n];\\n    memset( dp, false, n*n*sizeof(bool) );\\n    \\n    // Base case: only one charactor\\n    for (int i = 0; i < n; i++)\\n    {\\n        dp[i][i] = true;\\n    }\\n    \\n    // Sub questions: substring with length of x\\n    for (int length = 2; length <= n; length++)\\n    {\\n        // Sub questions: substring with starting index of x\\n        for (int start = 0; start < n; start++)\\n        {\\n            int end = start + length - 1;\\n            // No need to check if end is out of bound\\n            if (end >= n)\\n            {\\n                break;\\n            }\\n            \\n            // Palindrom only exist when start and end are the same\\n            if (s[start] != s[end])\\n            {\\n                dp[start][end] = false;\\n            }\\n            else\\n            {\\n                // When length is 1 or 2, no need to check if it contains any palindrom substring\\n                if (length <= 2)\\n                {\\n                    dp[start][end] = true;\\n                }\\n                // Check if one index smaller at the beginning and the end is a palindrom substring\\n                else\\n                {\\n                    dp[start][end] = dp[start+1][end-1];\\n                }\\n            }\\n            // Check it the current substing is a palindrom\\n            if (dp[start][end])\\n            {\\n                // Compare the current substring with the longest\\n                if (length > longest)\\n                {\\n                    longest = length;\\n                    begin = start;\\n                }\\n            }\\n        }\\n    }\\n    // Get target substring\\n    char *result = malloc(n+1);\\n    strncpy(result, s+begin, longest);\\n    // Set the last index as ending char so that result is a string.\\n    result[longest] = 0;\\n    return result;\\n    \\n}\\n```",
                "solutionTags": [
                    "Python",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def longestPalindrome(self, s: str) -> str:\\n        # Dynamic Programming\\n        n = len(s)\\n        # Default to pick the first element if no palindrom found longer than 1\\n        longest, begin = 1, 0\\n        dp = [[None] * n for _ in range(n)]\\n        # All charactors itself is a palindrom:\\\\\\n        for i in range(n):\\n            dp[i][i] = True\\n        # Try all possible substring lengths\\n        for length in range(2, n + 1):\\n            # Try all starting point\\n            for start in range(n):\\n                # Get ending index\\n                end = start + length - 1\\n                # Check if end index is larger than the total length\\n                if end >= n:\\n                    break\\n                # s[start : end] will only be palindrom is the first and the last element is the same\\n                if s[start] != s[end]:\\n                    dp[start][end] = False\\n                else:\\n                    # s[start : end] will be a palendrom if [start + 1 : end - 1] is a panlindrom\\n                    if length <= 2:\\n                        dp[start][end] = True\\n                    else:\\n                        dp[start][end] = dp[start + 1][end - 1]\\n                # If s[start : end] is palindrom, compare the length with max length\\n                if dp[start][end]:\\n                    if length > longest:\\n                        longest = length\\n                        begin = start\\n        return s[begin : begin + longest]\\n```\n```\\nchar * longestPalindrome(char * s){\\n    // Dynamic Programming\\n    int n = strlen(s);\\n    // Default the begin and longest so that we can pick the first element if no palindrom longer than 1 charactor can be found\\n    int begin = 0;\\n    int longest = 1;\\n    // dp array\\n    bool dp[n][n];\\n    memset( dp, false, n*n*sizeof(bool) );\\n    \\n    // Base case: only one charactor\\n    for (int i = 0; i < n; i++)\\n    {\\n        dp[i][i] = true;\\n    }\\n    \\n    // Sub questions: substring with length of x\\n    for (int length = 2; length <= n; length++)\\n    {\\n        // Sub questions: substring with starting index of x\\n        for (int start = 0; start < n; start++)\\n        {\\n            int end = start + length - 1;\\n            // No need to check if end is out of bound\\n            if (end >= n)\\n            {\\n                break;\\n            }\\n            \\n            // Palindrom only exist when start and end are the same\\n            if (s[start] != s[end])\\n            {\\n                dp[start][end] = false;\\n            }\\n            else\\n            {\\n                // When length is 1 or 2, no need to check if it contains any palindrom substring\\n                if (length <= 2)\\n                {\\n                    dp[start][end] = true;\\n                }\\n                // Check if one index smaller at the beginning and the end is a palindrom substring\\n                else\\n                {\\n                    dp[start][end] = dp[start+1][end-1];\\n                }\\n            }\\n            // Check it the current substing is a palindrom\\n            if (dp[start][end])\\n            {\\n                // Compare the current substring with the longest\\n                if (length > longest)\\n                {\\n                    longest = length;\\n                    begin = start;\\n                }\\n            }\\n        }\\n    }\\n    // Get target substring\\n    char *result = malloc(n+1);\\n    strncpy(result, s+begin, longest);\\n    // Set the last index as ending char so that result is a string.\\n    result[longest] = 0;\\n    return result;\\n    \\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1671198,
                "content": [
                    {
                        "username": "ZenMasterV",
                        "content": "Seems like too many of the  coding wunderkinds here lack basic reading comprehension skills \\n\" Please don\\'t post any solutions in this discussion tab\"\\nIt\\'s almost the rule to find the exact opposite for the discussion of every question. I don\\'t want to see your damned solution!"
                    },
                    {
                        "username": "NeroXIII",
                        "content": "[@charonme](/charonme) name does not check out :((("
                    },
                    {
                        "username": "192731",
                        "content": "and if they do?"
                    },
                    {
                        "username": "plevi1995",
                        "content": "Excellent comment"
                    },
                    {
                        "username": "khan60939",
                        "content": "Can anyone tell how DP is being used here? "
                    },
                    {
                        "username": "sandagolcea",
                        "content": "[@charonme](/charonme) my thinking exactly, but at least they should create a flag to help us moderate and move solutions to the correct tab. Would only need a stack overflow moderation-like system: one person flags, another person receives a queue of flagged comments and confirms the tagging.. oh well"
                    },
                    {
                        "username": "charonme",
                        "content": "maybe people get confused by the official leetcode comment which says: \"If you\\'d like to share a detailed solution to the problem, please create a new post in the discuss section\"\\nMaybe some time ago they didn\\'t have a separate solutions section and only recently changed it, but left some of the old solutions in the discussion section and didn\\'t fix the automated comment worting?"
                    },
                    {
                        "username": "klanjewar037",
                        "content": "hehe"
                    },
                    {
                        "username": "sanemdeepak",
                        "content": "For input \"ac\" test case is expecting \"a\" as output, how is just \"a\" a palindromic string?"
                    },
                    {
                        "username": "ayushiidevpura",
                        "content": "because when we read \"a\" from forward it results in \"a\" and at the same time when we read \"a\" from backward it is still \"a\""
                    },
                    {
                        "username": "beyzigo",
                        "content": "Because if you read the string \"a\" backwards it will still be \"a\""
                    },
                    {
                        "username": "tsafackghokeng",
                        "content": "[@Chouhan_Gourav](/Chouhan_Gourav) the test case said \"ac\" not \"a\". is \"ac\" palindromic? for \"a\" i understand"
                    },
                    {
                        "username": "CODEWITHABHINAV",
                        "content": "you have to submit the first string as your answer read more about this question on gFg\\n"
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "any string is palindrome if we read it same from front and from back\\nin single character we read it same from front and back"
                    },
                    {
                        "username": "oinrup",
                        "content": "yes thats my question too"
                    },
                    {
                        "username": "yldemon",
                        "content": "Any character in the string by itself is a palindromic substring. So in the case where there is no palindromic substring with length > 1, you can return any character."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "Whenever you come accross such contradiction, just google the definition, any. Any string is called is pallindromic if the reverse of the string is equal to the original string. Reverse of \\'a\\' is \\'a\\'. Hope you get this."
                    },
                    {
                        "username": "947876275",
                        "content": "This post is for learner wanna practice DP.\\nThe basic idea is, if we wanna say \"aba\" is palindromic, then we need to firstly confirm that \"b\" is palindromic, then we also need to check if \"a\"(the first a) = \"a\" (the second a).\\n\\nM is a 2-d array which stores boolean values.\\nM[i][j] indicates if string[i.....j] is palindromic.\\nSo base cases are:\\nM[i][i] is true.\\nM[i][i + 1] = (s[i] == s[i + 1]);\\nrecurrence relation is :\\nM[i][j] = (s[i] == s[j] AND M[i + 1][j - 1]);\\nFor the implementation of recurrence relation, one idea is you can loop through all possible symmetry axis. For each of the axis, you expand at both RHS and LHS simultaneously. This method promises that when you are determining value in M[i][j], M[i + 1][j - 1] must have the correct value.\\nFinal answer can be found from all M[i][j] == 1 with largest (j - i)."
                    },
                    {
                        "username": "Msey",
                        "content": "thank you, cat brother"
                    },
                    {
                        "username": "user0558y",
                        "content": "I understand the solution but I don't understand why it needs any storage at all or why it needs to be a DP solution.\n\nThe condition `(s[i] == s[j] AND M[i + 1][j - 1])` requires you to memorise if `M[i+1][j-1]` is true, that's easy to understand. However, if you expand each possible axis at the same time, i.e. 1st iteration (s[i+1], s[j-1]), 2nd iteration `s[i+2], s[j-2]`, ... It is guaranteed that M[i+1][j-1] is always true and hence can be dropped, and you should break the loop when it is not true.\n\nIn summary, you don't need to memorise anything at all and you just need to check `s[i] == s[j]` while expanding in both directions at the same time, unless I have misunderstood anything? Here is an implementation of your algorithm but without storage: https://leetcode.com/problems/longest-palindromic-substring/submissions/868540120/"
                    },
                    {
                        "username": "taras",
                        "content": "Thank you! this is a beautiful explanation, though I\\'m not sure what exactly you mean by expanding both on LHS and RHS. In my implementation it\\'s enough to compute all diagonals of  the upper right triangle of the dp matrix."
                    },
                    {
                        "username": "klu_2100031593",
                        "content": "super explanation"
                    },
                    {
                        "username": "napoleon",
                        "content": "My Solution Is Naive, It Cost O(n^2), Is there Any Solution faster?"
                    },
                    {
                        "username": "leocampos",
                        "content": "[@tylerprill-rhdc](/tylerprill-rhdc) So, what I did was:\nStated in my mind the Brute Force approach - create every possible substring and test each one to see if is a palindrome and find the longest.\n\nOf course this would be ridiculously slow, so let's improve it.\nI also mentally stated that a palindrome has a recursive aspect -> if single char, or two equal chars, or charX + palindrome + charX\nSo I created a isPalindrome recursive method that checked it delegating to itself extracting the borders.\n\nSince a palindrome must start and end with the same char, in my traverse of the string, I started storing the position of each character Map<Character, List< Integer>>, so I would just go back to the previous found Char and check if from there to the current pointer I would have a Palindrome.\n\nThen I stopped doing this for every possible palindrome, I then started doing only for the ones that COULD be longer than the already found longest palindrome. That accelerated a lot.\n\nIn the almost last step, I added memoization. Remember that a palindrome is like a sandwich, with the external chars being equal and the meat being another palindrome? So I stored the found palindromes using their start and and positions. So I could check if that had already being checked and if so, either return true or false directly.\n\nThe final step was to convert the recursive function to an iterative function to save some memory used by the call stack.\nMaybe there are better implementations, just sharing my thought process."
                    },
                    {
                        "username": "tylerprill-rhdc",
                        "content": "[@tylerprill-rhdc](/tylerprill-rhdc) Two pointer based solution is also a really good solve here"
                    },
                    {
                        "username": "tylerprill-rhdc",
                        "content": "This could be done in a single pass algorithm, but will inherently check character indices multiple times based on the nature of the problem. (basically, iterate through each, then bubble out from each index)"
                    },
                    {
                        "username": "neetika",
                        "content": "From the leetcode blog, one of the methods of solving this is:\\n\\nA common mistake:\\nSome people will be tempted to come up with a quick solution, which is unfortunately flawed (however can be corrected easily):\\n\\nReverse S and become S\\u2019. Find the longest common substring between S and S\\u2019, which must also be the longest palindromic substring.\\nThis seemed to work, let\\u2019s see some examples below.\\n\\nFor example,\\nS = \\u201ccaba\\u201d, S\\u2019 = \\u201cabac\\u201d.\\nThe longest common substring between S and S\\u2019 is \\u201caba\\u201d, which is the answer.\\n\\nLet\\u2019s try another example:\\nS = \\u201cabacdfgdcaba\\u201d, S\\u2019 = \\u201cabacdgfdcaba\\u201d.\\nThe longest common substring between S and S\\u2019 is \\u201cabacd\\u201d. Clearly, this is not a valid palindrome.\\n\\n**We could see that the longest common substring method fails when there exists a reversed copy of a non-palindromic substring in some other part of S. To rectify this, each time we find a longest common substring candidate, we check if the substring\\u2019s indices are the same as the reversed substring\\u2019s original indices. If it is, then we attempt to update the longest palindrome found so far; if not, we skip this and find the next candidate.**\\n\\nIs this part correct? \\n\\nexample string: abcxycba\\nreverse string:  abcxycba\\n\\nThe substring indices are same as reversed string original indices and yet it is not a palindrome?"
                    },
                    {
                        "username": "HRVY_SNOWDEN",
                        "content": "cool sirr:)\\n"
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "WRONG.\\n\\nabcxycba reversed is abcyxcba."
                    },
                    {
                        "username": "travisl12",
                        "content": "After I solved this problem I thought it\\'d be interesting to see how it worked in realtime.\\n\\nhttps://codepen.io/TravisL12/pen/pogvweg"
                    },
                    {
                        "username": "user3907vj",
                        "content": "thanks for the \"nanananananana\" from all the small things ;)"
                    },
                    {
                        "username": "zapataast",
                        "content": "u are crazy"
                    },
                    {
                        "username": "sondq98",
                        "content": "very intuitive"
                    },
                    {
                        "username": "Tathagat017",
                        "content": "thank you\\n"
                    },
                    {
                        "username": "mikler",
                        "content": "So I think I finally understood logic of test creators. \\nEven if you write a classical DP or memorization solution for this one you will timeout on latest tests.\\nI think they consider it edge cases. Because if you add one simple line it will pass! OMG. \\nI have leet code for this. Instead of solving problems I spend hours optimizing the constants.\\n\\nif s == s[::-1]: return s"
                    },
                    {
                        "username": "Vectorido",
                        "content": "Don\\'t work already. Time limit at 141 test even with that construction."
                    },
                    {
                        "username": "deepalithakur17",
                        "content": "It will only work in python."
                    },
                    {
                        "username": "ishogbon",
                        "content": "Its memoization, not memorization "
                    },
                    {
                        "username": "84danie",
                        "content": "I submitted my solution, and received a Time Limit Exceeded on this test case:\\n\\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabcaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n\\nSo I copied and pasted the TC into a custom test case, and started to think about what I could tweak. However, I ended up accidentally hitting Run Code, but instead of getting a Time Limit Exceeded result, it passed:\\n\\n![0_1479079812693_upload-4af9e94c-2e53-4915-acf6-782780c7bf8b](/uploads/files/1479079813717-upload-4af9e94c-2e53-4915-acf6-782780c7bf8b.png) \\n\\nIs this supposed to happen and I just need to make my code more efficient, or is this a bug? \\n![0_1479079956817_upload-1ef15826-d6e6-4bde-9c06-eb597c5c8d0e](/uploads/files/1479079957639-upload-1ef15826-d6e6-4bde-9c06-eb597c5c8d0e.png)"
                    },
                    {
                        "username": "RitikaSahay",
                        "content": "Same thing happened with me. Is there a solution for it?\\n"
                    },
                    {
                        "username": "danicruz0415",
                        "content": "It\\'s happened to me a couple of times. My theory is that the time limit is given for the whole list of test cases. Thus, you can have your test pass, but it will still time limit exceed because it wont get to calculate all the test cases before the time runs out. I cannot confirm this but I think its true because with a very unoptimized solution I got time limit exceeded very early in the test cases (for another problem), after some optimizations I got it much later (like getting to the last tests) which themselves were around the same size, so if the time limit was set per test it would not make sense to fail in a similarly long test-case just that is much later in the test list. (I think the same would apply to memory limit exceeded)"
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "The exact same situation happened with me in one problem... it was a DP problem too... I was getting a Memory Limit Exceeded error with the memoized solution but it was running fine in the Run Code button."
                    },
                    {
                        "username": "Hubro",
                        "content": "I\\'m getting \"Time Limit Exceeded\" with 141/141 testcases passed and \"Last Executed Input\" is:\\n\\n```\\ns =\\n```\\n\\nDid I break it?"
                    },
                    {
                        "username": "karan_dhiman",
                        "content": "same issue"
                    },
                    {
                        "username": "BLANK-Zora",
                        "content": "exactly bro this shit is recked , like it is giving tests outside the constraints , how am i suppose to include such things in the code"
                    },
                    {
                        "username": "arunprep5",
                        "content": "same issue. java"
                    },
                    {
                        "username": "blasphelmy",
                        "content": "[@tuancoltech](/tuancoltech) it worked when i rewrote the code in c# instead of c++"
                    },
                    {
                        "username": "tuancoltech",
                        "content": "[@blasphelmy](/blasphelmy) [@Tomas Sandven](/Hubro) Did you guys find out why? I got the same issue."
                    },
                    {
                        "username": "blasphelmy",
                        "content": "i got that too. im not sure whats going on given that the constraint for input is between 1 and 1000"
                    },
                    {
                        "username": "Vinitajain",
                        "content": "Hi All,\\nI have a test case which is failing, but I feel the testcase result is incorrect.Please refer the screenshot below.\\n![image](https://assets.leetcode.com/users/images/e9e42efb-63d5-4cfa-b420-f1926674f6dc_1654838015.8394327.png)\\n\\nThe longest palindromic substring is \"aaca\" but the test case result is \"aca\". Anyone else faced this problem?"
                    },
                    {
                        "username": "OthSO",
                        "content": "[@mohdansah10](/mohdansah10) \\nthey are separated in the input with \"bd\" so it is not a valid answer "
                    },
                    {
                        "username": "mohdansah10",
                        "content": "I\\'m getting same error, but different case:\\nInput\\ns =\\n\"aacabdkacaa\"\\n\\nOutput\\n\"aacakacaa\"\\nExpected\\n\"aca\"\\n\\nBut mine is Palindrome"
                    },
                    {
                        "username": "hasmithraa",
                        "content": "the expected is correct because aaca can\\'t be a palindrome only \\'aacaa\\' can be a palindrome which is not there in your case"
                    },
                    {
                        "username": "Amish_Singh",
                        "content": "how are you considering \"aaca\" as a palindromic substring, \"aca\" is a palindrome and it is the longest"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "dude you really came up with the solution "
                    },
                    {
                        "username": "AryaAditya3609",
                        "content": "how is \"aaca\" and \"acaa\" same ???\\nWhile \"aca\" is palindrome because both \"aca\" and reverse of it \"aca\" is same !!"
                    },
                    {
                        "username": "alexandra-pickle",
                        "content": "\"aaca\" is not a palindrome"
                    },
                    {
                        "username": "bugHackerLoop",
                        "content": "I followed the approach leant by Aditya Verma DP lectures and encountered the same test case failing. Does the logic where I reverse the string and calculate the longest common substring doesn\\'t work here? I know it works for longest palindromic subsequence but here it fails for such test cases .. why is it so?"
                    },
                    {
                        "username": "mductran",
                        "content": "how is \\'aaca\\' a palindrome? when read backward it\\'s \\'acaa\\' so it\\'s not the same reading forward."
                    },
                    {
                        "username": "jnsudhir",
                        "content": "Check my solution, it was able to clear test case \"aaca\". Explained code in comments.\\n\\nhttps://leetcode.com/problems/longest-palindromic-substring/solutions/3091016/longest-palindromic-substring-using-javascript-beats-94-82-in-runtime-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "nikhileshratna",
                        "content": "aaca is not palindrome"
                    },
                    {
                        "username": "sunshine77",
                        "content": "hey, iam getting the same error, i have seen ansewrs where they have totally changed the algorithm, how did u solve this by tweaking the same algoirhtm"
                    },
                    {
                        "username": "bhupendrabc71",
                        "content": "how come \"aaca\" is palindrome. it should be \"aca\""
                    },
                    {
                        "username": "just11blocks",
                        "content": "aaca is not a palindrome...aacaa and aca are."
                    },
                    {
                        "username": "odi1n",
                        "content": "I also encountered this problem"
                    },
                    {
                        "username": "vamsi2302",
                        "content": "I think you get it by now!\\n"
                    }
                ]
            },
            {
                "id": 1565544,
                "content": [
                    {
                        "username": "ZenMasterV",
                        "content": "Seems like too many of the  coding wunderkinds here lack basic reading comprehension skills \\n\" Please don\\'t post any solutions in this discussion tab\"\\nIt\\'s almost the rule to find the exact opposite for the discussion of every question. I don\\'t want to see your damned solution!"
                    },
                    {
                        "username": "NeroXIII",
                        "content": "[@charonme](/charonme) name does not check out :((("
                    },
                    {
                        "username": "192731",
                        "content": "and if they do?"
                    },
                    {
                        "username": "plevi1995",
                        "content": "Excellent comment"
                    },
                    {
                        "username": "khan60939",
                        "content": "Can anyone tell how DP is being used here? "
                    },
                    {
                        "username": "sandagolcea",
                        "content": "[@charonme](/charonme) my thinking exactly, but at least they should create a flag to help us moderate and move solutions to the correct tab. Would only need a stack overflow moderation-like system: one person flags, another person receives a queue of flagged comments and confirms the tagging.. oh well"
                    },
                    {
                        "username": "charonme",
                        "content": "maybe people get confused by the official leetcode comment which says: \"If you\\'d like to share a detailed solution to the problem, please create a new post in the discuss section\"\\nMaybe some time ago they didn\\'t have a separate solutions section and only recently changed it, but left some of the old solutions in the discussion section and didn\\'t fix the automated comment worting?"
                    },
                    {
                        "username": "klanjewar037",
                        "content": "hehe"
                    },
                    {
                        "username": "sanemdeepak",
                        "content": "For input \"ac\" test case is expecting \"a\" as output, how is just \"a\" a palindromic string?"
                    },
                    {
                        "username": "ayushiidevpura",
                        "content": "because when we read \"a\" from forward it results in \"a\" and at the same time when we read \"a\" from backward it is still \"a\""
                    },
                    {
                        "username": "beyzigo",
                        "content": "Because if you read the string \"a\" backwards it will still be \"a\""
                    },
                    {
                        "username": "tsafackghokeng",
                        "content": "[@Chouhan_Gourav](/Chouhan_Gourav) the test case said \"ac\" not \"a\". is \"ac\" palindromic? for \"a\" i understand"
                    },
                    {
                        "username": "CODEWITHABHINAV",
                        "content": "you have to submit the first string as your answer read more about this question on gFg\\n"
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "any string is palindrome if we read it same from front and from back\\nin single character we read it same from front and back"
                    },
                    {
                        "username": "oinrup",
                        "content": "yes thats my question too"
                    },
                    {
                        "username": "yldemon",
                        "content": "Any character in the string by itself is a palindromic substring. So in the case where there is no palindromic substring with length > 1, you can return any character."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "Whenever you come accross such contradiction, just google the definition, any. Any string is called is pallindromic if the reverse of the string is equal to the original string. Reverse of \\'a\\' is \\'a\\'. Hope you get this."
                    },
                    {
                        "username": "947876275",
                        "content": "This post is for learner wanna practice DP.\\nThe basic idea is, if we wanna say \"aba\" is palindromic, then we need to firstly confirm that \"b\" is palindromic, then we also need to check if \"a\"(the first a) = \"a\" (the second a).\\n\\nM is a 2-d array which stores boolean values.\\nM[i][j] indicates if string[i.....j] is palindromic.\\nSo base cases are:\\nM[i][i] is true.\\nM[i][i + 1] = (s[i] == s[i + 1]);\\nrecurrence relation is :\\nM[i][j] = (s[i] == s[j] AND M[i + 1][j - 1]);\\nFor the implementation of recurrence relation, one idea is you can loop through all possible symmetry axis. For each of the axis, you expand at both RHS and LHS simultaneously. This method promises that when you are determining value in M[i][j], M[i + 1][j - 1] must have the correct value.\\nFinal answer can be found from all M[i][j] == 1 with largest (j - i)."
                    },
                    {
                        "username": "Msey",
                        "content": "thank you, cat brother"
                    },
                    {
                        "username": "user0558y",
                        "content": "I understand the solution but I don't understand why it needs any storage at all or why it needs to be a DP solution.\n\nThe condition `(s[i] == s[j] AND M[i + 1][j - 1])` requires you to memorise if `M[i+1][j-1]` is true, that's easy to understand. However, if you expand each possible axis at the same time, i.e. 1st iteration (s[i+1], s[j-1]), 2nd iteration `s[i+2], s[j-2]`, ... It is guaranteed that M[i+1][j-1] is always true and hence can be dropped, and you should break the loop when it is not true.\n\nIn summary, you don't need to memorise anything at all and you just need to check `s[i] == s[j]` while expanding in both directions at the same time, unless I have misunderstood anything? Here is an implementation of your algorithm but without storage: https://leetcode.com/problems/longest-palindromic-substring/submissions/868540120/"
                    },
                    {
                        "username": "taras",
                        "content": "Thank you! this is a beautiful explanation, though I\\'m not sure what exactly you mean by expanding both on LHS and RHS. In my implementation it\\'s enough to compute all diagonals of  the upper right triangle of the dp matrix."
                    },
                    {
                        "username": "klu_2100031593",
                        "content": "super explanation"
                    },
                    {
                        "username": "napoleon",
                        "content": "My Solution Is Naive, It Cost O(n^2), Is there Any Solution faster?"
                    },
                    {
                        "username": "leocampos",
                        "content": "[@tylerprill-rhdc](/tylerprill-rhdc) So, what I did was:\nStated in my mind the Brute Force approach - create every possible substring and test each one to see if is a palindrome and find the longest.\n\nOf course this would be ridiculously slow, so let's improve it.\nI also mentally stated that a palindrome has a recursive aspect -> if single char, or two equal chars, or charX + palindrome + charX\nSo I created a isPalindrome recursive method that checked it delegating to itself extracting the borders.\n\nSince a palindrome must start and end with the same char, in my traverse of the string, I started storing the position of each character Map<Character, List< Integer>>, so I would just go back to the previous found Char and check if from there to the current pointer I would have a Palindrome.\n\nThen I stopped doing this for every possible palindrome, I then started doing only for the ones that COULD be longer than the already found longest palindrome. That accelerated a lot.\n\nIn the almost last step, I added memoization. Remember that a palindrome is like a sandwich, with the external chars being equal and the meat being another palindrome? So I stored the found palindromes using their start and and positions. So I could check if that had already being checked and if so, either return true or false directly.\n\nThe final step was to convert the recursive function to an iterative function to save some memory used by the call stack.\nMaybe there are better implementations, just sharing my thought process."
                    },
                    {
                        "username": "tylerprill-rhdc",
                        "content": "[@tylerprill-rhdc](/tylerprill-rhdc) Two pointer based solution is also a really good solve here"
                    },
                    {
                        "username": "tylerprill-rhdc",
                        "content": "This could be done in a single pass algorithm, but will inherently check character indices multiple times based on the nature of the problem. (basically, iterate through each, then bubble out from each index)"
                    },
                    {
                        "username": "neetika",
                        "content": "From the leetcode blog, one of the methods of solving this is:\\n\\nA common mistake:\\nSome people will be tempted to come up with a quick solution, which is unfortunately flawed (however can be corrected easily):\\n\\nReverse S and become S\\u2019. Find the longest common substring between S and S\\u2019, which must also be the longest palindromic substring.\\nThis seemed to work, let\\u2019s see some examples below.\\n\\nFor example,\\nS = \\u201ccaba\\u201d, S\\u2019 = \\u201cabac\\u201d.\\nThe longest common substring between S and S\\u2019 is \\u201caba\\u201d, which is the answer.\\n\\nLet\\u2019s try another example:\\nS = \\u201cabacdfgdcaba\\u201d, S\\u2019 = \\u201cabacdgfdcaba\\u201d.\\nThe longest common substring between S and S\\u2019 is \\u201cabacd\\u201d. Clearly, this is not a valid palindrome.\\n\\n**We could see that the longest common substring method fails when there exists a reversed copy of a non-palindromic substring in some other part of S. To rectify this, each time we find a longest common substring candidate, we check if the substring\\u2019s indices are the same as the reversed substring\\u2019s original indices. If it is, then we attempt to update the longest palindrome found so far; if not, we skip this and find the next candidate.**\\n\\nIs this part correct? \\n\\nexample string: abcxycba\\nreverse string:  abcxycba\\n\\nThe substring indices are same as reversed string original indices and yet it is not a palindrome?"
                    },
                    {
                        "username": "HRVY_SNOWDEN",
                        "content": "cool sirr:)\\n"
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "WRONG.\\n\\nabcxycba reversed is abcyxcba."
                    },
                    {
                        "username": "travisl12",
                        "content": "After I solved this problem I thought it\\'d be interesting to see how it worked in realtime.\\n\\nhttps://codepen.io/TravisL12/pen/pogvweg"
                    },
                    {
                        "username": "user3907vj",
                        "content": "thanks for the \"nanananananana\" from all the small things ;)"
                    },
                    {
                        "username": "zapataast",
                        "content": "u are crazy"
                    },
                    {
                        "username": "sondq98",
                        "content": "very intuitive"
                    },
                    {
                        "username": "Tathagat017",
                        "content": "thank you\\n"
                    },
                    {
                        "username": "mikler",
                        "content": "So I think I finally understood logic of test creators. \\nEven if you write a classical DP or memorization solution for this one you will timeout on latest tests.\\nI think they consider it edge cases. Because if you add one simple line it will pass! OMG. \\nI have leet code for this. Instead of solving problems I spend hours optimizing the constants.\\n\\nif s == s[::-1]: return s"
                    },
                    {
                        "username": "Vectorido",
                        "content": "Don\\'t work already. Time limit at 141 test even with that construction."
                    },
                    {
                        "username": "deepalithakur17",
                        "content": "It will only work in python."
                    },
                    {
                        "username": "ishogbon",
                        "content": "Its memoization, not memorization "
                    },
                    {
                        "username": "84danie",
                        "content": "I submitted my solution, and received a Time Limit Exceeded on this test case:\\n\\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabcaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n\\nSo I copied and pasted the TC into a custom test case, and started to think about what I could tweak. However, I ended up accidentally hitting Run Code, but instead of getting a Time Limit Exceeded result, it passed:\\n\\n![0_1479079812693_upload-4af9e94c-2e53-4915-acf6-782780c7bf8b](/uploads/files/1479079813717-upload-4af9e94c-2e53-4915-acf6-782780c7bf8b.png) \\n\\nIs this supposed to happen and I just need to make my code more efficient, or is this a bug? \\n![0_1479079956817_upload-1ef15826-d6e6-4bde-9c06-eb597c5c8d0e](/uploads/files/1479079957639-upload-1ef15826-d6e6-4bde-9c06-eb597c5c8d0e.png)"
                    },
                    {
                        "username": "RitikaSahay",
                        "content": "Same thing happened with me. Is there a solution for it?\\n"
                    },
                    {
                        "username": "danicruz0415",
                        "content": "It\\'s happened to me a couple of times. My theory is that the time limit is given for the whole list of test cases. Thus, you can have your test pass, but it will still time limit exceed because it wont get to calculate all the test cases before the time runs out. I cannot confirm this but I think its true because with a very unoptimized solution I got time limit exceeded very early in the test cases (for another problem), after some optimizations I got it much later (like getting to the last tests) which themselves were around the same size, so if the time limit was set per test it would not make sense to fail in a similarly long test-case just that is much later in the test list. (I think the same would apply to memory limit exceeded)"
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "The exact same situation happened with me in one problem... it was a DP problem too... I was getting a Memory Limit Exceeded error with the memoized solution but it was running fine in the Run Code button."
                    },
                    {
                        "username": "Hubro",
                        "content": "I\\'m getting \"Time Limit Exceeded\" with 141/141 testcases passed and \"Last Executed Input\" is:\\n\\n```\\ns =\\n```\\n\\nDid I break it?"
                    },
                    {
                        "username": "karan_dhiman",
                        "content": "same issue"
                    },
                    {
                        "username": "BLANK-Zora",
                        "content": "exactly bro this shit is recked , like it is giving tests outside the constraints , how am i suppose to include such things in the code"
                    },
                    {
                        "username": "arunprep5",
                        "content": "same issue. java"
                    },
                    {
                        "username": "blasphelmy",
                        "content": "[@tuancoltech](/tuancoltech) it worked when i rewrote the code in c# instead of c++"
                    },
                    {
                        "username": "tuancoltech",
                        "content": "[@blasphelmy](/blasphelmy) [@Tomas Sandven](/Hubro) Did you guys find out why? I got the same issue."
                    },
                    {
                        "username": "blasphelmy",
                        "content": "i got that too. im not sure whats going on given that the constraint for input is between 1 and 1000"
                    },
                    {
                        "username": "Vinitajain",
                        "content": "Hi All,\\nI have a test case which is failing, but I feel the testcase result is incorrect.Please refer the screenshot below.\\n![image](https://assets.leetcode.com/users/images/e9e42efb-63d5-4cfa-b420-f1926674f6dc_1654838015.8394327.png)\\n\\nThe longest palindromic substring is \"aaca\" but the test case result is \"aca\". Anyone else faced this problem?"
                    },
                    {
                        "username": "OthSO",
                        "content": "[@mohdansah10](/mohdansah10) \\nthey are separated in the input with \"bd\" so it is not a valid answer "
                    },
                    {
                        "username": "mohdansah10",
                        "content": "I\\'m getting same error, but different case:\\nInput\\ns =\\n\"aacabdkacaa\"\\n\\nOutput\\n\"aacakacaa\"\\nExpected\\n\"aca\"\\n\\nBut mine is Palindrome"
                    },
                    {
                        "username": "hasmithraa",
                        "content": "the expected is correct because aaca can\\'t be a palindrome only \\'aacaa\\' can be a palindrome which is not there in your case"
                    },
                    {
                        "username": "Amish_Singh",
                        "content": "how are you considering \"aaca\" as a palindromic substring, \"aca\" is a palindrome and it is the longest"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "dude you really came up with the solution "
                    },
                    {
                        "username": "AryaAditya3609",
                        "content": "how is \"aaca\" and \"acaa\" same ???\\nWhile \"aca\" is palindrome because both \"aca\" and reverse of it \"aca\" is same !!"
                    },
                    {
                        "username": "alexandra-pickle",
                        "content": "\"aaca\" is not a palindrome"
                    },
                    {
                        "username": "bugHackerLoop",
                        "content": "I followed the approach leant by Aditya Verma DP lectures and encountered the same test case failing. Does the logic where I reverse the string and calculate the longest common substring doesn\\'t work here? I know it works for longest palindromic subsequence but here it fails for such test cases .. why is it so?"
                    },
                    {
                        "username": "mductran",
                        "content": "how is \\'aaca\\' a palindrome? when read backward it\\'s \\'acaa\\' so it\\'s not the same reading forward."
                    },
                    {
                        "username": "jnsudhir",
                        "content": "Check my solution, it was able to clear test case \"aaca\". Explained code in comments.\\n\\nhttps://leetcode.com/problems/longest-palindromic-substring/solutions/3091016/longest-palindromic-substring-using-javascript-beats-94-82-in-runtime-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "nikhileshratna",
                        "content": "aaca is not palindrome"
                    },
                    {
                        "username": "sunshine77",
                        "content": "hey, iam getting the same error, i have seen ansewrs where they have totally changed the algorithm, how did u solve this by tweaking the same algoirhtm"
                    },
                    {
                        "username": "bhupendrabc71",
                        "content": "how come \"aaca\" is palindrome. it should be \"aca\""
                    },
                    {
                        "username": "just11blocks",
                        "content": "aaca is not a palindrome...aacaa and aca are."
                    },
                    {
                        "username": "odi1n",
                        "content": "I also encountered this problem"
                    },
                    {
                        "username": "vamsi2302",
                        "content": "I think you get it by now!\\n"
                    }
                ]
            },
            {
                "id": 1569251,
                "content": [
                    {
                        "username": "ZenMasterV",
                        "content": "Seems like too many of the  coding wunderkinds here lack basic reading comprehension skills \\n\" Please don\\'t post any solutions in this discussion tab\"\\nIt\\'s almost the rule to find the exact opposite for the discussion of every question. I don\\'t want to see your damned solution!"
                    },
                    {
                        "username": "NeroXIII",
                        "content": "[@charonme](/charonme) name does not check out :((("
                    },
                    {
                        "username": "192731",
                        "content": "and if they do?"
                    },
                    {
                        "username": "plevi1995",
                        "content": "Excellent comment"
                    },
                    {
                        "username": "khan60939",
                        "content": "Can anyone tell how DP is being used here? "
                    },
                    {
                        "username": "sandagolcea",
                        "content": "[@charonme](/charonme) my thinking exactly, but at least they should create a flag to help us moderate and move solutions to the correct tab. Would only need a stack overflow moderation-like system: one person flags, another person receives a queue of flagged comments and confirms the tagging.. oh well"
                    },
                    {
                        "username": "charonme",
                        "content": "maybe people get confused by the official leetcode comment which says: \"If you\\'d like to share a detailed solution to the problem, please create a new post in the discuss section\"\\nMaybe some time ago they didn\\'t have a separate solutions section and only recently changed it, but left some of the old solutions in the discussion section and didn\\'t fix the automated comment worting?"
                    },
                    {
                        "username": "klanjewar037",
                        "content": "hehe"
                    },
                    {
                        "username": "sanemdeepak",
                        "content": "For input \"ac\" test case is expecting \"a\" as output, how is just \"a\" a palindromic string?"
                    },
                    {
                        "username": "ayushiidevpura",
                        "content": "because when we read \"a\" from forward it results in \"a\" and at the same time when we read \"a\" from backward it is still \"a\""
                    },
                    {
                        "username": "beyzigo",
                        "content": "Because if you read the string \"a\" backwards it will still be \"a\""
                    },
                    {
                        "username": "tsafackghokeng",
                        "content": "[@Chouhan_Gourav](/Chouhan_Gourav) the test case said \"ac\" not \"a\". is \"ac\" palindromic? for \"a\" i understand"
                    },
                    {
                        "username": "CODEWITHABHINAV",
                        "content": "you have to submit the first string as your answer read more about this question on gFg\\n"
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "any string is palindrome if we read it same from front and from back\\nin single character we read it same from front and back"
                    },
                    {
                        "username": "oinrup",
                        "content": "yes thats my question too"
                    },
                    {
                        "username": "yldemon",
                        "content": "Any character in the string by itself is a palindromic substring. So in the case where there is no palindromic substring with length > 1, you can return any character."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "Whenever you come accross such contradiction, just google the definition, any. Any string is called is pallindromic if the reverse of the string is equal to the original string. Reverse of \\'a\\' is \\'a\\'. Hope you get this."
                    },
                    {
                        "username": "947876275",
                        "content": "This post is for learner wanna practice DP.\\nThe basic idea is, if we wanna say \"aba\" is palindromic, then we need to firstly confirm that \"b\" is palindromic, then we also need to check if \"a\"(the first a) = \"a\" (the second a).\\n\\nM is a 2-d array which stores boolean values.\\nM[i][j] indicates if string[i.....j] is palindromic.\\nSo base cases are:\\nM[i][i] is true.\\nM[i][i + 1] = (s[i] == s[i + 1]);\\nrecurrence relation is :\\nM[i][j] = (s[i] == s[j] AND M[i + 1][j - 1]);\\nFor the implementation of recurrence relation, one idea is you can loop through all possible symmetry axis. For each of the axis, you expand at both RHS and LHS simultaneously. This method promises that when you are determining value in M[i][j], M[i + 1][j - 1] must have the correct value.\\nFinal answer can be found from all M[i][j] == 1 with largest (j - i)."
                    },
                    {
                        "username": "Msey",
                        "content": "thank you, cat brother"
                    },
                    {
                        "username": "user0558y",
                        "content": "I understand the solution but I don't understand why it needs any storage at all or why it needs to be a DP solution.\n\nThe condition `(s[i] == s[j] AND M[i + 1][j - 1])` requires you to memorise if `M[i+1][j-1]` is true, that's easy to understand. However, if you expand each possible axis at the same time, i.e. 1st iteration (s[i+1], s[j-1]), 2nd iteration `s[i+2], s[j-2]`, ... It is guaranteed that M[i+1][j-1] is always true and hence can be dropped, and you should break the loop when it is not true.\n\nIn summary, you don't need to memorise anything at all and you just need to check `s[i] == s[j]` while expanding in both directions at the same time, unless I have misunderstood anything? Here is an implementation of your algorithm but without storage: https://leetcode.com/problems/longest-palindromic-substring/submissions/868540120/"
                    },
                    {
                        "username": "taras",
                        "content": "Thank you! this is a beautiful explanation, though I\\'m not sure what exactly you mean by expanding both on LHS and RHS. In my implementation it\\'s enough to compute all diagonals of  the upper right triangle of the dp matrix."
                    },
                    {
                        "username": "klu_2100031593",
                        "content": "super explanation"
                    },
                    {
                        "username": "napoleon",
                        "content": "My Solution Is Naive, It Cost O(n^2), Is there Any Solution faster?"
                    },
                    {
                        "username": "leocampos",
                        "content": "[@tylerprill-rhdc](/tylerprill-rhdc) So, what I did was:\nStated in my mind the Brute Force approach - create every possible substring and test each one to see if is a palindrome and find the longest.\n\nOf course this would be ridiculously slow, so let's improve it.\nI also mentally stated that a palindrome has a recursive aspect -> if single char, or two equal chars, or charX + palindrome + charX\nSo I created a isPalindrome recursive method that checked it delegating to itself extracting the borders.\n\nSince a palindrome must start and end with the same char, in my traverse of the string, I started storing the position of each character Map<Character, List< Integer>>, so I would just go back to the previous found Char and check if from there to the current pointer I would have a Palindrome.\n\nThen I stopped doing this for every possible palindrome, I then started doing only for the ones that COULD be longer than the already found longest palindrome. That accelerated a lot.\n\nIn the almost last step, I added memoization. Remember that a palindrome is like a sandwich, with the external chars being equal and the meat being another palindrome? So I stored the found palindromes using their start and and positions. So I could check if that had already being checked and if so, either return true or false directly.\n\nThe final step was to convert the recursive function to an iterative function to save some memory used by the call stack.\nMaybe there are better implementations, just sharing my thought process."
                    },
                    {
                        "username": "tylerprill-rhdc",
                        "content": "[@tylerprill-rhdc](/tylerprill-rhdc) Two pointer based solution is also a really good solve here"
                    },
                    {
                        "username": "tylerprill-rhdc",
                        "content": "This could be done in a single pass algorithm, but will inherently check character indices multiple times based on the nature of the problem. (basically, iterate through each, then bubble out from each index)"
                    },
                    {
                        "username": "neetika",
                        "content": "From the leetcode blog, one of the methods of solving this is:\\n\\nA common mistake:\\nSome people will be tempted to come up with a quick solution, which is unfortunately flawed (however can be corrected easily):\\n\\nReverse S and become S\\u2019. Find the longest common substring between S and S\\u2019, which must also be the longest palindromic substring.\\nThis seemed to work, let\\u2019s see some examples below.\\n\\nFor example,\\nS = \\u201ccaba\\u201d, S\\u2019 = \\u201cabac\\u201d.\\nThe longest common substring between S and S\\u2019 is \\u201caba\\u201d, which is the answer.\\n\\nLet\\u2019s try another example:\\nS = \\u201cabacdfgdcaba\\u201d, S\\u2019 = \\u201cabacdgfdcaba\\u201d.\\nThe longest common substring between S and S\\u2019 is \\u201cabacd\\u201d. Clearly, this is not a valid palindrome.\\n\\n**We could see that the longest common substring method fails when there exists a reversed copy of a non-palindromic substring in some other part of S. To rectify this, each time we find a longest common substring candidate, we check if the substring\\u2019s indices are the same as the reversed substring\\u2019s original indices. If it is, then we attempt to update the longest palindrome found so far; if not, we skip this and find the next candidate.**\\n\\nIs this part correct? \\n\\nexample string: abcxycba\\nreverse string:  abcxycba\\n\\nThe substring indices are same as reversed string original indices and yet it is not a palindrome?"
                    },
                    {
                        "username": "HRVY_SNOWDEN",
                        "content": "cool sirr:)\\n"
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "WRONG.\\n\\nabcxycba reversed is abcyxcba."
                    },
                    {
                        "username": "travisl12",
                        "content": "After I solved this problem I thought it\\'d be interesting to see how it worked in realtime.\\n\\nhttps://codepen.io/TravisL12/pen/pogvweg"
                    },
                    {
                        "username": "user3907vj",
                        "content": "thanks for the \"nanananananana\" from all the small things ;)"
                    },
                    {
                        "username": "zapataast",
                        "content": "u are crazy"
                    },
                    {
                        "username": "sondq98",
                        "content": "very intuitive"
                    },
                    {
                        "username": "Tathagat017",
                        "content": "thank you\\n"
                    },
                    {
                        "username": "mikler",
                        "content": "So I think I finally understood logic of test creators. \\nEven if you write a classical DP or memorization solution for this one you will timeout on latest tests.\\nI think they consider it edge cases. Because if you add one simple line it will pass! OMG. \\nI have leet code for this. Instead of solving problems I spend hours optimizing the constants.\\n\\nif s == s[::-1]: return s"
                    },
                    {
                        "username": "Vectorido",
                        "content": "Don\\'t work already. Time limit at 141 test even with that construction."
                    },
                    {
                        "username": "deepalithakur17",
                        "content": "It will only work in python."
                    },
                    {
                        "username": "ishogbon",
                        "content": "Its memoization, not memorization "
                    },
                    {
                        "username": "84danie",
                        "content": "I submitted my solution, and received a Time Limit Exceeded on this test case:\\n\\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabcaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n\\nSo I copied and pasted the TC into a custom test case, and started to think about what I could tweak. However, I ended up accidentally hitting Run Code, but instead of getting a Time Limit Exceeded result, it passed:\\n\\n![0_1479079812693_upload-4af9e94c-2e53-4915-acf6-782780c7bf8b](/uploads/files/1479079813717-upload-4af9e94c-2e53-4915-acf6-782780c7bf8b.png) \\n\\nIs this supposed to happen and I just need to make my code more efficient, or is this a bug? \\n![0_1479079956817_upload-1ef15826-d6e6-4bde-9c06-eb597c5c8d0e](/uploads/files/1479079957639-upload-1ef15826-d6e6-4bde-9c06-eb597c5c8d0e.png)"
                    },
                    {
                        "username": "RitikaSahay",
                        "content": "Same thing happened with me. Is there a solution for it?\\n"
                    },
                    {
                        "username": "danicruz0415",
                        "content": "It\\'s happened to me a couple of times. My theory is that the time limit is given for the whole list of test cases. Thus, you can have your test pass, but it will still time limit exceed because it wont get to calculate all the test cases before the time runs out. I cannot confirm this but I think its true because with a very unoptimized solution I got time limit exceeded very early in the test cases (for another problem), after some optimizations I got it much later (like getting to the last tests) which themselves were around the same size, so if the time limit was set per test it would not make sense to fail in a similarly long test-case just that is much later in the test list. (I think the same would apply to memory limit exceeded)"
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "The exact same situation happened with me in one problem... it was a DP problem too... I was getting a Memory Limit Exceeded error with the memoized solution but it was running fine in the Run Code button."
                    },
                    {
                        "username": "Hubro",
                        "content": "I\\'m getting \"Time Limit Exceeded\" with 141/141 testcases passed and \"Last Executed Input\" is:\\n\\n```\\ns =\\n```\\n\\nDid I break it?"
                    },
                    {
                        "username": "karan_dhiman",
                        "content": "same issue"
                    },
                    {
                        "username": "BLANK-Zora",
                        "content": "exactly bro this shit is recked , like it is giving tests outside the constraints , how am i suppose to include such things in the code"
                    },
                    {
                        "username": "arunprep5",
                        "content": "same issue. java"
                    },
                    {
                        "username": "blasphelmy",
                        "content": "[@tuancoltech](/tuancoltech) it worked when i rewrote the code in c# instead of c++"
                    },
                    {
                        "username": "tuancoltech",
                        "content": "[@blasphelmy](/blasphelmy) [@Tomas Sandven](/Hubro) Did you guys find out why? I got the same issue."
                    },
                    {
                        "username": "blasphelmy",
                        "content": "i got that too. im not sure whats going on given that the constraint for input is between 1 and 1000"
                    },
                    {
                        "username": "Vinitajain",
                        "content": "Hi All,\\nI have a test case which is failing, but I feel the testcase result is incorrect.Please refer the screenshot below.\\n![image](https://assets.leetcode.com/users/images/e9e42efb-63d5-4cfa-b420-f1926674f6dc_1654838015.8394327.png)\\n\\nThe longest palindromic substring is \"aaca\" but the test case result is \"aca\". Anyone else faced this problem?"
                    },
                    {
                        "username": "OthSO",
                        "content": "[@mohdansah10](/mohdansah10) \\nthey are separated in the input with \"bd\" so it is not a valid answer "
                    },
                    {
                        "username": "mohdansah10",
                        "content": "I\\'m getting same error, but different case:\\nInput\\ns =\\n\"aacabdkacaa\"\\n\\nOutput\\n\"aacakacaa\"\\nExpected\\n\"aca\"\\n\\nBut mine is Palindrome"
                    },
                    {
                        "username": "hasmithraa",
                        "content": "the expected is correct because aaca can\\'t be a palindrome only \\'aacaa\\' can be a palindrome which is not there in your case"
                    },
                    {
                        "username": "Amish_Singh",
                        "content": "how are you considering \"aaca\" as a palindromic substring, \"aca\" is a palindrome and it is the longest"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "dude you really came up with the solution "
                    },
                    {
                        "username": "AryaAditya3609",
                        "content": "how is \"aaca\" and \"acaa\" same ???\\nWhile \"aca\" is palindrome because both \"aca\" and reverse of it \"aca\" is same !!"
                    },
                    {
                        "username": "alexandra-pickle",
                        "content": "\"aaca\" is not a palindrome"
                    },
                    {
                        "username": "bugHackerLoop",
                        "content": "I followed the approach leant by Aditya Verma DP lectures and encountered the same test case failing. Does the logic where I reverse the string and calculate the longest common substring doesn\\'t work here? I know it works for longest palindromic subsequence but here it fails for such test cases .. why is it so?"
                    },
                    {
                        "username": "mductran",
                        "content": "how is \\'aaca\\' a palindrome? when read backward it\\'s \\'acaa\\' so it\\'s not the same reading forward."
                    },
                    {
                        "username": "jnsudhir",
                        "content": "Check my solution, it was able to clear test case \"aaca\". Explained code in comments.\\n\\nhttps://leetcode.com/problems/longest-palindromic-substring/solutions/3091016/longest-palindromic-substring-using-javascript-beats-94-82-in-runtime-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "nikhileshratna",
                        "content": "aaca is not palindrome"
                    },
                    {
                        "username": "sunshine77",
                        "content": "hey, iam getting the same error, i have seen ansewrs where they have totally changed the algorithm, how did u solve this by tweaking the same algoirhtm"
                    },
                    {
                        "username": "bhupendrabc71",
                        "content": "how come \"aaca\" is palindrome. it should be \"aca\""
                    },
                    {
                        "username": "just11blocks",
                        "content": "aaca is not a palindrome...aacaa and aca are."
                    },
                    {
                        "username": "odi1n",
                        "content": "I also encountered this problem"
                    },
                    {
                        "username": "vamsi2302",
                        "content": "I think you get it by now!\\n"
                    }
                ]
            },
            {
                "id": 1566232,
                "content": [
                    {
                        "username": "ZenMasterV",
                        "content": "Seems like too many of the  coding wunderkinds here lack basic reading comprehension skills \\n\" Please don\\'t post any solutions in this discussion tab\"\\nIt\\'s almost the rule to find the exact opposite for the discussion of every question. I don\\'t want to see your damned solution!"
                    },
                    {
                        "username": "NeroXIII",
                        "content": "[@charonme](/charonme) name does not check out :((("
                    },
                    {
                        "username": "192731",
                        "content": "and if they do?"
                    },
                    {
                        "username": "plevi1995",
                        "content": "Excellent comment"
                    },
                    {
                        "username": "khan60939",
                        "content": "Can anyone tell how DP is being used here? "
                    },
                    {
                        "username": "sandagolcea",
                        "content": "[@charonme](/charonme) my thinking exactly, but at least they should create a flag to help us moderate and move solutions to the correct tab. Would only need a stack overflow moderation-like system: one person flags, another person receives a queue of flagged comments and confirms the tagging.. oh well"
                    },
                    {
                        "username": "charonme",
                        "content": "maybe people get confused by the official leetcode comment which says: \"If you\\'d like to share a detailed solution to the problem, please create a new post in the discuss section\"\\nMaybe some time ago they didn\\'t have a separate solutions section and only recently changed it, but left some of the old solutions in the discussion section and didn\\'t fix the automated comment worting?"
                    },
                    {
                        "username": "klanjewar037",
                        "content": "hehe"
                    },
                    {
                        "username": "sanemdeepak",
                        "content": "For input \"ac\" test case is expecting \"a\" as output, how is just \"a\" a palindromic string?"
                    },
                    {
                        "username": "ayushiidevpura",
                        "content": "because when we read \"a\" from forward it results in \"a\" and at the same time when we read \"a\" from backward it is still \"a\""
                    },
                    {
                        "username": "beyzigo",
                        "content": "Because if you read the string \"a\" backwards it will still be \"a\""
                    },
                    {
                        "username": "tsafackghokeng",
                        "content": "[@Chouhan_Gourav](/Chouhan_Gourav) the test case said \"ac\" not \"a\". is \"ac\" palindromic? for \"a\" i understand"
                    },
                    {
                        "username": "CODEWITHABHINAV",
                        "content": "you have to submit the first string as your answer read more about this question on gFg\\n"
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "any string is palindrome if we read it same from front and from back\\nin single character we read it same from front and back"
                    },
                    {
                        "username": "oinrup",
                        "content": "yes thats my question too"
                    },
                    {
                        "username": "yldemon",
                        "content": "Any character in the string by itself is a palindromic substring. So in the case where there is no palindromic substring with length > 1, you can return any character."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "Whenever you come accross such contradiction, just google the definition, any. Any string is called is pallindromic if the reverse of the string is equal to the original string. Reverse of \\'a\\' is \\'a\\'. Hope you get this."
                    },
                    {
                        "username": "947876275",
                        "content": "This post is for learner wanna practice DP.\\nThe basic idea is, if we wanna say \"aba\" is palindromic, then we need to firstly confirm that \"b\" is palindromic, then we also need to check if \"a\"(the first a) = \"a\" (the second a).\\n\\nM is a 2-d array which stores boolean values.\\nM[i][j] indicates if string[i.....j] is palindromic.\\nSo base cases are:\\nM[i][i] is true.\\nM[i][i + 1] = (s[i] == s[i + 1]);\\nrecurrence relation is :\\nM[i][j] = (s[i] == s[j] AND M[i + 1][j - 1]);\\nFor the implementation of recurrence relation, one idea is you can loop through all possible symmetry axis. For each of the axis, you expand at both RHS and LHS simultaneously. This method promises that when you are determining value in M[i][j], M[i + 1][j - 1] must have the correct value.\\nFinal answer can be found from all M[i][j] == 1 with largest (j - i)."
                    },
                    {
                        "username": "Msey",
                        "content": "thank you, cat brother"
                    },
                    {
                        "username": "user0558y",
                        "content": "I understand the solution but I don't understand why it needs any storage at all or why it needs to be a DP solution.\n\nThe condition `(s[i] == s[j] AND M[i + 1][j - 1])` requires you to memorise if `M[i+1][j-1]` is true, that's easy to understand. However, if you expand each possible axis at the same time, i.e. 1st iteration (s[i+1], s[j-1]), 2nd iteration `s[i+2], s[j-2]`, ... It is guaranteed that M[i+1][j-1] is always true and hence can be dropped, and you should break the loop when it is not true.\n\nIn summary, you don't need to memorise anything at all and you just need to check `s[i] == s[j]` while expanding in both directions at the same time, unless I have misunderstood anything? Here is an implementation of your algorithm but without storage: https://leetcode.com/problems/longest-palindromic-substring/submissions/868540120/"
                    },
                    {
                        "username": "taras",
                        "content": "Thank you! this is a beautiful explanation, though I\\'m not sure what exactly you mean by expanding both on LHS and RHS. In my implementation it\\'s enough to compute all diagonals of  the upper right triangle of the dp matrix."
                    },
                    {
                        "username": "klu_2100031593",
                        "content": "super explanation"
                    },
                    {
                        "username": "napoleon",
                        "content": "My Solution Is Naive, It Cost O(n^2), Is there Any Solution faster?"
                    },
                    {
                        "username": "leocampos",
                        "content": "[@tylerprill-rhdc](/tylerprill-rhdc) So, what I did was:\nStated in my mind the Brute Force approach - create every possible substring and test each one to see if is a palindrome and find the longest.\n\nOf course this would be ridiculously slow, so let's improve it.\nI also mentally stated that a palindrome has a recursive aspect -> if single char, or two equal chars, or charX + palindrome + charX\nSo I created a isPalindrome recursive method that checked it delegating to itself extracting the borders.\n\nSince a palindrome must start and end with the same char, in my traverse of the string, I started storing the position of each character Map<Character, List< Integer>>, so I would just go back to the previous found Char and check if from there to the current pointer I would have a Palindrome.\n\nThen I stopped doing this for every possible palindrome, I then started doing only for the ones that COULD be longer than the already found longest palindrome. That accelerated a lot.\n\nIn the almost last step, I added memoization. Remember that a palindrome is like a sandwich, with the external chars being equal and the meat being another palindrome? So I stored the found palindromes using their start and and positions. So I could check if that had already being checked and if so, either return true or false directly.\n\nThe final step was to convert the recursive function to an iterative function to save some memory used by the call stack.\nMaybe there are better implementations, just sharing my thought process."
                    },
                    {
                        "username": "tylerprill-rhdc",
                        "content": "[@tylerprill-rhdc](/tylerprill-rhdc) Two pointer based solution is also a really good solve here"
                    },
                    {
                        "username": "tylerprill-rhdc",
                        "content": "This could be done in a single pass algorithm, but will inherently check character indices multiple times based on the nature of the problem. (basically, iterate through each, then bubble out from each index)"
                    },
                    {
                        "username": "neetika",
                        "content": "From the leetcode blog, one of the methods of solving this is:\\n\\nA common mistake:\\nSome people will be tempted to come up with a quick solution, which is unfortunately flawed (however can be corrected easily):\\n\\nReverse S and become S\\u2019. Find the longest common substring between S and S\\u2019, which must also be the longest palindromic substring.\\nThis seemed to work, let\\u2019s see some examples below.\\n\\nFor example,\\nS = \\u201ccaba\\u201d, S\\u2019 = \\u201cabac\\u201d.\\nThe longest common substring between S and S\\u2019 is \\u201caba\\u201d, which is the answer.\\n\\nLet\\u2019s try another example:\\nS = \\u201cabacdfgdcaba\\u201d, S\\u2019 = \\u201cabacdgfdcaba\\u201d.\\nThe longest common substring between S and S\\u2019 is \\u201cabacd\\u201d. Clearly, this is not a valid palindrome.\\n\\n**We could see that the longest common substring method fails when there exists a reversed copy of a non-palindromic substring in some other part of S. To rectify this, each time we find a longest common substring candidate, we check if the substring\\u2019s indices are the same as the reversed substring\\u2019s original indices. If it is, then we attempt to update the longest palindrome found so far; if not, we skip this and find the next candidate.**\\n\\nIs this part correct? \\n\\nexample string: abcxycba\\nreverse string:  abcxycba\\n\\nThe substring indices are same as reversed string original indices and yet it is not a palindrome?"
                    },
                    {
                        "username": "HRVY_SNOWDEN",
                        "content": "cool sirr:)\\n"
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "WRONG.\\n\\nabcxycba reversed is abcyxcba."
                    },
                    {
                        "username": "travisl12",
                        "content": "After I solved this problem I thought it\\'d be interesting to see how it worked in realtime.\\n\\nhttps://codepen.io/TravisL12/pen/pogvweg"
                    },
                    {
                        "username": "user3907vj",
                        "content": "thanks for the \"nanananananana\" from all the small things ;)"
                    },
                    {
                        "username": "zapataast",
                        "content": "u are crazy"
                    },
                    {
                        "username": "sondq98",
                        "content": "very intuitive"
                    },
                    {
                        "username": "Tathagat017",
                        "content": "thank you\\n"
                    },
                    {
                        "username": "mikler",
                        "content": "So I think I finally understood logic of test creators. \\nEven if you write a classical DP or memorization solution for this one you will timeout on latest tests.\\nI think they consider it edge cases. Because if you add one simple line it will pass! OMG. \\nI have leet code for this. Instead of solving problems I spend hours optimizing the constants.\\n\\nif s == s[::-1]: return s"
                    },
                    {
                        "username": "Vectorido",
                        "content": "Don\\'t work already. Time limit at 141 test even with that construction."
                    },
                    {
                        "username": "deepalithakur17",
                        "content": "It will only work in python."
                    },
                    {
                        "username": "ishogbon",
                        "content": "Its memoization, not memorization "
                    },
                    {
                        "username": "84danie",
                        "content": "I submitted my solution, and received a Time Limit Exceeded on this test case:\\n\\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabcaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n\\nSo I copied and pasted the TC into a custom test case, and started to think about what I could tweak. However, I ended up accidentally hitting Run Code, but instead of getting a Time Limit Exceeded result, it passed:\\n\\n![0_1479079812693_upload-4af9e94c-2e53-4915-acf6-782780c7bf8b](/uploads/files/1479079813717-upload-4af9e94c-2e53-4915-acf6-782780c7bf8b.png) \\n\\nIs this supposed to happen and I just need to make my code more efficient, or is this a bug? \\n![0_1479079956817_upload-1ef15826-d6e6-4bde-9c06-eb597c5c8d0e](/uploads/files/1479079957639-upload-1ef15826-d6e6-4bde-9c06-eb597c5c8d0e.png)"
                    },
                    {
                        "username": "RitikaSahay",
                        "content": "Same thing happened with me. Is there a solution for it?\\n"
                    },
                    {
                        "username": "danicruz0415",
                        "content": "It\\'s happened to me a couple of times. My theory is that the time limit is given for the whole list of test cases. Thus, you can have your test pass, but it will still time limit exceed because it wont get to calculate all the test cases before the time runs out. I cannot confirm this but I think its true because with a very unoptimized solution I got time limit exceeded very early in the test cases (for another problem), after some optimizations I got it much later (like getting to the last tests) which themselves were around the same size, so if the time limit was set per test it would not make sense to fail in a similarly long test-case just that is much later in the test list. (I think the same would apply to memory limit exceeded)"
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "The exact same situation happened with me in one problem... it was a DP problem too... I was getting a Memory Limit Exceeded error with the memoized solution but it was running fine in the Run Code button."
                    },
                    {
                        "username": "Hubro",
                        "content": "I\\'m getting \"Time Limit Exceeded\" with 141/141 testcases passed and \"Last Executed Input\" is:\\n\\n```\\ns =\\n```\\n\\nDid I break it?"
                    },
                    {
                        "username": "karan_dhiman",
                        "content": "same issue"
                    },
                    {
                        "username": "BLANK-Zora",
                        "content": "exactly bro this shit is recked , like it is giving tests outside the constraints , how am i suppose to include such things in the code"
                    },
                    {
                        "username": "arunprep5",
                        "content": "same issue. java"
                    },
                    {
                        "username": "blasphelmy",
                        "content": "[@tuancoltech](/tuancoltech) it worked when i rewrote the code in c# instead of c++"
                    },
                    {
                        "username": "tuancoltech",
                        "content": "[@blasphelmy](/blasphelmy) [@Tomas Sandven](/Hubro) Did you guys find out why? I got the same issue."
                    },
                    {
                        "username": "blasphelmy",
                        "content": "i got that too. im not sure whats going on given that the constraint for input is between 1 and 1000"
                    },
                    {
                        "username": "Vinitajain",
                        "content": "Hi All,\\nI have a test case which is failing, but I feel the testcase result is incorrect.Please refer the screenshot below.\\n![image](https://assets.leetcode.com/users/images/e9e42efb-63d5-4cfa-b420-f1926674f6dc_1654838015.8394327.png)\\n\\nThe longest palindromic substring is \"aaca\" but the test case result is \"aca\". Anyone else faced this problem?"
                    },
                    {
                        "username": "OthSO",
                        "content": "[@mohdansah10](/mohdansah10) \\nthey are separated in the input with \"bd\" so it is not a valid answer "
                    },
                    {
                        "username": "mohdansah10",
                        "content": "I\\'m getting same error, but different case:\\nInput\\ns =\\n\"aacabdkacaa\"\\n\\nOutput\\n\"aacakacaa\"\\nExpected\\n\"aca\"\\n\\nBut mine is Palindrome"
                    },
                    {
                        "username": "hasmithraa",
                        "content": "the expected is correct because aaca can\\'t be a palindrome only \\'aacaa\\' can be a palindrome which is not there in your case"
                    },
                    {
                        "username": "Amish_Singh",
                        "content": "how are you considering \"aaca\" as a palindromic substring, \"aca\" is a palindrome and it is the longest"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "dude you really came up with the solution "
                    },
                    {
                        "username": "AryaAditya3609",
                        "content": "how is \"aaca\" and \"acaa\" same ???\\nWhile \"aca\" is palindrome because both \"aca\" and reverse of it \"aca\" is same !!"
                    },
                    {
                        "username": "alexandra-pickle",
                        "content": "\"aaca\" is not a palindrome"
                    },
                    {
                        "username": "bugHackerLoop",
                        "content": "I followed the approach leant by Aditya Verma DP lectures and encountered the same test case failing. Does the logic where I reverse the string and calculate the longest common substring doesn\\'t work here? I know it works for longest palindromic subsequence but here it fails for such test cases .. why is it so?"
                    },
                    {
                        "username": "mductran",
                        "content": "how is \\'aaca\\' a palindrome? when read backward it\\'s \\'acaa\\' so it\\'s not the same reading forward."
                    },
                    {
                        "username": "jnsudhir",
                        "content": "Check my solution, it was able to clear test case \"aaca\". Explained code in comments.\\n\\nhttps://leetcode.com/problems/longest-palindromic-substring/solutions/3091016/longest-palindromic-substring-using-javascript-beats-94-82-in-runtime-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "nikhileshratna",
                        "content": "aaca is not palindrome"
                    },
                    {
                        "username": "sunshine77",
                        "content": "hey, iam getting the same error, i have seen ansewrs where they have totally changed the algorithm, how did u solve this by tweaking the same algoirhtm"
                    },
                    {
                        "username": "bhupendrabc71",
                        "content": "how come \"aaca\" is palindrome. it should be \"aca\""
                    },
                    {
                        "username": "just11blocks",
                        "content": "aaca is not a palindrome...aacaa and aca are."
                    },
                    {
                        "username": "odi1n",
                        "content": "I also encountered this problem"
                    },
                    {
                        "username": "vamsi2302",
                        "content": "I think you get it by now!\\n"
                    }
                ]
            },
            {
                "id": 1568804,
                "content": [
                    {
                        "username": "ZenMasterV",
                        "content": "Seems like too many of the  coding wunderkinds here lack basic reading comprehension skills \\n\" Please don\\'t post any solutions in this discussion tab\"\\nIt\\'s almost the rule to find the exact opposite for the discussion of every question. I don\\'t want to see your damned solution!"
                    },
                    {
                        "username": "NeroXIII",
                        "content": "[@charonme](/charonme) name does not check out :((("
                    },
                    {
                        "username": "192731",
                        "content": "and if they do?"
                    },
                    {
                        "username": "plevi1995",
                        "content": "Excellent comment"
                    },
                    {
                        "username": "khan60939",
                        "content": "Can anyone tell how DP is being used here? "
                    },
                    {
                        "username": "sandagolcea",
                        "content": "[@charonme](/charonme) my thinking exactly, but at least they should create a flag to help us moderate and move solutions to the correct tab. Would only need a stack overflow moderation-like system: one person flags, another person receives a queue of flagged comments and confirms the tagging.. oh well"
                    },
                    {
                        "username": "charonme",
                        "content": "maybe people get confused by the official leetcode comment which says: \"If you\\'d like to share a detailed solution to the problem, please create a new post in the discuss section\"\\nMaybe some time ago they didn\\'t have a separate solutions section and only recently changed it, but left some of the old solutions in the discussion section and didn\\'t fix the automated comment worting?"
                    },
                    {
                        "username": "klanjewar037",
                        "content": "hehe"
                    },
                    {
                        "username": "sanemdeepak",
                        "content": "For input \"ac\" test case is expecting \"a\" as output, how is just \"a\" a palindromic string?"
                    },
                    {
                        "username": "ayushiidevpura",
                        "content": "because when we read \"a\" from forward it results in \"a\" and at the same time when we read \"a\" from backward it is still \"a\""
                    },
                    {
                        "username": "beyzigo",
                        "content": "Because if you read the string \"a\" backwards it will still be \"a\""
                    },
                    {
                        "username": "tsafackghokeng",
                        "content": "[@Chouhan_Gourav](/Chouhan_Gourav) the test case said \"ac\" not \"a\". is \"ac\" palindromic? for \"a\" i understand"
                    },
                    {
                        "username": "CODEWITHABHINAV",
                        "content": "you have to submit the first string as your answer read more about this question on gFg\\n"
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "any string is palindrome if we read it same from front and from back\\nin single character we read it same from front and back"
                    },
                    {
                        "username": "oinrup",
                        "content": "yes thats my question too"
                    },
                    {
                        "username": "yldemon",
                        "content": "Any character in the string by itself is a palindromic substring. So in the case where there is no palindromic substring with length > 1, you can return any character."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "Whenever you come accross such contradiction, just google the definition, any. Any string is called is pallindromic if the reverse of the string is equal to the original string. Reverse of \\'a\\' is \\'a\\'. Hope you get this."
                    },
                    {
                        "username": "947876275",
                        "content": "This post is for learner wanna practice DP.\\nThe basic idea is, if we wanna say \"aba\" is palindromic, then we need to firstly confirm that \"b\" is palindromic, then we also need to check if \"a\"(the first a) = \"a\" (the second a).\\n\\nM is a 2-d array which stores boolean values.\\nM[i][j] indicates if string[i.....j] is palindromic.\\nSo base cases are:\\nM[i][i] is true.\\nM[i][i + 1] = (s[i] == s[i + 1]);\\nrecurrence relation is :\\nM[i][j] = (s[i] == s[j] AND M[i + 1][j - 1]);\\nFor the implementation of recurrence relation, one idea is you can loop through all possible symmetry axis. For each of the axis, you expand at both RHS and LHS simultaneously. This method promises that when you are determining value in M[i][j], M[i + 1][j - 1] must have the correct value.\\nFinal answer can be found from all M[i][j] == 1 with largest (j - i)."
                    },
                    {
                        "username": "Msey",
                        "content": "thank you, cat brother"
                    },
                    {
                        "username": "user0558y",
                        "content": "I understand the solution but I don't understand why it needs any storage at all or why it needs to be a DP solution.\n\nThe condition `(s[i] == s[j] AND M[i + 1][j - 1])` requires you to memorise if `M[i+1][j-1]` is true, that's easy to understand. However, if you expand each possible axis at the same time, i.e. 1st iteration (s[i+1], s[j-1]), 2nd iteration `s[i+2], s[j-2]`, ... It is guaranteed that M[i+1][j-1] is always true and hence can be dropped, and you should break the loop when it is not true.\n\nIn summary, you don't need to memorise anything at all and you just need to check `s[i] == s[j]` while expanding in both directions at the same time, unless I have misunderstood anything? Here is an implementation of your algorithm but without storage: https://leetcode.com/problems/longest-palindromic-substring/submissions/868540120/"
                    },
                    {
                        "username": "taras",
                        "content": "Thank you! this is a beautiful explanation, though I\\'m not sure what exactly you mean by expanding both on LHS and RHS. In my implementation it\\'s enough to compute all diagonals of  the upper right triangle of the dp matrix."
                    },
                    {
                        "username": "klu_2100031593",
                        "content": "super explanation"
                    },
                    {
                        "username": "napoleon",
                        "content": "My Solution Is Naive, It Cost O(n^2), Is there Any Solution faster?"
                    },
                    {
                        "username": "leocampos",
                        "content": "[@tylerprill-rhdc](/tylerprill-rhdc) So, what I did was:\nStated in my mind the Brute Force approach - create every possible substring and test each one to see if is a palindrome and find the longest.\n\nOf course this would be ridiculously slow, so let's improve it.\nI also mentally stated that a palindrome has a recursive aspect -> if single char, or two equal chars, or charX + palindrome + charX\nSo I created a isPalindrome recursive method that checked it delegating to itself extracting the borders.\n\nSince a palindrome must start and end with the same char, in my traverse of the string, I started storing the position of each character Map<Character, List< Integer>>, so I would just go back to the previous found Char and check if from there to the current pointer I would have a Palindrome.\n\nThen I stopped doing this for every possible palindrome, I then started doing only for the ones that COULD be longer than the already found longest palindrome. That accelerated a lot.\n\nIn the almost last step, I added memoization. Remember that a palindrome is like a sandwich, with the external chars being equal and the meat being another palindrome? So I stored the found palindromes using their start and and positions. So I could check if that had already being checked and if so, either return true or false directly.\n\nThe final step was to convert the recursive function to an iterative function to save some memory used by the call stack.\nMaybe there are better implementations, just sharing my thought process."
                    },
                    {
                        "username": "tylerprill-rhdc",
                        "content": "[@tylerprill-rhdc](/tylerprill-rhdc) Two pointer based solution is also a really good solve here"
                    },
                    {
                        "username": "tylerprill-rhdc",
                        "content": "This could be done in a single pass algorithm, but will inherently check character indices multiple times based on the nature of the problem. (basically, iterate through each, then bubble out from each index)"
                    },
                    {
                        "username": "neetika",
                        "content": "From the leetcode blog, one of the methods of solving this is:\\n\\nA common mistake:\\nSome people will be tempted to come up with a quick solution, which is unfortunately flawed (however can be corrected easily):\\n\\nReverse S and become S\\u2019. Find the longest common substring between S and S\\u2019, which must also be the longest palindromic substring.\\nThis seemed to work, let\\u2019s see some examples below.\\n\\nFor example,\\nS = \\u201ccaba\\u201d, S\\u2019 = \\u201cabac\\u201d.\\nThe longest common substring between S and S\\u2019 is \\u201caba\\u201d, which is the answer.\\n\\nLet\\u2019s try another example:\\nS = \\u201cabacdfgdcaba\\u201d, S\\u2019 = \\u201cabacdgfdcaba\\u201d.\\nThe longest common substring between S and S\\u2019 is \\u201cabacd\\u201d. Clearly, this is not a valid palindrome.\\n\\n**We could see that the longest common substring method fails when there exists a reversed copy of a non-palindromic substring in some other part of S. To rectify this, each time we find a longest common substring candidate, we check if the substring\\u2019s indices are the same as the reversed substring\\u2019s original indices. If it is, then we attempt to update the longest palindrome found so far; if not, we skip this and find the next candidate.**\\n\\nIs this part correct? \\n\\nexample string: abcxycba\\nreverse string:  abcxycba\\n\\nThe substring indices are same as reversed string original indices and yet it is not a palindrome?"
                    },
                    {
                        "username": "HRVY_SNOWDEN",
                        "content": "cool sirr:)\\n"
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "WRONG.\\n\\nabcxycba reversed is abcyxcba."
                    },
                    {
                        "username": "travisl12",
                        "content": "After I solved this problem I thought it\\'d be interesting to see how it worked in realtime.\\n\\nhttps://codepen.io/TravisL12/pen/pogvweg"
                    },
                    {
                        "username": "user3907vj",
                        "content": "thanks for the \"nanananananana\" from all the small things ;)"
                    },
                    {
                        "username": "zapataast",
                        "content": "u are crazy"
                    },
                    {
                        "username": "sondq98",
                        "content": "very intuitive"
                    },
                    {
                        "username": "Tathagat017",
                        "content": "thank you\\n"
                    },
                    {
                        "username": "mikler",
                        "content": "So I think I finally understood logic of test creators. \\nEven if you write a classical DP or memorization solution for this one you will timeout on latest tests.\\nI think they consider it edge cases. Because if you add one simple line it will pass! OMG. \\nI have leet code for this. Instead of solving problems I spend hours optimizing the constants.\\n\\nif s == s[::-1]: return s"
                    },
                    {
                        "username": "Vectorido",
                        "content": "Don\\'t work already. Time limit at 141 test even with that construction."
                    },
                    {
                        "username": "deepalithakur17",
                        "content": "It will only work in python."
                    },
                    {
                        "username": "ishogbon",
                        "content": "Its memoization, not memorization "
                    },
                    {
                        "username": "84danie",
                        "content": "I submitted my solution, and received a Time Limit Exceeded on this test case:\\n\\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabcaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n\\nSo I copied and pasted the TC into a custom test case, and started to think about what I could tweak. However, I ended up accidentally hitting Run Code, but instead of getting a Time Limit Exceeded result, it passed:\\n\\n![0_1479079812693_upload-4af9e94c-2e53-4915-acf6-782780c7bf8b](/uploads/files/1479079813717-upload-4af9e94c-2e53-4915-acf6-782780c7bf8b.png) \\n\\nIs this supposed to happen and I just need to make my code more efficient, or is this a bug? \\n![0_1479079956817_upload-1ef15826-d6e6-4bde-9c06-eb597c5c8d0e](/uploads/files/1479079957639-upload-1ef15826-d6e6-4bde-9c06-eb597c5c8d0e.png)"
                    },
                    {
                        "username": "RitikaSahay",
                        "content": "Same thing happened with me. Is there a solution for it?\\n"
                    },
                    {
                        "username": "danicruz0415",
                        "content": "It\\'s happened to me a couple of times. My theory is that the time limit is given for the whole list of test cases. Thus, you can have your test pass, but it will still time limit exceed because it wont get to calculate all the test cases before the time runs out. I cannot confirm this but I think its true because with a very unoptimized solution I got time limit exceeded very early in the test cases (for another problem), after some optimizations I got it much later (like getting to the last tests) which themselves were around the same size, so if the time limit was set per test it would not make sense to fail in a similarly long test-case just that is much later in the test list. (I think the same would apply to memory limit exceeded)"
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "The exact same situation happened with me in one problem... it was a DP problem too... I was getting a Memory Limit Exceeded error with the memoized solution but it was running fine in the Run Code button."
                    },
                    {
                        "username": "Hubro",
                        "content": "I\\'m getting \"Time Limit Exceeded\" with 141/141 testcases passed and \"Last Executed Input\" is:\\n\\n```\\ns =\\n```\\n\\nDid I break it?"
                    },
                    {
                        "username": "karan_dhiman",
                        "content": "same issue"
                    },
                    {
                        "username": "BLANK-Zora",
                        "content": "exactly bro this shit is recked , like it is giving tests outside the constraints , how am i suppose to include such things in the code"
                    },
                    {
                        "username": "arunprep5",
                        "content": "same issue. java"
                    },
                    {
                        "username": "blasphelmy",
                        "content": "[@tuancoltech](/tuancoltech) it worked when i rewrote the code in c# instead of c++"
                    },
                    {
                        "username": "tuancoltech",
                        "content": "[@blasphelmy](/blasphelmy) [@Tomas Sandven](/Hubro) Did you guys find out why? I got the same issue."
                    },
                    {
                        "username": "blasphelmy",
                        "content": "i got that too. im not sure whats going on given that the constraint for input is between 1 and 1000"
                    },
                    {
                        "username": "Vinitajain",
                        "content": "Hi All,\\nI have a test case which is failing, but I feel the testcase result is incorrect.Please refer the screenshot below.\\n![image](https://assets.leetcode.com/users/images/e9e42efb-63d5-4cfa-b420-f1926674f6dc_1654838015.8394327.png)\\n\\nThe longest palindromic substring is \"aaca\" but the test case result is \"aca\". Anyone else faced this problem?"
                    },
                    {
                        "username": "OthSO",
                        "content": "[@mohdansah10](/mohdansah10) \\nthey are separated in the input with \"bd\" so it is not a valid answer "
                    },
                    {
                        "username": "mohdansah10",
                        "content": "I\\'m getting same error, but different case:\\nInput\\ns =\\n\"aacabdkacaa\"\\n\\nOutput\\n\"aacakacaa\"\\nExpected\\n\"aca\"\\n\\nBut mine is Palindrome"
                    },
                    {
                        "username": "hasmithraa",
                        "content": "the expected is correct because aaca can\\'t be a palindrome only \\'aacaa\\' can be a palindrome which is not there in your case"
                    },
                    {
                        "username": "Amish_Singh",
                        "content": "how are you considering \"aaca\" as a palindromic substring, \"aca\" is a palindrome and it is the longest"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "dude you really came up with the solution "
                    },
                    {
                        "username": "AryaAditya3609",
                        "content": "how is \"aaca\" and \"acaa\" same ???\\nWhile \"aca\" is palindrome because both \"aca\" and reverse of it \"aca\" is same !!"
                    },
                    {
                        "username": "alexandra-pickle",
                        "content": "\"aaca\" is not a palindrome"
                    },
                    {
                        "username": "bugHackerLoop",
                        "content": "I followed the approach leant by Aditya Verma DP lectures and encountered the same test case failing. Does the logic where I reverse the string and calculate the longest common substring doesn\\'t work here? I know it works for longest palindromic subsequence but here it fails for such test cases .. why is it so?"
                    },
                    {
                        "username": "mductran",
                        "content": "how is \\'aaca\\' a palindrome? when read backward it\\'s \\'acaa\\' so it\\'s not the same reading forward."
                    },
                    {
                        "username": "jnsudhir",
                        "content": "Check my solution, it was able to clear test case \"aaca\". Explained code in comments.\\n\\nhttps://leetcode.com/problems/longest-palindromic-substring/solutions/3091016/longest-palindromic-substring-using-javascript-beats-94-82-in-runtime-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "nikhileshratna",
                        "content": "aaca is not palindrome"
                    },
                    {
                        "username": "sunshine77",
                        "content": "hey, iam getting the same error, i have seen ansewrs where they have totally changed the algorithm, how did u solve this by tweaking the same algoirhtm"
                    },
                    {
                        "username": "bhupendrabc71",
                        "content": "how come \"aaca\" is palindrome. it should be \"aca\""
                    },
                    {
                        "username": "just11blocks",
                        "content": "aaca is not a palindrome...aacaa and aca are."
                    },
                    {
                        "username": "odi1n",
                        "content": "I also encountered this problem"
                    },
                    {
                        "username": "vamsi2302",
                        "content": "I think you get it by now!\\n"
                    }
                ]
            },
            {
                "id": 1573869,
                "content": [
                    {
                        "username": "ZenMasterV",
                        "content": "Seems like too many of the  coding wunderkinds here lack basic reading comprehension skills \\n\" Please don\\'t post any solutions in this discussion tab\"\\nIt\\'s almost the rule to find the exact opposite for the discussion of every question. I don\\'t want to see your damned solution!"
                    },
                    {
                        "username": "NeroXIII",
                        "content": "[@charonme](/charonme) name does not check out :((("
                    },
                    {
                        "username": "192731",
                        "content": "and if they do?"
                    },
                    {
                        "username": "plevi1995",
                        "content": "Excellent comment"
                    },
                    {
                        "username": "khan60939",
                        "content": "Can anyone tell how DP is being used here? "
                    },
                    {
                        "username": "sandagolcea",
                        "content": "[@charonme](/charonme) my thinking exactly, but at least they should create a flag to help us moderate and move solutions to the correct tab. Would only need a stack overflow moderation-like system: one person flags, another person receives a queue of flagged comments and confirms the tagging.. oh well"
                    },
                    {
                        "username": "charonme",
                        "content": "maybe people get confused by the official leetcode comment which says: \"If you\\'d like to share a detailed solution to the problem, please create a new post in the discuss section\"\\nMaybe some time ago they didn\\'t have a separate solutions section and only recently changed it, but left some of the old solutions in the discussion section and didn\\'t fix the automated comment worting?"
                    },
                    {
                        "username": "klanjewar037",
                        "content": "hehe"
                    },
                    {
                        "username": "sanemdeepak",
                        "content": "For input \"ac\" test case is expecting \"a\" as output, how is just \"a\" a palindromic string?"
                    },
                    {
                        "username": "ayushiidevpura",
                        "content": "because when we read \"a\" from forward it results in \"a\" and at the same time when we read \"a\" from backward it is still \"a\""
                    },
                    {
                        "username": "beyzigo",
                        "content": "Because if you read the string \"a\" backwards it will still be \"a\""
                    },
                    {
                        "username": "tsafackghokeng",
                        "content": "[@Chouhan_Gourav](/Chouhan_Gourav) the test case said \"ac\" not \"a\". is \"ac\" palindromic? for \"a\" i understand"
                    },
                    {
                        "username": "CODEWITHABHINAV",
                        "content": "you have to submit the first string as your answer read more about this question on gFg\\n"
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "any string is palindrome if we read it same from front and from back\\nin single character we read it same from front and back"
                    },
                    {
                        "username": "oinrup",
                        "content": "yes thats my question too"
                    },
                    {
                        "username": "yldemon",
                        "content": "Any character in the string by itself is a palindromic substring. So in the case where there is no palindromic substring with length > 1, you can return any character."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "Whenever you come accross such contradiction, just google the definition, any. Any string is called is pallindromic if the reverse of the string is equal to the original string. Reverse of \\'a\\' is \\'a\\'. Hope you get this."
                    },
                    {
                        "username": "947876275",
                        "content": "This post is for learner wanna practice DP.\\nThe basic idea is, if we wanna say \"aba\" is palindromic, then we need to firstly confirm that \"b\" is palindromic, then we also need to check if \"a\"(the first a) = \"a\" (the second a).\\n\\nM is a 2-d array which stores boolean values.\\nM[i][j] indicates if string[i.....j] is palindromic.\\nSo base cases are:\\nM[i][i] is true.\\nM[i][i + 1] = (s[i] == s[i + 1]);\\nrecurrence relation is :\\nM[i][j] = (s[i] == s[j] AND M[i + 1][j - 1]);\\nFor the implementation of recurrence relation, one idea is you can loop through all possible symmetry axis. For each of the axis, you expand at both RHS and LHS simultaneously. This method promises that when you are determining value in M[i][j], M[i + 1][j - 1] must have the correct value.\\nFinal answer can be found from all M[i][j] == 1 with largest (j - i)."
                    },
                    {
                        "username": "Msey",
                        "content": "thank you, cat brother"
                    },
                    {
                        "username": "user0558y",
                        "content": "I understand the solution but I don't understand why it needs any storage at all or why it needs to be a DP solution.\n\nThe condition `(s[i] == s[j] AND M[i + 1][j - 1])` requires you to memorise if `M[i+1][j-1]` is true, that's easy to understand. However, if you expand each possible axis at the same time, i.e. 1st iteration (s[i+1], s[j-1]), 2nd iteration `s[i+2], s[j-2]`, ... It is guaranteed that M[i+1][j-1] is always true and hence can be dropped, and you should break the loop when it is not true.\n\nIn summary, you don't need to memorise anything at all and you just need to check `s[i] == s[j]` while expanding in both directions at the same time, unless I have misunderstood anything? Here is an implementation of your algorithm but without storage: https://leetcode.com/problems/longest-palindromic-substring/submissions/868540120/"
                    },
                    {
                        "username": "taras",
                        "content": "Thank you! this is a beautiful explanation, though I\\'m not sure what exactly you mean by expanding both on LHS and RHS. In my implementation it\\'s enough to compute all diagonals of  the upper right triangle of the dp matrix."
                    },
                    {
                        "username": "klu_2100031593",
                        "content": "super explanation"
                    },
                    {
                        "username": "napoleon",
                        "content": "My Solution Is Naive, It Cost O(n^2), Is there Any Solution faster?"
                    },
                    {
                        "username": "leocampos",
                        "content": "[@tylerprill-rhdc](/tylerprill-rhdc) So, what I did was:\nStated in my mind the Brute Force approach - create every possible substring and test each one to see if is a palindrome and find the longest.\n\nOf course this would be ridiculously slow, so let's improve it.\nI also mentally stated that a palindrome has a recursive aspect -> if single char, or two equal chars, or charX + palindrome + charX\nSo I created a isPalindrome recursive method that checked it delegating to itself extracting the borders.\n\nSince a palindrome must start and end with the same char, in my traverse of the string, I started storing the position of each character Map<Character, List< Integer>>, so I would just go back to the previous found Char and check if from there to the current pointer I would have a Palindrome.\n\nThen I stopped doing this for every possible palindrome, I then started doing only for the ones that COULD be longer than the already found longest palindrome. That accelerated a lot.\n\nIn the almost last step, I added memoization. Remember that a palindrome is like a sandwich, with the external chars being equal and the meat being another palindrome? So I stored the found palindromes using their start and and positions. So I could check if that had already being checked and if so, either return true or false directly.\n\nThe final step was to convert the recursive function to an iterative function to save some memory used by the call stack.\nMaybe there are better implementations, just sharing my thought process."
                    },
                    {
                        "username": "tylerprill-rhdc",
                        "content": "[@tylerprill-rhdc](/tylerprill-rhdc) Two pointer based solution is also a really good solve here"
                    },
                    {
                        "username": "tylerprill-rhdc",
                        "content": "This could be done in a single pass algorithm, but will inherently check character indices multiple times based on the nature of the problem. (basically, iterate through each, then bubble out from each index)"
                    },
                    {
                        "username": "neetika",
                        "content": "From the leetcode blog, one of the methods of solving this is:\\n\\nA common mistake:\\nSome people will be tempted to come up with a quick solution, which is unfortunately flawed (however can be corrected easily):\\n\\nReverse S and become S\\u2019. Find the longest common substring between S and S\\u2019, which must also be the longest palindromic substring.\\nThis seemed to work, let\\u2019s see some examples below.\\n\\nFor example,\\nS = \\u201ccaba\\u201d, S\\u2019 = \\u201cabac\\u201d.\\nThe longest common substring between S and S\\u2019 is \\u201caba\\u201d, which is the answer.\\n\\nLet\\u2019s try another example:\\nS = \\u201cabacdfgdcaba\\u201d, S\\u2019 = \\u201cabacdgfdcaba\\u201d.\\nThe longest common substring between S and S\\u2019 is \\u201cabacd\\u201d. Clearly, this is not a valid palindrome.\\n\\n**We could see that the longest common substring method fails when there exists a reversed copy of a non-palindromic substring in some other part of S. To rectify this, each time we find a longest common substring candidate, we check if the substring\\u2019s indices are the same as the reversed substring\\u2019s original indices. If it is, then we attempt to update the longest palindrome found so far; if not, we skip this and find the next candidate.**\\n\\nIs this part correct? \\n\\nexample string: abcxycba\\nreverse string:  abcxycba\\n\\nThe substring indices are same as reversed string original indices and yet it is not a palindrome?"
                    },
                    {
                        "username": "HRVY_SNOWDEN",
                        "content": "cool sirr:)\\n"
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "WRONG.\\n\\nabcxycba reversed is abcyxcba."
                    },
                    {
                        "username": "travisl12",
                        "content": "After I solved this problem I thought it\\'d be interesting to see how it worked in realtime.\\n\\nhttps://codepen.io/TravisL12/pen/pogvweg"
                    },
                    {
                        "username": "user3907vj",
                        "content": "thanks for the \"nanananananana\" from all the small things ;)"
                    },
                    {
                        "username": "zapataast",
                        "content": "u are crazy"
                    },
                    {
                        "username": "sondq98",
                        "content": "very intuitive"
                    },
                    {
                        "username": "Tathagat017",
                        "content": "thank you\\n"
                    },
                    {
                        "username": "mikler",
                        "content": "So I think I finally understood logic of test creators. \\nEven if you write a classical DP or memorization solution for this one you will timeout on latest tests.\\nI think they consider it edge cases. Because if you add one simple line it will pass! OMG. \\nI have leet code for this. Instead of solving problems I spend hours optimizing the constants.\\n\\nif s == s[::-1]: return s"
                    },
                    {
                        "username": "Vectorido",
                        "content": "Don\\'t work already. Time limit at 141 test even with that construction."
                    },
                    {
                        "username": "deepalithakur17",
                        "content": "It will only work in python."
                    },
                    {
                        "username": "ishogbon",
                        "content": "Its memoization, not memorization "
                    },
                    {
                        "username": "84danie",
                        "content": "I submitted my solution, and received a Time Limit Exceeded on this test case:\\n\\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabcaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n\\nSo I copied and pasted the TC into a custom test case, and started to think about what I could tweak. However, I ended up accidentally hitting Run Code, but instead of getting a Time Limit Exceeded result, it passed:\\n\\n![0_1479079812693_upload-4af9e94c-2e53-4915-acf6-782780c7bf8b](/uploads/files/1479079813717-upload-4af9e94c-2e53-4915-acf6-782780c7bf8b.png) \\n\\nIs this supposed to happen and I just need to make my code more efficient, or is this a bug? \\n![0_1479079956817_upload-1ef15826-d6e6-4bde-9c06-eb597c5c8d0e](/uploads/files/1479079957639-upload-1ef15826-d6e6-4bde-9c06-eb597c5c8d0e.png)"
                    },
                    {
                        "username": "RitikaSahay",
                        "content": "Same thing happened with me. Is there a solution for it?\\n"
                    },
                    {
                        "username": "danicruz0415",
                        "content": "It\\'s happened to me a couple of times. My theory is that the time limit is given for the whole list of test cases. Thus, you can have your test pass, but it will still time limit exceed because it wont get to calculate all the test cases before the time runs out. I cannot confirm this but I think its true because with a very unoptimized solution I got time limit exceeded very early in the test cases (for another problem), after some optimizations I got it much later (like getting to the last tests) which themselves were around the same size, so if the time limit was set per test it would not make sense to fail in a similarly long test-case just that is much later in the test list. (I think the same would apply to memory limit exceeded)"
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "The exact same situation happened with me in one problem... it was a DP problem too... I was getting a Memory Limit Exceeded error with the memoized solution but it was running fine in the Run Code button."
                    },
                    {
                        "username": "Hubro",
                        "content": "I\\'m getting \"Time Limit Exceeded\" with 141/141 testcases passed and \"Last Executed Input\" is:\\n\\n```\\ns =\\n```\\n\\nDid I break it?"
                    },
                    {
                        "username": "karan_dhiman",
                        "content": "same issue"
                    },
                    {
                        "username": "BLANK-Zora",
                        "content": "exactly bro this shit is recked , like it is giving tests outside the constraints , how am i suppose to include such things in the code"
                    },
                    {
                        "username": "arunprep5",
                        "content": "same issue. java"
                    },
                    {
                        "username": "blasphelmy",
                        "content": "[@tuancoltech](/tuancoltech) it worked when i rewrote the code in c# instead of c++"
                    },
                    {
                        "username": "tuancoltech",
                        "content": "[@blasphelmy](/blasphelmy) [@Tomas Sandven](/Hubro) Did you guys find out why? I got the same issue."
                    },
                    {
                        "username": "blasphelmy",
                        "content": "i got that too. im not sure whats going on given that the constraint for input is between 1 and 1000"
                    },
                    {
                        "username": "Vinitajain",
                        "content": "Hi All,\\nI have a test case which is failing, but I feel the testcase result is incorrect.Please refer the screenshot below.\\n![image](https://assets.leetcode.com/users/images/e9e42efb-63d5-4cfa-b420-f1926674f6dc_1654838015.8394327.png)\\n\\nThe longest palindromic substring is \"aaca\" but the test case result is \"aca\". Anyone else faced this problem?"
                    },
                    {
                        "username": "OthSO",
                        "content": "[@mohdansah10](/mohdansah10) \\nthey are separated in the input with \"bd\" so it is not a valid answer "
                    },
                    {
                        "username": "mohdansah10",
                        "content": "I\\'m getting same error, but different case:\\nInput\\ns =\\n\"aacabdkacaa\"\\n\\nOutput\\n\"aacakacaa\"\\nExpected\\n\"aca\"\\n\\nBut mine is Palindrome"
                    },
                    {
                        "username": "hasmithraa",
                        "content": "the expected is correct because aaca can\\'t be a palindrome only \\'aacaa\\' can be a palindrome which is not there in your case"
                    },
                    {
                        "username": "Amish_Singh",
                        "content": "how are you considering \"aaca\" as a palindromic substring, \"aca\" is a palindrome and it is the longest"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "dude you really came up with the solution "
                    },
                    {
                        "username": "AryaAditya3609",
                        "content": "how is \"aaca\" and \"acaa\" same ???\\nWhile \"aca\" is palindrome because both \"aca\" and reverse of it \"aca\" is same !!"
                    },
                    {
                        "username": "alexandra-pickle",
                        "content": "\"aaca\" is not a palindrome"
                    },
                    {
                        "username": "bugHackerLoop",
                        "content": "I followed the approach leant by Aditya Verma DP lectures and encountered the same test case failing. Does the logic where I reverse the string and calculate the longest common substring doesn\\'t work here? I know it works for longest palindromic subsequence but here it fails for such test cases .. why is it so?"
                    },
                    {
                        "username": "mductran",
                        "content": "how is \\'aaca\\' a palindrome? when read backward it\\'s \\'acaa\\' so it\\'s not the same reading forward."
                    },
                    {
                        "username": "jnsudhir",
                        "content": "Check my solution, it was able to clear test case \"aaca\". Explained code in comments.\\n\\nhttps://leetcode.com/problems/longest-palindromic-substring/solutions/3091016/longest-palindromic-substring-using-javascript-beats-94-82-in-runtime-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "nikhileshratna",
                        "content": "aaca is not palindrome"
                    },
                    {
                        "username": "sunshine77",
                        "content": "hey, iam getting the same error, i have seen ansewrs where they have totally changed the algorithm, how did u solve this by tweaking the same algoirhtm"
                    },
                    {
                        "username": "bhupendrabc71",
                        "content": "how come \"aaca\" is palindrome. it should be \"aca\""
                    },
                    {
                        "username": "just11blocks",
                        "content": "aaca is not a palindrome...aacaa and aca are."
                    },
                    {
                        "username": "odi1n",
                        "content": "I also encountered this problem"
                    },
                    {
                        "username": "vamsi2302",
                        "content": "I think you get it by now!\\n"
                    }
                ]
            },
            {
                "id": 1568802,
                "content": [
                    {
                        "username": "ZenMasterV",
                        "content": "Seems like too many of the  coding wunderkinds here lack basic reading comprehension skills \\n\" Please don\\'t post any solutions in this discussion tab\"\\nIt\\'s almost the rule to find the exact opposite for the discussion of every question. I don\\'t want to see your damned solution!"
                    },
                    {
                        "username": "NeroXIII",
                        "content": "[@charonme](/charonme) name does not check out :((("
                    },
                    {
                        "username": "192731",
                        "content": "and if they do?"
                    },
                    {
                        "username": "plevi1995",
                        "content": "Excellent comment"
                    },
                    {
                        "username": "khan60939",
                        "content": "Can anyone tell how DP is being used here? "
                    },
                    {
                        "username": "sandagolcea",
                        "content": "[@charonme](/charonme) my thinking exactly, but at least they should create a flag to help us moderate and move solutions to the correct tab. Would only need a stack overflow moderation-like system: one person flags, another person receives a queue of flagged comments and confirms the tagging.. oh well"
                    },
                    {
                        "username": "charonme",
                        "content": "maybe people get confused by the official leetcode comment which says: \"If you\\'d like to share a detailed solution to the problem, please create a new post in the discuss section\"\\nMaybe some time ago they didn\\'t have a separate solutions section and only recently changed it, but left some of the old solutions in the discussion section and didn\\'t fix the automated comment worting?"
                    },
                    {
                        "username": "klanjewar037",
                        "content": "hehe"
                    },
                    {
                        "username": "sanemdeepak",
                        "content": "For input \"ac\" test case is expecting \"a\" as output, how is just \"a\" a palindromic string?"
                    },
                    {
                        "username": "ayushiidevpura",
                        "content": "because when we read \"a\" from forward it results in \"a\" and at the same time when we read \"a\" from backward it is still \"a\""
                    },
                    {
                        "username": "beyzigo",
                        "content": "Because if you read the string \"a\" backwards it will still be \"a\""
                    },
                    {
                        "username": "tsafackghokeng",
                        "content": "[@Chouhan_Gourav](/Chouhan_Gourav) the test case said \"ac\" not \"a\". is \"ac\" palindromic? for \"a\" i understand"
                    },
                    {
                        "username": "CODEWITHABHINAV",
                        "content": "you have to submit the first string as your answer read more about this question on gFg\\n"
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "any string is palindrome if we read it same from front and from back\\nin single character we read it same from front and back"
                    },
                    {
                        "username": "oinrup",
                        "content": "yes thats my question too"
                    },
                    {
                        "username": "yldemon",
                        "content": "Any character in the string by itself is a palindromic substring. So in the case where there is no palindromic substring with length > 1, you can return any character."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "Whenever you come accross such contradiction, just google the definition, any. Any string is called is pallindromic if the reverse of the string is equal to the original string. Reverse of \\'a\\' is \\'a\\'. Hope you get this."
                    },
                    {
                        "username": "947876275",
                        "content": "This post is for learner wanna practice DP.\\nThe basic idea is, if we wanna say \"aba\" is palindromic, then we need to firstly confirm that \"b\" is palindromic, then we also need to check if \"a\"(the first a) = \"a\" (the second a).\\n\\nM is a 2-d array which stores boolean values.\\nM[i][j] indicates if string[i.....j] is palindromic.\\nSo base cases are:\\nM[i][i] is true.\\nM[i][i + 1] = (s[i] == s[i + 1]);\\nrecurrence relation is :\\nM[i][j] = (s[i] == s[j] AND M[i + 1][j - 1]);\\nFor the implementation of recurrence relation, one idea is you can loop through all possible symmetry axis. For each of the axis, you expand at both RHS and LHS simultaneously. This method promises that when you are determining value in M[i][j], M[i + 1][j - 1] must have the correct value.\\nFinal answer can be found from all M[i][j] == 1 with largest (j - i)."
                    },
                    {
                        "username": "Msey",
                        "content": "thank you, cat brother"
                    },
                    {
                        "username": "user0558y",
                        "content": "I understand the solution but I don't understand why it needs any storage at all or why it needs to be a DP solution.\n\nThe condition `(s[i] == s[j] AND M[i + 1][j - 1])` requires you to memorise if `M[i+1][j-1]` is true, that's easy to understand. However, if you expand each possible axis at the same time, i.e. 1st iteration (s[i+1], s[j-1]), 2nd iteration `s[i+2], s[j-2]`, ... It is guaranteed that M[i+1][j-1] is always true and hence can be dropped, and you should break the loop when it is not true.\n\nIn summary, you don't need to memorise anything at all and you just need to check `s[i] == s[j]` while expanding in both directions at the same time, unless I have misunderstood anything? Here is an implementation of your algorithm but without storage: https://leetcode.com/problems/longest-palindromic-substring/submissions/868540120/"
                    },
                    {
                        "username": "taras",
                        "content": "Thank you! this is a beautiful explanation, though I\\'m not sure what exactly you mean by expanding both on LHS and RHS. In my implementation it\\'s enough to compute all diagonals of  the upper right triangle of the dp matrix."
                    },
                    {
                        "username": "klu_2100031593",
                        "content": "super explanation"
                    },
                    {
                        "username": "napoleon",
                        "content": "My Solution Is Naive, It Cost O(n^2), Is there Any Solution faster?"
                    },
                    {
                        "username": "leocampos",
                        "content": "[@tylerprill-rhdc](/tylerprill-rhdc) So, what I did was:\nStated in my mind the Brute Force approach - create every possible substring and test each one to see if is a palindrome and find the longest.\n\nOf course this would be ridiculously slow, so let's improve it.\nI also mentally stated that a palindrome has a recursive aspect -> if single char, or two equal chars, or charX + palindrome + charX\nSo I created a isPalindrome recursive method that checked it delegating to itself extracting the borders.\n\nSince a palindrome must start and end with the same char, in my traverse of the string, I started storing the position of each character Map<Character, List< Integer>>, so I would just go back to the previous found Char and check if from there to the current pointer I would have a Palindrome.\n\nThen I stopped doing this for every possible palindrome, I then started doing only for the ones that COULD be longer than the already found longest palindrome. That accelerated a lot.\n\nIn the almost last step, I added memoization. Remember that a palindrome is like a sandwich, with the external chars being equal and the meat being another palindrome? So I stored the found palindromes using their start and and positions. So I could check if that had already being checked and if so, either return true or false directly.\n\nThe final step was to convert the recursive function to an iterative function to save some memory used by the call stack.\nMaybe there are better implementations, just sharing my thought process."
                    },
                    {
                        "username": "tylerprill-rhdc",
                        "content": "[@tylerprill-rhdc](/tylerprill-rhdc) Two pointer based solution is also a really good solve here"
                    },
                    {
                        "username": "tylerprill-rhdc",
                        "content": "This could be done in a single pass algorithm, but will inherently check character indices multiple times based on the nature of the problem. (basically, iterate through each, then bubble out from each index)"
                    },
                    {
                        "username": "neetika",
                        "content": "From the leetcode blog, one of the methods of solving this is:\\n\\nA common mistake:\\nSome people will be tempted to come up with a quick solution, which is unfortunately flawed (however can be corrected easily):\\n\\nReverse S and become S\\u2019. Find the longest common substring between S and S\\u2019, which must also be the longest palindromic substring.\\nThis seemed to work, let\\u2019s see some examples below.\\n\\nFor example,\\nS = \\u201ccaba\\u201d, S\\u2019 = \\u201cabac\\u201d.\\nThe longest common substring between S and S\\u2019 is \\u201caba\\u201d, which is the answer.\\n\\nLet\\u2019s try another example:\\nS = \\u201cabacdfgdcaba\\u201d, S\\u2019 = \\u201cabacdgfdcaba\\u201d.\\nThe longest common substring between S and S\\u2019 is \\u201cabacd\\u201d. Clearly, this is not a valid palindrome.\\n\\n**We could see that the longest common substring method fails when there exists a reversed copy of a non-palindromic substring in some other part of S. To rectify this, each time we find a longest common substring candidate, we check if the substring\\u2019s indices are the same as the reversed substring\\u2019s original indices. If it is, then we attempt to update the longest palindrome found so far; if not, we skip this and find the next candidate.**\\n\\nIs this part correct? \\n\\nexample string: abcxycba\\nreverse string:  abcxycba\\n\\nThe substring indices are same as reversed string original indices and yet it is not a palindrome?"
                    },
                    {
                        "username": "HRVY_SNOWDEN",
                        "content": "cool sirr:)\\n"
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "WRONG.\\n\\nabcxycba reversed is abcyxcba."
                    },
                    {
                        "username": "travisl12",
                        "content": "After I solved this problem I thought it\\'d be interesting to see how it worked in realtime.\\n\\nhttps://codepen.io/TravisL12/pen/pogvweg"
                    },
                    {
                        "username": "user3907vj",
                        "content": "thanks for the \"nanananananana\" from all the small things ;)"
                    },
                    {
                        "username": "zapataast",
                        "content": "u are crazy"
                    },
                    {
                        "username": "sondq98",
                        "content": "very intuitive"
                    },
                    {
                        "username": "Tathagat017",
                        "content": "thank you\\n"
                    },
                    {
                        "username": "mikler",
                        "content": "So I think I finally understood logic of test creators. \\nEven if you write a classical DP or memorization solution for this one you will timeout on latest tests.\\nI think they consider it edge cases. Because if you add one simple line it will pass! OMG. \\nI have leet code for this. Instead of solving problems I spend hours optimizing the constants.\\n\\nif s == s[::-1]: return s"
                    },
                    {
                        "username": "Vectorido",
                        "content": "Don\\'t work already. Time limit at 141 test even with that construction."
                    },
                    {
                        "username": "deepalithakur17",
                        "content": "It will only work in python."
                    },
                    {
                        "username": "ishogbon",
                        "content": "Its memoization, not memorization "
                    },
                    {
                        "username": "84danie",
                        "content": "I submitted my solution, and received a Time Limit Exceeded on this test case:\\n\\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabcaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n\\nSo I copied and pasted the TC into a custom test case, and started to think about what I could tweak. However, I ended up accidentally hitting Run Code, but instead of getting a Time Limit Exceeded result, it passed:\\n\\n![0_1479079812693_upload-4af9e94c-2e53-4915-acf6-782780c7bf8b](/uploads/files/1479079813717-upload-4af9e94c-2e53-4915-acf6-782780c7bf8b.png) \\n\\nIs this supposed to happen and I just need to make my code more efficient, or is this a bug? \\n![0_1479079956817_upload-1ef15826-d6e6-4bde-9c06-eb597c5c8d0e](/uploads/files/1479079957639-upload-1ef15826-d6e6-4bde-9c06-eb597c5c8d0e.png)"
                    },
                    {
                        "username": "RitikaSahay",
                        "content": "Same thing happened with me. Is there a solution for it?\\n"
                    },
                    {
                        "username": "danicruz0415",
                        "content": "It\\'s happened to me a couple of times. My theory is that the time limit is given for the whole list of test cases. Thus, you can have your test pass, but it will still time limit exceed because it wont get to calculate all the test cases before the time runs out. I cannot confirm this but I think its true because with a very unoptimized solution I got time limit exceeded very early in the test cases (for another problem), after some optimizations I got it much later (like getting to the last tests) which themselves were around the same size, so if the time limit was set per test it would not make sense to fail in a similarly long test-case just that is much later in the test list. (I think the same would apply to memory limit exceeded)"
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "The exact same situation happened with me in one problem... it was a DP problem too... I was getting a Memory Limit Exceeded error with the memoized solution but it was running fine in the Run Code button."
                    },
                    {
                        "username": "Hubro",
                        "content": "I\\'m getting \"Time Limit Exceeded\" with 141/141 testcases passed and \"Last Executed Input\" is:\\n\\n```\\ns =\\n```\\n\\nDid I break it?"
                    },
                    {
                        "username": "karan_dhiman",
                        "content": "same issue"
                    },
                    {
                        "username": "BLANK-Zora",
                        "content": "exactly bro this shit is recked , like it is giving tests outside the constraints , how am i suppose to include such things in the code"
                    },
                    {
                        "username": "arunprep5",
                        "content": "same issue. java"
                    },
                    {
                        "username": "blasphelmy",
                        "content": "[@tuancoltech](/tuancoltech) it worked when i rewrote the code in c# instead of c++"
                    },
                    {
                        "username": "tuancoltech",
                        "content": "[@blasphelmy](/blasphelmy) [@Tomas Sandven](/Hubro) Did you guys find out why? I got the same issue."
                    },
                    {
                        "username": "blasphelmy",
                        "content": "i got that too. im not sure whats going on given that the constraint for input is between 1 and 1000"
                    },
                    {
                        "username": "Vinitajain",
                        "content": "Hi All,\\nI have a test case which is failing, but I feel the testcase result is incorrect.Please refer the screenshot below.\\n![image](https://assets.leetcode.com/users/images/e9e42efb-63d5-4cfa-b420-f1926674f6dc_1654838015.8394327.png)\\n\\nThe longest palindromic substring is \"aaca\" but the test case result is \"aca\". Anyone else faced this problem?"
                    },
                    {
                        "username": "OthSO",
                        "content": "[@mohdansah10](/mohdansah10) \\nthey are separated in the input with \"bd\" so it is not a valid answer "
                    },
                    {
                        "username": "mohdansah10",
                        "content": "I\\'m getting same error, but different case:\\nInput\\ns =\\n\"aacabdkacaa\"\\n\\nOutput\\n\"aacakacaa\"\\nExpected\\n\"aca\"\\n\\nBut mine is Palindrome"
                    },
                    {
                        "username": "hasmithraa",
                        "content": "the expected is correct because aaca can\\'t be a palindrome only \\'aacaa\\' can be a palindrome which is not there in your case"
                    },
                    {
                        "username": "Amish_Singh",
                        "content": "how are you considering \"aaca\" as a palindromic substring, \"aca\" is a palindrome and it is the longest"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "dude you really came up with the solution "
                    },
                    {
                        "username": "AryaAditya3609",
                        "content": "how is \"aaca\" and \"acaa\" same ???\\nWhile \"aca\" is palindrome because both \"aca\" and reverse of it \"aca\" is same !!"
                    },
                    {
                        "username": "alexandra-pickle",
                        "content": "\"aaca\" is not a palindrome"
                    },
                    {
                        "username": "bugHackerLoop",
                        "content": "I followed the approach leant by Aditya Verma DP lectures and encountered the same test case failing. Does the logic where I reverse the string and calculate the longest common substring doesn\\'t work here? I know it works for longest palindromic subsequence but here it fails for such test cases .. why is it so?"
                    },
                    {
                        "username": "mductran",
                        "content": "how is \\'aaca\\' a palindrome? when read backward it\\'s \\'acaa\\' so it\\'s not the same reading forward."
                    },
                    {
                        "username": "jnsudhir",
                        "content": "Check my solution, it was able to clear test case \"aaca\". Explained code in comments.\\n\\nhttps://leetcode.com/problems/longest-palindromic-substring/solutions/3091016/longest-palindromic-substring-using-javascript-beats-94-82-in-runtime-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "nikhileshratna",
                        "content": "aaca is not palindrome"
                    },
                    {
                        "username": "sunshine77",
                        "content": "hey, iam getting the same error, i have seen ansewrs where they have totally changed the algorithm, how did u solve this by tweaking the same algoirhtm"
                    },
                    {
                        "username": "bhupendrabc71",
                        "content": "how come \"aaca\" is palindrome. it should be \"aca\""
                    },
                    {
                        "username": "just11blocks",
                        "content": "aaca is not a palindrome...aacaa and aca are."
                    },
                    {
                        "username": "odi1n",
                        "content": "I also encountered this problem"
                    },
                    {
                        "username": "vamsi2302",
                        "content": "I think you get it by now!\\n"
                    }
                ]
            },
            {
                "id": 1570975,
                "content": [
                    {
                        "username": "ZenMasterV",
                        "content": "Seems like too many of the  coding wunderkinds here lack basic reading comprehension skills \\n\" Please don\\'t post any solutions in this discussion tab\"\\nIt\\'s almost the rule to find the exact opposite for the discussion of every question. I don\\'t want to see your damned solution!"
                    },
                    {
                        "username": "NeroXIII",
                        "content": "[@charonme](/charonme) name does not check out :((("
                    },
                    {
                        "username": "192731",
                        "content": "and if they do?"
                    },
                    {
                        "username": "plevi1995",
                        "content": "Excellent comment"
                    },
                    {
                        "username": "khan60939",
                        "content": "Can anyone tell how DP is being used here? "
                    },
                    {
                        "username": "sandagolcea",
                        "content": "[@charonme](/charonme) my thinking exactly, but at least they should create a flag to help us moderate and move solutions to the correct tab. Would only need a stack overflow moderation-like system: one person flags, another person receives a queue of flagged comments and confirms the tagging.. oh well"
                    },
                    {
                        "username": "charonme",
                        "content": "maybe people get confused by the official leetcode comment which says: \"If you\\'d like to share a detailed solution to the problem, please create a new post in the discuss section\"\\nMaybe some time ago they didn\\'t have a separate solutions section and only recently changed it, but left some of the old solutions in the discussion section and didn\\'t fix the automated comment worting?"
                    },
                    {
                        "username": "klanjewar037",
                        "content": "hehe"
                    },
                    {
                        "username": "sanemdeepak",
                        "content": "For input \"ac\" test case is expecting \"a\" as output, how is just \"a\" a palindromic string?"
                    },
                    {
                        "username": "ayushiidevpura",
                        "content": "because when we read \"a\" from forward it results in \"a\" and at the same time when we read \"a\" from backward it is still \"a\""
                    },
                    {
                        "username": "beyzigo",
                        "content": "Because if you read the string \"a\" backwards it will still be \"a\""
                    },
                    {
                        "username": "tsafackghokeng",
                        "content": "[@Chouhan_Gourav](/Chouhan_Gourav) the test case said \"ac\" not \"a\". is \"ac\" palindromic? for \"a\" i understand"
                    },
                    {
                        "username": "CODEWITHABHINAV",
                        "content": "you have to submit the first string as your answer read more about this question on gFg\\n"
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "any string is palindrome if we read it same from front and from back\\nin single character we read it same from front and back"
                    },
                    {
                        "username": "oinrup",
                        "content": "yes thats my question too"
                    },
                    {
                        "username": "yldemon",
                        "content": "Any character in the string by itself is a palindromic substring. So in the case where there is no palindromic substring with length > 1, you can return any character."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "Whenever you come accross such contradiction, just google the definition, any. Any string is called is pallindromic if the reverse of the string is equal to the original string. Reverse of \\'a\\' is \\'a\\'. Hope you get this."
                    },
                    {
                        "username": "947876275",
                        "content": "This post is for learner wanna practice DP.\\nThe basic idea is, if we wanna say \"aba\" is palindromic, then we need to firstly confirm that \"b\" is palindromic, then we also need to check if \"a\"(the first a) = \"a\" (the second a).\\n\\nM is a 2-d array which stores boolean values.\\nM[i][j] indicates if string[i.....j] is palindromic.\\nSo base cases are:\\nM[i][i] is true.\\nM[i][i + 1] = (s[i] == s[i + 1]);\\nrecurrence relation is :\\nM[i][j] = (s[i] == s[j] AND M[i + 1][j - 1]);\\nFor the implementation of recurrence relation, one idea is you can loop through all possible symmetry axis. For each of the axis, you expand at both RHS and LHS simultaneously. This method promises that when you are determining value in M[i][j], M[i + 1][j - 1] must have the correct value.\\nFinal answer can be found from all M[i][j] == 1 with largest (j - i)."
                    },
                    {
                        "username": "Msey",
                        "content": "thank you, cat brother"
                    },
                    {
                        "username": "user0558y",
                        "content": "I understand the solution but I don't understand why it needs any storage at all or why it needs to be a DP solution.\n\nThe condition `(s[i] == s[j] AND M[i + 1][j - 1])` requires you to memorise if `M[i+1][j-1]` is true, that's easy to understand. However, if you expand each possible axis at the same time, i.e. 1st iteration (s[i+1], s[j-1]), 2nd iteration `s[i+2], s[j-2]`, ... It is guaranteed that M[i+1][j-1] is always true and hence can be dropped, and you should break the loop when it is not true.\n\nIn summary, you don't need to memorise anything at all and you just need to check `s[i] == s[j]` while expanding in both directions at the same time, unless I have misunderstood anything? Here is an implementation of your algorithm but without storage: https://leetcode.com/problems/longest-palindromic-substring/submissions/868540120/"
                    },
                    {
                        "username": "taras",
                        "content": "Thank you! this is a beautiful explanation, though I\\'m not sure what exactly you mean by expanding both on LHS and RHS. In my implementation it\\'s enough to compute all diagonals of  the upper right triangle of the dp matrix."
                    },
                    {
                        "username": "klu_2100031593",
                        "content": "super explanation"
                    },
                    {
                        "username": "napoleon",
                        "content": "My Solution Is Naive, It Cost O(n^2), Is there Any Solution faster?"
                    },
                    {
                        "username": "leocampos",
                        "content": "[@tylerprill-rhdc](/tylerprill-rhdc) So, what I did was:\nStated in my mind the Brute Force approach - create every possible substring and test each one to see if is a palindrome and find the longest.\n\nOf course this would be ridiculously slow, so let's improve it.\nI also mentally stated that a palindrome has a recursive aspect -> if single char, or two equal chars, or charX + palindrome + charX\nSo I created a isPalindrome recursive method that checked it delegating to itself extracting the borders.\n\nSince a palindrome must start and end with the same char, in my traverse of the string, I started storing the position of each character Map<Character, List< Integer>>, so I would just go back to the previous found Char and check if from there to the current pointer I would have a Palindrome.\n\nThen I stopped doing this for every possible palindrome, I then started doing only for the ones that COULD be longer than the already found longest palindrome. That accelerated a lot.\n\nIn the almost last step, I added memoization. Remember that a palindrome is like a sandwich, with the external chars being equal and the meat being another palindrome? So I stored the found palindromes using their start and and positions. So I could check if that had already being checked and if so, either return true or false directly.\n\nThe final step was to convert the recursive function to an iterative function to save some memory used by the call stack.\nMaybe there are better implementations, just sharing my thought process."
                    },
                    {
                        "username": "tylerprill-rhdc",
                        "content": "[@tylerprill-rhdc](/tylerprill-rhdc) Two pointer based solution is also a really good solve here"
                    },
                    {
                        "username": "tylerprill-rhdc",
                        "content": "This could be done in a single pass algorithm, but will inherently check character indices multiple times based on the nature of the problem. (basically, iterate through each, then bubble out from each index)"
                    },
                    {
                        "username": "neetika",
                        "content": "From the leetcode blog, one of the methods of solving this is:\\n\\nA common mistake:\\nSome people will be tempted to come up with a quick solution, which is unfortunately flawed (however can be corrected easily):\\n\\nReverse S and become S\\u2019. Find the longest common substring between S and S\\u2019, which must also be the longest palindromic substring.\\nThis seemed to work, let\\u2019s see some examples below.\\n\\nFor example,\\nS = \\u201ccaba\\u201d, S\\u2019 = \\u201cabac\\u201d.\\nThe longest common substring between S and S\\u2019 is \\u201caba\\u201d, which is the answer.\\n\\nLet\\u2019s try another example:\\nS = \\u201cabacdfgdcaba\\u201d, S\\u2019 = \\u201cabacdgfdcaba\\u201d.\\nThe longest common substring between S and S\\u2019 is \\u201cabacd\\u201d. Clearly, this is not a valid palindrome.\\n\\n**We could see that the longest common substring method fails when there exists a reversed copy of a non-palindromic substring in some other part of S. To rectify this, each time we find a longest common substring candidate, we check if the substring\\u2019s indices are the same as the reversed substring\\u2019s original indices. If it is, then we attempt to update the longest palindrome found so far; if not, we skip this and find the next candidate.**\\n\\nIs this part correct? \\n\\nexample string: abcxycba\\nreverse string:  abcxycba\\n\\nThe substring indices are same as reversed string original indices and yet it is not a palindrome?"
                    },
                    {
                        "username": "HRVY_SNOWDEN",
                        "content": "cool sirr:)\\n"
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "WRONG.\\n\\nabcxycba reversed is abcyxcba."
                    },
                    {
                        "username": "travisl12",
                        "content": "After I solved this problem I thought it\\'d be interesting to see how it worked in realtime.\\n\\nhttps://codepen.io/TravisL12/pen/pogvweg"
                    },
                    {
                        "username": "user3907vj",
                        "content": "thanks for the \"nanananananana\" from all the small things ;)"
                    },
                    {
                        "username": "zapataast",
                        "content": "u are crazy"
                    },
                    {
                        "username": "sondq98",
                        "content": "very intuitive"
                    },
                    {
                        "username": "Tathagat017",
                        "content": "thank you\\n"
                    },
                    {
                        "username": "mikler",
                        "content": "So I think I finally understood logic of test creators. \\nEven if you write a classical DP or memorization solution for this one you will timeout on latest tests.\\nI think they consider it edge cases. Because if you add one simple line it will pass! OMG. \\nI have leet code for this. Instead of solving problems I spend hours optimizing the constants.\\n\\nif s == s[::-1]: return s"
                    },
                    {
                        "username": "Vectorido",
                        "content": "Don\\'t work already. Time limit at 141 test even with that construction."
                    },
                    {
                        "username": "deepalithakur17",
                        "content": "It will only work in python."
                    },
                    {
                        "username": "ishogbon",
                        "content": "Its memoization, not memorization "
                    },
                    {
                        "username": "84danie",
                        "content": "I submitted my solution, and received a Time Limit Exceeded on this test case:\\n\\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabcaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n\\nSo I copied and pasted the TC into a custom test case, and started to think about what I could tweak. However, I ended up accidentally hitting Run Code, but instead of getting a Time Limit Exceeded result, it passed:\\n\\n![0_1479079812693_upload-4af9e94c-2e53-4915-acf6-782780c7bf8b](/uploads/files/1479079813717-upload-4af9e94c-2e53-4915-acf6-782780c7bf8b.png) \\n\\nIs this supposed to happen and I just need to make my code more efficient, or is this a bug? \\n![0_1479079956817_upload-1ef15826-d6e6-4bde-9c06-eb597c5c8d0e](/uploads/files/1479079957639-upload-1ef15826-d6e6-4bde-9c06-eb597c5c8d0e.png)"
                    },
                    {
                        "username": "RitikaSahay",
                        "content": "Same thing happened with me. Is there a solution for it?\\n"
                    },
                    {
                        "username": "danicruz0415",
                        "content": "It\\'s happened to me a couple of times. My theory is that the time limit is given for the whole list of test cases. Thus, you can have your test pass, but it will still time limit exceed because it wont get to calculate all the test cases before the time runs out. I cannot confirm this but I think its true because with a very unoptimized solution I got time limit exceeded very early in the test cases (for another problem), after some optimizations I got it much later (like getting to the last tests) which themselves were around the same size, so if the time limit was set per test it would not make sense to fail in a similarly long test-case just that is much later in the test list. (I think the same would apply to memory limit exceeded)"
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "The exact same situation happened with me in one problem... it was a DP problem too... I was getting a Memory Limit Exceeded error with the memoized solution but it was running fine in the Run Code button."
                    },
                    {
                        "username": "Hubro",
                        "content": "I\\'m getting \"Time Limit Exceeded\" with 141/141 testcases passed and \"Last Executed Input\" is:\\n\\n```\\ns =\\n```\\n\\nDid I break it?"
                    },
                    {
                        "username": "karan_dhiman",
                        "content": "same issue"
                    },
                    {
                        "username": "BLANK-Zora",
                        "content": "exactly bro this shit is recked , like it is giving tests outside the constraints , how am i suppose to include such things in the code"
                    },
                    {
                        "username": "arunprep5",
                        "content": "same issue. java"
                    },
                    {
                        "username": "blasphelmy",
                        "content": "[@tuancoltech](/tuancoltech) it worked when i rewrote the code in c# instead of c++"
                    },
                    {
                        "username": "tuancoltech",
                        "content": "[@blasphelmy](/blasphelmy) [@Tomas Sandven](/Hubro) Did you guys find out why? I got the same issue."
                    },
                    {
                        "username": "blasphelmy",
                        "content": "i got that too. im not sure whats going on given that the constraint for input is between 1 and 1000"
                    },
                    {
                        "username": "Vinitajain",
                        "content": "Hi All,\\nI have a test case which is failing, but I feel the testcase result is incorrect.Please refer the screenshot below.\\n![image](https://assets.leetcode.com/users/images/e9e42efb-63d5-4cfa-b420-f1926674f6dc_1654838015.8394327.png)\\n\\nThe longest palindromic substring is \"aaca\" but the test case result is \"aca\". Anyone else faced this problem?"
                    },
                    {
                        "username": "OthSO",
                        "content": "[@mohdansah10](/mohdansah10) \\nthey are separated in the input with \"bd\" so it is not a valid answer "
                    },
                    {
                        "username": "mohdansah10",
                        "content": "I\\'m getting same error, but different case:\\nInput\\ns =\\n\"aacabdkacaa\"\\n\\nOutput\\n\"aacakacaa\"\\nExpected\\n\"aca\"\\n\\nBut mine is Palindrome"
                    },
                    {
                        "username": "hasmithraa",
                        "content": "the expected is correct because aaca can\\'t be a palindrome only \\'aacaa\\' can be a palindrome which is not there in your case"
                    },
                    {
                        "username": "Amish_Singh",
                        "content": "how are you considering \"aaca\" as a palindromic substring, \"aca\" is a palindrome and it is the longest"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "dude you really came up with the solution "
                    },
                    {
                        "username": "AryaAditya3609",
                        "content": "how is \"aaca\" and \"acaa\" same ???\\nWhile \"aca\" is palindrome because both \"aca\" and reverse of it \"aca\" is same !!"
                    },
                    {
                        "username": "alexandra-pickle",
                        "content": "\"aaca\" is not a palindrome"
                    },
                    {
                        "username": "bugHackerLoop",
                        "content": "I followed the approach leant by Aditya Verma DP lectures and encountered the same test case failing. Does the logic where I reverse the string and calculate the longest common substring doesn\\'t work here? I know it works for longest palindromic subsequence but here it fails for such test cases .. why is it so?"
                    },
                    {
                        "username": "mductran",
                        "content": "how is \\'aaca\\' a palindrome? when read backward it\\'s \\'acaa\\' so it\\'s not the same reading forward."
                    },
                    {
                        "username": "jnsudhir",
                        "content": "Check my solution, it was able to clear test case \"aaca\". Explained code in comments.\\n\\nhttps://leetcode.com/problems/longest-palindromic-substring/solutions/3091016/longest-palindromic-substring-using-javascript-beats-94-82-in-runtime-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "nikhileshratna",
                        "content": "aaca is not palindrome"
                    },
                    {
                        "username": "sunshine77",
                        "content": "hey, iam getting the same error, i have seen ansewrs where they have totally changed the algorithm, how did u solve this by tweaking the same algoirhtm"
                    },
                    {
                        "username": "bhupendrabc71",
                        "content": "how come \"aaca\" is palindrome. it should be \"aca\""
                    },
                    {
                        "username": "just11blocks",
                        "content": "aaca is not a palindrome...aacaa and aca are."
                    },
                    {
                        "username": "odi1n",
                        "content": "I also encountered this problem"
                    },
                    {
                        "username": "vamsi2302",
                        "content": "I think you get it by now!\\n"
                    }
                ]
            },
            {
                "id": 1873701,
                "content": [
                    {
                        "username": "ZenMasterV",
                        "content": "Seems like too many of the  coding wunderkinds here lack basic reading comprehension skills \\n\" Please don\\'t post any solutions in this discussion tab\"\\nIt\\'s almost the rule to find the exact opposite for the discussion of every question. I don\\'t want to see your damned solution!"
                    },
                    {
                        "username": "NeroXIII",
                        "content": "[@charonme](/charonme) name does not check out :((("
                    },
                    {
                        "username": "192731",
                        "content": "and if they do?"
                    },
                    {
                        "username": "plevi1995",
                        "content": "Excellent comment"
                    },
                    {
                        "username": "khan60939",
                        "content": "Can anyone tell how DP is being used here? "
                    },
                    {
                        "username": "sandagolcea",
                        "content": "[@charonme](/charonme) my thinking exactly, but at least they should create a flag to help us moderate and move solutions to the correct tab. Would only need a stack overflow moderation-like system: one person flags, another person receives a queue of flagged comments and confirms the tagging.. oh well"
                    },
                    {
                        "username": "charonme",
                        "content": "maybe people get confused by the official leetcode comment which says: \"If you\\'d like to share a detailed solution to the problem, please create a new post in the discuss section\"\\nMaybe some time ago they didn\\'t have a separate solutions section and only recently changed it, but left some of the old solutions in the discussion section and didn\\'t fix the automated comment worting?"
                    },
                    {
                        "username": "klanjewar037",
                        "content": "hehe"
                    },
                    {
                        "username": "sanemdeepak",
                        "content": "For input \"ac\" test case is expecting \"a\" as output, how is just \"a\" a palindromic string?"
                    },
                    {
                        "username": "ayushiidevpura",
                        "content": "because when we read \"a\" from forward it results in \"a\" and at the same time when we read \"a\" from backward it is still \"a\""
                    },
                    {
                        "username": "beyzigo",
                        "content": "Because if you read the string \"a\" backwards it will still be \"a\""
                    },
                    {
                        "username": "tsafackghokeng",
                        "content": "[@Chouhan_Gourav](/Chouhan_Gourav) the test case said \"ac\" not \"a\". is \"ac\" palindromic? for \"a\" i understand"
                    },
                    {
                        "username": "CODEWITHABHINAV",
                        "content": "you have to submit the first string as your answer read more about this question on gFg\\n"
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "any string is palindrome if we read it same from front and from back\\nin single character we read it same from front and back"
                    },
                    {
                        "username": "oinrup",
                        "content": "yes thats my question too"
                    },
                    {
                        "username": "yldemon",
                        "content": "Any character in the string by itself is a palindromic substring. So in the case where there is no palindromic substring with length > 1, you can return any character."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "Whenever you come accross such contradiction, just google the definition, any. Any string is called is pallindromic if the reverse of the string is equal to the original string. Reverse of \\'a\\' is \\'a\\'. Hope you get this."
                    },
                    {
                        "username": "947876275",
                        "content": "This post is for learner wanna practice DP.\\nThe basic idea is, if we wanna say \"aba\" is palindromic, then we need to firstly confirm that \"b\" is palindromic, then we also need to check if \"a\"(the first a) = \"a\" (the second a).\\n\\nM is a 2-d array which stores boolean values.\\nM[i][j] indicates if string[i.....j] is palindromic.\\nSo base cases are:\\nM[i][i] is true.\\nM[i][i + 1] = (s[i] == s[i + 1]);\\nrecurrence relation is :\\nM[i][j] = (s[i] == s[j] AND M[i + 1][j - 1]);\\nFor the implementation of recurrence relation, one idea is you can loop through all possible symmetry axis. For each of the axis, you expand at both RHS and LHS simultaneously. This method promises that when you are determining value in M[i][j], M[i + 1][j - 1] must have the correct value.\\nFinal answer can be found from all M[i][j] == 1 with largest (j - i)."
                    },
                    {
                        "username": "Msey",
                        "content": "thank you, cat brother"
                    },
                    {
                        "username": "user0558y",
                        "content": "I understand the solution but I don't understand why it needs any storage at all or why it needs to be a DP solution.\n\nThe condition `(s[i] == s[j] AND M[i + 1][j - 1])` requires you to memorise if `M[i+1][j-1]` is true, that's easy to understand. However, if you expand each possible axis at the same time, i.e. 1st iteration (s[i+1], s[j-1]), 2nd iteration `s[i+2], s[j-2]`, ... It is guaranteed that M[i+1][j-1] is always true and hence can be dropped, and you should break the loop when it is not true.\n\nIn summary, you don't need to memorise anything at all and you just need to check `s[i] == s[j]` while expanding in both directions at the same time, unless I have misunderstood anything? Here is an implementation of your algorithm but without storage: https://leetcode.com/problems/longest-palindromic-substring/submissions/868540120/"
                    },
                    {
                        "username": "taras",
                        "content": "Thank you! this is a beautiful explanation, though I\\'m not sure what exactly you mean by expanding both on LHS and RHS. In my implementation it\\'s enough to compute all diagonals of  the upper right triangle of the dp matrix."
                    },
                    {
                        "username": "klu_2100031593",
                        "content": "super explanation"
                    },
                    {
                        "username": "napoleon",
                        "content": "My Solution Is Naive, It Cost O(n^2), Is there Any Solution faster?"
                    },
                    {
                        "username": "leocampos",
                        "content": "[@tylerprill-rhdc](/tylerprill-rhdc) So, what I did was:\nStated in my mind the Brute Force approach - create every possible substring and test each one to see if is a palindrome and find the longest.\n\nOf course this would be ridiculously slow, so let's improve it.\nI also mentally stated that a palindrome has a recursive aspect -> if single char, or two equal chars, or charX + palindrome + charX\nSo I created a isPalindrome recursive method that checked it delegating to itself extracting the borders.\n\nSince a palindrome must start and end with the same char, in my traverse of the string, I started storing the position of each character Map<Character, List< Integer>>, so I would just go back to the previous found Char and check if from there to the current pointer I would have a Palindrome.\n\nThen I stopped doing this for every possible palindrome, I then started doing only for the ones that COULD be longer than the already found longest palindrome. That accelerated a lot.\n\nIn the almost last step, I added memoization. Remember that a palindrome is like a sandwich, with the external chars being equal and the meat being another palindrome? So I stored the found palindromes using their start and and positions. So I could check if that had already being checked and if so, either return true or false directly.\n\nThe final step was to convert the recursive function to an iterative function to save some memory used by the call stack.\nMaybe there are better implementations, just sharing my thought process."
                    },
                    {
                        "username": "tylerprill-rhdc",
                        "content": "[@tylerprill-rhdc](/tylerprill-rhdc) Two pointer based solution is also a really good solve here"
                    },
                    {
                        "username": "tylerprill-rhdc",
                        "content": "This could be done in a single pass algorithm, but will inherently check character indices multiple times based on the nature of the problem. (basically, iterate through each, then bubble out from each index)"
                    },
                    {
                        "username": "neetika",
                        "content": "From the leetcode blog, one of the methods of solving this is:\\n\\nA common mistake:\\nSome people will be tempted to come up with a quick solution, which is unfortunately flawed (however can be corrected easily):\\n\\nReverse S and become S\\u2019. Find the longest common substring between S and S\\u2019, which must also be the longest palindromic substring.\\nThis seemed to work, let\\u2019s see some examples below.\\n\\nFor example,\\nS = \\u201ccaba\\u201d, S\\u2019 = \\u201cabac\\u201d.\\nThe longest common substring between S and S\\u2019 is \\u201caba\\u201d, which is the answer.\\n\\nLet\\u2019s try another example:\\nS = \\u201cabacdfgdcaba\\u201d, S\\u2019 = \\u201cabacdgfdcaba\\u201d.\\nThe longest common substring between S and S\\u2019 is \\u201cabacd\\u201d. Clearly, this is not a valid palindrome.\\n\\n**We could see that the longest common substring method fails when there exists a reversed copy of a non-palindromic substring in some other part of S. To rectify this, each time we find a longest common substring candidate, we check if the substring\\u2019s indices are the same as the reversed substring\\u2019s original indices. If it is, then we attempt to update the longest palindrome found so far; if not, we skip this and find the next candidate.**\\n\\nIs this part correct? \\n\\nexample string: abcxycba\\nreverse string:  abcxycba\\n\\nThe substring indices are same as reversed string original indices and yet it is not a palindrome?"
                    },
                    {
                        "username": "HRVY_SNOWDEN",
                        "content": "cool sirr:)\\n"
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "WRONG.\\n\\nabcxycba reversed is abcyxcba."
                    },
                    {
                        "username": "travisl12",
                        "content": "After I solved this problem I thought it\\'d be interesting to see how it worked in realtime.\\n\\nhttps://codepen.io/TravisL12/pen/pogvweg"
                    },
                    {
                        "username": "user3907vj",
                        "content": "thanks for the \"nanananananana\" from all the small things ;)"
                    },
                    {
                        "username": "zapataast",
                        "content": "u are crazy"
                    },
                    {
                        "username": "sondq98",
                        "content": "very intuitive"
                    },
                    {
                        "username": "Tathagat017",
                        "content": "thank you\\n"
                    },
                    {
                        "username": "mikler",
                        "content": "So I think I finally understood logic of test creators. \\nEven if you write a classical DP or memorization solution for this one you will timeout on latest tests.\\nI think they consider it edge cases. Because if you add one simple line it will pass! OMG. \\nI have leet code for this. Instead of solving problems I spend hours optimizing the constants.\\n\\nif s == s[::-1]: return s"
                    },
                    {
                        "username": "Vectorido",
                        "content": "Don\\'t work already. Time limit at 141 test even with that construction."
                    },
                    {
                        "username": "deepalithakur17",
                        "content": "It will only work in python."
                    },
                    {
                        "username": "ishogbon",
                        "content": "Its memoization, not memorization "
                    },
                    {
                        "username": "84danie",
                        "content": "I submitted my solution, and received a Time Limit Exceeded on this test case:\\n\\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabcaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n\\nSo I copied and pasted the TC into a custom test case, and started to think about what I could tweak. However, I ended up accidentally hitting Run Code, but instead of getting a Time Limit Exceeded result, it passed:\\n\\n![0_1479079812693_upload-4af9e94c-2e53-4915-acf6-782780c7bf8b](/uploads/files/1479079813717-upload-4af9e94c-2e53-4915-acf6-782780c7bf8b.png) \\n\\nIs this supposed to happen and I just need to make my code more efficient, or is this a bug? \\n![0_1479079956817_upload-1ef15826-d6e6-4bde-9c06-eb597c5c8d0e](/uploads/files/1479079957639-upload-1ef15826-d6e6-4bde-9c06-eb597c5c8d0e.png)"
                    },
                    {
                        "username": "RitikaSahay",
                        "content": "Same thing happened with me. Is there a solution for it?\\n"
                    },
                    {
                        "username": "danicruz0415",
                        "content": "It\\'s happened to me a couple of times. My theory is that the time limit is given for the whole list of test cases. Thus, you can have your test pass, but it will still time limit exceed because it wont get to calculate all the test cases before the time runs out. I cannot confirm this but I think its true because with a very unoptimized solution I got time limit exceeded very early in the test cases (for another problem), after some optimizations I got it much later (like getting to the last tests) which themselves were around the same size, so if the time limit was set per test it would not make sense to fail in a similarly long test-case just that is much later in the test list. (I think the same would apply to memory limit exceeded)"
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "The exact same situation happened with me in one problem... it was a DP problem too... I was getting a Memory Limit Exceeded error with the memoized solution but it was running fine in the Run Code button."
                    },
                    {
                        "username": "Hubro",
                        "content": "I\\'m getting \"Time Limit Exceeded\" with 141/141 testcases passed and \"Last Executed Input\" is:\\n\\n```\\ns =\\n```\\n\\nDid I break it?"
                    },
                    {
                        "username": "karan_dhiman",
                        "content": "same issue"
                    },
                    {
                        "username": "BLANK-Zora",
                        "content": "exactly bro this shit is recked , like it is giving tests outside the constraints , how am i suppose to include such things in the code"
                    },
                    {
                        "username": "arunprep5",
                        "content": "same issue. java"
                    },
                    {
                        "username": "blasphelmy",
                        "content": "[@tuancoltech](/tuancoltech) it worked when i rewrote the code in c# instead of c++"
                    },
                    {
                        "username": "tuancoltech",
                        "content": "[@blasphelmy](/blasphelmy) [@Tomas Sandven](/Hubro) Did you guys find out why? I got the same issue."
                    },
                    {
                        "username": "blasphelmy",
                        "content": "i got that too. im not sure whats going on given that the constraint for input is between 1 and 1000"
                    },
                    {
                        "username": "Vinitajain",
                        "content": "Hi All,\\nI have a test case which is failing, but I feel the testcase result is incorrect.Please refer the screenshot below.\\n![image](https://assets.leetcode.com/users/images/e9e42efb-63d5-4cfa-b420-f1926674f6dc_1654838015.8394327.png)\\n\\nThe longest palindromic substring is \"aaca\" but the test case result is \"aca\". Anyone else faced this problem?"
                    },
                    {
                        "username": "OthSO",
                        "content": "[@mohdansah10](/mohdansah10) \\nthey are separated in the input with \"bd\" so it is not a valid answer "
                    },
                    {
                        "username": "mohdansah10",
                        "content": "I\\'m getting same error, but different case:\\nInput\\ns =\\n\"aacabdkacaa\"\\n\\nOutput\\n\"aacakacaa\"\\nExpected\\n\"aca\"\\n\\nBut mine is Palindrome"
                    },
                    {
                        "username": "hasmithraa",
                        "content": "the expected is correct because aaca can\\'t be a palindrome only \\'aacaa\\' can be a palindrome which is not there in your case"
                    },
                    {
                        "username": "Amish_Singh",
                        "content": "how are you considering \"aaca\" as a palindromic substring, \"aca\" is a palindrome and it is the longest"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "dude you really came up with the solution "
                    },
                    {
                        "username": "AryaAditya3609",
                        "content": "how is \"aaca\" and \"acaa\" same ???\\nWhile \"aca\" is palindrome because both \"aca\" and reverse of it \"aca\" is same !!"
                    },
                    {
                        "username": "alexandra-pickle",
                        "content": "\"aaca\" is not a palindrome"
                    },
                    {
                        "username": "bugHackerLoop",
                        "content": "I followed the approach leant by Aditya Verma DP lectures and encountered the same test case failing. Does the logic where I reverse the string and calculate the longest common substring doesn\\'t work here? I know it works for longest palindromic subsequence but here it fails for such test cases .. why is it so?"
                    },
                    {
                        "username": "mductran",
                        "content": "how is \\'aaca\\' a palindrome? when read backward it\\'s \\'acaa\\' so it\\'s not the same reading forward."
                    },
                    {
                        "username": "jnsudhir",
                        "content": "Check my solution, it was able to clear test case \"aaca\". Explained code in comments.\\n\\nhttps://leetcode.com/problems/longest-palindromic-substring/solutions/3091016/longest-palindromic-substring-using-javascript-beats-94-82-in-runtime-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "nikhileshratna",
                        "content": "aaca is not palindrome"
                    },
                    {
                        "username": "sunshine77",
                        "content": "hey, iam getting the same error, i have seen ansewrs where they have totally changed the algorithm, how did u solve this by tweaking the same algoirhtm"
                    },
                    {
                        "username": "bhupendrabc71",
                        "content": "how come \"aaca\" is palindrome. it should be \"aca\""
                    },
                    {
                        "username": "just11blocks",
                        "content": "aaca is not a palindrome...aacaa and aca are."
                    },
                    {
                        "username": "odi1n",
                        "content": "I also encountered this problem"
                    },
                    {
                        "username": "vamsi2302",
                        "content": "I think you get it by now!\\n"
                    }
                ]
            },
            {
                "id": 1576875,
                "content": [
                    {
                        "username": "ZenMasterV",
                        "content": "Seems like too many of the  coding wunderkinds here lack basic reading comprehension skills \\n\" Please don\\'t post any solutions in this discussion tab\"\\nIt\\'s almost the rule to find the exact opposite for the discussion of every question. I don\\'t want to see your damned solution!"
                    },
                    {
                        "username": "NeroXIII",
                        "content": "[@charonme](/charonme) name does not check out :((("
                    },
                    {
                        "username": "192731",
                        "content": "and if they do?"
                    },
                    {
                        "username": "plevi1995",
                        "content": "Excellent comment"
                    },
                    {
                        "username": "khan60939",
                        "content": "Can anyone tell how DP is being used here? "
                    },
                    {
                        "username": "sandagolcea",
                        "content": "[@charonme](/charonme) my thinking exactly, but at least they should create a flag to help us moderate and move solutions to the correct tab. Would only need a stack overflow moderation-like system: one person flags, another person receives a queue of flagged comments and confirms the tagging.. oh well"
                    },
                    {
                        "username": "charonme",
                        "content": "maybe people get confused by the official leetcode comment which says: \"If you\\'d like to share a detailed solution to the problem, please create a new post in the discuss section\"\\nMaybe some time ago they didn\\'t have a separate solutions section and only recently changed it, but left some of the old solutions in the discussion section and didn\\'t fix the automated comment worting?"
                    },
                    {
                        "username": "klanjewar037",
                        "content": "hehe"
                    },
                    {
                        "username": "sanemdeepak",
                        "content": "For input \"ac\" test case is expecting \"a\" as output, how is just \"a\" a palindromic string?"
                    },
                    {
                        "username": "ayushiidevpura",
                        "content": "because when we read \"a\" from forward it results in \"a\" and at the same time when we read \"a\" from backward it is still \"a\""
                    },
                    {
                        "username": "beyzigo",
                        "content": "Because if you read the string \"a\" backwards it will still be \"a\""
                    },
                    {
                        "username": "tsafackghokeng",
                        "content": "[@Chouhan_Gourav](/Chouhan_Gourav) the test case said \"ac\" not \"a\". is \"ac\" palindromic? for \"a\" i understand"
                    },
                    {
                        "username": "CODEWITHABHINAV",
                        "content": "you have to submit the first string as your answer read more about this question on gFg\\n"
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "any string is palindrome if we read it same from front and from back\\nin single character we read it same from front and back"
                    },
                    {
                        "username": "oinrup",
                        "content": "yes thats my question too"
                    },
                    {
                        "username": "yldemon",
                        "content": "Any character in the string by itself is a palindromic substring. So in the case where there is no palindromic substring with length > 1, you can return any character."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "Whenever you come accross such contradiction, just google the definition, any. Any string is called is pallindromic if the reverse of the string is equal to the original string. Reverse of \\'a\\' is \\'a\\'. Hope you get this."
                    },
                    {
                        "username": "947876275",
                        "content": "This post is for learner wanna practice DP.\\nThe basic idea is, if we wanna say \"aba\" is palindromic, then we need to firstly confirm that \"b\" is palindromic, then we also need to check if \"a\"(the first a) = \"a\" (the second a).\\n\\nM is a 2-d array which stores boolean values.\\nM[i][j] indicates if string[i.....j] is palindromic.\\nSo base cases are:\\nM[i][i] is true.\\nM[i][i + 1] = (s[i] == s[i + 1]);\\nrecurrence relation is :\\nM[i][j] = (s[i] == s[j] AND M[i + 1][j - 1]);\\nFor the implementation of recurrence relation, one idea is you can loop through all possible symmetry axis. For each of the axis, you expand at both RHS and LHS simultaneously. This method promises that when you are determining value in M[i][j], M[i + 1][j - 1] must have the correct value.\\nFinal answer can be found from all M[i][j] == 1 with largest (j - i)."
                    },
                    {
                        "username": "Msey",
                        "content": "thank you, cat brother"
                    },
                    {
                        "username": "user0558y",
                        "content": "I understand the solution but I don't understand why it needs any storage at all or why it needs to be a DP solution.\n\nThe condition `(s[i] == s[j] AND M[i + 1][j - 1])` requires you to memorise if `M[i+1][j-1]` is true, that's easy to understand. However, if you expand each possible axis at the same time, i.e. 1st iteration (s[i+1], s[j-1]), 2nd iteration `s[i+2], s[j-2]`, ... It is guaranteed that M[i+1][j-1] is always true and hence can be dropped, and you should break the loop when it is not true.\n\nIn summary, you don't need to memorise anything at all and you just need to check `s[i] == s[j]` while expanding in both directions at the same time, unless I have misunderstood anything? Here is an implementation of your algorithm but without storage: https://leetcode.com/problems/longest-palindromic-substring/submissions/868540120/"
                    },
                    {
                        "username": "taras",
                        "content": "Thank you! this is a beautiful explanation, though I\\'m not sure what exactly you mean by expanding both on LHS and RHS. In my implementation it\\'s enough to compute all diagonals of  the upper right triangle of the dp matrix."
                    },
                    {
                        "username": "klu_2100031593",
                        "content": "super explanation"
                    },
                    {
                        "username": "napoleon",
                        "content": "My Solution Is Naive, It Cost O(n^2), Is there Any Solution faster?"
                    },
                    {
                        "username": "leocampos",
                        "content": "[@tylerprill-rhdc](/tylerprill-rhdc) So, what I did was:\nStated in my mind the Brute Force approach - create every possible substring and test each one to see if is a palindrome and find the longest.\n\nOf course this would be ridiculously slow, so let's improve it.\nI also mentally stated that a palindrome has a recursive aspect -> if single char, or two equal chars, or charX + palindrome + charX\nSo I created a isPalindrome recursive method that checked it delegating to itself extracting the borders.\n\nSince a palindrome must start and end with the same char, in my traverse of the string, I started storing the position of each character Map<Character, List< Integer>>, so I would just go back to the previous found Char and check if from there to the current pointer I would have a Palindrome.\n\nThen I stopped doing this for every possible palindrome, I then started doing only for the ones that COULD be longer than the already found longest palindrome. That accelerated a lot.\n\nIn the almost last step, I added memoization. Remember that a palindrome is like a sandwich, with the external chars being equal and the meat being another palindrome? So I stored the found palindromes using their start and and positions. So I could check if that had already being checked and if so, either return true or false directly.\n\nThe final step was to convert the recursive function to an iterative function to save some memory used by the call stack.\nMaybe there are better implementations, just sharing my thought process."
                    },
                    {
                        "username": "tylerprill-rhdc",
                        "content": "[@tylerprill-rhdc](/tylerprill-rhdc) Two pointer based solution is also a really good solve here"
                    },
                    {
                        "username": "tylerprill-rhdc",
                        "content": "This could be done in a single pass algorithm, but will inherently check character indices multiple times based on the nature of the problem. (basically, iterate through each, then bubble out from each index)"
                    },
                    {
                        "username": "neetika",
                        "content": "From the leetcode blog, one of the methods of solving this is:\\n\\nA common mistake:\\nSome people will be tempted to come up with a quick solution, which is unfortunately flawed (however can be corrected easily):\\n\\nReverse S and become S\\u2019. Find the longest common substring between S and S\\u2019, which must also be the longest palindromic substring.\\nThis seemed to work, let\\u2019s see some examples below.\\n\\nFor example,\\nS = \\u201ccaba\\u201d, S\\u2019 = \\u201cabac\\u201d.\\nThe longest common substring between S and S\\u2019 is \\u201caba\\u201d, which is the answer.\\n\\nLet\\u2019s try another example:\\nS = \\u201cabacdfgdcaba\\u201d, S\\u2019 = \\u201cabacdgfdcaba\\u201d.\\nThe longest common substring between S and S\\u2019 is \\u201cabacd\\u201d. Clearly, this is not a valid palindrome.\\n\\n**We could see that the longest common substring method fails when there exists a reversed copy of a non-palindromic substring in some other part of S. To rectify this, each time we find a longest common substring candidate, we check if the substring\\u2019s indices are the same as the reversed substring\\u2019s original indices. If it is, then we attempt to update the longest palindrome found so far; if not, we skip this and find the next candidate.**\\n\\nIs this part correct? \\n\\nexample string: abcxycba\\nreverse string:  abcxycba\\n\\nThe substring indices are same as reversed string original indices and yet it is not a palindrome?"
                    },
                    {
                        "username": "HRVY_SNOWDEN",
                        "content": "cool sirr:)\\n"
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "WRONG.\\n\\nabcxycba reversed is abcyxcba."
                    },
                    {
                        "username": "travisl12",
                        "content": "After I solved this problem I thought it\\'d be interesting to see how it worked in realtime.\\n\\nhttps://codepen.io/TravisL12/pen/pogvweg"
                    },
                    {
                        "username": "user3907vj",
                        "content": "thanks for the \"nanananananana\" from all the small things ;)"
                    },
                    {
                        "username": "zapataast",
                        "content": "u are crazy"
                    },
                    {
                        "username": "sondq98",
                        "content": "very intuitive"
                    },
                    {
                        "username": "Tathagat017",
                        "content": "thank you\\n"
                    },
                    {
                        "username": "mikler",
                        "content": "So I think I finally understood logic of test creators. \\nEven if you write a classical DP or memorization solution for this one you will timeout on latest tests.\\nI think they consider it edge cases. Because if you add one simple line it will pass! OMG. \\nI have leet code for this. Instead of solving problems I spend hours optimizing the constants.\\n\\nif s == s[::-1]: return s"
                    },
                    {
                        "username": "Vectorido",
                        "content": "Don\\'t work already. Time limit at 141 test even with that construction."
                    },
                    {
                        "username": "deepalithakur17",
                        "content": "It will only work in python."
                    },
                    {
                        "username": "ishogbon",
                        "content": "Its memoization, not memorization "
                    },
                    {
                        "username": "84danie",
                        "content": "I submitted my solution, and received a Time Limit Exceeded on this test case:\\n\\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabcaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n\\nSo I copied and pasted the TC into a custom test case, and started to think about what I could tweak. However, I ended up accidentally hitting Run Code, but instead of getting a Time Limit Exceeded result, it passed:\\n\\n![0_1479079812693_upload-4af9e94c-2e53-4915-acf6-782780c7bf8b](/uploads/files/1479079813717-upload-4af9e94c-2e53-4915-acf6-782780c7bf8b.png) \\n\\nIs this supposed to happen and I just need to make my code more efficient, or is this a bug? \\n![0_1479079956817_upload-1ef15826-d6e6-4bde-9c06-eb597c5c8d0e](/uploads/files/1479079957639-upload-1ef15826-d6e6-4bde-9c06-eb597c5c8d0e.png)"
                    },
                    {
                        "username": "RitikaSahay",
                        "content": "Same thing happened with me. Is there a solution for it?\\n"
                    },
                    {
                        "username": "danicruz0415",
                        "content": "It\\'s happened to me a couple of times. My theory is that the time limit is given for the whole list of test cases. Thus, you can have your test pass, but it will still time limit exceed because it wont get to calculate all the test cases before the time runs out. I cannot confirm this but I think its true because with a very unoptimized solution I got time limit exceeded very early in the test cases (for another problem), after some optimizations I got it much later (like getting to the last tests) which themselves were around the same size, so if the time limit was set per test it would not make sense to fail in a similarly long test-case just that is much later in the test list. (I think the same would apply to memory limit exceeded)"
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "The exact same situation happened with me in one problem... it was a DP problem too... I was getting a Memory Limit Exceeded error with the memoized solution but it was running fine in the Run Code button."
                    },
                    {
                        "username": "Hubro",
                        "content": "I\\'m getting \"Time Limit Exceeded\" with 141/141 testcases passed and \"Last Executed Input\" is:\\n\\n```\\ns =\\n```\\n\\nDid I break it?"
                    },
                    {
                        "username": "karan_dhiman",
                        "content": "same issue"
                    },
                    {
                        "username": "BLANK-Zora",
                        "content": "exactly bro this shit is recked , like it is giving tests outside the constraints , how am i suppose to include such things in the code"
                    },
                    {
                        "username": "arunprep5",
                        "content": "same issue. java"
                    },
                    {
                        "username": "blasphelmy",
                        "content": "[@tuancoltech](/tuancoltech) it worked when i rewrote the code in c# instead of c++"
                    },
                    {
                        "username": "tuancoltech",
                        "content": "[@blasphelmy](/blasphelmy) [@Tomas Sandven](/Hubro) Did you guys find out why? I got the same issue."
                    },
                    {
                        "username": "blasphelmy",
                        "content": "i got that too. im not sure whats going on given that the constraint for input is between 1 and 1000"
                    },
                    {
                        "username": "Vinitajain",
                        "content": "Hi All,\\nI have a test case which is failing, but I feel the testcase result is incorrect.Please refer the screenshot below.\\n![image](https://assets.leetcode.com/users/images/e9e42efb-63d5-4cfa-b420-f1926674f6dc_1654838015.8394327.png)\\n\\nThe longest palindromic substring is \"aaca\" but the test case result is \"aca\". Anyone else faced this problem?"
                    },
                    {
                        "username": "OthSO",
                        "content": "[@mohdansah10](/mohdansah10) \\nthey are separated in the input with \"bd\" so it is not a valid answer "
                    },
                    {
                        "username": "mohdansah10",
                        "content": "I\\'m getting same error, but different case:\\nInput\\ns =\\n\"aacabdkacaa\"\\n\\nOutput\\n\"aacakacaa\"\\nExpected\\n\"aca\"\\n\\nBut mine is Palindrome"
                    },
                    {
                        "username": "hasmithraa",
                        "content": "the expected is correct because aaca can\\'t be a palindrome only \\'aacaa\\' can be a palindrome which is not there in your case"
                    },
                    {
                        "username": "Amish_Singh",
                        "content": "how are you considering \"aaca\" as a palindromic substring, \"aca\" is a palindrome and it is the longest"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "dude you really came up with the solution "
                    },
                    {
                        "username": "AryaAditya3609",
                        "content": "how is \"aaca\" and \"acaa\" same ???\\nWhile \"aca\" is palindrome because both \"aca\" and reverse of it \"aca\" is same !!"
                    },
                    {
                        "username": "alexandra-pickle",
                        "content": "\"aaca\" is not a palindrome"
                    },
                    {
                        "username": "bugHackerLoop",
                        "content": "I followed the approach leant by Aditya Verma DP lectures and encountered the same test case failing. Does the logic where I reverse the string and calculate the longest common substring doesn\\'t work here? I know it works for longest palindromic subsequence but here it fails for such test cases .. why is it so?"
                    },
                    {
                        "username": "mductran",
                        "content": "how is \\'aaca\\' a palindrome? when read backward it\\'s \\'acaa\\' so it\\'s not the same reading forward."
                    },
                    {
                        "username": "jnsudhir",
                        "content": "Check my solution, it was able to clear test case \"aaca\". Explained code in comments.\\n\\nhttps://leetcode.com/problems/longest-palindromic-substring/solutions/3091016/longest-palindromic-substring-using-javascript-beats-94-82-in-runtime-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "nikhileshratna",
                        "content": "aaca is not palindrome"
                    },
                    {
                        "username": "sunshine77",
                        "content": "hey, iam getting the same error, i have seen ansewrs where they have totally changed the algorithm, how did u solve this by tweaking the same algoirhtm"
                    },
                    {
                        "username": "bhupendrabc71",
                        "content": "how come \"aaca\" is palindrome. it should be \"aca\""
                    },
                    {
                        "username": "just11blocks",
                        "content": "aaca is not a palindrome...aacaa and aca are."
                    },
                    {
                        "username": "odi1n",
                        "content": "I also encountered this problem"
                    },
                    {
                        "username": "vamsi2302",
                        "content": "I think you get it by now!\\n"
                    }
                ]
            },
            {
                "id": 1671198,
                "content": [
                    {
                        "username": "ZenMasterV",
                        "content": "Seems like too many of the  coding wunderkinds here lack basic reading comprehension skills \\n\" Please don\\'t post any solutions in this discussion tab\"\\nIt\\'s almost the rule to find the exact opposite for the discussion of every question. I don\\'t want to see your damned solution!"
                    },
                    {
                        "username": "NeroXIII",
                        "content": "[@charonme](/charonme) name does not check out :((("
                    },
                    {
                        "username": "192731",
                        "content": "and if they do?"
                    },
                    {
                        "username": "plevi1995",
                        "content": "Excellent comment"
                    },
                    {
                        "username": "khan60939",
                        "content": "Can anyone tell how DP is being used here? "
                    },
                    {
                        "username": "sandagolcea",
                        "content": "[@charonme](/charonme) my thinking exactly, but at least they should create a flag to help us moderate and move solutions to the correct tab. Would only need a stack overflow moderation-like system: one person flags, another person receives a queue of flagged comments and confirms the tagging.. oh well"
                    },
                    {
                        "username": "charonme",
                        "content": "maybe people get confused by the official leetcode comment which says: \"If you\\'d like to share a detailed solution to the problem, please create a new post in the discuss section\"\\nMaybe some time ago they didn\\'t have a separate solutions section and only recently changed it, but left some of the old solutions in the discussion section and didn\\'t fix the automated comment worting?"
                    },
                    {
                        "username": "klanjewar037",
                        "content": "hehe"
                    },
                    {
                        "username": "sanemdeepak",
                        "content": "For input \"ac\" test case is expecting \"a\" as output, how is just \"a\" a palindromic string?"
                    },
                    {
                        "username": "ayushiidevpura",
                        "content": "because when we read \"a\" from forward it results in \"a\" and at the same time when we read \"a\" from backward it is still \"a\""
                    },
                    {
                        "username": "beyzigo",
                        "content": "Because if you read the string \"a\" backwards it will still be \"a\""
                    },
                    {
                        "username": "tsafackghokeng",
                        "content": "[@Chouhan_Gourav](/Chouhan_Gourav) the test case said \"ac\" not \"a\". is \"ac\" palindromic? for \"a\" i understand"
                    },
                    {
                        "username": "CODEWITHABHINAV",
                        "content": "you have to submit the first string as your answer read more about this question on gFg\\n"
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "any string is palindrome if we read it same from front and from back\\nin single character we read it same from front and back"
                    },
                    {
                        "username": "oinrup",
                        "content": "yes thats my question too"
                    },
                    {
                        "username": "yldemon",
                        "content": "Any character in the string by itself is a palindromic substring. So in the case where there is no palindromic substring with length > 1, you can return any character."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "Whenever you come accross such contradiction, just google the definition, any. Any string is called is pallindromic if the reverse of the string is equal to the original string. Reverse of \\'a\\' is \\'a\\'. Hope you get this."
                    },
                    {
                        "username": "947876275",
                        "content": "This post is for learner wanna practice DP.\\nThe basic idea is, if we wanna say \"aba\" is palindromic, then we need to firstly confirm that \"b\" is palindromic, then we also need to check if \"a\"(the first a) = \"a\" (the second a).\\n\\nM is a 2-d array which stores boolean values.\\nM[i][j] indicates if string[i.....j] is palindromic.\\nSo base cases are:\\nM[i][i] is true.\\nM[i][i + 1] = (s[i] == s[i + 1]);\\nrecurrence relation is :\\nM[i][j] = (s[i] == s[j] AND M[i + 1][j - 1]);\\nFor the implementation of recurrence relation, one idea is you can loop through all possible symmetry axis. For each of the axis, you expand at both RHS and LHS simultaneously. This method promises that when you are determining value in M[i][j], M[i + 1][j - 1] must have the correct value.\\nFinal answer can be found from all M[i][j] == 1 with largest (j - i)."
                    },
                    {
                        "username": "Msey",
                        "content": "thank you, cat brother"
                    },
                    {
                        "username": "user0558y",
                        "content": "I understand the solution but I don't understand why it needs any storage at all or why it needs to be a DP solution.\n\nThe condition `(s[i] == s[j] AND M[i + 1][j - 1])` requires you to memorise if `M[i+1][j-1]` is true, that's easy to understand. However, if you expand each possible axis at the same time, i.e. 1st iteration (s[i+1], s[j-1]), 2nd iteration `s[i+2], s[j-2]`, ... It is guaranteed that M[i+1][j-1] is always true and hence can be dropped, and you should break the loop when it is not true.\n\nIn summary, you don't need to memorise anything at all and you just need to check `s[i] == s[j]` while expanding in both directions at the same time, unless I have misunderstood anything? Here is an implementation of your algorithm but without storage: https://leetcode.com/problems/longest-palindromic-substring/submissions/868540120/"
                    },
                    {
                        "username": "taras",
                        "content": "Thank you! this is a beautiful explanation, though I\\'m not sure what exactly you mean by expanding both on LHS and RHS. In my implementation it\\'s enough to compute all diagonals of  the upper right triangle of the dp matrix."
                    },
                    {
                        "username": "klu_2100031593",
                        "content": "super explanation"
                    },
                    {
                        "username": "napoleon",
                        "content": "My Solution Is Naive, It Cost O(n^2), Is there Any Solution faster?"
                    },
                    {
                        "username": "leocampos",
                        "content": "[@tylerprill-rhdc](/tylerprill-rhdc) So, what I did was:\nStated in my mind the Brute Force approach - create every possible substring and test each one to see if is a palindrome and find the longest.\n\nOf course this would be ridiculously slow, so let's improve it.\nI also mentally stated that a palindrome has a recursive aspect -> if single char, or two equal chars, or charX + palindrome + charX\nSo I created a isPalindrome recursive method that checked it delegating to itself extracting the borders.\n\nSince a palindrome must start and end with the same char, in my traverse of the string, I started storing the position of each character Map<Character, List< Integer>>, so I would just go back to the previous found Char and check if from there to the current pointer I would have a Palindrome.\n\nThen I stopped doing this for every possible palindrome, I then started doing only for the ones that COULD be longer than the already found longest palindrome. That accelerated a lot.\n\nIn the almost last step, I added memoization. Remember that a palindrome is like a sandwich, with the external chars being equal and the meat being another palindrome? So I stored the found palindromes using their start and and positions. So I could check if that had already being checked and if so, either return true or false directly.\n\nThe final step was to convert the recursive function to an iterative function to save some memory used by the call stack.\nMaybe there are better implementations, just sharing my thought process."
                    },
                    {
                        "username": "tylerprill-rhdc",
                        "content": "[@tylerprill-rhdc](/tylerprill-rhdc) Two pointer based solution is also a really good solve here"
                    },
                    {
                        "username": "tylerprill-rhdc",
                        "content": "This could be done in a single pass algorithm, but will inherently check character indices multiple times based on the nature of the problem. (basically, iterate through each, then bubble out from each index)"
                    },
                    {
                        "username": "neetika",
                        "content": "From the leetcode blog, one of the methods of solving this is:\\n\\nA common mistake:\\nSome people will be tempted to come up with a quick solution, which is unfortunately flawed (however can be corrected easily):\\n\\nReverse S and become S\\u2019. Find the longest common substring between S and S\\u2019, which must also be the longest palindromic substring.\\nThis seemed to work, let\\u2019s see some examples below.\\n\\nFor example,\\nS = \\u201ccaba\\u201d, S\\u2019 = \\u201cabac\\u201d.\\nThe longest common substring between S and S\\u2019 is \\u201caba\\u201d, which is the answer.\\n\\nLet\\u2019s try another example:\\nS = \\u201cabacdfgdcaba\\u201d, S\\u2019 = \\u201cabacdgfdcaba\\u201d.\\nThe longest common substring between S and S\\u2019 is \\u201cabacd\\u201d. Clearly, this is not a valid palindrome.\\n\\n**We could see that the longest common substring method fails when there exists a reversed copy of a non-palindromic substring in some other part of S. To rectify this, each time we find a longest common substring candidate, we check if the substring\\u2019s indices are the same as the reversed substring\\u2019s original indices. If it is, then we attempt to update the longest palindrome found so far; if not, we skip this and find the next candidate.**\\n\\nIs this part correct? \\n\\nexample string: abcxycba\\nreverse string:  abcxycba\\n\\nThe substring indices are same as reversed string original indices and yet it is not a palindrome?"
                    },
                    {
                        "username": "HRVY_SNOWDEN",
                        "content": "cool sirr:)\\n"
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "WRONG.\\n\\nabcxycba reversed is abcyxcba."
                    },
                    {
                        "username": "travisl12",
                        "content": "After I solved this problem I thought it\\'d be interesting to see how it worked in realtime.\\n\\nhttps://codepen.io/TravisL12/pen/pogvweg"
                    },
                    {
                        "username": "user3907vj",
                        "content": "thanks for the \"nanananananana\" from all the small things ;)"
                    },
                    {
                        "username": "zapataast",
                        "content": "u are crazy"
                    },
                    {
                        "username": "sondq98",
                        "content": "very intuitive"
                    },
                    {
                        "username": "Tathagat017",
                        "content": "thank you\\n"
                    },
                    {
                        "username": "mikler",
                        "content": "So I think I finally understood logic of test creators. \\nEven if you write a classical DP or memorization solution for this one you will timeout on latest tests.\\nI think they consider it edge cases. Because if you add one simple line it will pass! OMG. \\nI have leet code for this. Instead of solving problems I spend hours optimizing the constants.\\n\\nif s == s[::-1]: return s"
                    },
                    {
                        "username": "Vectorido",
                        "content": "Don\\'t work already. Time limit at 141 test even with that construction."
                    },
                    {
                        "username": "deepalithakur17",
                        "content": "It will only work in python."
                    },
                    {
                        "username": "ishogbon",
                        "content": "Its memoization, not memorization "
                    },
                    {
                        "username": "84danie",
                        "content": "I submitted my solution, and received a Time Limit Exceeded on this test case:\\n\\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabcaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n\\nSo I copied and pasted the TC into a custom test case, and started to think about what I could tweak. However, I ended up accidentally hitting Run Code, but instead of getting a Time Limit Exceeded result, it passed:\\n\\n![0_1479079812693_upload-4af9e94c-2e53-4915-acf6-782780c7bf8b](/uploads/files/1479079813717-upload-4af9e94c-2e53-4915-acf6-782780c7bf8b.png) \\n\\nIs this supposed to happen and I just need to make my code more efficient, or is this a bug? \\n![0_1479079956817_upload-1ef15826-d6e6-4bde-9c06-eb597c5c8d0e](/uploads/files/1479079957639-upload-1ef15826-d6e6-4bde-9c06-eb597c5c8d0e.png)"
                    },
                    {
                        "username": "RitikaSahay",
                        "content": "Same thing happened with me. Is there a solution for it?\\n"
                    },
                    {
                        "username": "danicruz0415",
                        "content": "It\\'s happened to me a couple of times. My theory is that the time limit is given for the whole list of test cases. Thus, you can have your test pass, but it will still time limit exceed because it wont get to calculate all the test cases before the time runs out. I cannot confirm this but I think its true because with a very unoptimized solution I got time limit exceeded very early in the test cases (for another problem), after some optimizations I got it much later (like getting to the last tests) which themselves were around the same size, so if the time limit was set per test it would not make sense to fail in a similarly long test-case just that is much later in the test list. (I think the same would apply to memory limit exceeded)"
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "The exact same situation happened with me in one problem... it was a DP problem too... I was getting a Memory Limit Exceeded error with the memoized solution but it was running fine in the Run Code button."
                    },
                    {
                        "username": "Hubro",
                        "content": "I\\'m getting \"Time Limit Exceeded\" with 141/141 testcases passed and \"Last Executed Input\" is:\\n\\n```\\ns =\\n```\\n\\nDid I break it?"
                    },
                    {
                        "username": "karan_dhiman",
                        "content": "same issue"
                    },
                    {
                        "username": "BLANK-Zora",
                        "content": "exactly bro this shit is recked , like it is giving tests outside the constraints , how am i suppose to include such things in the code"
                    },
                    {
                        "username": "arunprep5",
                        "content": "same issue. java"
                    },
                    {
                        "username": "blasphelmy",
                        "content": "[@tuancoltech](/tuancoltech) it worked when i rewrote the code in c# instead of c++"
                    },
                    {
                        "username": "tuancoltech",
                        "content": "[@blasphelmy](/blasphelmy) [@Tomas Sandven](/Hubro) Did you guys find out why? I got the same issue."
                    },
                    {
                        "username": "blasphelmy",
                        "content": "i got that too. im not sure whats going on given that the constraint for input is between 1 and 1000"
                    },
                    {
                        "username": "Vinitajain",
                        "content": "Hi All,\\nI have a test case which is failing, but I feel the testcase result is incorrect.Please refer the screenshot below.\\n![image](https://assets.leetcode.com/users/images/e9e42efb-63d5-4cfa-b420-f1926674f6dc_1654838015.8394327.png)\\n\\nThe longest palindromic substring is \"aaca\" but the test case result is \"aca\". Anyone else faced this problem?"
                    },
                    {
                        "username": "OthSO",
                        "content": "[@mohdansah10](/mohdansah10) \\nthey are separated in the input with \"bd\" so it is not a valid answer "
                    },
                    {
                        "username": "mohdansah10",
                        "content": "I\\'m getting same error, but different case:\\nInput\\ns =\\n\"aacabdkacaa\"\\n\\nOutput\\n\"aacakacaa\"\\nExpected\\n\"aca\"\\n\\nBut mine is Palindrome"
                    },
                    {
                        "username": "hasmithraa",
                        "content": "the expected is correct because aaca can\\'t be a palindrome only \\'aacaa\\' can be a palindrome which is not there in your case"
                    },
                    {
                        "username": "Amish_Singh",
                        "content": "how are you considering \"aaca\" as a palindromic substring, \"aca\" is a palindrome and it is the longest"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "dude you really came up with the solution "
                    },
                    {
                        "username": "AryaAditya3609",
                        "content": "how is \"aaca\" and \"acaa\" same ???\\nWhile \"aca\" is palindrome because both \"aca\" and reverse of it \"aca\" is same !!"
                    },
                    {
                        "username": "alexandra-pickle",
                        "content": "\"aaca\" is not a palindrome"
                    },
                    {
                        "username": "bugHackerLoop",
                        "content": "I followed the approach leant by Aditya Verma DP lectures and encountered the same test case failing. Does the logic where I reverse the string and calculate the longest common substring doesn\\'t work here? I know it works for longest palindromic subsequence but here it fails for such test cases .. why is it so?"
                    },
                    {
                        "username": "mductran",
                        "content": "how is \\'aaca\\' a palindrome? when read backward it\\'s \\'acaa\\' so it\\'s not the same reading forward."
                    },
                    {
                        "username": "jnsudhir",
                        "content": "Check my solution, it was able to clear test case \"aaca\". Explained code in comments.\\n\\nhttps://leetcode.com/problems/longest-palindromic-substring/solutions/3091016/longest-palindromic-substring-using-javascript-beats-94-82-in-runtime-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "nikhileshratna",
                        "content": "aaca is not palindrome"
                    },
                    {
                        "username": "sunshine77",
                        "content": "hey, iam getting the same error, i have seen ansewrs where they have totally changed the algorithm, how did u solve this by tweaking the same algoirhtm"
                    },
                    {
                        "username": "bhupendrabc71",
                        "content": "how come \"aaca\" is palindrome. it should be \"aca\""
                    },
                    {
                        "username": "just11blocks",
                        "content": "aaca is not a palindrome...aacaa and aca are."
                    },
                    {
                        "username": "odi1n",
                        "content": "I also encountered this problem"
                    },
                    {
                        "username": "vamsi2302",
                        "content": "I think you get it by now!\\n"
                    }
                ]
            },
            {
                "id": 1565544,
                "content": [
                    {
                        "username": "ZenMasterV",
                        "content": "Seems like too many of the  coding wunderkinds here lack basic reading comprehension skills \\n\" Please don\\'t post any solutions in this discussion tab\"\\nIt\\'s almost the rule to find the exact opposite for the discussion of every question. I don\\'t want to see your damned solution!"
                    },
                    {
                        "username": "NeroXIII",
                        "content": "[@charonme](/charonme) name does not check out :((("
                    },
                    {
                        "username": "192731",
                        "content": "and if they do?"
                    },
                    {
                        "username": "plevi1995",
                        "content": "Excellent comment"
                    },
                    {
                        "username": "khan60939",
                        "content": "Can anyone tell how DP is being used here? "
                    },
                    {
                        "username": "sandagolcea",
                        "content": "[@charonme](/charonme) my thinking exactly, but at least they should create a flag to help us moderate and move solutions to the correct tab. Would only need a stack overflow moderation-like system: one person flags, another person receives a queue of flagged comments and confirms the tagging.. oh well"
                    },
                    {
                        "username": "charonme",
                        "content": "maybe people get confused by the official leetcode comment which says: \"If you\\'d like to share a detailed solution to the problem, please create a new post in the discuss section\"\\nMaybe some time ago they didn\\'t have a separate solutions section and only recently changed it, but left some of the old solutions in the discussion section and didn\\'t fix the automated comment worting?"
                    },
                    {
                        "username": "klanjewar037",
                        "content": "hehe"
                    },
                    {
                        "username": "sanemdeepak",
                        "content": "For input \"ac\" test case is expecting \"a\" as output, how is just \"a\" a palindromic string?"
                    },
                    {
                        "username": "ayushiidevpura",
                        "content": "because when we read \"a\" from forward it results in \"a\" and at the same time when we read \"a\" from backward it is still \"a\""
                    },
                    {
                        "username": "beyzigo",
                        "content": "Because if you read the string \"a\" backwards it will still be \"a\""
                    },
                    {
                        "username": "tsafackghokeng",
                        "content": "[@Chouhan_Gourav](/Chouhan_Gourav) the test case said \"ac\" not \"a\". is \"ac\" palindromic? for \"a\" i understand"
                    },
                    {
                        "username": "CODEWITHABHINAV",
                        "content": "you have to submit the first string as your answer read more about this question on gFg\\n"
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "any string is palindrome if we read it same from front and from back\\nin single character we read it same from front and back"
                    },
                    {
                        "username": "oinrup",
                        "content": "yes thats my question too"
                    },
                    {
                        "username": "yldemon",
                        "content": "Any character in the string by itself is a palindromic substring. So in the case where there is no palindromic substring with length > 1, you can return any character."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "Whenever you come accross such contradiction, just google the definition, any. Any string is called is pallindromic if the reverse of the string is equal to the original string. Reverse of \\'a\\' is \\'a\\'. Hope you get this."
                    },
                    {
                        "username": "947876275",
                        "content": "This post is for learner wanna practice DP.\\nThe basic idea is, if we wanna say \"aba\" is palindromic, then we need to firstly confirm that \"b\" is palindromic, then we also need to check if \"a\"(the first a) = \"a\" (the second a).\\n\\nM is a 2-d array which stores boolean values.\\nM[i][j] indicates if string[i.....j] is palindromic.\\nSo base cases are:\\nM[i][i] is true.\\nM[i][i + 1] = (s[i] == s[i + 1]);\\nrecurrence relation is :\\nM[i][j] = (s[i] == s[j] AND M[i + 1][j - 1]);\\nFor the implementation of recurrence relation, one idea is you can loop through all possible symmetry axis. For each of the axis, you expand at both RHS and LHS simultaneously. This method promises that when you are determining value in M[i][j], M[i + 1][j - 1] must have the correct value.\\nFinal answer can be found from all M[i][j] == 1 with largest (j - i)."
                    },
                    {
                        "username": "Msey",
                        "content": "thank you, cat brother"
                    },
                    {
                        "username": "user0558y",
                        "content": "I understand the solution but I don't understand why it needs any storage at all or why it needs to be a DP solution.\n\nThe condition `(s[i] == s[j] AND M[i + 1][j - 1])` requires you to memorise if `M[i+1][j-1]` is true, that's easy to understand. However, if you expand each possible axis at the same time, i.e. 1st iteration (s[i+1], s[j-1]), 2nd iteration `s[i+2], s[j-2]`, ... It is guaranteed that M[i+1][j-1] is always true and hence can be dropped, and you should break the loop when it is not true.\n\nIn summary, you don't need to memorise anything at all and you just need to check `s[i] == s[j]` while expanding in both directions at the same time, unless I have misunderstood anything? Here is an implementation of your algorithm but without storage: https://leetcode.com/problems/longest-palindromic-substring/submissions/868540120/"
                    },
                    {
                        "username": "taras",
                        "content": "Thank you! this is a beautiful explanation, though I\\'m not sure what exactly you mean by expanding both on LHS and RHS. In my implementation it\\'s enough to compute all diagonals of  the upper right triangle of the dp matrix."
                    },
                    {
                        "username": "klu_2100031593",
                        "content": "super explanation"
                    },
                    {
                        "username": "napoleon",
                        "content": "My Solution Is Naive, It Cost O(n^2), Is there Any Solution faster?"
                    },
                    {
                        "username": "leocampos",
                        "content": "[@tylerprill-rhdc](/tylerprill-rhdc) So, what I did was:\nStated in my mind the Brute Force approach - create every possible substring and test each one to see if is a palindrome and find the longest.\n\nOf course this would be ridiculously slow, so let's improve it.\nI also mentally stated that a palindrome has a recursive aspect -> if single char, or two equal chars, or charX + palindrome + charX\nSo I created a isPalindrome recursive method that checked it delegating to itself extracting the borders.\n\nSince a palindrome must start and end with the same char, in my traverse of the string, I started storing the position of each character Map<Character, List< Integer>>, so I would just go back to the previous found Char and check if from there to the current pointer I would have a Palindrome.\n\nThen I stopped doing this for every possible palindrome, I then started doing only for the ones that COULD be longer than the already found longest palindrome. That accelerated a lot.\n\nIn the almost last step, I added memoization. Remember that a palindrome is like a sandwich, with the external chars being equal and the meat being another palindrome? So I stored the found palindromes using their start and and positions. So I could check if that had already being checked and if so, either return true or false directly.\n\nThe final step was to convert the recursive function to an iterative function to save some memory used by the call stack.\nMaybe there are better implementations, just sharing my thought process."
                    },
                    {
                        "username": "tylerprill-rhdc",
                        "content": "[@tylerprill-rhdc](/tylerprill-rhdc) Two pointer based solution is also a really good solve here"
                    },
                    {
                        "username": "tylerprill-rhdc",
                        "content": "This could be done in a single pass algorithm, but will inherently check character indices multiple times based on the nature of the problem. (basically, iterate through each, then bubble out from each index)"
                    },
                    {
                        "username": "neetika",
                        "content": "From the leetcode blog, one of the methods of solving this is:\\n\\nA common mistake:\\nSome people will be tempted to come up with a quick solution, which is unfortunately flawed (however can be corrected easily):\\n\\nReverse S and become S\\u2019. Find the longest common substring between S and S\\u2019, which must also be the longest palindromic substring.\\nThis seemed to work, let\\u2019s see some examples below.\\n\\nFor example,\\nS = \\u201ccaba\\u201d, S\\u2019 = \\u201cabac\\u201d.\\nThe longest common substring between S and S\\u2019 is \\u201caba\\u201d, which is the answer.\\n\\nLet\\u2019s try another example:\\nS = \\u201cabacdfgdcaba\\u201d, S\\u2019 = \\u201cabacdgfdcaba\\u201d.\\nThe longest common substring between S and S\\u2019 is \\u201cabacd\\u201d. Clearly, this is not a valid palindrome.\\n\\n**We could see that the longest common substring method fails when there exists a reversed copy of a non-palindromic substring in some other part of S. To rectify this, each time we find a longest common substring candidate, we check if the substring\\u2019s indices are the same as the reversed substring\\u2019s original indices. If it is, then we attempt to update the longest palindrome found so far; if not, we skip this and find the next candidate.**\\n\\nIs this part correct? \\n\\nexample string: abcxycba\\nreverse string:  abcxycba\\n\\nThe substring indices are same as reversed string original indices and yet it is not a palindrome?"
                    },
                    {
                        "username": "HRVY_SNOWDEN",
                        "content": "cool sirr:)\\n"
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "WRONG.\\n\\nabcxycba reversed is abcyxcba."
                    },
                    {
                        "username": "travisl12",
                        "content": "After I solved this problem I thought it\\'d be interesting to see how it worked in realtime.\\n\\nhttps://codepen.io/TravisL12/pen/pogvweg"
                    },
                    {
                        "username": "user3907vj",
                        "content": "thanks for the \"nanananananana\" from all the small things ;)"
                    },
                    {
                        "username": "zapataast",
                        "content": "u are crazy"
                    },
                    {
                        "username": "sondq98",
                        "content": "very intuitive"
                    },
                    {
                        "username": "Tathagat017",
                        "content": "thank you\\n"
                    },
                    {
                        "username": "mikler",
                        "content": "So I think I finally understood logic of test creators. \\nEven if you write a classical DP or memorization solution for this one you will timeout on latest tests.\\nI think they consider it edge cases. Because if you add one simple line it will pass! OMG. \\nI have leet code for this. Instead of solving problems I spend hours optimizing the constants.\\n\\nif s == s[::-1]: return s"
                    },
                    {
                        "username": "Vectorido",
                        "content": "Don\\'t work already. Time limit at 141 test even with that construction."
                    },
                    {
                        "username": "deepalithakur17",
                        "content": "It will only work in python."
                    },
                    {
                        "username": "ishogbon",
                        "content": "Its memoization, not memorization "
                    },
                    {
                        "username": "84danie",
                        "content": "I submitted my solution, and received a Time Limit Exceeded on this test case:\\n\\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabcaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n\\nSo I copied and pasted the TC into a custom test case, and started to think about what I could tweak. However, I ended up accidentally hitting Run Code, but instead of getting a Time Limit Exceeded result, it passed:\\n\\n![0_1479079812693_upload-4af9e94c-2e53-4915-acf6-782780c7bf8b](/uploads/files/1479079813717-upload-4af9e94c-2e53-4915-acf6-782780c7bf8b.png) \\n\\nIs this supposed to happen and I just need to make my code more efficient, or is this a bug? \\n![0_1479079956817_upload-1ef15826-d6e6-4bde-9c06-eb597c5c8d0e](/uploads/files/1479079957639-upload-1ef15826-d6e6-4bde-9c06-eb597c5c8d0e.png)"
                    },
                    {
                        "username": "RitikaSahay",
                        "content": "Same thing happened with me. Is there a solution for it?\\n"
                    },
                    {
                        "username": "danicruz0415",
                        "content": "It\\'s happened to me a couple of times. My theory is that the time limit is given for the whole list of test cases. Thus, you can have your test pass, but it will still time limit exceed because it wont get to calculate all the test cases before the time runs out. I cannot confirm this but I think its true because with a very unoptimized solution I got time limit exceeded very early in the test cases (for another problem), after some optimizations I got it much later (like getting to the last tests) which themselves were around the same size, so if the time limit was set per test it would not make sense to fail in a similarly long test-case just that is much later in the test list. (I think the same would apply to memory limit exceeded)"
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "The exact same situation happened with me in one problem... it was a DP problem too... I was getting a Memory Limit Exceeded error with the memoized solution but it was running fine in the Run Code button."
                    },
                    {
                        "username": "Hubro",
                        "content": "I\\'m getting \"Time Limit Exceeded\" with 141/141 testcases passed and \"Last Executed Input\" is:\\n\\n```\\ns =\\n```\\n\\nDid I break it?"
                    },
                    {
                        "username": "karan_dhiman",
                        "content": "same issue"
                    },
                    {
                        "username": "BLANK-Zora",
                        "content": "exactly bro this shit is recked , like it is giving tests outside the constraints , how am i suppose to include such things in the code"
                    },
                    {
                        "username": "arunprep5",
                        "content": "same issue. java"
                    },
                    {
                        "username": "blasphelmy",
                        "content": "[@tuancoltech](/tuancoltech) it worked when i rewrote the code in c# instead of c++"
                    },
                    {
                        "username": "tuancoltech",
                        "content": "[@blasphelmy](/blasphelmy) [@Tomas Sandven](/Hubro) Did you guys find out why? I got the same issue."
                    },
                    {
                        "username": "blasphelmy",
                        "content": "i got that too. im not sure whats going on given that the constraint for input is between 1 and 1000"
                    },
                    {
                        "username": "Vinitajain",
                        "content": "Hi All,\\nI have a test case which is failing, but I feel the testcase result is incorrect.Please refer the screenshot below.\\n![image](https://assets.leetcode.com/users/images/e9e42efb-63d5-4cfa-b420-f1926674f6dc_1654838015.8394327.png)\\n\\nThe longest palindromic substring is \"aaca\" but the test case result is \"aca\". Anyone else faced this problem?"
                    },
                    {
                        "username": "OthSO",
                        "content": "[@mohdansah10](/mohdansah10) \\nthey are separated in the input with \"bd\" so it is not a valid answer "
                    },
                    {
                        "username": "mohdansah10",
                        "content": "I\\'m getting same error, but different case:\\nInput\\ns =\\n\"aacabdkacaa\"\\n\\nOutput\\n\"aacakacaa\"\\nExpected\\n\"aca\"\\n\\nBut mine is Palindrome"
                    },
                    {
                        "username": "hasmithraa",
                        "content": "the expected is correct because aaca can\\'t be a palindrome only \\'aacaa\\' can be a palindrome which is not there in your case"
                    },
                    {
                        "username": "Amish_Singh",
                        "content": "how are you considering \"aaca\" as a palindromic substring, \"aca\" is a palindrome and it is the longest"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "dude you really came up with the solution "
                    },
                    {
                        "username": "AryaAditya3609",
                        "content": "how is \"aaca\" and \"acaa\" same ???\\nWhile \"aca\" is palindrome because both \"aca\" and reverse of it \"aca\" is same !!"
                    },
                    {
                        "username": "alexandra-pickle",
                        "content": "\"aaca\" is not a palindrome"
                    },
                    {
                        "username": "bugHackerLoop",
                        "content": "I followed the approach leant by Aditya Verma DP lectures and encountered the same test case failing. Does the logic where I reverse the string and calculate the longest common substring doesn\\'t work here? I know it works for longest palindromic subsequence but here it fails for such test cases .. why is it so?"
                    },
                    {
                        "username": "mductran",
                        "content": "how is \\'aaca\\' a palindrome? when read backward it\\'s \\'acaa\\' so it\\'s not the same reading forward."
                    },
                    {
                        "username": "jnsudhir",
                        "content": "Check my solution, it was able to clear test case \"aaca\". Explained code in comments.\\n\\nhttps://leetcode.com/problems/longest-palindromic-substring/solutions/3091016/longest-palindromic-substring-using-javascript-beats-94-82-in-runtime-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "nikhileshratna",
                        "content": "aaca is not palindrome"
                    },
                    {
                        "username": "sunshine77",
                        "content": "hey, iam getting the same error, i have seen ansewrs where they have totally changed the algorithm, how did u solve this by tweaking the same algoirhtm"
                    },
                    {
                        "username": "bhupendrabc71",
                        "content": "how come \"aaca\" is palindrome. it should be \"aca\""
                    },
                    {
                        "username": "just11blocks",
                        "content": "aaca is not a palindrome...aacaa and aca are."
                    },
                    {
                        "username": "odi1n",
                        "content": "I also encountered this problem"
                    },
                    {
                        "username": "vamsi2302",
                        "content": "I think you get it by now!\\n"
                    }
                ]
            },
            {
                "id": 1569251,
                "content": [
                    {
                        "username": "ZenMasterV",
                        "content": "Seems like too many of the  coding wunderkinds here lack basic reading comprehension skills \\n\" Please don\\'t post any solutions in this discussion tab\"\\nIt\\'s almost the rule to find the exact opposite for the discussion of every question. I don\\'t want to see your damned solution!"
                    },
                    {
                        "username": "NeroXIII",
                        "content": "[@charonme](/charonme) name does not check out :((("
                    },
                    {
                        "username": "192731",
                        "content": "and if they do?"
                    },
                    {
                        "username": "plevi1995",
                        "content": "Excellent comment"
                    },
                    {
                        "username": "khan60939",
                        "content": "Can anyone tell how DP is being used here? "
                    },
                    {
                        "username": "sandagolcea",
                        "content": "[@charonme](/charonme) my thinking exactly, but at least they should create a flag to help us moderate and move solutions to the correct tab. Would only need a stack overflow moderation-like system: one person flags, another person receives a queue of flagged comments and confirms the tagging.. oh well"
                    },
                    {
                        "username": "charonme",
                        "content": "maybe people get confused by the official leetcode comment which says: \"If you\\'d like to share a detailed solution to the problem, please create a new post in the discuss section\"\\nMaybe some time ago they didn\\'t have a separate solutions section and only recently changed it, but left some of the old solutions in the discussion section and didn\\'t fix the automated comment worting?"
                    },
                    {
                        "username": "klanjewar037",
                        "content": "hehe"
                    },
                    {
                        "username": "sanemdeepak",
                        "content": "For input \"ac\" test case is expecting \"a\" as output, how is just \"a\" a palindromic string?"
                    },
                    {
                        "username": "ayushiidevpura",
                        "content": "because when we read \"a\" from forward it results in \"a\" and at the same time when we read \"a\" from backward it is still \"a\""
                    },
                    {
                        "username": "beyzigo",
                        "content": "Because if you read the string \"a\" backwards it will still be \"a\""
                    },
                    {
                        "username": "tsafackghokeng",
                        "content": "[@Chouhan_Gourav](/Chouhan_Gourav) the test case said \"ac\" not \"a\". is \"ac\" palindromic? for \"a\" i understand"
                    },
                    {
                        "username": "CODEWITHABHINAV",
                        "content": "you have to submit the first string as your answer read more about this question on gFg\\n"
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "any string is palindrome if we read it same from front and from back\\nin single character we read it same from front and back"
                    },
                    {
                        "username": "oinrup",
                        "content": "yes thats my question too"
                    },
                    {
                        "username": "yldemon",
                        "content": "Any character in the string by itself is a palindromic substring. So in the case where there is no palindromic substring with length > 1, you can return any character."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "Whenever you come accross such contradiction, just google the definition, any. Any string is called is pallindromic if the reverse of the string is equal to the original string. Reverse of \\'a\\' is \\'a\\'. Hope you get this."
                    },
                    {
                        "username": "947876275",
                        "content": "This post is for learner wanna practice DP.\\nThe basic idea is, if we wanna say \"aba\" is palindromic, then we need to firstly confirm that \"b\" is palindromic, then we also need to check if \"a\"(the first a) = \"a\" (the second a).\\n\\nM is a 2-d array which stores boolean values.\\nM[i][j] indicates if string[i.....j] is palindromic.\\nSo base cases are:\\nM[i][i] is true.\\nM[i][i + 1] = (s[i] == s[i + 1]);\\nrecurrence relation is :\\nM[i][j] = (s[i] == s[j] AND M[i + 1][j - 1]);\\nFor the implementation of recurrence relation, one idea is you can loop through all possible symmetry axis. For each of the axis, you expand at both RHS and LHS simultaneously. This method promises that when you are determining value in M[i][j], M[i + 1][j - 1] must have the correct value.\\nFinal answer can be found from all M[i][j] == 1 with largest (j - i)."
                    },
                    {
                        "username": "Msey",
                        "content": "thank you, cat brother"
                    },
                    {
                        "username": "user0558y",
                        "content": "I understand the solution but I don't understand why it needs any storage at all or why it needs to be a DP solution.\n\nThe condition `(s[i] == s[j] AND M[i + 1][j - 1])` requires you to memorise if `M[i+1][j-1]` is true, that's easy to understand. However, if you expand each possible axis at the same time, i.e. 1st iteration (s[i+1], s[j-1]), 2nd iteration `s[i+2], s[j-2]`, ... It is guaranteed that M[i+1][j-1] is always true and hence can be dropped, and you should break the loop when it is not true.\n\nIn summary, you don't need to memorise anything at all and you just need to check `s[i] == s[j]` while expanding in both directions at the same time, unless I have misunderstood anything? Here is an implementation of your algorithm but without storage: https://leetcode.com/problems/longest-palindromic-substring/submissions/868540120/"
                    },
                    {
                        "username": "taras",
                        "content": "Thank you! this is a beautiful explanation, though I\\'m not sure what exactly you mean by expanding both on LHS and RHS. In my implementation it\\'s enough to compute all diagonals of  the upper right triangle of the dp matrix."
                    },
                    {
                        "username": "klu_2100031593",
                        "content": "super explanation"
                    },
                    {
                        "username": "napoleon",
                        "content": "My Solution Is Naive, It Cost O(n^2), Is there Any Solution faster?"
                    },
                    {
                        "username": "leocampos",
                        "content": "[@tylerprill-rhdc](/tylerprill-rhdc) So, what I did was:\nStated in my mind the Brute Force approach - create every possible substring and test each one to see if is a palindrome and find the longest.\n\nOf course this would be ridiculously slow, so let's improve it.\nI also mentally stated that a palindrome has a recursive aspect -> if single char, or two equal chars, or charX + palindrome + charX\nSo I created a isPalindrome recursive method that checked it delegating to itself extracting the borders.\n\nSince a palindrome must start and end with the same char, in my traverse of the string, I started storing the position of each character Map<Character, List< Integer>>, so I would just go back to the previous found Char and check if from there to the current pointer I would have a Palindrome.\n\nThen I stopped doing this for every possible palindrome, I then started doing only for the ones that COULD be longer than the already found longest palindrome. That accelerated a lot.\n\nIn the almost last step, I added memoization. Remember that a palindrome is like a sandwich, with the external chars being equal and the meat being another palindrome? So I stored the found palindromes using their start and and positions. So I could check if that had already being checked and if so, either return true or false directly.\n\nThe final step was to convert the recursive function to an iterative function to save some memory used by the call stack.\nMaybe there are better implementations, just sharing my thought process."
                    },
                    {
                        "username": "tylerprill-rhdc",
                        "content": "[@tylerprill-rhdc](/tylerprill-rhdc) Two pointer based solution is also a really good solve here"
                    },
                    {
                        "username": "tylerprill-rhdc",
                        "content": "This could be done in a single pass algorithm, but will inherently check character indices multiple times based on the nature of the problem. (basically, iterate through each, then bubble out from each index)"
                    },
                    {
                        "username": "neetika",
                        "content": "From the leetcode blog, one of the methods of solving this is:\\n\\nA common mistake:\\nSome people will be tempted to come up with a quick solution, which is unfortunately flawed (however can be corrected easily):\\n\\nReverse S and become S\\u2019. Find the longest common substring between S and S\\u2019, which must also be the longest palindromic substring.\\nThis seemed to work, let\\u2019s see some examples below.\\n\\nFor example,\\nS = \\u201ccaba\\u201d, S\\u2019 = \\u201cabac\\u201d.\\nThe longest common substring between S and S\\u2019 is \\u201caba\\u201d, which is the answer.\\n\\nLet\\u2019s try another example:\\nS = \\u201cabacdfgdcaba\\u201d, S\\u2019 = \\u201cabacdgfdcaba\\u201d.\\nThe longest common substring between S and S\\u2019 is \\u201cabacd\\u201d. Clearly, this is not a valid palindrome.\\n\\n**We could see that the longest common substring method fails when there exists a reversed copy of a non-palindromic substring in some other part of S. To rectify this, each time we find a longest common substring candidate, we check if the substring\\u2019s indices are the same as the reversed substring\\u2019s original indices. If it is, then we attempt to update the longest palindrome found so far; if not, we skip this and find the next candidate.**\\n\\nIs this part correct? \\n\\nexample string: abcxycba\\nreverse string:  abcxycba\\n\\nThe substring indices are same as reversed string original indices and yet it is not a palindrome?"
                    },
                    {
                        "username": "HRVY_SNOWDEN",
                        "content": "cool sirr:)\\n"
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "WRONG.\\n\\nabcxycba reversed is abcyxcba."
                    },
                    {
                        "username": "travisl12",
                        "content": "After I solved this problem I thought it\\'d be interesting to see how it worked in realtime.\\n\\nhttps://codepen.io/TravisL12/pen/pogvweg"
                    },
                    {
                        "username": "user3907vj",
                        "content": "thanks for the \"nanananananana\" from all the small things ;)"
                    },
                    {
                        "username": "zapataast",
                        "content": "u are crazy"
                    },
                    {
                        "username": "sondq98",
                        "content": "very intuitive"
                    },
                    {
                        "username": "Tathagat017",
                        "content": "thank you\\n"
                    },
                    {
                        "username": "mikler",
                        "content": "So I think I finally understood logic of test creators. \\nEven if you write a classical DP or memorization solution for this one you will timeout on latest tests.\\nI think they consider it edge cases. Because if you add one simple line it will pass! OMG. \\nI have leet code for this. Instead of solving problems I spend hours optimizing the constants.\\n\\nif s == s[::-1]: return s"
                    },
                    {
                        "username": "Vectorido",
                        "content": "Don\\'t work already. Time limit at 141 test even with that construction."
                    },
                    {
                        "username": "deepalithakur17",
                        "content": "It will only work in python."
                    },
                    {
                        "username": "ishogbon",
                        "content": "Its memoization, not memorization "
                    },
                    {
                        "username": "84danie",
                        "content": "I submitted my solution, and received a Time Limit Exceeded on this test case:\\n\\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabcaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n\\nSo I copied and pasted the TC into a custom test case, and started to think about what I could tweak. However, I ended up accidentally hitting Run Code, but instead of getting a Time Limit Exceeded result, it passed:\\n\\n![0_1479079812693_upload-4af9e94c-2e53-4915-acf6-782780c7bf8b](/uploads/files/1479079813717-upload-4af9e94c-2e53-4915-acf6-782780c7bf8b.png) \\n\\nIs this supposed to happen and I just need to make my code more efficient, or is this a bug? \\n![0_1479079956817_upload-1ef15826-d6e6-4bde-9c06-eb597c5c8d0e](/uploads/files/1479079957639-upload-1ef15826-d6e6-4bde-9c06-eb597c5c8d0e.png)"
                    },
                    {
                        "username": "RitikaSahay",
                        "content": "Same thing happened with me. Is there a solution for it?\\n"
                    },
                    {
                        "username": "danicruz0415",
                        "content": "It\\'s happened to me a couple of times. My theory is that the time limit is given for the whole list of test cases. Thus, you can have your test pass, but it will still time limit exceed because it wont get to calculate all the test cases before the time runs out. I cannot confirm this but I think its true because with a very unoptimized solution I got time limit exceeded very early in the test cases (for another problem), after some optimizations I got it much later (like getting to the last tests) which themselves were around the same size, so if the time limit was set per test it would not make sense to fail in a similarly long test-case just that is much later in the test list. (I think the same would apply to memory limit exceeded)"
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "The exact same situation happened with me in one problem... it was a DP problem too... I was getting a Memory Limit Exceeded error with the memoized solution but it was running fine in the Run Code button."
                    },
                    {
                        "username": "Hubro",
                        "content": "I\\'m getting \"Time Limit Exceeded\" with 141/141 testcases passed and \"Last Executed Input\" is:\\n\\n```\\ns =\\n```\\n\\nDid I break it?"
                    },
                    {
                        "username": "karan_dhiman",
                        "content": "same issue"
                    },
                    {
                        "username": "BLANK-Zora",
                        "content": "exactly bro this shit is recked , like it is giving tests outside the constraints , how am i suppose to include such things in the code"
                    },
                    {
                        "username": "arunprep5",
                        "content": "same issue. java"
                    },
                    {
                        "username": "blasphelmy",
                        "content": "[@tuancoltech](/tuancoltech) it worked when i rewrote the code in c# instead of c++"
                    },
                    {
                        "username": "tuancoltech",
                        "content": "[@blasphelmy](/blasphelmy) [@Tomas Sandven](/Hubro) Did you guys find out why? I got the same issue."
                    },
                    {
                        "username": "blasphelmy",
                        "content": "i got that too. im not sure whats going on given that the constraint for input is between 1 and 1000"
                    },
                    {
                        "username": "Vinitajain",
                        "content": "Hi All,\\nI have a test case which is failing, but I feel the testcase result is incorrect.Please refer the screenshot below.\\n![image](https://assets.leetcode.com/users/images/e9e42efb-63d5-4cfa-b420-f1926674f6dc_1654838015.8394327.png)\\n\\nThe longest palindromic substring is \"aaca\" but the test case result is \"aca\". Anyone else faced this problem?"
                    },
                    {
                        "username": "OthSO",
                        "content": "[@mohdansah10](/mohdansah10) \\nthey are separated in the input with \"bd\" so it is not a valid answer "
                    },
                    {
                        "username": "mohdansah10",
                        "content": "I\\'m getting same error, but different case:\\nInput\\ns =\\n\"aacabdkacaa\"\\n\\nOutput\\n\"aacakacaa\"\\nExpected\\n\"aca\"\\n\\nBut mine is Palindrome"
                    },
                    {
                        "username": "hasmithraa",
                        "content": "the expected is correct because aaca can\\'t be a palindrome only \\'aacaa\\' can be a palindrome which is not there in your case"
                    },
                    {
                        "username": "Amish_Singh",
                        "content": "how are you considering \"aaca\" as a palindromic substring, \"aca\" is a palindrome and it is the longest"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "dude you really came up with the solution "
                    },
                    {
                        "username": "AryaAditya3609",
                        "content": "how is \"aaca\" and \"acaa\" same ???\\nWhile \"aca\" is palindrome because both \"aca\" and reverse of it \"aca\" is same !!"
                    },
                    {
                        "username": "alexandra-pickle",
                        "content": "\"aaca\" is not a palindrome"
                    },
                    {
                        "username": "bugHackerLoop",
                        "content": "I followed the approach leant by Aditya Verma DP lectures and encountered the same test case failing. Does the logic where I reverse the string and calculate the longest common substring doesn\\'t work here? I know it works for longest palindromic subsequence but here it fails for such test cases .. why is it so?"
                    },
                    {
                        "username": "mductran",
                        "content": "how is \\'aaca\\' a palindrome? when read backward it\\'s \\'acaa\\' so it\\'s not the same reading forward."
                    },
                    {
                        "username": "jnsudhir",
                        "content": "Check my solution, it was able to clear test case \"aaca\". Explained code in comments.\\n\\nhttps://leetcode.com/problems/longest-palindromic-substring/solutions/3091016/longest-palindromic-substring-using-javascript-beats-94-82-in-runtime-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "nikhileshratna",
                        "content": "aaca is not palindrome"
                    },
                    {
                        "username": "sunshine77",
                        "content": "hey, iam getting the same error, i have seen ansewrs where they have totally changed the algorithm, how did u solve this by tweaking the same algoirhtm"
                    },
                    {
                        "username": "bhupendrabc71",
                        "content": "how come \"aaca\" is palindrome. it should be \"aca\""
                    },
                    {
                        "username": "just11blocks",
                        "content": "aaca is not a palindrome...aacaa and aca are."
                    },
                    {
                        "username": "odi1n",
                        "content": "I also encountered this problem"
                    },
                    {
                        "username": "vamsi2302",
                        "content": "I think you get it by now!\\n"
                    }
                ]
            },
            {
                "id": 1566232,
                "content": [
                    {
                        "username": "ZenMasterV",
                        "content": "Seems like too many of the  coding wunderkinds here lack basic reading comprehension skills \\n\" Please don\\'t post any solutions in this discussion tab\"\\nIt\\'s almost the rule to find the exact opposite for the discussion of every question. I don\\'t want to see your damned solution!"
                    },
                    {
                        "username": "NeroXIII",
                        "content": "[@charonme](/charonme) name does not check out :((("
                    },
                    {
                        "username": "192731",
                        "content": "and if they do?"
                    },
                    {
                        "username": "plevi1995",
                        "content": "Excellent comment"
                    },
                    {
                        "username": "khan60939",
                        "content": "Can anyone tell how DP is being used here? "
                    },
                    {
                        "username": "sandagolcea",
                        "content": "[@charonme](/charonme) my thinking exactly, but at least they should create a flag to help us moderate and move solutions to the correct tab. Would only need a stack overflow moderation-like system: one person flags, another person receives a queue of flagged comments and confirms the tagging.. oh well"
                    },
                    {
                        "username": "charonme",
                        "content": "maybe people get confused by the official leetcode comment which says: \"If you\\'d like to share a detailed solution to the problem, please create a new post in the discuss section\"\\nMaybe some time ago they didn\\'t have a separate solutions section and only recently changed it, but left some of the old solutions in the discussion section and didn\\'t fix the automated comment worting?"
                    },
                    {
                        "username": "klanjewar037",
                        "content": "hehe"
                    },
                    {
                        "username": "sanemdeepak",
                        "content": "For input \"ac\" test case is expecting \"a\" as output, how is just \"a\" a palindromic string?"
                    },
                    {
                        "username": "ayushiidevpura",
                        "content": "because when we read \"a\" from forward it results in \"a\" and at the same time when we read \"a\" from backward it is still \"a\""
                    },
                    {
                        "username": "beyzigo",
                        "content": "Because if you read the string \"a\" backwards it will still be \"a\""
                    },
                    {
                        "username": "tsafackghokeng",
                        "content": "[@Chouhan_Gourav](/Chouhan_Gourav) the test case said \"ac\" not \"a\". is \"ac\" palindromic? for \"a\" i understand"
                    },
                    {
                        "username": "CODEWITHABHINAV",
                        "content": "you have to submit the first string as your answer read more about this question on gFg\\n"
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "any string is palindrome if we read it same from front and from back\\nin single character we read it same from front and back"
                    },
                    {
                        "username": "oinrup",
                        "content": "yes thats my question too"
                    },
                    {
                        "username": "yldemon",
                        "content": "Any character in the string by itself is a palindromic substring. So in the case where there is no palindromic substring with length > 1, you can return any character."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "Whenever you come accross such contradiction, just google the definition, any. Any string is called is pallindromic if the reverse of the string is equal to the original string. Reverse of \\'a\\' is \\'a\\'. Hope you get this."
                    },
                    {
                        "username": "947876275",
                        "content": "This post is for learner wanna practice DP.\\nThe basic idea is, if we wanna say \"aba\" is palindromic, then we need to firstly confirm that \"b\" is palindromic, then we also need to check if \"a\"(the first a) = \"a\" (the second a).\\n\\nM is a 2-d array which stores boolean values.\\nM[i][j] indicates if string[i.....j] is palindromic.\\nSo base cases are:\\nM[i][i] is true.\\nM[i][i + 1] = (s[i] == s[i + 1]);\\nrecurrence relation is :\\nM[i][j] = (s[i] == s[j] AND M[i + 1][j - 1]);\\nFor the implementation of recurrence relation, one idea is you can loop through all possible symmetry axis. For each of the axis, you expand at both RHS and LHS simultaneously. This method promises that when you are determining value in M[i][j], M[i + 1][j - 1] must have the correct value.\\nFinal answer can be found from all M[i][j] == 1 with largest (j - i)."
                    },
                    {
                        "username": "Msey",
                        "content": "thank you, cat brother"
                    },
                    {
                        "username": "user0558y",
                        "content": "I understand the solution but I don't understand why it needs any storage at all or why it needs to be a DP solution.\n\nThe condition `(s[i] == s[j] AND M[i + 1][j - 1])` requires you to memorise if `M[i+1][j-1]` is true, that's easy to understand. However, if you expand each possible axis at the same time, i.e. 1st iteration (s[i+1], s[j-1]), 2nd iteration `s[i+2], s[j-2]`, ... It is guaranteed that M[i+1][j-1] is always true and hence can be dropped, and you should break the loop when it is not true.\n\nIn summary, you don't need to memorise anything at all and you just need to check `s[i] == s[j]` while expanding in both directions at the same time, unless I have misunderstood anything? Here is an implementation of your algorithm but without storage: https://leetcode.com/problems/longest-palindromic-substring/submissions/868540120/"
                    },
                    {
                        "username": "taras",
                        "content": "Thank you! this is a beautiful explanation, though I\\'m not sure what exactly you mean by expanding both on LHS and RHS. In my implementation it\\'s enough to compute all diagonals of  the upper right triangle of the dp matrix."
                    },
                    {
                        "username": "klu_2100031593",
                        "content": "super explanation"
                    },
                    {
                        "username": "napoleon",
                        "content": "My Solution Is Naive, It Cost O(n^2), Is there Any Solution faster?"
                    },
                    {
                        "username": "leocampos",
                        "content": "[@tylerprill-rhdc](/tylerprill-rhdc) So, what I did was:\nStated in my mind the Brute Force approach - create every possible substring and test each one to see if is a palindrome and find the longest.\n\nOf course this would be ridiculously slow, so let's improve it.\nI also mentally stated that a palindrome has a recursive aspect -> if single char, or two equal chars, or charX + palindrome + charX\nSo I created a isPalindrome recursive method that checked it delegating to itself extracting the borders.\n\nSince a palindrome must start and end with the same char, in my traverse of the string, I started storing the position of each character Map<Character, List< Integer>>, so I would just go back to the previous found Char and check if from there to the current pointer I would have a Palindrome.\n\nThen I stopped doing this for every possible palindrome, I then started doing only for the ones that COULD be longer than the already found longest palindrome. That accelerated a lot.\n\nIn the almost last step, I added memoization. Remember that a palindrome is like a sandwich, with the external chars being equal and the meat being another palindrome? So I stored the found palindromes using their start and and positions. So I could check if that had already being checked and if so, either return true or false directly.\n\nThe final step was to convert the recursive function to an iterative function to save some memory used by the call stack.\nMaybe there are better implementations, just sharing my thought process."
                    },
                    {
                        "username": "tylerprill-rhdc",
                        "content": "[@tylerprill-rhdc](/tylerprill-rhdc) Two pointer based solution is also a really good solve here"
                    },
                    {
                        "username": "tylerprill-rhdc",
                        "content": "This could be done in a single pass algorithm, but will inherently check character indices multiple times based on the nature of the problem. (basically, iterate through each, then bubble out from each index)"
                    },
                    {
                        "username": "neetika",
                        "content": "From the leetcode blog, one of the methods of solving this is:\\n\\nA common mistake:\\nSome people will be tempted to come up with a quick solution, which is unfortunately flawed (however can be corrected easily):\\n\\nReverse S and become S\\u2019. Find the longest common substring between S and S\\u2019, which must also be the longest palindromic substring.\\nThis seemed to work, let\\u2019s see some examples below.\\n\\nFor example,\\nS = \\u201ccaba\\u201d, S\\u2019 = \\u201cabac\\u201d.\\nThe longest common substring between S and S\\u2019 is \\u201caba\\u201d, which is the answer.\\n\\nLet\\u2019s try another example:\\nS = \\u201cabacdfgdcaba\\u201d, S\\u2019 = \\u201cabacdgfdcaba\\u201d.\\nThe longest common substring between S and S\\u2019 is \\u201cabacd\\u201d. Clearly, this is not a valid palindrome.\\n\\n**We could see that the longest common substring method fails when there exists a reversed copy of a non-palindromic substring in some other part of S. To rectify this, each time we find a longest common substring candidate, we check if the substring\\u2019s indices are the same as the reversed substring\\u2019s original indices. If it is, then we attempt to update the longest palindrome found so far; if not, we skip this and find the next candidate.**\\n\\nIs this part correct? \\n\\nexample string: abcxycba\\nreverse string:  abcxycba\\n\\nThe substring indices are same as reversed string original indices and yet it is not a palindrome?"
                    },
                    {
                        "username": "HRVY_SNOWDEN",
                        "content": "cool sirr:)\\n"
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "WRONG.\\n\\nabcxycba reversed is abcyxcba."
                    },
                    {
                        "username": "travisl12",
                        "content": "After I solved this problem I thought it\\'d be interesting to see how it worked in realtime.\\n\\nhttps://codepen.io/TravisL12/pen/pogvweg"
                    },
                    {
                        "username": "user3907vj",
                        "content": "thanks for the \"nanananananana\" from all the small things ;)"
                    },
                    {
                        "username": "zapataast",
                        "content": "u are crazy"
                    },
                    {
                        "username": "sondq98",
                        "content": "very intuitive"
                    },
                    {
                        "username": "Tathagat017",
                        "content": "thank you\\n"
                    },
                    {
                        "username": "mikler",
                        "content": "So I think I finally understood logic of test creators. \\nEven if you write a classical DP or memorization solution for this one you will timeout on latest tests.\\nI think they consider it edge cases. Because if you add one simple line it will pass! OMG. \\nI have leet code for this. Instead of solving problems I spend hours optimizing the constants.\\n\\nif s == s[::-1]: return s"
                    },
                    {
                        "username": "Vectorido",
                        "content": "Don\\'t work already. Time limit at 141 test even with that construction."
                    },
                    {
                        "username": "deepalithakur17",
                        "content": "It will only work in python."
                    },
                    {
                        "username": "ishogbon",
                        "content": "Its memoization, not memorization "
                    },
                    {
                        "username": "84danie",
                        "content": "I submitted my solution, and received a Time Limit Exceeded on this test case:\\n\\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabcaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n\\nSo I copied and pasted the TC into a custom test case, and started to think about what I could tweak. However, I ended up accidentally hitting Run Code, but instead of getting a Time Limit Exceeded result, it passed:\\n\\n![0_1479079812693_upload-4af9e94c-2e53-4915-acf6-782780c7bf8b](/uploads/files/1479079813717-upload-4af9e94c-2e53-4915-acf6-782780c7bf8b.png) \\n\\nIs this supposed to happen and I just need to make my code more efficient, or is this a bug? \\n![0_1479079956817_upload-1ef15826-d6e6-4bde-9c06-eb597c5c8d0e](/uploads/files/1479079957639-upload-1ef15826-d6e6-4bde-9c06-eb597c5c8d0e.png)"
                    },
                    {
                        "username": "RitikaSahay",
                        "content": "Same thing happened with me. Is there a solution for it?\\n"
                    },
                    {
                        "username": "danicruz0415",
                        "content": "It\\'s happened to me a couple of times. My theory is that the time limit is given for the whole list of test cases. Thus, you can have your test pass, but it will still time limit exceed because it wont get to calculate all the test cases before the time runs out. I cannot confirm this but I think its true because with a very unoptimized solution I got time limit exceeded very early in the test cases (for another problem), after some optimizations I got it much later (like getting to the last tests) which themselves were around the same size, so if the time limit was set per test it would not make sense to fail in a similarly long test-case just that is much later in the test list. (I think the same would apply to memory limit exceeded)"
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "The exact same situation happened with me in one problem... it was a DP problem too... I was getting a Memory Limit Exceeded error with the memoized solution but it was running fine in the Run Code button."
                    },
                    {
                        "username": "Hubro",
                        "content": "I\\'m getting \"Time Limit Exceeded\" with 141/141 testcases passed and \"Last Executed Input\" is:\\n\\n```\\ns =\\n```\\n\\nDid I break it?"
                    },
                    {
                        "username": "karan_dhiman",
                        "content": "same issue"
                    },
                    {
                        "username": "BLANK-Zora",
                        "content": "exactly bro this shit is recked , like it is giving tests outside the constraints , how am i suppose to include such things in the code"
                    },
                    {
                        "username": "arunprep5",
                        "content": "same issue. java"
                    },
                    {
                        "username": "blasphelmy",
                        "content": "[@tuancoltech](/tuancoltech) it worked when i rewrote the code in c# instead of c++"
                    },
                    {
                        "username": "tuancoltech",
                        "content": "[@blasphelmy](/blasphelmy) [@Tomas Sandven](/Hubro) Did you guys find out why? I got the same issue."
                    },
                    {
                        "username": "blasphelmy",
                        "content": "i got that too. im not sure whats going on given that the constraint for input is between 1 and 1000"
                    },
                    {
                        "username": "Vinitajain",
                        "content": "Hi All,\\nI have a test case which is failing, but I feel the testcase result is incorrect.Please refer the screenshot below.\\n![image](https://assets.leetcode.com/users/images/e9e42efb-63d5-4cfa-b420-f1926674f6dc_1654838015.8394327.png)\\n\\nThe longest palindromic substring is \"aaca\" but the test case result is \"aca\". Anyone else faced this problem?"
                    },
                    {
                        "username": "OthSO",
                        "content": "[@mohdansah10](/mohdansah10) \\nthey are separated in the input with \"bd\" so it is not a valid answer "
                    },
                    {
                        "username": "mohdansah10",
                        "content": "I\\'m getting same error, but different case:\\nInput\\ns =\\n\"aacabdkacaa\"\\n\\nOutput\\n\"aacakacaa\"\\nExpected\\n\"aca\"\\n\\nBut mine is Palindrome"
                    },
                    {
                        "username": "hasmithraa",
                        "content": "the expected is correct because aaca can\\'t be a palindrome only \\'aacaa\\' can be a palindrome which is not there in your case"
                    },
                    {
                        "username": "Amish_Singh",
                        "content": "how are you considering \"aaca\" as a palindromic substring, \"aca\" is a palindrome and it is the longest"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "dude you really came up with the solution "
                    },
                    {
                        "username": "AryaAditya3609",
                        "content": "how is \"aaca\" and \"acaa\" same ???\\nWhile \"aca\" is palindrome because both \"aca\" and reverse of it \"aca\" is same !!"
                    },
                    {
                        "username": "alexandra-pickle",
                        "content": "\"aaca\" is not a palindrome"
                    },
                    {
                        "username": "bugHackerLoop",
                        "content": "I followed the approach leant by Aditya Verma DP lectures and encountered the same test case failing. Does the logic where I reverse the string and calculate the longest common substring doesn\\'t work here? I know it works for longest palindromic subsequence but here it fails for such test cases .. why is it so?"
                    },
                    {
                        "username": "mductran",
                        "content": "how is \\'aaca\\' a palindrome? when read backward it\\'s \\'acaa\\' so it\\'s not the same reading forward."
                    },
                    {
                        "username": "jnsudhir",
                        "content": "Check my solution, it was able to clear test case \"aaca\". Explained code in comments.\\n\\nhttps://leetcode.com/problems/longest-palindromic-substring/solutions/3091016/longest-palindromic-substring-using-javascript-beats-94-82-in-runtime-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "nikhileshratna",
                        "content": "aaca is not palindrome"
                    },
                    {
                        "username": "sunshine77",
                        "content": "hey, iam getting the same error, i have seen ansewrs where they have totally changed the algorithm, how did u solve this by tweaking the same algoirhtm"
                    },
                    {
                        "username": "bhupendrabc71",
                        "content": "how come \"aaca\" is palindrome. it should be \"aca\""
                    },
                    {
                        "username": "just11blocks",
                        "content": "aaca is not a palindrome...aacaa and aca are."
                    },
                    {
                        "username": "odi1n",
                        "content": "I also encountered this problem"
                    },
                    {
                        "username": "vamsi2302",
                        "content": "I think you get it by now!\\n"
                    }
                ]
            },
            {
                "id": 1568804,
                "content": [
                    {
                        "username": "ZenMasterV",
                        "content": "Seems like too many of the  coding wunderkinds here lack basic reading comprehension skills \\n\" Please don\\'t post any solutions in this discussion tab\"\\nIt\\'s almost the rule to find the exact opposite for the discussion of every question. I don\\'t want to see your damned solution!"
                    },
                    {
                        "username": "NeroXIII",
                        "content": "[@charonme](/charonme) name does not check out :((("
                    },
                    {
                        "username": "192731",
                        "content": "and if they do?"
                    },
                    {
                        "username": "plevi1995",
                        "content": "Excellent comment"
                    },
                    {
                        "username": "khan60939",
                        "content": "Can anyone tell how DP is being used here? "
                    },
                    {
                        "username": "sandagolcea",
                        "content": "[@charonme](/charonme) my thinking exactly, but at least they should create a flag to help us moderate and move solutions to the correct tab. Would only need a stack overflow moderation-like system: one person flags, another person receives a queue of flagged comments and confirms the tagging.. oh well"
                    },
                    {
                        "username": "charonme",
                        "content": "maybe people get confused by the official leetcode comment which says: \"If you\\'d like to share a detailed solution to the problem, please create a new post in the discuss section\"\\nMaybe some time ago they didn\\'t have a separate solutions section and only recently changed it, but left some of the old solutions in the discussion section and didn\\'t fix the automated comment worting?"
                    },
                    {
                        "username": "klanjewar037",
                        "content": "hehe"
                    },
                    {
                        "username": "sanemdeepak",
                        "content": "For input \"ac\" test case is expecting \"a\" as output, how is just \"a\" a palindromic string?"
                    },
                    {
                        "username": "ayushiidevpura",
                        "content": "because when we read \"a\" from forward it results in \"a\" and at the same time when we read \"a\" from backward it is still \"a\""
                    },
                    {
                        "username": "beyzigo",
                        "content": "Because if you read the string \"a\" backwards it will still be \"a\""
                    },
                    {
                        "username": "tsafackghokeng",
                        "content": "[@Chouhan_Gourav](/Chouhan_Gourav) the test case said \"ac\" not \"a\". is \"ac\" palindromic? for \"a\" i understand"
                    },
                    {
                        "username": "CODEWITHABHINAV",
                        "content": "you have to submit the first string as your answer read more about this question on gFg\\n"
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "any string is palindrome if we read it same from front and from back\\nin single character we read it same from front and back"
                    },
                    {
                        "username": "oinrup",
                        "content": "yes thats my question too"
                    },
                    {
                        "username": "yldemon",
                        "content": "Any character in the string by itself is a palindromic substring. So in the case where there is no palindromic substring with length > 1, you can return any character."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "Whenever you come accross such contradiction, just google the definition, any. Any string is called is pallindromic if the reverse of the string is equal to the original string. Reverse of \\'a\\' is \\'a\\'. Hope you get this."
                    },
                    {
                        "username": "947876275",
                        "content": "This post is for learner wanna practice DP.\\nThe basic idea is, if we wanna say \"aba\" is palindromic, then we need to firstly confirm that \"b\" is palindromic, then we also need to check if \"a\"(the first a) = \"a\" (the second a).\\n\\nM is a 2-d array which stores boolean values.\\nM[i][j] indicates if string[i.....j] is palindromic.\\nSo base cases are:\\nM[i][i] is true.\\nM[i][i + 1] = (s[i] == s[i + 1]);\\nrecurrence relation is :\\nM[i][j] = (s[i] == s[j] AND M[i + 1][j - 1]);\\nFor the implementation of recurrence relation, one idea is you can loop through all possible symmetry axis. For each of the axis, you expand at both RHS and LHS simultaneously. This method promises that when you are determining value in M[i][j], M[i + 1][j - 1] must have the correct value.\\nFinal answer can be found from all M[i][j] == 1 with largest (j - i)."
                    },
                    {
                        "username": "Msey",
                        "content": "thank you, cat brother"
                    },
                    {
                        "username": "user0558y",
                        "content": "I understand the solution but I don't understand why it needs any storage at all or why it needs to be a DP solution.\n\nThe condition `(s[i] == s[j] AND M[i + 1][j - 1])` requires you to memorise if `M[i+1][j-1]` is true, that's easy to understand. However, if you expand each possible axis at the same time, i.e. 1st iteration (s[i+1], s[j-1]), 2nd iteration `s[i+2], s[j-2]`, ... It is guaranteed that M[i+1][j-1] is always true and hence can be dropped, and you should break the loop when it is not true.\n\nIn summary, you don't need to memorise anything at all and you just need to check `s[i] == s[j]` while expanding in both directions at the same time, unless I have misunderstood anything? Here is an implementation of your algorithm but without storage: https://leetcode.com/problems/longest-palindromic-substring/submissions/868540120/"
                    },
                    {
                        "username": "taras",
                        "content": "Thank you! this is a beautiful explanation, though I\\'m not sure what exactly you mean by expanding both on LHS and RHS. In my implementation it\\'s enough to compute all diagonals of  the upper right triangle of the dp matrix."
                    },
                    {
                        "username": "klu_2100031593",
                        "content": "super explanation"
                    },
                    {
                        "username": "napoleon",
                        "content": "My Solution Is Naive, It Cost O(n^2), Is there Any Solution faster?"
                    },
                    {
                        "username": "leocampos",
                        "content": "[@tylerprill-rhdc](/tylerprill-rhdc) So, what I did was:\nStated in my mind the Brute Force approach - create every possible substring and test each one to see if is a palindrome and find the longest.\n\nOf course this would be ridiculously slow, so let's improve it.\nI also mentally stated that a palindrome has a recursive aspect -> if single char, or two equal chars, or charX + palindrome + charX\nSo I created a isPalindrome recursive method that checked it delegating to itself extracting the borders.\n\nSince a palindrome must start and end with the same char, in my traverse of the string, I started storing the position of each character Map<Character, List< Integer>>, so I would just go back to the previous found Char and check if from there to the current pointer I would have a Palindrome.\n\nThen I stopped doing this for every possible palindrome, I then started doing only for the ones that COULD be longer than the already found longest palindrome. That accelerated a lot.\n\nIn the almost last step, I added memoization. Remember that a palindrome is like a sandwich, with the external chars being equal and the meat being another palindrome? So I stored the found palindromes using their start and and positions. So I could check if that had already being checked and if so, either return true or false directly.\n\nThe final step was to convert the recursive function to an iterative function to save some memory used by the call stack.\nMaybe there are better implementations, just sharing my thought process."
                    },
                    {
                        "username": "tylerprill-rhdc",
                        "content": "[@tylerprill-rhdc](/tylerprill-rhdc) Two pointer based solution is also a really good solve here"
                    },
                    {
                        "username": "tylerprill-rhdc",
                        "content": "This could be done in a single pass algorithm, but will inherently check character indices multiple times based on the nature of the problem. (basically, iterate through each, then bubble out from each index)"
                    },
                    {
                        "username": "neetika",
                        "content": "From the leetcode blog, one of the methods of solving this is:\\n\\nA common mistake:\\nSome people will be tempted to come up with a quick solution, which is unfortunately flawed (however can be corrected easily):\\n\\nReverse S and become S\\u2019. Find the longest common substring between S and S\\u2019, which must also be the longest palindromic substring.\\nThis seemed to work, let\\u2019s see some examples below.\\n\\nFor example,\\nS = \\u201ccaba\\u201d, S\\u2019 = \\u201cabac\\u201d.\\nThe longest common substring between S and S\\u2019 is \\u201caba\\u201d, which is the answer.\\n\\nLet\\u2019s try another example:\\nS = \\u201cabacdfgdcaba\\u201d, S\\u2019 = \\u201cabacdgfdcaba\\u201d.\\nThe longest common substring between S and S\\u2019 is \\u201cabacd\\u201d. Clearly, this is not a valid palindrome.\\n\\n**We could see that the longest common substring method fails when there exists a reversed copy of a non-palindromic substring in some other part of S. To rectify this, each time we find a longest common substring candidate, we check if the substring\\u2019s indices are the same as the reversed substring\\u2019s original indices. If it is, then we attempt to update the longest palindrome found so far; if not, we skip this and find the next candidate.**\\n\\nIs this part correct? \\n\\nexample string: abcxycba\\nreverse string:  abcxycba\\n\\nThe substring indices are same as reversed string original indices and yet it is not a palindrome?"
                    },
                    {
                        "username": "HRVY_SNOWDEN",
                        "content": "cool sirr:)\\n"
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "WRONG.\\n\\nabcxycba reversed is abcyxcba."
                    },
                    {
                        "username": "travisl12",
                        "content": "After I solved this problem I thought it\\'d be interesting to see how it worked in realtime.\\n\\nhttps://codepen.io/TravisL12/pen/pogvweg"
                    },
                    {
                        "username": "user3907vj",
                        "content": "thanks for the \"nanananananana\" from all the small things ;)"
                    },
                    {
                        "username": "zapataast",
                        "content": "u are crazy"
                    },
                    {
                        "username": "sondq98",
                        "content": "very intuitive"
                    },
                    {
                        "username": "Tathagat017",
                        "content": "thank you\\n"
                    },
                    {
                        "username": "mikler",
                        "content": "So I think I finally understood logic of test creators. \\nEven if you write a classical DP or memorization solution for this one you will timeout on latest tests.\\nI think they consider it edge cases. Because if you add one simple line it will pass! OMG. \\nI have leet code for this. Instead of solving problems I spend hours optimizing the constants.\\n\\nif s == s[::-1]: return s"
                    },
                    {
                        "username": "Vectorido",
                        "content": "Don\\'t work already. Time limit at 141 test even with that construction."
                    },
                    {
                        "username": "deepalithakur17",
                        "content": "It will only work in python."
                    },
                    {
                        "username": "ishogbon",
                        "content": "Its memoization, not memorization "
                    },
                    {
                        "username": "84danie",
                        "content": "I submitted my solution, and received a Time Limit Exceeded on this test case:\\n\\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabcaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n\\nSo I copied and pasted the TC into a custom test case, and started to think about what I could tweak. However, I ended up accidentally hitting Run Code, but instead of getting a Time Limit Exceeded result, it passed:\\n\\n![0_1479079812693_upload-4af9e94c-2e53-4915-acf6-782780c7bf8b](/uploads/files/1479079813717-upload-4af9e94c-2e53-4915-acf6-782780c7bf8b.png) \\n\\nIs this supposed to happen and I just need to make my code more efficient, or is this a bug? \\n![0_1479079956817_upload-1ef15826-d6e6-4bde-9c06-eb597c5c8d0e](/uploads/files/1479079957639-upload-1ef15826-d6e6-4bde-9c06-eb597c5c8d0e.png)"
                    },
                    {
                        "username": "RitikaSahay",
                        "content": "Same thing happened with me. Is there a solution for it?\\n"
                    },
                    {
                        "username": "danicruz0415",
                        "content": "It\\'s happened to me a couple of times. My theory is that the time limit is given for the whole list of test cases. Thus, you can have your test pass, but it will still time limit exceed because it wont get to calculate all the test cases before the time runs out. I cannot confirm this but I think its true because with a very unoptimized solution I got time limit exceeded very early in the test cases (for another problem), after some optimizations I got it much later (like getting to the last tests) which themselves were around the same size, so if the time limit was set per test it would not make sense to fail in a similarly long test-case just that is much later in the test list. (I think the same would apply to memory limit exceeded)"
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "The exact same situation happened with me in one problem... it was a DP problem too... I was getting a Memory Limit Exceeded error with the memoized solution but it was running fine in the Run Code button."
                    },
                    {
                        "username": "Hubro",
                        "content": "I\\'m getting \"Time Limit Exceeded\" with 141/141 testcases passed and \"Last Executed Input\" is:\\n\\n```\\ns =\\n```\\n\\nDid I break it?"
                    },
                    {
                        "username": "karan_dhiman",
                        "content": "same issue"
                    },
                    {
                        "username": "BLANK-Zora",
                        "content": "exactly bro this shit is recked , like it is giving tests outside the constraints , how am i suppose to include such things in the code"
                    },
                    {
                        "username": "arunprep5",
                        "content": "same issue. java"
                    },
                    {
                        "username": "blasphelmy",
                        "content": "[@tuancoltech](/tuancoltech) it worked when i rewrote the code in c# instead of c++"
                    },
                    {
                        "username": "tuancoltech",
                        "content": "[@blasphelmy](/blasphelmy) [@Tomas Sandven](/Hubro) Did you guys find out why? I got the same issue."
                    },
                    {
                        "username": "blasphelmy",
                        "content": "i got that too. im not sure whats going on given that the constraint for input is between 1 and 1000"
                    },
                    {
                        "username": "Vinitajain",
                        "content": "Hi All,\\nI have a test case which is failing, but I feel the testcase result is incorrect.Please refer the screenshot below.\\n![image](https://assets.leetcode.com/users/images/e9e42efb-63d5-4cfa-b420-f1926674f6dc_1654838015.8394327.png)\\n\\nThe longest palindromic substring is \"aaca\" but the test case result is \"aca\". Anyone else faced this problem?"
                    },
                    {
                        "username": "OthSO",
                        "content": "[@mohdansah10](/mohdansah10) \\nthey are separated in the input with \"bd\" so it is not a valid answer "
                    },
                    {
                        "username": "mohdansah10",
                        "content": "I\\'m getting same error, but different case:\\nInput\\ns =\\n\"aacabdkacaa\"\\n\\nOutput\\n\"aacakacaa\"\\nExpected\\n\"aca\"\\n\\nBut mine is Palindrome"
                    },
                    {
                        "username": "hasmithraa",
                        "content": "the expected is correct because aaca can\\'t be a palindrome only \\'aacaa\\' can be a palindrome which is not there in your case"
                    },
                    {
                        "username": "Amish_Singh",
                        "content": "how are you considering \"aaca\" as a palindromic substring, \"aca\" is a palindrome and it is the longest"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "dude you really came up with the solution "
                    },
                    {
                        "username": "AryaAditya3609",
                        "content": "how is \"aaca\" and \"acaa\" same ???\\nWhile \"aca\" is palindrome because both \"aca\" and reverse of it \"aca\" is same !!"
                    },
                    {
                        "username": "alexandra-pickle",
                        "content": "\"aaca\" is not a palindrome"
                    },
                    {
                        "username": "bugHackerLoop",
                        "content": "I followed the approach leant by Aditya Verma DP lectures and encountered the same test case failing. Does the logic where I reverse the string and calculate the longest common substring doesn\\'t work here? I know it works for longest palindromic subsequence but here it fails for such test cases .. why is it so?"
                    },
                    {
                        "username": "mductran",
                        "content": "how is \\'aaca\\' a palindrome? when read backward it\\'s \\'acaa\\' so it\\'s not the same reading forward."
                    },
                    {
                        "username": "jnsudhir",
                        "content": "Check my solution, it was able to clear test case \"aaca\". Explained code in comments.\\n\\nhttps://leetcode.com/problems/longest-palindromic-substring/solutions/3091016/longest-palindromic-substring-using-javascript-beats-94-82-in-runtime-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "nikhileshratna",
                        "content": "aaca is not palindrome"
                    },
                    {
                        "username": "sunshine77",
                        "content": "hey, iam getting the same error, i have seen ansewrs where they have totally changed the algorithm, how did u solve this by tweaking the same algoirhtm"
                    },
                    {
                        "username": "bhupendrabc71",
                        "content": "how come \"aaca\" is palindrome. it should be \"aca\""
                    },
                    {
                        "username": "just11blocks",
                        "content": "aaca is not a palindrome...aacaa and aca are."
                    },
                    {
                        "username": "odi1n",
                        "content": "I also encountered this problem"
                    },
                    {
                        "username": "vamsi2302",
                        "content": "I think you get it by now!\\n"
                    }
                ]
            },
            {
                "id": 1573869,
                "content": [
                    {
                        "username": "ZenMasterV",
                        "content": "Seems like too many of the  coding wunderkinds here lack basic reading comprehension skills \\n\" Please don\\'t post any solutions in this discussion tab\"\\nIt\\'s almost the rule to find the exact opposite for the discussion of every question. I don\\'t want to see your damned solution!"
                    },
                    {
                        "username": "NeroXIII",
                        "content": "[@charonme](/charonme) name does not check out :((("
                    },
                    {
                        "username": "192731",
                        "content": "and if they do?"
                    },
                    {
                        "username": "plevi1995",
                        "content": "Excellent comment"
                    },
                    {
                        "username": "khan60939",
                        "content": "Can anyone tell how DP is being used here? "
                    },
                    {
                        "username": "sandagolcea",
                        "content": "[@charonme](/charonme) my thinking exactly, but at least they should create a flag to help us moderate and move solutions to the correct tab. Would only need a stack overflow moderation-like system: one person flags, another person receives a queue of flagged comments and confirms the tagging.. oh well"
                    },
                    {
                        "username": "charonme",
                        "content": "maybe people get confused by the official leetcode comment which says: \"If you\\'d like to share a detailed solution to the problem, please create a new post in the discuss section\"\\nMaybe some time ago they didn\\'t have a separate solutions section and only recently changed it, but left some of the old solutions in the discussion section and didn\\'t fix the automated comment worting?"
                    },
                    {
                        "username": "klanjewar037",
                        "content": "hehe"
                    },
                    {
                        "username": "sanemdeepak",
                        "content": "For input \"ac\" test case is expecting \"a\" as output, how is just \"a\" a palindromic string?"
                    },
                    {
                        "username": "ayushiidevpura",
                        "content": "because when we read \"a\" from forward it results in \"a\" and at the same time when we read \"a\" from backward it is still \"a\""
                    },
                    {
                        "username": "beyzigo",
                        "content": "Because if you read the string \"a\" backwards it will still be \"a\""
                    },
                    {
                        "username": "tsafackghokeng",
                        "content": "[@Chouhan_Gourav](/Chouhan_Gourav) the test case said \"ac\" not \"a\". is \"ac\" palindromic? for \"a\" i understand"
                    },
                    {
                        "username": "CODEWITHABHINAV",
                        "content": "you have to submit the first string as your answer read more about this question on gFg\\n"
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "any string is palindrome if we read it same from front and from back\\nin single character we read it same from front and back"
                    },
                    {
                        "username": "oinrup",
                        "content": "yes thats my question too"
                    },
                    {
                        "username": "yldemon",
                        "content": "Any character in the string by itself is a palindromic substring. So in the case where there is no palindromic substring with length > 1, you can return any character."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "Whenever you come accross such contradiction, just google the definition, any. Any string is called is pallindromic if the reverse of the string is equal to the original string. Reverse of \\'a\\' is \\'a\\'. Hope you get this."
                    },
                    {
                        "username": "947876275",
                        "content": "This post is for learner wanna practice DP.\\nThe basic idea is, if we wanna say \"aba\" is palindromic, then we need to firstly confirm that \"b\" is palindromic, then we also need to check if \"a\"(the first a) = \"a\" (the second a).\\n\\nM is a 2-d array which stores boolean values.\\nM[i][j] indicates if string[i.....j] is palindromic.\\nSo base cases are:\\nM[i][i] is true.\\nM[i][i + 1] = (s[i] == s[i + 1]);\\nrecurrence relation is :\\nM[i][j] = (s[i] == s[j] AND M[i + 1][j - 1]);\\nFor the implementation of recurrence relation, one idea is you can loop through all possible symmetry axis. For each of the axis, you expand at both RHS and LHS simultaneously. This method promises that when you are determining value in M[i][j], M[i + 1][j - 1] must have the correct value.\\nFinal answer can be found from all M[i][j] == 1 with largest (j - i)."
                    },
                    {
                        "username": "Msey",
                        "content": "thank you, cat brother"
                    },
                    {
                        "username": "user0558y",
                        "content": "I understand the solution but I don't understand why it needs any storage at all or why it needs to be a DP solution.\n\nThe condition `(s[i] == s[j] AND M[i + 1][j - 1])` requires you to memorise if `M[i+1][j-1]` is true, that's easy to understand. However, if you expand each possible axis at the same time, i.e. 1st iteration (s[i+1], s[j-1]), 2nd iteration `s[i+2], s[j-2]`, ... It is guaranteed that M[i+1][j-1] is always true and hence can be dropped, and you should break the loop when it is not true.\n\nIn summary, you don't need to memorise anything at all and you just need to check `s[i] == s[j]` while expanding in both directions at the same time, unless I have misunderstood anything? Here is an implementation of your algorithm but without storage: https://leetcode.com/problems/longest-palindromic-substring/submissions/868540120/"
                    },
                    {
                        "username": "taras",
                        "content": "Thank you! this is a beautiful explanation, though I\\'m not sure what exactly you mean by expanding both on LHS and RHS. In my implementation it\\'s enough to compute all diagonals of  the upper right triangle of the dp matrix."
                    },
                    {
                        "username": "klu_2100031593",
                        "content": "super explanation"
                    },
                    {
                        "username": "napoleon",
                        "content": "My Solution Is Naive, It Cost O(n^2), Is there Any Solution faster?"
                    },
                    {
                        "username": "leocampos",
                        "content": "[@tylerprill-rhdc](/tylerprill-rhdc) So, what I did was:\nStated in my mind the Brute Force approach - create every possible substring and test each one to see if is a palindrome and find the longest.\n\nOf course this would be ridiculously slow, so let's improve it.\nI also mentally stated that a palindrome has a recursive aspect -> if single char, or two equal chars, or charX + palindrome + charX\nSo I created a isPalindrome recursive method that checked it delegating to itself extracting the borders.\n\nSince a palindrome must start and end with the same char, in my traverse of the string, I started storing the position of each character Map<Character, List< Integer>>, so I would just go back to the previous found Char and check if from there to the current pointer I would have a Palindrome.\n\nThen I stopped doing this for every possible palindrome, I then started doing only for the ones that COULD be longer than the already found longest palindrome. That accelerated a lot.\n\nIn the almost last step, I added memoization. Remember that a palindrome is like a sandwich, with the external chars being equal and the meat being another palindrome? So I stored the found palindromes using their start and and positions. So I could check if that had already being checked and if so, either return true or false directly.\n\nThe final step was to convert the recursive function to an iterative function to save some memory used by the call stack.\nMaybe there are better implementations, just sharing my thought process."
                    },
                    {
                        "username": "tylerprill-rhdc",
                        "content": "[@tylerprill-rhdc](/tylerprill-rhdc) Two pointer based solution is also a really good solve here"
                    },
                    {
                        "username": "tylerprill-rhdc",
                        "content": "This could be done in a single pass algorithm, but will inherently check character indices multiple times based on the nature of the problem. (basically, iterate through each, then bubble out from each index)"
                    },
                    {
                        "username": "neetika",
                        "content": "From the leetcode blog, one of the methods of solving this is:\\n\\nA common mistake:\\nSome people will be tempted to come up with a quick solution, which is unfortunately flawed (however can be corrected easily):\\n\\nReverse S and become S\\u2019. Find the longest common substring between S and S\\u2019, which must also be the longest palindromic substring.\\nThis seemed to work, let\\u2019s see some examples below.\\n\\nFor example,\\nS = \\u201ccaba\\u201d, S\\u2019 = \\u201cabac\\u201d.\\nThe longest common substring between S and S\\u2019 is \\u201caba\\u201d, which is the answer.\\n\\nLet\\u2019s try another example:\\nS = \\u201cabacdfgdcaba\\u201d, S\\u2019 = \\u201cabacdgfdcaba\\u201d.\\nThe longest common substring between S and S\\u2019 is \\u201cabacd\\u201d. Clearly, this is not a valid palindrome.\\n\\n**We could see that the longest common substring method fails when there exists a reversed copy of a non-palindromic substring in some other part of S. To rectify this, each time we find a longest common substring candidate, we check if the substring\\u2019s indices are the same as the reversed substring\\u2019s original indices. If it is, then we attempt to update the longest palindrome found so far; if not, we skip this and find the next candidate.**\\n\\nIs this part correct? \\n\\nexample string: abcxycba\\nreverse string:  abcxycba\\n\\nThe substring indices are same as reversed string original indices and yet it is not a palindrome?"
                    },
                    {
                        "username": "HRVY_SNOWDEN",
                        "content": "cool sirr:)\\n"
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "WRONG.\\n\\nabcxycba reversed is abcyxcba."
                    },
                    {
                        "username": "travisl12",
                        "content": "After I solved this problem I thought it\\'d be interesting to see how it worked in realtime.\\n\\nhttps://codepen.io/TravisL12/pen/pogvweg"
                    },
                    {
                        "username": "user3907vj",
                        "content": "thanks for the \"nanananananana\" from all the small things ;)"
                    },
                    {
                        "username": "zapataast",
                        "content": "u are crazy"
                    },
                    {
                        "username": "sondq98",
                        "content": "very intuitive"
                    },
                    {
                        "username": "Tathagat017",
                        "content": "thank you\\n"
                    },
                    {
                        "username": "mikler",
                        "content": "So I think I finally understood logic of test creators. \\nEven if you write a classical DP or memorization solution for this one you will timeout on latest tests.\\nI think they consider it edge cases. Because if you add one simple line it will pass! OMG. \\nI have leet code for this. Instead of solving problems I spend hours optimizing the constants.\\n\\nif s == s[::-1]: return s"
                    },
                    {
                        "username": "Vectorido",
                        "content": "Don\\'t work already. Time limit at 141 test even with that construction."
                    },
                    {
                        "username": "deepalithakur17",
                        "content": "It will only work in python."
                    },
                    {
                        "username": "ishogbon",
                        "content": "Its memoization, not memorization "
                    },
                    {
                        "username": "84danie",
                        "content": "I submitted my solution, and received a Time Limit Exceeded on this test case:\\n\\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabcaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n\\nSo I copied and pasted the TC into a custom test case, and started to think about what I could tweak. However, I ended up accidentally hitting Run Code, but instead of getting a Time Limit Exceeded result, it passed:\\n\\n![0_1479079812693_upload-4af9e94c-2e53-4915-acf6-782780c7bf8b](/uploads/files/1479079813717-upload-4af9e94c-2e53-4915-acf6-782780c7bf8b.png) \\n\\nIs this supposed to happen and I just need to make my code more efficient, or is this a bug? \\n![0_1479079956817_upload-1ef15826-d6e6-4bde-9c06-eb597c5c8d0e](/uploads/files/1479079957639-upload-1ef15826-d6e6-4bde-9c06-eb597c5c8d0e.png)"
                    },
                    {
                        "username": "RitikaSahay",
                        "content": "Same thing happened with me. Is there a solution for it?\\n"
                    },
                    {
                        "username": "danicruz0415",
                        "content": "It\\'s happened to me a couple of times. My theory is that the time limit is given for the whole list of test cases. Thus, you can have your test pass, but it will still time limit exceed because it wont get to calculate all the test cases before the time runs out. I cannot confirm this but I think its true because with a very unoptimized solution I got time limit exceeded very early in the test cases (for another problem), after some optimizations I got it much later (like getting to the last tests) which themselves were around the same size, so if the time limit was set per test it would not make sense to fail in a similarly long test-case just that is much later in the test list. (I think the same would apply to memory limit exceeded)"
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "The exact same situation happened with me in one problem... it was a DP problem too... I was getting a Memory Limit Exceeded error with the memoized solution but it was running fine in the Run Code button."
                    },
                    {
                        "username": "Hubro",
                        "content": "I\\'m getting \"Time Limit Exceeded\" with 141/141 testcases passed and \"Last Executed Input\" is:\\n\\n```\\ns =\\n```\\n\\nDid I break it?"
                    },
                    {
                        "username": "karan_dhiman",
                        "content": "same issue"
                    },
                    {
                        "username": "BLANK-Zora",
                        "content": "exactly bro this shit is recked , like it is giving tests outside the constraints , how am i suppose to include such things in the code"
                    },
                    {
                        "username": "arunprep5",
                        "content": "same issue. java"
                    },
                    {
                        "username": "blasphelmy",
                        "content": "[@tuancoltech](/tuancoltech) it worked when i rewrote the code in c# instead of c++"
                    },
                    {
                        "username": "tuancoltech",
                        "content": "[@blasphelmy](/blasphelmy) [@Tomas Sandven](/Hubro) Did you guys find out why? I got the same issue."
                    },
                    {
                        "username": "blasphelmy",
                        "content": "i got that too. im not sure whats going on given that the constraint for input is between 1 and 1000"
                    },
                    {
                        "username": "Vinitajain",
                        "content": "Hi All,\\nI have a test case which is failing, but I feel the testcase result is incorrect.Please refer the screenshot below.\\n![image](https://assets.leetcode.com/users/images/e9e42efb-63d5-4cfa-b420-f1926674f6dc_1654838015.8394327.png)\\n\\nThe longest palindromic substring is \"aaca\" but the test case result is \"aca\". Anyone else faced this problem?"
                    },
                    {
                        "username": "OthSO",
                        "content": "[@mohdansah10](/mohdansah10) \\nthey are separated in the input with \"bd\" so it is not a valid answer "
                    },
                    {
                        "username": "mohdansah10",
                        "content": "I\\'m getting same error, but different case:\\nInput\\ns =\\n\"aacabdkacaa\"\\n\\nOutput\\n\"aacakacaa\"\\nExpected\\n\"aca\"\\n\\nBut mine is Palindrome"
                    },
                    {
                        "username": "hasmithraa",
                        "content": "the expected is correct because aaca can\\'t be a palindrome only \\'aacaa\\' can be a palindrome which is not there in your case"
                    },
                    {
                        "username": "Amish_Singh",
                        "content": "how are you considering \"aaca\" as a palindromic substring, \"aca\" is a palindrome and it is the longest"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "dude you really came up with the solution "
                    },
                    {
                        "username": "AryaAditya3609",
                        "content": "how is \"aaca\" and \"acaa\" same ???\\nWhile \"aca\" is palindrome because both \"aca\" and reverse of it \"aca\" is same !!"
                    },
                    {
                        "username": "alexandra-pickle",
                        "content": "\"aaca\" is not a palindrome"
                    },
                    {
                        "username": "bugHackerLoop",
                        "content": "I followed the approach leant by Aditya Verma DP lectures and encountered the same test case failing. Does the logic where I reverse the string and calculate the longest common substring doesn\\'t work here? I know it works for longest palindromic subsequence but here it fails for such test cases .. why is it so?"
                    },
                    {
                        "username": "mductran",
                        "content": "how is \\'aaca\\' a palindrome? when read backward it\\'s \\'acaa\\' so it\\'s not the same reading forward."
                    },
                    {
                        "username": "jnsudhir",
                        "content": "Check my solution, it was able to clear test case \"aaca\". Explained code in comments.\\n\\nhttps://leetcode.com/problems/longest-palindromic-substring/solutions/3091016/longest-palindromic-substring-using-javascript-beats-94-82-in-runtime-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "nikhileshratna",
                        "content": "aaca is not palindrome"
                    },
                    {
                        "username": "sunshine77",
                        "content": "hey, iam getting the same error, i have seen ansewrs where they have totally changed the algorithm, how did u solve this by tweaking the same algoirhtm"
                    },
                    {
                        "username": "bhupendrabc71",
                        "content": "how come \"aaca\" is palindrome. it should be \"aca\""
                    },
                    {
                        "username": "just11blocks",
                        "content": "aaca is not a palindrome...aacaa and aca are."
                    },
                    {
                        "username": "odi1n",
                        "content": "I also encountered this problem"
                    },
                    {
                        "username": "vamsi2302",
                        "content": "I think you get it by now!\\n"
                    }
                ]
            },
            {
                "id": 1568802,
                "content": [
                    {
                        "username": "ZenMasterV",
                        "content": "Seems like too many of the  coding wunderkinds here lack basic reading comprehension skills \\n\" Please don\\'t post any solutions in this discussion tab\"\\nIt\\'s almost the rule to find the exact opposite for the discussion of every question. I don\\'t want to see your damned solution!"
                    },
                    {
                        "username": "NeroXIII",
                        "content": "[@charonme](/charonme) name does not check out :((("
                    },
                    {
                        "username": "192731",
                        "content": "and if they do?"
                    },
                    {
                        "username": "plevi1995",
                        "content": "Excellent comment"
                    },
                    {
                        "username": "khan60939",
                        "content": "Can anyone tell how DP is being used here? "
                    },
                    {
                        "username": "sandagolcea",
                        "content": "[@charonme](/charonme) my thinking exactly, but at least they should create a flag to help us moderate and move solutions to the correct tab. Would only need a stack overflow moderation-like system: one person flags, another person receives a queue of flagged comments and confirms the tagging.. oh well"
                    },
                    {
                        "username": "charonme",
                        "content": "maybe people get confused by the official leetcode comment which says: \"If you\\'d like to share a detailed solution to the problem, please create a new post in the discuss section\"\\nMaybe some time ago they didn\\'t have a separate solutions section and only recently changed it, but left some of the old solutions in the discussion section and didn\\'t fix the automated comment worting?"
                    },
                    {
                        "username": "klanjewar037",
                        "content": "hehe"
                    },
                    {
                        "username": "sanemdeepak",
                        "content": "For input \"ac\" test case is expecting \"a\" as output, how is just \"a\" a palindromic string?"
                    },
                    {
                        "username": "ayushiidevpura",
                        "content": "because when we read \"a\" from forward it results in \"a\" and at the same time when we read \"a\" from backward it is still \"a\""
                    },
                    {
                        "username": "beyzigo",
                        "content": "Because if you read the string \"a\" backwards it will still be \"a\""
                    },
                    {
                        "username": "tsafackghokeng",
                        "content": "[@Chouhan_Gourav](/Chouhan_Gourav) the test case said \"ac\" not \"a\". is \"ac\" palindromic? for \"a\" i understand"
                    },
                    {
                        "username": "CODEWITHABHINAV",
                        "content": "you have to submit the first string as your answer read more about this question on gFg\\n"
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "any string is palindrome if we read it same from front and from back\\nin single character we read it same from front and back"
                    },
                    {
                        "username": "oinrup",
                        "content": "yes thats my question too"
                    },
                    {
                        "username": "yldemon",
                        "content": "Any character in the string by itself is a palindromic substring. So in the case where there is no palindromic substring with length > 1, you can return any character."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "Whenever you come accross such contradiction, just google the definition, any. Any string is called is pallindromic if the reverse of the string is equal to the original string. Reverse of \\'a\\' is \\'a\\'. Hope you get this."
                    },
                    {
                        "username": "947876275",
                        "content": "This post is for learner wanna practice DP.\\nThe basic idea is, if we wanna say \"aba\" is palindromic, then we need to firstly confirm that \"b\" is palindromic, then we also need to check if \"a\"(the first a) = \"a\" (the second a).\\n\\nM is a 2-d array which stores boolean values.\\nM[i][j] indicates if string[i.....j] is palindromic.\\nSo base cases are:\\nM[i][i] is true.\\nM[i][i + 1] = (s[i] == s[i + 1]);\\nrecurrence relation is :\\nM[i][j] = (s[i] == s[j] AND M[i + 1][j - 1]);\\nFor the implementation of recurrence relation, one idea is you can loop through all possible symmetry axis. For each of the axis, you expand at both RHS and LHS simultaneously. This method promises that when you are determining value in M[i][j], M[i + 1][j - 1] must have the correct value.\\nFinal answer can be found from all M[i][j] == 1 with largest (j - i)."
                    },
                    {
                        "username": "Msey",
                        "content": "thank you, cat brother"
                    },
                    {
                        "username": "user0558y",
                        "content": "I understand the solution but I don't understand why it needs any storage at all or why it needs to be a DP solution.\n\nThe condition `(s[i] == s[j] AND M[i + 1][j - 1])` requires you to memorise if `M[i+1][j-1]` is true, that's easy to understand. However, if you expand each possible axis at the same time, i.e. 1st iteration (s[i+1], s[j-1]), 2nd iteration `s[i+2], s[j-2]`, ... It is guaranteed that M[i+1][j-1] is always true and hence can be dropped, and you should break the loop when it is not true.\n\nIn summary, you don't need to memorise anything at all and you just need to check `s[i] == s[j]` while expanding in both directions at the same time, unless I have misunderstood anything? Here is an implementation of your algorithm but without storage: https://leetcode.com/problems/longest-palindromic-substring/submissions/868540120/"
                    },
                    {
                        "username": "taras",
                        "content": "Thank you! this is a beautiful explanation, though I\\'m not sure what exactly you mean by expanding both on LHS and RHS. In my implementation it\\'s enough to compute all diagonals of  the upper right triangle of the dp matrix."
                    },
                    {
                        "username": "klu_2100031593",
                        "content": "super explanation"
                    },
                    {
                        "username": "napoleon",
                        "content": "My Solution Is Naive, It Cost O(n^2), Is there Any Solution faster?"
                    },
                    {
                        "username": "leocampos",
                        "content": "[@tylerprill-rhdc](/tylerprill-rhdc) So, what I did was:\nStated in my mind the Brute Force approach - create every possible substring and test each one to see if is a palindrome and find the longest.\n\nOf course this would be ridiculously slow, so let's improve it.\nI also mentally stated that a palindrome has a recursive aspect -> if single char, or two equal chars, or charX + palindrome + charX\nSo I created a isPalindrome recursive method that checked it delegating to itself extracting the borders.\n\nSince a palindrome must start and end with the same char, in my traverse of the string, I started storing the position of each character Map<Character, List< Integer>>, so I would just go back to the previous found Char and check if from there to the current pointer I would have a Palindrome.\n\nThen I stopped doing this for every possible palindrome, I then started doing only for the ones that COULD be longer than the already found longest palindrome. That accelerated a lot.\n\nIn the almost last step, I added memoization. Remember that a palindrome is like a sandwich, with the external chars being equal and the meat being another palindrome? So I stored the found palindromes using their start and and positions. So I could check if that had already being checked and if so, either return true or false directly.\n\nThe final step was to convert the recursive function to an iterative function to save some memory used by the call stack.\nMaybe there are better implementations, just sharing my thought process."
                    },
                    {
                        "username": "tylerprill-rhdc",
                        "content": "[@tylerprill-rhdc](/tylerprill-rhdc) Two pointer based solution is also a really good solve here"
                    },
                    {
                        "username": "tylerprill-rhdc",
                        "content": "This could be done in a single pass algorithm, but will inherently check character indices multiple times based on the nature of the problem. (basically, iterate through each, then bubble out from each index)"
                    },
                    {
                        "username": "neetika",
                        "content": "From the leetcode blog, one of the methods of solving this is:\\n\\nA common mistake:\\nSome people will be tempted to come up with a quick solution, which is unfortunately flawed (however can be corrected easily):\\n\\nReverse S and become S\\u2019. Find the longest common substring between S and S\\u2019, which must also be the longest palindromic substring.\\nThis seemed to work, let\\u2019s see some examples below.\\n\\nFor example,\\nS = \\u201ccaba\\u201d, S\\u2019 = \\u201cabac\\u201d.\\nThe longest common substring between S and S\\u2019 is \\u201caba\\u201d, which is the answer.\\n\\nLet\\u2019s try another example:\\nS = \\u201cabacdfgdcaba\\u201d, S\\u2019 = \\u201cabacdgfdcaba\\u201d.\\nThe longest common substring between S and S\\u2019 is \\u201cabacd\\u201d. Clearly, this is not a valid palindrome.\\n\\n**We could see that the longest common substring method fails when there exists a reversed copy of a non-palindromic substring in some other part of S. To rectify this, each time we find a longest common substring candidate, we check if the substring\\u2019s indices are the same as the reversed substring\\u2019s original indices. If it is, then we attempt to update the longest palindrome found so far; if not, we skip this and find the next candidate.**\\n\\nIs this part correct? \\n\\nexample string: abcxycba\\nreverse string:  abcxycba\\n\\nThe substring indices are same as reversed string original indices and yet it is not a palindrome?"
                    },
                    {
                        "username": "HRVY_SNOWDEN",
                        "content": "cool sirr:)\\n"
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "WRONG.\\n\\nabcxycba reversed is abcyxcba."
                    },
                    {
                        "username": "travisl12",
                        "content": "After I solved this problem I thought it\\'d be interesting to see how it worked in realtime.\\n\\nhttps://codepen.io/TravisL12/pen/pogvweg"
                    },
                    {
                        "username": "user3907vj",
                        "content": "thanks for the \"nanananananana\" from all the small things ;)"
                    },
                    {
                        "username": "zapataast",
                        "content": "u are crazy"
                    },
                    {
                        "username": "sondq98",
                        "content": "very intuitive"
                    },
                    {
                        "username": "Tathagat017",
                        "content": "thank you\\n"
                    },
                    {
                        "username": "mikler",
                        "content": "So I think I finally understood logic of test creators. \\nEven if you write a classical DP or memorization solution for this one you will timeout on latest tests.\\nI think they consider it edge cases. Because if you add one simple line it will pass! OMG. \\nI have leet code for this. Instead of solving problems I spend hours optimizing the constants.\\n\\nif s == s[::-1]: return s"
                    },
                    {
                        "username": "Vectorido",
                        "content": "Don\\'t work already. Time limit at 141 test even with that construction."
                    },
                    {
                        "username": "deepalithakur17",
                        "content": "It will only work in python."
                    },
                    {
                        "username": "ishogbon",
                        "content": "Its memoization, not memorization "
                    },
                    {
                        "username": "84danie",
                        "content": "I submitted my solution, and received a Time Limit Exceeded on this test case:\\n\\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabcaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n\\nSo I copied and pasted the TC into a custom test case, and started to think about what I could tweak. However, I ended up accidentally hitting Run Code, but instead of getting a Time Limit Exceeded result, it passed:\\n\\n![0_1479079812693_upload-4af9e94c-2e53-4915-acf6-782780c7bf8b](/uploads/files/1479079813717-upload-4af9e94c-2e53-4915-acf6-782780c7bf8b.png) \\n\\nIs this supposed to happen and I just need to make my code more efficient, or is this a bug? \\n![0_1479079956817_upload-1ef15826-d6e6-4bde-9c06-eb597c5c8d0e](/uploads/files/1479079957639-upload-1ef15826-d6e6-4bde-9c06-eb597c5c8d0e.png)"
                    },
                    {
                        "username": "RitikaSahay",
                        "content": "Same thing happened with me. Is there a solution for it?\\n"
                    },
                    {
                        "username": "danicruz0415",
                        "content": "It\\'s happened to me a couple of times. My theory is that the time limit is given for the whole list of test cases. Thus, you can have your test pass, but it will still time limit exceed because it wont get to calculate all the test cases before the time runs out. I cannot confirm this but I think its true because with a very unoptimized solution I got time limit exceeded very early in the test cases (for another problem), after some optimizations I got it much later (like getting to the last tests) which themselves were around the same size, so if the time limit was set per test it would not make sense to fail in a similarly long test-case just that is much later in the test list. (I think the same would apply to memory limit exceeded)"
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "The exact same situation happened with me in one problem... it was a DP problem too... I was getting a Memory Limit Exceeded error with the memoized solution but it was running fine in the Run Code button."
                    },
                    {
                        "username": "Hubro",
                        "content": "I\\'m getting \"Time Limit Exceeded\" with 141/141 testcases passed and \"Last Executed Input\" is:\\n\\n```\\ns =\\n```\\n\\nDid I break it?"
                    },
                    {
                        "username": "karan_dhiman",
                        "content": "same issue"
                    },
                    {
                        "username": "BLANK-Zora",
                        "content": "exactly bro this shit is recked , like it is giving tests outside the constraints , how am i suppose to include such things in the code"
                    },
                    {
                        "username": "arunprep5",
                        "content": "same issue. java"
                    },
                    {
                        "username": "blasphelmy",
                        "content": "[@tuancoltech](/tuancoltech) it worked when i rewrote the code in c# instead of c++"
                    },
                    {
                        "username": "tuancoltech",
                        "content": "[@blasphelmy](/blasphelmy) [@Tomas Sandven](/Hubro) Did you guys find out why? I got the same issue."
                    },
                    {
                        "username": "blasphelmy",
                        "content": "i got that too. im not sure whats going on given that the constraint for input is between 1 and 1000"
                    },
                    {
                        "username": "Vinitajain",
                        "content": "Hi All,\\nI have a test case which is failing, but I feel the testcase result is incorrect.Please refer the screenshot below.\\n![image](https://assets.leetcode.com/users/images/e9e42efb-63d5-4cfa-b420-f1926674f6dc_1654838015.8394327.png)\\n\\nThe longest palindromic substring is \"aaca\" but the test case result is \"aca\". Anyone else faced this problem?"
                    },
                    {
                        "username": "OthSO",
                        "content": "[@mohdansah10](/mohdansah10) \\nthey are separated in the input with \"bd\" so it is not a valid answer "
                    },
                    {
                        "username": "mohdansah10",
                        "content": "I\\'m getting same error, but different case:\\nInput\\ns =\\n\"aacabdkacaa\"\\n\\nOutput\\n\"aacakacaa\"\\nExpected\\n\"aca\"\\n\\nBut mine is Palindrome"
                    },
                    {
                        "username": "hasmithraa",
                        "content": "the expected is correct because aaca can\\'t be a palindrome only \\'aacaa\\' can be a palindrome which is not there in your case"
                    },
                    {
                        "username": "Amish_Singh",
                        "content": "how are you considering \"aaca\" as a palindromic substring, \"aca\" is a palindrome and it is the longest"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "dude you really came up with the solution "
                    },
                    {
                        "username": "AryaAditya3609",
                        "content": "how is \"aaca\" and \"acaa\" same ???\\nWhile \"aca\" is palindrome because both \"aca\" and reverse of it \"aca\" is same !!"
                    },
                    {
                        "username": "alexandra-pickle",
                        "content": "\"aaca\" is not a palindrome"
                    },
                    {
                        "username": "bugHackerLoop",
                        "content": "I followed the approach leant by Aditya Verma DP lectures and encountered the same test case failing. Does the logic where I reverse the string and calculate the longest common substring doesn\\'t work here? I know it works for longest palindromic subsequence but here it fails for such test cases .. why is it so?"
                    },
                    {
                        "username": "mductran",
                        "content": "how is \\'aaca\\' a palindrome? when read backward it\\'s \\'acaa\\' so it\\'s not the same reading forward."
                    },
                    {
                        "username": "jnsudhir",
                        "content": "Check my solution, it was able to clear test case \"aaca\". Explained code in comments.\\n\\nhttps://leetcode.com/problems/longest-palindromic-substring/solutions/3091016/longest-palindromic-substring-using-javascript-beats-94-82-in-runtime-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "nikhileshratna",
                        "content": "aaca is not palindrome"
                    },
                    {
                        "username": "sunshine77",
                        "content": "hey, iam getting the same error, i have seen ansewrs where they have totally changed the algorithm, how did u solve this by tweaking the same algoirhtm"
                    },
                    {
                        "username": "bhupendrabc71",
                        "content": "how come \"aaca\" is palindrome. it should be \"aca\""
                    },
                    {
                        "username": "just11blocks",
                        "content": "aaca is not a palindrome...aacaa and aca are."
                    },
                    {
                        "username": "odi1n",
                        "content": "I also encountered this problem"
                    },
                    {
                        "username": "vamsi2302",
                        "content": "I think you get it by now!\\n"
                    }
                ]
            },
            {
                "id": 1570975,
                "content": [
                    {
                        "username": "ZenMasterV",
                        "content": "Seems like too many of the  coding wunderkinds here lack basic reading comprehension skills \\n\" Please don\\'t post any solutions in this discussion tab\"\\nIt\\'s almost the rule to find the exact opposite for the discussion of every question. I don\\'t want to see your damned solution!"
                    },
                    {
                        "username": "NeroXIII",
                        "content": "[@charonme](/charonme) name does not check out :((("
                    },
                    {
                        "username": "192731",
                        "content": "and if they do?"
                    },
                    {
                        "username": "plevi1995",
                        "content": "Excellent comment"
                    },
                    {
                        "username": "khan60939",
                        "content": "Can anyone tell how DP is being used here? "
                    },
                    {
                        "username": "sandagolcea",
                        "content": "[@charonme](/charonme) my thinking exactly, but at least they should create a flag to help us moderate and move solutions to the correct tab. Would only need a stack overflow moderation-like system: one person flags, another person receives a queue of flagged comments and confirms the tagging.. oh well"
                    },
                    {
                        "username": "charonme",
                        "content": "maybe people get confused by the official leetcode comment which says: \"If you\\'d like to share a detailed solution to the problem, please create a new post in the discuss section\"\\nMaybe some time ago they didn\\'t have a separate solutions section and only recently changed it, but left some of the old solutions in the discussion section and didn\\'t fix the automated comment worting?"
                    },
                    {
                        "username": "klanjewar037",
                        "content": "hehe"
                    },
                    {
                        "username": "sanemdeepak",
                        "content": "For input \"ac\" test case is expecting \"a\" as output, how is just \"a\" a palindromic string?"
                    },
                    {
                        "username": "ayushiidevpura",
                        "content": "because when we read \"a\" from forward it results in \"a\" and at the same time when we read \"a\" from backward it is still \"a\""
                    },
                    {
                        "username": "beyzigo",
                        "content": "Because if you read the string \"a\" backwards it will still be \"a\""
                    },
                    {
                        "username": "tsafackghokeng",
                        "content": "[@Chouhan_Gourav](/Chouhan_Gourav) the test case said \"ac\" not \"a\". is \"ac\" palindromic? for \"a\" i understand"
                    },
                    {
                        "username": "CODEWITHABHINAV",
                        "content": "you have to submit the first string as your answer read more about this question on gFg\\n"
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "any string is palindrome if we read it same from front and from back\\nin single character we read it same from front and back"
                    },
                    {
                        "username": "oinrup",
                        "content": "yes thats my question too"
                    },
                    {
                        "username": "yldemon",
                        "content": "Any character in the string by itself is a palindromic substring. So in the case where there is no palindromic substring with length > 1, you can return any character."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "Whenever you come accross such contradiction, just google the definition, any. Any string is called is pallindromic if the reverse of the string is equal to the original string. Reverse of \\'a\\' is \\'a\\'. Hope you get this."
                    },
                    {
                        "username": "947876275",
                        "content": "This post is for learner wanna practice DP.\\nThe basic idea is, if we wanna say \"aba\" is palindromic, then we need to firstly confirm that \"b\" is palindromic, then we also need to check if \"a\"(the first a) = \"a\" (the second a).\\n\\nM is a 2-d array which stores boolean values.\\nM[i][j] indicates if string[i.....j] is palindromic.\\nSo base cases are:\\nM[i][i] is true.\\nM[i][i + 1] = (s[i] == s[i + 1]);\\nrecurrence relation is :\\nM[i][j] = (s[i] == s[j] AND M[i + 1][j - 1]);\\nFor the implementation of recurrence relation, one idea is you can loop through all possible symmetry axis. For each of the axis, you expand at both RHS and LHS simultaneously. This method promises that when you are determining value in M[i][j], M[i + 1][j - 1] must have the correct value.\\nFinal answer can be found from all M[i][j] == 1 with largest (j - i)."
                    },
                    {
                        "username": "Msey",
                        "content": "thank you, cat brother"
                    },
                    {
                        "username": "user0558y",
                        "content": "I understand the solution but I don't understand why it needs any storage at all or why it needs to be a DP solution.\n\nThe condition `(s[i] == s[j] AND M[i + 1][j - 1])` requires you to memorise if `M[i+1][j-1]` is true, that's easy to understand. However, if you expand each possible axis at the same time, i.e. 1st iteration (s[i+1], s[j-1]), 2nd iteration `s[i+2], s[j-2]`, ... It is guaranteed that M[i+1][j-1] is always true and hence can be dropped, and you should break the loop when it is not true.\n\nIn summary, you don't need to memorise anything at all and you just need to check `s[i] == s[j]` while expanding in both directions at the same time, unless I have misunderstood anything? Here is an implementation of your algorithm but without storage: https://leetcode.com/problems/longest-palindromic-substring/submissions/868540120/"
                    },
                    {
                        "username": "taras",
                        "content": "Thank you! this is a beautiful explanation, though I\\'m not sure what exactly you mean by expanding both on LHS and RHS. In my implementation it\\'s enough to compute all diagonals of  the upper right triangle of the dp matrix."
                    },
                    {
                        "username": "klu_2100031593",
                        "content": "super explanation"
                    },
                    {
                        "username": "napoleon",
                        "content": "My Solution Is Naive, It Cost O(n^2), Is there Any Solution faster?"
                    },
                    {
                        "username": "leocampos",
                        "content": "[@tylerprill-rhdc](/tylerprill-rhdc) So, what I did was:\nStated in my mind the Brute Force approach - create every possible substring and test each one to see if is a palindrome and find the longest.\n\nOf course this would be ridiculously slow, so let's improve it.\nI also mentally stated that a palindrome has a recursive aspect -> if single char, or two equal chars, or charX + palindrome + charX\nSo I created a isPalindrome recursive method that checked it delegating to itself extracting the borders.\n\nSince a palindrome must start and end with the same char, in my traverse of the string, I started storing the position of each character Map<Character, List< Integer>>, so I would just go back to the previous found Char and check if from there to the current pointer I would have a Palindrome.\n\nThen I stopped doing this for every possible palindrome, I then started doing only for the ones that COULD be longer than the already found longest palindrome. That accelerated a lot.\n\nIn the almost last step, I added memoization. Remember that a palindrome is like a sandwich, with the external chars being equal and the meat being another palindrome? So I stored the found palindromes using their start and and positions. So I could check if that had already being checked and if so, either return true or false directly.\n\nThe final step was to convert the recursive function to an iterative function to save some memory used by the call stack.\nMaybe there are better implementations, just sharing my thought process."
                    },
                    {
                        "username": "tylerprill-rhdc",
                        "content": "[@tylerprill-rhdc](/tylerprill-rhdc) Two pointer based solution is also a really good solve here"
                    },
                    {
                        "username": "tylerprill-rhdc",
                        "content": "This could be done in a single pass algorithm, but will inherently check character indices multiple times based on the nature of the problem. (basically, iterate through each, then bubble out from each index)"
                    },
                    {
                        "username": "neetika",
                        "content": "From the leetcode blog, one of the methods of solving this is:\\n\\nA common mistake:\\nSome people will be tempted to come up with a quick solution, which is unfortunately flawed (however can be corrected easily):\\n\\nReverse S and become S\\u2019. Find the longest common substring between S and S\\u2019, which must also be the longest palindromic substring.\\nThis seemed to work, let\\u2019s see some examples below.\\n\\nFor example,\\nS = \\u201ccaba\\u201d, S\\u2019 = \\u201cabac\\u201d.\\nThe longest common substring between S and S\\u2019 is \\u201caba\\u201d, which is the answer.\\n\\nLet\\u2019s try another example:\\nS = \\u201cabacdfgdcaba\\u201d, S\\u2019 = \\u201cabacdgfdcaba\\u201d.\\nThe longest common substring between S and S\\u2019 is \\u201cabacd\\u201d. Clearly, this is not a valid palindrome.\\n\\n**We could see that the longest common substring method fails when there exists a reversed copy of a non-palindromic substring in some other part of S. To rectify this, each time we find a longest common substring candidate, we check if the substring\\u2019s indices are the same as the reversed substring\\u2019s original indices. If it is, then we attempt to update the longest palindrome found so far; if not, we skip this and find the next candidate.**\\n\\nIs this part correct? \\n\\nexample string: abcxycba\\nreverse string:  abcxycba\\n\\nThe substring indices are same as reversed string original indices and yet it is not a palindrome?"
                    },
                    {
                        "username": "HRVY_SNOWDEN",
                        "content": "cool sirr:)\\n"
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "WRONG.\\n\\nabcxycba reversed is abcyxcba."
                    },
                    {
                        "username": "travisl12",
                        "content": "After I solved this problem I thought it\\'d be interesting to see how it worked in realtime.\\n\\nhttps://codepen.io/TravisL12/pen/pogvweg"
                    },
                    {
                        "username": "user3907vj",
                        "content": "thanks for the \"nanananananana\" from all the small things ;)"
                    },
                    {
                        "username": "zapataast",
                        "content": "u are crazy"
                    },
                    {
                        "username": "sondq98",
                        "content": "very intuitive"
                    },
                    {
                        "username": "Tathagat017",
                        "content": "thank you\\n"
                    },
                    {
                        "username": "mikler",
                        "content": "So I think I finally understood logic of test creators. \\nEven if you write a classical DP or memorization solution for this one you will timeout on latest tests.\\nI think they consider it edge cases. Because if you add one simple line it will pass! OMG. \\nI have leet code for this. Instead of solving problems I spend hours optimizing the constants.\\n\\nif s == s[::-1]: return s"
                    },
                    {
                        "username": "Vectorido",
                        "content": "Don\\'t work already. Time limit at 141 test even with that construction."
                    },
                    {
                        "username": "deepalithakur17",
                        "content": "It will only work in python."
                    },
                    {
                        "username": "ishogbon",
                        "content": "Its memoization, not memorization "
                    },
                    {
                        "username": "84danie",
                        "content": "I submitted my solution, and received a Time Limit Exceeded on this test case:\\n\\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabcaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n\\nSo I copied and pasted the TC into a custom test case, and started to think about what I could tweak. However, I ended up accidentally hitting Run Code, but instead of getting a Time Limit Exceeded result, it passed:\\n\\n![0_1479079812693_upload-4af9e94c-2e53-4915-acf6-782780c7bf8b](/uploads/files/1479079813717-upload-4af9e94c-2e53-4915-acf6-782780c7bf8b.png) \\n\\nIs this supposed to happen and I just need to make my code more efficient, or is this a bug? \\n![0_1479079956817_upload-1ef15826-d6e6-4bde-9c06-eb597c5c8d0e](/uploads/files/1479079957639-upload-1ef15826-d6e6-4bde-9c06-eb597c5c8d0e.png)"
                    },
                    {
                        "username": "RitikaSahay",
                        "content": "Same thing happened with me. Is there a solution for it?\\n"
                    },
                    {
                        "username": "danicruz0415",
                        "content": "It\\'s happened to me a couple of times. My theory is that the time limit is given for the whole list of test cases. Thus, you can have your test pass, but it will still time limit exceed because it wont get to calculate all the test cases before the time runs out. I cannot confirm this but I think its true because with a very unoptimized solution I got time limit exceeded very early in the test cases (for another problem), after some optimizations I got it much later (like getting to the last tests) which themselves were around the same size, so if the time limit was set per test it would not make sense to fail in a similarly long test-case just that is much later in the test list. (I think the same would apply to memory limit exceeded)"
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "The exact same situation happened with me in one problem... it was a DP problem too... I was getting a Memory Limit Exceeded error with the memoized solution but it was running fine in the Run Code button."
                    },
                    {
                        "username": "Hubro",
                        "content": "I\\'m getting \"Time Limit Exceeded\" with 141/141 testcases passed and \"Last Executed Input\" is:\\n\\n```\\ns =\\n```\\n\\nDid I break it?"
                    },
                    {
                        "username": "karan_dhiman",
                        "content": "same issue"
                    },
                    {
                        "username": "BLANK-Zora",
                        "content": "exactly bro this shit is recked , like it is giving tests outside the constraints , how am i suppose to include such things in the code"
                    },
                    {
                        "username": "arunprep5",
                        "content": "same issue. java"
                    },
                    {
                        "username": "blasphelmy",
                        "content": "[@tuancoltech](/tuancoltech) it worked when i rewrote the code in c# instead of c++"
                    },
                    {
                        "username": "tuancoltech",
                        "content": "[@blasphelmy](/blasphelmy) [@Tomas Sandven](/Hubro) Did you guys find out why? I got the same issue."
                    },
                    {
                        "username": "blasphelmy",
                        "content": "i got that too. im not sure whats going on given that the constraint for input is between 1 and 1000"
                    },
                    {
                        "username": "Vinitajain",
                        "content": "Hi All,\\nI have a test case which is failing, but I feel the testcase result is incorrect.Please refer the screenshot below.\\n![image](https://assets.leetcode.com/users/images/e9e42efb-63d5-4cfa-b420-f1926674f6dc_1654838015.8394327.png)\\n\\nThe longest palindromic substring is \"aaca\" but the test case result is \"aca\". Anyone else faced this problem?"
                    },
                    {
                        "username": "OthSO",
                        "content": "[@mohdansah10](/mohdansah10) \\nthey are separated in the input with \"bd\" so it is not a valid answer "
                    },
                    {
                        "username": "mohdansah10",
                        "content": "I\\'m getting same error, but different case:\\nInput\\ns =\\n\"aacabdkacaa\"\\n\\nOutput\\n\"aacakacaa\"\\nExpected\\n\"aca\"\\n\\nBut mine is Palindrome"
                    },
                    {
                        "username": "hasmithraa",
                        "content": "the expected is correct because aaca can\\'t be a palindrome only \\'aacaa\\' can be a palindrome which is not there in your case"
                    },
                    {
                        "username": "Amish_Singh",
                        "content": "how are you considering \"aaca\" as a palindromic substring, \"aca\" is a palindrome and it is the longest"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "dude you really came up with the solution "
                    },
                    {
                        "username": "AryaAditya3609",
                        "content": "how is \"aaca\" and \"acaa\" same ???\\nWhile \"aca\" is palindrome because both \"aca\" and reverse of it \"aca\" is same !!"
                    },
                    {
                        "username": "alexandra-pickle",
                        "content": "\"aaca\" is not a palindrome"
                    },
                    {
                        "username": "bugHackerLoop",
                        "content": "I followed the approach leant by Aditya Verma DP lectures and encountered the same test case failing. Does the logic where I reverse the string and calculate the longest common substring doesn\\'t work here? I know it works for longest palindromic subsequence but here it fails for such test cases .. why is it so?"
                    },
                    {
                        "username": "mductran",
                        "content": "how is \\'aaca\\' a palindrome? when read backward it\\'s \\'acaa\\' so it\\'s not the same reading forward."
                    },
                    {
                        "username": "jnsudhir",
                        "content": "Check my solution, it was able to clear test case \"aaca\". Explained code in comments.\\n\\nhttps://leetcode.com/problems/longest-palindromic-substring/solutions/3091016/longest-palindromic-substring-using-javascript-beats-94-82-in-runtime-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "nikhileshratna",
                        "content": "aaca is not palindrome"
                    },
                    {
                        "username": "sunshine77",
                        "content": "hey, iam getting the same error, i have seen ansewrs where they have totally changed the algorithm, how did u solve this by tweaking the same algoirhtm"
                    },
                    {
                        "username": "bhupendrabc71",
                        "content": "how come \"aaca\" is palindrome. it should be \"aca\""
                    },
                    {
                        "username": "just11blocks",
                        "content": "aaca is not a palindrome...aacaa and aca are."
                    },
                    {
                        "username": "odi1n",
                        "content": "I also encountered this problem"
                    },
                    {
                        "username": "vamsi2302",
                        "content": "I think you get it by now!\\n"
                    }
                ]
            },
            {
                "id": 1873701,
                "content": [
                    {
                        "username": "ZenMasterV",
                        "content": "Seems like too many of the  coding wunderkinds here lack basic reading comprehension skills \\n\" Please don\\'t post any solutions in this discussion tab\"\\nIt\\'s almost the rule to find the exact opposite for the discussion of every question. I don\\'t want to see your damned solution!"
                    },
                    {
                        "username": "NeroXIII",
                        "content": "[@charonme](/charonme) name does not check out :((("
                    },
                    {
                        "username": "192731",
                        "content": "and if they do?"
                    },
                    {
                        "username": "plevi1995",
                        "content": "Excellent comment"
                    },
                    {
                        "username": "khan60939",
                        "content": "Can anyone tell how DP is being used here? "
                    },
                    {
                        "username": "sandagolcea",
                        "content": "[@charonme](/charonme) my thinking exactly, but at least they should create a flag to help us moderate and move solutions to the correct tab. Would only need a stack overflow moderation-like system: one person flags, another person receives a queue of flagged comments and confirms the tagging.. oh well"
                    },
                    {
                        "username": "charonme",
                        "content": "maybe people get confused by the official leetcode comment which says: \"If you\\'d like to share a detailed solution to the problem, please create a new post in the discuss section\"\\nMaybe some time ago they didn\\'t have a separate solutions section and only recently changed it, but left some of the old solutions in the discussion section and didn\\'t fix the automated comment worting?"
                    },
                    {
                        "username": "klanjewar037",
                        "content": "hehe"
                    },
                    {
                        "username": "sanemdeepak",
                        "content": "For input \"ac\" test case is expecting \"a\" as output, how is just \"a\" a palindromic string?"
                    },
                    {
                        "username": "ayushiidevpura",
                        "content": "because when we read \"a\" from forward it results in \"a\" and at the same time when we read \"a\" from backward it is still \"a\""
                    },
                    {
                        "username": "beyzigo",
                        "content": "Because if you read the string \"a\" backwards it will still be \"a\""
                    },
                    {
                        "username": "tsafackghokeng",
                        "content": "[@Chouhan_Gourav](/Chouhan_Gourav) the test case said \"ac\" not \"a\". is \"ac\" palindromic? for \"a\" i understand"
                    },
                    {
                        "username": "CODEWITHABHINAV",
                        "content": "you have to submit the first string as your answer read more about this question on gFg\\n"
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "any string is palindrome if we read it same from front and from back\\nin single character we read it same from front and back"
                    },
                    {
                        "username": "oinrup",
                        "content": "yes thats my question too"
                    },
                    {
                        "username": "yldemon",
                        "content": "Any character in the string by itself is a palindromic substring. So in the case where there is no palindromic substring with length > 1, you can return any character."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "Whenever you come accross such contradiction, just google the definition, any. Any string is called is pallindromic if the reverse of the string is equal to the original string. Reverse of \\'a\\' is \\'a\\'. Hope you get this."
                    },
                    {
                        "username": "947876275",
                        "content": "This post is for learner wanna practice DP.\\nThe basic idea is, if we wanna say \"aba\" is palindromic, then we need to firstly confirm that \"b\" is palindromic, then we also need to check if \"a\"(the first a) = \"a\" (the second a).\\n\\nM is a 2-d array which stores boolean values.\\nM[i][j] indicates if string[i.....j] is palindromic.\\nSo base cases are:\\nM[i][i] is true.\\nM[i][i + 1] = (s[i] == s[i + 1]);\\nrecurrence relation is :\\nM[i][j] = (s[i] == s[j] AND M[i + 1][j - 1]);\\nFor the implementation of recurrence relation, one idea is you can loop through all possible symmetry axis. For each of the axis, you expand at both RHS and LHS simultaneously. This method promises that when you are determining value in M[i][j], M[i + 1][j - 1] must have the correct value.\\nFinal answer can be found from all M[i][j] == 1 with largest (j - i)."
                    },
                    {
                        "username": "Msey",
                        "content": "thank you, cat brother"
                    },
                    {
                        "username": "user0558y",
                        "content": "I understand the solution but I don't understand why it needs any storage at all or why it needs to be a DP solution.\n\nThe condition `(s[i] == s[j] AND M[i + 1][j - 1])` requires you to memorise if `M[i+1][j-1]` is true, that's easy to understand. However, if you expand each possible axis at the same time, i.e. 1st iteration (s[i+1], s[j-1]), 2nd iteration `s[i+2], s[j-2]`, ... It is guaranteed that M[i+1][j-1] is always true and hence can be dropped, and you should break the loop when it is not true.\n\nIn summary, you don't need to memorise anything at all and you just need to check `s[i] == s[j]` while expanding in both directions at the same time, unless I have misunderstood anything? Here is an implementation of your algorithm but without storage: https://leetcode.com/problems/longest-palindromic-substring/submissions/868540120/"
                    },
                    {
                        "username": "taras",
                        "content": "Thank you! this is a beautiful explanation, though I\\'m not sure what exactly you mean by expanding both on LHS and RHS. In my implementation it\\'s enough to compute all diagonals of  the upper right triangle of the dp matrix."
                    },
                    {
                        "username": "klu_2100031593",
                        "content": "super explanation"
                    },
                    {
                        "username": "napoleon",
                        "content": "My Solution Is Naive, It Cost O(n^2), Is there Any Solution faster?"
                    },
                    {
                        "username": "leocampos",
                        "content": "[@tylerprill-rhdc](/tylerprill-rhdc) So, what I did was:\nStated in my mind the Brute Force approach - create every possible substring and test each one to see if is a palindrome and find the longest.\n\nOf course this would be ridiculously slow, so let's improve it.\nI also mentally stated that a palindrome has a recursive aspect -> if single char, or two equal chars, or charX + palindrome + charX\nSo I created a isPalindrome recursive method that checked it delegating to itself extracting the borders.\n\nSince a palindrome must start and end with the same char, in my traverse of the string, I started storing the position of each character Map<Character, List< Integer>>, so I would just go back to the previous found Char and check if from there to the current pointer I would have a Palindrome.\n\nThen I stopped doing this for every possible palindrome, I then started doing only for the ones that COULD be longer than the already found longest palindrome. That accelerated a lot.\n\nIn the almost last step, I added memoization. Remember that a palindrome is like a sandwich, with the external chars being equal and the meat being another palindrome? So I stored the found palindromes using their start and and positions. So I could check if that had already being checked and if so, either return true or false directly.\n\nThe final step was to convert the recursive function to an iterative function to save some memory used by the call stack.\nMaybe there are better implementations, just sharing my thought process."
                    },
                    {
                        "username": "tylerprill-rhdc",
                        "content": "[@tylerprill-rhdc](/tylerprill-rhdc) Two pointer based solution is also a really good solve here"
                    },
                    {
                        "username": "tylerprill-rhdc",
                        "content": "This could be done in a single pass algorithm, but will inherently check character indices multiple times based on the nature of the problem. (basically, iterate through each, then bubble out from each index)"
                    },
                    {
                        "username": "neetika",
                        "content": "From the leetcode blog, one of the methods of solving this is:\\n\\nA common mistake:\\nSome people will be tempted to come up with a quick solution, which is unfortunately flawed (however can be corrected easily):\\n\\nReverse S and become S\\u2019. Find the longest common substring between S and S\\u2019, which must also be the longest palindromic substring.\\nThis seemed to work, let\\u2019s see some examples below.\\n\\nFor example,\\nS = \\u201ccaba\\u201d, S\\u2019 = \\u201cabac\\u201d.\\nThe longest common substring between S and S\\u2019 is \\u201caba\\u201d, which is the answer.\\n\\nLet\\u2019s try another example:\\nS = \\u201cabacdfgdcaba\\u201d, S\\u2019 = \\u201cabacdgfdcaba\\u201d.\\nThe longest common substring between S and S\\u2019 is \\u201cabacd\\u201d. Clearly, this is not a valid palindrome.\\n\\n**We could see that the longest common substring method fails when there exists a reversed copy of a non-palindromic substring in some other part of S. To rectify this, each time we find a longest common substring candidate, we check if the substring\\u2019s indices are the same as the reversed substring\\u2019s original indices. If it is, then we attempt to update the longest palindrome found so far; if not, we skip this and find the next candidate.**\\n\\nIs this part correct? \\n\\nexample string: abcxycba\\nreverse string:  abcxycba\\n\\nThe substring indices are same as reversed string original indices and yet it is not a palindrome?"
                    },
                    {
                        "username": "HRVY_SNOWDEN",
                        "content": "cool sirr:)\\n"
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "WRONG.\\n\\nabcxycba reversed is abcyxcba."
                    },
                    {
                        "username": "travisl12",
                        "content": "After I solved this problem I thought it\\'d be interesting to see how it worked in realtime.\\n\\nhttps://codepen.io/TravisL12/pen/pogvweg"
                    },
                    {
                        "username": "user3907vj",
                        "content": "thanks for the \"nanananananana\" from all the small things ;)"
                    },
                    {
                        "username": "zapataast",
                        "content": "u are crazy"
                    },
                    {
                        "username": "sondq98",
                        "content": "very intuitive"
                    },
                    {
                        "username": "Tathagat017",
                        "content": "thank you\\n"
                    },
                    {
                        "username": "mikler",
                        "content": "So I think I finally understood logic of test creators. \\nEven if you write a classical DP or memorization solution for this one you will timeout on latest tests.\\nI think they consider it edge cases. Because if you add one simple line it will pass! OMG. \\nI have leet code for this. Instead of solving problems I spend hours optimizing the constants.\\n\\nif s == s[::-1]: return s"
                    },
                    {
                        "username": "Vectorido",
                        "content": "Don\\'t work already. Time limit at 141 test even with that construction."
                    },
                    {
                        "username": "deepalithakur17",
                        "content": "It will only work in python."
                    },
                    {
                        "username": "ishogbon",
                        "content": "Its memoization, not memorization "
                    },
                    {
                        "username": "84danie",
                        "content": "I submitted my solution, and received a Time Limit Exceeded on this test case:\\n\\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabcaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n\\nSo I copied and pasted the TC into a custom test case, and started to think about what I could tweak. However, I ended up accidentally hitting Run Code, but instead of getting a Time Limit Exceeded result, it passed:\\n\\n![0_1479079812693_upload-4af9e94c-2e53-4915-acf6-782780c7bf8b](/uploads/files/1479079813717-upload-4af9e94c-2e53-4915-acf6-782780c7bf8b.png) \\n\\nIs this supposed to happen and I just need to make my code more efficient, or is this a bug? \\n![0_1479079956817_upload-1ef15826-d6e6-4bde-9c06-eb597c5c8d0e](/uploads/files/1479079957639-upload-1ef15826-d6e6-4bde-9c06-eb597c5c8d0e.png)"
                    },
                    {
                        "username": "RitikaSahay",
                        "content": "Same thing happened with me. Is there a solution for it?\\n"
                    },
                    {
                        "username": "danicruz0415",
                        "content": "It\\'s happened to me a couple of times. My theory is that the time limit is given for the whole list of test cases. Thus, you can have your test pass, but it will still time limit exceed because it wont get to calculate all the test cases before the time runs out. I cannot confirm this but I think its true because with a very unoptimized solution I got time limit exceeded very early in the test cases (for another problem), after some optimizations I got it much later (like getting to the last tests) which themselves were around the same size, so if the time limit was set per test it would not make sense to fail in a similarly long test-case just that is much later in the test list. (I think the same would apply to memory limit exceeded)"
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "The exact same situation happened with me in one problem... it was a DP problem too... I was getting a Memory Limit Exceeded error with the memoized solution but it was running fine in the Run Code button."
                    },
                    {
                        "username": "Hubro",
                        "content": "I\\'m getting \"Time Limit Exceeded\" with 141/141 testcases passed and \"Last Executed Input\" is:\\n\\n```\\ns =\\n```\\n\\nDid I break it?"
                    },
                    {
                        "username": "karan_dhiman",
                        "content": "same issue"
                    },
                    {
                        "username": "BLANK-Zora",
                        "content": "exactly bro this shit is recked , like it is giving tests outside the constraints , how am i suppose to include such things in the code"
                    },
                    {
                        "username": "arunprep5",
                        "content": "same issue. java"
                    },
                    {
                        "username": "blasphelmy",
                        "content": "[@tuancoltech](/tuancoltech) it worked when i rewrote the code in c# instead of c++"
                    },
                    {
                        "username": "tuancoltech",
                        "content": "[@blasphelmy](/blasphelmy) [@Tomas Sandven](/Hubro) Did you guys find out why? I got the same issue."
                    },
                    {
                        "username": "blasphelmy",
                        "content": "i got that too. im not sure whats going on given that the constraint for input is between 1 and 1000"
                    },
                    {
                        "username": "Vinitajain",
                        "content": "Hi All,\\nI have a test case which is failing, but I feel the testcase result is incorrect.Please refer the screenshot below.\\n![image](https://assets.leetcode.com/users/images/e9e42efb-63d5-4cfa-b420-f1926674f6dc_1654838015.8394327.png)\\n\\nThe longest palindromic substring is \"aaca\" but the test case result is \"aca\". Anyone else faced this problem?"
                    },
                    {
                        "username": "OthSO",
                        "content": "[@mohdansah10](/mohdansah10) \\nthey are separated in the input with \"bd\" so it is not a valid answer "
                    },
                    {
                        "username": "mohdansah10",
                        "content": "I\\'m getting same error, but different case:\\nInput\\ns =\\n\"aacabdkacaa\"\\n\\nOutput\\n\"aacakacaa\"\\nExpected\\n\"aca\"\\n\\nBut mine is Palindrome"
                    },
                    {
                        "username": "hasmithraa",
                        "content": "the expected is correct because aaca can\\'t be a palindrome only \\'aacaa\\' can be a palindrome which is not there in your case"
                    },
                    {
                        "username": "Amish_Singh",
                        "content": "how are you considering \"aaca\" as a palindromic substring, \"aca\" is a palindrome and it is the longest"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "dude you really came up with the solution "
                    },
                    {
                        "username": "AryaAditya3609",
                        "content": "how is \"aaca\" and \"acaa\" same ???\\nWhile \"aca\" is palindrome because both \"aca\" and reverse of it \"aca\" is same !!"
                    },
                    {
                        "username": "alexandra-pickle",
                        "content": "\"aaca\" is not a palindrome"
                    },
                    {
                        "username": "bugHackerLoop",
                        "content": "I followed the approach leant by Aditya Verma DP lectures and encountered the same test case failing. Does the logic where I reverse the string and calculate the longest common substring doesn\\'t work here? I know it works for longest palindromic subsequence but here it fails for such test cases .. why is it so?"
                    },
                    {
                        "username": "mductran",
                        "content": "how is \\'aaca\\' a palindrome? when read backward it\\'s \\'acaa\\' so it\\'s not the same reading forward."
                    },
                    {
                        "username": "jnsudhir",
                        "content": "Check my solution, it was able to clear test case \"aaca\". Explained code in comments.\\n\\nhttps://leetcode.com/problems/longest-palindromic-substring/solutions/3091016/longest-palindromic-substring-using-javascript-beats-94-82-in-runtime-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "nikhileshratna",
                        "content": "aaca is not palindrome"
                    },
                    {
                        "username": "sunshine77",
                        "content": "hey, iam getting the same error, i have seen ansewrs where they have totally changed the algorithm, how did u solve this by tweaking the same algoirhtm"
                    },
                    {
                        "username": "bhupendrabc71",
                        "content": "how come \"aaca\" is palindrome. it should be \"aca\""
                    },
                    {
                        "username": "just11blocks",
                        "content": "aaca is not a palindrome...aacaa and aca are."
                    },
                    {
                        "username": "odi1n",
                        "content": "I also encountered this problem"
                    },
                    {
                        "username": "vamsi2302",
                        "content": "I think you get it by now!\\n"
                    }
                ]
            },
            {
                "id": 1576875,
                "content": [
                    {
                        "username": "ZenMasterV",
                        "content": "Seems like too many of the  coding wunderkinds here lack basic reading comprehension skills \\n\" Please don\\'t post any solutions in this discussion tab\"\\nIt\\'s almost the rule to find the exact opposite for the discussion of every question. I don\\'t want to see your damned solution!"
                    },
                    {
                        "username": "NeroXIII",
                        "content": "[@charonme](/charonme) name does not check out :((("
                    },
                    {
                        "username": "192731",
                        "content": "and if they do?"
                    },
                    {
                        "username": "plevi1995",
                        "content": "Excellent comment"
                    },
                    {
                        "username": "khan60939",
                        "content": "Can anyone tell how DP is being used here? "
                    },
                    {
                        "username": "sandagolcea",
                        "content": "[@charonme](/charonme) my thinking exactly, but at least they should create a flag to help us moderate and move solutions to the correct tab. Would only need a stack overflow moderation-like system: one person flags, another person receives a queue of flagged comments and confirms the tagging.. oh well"
                    },
                    {
                        "username": "charonme",
                        "content": "maybe people get confused by the official leetcode comment which says: \"If you\\'d like to share a detailed solution to the problem, please create a new post in the discuss section\"\\nMaybe some time ago they didn\\'t have a separate solutions section and only recently changed it, but left some of the old solutions in the discussion section and didn\\'t fix the automated comment worting?"
                    },
                    {
                        "username": "klanjewar037",
                        "content": "hehe"
                    },
                    {
                        "username": "sanemdeepak",
                        "content": "For input \"ac\" test case is expecting \"a\" as output, how is just \"a\" a palindromic string?"
                    },
                    {
                        "username": "ayushiidevpura",
                        "content": "because when we read \"a\" from forward it results in \"a\" and at the same time when we read \"a\" from backward it is still \"a\""
                    },
                    {
                        "username": "beyzigo",
                        "content": "Because if you read the string \"a\" backwards it will still be \"a\""
                    },
                    {
                        "username": "tsafackghokeng",
                        "content": "[@Chouhan_Gourav](/Chouhan_Gourav) the test case said \"ac\" not \"a\". is \"ac\" palindromic? for \"a\" i understand"
                    },
                    {
                        "username": "CODEWITHABHINAV",
                        "content": "you have to submit the first string as your answer read more about this question on gFg\\n"
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "any string is palindrome if we read it same from front and from back\\nin single character we read it same from front and back"
                    },
                    {
                        "username": "oinrup",
                        "content": "yes thats my question too"
                    },
                    {
                        "username": "yldemon",
                        "content": "Any character in the string by itself is a palindromic substring. So in the case where there is no palindromic substring with length > 1, you can return any character."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "Whenever you come accross such contradiction, just google the definition, any. Any string is called is pallindromic if the reverse of the string is equal to the original string. Reverse of \\'a\\' is \\'a\\'. Hope you get this."
                    },
                    {
                        "username": "947876275",
                        "content": "This post is for learner wanna practice DP.\\nThe basic idea is, if we wanna say \"aba\" is palindromic, then we need to firstly confirm that \"b\" is palindromic, then we also need to check if \"a\"(the first a) = \"a\" (the second a).\\n\\nM is a 2-d array which stores boolean values.\\nM[i][j] indicates if string[i.....j] is palindromic.\\nSo base cases are:\\nM[i][i] is true.\\nM[i][i + 1] = (s[i] == s[i + 1]);\\nrecurrence relation is :\\nM[i][j] = (s[i] == s[j] AND M[i + 1][j - 1]);\\nFor the implementation of recurrence relation, one idea is you can loop through all possible symmetry axis. For each of the axis, you expand at both RHS and LHS simultaneously. This method promises that when you are determining value in M[i][j], M[i + 1][j - 1] must have the correct value.\\nFinal answer can be found from all M[i][j] == 1 with largest (j - i)."
                    },
                    {
                        "username": "Msey",
                        "content": "thank you, cat brother"
                    },
                    {
                        "username": "user0558y",
                        "content": "I understand the solution but I don't understand why it needs any storage at all or why it needs to be a DP solution.\n\nThe condition `(s[i] == s[j] AND M[i + 1][j - 1])` requires you to memorise if `M[i+1][j-1]` is true, that's easy to understand. However, if you expand each possible axis at the same time, i.e. 1st iteration (s[i+1], s[j-1]), 2nd iteration `s[i+2], s[j-2]`, ... It is guaranteed that M[i+1][j-1] is always true and hence can be dropped, and you should break the loop when it is not true.\n\nIn summary, you don't need to memorise anything at all and you just need to check `s[i] == s[j]` while expanding in both directions at the same time, unless I have misunderstood anything? Here is an implementation of your algorithm but without storage: https://leetcode.com/problems/longest-palindromic-substring/submissions/868540120/"
                    },
                    {
                        "username": "taras",
                        "content": "Thank you! this is a beautiful explanation, though I\\'m not sure what exactly you mean by expanding both on LHS and RHS. In my implementation it\\'s enough to compute all diagonals of  the upper right triangle of the dp matrix."
                    },
                    {
                        "username": "klu_2100031593",
                        "content": "super explanation"
                    },
                    {
                        "username": "napoleon",
                        "content": "My Solution Is Naive, It Cost O(n^2), Is there Any Solution faster?"
                    },
                    {
                        "username": "leocampos",
                        "content": "[@tylerprill-rhdc](/tylerprill-rhdc) So, what I did was:\nStated in my mind the Brute Force approach - create every possible substring and test each one to see if is a palindrome and find the longest.\n\nOf course this would be ridiculously slow, so let's improve it.\nI also mentally stated that a palindrome has a recursive aspect -> if single char, or two equal chars, or charX + palindrome + charX\nSo I created a isPalindrome recursive method that checked it delegating to itself extracting the borders.\n\nSince a palindrome must start and end with the same char, in my traverse of the string, I started storing the position of each character Map<Character, List< Integer>>, so I would just go back to the previous found Char and check if from there to the current pointer I would have a Palindrome.\n\nThen I stopped doing this for every possible palindrome, I then started doing only for the ones that COULD be longer than the already found longest palindrome. That accelerated a lot.\n\nIn the almost last step, I added memoization. Remember that a palindrome is like a sandwich, with the external chars being equal and the meat being another palindrome? So I stored the found palindromes using their start and and positions. So I could check if that had already being checked and if so, either return true or false directly.\n\nThe final step was to convert the recursive function to an iterative function to save some memory used by the call stack.\nMaybe there are better implementations, just sharing my thought process."
                    },
                    {
                        "username": "tylerprill-rhdc",
                        "content": "[@tylerprill-rhdc](/tylerprill-rhdc) Two pointer based solution is also a really good solve here"
                    },
                    {
                        "username": "tylerprill-rhdc",
                        "content": "This could be done in a single pass algorithm, but will inherently check character indices multiple times based on the nature of the problem. (basically, iterate through each, then bubble out from each index)"
                    },
                    {
                        "username": "neetika",
                        "content": "From the leetcode blog, one of the methods of solving this is:\\n\\nA common mistake:\\nSome people will be tempted to come up with a quick solution, which is unfortunately flawed (however can be corrected easily):\\n\\nReverse S and become S\\u2019. Find the longest common substring between S and S\\u2019, which must also be the longest palindromic substring.\\nThis seemed to work, let\\u2019s see some examples below.\\n\\nFor example,\\nS = \\u201ccaba\\u201d, S\\u2019 = \\u201cabac\\u201d.\\nThe longest common substring between S and S\\u2019 is \\u201caba\\u201d, which is the answer.\\n\\nLet\\u2019s try another example:\\nS = \\u201cabacdfgdcaba\\u201d, S\\u2019 = \\u201cabacdgfdcaba\\u201d.\\nThe longest common substring between S and S\\u2019 is \\u201cabacd\\u201d. Clearly, this is not a valid palindrome.\\n\\n**We could see that the longest common substring method fails when there exists a reversed copy of a non-palindromic substring in some other part of S. To rectify this, each time we find a longest common substring candidate, we check if the substring\\u2019s indices are the same as the reversed substring\\u2019s original indices. If it is, then we attempt to update the longest palindrome found so far; if not, we skip this and find the next candidate.**\\n\\nIs this part correct? \\n\\nexample string: abcxycba\\nreverse string:  abcxycba\\n\\nThe substring indices are same as reversed string original indices and yet it is not a palindrome?"
                    },
                    {
                        "username": "HRVY_SNOWDEN",
                        "content": "cool sirr:)\\n"
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "WRONG.\\n\\nabcxycba reversed is abcyxcba."
                    },
                    {
                        "username": "travisl12",
                        "content": "After I solved this problem I thought it\\'d be interesting to see how it worked in realtime.\\n\\nhttps://codepen.io/TravisL12/pen/pogvweg"
                    },
                    {
                        "username": "user3907vj",
                        "content": "thanks for the \"nanananananana\" from all the small things ;)"
                    },
                    {
                        "username": "zapataast",
                        "content": "u are crazy"
                    },
                    {
                        "username": "sondq98",
                        "content": "very intuitive"
                    },
                    {
                        "username": "Tathagat017",
                        "content": "thank you\\n"
                    },
                    {
                        "username": "mikler",
                        "content": "So I think I finally understood logic of test creators. \\nEven if you write a classical DP or memorization solution for this one you will timeout on latest tests.\\nI think they consider it edge cases. Because if you add one simple line it will pass! OMG. \\nI have leet code for this. Instead of solving problems I spend hours optimizing the constants.\\n\\nif s == s[::-1]: return s"
                    },
                    {
                        "username": "Vectorido",
                        "content": "Don\\'t work already. Time limit at 141 test even with that construction."
                    },
                    {
                        "username": "deepalithakur17",
                        "content": "It will only work in python."
                    },
                    {
                        "username": "ishogbon",
                        "content": "Its memoization, not memorization "
                    },
                    {
                        "username": "84danie",
                        "content": "I submitted my solution, and received a Time Limit Exceeded on this test case:\\n\\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabcaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n\\nSo I copied and pasted the TC into a custom test case, and started to think about what I could tweak. However, I ended up accidentally hitting Run Code, but instead of getting a Time Limit Exceeded result, it passed:\\n\\n![0_1479079812693_upload-4af9e94c-2e53-4915-acf6-782780c7bf8b](/uploads/files/1479079813717-upload-4af9e94c-2e53-4915-acf6-782780c7bf8b.png) \\n\\nIs this supposed to happen and I just need to make my code more efficient, or is this a bug? \\n![0_1479079956817_upload-1ef15826-d6e6-4bde-9c06-eb597c5c8d0e](/uploads/files/1479079957639-upload-1ef15826-d6e6-4bde-9c06-eb597c5c8d0e.png)"
                    },
                    {
                        "username": "RitikaSahay",
                        "content": "Same thing happened with me. Is there a solution for it?\\n"
                    },
                    {
                        "username": "danicruz0415",
                        "content": "It\\'s happened to me a couple of times. My theory is that the time limit is given for the whole list of test cases. Thus, you can have your test pass, but it will still time limit exceed because it wont get to calculate all the test cases before the time runs out. I cannot confirm this but I think its true because with a very unoptimized solution I got time limit exceeded very early in the test cases (for another problem), after some optimizations I got it much later (like getting to the last tests) which themselves were around the same size, so if the time limit was set per test it would not make sense to fail in a similarly long test-case just that is much later in the test list. (I think the same would apply to memory limit exceeded)"
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "The exact same situation happened with me in one problem... it was a DP problem too... I was getting a Memory Limit Exceeded error with the memoized solution but it was running fine in the Run Code button."
                    },
                    {
                        "username": "Hubro",
                        "content": "I\\'m getting \"Time Limit Exceeded\" with 141/141 testcases passed and \"Last Executed Input\" is:\\n\\n```\\ns =\\n```\\n\\nDid I break it?"
                    },
                    {
                        "username": "karan_dhiman",
                        "content": "same issue"
                    },
                    {
                        "username": "BLANK-Zora",
                        "content": "exactly bro this shit is recked , like it is giving tests outside the constraints , how am i suppose to include such things in the code"
                    },
                    {
                        "username": "arunprep5",
                        "content": "same issue. java"
                    },
                    {
                        "username": "blasphelmy",
                        "content": "[@tuancoltech](/tuancoltech) it worked when i rewrote the code in c# instead of c++"
                    },
                    {
                        "username": "tuancoltech",
                        "content": "[@blasphelmy](/blasphelmy) [@Tomas Sandven](/Hubro) Did you guys find out why? I got the same issue."
                    },
                    {
                        "username": "blasphelmy",
                        "content": "i got that too. im not sure whats going on given that the constraint for input is between 1 and 1000"
                    },
                    {
                        "username": "Vinitajain",
                        "content": "Hi All,\\nI have a test case which is failing, but I feel the testcase result is incorrect.Please refer the screenshot below.\\n![image](https://assets.leetcode.com/users/images/e9e42efb-63d5-4cfa-b420-f1926674f6dc_1654838015.8394327.png)\\n\\nThe longest palindromic substring is \"aaca\" but the test case result is \"aca\". Anyone else faced this problem?"
                    },
                    {
                        "username": "OthSO",
                        "content": "[@mohdansah10](/mohdansah10) \\nthey are separated in the input with \"bd\" so it is not a valid answer "
                    },
                    {
                        "username": "mohdansah10",
                        "content": "I\\'m getting same error, but different case:\\nInput\\ns =\\n\"aacabdkacaa\"\\n\\nOutput\\n\"aacakacaa\"\\nExpected\\n\"aca\"\\n\\nBut mine is Palindrome"
                    },
                    {
                        "username": "hasmithraa",
                        "content": "the expected is correct because aaca can\\'t be a palindrome only \\'aacaa\\' can be a palindrome which is not there in your case"
                    },
                    {
                        "username": "Amish_Singh",
                        "content": "how are you considering \"aaca\" as a palindromic substring, \"aca\" is a palindrome and it is the longest"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "dude you really came up with the solution "
                    },
                    {
                        "username": "AryaAditya3609",
                        "content": "how is \"aaca\" and \"acaa\" same ???\\nWhile \"aca\" is palindrome because both \"aca\" and reverse of it \"aca\" is same !!"
                    },
                    {
                        "username": "alexandra-pickle",
                        "content": "\"aaca\" is not a palindrome"
                    },
                    {
                        "username": "bugHackerLoop",
                        "content": "I followed the approach leant by Aditya Verma DP lectures and encountered the same test case failing. Does the logic where I reverse the string and calculate the longest common substring doesn\\'t work here? I know it works for longest palindromic subsequence but here it fails for such test cases .. why is it so?"
                    },
                    {
                        "username": "mductran",
                        "content": "how is \\'aaca\\' a palindrome? when read backward it\\'s \\'acaa\\' so it\\'s not the same reading forward."
                    },
                    {
                        "username": "jnsudhir",
                        "content": "Check my solution, it was able to clear test case \"aaca\". Explained code in comments.\\n\\nhttps://leetcode.com/problems/longest-palindromic-substring/solutions/3091016/longest-palindromic-substring-using-javascript-beats-94-82-in-runtime-explained/?orderBy=most_votes"
                    },
                    {
                        "username": "nikhileshratna",
                        "content": "aaca is not palindrome"
                    },
                    {
                        "username": "sunshine77",
                        "content": "hey, iam getting the same error, i have seen ansewrs where they have totally changed the algorithm, how did u solve this by tweaking the same algoirhtm"
                    },
                    {
                        "username": "bhupendrabc71",
                        "content": "how come \"aaca\" is palindrome. it should be \"aca\""
                    },
                    {
                        "username": "just11blocks",
                        "content": "aaca is not a palindrome...aacaa and aca are."
                    },
                    {
                        "username": "odi1n",
                        "content": "I also encountered this problem"
                    },
                    {
                        "username": "vamsi2302",
                        "content": "I think you get it by now!\\n"
                    }
                ]
            },
            {
                "id": 1568053,
                "content": [
                    {
                        "username": "tarun_kothari",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/tarun_kothari/image_1536831337.png)\\nWhile submitting the code it is showing the error for a test case but for the same test case if I try giving input as coustom it is showing correct."
                    },
                    {
                        "username": "showtroylove",
                        "content": "How did you add this image to your comment?"
                    },
                    {
                        "username": "loretta",
                        "content": "What is OJ???"
                    },
                    {
                        "username": "ishita_gupta21",
                        "content": "[@SLazaruss](/SLazaruss) i was about the say the same thing lawd"
                    },
                    {
                        "username": "SLazaruss",
                        "content": "Orange juice"
                    },
                    {
                        "username": "Ashu_91",
                        "content": "Online judge."
                    },
                    {
                        "username": "ClocloDyArx",
                        "content": "Hello,\\nI have finished this exercise but even though I pass all 141/141 tests the Results says \"Time Limit Exceeded\".\\nThe last executed input is empty."
                    },
                    {
                        "username": "swet_rajput",
                        "content": "It took me an hour to solve this even though it\\'s not that difficult but anyhow came to the conclusion that I need to do more practice."
                    },
                    {
                        "username": "2012094",
                        "content": "I face an error while solving the \"5. Longest Palindromic Substring\" problem i.e.\\nTestcase Result\\n\\nTime Limit Exceeded\\n\\nLast Executed Input\\n\\n141/141 testcases passed\\n\\nUse Testcase\\n\\nWhat am I supposed to do ?"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 16.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/longest-palindromic-substring/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Longest Common Substring\n\n  \n**Approach 2:** Brute Force\n\n  \n**Approach 3:** Dynamic Programming\n\n  \n**Approach 4:** Expand Around Center\n\n  \n**Approach 5:** Manacher's Algorithm\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Visualization of \"Expand from Centers\" solution:\n\nhttps://youtu.be/E-tmN1OM9aA"
                    },
                    {
                        "username": "vitalik11087625",
                        "content": "\"000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000..\\n\\nPiece of shit, on submit its doent work, but when i test it myself, its work))))))))))))))))))"
                    },
                    {
                        "username": "NileshKumarGupta",
                        "content": "![image](https://assets.leetcode.com/users/images/d4d76bca-4918-4afc-8fb2-8f24506cab22_1598198725.4986076.png)\\nThe test case shows time limit exceeded but it runs fine locally with 180ms. Why is this error?"
                    },
                    {
                        "username": "amanmaurya8419",
                        "content": "Try to Think with two Pointer Approach because we have to give solution of O(N^2) so normal brute force is not applicable. \\n\\nthink i that way to take element as center and check for left and right of center if left and right element are equal then check for further  else no palindrome found between left and right index"
                    }
                ]
            },
            {
                "id": 1565932,
                "content": [
                    {
                        "username": "tarun_kothari",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/tarun_kothari/image_1536831337.png)\\nWhile submitting the code it is showing the error for a test case but for the same test case if I try giving input as coustom it is showing correct."
                    },
                    {
                        "username": "showtroylove",
                        "content": "How did you add this image to your comment?"
                    },
                    {
                        "username": "loretta",
                        "content": "What is OJ???"
                    },
                    {
                        "username": "ishita_gupta21",
                        "content": "[@SLazaruss](/SLazaruss) i was about the say the same thing lawd"
                    },
                    {
                        "username": "SLazaruss",
                        "content": "Orange juice"
                    },
                    {
                        "username": "Ashu_91",
                        "content": "Online judge."
                    },
                    {
                        "username": "ClocloDyArx",
                        "content": "Hello,\\nI have finished this exercise but even though I pass all 141/141 tests the Results says \"Time Limit Exceeded\".\\nThe last executed input is empty."
                    },
                    {
                        "username": "swet_rajput",
                        "content": "It took me an hour to solve this even though it\\'s not that difficult but anyhow came to the conclusion that I need to do more practice."
                    },
                    {
                        "username": "2012094",
                        "content": "I face an error while solving the \"5. Longest Palindromic Substring\" problem i.e.\\nTestcase Result\\n\\nTime Limit Exceeded\\n\\nLast Executed Input\\n\\n141/141 testcases passed\\n\\nUse Testcase\\n\\nWhat am I supposed to do ?"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 16.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/longest-palindromic-substring/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Longest Common Substring\n\n  \n**Approach 2:** Brute Force\n\n  \n**Approach 3:** Dynamic Programming\n\n  \n**Approach 4:** Expand Around Center\n\n  \n**Approach 5:** Manacher's Algorithm\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Visualization of \"Expand from Centers\" solution:\n\nhttps://youtu.be/E-tmN1OM9aA"
                    },
                    {
                        "username": "vitalik11087625",
                        "content": "\"000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000..\\n\\nPiece of shit, on submit its doent work, but when i test it myself, its work))))))))))))))))))"
                    },
                    {
                        "username": "NileshKumarGupta",
                        "content": "![image](https://assets.leetcode.com/users/images/d4d76bca-4918-4afc-8fb2-8f24506cab22_1598198725.4986076.png)\\nThe test case shows time limit exceeded but it runs fine locally with 180ms. Why is this error?"
                    },
                    {
                        "username": "amanmaurya8419",
                        "content": "Try to Think with two Pointer Approach because we have to give solution of O(N^2) so normal brute force is not applicable. \\n\\nthink i that way to take element as center and check for left and right of center if left and right element are equal then check for further  else no palindrome found between left and right index"
                    }
                ]
            },
            {
                "id": 1875226,
                "content": [
                    {
                        "username": "tarun_kothari",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/tarun_kothari/image_1536831337.png)\\nWhile submitting the code it is showing the error for a test case but for the same test case if I try giving input as coustom it is showing correct."
                    },
                    {
                        "username": "showtroylove",
                        "content": "How did you add this image to your comment?"
                    },
                    {
                        "username": "loretta",
                        "content": "What is OJ???"
                    },
                    {
                        "username": "ishita_gupta21",
                        "content": "[@SLazaruss](/SLazaruss) i was about the say the same thing lawd"
                    },
                    {
                        "username": "SLazaruss",
                        "content": "Orange juice"
                    },
                    {
                        "username": "Ashu_91",
                        "content": "Online judge."
                    },
                    {
                        "username": "ClocloDyArx",
                        "content": "Hello,\\nI have finished this exercise but even though I pass all 141/141 tests the Results says \"Time Limit Exceeded\".\\nThe last executed input is empty."
                    },
                    {
                        "username": "swet_rajput",
                        "content": "It took me an hour to solve this even though it\\'s not that difficult but anyhow came to the conclusion that I need to do more practice."
                    },
                    {
                        "username": "2012094",
                        "content": "I face an error while solving the \"5. Longest Palindromic Substring\" problem i.e.\\nTestcase Result\\n\\nTime Limit Exceeded\\n\\nLast Executed Input\\n\\n141/141 testcases passed\\n\\nUse Testcase\\n\\nWhat am I supposed to do ?"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 16.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/longest-palindromic-substring/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Longest Common Substring\n\n  \n**Approach 2:** Brute Force\n\n  \n**Approach 3:** Dynamic Programming\n\n  \n**Approach 4:** Expand Around Center\n\n  \n**Approach 5:** Manacher's Algorithm\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Visualization of \"Expand from Centers\" solution:\n\nhttps://youtu.be/E-tmN1OM9aA"
                    },
                    {
                        "username": "vitalik11087625",
                        "content": "\"000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000..\\n\\nPiece of shit, on submit its doent work, but when i test it myself, its work))))))))))))))))))"
                    },
                    {
                        "username": "NileshKumarGupta",
                        "content": "![image](https://assets.leetcode.com/users/images/d4d76bca-4918-4afc-8fb2-8f24506cab22_1598198725.4986076.png)\\nThe test case shows time limit exceeded but it runs fine locally with 180ms. Why is this error?"
                    },
                    {
                        "username": "amanmaurya8419",
                        "content": "Try to Think with two Pointer Approach because we have to give solution of O(N^2) so normal brute force is not applicable. \\n\\nthink i that way to take element as center and check for left and right of center if left and right element are equal then check for further  else no palindrome found between left and right index"
                    }
                ]
            },
            {
                "id": 1670373,
                "content": [
                    {
                        "username": "tarun_kothari",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/tarun_kothari/image_1536831337.png)\\nWhile submitting the code it is showing the error for a test case but for the same test case if I try giving input as coustom it is showing correct."
                    },
                    {
                        "username": "showtroylove",
                        "content": "How did you add this image to your comment?"
                    },
                    {
                        "username": "loretta",
                        "content": "What is OJ???"
                    },
                    {
                        "username": "ishita_gupta21",
                        "content": "[@SLazaruss](/SLazaruss) i was about the say the same thing lawd"
                    },
                    {
                        "username": "SLazaruss",
                        "content": "Orange juice"
                    },
                    {
                        "username": "Ashu_91",
                        "content": "Online judge."
                    },
                    {
                        "username": "ClocloDyArx",
                        "content": "Hello,\\nI have finished this exercise but even though I pass all 141/141 tests the Results says \"Time Limit Exceeded\".\\nThe last executed input is empty."
                    },
                    {
                        "username": "swet_rajput",
                        "content": "It took me an hour to solve this even though it\\'s not that difficult but anyhow came to the conclusion that I need to do more practice."
                    },
                    {
                        "username": "2012094",
                        "content": "I face an error while solving the \"5. Longest Palindromic Substring\" problem i.e.\\nTestcase Result\\n\\nTime Limit Exceeded\\n\\nLast Executed Input\\n\\n141/141 testcases passed\\n\\nUse Testcase\\n\\nWhat am I supposed to do ?"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 16.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/longest-palindromic-substring/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Longest Common Substring\n\n  \n**Approach 2:** Brute Force\n\n  \n**Approach 3:** Dynamic Programming\n\n  \n**Approach 4:** Expand Around Center\n\n  \n**Approach 5:** Manacher's Algorithm\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Visualization of \"Expand from Centers\" solution:\n\nhttps://youtu.be/E-tmN1OM9aA"
                    },
                    {
                        "username": "vitalik11087625",
                        "content": "\"000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000..\\n\\nPiece of shit, on submit its doent work, but when i test it myself, its work))))))))))))))))))"
                    },
                    {
                        "username": "NileshKumarGupta",
                        "content": "![image](https://assets.leetcode.com/users/images/d4d76bca-4918-4afc-8fb2-8f24506cab22_1598198725.4986076.png)\\nThe test case shows time limit exceeded but it runs fine locally with 180ms. Why is this error?"
                    },
                    {
                        "username": "amanmaurya8419",
                        "content": "Try to Think with two Pointer Approach because we have to give solution of O(N^2) so normal brute force is not applicable. \\n\\nthink i that way to take element as center and check for left and right of center if left and right element are equal then check for further  else no palindrome found between left and right index"
                    }
                ]
            },
            {
                "id": 1912401,
                "content": [
                    {
                        "username": "tarun_kothari",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/tarun_kothari/image_1536831337.png)\\nWhile submitting the code it is showing the error for a test case but for the same test case if I try giving input as coustom it is showing correct."
                    },
                    {
                        "username": "showtroylove",
                        "content": "How did you add this image to your comment?"
                    },
                    {
                        "username": "loretta",
                        "content": "What is OJ???"
                    },
                    {
                        "username": "ishita_gupta21",
                        "content": "[@SLazaruss](/SLazaruss) i was about the say the same thing lawd"
                    },
                    {
                        "username": "SLazaruss",
                        "content": "Orange juice"
                    },
                    {
                        "username": "Ashu_91",
                        "content": "Online judge."
                    },
                    {
                        "username": "ClocloDyArx",
                        "content": "Hello,\\nI have finished this exercise but even though I pass all 141/141 tests the Results says \"Time Limit Exceeded\".\\nThe last executed input is empty."
                    },
                    {
                        "username": "swet_rajput",
                        "content": "It took me an hour to solve this even though it\\'s not that difficult but anyhow came to the conclusion that I need to do more practice."
                    },
                    {
                        "username": "2012094",
                        "content": "I face an error while solving the \"5. Longest Palindromic Substring\" problem i.e.\\nTestcase Result\\n\\nTime Limit Exceeded\\n\\nLast Executed Input\\n\\n141/141 testcases passed\\n\\nUse Testcase\\n\\nWhat am I supposed to do ?"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 16.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/longest-palindromic-substring/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Longest Common Substring\n\n  \n**Approach 2:** Brute Force\n\n  \n**Approach 3:** Dynamic Programming\n\n  \n**Approach 4:** Expand Around Center\n\n  \n**Approach 5:** Manacher's Algorithm\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Visualization of \"Expand from Centers\" solution:\n\nhttps://youtu.be/E-tmN1OM9aA"
                    },
                    {
                        "username": "vitalik11087625",
                        "content": "\"000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000..\\n\\nPiece of shit, on submit its doent work, but when i test it myself, its work))))))))))))))))))"
                    },
                    {
                        "username": "NileshKumarGupta",
                        "content": "![image](https://assets.leetcode.com/users/images/d4d76bca-4918-4afc-8fb2-8f24506cab22_1598198725.4986076.png)\\nThe test case shows time limit exceeded but it runs fine locally with 180ms. Why is this error?"
                    },
                    {
                        "username": "amanmaurya8419",
                        "content": "Try to Think with two Pointer Approach because we have to give solution of O(N^2) so normal brute force is not applicable. \\n\\nthink i that way to take element as center and check for left and right of center if left and right element are equal then check for further  else no palindrome found between left and right index"
                    }
                ]
            },
            {
                "id": 1568779,
                "content": [
                    {
                        "username": "tarun_kothari",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/tarun_kothari/image_1536831337.png)\\nWhile submitting the code it is showing the error for a test case but for the same test case if I try giving input as coustom it is showing correct."
                    },
                    {
                        "username": "showtroylove",
                        "content": "How did you add this image to your comment?"
                    },
                    {
                        "username": "loretta",
                        "content": "What is OJ???"
                    },
                    {
                        "username": "ishita_gupta21",
                        "content": "[@SLazaruss](/SLazaruss) i was about the say the same thing lawd"
                    },
                    {
                        "username": "SLazaruss",
                        "content": "Orange juice"
                    },
                    {
                        "username": "Ashu_91",
                        "content": "Online judge."
                    },
                    {
                        "username": "ClocloDyArx",
                        "content": "Hello,\\nI have finished this exercise but even though I pass all 141/141 tests the Results says \"Time Limit Exceeded\".\\nThe last executed input is empty."
                    },
                    {
                        "username": "swet_rajput",
                        "content": "It took me an hour to solve this even though it\\'s not that difficult but anyhow came to the conclusion that I need to do more practice."
                    },
                    {
                        "username": "2012094",
                        "content": "I face an error while solving the \"5. Longest Palindromic Substring\" problem i.e.\\nTestcase Result\\n\\nTime Limit Exceeded\\n\\nLast Executed Input\\n\\n141/141 testcases passed\\n\\nUse Testcase\\n\\nWhat am I supposed to do ?"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 16.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/longest-palindromic-substring/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Longest Common Substring\n\n  \n**Approach 2:** Brute Force\n\n  \n**Approach 3:** Dynamic Programming\n\n  \n**Approach 4:** Expand Around Center\n\n  \n**Approach 5:** Manacher's Algorithm\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Visualization of \"Expand from Centers\" solution:\n\nhttps://youtu.be/E-tmN1OM9aA"
                    },
                    {
                        "username": "vitalik11087625",
                        "content": "\"000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000..\\n\\nPiece of shit, on submit its doent work, but when i test it myself, its work))))))))))))))))))"
                    },
                    {
                        "username": "NileshKumarGupta",
                        "content": "![image](https://assets.leetcode.com/users/images/d4d76bca-4918-4afc-8fb2-8f24506cab22_1598198725.4986076.png)\\nThe test case shows time limit exceeded but it runs fine locally with 180ms. Why is this error?"
                    },
                    {
                        "username": "amanmaurya8419",
                        "content": "Try to Think with two Pointer Approach because we have to give solution of O(N^2) so normal brute force is not applicable. \\n\\nthink i that way to take element as center and check for left and right of center if left and right element are equal then check for further  else no palindrome found between left and right index"
                    }
                ]
            },
            {
                "id": 1932644,
                "content": [
                    {
                        "username": "tarun_kothari",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/tarun_kothari/image_1536831337.png)\\nWhile submitting the code it is showing the error for a test case but for the same test case if I try giving input as coustom it is showing correct."
                    },
                    {
                        "username": "showtroylove",
                        "content": "How did you add this image to your comment?"
                    },
                    {
                        "username": "loretta",
                        "content": "What is OJ???"
                    },
                    {
                        "username": "ishita_gupta21",
                        "content": "[@SLazaruss](/SLazaruss) i was about the say the same thing lawd"
                    },
                    {
                        "username": "SLazaruss",
                        "content": "Orange juice"
                    },
                    {
                        "username": "Ashu_91",
                        "content": "Online judge."
                    },
                    {
                        "username": "ClocloDyArx",
                        "content": "Hello,\\nI have finished this exercise but even though I pass all 141/141 tests the Results says \"Time Limit Exceeded\".\\nThe last executed input is empty."
                    },
                    {
                        "username": "swet_rajput",
                        "content": "It took me an hour to solve this even though it\\'s not that difficult but anyhow came to the conclusion that I need to do more practice."
                    },
                    {
                        "username": "2012094",
                        "content": "I face an error while solving the \"5. Longest Palindromic Substring\" problem i.e.\\nTestcase Result\\n\\nTime Limit Exceeded\\n\\nLast Executed Input\\n\\n141/141 testcases passed\\n\\nUse Testcase\\n\\nWhat am I supposed to do ?"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 16.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/longest-palindromic-substring/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Longest Common Substring\n\n  \n**Approach 2:** Brute Force\n\n  \n**Approach 3:** Dynamic Programming\n\n  \n**Approach 4:** Expand Around Center\n\n  \n**Approach 5:** Manacher's Algorithm\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Visualization of \"Expand from Centers\" solution:\n\nhttps://youtu.be/E-tmN1OM9aA"
                    },
                    {
                        "username": "vitalik11087625",
                        "content": "\"000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000..\\n\\nPiece of shit, on submit its doent work, but when i test it myself, its work))))))))))))))))))"
                    },
                    {
                        "username": "NileshKumarGupta",
                        "content": "![image](https://assets.leetcode.com/users/images/d4d76bca-4918-4afc-8fb2-8f24506cab22_1598198725.4986076.png)\\nThe test case shows time limit exceeded but it runs fine locally with 180ms. Why is this error?"
                    },
                    {
                        "username": "amanmaurya8419",
                        "content": "Try to Think with two Pointer Approach because we have to give solution of O(N^2) so normal brute force is not applicable. \\n\\nthink i that way to take element as center and check for left and right of center if left and right element are equal then check for further  else no palindrome found between left and right index"
                    }
                ]
            },
            {
                "id": 1922311,
                "content": [
                    {
                        "username": "tarun_kothari",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/tarun_kothari/image_1536831337.png)\\nWhile submitting the code it is showing the error for a test case but for the same test case if I try giving input as coustom it is showing correct."
                    },
                    {
                        "username": "showtroylove",
                        "content": "How did you add this image to your comment?"
                    },
                    {
                        "username": "loretta",
                        "content": "What is OJ???"
                    },
                    {
                        "username": "ishita_gupta21",
                        "content": "[@SLazaruss](/SLazaruss) i was about the say the same thing lawd"
                    },
                    {
                        "username": "SLazaruss",
                        "content": "Orange juice"
                    },
                    {
                        "username": "Ashu_91",
                        "content": "Online judge."
                    },
                    {
                        "username": "ClocloDyArx",
                        "content": "Hello,\\nI have finished this exercise but even though I pass all 141/141 tests the Results says \"Time Limit Exceeded\".\\nThe last executed input is empty."
                    },
                    {
                        "username": "swet_rajput",
                        "content": "It took me an hour to solve this even though it\\'s not that difficult but anyhow came to the conclusion that I need to do more practice."
                    },
                    {
                        "username": "2012094",
                        "content": "I face an error while solving the \"5. Longest Palindromic Substring\" problem i.e.\\nTestcase Result\\n\\nTime Limit Exceeded\\n\\nLast Executed Input\\n\\n141/141 testcases passed\\n\\nUse Testcase\\n\\nWhat am I supposed to do ?"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 16.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/longest-palindromic-substring/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Longest Common Substring\n\n  \n**Approach 2:** Brute Force\n\n  \n**Approach 3:** Dynamic Programming\n\n  \n**Approach 4:** Expand Around Center\n\n  \n**Approach 5:** Manacher's Algorithm\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Visualization of \"Expand from Centers\" solution:\n\nhttps://youtu.be/E-tmN1OM9aA"
                    },
                    {
                        "username": "vitalik11087625",
                        "content": "\"000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000..\\n\\nPiece of shit, on submit its doent work, but when i test it myself, its work))))))))))))))))))"
                    },
                    {
                        "username": "NileshKumarGupta",
                        "content": "![image](https://assets.leetcode.com/users/images/d4d76bca-4918-4afc-8fb2-8f24506cab22_1598198725.4986076.png)\\nThe test case shows time limit exceeded but it runs fine locally with 180ms. Why is this error?"
                    },
                    {
                        "username": "amanmaurya8419",
                        "content": "Try to Think with two Pointer Approach because we have to give solution of O(N^2) so normal brute force is not applicable. \\n\\nthink i that way to take element as center and check for left and right of center if left and right element are equal then check for further  else no palindrome found between left and right index"
                    }
                ]
            },
            {
                "id": 1574268,
                "content": [
                    {
                        "username": "tarun_kothari",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/tarun_kothari/image_1536831337.png)\\nWhile submitting the code it is showing the error for a test case but for the same test case if I try giving input as coustom it is showing correct."
                    },
                    {
                        "username": "showtroylove",
                        "content": "How did you add this image to your comment?"
                    },
                    {
                        "username": "loretta",
                        "content": "What is OJ???"
                    },
                    {
                        "username": "ishita_gupta21",
                        "content": "[@SLazaruss](/SLazaruss) i was about the say the same thing lawd"
                    },
                    {
                        "username": "SLazaruss",
                        "content": "Orange juice"
                    },
                    {
                        "username": "Ashu_91",
                        "content": "Online judge."
                    },
                    {
                        "username": "ClocloDyArx",
                        "content": "Hello,\\nI have finished this exercise but even though I pass all 141/141 tests the Results says \"Time Limit Exceeded\".\\nThe last executed input is empty."
                    },
                    {
                        "username": "swet_rajput",
                        "content": "It took me an hour to solve this even though it\\'s not that difficult but anyhow came to the conclusion that I need to do more practice."
                    },
                    {
                        "username": "2012094",
                        "content": "I face an error while solving the \"5. Longest Palindromic Substring\" problem i.e.\\nTestcase Result\\n\\nTime Limit Exceeded\\n\\nLast Executed Input\\n\\n141/141 testcases passed\\n\\nUse Testcase\\n\\nWhat am I supposed to do ?"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 16.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/longest-palindromic-substring/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Longest Common Substring\n\n  \n**Approach 2:** Brute Force\n\n  \n**Approach 3:** Dynamic Programming\n\n  \n**Approach 4:** Expand Around Center\n\n  \n**Approach 5:** Manacher's Algorithm\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Visualization of \"Expand from Centers\" solution:\n\nhttps://youtu.be/E-tmN1OM9aA"
                    },
                    {
                        "username": "vitalik11087625",
                        "content": "\"000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000..\\n\\nPiece of shit, on submit its doent work, but when i test it myself, its work))))))))))))))))))"
                    },
                    {
                        "username": "NileshKumarGupta",
                        "content": "![image](https://assets.leetcode.com/users/images/d4d76bca-4918-4afc-8fb2-8f24506cab22_1598198725.4986076.png)\\nThe test case shows time limit exceeded but it runs fine locally with 180ms. Why is this error?"
                    },
                    {
                        "username": "amanmaurya8419",
                        "content": "Try to Think with two Pointer Approach because we have to give solution of O(N^2) so normal brute force is not applicable. \\n\\nthink i that way to take element as center and check for left and right of center if left and right element are equal then check for further  else no palindrome found between left and right index"
                    }
                ]
            },
            {
                "id": 1894157,
                "content": [
                    {
                        "username": "tarun_kothari",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/tarun_kothari/image_1536831337.png)\\nWhile submitting the code it is showing the error for a test case but for the same test case if I try giving input as coustom it is showing correct."
                    },
                    {
                        "username": "showtroylove",
                        "content": "How did you add this image to your comment?"
                    },
                    {
                        "username": "loretta",
                        "content": "What is OJ???"
                    },
                    {
                        "username": "ishita_gupta21",
                        "content": "[@SLazaruss](/SLazaruss) i was about the say the same thing lawd"
                    },
                    {
                        "username": "SLazaruss",
                        "content": "Orange juice"
                    },
                    {
                        "username": "Ashu_91",
                        "content": "Online judge."
                    },
                    {
                        "username": "ClocloDyArx",
                        "content": "Hello,\\nI have finished this exercise but even though I pass all 141/141 tests the Results says \"Time Limit Exceeded\".\\nThe last executed input is empty."
                    },
                    {
                        "username": "swet_rajput",
                        "content": "It took me an hour to solve this even though it\\'s not that difficult but anyhow came to the conclusion that I need to do more practice."
                    },
                    {
                        "username": "2012094",
                        "content": "I face an error while solving the \"5. Longest Palindromic Substring\" problem i.e.\\nTestcase Result\\n\\nTime Limit Exceeded\\n\\nLast Executed Input\\n\\n141/141 testcases passed\\n\\nUse Testcase\\n\\nWhat am I supposed to do ?"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 16.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/longest-palindromic-substring/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Longest Common Substring\n\n  \n**Approach 2:** Brute Force\n\n  \n**Approach 3:** Dynamic Programming\n\n  \n**Approach 4:** Expand Around Center\n\n  \n**Approach 5:** Manacher's Algorithm\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Visualization of \"Expand from Centers\" solution:\n\nhttps://youtu.be/E-tmN1OM9aA"
                    },
                    {
                        "username": "vitalik11087625",
                        "content": "\"000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000..\\n\\nPiece of shit, on submit its doent work, but when i test it myself, its work))))))))))))))))))"
                    },
                    {
                        "username": "NileshKumarGupta",
                        "content": "![image](https://assets.leetcode.com/users/images/d4d76bca-4918-4afc-8fb2-8f24506cab22_1598198725.4986076.png)\\nThe test case shows time limit exceeded but it runs fine locally with 180ms. Why is this error?"
                    },
                    {
                        "username": "amanmaurya8419",
                        "content": "Try to Think with two Pointer Approach because we have to give solution of O(N^2) so normal brute force is not applicable. \\n\\nthink i that way to take element as center and check for left and right of center if left and right element are equal then check for further  else no palindrome found between left and right index"
                    }
                ]
            },
            {
                "id": 1573820,
                "content": [
                    {
                        "username": "dword",
                        "content": "Algorithm A: \"Expand Around Center\" (approach 4 described in the solution).\\nO(n) best case (string contains no palindromes).\\nO(n^2) worst case (string consists of one repeated character).\\n\\nAlgorithm B: modified version of algorithm A that looks ahead to the end of a substring consisting of one repeated character, and expands around the whole substring, avoiding the effort of expanding around each position within the substring.\\nO(n) best case (string consists of one repeated character).\\nO(n^2) worst case (string consists of two alternating characters, like \"ababab\".)\\n\\nAlgorithm C: Manacher\\'s.\\nO(n) best and worst case.\\n\\nImplemented in C++, algorithm A runs in 44 ms, while algorithms B and C both run in 4 ms. Apparently, algorithm A is encountering its worst case but algorithm B is not.\\n\\nSure enough, when tested on \"ab\" repeated 5,000 times, algorithms A and B both run in ~100 ms and algorithm C runs in ~0 ms.\\n\\nSo it appears that in the test cases, there\\'s a long string of one repeated character but no similarly long string of two alternating characters.\\n\\nJust something I find interesting."
                    },
                    {
                        "username": "Ab__23",
                        "content": "I would like to report a bug here that, my solution runs successfully on all except the last testcase. When it shows that test case failed, I looked and found that the test case was empty, I mean such a minor bug in test case checking caused bad effect on my accuracy. Please remove the last test case. :("
                    },
                    {
                        "username": "timewaster69",
                        "content": "agreed. it also directly contradicts the two constraints given in the problem. Even if you were to write a testcase accounting for an empty string it still does not work for some reason."
                    },
                    {
                        "username": "martinvilche98",
                        "content": "\"Time Limit Exceeded\" On Passing solution...\\n\\nHonestly sounds like an excuse to reduce server load."
                    },
                    {
                        "username": "showtroylove",
                        "content": "Key to this task is avoiding string operations in your solution.  It can save you enormous time and avoids the TLE error.  Going one by one or using two loops stripping on char off the front or back doesn\\'t matter.  Reduce it all to int operations and it simplifies the task immensely.  That\\'s my two cents and I\\'m sticking with it. Cheers!"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/longest-palindromic-substring-solution-python-leetcode/\\n"
                    },
                    {
                        "username": "0Camus0",
                        "content": "Hi, \\n\\nMany Manacher\\u2019s Algorithm implementation threads over the internet, but they always handle the even string case as:\\n\\n\"We just add $ to the string before and after, so baba would be $b$a$b$a$ and now we can have this case working too...\"\\n\\nBut it\\'s kind of defeating the purpose of having a O(n) time complexity, because you are doing another O(n) just to add the $, and then another O(n) to remove the $ for the even case. \\n\\nMaybe there is another Manchester\\'s implementation that doesn\\'t require that tricky \"add $\" in order to work.\\n\\nFor my solution I had two pases, one for the even and one for the odd, but I feel dumb when I see solutions from other people.. still 14 ms."
                    },
                    {
                        "username": "kshitij_sanghvi",
                        "content": "For folks getting a TLE. There are certain optimisations that work which would not work for smaller inputs.\\nIf you think about it logically the constant in dictionary look up is substantially higher that that of a list look up. However, we need to create a list and initialise it. This is where the constant in dictionary look up is traded off by default dict.\\n"
                    },
                    {
                        "username": "office93662",
                        "content": "Could someone help me understand how the time complexity is o(n^3) for the brute force?"
                    },
                    {
                        "username": "annen",
                        "content": "There are O(N^2) sub-strings. Checking whether a string is a palindrome is O(N). So O(N^3)"
                    },
                    {
                        "username": "infoie",
                        "content": "O(n3) runtime, O(1) space \\u2013 Brute force:\\nThe obvious brute force solution is to pick all possible starting and ending positions for a substring, and verify if it is a palindrome. There are a total of such substrings (excluding the trivial solution where a character itself is a palindrome).\\nSince verifying each substring takes O(n) time, the run time complexity is O(n3).\\n![image](https://assets.leetcode.com/users/infoie/image_1576132859.png)\\n\\nO(n2) runtime, O(n) space \\u2013 Dynamic programming:\\nTo improve over the brute force solution from a DP approach, first think how we can avoid unnecessary re-computation in validating palindromes. Consider the case \\u201Cababa\\u201D.\\nIf we already knew that \\u201Cbab\\u201D is a palindrome, it is obvious that \\u201Cababa\\u201D must be a palindrome since the two left and right end letters are the same.\\nStated more formally below:\\n\\tDefine P[ i, j ] \\u2190 true if the substring Si \\u2026 Sj is a palindrome, otherwise false.\\n\\tTherefore,\\n\\tP[ i, j ] \\u2190 ( P[ i+1, j-1 ] and Si = Sj )\\n\\tThe base cases are:\\n\\tP[ i, i ] \\u2190 true\\n\\tP[ i, i+1 ] \\u2190 ( Si = Si+1 )\\nThis yields a straight forward DP solution, which we first initialize the one and two letters palindromes, and work our way up finding all three letters palindromes, and so on\\u2026\\nThis gives us a runtime complexity of O(n2) and uses O(n2) space to store the table.\\n![image](https://assets.leetcode.com/users/infoie/image_1576132896.png)\\n\\nO(n2) runtime, O(1) space \\u2013 Simpler solution:\\nIn fact, we could solve it in O(n2) time using only constant space.\\nWe observe that a palindrome mirrors around its center. Therefore, a palindrome can be expanded from its center, and there are only 2n \\u2013 1 such centers.\\nYou might be asking why there are 2n \\u2013 1 but not n centers? The reason is the center of a palindrome can be in between two letters. Such palindromes have even number of letters (such as \\u201Cabba\\u201D) and its center are between the two \\u2018b\\u2019s.\\nSince expanding a palindrome around its center could take O(n) time, the overall complexity is O(n2).\\n![image](https://assets.leetcode.com/users/infoie/image_1576132950.png)\\n\\nO(n) runtime, O(n) space \\u2013 Manacher\\u2019s algorithm:\\n![image](https://assets.leetcode.com/users/infoie/image_1576132981.png)\\n"
                    },
                    {
                        "username": "luo980",
                        "content": "![alt text]![0_1499137449406_8cb1c4ff-b5a3-46f1-9aeb-eed2e7012534-image.png](/assets/uploads/files/1499137454573-8cb1c4ff-b5a3-46f1-9aeb-eed2e7012534-image-resized.png) \\nHow should i deal with this problem?"
                    }
                ]
            },
            {
                "id": 1971133,
                "content": [
                    {
                        "username": "dword",
                        "content": "Algorithm A: \"Expand Around Center\" (approach 4 described in the solution).\\nO(n) best case (string contains no palindromes).\\nO(n^2) worst case (string consists of one repeated character).\\n\\nAlgorithm B: modified version of algorithm A that looks ahead to the end of a substring consisting of one repeated character, and expands around the whole substring, avoiding the effort of expanding around each position within the substring.\\nO(n) best case (string consists of one repeated character).\\nO(n^2) worst case (string consists of two alternating characters, like \"ababab\".)\\n\\nAlgorithm C: Manacher\\'s.\\nO(n) best and worst case.\\n\\nImplemented in C++, algorithm A runs in 44 ms, while algorithms B and C both run in 4 ms. Apparently, algorithm A is encountering its worst case but algorithm B is not.\\n\\nSure enough, when tested on \"ab\" repeated 5,000 times, algorithms A and B both run in ~100 ms and algorithm C runs in ~0 ms.\\n\\nSo it appears that in the test cases, there\\'s a long string of one repeated character but no similarly long string of two alternating characters.\\n\\nJust something I find interesting."
                    },
                    {
                        "username": "Ab__23",
                        "content": "I would like to report a bug here that, my solution runs successfully on all except the last testcase. When it shows that test case failed, I looked and found that the test case was empty, I mean such a minor bug in test case checking caused bad effect on my accuracy. Please remove the last test case. :("
                    },
                    {
                        "username": "timewaster69",
                        "content": "agreed. it also directly contradicts the two constraints given in the problem. Even if you were to write a testcase accounting for an empty string it still does not work for some reason."
                    },
                    {
                        "username": "martinvilche98",
                        "content": "\"Time Limit Exceeded\" On Passing solution...\\n\\nHonestly sounds like an excuse to reduce server load."
                    },
                    {
                        "username": "showtroylove",
                        "content": "Key to this task is avoiding string operations in your solution.  It can save you enormous time and avoids the TLE error.  Going one by one or using two loops stripping on char off the front or back doesn\\'t matter.  Reduce it all to int operations and it simplifies the task immensely.  That\\'s my two cents and I\\'m sticking with it. Cheers!"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/longest-palindromic-substring-solution-python-leetcode/\\n"
                    },
                    {
                        "username": "0Camus0",
                        "content": "Hi, \\n\\nMany Manacher\\u2019s Algorithm implementation threads over the internet, but they always handle the even string case as:\\n\\n\"We just add $ to the string before and after, so baba would be $b$a$b$a$ and now we can have this case working too...\"\\n\\nBut it\\'s kind of defeating the purpose of having a O(n) time complexity, because you are doing another O(n) just to add the $, and then another O(n) to remove the $ for the even case. \\n\\nMaybe there is another Manchester\\'s implementation that doesn\\'t require that tricky \"add $\" in order to work.\\n\\nFor my solution I had two pases, one for the even and one for the odd, but I feel dumb when I see solutions from other people.. still 14 ms."
                    },
                    {
                        "username": "kshitij_sanghvi",
                        "content": "For folks getting a TLE. There are certain optimisations that work which would not work for smaller inputs.\\nIf you think about it logically the constant in dictionary look up is substantially higher that that of a list look up. However, we need to create a list and initialise it. This is where the constant in dictionary look up is traded off by default dict.\\n"
                    },
                    {
                        "username": "office93662",
                        "content": "Could someone help me understand how the time complexity is o(n^3) for the brute force?"
                    },
                    {
                        "username": "annen",
                        "content": "There are O(N^2) sub-strings. Checking whether a string is a palindrome is O(N). So O(N^3)"
                    },
                    {
                        "username": "infoie",
                        "content": "O(n3) runtime, O(1) space \\u2013 Brute force:\\nThe obvious brute force solution is to pick all possible starting and ending positions for a substring, and verify if it is a palindrome. There are a total of such substrings (excluding the trivial solution where a character itself is a palindrome).\\nSince verifying each substring takes O(n) time, the run time complexity is O(n3).\\n![image](https://assets.leetcode.com/users/infoie/image_1576132859.png)\\n\\nO(n2) runtime, O(n) space \\u2013 Dynamic programming:\\nTo improve over the brute force solution from a DP approach, first think how we can avoid unnecessary re-computation in validating palindromes. Consider the case \\u201Cababa\\u201D.\\nIf we already knew that \\u201Cbab\\u201D is a palindrome, it is obvious that \\u201Cababa\\u201D must be a palindrome since the two left and right end letters are the same.\\nStated more formally below:\\n\\tDefine P[ i, j ] \\u2190 true if the substring Si \\u2026 Sj is a palindrome, otherwise false.\\n\\tTherefore,\\n\\tP[ i, j ] \\u2190 ( P[ i+1, j-1 ] and Si = Sj )\\n\\tThe base cases are:\\n\\tP[ i, i ] \\u2190 true\\n\\tP[ i, i+1 ] \\u2190 ( Si = Si+1 )\\nThis yields a straight forward DP solution, which we first initialize the one and two letters palindromes, and work our way up finding all three letters palindromes, and so on\\u2026\\nThis gives us a runtime complexity of O(n2) and uses O(n2) space to store the table.\\n![image](https://assets.leetcode.com/users/infoie/image_1576132896.png)\\n\\nO(n2) runtime, O(1) space \\u2013 Simpler solution:\\nIn fact, we could solve it in O(n2) time using only constant space.\\nWe observe that a palindrome mirrors around its center. Therefore, a palindrome can be expanded from its center, and there are only 2n \\u2013 1 such centers.\\nYou might be asking why there are 2n \\u2013 1 but not n centers? The reason is the center of a palindrome can be in between two letters. Such palindromes have even number of letters (such as \\u201Cabba\\u201D) and its center are between the two \\u2018b\\u2019s.\\nSince expanding a palindrome around its center could take O(n) time, the overall complexity is O(n2).\\n![image](https://assets.leetcode.com/users/infoie/image_1576132950.png)\\n\\nO(n) runtime, O(n) space \\u2013 Manacher\\u2019s algorithm:\\n![image](https://assets.leetcode.com/users/infoie/image_1576132981.png)\\n"
                    },
                    {
                        "username": "luo980",
                        "content": "![alt text]![0_1499137449406_8cb1c4ff-b5a3-46f1-9aeb-eed2e7012534-image.png](/assets/uploads/files/1499137454573-8cb1c4ff-b5a3-46f1-9aeb-eed2e7012534-image-resized.png) \\nHow should i deal with this problem?"
                    }
                ]
            },
            {
                "id": 1939934,
                "content": [
                    {
                        "username": "dword",
                        "content": "Algorithm A: \"Expand Around Center\" (approach 4 described in the solution).\\nO(n) best case (string contains no palindromes).\\nO(n^2) worst case (string consists of one repeated character).\\n\\nAlgorithm B: modified version of algorithm A that looks ahead to the end of a substring consisting of one repeated character, and expands around the whole substring, avoiding the effort of expanding around each position within the substring.\\nO(n) best case (string consists of one repeated character).\\nO(n^2) worst case (string consists of two alternating characters, like \"ababab\".)\\n\\nAlgorithm C: Manacher\\'s.\\nO(n) best and worst case.\\n\\nImplemented in C++, algorithm A runs in 44 ms, while algorithms B and C both run in 4 ms. Apparently, algorithm A is encountering its worst case but algorithm B is not.\\n\\nSure enough, when tested on \"ab\" repeated 5,000 times, algorithms A and B both run in ~100 ms and algorithm C runs in ~0 ms.\\n\\nSo it appears that in the test cases, there\\'s a long string of one repeated character but no similarly long string of two alternating characters.\\n\\nJust something I find interesting."
                    },
                    {
                        "username": "Ab__23",
                        "content": "I would like to report a bug here that, my solution runs successfully on all except the last testcase. When it shows that test case failed, I looked and found that the test case was empty, I mean such a minor bug in test case checking caused bad effect on my accuracy. Please remove the last test case. :("
                    },
                    {
                        "username": "timewaster69",
                        "content": "agreed. it also directly contradicts the two constraints given in the problem. Even if you were to write a testcase accounting for an empty string it still does not work for some reason."
                    },
                    {
                        "username": "martinvilche98",
                        "content": "\"Time Limit Exceeded\" On Passing solution...\\n\\nHonestly sounds like an excuse to reduce server load."
                    },
                    {
                        "username": "showtroylove",
                        "content": "Key to this task is avoiding string operations in your solution.  It can save you enormous time and avoids the TLE error.  Going one by one or using two loops stripping on char off the front or back doesn\\'t matter.  Reduce it all to int operations and it simplifies the task immensely.  That\\'s my two cents and I\\'m sticking with it. Cheers!"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/longest-palindromic-substring-solution-python-leetcode/\\n"
                    },
                    {
                        "username": "0Camus0",
                        "content": "Hi, \\n\\nMany Manacher\\u2019s Algorithm implementation threads over the internet, but they always handle the even string case as:\\n\\n\"We just add $ to the string before and after, so baba would be $b$a$b$a$ and now we can have this case working too...\"\\n\\nBut it\\'s kind of defeating the purpose of having a O(n) time complexity, because you are doing another O(n) just to add the $, and then another O(n) to remove the $ for the even case. \\n\\nMaybe there is another Manchester\\'s implementation that doesn\\'t require that tricky \"add $\" in order to work.\\n\\nFor my solution I had two pases, one for the even and one for the odd, but I feel dumb when I see solutions from other people.. still 14 ms."
                    },
                    {
                        "username": "kshitij_sanghvi",
                        "content": "For folks getting a TLE. There are certain optimisations that work which would not work for smaller inputs.\\nIf you think about it logically the constant in dictionary look up is substantially higher that that of a list look up. However, we need to create a list and initialise it. This is where the constant in dictionary look up is traded off by default dict.\\n"
                    },
                    {
                        "username": "office93662",
                        "content": "Could someone help me understand how the time complexity is o(n^3) for the brute force?"
                    },
                    {
                        "username": "annen",
                        "content": "There are O(N^2) sub-strings. Checking whether a string is a palindrome is O(N). So O(N^3)"
                    },
                    {
                        "username": "infoie",
                        "content": "O(n3) runtime, O(1) space \\u2013 Brute force:\\nThe obvious brute force solution is to pick all possible starting and ending positions for a substring, and verify if it is a palindrome. There are a total of such substrings (excluding the trivial solution where a character itself is a palindrome).\\nSince verifying each substring takes O(n) time, the run time complexity is O(n3).\\n![image](https://assets.leetcode.com/users/infoie/image_1576132859.png)\\n\\nO(n2) runtime, O(n) space \\u2013 Dynamic programming:\\nTo improve over the brute force solution from a DP approach, first think how we can avoid unnecessary re-computation in validating palindromes. Consider the case \\u201Cababa\\u201D.\\nIf we already knew that \\u201Cbab\\u201D is a palindrome, it is obvious that \\u201Cababa\\u201D must be a palindrome since the two left and right end letters are the same.\\nStated more formally below:\\n\\tDefine P[ i, j ] \\u2190 true if the substring Si \\u2026 Sj is a palindrome, otherwise false.\\n\\tTherefore,\\n\\tP[ i, j ] \\u2190 ( P[ i+1, j-1 ] and Si = Sj )\\n\\tThe base cases are:\\n\\tP[ i, i ] \\u2190 true\\n\\tP[ i, i+1 ] \\u2190 ( Si = Si+1 )\\nThis yields a straight forward DP solution, which we first initialize the one and two letters palindromes, and work our way up finding all three letters palindromes, and so on\\u2026\\nThis gives us a runtime complexity of O(n2) and uses O(n2) space to store the table.\\n![image](https://assets.leetcode.com/users/infoie/image_1576132896.png)\\n\\nO(n2) runtime, O(1) space \\u2013 Simpler solution:\\nIn fact, we could solve it in O(n2) time using only constant space.\\nWe observe that a palindrome mirrors around its center. Therefore, a palindrome can be expanded from its center, and there are only 2n \\u2013 1 such centers.\\nYou might be asking why there are 2n \\u2013 1 but not n centers? The reason is the center of a palindrome can be in between two letters. Such palindromes have even number of letters (such as \\u201Cabba\\u201D) and its center are between the two \\u2018b\\u2019s.\\nSince expanding a palindrome around its center could take O(n) time, the overall complexity is O(n2).\\n![image](https://assets.leetcode.com/users/infoie/image_1576132950.png)\\n\\nO(n) runtime, O(n) space \\u2013 Manacher\\u2019s algorithm:\\n![image](https://assets.leetcode.com/users/infoie/image_1576132981.png)\\n"
                    },
                    {
                        "username": "luo980",
                        "content": "![alt text]![0_1499137449406_8cb1c4ff-b5a3-46f1-9aeb-eed2e7012534-image.png](/assets/uploads/files/1499137454573-8cb1c4ff-b5a3-46f1-9aeb-eed2e7012534-image-resized.png) \\nHow should i deal with this problem?"
                    }
                ]
            },
            {
                "id": 1654221,
                "content": [
                    {
                        "username": "dword",
                        "content": "Algorithm A: \"Expand Around Center\" (approach 4 described in the solution).\\nO(n) best case (string contains no palindromes).\\nO(n^2) worst case (string consists of one repeated character).\\n\\nAlgorithm B: modified version of algorithm A that looks ahead to the end of a substring consisting of one repeated character, and expands around the whole substring, avoiding the effort of expanding around each position within the substring.\\nO(n) best case (string consists of one repeated character).\\nO(n^2) worst case (string consists of two alternating characters, like \"ababab\".)\\n\\nAlgorithm C: Manacher\\'s.\\nO(n) best and worst case.\\n\\nImplemented in C++, algorithm A runs in 44 ms, while algorithms B and C both run in 4 ms. Apparently, algorithm A is encountering its worst case but algorithm B is not.\\n\\nSure enough, when tested on \"ab\" repeated 5,000 times, algorithms A and B both run in ~100 ms and algorithm C runs in ~0 ms.\\n\\nSo it appears that in the test cases, there\\'s a long string of one repeated character but no similarly long string of two alternating characters.\\n\\nJust something I find interesting."
                    },
                    {
                        "username": "Ab__23",
                        "content": "I would like to report a bug here that, my solution runs successfully on all except the last testcase. When it shows that test case failed, I looked and found that the test case was empty, I mean such a minor bug in test case checking caused bad effect on my accuracy. Please remove the last test case. :("
                    },
                    {
                        "username": "timewaster69",
                        "content": "agreed. it also directly contradicts the two constraints given in the problem. Even if you were to write a testcase accounting for an empty string it still does not work for some reason."
                    },
                    {
                        "username": "martinvilche98",
                        "content": "\"Time Limit Exceeded\" On Passing solution...\\n\\nHonestly sounds like an excuse to reduce server load."
                    },
                    {
                        "username": "showtroylove",
                        "content": "Key to this task is avoiding string operations in your solution.  It can save you enormous time and avoids the TLE error.  Going one by one or using two loops stripping on char off the front or back doesn\\'t matter.  Reduce it all to int operations and it simplifies the task immensely.  That\\'s my two cents and I\\'m sticking with it. Cheers!"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/longest-palindromic-substring-solution-python-leetcode/\\n"
                    },
                    {
                        "username": "0Camus0",
                        "content": "Hi, \\n\\nMany Manacher\\u2019s Algorithm implementation threads over the internet, but they always handle the even string case as:\\n\\n\"We just add $ to the string before and after, so baba would be $b$a$b$a$ and now we can have this case working too...\"\\n\\nBut it\\'s kind of defeating the purpose of having a O(n) time complexity, because you are doing another O(n) just to add the $, and then another O(n) to remove the $ for the even case. \\n\\nMaybe there is another Manchester\\'s implementation that doesn\\'t require that tricky \"add $\" in order to work.\\n\\nFor my solution I had two pases, one for the even and one for the odd, but I feel dumb when I see solutions from other people.. still 14 ms."
                    },
                    {
                        "username": "kshitij_sanghvi",
                        "content": "For folks getting a TLE. There are certain optimisations that work which would not work for smaller inputs.\\nIf you think about it logically the constant in dictionary look up is substantially higher that that of a list look up. However, we need to create a list and initialise it. This is where the constant in dictionary look up is traded off by default dict.\\n"
                    },
                    {
                        "username": "office93662",
                        "content": "Could someone help me understand how the time complexity is o(n^3) for the brute force?"
                    },
                    {
                        "username": "annen",
                        "content": "There are O(N^2) sub-strings. Checking whether a string is a palindrome is O(N). So O(N^3)"
                    },
                    {
                        "username": "infoie",
                        "content": "O(n3) runtime, O(1) space \\u2013 Brute force:\\nThe obvious brute force solution is to pick all possible starting and ending positions for a substring, and verify if it is a palindrome. There are a total of such substrings (excluding the trivial solution where a character itself is a palindrome).\\nSince verifying each substring takes O(n) time, the run time complexity is O(n3).\\n![image](https://assets.leetcode.com/users/infoie/image_1576132859.png)\\n\\nO(n2) runtime, O(n) space \\u2013 Dynamic programming:\\nTo improve over the brute force solution from a DP approach, first think how we can avoid unnecessary re-computation in validating palindromes. Consider the case \\u201Cababa\\u201D.\\nIf we already knew that \\u201Cbab\\u201D is a palindrome, it is obvious that \\u201Cababa\\u201D must be a palindrome since the two left and right end letters are the same.\\nStated more formally below:\\n\\tDefine P[ i, j ] \\u2190 true if the substring Si \\u2026 Sj is a palindrome, otherwise false.\\n\\tTherefore,\\n\\tP[ i, j ] \\u2190 ( P[ i+1, j-1 ] and Si = Sj )\\n\\tThe base cases are:\\n\\tP[ i, i ] \\u2190 true\\n\\tP[ i, i+1 ] \\u2190 ( Si = Si+1 )\\nThis yields a straight forward DP solution, which we first initialize the one and two letters palindromes, and work our way up finding all three letters palindromes, and so on\\u2026\\nThis gives us a runtime complexity of O(n2) and uses O(n2) space to store the table.\\n![image](https://assets.leetcode.com/users/infoie/image_1576132896.png)\\n\\nO(n2) runtime, O(1) space \\u2013 Simpler solution:\\nIn fact, we could solve it in O(n2) time using only constant space.\\nWe observe that a palindrome mirrors around its center. Therefore, a palindrome can be expanded from its center, and there are only 2n \\u2013 1 such centers.\\nYou might be asking why there are 2n \\u2013 1 but not n centers? The reason is the center of a palindrome can be in between two letters. Such palindromes have even number of letters (such as \\u201Cabba\\u201D) and its center are between the two \\u2018b\\u2019s.\\nSince expanding a palindrome around its center could take O(n) time, the overall complexity is O(n2).\\n![image](https://assets.leetcode.com/users/infoie/image_1576132950.png)\\n\\nO(n) runtime, O(n) space \\u2013 Manacher\\u2019s algorithm:\\n![image](https://assets.leetcode.com/users/infoie/image_1576132981.png)\\n"
                    },
                    {
                        "username": "luo980",
                        "content": "![alt text]![0_1499137449406_8cb1c4ff-b5a3-46f1-9aeb-eed2e7012534-image.png](/assets/uploads/files/1499137454573-8cb1c4ff-b5a3-46f1-9aeb-eed2e7012534-image-resized.png) \\nHow should i deal with this problem?"
                    }
                ]
            },
            {
                "id": 1570831,
                "content": [
                    {
                        "username": "dword",
                        "content": "Algorithm A: \"Expand Around Center\" (approach 4 described in the solution).\\nO(n) best case (string contains no palindromes).\\nO(n^2) worst case (string consists of one repeated character).\\n\\nAlgorithm B: modified version of algorithm A that looks ahead to the end of a substring consisting of one repeated character, and expands around the whole substring, avoiding the effort of expanding around each position within the substring.\\nO(n) best case (string consists of one repeated character).\\nO(n^2) worst case (string consists of two alternating characters, like \"ababab\".)\\n\\nAlgorithm C: Manacher\\'s.\\nO(n) best and worst case.\\n\\nImplemented in C++, algorithm A runs in 44 ms, while algorithms B and C both run in 4 ms. Apparently, algorithm A is encountering its worst case but algorithm B is not.\\n\\nSure enough, when tested on \"ab\" repeated 5,000 times, algorithms A and B both run in ~100 ms and algorithm C runs in ~0 ms.\\n\\nSo it appears that in the test cases, there\\'s a long string of one repeated character but no similarly long string of two alternating characters.\\n\\nJust something I find interesting."
                    },
                    {
                        "username": "Ab__23",
                        "content": "I would like to report a bug here that, my solution runs successfully on all except the last testcase. When it shows that test case failed, I looked and found that the test case was empty, I mean such a minor bug in test case checking caused bad effect on my accuracy. Please remove the last test case. :("
                    },
                    {
                        "username": "timewaster69",
                        "content": "agreed. it also directly contradicts the two constraints given in the problem. Even if you were to write a testcase accounting for an empty string it still does not work for some reason."
                    },
                    {
                        "username": "martinvilche98",
                        "content": "\"Time Limit Exceeded\" On Passing solution...\\n\\nHonestly sounds like an excuse to reduce server load."
                    },
                    {
                        "username": "showtroylove",
                        "content": "Key to this task is avoiding string operations in your solution.  It can save you enormous time and avoids the TLE error.  Going one by one or using two loops stripping on char off the front or back doesn\\'t matter.  Reduce it all to int operations and it simplifies the task immensely.  That\\'s my two cents and I\\'m sticking with it. Cheers!"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/longest-palindromic-substring-solution-python-leetcode/\\n"
                    },
                    {
                        "username": "0Camus0",
                        "content": "Hi, \\n\\nMany Manacher\\u2019s Algorithm implementation threads over the internet, but they always handle the even string case as:\\n\\n\"We just add $ to the string before and after, so baba would be $b$a$b$a$ and now we can have this case working too...\"\\n\\nBut it\\'s kind of defeating the purpose of having a O(n) time complexity, because you are doing another O(n) just to add the $, and then another O(n) to remove the $ for the even case. \\n\\nMaybe there is another Manchester\\'s implementation that doesn\\'t require that tricky \"add $\" in order to work.\\n\\nFor my solution I had two pases, one for the even and one for the odd, but I feel dumb when I see solutions from other people.. still 14 ms."
                    },
                    {
                        "username": "kshitij_sanghvi",
                        "content": "For folks getting a TLE. There are certain optimisations that work which would not work for smaller inputs.\\nIf you think about it logically the constant in dictionary look up is substantially higher that that of a list look up. However, we need to create a list and initialise it. This is where the constant in dictionary look up is traded off by default dict.\\n"
                    },
                    {
                        "username": "office93662",
                        "content": "Could someone help me understand how the time complexity is o(n^3) for the brute force?"
                    },
                    {
                        "username": "annen",
                        "content": "There are O(N^2) sub-strings. Checking whether a string is a palindrome is O(N). So O(N^3)"
                    },
                    {
                        "username": "infoie",
                        "content": "O(n3) runtime, O(1) space \\u2013 Brute force:\\nThe obvious brute force solution is to pick all possible starting and ending positions for a substring, and verify if it is a palindrome. There are a total of such substrings (excluding the trivial solution where a character itself is a palindrome).\\nSince verifying each substring takes O(n) time, the run time complexity is O(n3).\\n![image](https://assets.leetcode.com/users/infoie/image_1576132859.png)\\n\\nO(n2) runtime, O(n) space \\u2013 Dynamic programming:\\nTo improve over the brute force solution from a DP approach, first think how we can avoid unnecessary re-computation in validating palindromes. Consider the case \\u201Cababa\\u201D.\\nIf we already knew that \\u201Cbab\\u201D is a palindrome, it is obvious that \\u201Cababa\\u201D must be a palindrome since the two left and right end letters are the same.\\nStated more formally below:\\n\\tDefine P[ i, j ] \\u2190 true if the substring Si \\u2026 Sj is a palindrome, otherwise false.\\n\\tTherefore,\\n\\tP[ i, j ] \\u2190 ( P[ i+1, j-1 ] and Si = Sj )\\n\\tThe base cases are:\\n\\tP[ i, i ] \\u2190 true\\n\\tP[ i, i+1 ] \\u2190 ( Si = Si+1 )\\nThis yields a straight forward DP solution, which we first initialize the one and two letters palindromes, and work our way up finding all three letters palindromes, and so on\\u2026\\nThis gives us a runtime complexity of O(n2) and uses O(n2) space to store the table.\\n![image](https://assets.leetcode.com/users/infoie/image_1576132896.png)\\n\\nO(n2) runtime, O(1) space \\u2013 Simpler solution:\\nIn fact, we could solve it in O(n2) time using only constant space.\\nWe observe that a palindrome mirrors around its center. Therefore, a palindrome can be expanded from its center, and there are only 2n \\u2013 1 such centers.\\nYou might be asking why there are 2n \\u2013 1 but not n centers? The reason is the center of a palindrome can be in between two letters. Such palindromes have even number of letters (such as \\u201Cabba\\u201D) and its center are between the two \\u2018b\\u2019s.\\nSince expanding a palindrome around its center could take O(n) time, the overall complexity is O(n2).\\n![image](https://assets.leetcode.com/users/infoie/image_1576132950.png)\\n\\nO(n) runtime, O(n) space \\u2013 Manacher\\u2019s algorithm:\\n![image](https://assets.leetcode.com/users/infoie/image_1576132981.png)\\n"
                    },
                    {
                        "username": "luo980",
                        "content": "![alt text]![0_1499137449406_8cb1c4ff-b5a3-46f1-9aeb-eed2e7012534-image.png](/assets/uploads/files/1499137454573-8cb1c4ff-b5a3-46f1-9aeb-eed2e7012534-image-resized.png) \\nHow should i deal with this problem?"
                    }
                ]
            },
            {
                "id": 1576462,
                "content": [
                    {
                        "username": "dword",
                        "content": "Algorithm A: \"Expand Around Center\" (approach 4 described in the solution).\\nO(n) best case (string contains no palindromes).\\nO(n^2) worst case (string consists of one repeated character).\\n\\nAlgorithm B: modified version of algorithm A that looks ahead to the end of a substring consisting of one repeated character, and expands around the whole substring, avoiding the effort of expanding around each position within the substring.\\nO(n) best case (string consists of one repeated character).\\nO(n^2) worst case (string consists of two alternating characters, like \"ababab\".)\\n\\nAlgorithm C: Manacher\\'s.\\nO(n) best and worst case.\\n\\nImplemented in C++, algorithm A runs in 44 ms, while algorithms B and C both run in 4 ms. Apparently, algorithm A is encountering its worst case but algorithm B is not.\\n\\nSure enough, when tested on \"ab\" repeated 5,000 times, algorithms A and B both run in ~100 ms and algorithm C runs in ~0 ms.\\n\\nSo it appears that in the test cases, there\\'s a long string of one repeated character but no similarly long string of two alternating characters.\\n\\nJust something I find interesting."
                    },
                    {
                        "username": "Ab__23",
                        "content": "I would like to report a bug here that, my solution runs successfully on all except the last testcase. When it shows that test case failed, I looked and found that the test case was empty, I mean such a minor bug in test case checking caused bad effect on my accuracy. Please remove the last test case. :("
                    },
                    {
                        "username": "timewaster69",
                        "content": "agreed. it also directly contradicts the two constraints given in the problem. Even if you were to write a testcase accounting for an empty string it still does not work for some reason."
                    },
                    {
                        "username": "martinvilche98",
                        "content": "\"Time Limit Exceeded\" On Passing solution...\\n\\nHonestly sounds like an excuse to reduce server load."
                    },
                    {
                        "username": "showtroylove",
                        "content": "Key to this task is avoiding string operations in your solution.  It can save you enormous time and avoids the TLE error.  Going one by one or using two loops stripping on char off the front or back doesn\\'t matter.  Reduce it all to int operations and it simplifies the task immensely.  That\\'s my two cents and I\\'m sticking with it. Cheers!"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/longest-palindromic-substring-solution-python-leetcode/\\n"
                    },
                    {
                        "username": "0Camus0",
                        "content": "Hi, \\n\\nMany Manacher\\u2019s Algorithm implementation threads over the internet, but they always handle the even string case as:\\n\\n\"We just add $ to the string before and after, so baba would be $b$a$b$a$ and now we can have this case working too...\"\\n\\nBut it\\'s kind of defeating the purpose of having a O(n) time complexity, because you are doing another O(n) just to add the $, and then another O(n) to remove the $ for the even case. \\n\\nMaybe there is another Manchester\\'s implementation that doesn\\'t require that tricky \"add $\" in order to work.\\n\\nFor my solution I had two pases, one for the even and one for the odd, but I feel dumb when I see solutions from other people.. still 14 ms."
                    },
                    {
                        "username": "kshitij_sanghvi",
                        "content": "For folks getting a TLE. There are certain optimisations that work which would not work for smaller inputs.\\nIf you think about it logically the constant in dictionary look up is substantially higher that that of a list look up. However, we need to create a list and initialise it. This is where the constant in dictionary look up is traded off by default dict.\\n"
                    },
                    {
                        "username": "office93662",
                        "content": "Could someone help me understand how the time complexity is o(n^3) for the brute force?"
                    },
                    {
                        "username": "annen",
                        "content": "There are O(N^2) sub-strings. Checking whether a string is a palindrome is O(N). So O(N^3)"
                    },
                    {
                        "username": "infoie",
                        "content": "O(n3) runtime, O(1) space \\u2013 Brute force:\\nThe obvious brute force solution is to pick all possible starting and ending positions for a substring, and verify if it is a palindrome. There are a total of such substrings (excluding the trivial solution where a character itself is a palindrome).\\nSince verifying each substring takes O(n) time, the run time complexity is O(n3).\\n![image](https://assets.leetcode.com/users/infoie/image_1576132859.png)\\n\\nO(n2) runtime, O(n) space \\u2013 Dynamic programming:\\nTo improve over the brute force solution from a DP approach, first think how we can avoid unnecessary re-computation in validating palindromes. Consider the case \\u201Cababa\\u201D.\\nIf we already knew that \\u201Cbab\\u201D is a palindrome, it is obvious that \\u201Cababa\\u201D must be a palindrome since the two left and right end letters are the same.\\nStated more formally below:\\n\\tDefine P[ i, j ] \\u2190 true if the substring Si \\u2026 Sj is a palindrome, otherwise false.\\n\\tTherefore,\\n\\tP[ i, j ] \\u2190 ( P[ i+1, j-1 ] and Si = Sj )\\n\\tThe base cases are:\\n\\tP[ i, i ] \\u2190 true\\n\\tP[ i, i+1 ] \\u2190 ( Si = Si+1 )\\nThis yields a straight forward DP solution, which we first initialize the one and two letters palindromes, and work our way up finding all three letters palindromes, and so on\\u2026\\nThis gives us a runtime complexity of O(n2) and uses O(n2) space to store the table.\\n![image](https://assets.leetcode.com/users/infoie/image_1576132896.png)\\n\\nO(n2) runtime, O(1) space \\u2013 Simpler solution:\\nIn fact, we could solve it in O(n2) time using only constant space.\\nWe observe that a palindrome mirrors around its center. Therefore, a palindrome can be expanded from its center, and there are only 2n \\u2013 1 such centers.\\nYou might be asking why there are 2n \\u2013 1 but not n centers? The reason is the center of a palindrome can be in between two letters. Such palindromes have even number of letters (such as \\u201Cabba\\u201D) and its center are between the two \\u2018b\\u2019s.\\nSince expanding a palindrome around its center could take O(n) time, the overall complexity is O(n2).\\n![image](https://assets.leetcode.com/users/infoie/image_1576132950.png)\\n\\nO(n) runtime, O(n) space \\u2013 Manacher\\u2019s algorithm:\\n![image](https://assets.leetcode.com/users/infoie/image_1576132981.png)\\n"
                    },
                    {
                        "username": "luo980",
                        "content": "![alt text]![0_1499137449406_8cb1c4ff-b5a3-46f1-9aeb-eed2e7012534-image.png](/assets/uploads/files/1499137454573-8cb1c4ff-b5a3-46f1-9aeb-eed2e7012534-image-resized.png) \\nHow should i deal with this problem?"
                    }
                ]
            },
            {
                "id": 1576344,
                "content": [
                    {
                        "username": "dword",
                        "content": "Algorithm A: \"Expand Around Center\" (approach 4 described in the solution).\\nO(n) best case (string contains no palindromes).\\nO(n^2) worst case (string consists of one repeated character).\\n\\nAlgorithm B: modified version of algorithm A that looks ahead to the end of a substring consisting of one repeated character, and expands around the whole substring, avoiding the effort of expanding around each position within the substring.\\nO(n) best case (string consists of one repeated character).\\nO(n^2) worst case (string consists of two alternating characters, like \"ababab\".)\\n\\nAlgorithm C: Manacher\\'s.\\nO(n) best and worst case.\\n\\nImplemented in C++, algorithm A runs in 44 ms, while algorithms B and C both run in 4 ms. Apparently, algorithm A is encountering its worst case but algorithm B is not.\\n\\nSure enough, when tested on \"ab\" repeated 5,000 times, algorithms A and B both run in ~100 ms and algorithm C runs in ~0 ms.\\n\\nSo it appears that in the test cases, there\\'s a long string of one repeated character but no similarly long string of two alternating characters.\\n\\nJust something I find interesting."
                    },
                    {
                        "username": "Ab__23",
                        "content": "I would like to report a bug here that, my solution runs successfully on all except the last testcase. When it shows that test case failed, I looked and found that the test case was empty, I mean such a minor bug in test case checking caused bad effect on my accuracy. Please remove the last test case. :("
                    },
                    {
                        "username": "timewaster69",
                        "content": "agreed. it also directly contradicts the two constraints given in the problem. Even if you were to write a testcase accounting for an empty string it still does not work for some reason."
                    },
                    {
                        "username": "martinvilche98",
                        "content": "\"Time Limit Exceeded\" On Passing solution...\\n\\nHonestly sounds like an excuse to reduce server load."
                    },
                    {
                        "username": "showtroylove",
                        "content": "Key to this task is avoiding string operations in your solution.  It can save you enormous time and avoids the TLE error.  Going one by one or using two loops stripping on char off the front or back doesn\\'t matter.  Reduce it all to int operations and it simplifies the task immensely.  That\\'s my two cents and I\\'m sticking with it. Cheers!"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/longest-palindromic-substring-solution-python-leetcode/\\n"
                    },
                    {
                        "username": "0Camus0",
                        "content": "Hi, \\n\\nMany Manacher\\u2019s Algorithm implementation threads over the internet, but they always handle the even string case as:\\n\\n\"We just add $ to the string before and after, so baba would be $b$a$b$a$ and now we can have this case working too...\"\\n\\nBut it\\'s kind of defeating the purpose of having a O(n) time complexity, because you are doing another O(n) just to add the $, and then another O(n) to remove the $ for the even case. \\n\\nMaybe there is another Manchester\\'s implementation that doesn\\'t require that tricky \"add $\" in order to work.\\n\\nFor my solution I had two pases, one for the even and one for the odd, but I feel dumb when I see solutions from other people.. still 14 ms."
                    },
                    {
                        "username": "kshitij_sanghvi",
                        "content": "For folks getting a TLE. There are certain optimisations that work which would not work for smaller inputs.\\nIf you think about it logically the constant in dictionary look up is substantially higher that that of a list look up. However, we need to create a list and initialise it. This is where the constant in dictionary look up is traded off by default dict.\\n"
                    },
                    {
                        "username": "office93662",
                        "content": "Could someone help me understand how the time complexity is o(n^3) for the brute force?"
                    },
                    {
                        "username": "annen",
                        "content": "There are O(N^2) sub-strings. Checking whether a string is a palindrome is O(N). So O(N^3)"
                    },
                    {
                        "username": "infoie",
                        "content": "O(n3) runtime, O(1) space \\u2013 Brute force:\\nThe obvious brute force solution is to pick all possible starting and ending positions for a substring, and verify if it is a palindrome. There are a total of such substrings (excluding the trivial solution where a character itself is a palindrome).\\nSince verifying each substring takes O(n) time, the run time complexity is O(n3).\\n![image](https://assets.leetcode.com/users/infoie/image_1576132859.png)\\n\\nO(n2) runtime, O(n) space \\u2013 Dynamic programming:\\nTo improve over the brute force solution from a DP approach, first think how we can avoid unnecessary re-computation in validating palindromes. Consider the case \\u201Cababa\\u201D.\\nIf we already knew that \\u201Cbab\\u201D is a palindrome, it is obvious that \\u201Cababa\\u201D must be a palindrome since the two left and right end letters are the same.\\nStated more formally below:\\n\\tDefine P[ i, j ] \\u2190 true if the substring Si \\u2026 Sj is a palindrome, otherwise false.\\n\\tTherefore,\\n\\tP[ i, j ] \\u2190 ( P[ i+1, j-1 ] and Si = Sj )\\n\\tThe base cases are:\\n\\tP[ i, i ] \\u2190 true\\n\\tP[ i, i+1 ] \\u2190 ( Si = Si+1 )\\nThis yields a straight forward DP solution, which we first initialize the one and two letters palindromes, and work our way up finding all three letters palindromes, and so on\\u2026\\nThis gives us a runtime complexity of O(n2) and uses O(n2) space to store the table.\\n![image](https://assets.leetcode.com/users/infoie/image_1576132896.png)\\n\\nO(n2) runtime, O(1) space \\u2013 Simpler solution:\\nIn fact, we could solve it in O(n2) time using only constant space.\\nWe observe that a palindrome mirrors around its center. Therefore, a palindrome can be expanded from its center, and there are only 2n \\u2013 1 such centers.\\nYou might be asking why there are 2n \\u2013 1 but not n centers? The reason is the center of a palindrome can be in between two letters. Such palindromes have even number of letters (such as \\u201Cabba\\u201D) and its center are between the two \\u2018b\\u2019s.\\nSince expanding a palindrome around its center could take O(n) time, the overall complexity is O(n2).\\n![image](https://assets.leetcode.com/users/infoie/image_1576132950.png)\\n\\nO(n) runtime, O(n) space \\u2013 Manacher\\u2019s algorithm:\\n![image](https://assets.leetcode.com/users/infoie/image_1576132981.png)\\n"
                    },
                    {
                        "username": "luo980",
                        "content": "![alt text]![0_1499137449406_8cb1c4ff-b5a3-46f1-9aeb-eed2e7012534-image.png](/assets/uploads/files/1499137454573-8cb1c4ff-b5a3-46f1-9aeb-eed2e7012534-image-resized.png) \\nHow should i deal with this problem?"
                    }
                ]
            },
            {
                "id": 1574602,
                "content": [
                    {
                        "username": "dword",
                        "content": "Algorithm A: \"Expand Around Center\" (approach 4 described in the solution).\\nO(n) best case (string contains no palindromes).\\nO(n^2) worst case (string consists of one repeated character).\\n\\nAlgorithm B: modified version of algorithm A that looks ahead to the end of a substring consisting of one repeated character, and expands around the whole substring, avoiding the effort of expanding around each position within the substring.\\nO(n) best case (string consists of one repeated character).\\nO(n^2) worst case (string consists of two alternating characters, like \"ababab\".)\\n\\nAlgorithm C: Manacher\\'s.\\nO(n) best and worst case.\\n\\nImplemented in C++, algorithm A runs in 44 ms, while algorithms B and C both run in 4 ms. Apparently, algorithm A is encountering its worst case but algorithm B is not.\\n\\nSure enough, when tested on \"ab\" repeated 5,000 times, algorithms A and B both run in ~100 ms and algorithm C runs in ~0 ms.\\n\\nSo it appears that in the test cases, there\\'s a long string of one repeated character but no similarly long string of two alternating characters.\\n\\nJust something I find interesting."
                    },
                    {
                        "username": "Ab__23",
                        "content": "I would like to report a bug here that, my solution runs successfully on all except the last testcase. When it shows that test case failed, I looked and found that the test case was empty, I mean such a minor bug in test case checking caused bad effect on my accuracy. Please remove the last test case. :("
                    },
                    {
                        "username": "timewaster69",
                        "content": "agreed. it also directly contradicts the two constraints given in the problem. Even if you were to write a testcase accounting for an empty string it still does not work for some reason."
                    },
                    {
                        "username": "martinvilche98",
                        "content": "\"Time Limit Exceeded\" On Passing solution...\\n\\nHonestly sounds like an excuse to reduce server load."
                    },
                    {
                        "username": "showtroylove",
                        "content": "Key to this task is avoiding string operations in your solution.  It can save you enormous time and avoids the TLE error.  Going one by one or using two loops stripping on char off the front or back doesn\\'t matter.  Reduce it all to int operations and it simplifies the task immensely.  That\\'s my two cents and I\\'m sticking with it. Cheers!"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/longest-palindromic-substring-solution-python-leetcode/\\n"
                    },
                    {
                        "username": "0Camus0",
                        "content": "Hi, \\n\\nMany Manacher\\u2019s Algorithm implementation threads over the internet, but they always handle the even string case as:\\n\\n\"We just add $ to the string before and after, so baba would be $b$a$b$a$ and now we can have this case working too...\"\\n\\nBut it\\'s kind of defeating the purpose of having a O(n) time complexity, because you are doing another O(n) just to add the $, and then another O(n) to remove the $ for the even case. \\n\\nMaybe there is another Manchester\\'s implementation that doesn\\'t require that tricky \"add $\" in order to work.\\n\\nFor my solution I had two pases, one for the even and one for the odd, but I feel dumb when I see solutions from other people.. still 14 ms."
                    },
                    {
                        "username": "kshitij_sanghvi",
                        "content": "For folks getting a TLE. There are certain optimisations that work which would not work for smaller inputs.\\nIf you think about it logically the constant in dictionary look up is substantially higher that that of a list look up. However, we need to create a list and initialise it. This is where the constant in dictionary look up is traded off by default dict.\\n"
                    },
                    {
                        "username": "office93662",
                        "content": "Could someone help me understand how the time complexity is o(n^3) for the brute force?"
                    },
                    {
                        "username": "annen",
                        "content": "There are O(N^2) sub-strings. Checking whether a string is a palindrome is O(N). So O(N^3)"
                    },
                    {
                        "username": "infoie",
                        "content": "O(n3) runtime, O(1) space \\u2013 Brute force:\\nThe obvious brute force solution is to pick all possible starting and ending positions for a substring, and verify if it is a palindrome. There are a total of such substrings (excluding the trivial solution where a character itself is a palindrome).\\nSince verifying each substring takes O(n) time, the run time complexity is O(n3).\\n![image](https://assets.leetcode.com/users/infoie/image_1576132859.png)\\n\\nO(n2) runtime, O(n) space \\u2013 Dynamic programming:\\nTo improve over the brute force solution from a DP approach, first think how we can avoid unnecessary re-computation in validating palindromes. Consider the case \\u201Cababa\\u201D.\\nIf we already knew that \\u201Cbab\\u201D is a palindrome, it is obvious that \\u201Cababa\\u201D must be a palindrome since the two left and right end letters are the same.\\nStated more formally below:\\n\\tDefine P[ i, j ] \\u2190 true if the substring Si \\u2026 Sj is a palindrome, otherwise false.\\n\\tTherefore,\\n\\tP[ i, j ] \\u2190 ( P[ i+1, j-1 ] and Si = Sj )\\n\\tThe base cases are:\\n\\tP[ i, i ] \\u2190 true\\n\\tP[ i, i+1 ] \\u2190 ( Si = Si+1 )\\nThis yields a straight forward DP solution, which we first initialize the one and two letters palindromes, and work our way up finding all three letters palindromes, and so on\\u2026\\nThis gives us a runtime complexity of O(n2) and uses O(n2) space to store the table.\\n![image](https://assets.leetcode.com/users/infoie/image_1576132896.png)\\n\\nO(n2) runtime, O(1) space \\u2013 Simpler solution:\\nIn fact, we could solve it in O(n2) time using only constant space.\\nWe observe that a palindrome mirrors around its center. Therefore, a palindrome can be expanded from its center, and there are only 2n \\u2013 1 such centers.\\nYou might be asking why there are 2n \\u2013 1 but not n centers? The reason is the center of a palindrome can be in between two letters. Such palindromes have even number of letters (such as \\u201Cabba\\u201D) and its center are between the two \\u2018b\\u2019s.\\nSince expanding a palindrome around its center could take O(n) time, the overall complexity is O(n2).\\n![image](https://assets.leetcode.com/users/infoie/image_1576132950.png)\\n\\nO(n) runtime, O(n) space \\u2013 Manacher\\u2019s algorithm:\\n![image](https://assets.leetcode.com/users/infoie/image_1576132981.png)\\n"
                    },
                    {
                        "username": "luo980",
                        "content": "![alt text]![0_1499137449406_8cb1c4ff-b5a3-46f1-9aeb-eed2e7012534-image.png](/assets/uploads/files/1499137454573-8cb1c4ff-b5a3-46f1-9aeb-eed2e7012534-image-resized.png) \\nHow should i deal with this problem?"
                    }
                ]
            },
            {
                "id": 1573253,
                "content": [
                    {
                        "username": "dword",
                        "content": "Algorithm A: \"Expand Around Center\" (approach 4 described in the solution).\\nO(n) best case (string contains no palindromes).\\nO(n^2) worst case (string consists of one repeated character).\\n\\nAlgorithm B: modified version of algorithm A that looks ahead to the end of a substring consisting of one repeated character, and expands around the whole substring, avoiding the effort of expanding around each position within the substring.\\nO(n) best case (string consists of one repeated character).\\nO(n^2) worst case (string consists of two alternating characters, like \"ababab\".)\\n\\nAlgorithm C: Manacher\\'s.\\nO(n) best and worst case.\\n\\nImplemented in C++, algorithm A runs in 44 ms, while algorithms B and C both run in 4 ms. Apparently, algorithm A is encountering its worst case but algorithm B is not.\\n\\nSure enough, when tested on \"ab\" repeated 5,000 times, algorithms A and B both run in ~100 ms and algorithm C runs in ~0 ms.\\n\\nSo it appears that in the test cases, there\\'s a long string of one repeated character but no similarly long string of two alternating characters.\\n\\nJust something I find interesting."
                    },
                    {
                        "username": "Ab__23",
                        "content": "I would like to report a bug here that, my solution runs successfully on all except the last testcase. When it shows that test case failed, I looked and found that the test case was empty, I mean such a minor bug in test case checking caused bad effect on my accuracy. Please remove the last test case. :("
                    },
                    {
                        "username": "timewaster69",
                        "content": "agreed. it also directly contradicts the two constraints given in the problem. Even if you were to write a testcase accounting for an empty string it still does not work for some reason."
                    },
                    {
                        "username": "martinvilche98",
                        "content": "\"Time Limit Exceeded\" On Passing solution...\\n\\nHonestly sounds like an excuse to reduce server load."
                    },
                    {
                        "username": "showtroylove",
                        "content": "Key to this task is avoiding string operations in your solution.  It can save you enormous time and avoids the TLE error.  Going one by one or using two loops stripping on char off the front or back doesn\\'t matter.  Reduce it all to int operations and it simplifies the task immensely.  That\\'s my two cents and I\\'m sticking with it. Cheers!"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/longest-palindromic-substring-solution-python-leetcode/\\n"
                    },
                    {
                        "username": "0Camus0",
                        "content": "Hi, \\n\\nMany Manacher\\u2019s Algorithm implementation threads over the internet, but they always handle the even string case as:\\n\\n\"We just add $ to the string before and after, so baba would be $b$a$b$a$ and now we can have this case working too...\"\\n\\nBut it\\'s kind of defeating the purpose of having a O(n) time complexity, because you are doing another O(n) just to add the $, and then another O(n) to remove the $ for the even case. \\n\\nMaybe there is another Manchester\\'s implementation that doesn\\'t require that tricky \"add $\" in order to work.\\n\\nFor my solution I had two pases, one for the even and one for the odd, but I feel dumb when I see solutions from other people.. still 14 ms."
                    },
                    {
                        "username": "kshitij_sanghvi",
                        "content": "For folks getting a TLE. There are certain optimisations that work which would not work for smaller inputs.\\nIf you think about it logically the constant in dictionary look up is substantially higher that that of a list look up. However, we need to create a list and initialise it. This is where the constant in dictionary look up is traded off by default dict.\\n"
                    },
                    {
                        "username": "office93662",
                        "content": "Could someone help me understand how the time complexity is o(n^3) for the brute force?"
                    },
                    {
                        "username": "annen",
                        "content": "There are O(N^2) sub-strings. Checking whether a string is a palindrome is O(N). So O(N^3)"
                    },
                    {
                        "username": "infoie",
                        "content": "O(n3) runtime, O(1) space \\u2013 Brute force:\\nThe obvious brute force solution is to pick all possible starting and ending positions for a substring, and verify if it is a palindrome. There are a total of such substrings (excluding the trivial solution where a character itself is a palindrome).\\nSince verifying each substring takes O(n) time, the run time complexity is O(n3).\\n![image](https://assets.leetcode.com/users/infoie/image_1576132859.png)\\n\\nO(n2) runtime, O(n) space \\u2013 Dynamic programming:\\nTo improve over the brute force solution from a DP approach, first think how we can avoid unnecessary re-computation in validating palindromes. Consider the case \\u201Cababa\\u201D.\\nIf we already knew that \\u201Cbab\\u201D is a palindrome, it is obvious that \\u201Cababa\\u201D must be a palindrome since the two left and right end letters are the same.\\nStated more formally below:\\n\\tDefine P[ i, j ] \\u2190 true if the substring Si \\u2026 Sj is a palindrome, otherwise false.\\n\\tTherefore,\\n\\tP[ i, j ] \\u2190 ( P[ i+1, j-1 ] and Si = Sj )\\n\\tThe base cases are:\\n\\tP[ i, i ] \\u2190 true\\n\\tP[ i, i+1 ] \\u2190 ( Si = Si+1 )\\nThis yields a straight forward DP solution, which we first initialize the one and two letters palindromes, and work our way up finding all three letters palindromes, and so on\\u2026\\nThis gives us a runtime complexity of O(n2) and uses O(n2) space to store the table.\\n![image](https://assets.leetcode.com/users/infoie/image_1576132896.png)\\n\\nO(n2) runtime, O(1) space \\u2013 Simpler solution:\\nIn fact, we could solve it in O(n2) time using only constant space.\\nWe observe that a palindrome mirrors around its center. Therefore, a palindrome can be expanded from its center, and there are only 2n \\u2013 1 such centers.\\nYou might be asking why there are 2n \\u2013 1 but not n centers? The reason is the center of a palindrome can be in between two letters. Such palindromes have even number of letters (such as \\u201Cabba\\u201D) and its center are between the two \\u2018b\\u2019s.\\nSince expanding a palindrome around its center could take O(n) time, the overall complexity is O(n2).\\n![image](https://assets.leetcode.com/users/infoie/image_1576132950.png)\\n\\nO(n) runtime, O(n) space \\u2013 Manacher\\u2019s algorithm:\\n![image](https://assets.leetcode.com/users/infoie/image_1576132981.png)\\n"
                    },
                    {
                        "username": "luo980",
                        "content": "![alt text]![0_1499137449406_8cb1c4ff-b5a3-46f1-9aeb-eed2e7012534-image.png](/assets/uploads/files/1499137454573-8cb1c4ff-b5a3-46f1-9aeb-eed2e7012534-image-resized.png) \\nHow should i deal with this problem?"
                    }
                ]
            },
            {
                "id": 1568803,
                "content": [
                    {
                        "username": "dword",
                        "content": "Algorithm A: \"Expand Around Center\" (approach 4 described in the solution).\\nO(n) best case (string contains no palindromes).\\nO(n^2) worst case (string consists of one repeated character).\\n\\nAlgorithm B: modified version of algorithm A that looks ahead to the end of a substring consisting of one repeated character, and expands around the whole substring, avoiding the effort of expanding around each position within the substring.\\nO(n) best case (string consists of one repeated character).\\nO(n^2) worst case (string consists of two alternating characters, like \"ababab\".)\\n\\nAlgorithm C: Manacher\\'s.\\nO(n) best and worst case.\\n\\nImplemented in C++, algorithm A runs in 44 ms, while algorithms B and C both run in 4 ms. Apparently, algorithm A is encountering its worst case but algorithm B is not.\\n\\nSure enough, when tested on \"ab\" repeated 5,000 times, algorithms A and B both run in ~100 ms and algorithm C runs in ~0 ms.\\n\\nSo it appears that in the test cases, there\\'s a long string of one repeated character but no similarly long string of two alternating characters.\\n\\nJust something I find interesting."
                    },
                    {
                        "username": "Ab__23",
                        "content": "I would like to report a bug here that, my solution runs successfully on all except the last testcase. When it shows that test case failed, I looked and found that the test case was empty, I mean such a minor bug in test case checking caused bad effect on my accuracy. Please remove the last test case. :("
                    },
                    {
                        "username": "timewaster69",
                        "content": "agreed. it also directly contradicts the two constraints given in the problem. Even if you were to write a testcase accounting for an empty string it still does not work for some reason."
                    },
                    {
                        "username": "martinvilche98",
                        "content": "\"Time Limit Exceeded\" On Passing solution...\\n\\nHonestly sounds like an excuse to reduce server load."
                    },
                    {
                        "username": "showtroylove",
                        "content": "Key to this task is avoiding string operations in your solution.  It can save you enormous time and avoids the TLE error.  Going one by one or using two loops stripping on char off the front or back doesn\\'t matter.  Reduce it all to int operations and it simplifies the task immensely.  That\\'s my two cents and I\\'m sticking with it. Cheers!"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/longest-palindromic-substring-solution-python-leetcode/\\n"
                    },
                    {
                        "username": "0Camus0",
                        "content": "Hi, \\n\\nMany Manacher\\u2019s Algorithm implementation threads over the internet, but they always handle the even string case as:\\n\\n\"We just add $ to the string before and after, so baba would be $b$a$b$a$ and now we can have this case working too...\"\\n\\nBut it\\'s kind of defeating the purpose of having a O(n) time complexity, because you are doing another O(n) just to add the $, and then another O(n) to remove the $ for the even case. \\n\\nMaybe there is another Manchester\\'s implementation that doesn\\'t require that tricky \"add $\" in order to work.\\n\\nFor my solution I had two pases, one for the even and one for the odd, but I feel dumb when I see solutions from other people.. still 14 ms."
                    },
                    {
                        "username": "kshitij_sanghvi",
                        "content": "For folks getting a TLE. There are certain optimisations that work which would not work for smaller inputs.\\nIf you think about it logically the constant in dictionary look up is substantially higher that that of a list look up. However, we need to create a list and initialise it. This is where the constant in dictionary look up is traded off by default dict.\\n"
                    },
                    {
                        "username": "office93662",
                        "content": "Could someone help me understand how the time complexity is o(n^3) for the brute force?"
                    },
                    {
                        "username": "annen",
                        "content": "There are O(N^2) sub-strings. Checking whether a string is a palindrome is O(N). So O(N^3)"
                    },
                    {
                        "username": "infoie",
                        "content": "O(n3) runtime, O(1) space \\u2013 Brute force:\\nThe obvious brute force solution is to pick all possible starting and ending positions for a substring, and verify if it is a palindrome. There are a total of such substrings (excluding the trivial solution where a character itself is a palindrome).\\nSince verifying each substring takes O(n) time, the run time complexity is O(n3).\\n![image](https://assets.leetcode.com/users/infoie/image_1576132859.png)\\n\\nO(n2) runtime, O(n) space \\u2013 Dynamic programming:\\nTo improve over the brute force solution from a DP approach, first think how we can avoid unnecessary re-computation in validating palindromes. Consider the case \\u201Cababa\\u201D.\\nIf we already knew that \\u201Cbab\\u201D is a palindrome, it is obvious that \\u201Cababa\\u201D must be a palindrome since the two left and right end letters are the same.\\nStated more formally below:\\n\\tDefine P[ i, j ] \\u2190 true if the substring Si \\u2026 Sj is a palindrome, otherwise false.\\n\\tTherefore,\\n\\tP[ i, j ] \\u2190 ( P[ i+1, j-1 ] and Si = Sj )\\n\\tThe base cases are:\\n\\tP[ i, i ] \\u2190 true\\n\\tP[ i, i+1 ] \\u2190 ( Si = Si+1 )\\nThis yields a straight forward DP solution, which we first initialize the one and two letters palindromes, and work our way up finding all three letters palindromes, and so on\\u2026\\nThis gives us a runtime complexity of O(n2) and uses O(n2) space to store the table.\\n![image](https://assets.leetcode.com/users/infoie/image_1576132896.png)\\n\\nO(n2) runtime, O(1) space \\u2013 Simpler solution:\\nIn fact, we could solve it in O(n2) time using only constant space.\\nWe observe that a palindrome mirrors around its center. Therefore, a palindrome can be expanded from its center, and there are only 2n \\u2013 1 such centers.\\nYou might be asking why there are 2n \\u2013 1 but not n centers? The reason is the center of a palindrome can be in between two letters. Such palindromes have even number of letters (such as \\u201Cabba\\u201D) and its center are between the two \\u2018b\\u2019s.\\nSince expanding a palindrome around its center could take O(n) time, the overall complexity is O(n2).\\n![image](https://assets.leetcode.com/users/infoie/image_1576132950.png)\\n\\nO(n) runtime, O(n) space \\u2013 Manacher\\u2019s algorithm:\\n![image](https://assets.leetcode.com/users/infoie/image_1576132981.png)\\n"
                    },
                    {
                        "username": "luo980",
                        "content": "![alt text]![0_1499137449406_8cb1c4ff-b5a3-46f1-9aeb-eed2e7012534-image.png](/assets/uploads/files/1499137454573-8cb1c4ff-b5a3-46f1-9aeb-eed2e7012534-image-resized.png) \\nHow should i deal with this problem?"
                    }
                ]
            },
            {
                "id": 2075986,
                "content": [
                    {
                        "username": "sparasuram",
                        "content": "test case \"ac\" is not a palindromic string. But it shows output as \"a\""
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "we have to find substring, so the string itself could be not palindromic, the answers to that question could be either \"a\" or \"c\", cause they are palindromic"
                    },
                    {
                        "username": "anupamprakash82",
                        "content": "Why O(n^2) solution is giving the TLE? Since the constraint is 1 <= s.length <= 1000, O(n^2) solution should work"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@anupamprakash82](/anupamprakash82) Nuh"
                    },
                    {
                        "username": "anupamprakash82",
                        "content": "[@DamianIvanochko](/DamianIvanochko) is your code getting AC?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "bro my solutions is O(n^3)"
                    },
                    {
                        "username": "piyush_mehta22",
                        "content": "if(s.charAt(i) == s.charAt(j) && substring(i,j).length() > longestSubstring.lenght() && isPalindrome(substring(i,j)) {\\nlongestSubstring = substring(i,j);\\n}\\nis much much better than \\nif(isPalindrome(substring(i,j)) {\\n  if(substring.length() > longestSubstring.length()) {\\n     longestubstring = substring(i,j);\\n  }\\n}\\n\\nbecause the first condition first checks whether first and last char are equal or not, then it checks if length is greater or not then it goes for checking is it palindrome or not(which removes  most of the unwanted cases and saves some time), while in second, first it checks the palindrome condition for all string then makes further decision"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@georgezakharov](/georgezakharov) good job lil nigga"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "That\\'s gay, don\\'t post solutions here"
                    },
                    {
                        "username": "jai218",
                        "content": "How do I optimize my code further? \\nI have defined a function outside the class that checks if a string is a palindrome (recursive) and then in the main function i go over all possible substrings starting from the biggest to smallest and checking if that is a palindrome, if True then return that. "
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "anyways your code is still better, mine runs at O(n^3)\\uD83D\\uDC80"
                    },
                    {
                        "username": "AnthonyR21",
                        "content": "## Intuition \n- The problem is to find the longest palndromic substring within a given string.\n- A palindrome reads the same backward as forward.\n- We can use a brute-force approach to check all possible substrings and find the longest one that is also a palindrome.\n\n## Approach\n- Define an ```isPalindrome``` method to check if substring is a palindrome. This method compares characters from the start and end of the substring, moving toward the center.\n- In the ```longestPalindrome``` method:\n- Initialize variables ```maxLength``` to store the length of the longest palindrome found so far and start to store the starting index of the longest palindrome.\n- Iterate through all possible pairs of indexes (i, j) to consider all substrings.\n- For each substring (i, j) check if it's a palindrome using the ```isPalindrome``` method.\n- If it's a palindrome and longer than the current maximum, update ```maxLength``` and start."
                    },
                    {
                        "username": "benlhachemi",
                        "content": "if you passed the \"RUN\" and get the message \"Time Limit Exceeded\" on Submit, your code is correct but the complexity is not.\\nTry to reduce complexity of your algorithm."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "GigaNigger"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "My dick is 20 inches"
                    },
                    {
                        "username": "igorKor",
                        "content": "According to the condition of the task, you need to find the longest palindrome.\nWhen tested, the input string is \"babadada\".\nThe test expects to receive \"adada\".\nBut the longest polyndrom in this case will be the substring \"adabada\""
                    },
                    {
                        "username": "AMerrill",
                        "content": "a substring is a set of continuous characters (i.e. you cannot rearrange characters). Thus, for the example given, \"*adada*\" is the longest palindrome that is a substring of \"*babadada*\""
                    },
                    {
                        "username": "mishraanuyesh7",
                        "content": "javascript\\n"
                    },
                    {
                        "username": "showtroylove",
                        "content": "How do you add an image to post?"
                    }
                ]
            },
            {
                "id": 2069483,
                "content": [
                    {
                        "username": "sparasuram",
                        "content": "test case \"ac\" is not a palindromic string. But it shows output as \"a\""
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "we have to find substring, so the string itself could be not palindromic, the answers to that question could be either \"a\" or \"c\", cause they are palindromic"
                    },
                    {
                        "username": "anupamprakash82",
                        "content": "Why O(n^2) solution is giving the TLE? Since the constraint is 1 <= s.length <= 1000, O(n^2) solution should work"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@anupamprakash82](/anupamprakash82) Nuh"
                    },
                    {
                        "username": "anupamprakash82",
                        "content": "[@DamianIvanochko](/DamianIvanochko) is your code getting AC?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "bro my solutions is O(n^3)"
                    },
                    {
                        "username": "piyush_mehta22",
                        "content": "if(s.charAt(i) == s.charAt(j) && substring(i,j).length() > longestSubstring.lenght() && isPalindrome(substring(i,j)) {\\nlongestSubstring = substring(i,j);\\n}\\nis much much better than \\nif(isPalindrome(substring(i,j)) {\\n  if(substring.length() > longestSubstring.length()) {\\n     longestubstring = substring(i,j);\\n  }\\n}\\n\\nbecause the first condition first checks whether first and last char are equal or not, then it checks if length is greater or not then it goes for checking is it palindrome or not(which removes  most of the unwanted cases and saves some time), while in second, first it checks the palindrome condition for all string then makes further decision"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@georgezakharov](/georgezakharov) good job lil nigga"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "That\\'s gay, don\\'t post solutions here"
                    },
                    {
                        "username": "jai218",
                        "content": "How do I optimize my code further? \\nI have defined a function outside the class that checks if a string is a palindrome (recursive) and then in the main function i go over all possible substrings starting from the biggest to smallest and checking if that is a palindrome, if True then return that. "
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "anyways your code is still better, mine runs at O(n^3)\\uD83D\\uDC80"
                    },
                    {
                        "username": "AnthonyR21",
                        "content": "## Intuition \n- The problem is to find the longest palndromic substring within a given string.\n- A palindrome reads the same backward as forward.\n- We can use a brute-force approach to check all possible substrings and find the longest one that is also a palindrome.\n\n## Approach\n- Define an ```isPalindrome``` method to check if substring is a palindrome. This method compares characters from the start and end of the substring, moving toward the center.\n- In the ```longestPalindrome``` method:\n- Initialize variables ```maxLength``` to store the length of the longest palindrome found so far and start to store the starting index of the longest palindrome.\n- Iterate through all possible pairs of indexes (i, j) to consider all substrings.\n- For each substring (i, j) check if it's a palindrome using the ```isPalindrome``` method.\n- If it's a palindrome and longer than the current maximum, update ```maxLength``` and start."
                    },
                    {
                        "username": "benlhachemi",
                        "content": "if you passed the \"RUN\" and get the message \"Time Limit Exceeded\" on Submit, your code is correct but the complexity is not.\\nTry to reduce complexity of your algorithm."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "GigaNigger"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "My dick is 20 inches"
                    },
                    {
                        "username": "igorKor",
                        "content": "According to the condition of the task, you need to find the longest palindrome.\nWhen tested, the input string is \"babadada\".\nThe test expects to receive \"adada\".\nBut the longest polyndrom in this case will be the substring \"adabada\""
                    },
                    {
                        "username": "AMerrill",
                        "content": "a substring is a set of continuous characters (i.e. you cannot rearrange characters). Thus, for the example given, \"*adada*\" is the longest palindrome that is a substring of \"*babadada*\""
                    },
                    {
                        "username": "mishraanuyesh7",
                        "content": "javascript\\n"
                    },
                    {
                        "username": "showtroylove",
                        "content": "How do you add an image to post?"
                    }
                ]
            },
            {
                "id": 2063076,
                "content": [
                    {
                        "username": "sparasuram",
                        "content": "test case \"ac\" is not a palindromic string. But it shows output as \"a\""
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "we have to find substring, so the string itself could be not palindromic, the answers to that question could be either \"a\" or \"c\", cause they are palindromic"
                    },
                    {
                        "username": "anupamprakash82",
                        "content": "Why O(n^2) solution is giving the TLE? Since the constraint is 1 <= s.length <= 1000, O(n^2) solution should work"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@anupamprakash82](/anupamprakash82) Nuh"
                    },
                    {
                        "username": "anupamprakash82",
                        "content": "[@DamianIvanochko](/DamianIvanochko) is your code getting AC?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "bro my solutions is O(n^3)"
                    },
                    {
                        "username": "piyush_mehta22",
                        "content": "if(s.charAt(i) == s.charAt(j) && substring(i,j).length() > longestSubstring.lenght() && isPalindrome(substring(i,j)) {\\nlongestSubstring = substring(i,j);\\n}\\nis much much better than \\nif(isPalindrome(substring(i,j)) {\\n  if(substring.length() > longestSubstring.length()) {\\n     longestubstring = substring(i,j);\\n  }\\n}\\n\\nbecause the first condition first checks whether first and last char are equal or not, then it checks if length is greater or not then it goes for checking is it palindrome or not(which removes  most of the unwanted cases and saves some time), while in second, first it checks the palindrome condition for all string then makes further decision"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@georgezakharov](/georgezakharov) good job lil nigga"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "That\\'s gay, don\\'t post solutions here"
                    },
                    {
                        "username": "jai218",
                        "content": "How do I optimize my code further? \\nI have defined a function outside the class that checks if a string is a palindrome (recursive) and then in the main function i go over all possible substrings starting from the biggest to smallest and checking if that is a palindrome, if True then return that. "
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "anyways your code is still better, mine runs at O(n^3)\\uD83D\\uDC80"
                    },
                    {
                        "username": "AnthonyR21",
                        "content": "## Intuition \n- The problem is to find the longest palndromic substring within a given string.\n- A palindrome reads the same backward as forward.\n- We can use a brute-force approach to check all possible substrings and find the longest one that is also a palindrome.\n\n## Approach\n- Define an ```isPalindrome``` method to check if substring is a palindrome. This method compares characters from the start and end of the substring, moving toward the center.\n- In the ```longestPalindrome``` method:\n- Initialize variables ```maxLength``` to store the length of the longest palindrome found so far and start to store the starting index of the longest palindrome.\n- Iterate through all possible pairs of indexes (i, j) to consider all substrings.\n- For each substring (i, j) check if it's a palindrome using the ```isPalindrome``` method.\n- If it's a palindrome and longer than the current maximum, update ```maxLength``` and start."
                    },
                    {
                        "username": "benlhachemi",
                        "content": "if you passed the \"RUN\" and get the message \"Time Limit Exceeded\" on Submit, your code is correct but the complexity is not.\\nTry to reduce complexity of your algorithm."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "GigaNigger"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "My dick is 20 inches"
                    },
                    {
                        "username": "igorKor",
                        "content": "According to the condition of the task, you need to find the longest palindrome.\nWhen tested, the input string is \"babadada\".\nThe test expects to receive \"adada\".\nBut the longest polyndrom in this case will be the substring \"adabada\""
                    },
                    {
                        "username": "AMerrill",
                        "content": "a substring is a set of continuous characters (i.e. you cannot rearrange characters). Thus, for the example given, \"*adada*\" is the longest palindrome that is a substring of \"*babadada*\""
                    },
                    {
                        "username": "mishraanuyesh7",
                        "content": "javascript\\n"
                    },
                    {
                        "username": "showtroylove",
                        "content": "How do you add an image to post?"
                    }
                ]
            },
            {
                "id": 2049173,
                "content": [
                    {
                        "username": "sparasuram",
                        "content": "test case \"ac\" is not a palindromic string. But it shows output as \"a\""
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "we have to find substring, so the string itself could be not palindromic, the answers to that question could be either \"a\" or \"c\", cause they are palindromic"
                    },
                    {
                        "username": "anupamprakash82",
                        "content": "Why O(n^2) solution is giving the TLE? Since the constraint is 1 <= s.length <= 1000, O(n^2) solution should work"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@anupamprakash82](/anupamprakash82) Nuh"
                    },
                    {
                        "username": "anupamprakash82",
                        "content": "[@DamianIvanochko](/DamianIvanochko) is your code getting AC?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "bro my solutions is O(n^3)"
                    },
                    {
                        "username": "piyush_mehta22",
                        "content": "if(s.charAt(i) == s.charAt(j) && substring(i,j).length() > longestSubstring.lenght() && isPalindrome(substring(i,j)) {\\nlongestSubstring = substring(i,j);\\n}\\nis much much better than \\nif(isPalindrome(substring(i,j)) {\\n  if(substring.length() > longestSubstring.length()) {\\n     longestubstring = substring(i,j);\\n  }\\n}\\n\\nbecause the first condition first checks whether first and last char are equal or not, then it checks if length is greater or not then it goes for checking is it palindrome or not(which removes  most of the unwanted cases and saves some time), while in second, first it checks the palindrome condition for all string then makes further decision"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@georgezakharov](/georgezakharov) good job lil nigga"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "That\\'s gay, don\\'t post solutions here"
                    },
                    {
                        "username": "jai218",
                        "content": "How do I optimize my code further? \\nI have defined a function outside the class that checks if a string is a palindrome (recursive) and then in the main function i go over all possible substrings starting from the biggest to smallest and checking if that is a palindrome, if True then return that. "
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "anyways your code is still better, mine runs at O(n^3)\\uD83D\\uDC80"
                    },
                    {
                        "username": "AnthonyR21",
                        "content": "## Intuition \n- The problem is to find the longest palndromic substring within a given string.\n- A palindrome reads the same backward as forward.\n- We can use a brute-force approach to check all possible substrings and find the longest one that is also a palindrome.\n\n## Approach\n- Define an ```isPalindrome``` method to check if substring is a palindrome. This method compares characters from the start and end of the substring, moving toward the center.\n- In the ```longestPalindrome``` method:\n- Initialize variables ```maxLength``` to store the length of the longest palindrome found so far and start to store the starting index of the longest palindrome.\n- Iterate through all possible pairs of indexes (i, j) to consider all substrings.\n- For each substring (i, j) check if it's a palindrome using the ```isPalindrome``` method.\n- If it's a palindrome and longer than the current maximum, update ```maxLength``` and start."
                    },
                    {
                        "username": "benlhachemi",
                        "content": "if you passed the \"RUN\" and get the message \"Time Limit Exceeded\" on Submit, your code is correct but the complexity is not.\\nTry to reduce complexity of your algorithm."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "GigaNigger"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "My dick is 20 inches"
                    },
                    {
                        "username": "igorKor",
                        "content": "According to the condition of the task, you need to find the longest palindrome.\nWhen tested, the input string is \"babadada\".\nThe test expects to receive \"adada\".\nBut the longest polyndrom in this case will be the substring \"adabada\""
                    },
                    {
                        "username": "AMerrill",
                        "content": "a substring is a set of continuous characters (i.e. you cannot rearrange characters). Thus, for the example given, \"*adada*\" is the longest palindrome that is a substring of \"*babadada*\""
                    },
                    {
                        "username": "mishraanuyesh7",
                        "content": "javascript\\n"
                    },
                    {
                        "username": "showtroylove",
                        "content": "How do you add an image to post?"
                    }
                ]
            },
            {
                "id": 2041500,
                "content": [
                    {
                        "username": "sparasuram",
                        "content": "test case \"ac\" is not a palindromic string. But it shows output as \"a\""
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "we have to find substring, so the string itself could be not palindromic, the answers to that question could be either \"a\" or \"c\", cause they are palindromic"
                    },
                    {
                        "username": "anupamprakash82",
                        "content": "Why O(n^2) solution is giving the TLE? Since the constraint is 1 <= s.length <= 1000, O(n^2) solution should work"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@anupamprakash82](/anupamprakash82) Nuh"
                    },
                    {
                        "username": "anupamprakash82",
                        "content": "[@DamianIvanochko](/DamianIvanochko) is your code getting AC?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "bro my solutions is O(n^3)"
                    },
                    {
                        "username": "piyush_mehta22",
                        "content": "if(s.charAt(i) == s.charAt(j) && substring(i,j).length() > longestSubstring.lenght() && isPalindrome(substring(i,j)) {\\nlongestSubstring = substring(i,j);\\n}\\nis much much better than \\nif(isPalindrome(substring(i,j)) {\\n  if(substring.length() > longestSubstring.length()) {\\n     longestubstring = substring(i,j);\\n  }\\n}\\n\\nbecause the first condition first checks whether first and last char are equal or not, then it checks if length is greater or not then it goes for checking is it palindrome or not(which removes  most of the unwanted cases and saves some time), while in second, first it checks the palindrome condition for all string then makes further decision"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@georgezakharov](/georgezakharov) good job lil nigga"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "That\\'s gay, don\\'t post solutions here"
                    },
                    {
                        "username": "jai218",
                        "content": "How do I optimize my code further? \\nI have defined a function outside the class that checks if a string is a palindrome (recursive) and then in the main function i go over all possible substrings starting from the biggest to smallest and checking if that is a palindrome, if True then return that. "
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "anyways your code is still better, mine runs at O(n^3)\\uD83D\\uDC80"
                    },
                    {
                        "username": "AnthonyR21",
                        "content": "## Intuition \n- The problem is to find the longest palndromic substring within a given string.\n- A palindrome reads the same backward as forward.\n- We can use a brute-force approach to check all possible substrings and find the longest one that is also a palindrome.\n\n## Approach\n- Define an ```isPalindrome``` method to check if substring is a palindrome. This method compares characters from the start and end of the substring, moving toward the center.\n- In the ```longestPalindrome``` method:\n- Initialize variables ```maxLength``` to store the length of the longest palindrome found so far and start to store the starting index of the longest palindrome.\n- Iterate through all possible pairs of indexes (i, j) to consider all substrings.\n- For each substring (i, j) check if it's a palindrome using the ```isPalindrome``` method.\n- If it's a palindrome and longer than the current maximum, update ```maxLength``` and start."
                    },
                    {
                        "username": "benlhachemi",
                        "content": "if you passed the \"RUN\" and get the message \"Time Limit Exceeded\" on Submit, your code is correct but the complexity is not.\\nTry to reduce complexity of your algorithm."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "GigaNigger"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "My dick is 20 inches"
                    },
                    {
                        "username": "igorKor",
                        "content": "According to the condition of the task, you need to find the longest palindrome.\nWhen tested, the input string is \"babadada\".\nThe test expects to receive \"adada\".\nBut the longest polyndrom in this case will be the substring \"adabada\""
                    },
                    {
                        "username": "AMerrill",
                        "content": "a substring is a set of continuous characters (i.e. you cannot rearrange characters). Thus, for the example given, \"*adada*\" is the longest palindrome that is a substring of \"*babadada*\""
                    },
                    {
                        "username": "mishraanuyesh7",
                        "content": "javascript\\n"
                    },
                    {
                        "username": "showtroylove",
                        "content": "How do you add an image to post?"
                    }
                ]
            },
            {
                "id": 2036858,
                "content": [
                    {
                        "username": "sparasuram",
                        "content": "test case \"ac\" is not a palindromic string. But it shows output as \"a\""
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "we have to find substring, so the string itself could be not palindromic, the answers to that question could be either \"a\" or \"c\", cause they are palindromic"
                    },
                    {
                        "username": "anupamprakash82",
                        "content": "Why O(n^2) solution is giving the TLE? Since the constraint is 1 <= s.length <= 1000, O(n^2) solution should work"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@anupamprakash82](/anupamprakash82) Nuh"
                    },
                    {
                        "username": "anupamprakash82",
                        "content": "[@DamianIvanochko](/DamianIvanochko) is your code getting AC?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "bro my solutions is O(n^3)"
                    },
                    {
                        "username": "piyush_mehta22",
                        "content": "if(s.charAt(i) == s.charAt(j) && substring(i,j).length() > longestSubstring.lenght() && isPalindrome(substring(i,j)) {\\nlongestSubstring = substring(i,j);\\n}\\nis much much better than \\nif(isPalindrome(substring(i,j)) {\\n  if(substring.length() > longestSubstring.length()) {\\n     longestubstring = substring(i,j);\\n  }\\n}\\n\\nbecause the first condition first checks whether first and last char are equal or not, then it checks if length is greater or not then it goes for checking is it palindrome or not(which removes  most of the unwanted cases and saves some time), while in second, first it checks the palindrome condition for all string then makes further decision"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@georgezakharov](/georgezakharov) good job lil nigga"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "That\\'s gay, don\\'t post solutions here"
                    },
                    {
                        "username": "jai218",
                        "content": "How do I optimize my code further? \\nI have defined a function outside the class that checks if a string is a palindrome (recursive) and then in the main function i go over all possible substrings starting from the biggest to smallest and checking if that is a palindrome, if True then return that. "
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "anyways your code is still better, mine runs at O(n^3)\\uD83D\\uDC80"
                    },
                    {
                        "username": "AnthonyR21",
                        "content": "## Intuition \n- The problem is to find the longest palndromic substring within a given string.\n- A palindrome reads the same backward as forward.\n- We can use a brute-force approach to check all possible substrings and find the longest one that is also a palindrome.\n\n## Approach\n- Define an ```isPalindrome``` method to check if substring is a palindrome. This method compares characters from the start and end of the substring, moving toward the center.\n- In the ```longestPalindrome``` method:\n- Initialize variables ```maxLength``` to store the length of the longest palindrome found so far and start to store the starting index of the longest palindrome.\n- Iterate through all possible pairs of indexes (i, j) to consider all substrings.\n- For each substring (i, j) check if it's a palindrome using the ```isPalindrome``` method.\n- If it's a palindrome and longer than the current maximum, update ```maxLength``` and start."
                    },
                    {
                        "username": "benlhachemi",
                        "content": "if you passed the \"RUN\" and get the message \"Time Limit Exceeded\" on Submit, your code is correct but the complexity is not.\\nTry to reduce complexity of your algorithm."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "GigaNigger"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "My dick is 20 inches"
                    },
                    {
                        "username": "igorKor",
                        "content": "According to the condition of the task, you need to find the longest palindrome.\nWhen tested, the input string is \"babadada\".\nThe test expects to receive \"adada\".\nBut the longest polyndrom in this case will be the substring \"adabada\""
                    },
                    {
                        "username": "AMerrill",
                        "content": "a substring is a set of continuous characters (i.e. you cannot rearrange characters). Thus, for the example given, \"*adada*\" is the longest palindrome that is a substring of \"*babadada*\""
                    },
                    {
                        "username": "mishraanuyesh7",
                        "content": "javascript\\n"
                    },
                    {
                        "username": "showtroylove",
                        "content": "How do you add an image to post?"
                    }
                ]
            },
            {
                "id": 2028006,
                "content": [
                    {
                        "username": "sparasuram",
                        "content": "test case \"ac\" is not a palindromic string. But it shows output as \"a\""
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "we have to find substring, so the string itself could be not palindromic, the answers to that question could be either \"a\" or \"c\", cause they are palindromic"
                    },
                    {
                        "username": "anupamprakash82",
                        "content": "Why O(n^2) solution is giving the TLE? Since the constraint is 1 <= s.length <= 1000, O(n^2) solution should work"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@anupamprakash82](/anupamprakash82) Nuh"
                    },
                    {
                        "username": "anupamprakash82",
                        "content": "[@DamianIvanochko](/DamianIvanochko) is your code getting AC?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "bro my solutions is O(n^3)"
                    },
                    {
                        "username": "piyush_mehta22",
                        "content": "if(s.charAt(i) == s.charAt(j) && substring(i,j).length() > longestSubstring.lenght() && isPalindrome(substring(i,j)) {\\nlongestSubstring = substring(i,j);\\n}\\nis much much better than \\nif(isPalindrome(substring(i,j)) {\\n  if(substring.length() > longestSubstring.length()) {\\n     longestubstring = substring(i,j);\\n  }\\n}\\n\\nbecause the first condition first checks whether first and last char are equal or not, then it checks if length is greater or not then it goes for checking is it palindrome or not(which removes  most of the unwanted cases and saves some time), while in second, first it checks the palindrome condition for all string then makes further decision"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@georgezakharov](/georgezakharov) good job lil nigga"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "That\\'s gay, don\\'t post solutions here"
                    },
                    {
                        "username": "jai218",
                        "content": "How do I optimize my code further? \\nI have defined a function outside the class that checks if a string is a palindrome (recursive) and then in the main function i go over all possible substrings starting from the biggest to smallest and checking if that is a palindrome, if True then return that. "
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "anyways your code is still better, mine runs at O(n^3)\\uD83D\\uDC80"
                    },
                    {
                        "username": "AnthonyR21",
                        "content": "## Intuition \n- The problem is to find the longest palndromic substring within a given string.\n- A palindrome reads the same backward as forward.\n- We can use a brute-force approach to check all possible substrings and find the longest one that is also a palindrome.\n\n## Approach\n- Define an ```isPalindrome``` method to check if substring is a palindrome. This method compares characters from the start and end of the substring, moving toward the center.\n- In the ```longestPalindrome``` method:\n- Initialize variables ```maxLength``` to store the length of the longest palindrome found so far and start to store the starting index of the longest palindrome.\n- Iterate through all possible pairs of indexes (i, j) to consider all substrings.\n- For each substring (i, j) check if it's a palindrome using the ```isPalindrome``` method.\n- If it's a palindrome and longer than the current maximum, update ```maxLength``` and start."
                    },
                    {
                        "username": "benlhachemi",
                        "content": "if you passed the \"RUN\" and get the message \"Time Limit Exceeded\" on Submit, your code is correct but the complexity is not.\\nTry to reduce complexity of your algorithm."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "GigaNigger"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "My dick is 20 inches"
                    },
                    {
                        "username": "igorKor",
                        "content": "According to the condition of the task, you need to find the longest palindrome.\nWhen tested, the input string is \"babadada\".\nThe test expects to receive \"adada\".\nBut the longest polyndrom in this case will be the substring \"adabada\""
                    },
                    {
                        "username": "AMerrill",
                        "content": "a substring is a set of continuous characters (i.e. you cannot rearrange characters). Thus, for the example given, \"*adada*\" is the longest palindrome that is a substring of \"*babadada*\""
                    },
                    {
                        "username": "mishraanuyesh7",
                        "content": "javascript\\n"
                    },
                    {
                        "username": "showtroylove",
                        "content": "How do you add an image to post?"
                    }
                ]
            },
            {
                "id": 1803485,
                "content": [
                    {
                        "username": "sparasuram",
                        "content": "test case \"ac\" is not a palindromic string. But it shows output as \"a\""
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "we have to find substring, so the string itself could be not palindromic, the answers to that question could be either \"a\" or \"c\", cause they are palindromic"
                    },
                    {
                        "username": "anupamprakash82",
                        "content": "Why O(n^2) solution is giving the TLE? Since the constraint is 1 <= s.length <= 1000, O(n^2) solution should work"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@anupamprakash82](/anupamprakash82) Nuh"
                    },
                    {
                        "username": "anupamprakash82",
                        "content": "[@DamianIvanochko](/DamianIvanochko) is your code getting AC?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "bro my solutions is O(n^3)"
                    },
                    {
                        "username": "piyush_mehta22",
                        "content": "if(s.charAt(i) == s.charAt(j) && substring(i,j).length() > longestSubstring.lenght() && isPalindrome(substring(i,j)) {\\nlongestSubstring = substring(i,j);\\n}\\nis much much better than \\nif(isPalindrome(substring(i,j)) {\\n  if(substring.length() > longestSubstring.length()) {\\n     longestubstring = substring(i,j);\\n  }\\n}\\n\\nbecause the first condition first checks whether first and last char are equal or not, then it checks if length is greater or not then it goes for checking is it palindrome or not(which removes  most of the unwanted cases and saves some time), while in second, first it checks the palindrome condition for all string then makes further decision"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@georgezakharov](/georgezakharov) good job lil nigga"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "That\\'s gay, don\\'t post solutions here"
                    },
                    {
                        "username": "jai218",
                        "content": "How do I optimize my code further? \\nI have defined a function outside the class that checks if a string is a palindrome (recursive) and then in the main function i go over all possible substrings starting from the biggest to smallest and checking if that is a palindrome, if True then return that. "
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "anyways your code is still better, mine runs at O(n^3)\\uD83D\\uDC80"
                    },
                    {
                        "username": "AnthonyR21",
                        "content": "## Intuition \n- The problem is to find the longest palndromic substring within a given string.\n- A palindrome reads the same backward as forward.\n- We can use a brute-force approach to check all possible substrings and find the longest one that is also a palindrome.\n\n## Approach\n- Define an ```isPalindrome``` method to check if substring is a palindrome. This method compares characters from the start and end of the substring, moving toward the center.\n- In the ```longestPalindrome``` method:\n- Initialize variables ```maxLength``` to store the length of the longest palindrome found so far and start to store the starting index of the longest palindrome.\n- Iterate through all possible pairs of indexes (i, j) to consider all substrings.\n- For each substring (i, j) check if it's a palindrome using the ```isPalindrome``` method.\n- If it's a palindrome and longer than the current maximum, update ```maxLength``` and start."
                    },
                    {
                        "username": "benlhachemi",
                        "content": "if you passed the \"RUN\" and get the message \"Time Limit Exceeded\" on Submit, your code is correct but the complexity is not.\\nTry to reduce complexity of your algorithm."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "GigaNigger"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "My dick is 20 inches"
                    },
                    {
                        "username": "igorKor",
                        "content": "According to the condition of the task, you need to find the longest palindrome.\nWhen tested, the input string is \"babadada\".\nThe test expects to receive \"adada\".\nBut the longest polyndrom in this case will be the substring \"adabada\""
                    },
                    {
                        "username": "AMerrill",
                        "content": "a substring is a set of continuous characters (i.e. you cannot rearrange characters). Thus, for the example given, \"*adada*\" is the longest palindrome that is a substring of \"*babadada*\""
                    },
                    {
                        "username": "mishraanuyesh7",
                        "content": "javascript\\n"
                    },
                    {
                        "username": "showtroylove",
                        "content": "How do you add an image to post?"
                    }
                ]
            },
            {
                "id": 1719259,
                "content": [
                    {
                        "username": "sparasuram",
                        "content": "test case \"ac\" is not a palindromic string. But it shows output as \"a\""
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "we have to find substring, so the string itself could be not palindromic, the answers to that question could be either \"a\" or \"c\", cause they are palindromic"
                    },
                    {
                        "username": "anupamprakash82",
                        "content": "Why O(n^2) solution is giving the TLE? Since the constraint is 1 <= s.length <= 1000, O(n^2) solution should work"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@anupamprakash82](/anupamprakash82) Nuh"
                    },
                    {
                        "username": "anupamprakash82",
                        "content": "[@DamianIvanochko](/DamianIvanochko) is your code getting AC?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "bro my solutions is O(n^3)"
                    },
                    {
                        "username": "piyush_mehta22",
                        "content": "if(s.charAt(i) == s.charAt(j) && substring(i,j).length() > longestSubstring.lenght() && isPalindrome(substring(i,j)) {\\nlongestSubstring = substring(i,j);\\n}\\nis much much better than \\nif(isPalindrome(substring(i,j)) {\\n  if(substring.length() > longestSubstring.length()) {\\n     longestubstring = substring(i,j);\\n  }\\n}\\n\\nbecause the first condition first checks whether first and last char are equal or not, then it checks if length is greater or not then it goes for checking is it palindrome or not(which removes  most of the unwanted cases and saves some time), while in second, first it checks the palindrome condition for all string then makes further decision"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@georgezakharov](/georgezakharov) good job lil nigga"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "That\\'s gay, don\\'t post solutions here"
                    },
                    {
                        "username": "jai218",
                        "content": "How do I optimize my code further? \\nI have defined a function outside the class that checks if a string is a palindrome (recursive) and then in the main function i go over all possible substrings starting from the biggest to smallest and checking if that is a palindrome, if True then return that. "
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "anyways your code is still better, mine runs at O(n^3)\\uD83D\\uDC80"
                    },
                    {
                        "username": "AnthonyR21",
                        "content": "## Intuition \n- The problem is to find the longest palndromic substring within a given string.\n- A palindrome reads the same backward as forward.\n- We can use a brute-force approach to check all possible substrings and find the longest one that is also a palindrome.\n\n## Approach\n- Define an ```isPalindrome``` method to check if substring is a palindrome. This method compares characters from the start and end of the substring, moving toward the center.\n- In the ```longestPalindrome``` method:\n- Initialize variables ```maxLength``` to store the length of the longest palindrome found so far and start to store the starting index of the longest palindrome.\n- Iterate through all possible pairs of indexes (i, j) to consider all substrings.\n- For each substring (i, j) check if it's a palindrome using the ```isPalindrome``` method.\n- If it's a palindrome and longer than the current maximum, update ```maxLength``` and start."
                    },
                    {
                        "username": "benlhachemi",
                        "content": "if you passed the \"RUN\" and get the message \"Time Limit Exceeded\" on Submit, your code is correct but the complexity is not.\\nTry to reduce complexity of your algorithm."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "GigaNigger"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "My dick is 20 inches"
                    },
                    {
                        "username": "igorKor",
                        "content": "According to the condition of the task, you need to find the longest palindrome.\nWhen tested, the input string is \"babadada\".\nThe test expects to receive \"adada\".\nBut the longest polyndrom in this case will be the substring \"adabada\""
                    },
                    {
                        "username": "AMerrill",
                        "content": "a substring is a set of continuous characters (i.e. you cannot rearrange characters). Thus, for the example given, \"*adada*\" is the longest palindrome that is a substring of \"*babadada*\""
                    },
                    {
                        "username": "mishraanuyesh7",
                        "content": "javascript\\n"
                    },
                    {
                        "username": "showtroylove",
                        "content": "How do you add an image to post?"
                    }
                ]
            },
            {
                "id": 1654196,
                "content": [
                    {
                        "username": "sparasuram",
                        "content": "test case \"ac\" is not a palindromic string. But it shows output as \"a\""
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "we have to find substring, so the string itself could be not palindromic, the answers to that question could be either \"a\" or \"c\", cause they are palindromic"
                    },
                    {
                        "username": "anupamprakash82",
                        "content": "Why O(n^2) solution is giving the TLE? Since the constraint is 1 <= s.length <= 1000, O(n^2) solution should work"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@anupamprakash82](/anupamprakash82) Nuh"
                    },
                    {
                        "username": "anupamprakash82",
                        "content": "[@DamianIvanochko](/DamianIvanochko) is your code getting AC?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "bro my solutions is O(n^3)"
                    },
                    {
                        "username": "piyush_mehta22",
                        "content": "if(s.charAt(i) == s.charAt(j) && substring(i,j).length() > longestSubstring.lenght() && isPalindrome(substring(i,j)) {\\nlongestSubstring = substring(i,j);\\n}\\nis much much better than \\nif(isPalindrome(substring(i,j)) {\\n  if(substring.length() > longestSubstring.length()) {\\n     longestubstring = substring(i,j);\\n  }\\n}\\n\\nbecause the first condition first checks whether first and last char are equal or not, then it checks if length is greater or not then it goes for checking is it palindrome or not(which removes  most of the unwanted cases and saves some time), while in second, first it checks the palindrome condition for all string then makes further decision"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@georgezakharov](/georgezakharov) good job lil nigga"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "That\\'s gay, don\\'t post solutions here"
                    },
                    {
                        "username": "jai218",
                        "content": "How do I optimize my code further? \\nI have defined a function outside the class that checks if a string is a palindrome (recursive) and then in the main function i go over all possible substrings starting from the biggest to smallest and checking if that is a palindrome, if True then return that. "
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "anyways your code is still better, mine runs at O(n^3)\\uD83D\\uDC80"
                    },
                    {
                        "username": "AnthonyR21",
                        "content": "## Intuition \n- The problem is to find the longest palndromic substring within a given string.\n- A palindrome reads the same backward as forward.\n- We can use a brute-force approach to check all possible substrings and find the longest one that is also a palindrome.\n\n## Approach\n- Define an ```isPalindrome``` method to check if substring is a palindrome. This method compares characters from the start and end of the substring, moving toward the center.\n- In the ```longestPalindrome``` method:\n- Initialize variables ```maxLength``` to store the length of the longest palindrome found so far and start to store the starting index of the longest palindrome.\n- Iterate through all possible pairs of indexes (i, j) to consider all substrings.\n- For each substring (i, j) check if it's a palindrome using the ```isPalindrome``` method.\n- If it's a palindrome and longer than the current maximum, update ```maxLength``` and start."
                    },
                    {
                        "username": "benlhachemi",
                        "content": "if you passed the \"RUN\" and get the message \"Time Limit Exceeded\" on Submit, your code is correct but the complexity is not.\\nTry to reduce complexity of your algorithm."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "GigaNigger"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "My dick is 20 inches"
                    },
                    {
                        "username": "igorKor",
                        "content": "According to the condition of the task, you need to find the longest palindrome.\nWhen tested, the input string is \"babadada\".\nThe test expects to receive \"adada\".\nBut the longest polyndrom in this case will be the substring \"adabada\""
                    },
                    {
                        "username": "AMerrill",
                        "content": "a substring is a set of continuous characters (i.e. you cannot rearrange characters). Thus, for the example given, \"*adada*\" is the longest palindrome that is a substring of \"*babadada*\""
                    },
                    {
                        "username": "mishraanuyesh7",
                        "content": "javascript\\n"
                    },
                    {
                        "username": "showtroylove",
                        "content": "How do you add an image to post?"
                    }
                ]
            },
            {
                "id": 1576613,
                "content": [
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/longest-palindromic-substring-solution-python-leetcode/\\n"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/longest-palindromic-substring-solution-python-leetcode/\\n"
                    },
                    {
                        "username": "Mght_tyb",
                        "content": "![image](https://assets.leetcode.com/users/images/47105dc4-1850-499a-9e78-b90c7e0ac0ef_1639159747.7107038.png)\\n"
                    },
                    {
                        "username": "htt210",
                        "content": "Update: Thank you. It was my misunderstanding.\\n\\nHi there, this is my first time here and I have many stupid questions to ask. \\nI have this test case:\\n\\nInput: aacabdkacaa\\nMy Output: aacabacaa\\nExpected: aca\\n\\nHave you ever encountered this test case? How can we report this error to the author? Thanks"
                    },
                    {
                        "username": "ktime",
                        "content": "I solved it using dynamic programming based on the explanation in\\nhttps://algotree.org/algorithms/dynamic_programming/longest_palindromic_substring/"
                    },
                    {
                        "username": "ambuj100",
                        "content": "The total centers should be equal to the total no. of elements in string which is n then why are there 2n-1 centers ???"
                    },
                    {
                        "username": "delosrd",
                        "content": "I got this given \"aacdefcaa\" when submitting my solution.\\n\\nMy output is \"caa.\" My understanding is that the output could either be \"aac\" or \"caa\" given that \"aacdefcaa\" backwards is \"aacfedcaa\" but the expected output is \"aa.\" Unless my brain is already fried or I think the expected output is wrong?\\n\\n![image](https://assets.leetcode.com/users/images/fbb482d2-1133-4502-ac59-498febd02ded_1600596206.1396868.png)\\n"
                    },
                    {
                        "username": "Itsover12",
                        "content": "[@1shibu](/1shibu) It\\'s \"aa\" because \"caa\" is not a palindrome."
                    },
                    {
                        "username": "1shibu",
                        "content": "\"aac\" is not equal to \"caa\" so it is wrong, but \"aa\" is equal to \"aa\""
                    },
                    {
                        "username": "danyoungmusic93",
                        "content": "Has anyone run into a problem where the testcase runner shows the solution as passing, but the submit button shows different output for the same test case? I ran the same code twice in the test runner and the solution button.\\n\\n![image](https://assets.leetcode.com/users/images/79ac39dd-cdc8-4ee1-bb9c-aef81dc0f46c_1598129427.85128.png)\\n\\n\\nI\\'ve never run into this problem before. This is NOT a Time Limit Exceeded issue, but rather the return value of my solution is different depending on whether I hit submit, or run the test case. Looks like a bug in Leetcode\\'s test cases"
                    },
                    {
                        "username": "max_223",
                        "content": "Alternative non-DP solution here with well-commented code in C++, Java and Python:\\nhttps://www.techiedelight.com/longest-palindromic-substring-non-dp-space-optimized-solution/\\n"
                    },
                    {
                        "username": "baites",
                        "content": "I have an alternative O(n^2) solution using hashing that I discuss in this post: https://baites.github.io/algorithms/algorithm-analysis/2020/03/23/string-hashing-and-palindromes.html\\nAlso, using the same tool, I show how to solve the problem of the Shortest palindrome https://leetcode.com/problems/shortest-palindrome/"
                    },
                    {
                        "username": "monikakumari2k",
                        "content": "okay..bt where is the code :)"
                    }
                ]
            },
            {
                "id": 1576609,
                "content": [
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/longest-palindromic-substring-solution-python-leetcode/\\n"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/longest-palindromic-substring-solution-python-leetcode/\\n"
                    },
                    {
                        "username": "Mght_tyb",
                        "content": "![image](https://assets.leetcode.com/users/images/47105dc4-1850-499a-9e78-b90c7e0ac0ef_1639159747.7107038.png)\\n"
                    },
                    {
                        "username": "htt210",
                        "content": "Update: Thank you. It was my misunderstanding.\\n\\nHi there, this is my first time here and I have many stupid questions to ask. \\nI have this test case:\\n\\nInput: aacabdkacaa\\nMy Output: aacabacaa\\nExpected: aca\\n\\nHave you ever encountered this test case? How can we report this error to the author? Thanks"
                    },
                    {
                        "username": "ktime",
                        "content": "I solved it using dynamic programming based on the explanation in\\nhttps://algotree.org/algorithms/dynamic_programming/longest_palindromic_substring/"
                    },
                    {
                        "username": "ambuj100",
                        "content": "The total centers should be equal to the total no. of elements in string which is n then why are there 2n-1 centers ???"
                    },
                    {
                        "username": "delosrd",
                        "content": "I got this given \"aacdefcaa\" when submitting my solution.\\n\\nMy output is \"caa.\" My understanding is that the output could either be \"aac\" or \"caa\" given that \"aacdefcaa\" backwards is \"aacfedcaa\" but the expected output is \"aa.\" Unless my brain is already fried or I think the expected output is wrong?\\n\\n![image](https://assets.leetcode.com/users/images/fbb482d2-1133-4502-ac59-498febd02ded_1600596206.1396868.png)\\n"
                    },
                    {
                        "username": "Itsover12",
                        "content": "[@1shibu](/1shibu) It\\'s \"aa\" because \"caa\" is not a palindrome."
                    },
                    {
                        "username": "1shibu",
                        "content": "\"aac\" is not equal to \"caa\" so it is wrong, but \"aa\" is equal to \"aa\""
                    },
                    {
                        "username": "danyoungmusic93",
                        "content": "Has anyone run into a problem where the testcase runner shows the solution as passing, but the submit button shows different output for the same test case? I ran the same code twice in the test runner and the solution button.\\n\\n![image](https://assets.leetcode.com/users/images/79ac39dd-cdc8-4ee1-bb9c-aef81dc0f46c_1598129427.85128.png)\\n\\n\\nI\\'ve never run into this problem before. This is NOT a Time Limit Exceeded issue, but rather the return value of my solution is different depending on whether I hit submit, or run the test case. Looks like a bug in Leetcode\\'s test cases"
                    },
                    {
                        "username": "max_223",
                        "content": "Alternative non-DP solution here with well-commented code in C++, Java and Python:\\nhttps://www.techiedelight.com/longest-palindromic-substring-non-dp-space-optimized-solution/\\n"
                    },
                    {
                        "username": "baites",
                        "content": "I have an alternative O(n^2) solution using hashing that I discuss in this post: https://baites.github.io/algorithms/algorithm-analysis/2020/03/23/string-hashing-and-palindromes.html\\nAlso, using the same tool, I show how to solve the problem of the Shortest palindrome https://leetcode.com/problems/shortest-palindrome/"
                    },
                    {
                        "username": "monikakumari2k",
                        "content": "okay..bt where is the code :)"
                    }
                ]
            },
            {
                "id": 1576068,
                "content": [
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/longest-palindromic-substring-solution-python-leetcode/\\n"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/longest-palindromic-substring-solution-python-leetcode/\\n"
                    },
                    {
                        "username": "Mght_tyb",
                        "content": "![image](https://assets.leetcode.com/users/images/47105dc4-1850-499a-9e78-b90c7e0ac0ef_1639159747.7107038.png)\\n"
                    },
                    {
                        "username": "htt210",
                        "content": "Update: Thank you. It was my misunderstanding.\\n\\nHi there, this is my first time here and I have many stupid questions to ask. \\nI have this test case:\\n\\nInput: aacabdkacaa\\nMy Output: aacabacaa\\nExpected: aca\\n\\nHave you ever encountered this test case? How can we report this error to the author? Thanks"
                    },
                    {
                        "username": "ktime",
                        "content": "I solved it using dynamic programming based on the explanation in\\nhttps://algotree.org/algorithms/dynamic_programming/longest_palindromic_substring/"
                    },
                    {
                        "username": "ambuj100",
                        "content": "The total centers should be equal to the total no. of elements in string which is n then why are there 2n-1 centers ???"
                    },
                    {
                        "username": "delosrd",
                        "content": "I got this given \"aacdefcaa\" when submitting my solution.\\n\\nMy output is \"caa.\" My understanding is that the output could either be \"aac\" or \"caa\" given that \"aacdefcaa\" backwards is \"aacfedcaa\" but the expected output is \"aa.\" Unless my brain is already fried or I think the expected output is wrong?\\n\\n![image](https://assets.leetcode.com/users/images/fbb482d2-1133-4502-ac59-498febd02ded_1600596206.1396868.png)\\n"
                    },
                    {
                        "username": "Itsover12",
                        "content": "[@1shibu](/1shibu) It\\'s \"aa\" because \"caa\" is not a palindrome."
                    },
                    {
                        "username": "1shibu",
                        "content": "\"aac\" is not equal to \"caa\" so it is wrong, but \"aa\" is equal to \"aa\""
                    },
                    {
                        "username": "danyoungmusic93",
                        "content": "Has anyone run into a problem where the testcase runner shows the solution as passing, but the submit button shows different output for the same test case? I ran the same code twice in the test runner and the solution button.\\n\\n![image](https://assets.leetcode.com/users/images/79ac39dd-cdc8-4ee1-bb9c-aef81dc0f46c_1598129427.85128.png)\\n\\n\\nI\\'ve never run into this problem before. This is NOT a Time Limit Exceeded issue, but rather the return value of my solution is different depending on whether I hit submit, or run the test case. Looks like a bug in Leetcode\\'s test cases"
                    },
                    {
                        "username": "max_223",
                        "content": "Alternative non-DP solution here with well-commented code in C++, Java and Python:\\nhttps://www.techiedelight.com/longest-palindromic-substring-non-dp-space-optimized-solution/\\n"
                    },
                    {
                        "username": "baites",
                        "content": "I have an alternative O(n^2) solution using hashing that I discuss in this post: https://baites.github.io/algorithms/algorithm-analysis/2020/03/23/string-hashing-and-palindromes.html\\nAlso, using the same tool, I show how to solve the problem of the Shortest palindrome https://leetcode.com/problems/shortest-palindrome/"
                    },
                    {
                        "username": "monikakumari2k",
                        "content": "okay..bt where is the code :)"
                    }
                ]
            },
            {
                "id": 1574881,
                "content": [
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/longest-palindromic-substring-solution-python-leetcode/\\n"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/longest-palindromic-substring-solution-python-leetcode/\\n"
                    },
                    {
                        "username": "Mght_tyb",
                        "content": "![image](https://assets.leetcode.com/users/images/47105dc4-1850-499a-9e78-b90c7e0ac0ef_1639159747.7107038.png)\\n"
                    },
                    {
                        "username": "htt210",
                        "content": "Update: Thank you. It was my misunderstanding.\\n\\nHi there, this is my first time here and I have many stupid questions to ask. \\nI have this test case:\\n\\nInput: aacabdkacaa\\nMy Output: aacabacaa\\nExpected: aca\\n\\nHave you ever encountered this test case? How can we report this error to the author? Thanks"
                    },
                    {
                        "username": "ktime",
                        "content": "I solved it using dynamic programming based on the explanation in\\nhttps://algotree.org/algorithms/dynamic_programming/longest_palindromic_substring/"
                    },
                    {
                        "username": "ambuj100",
                        "content": "The total centers should be equal to the total no. of elements in string which is n then why are there 2n-1 centers ???"
                    },
                    {
                        "username": "delosrd",
                        "content": "I got this given \"aacdefcaa\" when submitting my solution.\\n\\nMy output is \"caa.\" My understanding is that the output could either be \"aac\" or \"caa\" given that \"aacdefcaa\" backwards is \"aacfedcaa\" but the expected output is \"aa.\" Unless my brain is already fried or I think the expected output is wrong?\\n\\n![image](https://assets.leetcode.com/users/images/fbb482d2-1133-4502-ac59-498febd02ded_1600596206.1396868.png)\\n"
                    },
                    {
                        "username": "Itsover12",
                        "content": "[@1shibu](/1shibu) It\\'s \"aa\" because \"caa\" is not a palindrome."
                    },
                    {
                        "username": "1shibu",
                        "content": "\"aac\" is not equal to \"caa\" so it is wrong, but \"aa\" is equal to \"aa\""
                    },
                    {
                        "username": "danyoungmusic93",
                        "content": "Has anyone run into a problem where the testcase runner shows the solution as passing, but the submit button shows different output for the same test case? I ran the same code twice in the test runner and the solution button.\\n\\n![image](https://assets.leetcode.com/users/images/79ac39dd-cdc8-4ee1-bb9c-aef81dc0f46c_1598129427.85128.png)\\n\\n\\nI\\'ve never run into this problem before. This is NOT a Time Limit Exceeded issue, but rather the return value of my solution is different depending on whether I hit submit, or run the test case. Looks like a bug in Leetcode\\'s test cases"
                    },
                    {
                        "username": "max_223",
                        "content": "Alternative non-DP solution here with well-commented code in C++, Java and Python:\\nhttps://www.techiedelight.com/longest-palindromic-substring-non-dp-space-optimized-solution/\\n"
                    },
                    {
                        "username": "baites",
                        "content": "I have an alternative O(n^2) solution using hashing that I discuss in this post: https://baites.github.io/algorithms/algorithm-analysis/2020/03/23/string-hashing-and-palindromes.html\\nAlso, using the same tool, I show how to solve the problem of the Shortest palindrome https://leetcode.com/problems/shortest-palindrome/"
                    },
                    {
                        "username": "monikakumari2k",
                        "content": "okay..bt where is the code :)"
                    }
                ]
            },
            {
                "id": 1574873,
                "content": [
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/longest-palindromic-substring-solution-python-leetcode/\\n"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/longest-palindromic-substring-solution-python-leetcode/\\n"
                    },
                    {
                        "username": "Mght_tyb",
                        "content": "![image](https://assets.leetcode.com/users/images/47105dc4-1850-499a-9e78-b90c7e0ac0ef_1639159747.7107038.png)\\n"
                    },
                    {
                        "username": "htt210",
                        "content": "Update: Thank you. It was my misunderstanding.\\n\\nHi there, this is my first time here and I have many stupid questions to ask. \\nI have this test case:\\n\\nInput: aacabdkacaa\\nMy Output: aacabacaa\\nExpected: aca\\n\\nHave you ever encountered this test case? How can we report this error to the author? Thanks"
                    },
                    {
                        "username": "ktime",
                        "content": "I solved it using dynamic programming based on the explanation in\\nhttps://algotree.org/algorithms/dynamic_programming/longest_palindromic_substring/"
                    },
                    {
                        "username": "ambuj100",
                        "content": "The total centers should be equal to the total no. of elements in string which is n then why are there 2n-1 centers ???"
                    },
                    {
                        "username": "delosrd",
                        "content": "I got this given \"aacdefcaa\" when submitting my solution.\\n\\nMy output is \"caa.\" My understanding is that the output could either be \"aac\" or \"caa\" given that \"aacdefcaa\" backwards is \"aacfedcaa\" but the expected output is \"aa.\" Unless my brain is already fried or I think the expected output is wrong?\\n\\n![image](https://assets.leetcode.com/users/images/fbb482d2-1133-4502-ac59-498febd02ded_1600596206.1396868.png)\\n"
                    },
                    {
                        "username": "Itsover12",
                        "content": "[@1shibu](/1shibu) It\\'s \"aa\" because \"caa\" is not a palindrome."
                    },
                    {
                        "username": "1shibu",
                        "content": "\"aac\" is not equal to \"caa\" so it is wrong, but \"aa\" is equal to \"aa\""
                    },
                    {
                        "username": "danyoungmusic93",
                        "content": "Has anyone run into a problem where the testcase runner shows the solution as passing, but the submit button shows different output for the same test case? I ran the same code twice in the test runner and the solution button.\\n\\n![image](https://assets.leetcode.com/users/images/79ac39dd-cdc8-4ee1-bb9c-aef81dc0f46c_1598129427.85128.png)\\n\\n\\nI\\'ve never run into this problem before. This is NOT a Time Limit Exceeded issue, but rather the return value of my solution is different depending on whether I hit submit, or run the test case. Looks like a bug in Leetcode\\'s test cases"
                    },
                    {
                        "username": "max_223",
                        "content": "Alternative non-DP solution here with well-commented code in C++, Java and Python:\\nhttps://www.techiedelight.com/longest-palindromic-substring-non-dp-space-optimized-solution/\\n"
                    },
                    {
                        "username": "baites",
                        "content": "I have an alternative O(n^2) solution using hashing that I discuss in this post: https://baites.github.io/algorithms/algorithm-analysis/2020/03/23/string-hashing-and-palindromes.html\\nAlso, using the same tool, I show how to solve the problem of the Shortest palindrome https://leetcode.com/problems/shortest-palindrome/"
                    },
                    {
                        "username": "monikakumari2k",
                        "content": "okay..bt where is the code :)"
                    }
                ]
            },
            {
                "id": 1574859,
                "content": [
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/longest-palindromic-substring-solution-python-leetcode/\\n"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/longest-palindromic-substring-solution-python-leetcode/\\n"
                    },
                    {
                        "username": "Mght_tyb",
                        "content": "![image](https://assets.leetcode.com/users/images/47105dc4-1850-499a-9e78-b90c7e0ac0ef_1639159747.7107038.png)\\n"
                    },
                    {
                        "username": "htt210",
                        "content": "Update: Thank you. It was my misunderstanding.\\n\\nHi there, this is my first time here and I have many stupid questions to ask. \\nI have this test case:\\n\\nInput: aacabdkacaa\\nMy Output: aacabacaa\\nExpected: aca\\n\\nHave you ever encountered this test case? How can we report this error to the author? Thanks"
                    },
                    {
                        "username": "ktime",
                        "content": "I solved it using dynamic programming based on the explanation in\\nhttps://algotree.org/algorithms/dynamic_programming/longest_palindromic_substring/"
                    },
                    {
                        "username": "ambuj100",
                        "content": "The total centers should be equal to the total no. of elements in string which is n then why are there 2n-1 centers ???"
                    },
                    {
                        "username": "delosrd",
                        "content": "I got this given \"aacdefcaa\" when submitting my solution.\\n\\nMy output is \"caa.\" My understanding is that the output could either be \"aac\" or \"caa\" given that \"aacdefcaa\" backwards is \"aacfedcaa\" but the expected output is \"aa.\" Unless my brain is already fried or I think the expected output is wrong?\\n\\n![image](https://assets.leetcode.com/users/images/fbb482d2-1133-4502-ac59-498febd02ded_1600596206.1396868.png)\\n"
                    },
                    {
                        "username": "Itsover12",
                        "content": "[@1shibu](/1shibu) It\\'s \"aa\" because \"caa\" is not a palindrome."
                    },
                    {
                        "username": "1shibu",
                        "content": "\"aac\" is not equal to \"caa\" so it is wrong, but \"aa\" is equal to \"aa\""
                    },
                    {
                        "username": "danyoungmusic93",
                        "content": "Has anyone run into a problem where the testcase runner shows the solution as passing, but the submit button shows different output for the same test case? I ran the same code twice in the test runner and the solution button.\\n\\n![image](https://assets.leetcode.com/users/images/79ac39dd-cdc8-4ee1-bb9c-aef81dc0f46c_1598129427.85128.png)\\n\\n\\nI\\'ve never run into this problem before. This is NOT a Time Limit Exceeded issue, but rather the return value of my solution is different depending on whether I hit submit, or run the test case. Looks like a bug in Leetcode\\'s test cases"
                    },
                    {
                        "username": "max_223",
                        "content": "Alternative non-DP solution here with well-commented code in C++, Java and Python:\\nhttps://www.techiedelight.com/longest-palindromic-substring-non-dp-space-optimized-solution/\\n"
                    },
                    {
                        "username": "baites",
                        "content": "I have an alternative O(n^2) solution using hashing that I discuss in this post: https://baites.github.io/algorithms/algorithm-analysis/2020/03/23/string-hashing-and-palindromes.html\\nAlso, using the same tool, I show how to solve the problem of the Shortest palindrome https://leetcode.com/problems/shortest-palindrome/"
                    },
                    {
                        "username": "monikakumari2k",
                        "content": "okay..bt where is the code :)"
                    }
                ]
            },
            {
                "id": 1574395,
                "content": [
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/longest-palindromic-substring-solution-python-leetcode/\\n"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/longest-palindromic-substring-solution-python-leetcode/\\n"
                    },
                    {
                        "username": "Mght_tyb",
                        "content": "![image](https://assets.leetcode.com/users/images/47105dc4-1850-499a-9e78-b90c7e0ac0ef_1639159747.7107038.png)\\n"
                    },
                    {
                        "username": "htt210",
                        "content": "Update: Thank you. It was my misunderstanding.\\n\\nHi there, this is my first time here and I have many stupid questions to ask. \\nI have this test case:\\n\\nInput: aacabdkacaa\\nMy Output: aacabacaa\\nExpected: aca\\n\\nHave you ever encountered this test case? How can we report this error to the author? Thanks"
                    },
                    {
                        "username": "ktime",
                        "content": "I solved it using dynamic programming based on the explanation in\\nhttps://algotree.org/algorithms/dynamic_programming/longest_palindromic_substring/"
                    },
                    {
                        "username": "ambuj100",
                        "content": "The total centers should be equal to the total no. of elements in string which is n then why are there 2n-1 centers ???"
                    },
                    {
                        "username": "delosrd",
                        "content": "I got this given \"aacdefcaa\" when submitting my solution.\\n\\nMy output is \"caa.\" My understanding is that the output could either be \"aac\" or \"caa\" given that \"aacdefcaa\" backwards is \"aacfedcaa\" but the expected output is \"aa.\" Unless my brain is already fried or I think the expected output is wrong?\\n\\n![image](https://assets.leetcode.com/users/images/fbb482d2-1133-4502-ac59-498febd02ded_1600596206.1396868.png)\\n"
                    },
                    {
                        "username": "Itsover12",
                        "content": "[@1shibu](/1shibu) It\\'s \"aa\" because \"caa\" is not a palindrome."
                    },
                    {
                        "username": "1shibu",
                        "content": "\"aac\" is not equal to \"caa\" so it is wrong, but \"aa\" is equal to \"aa\""
                    },
                    {
                        "username": "danyoungmusic93",
                        "content": "Has anyone run into a problem where the testcase runner shows the solution as passing, but the submit button shows different output for the same test case? I ran the same code twice in the test runner and the solution button.\\n\\n![image](https://assets.leetcode.com/users/images/79ac39dd-cdc8-4ee1-bb9c-aef81dc0f46c_1598129427.85128.png)\\n\\n\\nI\\'ve never run into this problem before. This is NOT a Time Limit Exceeded issue, but rather the return value of my solution is different depending on whether I hit submit, or run the test case. Looks like a bug in Leetcode\\'s test cases"
                    },
                    {
                        "username": "max_223",
                        "content": "Alternative non-DP solution here with well-commented code in C++, Java and Python:\\nhttps://www.techiedelight.com/longest-palindromic-substring-non-dp-space-optimized-solution/\\n"
                    },
                    {
                        "username": "baites",
                        "content": "I have an alternative O(n^2) solution using hashing that I discuss in this post: https://baites.github.io/algorithms/algorithm-analysis/2020/03/23/string-hashing-and-palindromes.html\\nAlso, using the same tool, I show how to solve the problem of the Shortest palindrome https://leetcode.com/problems/shortest-palindrome/"
                    },
                    {
                        "username": "monikakumari2k",
                        "content": "okay..bt where is the code :)"
                    }
                ]
            },
            {
                "id": 1574261,
                "content": [
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/longest-palindromic-substring-solution-python-leetcode/\\n"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/longest-palindromic-substring-solution-python-leetcode/\\n"
                    },
                    {
                        "username": "Mght_tyb",
                        "content": "![image](https://assets.leetcode.com/users/images/47105dc4-1850-499a-9e78-b90c7e0ac0ef_1639159747.7107038.png)\\n"
                    },
                    {
                        "username": "htt210",
                        "content": "Update: Thank you. It was my misunderstanding.\\n\\nHi there, this is my first time here and I have many stupid questions to ask. \\nI have this test case:\\n\\nInput: aacabdkacaa\\nMy Output: aacabacaa\\nExpected: aca\\n\\nHave you ever encountered this test case? How can we report this error to the author? Thanks"
                    },
                    {
                        "username": "ktime",
                        "content": "I solved it using dynamic programming based on the explanation in\\nhttps://algotree.org/algorithms/dynamic_programming/longest_palindromic_substring/"
                    },
                    {
                        "username": "ambuj100",
                        "content": "The total centers should be equal to the total no. of elements in string which is n then why are there 2n-1 centers ???"
                    },
                    {
                        "username": "delosrd",
                        "content": "I got this given \"aacdefcaa\" when submitting my solution.\\n\\nMy output is \"caa.\" My understanding is that the output could either be \"aac\" or \"caa\" given that \"aacdefcaa\" backwards is \"aacfedcaa\" but the expected output is \"aa.\" Unless my brain is already fried or I think the expected output is wrong?\\n\\n![image](https://assets.leetcode.com/users/images/fbb482d2-1133-4502-ac59-498febd02ded_1600596206.1396868.png)\\n"
                    },
                    {
                        "username": "Itsover12",
                        "content": "[@1shibu](/1shibu) It\\'s \"aa\" because \"caa\" is not a palindrome."
                    },
                    {
                        "username": "1shibu",
                        "content": "\"aac\" is not equal to \"caa\" so it is wrong, but \"aa\" is equal to \"aa\""
                    },
                    {
                        "username": "danyoungmusic93",
                        "content": "Has anyone run into a problem where the testcase runner shows the solution as passing, but the submit button shows different output for the same test case? I ran the same code twice in the test runner and the solution button.\\n\\n![image](https://assets.leetcode.com/users/images/79ac39dd-cdc8-4ee1-bb9c-aef81dc0f46c_1598129427.85128.png)\\n\\n\\nI\\'ve never run into this problem before. This is NOT a Time Limit Exceeded issue, but rather the return value of my solution is different depending on whether I hit submit, or run the test case. Looks like a bug in Leetcode\\'s test cases"
                    },
                    {
                        "username": "max_223",
                        "content": "Alternative non-DP solution here with well-commented code in C++, Java and Python:\\nhttps://www.techiedelight.com/longest-palindromic-substring-non-dp-space-optimized-solution/\\n"
                    },
                    {
                        "username": "baites",
                        "content": "I have an alternative O(n^2) solution using hashing that I discuss in this post: https://baites.github.io/algorithms/algorithm-analysis/2020/03/23/string-hashing-and-palindromes.html\\nAlso, using the same tool, I show how to solve the problem of the Shortest palindrome https://leetcode.com/problems/shortest-palindrome/"
                    },
                    {
                        "username": "monikakumari2k",
                        "content": "okay..bt where is the code :)"
                    }
                ]
            },
            {
                "id": 1573935,
                "content": [
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/longest-palindromic-substring-solution-python-leetcode/\\n"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/longest-palindromic-substring-solution-python-leetcode/\\n"
                    },
                    {
                        "username": "Mght_tyb",
                        "content": "![image](https://assets.leetcode.com/users/images/47105dc4-1850-499a-9e78-b90c7e0ac0ef_1639159747.7107038.png)\\n"
                    },
                    {
                        "username": "htt210",
                        "content": "Update: Thank you. It was my misunderstanding.\\n\\nHi there, this is my first time here and I have many stupid questions to ask. \\nI have this test case:\\n\\nInput: aacabdkacaa\\nMy Output: aacabacaa\\nExpected: aca\\n\\nHave you ever encountered this test case? How can we report this error to the author? Thanks"
                    },
                    {
                        "username": "ktime",
                        "content": "I solved it using dynamic programming based on the explanation in\\nhttps://algotree.org/algorithms/dynamic_programming/longest_palindromic_substring/"
                    },
                    {
                        "username": "ambuj100",
                        "content": "The total centers should be equal to the total no. of elements in string which is n then why are there 2n-1 centers ???"
                    },
                    {
                        "username": "delosrd",
                        "content": "I got this given \"aacdefcaa\" when submitting my solution.\\n\\nMy output is \"caa.\" My understanding is that the output could either be \"aac\" or \"caa\" given that \"aacdefcaa\" backwards is \"aacfedcaa\" but the expected output is \"aa.\" Unless my brain is already fried or I think the expected output is wrong?\\n\\n![image](https://assets.leetcode.com/users/images/fbb482d2-1133-4502-ac59-498febd02ded_1600596206.1396868.png)\\n"
                    },
                    {
                        "username": "Itsover12",
                        "content": "[@1shibu](/1shibu) It\\'s \"aa\" because \"caa\" is not a palindrome."
                    },
                    {
                        "username": "1shibu",
                        "content": "\"aac\" is not equal to \"caa\" so it is wrong, but \"aa\" is equal to \"aa\""
                    },
                    {
                        "username": "danyoungmusic93",
                        "content": "Has anyone run into a problem where the testcase runner shows the solution as passing, but the submit button shows different output for the same test case? I ran the same code twice in the test runner and the solution button.\\n\\n![image](https://assets.leetcode.com/users/images/79ac39dd-cdc8-4ee1-bb9c-aef81dc0f46c_1598129427.85128.png)\\n\\n\\nI\\'ve never run into this problem before. This is NOT a Time Limit Exceeded issue, but rather the return value of my solution is different depending on whether I hit submit, or run the test case. Looks like a bug in Leetcode\\'s test cases"
                    },
                    {
                        "username": "max_223",
                        "content": "Alternative non-DP solution here with well-commented code in C++, Java and Python:\\nhttps://www.techiedelight.com/longest-palindromic-substring-non-dp-space-optimized-solution/\\n"
                    },
                    {
                        "username": "baites",
                        "content": "I have an alternative O(n^2) solution using hashing that I discuss in this post: https://baites.github.io/algorithms/algorithm-analysis/2020/03/23/string-hashing-and-palindromes.html\\nAlso, using the same tool, I show how to solve the problem of the Shortest palindrome https://leetcode.com/problems/shortest-palindrome/"
                    },
                    {
                        "username": "monikakumari2k",
                        "content": "okay..bt where is the code :)"
                    }
                ]
            },
            {
                "id": 1573543,
                "content": [
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/longest-palindromic-substring-solution-python-leetcode/\\n"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/longest-palindromic-substring-solution-python-leetcode/\\n"
                    },
                    {
                        "username": "Mght_tyb",
                        "content": "![image](https://assets.leetcode.com/users/images/47105dc4-1850-499a-9e78-b90c7e0ac0ef_1639159747.7107038.png)\\n"
                    },
                    {
                        "username": "htt210",
                        "content": "Update: Thank you. It was my misunderstanding.\\n\\nHi there, this is my first time here and I have many stupid questions to ask. \\nI have this test case:\\n\\nInput: aacabdkacaa\\nMy Output: aacabacaa\\nExpected: aca\\n\\nHave you ever encountered this test case? How can we report this error to the author? Thanks"
                    },
                    {
                        "username": "ktime",
                        "content": "I solved it using dynamic programming based on the explanation in\\nhttps://algotree.org/algorithms/dynamic_programming/longest_palindromic_substring/"
                    },
                    {
                        "username": "ambuj100",
                        "content": "The total centers should be equal to the total no. of elements in string which is n then why are there 2n-1 centers ???"
                    },
                    {
                        "username": "delosrd",
                        "content": "I got this given \"aacdefcaa\" when submitting my solution.\\n\\nMy output is \"caa.\" My understanding is that the output could either be \"aac\" or \"caa\" given that \"aacdefcaa\" backwards is \"aacfedcaa\" but the expected output is \"aa.\" Unless my brain is already fried or I think the expected output is wrong?\\n\\n![image](https://assets.leetcode.com/users/images/fbb482d2-1133-4502-ac59-498febd02ded_1600596206.1396868.png)\\n"
                    },
                    {
                        "username": "Itsover12",
                        "content": "[@1shibu](/1shibu) It\\'s \"aa\" because \"caa\" is not a palindrome."
                    },
                    {
                        "username": "1shibu",
                        "content": "\"aac\" is not equal to \"caa\" so it is wrong, but \"aa\" is equal to \"aa\""
                    },
                    {
                        "username": "danyoungmusic93",
                        "content": "Has anyone run into a problem where the testcase runner shows the solution as passing, but the submit button shows different output for the same test case? I ran the same code twice in the test runner and the solution button.\\n\\n![image](https://assets.leetcode.com/users/images/79ac39dd-cdc8-4ee1-bb9c-aef81dc0f46c_1598129427.85128.png)\\n\\n\\nI\\'ve never run into this problem before. This is NOT a Time Limit Exceeded issue, but rather the return value of my solution is different depending on whether I hit submit, or run the test case. Looks like a bug in Leetcode\\'s test cases"
                    },
                    {
                        "username": "max_223",
                        "content": "Alternative non-DP solution here with well-commented code in C++, Java and Python:\\nhttps://www.techiedelight.com/longest-palindromic-substring-non-dp-space-optimized-solution/\\n"
                    },
                    {
                        "username": "baites",
                        "content": "I have an alternative O(n^2) solution using hashing that I discuss in this post: https://baites.github.io/algorithms/algorithm-analysis/2020/03/23/string-hashing-and-palindromes.html\\nAlso, using the same tool, I show how to solve the problem of the Shortest palindrome https://leetcode.com/problems/shortest-palindrome/"
                    },
                    {
                        "username": "monikakumari2k",
                        "content": "okay..bt where is the code :)"
                    }
                ]
            },
            {
                "id": 1573060,
                "content": [
                    {
                        "username": "mp0wr",
                        "content": "The problem statement claims the grader will accept alternate correct answers.\\n> Note: \"aba\" is also a valid answer.\\n\\nMy code takes \"babad\" as input, and outputs \"aba\".\\n\\n## Using [Run Code]\\nGrader returns:\\n> Expected \"bab\"\\n\\nThere\\'s no way (other than [Submit]) to know that another palindrome of equal length is accepted. \\n"
                    },
                    {
                        "username": "jamespaz311",
                        "content": "Did i miss something? I know that palindromic is when String s==s(reversed) but how it end up \"a\" from \"ac\"?"
                    },
                    {
                        "username": "user2531u",
                        "content": "Has anyone come across this in an actual interview?"
                    },
                    {
                        "username": "supreme_dalek",
                        "content": "If anyone understands \"a\" from \"ac\" to fit the definition of a palindrome, can you please let me know by providing a link or citation to an authoratative source stating as much?\\n\\nThanks,\\nmr.T\\n"
                    },
                    {
                        "username": "gktk",
                        "content": "The link to Manacher\\'s algorithm provided in the Solution section is dead: https://articles.leetcode.com/longest-palindromic-substring-part-ii/\\n\\nI get a database error. Could someone please fix it? Thanks!"
                    },
                    {
                        "username": "RayYang_",
                        "content": "see the picture , what\\'s wrong with this?\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/rayyang_/image_1536665252.png)\\n"
                    },
                    {
                        "username": "rabeeh",
                        "content": "Hi, \\nwhen I submit my codes, judge keep being pending, I wonder if anyone has how to solve it.\\nThanks."
                    },
                    {
                        "username": "aaaaaqi5",
                        "content": "Why input \"abcda\" should return \"a\"? \\nDoesn't make sense at all!\\n\\nCan anyone explain?"
                    },
                    {
                        "username": "Future6",
                        "content": "Should the answer be \"aacakacaa\"?\\n\\nBut it gives \"aca\" as correct answer. Did i miss something here?"
                    },
                    {
                        "username": "AssasianKing",
                        "content": "Can be easily solved using [Manacher\\u2019s Algorithm](httphttps://en.wikipedia.org/wiki/Longest_palindromic_substring#Manacher.27s_algorithm://) .\\n\\nRefer\": https://www.hackerearth.com/practice/algorithms/string-algorithm/manachars-algorithm/tutorial/\\n\\n\\n"
                    }
                ]
            },
            {
                "id": 1572778,
                "content": [
                    {
                        "username": "mp0wr",
                        "content": "The problem statement claims the grader will accept alternate correct answers.\\n> Note: \"aba\" is also a valid answer.\\n\\nMy code takes \"babad\" as input, and outputs \"aba\".\\n\\n## Using [Run Code]\\nGrader returns:\\n> Expected \"bab\"\\n\\nThere\\'s no way (other than [Submit]) to know that another palindrome of equal length is accepted. \\n"
                    },
                    {
                        "username": "jamespaz311",
                        "content": "Did i miss something? I know that palindromic is when String s==s(reversed) but how it end up \"a\" from \"ac\"?"
                    },
                    {
                        "username": "user2531u",
                        "content": "Has anyone come across this in an actual interview?"
                    },
                    {
                        "username": "supreme_dalek",
                        "content": "If anyone understands \"a\" from \"ac\" to fit the definition of a palindrome, can you please let me know by providing a link or citation to an authoratative source stating as much?\\n\\nThanks,\\nmr.T\\n"
                    },
                    {
                        "username": "gktk",
                        "content": "The link to Manacher\\'s algorithm provided in the Solution section is dead: https://articles.leetcode.com/longest-palindromic-substring-part-ii/\\n\\nI get a database error. Could someone please fix it? Thanks!"
                    },
                    {
                        "username": "RayYang_",
                        "content": "see the picture , what\\'s wrong with this?\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/rayyang_/image_1536665252.png)\\n"
                    },
                    {
                        "username": "rabeeh",
                        "content": "Hi, \\nwhen I submit my codes, judge keep being pending, I wonder if anyone has how to solve it.\\nThanks."
                    },
                    {
                        "username": "aaaaaqi5",
                        "content": "Why input \"abcda\" should return \"a\"? \\nDoesn't make sense at all!\\n\\nCan anyone explain?"
                    },
                    {
                        "username": "Future6",
                        "content": "Should the answer be \"aacakacaa\"?\\n\\nBut it gives \"aca\" as correct answer. Did i miss something here?"
                    },
                    {
                        "username": "AssasianKing",
                        "content": "Can be easily solved using [Manacher\\u2019s Algorithm](httphttps://en.wikipedia.org/wiki/Longest_palindromic_substring#Manacher.27s_algorithm://) .\\n\\nRefer\": https://www.hackerearth.com/practice/algorithms/string-algorithm/manachars-algorithm/tutorial/\\n\\n\\n"
                    }
                ]
            },
            {
                "id": 1572743,
                "content": [
                    {
                        "username": "mp0wr",
                        "content": "The problem statement claims the grader will accept alternate correct answers.\\n> Note: \"aba\" is also a valid answer.\\n\\nMy code takes \"babad\" as input, and outputs \"aba\".\\n\\n## Using [Run Code]\\nGrader returns:\\n> Expected \"bab\"\\n\\nThere\\'s no way (other than [Submit]) to know that another palindrome of equal length is accepted. \\n"
                    },
                    {
                        "username": "jamespaz311",
                        "content": "Did i miss something? I know that palindromic is when String s==s(reversed) but how it end up \"a\" from \"ac\"?"
                    },
                    {
                        "username": "user2531u",
                        "content": "Has anyone come across this in an actual interview?"
                    },
                    {
                        "username": "supreme_dalek",
                        "content": "If anyone understands \"a\" from \"ac\" to fit the definition of a palindrome, can you please let me know by providing a link or citation to an authoratative source stating as much?\\n\\nThanks,\\nmr.T\\n"
                    },
                    {
                        "username": "gktk",
                        "content": "The link to Manacher\\'s algorithm provided in the Solution section is dead: https://articles.leetcode.com/longest-palindromic-substring-part-ii/\\n\\nI get a database error. Could someone please fix it? Thanks!"
                    },
                    {
                        "username": "RayYang_",
                        "content": "see the picture , what\\'s wrong with this?\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/rayyang_/image_1536665252.png)\\n"
                    },
                    {
                        "username": "rabeeh",
                        "content": "Hi, \\nwhen I submit my codes, judge keep being pending, I wonder if anyone has how to solve it.\\nThanks."
                    },
                    {
                        "username": "aaaaaqi5",
                        "content": "Why input \"abcda\" should return \"a\"? \\nDoesn't make sense at all!\\n\\nCan anyone explain?"
                    },
                    {
                        "username": "Future6",
                        "content": "Should the answer be \"aacakacaa\"?\\n\\nBut it gives \"aca\" as correct answer. Did i miss something here?"
                    },
                    {
                        "username": "AssasianKing",
                        "content": "Can be easily solved using [Manacher\\u2019s Algorithm](httphttps://en.wikipedia.org/wiki/Longest_palindromic_substring#Manacher.27s_algorithm://) .\\n\\nRefer\": https://www.hackerearth.com/practice/algorithms/string-algorithm/manachars-algorithm/tutorial/\\n\\n\\n"
                    }
                ]
            },
            {
                "id": 1572529,
                "content": [
                    {
                        "username": "mp0wr",
                        "content": "The problem statement claims the grader will accept alternate correct answers.\\n> Note: \"aba\" is also a valid answer.\\n\\nMy code takes \"babad\" as input, and outputs \"aba\".\\n\\n## Using [Run Code]\\nGrader returns:\\n> Expected \"bab\"\\n\\nThere\\'s no way (other than [Submit]) to know that another palindrome of equal length is accepted. \\n"
                    },
                    {
                        "username": "jamespaz311",
                        "content": "Did i miss something? I know that palindromic is when String s==s(reversed) but how it end up \"a\" from \"ac\"?"
                    },
                    {
                        "username": "user2531u",
                        "content": "Has anyone come across this in an actual interview?"
                    },
                    {
                        "username": "supreme_dalek",
                        "content": "If anyone understands \"a\" from \"ac\" to fit the definition of a palindrome, can you please let me know by providing a link or citation to an authoratative source stating as much?\\n\\nThanks,\\nmr.T\\n"
                    },
                    {
                        "username": "gktk",
                        "content": "The link to Manacher\\'s algorithm provided in the Solution section is dead: https://articles.leetcode.com/longest-palindromic-substring-part-ii/\\n\\nI get a database error. Could someone please fix it? Thanks!"
                    },
                    {
                        "username": "RayYang_",
                        "content": "see the picture , what\\'s wrong with this?\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/rayyang_/image_1536665252.png)\\n"
                    },
                    {
                        "username": "rabeeh",
                        "content": "Hi, \\nwhen I submit my codes, judge keep being pending, I wonder if anyone has how to solve it.\\nThanks."
                    },
                    {
                        "username": "aaaaaqi5",
                        "content": "Why input \"abcda\" should return \"a\"? \\nDoesn't make sense at all!\\n\\nCan anyone explain?"
                    },
                    {
                        "username": "Future6",
                        "content": "Should the answer be \"aacakacaa\"?\\n\\nBut it gives \"aca\" as correct answer. Did i miss something here?"
                    },
                    {
                        "username": "AssasianKing",
                        "content": "Can be easily solved using [Manacher\\u2019s Algorithm](httphttps://en.wikipedia.org/wiki/Longest_palindromic_substring#Manacher.27s_algorithm://) .\\n\\nRefer\": https://www.hackerearth.com/practice/algorithms/string-algorithm/manachars-algorithm/tutorial/\\n\\n\\n"
                    }
                ]
            },
            {
                "id": 1572481,
                "content": [
                    {
                        "username": "mp0wr",
                        "content": "The problem statement claims the grader will accept alternate correct answers.\\n> Note: \"aba\" is also a valid answer.\\n\\nMy code takes \"babad\" as input, and outputs \"aba\".\\n\\n## Using [Run Code]\\nGrader returns:\\n> Expected \"bab\"\\n\\nThere\\'s no way (other than [Submit]) to know that another palindrome of equal length is accepted. \\n"
                    },
                    {
                        "username": "jamespaz311",
                        "content": "Did i miss something? I know that palindromic is when String s==s(reversed) but how it end up \"a\" from \"ac\"?"
                    },
                    {
                        "username": "user2531u",
                        "content": "Has anyone come across this in an actual interview?"
                    },
                    {
                        "username": "supreme_dalek",
                        "content": "If anyone understands \"a\" from \"ac\" to fit the definition of a palindrome, can you please let me know by providing a link or citation to an authoratative source stating as much?\\n\\nThanks,\\nmr.T\\n"
                    },
                    {
                        "username": "gktk",
                        "content": "The link to Manacher\\'s algorithm provided in the Solution section is dead: https://articles.leetcode.com/longest-palindromic-substring-part-ii/\\n\\nI get a database error. Could someone please fix it? Thanks!"
                    },
                    {
                        "username": "RayYang_",
                        "content": "see the picture , what\\'s wrong with this?\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/rayyang_/image_1536665252.png)\\n"
                    },
                    {
                        "username": "rabeeh",
                        "content": "Hi, \\nwhen I submit my codes, judge keep being pending, I wonder if anyone has how to solve it.\\nThanks."
                    },
                    {
                        "username": "aaaaaqi5",
                        "content": "Why input \"abcda\" should return \"a\"? \\nDoesn't make sense at all!\\n\\nCan anyone explain?"
                    },
                    {
                        "username": "Future6",
                        "content": "Should the answer be \"aacakacaa\"?\\n\\nBut it gives \"aca\" as correct answer. Did i miss something here?"
                    },
                    {
                        "username": "AssasianKing",
                        "content": "Can be easily solved using [Manacher\\u2019s Algorithm](httphttps://en.wikipedia.org/wiki/Longest_palindromic_substring#Manacher.27s_algorithm://) .\\n\\nRefer\": https://www.hackerearth.com/practice/algorithms/string-algorithm/manachars-algorithm/tutorial/\\n\\n\\n"
                    }
                ]
            },
            {
                "id": 1572141,
                "content": [
                    {
                        "username": "mp0wr",
                        "content": "The problem statement claims the grader will accept alternate correct answers.\\n> Note: \"aba\" is also a valid answer.\\n\\nMy code takes \"babad\" as input, and outputs \"aba\".\\n\\n## Using [Run Code]\\nGrader returns:\\n> Expected \"bab\"\\n\\nThere\\'s no way (other than [Submit]) to know that another palindrome of equal length is accepted. \\n"
                    },
                    {
                        "username": "jamespaz311",
                        "content": "Did i miss something? I know that palindromic is when String s==s(reversed) but how it end up \"a\" from \"ac\"?"
                    },
                    {
                        "username": "user2531u",
                        "content": "Has anyone come across this in an actual interview?"
                    },
                    {
                        "username": "supreme_dalek",
                        "content": "If anyone understands \"a\" from \"ac\" to fit the definition of a palindrome, can you please let me know by providing a link or citation to an authoratative source stating as much?\\n\\nThanks,\\nmr.T\\n"
                    },
                    {
                        "username": "gktk",
                        "content": "The link to Manacher\\'s algorithm provided in the Solution section is dead: https://articles.leetcode.com/longest-palindromic-substring-part-ii/\\n\\nI get a database error. Could someone please fix it? Thanks!"
                    },
                    {
                        "username": "RayYang_",
                        "content": "see the picture , what\\'s wrong with this?\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/rayyang_/image_1536665252.png)\\n"
                    },
                    {
                        "username": "rabeeh",
                        "content": "Hi, \\nwhen I submit my codes, judge keep being pending, I wonder if anyone has how to solve it.\\nThanks."
                    },
                    {
                        "username": "aaaaaqi5",
                        "content": "Why input \"abcda\" should return \"a\"? \\nDoesn't make sense at all!\\n\\nCan anyone explain?"
                    },
                    {
                        "username": "Future6",
                        "content": "Should the answer be \"aacakacaa\"?\\n\\nBut it gives \"aca\" as correct answer. Did i miss something here?"
                    },
                    {
                        "username": "AssasianKing",
                        "content": "Can be easily solved using [Manacher\\u2019s Algorithm](httphttps://en.wikipedia.org/wiki/Longest_palindromic_substring#Manacher.27s_algorithm://) .\\n\\nRefer\": https://www.hackerearth.com/practice/algorithms/string-algorithm/manachars-algorithm/tutorial/\\n\\n\\n"
                    }
                ]
            },
            {
                "id": 1570974,
                "content": [
                    {
                        "username": "mp0wr",
                        "content": "The problem statement claims the grader will accept alternate correct answers.\\n> Note: \"aba\" is also a valid answer.\\n\\nMy code takes \"babad\" as input, and outputs \"aba\".\\n\\n## Using [Run Code]\\nGrader returns:\\n> Expected \"bab\"\\n\\nThere\\'s no way (other than [Submit]) to know that another palindrome of equal length is accepted. \\n"
                    },
                    {
                        "username": "jamespaz311",
                        "content": "Did i miss something? I know that palindromic is when String s==s(reversed) but how it end up \"a\" from \"ac\"?"
                    },
                    {
                        "username": "user2531u",
                        "content": "Has anyone come across this in an actual interview?"
                    },
                    {
                        "username": "supreme_dalek",
                        "content": "If anyone understands \"a\" from \"ac\" to fit the definition of a palindrome, can you please let me know by providing a link or citation to an authoratative source stating as much?\\n\\nThanks,\\nmr.T\\n"
                    },
                    {
                        "username": "gktk",
                        "content": "The link to Manacher\\'s algorithm provided in the Solution section is dead: https://articles.leetcode.com/longest-palindromic-substring-part-ii/\\n\\nI get a database error. Could someone please fix it? Thanks!"
                    },
                    {
                        "username": "RayYang_",
                        "content": "see the picture , what\\'s wrong with this?\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/rayyang_/image_1536665252.png)\\n"
                    },
                    {
                        "username": "rabeeh",
                        "content": "Hi, \\nwhen I submit my codes, judge keep being pending, I wonder if anyone has how to solve it.\\nThanks."
                    },
                    {
                        "username": "aaaaaqi5",
                        "content": "Why input \"abcda\" should return \"a\"? \\nDoesn't make sense at all!\\n\\nCan anyone explain?"
                    },
                    {
                        "username": "Future6",
                        "content": "Should the answer be \"aacakacaa\"?\\n\\nBut it gives \"aca\" as correct answer. Did i miss something here?"
                    },
                    {
                        "username": "AssasianKing",
                        "content": "Can be easily solved using [Manacher\\u2019s Algorithm](httphttps://en.wikipedia.org/wiki/Longest_palindromic_substring#Manacher.27s_algorithm://) .\\n\\nRefer\": https://www.hackerearth.com/practice/algorithms/string-algorithm/manachars-algorithm/tutorial/\\n\\n\\n"
                    }
                ]
            },
            {
                "id": 1570973,
                "content": [
                    {
                        "username": "mp0wr",
                        "content": "The problem statement claims the grader will accept alternate correct answers.\\n> Note: \"aba\" is also a valid answer.\\n\\nMy code takes \"babad\" as input, and outputs \"aba\".\\n\\n## Using [Run Code]\\nGrader returns:\\n> Expected \"bab\"\\n\\nThere\\'s no way (other than [Submit]) to know that another palindrome of equal length is accepted. \\n"
                    },
                    {
                        "username": "jamespaz311",
                        "content": "Did i miss something? I know that palindromic is when String s==s(reversed) but how it end up \"a\" from \"ac\"?"
                    },
                    {
                        "username": "user2531u",
                        "content": "Has anyone come across this in an actual interview?"
                    },
                    {
                        "username": "supreme_dalek",
                        "content": "If anyone understands \"a\" from \"ac\" to fit the definition of a palindrome, can you please let me know by providing a link or citation to an authoratative source stating as much?\\n\\nThanks,\\nmr.T\\n"
                    },
                    {
                        "username": "gktk",
                        "content": "The link to Manacher\\'s algorithm provided in the Solution section is dead: https://articles.leetcode.com/longest-palindromic-substring-part-ii/\\n\\nI get a database error. Could someone please fix it? Thanks!"
                    },
                    {
                        "username": "RayYang_",
                        "content": "see the picture , what\\'s wrong with this?\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/rayyang_/image_1536665252.png)\\n"
                    },
                    {
                        "username": "rabeeh",
                        "content": "Hi, \\nwhen I submit my codes, judge keep being pending, I wonder if anyone has how to solve it.\\nThanks."
                    },
                    {
                        "username": "aaaaaqi5",
                        "content": "Why input \"abcda\" should return \"a\"? \\nDoesn't make sense at all!\\n\\nCan anyone explain?"
                    },
                    {
                        "username": "Future6",
                        "content": "Should the answer be \"aacakacaa\"?\\n\\nBut it gives \"aca\" as correct answer. Did i miss something here?"
                    },
                    {
                        "username": "AssasianKing",
                        "content": "Can be easily solved using [Manacher\\u2019s Algorithm](httphttps://en.wikipedia.org/wiki/Longest_palindromic_substring#Manacher.27s_algorithm://) .\\n\\nRefer\": https://www.hackerearth.com/practice/algorithms/string-algorithm/manachars-algorithm/tutorial/\\n\\n\\n"
                    }
                ]
            },
            {
                "id": 1570209,
                "content": [
                    {
                        "username": "mp0wr",
                        "content": "The problem statement claims the grader will accept alternate correct answers.\\n> Note: \"aba\" is also a valid answer.\\n\\nMy code takes \"babad\" as input, and outputs \"aba\".\\n\\n## Using [Run Code]\\nGrader returns:\\n> Expected \"bab\"\\n\\nThere\\'s no way (other than [Submit]) to know that another palindrome of equal length is accepted. \\n"
                    },
                    {
                        "username": "jamespaz311",
                        "content": "Did i miss something? I know that palindromic is when String s==s(reversed) but how it end up \"a\" from \"ac\"?"
                    },
                    {
                        "username": "user2531u",
                        "content": "Has anyone come across this in an actual interview?"
                    },
                    {
                        "username": "supreme_dalek",
                        "content": "If anyone understands \"a\" from \"ac\" to fit the definition of a palindrome, can you please let me know by providing a link or citation to an authoratative source stating as much?\\n\\nThanks,\\nmr.T\\n"
                    },
                    {
                        "username": "gktk",
                        "content": "The link to Manacher\\'s algorithm provided in the Solution section is dead: https://articles.leetcode.com/longest-palindromic-substring-part-ii/\\n\\nI get a database error. Could someone please fix it? Thanks!"
                    },
                    {
                        "username": "RayYang_",
                        "content": "see the picture , what\\'s wrong with this?\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/rayyang_/image_1536665252.png)\\n"
                    },
                    {
                        "username": "rabeeh",
                        "content": "Hi, \\nwhen I submit my codes, judge keep being pending, I wonder if anyone has how to solve it.\\nThanks."
                    },
                    {
                        "username": "aaaaaqi5",
                        "content": "Why input \"abcda\" should return \"a\"? \\nDoesn't make sense at all!\\n\\nCan anyone explain?"
                    },
                    {
                        "username": "Future6",
                        "content": "Should the answer be \"aacakacaa\"?\\n\\nBut it gives \"aca\" as correct answer. Did i miss something here?"
                    },
                    {
                        "username": "AssasianKing",
                        "content": "Can be easily solved using [Manacher\\u2019s Algorithm](httphttps://en.wikipedia.org/wiki/Longest_palindromic_substring#Manacher.27s_algorithm://) .\\n\\nRefer\": https://www.hackerearth.com/practice/algorithms/string-algorithm/manachars-algorithm/tutorial/\\n\\n\\n"
                    }
                ]
            },
            {
                "id": 1576453,
                "content": [
                    {
                        "username": "mp0wr",
                        "content": "The problem statement claims the grader will accept alternate correct answers.\\n> Note: \"aba\" is also a valid answer.\\n\\nMy code takes \"babad\" as input, and outputs \"aba\".\\n\\n## Using [Run Code]\\nGrader returns:\\n> Expected \"bab\"\\n\\nThere\\'s no way (other than [Submit]) to know that another palindrome of equal length is accepted. \\n"
                    },
                    {
                        "username": "jamespaz311",
                        "content": "Did i miss something? I know that palindromic is when String s==s(reversed) but how it end up \"a\" from \"ac\"?"
                    },
                    {
                        "username": "user2531u",
                        "content": "Has anyone come across this in an actual interview?"
                    },
                    {
                        "username": "supreme_dalek",
                        "content": "If anyone understands \"a\" from \"ac\" to fit the definition of a palindrome, can you please let me know by providing a link or citation to an authoratative source stating as much?\\n\\nThanks,\\nmr.T\\n"
                    },
                    {
                        "username": "gktk",
                        "content": "The link to Manacher\\'s algorithm provided in the Solution section is dead: https://articles.leetcode.com/longest-palindromic-substring-part-ii/\\n\\nI get a database error. Could someone please fix it? Thanks!"
                    },
                    {
                        "username": "RayYang_",
                        "content": "see the picture , what\\'s wrong with this?\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/rayyang_/image_1536665252.png)\\n"
                    },
                    {
                        "username": "rabeeh",
                        "content": "Hi, \\nwhen I submit my codes, judge keep being pending, I wonder if anyone has how to solve it.\\nThanks."
                    },
                    {
                        "username": "aaaaaqi5",
                        "content": "Why input \"abcda\" should return \"a\"? \\nDoesn't make sense at all!\\n\\nCan anyone explain?"
                    },
                    {
                        "username": "Future6",
                        "content": "Should the answer be \"aacakacaa\"?\\n\\nBut it gives \"aca\" as correct answer. Did i miss something here?"
                    },
                    {
                        "username": "AssasianKing",
                        "content": "Can be easily solved using [Manacher\\u2019s Algorithm](httphttps://en.wikipedia.org/wiki/Longest_palindromic_substring#Manacher.27s_algorithm://) .\\n\\nRefer\": https://www.hackerearth.com/practice/algorithms/string-algorithm/manachars-algorithm/tutorial/\\n\\n\\n"
                    }
                ]
            },
            {
                "id": 1575285,
                "content": [
                    {
                        "username": "dhavalkolapkar",
                        "content": "Variable Sliding window is used when we have to find a subarry or substring with a condition. Find max subarray with distinct chars.\\nNow why is this a DP and not sliding window as we have to find a min substring with palindrome."
                    },
                    {
                        "username": "msn_user",
                        "content": "Refer below for non-DP solution and well-commented code in C++, Java and Python:\\nhttps://www.techiedelight.com/longest-palindromic-substring-non-dp-space-optimized-solution/"
                    },
                    {
                        "username": "JasonDada",
                        "content": "Using dynamic programming algorithm, the memorization table dp[i,j] shows the maximum palindromic substring lengith is 3.  Then the answer is \"aba\". However, leetcode rejects the this answer.  Please help me understand why the accepted answer is \"a\" instead of \"aba\". \\n"
                    },
                    {
                        "username": "hanayashiki",
                        "content": "Input:\\n\"abcdasdfghjkldcba\"\\nOutput:\\n\"abcd\"\\nExpected:\\n\"a\"\\n\\nobviously s[0:4] = \\'abcd\\' while s[-5:-1]=\\'dcba\\' so the answer should be \\'abcd\\'"
                    },
                    {
                        "username": "jt88",
                        "content": "the problem is, you don\\'t know what a palindrome is...\"abcd\" != \"dcba\", if that were the case you would return the whole string and then there would be no point to the exercise"
                    },
                    {
                        "username": "mailo14",
                        "content": "I got Wrong Answer on test:\\nInput:\"abcda\"\\nOutput:\"\"\\nExpected:\"a\"\\nIs \"a\" a palindrom?"
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "Are you for real dude? O(n^3) accepted but O(n^2) giving TLE!\\n\\n1. O(n^3) -> Accepted \\n ```\\nclass Solution {\\n    private static boolean isPalindrome(String s, int start, int end){\\n        while(start<end){\\n            if(s.charAt(start)!=s.charAt(end)) return false;\\n            start++;\\n            end--;\\n        }\\n        return true;\\n    }\\n\\n    public String longestPalindrome(String s) {\\n        int len = s.length();\\n        String ans = \"\";\\n        for(int start=0;start<len;start++){\\n            for(int end=start;end<len;end++){\\n                if(isPalindrome(s,start,end) && ans.length()<end-start+1) ans = s.substring(start,end+1);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\\n// BruteForce Code \\n// Time Complexity : O(len^3)\\n// Space Complexity : O(len)\\n```\\n\\n2. O(n^2) -> TLE\\n```\\nclass Solution {\\n    public String longestPalindrome(String s) {\\n        int len = s.length();\\n        String ans = \"\";\\n        for(int start=0;start<len;start++){\\n            String temp = \"\", temp_ = \"\";\\n            for(int end=start;end<len;end++){\\n                temp_ = temp_ + s.charAt(end);\\n                temp = s.charAt(end) + temp;\\n                if(temp.equals(temp_) && ans.length()<temp.length()) ans = temp;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\\n// Optimal Code \\n// Time Complexity : O(len^2)\\n// Space Complexity : O(len*2)\\n```"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "stop posting solutions"
                    },
                    {
                        "username": "layyy",
                        "content": "A substring from index i to j can be palindrome only if the substring from index i+1 to j-1 is palindrome and characters at index i and j are equal \\ndp[i][j]=1 only if dp[i+1][j-1]==1 and s[i]==s[j]"
                    },
                    {
                        "username": "Vaibhav247",
                        "content": "class Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n        int n = s.size();\\n        int num=0;\\n        if(s.size()==1) {\\n            return s;\\n        }\\n        int min_ind , max_ind;\\n        for(int i=0; i<n; i++ ) {\\n            int x=i;\\n            int y=i;\\n            int count=1;\\n            if(count>num) {\\n                num=count;\\n                min_ind=x;\\n                max_ind=y;\\n            }\\n            x--;\\n            y++;\\n            while(x>=0 && y<n) {\\n                if(s[x]==s[y]) {\\n                    count=count+2;\\n                    x--;\\n                    y++;\\n                    if(count>num) {\\n                        num=count;\\n                        min_ind=x+1;\\n                        max_ind=y-1;\\n                    }\\n                }\\n                else {\\n                    break;\\n                }\\n            }\\n        }\\n        for(int i=0; i<n-1; i++ ) {\\n            int x=i;\\n            int y=i+1;\\n            int count=0;\\n            while(x>=0 && y<n) {\\n                if(s[x]==s[y]) {\\n                    count=count+2;\\n                    x--;\\n                    y++;\\n                    if(count>num) {\\n                        num=count;\\n                        min_ind=x+1;\\n                        max_ind=y-1;\\n                    }\\n                }\\n                else {\\n                    break;\\n                }\\n            }\\n        }\\n        string ans=\"\";\\n        for(int i=min_ind; i<=max_ind; i++) {\\n            ans.push_back(s[i]);\\n        }\\n        return ans;\\n    }\\n};\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "devrathod_212",
                        "content": "s =\\n\"aacabdkacaa\"\\n\\nin this testcase expected output is wrong\\nmy code output : aacabacaa\\nexpected: aca.\\n\\nHow?\\ncan anyone solve this ?  "
                    },
                    {
                        "username": "BLANK-Zora",
                        "content": "can someone explain me the case 141 , it just says s = \\nthat\\'s it , its like not even in the constraint , its not even a string , its just ... it"
                    }
                ]
            },
            {
                "id": 1574081,
                "content": [
                    {
                        "username": "dhavalkolapkar",
                        "content": "Variable Sliding window is used when we have to find a subarry or substring with a condition. Find max subarray with distinct chars.\\nNow why is this a DP and not sliding window as we have to find a min substring with palindrome."
                    },
                    {
                        "username": "msn_user",
                        "content": "Refer below for non-DP solution and well-commented code in C++, Java and Python:\\nhttps://www.techiedelight.com/longest-palindromic-substring-non-dp-space-optimized-solution/"
                    },
                    {
                        "username": "JasonDada",
                        "content": "Using dynamic programming algorithm, the memorization table dp[i,j] shows the maximum palindromic substring lengith is 3.  Then the answer is \"aba\". However, leetcode rejects the this answer.  Please help me understand why the accepted answer is \"a\" instead of \"aba\". \\n"
                    },
                    {
                        "username": "hanayashiki",
                        "content": "Input:\\n\"abcdasdfghjkldcba\"\\nOutput:\\n\"abcd\"\\nExpected:\\n\"a\"\\n\\nobviously s[0:4] = \\'abcd\\' while s[-5:-1]=\\'dcba\\' so the answer should be \\'abcd\\'"
                    },
                    {
                        "username": "jt88",
                        "content": "the problem is, you don\\'t know what a palindrome is...\"abcd\" != \"dcba\", if that were the case you would return the whole string and then there would be no point to the exercise"
                    },
                    {
                        "username": "mailo14",
                        "content": "I got Wrong Answer on test:\\nInput:\"abcda\"\\nOutput:\"\"\\nExpected:\"a\"\\nIs \"a\" a palindrom?"
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "Are you for real dude? O(n^3) accepted but O(n^2) giving TLE!\\n\\n1. O(n^3) -> Accepted \\n ```\\nclass Solution {\\n    private static boolean isPalindrome(String s, int start, int end){\\n        while(start<end){\\n            if(s.charAt(start)!=s.charAt(end)) return false;\\n            start++;\\n            end--;\\n        }\\n        return true;\\n    }\\n\\n    public String longestPalindrome(String s) {\\n        int len = s.length();\\n        String ans = \"\";\\n        for(int start=0;start<len;start++){\\n            for(int end=start;end<len;end++){\\n                if(isPalindrome(s,start,end) && ans.length()<end-start+1) ans = s.substring(start,end+1);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\\n// BruteForce Code \\n// Time Complexity : O(len^3)\\n// Space Complexity : O(len)\\n```\\n\\n2. O(n^2) -> TLE\\n```\\nclass Solution {\\n    public String longestPalindrome(String s) {\\n        int len = s.length();\\n        String ans = \"\";\\n        for(int start=0;start<len;start++){\\n            String temp = \"\", temp_ = \"\";\\n            for(int end=start;end<len;end++){\\n                temp_ = temp_ + s.charAt(end);\\n                temp = s.charAt(end) + temp;\\n                if(temp.equals(temp_) && ans.length()<temp.length()) ans = temp;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\\n// Optimal Code \\n// Time Complexity : O(len^2)\\n// Space Complexity : O(len*2)\\n```"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "stop posting solutions"
                    },
                    {
                        "username": "layyy",
                        "content": "A substring from index i to j can be palindrome only if the substring from index i+1 to j-1 is palindrome and characters at index i and j are equal \\ndp[i][j]=1 only if dp[i+1][j-1]==1 and s[i]==s[j]"
                    },
                    {
                        "username": "Vaibhav247",
                        "content": "class Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n        int n = s.size();\\n        int num=0;\\n        if(s.size()==1) {\\n            return s;\\n        }\\n        int min_ind , max_ind;\\n        for(int i=0; i<n; i++ ) {\\n            int x=i;\\n            int y=i;\\n            int count=1;\\n            if(count>num) {\\n                num=count;\\n                min_ind=x;\\n                max_ind=y;\\n            }\\n            x--;\\n            y++;\\n            while(x>=0 && y<n) {\\n                if(s[x]==s[y]) {\\n                    count=count+2;\\n                    x--;\\n                    y++;\\n                    if(count>num) {\\n                        num=count;\\n                        min_ind=x+1;\\n                        max_ind=y-1;\\n                    }\\n                }\\n                else {\\n                    break;\\n                }\\n            }\\n        }\\n        for(int i=0; i<n-1; i++ ) {\\n            int x=i;\\n            int y=i+1;\\n            int count=0;\\n            while(x>=0 && y<n) {\\n                if(s[x]==s[y]) {\\n                    count=count+2;\\n                    x--;\\n                    y++;\\n                    if(count>num) {\\n                        num=count;\\n                        min_ind=x+1;\\n                        max_ind=y-1;\\n                    }\\n                }\\n                else {\\n                    break;\\n                }\\n            }\\n        }\\n        string ans=\"\";\\n        for(int i=min_ind; i<=max_ind; i++) {\\n            ans.push_back(s[i]);\\n        }\\n        return ans;\\n    }\\n};\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "devrathod_212",
                        "content": "s =\\n\"aacabdkacaa\"\\n\\nin this testcase expected output is wrong\\nmy code output : aacabacaa\\nexpected: aca.\\n\\nHow?\\ncan anyone solve this ?  "
                    },
                    {
                        "username": "BLANK-Zora",
                        "content": "can someone explain me the case 141 , it just says s = \\nthat\\'s it , its like not even in the constraint , its not even a string , its just ... it"
                    }
                ]
            },
            {
                "id": 1571894,
                "content": [
                    {
                        "username": "dhavalkolapkar",
                        "content": "Variable Sliding window is used when we have to find a subarry or substring with a condition. Find max subarray with distinct chars.\\nNow why is this a DP and not sliding window as we have to find a min substring with palindrome."
                    },
                    {
                        "username": "msn_user",
                        "content": "Refer below for non-DP solution and well-commented code in C++, Java and Python:\\nhttps://www.techiedelight.com/longest-palindromic-substring-non-dp-space-optimized-solution/"
                    },
                    {
                        "username": "JasonDada",
                        "content": "Using dynamic programming algorithm, the memorization table dp[i,j] shows the maximum palindromic substring lengith is 3.  Then the answer is \"aba\". However, leetcode rejects the this answer.  Please help me understand why the accepted answer is \"a\" instead of \"aba\". \\n"
                    },
                    {
                        "username": "hanayashiki",
                        "content": "Input:\\n\"abcdasdfghjkldcba\"\\nOutput:\\n\"abcd\"\\nExpected:\\n\"a\"\\n\\nobviously s[0:4] = \\'abcd\\' while s[-5:-1]=\\'dcba\\' so the answer should be \\'abcd\\'"
                    },
                    {
                        "username": "jt88",
                        "content": "the problem is, you don\\'t know what a palindrome is...\"abcd\" != \"dcba\", if that were the case you would return the whole string and then there would be no point to the exercise"
                    },
                    {
                        "username": "mailo14",
                        "content": "I got Wrong Answer on test:\\nInput:\"abcda\"\\nOutput:\"\"\\nExpected:\"a\"\\nIs \"a\" a palindrom?"
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "Are you for real dude? O(n^3) accepted but O(n^2) giving TLE!\\n\\n1. O(n^3) -> Accepted \\n ```\\nclass Solution {\\n    private static boolean isPalindrome(String s, int start, int end){\\n        while(start<end){\\n            if(s.charAt(start)!=s.charAt(end)) return false;\\n            start++;\\n            end--;\\n        }\\n        return true;\\n    }\\n\\n    public String longestPalindrome(String s) {\\n        int len = s.length();\\n        String ans = \"\";\\n        for(int start=0;start<len;start++){\\n            for(int end=start;end<len;end++){\\n                if(isPalindrome(s,start,end) && ans.length()<end-start+1) ans = s.substring(start,end+1);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\\n// BruteForce Code \\n// Time Complexity : O(len^3)\\n// Space Complexity : O(len)\\n```\\n\\n2. O(n^2) -> TLE\\n```\\nclass Solution {\\n    public String longestPalindrome(String s) {\\n        int len = s.length();\\n        String ans = \"\";\\n        for(int start=0;start<len;start++){\\n            String temp = \"\", temp_ = \"\";\\n            for(int end=start;end<len;end++){\\n                temp_ = temp_ + s.charAt(end);\\n                temp = s.charAt(end) + temp;\\n                if(temp.equals(temp_) && ans.length()<temp.length()) ans = temp;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\\n// Optimal Code \\n// Time Complexity : O(len^2)\\n// Space Complexity : O(len*2)\\n```"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "stop posting solutions"
                    },
                    {
                        "username": "layyy",
                        "content": "A substring from index i to j can be palindrome only if the substring from index i+1 to j-1 is palindrome and characters at index i and j are equal \\ndp[i][j]=1 only if dp[i+1][j-1]==1 and s[i]==s[j]"
                    },
                    {
                        "username": "Vaibhav247",
                        "content": "class Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n        int n = s.size();\\n        int num=0;\\n        if(s.size()==1) {\\n            return s;\\n        }\\n        int min_ind , max_ind;\\n        for(int i=0; i<n; i++ ) {\\n            int x=i;\\n            int y=i;\\n            int count=1;\\n            if(count>num) {\\n                num=count;\\n                min_ind=x;\\n                max_ind=y;\\n            }\\n            x--;\\n            y++;\\n            while(x>=0 && y<n) {\\n                if(s[x]==s[y]) {\\n                    count=count+2;\\n                    x--;\\n                    y++;\\n                    if(count>num) {\\n                        num=count;\\n                        min_ind=x+1;\\n                        max_ind=y-1;\\n                    }\\n                }\\n                else {\\n                    break;\\n                }\\n            }\\n        }\\n        for(int i=0; i<n-1; i++ ) {\\n            int x=i;\\n            int y=i+1;\\n            int count=0;\\n            while(x>=0 && y<n) {\\n                if(s[x]==s[y]) {\\n                    count=count+2;\\n                    x--;\\n                    y++;\\n                    if(count>num) {\\n                        num=count;\\n                        min_ind=x+1;\\n                        max_ind=y-1;\\n                    }\\n                }\\n                else {\\n                    break;\\n                }\\n            }\\n        }\\n        string ans=\"\";\\n        for(int i=min_ind; i<=max_ind; i++) {\\n            ans.push_back(s[i]);\\n        }\\n        return ans;\\n    }\\n};\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "devrathod_212",
                        "content": "s =\\n\"aacabdkacaa\"\\n\\nin this testcase expected output is wrong\\nmy code output : aacabacaa\\nexpected: aca.\\n\\nHow?\\ncan anyone solve this ?  "
                    },
                    {
                        "username": "BLANK-Zora",
                        "content": "can someone explain me the case 141 , it just says s = \\nthat\\'s it , its like not even in the constraint , its not even a string , its just ... it"
                    }
                ]
            },
            {
                "id": 1571892,
                "content": [
                    {
                        "username": "dhavalkolapkar",
                        "content": "Variable Sliding window is used when we have to find a subarry or substring with a condition. Find max subarray with distinct chars.\\nNow why is this a DP and not sliding window as we have to find a min substring with palindrome."
                    },
                    {
                        "username": "msn_user",
                        "content": "Refer below for non-DP solution and well-commented code in C++, Java and Python:\\nhttps://www.techiedelight.com/longest-palindromic-substring-non-dp-space-optimized-solution/"
                    },
                    {
                        "username": "JasonDada",
                        "content": "Using dynamic programming algorithm, the memorization table dp[i,j] shows the maximum palindromic substring lengith is 3.  Then the answer is \"aba\". However, leetcode rejects the this answer.  Please help me understand why the accepted answer is \"a\" instead of \"aba\". \\n"
                    },
                    {
                        "username": "hanayashiki",
                        "content": "Input:\\n\"abcdasdfghjkldcba\"\\nOutput:\\n\"abcd\"\\nExpected:\\n\"a\"\\n\\nobviously s[0:4] = \\'abcd\\' while s[-5:-1]=\\'dcba\\' so the answer should be \\'abcd\\'"
                    },
                    {
                        "username": "jt88",
                        "content": "the problem is, you don\\'t know what a palindrome is...\"abcd\" != \"dcba\", if that were the case you would return the whole string and then there would be no point to the exercise"
                    },
                    {
                        "username": "mailo14",
                        "content": "I got Wrong Answer on test:\\nInput:\"abcda\"\\nOutput:\"\"\\nExpected:\"a\"\\nIs \"a\" a palindrom?"
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "Are you for real dude? O(n^3) accepted but O(n^2) giving TLE!\\n\\n1. O(n^3) -> Accepted \\n ```\\nclass Solution {\\n    private static boolean isPalindrome(String s, int start, int end){\\n        while(start<end){\\n            if(s.charAt(start)!=s.charAt(end)) return false;\\n            start++;\\n            end--;\\n        }\\n        return true;\\n    }\\n\\n    public String longestPalindrome(String s) {\\n        int len = s.length();\\n        String ans = \"\";\\n        for(int start=0;start<len;start++){\\n            for(int end=start;end<len;end++){\\n                if(isPalindrome(s,start,end) && ans.length()<end-start+1) ans = s.substring(start,end+1);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\\n// BruteForce Code \\n// Time Complexity : O(len^3)\\n// Space Complexity : O(len)\\n```\\n\\n2. O(n^2) -> TLE\\n```\\nclass Solution {\\n    public String longestPalindrome(String s) {\\n        int len = s.length();\\n        String ans = \"\";\\n        for(int start=0;start<len;start++){\\n            String temp = \"\", temp_ = \"\";\\n            for(int end=start;end<len;end++){\\n                temp_ = temp_ + s.charAt(end);\\n                temp = s.charAt(end) + temp;\\n                if(temp.equals(temp_) && ans.length()<temp.length()) ans = temp;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\\n// Optimal Code \\n// Time Complexity : O(len^2)\\n// Space Complexity : O(len*2)\\n```"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "stop posting solutions"
                    },
                    {
                        "username": "layyy",
                        "content": "A substring from index i to j can be palindrome only if the substring from index i+1 to j-1 is palindrome and characters at index i and j are equal \\ndp[i][j]=1 only if dp[i+1][j-1]==1 and s[i]==s[j]"
                    },
                    {
                        "username": "Vaibhav247",
                        "content": "class Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n        int n = s.size();\\n        int num=0;\\n        if(s.size()==1) {\\n            return s;\\n        }\\n        int min_ind , max_ind;\\n        for(int i=0; i<n; i++ ) {\\n            int x=i;\\n            int y=i;\\n            int count=1;\\n            if(count>num) {\\n                num=count;\\n                min_ind=x;\\n                max_ind=y;\\n            }\\n            x--;\\n            y++;\\n            while(x>=0 && y<n) {\\n                if(s[x]==s[y]) {\\n                    count=count+2;\\n                    x--;\\n                    y++;\\n                    if(count>num) {\\n                        num=count;\\n                        min_ind=x+1;\\n                        max_ind=y-1;\\n                    }\\n                }\\n                else {\\n                    break;\\n                }\\n            }\\n        }\\n        for(int i=0; i<n-1; i++ ) {\\n            int x=i;\\n            int y=i+1;\\n            int count=0;\\n            while(x>=0 && y<n) {\\n                if(s[x]==s[y]) {\\n                    count=count+2;\\n                    x--;\\n                    y++;\\n                    if(count>num) {\\n                        num=count;\\n                        min_ind=x+1;\\n                        max_ind=y-1;\\n                    }\\n                }\\n                else {\\n                    break;\\n                }\\n            }\\n        }\\n        string ans=\"\";\\n        for(int i=min_ind; i<=max_ind; i++) {\\n            ans.push_back(s[i]);\\n        }\\n        return ans;\\n    }\\n};\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "devrathod_212",
                        "content": "s =\\n\"aacabdkacaa\"\\n\\nin this testcase expected output is wrong\\nmy code output : aacabacaa\\nexpected: aca.\\n\\nHow?\\ncan anyone solve this ?  "
                    },
                    {
                        "username": "BLANK-Zora",
                        "content": "can someone explain me the case 141 , it just says s = \\nthat\\'s it , its like not even in the constraint , its not even a string , its just ... it"
                    }
                ]
            },
            {
                "id": 1570972,
                "content": [
                    {
                        "username": "dhavalkolapkar",
                        "content": "Variable Sliding window is used when we have to find a subarry or substring with a condition. Find max subarray with distinct chars.\\nNow why is this a DP and not sliding window as we have to find a min substring with palindrome."
                    },
                    {
                        "username": "msn_user",
                        "content": "Refer below for non-DP solution and well-commented code in C++, Java and Python:\\nhttps://www.techiedelight.com/longest-palindromic-substring-non-dp-space-optimized-solution/"
                    },
                    {
                        "username": "JasonDada",
                        "content": "Using dynamic programming algorithm, the memorization table dp[i,j] shows the maximum palindromic substring lengith is 3.  Then the answer is \"aba\". However, leetcode rejects the this answer.  Please help me understand why the accepted answer is \"a\" instead of \"aba\". \\n"
                    },
                    {
                        "username": "hanayashiki",
                        "content": "Input:\\n\"abcdasdfghjkldcba\"\\nOutput:\\n\"abcd\"\\nExpected:\\n\"a\"\\n\\nobviously s[0:4] = \\'abcd\\' while s[-5:-1]=\\'dcba\\' so the answer should be \\'abcd\\'"
                    },
                    {
                        "username": "jt88",
                        "content": "the problem is, you don\\'t know what a palindrome is...\"abcd\" != \"dcba\", if that were the case you would return the whole string and then there would be no point to the exercise"
                    },
                    {
                        "username": "mailo14",
                        "content": "I got Wrong Answer on test:\\nInput:\"abcda\"\\nOutput:\"\"\\nExpected:\"a\"\\nIs \"a\" a palindrom?"
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "Are you for real dude? O(n^3) accepted but O(n^2) giving TLE!\\n\\n1. O(n^3) -> Accepted \\n ```\\nclass Solution {\\n    private static boolean isPalindrome(String s, int start, int end){\\n        while(start<end){\\n            if(s.charAt(start)!=s.charAt(end)) return false;\\n            start++;\\n            end--;\\n        }\\n        return true;\\n    }\\n\\n    public String longestPalindrome(String s) {\\n        int len = s.length();\\n        String ans = \"\";\\n        for(int start=0;start<len;start++){\\n            for(int end=start;end<len;end++){\\n                if(isPalindrome(s,start,end) && ans.length()<end-start+1) ans = s.substring(start,end+1);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\\n// BruteForce Code \\n// Time Complexity : O(len^3)\\n// Space Complexity : O(len)\\n```\\n\\n2. O(n^2) -> TLE\\n```\\nclass Solution {\\n    public String longestPalindrome(String s) {\\n        int len = s.length();\\n        String ans = \"\";\\n        for(int start=0;start<len;start++){\\n            String temp = \"\", temp_ = \"\";\\n            for(int end=start;end<len;end++){\\n                temp_ = temp_ + s.charAt(end);\\n                temp = s.charAt(end) + temp;\\n                if(temp.equals(temp_) && ans.length()<temp.length()) ans = temp;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\\n// Optimal Code \\n// Time Complexity : O(len^2)\\n// Space Complexity : O(len*2)\\n```"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "stop posting solutions"
                    },
                    {
                        "username": "layyy",
                        "content": "A substring from index i to j can be palindrome only if the substring from index i+1 to j-1 is palindrome and characters at index i and j are equal \\ndp[i][j]=1 only if dp[i+1][j-1]==1 and s[i]==s[j]"
                    },
                    {
                        "username": "Vaibhav247",
                        "content": "class Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n        int n = s.size();\\n        int num=0;\\n        if(s.size()==1) {\\n            return s;\\n        }\\n        int min_ind , max_ind;\\n        for(int i=0; i<n; i++ ) {\\n            int x=i;\\n            int y=i;\\n            int count=1;\\n            if(count>num) {\\n                num=count;\\n                min_ind=x;\\n                max_ind=y;\\n            }\\n            x--;\\n            y++;\\n            while(x>=0 && y<n) {\\n                if(s[x]==s[y]) {\\n                    count=count+2;\\n                    x--;\\n                    y++;\\n                    if(count>num) {\\n                        num=count;\\n                        min_ind=x+1;\\n                        max_ind=y-1;\\n                    }\\n                }\\n                else {\\n                    break;\\n                }\\n            }\\n        }\\n        for(int i=0; i<n-1; i++ ) {\\n            int x=i;\\n            int y=i+1;\\n            int count=0;\\n            while(x>=0 && y<n) {\\n                if(s[x]==s[y]) {\\n                    count=count+2;\\n                    x--;\\n                    y++;\\n                    if(count>num) {\\n                        num=count;\\n                        min_ind=x+1;\\n                        max_ind=y-1;\\n                    }\\n                }\\n                else {\\n                    break;\\n                }\\n            }\\n        }\\n        string ans=\"\";\\n        for(int i=min_ind; i<=max_ind; i++) {\\n            ans.push_back(s[i]);\\n        }\\n        return ans;\\n    }\\n};\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "devrathod_212",
                        "content": "s =\\n\"aacabdkacaa\"\\n\\nin this testcase expected output is wrong\\nmy code output : aacabacaa\\nexpected: aca.\\n\\nHow?\\ncan anyone solve this ?  "
                    },
                    {
                        "username": "BLANK-Zora",
                        "content": "can someone explain me the case 141 , it just says s = \\nthat\\'s it , its like not even in the constraint , its not even a string , its just ... it"
                    }
                ]
            },
            {
                "id": 2058336,
                "content": [
                    {
                        "username": "dhavalkolapkar",
                        "content": "Variable Sliding window is used when we have to find a subarry or substring with a condition. Find max subarray with distinct chars.\\nNow why is this a DP and not sliding window as we have to find a min substring with palindrome."
                    },
                    {
                        "username": "msn_user",
                        "content": "Refer below for non-DP solution and well-commented code in C++, Java and Python:\\nhttps://www.techiedelight.com/longest-palindromic-substring-non-dp-space-optimized-solution/"
                    },
                    {
                        "username": "JasonDada",
                        "content": "Using dynamic programming algorithm, the memorization table dp[i,j] shows the maximum palindromic substring lengith is 3.  Then the answer is \"aba\". However, leetcode rejects the this answer.  Please help me understand why the accepted answer is \"a\" instead of \"aba\". \\n"
                    },
                    {
                        "username": "hanayashiki",
                        "content": "Input:\\n\"abcdasdfghjkldcba\"\\nOutput:\\n\"abcd\"\\nExpected:\\n\"a\"\\n\\nobviously s[0:4] = \\'abcd\\' while s[-5:-1]=\\'dcba\\' so the answer should be \\'abcd\\'"
                    },
                    {
                        "username": "jt88",
                        "content": "the problem is, you don\\'t know what a palindrome is...\"abcd\" != \"dcba\", if that were the case you would return the whole string and then there would be no point to the exercise"
                    },
                    {
                        "username": "mailo14",
                        "content": "I got Wrong Answer on test:\\nInput:\"abcda\"\\nOutput:\"\"\\nExpected:\"a\"\\nIs \"a\" a palindrom?"
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "Are you for real dude? O(n^3) accepted but O(n^2) giving TLE!\\n\\n1. O(n^3) -> Accepted \\n ```\\nclass Solution {\\n    private static boolean isPalindrome(String s, int start, int end){\\n        while(start<end){\\n            if(s.charAt(start)!=s.charAt(end)) return false;\\n            start++;\\n            end--;\\n        }\\n        return true;\\n    }\\n\\n    public String longestPalindrome(String s) {\\n        int len = s.length();\\n        String ans = \"\";\\n        for(int start=0;start<len;start++){\\n            for(int end=start;end<len;end++){\\n                if(isPalindrome(s,start,end) && ans.length()<end-start+1) ans = s.substring(start,end+1);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\\n// BruteForce Code \\n// Time Complexity : O(len^3)\\n// Space Complexity : O(len)\\n```\\n\\n2. O(n^2) -> TLE\\n```\\nclass Solution {\\n    public String longestPalindrome(String s) {\\n        int len = s.length();\\n        String ans = \"\";\\n        for(int start=0;start<len;start++){\\n            String temp = \"\", temp_ = \"\";\\n            for(int end=start;end<len;end++){\\n                temp_ = temp_ + s.charAt(end);\\n                temp = s.charAt(end) + temp;\\n                if(temp.equals(temp_) && ans.length()<temp.length()) ans = temp;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\\n// Optimal Code \\n// Time Complexity : O(len^2)\\n// Space Complexity : O(len*2)\\n```"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "stop posting solutions"
                    },
                    {
                        "username": "layyy",
                        "content": "A substring from index i to j can be palindrome only if the substring from index i+1 to j-1 is palindrome and characters at index i and j are equal \\ndp[i][j]=1 only if dp[i+1][j-1]==1 and s[i]==s[j]"
                    },
                    {
                        "username": "Vaibhav247",
                        "content": "class Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n        int n = s.size();\\n        int num=0;\\n        if(s.size()==1) {\\n            return s;\\n        }\\n        int min_ind , max_ind;\\n        for(int i=0; i<n; i++ ) {\\n            int x=i;\\n            int y=i;\\n            int count=1;\\n            if(count>num) {\\n                num=count;\\n                min_ind=x;\\n                max_ind=y;\\n            }\\n            x--;\\n            y++;\\n            while(x>=0 && y<n) {\\n                if(s[x]==s[y]) {\\n                    count=count+2;\\n                    x--;\\n                    y++;\\n                    if(count>num) {\\n                        num=count;\\n                        min_ind=x+1;\\n                        max_ind=y-1;\\n                    }\\n                }\\n                else {\\n                    break;\\n                }\\n            }\\n        }\\n        for(int i=0; i<n-1; i++ ) {\\n            int x=i;\\n            int y=i+1;\\n            int count=0;\\n            while(x>=0 && y<n) {\\n                if(s[x]==s[y]) {\\n                    count=count+2;\\n                    x--;\\n                    y++;\\n                    if(count>num) {\\n                        num=count;\\n                        min_ind=x+1;\\n                        max_ind=y-1;\\n                    }\\n                }\\n                else {\\n                    break;\\n                }\\n            }\\n        }\\n        string ans=\"\";\\n        for(int i=min_ind; i<=max_ind; i++) {\\n            ans.push_back(s[i]);\\n        }\\n        return ans;\\n    }\\n};\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "devrathod_212",
                        "content": "s =\\n\"aacabdkacaa\"\\n\\nin this testcase expected output is wrong\\nmy code output : aacabacaa\\nexpected: aca.\\n\\nHow?\\ncan anyone solve this ?  "
                    },
                    {
                        "username": "BLANK-Zora",
                        "content": "can someone explain me the case 141 , it just says s = \\nthat\\'s it , its like not even in the constraint , its not even a string , its just ... it"
                    }
                ]
            },
            {
                "id": 2041347,
                "content": [
                    {
                        "username": "dhavalkolapkar",
                        "content": "Variable Sliding window is used when we have to find a subarry or substring with a condition. Find max subarray with distinct chars.\\nNow why is this a DP and not sliding window as we have to find a min substring with palindrome."
                    },
                    {
                        "username": "msn_user",
                        "content": "Refer below for non-DP solution and well-commented code in C++, Java and Python:\\nhttps://www.techiedelight.com/longest-palindromic-substring-non-dp-space-optimized-solution/"
                    },
                    {
                        "username": "JasonDada",
                        "content": "Using dynamic programming algorithm, the memorization table dp[i,j] shows the maximum palindromic substring lengith is 3.  Then the answer is \"aba\". However, leetcode rejects the this answer.  Please help me understand why the accepted answer is \"a\" instead of \"aba\". \\n"
                    },
                    {
                        "username": "hanayashiki",
                        "content": "Input:\\n\"abcdasdfghjkldcba\"\\nOutput:\\n\"abcd\"\\nExpected:\\n\"a\"\\n\\nobviously s[0:4] = \\'abcd\\' while s[-5:-1]=\\'dcba\\' so the answer should be \\'abcd\\'"
                    },
                    {
                        "username": "jt88",
                        "content": "the problem is, you don\\'t know what a palindrome is...\"abcd\" != \"dcba\", if that were the case you would return the whole string and then there would be no point to the exercise"
                    },
                    {
                        "username": "mailo14",
                        "content": "I got Wrong Answer on test:\\nInput:\"abcda\"\\nOutput:\"\"\\nExpected:\"a\"\\nIs \"a\" a palindrom?"
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "Are you for real dude? O(n^3) accepted but O(n^2) giving TLE!\\n\\n1. O(n^3) -> Accepted \\n ```\\nclass Solution {\\n    private static boolean isPalindrome(String s, int start, int end){\\n        while(start<end){\\n            if(s.charAt(start)!=s.charAt(end)) return false;\\n            start++;\\n            end--;\\n        }\\n        return true;\\n    }\\n\\n    public String longestPalindrome(String s) {\\n        int len = s.length();\\n        String ans = \"\";\\n        for(int start=0;start<len;start++){\\n            for(int end=start;end<len;end++){\\n                if(isPalindrome(s,start,end) && ans.length()<end-start+1) ans = s.substring(start,end+1);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\\n// BruteForce Code \\n// Time Complexity : O(len^3)\\n// Space Complexity : O(len)\\n```\\n\\n2. O(n^2) -> TLE\\n```\\nclass Solution {\\n    public String longestPalindrome(String s) {\\n        int len = s.length();\\n        String ans = \"\";\\n        for(int start=0;start<len;start++){\\n            String temp = \"\", temp_ = \"\";\\n            for(int end=start;end<len;end++){\\n                temp_ = temp_ + s.charAt(end);\\n                temp = s.charAt(end) + temp;\\n                if(temp.equals(temp_) && ans.length()<temp.length()) ans = temp;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\\n// Optimal Code \\n// Time Complexity : O(len^2)\\n// Space Complexity : O(len*2)\\n```"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "stop posting solutions"
                    },
                    {
                        "username": "layyy",
                        "content": "A substring from index i to j can be palindrome only if the substring from index i+1 to j-1 is palindrome and characters at index i and j are equal \\ndp[i][j]=1 only if dp[i+1][j-1]==1 and s[i]==s[j]"
                    },
                    {
                        "username": "Vaibhav247",
                        "content": "class Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n        int n = s.size();\\n        int num=0;\\n        if(s.size()==1) {\\n            return s;\\n        }\\n        int min_ind , max_ind;\\n        for(int i=0; i<n; i++ ) {\\n            int x=i;\\n            int y=i;\\n            int count=1;\\n            if(count>num) {\\n                num=count;\\n                min_ind=x;\\n                max_ind=y;\\n            }\\n            x--;\\n            y++;\\n            while(x>=0 && y<n) {\\n                if(s[x]==s[y]) {\\n                    count=count+2;\\n                    x--;\\n                    y++;\\n                    if(count>num) {\\n                        num=count;\\n                        min_ind=x+1;\\n                        max_ind=y-1;\\n                    }\\n                }\\n                else {\\n                    break;\\n                }\\n            }\\n        }\\n        for(int i=0; i<n-1; i++ ) {\\n            int x=i;\\n            int y=i+1;\\n            int count=0;\\n            while(x>=0 && y<n) {\\n                if(s[x]==s[y]) {\\n                    count=count+2;\\n                    x--;\\n                    y++;\\n                    if(count>num) {\\n                        num=count;\\n                        min_ind=x+1;\\n                        max_ind=y-1;\\n                    }\\n                }\\n                else {\\n                    break;\\n                }\\n            }\\n        }\\n        string ans=\"\";\\n        for(int i=min_ind; i<=max_ind; i++) {\\n            ans.push_back(s[i]);\\n        }\\n        return ans;\\n    }\\n};\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "devrathod_212",
                        "content": "s =\\n\"aacabdkacaa\"\\n\\nin this testcase expected output is wrong\\nmy code output : aacabacaa\\nexpected: aca.\\n\\nHow?\\ncan anyone solve this ?  "
                    },
                    {
                        "username": "BLANK-Zora",
                        "content": "can someone explain me the case 141 , it just says s = \\nthat\\'s it , its like not even in the constraint , its not even a string , its just ... it"
                    }
                ]
            },
            {
                "id": 2019252,
                "content": [
                    {
                        "username": "dhavalkolapkar",
                        "content": "Variable Sliding window is used when we have to find a subarry or substring with a condition. Find max subarray with distinct chars.\\nNow why is this a DP and not sliding window as we have to find a min substring with palindrome."
                    },
                    {
                        "username": "msn_user",
                        "content": "Refer below for non-DP solution and well-commented code in C++, Java and Python:\\nhttps://www.techiedelight.com/longest-palindromic-substring-non-dp-space-optimized-solution/"
                    },
                    {
                        "username": "JasonDada",
                        "content": "Using dynamic programming algorithm, the memorization table dp[i,j] shows the maximum palindromic substring lengith is 3.  Then the answer is \"aba\". However, leetcode rejects the this answer.  Please help me understand why the accepted answer is \"a\" instead of \"aba\". \\n"
                    },
                    {
                        "username": "hanayashiki",
                        "content": "Input:\\n\"abcdasdfghjkldcba\"\\nOutput:\\n\"abcd\"\\nExpected:\\n\"a\"\\n\\nobviously s[0:4] = \\'abcd\\' while s[-5:-1]=\\'dcba\\' so the answer should be \\'abcd\\'"
                    },
                    {
                        "username": "jt88",
                        "content": "the problem is, you don\\'t know what a palindrome is...\"abcd\" != \"dcba\", if that were the case you would return the whole string and then there would be no point to the exercise"
                    },
                    {
                        "username": "mailo14",
                        "content": "I got Wrong Answer on test:\\nInput:\"abcda\"\\nOutput:\"\"\\nExpected:\"a\"\\nIs \"a\" a palindrom?"
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "Are you for real dude? O(n^3) accepted but O(n^2) giving TLE!\\n\\n1. O(n^3) -> Accepted \\n ```\\nclass Solution {\\n    private static boolean isPalindrome(String s, int start, int end){\\n        while(start<end){\\n            if(s.charAt(start)!=s.charAt(end)) return false;\\n            start++;\\n            end--;\\n        }\\n        return true;\\n    }\\n\\n    public String longestPalindrome(String s) {\\n        int len = s.length();\\n        String ans = \"\";\\n        for(int start=0;start<len;start++){\\n            for(int end=start;end<len;end++){\\n                if(isPalindrome(s,start,end) && ans.length()<end-start+1) ans = s.substring(start,end+1);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\\n// BruteForce Code \\n// Time Complexity : O(len^3)\\n// Space Complexity : O(len)\\n```\\n\\n2. O(n^2) -> TLE\\n```\\nclass Solution {\\n    public String longestPalindrome(String s) {\\n        int len = s.length();\\n        String ans = \"\";\\n        for(int start=0;start<len;start++){\\n            String temp = \"\", temp_ = \"\";\\n            for(int end=start;end<len;end++){\\n                temp_ = temp_ + s.charAt(end);\\n                temp = s.charAt(end) + temp;\\n                if(temp.equals(temp_) && ans.length()<temp.length()) ans = temp;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\\n// Optimal Code \\n// Time Complexity : O(len^2)\\n// Space Complexity : O(len*2)\\n```"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "stop posting solutions"
                    },
                    {
                        "username": "layyy",
                        "content": "A substring from index i to j can be palindrome only if the substring from index i+1 to j-1 is palindrome and characters at index i and j are equal \\ndp[i][j]=1 only if dp[i+1][j-1]==1 and s[i]==s[j]"
                    },
                    {
                        "username": "Vaibhav247",
                        "content": "class Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n        int n = s.size();\\n        int num=0;\\n        if(s.size()==1) {\\n            return s;\\n        }\\n        int min_ind , max_ind;\\n        for(int i=0; i<n; i++ ) {\\n            int x=i;\\n            int y=i;\\n            int count=1;\\n            if(count>num) {\\n                num=count;\\n                min_ind=x;\\n                max_ind=y;\\n            }\\n            x--;\\n            y++;\\n            while(x>=0 && y<n) {\\n                if(s[x]==s[y]) {\\n                    count=count+2;\\n                    x--;\\n                    y++;\\n                    if(count>num) {\\n                        num=count;\\n                        min_ind=x+1;\\n                        max_ind=y-1;\\n                    }\\n                }\\n                else {\\n                    break;\\n                }\\n            }\\n        }\\n        for(int i=0; i<n-1; i++ ) {\\n            int x=i;\\n            int y=i+1;\\n            int count=0;\\n            while(x>=0 && y<n) {\\n                if(s[x]==s[y]) {\\n                    count=count+2;\\n                    x--;\\n                    y++;\\n                    if(count>num) {\\n                        num=count;\\n                        min_ind=x+1;\\n                        max_ind=y-1;\\n                    }\\n                }\\n                else {\\n                    break;\\n                }\\n            }\\n        }\\n        string ans=\"\";\\n        for(int i=min_ind; i<=max_ind; i++) {\\n            ans.push_back(s[i]);\\n        }\\n        return ans;\\n    }\\n};\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "devrathod_212",
                        "content": "s =\\n\"aacabdkacaa\"\\n\\nin this testcase expected output is wrong\\nmy code output : aacabacaa\\nexpected: aca.\\n\\nHow?\\ncan anyone solve this ?  "
                    },
                    {
                        "username": "BLANK-Zora",
                        "content": "can someone explain me the case 141 , it just says s = \\nthat\\'s it , its like not even in the constraint , its not even a string , its just ... it"
                    }
                ]
            },
            {
                "id": 2016852,
                "content": [
                    {
                        "username": "dhavalkolapkar",
                        "content": "Variable Sliding window is used when we have to find a subarry or substring with a condition. Find max subarray with distinct chars.\\nNow why is this a DP and not sliding window as we have to find a min substring with palindrome."
                    },
                    {
                        "username": "msn_user",
                        "content": "Refer below for non-DP solution and well-commented code in C++, Java and Python:\\nhttps://www.techiedelight.com/longest-palindromic-substring-non-dp-space-optimized-solution/"
                    },
                    {
                        "username": "JasonDada",
                        "content": "Using dynamic programming algorithm, the memorization table dp[i,j] shows the maximum palindromic substring lengith is 3.  Then the answer is \"aba\". However, leetcode rejects the this answer.  Please help me understand why the accepted answer is \"a\" instead of \"aba\". \\n"
                    },
                    {
                        "username": "hanayashiki",
                        "content": "Input:\\n\"abcdasdfghjkldcba\"\\nOutput:\\n\"abcd\"\\nExpected:\\n\"a\"\\n\\nobviously s[0:4] = \\'abcd\\' while s[-5:-1]=\\'dcba\\' so the answer should be \\'abcd\\'"
                    },
                    {
                        "username": "jt88",
                        "content": "the problem is, you don\\'t know what a palindrome is...\"abcd\" != \"dcba\", if that were the case you would return the whole string and then there would be no point to the exercise"
                    },
                    {
                        "username": "mailo14",
                        "content": "I got Wrong Answer on test:\\nInput:\"abcda\"\\nOutput:\"\"\\nExpected:\"a\"\\nIs \"a\" a palindrom?"
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "Are you for real dude? O(n^3) accepted but O(n^2) giving TLE!\\n\\n1. O(n^3) -> Accepted \\n ```\\nclass Solution {\\n    private static boolean isPalindrome(String s, int start, int end){\\n        while(start<end){\\n            if(s.charAt(start)!=s.charAt(end)) return false;\\n            start++;\\n            end--;\\n        }\\n        return true;\\n    }\\n\\n    public String longestPalindrome(String s) {\\n        int len = s.length();\\n        String ans = \"\";\\n        for(int start=0;start<len;start++){\\n            for(int end=start;end<len;end++){\\n                if(isPalindrome(s,start,end) && ans.length()<end-start+1) ans = s.substring(start,end+1);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\\n// BruteForce Code \\n// Time Complexity : O(len^3)\\n// Space Complexity : O(len)\\n```\\n\\n2. O(n^2) -> TLE\\n```\\nclass Solution {\\n    public String longestPalindrome(String s) {\\n        int len = s.length();\\n        String ans = \"\";\\n        for(int start=0;start<len;start++){\\n            String temp = \"\", temp_ = \"\";\\n            for(int end=start;end<len;end++){\\n                temp_ = temp_ + s.charAt(end);\\n                temp = s.charAt(end) + temp;\\n                if(temp.equals(temp_) && ans.length()<temp.length()) ans = temp;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\\n// Optimal Code \\n// Time Complexity : O(len^2)\\n// Space Complexity : O(len*2)\\n```"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "stop posting solutions"
                    },
                    {
                        "username": "layyy",
                        "content": "A substring from index i to j can be palindrome only if the substring from index i+1 to j-1 is palindrome and characters at index i and j are equal \\ndp[i][j]=1 only if dp[i+1][j-1]==1 and s[i]==s[j]"
                    },
                    {
                        "username": "Vaibhav247",
                        "content": "class Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n        int n = s.size();\\n        int num=0;\\n        if(s.size()==1) {\\n            return s;\\n        }\\n        int min_ind , max_ind;\\n        for(int i=0; i<n; i++ ) {\\n            int x=i;\\n            int y=i;\\n            int count=1;\\n            if(count>num) {\\n                num=count;\\n                min_ind=x;\\n                max_ind=y;\\n            }\\n            x--;\\n            y++;\\n            while(x>=0 && y<n) {\\n                if(s[x]==s[y]) {\\n                    count=count+2;\\n                    x--;\\n                    y++;\\n                    if(count>num) {\\n                        num=count;\\n                        min_ind=x+1;\\n                        max_ind=y-1;\\n                    }\\n                }\\n                else {\\n                    break;\\n                }\\n            }\\n        }\\n        for(int i=0; i<n-1; i++ ) {\\n            int x=i;\\n            int y=i+1;\\n            int count=0;\\n            while(x>=0 && y<n) {\\n                if(s[x]==s[y]) {\\n                    count=count+2;\\n                    x--;\\n                    y++;\\n                    if(count>num) {\\n                        num=count;\\n                        min_ind=x+1;\\n                        max_ind=y-1;\\n                    }\\n                }\\n                else {\\n                    break;\\n                }\\n            }\\n        }\\n        string ans=\"\";\\n        for(int i=min_ind; i<=max_ind; i++) {\\n            ans.push_back(s[i]);\\n        }\\n        return ans;\\n    }\\n};\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "devrathod_212",
                        "content": "s =\\n\"aacabdkacaa\"\\n\\nin this testcase expected output is wrong\\nmy code output : aacabacaa\\nexpected: aca.\\n\\nHow?\\ncan anyone solve this ?  "
                    },
                    {
                        "username": "BLANK-Zora",
                        "content": "can someone explain me the case 141 , it just says s = \\nthat\\'s it , its like not even in the constraint , its not even a string , its just ... it"
                    }
                ]
            },
            {
                "id": 2010967,
                "content": [
                    {
                        "username": "dhavalkolapkar",
                        "content": "Variable Sliding window is used when we have to find a subarry or substring with a condition. Find max subarray with distinct chars.\\nNow why is this a DP and not sliding window as we have to find a min substring with palindrome."
                    },
                    {
                        "username": "msn_user",
                        "content": "Refer below for non-DP solution and well-commented code in C++, Java and Python:\\nhttps://www.techiedelight.com/longest-palindromic-substring-non-dp-space-optimized-solution/"
                    },
                    {
                        "username": "JasonDada",
                        "content": "Using dynamic programming algorithm, the memorization table dp[i,j] shows the maximum palindromic substring lengith is 3.  Then the answer is \"aba\". However, leetcode rejects the this answer.  Please help me understand why the accepted answer is \"a\" instead of \"aba\". \\n"
                    },
                    {
                        "username": "hanayashiki",
                        "content": "Input:\\n\"abcdasdfghjkldcba\"\\nOutput:\\n\"abcd\"\\nExpected:\\n\"a\"\\n\\nobviously s[0:4] = \\'abcd\\' while s[-5:-1]=\\'dcba\\' so the answer should be \\'abcd\\'"
                    },
                    {
                        "username": "jt88",
                        "content": "the problem is, you don\\'t know what a palindrome is...\"abcd\" != \"dcba\", if that were the case you would return the whole string and then there would be no point to the exercise"
                    },
                    {
                        "username": "mailo14",
                        "content": "I got Wrong Answer on test:\\nInput:\"abcda\"\\nOutput:\"\"\\nExpected:\"a\"\\nIs \"a\" a palindrom?"
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "Are you for real dude? O(n^3) accepted but O(n^2) giving TLE!\\n\\n1. O(n^3) -> Accepted \\n ```\\nclass Solution {\\n    private static boolean isPalindrome(String s, int start, int end){\\n        while(start<end){\\n            if(s.charAt(start)!=s.charAt(end)) return false;\\n            start++;\\n            end--;\\n        }\\n        return true;\\n    }\\n\\n    public String longestPalindrome(String s) {\\n        int len = s.length();\\n        String ans = \"\";\\n        for(int start=0;start<len;start++){\\n            for(int end=start;end<len;end++){\\n                if(isPalindrome(s,start,end) && ans.length()<end-start+1) ans = s.substring(start,end+1);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\\n// BruteForce Code \\n// Time Complexity : O(len^3)\\n// Space Complexity : O(len)\\n```\\n\\n2. O(n^2) -> TLE\\n```\\nclass Solution {\\n    public String longestPalindrome(String s) {\\n        int len = s.length();\\n        String ans = \"\";\\n        for(int start=0;start<len;start++){\\n            String temp = \"\", temp_ = \"\";\\n            for(int end=start;end<len;end++){\\n                temp_ = temp_ + s.charAt(end);\\n                temp = s.charAt(end) + temp;\\n                if(temp.equals(temp_) && ans.length()<temp.length()) ans = temp;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\\n// Optimal Code \\n// Time Complexity : O(len^2)\\n// Space Complexity : O(len*2)\\n```"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "stop posting solutions"
                    },
                    {
                        "username": "layyy",
                        "content": "A substring from index i to j can be palindrome only if the substring from index i+1 to j-1 is palindrome and characters at index i and j are equal \\ndp[i][j]=1 only if dp[i+1][j-1]==1 and s[i]==s[j]"
                    },
                    {
                        "username": "Vaibhav247",
                        "content": "class Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n        int n = s.size();\\n        int num=0;\\n        if(s.size()==1) {\\n            return s;\\n        }\\n        int min_ind , max_ind;\\n        for(int i=0; i<n; i++ ) {\\n            int x=i;\\n            int y=i;\\n            int count=1;\\n            if(count>num) {\\n                num=count;\\n                min_ind=x;\\n                max_ind=y;\\n            }\\n            x--;\\n            y++;\\n            while(x>=0 && y<n) {\\n                if(s[x]==s[y]) {\\n                    count=count+2;\\n                    x--;\\n                    y++;\\n                    if(count>num) {\\n                        num=count;\\n                        min_ind=x+1;\\n                        max_ind=y-1;\\n                    }\\n                }\\n                else {\\n                    break;\\n                }\\n            }\\n        }\\n        for(int i=0; i<n-1; i++ ) {\\n            int x=i;\\n            int y=i+1;\\n            int count=0;\\n            while(x>=0 && y<n) {\\n                if(s[x]==s[y]) {\\n                    count=count+2;\\n                    x--;\\n                    y++;\\n                    if(count>num) {\\n                        num=count;\\n                        min_ind=x+1;\\n                        max_ind=y-1;\\n                    }\\n                }\\n                else {\\n                    break;\\n                }\\n            }\\n        }\\n        string ans=\"\";\\n        for(int i=min_ind; i<=max_ind; i++) {\\n            ans.push_back(s[i]);\\n        }\\n        return ans;\\n    }\\n};\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "devrathod_212",
                        "content": "s =\\n\"aacabdkacaa\"\\n\\nin this testcase expected output is wrong\\nmy code output : aacabacaa\\nexpected: aca.\\n\\nHow?\\ncan anyone solve this ?  "
                    },
                    {
                        "username": "BLANK-Zora",
                        "content": "can someone explain me the case 141 , it just says s = \\nthat\\'s it , its like not even in the constraint , its not even a string , its just ... it"
                    }
                ]
            },
            {
                "id": 2007280,
                "content": [
                    {
                        "username": "aylahjomri",
                        "content": "why does it say 141/141 testcases passed but says Time Limit Exceeded and the last executed input is empty ?"
                    },
                    {
                        "username": "CvamReborn_C2R",
                        "content": "Wrong Question some test cases are not right"
                    },
                    {
                        "username": "ak_3101",
                        "content": "okay so is it absolutely normal to get an intuition of writing code in tabular form or everybody first write recursion, and then top down/ bottom up"
                    },
                    {
                        "username": "jfonseca32",
                        "content": "There is something wrong with this question. I made and ran the code in Python and for every test case LeetCode says the code failed on, it works when I run it in Python."
                    },
                    {
                        "username": "timewaster69",
                        "content": "I think the test case s= (nothing) should be removed. It only causes errors and the constraints specifically state that there's at least one character to work with, and that there's specifically alphanumericals to deal with."
                    },
                    {
                        "username": "kevinbiju",
                        "content": "how do we learn to optimize brute force approach\\n"
                    },
                    {
                        "username": "espinosarennieljun",
                        "content": "To solve this you only need to mind two things. \none, Palindrome can't have with more than one even number of character duplicate.\ntwo, all single character should be ignore you only need to add one single character if the result total number is odd. example the total none single character of string is 6 and you can place single character on the middle of the string so it become 7."
                    },
                    {
                        "username": "muraripavansai22",
                        "content": "\"aacabdkacaa\"\\n\\nThis is my output : \"aacakacaa\"\\ngiven this should be expected : \"aca\"\\n\\nThere is some error with this test case\\ncorrect me if im wrong."
                    },
                    {
                        "username": "Ab__23",
                        "content": "\"aacakacaa\" is a subsequence of input string not it's substring, as the question is to find substring that's where you are getting wrong.\nFor example : let string = \"abcdef\"\nit's substrings: 'a' 'ab' 'abc' 'cde' 'abcde' ...\nit's subsequences : 'a' 'ab' 'ac' 'acf' 'abe' ..."
                    },
                    {
                        "username": "TheMystery28",
                        "content": "I've tried and failed enough times to allow myself to see the hints and come up with an optimal solution.\n\nHowever, I'd like to understand why my old code gives a \"time exceeded\" error for \"aacabdkacaa\" when I have made sure to skip the calculation that can be skipped to avoid wasting time.\n\nCould someone please enlighten me?\n\n ```\n#include <algorithm>\n#include <iostream>\n#include <string>\n#include <string_view>\n#include <unordered_map>\n#include <set>\n#include <functional>\n#include <list>\n#include <iterator>\n#include <memory>\n\n\nclass Solution {\n\n    private:\n\n        std::unordered_map<char, std::set<int>> vOfList{};\n\n        int numberOfDifferentLetters{0};\n        int numberOfDifferentLettersBeingMoreThanOne{0};\n        std::vector<char> allOfTheDifferentLetters{};\n\n    public:\n        void itLoop2(std::set<int>::iterator& auto_pLeftItPos,\n                     std::set<int>::iterator& auto_pRightItPos,\n                     int pLeft, int pRight,\n                     std::string& palindromic, const std::string_view& s,\n                     bool trueToStopTheSpetialLoopToLoop){\n                        \n                    if (abs(*auto_pLeftItPos-*auto_pRightItPos)+1<=palindromic.length()) return;\n                    if(s[pLeft] == s[pRight]){\n\n                        if (pLeft==pRight||abs(pLeft - pRight)==1){\n                            palindromic=s.substr(*auto_pLeftItPos,abs(*auto_pLeftItPos-*auto_pRightItPos)+1);\n                        }\n                        else{\n\n\n                        itLoop2(auto_pLeftItPos, auto_pRightItPos,\n                                pLeft+1, pRight-1,palindromic, \n                                s,trueToStopTheSpetialLoopToLoop);}\n                    }\n                    else if (trueToStopTheSpetialLoopToLoop==false){\n                        trueToStopTheSpetialLoopToLoop = true;\n                    \n                        int x{std::abs(static_cast<int>(std::distance(auto_pLeftItPos,auto_pRightItPos)))};\n\n\n                        int c{0};\n\n                        for (int n{x};n>0;--n){\n                            //remainder that auto_pLeftItPos/auto_pRightItPos are in reverse for their iterator\n\n                            if (n==x) {++c;continue;} //If not we wouldn't be here in the first place\n\n\n\n                            int z{n};\n\n                            auto auto_pLeftItPosEdit{std::prev(auto_pLeftItPos,c)};\n\n                            itLoop2(auto_pLeftItPosEdit, auto_pRightItPos,\n                                *auto_pLeftItPosEdit, pRight,\n                                palindromic, \n                                s,trueToStopTheSpetialLoopToLoop);\n\n                            auto auto_pRightItPosEdit{auto_pRightItPos};\n\n                            while(auto_pLeftItPosEdit!=auto_pLeftItPos){\n                                \n                                auto_pLeftItPosEdit = std::next(auto_pLeftItPosEdit,1);\n                                auto_pRightItPosEdit = std::next(auto_pRightItPosEdit, 1);\n\n                                if (abs(*auto_pLeftItPos-*auto_pRightItPos)+1<=palindromic.length()) continue;\n\n                                itLoop2(auto_pLeftItPosEdit, auto_pRightItPosEdit,\n                                *auto_pLeftItPosEdit, *auto_pRightItPosEdit,\n                                palindromic, \n                                s,trueToStopTheSpetialLoopToLoop);\n\n                            }\n\n                            ++c;\n                        }\n\n                    }\n                    else return;\n\n        }\n\n        void itLoop(std::unordered_map<char, std::set<int>>::iterator& itBegin,\n                    std::string& palindromic, const std::string_view& s){\n                    \n\n                bool trueToStopTheSpetialLoopToLoop{false};\n\n            \n                auto *ptr {&((itBegin->second))};\n             \n                std::set<int>::iterator setEnd {ptr->begin()};\n\n\n                std::set<int>::iterator setBegin {ptr->end()};\n\n                std::advance(setBegin, -1);\n                //end() give the iterator AFTER the last element of the container\n\n            int pLeft{*setEnd};\n\n            int pRight{*setBegin};\n\n            if (abs(pLeft-pRight)+1<=palindromic.length()) return;\n\n\n            itLoop2(setEnd, setBegin, pLeft, pRight, palindromic, s, trueToStopTheSpetialLoopToLoop);\n\n\n        }\n\n        std::string longestPalindrome(const std::string_view& s) {\n\n            if (s.length()==0){\n                return \"\";\n            }\n            \n            std::vector<bool> everythingUsed (s.length(), false);\n\n            auto finised{[&]() -> bool {return (std::all_of(everythingUsed.begin(), everythingUsed.end(), [&](bool v) { return v; }));}};\n                \n            for (int x{0}; x<s.length()&&!finised();++x){\n\n\n                        if (everythingUsed[x]==false){\n                            everythingUsed[x]=true;\n\n                            ++numberOfDifferentLetters;\n                            allOfTheDifferentLetters.push_back(s[x]);\n\n\n                            for (int y{x+1};y<s.length()&&!finised();++y){\n                                if (everythingUsed[y]==true) continue;\n\n                                else {\n                                    if (s[x]==s[y]){\n                                        everythingUsed[y]=true;\n                                        vOfList[s[x]].insert({x,y});\n                                        ++numberOfDifferentLettersBeingMoreThanOne;\n                                    }\n                                }\n                            }\n                        }\n                        else continue;\n                    }\n\n            if (numberOfDifferentLettersBeingMoreThanOne==0) {\n                std::string str_ch {s[0]};\n                return str_ch;\n            };\n\n            std::unordered_map<char, std::set<int>>::iterator itBegin {vOfList.begin()};\n        \n\n            \n            std::string palindromic{};\n\n            while(itBegin != vOfList.end()){\n            \n                itLoop(itBegin, palindromic, s );\n                ++itBegin;\n            \n                }\n            \n            return palindromic;\n    \n    }\n};\n```\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "shri1403",
                        "content": "hi i was trying to solve this using the concepts of longest common substring and longest palindromic substring,\nhowver it doesnt work for the cases like aadabcadaa. this gives adaa as the ans and not ada. please help me with this\nthe following is my code:\n  string lcsub(string s , string s2){\n        int n=s.size();\n        int m=s2.size();\n         \n         vector<vector<int>> dp(n+1,vector<int>(m+1,0));\n         for(int i=0 ; i<=n;i++){\n             dp[i][0]=0;\n         }\n         for(int j=0; j<=m; j++){\n             dp[0][j]=0;\n         }\n        int maxi=0; int row=0; int col=0;\n         for(int i=1;i<=n;i++){\n             for(int j=1; j<=m ;j++){\n                 if(s[i-1]==s2[j-1]){\n                     dp[i][j]=1+dp[i-1][j-1];\n                     if(dp[i][j]>maxi){\n                         maxi=dp[i][j];\n                         row=i;\n                         col=j;\n                     }\n\n                    } \n                else\n                dp[i][j]=0; // if the continuity is broken then there is no LCS'\n                    \n             }\n         }\n\n        \n         //maxi is the length of the longest commmon palindromic substring\n         \n         //we also have the row and col at which maxi element is found;\n         string ans=\"\";\n         int len=maxi;\n\n\n         while((row>0&&col>0) && len>0){ //added this condition of len>0 beacsyein the second test case bbc print horha tha and this was because humara len=2 ka lcsubstring h par abhi tak row ya col 0 nhi hua tha toh islioye c bhi append hogya\n         //toh matlab yeh h ki jaha tak len h utna hi string me daalo\n               ans+=s[row-1];\n               row--;\n               col--;\n               len--;\n\n         }\n       cout<<maxi;\n        \n         return ans;\n\n\n    }\n    string longestPalindrome(string s) {\n        string s2=s;\n        reverse(s.begin(),s.end());\n        return lcsub(s2,s);\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 2005284,
                "content": [
                    {
                        "username": "aylahjomri",
                        "content": "why does it say 141/141 testcases passed but says Time Limit Exceeded and the last executed input is empty ?"
                    },
                    {
                        "username": "CvamReborn_C2R",
                        "content": "Wrong Question some test cases are not right"
                    },
                    {
                        "username": "ak_3101",
                        "content": "okay so is it absolutely normal to get an intuition of writing code in tabular form or everybody first write recursion, and then top down/ bottom up"
                    },
                    {
                        "username": "jfonseca32",
                        "content": "There is something wrong with this question. I made and ran the code in Python and for every test case LeetCode says the code failed on, it works when I run it in Python."
                    },
                    {
                        "username": "timewaster69",
                        "content": "I think the test case s= (nothing) should be removed. It only causes errors and the constraints specifically state that there's at least one character to work with, and that there's specifically alphanumericals to deal with."
                    },
                    {
                        "username": "kevinbiju",
                        "content": "how do we learn to optimize brute force approach\\n"
                    },
                    {
                        "username": "espinosarennieljun",
                        "content": "To solve this you only need to mind two things. \none, Palindrome can't have with more than one even number of character duplicate.\ntwo, all single character should be ignore you only need to add one single character if the result total number is odd. example the total none single character of string is 6 and you can place single character on the middle of the string so it become 7."
                    },
                    {
                        "username": "muraripavansai22",
                        "content": "\"aacabdkacaa\"\\n\\nThis is my output : \"aacakacaa\"\\ngiven this should be expected : \"aca\"\\n\\nThere is some error with this test case\\ncorrect me if im wrong."
                    },
                    {
                        "username": "Ab__23",
                        "content": "\"aacakacaa\" is a subsequence of input string not it's substring, as the question is to find substring that's where you are getting wrong.\nFor example : let string = \"abcdef\"\nit's substrings: 'a' 'ab' 'abc' 'cde' 'abcde' ...\nit's subsequences : 'a' 'ab' 'ac' 'acf' 'abe' ..."
                    },
                    {
                        "username": "TheMystery28",
                        "content": "I've tried and failed enough times to allow myself to see the hints and come up with an optimal solution.\n\nHowever, I'd like to understand why my old code gives a \"time exceeded\" error for \"aacabdkacaa\" when I have made sure to skip the calculation that can be skipped to avoid wasting time.\n\nCould someone please enlighten me?\n\n ```\n#include <algorithm>\n#include <iostream>\n#include <string>\n#include <string_view>\n#include <unordered_map>\n#include <set>\n#include <functional>\n#include <list>\n#include <iterator>\n#include <memory>\n\n\nclass Solution {\n\n    private:\n\n        std::unordered_map<char, std::set<int>> vOfList{};\n\n        int numberOfDifferentLetters{0};\n        int numberOfDifferentLettersBeingMoreThanOne{0};\n        std::vector<char> allOfTheDifferentLetters{};\n\n    public:\n        void itLoop2(std::set<int>::iterator& auto_pLeftItPos,\n                     std::set<int>::iterator& auto_pRightItPos,\n                     int pLeft, int pRight,\n                     std::string& palindromic, const std::string_view& s,\n                     bool trueToStopTheSpetialLoopToLoop){\n                        \n                    if (abs(*auto_pLeftItPos-*auto_pRightItPos)+1<=palindromic.length()) return;\n                    if(s[pLeft] == s[pRight]){\n\n                        if (pLeft==pRight||abs(pLeft - pRight)==1){\n                            palindromic=s.substr(*auto_pLeftItPos,abs(*auto_pLeftItPos-*auto_pRightItPos)+1);\n                        }\n                        else{\n\n\n                        itLoop2(auto_pLeftItPos, auto_pRightItPos,\n                                pLeft+1, pRight-1,palindromic, \n                                s,trueToStopTheSpetialLoopToLoop);}\n                    }\n                    else if (trueToStopTheSpetialLoopToLoop==false){\n                        trueToStopTheSpetialLoopToLoop = true;\n                    \n                        int x{std::abs(static_cast<int>(std::distance(auto_pLeftItPos,auto_pRightItPos)))};\n\n\n                        int c{0};\n\n                        for (int n{x};n>0;--n){\n                            //remainder that auto_pLeftItPos/auto_pRightItPos are in reverse for their iterator\n\n                            if (n==x) {++c;continue;} //If not we wouldn't be here in the first place\n\n\n\n                            int z{n};\n\n                            auto auto_pLeftItPosEdit{std::prev(auto_pLeftItPos,c)};\n\n                            itLoop2(auto_pLeftItPosEdit, auto_pRightItPos,\n                                *auto_pLeftItPosEdit, pRight,\n                                palindromic, \n                                s,trueToStopTheSpetialLoopToLoop);\n\n                            auto auto_pRightItPosEdit{auto_pRightItPos};\n\n                            while(auto_pLeftItPosEdit!=auto_pLeftItPos){\n                                \n                                auto_pLeftItPosEdit = std::next(auto_pLeftItPosEdit,1);\n                                auto_pRightItPosEdit = std::next(auto_pRightItPosEdit, 1);\n\n                                if (abs(*auto_pLeftItPos-*auto_pRightItPos)+1<=palindromic.length()) continue;\n\n                                itLoop2(auto_pLeftItPosEdit, auto_pRightItPosEdit,\n                                *auto_pLeftItPosEdit, *auto_pRightItPosEdit,\n                                palindromic, \n                                s,trueToStopTheSpetialLoopToLoop);\n\n                            }\n\n                            ++c;\n                        }\n\n                    }\n                    else return;\n\n        }\n\n        void itLoop(std::unordered_map<char, std::set<int>>::iterator& itBegin,\n                    std::string& palindromic, const std::string_view& s){\n                    \n\n                bool trueToStopTheSpetialLoopToLoop{false};\n\n            \n                auto *ptr {&((itBegin->second))};\n             \n                std::set<int>::iterator setEnd {ptr->begin()};\n\n\n                std::set<int>::iterator setBegin {ptr->end()};\n\n                std::advance(setBegin, -1);\n                //end() give the iterator AFTER the last element of the container\n\n            int pLeft{*setEnd};\n\n            int pRight{*setBegin};\n\n            if (abs(pLeft-pRight)+1<=palindromic.length()) return;\n\n\n            itLoop2(setEnd, setBegin, pLeft, pRight, palindromic, s, trueToStopTheSpetialLoopToLoop);\n\n\n        }\n\n        std::string longestPalindrome(const std::string_view& s) {\n\n            if (s.length()==0){\n                return \"\";\n            }\n            \n            std::vector<bool> everythingUsed (s.length(), false);\n\n            auto finised{[&]() -> bool {return (std::all_of(everythingUsed.begin(), everythingUsed.end(), [&](bool v) { return v; }));}};\n                \n            for (int x{0}; x<s.length()&&!finised();++x){\n\n\n                        if (everythingUsed[x]==false){\n                            everythingUsed[x]=true;\n\n                            ++numberOfDifferentLetters;\n                            allOfTheDifferentLetters.push_back(s[x]);\n\n\n                            for (int y{x+1};y<s.length()&&!finised();++y){\n                                if (everythingUsed[y]==true) continue;\n\n                                else {\n                                    if (s[x]==s[y]){\n                                        everythingUsed[y]=true;\n                                        vOfList[s[x]].insert({x,y});\n                                        ++numberOfDifferentLettersBeingMoreThanOne;\n                                    }\n                                }\n                            }\n                        }\n                        else continue;\n                    }\n\n            if (numberOfDifferentLettersBeingMoreThanOne==0) {\n                std::string str_ch {s[0]};\n                return str_ch;\n            };\n\n            std::unordered_map<char, std::set<int>>::iterator itBegin {vOfList.begin()};\n        \n\n            \n            std::string palindromic{};\n\n            while(itBegin != vOfList.end()){\n            \n                itLoop(itBegin, palindromic, s );\n                ++itBegin;\n            \n                }\n            \n            return palindromic;\n    \n    }\n};\n```\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "shri1403",
                        "content": "hi i was trying to solve this using the concepts of longest common substring and longest palindromic substring,\nhowver it doesnt work for the cases like aadabcadaa. this gives adaa as the ans and not ada. please help me with this\nthe following is my code:\n  string lcsub(string s , string s2){\n        int n=s.size();\n        int m=s2.size();\n         \n         vector<vector<int>> dp(n+1,vector<int>(m+1,0));\n         for(int i=0 ; i<=n;i++){\n             dp[i][0]=0;\n         }\n         for(int j=0; j<=m; j++){\n             dp[0][j]=0;\n         }\n        int maxi=0; int row=0; int col=0;\n         for(int i=1;i<=n;i++){\n             for(int j=1; j<=m ;j++){\n                 if(s[i-1]==s2[j-1]){\n                     dp[i][j]=1+dp[i-1][j-1];\n                     if(dp[i][j]>maxi){\n                         maxi=dp[i][j];\n                         row=i;\n                         col=j;\n                     }\n\n                    } \n                else\n                dp[i][j]=0; // if the continuity is broken then there is no LCS'\n                    \n             }\n         }\n\n        \n         //maxi is the length of the longest commmon palindromic substring\n         \n         //we also have the row and col at which maxi element is found;\n         string ans=\"\";\n         int len=maxi;\n\n\n         while((row>0&&col>0) && len>0){ //added this condition of len>0 beacsyein the second test case bbc print horha tha and this was because humara len=2 ka lcsubstring h par abhi tak row ya col 0 nhi hua tha toh islioye c bhi append hogya\n         //toh matlab yeh h ki jaha tak len h utna hi string me daalo\n               ans+=s[row-1];\n               row--;\n               col--;\n               len--;\n\n         }\n       cout<<maxi;\n        \n         return ans;\n\n\n    }\n    string longestPalindrome(string s) {\n        string s2=s;\n        reverse(s.begin(),s.end());\n        return lcsub(s2,s);\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 2001061,
                "content": [
                    {
                        "username": "aylahjomri",
                        "content": "why does it say 141/141 testcases passed but says Time Limit Exceeded and the last executed input is empty ?"
                    },
                    {
                        "username": "CvamReborn_C2R",
                        "content": "Wrong Question some test cases are not right"
                    },
                    {
                        "username": "ak_3101",
                        "content": "okay so is it absolutely normal to get an intuition of writing code in tabular form or everybody first write recursion, and then top down/ bottom up"
                    },
                    {
                        "username": "jfonseca32",
                        "content": "There is something wrong with this question. I made and ran the code in Python and for every test case LeetCode says the code failed on, it works when I run it in Python."
                    },
                    {
                        "username": "timewaster69",
                        "content": "I think the test case s= (nothing) should be removed. It only causes errors and the constraints specifically state that there's at least one character to work with, and that there's specifically alphanumericals to deal with."
                    },
                    {
                        "username": "kevinbiju",
                        "content": "how do we learn to optimize brute force approach\\n"
                    },
                    {
                        "username": "espinosarennieljun",
                        "content": "To solve this you only need to mind two things. \none, Palindrome can't have with more than one even number of character duplicate.\ntwo, all single character should be ignore you only need to add one single character if the result total number is odd. example the total none single character of string is 6 and you can place single character on the middle of the string so it become 7."
                    },
                    {
                        "username": "muraripavansai22",
                        "content": "\"aacabdkacaa\"\\n\\nThis is my output : \"aacakacaa\"\\ngiven this should be expected : \"aca\"\\n\\nThere is some error with this test case\\ncorrect me if im wrong."
                    },
                    {
                        "username": "Ab__23",
                        "content": "\"aacakacaa\" is a subsequence of input string not it's substring, as the question is to find substring that's where you are getting wrong.\nFor example : let string = \"abcdef\"\nit's substrings: 'a' 'ab' 'abc' 'cde' 'abcde' ...\nit's subsequences : 'a' 'ab' 'ac' 'acf' 'abe' ..."
                    },
                    {
                        "username": "TheMystery28",
                        "content": "I've tried and failed enough times to allow myself to see the hints and come up with an optimal solution.\n\nHowever, I'd like to understand why my old code gives a \"time exceeded\" error for \"aacabdkacaa\" when I have made sure to skip the calculation that can be skipped to avoid wasting time.\n\nCould someone please enlighten me?\n\n ```\n#include <algorithm>\n#include <iostream>\n#include <string>\n#include <string_view>\n#include <unordered_map>\n#include <set>\n#include <functional>\n#include <list>\n#include <iterator>\n#include <memory>\n\n\nclass Solution {\n\n    private:\n\n        std::unordered_map<char, std::set<int>> vOfList{};\n\n        int numberOfDifferentLetters{0};\n        int numberOfDifferentLettersBeingMoreThanOne{0};\n        std::vector<char> allOfTheDifferentLetters{};\n\n    public:\n        void itLoop2(std::set<int>::iterator& auto_pLeftItPos,\n                     std::set<int>::iterator& auto_pRightItPos,\n                     int pLeft, int pRight,\n                     std::string& palindromic, const std::string_view& s,\n                     bool trueToStopTheSpetialLoopToLoop){\n                        \n                    if (abs(*auto_pLeftItPos-*auto_pRightItPos)+1<=palindromic.length()) return;\n                    if(s[pLeft] == s[pRight]){\n\n                        if (pLeft==pRight||abs(pLeft - pRight)==1){\n                            palindromic=s.substr(*auto_pLeftItPos,abs(*auto_pLeftItPos-*auto_pRightItPos)+1);\n                        }\n                        else{\n\n\n                        itLoop2(auto_pLeftItPos, auto_pRightItPos,\n                                pLeft+1, pRight-1,palindromic, \n                                s,trueToStopTheSpetialLoopToLoop);}\n                    }\n                    else if (trueToStopTheSpetialLoopToLoop==false){\n                        trueToStopTheSpetialLoopToLoop = true;\n                    \n                        int x{std::abs(static_cast<int>(std::distance(auto_pLeftItPos,auto_pRightItPos)))};\n\n\n                        int c{0};\n\n                        for (int n{x};n>0;--n){\n                            //remainder that auto_pLeftItPos/auto_pRightItPos are in reverse for their iterator\n\n                            if (n==x) {++c;continue;} //If not we wouldn't be here in the first place\n\n\n\n                            int z{n};\n\n                            auto auto_pLeftItPosEdit{std::prev(auto_pLeftItPos,c)};\n\n                            itLoop2(auto_pLeftItPosEdit, auto_pRightItPos,\n                                *auto_pLeftItPosEdit, pRight,\n                                palindromic, \n                                s,trueToStopTheSpetialLoopToLoop);\n\n                            auto auto_pRightItPosEdit{auto_pRightItPos};\n\n                            while(auto_pLeftItPosEdit!=auto_pLeftItPos){\n                                \n                                auto_pLeftItPosEdit = std::next(auto_pLeftItPosEdit,1);\n                                auto_pRightItPosEdit = std::next(auto_pRightItPosEdit, 1);\n\n                                if (abs(*auto_pLeftItPos-*auto_pRightItPos)+1<=palindromic.length()) continue;\n\n                                itLoop2(auto_pLeftItPosEdit, auto_pRightItPosEdit,\n                                *auto_pLeftItPosEdit, *auto_pRightItPosEdit,\n                                palindromic, \n                                s,trueToStopTheSpetialLoopToLoop);\n\n                            }\n\n                            ++c;\n                        }\n\n                    }\n                    else return;\n\n        }\n\n        void itLoop(std::unordered_map<char, std::set<int>>::iterator& itBegin,\n                    std::string& palindromic, const std::string_view& s){\n                    \n\n                bool trueToStopTheSpetialLoopToLoop{false};\n\n            \n                auto *ptr {&((itBegin->second))};\n             \n                std::set<int>::iterator setEnd {ptr->begin()};\n\n\n                std::set<int>::iterator setBegin {ptr->end()};\n\n                std::advance(setBegin, -1);\n                //end() give the iterator AFTER the last element of the container\n\n            int pLeft{*setEnd};\n\n            int pRight{*setBegin};\n\n            if (abs(pLeft-pRight)+1<=palindromic.length()) return;\n\n\n            itLoop2(setEnd, setBegin, pLeft, pRight, palindromic, s, trueToStopTheSpetialLoopToLoop);\n\n\n        }\n\n        std::string longestPalindrome(const std::string_view& s) {\n\n            if (s.length()==0){\n                return \"\";\n            }\n            \n            std::vector<bool> everythingUsed (s.length(), false);\n\n            auto finised{[&]() -> bool {return (std::all_of(everythingUsed.begin(), everythingUsed.end(), [&](bool v) { return v; }));}};\n                \n            for (int x{0}; x<s.length()&&!finised();++x){\n\n\n                        if (everythingUsed[x]==false){\n                            everythingUsed[x]=true;\n\n                            ++numberOfDifferentLetters;\n                            allOfTheDifferentLetters.push_back(s[x]);\n\n\n                            for (int y{x+1};y<s.length()&&!finised();++y){\n                                if (everythingUsed[y]==true) continue;\n\n                                else {\n                                    if (s[x]==s[y]){\n                                        everythingUsed[y]=true;\n                                        vOfList[s[x]].insert({x,y});\n                                        ++numberOfDifferentLettersBeingMoreThanOne;\n                                    }\n                                }\n                            }\n                        }\n                        else continue;\n                    }\n\n            if (numberOfDifferentLettersBeingMoreThanOne==0) {\n                std::string str_ch {s[0]};\n                return str_ch;\n            };\n\n            std::unordered_map<char, std::set<int>>::iterator itBegin {vOfList.begin()};\n        \n\n            \n            std::string palindromic{};\n\n            while(itBegin != vOfList.end()){\n            \n                itLoop(itBegin, palindromic, s );\n                ++itBegin;\n            \n                }\n            \n            return palindromic;\n    \n    }\n};\n```\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "shri1403",
                        "content": "hi i was trying to solve this using the concepts of longest common substring and longest palindromic substring,\nhowver it doesnt work for the cases like aadabcadaa. this gives adaa as the ans and not ada. please help me with this\nthe following is my code:\n  string lcsub(string s , string s2){\n        int n=s.size();\n        int m=s2.size();\n         \n         vector<vector<int>> dp(n+1,vector<int>(m+1,0));\n         for(int i=0 ; i<=n;i++){\n             dp[i][0]=0;\n         }\n         for(int j=0; j<=m; j++){\n             dp[0][j]=0;\n         }\n        int maxi=0; int row=0; int col=0;\n         for(int i=1;i<=n;i++){\n             for(int j=1; j<=m ;j++){\n                 if(s[i-1]==s2[j-1]){\n                     dp[i][j]=1+dp[i-1][j-1];\n                     if(dp[i][j]>maxi){\n                         maxi=dp[i][j];\n                         row=i;\n                         col=j;\n                     }\n\n                    } \n                else\n                dp[i][j]=0; // if the continuity is broken then there is no LCS'\n                    \n             }\n         }\n\n        \n         //maxi is the length of the longest commmon palindromic substring\n         \n         //we also have the row and col at which maxi element is found;\n         string ans=\"\";\n         int len=maxi;\n\n\n         while((row>0&&col>0) && len>0){ //added this condition of len>0 beacsyein the second test case bbc print horha tha and this was because humara len=2 ka lcsubstring h par abhi tak row ya col 0 nhi hua tha toh islioye c bhi append hogya\n         //toh matlab yeh h ki jaha tak len h utna hi string me daalo\n               ans+=s[row-1];\n               row--;\n               col--;\n               len--;\n\n         }\n       cout<<maxi;\n        \n         return ans;\n\n\n    }\n    string longestPalindrome(string s) {\n        string s2=s;\n        reverse(s.begin(),s.end());\n        return lcsub(s2,s);\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1996056,
                "content": [
                    {
                        "username": "aylahjomri",
                        "content": "why does it say 141/141 testcases passed but says Time Limit Exceeded and the last executed input is empty ?"
                    },
                    {
                        "username": "CvamReborn_C2R",
                        "content": "Wrong Question some test cases are not right"
                    },
                    {
                        "username": "ak_3101",
                        "content": "okay so is it absolutely normal to get an intuition of writing code in tabular form or everybody first write recursion, and then top down/ bottom up"
                    },
                    {
                        "username": "jfonseca32",
                        "content": "There is something wrong with this question. I made and ran the code in Python and for every test case LeetCode says the code failed on, it works when I run it in Python."
                    },
                    {
                        "username": "timewaster69",
                        "content": "I think the test case s= (nothing) should be removed. It only causes errors and the constraints specifically state that there's at least one character to work with, and that there's specifically alphanumericals to deal with."
                    },
                    {
                        "username": "kevinbiju",
                        "content": "how do we learn to optimize brute force approach\\n"
                    },
                    {
                        "username": "espinosarennieljun",
                        "content": "To solve this you only need to mind two things. \none, Palindrome can't have with more than one even number of character duplicate.\ntwo, all single character should be ignore you only need to add one single character if the result total number is odd. example the total none single character of string is 6 and you can place single character on the middle of the string so it become 7."
                    },
                    {
                        "username": "muraripavansai22",
                        "content": "\"aacabdkacaa\"\\n\\nThis is my output : \"aacakacaa\"\\ngiven this should be expected : \"aca\"\\n\\nThere is some error with this test case\\ncorrect me if im wrong."
                    },
                    {
                        "username": "Ab__23",
                        "content": "\"aacakacaa\" is a subsequence of input string not it's substring, as the question is to find substring that's where you are getting wrong.\nFor example : let string = \"abcdef\"\nit's substrings: 'a' 'ab' 'abc' 'cde' 'abcde' ...\nit's subsequences : 'a' 'ab' 'ac' 'acf' 'abe' ..."
                    },
                    {
                        "username": "TheMystery28",
                        "content": "I've tried and failed enough times to allow myself to see the hints and come up with an optimal solution.\n\nHowever, I'd like to understand why my old code gives a \"time exceeded\" error for \"aacabdkacaa\" when I have made sure to skip the calculation that can be skipped to avoid wasting time.\n\nCould someone please enlighten me?\n\n ```\n#include <algorithm>\n#include <iostream>\n#include <string>\n#include <string_view>\n#include <unordered_map>\n#include <set>\n#include <functional>\n#include <list>\n#include <iterator>\n#include <memory>\n\n\nclass Solution {\n\n    private:\n\n        std::unordered_map<char, std::set<int>> vOfList{};\n\n        int numberOfDifferentLetters{0};\n        int numberOfDifferentLettersBeingMoreThanOne{0};\n        std::vector<char> allOfTheDifferentLetters{};\n\n    public:\n        void itLoop2(std::set<int>::iterator& auto_pLeftItPos,\n                     std::set<int>::iterator& auto_pRightItPos,\n                     int pLeft, int pRight,\n                     std::string& palindromic, const std::string_view& s,\n                     bool trueToStopTheSpetialLoopToLoop){\n                        \n                    if (abs(*auto_pLeftItPos-*auto_pRightItPos)+1<=palindromic.length()) return;\n                    if(s[pLeft] == s[pRight]){\n\n                        if (pLeft==pRight||abs(pLeft - pRight)==1){\n                            palindromic=s.substr(*auto_pLeftItPos,abs(*auto_pLeftItPos-*auto_pRightItPos)+1);\n                        }\n                        else{\n\n\n                        itLoop2(auto_pLeftItPos, auto_pRightItPos,\n                                pLeft+1, pRight-1,palindromic, \n                                s,trueToStopTheSpetialLoopToLoop);}\n                    }\n                    else if (trueToStopTheSpetialLoopToLoop==false){\n                        trueToStopTheSpetialLoopToLoop = true;\n                    \n                        int x{std::abs(static_cast<int>(std::distance(auto_pLeftItPos,auto_pRightItPos)))};\n\n\n                        int c{0};\n\n                        for (int n{x};n>0;--n){\n                            //remainder that auto_pLeftItPos/auto_pRightItPos are in reverse for their iterator\n\n                            if (n==x) {++c;continue;} //If not we wouldn't be here in the first place\n\n\n\n                            int z{n};\n\n                            auto auto_pLeftItPosEdit{std::prev(auto_pLeftItPos,c)};\n\n                            itLoop2(auto_pLeftItPosEdit, auto_pRightItPos,\n                                *auto_pLeftItPosEdit, pRight,\n                                palindromic, \n                                s,trueToStopTheSpetialLoopToLoop);\n\n                            auto auto_pRightItPosEdit{auto_pRightItPos};\n\n                            while(auto_pLeftItPosEdit!=auto_pLeftItPos){\n                                \n                                auto_pLeftItPosEdit = std::next(auto_pLeftItPosEdit,1);\n                                auto_pRightItPosEdit = std::next(auto_pRightItPosEdit, 1);\n\n                                if (abs(*auto_pLeftItPos-*auto_pRightItPos)+1<=palindromic.length()) continue;\n\n                                itLoop2(auto_pLeftItPosEdit, auto_pRightItPosEdit,\n                                *auto_pLeftItPosEdit, *auto_pRightItPosEdit,\n                                palindromic, \n                                s,trueToStopTheSpetialLoopToLoop);\n\n                            }\n\n                            ++c;\n                        }\n\n                    }\n                    else return;\n\n        }\n\n        void itLoop(std::unordered_map<char, std::set<int>>::iterator& itBegin,\n                    std::string& palindromic, const std::string_view& s){\n                    \n\n                bool trueToStopTheSpetialLoopToLoop{false};\n\n            \n                auto *ptr {&((itBegin->second))};\n             \n                std::set<int>::iterator setEnd {ptr->begin()};\n\n\n                std::set<int>::iterator setBegin {ptr->end()};\n\n                std::advance(setBegin, -1);\n                //end() give the iterator AFTER the last element of the container\n\n            int pLeft{*setEnd};\n\n            int pRight{*setBegin};\n\n            if (abs(pLeft-pRight)+1<=palindromic.length()) return;\n\n\n            itLoop2(setEnd, setBegin, pLeft, pRight, palindromic, s, trueToStopTheSpetialLoopToLoop);\n\n\n        }\n\n        std::string longestPalindrome(const std::string_view& s) {\n\n            if (s.length()==0){\n                return \"\";\n            }\n            \n            std::vector<bool> everythingUsed (s.length(), false);\n\n            auto finised{[&]() -> bool {return (std::all_of(everythingUsed.begin(), everythingUsed.end(), [&](bool v) { return v; }));}};\n                \n            for (int x{0}; x<s.length()&&!finised();++x){\n\n\n                        if (everythingUsed[x]==false){\n                            everythingUsed[x]=true;\n\n                            ++numberOfDifferentLetters;\n                            allOfTheDifferentLetters.push_back(s[x]);\n\n\n                            for (int y{x+1};y<s.length()&&!finised();++y){\n                                if (everythingUsed[y]==true) continue;\n\n                                else {\n                                    if (s[x]==s[y]){\n                                        everythingUsed[y]=true;\n                                        vOfList[s[x]].insert({x,y});\n                                        ++numberOfDifferentLettersBeingMoreThanOne;\n                                    }\n                                }\n                            }\n                        }\n                        else continue;\n                    }\n\n            if (numberOfDifferentLettersBeingMoreThanOne==0) {\n                std::string str_ch {s[0]};\n                return str_ch;\n            };\n\n            std::unordered_map<char, std::set<int>>::iterator itBegin {vOfList.begin()};\n        \n\n            \n            std::string palindromic{};\n\n            while(itBegin != vOfList.end()){\n            \n                itLoop(itBegin, palindromic, s );\n                ++itBegin;\n            \n                }\n            \n            return palindromic;\n    \n    }\n};\n```\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "shri1403",
                        "content": "hi i was trying to solve this using the concepts of longest common substring and longest palindromic substring,\nhowver it doesnt work for the cases like aadabcadaa. this gives adaa as the ans and not ada. please help me with this\nthe following is my code:\n  string lcsub(string s , string s2){\n        int n=s.size();\n        int m=s2.size();\n         \n         vector<vector<int>> dp(n+1,vector<int>(m+1,0));\n         for(int i=0 ; i<=n;i++){\n             dp[i][0]=0;\n         }\n         for(int j=0; j<=m; j++){\n             dp[0][j]=0;\n         }\n        int maxi=0; int row=0; int col=0;\n         for(int i=1;i<=n;i++){\n             for(int j=1; j<=m ;j++){\n                 if(s[i-1]==s2[j-1]){\n                     dp[i][j]=1+dp[i-1][j-1];\n                     if(dp[i][j]>maxi){\n                         maxi=dp[i][j];\n                         row=i;\n                         col=j;\n                     }\n\n                    } \n                else\n                dp[i][j]=0; // if the continuity is broken then there is no LCS'\n                    \n             }\n         }\n\n        \n         //maxi is the length of the longest commmon palindromic substring\n         \n         //we also have the row and col at which maxi element is found;\n         string ans=\"\";\n         int len=maxi;\n\n\n         while((row>0&&col>0) && len>0){ //added this condition of len>0 beacsyein the second test case bbc print horha tha and this was because humara len=2 ka lcsubstring h par abhi tak row ya col 0 nhi hua tha toh islioye c bhi append hogya\n         //toh matlab yeh h ki jaha tak len h utna hi string me daalo\n               ans+=s[row-1];\n               row--;\n               col--;\n               len--;\n\n         }\n       cout<<maxi;\n        \n         return ans;\n\n\n    }\n    string longestPalindrome(string s) {\n        string s2=s;\n        reverse(s.begin(),s.end());\n        return lcsub(s2,s);\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1992101,
                "content": [
                    {
                        "username": "aylahjomri",
                        "content": "why does it say 141/141 testcases passed but says Time Limit Exceeded and the last executed input is empty ?"
                    },
                    {
                        "username": "CvamReborn_C2R",
                        "content": "Wrong Question some test cases are not right"
                    },
                    {
                        "username": "ak_3101",
                        "content": "okay so is it absolutely normal to get an intuition of writing code in tabular form or everybody first write recursion, and then top down/ bottom up"
                    },
                    {
                        "username": "jfonseca32",
                        "content": "There is something wrong with this question. I made and ran the code in Python and for every test case LeetCode says the code failed on, it works when I run it in Python."
                    },
                    {
                        "username": "timewaster69",
                        "content": "I think the test case s= (nothing) should be removed. It only causes errors and the constraints specifically state that there's at least one character to work with, and that there's specifically alphanumericals to deal with."
                    },
                    {
                        "username": "kevinbiju",
                        "content": "how do we learn to optimize brute force approach\\n"
                    },
                    {
                        "username": "espinosarennieljun",
                        "content": "To solve this you only need to mind two things. \none, Palindrome can't have with more than one even number of character duplicate.\ntwo, all single character should be ignore you only need to add one single character if the result total number is odd. example the total none single character of string is 6 and you can place single character on the middle of the string so it become 7."
                    },
                    {
                        "username": "muraripavansai22",
                        "content": "\"aacabdkacaa\"\\n\\nThis is my output : \"aacakacaa\"\\ngiven this should be expected : \"aca\"\\n\\nThere is some error with this test case\\ncorrect me if im wrong."
                    },
                    {
                        "username": "Ab__23",
                        "content": "\"aacakacaa\" is a subsequence of input string not it's substring, as the question is to find substring that's where you are getting wrong.\nFor example : let string = \"abcdef\"\nit's substrings: 'a' 'ab' 'abc' 'cde' 'abcde' ...\nit's subsequences : 'a' 'ab' 'ac' 'acf' 'abe' ..."
                    },
                    {
                        "username": "TheMystery28",
                        "content": "I've tried and failed enough times to allow myself to see the hints and come up with an optimal solution.\n\nHowever, I'd like to understand why my old code gives a \"time exceeded\" error for \"aacabdkacaa\" when I have made sure to skip the calculation that can be skipped to avoid wasting time.\n\nCould someone please enlighten me?\n\n ```\n#include <algorithm>\n#include <iostream>\n#include <string>\n#include <string_view>\n#include <unordered_map>\n#include <set>\n#include <functional>\n#include <list>\n#include <iterator>\n#include <memory>\n\n\nclass Solution {\n\n    private:\n\n        std::unordered_map<char, std::set<int>> vOfList{};\n\n        int numberOfDifferentLetters{0};\n        int numberOfDifferentLettersBeingMoreThanOne{0};\n        std::vector<char> allOfTheDifferentLetters{};\n\n    public:\n        void itLoop2(std::set<int>::iterator& auto_pLeftItPos,\n                     std::set<int>::iterator& auto_pRightItPos,\n                     int pLeft, int pRight,\n                     std::string& palindromic, const std::string_view& s,\n                     bool trueToStopTheSpetialLoopToLoop){\n                        \n                    if (abs(*auto_pLeftItPos-*auto_pRightItPos)+1<=palindromic.length()) return;\n                    if(s[pLeft] == s[pRight]){\n\n                        if (pLeft==pRight||abs(pLeft - pRight)==1){\n                            palindromic=s.substr(*auto_pLeftItPos,abs(*auto_pLeftItPos-*auto_pRightItPos)+1);\n                        }\n                        else{\n\n\n                        itLoop2(auto_pLeftItPos, auto_pRightItPos,\n                                pLeft+1, pRight-1,palindromic, \n                                s,trueToStopTheSpetialLoopToLoop);}\n                    }\n                    else if (trueToStopTheSpetialLoopToLoop==false){\n                        trueToStopTheSpetialLoopToLoop = true;\n                    \n                        int x{std::abs(static_cast<int>(std::distance(auto_pLeftItPos,auto_pRightItPos)))};\n\n\n                        int c{0};\n\n                        for (int n{x};n>0;--n){\n                            //remainder that auto_pLeftItPos/auto_pRightItPos are in reverse for their iterator\n\n                            if (n==x) {++c;continue;} //If not we wouldn't be here in the first place\n\n\n\n                            int z{n};\n\n                            auto auto_pLeftItPosEdit{std::prev(auto_pLeftItPos,c)};\n\n                            itLoop2(auto_pLeftItPosEdit, auto_pRightItPos,\n                                *auto_pLeftItPosEdit, pRight,\n                                palindromic, \n                                s,trueToStopTheSpetialLoopToLoop);\n\n                            auto auto_pRightItPosEdit{auto_pRightItPos};\n\n                            while(auto_pLeftItPosEdit!=auto_pLeftItPos){\n                                \n                                auto_pLeftItPosEdit = std::next(auto_pLeftItPosEdit,1);\n                                auto_pRightItPosEdit = std::next(auto_pRightItPosEdit, 1);\n\n                                if (abs(*auto_pLeftItPos-*auto_pRightItPos)+1<=palindromic.length()) continue;\n\n                                itLoop2(auto_pLeftItPosEdit, auto_pRightItPosEdit,\n                                *auto_pLeftItPosEdit, *auto_pRightItPosEdit,\n                                palindromic, \n                                s,trueToStopTheSpetialLoopToLoop);\n\n                            }\n\n                            ++c;\n                        }\n\n                    }\n                    else return;\n\n        }\n\n        void itLoop(std::unordered_map<char, std::set<int>>::iterator& itBegin,\n                    std::string& palindromic, const std::string_view& s){\n                    \n\n                bool trueToStopTheSpetialLoopToLoop{false};\n\n            \n                auto *ptr {&((itBegin->second))};\n             \n                std::set<int>::iterator setEnd {ptr->begin()};\n\n\n                std::set<int>::iterator setBegin {ptr->end()};\n\n                std::advance(setBegin, -1);\n                //end() give the iterator AFTER the last element of the container\n\n            int pLeft{*setEnd};\n\n            int pRight{*setBegin};\n\n            if (abs(pLeft-pRight)+1<=palindromic.length()) return;\n\n\n            itLoop2(setEnd, setBegin, pLeft, pRight, palindromic, s, trueToStopTheSpetialLoopToLoop);\n\n\n        }\n\n        std::string longestPalindrome(const std::string_view& s) {\n\n            if (s.length()==0){\n                return \"\";\n            }\n            \n            std::vector<bool> everythingUsed (s.length(), false);\n\n            auto finised{[&]() -> bool {return (std::all_of(everythingUsed.begin(), everythingUsed.end(), [&](bool v) { return v; }));}};\n                \n            for (int x{0}; x<s.length()&&!finised();++x){\n\n\n                        if (everythingUsed[x]==false){\n                            everythingUsed[x]=true;\n\n                            ++numberOfDifferentLetters;\n                            allOfTheDifferentLetters.push_back(s[x]);\n\n\n                            for (int y{x+1};y<s.length()&&!finised();++y){\n                                if (everythingUsed[y]==true) continue;\n\n                                else {\n                                    if (s[x]==s[y]){\n                                        everythingUsed[y]=true;\n                                        vOfList[s[x]].insert({x,y});\n                                        ++numberOfDifferentLettersBeingMoreThanOne;\n                                    }\n                                }\n                            }\n                        }\n                        else continue;\n                    }\n\n            if (numberOfDifferentLettersBeingMoreThanOne==0) {\n                std::string str_ch {s[0]};\n                return str_ch;\n            };\n\n            std::unordered_map<char, std::set<int>>::iterator itBegin {vOfList.begin()};\n        \n\n            \n            std::string palindromic{};\n\n            while(itBegin != vOfList.end()){\n            \n                itLoop(itBegin, palindromic, s );\n                ++itBegin;\n            \n                }\n            \n            return palindromic;\n    \n    }\n};\n```\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "shri1403",
                        "content": "hi i was trying to solve this using the concepts of longest common substring and longest palindromic substring,\nhowver it doesnt work for the cases like aadabcadaa. this gives adaa as the ans and not ada. please help me with this\nthe following is my code:\n  string lcsub(string s , string s2){\n        int n=s.size();\n        int m=s2.size();\n         \n         vector<vector<int>> dp(n+1,vector<int>(m+1,0));\n         for(int i=0 ; i<=n;i++){\n             dp[i][0]=0;\n         }\n         for(int j=0; j<=m; j++){\n             dp[0][j]=0;\n         }\n        int maxi=0; int row=0; int col=0;\n         for(int i=1;i<=n;i++){\n             for(int j=1; j<=m ;j++){\n                 if(s[i-1]==s2[j-1]){\n                     dp[i][j]=1+dp[i-1][j-1];\n                     if(dp[i][j]>maxi){\n                         maxi=dp[i][j];\n                         row=i;\n                         col=j;\n                     }\n\n                    } \n                else\n                dp[i][j]=0; // if the continuity is broken then there is no LCS'\n                    \n             }\n         }\n\n        \n         //maxi is the length of the longest commmon palindromic substring\n         \n         //we also have the row and col at which maxi element is found;\n         string ans=\"\";\n         int len=maxi;\n\n\n         while((row>0&&col>0) && len>0){ //added this condition of len>0 beacsyein the second test case bbc print horha tha and this was because humara len=2 ka lcsubstring h par abhi tak row ya col 0 nhi hua tha toh islioye c bhi append hogya\n         //toh matlab yeh h ki jaha tak len h utna hi string me daalo\n               ans+=s[row-1];\n               row--;\n               col--;\n               len--;\n\n         }\n       cout<<maxi;\n        \n         return ans;\n\n\n    }\n    string longestPalindrome(string s) {\n        string s2=s;\n        reverse(s.begin(),s.end());\n        return lcsub(s2,s);\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1983388,
                "content": [
                    {
                        "username": "aylahjomri",
                        "content": "why does it say 141/141 testcases passed but says Time Limit Exceeded and the last executed input is empty ?"
                    },
                    {
                        "username": "CvamReborn_C2R",
                        "content": "Wrong Question some test cases are not right"
                    },
                    {
                        "username": "ak_3101",
                        "content": "okay so is it absolutely normal to get an intuition of writing code in tabular form or everybody first write recursion, and then top down/ bottom up"
                    },
                    {
                        "username": "jfonseca32",
                        "content": "There is something wrong with this question. I made and ran the code in Python and for every test case LeetCode says the code failed on, it works when I run it in Python."
                    },
                    {
                        "username": "timewaster69",
                        "content": "I think the test case s= (nothing) should be removed. It only causes errors and the constraints specifically state that there's at least one character to work with, and that there's specifically alphanumericals to deal with."
                    },
                    {
                        "username": "kevinbiju",
                        "content": "how do we learn to optimize brute force approach\\n"
                    },
                    {
                        "username": "espinosarennieljun",
                        "content": "To solve this you only need to mind two things. \none, Palindrome can't have with more than one even number of character duplicate.\ntwo, all single character should be ignore you only need to add one single character if the result total number is odd. example the total none single character of string is 6 and you can place single character on the middle of the string so it become 7."
                    },
                    {
                        "username": "muraripavansai22",
                        "content": "\"aacabdkacaa\"\\n\\nThis is my output : \"aacakacaa\"\\ngiven this should be expected : \"aca\"\\n\\nThere is some error with this test case\\ncorrect me if im wrong."
                    },
                    {
                        "username": "Ab__23",
                        "content": "\"aacakacaa\" is a subsequence of input string not it's substring, as the question is to find substring that's where you are getting wrong.\nFor example : let string = \"abcdef\"\nit's substrings: 'a' 'ab' 'abc' 'cde' 'abcde' ...\nit's subsequences : 'a' 'ab' 'ac' 'acf' 'abe' ..."
                    },
                    {
                        "username": "TheMystery28",
                        "content": "I've tried and failed enough times to allow myself to see the hints and come up with an optimal solution.\n\nHowever, I'd like to understand why my old code gives a \"time exceeded\" error for \"aacabdkacaa\" when I have made sure to skip the calculation that can be skipped to avoid wasting time.\n\nCould someone please enlighten me?\n\n ```\n#include <algorithm>\n#include <iostream>\n#include <string>\n#include <string_view>\n#include <unordered_map>\n#include <set>\n#include <functional>\n#include <list>\n#include <iterator>\n#include <memory>\n\n\nclass Solution {\n\n    private:\n\n        std::unordered_map<char, std::set<int>> vOfList{};\n\n        int numberOfDifferentLetters{0};\n        int numberOfDifferentLettersBeingMoreThanOne{0};\n        std::vector<char> allOfTheDifferentLetters{};\n\n    public:\n        void itLoop2(std::set<int>::iterator& auto_pLeftItPos,\n                     std::set<int>::iterator& auto_pRightItPos,\n                     int pLeft, int pRight,\n                     std::string& palindromic, const std::string_view& s,\n                     bool trueToStopTheSpetialLoopToLoop){\n                        \n                    if (abs(*auto_pLeftItPos-*auto_pRightItPos)+1<=palindromic.length()) return;\n                    if(s[pLeft] == s[pRight]){\n\n                        if (pLeft==pRight||abs(pLeft - pRight)==1){\n                            palindromic=s.substr(*auto_pLeftItPos,abs(*auto_pLeftItPos-*auto_pRightItPos)+1);\n                        }\n                        else{\n\n\n                        itLoop2(auto_pLeftItPos, auto_pRightItPos,\n                                pLeft+1, pRight-1,palindromic, \n                                s,trueToStopTheSpetialLoopToLoop);}\n                    }\n                    else if (trueToStopTheSpetialLoopToLoop==false){\n                        trueToStopTheSpetialLoopToLoop = true;\n                    \n                        int x{std::abs(static_cast<int>(std::distance(auto_pLeftItPos,auto_pRightItPos)))};\n\n\n                        int c{0};\n\n                        for (int n{x};n>0;--n){\n                            //remainder that auto_pLeftItPos/auto_pRightItPos are in reverse for their iterator\n\n                            if (n==x) {++c;continue;} //If not we wouldn't be here in the first place\n\n\n\n                            int z{n};\n\n                            auto auto_pLeftItPosEdit{std::prev(auto_pLeftItPos,c)};\n\n                            itLoop2(auto_pLeftItPosEdit, auto_pRightItPos,\n                                *auto_pLeftItPosEdit, pRight,\n                                palindromic, \n                                s,trueToStopTheSpetialLoopToLoop);\n\n                            auto auto_pRightItPosEdit{auto_pRightItPos};\n\n                            while(auto_pLeftItPosEdit!=auto_pLeftItPos){\n                                \n                                auto_pLeftItPosEdit = std::next(auto_pLeftItPosEdit,1);\n                                auto_pRightItPosEdit = std::next(auto_pRightItPosEdit, 1);\n\n                                if (abs(*auto_pLeftItPos-*auto_pRightItPos)+1<=palindromic.length()) continue;\n\n                                itLoop2(auto_pLeftItPosEdit, auto_pRightItPosEdit,\n                                *auto_pLeftItPosEdit, *auto_pRightItPosEdit,\n                                palindromic, \n                                s,trueToStopTheSpetialLoopToLoop);\n\n                            }\n\n                            ++c;\n                        }\n\n                    }\n                    else return;\n\n        }\n\n        void itLoop(std::unordered_map<char, std::set<int>>::iterator& itBegin,\n                    std::string& palindromic, const std::string_view& s){\n                    \n\n                bool trueToStopTheSpetialLoopToLoop{false};\n\n            \n                auto *ptr {&((itBegin->second))};\n             \n                std::set<int>::iterator setEnd {ptr->begin()};\n\n\n                std::set<int>::iterator setBegin {ptr->end()};\n\n                std::advance(setBegin, -1);\n                //end() give the iterator AFTER the last element of the container\n\n            int pLeft{*setEnd};\n\n            int pRight{*setBegin};\n\n            if (abs(pLeft-pRight)+1<=palindromic.length()) return;\n\n\n            itLoop2(setEnd, setBegin, pLeft, pRight, palindromic, s, trueToStopTheSpetialLoopToLoop);\n\n\n        }\n\n        std::string longestPalindrome(const std::string_view& s) {\n\n            if (s.length()==0){\n                return \"\";\n            }\n            \n            std::vector<bool> everythingUsed (s.length(), false);\n\n            auto finised{[&]() -> bool {return (std::all_of(everythingUsed.begin(), everythingUsed.end(), [&](bool v) { return v; }));}};\n                \n            for (int x{0}; x<s.length()&&!finised();++x){\n\n\n                        if (everythingUsed[x]==false){\n                            everythingUsed[x]=true;\n\n                            ++numberOfDifferentLetters;\n                            allOfTheDifferentLetters.push_back(s[x]);\n\n\n                            for (int y{x+1};y<s.length()&&!finised();++y){\n                                if (everythingUsed[y]==true) continue;\n\n                                else {\n                                    if (s[x]==s[y]){\n                                        everythingUsed[y]=true;\n                                        vOfList[s[x]].insert({x,y});\n                                        ++numberOfDifferentLettersBeingMoreThanOne;\n                                    }\n                                }\n                            }\n                        }\n                        else continue;\n                    }\n\n            if (numberOfDifferentLettersBeingMoreThanOne==0) {\n                std::string str_ch {s[0]};\n                return str_ch;\n            };\n\n            std::unordered_map<char, std::set<int>>::iterator itBegin {vOfList.begin()};\n        \n\n            \n            std::string palindromic{};\n\n            while(itBegin != vOfList.end()){\n            \n                itLoop(itBegin, palindromic, s );\n                ++itBegin;\n            \n                }\n            \n            return palindromic;\n    \n    }\n};\n```\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "shri1403",
                        "content": "hi i was trying to solve this using the concepts of longest common substring and longest palindromic substring,\nhowver it doesnt work for the cases like aadabcadaa. this gives adaa as the ans and not ada. please help me with this\nthe following is my code:\n  string lcsub(string s , string s2){\n        int n=s.size();\n        int m=s2.size();\n         \n         vector<vector<int>> dp(n+1,vector<int>(m+1,0));\n         for(int i=0 ; i<=n;i++){\n             dp[i][0]=0;\n         }\n         for(int j=0; j<=m; j++){\n             dp[0][j]=0;\n         }\n        int maxi=0; int row=0; int col=0;\n         for(int i=1;i<=n;i++){\n             for(int j=1; j<=m ;j++){\n                 if(s[i-1]==s2[j-1]){\n                     dp[i][j]=1+dp[i-1][j-1];\n                     if(dp[i][j]>maxi){\n                         maxi=dp[i][j];\n                         row=i;\n                         col=j;\n                     }\n\n                    } \n                else\n                dp[i][j]=0; // if the continuity is broken then there is no LCS'\n                    \n             }\n         }\n\n        \n         //maxi is the length of the longest commmon palindromic substring\n         \n         //we also have the row and col at which maxi element is found;\n         string ans=\"\";\n         int len=maxi;\n\n\n         while((row>0&&col>0) && len>0){ //added this condition of len>0 beacsyein the second test case bbc print horha tha and this was because humara len=2 ka lcsubstring h par abhi tak row ya col 0 nhi hua tha toh islioye c bhi append hogya\n         //toh matlab yeh h ki jaha tak len h utna hi string me daalo\n               ans+=s[row-1];\n               row--;\n               col--;\n               len--;\n\n         }\n       cout<<maxi;\n        \n         return ans;\n\n\n    }\n    string longestPalindrome(string s) {\n        string s2=s;\n        reverse(s.begin(),s.end());\n        return lcsub(s2,s);\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1981985,
                "content": [
                    {
                        "username": "aylahjomri",
                        "content": "why does it say 141/141 testcases passed but says Time Limit Exceeded and the last executed input is empty ?"
                    },
                    {
                        "username": "CvamReborn_C2R",
                        "content": "Wrong Question some test cases are not right"
                    },
                    {
                        "username": "ak_3101",
                        "content": "okay so is it absolutely normal to get an intuition of writing code in tabular form or everybody first write recursion, and then top down/ bottom up"
                    },
                    {
                        "username": "jfonseca32",
                        "content": "There is something wrong with this question. I made and ran the code in Python and for every test case LeetCode says the code failed on, it works when I run it in Python."
                    },
                    {
                        "username": "timewaster69",
                        "content": "I think the test case s= (nothing) should be removed. It only causes errors and the constraints specifically state that there's at least one character to work with, and that there's specifically alphanumericals to deal with."
                    },
                    {
                        "username": "kevinbiju",
                        "content": "how do we learn to optimize brute force approach\\n"
                    },
                    {
                        "username": "espinosarennieljun",
                        "content": "To solve this you only need to mind two things. \none, Palindrome can't have with more than one even number of character duplicate.\ntwo, all single character should be ignore you only need to add one single character if the result total number is odd. example the total none single character of string is 6 and you can place single character on the middle of the string so it become 7."
                    },
                    {
                        "username": "muraripavansai22",
                        "content": "\"aacabdkacaa\"\\n\\nThis is my output : \"aacakacaa\"\\ngiven this should be expected : \"aca\"\\n\\nThere is some error with this test case\\ncorrect me if im wrong."
                    },
                    {
                        "username": "Ab__23",
                        "content": "\"aacakacaa\" is a subsequence of input string not it's substring, as the question is to find substring that's where you are getting wrong.\nFor example : let string = \"abcdef\"\nit's substrings: 'a' 'ab' 'abc' 'cde' 'abcde' ...\nit's subsequences : 'a' 'ab' 'ac' 'acf' 'abe' ..."
                    },
                    {
                        "username": "TheMystery28",
                        "content": "I've tried and failed enough times to allow myself to see the hints and come up with an optimal solution.\n\nHowever, I'd like to understand why my old code gives a \"time exceeded\" error for \"aacabdkacaa\" when I have made sure to skip the calculation that can be skipped to avoid wasting time.\n\nCould someone please enlighten me?\n\n ```\n#include <algorithm>\n#include <iostream>\n#include <string>\n#include <string_view>\n#include <unordered_map>\n#include <set>\n#include <functional>\n#include <list>\n#include <iterator>\n#include <memory>\n\n\nclass Solution {\n\n    private:\n\n        std::unordered_map<char, std::set<int>> vOfList{};\n\n        int numberOfDifferentLetters{0};\n        int numberOfDifferentLettersBeingMoreThanOne{0};\n        std::vector<char> allOfTheDifferentLetters{};\n\n    public:\n        void itLoop2(std::set<int>::iterator& auto_pLeftItPos,\n                     std::set<int>::iterator& auto_pRightItPos,\n                     int pLeft, int pRight,\n                     std::string& palindromic, const std::string_view& s,\n                     bool trueToStopTheSpetialLoopToLoop){\n                        \n                    if (abs(*auto_pLeftItPos-*auto_pRightItPos)+1<=palindromic.length()) return;\n                    if(s[pLeft] == s[pRight]){\n\n                        if (pLeft==pRight||abs(pLeft - pRight)==1){\n                            palindromic=s.substr(*auto_pLeftItPos,abs(*auto_pLeftItPos-*auto_pRightItPos)+1);\n                        }\n                        else{\n\n\n                        itLoop2(auto_pLeftItPos, auto_pRightItPos,\n                                pLeft+1, pRight-1,palindromic, \n                                s,trueToStopTheSpetialLoopToLoop);}\n                    }\n                    else if (trueToStopTheSpetialLoopToLoop==false){\n                        trueToStopTheSpetialLoopToLoop = true;\n                    \n                        int x{std::abs(static_cast<int>(std::distance(auto_pLeftItPos,auto_pRightItPos)))};\n\n\n                        int c{0};\n\n                        for (int n{x};n>0;--n){\n                            //remainder that auto_pLeftItPos/auto_pRightItPos are in reverse for their iterator\n\n                            if (n==x) {++c;continue;} //If not we wouldn't be here in the first place\n\n\n\n                            int z{n};\n\n                            auto auto_pLeftItPosEdit{std::prev(auto_pLeftItPos,c)};\n\n                            itLoop2(auto_pLeftItPosEdit, auto_pRightItPos,\n                                *auto_pLeftItPosEdit, pRight,\n                                palindromic, \n                                s,trueToStopTheSpetialLoopToLoop);\n\n                            auto auto_pRightItPosEdit{auto_pRightItPos};\n\n                            while(auto_pLeftItPosEdit!=auto_pLeftItPos){\n                                \n                                auto_pLeftItPosEdit = std::next(auto_pLeftItPosEdit,1);\n                                auto_pRightItPosEdit = std::next(auto_pRightItPosEdit, 1);\n\n                                if (abs(*auto_pLeftItPos-*auto_pRightItPos)+1<=palindromic.length()) continue;\n\n                                itLoop2(auto_pLeftItPosEdit, auto_pRightItPosEdit,\n                                *auto_pLeftItPosEdit, *auto_pRightItPosEdit,\n                                palindromic, \n                                s,trueToStopTheSpetialLoopToLoop);\n\n                            }\n\n                            ++c;\n                        }\n\n                    }\n                    else return;\n\n        }\n\n        void itLoop(std::unordered_map<char, std::set<int>>::iterator& itBegin,\n                    std::string& palindromic, const std::string_view& s){\n                    \n\n                bool trueToStopTheSpetialLoopToLoop{false};\n\n            \n                auto *ptr {&((itBegin->second))};\n             \n                std::set<int>::iterator setEnd {ptr->begin()};\n\n\n                std::set<int>::iterator setBegin {ptr->end()};\n\n                std::advance(setBegin, -1);\n                //end() give the iterator AFTER the last element of the container\n\n            int pLeft{*setEnd};\n\n            int pRight{*setBegin};\n\n            if (abs(pLeft-pRight)+1<=palindromic.length()) return;\n\n\n            itLoop2(setEnd, setBegin, pLeft, pRight, palindromic, s, trueToStopTheSpetialLoopToLoop);\n\n\n        }\n\n        std::string longestPalindrome(const std::string_view& s) {\n\n            if (s.length()==0){\n                return \"\";\n            }\n            \n            std::vector<bool> everythingUsed (s.length(), false);\n\n            auto finised{[&]() -> bool {return (std::all_of(everythingUsed.begin(), everythingUsed.end(), [&](bool v) { return v; }));}};\n                \n            for (int x{0}; x<s.length()&&!finised();++x){\n\n\n                        if (everythingUsed[x]==false){\n                            everythingUsed[x]=true;\n\n                            ++numberOfDifferentLetters;\n                            allOfTheDifferentLetters.push_back(s[x]);\n\n\n                            for (int y{x+1};y<s.length()&&!finised();++y){\n                                if (everythingUsed[y]==true) continue;\n\n                                else {\n                                    if (s[x]==s[y]){\n                                        everythingUsed[y]=true;\n                                        vOfList[s[x]].insert({x,y});\n                                        ++numberOfDifferentLettersBeingMoreThanOne;\n                                    }\n                                }\n                            }\n                        }\n                        else continue;\n                    }\n\n            if (numberOfDifferentLettersBeingMoreThanOne==0) {\n                std::string str_ch {s[0]};\n                return str_ch;\n            };\n\n            std::unordered_map<char, std::set<int>>::iterator itBegin {vOfList.begin()};\n        \n\n            \n            std::string palindromic{};\n\n            while(itBegin != vOfList.end()){\n            \n                itLoop(itBegin, palindromic, s );\n                ++itBegin;\n            \n                }\n            \n            return palindromic;\n    \n    }\n};\n```\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "shri1403",
                        "content": "hi i was trying to solve this using the concepts of longest common substring and longest palindromic substring,\nhowver it doesnt work for the cases like aadabcadaa. this gives adaa as the ans and not ada. please help me with this\nthe following is my code:\n  string lcsub(string s , string s2){\n        int n=s.size();\n        int m=s2.size();\n         \n         vector<vector<int>> dp(n+1,vector<int>(m+1,0));\n         for(int i=0 ; i<=n;i++){\n             dp[i][0]=0;\n         }\n         for(int j=0; j<=m; j++){\n             dp[0][j]=0;\n         }\n        int maxi=0; int row=0; int col=0;\n         for(int i=1;i<=n;i++){\n             for(int j=1; j<=m ;j++){\n                 if(s[i-1]==s2[j-1]){\n                     dp[i][j]=1+dp[i-1][j-1];\n                     if(dp[i][j]>maxi){\n                         maxi=dp[i][j];\n                         row=i;\n                         col=j;\n                     }\n\n                    } \n                else\n                dp[i][j]=0; // if the continuity is broken then there is no LCS'\n                    \n             }\n         }\n\n        \n         //maxi is the length of the longest commmon palindromic substring\n         \n         //we also have the row and col at which maxi element is found;\n         string ans=\"\";\n         int len=maxi;\n\n\n         while((row>0&&col>0) && len>0){ //added this condition of len>0 beacsyein the second test case bbc print horha tha and this was because humara len=2 ka lcsubstring h par abhi tak row ya col 0 nhi hua tha toh islioye c bhi append hogya\n         //toh matlab yeh h ki jaha tak len h utna hi string me daalo\n               ans+=s[row-1];\n               row--;\n               col--;\n               len--;\n\n         }\n       cout<<maxi;\n        \n         return ans;\n\n\n    }\n    string longestPalindrome(string s) {\n        string s2=s;\n        reverse(s.begin(),s.end());\n        return lcsub(s2,s);\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1971179,
                "content": [
                    {
                        "username": "aylahjomri",
                        "content": "why does it say 141/141 testcases passed but says Time Limit Exceeded and the last executed input is empty ?"
                    },
                    {
                        "username": "CvamReborn_C2R",
                        "content": "Wrong Question some test cases are not right"
                    },
                    {
                        "username": "ak_3101",
                        "content": "okay so is it absolutely normal to get an intuition of writing code in tabular form or everybody first write recursion, and then top down/ bottom up"
                    },
                    {
                        "username": "jfonseca32",
                        "content": "There is something wrong with this question. I made and ran the code in Python and for every test case LeetCode says the code failed on, it works when I run it in Python."
                    },
                    {
                        "username": "timewaster69",
                        "content": "I think the test case s= (nothing) should be removed. It only causes errors and the constraints specifically state that there's at least one character to work with, and that there's specifically alphanumericals to deal with."
                    },
                    {
                        "username": "kevinbiju",
                        "content": "how do we learn to optimize brute force approach\\n"
                    },
                    {
                        "username": "espinosarennieljun",
                        "content": "To solve this you only need to mind two things. \none, Palindrome can't have with more than one even number of character duplicate.\ntwo, all single character should be ignore you only need to add one single character if the result total number is odd. example the total none single character of string is 6 and you can place single character on the middle of the string so it become 7."
                    },
                    {
                        "username": "muraripavansai22",
                        "content": "\"aacabdkacaa\"\\n\\nThis is my output : \"aacakacaa\"\\ngiven this should be expected : \"aca\"\\n\\nThere is some error with this test case\\ncorrect me if im wrong."
                    },
                    {
                        "username": "Ab__23",
                        "content": "\"aacakacaa\" is a subsequence of input string not it's substring, as the question is to find substring that's where you are getting wrong.\nFor example : let string = \"abcdef\"\nit's substrings: 'a' 'ab' 'abc' 'cde' 'abcde' ...\nit's subsequences : 'a' 'ab' 'ac' 'acf' 'abe' ..."
                    },
                    {
                        "username": "TheMystery28",
                        "content": "I've tried and failed enough times to allow myself to see the hints and come up with an optimal solution.\n\nHowever, I'd like to understand why my old code gives a \"time exceeded\" error for \"aacabdkacaa\" when I have made sure to skip the calculation that can be skipped to avoid wasting time.\n\nCould someone please enlighten me?\n\n ```\n#include <algorithm>\n#include <iostream>\n#include <string>\n#include <string_view>\n#include <unordered_map>\n#include <set>\n#include <functional>\n#include <list>\n#include <iterator>\n#include <memory>\n\n\nclass Solution {\n\n    private:\n\n        std::unordered_map<char, std::set<int>> vOfList{};\n\n        int numberOfDifferentLetters{0};\n        int numberOfDifferentLettersBeingMoreThanOne{0};\n        std::vector<char> allOfTheDifferentLetters{};\n\n    public:\n        void itLoop2(std::set<int>::iterator& auto_pLeftItPos,\n                     std::set<int>::iterator& auto_pRightItPos,\n                     int pLeft, int pRight,\n                     std::string& palindromic, const std::string_view& s,\n                     bool trueToStopTheSpetialLoopToLoop){\n                        \n                    if (abs(*auto_pLeftItPos-*auto_pRightItPos)+1<=palindromic.length()) return;\n                    if(s[pLeft] == s[pRight]){\n\n                        if (pLeft==pRight||abs(pLeft - pRight)==1){\n                            palindromic=s.substr(*auto_pLeftItPos,abs(*auto_pLeftItPos-*auto_pRightItPos)+1);\n                        }\n                        else{\n\n\n                        itLoop2(auto_pLeftItPos, auto_pRightItPos,\n                                pLeft+1, pRight-1,palindromic, \n                                s,trueToStopTheSpetialLoopToLoop);}\n                    }\n                    else if (trueToStopTheSpetialLoopToLoop==false){\n                        trueToStopTheSpetialLoopToLoop = true;\n                    \n                        int x{std::abs(static_cast<int>(std::distance(auto_pLeftItPos,auto_pRightItPos)))};\n\n\n                        int c{0};\n\n                        for (int n{x};n>0;--n){\n                            //remainder that auto_pLeftItPos/auto_pRightItPos are in reverse for their iterator\n\n                            if (n==x) {++c;continue;} //If not we wouldn't be here in the first place\n\n\n\n                            int z{n};\n\n                            auto auto_pLeftItPosEdit{std::prev(auto_pLeftItPos,c)};\n\n                            itLoop2(auto_pLeftItPosEdit, auto_pRightItPos,\n                                *auto_pLeftItPosEdit, pRight,\n                                palindromic, \n                                s,trueToStopTheSpetialLoopToLoop);\n\n                            auto auto_pRightItPosEdit{auto_pRightItPos};\n\n                            while(auto_pLeftItPosEdit!=auto_pLeftItPos){\n                                \n                                auto_pLeftItPosEdit = std::next(auto_pLeftItPosEdit,1);\n                                auto_pRightItPosEdit = std::next(auto_pRightItPosEdit, 1);\n\n                                if (abs(*auto_pLeftItPos-*auto_pRightItPos)+1<=palindromic.length()) continue;\n\n                                itLoop2(auto_pLeftItPosEdit, auto_pRightItPosEdit,\n                                *auto_pLeftItPosEdit, *auto_pRightItPosEdit,\n                                palindromic, \n                                s,trueToStopTheSpetialLoopToLoop);\n\n                            }\n\n                            ++c;\n                        }\n\n                    }\n                    else return;\n\n        }\n\n        void itLoop(std::unordered_map<char, std::set<int>>::iterator& itBegin,\n                    std::string& palindromic, const std::string_view& s){\n                    \n\n                bool trueToStopTheSpetialLoopToLoop{false};\n\n            \n                auto *ptr {&((itBegin->second))};\n             \n                std::set<int>::iterator setEnd {ptr->begin()};\n\n\n                std::set<int>::iterator setBegin {ptr->end()};\n\n                std::advance(setBegin, -1);\n                //end() give the iterator AFTER the last element of the container\n\n            int pLeft{*setEnd};\n\n            int pRight{*setBegin};\n\n            if (abs(pLeft-pRight)+1<=palindromic.length()) return;\n\n\n            itLoop2(setEnd, setBegin, pLeft, pRight, palindromic, s, trueToStopTheSpetialLoopToLoop);\n\n\n        }\n\n        std::string longestPalindrome(const std::string_view& s) {\n\n            if (s.length()==0){\n                return \"\";\n            }\n            \n            std::vector<bool> everythingUsed (s.length(), false);\n\n            auto finised{[&]() -> bool {return (std::all_of(everythingUsed.begin(), everythingUsed.end(), [&](bool v) { return v; }));}};\n                \n            for (int x{0}; x<s.length()&&!finised();++x){\n\n\n                        if (everythingUsed[x]==false){\n                            everythingUsed[x]=true;\n\n                            ++numberOfDifferentLetters;\n                            allOfTheDifferentLetters.push_back(s[x]);\n\n\n                            for (int y{x+1};y<s.length()&&!finised();++y){\n                                if (everythingUsed[y]==true) continue;\n\n                                else {\n                                    if (s[x]==s[y]){\n                                        everythingUsed[y]=true;\n                                        vOfList[s[x]].insert({x,y});\n                                        ++numberOfDifferentLettersBeingMoreThanOne;\n                                    }\n                                }\n                            }\n                        }\n                        else continue;\n                    }\n\n            if (numberOfDifferentLettersBeingMoreThanOne==0) {\n                std::string str_ch {s[0]};\n                return str_ch;\n            };\n\n            std::unordered_map<char, std::set<int>>::iterator itBegin {vOfList.begin()};\n        \n\n            \n            std::string palindromic{};\n\n            while(itBegin != vOfList.end()){\n            \n                itLoop(itBegin, palindromic, s );\n                ++itBegin;\n            \n                }\n            \n            return palindromic;\n    \n    }\n};\n```\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "shri1403",
                        "content": "hi i was trying to solve this using the concepts of longest common substring and longest palindromic substring,\nhowver it doesnt work for the cases like aadabcadaa. this gives adaa as the ans and not ada. please help me with this\nthe following is my code:\n  string lcsub(string s , string s2){\n        int n=s.size();\n        int m=s2.size();\n         \n         vector<vector<int>> dp(n+1,vector<int>(m+1,0));\n         for(int i=0 ; i<=n;i++){\n             dp[i][0]=0;\n         }\n         for(int j=0; j<=m; j++){\n             dp[0][j]=0;\n         }\n        int maxi=0; int row=0; int col=0;\n         for(int i=1;i<=n;i++){\n             for(int j=1; j<=m ;j++){\n                 if(s[i-1]==s2[j-1]){\n                     dp[i][j]=1+dp[i-1][j-1];\n                     if(dp[i][j]>maxi){\n                         maxi=dp[i][j];\n                         row=i;\n                         col=j;\n                     }\n\n                    } \n                else\n                dp[i][j]=0; // if the continuity is broken then there is no LCS'\n                    \n             }\n         }\n\n        \n         //maxi is the length of the longest commmon palindromic substring\n         \n         //we also have the row and col at which maxi element is found;\n         string ans=\"\";\n         int len=maxi;\n\n\n         while((row>0&&col>0) && len>0){ //added this condition of len>0 beacsyein the second test case bbc print horha tha and this was because humara len=2 ka lcsubstring h par abhi tak row ya col 0 nhi hua tha toh islioye c bhi append hogya\n         //toh matlab yeh h ki jaha tak len h utna hi string me daalo\n               ans+=s[row-1];\n               row--;\n               col--;\n               len--;\n\n         }\n       cout<<maxi;\n        \n         return ans;\n\n\n    }\n    string longestPalindrome(string s) {\n        string s2=s;\n        reverse(s.begin(),s.end());\n        return lcsub(s2,s);\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1964122,
                "content": [
                    {
                        "username": "aylahjomri",
                        "content": "why does it say 141/141 testcases passed but says Time Limit Exceeded and the last executed input is empty ?"
                    },
                    {
                        "username": "CvamReborn_C2R",
                        "content": "Wrong Question some test cases are not right"
                    },
                    {
                        "username": "ak_3101",
                        "content": "okay so is it absolutely normal to get an intuition of writing code in tabular form or everybody first write recursion, and then top down/ bottom up"
                    },
                    {
                        "username": "jfonseca32",
                        "content": "There is something wrong with this question. I made and ran the code in Python and for every test case LeetCode says the code failed on, it works when I run it in Python."
                    },
                    {
                        "username": "timewaster69",
                        "content": "I think the test case s= (nothing) should be removed. It only causes errors and the constraints specifically state that there's at least one character to work with, and that there's specifically alphanumericals to deal with."
                    },
                    {
                        "username": "kevinbiju",
                        "content": "how do we learn to optimize brute force approach\\n"
                    },
                    {
                        "username": "espinosarennieljun",
                        "content": "To solve this you only need to mind two things. \none, Palindrome can't have with more than one even number of character duplicate.\ntwo, all single character should be ignore you only need to add one single character if the result total number is odd. example the total none single character of string is 6 and you can place single character on the middle of the string so it become 7."
                    },
                    {
                        "username": "muraripavansai22",
                        "content": "\"aacabdkacaa\"\\n\\nThis is my output : \"aacakacaa\"\\ngiven this should be expected : \"aca\"\\n\\nThere is some error with this test case\\ncorrect me if im wrong."
                    },
                    {
                        "username": "Ab__23",
                        "content": "\"aacakacaa\" is a subsequence of input string not it's substring, as the question is to find substring that's where you are getting wrong.\nFor example : let string = \"abcdef\"\nit's substrings: 'a' 'ab' 'abc' 'cde' 'abcde' ...\nit's subsequences : 'a' 'ab' 'ac' 'acf' 'abe' ..."
                    },
                    {
                        "username": "TheMystery28",
                        "content": "I've tried and failed enough times to allow myself to see the hints and come up with an optimal solution.\n\nHowever, I'd like to understand why my old code gives a \"time exceeded\" error for \"aacabdkacaa\" when I have made sure to skip the calculation that can be skipped to avoid wasting time.\n\nCould someone please enlighten me?\n\n ```\n#include <algorithm>\n#include <iostream>\n#include <string>\n#include <string_view>\n#include <unordered_map>\n#include <set>\n#include <functional>\n#include <list>\n#include <iterator>\n#include <memory>\n\n\nclass Solution {\n\n    private:\n\n        std::unordered_map<char, std::set<int>> vOfList{};\n\n        int numberOfDifferentLetters{0};\n        int numberOfDifferentLettersBeingMoreThanOne{0};\n        std::vector<char> allOfTheDifferentLetters{};\n\n    public:\n        void itLoop2(std::set<int>::iterator& auto_pLeftItPos,\n                     std::set<int>::iterator& auto_pRightItPos,\n                     int pLeft, int pRight,\n                     std::string& palindromic, const std::string_view& s,\n                     bool trueToStopTheSpetialLoopToLoop){\n                        \n                    if (abs(*auto_pLeftItPos-*auto_pRightItPos)+1<=palindromic.length()) return;\n                    if(s[pLeft] == s[pRight]){\n\n                        if (pLeft==pRight||abs(pLeft - pRight)==1){\n                            palindromic=s.substr(*auto_pLeftItPos,abs(*auto_pLeftItPos-*auto_pRightItPos)+1);\n                        }\n                        else{\n\n\n                        itLoop2(auto_pLeftItPos, auto_pRightItPos,\n                                pLeft+1, pRight-1,palindromic, \n                                s,trueToStopTheSpetialLoopToLoop);}\n                    }\n                    else if (trueToStopTheSpetialLoopToLoop==false){\n                        trueToStopTheSpetialLoopToLoop = true;\n                    \n                        int x{std::abs(static_cast<int>(std::distance(auto_pLeftItPos,auto_pRightItPos)))};\n\n\n                        int c{0};\n\n                        for (int n{x};n>0;--n){\n                            //remainder that auto_pLeftItPos/auto_pRightItPos are in reverse for their iterator\n\n                            if (n==x) {++c;continue;} //If not we wouldn't be here in the first place\n\n\n\n                            int z{n};\n\n                            auto auto_pLeftItPosEdit{std::prev(auto_pLeftItPos,c)};\n\n                            itLoop2(auto_pLeftItPosEdit, auto_pRightItPos,\n                                *auto_pLeftItPosEdit, pRight,\n                                palindromic, \n                                s,trueToStopTheSpetialLoopToLoop);\n\n                            auto auto_pRightItPosEdit{auto_pRightItPos};\n\n                            while(auto_pLeftItPosEdit!=auto_pLeftItPos){\n                                \n                                auto_pLeftItPosEdit = std::next(auto_pLeftItPosEdit,1);\n                                auto_pRightItPosEdit = std::next(auto_pRightItPosEdit, 1);\n\n                                if (abs(*auto_pLeftItPos-*auto_pRightItPos)+1<=palindromic.length()) continue;\n\n                                itLoop2(auto_pLeftItPosEdit, auto_pRightItPosEdit,\n                                *auto_pLeftItPosEdit, *auto_pRightItPosEdit,\n                                palindromic, \n                                s,trueToStopTheSpetialLoopToLoop);\n\n                            }\n\n                            ++c;\n                        }\n\n                    }\n                    else return;\n\n        }\n\n        void itLoop(std::unordered_map<char, std::set<int>>::iterator& itBegin,\n                    std::string& palindromic, const std::string_view& s){\n                    \n\n                bool trueToStopTheSpetialLoopToLoop{false};\n\n            \n                auto *ptr {&((itBegin->second))};\n             \n                std::set<int>::iterator setEnd {ptr->begin()};\n\n\n                std::set<int>::iterator setBegin {ptr->end()};\n\n                std::advance(setBegin, -1);\n                //end() give the iterator AFTER the last element of the container\n\n            int pLeft{*setEnd};\n\n            int pRight{*setBegin};\n\n            if (abs(pLeft-pRight)+1<=palindromic.length()) return;\n\n\n            itLoop2(setEnd, setBegin, pLeft, pRight, palindromic, s, trueToStopTheSpetialLoopToLoop);\n\n\n        }\n\n        std::string longestPalindrome(const std::string_view& s) {\n\n            if (s.length()==0){\n                return \"\";\n            }\n            \n            std::vector<bool> everythingUsed (s.length(), false);\n\n            auto finised{[&]() -> bool {return (std::all_of(everythingUsed.begin(), everythingUsed.end(), [&](bool v) { return v; }));}};\n                \n            for (int x{0}; x<s.length()&&!finised();++x){\n\n\n                        if (everythingUsed[x]==false){\n                            everythingUsed[x]=true;\n\n                            ++numberOfDifferentLetters;\n                            allOfTheDifferentLetters.push_back(s[x]);\n\n\n                            for (int y{x+1};y<s.length()&&!finised();++y){\n                                if (everythingUsed[y]==true) continue;\n\n                                else {\n                                    if (s[x]==s[y]){\n                                        everythingUsed[y]=true;\n                                        vOfList[s[x]].insert({x,y});\n                                        ++numberOfDifferentLettersBeingMoreThanOne;\n                                    }\n                                }\n                            }\n                        }\n                        else continue;\n                    }\n\n            if (numberOfDifferentLettersBeingMoreThanOne==0) {\n                std::string str_ch {s[0]};\n                return str_ch;\n            };\n\n            std::unordered_map<char, std::set<int>>::iterator itBegin {vOfList.begin()};\n        \n\n            \n            std::string palindromic{};\n\n            while(itBegin != vOfList.end()){\n            \n                itLoop(itBegin, palindromic, s );\n                ++itBegin;\n            \n                }\n            \n            return palindromic;\n    \n    }\n};\n```\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "shri1403",
                        "content": "hi i was trying to solve this using the concepts of longest common substring and longest palindromic substring,\nhowver it doesnt work for the cases like aadabcadaa. this gives adaa as the ans and not ada. please help me with this\nthe following is my code:\n  string lcsub(string s , string s2){\n        int n=s.size();\n        int m=s2.size();\n         \n         vector<vector<int>> dp(n+1,vector<int>(m+1,0));\n         for(int i=0 ; i<=n;i++){\n             dp[i][0]=0;\n         }\n         for(int j=0; j<=m; j++){\n             dp[0][j]=0;\n         }\n        int maxi=0; int row=0; int col=0;\n         for(int i=1;i<=n;i++){\n             for(int j=1; j<=m ;j++){\n                 if(s[i-1]==s2[j-1]){\n                     dp[i][j]=1+dp[i-1][j-1];\n                     if(dp[i][j]>maxi){\n                         maxi=dp[i][j];\n                         row=i;\n                         col=j;\n                     }\n\n                    } \n                else\n                dp[i][j]=0; // if the continuity is broken then there is no LCS'\n                    \n             }\n         }\n\n        \n         //maxi is the length of the longest commmon palindromic substring\n         \n         //we also have the row and col at which maxi element is found;\n         string ans=\"\";\n         int len=maxi;\n\n\n         while((row>0&&col>0) && len>0){ //added this condition of len>0 beacsyein the second test case bbc print horha tha and this was because humara len=2 ka lcsubstring h par abhi tak row ya col 0 nhi hua tha toh islioye c bhi append hogya\n         //toh matlab yeh h ki jaha tak len h utna hi string me daalo\n               ans+=s[row-1];\n               row--;\n               col--;\n               len--;\n\n         }\n       cout<<maxi;\n        \n         return ans;\n\n\n    }\n    string longestPalindrome(string s) {\n        string s2=s;\n        reverse(s.begin(),s.end());\n        return lcsub(s2,s);\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1963368,
                "content": [
                    {
                        "username": "aylahjomri",
                        "content": "why does it say 141/141 testcases passed but says Time Limit Exceeded and the last executed input is empty ?"
                    },
                    {
                        "username": "CvamReborn_C2R",
                        "content": "Wrong Question some test cases are not right"
                    },
                    {
                        "username": "ak_3101",
                        "content": "okay so is it absolutely normal to get an intuition of writing code in tabular form or everybody first write recursion, and then top down/ bottom up"
                    },
                    {
                        "username": "jfonseca32",
                        "content": "There is something wrong with this question. I made and ran the code in Python and for every test case LeetCode says the code failed on, it works when I run it in Python."
                    },
                    {
                        "username": "timewaster69",
                        "content": "I think the test case s= (nothing) should be removed. It only causes errors and the constraints specifically state that there's at least one character to work with, and that there's specifically alphanumericals to deal with."
                    },
                    {
                        "username": "kevinbiju",
                        "content": "how do we learn to optimize brute force approach\\n"
                    },
                    {
                        "username": "espinosarennieljun",
                        "content": "To solve this you only need to mind two things. \none, Palindrome can't have with more than one even number of character duplicate.\ntwo, all single character should be ignore you only need to add one single character if the result total number is odd. example the total none single character of string is 6 and you can place single character on the middle of the string so it become 7."
                    },
                    {
                        "username": "muraripavansai22",
                        "content": "\"aacabdkacaa\"\\n\\nThis is my output : \"aacakacaa\"\\ngiven this should be expected : \"aca\"\\n\\nThere is some error with this test case\\ncorrect me if im wrong."
                    },
                    {
                        "username": "Ab__23",
                        "content": "\"aacakacaa\" is a subsequence of input string not it's substring, as the question is to find substring that's where you are getting wrong.\nFor example : let string = \"abcdef\"\nit's substrings: 'a' 'ab' 'abc' 'cde' 'abcde' ...\nit's subsequences : 'a' 'ab' 'ac' 'acf' 'abe' ..."
                    },
                    {
                        "username": "TheMystery28",
                        "content": "I've tried and failed enough times to allow myself to see the hints and come up with an optimal solution.\n\nHowever, I'd like to understand why my old code gives a \"time exceeded\" error for \"aacabdkacaa\" when I have made sure to skip the calculation that can be skipped to avoid wasting time.\n\nCould someone please enlighten me?\n\n ```\n#include <algorithm>\n#include <iostream>\n#include <string>\n#include <string_view>\n#include <unordered_map>\n#include <set>\n#include <functional>\n#include <list>\n#include <iterator>\n#include <memory>\n\n\nclass Solution {\n\n    private:\n\n        std::unordered_map<char, std::set<int>> vOfList{};\n\n        int numberOfDifferentLetters{0};\n        int numberOfDifferentLettersBeingMoreThanOne{0};\n        std::vector<char> allOfTheDifferentLetters{};\n\n    public:\n        void itLoop2(std::set<int>::iterator& auto_pLeftItPos,\n                     std::set<int>::iterator& auto_pRightItPos,\n                     int pLeft, int pRight,\n                     std::string& palindromic, const std::string_view& s,\n                     bool trueToStopTheSpetialLoopToLoop){\n                        \n                    if (abs(*auto_pLeftItPos-*auto_pRightItPos)+1<=palindromic.length()) return;\n                    if(s[pLeft] == s[pRight]){\n\n                        if (pLeft==pRight||abs(pLeft - pRight)==1){\n                            palindromic=s.substr(*auto_pLeftItPos,abs(*auto_pLeftItPos-*auto_pRightItPos)+1);\n                        }\n                        else{\n\n\n                        itLoop2(auto_pLeftItPos, auto_pRightItPos,\n                                pLeft+1, pRight-1,palindromic, \n                                s,trueToStopTheSpetialLoopToLoop);}\n                    }\n                    else if (trueToStopTheSpetialLoopToLoop==false){\n                        trueToStopTheSpetialLoopToLoop = true;\n                    \n                        int x{std::abs(static_cast<int>(std::distance(auto_pLeftItPos,auto_pRightItPos)))};\n\n\n                        int c{0};\n\n                        for (int n{x};n>0;--n){\n                            //remainder that auto_pLeftItPos/auto_pRightItPos are in reverse for their iterator\n\n                            if (n==x) {++c;continue;} //If not we wouldn't be here in the first place\n\n\n\n                            int z{n};\n\n                            auto auto_pLeftItPosEdit{std::prev(auto_pLeftItPos,c)};\n\n                            itLoop2(auto_pLeftItPosEdit, auto_pRightItPos,\n                                *auto_pLeftItPosEdit, pRight,\n                                palindromic, \n                                s,trueToStopTheSpetialLoopToLoop);\n\n                            auto auto_pRightItPosEdit{auto_pRightItPos};\n\n                            while(auto_pLeftItPosEdit!=auto_pLeftItPos){\n                                \n                                auto_pLeftItPosEdit = std::next(auto_pLeftItPosEdit,1);\n                                auto_pRightItPosEdit = std::next(auto_pRightItPosEdit, 1);\n\n                                if (abs(*auto_pLeftItPos-*auto_pRightItPos)+1<=palindromic.length()) continue;\n\n                                itLoop2(auto_pLeftItPosEdit, auto_pRightItPosEdit,\n                                *auto_pLeftItPosEdit, *auto_pRightItPosEdit,\n                                palindromic, \n                                s,trueToStopTheSpetialLoopToLoop);\n\n                            }\n\n                            ++c;\n                        }\n\n                    }\n                    else return;\n\n        }\n\n        void itLoop(std::unordered_map<char, std::set<int>>::iterator& itBegin,\n                    std::string& palindromic, const std::string_view& s){\n                    \n\n                bool trueToStopTheSpetialLoopToLoop{false};\n\n            \n                auto *ptr {&((itBegin->second))};\n             \n                std::set<int>::iterator setEnd {ptr->begin()};\n\n\n                std::set<int>::iterator setBegin {ptr->end()};\n\n                std::advance(setBegin, -1);\n                //end() give the iterator AFTER the last element of the container\n\n            int pLeft{*setEnd};\n\n            int pRight{*setBegin};\n\n            if (abs(pLeft-pRight)+1<=palindromic.length()) return;\n\n\n            itLoop2(setEnd, setBegin, pLeft, pRight, palindromic, s, trueToStopTheSpetialLoopToLoop);\n\n\n        }\n\n        std::string longestPalindrome(const std::string_view& s) {\n\n            if (s.length()==0){\n                return \"\";\n            }\n            \n            std::vector<bool> everythingUsed (s.length(), false);\n\n            auto finised{[&]() -> bool {return (std::all_of(everythingUsed.begin(), everythingUsed.end(), [&](bool v) { return v; }));}};\n                \n            for (int x{0}; x<s.length()&&!finised();++x){\n\n\n                        if (everythingUsed[x]==false){\n                            everythingUsed[x]=true;\n\n                            ++numberOfDifferentLetters;\n                            allOfTheDifferentLetters.push_back(s[x]);\n\n\n                            for (int y{x+1};y<s.length()&&!finised();++y){\n                                if (everythingUsed[y]==true) continue;\n\n                                else {\n                                    if (s[x]==s[y]){\n                                        everythingUsed[y]=true;\n                                        vOfList[s[x]].insert({x,y});\n                                        ++numberOfDifferentLettersBeingMoreThanOne;\n                                    }\n                                }\n                            }\n                        }\n                        else continue;\n                    }\n\n            if (numberOfDifferentLettersBeingMoreThanOne==0) {\n                std::string str_ch {s[0]};\n                return str_ch;\n            };\n\n            std::unordered_map<char, std::set<int>>::iterator itBegin {vOfList.begin()};\n        \n\n            \n            std::string palindromic{};\n\n            while(itBegin != vOfList.end()){\n            \n                itLoop(itBegin, palindromic, s );\n                ++itBegin;\n            \n                }\n            \n            return palindromic;\n    \n    }\n};\n```\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "shri1403",
                        "content": "hi i was trying to solve this using the concepts of longest common substring and longest palindromic substring,\nhowver it doesnt work for the cases like aadabcadaa. this gives adaa as the ans and not ada. please help me with this\nthe following is my code:\n  string lcsub(string s , string s2){\n        int n=s.size();\n        int m=s2.size();\n         \n         vector<vector<int>> dp(n+1,vector<int>(m+1,0));\n         for(int i=0 ; i<=n;i++){\n             dp[i][0]=0;\n         }\n         for(int j=0; j<=m; j++){\n             dp[0][j]=0;\n         }\n        int maxi=0; int row=0; int col=0;\n         for(int i=1;i<=n;i++){\n             for(int j=1; j<=m ;j++){\n                 if(s[i-1]==s2[j-1]){\n                     dp[i][j]=1+dp[i-1][j-1];\n                     if(dp[i][j]>maxi){\n                         maxi=dp[i][j];\n                         row=i;\n                         col=j;\n                     }\n\n                    } \n                else\n                dp[i][j]=0; // if the continuity is broken then there is no LCS'\n                    \n             }\n         }\n\n        \n         //maxi is the length of the longest commmon palindromic substring\n         \n         //we also have the row and col at which maxi element is found;\n         string ans=\"\";\n         int len=maxi;\n\n\n         while((row>0&&col>0) && len>0){ //added this condition of len>0 beacsyein the second test case bbc print horha tha and this was because humara len=2 ka lcsubstring h par abhi tak row ya col 0 nhi hua tha toh islioye c bhi append hogya\n         //toh matlab yeh h ki jaha tak len h utna hi string me daalo\n               ans+=s[row-1];\n               row--;\n               col--;\n               len--;\n\n         }\n       cout<<maxi;\n        \n         return ans;\n\n\n    }\n    string longestPalindrome(string s) {\n        string s2=s;\n        reverse(s.begin(),s.end());\n        return lcsub(s2,s);\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1959257,
                "content": [
                    {
                        "username": "Whitchurch",
                        "content": "I did a generic Dynamic Programming approach and hit a TLE.\nHas anyone done Memoization to cut down on redundancies, did that help avoid the TLE.\n\nI used a dictionary for memoization, it worked well. However , i don't know how to use it inside this LongestPalindrome function, without re-creating the dictionary over and over again. Is there a way to check if dictionary already exists and not re-create it.\n\nThanks"
                    },
                    {
                        "username": "Ishan1_1",
                        "content": "for the test case \"aacabdkacaa\" why the correct answer is \"aca\" and not \"aacakacaa\" isnt it the longest palindrome"
                    },
                    {
                        "username": "shuklaprakhar24",
                        "content": "Can we solve in o(n3) ?\\n"
                    },
                    {
                        "username": "nullskill",
                        "content": "I wonder what is the correct output should be for the input string \\'abc\\'? Shall it be \\'a\\', \\'b\\' or \\'c\\' ? Any of the three?"
                    },
                    {
                        "username": "Hritik__k",
                        "content": "Any of the three"
                    },
                    {
                        "username": "alvordar",
                        "content": "Anyone in Java getting 141/141 passed but it says Time Limit Exceeded for a blank input: s = .\\nIn other version I was getting an actual time limit exceeded and the given input but in this case it says all test passed but time limit exceeded.\\nAny idea?"
                    },
                    {
                        "username": "Hritik__k",
                        "content": "try passing the values by ref"
                    },
                    {
                        "username": "MaxiGalaxi",
                        "content": "I dont pass testcase 141, I can\\'t see any character in s"
                    },
                    {
                        "username": "anshh10",
                        "content": "Hi, why is this code not working?\\nclass Solution {\\npublic:\\n    string longestPalindrome(string s) \\n    {\\n        int left,right=0;\\n        int maxLen=1;\\n        string maxString=s.substr(0,1);\\n        for(int i=1;i<s.size();i++)\\n        {\\n            left=i;\\n            right=i;\\n            if(s[i]==s[i-1])\\n            {\\n                left--;\\n                while(left>=0 && right<=s.size()-1 && s[left]==s[right])\\n                {\\n                    if(right-left+1>=maxLen)\\n                    {\\n                        maxString=s.substr(left,right+1);\\n                        cout<<maxString<<endl;\\n                        maxLen=right-left+1;\\n                    }\\n                    left--;\\n                    right++;\\n                }\\n            }\\n            else\\n            {\\n                while(left>=0 && right<=s.size()-1 && s[left]==s[right])\\n                {\\n                    if(right-left+1>=maxLen)\\n                    {\\n                        maxString=s.substr(left,right);\\n                        cout<<maxString<<endl;\\n                        maxLen=right-left+1;\\n                    }\\n                    left--;\\n                    right++;\\n                }\\n            }\\n        }\\n        return maxString;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "slucker",
                        "content": "I solved this problem for the first submit by brute-force and beat >60%.\\nJust try to think in every position you will a Palindromic, move left and right to get the Longest match.\\nWe only have two case for each: left=i-1, r=i+1 and left=i, right=i+1;\\nTotal is O(n^2) complexity, O(1) space.\\n"
                    },
                    {
                        "username": "kazangeorg",
                        "content": "Wrong Answer\n\n87 / 141 testcases passed\nInput\ns =\n\"aacabdkacaa\"\nUse Testcase\nOutput\n\"aaca\"\nExpected\n\"aca\"\n\n\nWhy???"
                    },
                    {
                        "username": "dav3th3t3chg33k",
                        "content": "easy problem to solve\\n"
                    }
                ]
            },
            {
                "id": 1955166,
                "content": [
                    {
                        "username": "Whitchurch",
                        "content": "I did a generic Dynamic Programming approach and hit a TLE.\nHas anyone done Memoization to cut down on redundancies, did that help avoid the TLE.\n\nI used a dictionary for memoization, it worked well. However , i don't know how to use it inside this LongestPalindrome function, without re-creating the dictionary over and over again. Is there a way to check if dictionary already exists and not re-create it.\n\nThanks"
                    },
                    {
                        "username": "Ishan1_1",
                        "content": "for the test case \"aacabdkacaa\" why the correct answer is \"aca\" and not \"aacakacaa\" isnt it the longest palindrome"
                    },
                    {
                        "username": "shuklaprakhar24",
                        "content": "Can we solve in o(n3) ?\\n"
                    },
                    {
                        "username": "nullskill",
                        "content": "I wonder what is the correct output should be for the input string \\'abc\\'? Shall it be \\'a\\', \\'b\\' or \\'c\\' ? Any of the three?"
                    },
                    {
                        "username": "Hritik__k",
                        "content": "Any of the three"
                    },
                    {
                        "username": "alvordar",
                        "content": "Anyone in Java getting 141/141 passed but it says Time Limit Exceeded for a blank input: s = .\\nIn other version I was getting an actual time limit exceeded and the given input but in this case it says all test passed but time limit exceeded.\\nAny idea?"
                    },
                    {
                        "username": "Hritik__k",
                        "content": "try passing the values by ref"
                    },
                    {
                        "username": "MaxiGalaxi",
                        "content": "I dont pass testcase 141, I can\\'t see any character in s"
                    },
                    {
                        "username": "anshh10",
                        "content": "Hi, why is this code not working?\\nclass Solution {\\npublic:\\n    string longestPalindrome(string s) \\n    {\\n        int left,right=0;\\n        int maxLen=1;\\n        string maxString=s.substr(0,1);\\n        for(int i=1;i<s.size();i++)\\n        {\\n            left=i;\\n            right=i;\\n            if(s[i]==s[i-1])\\n            {\\n                left--;\\n                while(left>=0 && right<=s.size()-1 && s[left]==s[right])\\n                {\\n                    if(right-left+1>=maxLen)\\n                    {\\n                        maxString=s.substr(left,right+1);\\n                        cout<<maxString<<endl;\\n                        maxLen=right-left+1;\\n                    }\\n                    left--;\\n                    right++;\\n                }\\n            }\\n            else\\n            {\\n                while(left>=0 && right<=s.size()-1 && s[left]==s[right])\\n                {\\n                    if(right-left+1>=maxLen)\\n                    {\\n                        maxString=s.substr(left,right);\\n                        cout<<maxString<<endl;\\n                        maxLen=right-left+1;\\n                    }\\n                    left--;\\n                    right++;\\n                }\\n            }\\n        }\\n        return maxString;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "slucker",
                        "content": "I solved this problem for the first submit by brute-force and beat >60%.\\nJust try to think in every position you will a Palindromic, move left and right to get the Longest match.\\nWe only have two case for each: left=i-1, r=i+1 and left=i, right=i+1;\\nTotal is O(n^2) complexity, O(1) space.\\n"
                    },
                    {
                        "username": "kazangeorg",
                        "content": "Wrong Answer\n\n87 / 141 testcases passed\nInput\ns =\n\"aacabdkacaa\"\nUse Testcase\nOutput\n\"aaca\"\nExpected\n\"aca\"\n\n\nWhy???"
                    },
                    {
                        "username": "dav3th3t3chg33k",
                        "content": "easy problem to solve\\n"
                    }
                ]
            },
            {
                "id": 1946438,
                "content": [
                    {
                        "username": "Whitchurch",
                        "content": "I did a generic Dynamic Programming approach and hit a TLE.\nHas anyone done Memoization to cut down on redundancies, did that help avoid the TLE.\n\nI used a dictionary for memoization, it worked well. However , i don't know how to use it inside this LongestPalindrome function, without re-creating the dictionary over and over again. Is there a way to check if dictionary already exists and not re-create it.\n\nThanks"
                    },
                    {
                        "username": "Ishan1_1",
                        "content": "for the test case \"aacabdkacaa\" why the correct answer is \"aca\" and not \"aacakacaa\" isnt it the longest palindrome"
                    },
                    {
                        "username": "shuklaprakhar24",
                        "content": "Can we solve in o(n3) ?\\n"
                    },
                    {
                        "username": "nullskill",
                        "content": "I wonder what is the correct output should be for the input string \\'abc\\'? Shall it be \\'a\\', \\'b\\' or \\'c\\' ? Any of the three?"
                    },
                    {
                        "username": "Hritik__k",
                        "content": "Any of the three"
                    },
                    {
                        "username": "alvordar",
                        "content": "Anyone in Java getting 141/141 passed but it says Time Limit Exceeded for a blank input: s = .\\nIn other version I was getting an actual time limit exceeded and the given input but in this case it says all test passed but time limit exceeded.\\nAny idea?"
                    },
                    {
                        "username": "Hritik__k",
                        "content": "try passing the values by ref"
                    },
                    {
                        "username": "MaxiGalaxi",
                        "content": "I dont pass testcase 141, I can\\'t see any character in s"
                    },
                    {
                        "username": "anshh10",
                        "content": "Hi, why is this code not working?\\nclass Solution {\\npublic:\\n    string longestPalindrome(string s) \\n    {\\n        int left,right=0;\\n        int maxLen=1;\\n        string maxString=s.substr(0,1);\\n        for(int i=1;i<s.size();i++)\\n        {\\n            left=i;\\n            right=i;\\n            if(s[i]==s[i-1])\\n            {\\n                left--;\\n                while(left>=0 && right<=s.size()-1 && s[left]==s[right])\\n                {\\n                    if(right-left+1>=maxLen)\\n                    {\\n                        maxString=s.substr(left,right+1);\\n                        cout<<maxString<<endl;\\n                        maxLen=right-left+1;\\n                    }\\n                    left--;\\n                    right++;\\n                }\\n            }\\n            else\\n            {\\n                while(left>=0 && right<=s.size()-1 && s[left]==s[right])\\n                {\\n                    if(right-left+1>=maxLen)\\n                    {\\n                        maxString=s.substr(left,right);\\n                        cout<<maxString<<endl;\\n                        maxLen=right-left+1;\\n                    }\\n                    left--;\\n                    right++;\\n                }\\n            }\\n        }\\n        return maxString;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "slucker",
                        "content": "I solved this problem for the first submit by brute-force and beat >60%.\\nJust try to think in every position you will a Palindromic, move left and right to get the Longest match.\\nWe only have two case for each: left=i-1, r=i+1 and left=i, right=i+1;\\nTotal is O(n^2) complexity, O(1) space.\\n"
                    },
                    {
                        "username": "kazangeorg",
                        "content": "Wrong Answer\n\n87 / 141 testcases passed\nInput\ns =\n\"aacabdkacaa\"\nUse Testcase\nOutput\n\"aaca\"\nExpected\n\"aca\"\n\n\nWhy???"
                    },
                    {
                        "username": "dav3th3t3chg33k",
                        "content": "easy problem to solve\\n"
                    }
                ]
            },
            {
                "id": 1942062,
                "content": [
                    {
                        "username": "Whitchurch",
                        "content": "I did a generic Dynamic Programming approach and hit a TLE.\nHas anyone done Memoization to cut down on redundancies, did that help avoid the TLE.\n\nI used a dictionary for memoization, it worked well. However , i don't know how to use it inside this LongestPalindrome function, without re-creating the dictionary over and over again. Is there a way to check if dictionary already exists and not re-create it.\n\nThanks"
                    },
                    {
                        "username": "Ishan1_1",
                        "content": "for the test case \"aacabdkacaa\" why the correct answer is \"aca\" and not \"aacakacaa\" isnt it the longest palindrome"
                    },
                    {
                        "username": "shuklaprakhar24",
                        "content": "Can we solve in o(n3) ?\\n"
                    },
                    {
                        "username": "nullskill",
                        "content": "I wonder what is the correct output should be for the input string \\'abc\\'? Shall it be \\'a\\', \\'b\\' or \\'c\\' ? Any of the three?"
                    },
                    {
                        "username": "Hritik__k",
                        "content": "Any of the three"
                    },
                    {
                        "username": "alvordar",
                        "content": "Anyone in Java getting 141/141 passed but it says Time Limit Exceeded for a blank input: s = .\\nIn other version I was getting an actual time limit exceeded and the given input but in this case it says all test passed but time limit exceeded.\\nAny idea?"
                    },
                    {
                        "username": "Hritik__k",
                        "content": "try passing the values by ref"
                    },
                    {
                        "username": "MaxiGalaxi",
                        "content": "I dont pass testcase 141, I can\\'t see any character in s"
                    },
                    {
                        "username": "anshh10",
                        "content": "Hi, why is this code not working?\\nclass Solution {\\npublic:\\n    string longestPalindrome(string s) \\n    {\\n        int left,right=0;\\n        int maxLen=1;\\n        string maxString=s.substr(0,1);\\n        for(int i=1;i<s.size();i++)\\n        {\\n            left=i;\\n            right=i;\\n            if(s[i]==s[i-1])\\n            {\\n                left--;\\n                while(left>=0 && right<=s.size()-1 && s[left]==s[right])\\n                {\\n                    if(right-left+1>=maxLen)\\n                    {\\n                        maxString=s.substr(left,right+1);\\n                        cout<<maxString<<endl;\\n                        maxLen=right-left+1;\\n                    }\\n                    left--;\\n                    right++;\\n                }\\n            }\\n            else\\n            {\\n                while(left>=0 && right<=s.size()-1 && s[left]==s[right])\\n                {\\n                    if(right-left+1>=maxLen)\\n                    {\\n                        maxString=s.substr(left,right);\\n                        cout<<maxString<<endl;\\n                        maxLen=right-left+1;\\n                    }\\n                    left--;\\n                    right++;\\n                }\\n            }\\n        }\\n        return maxString;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "slucker",
                        "content": "I solved this problem for the first submit by brute-force and beat >60%.\\nJust try to think in every position you will a Palindromic, move left and right to get the Longest match.\\nWe only have two case for each: left=i-1, r=i+1 and left=i, right=i+1;\\nTotal is O(n^2) complexity, O(1) space.\\n"
                    },
                    {
                        "username": "kazangeorg",
                        "content": "Wrong Answer\n\n87 / 141 testcases passed\nInput\ns =\n\"aacabdkacaa\"\nUse Testcase\nOutput\n\"aaca\"\nExpected\n\"aca\"\n\n\nWhy???"
                    },
                    {
                        "username": "dav3th3t3chg33k",
                        "content": "easy problem to solve\\n"
                    }
                ]
            },
            {
                "id": 1941651,
                "content": [
                    {
                        "username": "Whitchurch",
                        "content": "I did a generic Dynamic Programming approach and hit a TLE.\nHas anyone done Memoization to cut down on redundancies, did that help avoid the TLE.\n\nI used a dictionary for memoization, it worked well. However , i don't know how to use it inside this LongestPalindrome function, without re-creating the dictionary over and over again. Is there a way to check if dictionary already exists and not re-create it.\n\nThanks"
                    },
                    {
                        "username": "Ishan1_1",
                        "content": "for the test case \"aacabdkacaa\" why the correct answer is \"aca\" and not \"aacakacaa\" isnt it the longest palindrome"
                    },
                    {
                        "username": "shuklaprakhar24",
                        "content": "Can we solve in o(n3) ?\\n"
                    },
                    {
                        "username": "nullskill",
                        "content": "I wonder what is the correct output should be for the input string \\'abc\\'? Shall it be \\'a\\', \\'b\\' or \\'c\\' ? Any of the three?"
                    },
                    {
                        "username": "Hritik__k",
                        "content": "Any of the three"
                    },
                    {
                        "username": "alvordar",
                        "content": "Anyone in Java getting 141/141 passed but it says Time Limit Exceeded for a blank input: s = .\\nIn other version I was getting an actual time limit exceeded and the given input but in this case it says all test passed but time limit exceeded.\\nAny idea?"
                    },
                    {
                        "username": "Hritik__k",
                        "content": "try passing the values by ref"
                    },
                    {
                        "username": "MaxiGalaxi",
                        "content": "I dont pass testcase 141, I can\\'t see any character in s"
                    },
                    {
                        "username": "anshh10",
                        "content": "Hi, why is this code not working?\\nclass Solution {\\npublic:\\n    string longestPalindrome(string s) \\n    {\\n        int left,right=0;\\n        int maxLen=1;\\n        string maxString=s.substr(0,1);\\n        for(int i=1;i<s.size();i++)\\n        {\\n            left=i;\\n            right=i;\\n            if(s[i]==s[i-1])\\n            {\\n                left--;\\n                while(left>=0 && right<=s.size()-1 && s[left]==s[right])\\n                {\\n                    if(right-left+1>=maxLen)\\n                    {\\n                        maxString=s.substr(left,right+1);\\n                        cout<<maxString<<endl;\\n                        maxLen=right-left+1;\\n                    }\\n                    left--;\\n                    right++;\\n                }\\n            }\\n            else\\n            {\\n                while(left>=0 && right<=s.size()-1 && s[left]==s[right])\\n                {\\n                    if(right-left+1>=maxLen)\\n                    {\\n                        maxString=s.substr(left,right);\\n                        cout<<maxString<<endl;\\n                        maxLen=right-left+1;\\n                    }\\n                    left--;\\n                    right++;\\n                }\\n            }\\n        }\\n        return maxString;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "slucker",
                        "content": "I solved this problem for the first submit by brute-force and beat >60%.\\nJust try to think in every position you will a Palindromic, move left and right to get the Longest match.\\nWe only have two case for each: left=i-1, r=i+1 and left=i, right=i+1;\\nTotal is O(n^2) complexity, O(1) space.\\n"
                    },
                    {
                        "username": "kazangeorg",
                        "content": "Wrong Answer\n\n87 / 141 testcases passed\nInput\ns =\n\"aacabdkacaa\"\nUse Testcase\nOutput\n\"aaca\"\nExpected\n\"aca\"\n\n\nWhy???"
                    },
                    {
                        "username": "dav3th3t3chg33k",
                        "content": "easy problem to solve\\n"
                    }
                ]
            },
            {
                "id": 1939791,
                "content": [
                    {
                        "username": "Whitchurch",
                        "content": "I did a generic Dynamic Programming approach and hit a TLE.\nHas anyone done Memoization to cut down on redundancies, did that help avoid the TLE.\n\nI used a dictionary for memoization, it worked well. However , i don't know how to use it inside this LongestPalindrome function, without re-creating the dictionary over and over again. Is there a way to check if dictionary already exists and not re-create it.\n\nThanks"
                    },
                    {
                        "username": "Ishan1_1",
                        "content": "for the test case \"aacabdkacaa\" why the correct answer is \"aca\" and not \"aacakacaa\" isnt it the longest palindrome"
                    },
                    {
                        "username": "shuklaprakhar24",
                        "content": "Can we solve in o(n3) ?\\n"
                    },
                    {
                        "username": "nullskill",
                        "content": "I wonder what is the correct output should be for the input string \\'abc\\'? Shall it be \\'a\\', \\'b\\' or \\'c\\' ? Any of the three?"
                    },
                    {
                        "username": "Hritik__k",
                        "content": "Any of the three"
                    },
                    {
                        "username": "alvordar",
                        "content": "Anyone in Java getting 141/141 passed but it says Time Limit Exceeded for a blank input: s = .\\nIn other version I was getting an actual time limit exceeded and the given input but in this case it says all test passed but time limit exceeded.\\nAny idea?"
                    },
                    {
                        "username": "Hritik__k",
                        "content": "try passing the values by ref"
                    },
                    {
                        "username": "MaxiGalaxi",
                        "content": "I dont pass testcase 141, I can\\'t see any character in s"
                    },
                    {
                        "username": "anshh10",
                        "content": "Hi, why is this code not working?\\nclass Solution {\\npublic:\\n    string longestPalindrome(string s) \\n    {\\n        int left,right=0;\\n        int maxLen=1;\\n        string maxString=s.substr(0,1);\\n        for(int i=1;i<s.size();i++)\\n        {\\n            left=i;\\n            right=i;\\n            if(s[i]==s[i-1])\\n            {\\n                left--;\\n                while(left>=0 && right<=s.size()-1 && s[left]==s[right])\\n                {\\n                    if(right-left+1>=maxLen)\\n                    {\\n                        maxString=s.substr(left,right+1);\\n                        cout<<maxString<<endl;\\n                        maxLen=right-left+1;\\n                    }\\n                    left--;\\n                    right++;\\n                }\\n            }\\n            else\\n            {\\n                while(left>=0 && right<=s.size()-1 && s[left]==s[right])\\n                {\\n                    if(right-left+1>=maxLen)\\n                    {\\n                        maxString=s.substr(left,right);\\n                        cout<<maxString<<endl;\\n                        maxLen=right-left+1;\\n                    }\\n                    left--;\\n                    right++;\\n                }\\n            }\\n        }\\n        return maxString;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "slucker",
                        "content": "I solved this problem for the first submit by brute-force and beat >60%.\\nJust try to think in every position you will a Palindromic, move left and right to get the Longest match.\\nWe only have two case for each: left=i-1, r=i+1 and left=i, right=i+1;\\nTotal is O(n^2) complexity, O(1) space.\\n"
                    },
                    {
                        "username": "kazangeorg",
                        "content": "Wrong Answer\n\n87 / 141 testcases passed\nInput\ns =\n\"aacabdkacaa\"\nUse Testcase\nOutput\n\"aaca\"\nExpected\n\"aca\"\n\n\nWhy???"
                    },
                    {
                        "username": "dav3th3t3chg33k",
                        "content": "easy problem to solve\\n"
                    }
                ]
            },
            {
                "id": 1935672,
                "content": [
                    {
                        "username": "Whitchurch",
                        "content": "I did a generic Dynamic Programming approach and hit a TLE.\nHas anyone done Memoization to cut down on redundancies, did that help avoid the TLE.\n\nI used a dictionary for memoization, it worked well. However , i don't know how to use it inside this LongestPalindrome function, without re-creating the dictionary over and over again. Is there a way to check if dictionary already exists and not re-create it.\n\nThanks"
                    },
                    {
                        "username": "Ishan1_1",
                        "content": "for the test case \"aacabdkacaa\" why the correct answer is \"aca\" and not \"aacakacaa\" isnt it the longest palindrome"
                    },
                    {
                        "username": "shuklaprakhar24",
                        "content": "Can we solve in o(n3) ?\\n"
                    },
                    {
                        "username": "nullskill",
                        "content": "I wonder what is the correct output should be for the input string \\'abc\\'? Shall it be \\'a\\', \\'b\\' or \\'c\\' ? Any of the three?"
                    },
                    {
                        "username": "Hritik__k",
                        "content": "Any of the three"
                    },
                    {
                        "username": "alvordar",
                        "content": "Anyone in Java getting 141/141 passed but it says Time Limit Exceeded for a blank input: s = .\\nIn other version I was getting an actual time limit exceeded and the given input but in this case it says all test passed but time limit exceeded.\\nAny idea?"
                    },
                    {
                        "username": "Hritik__k",
                        "content": "try passing the values by ref"
                    },
                    {
                        "username": "MaxiGalaxi",
                        "content": "I dont pass testcase 141, I can\\'t see any character in s"
                    },
                    {
                        "username": "anshh10",
                        "content": "Hi, why is this code not working?\\nclass Solution {\\npublic:\\n    string longestPalindrome(string s) \\n    {\\n        int left,right=0;\\n        int maxLen=1;\\n        string maxString=s.substr(0,1);\\n        for(int i=1;i<s.size();i++)\\n        {\\n            left=i;\\n            right=i;\\n            if(s[i]==s[i-1])\\n            {\\n                left--;\\n                while(left>=0 && right<=s.size()-1 && s[left]==s[right])\\n                {\\n                    if(right-left+1>=maxLen)\\n                    {\\n                        maxString=s.substr(left,right+1);\\n                        cout<<maxString<<endl;\\n                        maxLen=right-left+1;\\n                    }\\n                    left--;\\n                    right++;\\n                }\\n            }\\n            else\\n            {\\n                while(left>=0 && right<=s.size()-1 && s[left]==s[right])\\n                {\\n                    if(right-left+1>=maxLen)\\n                    {\\n                        maxString=s.substr(left,right);\\n                        cout<<maxString<<endl;\\n                        maxLen=right-left+1;\\n                    }\\n                    left--;\\n                    right++;\\n                }\\n            }\\n        }\\n        return maxString;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "slucker",
                        "content": "I solved this problem for the first submit by brute-force and beat >60%.\\nJust try to think in every position you will a Palindromic, move left and right to get the Longest match.\\nWe only have two case for each: left=i-1, r=i+1 and left=i, right=i+1;\\nTotal is O(n^2) complexity, O(1) space.\\n"
                    },
                    {
                        "username": "kazangeorg",
                        "content": "Wrong Answer\n\n87 / 141 testcases passed\nInput\ns =\n\"aacabdkacaa\"\nUse Testcase\nOutput\n\"aaca\"\nExpected\n\"aca\"\n\n\nWhy???"
                    },
                    {
                        "username": "dav3th3t3chg33k",
                        "content": "easy problem to solve\\n"
                    }
                ]
            },
            {
                "id": 1930093,
                "content": [
                    {
                        "username": "Whitchurch",
                        "content": "I did a generic Dynamic Programming approach and hit a TLE.\nHas anyone done Memoization to cut down on redundancies, did that help avoid the TLE.\n\nI used a dictionary for memoization, it worked well. However , i don't know how to use it inside this LongestPalindrome function, without re-creating the dictionary over and over again. Is there a way to check if dictionary already exists and not re-create it.\n\nThanks"
                    },
                    {
                        "username": "Ishan1_1",
                        "content": "for the test case \"aacabdkacaa\" why the correct answer is \"aca\" and not \"aacakacaa\" isnt it the longest palindrome"
                    },
                    {
                        "username": "shuklaprakhar24",
                        "content": "Can we solve in o(n3) ?\\n"
                    },
                    {
                        "username": "nullskill",
                        "content": "I wonder what is the correct output should be for the input string \\'abc\\'? Shall it be \\'a\\', \\'b\\' or \\'c\\' ? Any of the three?"
                    },
                    {
                        "username": "Hritik__k",
                        "content": "Any of the three"
                    },
                    {
                        "username": "alvordar",
                        "content": "Anyone in Java getting 141/141 passed but it says Time Limit Exceeded for a blank input: s = .\\nIn other version I was getting an actual time limit exceeded and the given input but in this case it says all test passed but time limit exceeded.\\nAny idea?"
                    },
                    {
                        "username": "Hritik__k",
                        "content": "try passing the values by ref"
                    },
                    {
                        "username": "MaxiGalaxi",
                        "content": "I dont pass testcase 141, I can\\'t see any character in s"
                    },
                    {
                        "username": "anshh10",
                        "content": "Hi, why is this code not working?\\nclass Solution {\\npublic:\\n    string longestPalindrome(string s) \\n    {\\n        int left,right=0;\\n        int maxLen=1;\\n        string maxString=s.substr(0,1);\\n        for(int i=1;i<s.size();i++)\\n        {\\n            left=i;\\n            right=i;\\n            if(s[i]==s[i-1])\\n            {\\n                left--;\\n                while(left>=0 && right<=s.size()-1 && s[left]==s[right])\\n                {\\n                    if(right-left+1>=maxLen)\\n                    {\\n                        maxString=s.substr(left,right+1);\\n                        cout<<maxString<<endl;\\n                        maxLen=right-left+1;\\n                    }\\n                    left--;\\n                    right++;\\n                }\\n            }\\n            else\\n            {\\n                while(left>=0 && right<=s.size()-1 && s[left]==s[right])\\n                {\\n                    if(right-left+1>=maxLen)\\n                    {\\n                        maxString=s.substr(left,right);\\n                        cout<<maxString<<endl;\\n                        maxLen=right-left+1;\\n                    }\\n                    left--;\\n                    right++;\\n                }\\n            }\\n        }\\n        return maxString;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "slucker",
                        "content": "I solved this problem for the first submit by brute-force and beat >60%.\\nJust try to think in every position you will a Palindromic, move left and right to get the Longest match.\\nWe only have two case for each: left=i-1, r=i+1 and left=i, right=i+1;\\nTotal is O(n^2) complexity, O(1) space.\\n"
                    },
                    {
                        "username": "kazangeorg",
                        "content": "Wrong Answer\n\n87 / 141 testcases passed\nInput\ns =\n\"aacabdkacaa\"\nUse Testcase\nOutput\n\"aaca\"\nExpected\n\"aca\"\n\n\nWhy???"
                    },
                    {
                        "username": "dav3th3t3chg33k",
                        "content": "easy problem to solve\\n"
                    }
                ]
            },
            {
                "id": 1921441,
                "content": [
                    {
                        "username": "Whitchurch",
                        "content": "I did a generic Dynamic Programming approach and hit a TLE.\nHas anyone done Memoization to cut down on redundancies, did that help avoid the TLE.\n\nI used a dictionary for memoization, it worked well. However , i don't know how to use it inside this LongestPalindrome function, without re-creating the dictionary over and over again. Is there a way to check if dictionary already exists and not re-create it.\n\nThanks"
                    },
                    {
                        "username": "Ishan1_1",
                        "content": "for the test case \"aacabdkacaa\" why the correct answer is \"aca\" and not \"aacakacaa\" isnt it the longest palindrome"
                    },
                    {
                        "username": "shuklaprakhar24",
                        "content": "Can we solve in o(n3) ?\\n"
                    },
                    {
                        "username": "nullskill",
                        "content": "I wonder what is the correct output should be for the input string \\'abc\\'? Shall it be \\'a\\', \\'b\\' or \\'c\\' ? Any of the three?"
                    },
                    {
                        "username": "Hritik__k",
                        "content": "Any of the three"
                    },
                    {
                        "username": "alvordar",
                        "content": "Anyone in Java getting 141/141 passed but it says Time Limit Exceeded for a blank input: s = .\\nIn other version I was getting an actual time limit exceeded and the given input but in this case it says all test passed but time limit exceeded.\\nAny idea?"
                    },
                    {
                        "username": "Hritik__k",
                        "content": "try passing the values by ref"
                    },
                    {
                        "username": "MaxiGalaxi",
                        "content": "I dont pass testcase 141, I can\\'t see any character in s"
                    },
                    {
                        "username": "anshh10",
                        "content": "Hi, why is this code not working?\\nclass Solution {\\npublic:\\n    string longestPalindrome(string s) \\n    {\\n        int left,right=0;\\n        int maxLen=1;\\n        string maxString=s.substr(0,1);\\n        for(int i=1;i<s.size();i++)\\n        {\\n            left=i;\\n            right=i;\\n            if(s[i]==s[i-1])\\n            {\\n                left--;\\n                while(left>=0 && right<=s.size()-1 && s[left]==s[right])\\n                {\\n                    if(right-left+1>=maxLen)\\n                    {\\n                        maxString=s.substr(left,right+1);\\n                        cout<<maxString<<endl;\\n                        maxLen=right-left+1;\\n                    }\\n                    left--;\\n                    right++;\\n                }\\n            }\\n            else\\n            {\\n                while(left>=0 && right<=s.size()-1 && s[left]==s[right])\\n                {\\n                    if(right-left+1>=maxLen)\\n                    {\\n                        maxString=s.substr(left,right);\\n                        cout<<maxString<<endl;\\n                        maxLen=right-left+1;\\n                    }\\n                    left--;\\n                    right++;\\n                }\\n            }\\n        }\\n        return maxString;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "slucker",
                        "content": "I solved this problem for the first submit by brute-force and beat >60%.\\nJust try to think in every position you will a Palindromic, move left and right to get the Longest match.\\nWe only have two case for each: left=i-1, r=i+1 and left=i, right=i+1;\\nTotal is O(n^2) complexity, O(1) space.\\n"
                    },
                    {
                        "username": "kazangeorg",
                        "content": "Wrong Answer\n\n87 / 141 testcases passed\nInput\ns =\n\"aacabdkacaa\"\nUse Testcase\nOutput\n\"aaca\"\nExpected\n\"aca\"\n\n\nWhy???"
                    },
                    {
                        "username": "dav3th3t3chg33k",
                        "content": "easy problem to solve\\n"
                    }
                ]
            },
            {
                "id": 1918683,
                "content": [
                    {
                        "username": "Whitchurch",
                        "content": "I did a generic Dynamic Programming approach and hit a TLE.\nHas anyone done Memoization to cut down on redundancies, did that help avoid the TLE.\n\nI used a dictionary for memoization, it worked well. However , i don't know how to use it inside this LongestPalindrome function, without re-creating the dictionary over and over again. Is there a way to check if dictionary already exists and not re-create it.\n\nThanks"
                    },
                    {
                        "username": "Ishan1_1",
                        "content": "for the test case \"aacabdkacaa\" why the correct answer is \"aca\" and not \"aacakacaa\" isnt it the longest palindrome"
                    },
                    {
                        "username": "shuklaprakhar24",
                        "content": "Can we solve in o(n3) ?\\n"
                    },
                    {
                        "username": "nullskill",
                        "content": "I wonder what is the correct output should be for the input string \\'abc\\'? Shall it be \\'a\\', \\'b\\' or \\'c\\' ? Any of the three?"
                    },
                    {
                        "username": "Hritik__k",
                        "content": "Any of the three"
                    },
                    {
                        "username": "alvordar",
                        "content": "Anyone in Java getting 141/141 passed but it says Time Limit Exceeded for a blank input: s = .\\nIn other version I was getting an actual time limit exceeded and the given input but in this case it says all test passed but time limit exceeded.\\nAny idea?"
                    },
                    {
                        "username": "Hritik__k",
                        "content": "try passing the values by ref"
                    },
                    {
                        "username": "MaxiGalaxi",
                        "content": "I dont pass testcase 141, I can\\'t see any character in s"
                    },
                    {
                        "username": "anshh10",
                        "content": "Hi, why is this code not working?\\nclass Solution {\\npublic:\\n    string longestPalindrome(string s) \\n    {\\n        int left,right=0;\\n        int maxLen=1;\\n        string maxString=s.substr(0,1);\\n        for(int i=1;i<s.size();i++)\\n        {\\n            left=i;\\n            right=i;\\n            if(s[i]==s[i-1])\\n            {\\n                left--;\\n                while(left>=0 && right<=s.size()-1 && s[left]==s[right])\\n                {\\n                    if(right-left+1>=maxLen)\\n                    {\\n                        maxString=s.substr(left,right+1);\\n                        cout<<maxString<<endl;\\n                        maxLen=right-left+1;\\n                    }\\n                    left--;\\n                    right++;\\n                }\\n            }\\n            else\\n            {\\n                while(left>=0 && right<=s.size()-1 && s[left]==s[right])\\n                {\\n                    if(right-left+1>=maxLen)\\n                    {\\n                        maxString=s.substr(left,right);\\n                        cout<<maxString<<endl;\\n                        maxLen=right-left+1;\\n                    }\\n                    left--;\\n                    right++;\\n                }\\n            }\\n        }\\n        return maxString;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "slucker",
                        "content": "I solved this problem for the first submit by brute-force and beat >60%.\\nJust try to think in every position you will a Palindromic, move left and right to get the Longest match.\\nWe only have two case for each: left=i-1, r=i+1 and left=i, right=i+1;\\nTotal is O(n^2) complexity, O(1) space.\\n"
                    },
                    {
                        "username": "kazangeorg",
                        "content": "Wrong Answer\n\n87 / 141 testcases passed\nInput\ns =\n\"aacabdkacaa\"\nUse Testcase\nOutput\n\"aaca\"\nExpected\n\"aca\"\n\n\nWhy???"
                    },
                    {
                        "username": "dav3th3t3chg33k",
                        "content": "easy problem to solve\\n"
                    }
                ]
            },
            {
                "id": 1902313,
                "content": [
                    {
                        "username": "user7351F",
                        "content": "class Solution {\\n    public String longestPalindrome(String s) {\\n    int i = 0;\\n     if(1 <= s.length() && s.length() <= 1000){\\n       if(s.length() == 1 || s.length() == 0){\\n           return s;\\n       }\\n       if(isPalindrome(s)){\\n         String new_str = s.substring(i+1,s.length()-1);\\n         longestPalindrome(new_str);\\n         \\n         \\n       } \\n       else{\\n           String new_str1 = s.substring(i,s.length()-1); \\n          longestPalindrome(new_str1);\\n          \\n          \\n       } \\n     }\\n     return s;\\n    }\\n     boolean isPalindrome(String s1){\\n       int a = 0;\\n       int j = s1.length() - 1;\\n       while(a <= j){\\n         if(s1.charAt(a) != s1.charAt(j)){\\n           return false;\\n         }\\n         \\n         a++;\\n         j--;\\n       }\\n       return true;\\n     }  \\n}\\nCAn someone explain what is wrong in my code?"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Posting your solution in discussions is wrong"
                    },
                    {
                        "username": "Mookambika8",
                        "content": "Hello Leetcoders,\\n\\nI have a basic question in the understanding of the logic that needs to be followed for solving this problem without brute force.\\n\\nI have the below approach in mind:\\n\\nwhen you get the longest length, \\n1. we need to get the palindrome with that length.\\n2. We need to reduce length to be checked by -1\\n3. shift left the window by 1 by fixing the end and moving only left index by 1 until there is only value 1 difference between start and end while end > start\\n4. shift left the window by 1 by fixing the end and moving only right index by 1 until there is only value 1 difference between start and end while end > start\\n5. the above to loop around until we have the i reaching end of the string.\\n\\nCan you please review this approach and let me know if this is good enough for the solution or I got the whole idea wrong."
                    },
                    {
                        "username": "KaleemRazaSyedJ",
                        "content": "How are you finding the length of the longest paldromic substring?\n"
                    },
                    {
                        "username": "rohitrangde",
                        "content": "Wrong Answer\\n\\nInput\\ns =\\n\"aacabdkacaa\"\\n\\nOutput\\n\"aacakacaa\"\\nExpected\\n\"aca\"\\n\\nis it wrong output ?\\n"
                    },
                    {
                        "username": "KaleemRazaSyedJ",
                        "content": "Your answer is aacakacaa is incorrect because we are asked for substring not subsequence."
                    },
                    {
                        "username": "anj20",
                        "content": "can we do this in a tc better than O(N^2)?"
                    },
                    {
                        "username": "espinosarennieljun",
                        "content": "I always ended up hitting the time limit exceeded error. "
                    },
                    {
                        "username": "PrashanthVR",
                        "content": "For one particular testcase while submitting, the compiler shows run time exceeded. But when I give that particular test case manually, it passes. HOw?\\n\\n"
                    },
                    {
                        "username": "joinfanng",
                        "content": "how the testcase \"ac\" works???\\nideally it should return nuthimg"
                    },
                    {
                        "username": "chibi_chihiro",
                        "content": "You can just use brute force if you are struggling :p"
                    },
                    {
                        "username": "balakrishna_95",
                        "content": "class Solution {\\n\\t  static boolean h(String s)\\n    {\\n    \\tString j=\"\";\\n    \\tfor(int i=s.length()-1;i>=0;i--)\\n    \\t{\\n    \\t\\tj=j+s.charAt(i);\\n    \\t}\\n    \\tif(j.equals(s))\\n    \\t{\\n    \\t\\treturn true;\\n    \\t}\\n    \\treturn false;\\n    }\\n\\tpublic String longestPalindrome(String s){\\n        int max=1;\\n        int start=0;\\n        for(int i=0;i<s.length();i++)\\n        {\\n        \\tfor(int j=i;j<s.length();j++)\\n        \\t{\\n        \\t\\tif(h(s.substring(i,j+1)))\\n        \\t\\t{\\n        \\t\\t\\tif(j-i+1>max)\\n        \\t\\t\\t{\\n        \\t\\t\\t  start=i;\\n        \\t\\t\\t  max=j-i+1;\\n        \\t\\t\\t}\\n        \\t\\t}\\n        \\t}\\n        }\\n\\t\\treturn s.substring(start,start+max);\\n\\t}\\n}\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "balakrishna_95",
                        "content": "why my code is not working for all the test case\\n"
                    },
                    {
                        "username": "SlowCodiee",
                        "content": "Please specify in the question what should I return if there are no valid palindrome substring"
                    }
                ]
            },
            {
                "id": 1899428,
                "content": [
                    {
                        "username": "user7351F",
                        "content": "class Solution {\\n    public String longestPalindrome(String s) {\\n    int i = 0;\\n     if(1 <= s.length() && s.length() <= 1000){\\n       if(s.length() == 1 || s.length() == 0){\\n           return s;\\n       }\\n       if(isPalindrome(s)){\\n         String new_str = s.substring(i+1,s.length()-1);\\n         longestPalindrome(new_str);\\n         \\n         \\n       } \\n       else{\\n           String new_str1 = s.substring(i,s.length()-1); \\n          longestPalindrome(new_str1);\\n          \\n          \\n       } \\n     }\\n     return s;\\n    }\\n     boolean isPalindrome(String s1){\\n       int a = 0;\\n       int j = s1.length() - 1;\\n       while(a <= j){\\n         if(s1.charAt(a) != s1.charAt(j)){\\n           return false;\\n         }\\n         \\n         a++;\\n         j--;\\n       }\\n       return true;\\n     }  \\n}\\nCAn someone explain what is wrong in my code?"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Posting your solution in discussions is wrong"
                    },
                    {
                        "username": "Mookambika8",
                        "content": "Hello Leetcoders,\\n\\nI have a basic question in the understanding of the logic that needs to be followed for solving this problem without brute force.\\n\\nI have the below approach in mind:\\n\\nwhen you get the longest length, \\n1. we need to get the palindrome with that length.\\n2. We need to reduce length to be checked by -1\\n3. shift left the window by 1 by fixing the end and moving only left index by 1 until there is only value 1 difference between start and end while end > start\\n4. shift left the window by 1 by fixing the end and moving only right index by 1 until there is only value 1 difference between start and end while end > start\\n5. the above to loop around until we have the i reaching end of the string.\\n\\nCan you please review this approach and let me know if this is good enough for the solution or I got the whole idea wrong."
                    },
                    {
                        "username": "KaleemRazaSyedJ",
                        "content": "How are you finding the length of the longest paldromic substring?\n"
                    },
                    {
                        "username": "rohitrangde",
                        "content": "Wrong Answer\\n\\nInput\\ns =\\n\"aacabdkacaa\"\\n\\nOutput\\n\"aacakacaa\"\\nExpected\\n\"aca\"\\n\\nis it wrong output ?\\n"
                    },
                    {
                        "username": "KaleemRazaSyedJ",
                        "content": "Your answer is aacakacaa is incorrect because we are asked for substring not subsequence."
                    },
                    {
                        "username": "anj20",
                        "content": "can we do this in a tc better than O(N^2)?"
                    },
                    {
                        "username": "espinosarennieljun",
                        "content": "I always ended up hitting the time limit exceeded error. "
                    },
                    {
                        "username": "PrashanthVR",
                        "content": "For one particular testcase while submitting, the compiler shows run time exceeded. But when I give that particular test case manually, it passes. HOw?\\n\\n"
                    },
                    {
                        "username": "joinfanng",
                        "content": "how the testcase \"ac\" works???\\nideally it should return nuthimg"
                    },
                    {
                        "username": "chibi_chihiro",
                        "content": "You can just use brute force if you are struggling :p"
                    },
                    {
                        "username": "balakrishna_95",
                        "content": "class Solution {\\n\\t  static boolean h(String s)\\n    {\\n    \\tString j=\"\";\\n    \\tfor(int i=s.length()-1;i>=0;i--)\\n    \\t{\\n    \\t\\tj=j+s.charAt(i);\\n    \\t}\\n    \\tif(j.equals(s))\\n    \\t{\\n    \\t\\treturn true;\\n    \\t}\\n    \\treturn false;\\n    }\\n\\tpublic String longestPalindrome(String s){\\n        int max=1;\\n        int start=0;\\n        for(int i=0;i<s.length();i++)\\n        {\\n        \\tfor(int j=i;j<s.length();j++)\\n        \\t{\\n        \\t\\tif(h(s.substring(i,j+1)))\\n        \\t\\t{\\n        \\t\\t\\tif(j-i+1>max)\\n        \\t\\t\\t{\\n        \\t\\t\\t  start=i;\\n        \\t\\t\\t  max=j-i+1;\\n        \\t\\t\\t}\\n        \\t\\t}\\n        \\t}\\n        }\\n\\t\\treturn s.substring(start,start+max);\\n\\t}\\n}\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "balakrishna_95",
                        "content": "why my code is not working for all the test case\\n"
                    },
                    {
                        "username": "SlowCodiee",
                        "content": "Please specify in the question what should I return if there are no valid palindrome substring"
                    }
                ]
            },
            {
                "id": 1895244,
                "content": [
                    {
                        "username": "user7351F",
                        "content": "class Solution {\\n    public String longestPalindrome(String s) {\\n    int i = 0;\\n     if(1 <= s.length() && s.length() <= 1000){\\n       if(s.length() == 1 || s.length() == 0){\\n           return s;\\n       }\\n       if(isPalindrome(s)){\\n         String new_str = s.substring(i+1,s.length()-1);\\n         longestPalindrome(new_str);\\n         \\n         \\n       } \\n       else{\\n           String new_str1 = s.substring(i,s.length()-1); \\n          longestPalindrome(new_str1);\\n          \\n          \\n       } \\n     }\\n     return s;\\n    }\\n     boolean isPalindrome(String s1){\\n       int a = 0;\\n       int j = s1.length() - 1;\\n       while(a <= j){\\n         if(s1.charAt(a) != s1.charAt(j)){\\n           return false;\\n         }\\n         \\n         a++;\\n         j--;\\n       }\\n       return true;\\n     }  \\n}\\nCAn someone explain what is wrong in my code?"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Posting your solution in discussions is wrong"
                    },
                    {
                        "username": "Mookambika8",
                        "content": "Hello Leetcoders,\\n\\nI have a basic question in the understanding of the logic that needs to be followed for solving this problem without brute force.\\n\\nI have the below approach in mind:\\n\\nwhen you get the longest length, \\n1. we need to get the palindrome with that length.\\n2. We need to reduce length to be checked by -1\\n3. shift left the window by 1 by fixing the end and moving only left index by 1 until there is only value 1 difference between start and end while end > start\\n4. shift left the window by 1 by fixing the end and moving only right index by 1 until there is only value 1 difference between start and end while end > start\\n5. the above to loop around until we have the i reaching end of the string.\\n\\nCan you please review this approach and let me know if this is good enough for the solution or I got the whole idea wrong."
                    },
                    {
                        "username": "KaleemRazaSyedJ",
                        "content": "How are you finding the length of the longest paldromic substring?\n"
                    },
                    {
                        "username": "rohitrangde",
                        "content": "Wrong Answer\\n\\nInput\\ns =\\n\"aacabdkacaa\"\\n\\nOutput\\n\"aacakacaa\"\\nExpected\\n\"aca\"\\n\\nis it wrong output ?\\n"
                    },
                    {
                        "username": "KaleemRazaSyedJ",
                        "content": "Your answer is aacakacaa is incorrect because we are asked for substring not subsequence."
                    },
                    {
                        "username": "anj20",
                        "content": "can we do this in a tc better than O(N^2)?"
                    },
                    {
                        "username": "espinosarennieljun",
                        "content": "I always ended up hitting the time limit exceeded error. "
                    },
                    {
                        "username": "PrashanthVR",
                        "content": "For one particular testcase while submitting, the compiler shows run time exceeded. But when I give that particular test case manually, it passes. HOw?\\n\\n"
                    },
                    {
                        "username": "joinfanng",
                        "content": "how the testcase \"ac\" works???\\nideally it should return nuthimg"
                    },
                    {
                        "username": "chibi_chihiro",
                        "content": "You can just use brute force if you are struggling :p"
                    },
                    {
                        "username": "balakrishna_95",
                        "content": "class Solution {\\n\\t  static boolean h(String s)\\n    {\\n    \\tString j=\"\";\\n    \\tfor(int i=s.length()-1;i>=0;i--)\\n    \\t{\\n    \\t\\tj=j+s.charAt(i);\\n    \\t}\\n    \\tif(j.equals(s))\\n    \\t{\\n    \\t\\treturn true;\\n    \\t}\\n    \\treturn false;\\n    }\\n\\tpublic String longestPalindrome(String s){\\n        int max=1;\\n        int start=0;\\n        for(int i=0;i<s.length();i++)\\n        {\\n        \\tfor(int j=i;j<s.length();j++)\\n        \\t{\\n        \\t\\tif(h(s.substring(i,j+1)))\\n        \\t\\t{\\n        \\t\\t\\tif(j-i+1>max)\\n        \\t\\t\\t{\\n        \\t\\t\\t  start=i;\\n        \\t\\t\\t  max=j-i+1;\\n        \\t\\t\\t}\\n        \\t\\t}\\n        \\t}\\n        }\\n\\t\\treturn s.substring(start,start+max);\\n\\t}\\n}\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "balakrishna_95",
                        "content": "why my code is not working for all the test case\\n"
                    },
                    {
                        "username": "SlowCodiee",
                        "content": "Please specify in the question what should I return if there are no valid palindrome substring"
                    }
                ]
            },
            {
                "id": 1889881,
                "content": [
                    {
                        "username": "user7351F",
                        "content": "class Solution {\\n    public String longestPalindrome(String s) {\\n    int i = 0;\\n     if(1 <= s.length() && s.length() <= 1000){\\n       if(s.length() == 1 || s.length() == 0){\\n           return s;\\n       }\\n       if(isPalindrome(s)){\\n         String new_str = s.substring(i+1,s.length()-1);\\n         longestPalindrome(new_str);\\n         \\n         \\n       } \\n       else{\\n           String new_str1 = s.substring(i,s.length()-1); \\n          longestPalindrome(new_str1);\\n          \\n          \\n       } \\n     }\\n     return s;\\n    }\\n     boolean isPalindrome(String s1){\\n       int a = 0;\\n       int j = s1.length() - 1;\\n       while(a <= j){\\n         if(s1.charAt(a) != s1.charAt(j)){\\n           return false;\\n         }\\n         \\n         a++;\\n         j--;\\n       }\\n       return true;\\n     }  \\n}\\nCAn someone explain what is wrong in my code?"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Posting your solution in discussions is wrong"
                    },
                    {
                        "username": "Mookambika8",
                        "content": "Hello Leetcoders,\\n\\nI have a basic question in the understanding of the logic that needs to be followed for solving this problem without brute force.\\n\\nI have the below approach in mind:\\n\\nwhen you get the longest length, \\n1. we need to get the palindrome with that length.\\n2. We need to reduce length to be checked by -1\\n3. shift left the window by 1 by fixing the end and moving only left index by 1 until there is only value 1 difference between start and end while end > start\\n4. shift left the window by 1 by fixing the end and moving only right index by 1 until there is only value 1 difference between start and end while end > start\\n5. the above to loop around until we have the i reaching end of the string.\\n\\nCan you please review this approach and let me know if this is good enough for the solution or I got the whole idea wrong."
                    },
                    {
                        "username": "KaleemRazaSyedJ",
                        "content": "How are you finding the length of the longest paldromic substring?\n"
                    },
                    {
                        "username": "rohitrangde",
                        "content": "Wrong Answer\\n\\nInput\\ns =\\n\"aacabdkacaa\"\\n\\nOutput\\n\"aacakacaa\"\\nExpected\\n\"aca\"\\n\\nis it wrong output ?\\n"
                    },
                    {
                        "username": "KaleemRazaSyedJ",
                        "content": "Your answer is aacakacaa is incorrect because we are asked for substring not subsequence."
                    },
                    {
                        "username": "anj20",
                        "content": "can we do this in a tc better than O(N^2)?"
                    },
                    {
                        "username": "espinosarennieljun",
                        "content": "I always ended up hitting the time limit exceeded error. "
                    },
                    {
                        "username": "PrashanthVR",
                        "content": "For one particular testcase while submitting, the compiler shows run time exceeded. But when I give that particular test case manually, it passes. HOw?\\n\\n"
                    },
                    {
                        "username": "joinfanng",
                        "content": "how the testcase \"ac\" works???\\nideally it should return nuthimg"
                    },
                    {
                        "username": "chibi_chihiro",
                        "content": "You can just use brute force if you are struggling :p"
                    },
                    {
                        "username": "balakrishna_95",
                        "content": "class Solution {\\n\\t  static boolean h(String s)\\n    {\\n    \\tString j=\"\";\\n    \\tfor(int i=s.length()-1;i>=0;i--)\\n    \\t{\\n    \\t\\tj=j+s.charAt(i);\\n    \\t}\\n    \\tif(j.equals(s))\\n    \\t{\\n    \\t\\treturn true;\\n    \\t}\\n    \\treturn false;\\n    }\\n\\tpublic String longestPalindrome(String s){\\n        int max=1;\\n        int start=0;\\n        for(int i=0;i<s.length();i++)\\n        {\\n        \\tfor(int j=i;j<s.length();j++)\\n        \\t{\\n        \\t\\tif(h(s.substring(i,j+1)))\\n        \\t\\t{\\n        \\t\\t\\tif(j-i+1>max)\\n        \\t\\t\\t{\\n        \\t\\t\\t  start=i;\\n        \\t\\t\\t  max=j-i+1;\\n        \\t\\t\\t}\\n        \\t\\t}\\n        \\t}\\n        }\\n\\t\\treturn s.substring(start,start+max);\\n\\t}\\n}\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "balakrishna_95",
                        "content": "why my code is not working for all the test case\\n"
                    },
                    {
                        "username": "SlowCodiee",
                        "content": "Please specify in the question what should I return if there are no valid palindrome substring"
                    }
                ]
            },
            {
                "id": 1889597,
                "content": [
                    {
                        "username": "user7351F",
                        "content": "class Solution {\\n    public String longestPalindrome(String s) {\\n    int i = 0;\\n     if(1 <= s.length() && s.length() <= 1000){\\n       if(s.length() == 1 || s.length() == 0){\\n           return s;\\n       }\\n       if(isPalindrome(s)){\\n         String new_str = s.substring(i+1,s.length()-1);\\n         longestPalindrome(new_str);\\n         \\n         \\n       } \\n       else{\\n           String new_str1 = s.substring(i,s.length()-1); \\n          longestPalindrome(new_str1);\\n          \\n          \\n       } \\n     }\\n     return s;\\n    }\\n     boolean isPalindrome(String s1){\\n       int a = 0;\\n       int j = s1.length() - 1;\\n       while(a <= j){\\n         if(s1.charAt(a) != s1.charAt(j)){\\n           return false;\\n         }\\n         \\n         a++;\\n         j--;\\n       }\\n       return true;\\n     }  \\n}\\nCAn someone explain what is wrong in my code?"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Posting your solution in discussions is wrong"
                    },
                    {
                        "username": "Mookambika8",
                        "content": "Hello Leetcoders,\\n\\nI have a basic question in the understanding of the logic that needs to be followed for solving this problem without brute force.\\n\\nI have the below approach in mind:\\n\\nwhen you get the longest length, \\n1. we need to get the palindrome with that length.\\n2. We need to reduce length to be checked by -1\\n3. shift left the window by 1 by fixing the end and moving only left index by 1 until there is only value 1 difference between start and end while end > start\\n4. shift left the window by 1 by fixing the end and moving only right index by 1 until there is only value 1 difference between start and end while end > start\\n5. the above to loop around until we have the i reaching end of the string.\\n\\nCan you please review this approach and let me know if this is good enough for the solution or I got the whole idea wrong."
                    },
                    {
                        "username": "KaleemRazaSyedJ",
                        "content": "How are you finding the length of the longest paldromic substring?\n"
                    },
                    {
                        "username": "rohitrangde",
                        "content": "Wrong Answer\\n\\nInput\\ns =\\n\"aacabdkacaa\"\\n\\nOutput\\n\"aacakacaa\"\\nExpected\\n\"aca\"\\n\\nis it wrong output ?\\n"
                    },
                    {
                        "username": "KaleemRazaSyedJ",
                        "content": "Your answer is aacakacaa is incorrect because we are asked for substring not subsequence."
                    },
                    {
                        "username": "anj20",
                        "content": "can we do this in a tc better than O(N^2)?"
                    },
                    {
                        "username": "espinosarennieljun",
                        "content": "I always ended up hitting the time limit exceeded error. "
                    },
                    {
                        "username": "PrashanthVR",
                        "content": "For one particular testcase while submitting, the compiler shows run time exceeded. But when I give that particular test case manually, it passes. HOw?\\n\\n"
                    },
                    {
                        "username": "joinfanng",
                        "content": "how the testcase \"ac\" works???\\nideally it should return nuthimg"
                    },
                    {
                        "username": "chibi_chihiro",
                        "content": "You can just use brute force if you are struggling :p"
                    },
                    {
                        "username": "balakrishna_95",
                        "content": "class Solution {\\n\\t  static boolean h(String s)\\n    {\\n    \\tString j=\"\";\\n    \\tfor(int i=s.length()-1;i>=0;i--)\\n    \\t{\\n    \\t\\tj=j+s.charAt(i);\\n    \\t}\\n    \\tif(j.equals(s))\\n    \\t{\\n    \\t\\treturn true;\\n    \\t}\\n    \\treturn false;\\n    }\\n\\tpublic String longestPalindrome(String s){\\n        int max=1;\\n        int start=0;\\n        for(int i=0;i<s.length();i++)\\n        {\\n        \\tfor(int j=i;j<s.length();j++)\\n        \\t{\\n        \\t\\tif(h(s.substring(i,j+1)))\\n        \\t\\t{\\n        \\t\\t\\tif(j-i+1>max)\\n        \\t\\t\\t{\\n        \\t\\t\\t  start=i;\\n        \\t\\t\\t  max=j-i+1;\\n        \\t\\t\\t}\\n        \\t\\t}\\n        \\t}\\n        }\\n\\t\\treturn s.substring(start,start+max);\\n\\t}\\n}\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "balakrishna_95",
                        "content": "why my code is not working for all the test case\\n"
                    },
                    {
                        "username": "SlowCodiee",
                        "content": "Please specify in the question what should I return if there are no valid palindrome substring"
                    }
                ]
            },
            {
                "id": 1887989,
                "content": [
                    {
                        "username": "user7351F",
                        "content": "class Solution {\\n    public String longestPalindrome(String s) {\\n    int i = 0;\\n     if(1 <= s.length() && s.length() <= 1000){\\n       if(s.length() == 1 || s.length() == 0){\\n           return s;\\n       }\\n       if(isPalindrome(s)){\\n         String new_str = s.substring(i+1,s.length()-1);\\n         longestPalindrome(new_str);\\n         \\n         \\n       } \\n       else{\\n           String new_str1 = s.substring(i,s.length()-1); \\n          longestPalindrome(new_str1);\\n          \\n          \\n       } \\n     }\\n     return s;\\n    }\\n     boolean isPalindrome(String s1){\\n       int a = 0;\\n       int j = s1.length() - 1;\\n       while(a <= j){\\n         if(s1.charAt(a) != s1.charAt(j)){\\n           return false;\\n         }\\n         \\n         a++;\\n         j--;\\n       }\\n       return true;\\n     }  \\n}\\nCAn someone explain what is wrong in my code?"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Posting your solution in discussions is wrong"
                    },
                    {
                        "username": "Mookambika8",
                        "content": "Hello Leetcoders,\\n\\nI have a basic question in the understanding of the logic that needs to be followed for solving this problem without brute force.\\n\\nI have the below approach in mind:\\n\\nwhen you get the longest length, \\n1. we need to get the palindrome with that length.\\n2. We need to reduce length to be checked by -1\\n3. shift left the window by 1 by fixing the end and moving only left index by 1 until there is only value 1 difference between start and end while end > start\\n4. shift left the window by 1 by fixing the end and moving only right index by 1 until there is only value 1 difference between start and end while end > start\\n5. the above to loop around until we have the i reaching end of the string.\\n\\nCan you please review this approach and let me know if this is good enough for the solution or I got the whole idea wrong."
                    },
                    {
                        "username": "KaleemRazaSyedJ",
                        "content": "How are you finding the length of the longest paldromic substring?\n"
                    },
                    {
                        "username": "rohitrangde",
                        "content": "Wrong Answer\\n\\nInput\\ns =\\n\"aacabdkacaa\"\\n\\nOutput\\n\"aacakacaa\"\\nExpected\\n\"aca\"\\n\\nis it wrong output ?\\n"
                    },
                    {
                        "username": "KaleemRazaSyedJ",
                        "content": "Your answer is aacakacaa is incorrect because we are asked for substring not subsequence."
                    },
                    {
                        "username": "anj20",
                        "content": "can we do this in a tc better than O(N^2)?"
                    },
                    {
                        "username": "espinosarennieljun",
                        "content": "I always ended up hitting the time limit exceeded error. "
                    },
                    {
                        "username": "PrashanthVR",
                        "content": "For one particular testcase while submitting, the compiler shows run time exceeded. But when I give that particular test case manually, it passes. HOw?\\n\\n"
                    },
                    {
                        "username": "joinfanng",
                        "content": "how the testcase \"ac\" works???\\nideally it should return nuthimg"
                    },
                    {
                        "username": "chibi_chihiro",
                        "content": "You can just use brute force if you are struggling :p"
                    },
                    {
                        "username": "balakrishna_95",
                        "content": "class Solution {\\n\\t  static boolean h(String s)\\n    {\\n    \\tString j=\"\";\\n    \\tfor(int i=s.length()-1;i>=0;i--)\\n    \\t{\\n    \\t\\tj=j+s.charAt(i);\\n    \\t}\\n    \\tif(j.equals(s))\\n    \\t{\\n    \\t\\treturn true;\\n    \\t}\\n    \\treturn false;\\n    }\\n\\tpublic String longestPalindrome(String s){\\n        int max=1;\\n        int start=0;\\n        for(int i=0;i<s.length();i++)\\n        {\\n        \\tfor(int j=i;j<s.length();j++)\\n        \\t{\\n        \\t\\tif(h(s.substring(i,j+1)))\\n        \\t\\t{\\n        \\t\\t\\tif(j-i+1>max)\\n        \\t\\t\\t{\\n        \\t\\t\\t  start=i;\\n        \\t\\t\\t  max=j-i+1;\\n        \\t\\t\\t}\\n        \\t\\t}\\n        \\t}\\n        }\\n\\t\\treturn s.substring(start,start+max);\\n\\t}\\n}\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "balakrishna_95",
                        "content": "why my code is not working for all the test case\\n"
                    },
                    {
                        "username": "SlowCodiee",
                        "content": "Please specify in the question what should I return if there are no valid palindrome substring"
                    }
                ]
            },
            {
                "id": 1882674,
                "content": [
                    {
                        "username": "user7351F",
                        "content": "class Solution {\\n    public String longestPalindrome(String s) {\\n    int i = 0;\\n     if(1 <= s.length() && s.length() <= 1000){\\n       if(s.length() == 1 || s.length() == 0){\\n           return s;\\n       }\\n       if(isPalindrome(s)){\\n         String new_str = s.substring(i+1,s.length()-1);\\n         longestPalindrome(new_str);\\n         \\n         \\n       } \\n       else{\\n           String new_str1 = s.substring(i,s.length()-1); \\n          longestPalindrome(new_str1);\\n          \\n          \\n       } \\n     }\\n     return s;\\n    }\\n     boolean isPalindrome(String s1){\\n       int a = 0;\\n       int j = s1.length() - 1;\\n       while(a <= j){\\n         if(s1.charAt(a) != s1.charAt(j)){\\n           return false;\\n         }\\n         \\n         a++;\\n         j--;\\n       }\\n       return true;\\n     }  \\n}\\nCAn someone explain what is wrong in my code?"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Posting your solution in discussions is wrong"
                    },
                    {
                        "username": "Mookambika8",
                        "content": "Hello Leetcoders,\\n\\nI have a basic question in the understanding of the logic that needs to be followed for solving this problem without brute force.\\n\\nI have the below approach in mind:\\n\\nwhen you get the longest length, \\n1. we need to get the palindrome with that length.\\n2. We need to reduce length to be checked by -1\\n3. shift left the window by 1 by fixing the end and moving only left index by 1 until there is only value 1 difference between start and end while end > start\\n4. shift left the window by 1 by fixing the end and moving only right index by 1 until there is only value 1 difference between start and end while end > start\\n5. the above to loop around until we have the i reaching end of the string.\\n\\nCan you please review this approach and let me know if this is good enough for the solution or I got the whole idea wrong."
                    },
                    {
                        "username": "KaleemRazaSyedJ",
                        "content": "How are you finding the length of the longest paldromic substring?\n"
                    },
                    {
                        "username": "rohitrangde",
                        "content": "Wrong Answer\\n\\nInput\\ns =\\n\"aacabdkacaa\"\\n\\nOutput\\n\"aacakacaa\"\\nExpected\\n\"aca\"\\n\\nis it wrong output ?\\n"
                    },
                    {
                        "username": "KaleemRazaSyedJ",
                        "content": "Your answer is aacakacaa is incorrect because we are asked for substring not subsequence."
                    },
                    {
                        "username": "anj20",
                        "content": "can we do this in a tc better than O(N^2)?"
                    },
                    {
                        "username": "espinosarennieljun",
                        "content": "I always ended up hitting the time limit exceeded error. "
                    },
                    {
                        "username": "PrashanthVR",
                        "content": "For one particular testcase while submitting, the compiler shows run time exceeded. But when I give that particular test case manually, it passes. HOw?\\n\\n"
                    },
                    {
                        "username": "joinfanng",
                        "content": "how the testcase \"ac\" works???\\nideally it should return nuthimg"
                    },
                    {
                        "username": "chibi_chihiro",
                        "content": "You can just use brute force if you are struggling :p"
                    },
                    {
                        "username": "balakrishna_95",
                        "content": "class Solution {\\n\\t  static boolean h(String s)\\n    {\\n    \\tString j=\"\";\\n    \\tfor(int i=s.length()-1;i>=0;i--)\\n    \\t{\\n    \\t\\tj=j+s.charAt(i);\\n    \\t}\\n    \\tif(j.equals(s))\\n    \\t{\\n    \\t\\treturn true;\\n    \\t}\\n    \\treturn false;\\n    }\\n\\tpublic String longestPalindrome(String s){\\n        int max=1;\\n        int start=0;\\n        for(int i=0;i<s.length();i++)\\n        {\\n        \\tfor(int j=i;j<s.length();j++)\\n        \\t{\\n        \\t\\tif(h(s.substring(i,j+1)))\\n        \\t\\t{\\n        \\t\\t\\tif(j-i+1>max)\\n        \\t\\t\\t{\\n        \\t\\t\\t  start=i;\\n        \\t\\t\\t  max=j-i+1;\\n        \\t\\t\\t}\\n        \\t\\t}\\n        \\t}\\n        }\\n\\t\\treturn s.substring(start,start+max);\\n\\t}\\n}\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "balakrishna_95",
                        "content": "why my code is not working for all the test case\\n"
                    },
                    {
                        "username": "SlowCodiee",
                        "content": "Please specify in the question what should I return if there are no valid palindrome substring"
                    }
                ]
            },
            {
                "id": 1878146,
                "content": [
                    {
                        "username": "user7351F",
                        "content": "class Solution {\\n    public String longestPalindrome(String s) {\\n    int i = 0;\\n     if(1 <= s.length() && s.length() <= 1000){\\n       if(s.length() == 1 || s.length() == 0){\\n           return s;\\n       }\\n       if(isPalindrome(s)){\\n         String new_str = s.substring(i+1,s.length()-1);\\n         longestPalindrome(new_str);\\n         \\n         \\n       } \\n       else{\\n           String new_str1 = s.substring(i,s.length()-1); \\n          longestPalindrome(new_str1);\\n          \\n          \\n       } \\n     }\\n     return s;\\n    }\\n     boolean isPalindrome(String s1){\\n       int a = 0;\\n       int j = s1.length() - 1;\\n       while(a <= j){\\n         if(s1.charAt(a) != s1.charAt(j)){\\n           return false;\\n         }\\n         \\n         a++;\\n         j--;\\n       }\\n       return true;\\n     }  \\n}\\nCAn someone explain what is wrong in my code?"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Posting your solution in discussions is wrong"
                    },
                    {
                        "username": "Mookambika8",
                        "content": "Hello Leetcoders,\\n\\nI have a basic question in the understanding of the logic that needs to be followed for solving this problem without brute force.\\n\\nI have the below approach in mind:\\n\\nwhen you get the longest length, \\n1. we need to get the palindrome with that length.\\n2. We need to reduce length to be checked by -1\\n3. shift left the window by 1 by fixing the end and moving only left index by 1 until there is only value 1 difference between start and end while end > start\\n4. shift left the window by 1 by fixing the end and moving only right index by 1 until there is only value 1 difference between start and end while end > start\\n5. the above to loop around until we have the i reaching end of the string.\\n\\nCan you please review this approach and let me know if this is good enough for the solution or I got the whole idea wrong."
                    },
                    {
                        "username": "KaleemRazaSyedJ",
                        "content": "How are you finding the length of the longest paldromic substring?\n"
                    },
                    {
                        "username": "rohitrangde",
                        "content": "Wrong Answer\\n\\nInput\\ns =\\n\"aacabdkacaa\"\\n\\nOutput\\n\"aacakacaa\"\\nExpected\\n\"aca\"\\n\\nis it wrong output ?\\n"
                    },
                    {
                        "username": "KaleemRazaSyedJ",
                        "content": "Your answer is aacakacaa is incorrect because we are asked for substring not subsequence."
                    },
                    {
                        "username": "anj20",
                        "content": "can we do this in a tc better than O(N^2)?"
                    },
                    {
                        "username": "espinosarennieljun",
                        "content": "I always ended up hitting the time limit exceeded error. "
                    },
                    {
                        "username": "PrashanthVR",
                        "content": "For one particular testcase while submitting, the compiler shows run time exceeded. But when I give that particular test case manually, it passes. HOw?\\n\\n"
                    },
                    {
                        "username": "joinfanng",
                        "content": "how the testcase \"ac\" works???\\nideally it should return nuthimg"
                    },
                    {
                        "username": "chibi_chihiro",
                        "content": "You can just use brute force if you are struggling :p"
                    },
                    {
                        "username": "balakrishna_95",
                        "content": "class Solution {\\n\\t  static boolean h(String s)\\n    {\\n    \\tString j=\"\";\\n    \\tfor(int i=s.length()-1;i>=0;i--)\\n    \\t{\\n    \\t\\tj=j+s.charAt(i);\\n    \\t}\\n    \\tif(j.equals(s))\\n    \\t{\\n    \\t\\treturn true;\\n    \\t}\\n    \\treturn false;\\n    }\\n\\tpublic String longestPalindrome(String s){\\n        int max=1;\\n        int start=0;\\n        for(int i=0;i<s.length();i++)\\n        {\\n        \\tfor(int j=i;j<s.length();j++)\\n        \\t{\\n        \\t\\tif(h(s.substring(i,j+1)))\\n        \\t\\t{\\n        \\t\\t\\tif(j-i+1>max)\\n        \\t\\t\\t{\\n        \\t\\t\\t  start=i;\\n        \\t\\t\\t  max=j-i+1;\\n        \\t\\t\\t}\\n        \\t\\t}\\n        \\t}\\n        }\\n\\t\\treturn s.substring(start,start+max);\\n\\t}\\n}\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "balakrishna_95",
                        "content": "why my code is not working for all the test case\\n"
                    },
                    {
                        "username": "SlowCodiee",
                        "content": "Please specify in the question what should I return if there are no valid palindrome substring"
                    }
                ]
            },
            {
                "id": 1876690,
                "content": [
                    {
                        "username": "user7351F",
                        "content": "class Solution {\\n    public String longestPalindrome(String s) {\\n    int i = 0;\\n     if(1 <= s.length() && s.length() <= 1000){\\n       if(s.length() == 1 || s.length() == 0){\\n           return s;\\n       }\\n       if(isPalindrome(s)){\\n         String new_str = s.substring(i+1,s.length()-1);\\n         longestPalindrome(new_str);\\n         \\n         \\n       } \\n       else{\\n           String new_str1 = s.substring(i,s.length()-1); \\n          longestPalindrome(new_str1);\\n          \\n          \\n       } \\n     }\\n     return s;\\n    }\\n     boolean isPalindrome(String s1){\\n       int a = 0;\\n       int j = s1.length() - 1;\\n       while(a <= j){\\n         if(s1.charAt(a) != s1.charAt(j)){\\n           return false;\\n         }\\n         \\n         a++;\\n         j--;\\n       }\\n       return true;\\n     }  \\n}\\nCAn someone explain what is wrong in my code?"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Posting your solution in discussions is wrong"
                    },
                    {
                        "username": "Mookambika8",
                        "content": "Hello Leetcoders,\\n\\nI have a basic question in the understanding of the logic that needs to be followed for solving this problem without brute force.\\n\\nI have the below approach in mind:\\n\\nwhen you get the longest length, \\n1. we need to get the palindrome with that length.\\n2. We need to reduce length to be checked by -1\\n3. shift left the window by 1 by fixing the end and moving only left index by 1 until there is only value 1 difference between start and end while end > start\\n4. shift left the window by 1 by fixing the end and moving only right index by 1 until there is only value 1 difference between start and end while end > start\\n5. the above to loop around until we have the i reaching end of the string.\\n\\nCan you please review this approach and let me know if this is good enough for the solution or I got the whole idea wrong."
                    },
                    {
                        "username": "KaleemRazaSyedJ",
                        "content": "How are you finding the length of the longest paldromic substring?\n"
                    },
                    {
                        "username": "rohitrangde",
                        "content": "Wrong Answer\\n\\nInput\\ns =\\n\"aacabdkacaa\"\\n\\nOutput\\n\"aacakacaa\"\\nExpected\\n\"aca\"\\n\\nis it wrong output ?\\n"
                    },
                    {
                        "username": "KaleemRazaSyedJ",
                        "content": "Your answer is aacakacaa is incorrect because we are asked for substring not subsequence."
                    },
                    {
                        "username": "anj20",
                        "content": "can we do this in a tc better than O(N^2)?"
                    },
                    {
                        "username": "espinosarennieljun",
                        "content": "I always ended up hitting the time limit exceeded error. "
                    },
                    {
                        "username": "PrashanthVR",
                        "content": "For one particular testcase while submitting, the compiler shows run time exceeded. But when I give that particular test case manually, it passes. HOw?\\n\\n"
                    },
                    {
                        "username": "joinfanng",
                        "content": "how the testcase \"ac\" works???\\nideally it should return nuthimg"
                    },
                    {
                        "username": "chibi_chihiro",
                        "content": "You can just use brute force if you are struggling :p"
                    },
                    {
                        "username": "balakrishna_95",
                        "content": "class Solution {\\n\\t  static boolean h(String s)\\n    {\\n    \\tString j=\"\";\\n    \\tfor(int i=s.length()-1;i>=0;i--)\\n    \\t{\\n    \\t\\tj=j+s.charAt(i);\\n    \\t}\\n    \\tif(j.equals(s))\\n    \\t{\\n    \\t\\treturn true;\\n    \\t}\\n    \\treturn false;\\n    }\\n\\tpublic String longestPalindrome(String s){\\n        int max=1;\\n        int start=0;\\n        for(int i=0;i<s.length();i++)\\n        {\\n        \\tfor(int j=i;j<s.length();j++)\\n        \\t{\\n        \\t\\tif(h(s.substring(i,j+1)))\\n        \\t\\t{\\n        \\t\\t\\tif(j-i+1>max)\\n        \\t\\t\\t{\\n        \\t\\t\\t  start=i;\\n        \\t\\t\\t  max=j-i+1;\\n        \\t\\t\\t}\\n        \\t\\t}\\n        \\t}\\n        }\\n\\t\\treturn s.substring(start,start+max);\\n\\t}\\n}\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "balakrishna_95",
                        "content": "why my code is not working for all the test case\\n"
                    },
                    {
                        "username": "SlowCodiee",
                        "content": "Please specify in the question what should I return if there are no valid palindrome substring"
                    }
                ]
            },
            {
                "id": 1874541,
                "content": [
                    {
                        "username": "user7351F",
                        "content": "class Solution {\\n    public String longestPalindrome(String s) {\\n    int i = 0;\\n     if(1 <= s.length() && s.length() <= 1000){\\n       if(s.length() == 1 || s.length() == 0){\\n           return s;\\n       }\\n       if(isPalindrome(s)){\\n         String new_str = s.substring(i+1,s.length()-1);\\n         longestPalindrome(new_str);\\n         \\n         \\n       } \\n       else{\\n           String new_str1 = s.substring(i,s.length()-1); \\n          longestPalindrome(new_str1);\\n          \\n          \\n       } \\n     }\\n     return s;\\n    }\\n     boolean isPalindrome(String s1){\\n       int a = 0;\\n       int j = s1.length() - 1;\\n       while(a <= j){\\n         if(s1.charAt(a) != s1.charAt(j)){\\n           return false;\\n         }\\n         \\n         a++;\\n         j--;\\n       }\\n       return true;\\n     }  \\n}\\nCAn someone explain what is wrong in my code?"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Posting your solution in discussions is wrong"
                    },
                    {
                        "username": "Mookambika8",
                        "content": "Hello Leetcoders,\\n\\nI have a basic question in the understanding of the logic that needs to be followed for solving this problem without brute force.\\n\\nI have the below approach in mind:\\n\\nwhen you get the longest length, \\n1. we need to get the palindrome with that length.\\n2. We need to reduce length to be checked by -1\\n3. shift left the window by 1 by fixing the end and moving only left index by 1 until there is only value 1 difference between start and end while end > start\\n4. shift left the window by 1 by fixing the end and moving only right index by 1 until there is only value 1 difference between start and end while end > start\\n5. the above to loop around until we have the i reaching end of the string.\\n\\nCan you please review this approach and let me know if this is good enough for the solution or I got the whole idea wrong."
                    },
                    {
                        "username": "KaleemRazaSyedJ",
                        "content": "How are you finding the length of the longest paldromic substring?\n"
                    },
                    {
                        "username": "rohitrangde",
                        "content": "Wrong Answer\\n\\nInput\\ns =\\n\"aacabdkacaa\"\\n\\nOutput\\n\"aacakacaa\"\\nExpected\\n\"aca\"\\n\\nis it wrong output ?\\n"
                    },
                    {
                        "username": "KaleemRazaSyedJ",
                        "content": "Your answer is aacakacaa is incorrect because we are asked for substring not subsequence."
                    },
                    {
                        "username": "anj20",
                        "content": "can we do this in a tc better than O(N^2)?"
                    },
                    {
                        "username": "espinosarennieljun",
                        "content": "I always ended up hitting the time limit exceeded error. "
                    },
                    {
                        "username": "PrashanthVR",
                        "content": "For one particular testcase while submitting, the compiler shows run time exceeded. But when I give that particular test case manually, it passes. HOw?\\n\\n"
                    },
                    {
                        "username": "joinfanng",
                        "content": "how the testcase \"ac\" works???\\nideally it should return nuthimg"
                    },
                    {
                        "username": "chibi_chihiro",
                        "content": "You can just use brute force if you are struggling :p"
                    },
                    {
                        "username": "balakrishna_95",
                        "content": "class Solution {\\n\\t  static boolean h(String s)\\n    {\\n    \\tString j=\"\";\\n    \\tfor(int i=s.length()-1;i>=0;i--)\\n    \\t{\\n    \\t\\tj=j+s.charAt(i);\\n    \\t}\\n    \\tif(j.equals(s))\\n    \\t{\\n    \\t\\treturn true;\\n    \\t}\\n    \\treturn false;\\n    }\\n\\tpublic String longestPalindrome(String s){\\n        int max=1;\\n        int start=0;\\n        for(int i=0;i<s.length();i++)\\n        {\\n        \\tfor(int j=i;j<s.length();j++)\\n        \\t{\\n        \\t\\tif(h(s.substring(i,j+1)))\\n        \\t\\t{\\n        \\t\\t\\tif(j-i+1>max)\\n        \\t\\t\\t{\\n        \\t\\t\\t  start=i;\\n        \\t\\t\\t  max=j-i+1;\\n        \\t\\t\\t}\\n        \\t\\t}\\n        \\t}\\n        }\\n\\t\\treturn s.substring(start,start+max);\\n\\t}\\n}\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "balakrishna_95",
                        "content": "why my code is not working for all the test case\\n"
                    },
                    {
                        "username": "SlowCodiee",
                        "content": "Please specify in the question what should I return if there are no valid palindrome substring"
                    }
                ]
            },
            {
                "id": 1870788,
                "content": [
                    {
                        "username": "ankush920",
                        "content": "\\nEXPLAINED TEXT || C++ || DYNAMIC PROGRAMMING\\nankush920\\n0\\nin a few seconds\\nIntuition\\ntake 2-d matrix of dp in which\\ni--> intial position and j --> final postion\\nsee all possible valid combination for palindrom and store it in this array\\n-> upper half of this array is not useful or invalid because i>j mean intial pos > final pos --> not valid\\n-> for i==j mean only one word and it is always palindromic\\n-> for j-i ==1 mean two word it is only palindromic when both char are same( s[i] == s[j])\\n\\n-> now main point for all other case :-\\n( understand my solution upto this point upvote it vro :) )\\nfor palindromic -> first pos char (i) and last pos char(j) must be equal and the portion in between then aslo need to be equal.\\n\\ni and using not traditional for loop and slightly modify it for only considred valid case ( i<=j)\\n\\n//for answer\\ni take two variable start and end store 0 ( mean first char of string in that (single char definately palindromic))\\n->for each palindrom case i check wheater\\ntheir j -i ( string length ) is greater then my ans lenght ( end - start) --> if it is then i change my start and end ( start =i ,end =j)\\n\\nnote * :-\\nfor string len >=1 --> answer>=1 and because of that i intially take length one not checking for one length\\n\\nApproach\\nbottom up dynamic programming\\n\\nComplexity\\nTime complexity:\\n0(n2)\\n\\nSpace complexity:\\n0(n2)\\n\\nCode\\n\\n//////  for explaination refer pep coding :)\\nclass Solution {\\npublic:\\nint dp[1000][1000];\\n    string longestPalindrome(string s) {\\n    \\n\\n    memset( dp,0, sizeof(dp));\\n     int i = 0 , j =0 ;\\n     int g =0, n = s.size();\\n     int start =0, end=0;\\n\\n if( n ==1)\\n   {  \\n   return s;  \\n}\\n     for( int g=0; g<n ;g++ )  /// gap \\n     {\\n         for( int i = 0 ,j=g ; i<n && j<n ;i++, j++ ) // covering all possible of i<j\\n         {\\n           \\n           if(i==j)\\n           {             \\n               dp[i][j] =1;\\n               continue;\\n           }\\n\\n           if(j-i==1 &&s[i]==s[j])\\n           {           \\n                dp[i][j] =1;\\n                \\n                if((j-i) >(end-start) )\\n                {\\n                     start =i;\\n                     end =j;\\n                }\\n                 \\n           continue;\\n           }\\n        \\n            \\n            if( s[i]==s[j] && dp[i+1][j-1]==1)\\n            { \\n                 dp[i][j] =1;\\n                \\n                if( j-i> (end-start) )\\n                {\\n                     start =i;\\n                     end =j;\\n                }\\n                  \\n            }\\n             \\n         }\\n     }\\n\\n     return s.substr(start, end+1-start);   \\n    }\\n};"
                    },
                    {
                        "username": "MiGameasa",
                        "content": "Hi, I'm kinda new and this is my code, it only work with palin string that 3 or less. Can someone point out how to fix this? \n\n```class Solution {\n    public String longestPalindrome(String s) {\n        int left=0, right=s.length()-1, temp = 0;\n        for(int i = 0; i < s.length(); i++){\n            for(int j = right; j > i; j--){\n                if(s.charAt(i) != s.charAt(j)){\n                    continue;\n                }else{\n                    left = i;\n                    right = j;\n                    temp = right;\n                    right--;\n                    break;\n                }\n            }\n        }\n\n        return s.substring(left, temp + 1);\n    }\n}"
                    },
                    {
                        "username": "Namasteydunia",
                        "content": "why it is not letting us use reverse() function in javascript. reverse() is a valid javascript function to reverse a string."
                    },
                    {
                        "username": "charucjoshi",
                        "content": "Can someone please explain why this is wrong?\\n\\nWrong Answer\\ns=\"aacabdkacaa\"\\nOutput\\n\"aacakacaa\"\\nExpected\\n\"aca\""
                    },
                    {
                        "username": "alphazwest",
                        "content": "For the first case, are not `abba` and `baab` both palindromic substrings -- both *longer* than the given solution output? "
                    },
                    {
                        "username": "harshitha____9",
                        "content": "why time limit exceeding?\\n\\nbool check(string s,int i,int j)\\n{\\n    \\n    while(i<=j)\\n    {\\n        if(s[i]!=s[j])\\n        {\\n            return false;\\n        }\\n        i++;\\n        j--;\\n    }\\n    return true;\\n}\\n void f(int i,int j,string&ans,string s)\\n {\\n     if(i>j) return;\\n     if(j<0) return;\\n    if(check(s,i,j))\\n    {\\n        if(ans.size()<(j-i+1))\\n        {\\n            ans=s.substr(i,j-i+1);\\n        }\\n        return;\\n    }\\n    \\n     f(i+1,j,ans,s);\\n     f(i,j-1,ans,s);\\n    \\n }\\n    string longestPalindrome(string s) {\\n        int i=0,j=s.size()-1;\\n        string ans=\"\";\\n        f(i,j,ans,s);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "nishantwestside",
                        "content": "There seems to be an extra curly brace at the end of your code, which may be causing a syntax error. However, assuming that this is a typographical error, the most likely reason why your code is exceeding the limit is because the time complexity of the algorithm is high.\\n\\nThe code is using a recursive function to check all possible substrings in the input string s, and then checking if they are palindromes or not using the check() function. This approach has an exponential time complexity of O(2^n), where n is the length of the input string s.\\n\\nThis means that as the length of the input string grows, the number of recursive calls made by the algorithm also grows exponentially, leading to a potential stack overflow or timeout.\\n\\nTo optimize the algorithm, you can use dynamic programming or expand around the center approach to reduce the time complexity to O(n2).\\n\\nDynamic Programming Approach:\\n\\n- Define a boolean table of size n x n, where n is the length of the input string.\\n- Initialize all cells in the table to false.\\n- Set all cells (i, i) to true, since a single character is always a palindrome.\\n- For all pairs of indices i, j where i < j, set table[i][j] to true if s[i] == s[j] and table[i+1][j-1] is also true. - This means that a substring from i to j is a palindrome if its first and last characters are equal, and its - inner substring is also a palindrome.\\n- Keep track of the longest palindrome found so far and its starting and ending indices."
                    },
                    {
                        "username": "optic188",
                        "content": "actually really curios about error one one of test cases \\nTime Limit Exceeded\\nnothing mentioned in desciption about complexity of algoritm or memeory using restrictions ? Why then this test case is not passing "
                    },
                    {
                        "username": "yashAryan",
                        "content": "Line 1061: Char 9: runtime error: addition of unsigned offset to 0x7fff8d8fc2b0 overflowed to 0x7fff8d8fc2af (basic_string.h)\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/basic_string.h:1070:9\n\n\n\n\nI am facing this error. Can anyone tell me what's wrong with my code?  \n class Solution {\npublic:\n    string longestPalindrome(string s) {\n        string t=\"#\";\n    for(int i=0;i<s.size();i++)\n    {\n        t+=s[i];\n        t+=\"#\";\n    }\n    int n=t.size();\n    vector<int> v(n,0);\n    int c=0,mirr=0,r=0;\n    for(int i=1;i<t.size()-1;i++)\n    {\n        mirr=2*c-i;\n        if(i<r and mirr>=0)\n        {\n            v[i]=min(v[mirr],r-i);\n        }\n        while(t[i+v[i]+1]==t[i-v[i]-1])\n        {\n            v[i]++;\n        }\n        if(i+v[i]>r)\n        {\n            c=i;\n            r=i+v[i];\n        }\n    }\n    int index=max_element(v.begin(),v.end())-v.begin();\n    int value=v[index];\n    int start=index-value;\n    string f=t.substr(start,2*value);\n    f.erase(remove(f.begin(),f.end(),'#'),f.end());\n\n    return f;\n    }\n};\n\n[Link to the question](https://leetcode.com/problems/longest-palindromic-substring/description/)"
                    },
                    {
                        "username": "DavidLindon",
                        "content": "This problem is extremely poor since it isn\\'t obvious that all the test cases can easily be solved by expanding around center.\\n\\nWhat about \"bbbba\", output should be bbbb!"
                    },
                    {
                        "username": "harshitha____9",
                        "content": "string f(int i,int j,string ref,string s,string&ans)\\n {\\n     if(i>=j) return ref;\\n     if(s[i]==s[j])\\n     {\\n         i++;\\n         j--;\\n     }\\n     else if(s[i]!=s[j])\\n     {\\n         string l=f(i+1,j,ref.substr(i+1,j-i),s,ans);\\n         string r=f(i,j-1,ref.substr(i,j-i),s,ans);\\n         if(l.size()>r.size())\\n         {\\n             ans=l;\\n         }\\n         else\\n         {\\n             ans=r;\\n         }\\n     }\\n      \\n     return ref;\\n }\\n    string longestPalindrome(string s) {\\n        int i=0,j=s.size()-1;\\n        string c=s;\\n        string ans=\"\";\\n        f(i,j,c,s,ans);\\n        return ans;\\n    }\\nwhat is wrong with this code......"
                    }
                ]
            },
            {
                "id": 1870494,
                "content": [
                    {
                        "username": "ankush920",
                        "content": "\\nEXPLAINED TEXT || C++ || DYNAMIC PROGRAMMING\\nankush920\\n0\\nin a few seconds\\nIntuition\\ntake 2-d matrix of dp in which\\ni--> intial position and j --> final postion\\nsee all possible valid combination for palindrom and store it in this array\\n-> upper half of this array is not useful or invalid because i>j mean intial pos > final pos --> not valid\\n-> for i==j mean only one word and it is always palindromic\\n-> for j-i ==1 mean two word it is only palindromic when both char are same( s[i] == s[j])\\n\\n-> now main point for all other case :-\\n( understand my solution upto this point upvote it vro :) )\\nfor palindromic -> first pos char (i) and last pos char(j) must be equal and the portion in between then aslo need to be equal.\\n\\ni and using not traditional for loop and slightly modify it for only considred valid case ( i<=j)\\n\\n//for answer\\ni take two variable start and end store 0 ( mean first char of string in that (single char definately palindromic))\\n->for each palindrom case i check wheater\\ntheir j -i ( string length ) is greater then my ans lenght ( end - start) --> if it is then i change my start and end ( start =i ,end =j)\\n\\nnote * :-\\nfor string len >=1 --> answer>=1 and because of that i intially take length one not checking for one length\\n\\nApproach\\nbottom up dynamic programming\\n\\nComplexity\\nTime complexity:\\n0(n2)\\n\\nSpace complexity:\\n0(n2)\\n\\nCode\\n\\n//////  for explaination refer pep coding :)\\nclass Solution {\\npublic:\\nint dp[1000][1000];\\n    string longestPalindrome(string s) {\\n    \\n\\n    memset( dp,0, sizeof(dp));\\n     int i = 0 , j =0 ;\\n     int g =0, n = s.size();\\n     int start =0, end=0;\\n\\n if( n ==1)\\n   {  \\n   return s;  \\n}\\n     for( int g=0; g<n ;g++ )  /// gap \\n     {\\n         for( int i = 0 ,j=g ; i<n && j<n ;i++, j++ ) // covering all possible of i<j\\n         {\\n           \\n           if(i==j)\\n           {             \\n               dp[i][j] =1;\\n               continue;\\n           }\\n\\n           if(j-i==1 &&s[i]==s[j])\\n           {           \\n                dp[i][j] =1;\\n                \\n                if((j-i) >(end-start) )\\n                {\\n                     start =i;\\n                     end =j;\\n                }\\n                 \\n           continue;\\n           }\\n        \\n            \\n            if( s[i]==s[j] && dp[i+1][j-1]==1)\\n            { \\n                 dp[i][j] =1;\\n                \\n                if( j-i> (end-start) )\\n                {\\n                     start =i;\\n                     end =j;\\n                }\\n                  \\n            }\\n             \\n         }\\n     }\\n\\n     return s.substr(start, end+1-start);   \\n    }\\n};"
                    },
                    {
                        "username": "MiGameasa",
                        "content": "Hi, I'm kinda new and this is my code, it only work with palin string that 3 or less. Can someone point out how to fix this? \n\n```class Solution {\n    public String longestPalindrome(String s) {\n        int left=0, right=s.length()-1, temp = 0;\n        for(int i = 0; i < s.length(); i++){\n            for(int j = right; j > i; j--){\n                if(s.charAt(i) != s.charAt(j)){\n                    continue;\n                }else{\n                    left = i;\n                    right = j;\n                    temp = right;\n                    right--;\n                    break;\n                }\n            }\n        }\n\n        return s.substring(left, temp + 1);\n    }\n}"
                    },
                    {
                        "username": "Namasteydunia",
                        "content": "why it is not letting us use reverse() function in javascript. reverse() is a valid javascript function to reverse a string."
                    },
                    {
                        "username": "charucjoshi",
                        "content": "Can someone please explain why this is wrong?\\n\\nWrong Answer\\ns=\"aacabdkacaa\"\\nOutput\\n\"aacakacaa\"\\nExpected\\n\"aca\""
                    },
                    {
                        "username": "alphazwest",
                        "content": "For the first case, are not `abba` and `baab` both palindromic substrings -- both *longer* than the given solution output? "
                    },
                    {
                        "username": "harshitha____9",
                        "content": "why time limit exceeding?\\n\\nbool check(string s,int i,int j)\\n{\\n    \\n    while(i<=j)\\n    {\\n        if(s[i]!=s[j])\\n        {\\n            return false;\\n        }\\n        i++;\\n        j--;\\n    }\\n    return true;\\n}\\n void f(int i,int j,string&ans,string s)\\n {\\n     if(i>j) return;\\n     if(j<0) return;\\n    if(check(s,i,j))\\n    {\\n        if(ans.size()<(j-i+1))\\n        {\\n            ans=s.substr(i,j-i+1);\\n        }\\n        return;\\n    }\\n    \\n     f(i+1,j,ans,s);\\n     f(i,j-1,ans,s);\\n    \\n }\\n    string longestPalindrome(string s) {\\n        int i=0,j=s.size()-1;\\n        string ans=\"\";\\n        f(i,j,ans,s);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "nishantwestside",
                        "content": "There seems to be an extra curly brace at the end of your code, which may be causing a syntax error. However, assuming that this is a typographical error, the most likely reason why your code is exceeding the limit is because the time complexity of the algorithm is high.\\n\\nThe code is using a recursive function to check all possible substrings in the input string s, and then checking if they are palindromes or not using the check() function. This approach has an exponential time complexity of O(2^n), where n is the length of the input string s.\\n\\nThis means that as the length of the input string grows, the number of recursive calls made by the algorithm also grows exponentially, leading to a potential stack overflow or timeout.\\n\\nTo optimize the algorithm, you can use dynamic programming or expand around the center approach to reduce the time complexity to O(n2).\\n\\nDynamic Programming Approach:\\n\\n- Define a boolean table of size n x n, where n is the length of the input string.\\n- Initialize all cells in the table to false.\\n- Set all cells (i, i) to true, since a single character is always a palindrome.\\n- For all pairs of indices i, j where i < j, set table[i][j] to true if s[i] == s[j] and table[i+1][j-1] is also true. - This means that a substring from i to j is a palindrome if its first and last characters are equal, and its - inner substring is also a palindrome.\\n- Keep track of the longest palindrome found so far and its starting and ending indices."
                    },
                    {
                        "username": "optic188",
                        "content": "actually really curios about error one one of test cases \\nTime Limit Exceeded\\nnothing mentioned in desciption about complexity of algoritm or memeory using restrictions ? Why then this test case is not passing "
                    },
                    {
                        "username": "yashAryan",
                        "content": "Line 1061: Char 9: runtime error: addition of unsigned offset to 0x7fff8d8fc2b0 overflowed to 0x7fff8d8fc2af (basic_string.h)\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/basic_string.h:1070:9\n\n\n\n\nI am facing this error. Can anyone tell me what's wrong with my code?  \n class Solution {\npublic:\n    string longestPalindrome(string s) {\n        string t=\"#\";\n    for(int i=0;i<s.size();i++)\n    {\n        t+=s[i];\n        t+=\"#\";\n    }\n    int n=t.size();\n    vector<int> v(n,0);\n    int c=0,mirr=0,r=0;\n    for(int i=1;i<t.size()-1;i++)\n    {\n        mirr=2*c-i;\n        if(i<r and mirr>=0)\n        {\n            v[i]=min(v[mirr],r-i);\n        }\n        while(t[i+v[i]+1]==t[i-v[i]-1])\n        {\n            v[i]++;\n        }\n        if(i+v[i]>r)\n        {\n            c=i;\n            r=i+v[i];\n        }\n    }\n    int index=max_element(v.begin(),v.end())-v.begin();\n    int value=v[index];\n    int start=index-value;\n    string f=t.substr(start,2*value);\n    f.erase(remove(f.begin(),f.end(),'#'),f.end());\n\n    return f;\n    }\n};\n\n[Link to the question](https://leetcode.com/problems/longest-palindromic-substring/description/)"
                    },
                    {
                        "username": "DavidLindon",
                        "content": "This problem is extremely poor since it isn\\'t obvious that all the test cases can easily be solved by expanding around center.\\n\\nWhat about \"bbbba\", output should be bbbb!"
                    },
                    {
                        "username": "harshitha____9",
                        "content": "string f(int i,int j,string ref,string s,string&ans)\\n {\\n     if(i>=j) return ref;\\n     if(s[i]==s[j])\\n     {\\n         i++;\\n         j--;\\n     }\\n     else if(s[i]!=s[j])\\n     {\\n         string l=f(i+1,j,ref.substr(i+1,j-i),s,ans);\\n         string r=f(i,j-1,ref.substr(i,j-i),s,ans);\\n         if(l.size()>r.size())\\n         {\\n             ans=l;\\n         }\\n         else\\n         {\\n             ans=r;\\n         }\\n     }\\n      \\n     return ref;\\n }\\n    string longestPalindrome(string s) {\\n        int i=0,j=s.size()-1;\\n        string c=s;\\n        string ans=\"\";\\n        f(i,j,c,s,ans);\\n        return ans;\\n    }\\nwhat is wrong with this code......"
                    }
                ]
            },
            {
                "id": 1870190,
                "content": [
                    {
                        "username": "ankush920",
                        "content": "\\nEXPLAINED TEXT || C++ || DYNAMIC PROGRAMMING\\nankush920\\n0\\nin a few seconds\\nIntuition\\ntake 2-d matrix of dp in which\\ni--> intial position and j --> final postion\\nsee all possible valid combination for palindrom and store it in this array\\n-> upper half of this array is not useful or invalid because i>j mean intial pos > final pos --> not valid\\n-> for i==j mean only one word and it is always palindromic\\n-> for j-i ==1 mean two word it is only palindromic when both char are same( s[i] == s[j])\\n\\n-> now main point for all other case :-\\n( understand my solution upto this point upvote it vro :) )\\nfor palindromic -> first pos char (i) and last pos char(j) must be equal and the portion in between then aslo need to be equal.\\n\\ni and using not traditional for loop and slightly modify it for only considred valid case ( i<=j)\\n\\n//for answer\\ni take two variable start and end store 0 ( mean first char of string in that (single char definately palindromic))\\n->for each palindrom case i check wheater\\ntheir j -i ( string length ) is greater then my ans lenght ( end - start) --> if it is then i change my start and end ( start =i ,end =j)\\n\\nnote * :-\\nfor string len >=1 --> answer>=1 and because of that i intially take length one not checking for one length\\n\\nApproach\\nbottom up dynamic programming\\n\\nComplexity\\nTime complexity:\\n0(n2)\\n\\nSpace complexity:\\n0(n2)\\n\\nCode\\n\\n//////  for explaination refer pep coding :)\\nclass Solution {\\npublic:\\nint dp[1000][1000];\\n    string longestPalindrome(string s) {\\n    \\n\\n    memset( dp,0, sizeof(dp));\\n     int i = 0 , j =0 ;\\n     int g =0, n = s.size();\\n     int start =0, end=0;\\n\\n if( n ==1)\\n   {  \\n   return s;  \\n}\\n     for( int g=0; g<n ;g++ )  /// gap \\n     {\\n         for( int i = 0 ,j=g ; i<n && j<n ;i++, j++ ) // covering all possible of i<j\\n         {\\n           \\n           if(i==j)\\n           {             \\n               dp[i][j] =1;\\n               continue;\\n           }\\n\\n           if(j-i==1 &&s[i]==s[j])\\n           {           \\n                dp[i][j] =1;\\n                \\n                if((j-i) >(end-start) )\\n                {\\n                     start =i;\\n                     end =j;\\n                }\\n                 \\n           continue;\\n           }\\n        \\n            \\n            if( s[i]==s[j] && dp[i+1][j-1]==1)\\n            { \\n                 dp[i][j] =1;\\n                \\n                if( j-i> (end-start) )\\n                {\\n                     start =i;\\n                     end =j;\\n                }\\n                  \\n            }\\n             \\n         }\\n     }\\n\\n     return s.substr(start, end+1-start);   \\n    }\\n};"
                    },
                    {
                        "username": "MiGameasa",
                        "content": "Hi, I'm kinda new and this is my code, it only work with palin string that 3 or less. Can someone point out how to fix this? \n\n```class Solution {\n    public String longestPalindrome(String s) {\n        int left=0, right=s.length()-1, temp = 0;\n        for(int i = 0; i < s.length(); i++){\n            for(int j = right; j > i; j--){\n                if(s.charAt(i) != s.charAt(j)){\n                    continue;\n                }else{\n                    left = i;\n                    right = j;\n                    temp = right;\n                    right--;\n                    break;\n                }\n            }\n        }\n\n        return s.substring(left, temp + 1);\n    }\n}"
                    },
                    {
                        "username": "Namasteydunia",
                        "content": "why it is not letting us use reverse() function in javascript. reverse() is a valid javascript function to reverse a string."
                    },
                    {
                        "username": "charucjoshi",
                        "content": "Can someone please explain why this is wrong?\\n\\nWrong Answer\\ns=\"aacabdkacaa\"\\nOutput\\n\"aacakacaa\"\\nExpected\\n\"aca\""
                    },
                    {
                        "username": "alphazwest",
                        "content": "For the first case, are not `abba` and `baab` both palindromic substrings -- both *longer* than the given solution output? "
                    },
                    {
                        "username": "harshitha____9",
                        "content": "why time limit exceeding?\\n\\nbool check(string s,int i,int j)\\n{\\n    \\n    while(i<=j)\\n    {\\n        if(s[i]!=s[j])\\n        {\\n            return false;\\n        }\\n        i++;\\n        j--;\\n    }\\n    return true;\\n}\\n void f(int i,int j,string&ans,string s)\\n {\\n     if(i>j) return;\\n     if(j<0) return;\\n    if(check(s,i,j))\\n    {\\n        if(ans.size()<(j-i+1))\\n        {\\n            ans=s.substr(i,j-i+1);\\n        }\\n        return;\\n    }\\n    \\n     f(i+1,j,ans,s);\\n     f(i,j-1,ans,s);\\n    \\n }\\n    string longestPalindrome(string s) {\\n        int i=0,j=s.size()-1;\\n        string ans=\"\";\\n        f(i,j,ans,s);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "nishantwestside",
                        "content": "There seems to be an extra curly brace at the end of your code, which may be causing a syntax error. However, assuming that this is a typographical error, the most likely reason why your code is exceeding the limit is because the time complexity of the algorithm is high.\\n\\nThe code is using a recursive function to check all possible substrings in the input string s, and then checking if they are palindromes or not using the check() function. This approach has an exponential time complexity of O(2^n), where n is the length of the input string s.\\n\\nThis means that as the length of the input string grows, the number of recursive calls made by the algorithm also grows exponentially, leading to a potential stack overflow or timeout.\\n\\nTo optimize the algorithm, you can use dynamic programming or expand around the center approach to reduce the time complexity to O(n2).\\n\\nDynamic Programming Approach:\\n\\n- Define a boolean table of size n x n, where n is the length of the input string.\\n- Initialize all cells in the table to false.\\n- Set all cells (i, i) to true, since a single character is always a palindrome.\\n- For all pairs of indices i, j where i < j, set table[i][j] to true if s[i] == s[j] and table[i+1][j-1] is also true. - This means that a substring from i to j is a palindrome if its first and last characters are equal, and its - inner substring is also a palindrome.\\n- Keep track of the longest palindrome found so far and its starting and ending indices."
                    },
                    {
                        "username": "optic188",
                        "content": "actually really curios about error one one of test cases \\nTime Limit Exceeded\\nnothing mentioned in desciption about complexity of algoritm or memeory using restrictions ? Why then this test case is not passing "
                    },
                    {
                        "username": "yashAryan",
                        "content": "Line 1061: Char 9: runtime error: addition of unsigned offset to 0x7fff8d8fc2b0 overflowed to 0x7fff8d8fc2af (basic_string.h)\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/basic_string.h:1070:9\n\n\n\n\nI am facing this error. Can anyone tell me what's wrong with my code?  \n class Solution {\npublic:\n    string longestPalindrome(string s) {\n        string t=\"#\";\n    for(int i=0;i<s.size();i++)\n    {\n        t+=s[i];\n        t+=\"#\";\n    }\n    int n=t.size();\n    vector<int> v(n,0);\n    int c=0,mirr=0,r=0;\n    for(int i=1;i<t.size()-1;i++)\n    {\n        mirr=2*c-i;\n        if(i<r and mirr>=0)\n        {\n            v[i]=min(v[mirr],r-i);\n        }\n        while(t[i+v[i]+1]==t[i-v[i]-1])\n        {\n            v[i]++;\n        }\n        if(i+v[i]>r)\n        {\n            c=i;\n            r=i+v[i];\n        }\n    }\n    int index=max_element(v.begin(),v.end())-v.begin();\n    int value=v[index];\n    int start=index-value;\n    string f=t.substr(start,2*value);\n    f.erase(remove(f.begin(),f.end(),'#'),f.end());\n\n    return f;\n    }\n};\n\n[Link to the question](https://leetcode.com/problems/longest-palindromic-substring/description/)"
                    },
                    {
                        "username": "DavidLindon",
                        "content": "This problem is extremely poor since it isn\\'t obvious that all the test cases can easily be solved by expanding around center.\\n\\nWhat about \"bbbba\", output should be bbbb!"
                    },
                    {
                        "username": "harshitha____9",
                        "content": "string f(int i,int j,string ref,string s,string&ans)\\n {\\n     if(i>=j) return ref;\\n     if(s[i]==s[j])\\n     {\\n         i++;\\n         j--;\\n     }\\n     else if(s[i]!=s[j])\\n     {\\n         string l=f(i+1,j,ref.substr(i+1,j-i),s,ans);\\n         string r=f(i,j-1,ref.substr(i,j-i),s,ans);\\n         if(l.size()>r.size())\\n         {\\n             ans=l;\\n         }\\n         else\\n         {\\n             ans=r;\\n         }\\n     }\\n      \\n     return ref;\\n }\\n    string longestPalindrome(string s) {\\n        int i=0,j=s.size()-1;\\n        string c=s;\\n        string ans=\"\";\\n        f(i,j,c,s,ans);\\n        return ans;\\n    }\\nwhat is wrong with this code......"
                    }
                ]
            },
            {
                "id": 1862816,
                "content": [
                    {
                        "username": "ankush920",
                        "content": "\\nEXPLAINED TEXT || C++ || DYNAMIC PROGRAMMING\\nankush920\\n0\\nin a few seconds\\nIntuition\\ntake 2-d matrix of dp in which\\ni--> intial position and j --> final postion\\nsee all possible valid combination for palindrom and store it in this array\\n-> upper half of this array is not useful or invalid because i>j mean intial pos > final pos --> not valid\\n-> for i==j mean only one word and it is always palindromic\\n-> for j-i ==1 mean two word it is only palindromic when both char are same( s[i] == s[j])\\n\\n-> now main point for all other case :-\\n( understand my solution upto this point upvote it vro :) )\\nfor palindromic -> first pos char (i) and last pos char(j) must be equal and the portion in between then aslo need to be equal.\\n\\ni and using not traditional for loop and slightly modify it for only considred valid case ( i<=j)\\n\\n//for answer\\ni take two variable start and end store 0 ( mean first char of string in that (single char definately palindromic))\\n->for each palindrom case i check wheater\\ntheir j -i ( string length ) is greater then my ans lenght ( end - start) --> if it is then i change my start and end ( start =i ,end =j)\\n\\nnote * :-\\nfor string len >=1 --> answer>=1 and because of that i intially take length one not checking for one length\\n\\nApproach\\nbottom up dynamic programming\\n\\nComplexity\\nTime complexity:\\n0(n2)\\n\\nSpace complexity:\\n0(n2)\\n\\nCode\\n\\n//////  for explaination refer pep coding :)\\nclass Solution {\\npublic:\\nint dp[1000][1000];\\n    string longestPalindrome(string s) {\\n    \\n\\n    memset( dp,0, sizeof(dp));\\n     int i = 0 , j =0 ;\\n     int g =0, n = s.size();\\n     int start =0, end=0;\\n\\n if( n ==1)\\n   {  \\n   return s;  \\n}\\n     for( int g=0; g<n ;g++ )  /// gap \\n     {\\n         for( int i = 0 ,j=g ; i<n && j<n ;i++, j++ ) // covering all possible of i<j\\n         {\\n           \\n           if(i==j)\\n           {             \\n               dp[i][j] =1;\\n               continue;\\n           }\\n\\n           if(j-i==1 &&s[i]==s[j])\\n           {           \\n                dp[i][j] =1;\\n                \\n                if((j-i) >(end-start) )\\n                {\\n                     start =i;\\n                     end =j;\\n                }\\n                 \\n           continue;\\n           }\\n        \\n            \\n            if( s[i]==s[j] && dp[i+1][j-1]==1)\\n            { \\n                 dp[i][j] =1;\\n                \\n                if( j-i> (end-start) )\\n                {\\n                     start =i;\\n                     end =j;\\n                }\\n                  \\n            }\\n             \\n         }\\n     }\\n\\n     return s.substr(start, end+1-start);   \\n    }\\n};"
                    },
                    {
                        "username": "MiGameasa",
                        "content": "Hi, I'm kinda new and this is my code, it only work with palin string that 3 or less. Can someone point out how to fix this? \n\n```class Solution {\n    public String longestPalindrome(String s) {\n        int left=0, right=s.length()-1, temp = 0;\n        for(int i = 0; i < s.length(); i++){\n            for(int j = right; j > i; j--){\n                if(s.charAt(i) != s.charAt(j)){\n                    continue;\n                }else{\n                    left = i;\n                    right = j;\n                    temp = right;\n                    right--;\n                    break;\n                }\n            }\n        }\n\n        return s.substring(left, temp + 1);\n    }\n}"
                    },
                    {
                        "username": "Namasteydunia",
                        "content": "why it is not letting us use reverse() function in javascript. reverse() is a valid javascript function to reverse a string."
                    },
                    {
                        "username": "charucjoshi",
                        "content": "Can someone please explain why this is wrong?\\n\\nWrong Answer\\ns=\"aacabdkacaa\"\\nOutput\\n\"aacakacaa\"\\nExpected\\n\"aca\""
                    },
                    {
                        "username": "alphazwest",
                        "content": "For the first case, are not `abba` and `baab` both palindromic substrings -- both *longer* than the given solution output? "
                    },
                    {
                        "username": "harshitha____9",
                        "content": "why time limit exceeding?\\n\\nbool check(string s,int i,int j)\\n{\\n    \\n    while(i<=j)\\n    {\\n        if(s[i]!=s[j])\\n        {\\n            return false;\\n        }\\n        i++;\\n        j--;\\n    }\\n    return true;\\n}\\n void f(int i,int j,string&ans,string s)\\n {\\n     if(i>j) return;\\n     if(j<0) return;\\n    if(check(s,i,j))\\n    {\\n        if(ans.size()<(j-i+1))\\n        {\\n            ans=s.substr(i,j-i+1);\\n        }\\n        return;\\n    }\\n    \\n     f(i+1,j,ans,s);\\n     f(i,j-1,ans,s);\\n    \\n }\\n    string longestPalindrome(string s) {\\n        int i=0,j=s.size()-1;\\n        string ans=\"\";\\n        f(i,j,ans,s);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "nishantwestside",
                        "content": "There seems to be an extra curly brace at the end of your code, which may be causing a syntax error. However, assuming that this is a typographical error, the most likely reason why your code is exceeding the limit is because the time complexity of the algorithm is high.\\n\\nThe code is using a recursive function to check all possible substrings in the input string s, and then checking if they are palindromes or not using the check() function. This approach has an exponential time complexity of O(2^n), where n is the length of the input string s.\\n\\nThis means that as the length of the input string grows, the number of recursive calls made by the algorithm also grows exponentially, leading to a potential stack overflow or timeout.\\n\\nTo optimize the algorithm, you can use dynamic programming or expand around the center approach to reduce the time complexity to O(n2).\\n\\nDynamic Programming Approach:\\n\\n- Define a boolean table of size n x n, where n is the length of the input string.\\n- Initialize all cells in the table to false.\\n- Set all cells (i, i) to true, since a single character is always a palindrome.\\n- For all pairs of indices i, j where i < j, set table[i][j] to true if s[i] == s[j] and table[i+1][j-1] is also true. - This means that a substring from i to j is a palindrome if its first and last characters are equal, and its - inner substring is also a palindrome.\\n- Keep track of the longest palindrome found so far and its starting and ending indices."
                    },
                    {
                        "username": "optic188",
                        "content": "actually really curios about error one one of test cases \\nTime Limit Exceeded\\nnothing mentioned in desciption about complexity of algoritm or memeory using restrictions ? Why then this test case is not passing "
                    },
                    {
                        "username": "yashAryan",
                        "content": "Line 1061: Char 9: runtime error: addition of unsigned offset to 0x7fff8d8fc2b0 overflowed to 0x7fff8d8fc2af (basic_string.h)\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/basic_string.h:1070:9\n\n\n\n\nI am facing this error. Can anyone tell me what's wrong with my code?  \n class Solution {\npublic:\n    string longestPalindrome(string s) {\n        string t=\"#\";\n    for(int i=0;i<s.size();i++)\n    {\n        t+=s[i];\n        t+=\"#\";\n    }\n    int n=t.size();\n    vector<int> v(n,0);\n    int c=0,mirr=0,r=0;\n    for(int i=1;i<t.size()-1;i++)\n    {\n        mirr=2*c-i;\n        if(i<r and mirr>=0)\n        {\n            v[i]=min(v[mirr],r-i);\n        }\n        while(t[i+v[i]+1]==t[i-v[i]-1])\n        {\n            v[i]++;\n        }\n        if(i+v[i]>r)\n        {\n            c=i;\n            r=i+v[i];\n        }\n    }\n    int index=max_element(v.begin(),v.end())-v.begin();\n    int value=v[index];\n    int start=index-value;\n    string f=t.substr(start,2*value);\n    f.erase(remove(f.begin(),f.end(),'#'),f.end());\n\n    return f;\n    }\n};\n\n[Link to the question](https://leetcode.com/problems/longest-palindromic-substring/description/)"
                    },
                    {
                        "username": "DavidLindon",
                        "content": "This problem is extremely poor since it isn\\'t obvious that all the test cases can easily be solved by expanding around center.\\n\\nWhat about \"bbbba\", output should be bbbb!"
                    },
                    {
                        "username": "harshitha____9",
                        "content": "string f(int i,int j,string ref,string s,string&ans)\\n {\\n     if(i>=j) return ref;\\n     if(s[i]==s[j])\\n     {\\n         i++;\\n         j--;\\n     }\\n     else if(s[i]!=s[j])\\n     {\\n         string l=f(i+1,j,ref.substr(i+1,j-i),s,ans);\\n         string r=f(i,j-1,ref.substr(i,j-i),s,ans);\\n         if(l.size()>r.size())\\n         {\\n             ans=l;\\n         }\\n         else\\n         {\\n             ans=r;\\n         }\\n     }\\n      \\n     return ref;\\n }\\n    string longestPalindrome(string s) {\\n        int i=0,j=s.size()-1;\\n        string c=s;\\n        string ans=\"\";\\n        f(i,j,c,s,ans);\\n        return ans;\\n    }\\nwhat is wrong with this code......"
                    }
                ]
            },
            {
                "id": 1853707,
                "content": [
                    {
                        "username": "ankush920",
                        "content": "\\nEXPLAINED TEXT || C++ || DYNAMIC PROGRAMMING\\nankush920\\n0\\nin a few seconds\\nIntuition\\ntake 2-d matrix of dp in which\\ni--> intial position and j --> final postion\\nsee all possible valid combination for palindrom and store it in this array\\n-> upper half of this array is not useful or invalid because i>j mean intial pos > final pos --> not valid\\n-> for i==j mean only one word and it is always palindromic\\n-> for j-i ==1 mean two word it is only palindromic when both char are same( s[i] == s[j])\\n\\n-> now main point for all other case :-\\n( understand my solution upto this point upvote it vro :) )\\nfor palindromic -> first pos char (i) and last pos char(j) must be equal and the portion in between then aslo need to be equal.\\n\\ni and using not traditional for loop and slightly modify it for only considred valid case ( i<=j)\\n\\n//for answer\\ni take two variable start and end store 0 ( mean first char of string in that (single char definately palindromic))\\n->for each palindrom case i check wheater\\ntheir j -i ( string length ) is greater then my ans lenght ( end - start) --> if it is then i change my start and end ( start =i ,end =j)\\n\\nnote * :-\\nfor string len >=1 --> answer>=1 and because of that i intially take length one not checking for one length\\n\\nApproach\\nbottom up dynamic programming\\n\\nComplexity\\nTime complexity:\\n0(n2)\\n\\nSpace complexity:\\n0(n2)\\n\\nCode\\n\\n//////  for explaination refer pep coding :)\\nclass Solution {\\npublic:\\nint dp[1000][1000];\\n    string longestPalindrome(string s) {\\n    \\n\\n    memset( dp,0, sizeof(dp));\\n     int i = 0 , j =0 ;\\n     int g =0, n = s.size();\\n     int start =0, end=0;\\n\\n if( n ==1)\\n   {  \\n   return s;  \\n}\\n     for( int g=0; g<n ;g++ )  /// gap \\n     {\\n         for( int i = 0 ,j=g ; i<n && j<n ;i++, j++ ) // covering all possible of i<j\\n         {\\n           \\n           if(i==j)\\n           {             \\n               dp[i][j] =1;\\n               continue;\\n           }\\n\\n           if(j-i==1 &&s[i]==s[j])\\n           {           \\n                dp[i][j] =1;\\n                \\n                if((j-i) >(end-start) )\\n                {\\n                     start =i;\\n                     end =j;\\n                }\\n                 \\n           continue;\\n           }\\n        \\n            \\n            if( s[i]==s[j] && dp[i+1][j-1]==1)\\n            { \\n                 dp[i][j] =1;\\n                \\n                if( j-i> (end-start) )\\n                {\\n                     start =i;\\n                     end =j;\\n                }\\n                  \\n            }\\n             \\n         }\\n     }\\n\\n     return s.substr(start, end+1-start);   \\n    }\\n};"
                    },
                    {
                        "username": "MiGameasa",
                        "content": "Hi, I'm kinda new and this is my code, it only work with palin string that 3 or less. Can someone point out how to fix this? \n\n```class Solution {\n    public String longestPalindrome(String s) {\n        int left=0, right=s.length()-1, temp = 0;\n        for(int i = 0; i < s.length(); i++){\n            for(int j = right; j > i; j--){\n                if(s.charAt(i) != s.charAt(j)){\n                    continue;\n                }else{\n                    left = i;\n                    right = j;\n                    temp = right;\n                    right--;\n                    break;\n                }\n            }\n        }\n\n        return s.substring(left, temp + 1);\n    }\n}"
                    },
                    {
                        "username": "Namasteydunia",
                        "content": "why it is not letting us use reverse() function in javascript. reverse() is a valid javascript function to reverse a string."
                    },
                    {
                        "username": "charucjoshi",
                        "content": "Can someone please explain why this is wrong?\\n\\nWrong Answer\\ns=\"aacabdkacaa\"\\nOutput\\n\"aacakacaa\"\\nExpected\\n\"aca\""
                    },
                    {
                        "username": "alphazwest",
                        "content": "For the first case, are not `abba` and `baab` both palindromic substrings -- both *longer* than the given solution output? "
                    },
                    {
                        "username": "harshitha____9",
                        "content": "why time limit exceeding?\\n\\nbool check(string s,int i,int j)\\n{\\n    \\n    while(i<=j)\\n    {\\n        if(s[i]!=s[j])\\n        {\\n            return false;\\n        }\\n        i++;\\n        j--;\\n    }\\n    return true;\\n}\\n void f(int i,int j,string&ans,string s)\\n {\\n     if(i>j) return;\\n     if(j<0) return;\\n    if(check(s,i,j))\\n    {\\n        if(ans.size()<(j-i+1))\\n        {\\n            ans=s.substr(i,j-i+1);\\n        }\\n        return;\\n    }\\n    \\n     f(i+1,j,ans,s);\\n     f(i,j-1,ans,s);\\n    \\n }\\n    string longestPalindrome(string s) {\\n        int i=0,j=s.size()-1;\\n        string ans=\"\";\\n        f(i,j,ans,s);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "nishantwestside",
                        "content": "There seems to be an extra curly brace at the end of your code, which may be causing a syntax error. However, assuming that this is a typographical error, the most likely reason why your code is exceeding the limit is because the time complexity of the algorithm is high.\\n\\nThe code is using a recursive function to check all possible substrings in the input string s, and then checking if they are palindromes or not using the check() function. This approach has an exponential time complexity of O(2^n), where n is the length of the input string s.\\n\\nThis means that as the length of the input string grows, the number of recursive calls made by the algorithm also grows exponentially, leading to a potential stack overflow or timeout.\\n\\nTo optimize the algorithm, you can use dynamic programming or expand around the center approach to reduce the time complexity to O(n2).\\n\\nDynamic Programming Approach:\\n\\n- Define a boolean table of size n x n, where n is the length of the input string.\\n- Initialize all cells in the table to false.\\n- Set all cells (i, i) to true, since a single character is always a palindrome.\\n- For all pairs of indices i, j where i < j, set table[i][j] to true if s[i] == s[j] and table[i+1][j-1] is also true. - This means that a substring from i to j is a palindrome if its first and last characters are equal, and its - inner substring is also a palindrome.\\n- Keep track of the longest palindrome found so far and its starting and ending indices."
                    },
                    {
                        "username": "optic188",
                        "content": "actually really curios about error one one of test cases \\nTime Limit Exceeded\\nnothing mentioned in desciption about complexity of algoritm or memeory using restrictions ? Why then this test case is not passing "
                    },
                    {
                        "username": "yashAryan",
                        "content": "Line 1061: Char 9: runtime error: addition of unsigned offset to 0x7fff8d8fc2b0 overflowed to 0x7fff8d8fc2af (basic_string.h)\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/basic_string.h:1070:9\n\n\n\n\nI am facing this error. Can anyone tell me what's wrong with my code?  \n class Solution {\npublic:\n    string longestPalindrome(string s) {\n        string t=\"#\";\n    for(int i=0;i<s.size();i++)\n    {\n        t+=s[i];\n        t+=\"#\";\n    }\n    int n=t.size();\n    vector<int> v(n,0);\n    int c=0,mirr=0,r=0;\n    for(int i=1;i<t.size()-1;i++)\n    {\n        mirr=2*c-i;\n        if(i<r and mirr>=0)\n        {\n            v[i]=min(v[mirr],r-i);\n        }\n        while(t[i+v[i]+1]==t[i-v[i]-1])\n        {\n            v[i]++;\n        }\n        if(i+v[i]>r)\n        {\n            c=i;\n            r=i+v[i];\n        }\n    }\n    int index=max_element(v.begin(),v.end())-v.begin();\n    int value=v[index];\n    int start=index-value;\n    string f=t.substr(start,2*value);\n    f.erase(remove(f.begin(),f.end(),'#'),f.end());\n\n    return f;\n    }\n};\n\n[Link to the question](https://leetcode.com/problems/longest-palindromic-substring/description/)"
                    },
                    {
                        "username": "DavidLindon",
                        "content": "This problem is extremely poor since it isn\\'t obvious that all the test cases can easily be solved by expanding around center.\\n\\nWhat about \"bbbba\", output should be bbbb!"
                    },
                    {
                        "username": "harshitha____9",
                        "content": "string f(int i,int j,string ref,string s,string&ans)\\n {\\n     if(i>=j) return ref;\\n     if(s[i]==s[j])\\n     {\\n         i++;\\n         j--;\\n     }\\n     else if(s[i]!=s[j])\\n     {\\n         string l=f(i+1,j,ref.substr(i+1,j-i),s,ans);\\n         string r=f(i,j-1,ref.substr(i,j-i),s,ans);\\n         if(l.size()>r.size())\\n         {\\n             ans=l;\\n         }\\n         else\\n         {\\n             ans=r;\\n         }\\n     }\\n      \\n     return ref;\\n }\\n    string longestPalindrome(string s) {\\n        int i=0,j=s.size()-1;\\n        string c=s;\\n        string ans=\"\";\\n        f(i,j,c,s,ans);\\n        return ans;\\n    }\\nwhat is wrong with this code......"
                    }
                ]
            },
            {
                "id": 1848242,
                "content": [
                    {
                        "username": "ankush920",
                        "content": "\\nEXPLAINED TEXT || C++ || DYNAMIC PROGRAMMING\\nankush920\\n0\\nin a few seconds\\nIntuition\\ntake 2-d matrix of dp in which\\ni--> intial position and j --> final postion\\nsee all possible valid combination for palindrom and store it in this array\\n-> upper half of this array is not useful or invalid because i>j mean intial pos > final pos --> not valid\\n-> for i==j mean only one word and it is always palindromic\\n-> for j-i ==1 mean two word it is only palindromic when both char are same( s[i] == s[j])\\n\\n-> now main point for all other case :-\\n( understand my solution upto this point upvote it vro :) )\\nfor palindromic -> first pos char (i) and last pos char(j) must be equal and the portion in between then aslo need to be equal.\\n\\ni and using not traditional for loop and slightly modify it for only considred valid case ( i<=j)\\n\\n//for answer\\ni take two variable start and end store 0 ( mean first char of string in that (single char definately palindromic))\\n->for each palindrom case i check wheater\\ntheir j -i ( string length ) is greater then my ans lenght ( end - start) --> if it is then i change my start and end ( start =i ,end =j)\\n\\nnote * :-\\nfor string len >=1 --> answer>=1 and because of that i intially take length one not checking for one length\\n\\nApproach\\nbottom up dynamic programming\\n\\nComplexity\\nTime complexity:\\n0(n2)\\n\\nSpace complexity:\\n0(n2)\\n\\nCode\\n\\n//////  for explaination refer pep coding :)\\nclass Solution {\\npublic:\\nint dp[1000][1000];\\n    string longestPalindrome(string s) {\\n    \\n\\n    memset( dp,0, sizeof(dp));\\n     int i = 0 , j =0 ;\\n     int g =0, n = s.size();\\n     int start =0, end=0;\\n\\n if( n ==1)\\n   {  \\n   return s;  \\n}\\n     for( int g=0; g<n ;g++ )  /// gap \\n     {\\n         for( int i = 0 ,j=g ; i<n && j<n ;i++, j++ ) // covering all possible of i<j\\n         {\\n           \\n           if(i==j)\\n           {             \\n               dp[i][j] =1;\\n               continue;\\n           }\\n\\n           if(j-i==1 &&s[i]==s[j])\\n           {           \\n                dp[i][j] =1;\\n                \\n                if((j-i) >(end-start) )\\n                {\\n                     start =i;\\n                     end =j;\\n                }\\n                 \\n           continue;\\n           }\\n        \\n            \\n            if( s[i]==s[j] && dp[i+1][j-1]==1)\\n            { \\n                 dp[i][j] =1;\\n                \\n                if( j-i> (end-start) )\\n                {\\n                     start =i;\\n                     end =j;\\n                }\\n                  \\n            }\\n             \\n         }\\n     }\\n\\n     return s.substr(start, end+1-start);   \\n    }\\n};"
                    },
                    {
                        "username": "MiGameasa",
                        "content": "Hi, I'm kinda new and this is my code, it only work with palin string that 3 or less. Can someone point out how to fix this? \n\n```class Solution {\n    public String longestPalindrome(String s) {\n        int left=0, right=s.length()-1, temp = 0;\n        for(int i = 0; i < s.length(); i++){\n            for(int j = right; j > i; j--){\n                if(s.charAt(i) != s.charAt(j)){\n                    continue;\n                }else{\n                    left = i;\n                    right = j;\n                    temp = right;\n                    right--;\n                    break;\n                }\n            }\n        }\n\n        return s.substring(left, temp + 1);\n    }\n}"
                    },
                    {
                        "username": "Namasteydunia",
                        "content": "why it is not letting us use reverse() function in javascript. reverse() is a valid javascript function to reverse a string."
                    },
                    {
                        "username": "charucjoshi",
                        "content": "Can someone please explain why this is wrong?\\n\\nWrong Answer\\ns=\"aacabdkacaa\"\\nOutput\\n\"aacakacaa\"\\nExpected\\n\"aca\""
                    },
                    {
                        "username": "alphazwest",
                        "content": "For the first case, are not `abba` and `baab` both palindromic substrings -- both *longer* than the given solution output? "
                    },
                    {
                        "username": "harshitha____9",
                        "content": "why time limit exceeding?\\n\\nbool check(string s,int i,int j)\\n{\\n    \\n    while(i<=j)\\n    {\\n        if(s[i]!=s[j])\\n        {\\n            return false;\\n        }\\n        i++;\\n        j--;\\n    }\\n    return true;\\n}\\n void f(int i,int j,string&ans,string s)\\n {\\n     if(i>j) return;\\n     if(j<0) return;\\n    if(check(s,i,j))\\n    {\\n        if(ans.size()<(j-i+1))\\n        {\\n            ans=s.substr(i,j-i+1);\\n        }\\n        return;\\n    }\\n    \\n     f(i+1,j,ans,s);\\n     f(i,j-1,ans,s);\\n    \\n }\\n    string longestPalindrome(string s) {\\n        int i=0,j=s.size()-1;\\n        string ans=\"\";\\n        f(i,j,ans,s);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "nishantwestside",
                        "content": "There seems to be an extra curly brace at the end of your code, which may be causing a syntax error. However, assuming that this is a typographical error, the most likely reason why your code is exceeding the limit is because the time complexity of the algorithm is high.\\n\\nThe code is using a recursive function to check all possible substrings in the input string s, and then checking if they are palindromes or not using the check() function. This approach has an exponential time complexity of O(2^n), where n is the length of the input string s.\\n\\nThis means that as the length of the input string grows, the number of recursive calls made by the algorithm also grows exponentially, leading to a potential stack overflow or timeout.\\n\\nTo optimize the algorithm, you can use dynamic programming or expand around the center approach to reduce the time complexity to O(n2).\\n\\nDynamic Programming Approach:\\n\\n- Define a boolean table of size n x n, where n is the length of the input string.\\n- Initialize all cells in the table to false.\\n- Set all cells (i, i) to true, since a single character is always a palindrome.\\n- For all pairs of indices i, j where i < j, set table[i][j] to true if s[i] == s[j] and table[i+1][j-1] is also true. - This means that a substring from i to j is a palindrome if its first and last characters are equal, and its - inner substring is also a palindrome.\\n- Keep track of the longest palindrome found so far and its starting and ending indices."
                    },
                    {
                        "username": "optic188",
                        "content": "actually really curios about error one one of test cases \\nTime Limit Exceeded\\nnothing mentioned in desciption about complexity of algoritm or memeory using restrictions ? Why then this test case is not passing "
                    },
                    {
                        "username": "yashAryan",
                        "content": "Line 1061: Char 9: runtime error: addition of unsigned offset to 0x7fff8d8fc2b0 overflowed to 0x7fff8d8fc2af (basic_string.h)\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/basic_string.h:1070:9\n\n\n\n\nI am facing this error. Can anyone tell me what's wrong with my code?  \n class Solution {\npublic:\n    string longestPalindrome(string s) {\n        string t=\"#\";\n    for(int i=0;i<s.size();i++)\n    {\n        t+=s[i];\n        t+=\"#\";\n    }\n    int n=t.size();\n    vector<int> v(n,0);\n    int c=0,mirr=0,r=0;\n    for(int i=1;i<t.size()-1;i++)\n    {\n        mirr=2*c-i;\n        if(i<r and mirr>=0)\n        {\n            v[i]=min(v[mirr],r-i);\n        }\n        while(t[i+v[i]+1]==t[i-v[i]-1])\n        {\n            v[i]++;\n        }\n        if(i+v[i]>r)\n        {\n            c=i;\n            r=i+v[i];\n        }\n    }\n    int index=max_element(v.begin(),v.end())-v.begin();\n    int value=v[index];\n    int start=index-value;\n    string f=t.substr(start,2*value);\n    f.erase(remove(f.begin(),f.end(),'#'),f.end());\n\n    return f;\n    }\n};\n\n[Link to the question](https://leetcode.com/problems/longest-palindromic-substring/description/)"
                    },
                    {
                        "username": "DavidLindon",
                        "content": "This problem is extremely poor since it isn\\'t obvious that all the test cases can easily be solved by expanding around center.\\n\\nWhat about \"bbbba\", output should be bbbb!"
                    },
                    {
                        "username": "harshitha____9",
                        "content": "string f(int i,int j,string ref,string s,string&ans)\\n {\\n     if(i>=j) return ref;\\n     if(s[i]==s[j])\\n     {\\n         i++;\\n         j--;\\n     }\\n     else if(s[i]!=s[j])\\n     {\\n         string l=f(i+1,j,ref.substr(i+1,j-i),s,ans);\\n         string r=f(i,j-1,ref.substr(i,j-i),s,ans);\\n         if(l.size()>r.size())\\n         {\\n             ans=l;\\n         }\\n         else\\n         {\\n             ans=r;\\n         }\\n     }\\n      \\n     return ref;\\n }\\n    string longestPalindrome(string s) {\\n        int i=0,j=s.size()-1;\\n        string c=s;\\n        string ans=\"\";\\n        f(i,j,c,s,ans);\\n        return ans;\\n    }\\nwhat is wrong with this code......"
                    }
                ]
            },
            {
                "id": 1845223,
                "content": [
                    {
                        "username": "ankush920",
                        "content": "\\nEXPLAINED TEXT || C++ || DYNAMIC PROGRAMMING\\nankush920\\n0\\nin a few seconds\\nIntuition\\ntake 2-d matrix of dp in which\\ni--> intial position and j --> final postion\\nsee all possible valid combination for palindrom and store it in this array\\n-> upper half of this array is not useful or invalid because i>j mean intial pos > final pos --> not valid\\n-> for i==j mean only one word and it is always palindromic\\n-> for j-i ==1 mean two word it is only palindromic when both char are same( s[i] == s[j])\\n\\n-> now main point for all other case :-\\n( understand my solution upto this point upvote it vro :) )\\nfor palindromic -> first pos char (i) and last pos char(j) must be equal and the portion in between then aslo need to be equal.\\n\\ni and using not traditional for loop and slightly modify it for only considred valid case ( i<=j)\\n\\n//for answer\\ni take two variable start and end store 0 ( mean first char of string in that (single char definately palindromic))\\n->for each palindrom case i check wheater\\ntheir j -i ( string length ) is greater then my ans lenght ( end - start) --> if it is then i change my start and end ( start =i ,end =j)\\n\\nnote * :-\\nfor string len >=1 --> answer>=1 and because of that i intially take length one not checking for one length\\n\\nApproach\\nbottom up dynamic programming\\n\\nComplexity\\nTime complexity:\\n0(n2)\\n\\nSpace complexity:\\n0(n2)\\n\\nCode\\n\\n//////  for explaination refer pep coding :)\\nclass Solution {\\npublic:\\nint dp[1000][1000];\\n    string longestPalindrome(string s) {\\n    \\n\\n    memset( dp,0, sizeof(dp));\\n     int i = 0 , j =0 ;\\n     int g =0, n = s.size();\\n     int start =0, end=0;\\n\\n if( n ==1)\\n   {  \\n   return s;  \\n}\\n     for( int g=0; g<n ;g++ )  /// gap \\n     {\\n         for( int i = 0 ,j=g ; i<n && j<n ;i++, j++ ) // covering all possible of i<j\\n         {\\n           \\n           if(i==j)\\n           {             \\n               dp[i][j] =1;\\n               continue;\\n           }\\n\\n           if(j-i==1 &&s[i]==s[j])\\n           {           \\n                dp[i][j] =1;\\n                \\n                if((j-i) >(end-start) )\\n                {\\n                     start =i;\\n                     end =j;\\n                }\\n                 \\n           continue;\\n           }\\n        \\n            \\n            if( s[i]==s[j] && dp[i+1][j-1]==1)\\n            { \\n                 dp[i][j] =1;\\n                \\n                if( j-i> (end-start) )\\n                {\\n                     start =i;\\n                     end =j;\\n                }\\n                  \\n            }\\n             \\n         }\\n     }\\n\\n     return s.substr(start, end+1-start);   \\n    }\\n};"
                    },
                    {
                        "username": "MiGameasa",
                        "content": "Hi, I'm kinda new and this is my code, it only work with palin string that 3 or less. Can someone point out how to fix this? \n\n```class Solution {\n    public String longestPalindrome(String s) {\n        int left=0, right=s.length()-1, temp = 0;\n        for(int i = 0; i < s.length(); i++){\n            for(int j = right; j > i; j--){\n                if(s.charAt(i) != s.charAt(j)){\n                    continue;\n                }else{\n                    left = i;\n                    right = j;\n                    temp = right;\n                    right--;\n                    break;\n                }\n            }\n        }\n\n        return s.substring(left, temp + 1);\n    }\n}"
                    },
                    {
                        "username": "Namasteydunia",
                        "content": "why it is not letting us use reverse() function in javascript. reverse() is a valid javascript function to reverse a string."
                    },
                    {
                        "username": "charucjoshi",
                        "content": "Can someone please explain why this is wrong?\\n\\nWrong Answer\\ns=\"aacabdkacaa\"\\nOutput\\n\"aacakacaa\"\\nExpected\\n\"aca\""
                    },
                    {
                        "username": "alphazwest",
                        "content": "For the first case, are not `abba` and `baab` both palindromic substrings -- both *longer* than the given solution output? "
                    },
                    {
                        "username": "harshitha____9",
                        "content": "why time limit exceeding?\\n\\nbool check(string s,int i,int j)\\n{\\n    \\n    while(i<=j)\\n    {\\n        if(s[i]!=s[j])\\n        {\\n            return false;\\n        }\\n        i++;\\n        j--;\\n    }\\n    return true;\\n}\\n void f(int i,int j,string&ans,string s)\\n {\\n     if(i>j) return;\\n     if(j<0) return;\\n    if(check(s,i,j))\\n    {\\n        if(ans.size()<(j-i+1))\\n        {\\n            ans=s.substr(i,j-i+1);\\n        }\\n        return;\\n    }\\n    \\n     f(i+1,j,ans,s);\\n     f(i,j-1,ans,s);\\n    \\n }\\n    string longestPalindrome(string s) {\\n        int i=0,j=s.size()-1;\\n        string ans=\"\";\\n        f(i,j,ans,s);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "nishantwestside",
                        "content": "There seems to be an extra curly brace at the end of your code, which may be causing a syntax error. However, assuming that this is a typographical error, the most likely reason why your code is exceeding the limit is because the time complexity of the algorithm is high.\\n\\nThe code is using a recursive function to check all possible substrings in the input string s, and then checking if they are palindromes or not using the check() function. This approach has an exponential time complexity of O(2^n), where n is the length of the input string s.\\n\\nThis means that as the length of the input string grows, the number of recursive calls made by the algorithm also grows exponentially, leading to a potential stack overflow or timeout.\\n\\nTo optimize the algorithm, you can use dynamic programming or expand around the center approach to reduce the time complexity to O(n2).\\n\\nDynamic Programming Approach:\\n\\n- Define a boolean table of size n x n, where n is the length of the input string.\\n- Initialize all cells in the table to false.\\n- Set all cells (i, i) to true, since a single character is always a palindrome.\\n- For all pairs of indices i, j where i < j, set table[i][j] to true if s[i] == s[j] and table[i+1][j-1] is also true. - This means that a substring from i to j is a palindrome if its first and last characters are equal, and its - inner substring is also a palindrome.\\n- Keep track of the longest palindrome found so far and its starting and ending indices."
                    },
                    {
                        "username": "optic188",
                        "content": "actually really curios about error one one of test cases \\nTime Limit Exceeded\\nnothing mentioned in desciption about complexity of algoritm or memeory using restrictions ? Why then this test case is not passing "
                    },
                    {
                        "username": "yashAryan",
                        "content": "Line 1061: Char 9: runtime error: addition of unsigned offset to 0x7fff8d8fc2b0 overflowed to 0x7fff8d8fc2af (basic_string.h)\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/basic_string.h:1070:9\n\n\n\n\nI am facing this error. Can anyone tell me what's wrong with my code?  \n class Solution {\npublic:\n    string longestPalindrome(string s) {\n        string t=\"#\";\n    for(int i=0;i<s.size();i++)\n    {\n        t+=s[i];\n        t+=\"#\";\n    }\n    int n=t.size();\n    vector<int> v(n,0);\n    int c=0,mirr=0,r=0;\n    for(int i=1;i<t.size()-1;i++)\n    {\n        mirr=2*c-i;\n        if(i<r and mirr>=0)\n        {\n            v[i]=min(v[mirr],r-i);\n        }\n        while(t[i+v[i]+1]==t[i-v[i]-1])\n        {\n            v[i]++;\n        }\n        if(i+v[i]>r)\n        {\n            c=i;\n            r=i+v[i];\n        }\n    }\n    int index=max_element(v.begin(),v.end())-v.begin();\n    int value=v[index];\n    int start=index-value;\n    string f=t.substr(start,2*value);\n    f.erase(remove(f.begin(),f.end(),'#'),f.end());\n\n    return f;\n    }\n};\n\n[Link to the question](https://leetcode.com/problems/longest-palindromic-substring/description/)"
                    },
                    {
                        "username": "DavidLindon",
                        "content": "This problem is extremely poor since it isn\\'t obvious that all the test cases can easily be solved by expanding around center.\\n\\nWhat about \"bbbba\", output should be bbbb!"
                    },
                    {
                        "username": "harshitha____9",
                        "content": "string f(int i,int j,string ref,string s,string&ans)\\n {\\n     if(i>=j) return ref;\\n     if(s[i]==s[j])\\n     {\\n         i++;\\n         j--;\\n     }\\n     else if(s[i]!=s[j])\\n     {\\n         string l=f(i+1,j,ref.substr(i+1,j-i),s,ans);\\n         string r=f(i,j-1,ref.substr(i,j-i),s,ans);\\n         if(l.size()>r.size())\\n         {\\n             ans=l;\\n         }\\n         else\\n         {\\n             ans=r;\\n         }\\n     }\\n      \\n     return ref;\\n }\\n    string longestPalindrome(string s) {\\n        int i=0,j=s.size()-1;\\n        string c=s;\\n        string ans=\"\";\\n        f(i,j,c,s,ans);\\n        return ans;\\n    }\\nwhat is wrong with this code......"
                    }
                ]
            },
            {
                "id": 1845027,
                "content": [
                    {
                        "username": "ankush920",
                        "content": "\\nEXPLAINED TEXT || C++ || DYNAMIC PROGRAMMING\\nankush920\\n0\\nin a few seconds\\nIntuition\\ntake 2-d matrix of dp in which\\ni--> intial position and j --> final postion\\nsee all possible valid combination for palindrom and store it in this array\\n-> upper half of this array is not useful or invalid because i>j mean intial pos > final pos --> not valid\\n-> for i==j mean only one word and it is always palindromic\\n-> for j-i ==1 mean two word it is only palindromic when both char are same( s[i] == s[j])\\n\\n-> now main point for all other case :-\\n( understand my solution upto this point upvote it vro :) )\\nfor palindromic -> first pos char (i) and last pos char(j) must be equal and the portion in between then aslo need to be equal.\\n\\ni and using not traditional for loop and slightly modify it for only considred valid case ( i<=j)\\n\\n//for answer\\ni take two variable start and end store 0 ( mean first char of string in that (single char definately palindromic))\\n->for each palindrom case i check wheater\\ntheir j -i ( string length ) is greater then my ans lenght ( end - start) --> if it is then i change my start and end ( start =i ,end =j)\\n\\nnote * :-\\nfor string len >=1 --> answer>=1 and because of that i intially take length one not checking for one length\\n\\nApproach\\nbottom up dynamic programming\\n\\nComplexity\\nTime complexity:\\n0(n2)\\n\\nSpace complexity:\\n0(n2)\\n\\nCode\\n\\n//////  for explaination refer pep coding :)\\nclass Solution {\\npublic:\\nint dp[1000][1000];\\n    string longestPalindrome(string s) {\\n    \\n\\n    memset( dp,0, sizeof(dp));\\n     int i = 0 , j =0 ;\\n     int g =0, n = s.size();\\n     int start =0, end=0;\\n\\n if( n ==1)\\n   {  \\n   return s;  \\n}\\n     for( int g=0; g<n ;g++ )  /// gap \\n     {\\n         for( int i = 0 ,j=g ; i<n && j<n ;i++, j++ ) // covering all possible of i<j\\n         {\\n           \\n           if(i==j)\\n           {             \\n               dp[i][j] =1;\\n               continue;\\n           }\\n\\n           if(j-i==1 &&s[i]==s[j])\\n           {           \\n                dp[i][j] =1;\\n                \\n                if((j-i) >(end-start) )\\n                {\\n                     start =i;\\n                     end =j;\\n                }\\n                 \\n           continue;\\n           }\\n        \\n            \\n            if( s[i]==s[j] && dp[i+1][j-1]==1)\\n            { \\n                 dp[i][j] =1;\\n                \\n                if( j-i> (end-start) )\\n                {\\n                     start =i;\\n                     end =j;\\n                }\\n                  \\n            }\\n             \\n         }\\n     }\\n\\n     return s.substr(start, end+1-start);   \\n    }\\n};"
                    },
                    {
                        "username": "MiGameasa",
                        "content": "Hi, I'm kinda new and this is my code, it only work with palin string that 3 or less. Can someone point out how to fix this? \n\n```class Solution {\n    public String longestPalindrome(String s) {\n        int left=0, right=s.length()-1, temp = 0;\n        for(int i = 0; i < s.length(); i++){\n            for(int j = right; j > i; j--){\n                if(s.charAt(i) != s.charAt(j)){\n                    continue;\n                }else{\n                    left = i;\n                    right = j;\n                    temp = right;\n                    right--;\n                    break;\n                }\n            }\n        }\n\n        return s.substring(left, temp + 1);\n    }\n}"
                    },
                    {
                        "username": "Namasteydunia",
                        "content": "why it is not letting us use reverse() function in javascript. reverse() is a valid javascript function to reverse a string."
                    },
                    {
                        "username": "charucjoshi",
                        "content": "Can someone please explain why this is wrong?\\n\\nWrong Answer\\ns=\"aacabdkacaa\"\\nOutput\\n\"aacakacaa\"\\nExpected\\n\"aca\""
                    },
                    {
                        "username": "alphazwest",
                        "content": "For the first case, are not `abba` and `baab` both palindromic substrings -- both *longer* than the given solution output? "
                    },
                    {
                        "username": "harshitha____9",
                        "content": "why time limit exceeding?\\n\\nbool check(string s,int i,int j)\\n{\\n    \\n    while(i<=j)\\n    {\\n        if(s[i]!=s[j])\\n        {\\n            return false;\\n        }\\n        i++;\\n        j--;\\n    }\\n    return true;\\n}\\n void f(int i,int j,string&ans,string s)\\n {\\n     if(i>j) return;\\n     if(j<0) return;\\n    if(check(s,i,j))\\n    {\\n        if(ans.size()<(j-i+1))\\n        {\\n            ans=s.substr(i,j-i+1);\\n        }\\n        return;\\n    }\\n    \\n     f(i+1,j,ans,s);\\n     f(i,j-1,ans,s);\\n    \\n }\\n    string longestPalindrome(string s) {\\n        int i=0,j=s.size()-1;\\n        string ans=\"\";\\n        f(i,j,ans,s);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "nishantwestside",
                        "content": "There seems to be an extra curly brace at the end of your code, which may be causing a syntax error. However, assuming that this is a typographical error, the most likely reason why your code is exceeding the limit is because the time complexity of the algorithm is high.\\n\\nThe code is using a recursive function to check all possible substrings in the input string s, and then checking if they are palindromes or not using the check() function. This approach has an exponential time complexity of O(2^n), where n is the length of the input string s.\\n\\nThis means that as the length of the input string grows, the number of recursive calls made by the algorithm also grows exponentially, leading to a potential stack overflow or timeout.\\n\\nTo optimize the algorithm, you can use dynamic programming or expand around the center approach to reduce the time complexity to O(n2).\\n\\nDynamic Programming Approach:\\n\\n- Define a boolean table of size n x n, where n is the length of the input string.\\n- Initialize all cells in the table to false.\\n- Set all cells (i, i) to true, since a single character is always a palindrome.\\n- For all pairs of indices i, j where i < j, set table[i][j] to true if s[i] == s[j] and table[i+1][j-1] is also true. - This means that a substring from i to j is a palindrome if its first and last characters are equal, and its - inner substring is also a palindrome.\\n- Keep track of the longest palindrome found so far and its starting and ending indices."
                    },
                    {
                        "username": "optic188",
                        "content": "actually really curios about error one one of test cases \\nTime Limit Exceeded\\nnothing mentioned in desciption about complexity of algoritm or memeory using restrictions ? Why then this test case is not passing "
                    },
                    {
                        "username": "yashAryan",
                        "content": "Line 1061: Char 9: runtime error: addition of unsigned offset to 0x7fff8d8fc2b0 overflowed to 0x7fff8d8fc2af (basic_string.h)\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/basic_string.h:1070:9\n\n\n\n\nI am facing this error. Can anyone tell me what's wrong with my code?  \n class Solution {\npublic:\n    string longestPalindrome(string s) {\n        string t=\"#\";\n    for(int i=0;i<s.size();i++)\n    {\n        t+=s[i];\n        t+=\"#\";\n    }\n    int n=t.size();\n    vector<int> v(n,0);\n    int c=0,mirr=0,r=0;\n    for(int i=1;i<t.size()-1;i++)\n    {\n        mirr=2*c-i;\n        if(i<r and mirr>=0)\n        {\n            v[i]=min(v[mirr],r-i);\n        }\n        while(t[i+v[i]+1]==t[i-v[i]-1])\n        {\n            v[i]++;\n        }\n        if(i+v[i]>r)\n        {\n            c=i;\n            r=i+v[i];\n        }\n    }\n    int index=max_element(v.begin(),v.end())-v.begin();\n    int value=v[index];\n    int start=index-value;\n    string f=t.substr(start,2*value);\n    f.erase(remove(f.begin(),f.end(),'#'),f.end());\n\n    return f;\n    }\n};\n\n[Link to the question](https://leetcode.com/problems/longest-palindromic-substring/description/)"
                    },
                    {
                        "username": "DavidLindon",
                        "content": "This problem is extremely poor since it isn\\'t obvious that all the test cases can easily be solved by expanding around center.\\n\\nWhat about \"bbbba\", output should be bbbb!"
                    },
                    {
                        "username": "harshitha____9",
                        "content": "string f(int i,int j,string ref,string s,string&ans)\\n {\\n     if(i>=j) return ref;\\n     if(s[i]==s[j])\\n     {\\n         i++;\\n         j--;\\n     }\\n     else if(s[i]!=s[j])\\n     {\\n         string l=f(i+1,j,ref.substr(i+1,j-i),s,ans);\\n         string r=f(i,j-1,ref.substr(i,j-i),s,ans);\\n         if(l.size()>r.size())\\n         {\\n             ans=l;\\n         }\\n         else\\n         {\\n             ans=r;\\n         }\\n     }\\n      \\n     return ref;\\n }\\n    string longestPalindrome(string s) {\\n        int i=0,j=s.size()-1;\\n        string c=s;\\n        string ans=\"\";\\n        f(i,j,c,s,ans);\\n        return ans;\\n    }\\nwhat is wrong with this code......"
                    }
                ]
            },
            {
                "id": 1840601,
                "content": [
                    {
                        "username": "ankush920",
                        "content": "\\nEXPLAINED TEXT || C++ || DYNAMIC PROGRAMMING\\nankush920\\n0\\nin a few seconds\\nIntuition\\ntake 2-d matrix of dp in which\\ni--> intial position and j --> final postion\\nsee all possible valid combination for palindrom and store it in this array\\n-> upper half of this array is not useful or invalid because i>j mean intial pos > final pos --> not valid\\n-> for i==j mean only one word and it is always palindromic\\n-> for j-i ==1 mean two word it is only palindromic when both char are same( s[i] == s[j])\\n\\n-> now main point for all other case :-\\n( understand my solution upto this point upvote it vro :) )\\nfor palindromic -> first pos char (i) and last pos char(j) must be equal and the portion in between then aslo need to be equal.\\n\\ni and using not traditional for loop and slightly modify it for only considred valid case ( i<=j)\\n\\n//for answer\\ni take two variable start and end store 0 ( mean first char of string in that (single char definately palindromic))\\n->for each palindrom case i check wheater\\ntheir j -i ( string length ) is greater then my ans lenght ( end - start) --> if it is then i change my start and end ( start =i ,end =j)\\n\\nnote * :-\\nfor string len >=1 --> answer>=1 and because of that i intially take length one not checking for one length\\n\\nApproach\\nbottom up dynamic programming\\n\\nComplexity\\nTime complexity:\\n0(n2)\\n\\nSpace complexity:\\n0(n2)\\n\\nCode\\n\\n//////  for explaination refer pep coding :)\\nclass Solution {\\npublic:\\nint dp[1000][1000];\\n    string longestPalindrome(string s) {\\n    \\n\\n    memset( dp,0, sizeof(dp));\\n     int i = 0 , j =0 ;\\n     int g =0, n = s.size();\\n     int start =0, end=0;\\n\\n if( n ==1)\\n   {  \\n   return s;  \\n}\\n     for( int g=0; g<n ;g++ )  /// gap \\n     {\\n         for( int i = 0 ,j=g ; i<n && j<n ;i++, j++ ) // covering all possible of i<j\\n         {\\n           \\n           if(i==j)\\n           {             \\n               dp[i][j] =1;\\n               continue;\\n           }\\n\\n           if(j-i==1 &&s[i]==s[j])\\n           {           \\n                dp[i][j] =1;\\n                \\n                if((j-i) >(end-start) )\\n                {\\n                     start =i;\\n                     end =j;\\n                }\\n                 \\n           continue;\\n           }\\n        \\n            \\n            if( s[i]==s[j] && dp[i+1][j-1]==1)\\n            { \\n                 dp[i][j] =1;\\n                \\n                if( j-i> (end-start) )\\n                {\\n                     start =i;\\n                     end =j;\\n                }\\n                  \\n            }\\n             \\n         }\\n     }\\n\\n     return s.substr(start, end+1-start);   \\n    }\\n};"
                    },
                    {
                        "username": "MiGameasa",
                        "content": "Hi, I'm kinda new and this is my code, it only work with palin string that 3 or less. Can someone point out how to fix this? \n\n```class Solution {\n    public String longestPalindrome(String s) {\n        int left=0, right=s.length()-1, temp = 0;\n        for(int i = 0; i < s.length(); i++){\n            for(int j = right; j > i; j--){\n                if(s.charAt(i) != s.charAt(j)){\n                    continue;\n                }else{\n                    left = i;\n                    right = j;\n                    temp = right;\n                    right--;\n                    break;\n                }\n            }\n        }\n\n        return s.substring(left, temp + 1);\n    }\n}"
                    },
                    {
                        "username": "Namasteydunia",
                        "content": "why it is not letting us use reverse() function in javascript. reverse() is a valid javascript function to reverse a string."
                    },
                    {
                        "username": "charucjoshi",
                        "content": "Can someone please explain why this is wrong?\\n\\nWrong Answer\\ns=\"aacabdkacaa\"\\nOutput\\n\"aacakacaa\"\\nExpected\\n\"aca\""
                    },
                    {
                        "username": "alphazwest",
                        "content": "For the first case, are not `abba` and `baab` both palindromic substrings -- both *longer* than the given solution output? "
                    },
                    {
                        "username": "harshitha____9",
                        "content": "why time limit exceeding?\\n\\nbool check(string s,int i,int j)\\n{\\n    \\n    while(i<=j)\\n    {\\n        if(s[i]!=s[j])\\n        {\\n            return false;\\n        }\\n        i++;\\n        j--;\\n    }\\n    return true;\\n}\\n void f(int i,int j,string&ans,string s)\\n {\\n     if(i>j) return;\\n     if(j<0) return;\\n    if(check(s,i,j))\\n    {\\n        if(ans.size()<(j-i+1))\\n        {\\n            ans=s.substr(i,j-i+1);\\n        }\\n        return;\\n    }\\n    \\n     f(i+1,j,ans,s);\\n     f(i,j-1,ans,s);\\n    \\n }\\n    string longestPalindrome(string s) {\\n        int i=0,j=s.size()-1;\\n        string ans=\"\";\\n        f(i,j,ans,s);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "nishantwestside",
                        "content": "There seems to be an extra curly brace at the end of your code, which may be causing a syntax error. However, assuming that this is a typographical error, the most likely reason why your code is exceeding the limit is because the time complexity of the algorithm is high.\\n\\nThe code is using a recursive function to check all possible substrings in the input string s, and then checking if they are palindromes or not using the check() function. This approach has an exponential time complexity of O(2^n), where n is the length of the input string s.\\n\\nThis means that as the length of the input string grows, the number of recursive calls made by the algorithm also grows exponentially, leading to a potential stack overflow or timeout.\\n\\nTo optimize the algorithm, you can use dynamic programming or expand around the center approach to reduce the time complexity to O(n2).\\n\\nDynamic Programming Approach:\\n\\n- Define a boolean table of size n x n, where n is the length of the input string.\\n- Initialize all cells in the table to false.\\n- Set all cells (i, i) to true, since a single character is always a palindrome.\\n- For all pairs of indices i, j where i < j, set table[i][j] to true if s[i] == s[j] and table[i+1][j-1] is also true. - This means that a substring from i to j is a palindrome if its first and last characters are equal, and its - inner substring is also a palindrome.\\n- Keep track of the longest palindrome found so far and its starting and ending indices."
                    },
                    {
                        "username": "optic188",
                        "content": "actually really curios about error one one of test cases \\nTime Limit Exceeded\\nnothing mentioned in desciption about complexity of algoritm or memeory using restrictions ? Why then this test case is not passing "
                    },
                    {
                        "username": "yashAryan",
                        "content": "Line 1061: Char 9: runtime error: addition of unsigned offset to 0x7fff8d8fc2b0 overflowed to 0x7fff8d8fc2af (basic_string.h)\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/basic_string.h:1070:9\n\n\n\n\nI am facing this error. Can anyone tell me what's wrong with my code?  \n class Solution {\npublic:\n    string longestPalindrome(string s) {\n        string t=\"#\";\n    for(int i=0;i<s.size();i++)\n    {\n        t+=s[i];\n        t+=\"#\";\n    }\n    int n=t.size();\n    vector<int> v(n,0);\n    int c=0,mirr=0,r=0;\n    for(int i=1;i<t.size()-1;i++)\n    {\n        mirr=2*c-i;\n        if(i<r and mirr>=0)\n        {\n            v[i]=min(v[mirr],r-i);\n        }\n        while(t[i+v[i]+1]==t[i-v[i]-1])\n        {\n            v[i]++;\n        }\n        if(i+v[i]>r)\n        {\n            c=i;\n            r=i+v[i];\n        }\n    }\n    int index=max_element(v.begin(),v.end())-v.begin();\n    int value=v[index];\n    int start=index-value;\n    string f=t.substr(start,2*value);\n    f.erase(remove(f.begin(),f.end(),'#'),f.end());\n\n    return f;\n    }\n};\n\n[Link to the question](https://leetcode.com/problems/longest-palindromic-substring/description/)"
                    },
                    {
                        "username": "DavidLindon",
                        "content": "This problem is extremely poor since it isn\\'t obvious that all the test cases can easily be solved by expanding around center.\\n\\nWhat about \"bbbba\", output should be bbbb!"
                    },
                    {
                        "username": "harshitha____9",
                        "content": "string f(int i,int j,string ref,string s,string&ans)\\n {\\n     if(i>=j) return ref;\\n     if(s[i]==s[j])\\n     {\\n         i++;\\n         j--;\\n     }\\n     else if(s[i]!=s[j])\\n     {\\n         string l=f(i+1,j,ref.substr(i+1,j-i),s,ans);\\n         string r=f(i,j-1,ref.substr(i,j-i),s,ans);\\n         if(l.size()>r.size())\\n         {\\n             ans=l;\\n         }\\n         else\\n         {\\n             ans=r;\\n         }\\n     }\\n      \\n     return ref;\\n }\\n    string longestPalindrome(string s) {\\n        int i=0,j=s.size()-1;\\n        string c=s;\\n        string ans=\"\";\\n        f(i,j,c,s,ans);\\n        return ans;\\n    }\\nwhat is wrong with this code......"
                    }
                ]
            },
            {
                "id": 1838635,
                "content": [
                    {
                        "username": "ankush920",
                        "content": "\\nEXPLAINED TEXT || C++ || DYNAMIC PROGRAMMING\\nankush920\\n0\\nin a few seconds\\nIntuition\\ntake 2-d matrix of dp in which\\ni--> intial position and j --> final postion\\nsee all possible valid combination for palindrom and store it in this array\\n-> upper half of this array is not useful or invalid because i>j mean intial pos > final pos --> not valid\\n-> for i==j mean only one word and it is always palindromic\\n-> for j-i ==1 mean two word it is only palindromic when both char are same( s[i] == s[j])\\n\\n-> now main point for all other case :-\\n( understand my solution upto this point upvote it vro :) )\\nfor palindromic -> first pos char (i) and last pos char(j) must be equal and the portion in between then aslo need to be equal.\\n\\ni and using not traditional for loop and slightly modify it for only considred valid case ( i<=j)\\n\\n//for answer\\ni take two variable start and end store 0 ( mean first char of string in that (single char definately palindromic))\\n->for each palindrom case i check wheater\\ntheir j -i ( string length ) is greater then my ans lenght ( end - start) --> if it is then i change my start and end ( start =i ,end =j)\\n\\nnote * :-\\nfor string len >=1 --> answer>=1 and because of that i intially take length one not checking for one length\\n\\nApproach\\nbottom up dynamic programming\\n\\nComplexity\\nTime complexity:\\n0(n2)\\n\\nSpace complexity:\\n0(n2)\\n\\nCode\\n\\n//////  for explaination refer pep coding :)\\nclass Solution {\\npublic:\\nint dp[1000][1000];\\n    string longestPalindrome(string s) {\\n    \\n\\n    memset( dp,0, sizeof(dp));\\n     int i = 0 , j =0 ;\\n     int g =0, n = s.size();\\n     int start =0, end=0;\\n\\n if( n ==1)\\n   {  \\n   return s;  \\n}\\n     for( int g=0; g<n ;g++ )  /// gap \\n     {\\n         for( int i = 0 ,j=g ; i<n && j<n ;i++, j++ ) // covering all possible of i<j\\n         {\\n           \\n           if(i==j)\\n           {             \\n               dp[i][j] =1;\\n               continue;\\n           }\\n\\n           if(j-i==1 &&s[i]==s[j])\\n           {           \\n                dp[i][j] =1;\\n                \\n                if((j-i) >(end-start) )\\n                {\\n                     start =i;\\n                     end =j;\\n                }\\n                 \\n           continue;\\n           }\\n        \\n            \\n            if( s[i]==s[j] && dp[i+1][j-1]==1)\\n            { \\n                 dp[i][j] =1;\\n                \\n                if( j-i> (end-start) )\\n                {\\n                     start =i;\\n                     end =j;\\n                }\\n                  \\n            }\\n             \\n         }\\n     }\\n\\n     return s.substr(start, end+1-start);   \\n    }\\n};"
                    },
                    {
                        "username": "MiGameasa",
                        "content": "Hi, I'm kinda new and this is my code, it only work with palin string that 3 or less. Can someone point out how to fix this? \n\n```class Solution {\n    public String longestPalindrome(String s) {\n        int left=0, right=s.length()-1, temp = 0;\n        for(int i = 0; i < s.length(); i++){\n            for(int j = right; j > i; j--){\n                if(s.charAt(i) != s.charAt(j)){\n                    continue;\n                }else{\n                    left = i;\n                    right = j;\n                    temp = right;\n                    right--;\n                    break;\n                }\n            }\n        }\n\n        return s.substring(left, temp + 1);\n    }\n}"
                    },
                    {
                        "username": "Namasteydunia",
                        "content": "why it is not letting us use reverse() function in javascript. reverse() is a valid javascript function to reverse a string."
                    },
                    {
                        "username": "charucjoshi",
                        "content": "Can someone please explain why this is wrong?\\n\\nWrong Answer\\ns=\"aacabdkacaa\"\\nOutput\\n\"aacakacaa\"\\nExpected\\n\"aca\""
                    },
                    {
                        "username": "alphazwest",
                        "content": "For the first case, are not `abba` and `baab` both palindromic substrings -- both *longer* than the given solution output? "
                    },
                    {
                        "username": "harshitha____9",
                        "content": "why time limit exceeding?\\n\\nbool check(string s,int i,int j)\\n{\\n    \\n    while(i<=j)\\n    {\\n        if(s[i]!=s[j])\\n        {\\n            return false;\\n        }\\n        i++;\\n        j--;\\n    }\\n    return true;\\n}\\n void f(int i,int j,string&ans,string s)\\n {\\n     if(i>j) return;\\n     if(j<0) return;\\n    if(check(s,i,j))\\n    {\\n        if(ans.size()<(j-i+1))\\n        {\\n            ans=s.substr(i,j-i+1);\\n        }\\n        return;\\n    }\\n    \\n     f(i+1,j,ans,s);\\n     f(i,j-1,ans,s);\\n    \\n }\\n    string longestPalindrome(string s) {\\n        int i=0,j=s.size()-1;\\n        string ans=\"\";\\n        f(i,j,ans,s);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "nishantwestside",
                        "content": "There seems to be an extra curly brace at the end of your code, which may be causing a syntax error. However, assuming that this is a typographical error, the most likely reason why your code is exceeding the limit is because the time complexity of the algorithm is high.\\n\\nThe code is using a recursive function to check all possible substrings in the input string s, and then checking if they are palindromes or not using the check() function. This approach has an exponential time complexity of O(2^n), where n is the length of the input string s.\\n\\nThis means that as the length of the input string grows, the number of recursive calls made by the algorithm also grows exponentially, leading to a potential stack overflow or timeout.\\n\\nTo optimize the algorithm, you can use dynamic programming or expand around the center approach to reduce the time complexity to O(n2).\\n\\nDynamic Programming Approach:\\n\\n- Define a boolean table of size n x n, where n is the length of the input string.\\n- Initialize all cells in the table to false.\\n- Set all cells (i, i) to true, since a single character is always a palindrome.\\n- For all pairs of indices i, j where i < j, set table[i][j] to true if s[i] == s[j] and table[i+1][j-1] is also true. - This means that a substring from i to j is a palindrome if its first and last characters are equal, and its - inner substring is also a palindrome.\\n- Keep track of the longest palindrome found so far and its starting and ending indices."
                    },
                    {
                        "username": "optic188",
                        "content": "actually really curios about error one one of test cases \\nTime Limit Exceeded\\nnothing mentioned in desciption about complexity of algoritm or memeory using restrictions ? Why then this test case is not passing "
                    },
                    {
                        "username": "yashAryan",
                        "content": "Line 1061: Char 9: runtime error: addition of unsigned offset to 0x7fff8d8fc2b0 overflowed to 0x7fff8d8fc2af (basic_string.h)\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/basic_string.h:1070:9\n\n\n\n\nI am facing this error. Can anyone tell me what's wrong with my code?  \n class Solution {\npublic:\n    string longestPalindrome(string s) {\n        string t=\"#\";\n    for(int i=0;i<s.size();i++)\n    {\n        t+=s[i];\n        t+=\"#\";\n    }\n    int n=t.size();\n    vector<int> v(n,0);\n    int c=0,mirr=0,r=0;\n    for(int i=1;i<t.size()-1;i++)\n    {\n        mirr=2*c-i;\n        if(i<r and mirr>=0)\n        {\n            v[i]=min(v[mirr],r-i);\n        }\n        while(t[i+v[i]+1]==t[i-v[i]-1])\n        {\n            v[i]++;\n        }\n        if(i+v[i]>r)\n        {\n            c=i;\n            r=i+v[i];\n        }\n    }\n    int index=max_element(v.begin(),v.end())-v.begin();\n    int value=v[index];\n    int start=index-value;\n    string f=t.substr(start,2*value);\n    f.erase(remove(f.begin(),f.end(),'#'),f.end());\n\n    return f;\n    }\n};\n\n[Link to the question](https://leetcode.com/problems/longest-palindromic-substring/description/)"
                    },
                    {
                        "username": "DavidLindon",
                        "content": "This problem is extremely poor since it isn\\'t obvious that all the test cases can easily be solved by expanding around center.\\n\\nWhat about \"bbbba\", output should be bbbb!"
                    },
                    {
                        "username": "harshitha____9",
                        "content": "string f(int i,int j,string ref,string s,string&ans)\\n {\\n     if(i>=j) return ref;\\n     if(s[i]==s[j])\\n     {\\n         i++;\\n         j--;\\n     }\\n     else if(s[i]!=s[j])\\n     {\\n         string l=f(i+1,j,ref.substr(i+1,j-i),s,ans);\\n         string r=f(i,j-1,ref.substr(i,j-i),s,ans);\\n         if(l.size()>r.size())\\n         {\\n             ans=l;\\n         }\\n         else\\n         {\\n             ans=r;\\n         }\\n     }\\n      \\n     return ref;\\n }\\n    string longestPalindrome(string s) {\\n        int i=0,j=s.size()-1;\\n        string c=s;\\n        string ans=\"\";\\n        f(i,j,c,s,ans);\\n        return ans;\\n    }\\nwhat is wrong with this code......"
                    }
                ]
            },
            {
                "id": 1833334,
                "content": [
                    {
                        "username": "Meena_leetcode",
                        "content": "for input \"cbbd\", wouldn\\'t the longest palindromic substring be \"bcb\" instead of \"bb\"?"
                    },
                    {
                        "username": "ufve0704terry",
                        "content": "I find out that I have such a big problem.\\nEverytime I AC I must need to have several times debug.\\nBut everytime I finish debug and AC,I don\\'t even know why the program can run...\\nI usually think that the program still have some problem I need to solve but it AC..."
                    },
                    {
                        "username": "Ritik_Gupta1",
                        "content": "Palindromic in String "
                    },
                    {
                        "username": "PythonAnalyst",
                        "content": "I passed all the tests except the last one, the 141st. At the last one, he submits either nothing or an empty line for input and writes \"Time Limit Exceed'. Has anyone encountered a similar problem?"
                    },
                    {
                        "username": "misuvasish114",
                        "content": "Can be solved in linear time using Manacher\\'s Algorithm\\nhttps://en.wikipedia.org/wiki/Longest_palindromic_substring#Manacher.27s_algorithm"
                    },
                    {
                        "username": "dunionwagner",
                        "content": "I think that a good testcase to test would be a test where it\\'s a complete palindrome, like racecar or tacocat, or bbbb."
                    },
                    {
                        "username": "vishakha_1102",
                        "content": "Can someone please tell me the error in this code? I\\'m not able to get why it is showing runtime error."
                    },
                    {
                        "username": "vishakha_1102",
                        "content": "string subString(string s, string x, int n, int m){\\n        int t[n+1][m+1];\\n        int result=0,r=0,c=0;\\n        string ans=\"\";\\n        for(int i=0;i<n+1;i++){\\n            for(int j=0;j<m+1;j++){\\n                if(i==0 || j==0)\\n                  t[i][j]=0;\\n                if(s[i-1]==x[j-1]){\\n                    t[i][j]=1+t[i-1][j-1];\\n                    if (result<t[i][j]) {\\n                     result = t[i][j];\\n                      r=i;\\n                      c=j;\\n                  }\\n                }\\n                else\\n                  t[i][j]=0;\\n            }\\n        }\\n        while(result>0){\\n           ans.push_back(s[r-1]);\\n           r--;\\n           result--;\\n        }\\n        return ans;\\n\\n    }\\n    string longestPalindrome(string s) {\\n     int n=s.size();\\n     string x =\"\";\\n     for(int i=n-1;i>=0;i--){\\n         x.push_back(s[i]);\\n     }\\n     return subString(s,x,n,n);\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "rahulgupta1597",
                        "content": "This will not work for input s =\"aacabdkacaa\""
                    },
                    {
                        "username": "cheungtriedtocode",
                        "content": "need help ,what can i do to solve TLE ,\\n```\\nclass Solution(object):\\n    def longestPalindrome(self, s):\\n        left = 0\\n        dp=\"\"\\n        \\n        for i in range(len(s)):\\n            left = i +1\\n            cur = \"\"\\n            while left<=len(s):\\n                # print(s[i:left])\\n                cur = s[i:left] if s[i:left]==s[i:left][::-1] else cur \\n                left+=1 \\n            dp = max(dp,cur,key=len)\\n      \\n        return dp \\n```"
                    },
                    {
                        "username": "pktk001",
                        "content": "141th testcase is not visible. I\\'m getting TLE on 141th testcase when I try to solve it with hashing.\\n"
                    }
                ]
            },
            {
                "id": 1829001,
                "content": [
                    {
                        "username": "Meena_leetcode",
                        "content": "for input \"cbbd\", wouldn\\'t the longest palindromic substring be \"bcb\" instead of \"bb\"?"
                    },
                    {
                        "username": "ufve0704terry",
                        "content": "I find out that I have such a big problem.\\nEverytime I AC I must need to have several times debug.\\nBut everytime I finish debug and AC,I don\\'t even know why the program can run...\\nI usually think that the program still have some problem I need to solve but it AC..."
                    },
                    {
                        "username": "Ritik_Gupta1",
                        "content": "Palindromic in String "
                    },
                    {
                        "username": "PythonAnalyst",
                        "content": "I passed all the tests except the last one, the 141st. At the last one, he submits either nothing or an empty line for input and writes \"Time Limit Exceed'. Has anyone encountered a similar problem?"
                    },
                    {
                        "username": "misuvasish114",
                        "content": "Can be solved in linear time using Manacher\\'s Algorithm\\nhttps://en.wikipedia.org/wiki/Longest_palindromic_substring#Manacher.27s_algorithm"
                    },
                    {
                        "username": "dunionwagner",
                        "content": "I think that a good testcase to test would be a test where it\\'s a complete palindrome, like racecar or tacocat, or bbbb."
                    },
                    {
                        "username": "vishakha_1102",
                        "content": "Can someone please tell me the error in this code? I\\'m not able to get why it is showing runtime error."
                    },
                    {
                        "username": "vishakha_1102",
                        "content": "string subString(string s, string x, int n, int m){\\n        int t[n+1][m+1];\\n        int result=0,r=0,c=0;\\n        string ans=\"\";\\n        for(int i=0;i<n+1;i++){\\n            for(int j=0;j<m+1;j++){\\n                if(i==0 || j==0)\\n                  t[i][j]=0;\\n                if(s[i-1]==x[j-1]){\\n                    t[i][j]=1+t[i-1][j-1];\\n                    if (result<t[i][j]) {\\n                     result = t[i][j];\\n                      r=i;\\n                      c=j;\\n                  }\\n                }\\n                else\\n                  t[i][j]=0;\\n            }\\n        }\\n        while(result>0){\\n           ans.push_back(s[r-1]);\\n           r--;\\n           result--;\\n        }\\n        return ans;\\n\\n    }\\n    string longestPalindrome(string s) {\\n     int n=s.size();\\n     string x =\"\";\\n     for(int i=n-1;i>=0;i--){\\n         x.push_back(s[i]);\\n     }\\n     return subString(s,x,n,n);\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "rahulgupta1597",
                        "content": "This will not work for input s =\"aacabdkacaa\""
                    },
                    {
                        "username": "cheungtriedtocode",
                        "content": "need help ,what can i do to solve TLE ,\\n```\\nclass Solution(object):\\n    def longestPalindrome(self, s):\\n        left = 0\\n        dp=\"\"\\n        \\n        for i in range(len(s)):\\n            left = i +1\\n            cur = \"\"\\n            while left<=len(s):\\n                # print(s[i:left])\\n                cur = s[i:left] if s[i:left]==s[i:left][::-1] else cur \\n                left+=1 \\n            dp = max(dp,cur,key=len)\\n      \\n        return dp \\n```"
                    },
                    {
                        "username": "pktk001",
                        "content": "141th testcase is not visible. I\\'m getting TLE on 141th testcase when I try to solve it with hashing.\\n"
                    }
                ]
            },
            {
                "id": 1828061,
                "content": [
                    {
                        "username": "Meena_leetcode",
                        "content": "for input \"cbbd\", wouldn\\'t the longest palindromic substring be \"bcb\" instead of \"bb\"?"
                    },
                    {
                        "username": "ufve0704terry",
                        "content": "I find out that I have such a big problem.\\nEverytime I AC I must need to have several times debug.\\nBut everytime I finish debug and AC,I don\\'t even know why the program can run...\\nI usually think that the program still have some problem I need to solve but it AC..."
                    },
                    {
                        "username": "Ritik_Gupta1",
                        "content": "Palindromic in String "
                    },
                    {
                        "username": "PythonAnalyst",
                        "content": "I passed all the tests except the last one, the 141st. At the last one, he submits either nothing or an empty line for input and writes \"Time Limit Exceed'. Has anyone encountered a similar problem?"
                    },
                    {
                        "username": "misuvasish114",
                        "content": "Can be solved in linear time using Manacher\\'s Algorithm\\nhttps://en.wikipedia.org/wiki/Longest_palindromic_substring#Manacher.27s_algorithm"
                    },
                    {
                        "username": "dunionwagner",
                        "content": "I think that a good testcase to test would be a test where it\\'s a complete palindrome, like racecar or tacocat, or bbbb."
                    },
                    {
                        "username": "vishakha_1102",
                        "content": "Can someone please tell me the error in this code? I\\'m not able to get why it is showing runtime error."
                    },
                    {
                        "username": "vishakha_1102",
                        "content": "string subString(string s, string x, int n, int m){\\n        int t[n+1][m+1];\\n        int result=0,r=0,c=0;\\n        string ans=\"\";\\n        for(int i=0;i<n+1;i++){\\n            for(int j=0;j<m+1;j++){\\n                if(i==0 || j==0)\\n                  t[i][j]=0;\\n                if(s[i-1]==x[j-1]){\\n                    t[i][j]=1+t[i-1][j-1];\\n                    if (result<t[i][j]) {\\n                     result = t[i][j];\\n                      r=i;\\n                      c=j;\\n                  }\\n                }\\n                else\\n                  t[i][j]=0;\\n            }\\n        }\\n        while(result>0){\\n           ans.push_back(s[r-1]);\\n           r--;\\n           result--;\\n        }\\n        return ans;\\n\\n    }\\n    string longestPalindrome(string s) {\\n     int n=s.size();\\n     string x =\"\";\\n     for(int i=n-1;i>=0;i--){\\n         x.push_back(s[i]);\\n     }\\n     return subString(s,x,n,n);\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "rahulgupta1597",
                        "content": "This will not work for input s =\"aacabdkacaa\""
                    },
                    {
                        "username": "cheungtriedtocode",
                        "content": "need help ,what can i do to solve TLE ,\\n```\\nclass Solution(object):\\n    def longestPalindrome(self, s):\\n        left = 0\\n        dp=\"\"\\n        \\n        for i in range(len(s)):\\n            left = i +1\\n            cur = \"\"\\n            while left<=len(s):\\n                # print(s[i:left])\\n                cur = s[i:left] if s[i:left]==s[i:left][::-1] else cur \\n                left+=1 \\n            dp = max(dp,cur,key=len)\\n      \\n        return dp \\n```"
                    },
                    {
                        "username": "pktk001",
                        "content": "141th testcase is not visible. I\\'m getting TLE on 141th testcase when I try to solve it with hashing.\\n"
                    }
                ]
            },
            {
                "id": 1826139,
                "content": [
                    {
                        "username": "Meena_leetcode",
                        "content": "for input \"cbbd\", wouldn\\'t the longest palindromic substring be \"bcb\" instead of \"bb\"?"
                    },
                    {
                        "username": "ufve0704terry",
                        "content": "I find out that I have such a big problem.\\nEverytime I AC I must need to have several times debug.\\nBut everytime I finish debug and AC,I don\\'t even know why the program can run...\\nI usually think that the program still have some problem I need to solve but it AC..."
                    },
                    {
                        "username": "Ritik_Gupta1",
                        "content": "Palindromic in String "
                    },
                    {
                        "username": "PythonAnalyst",
                        "content": "I passed all the tests except the last one, the 141st. At the last one, he submits either nothing or an empty line for input and writes \"Time Limit Exceed'. Has anyone encountered a similar problem?"
                    },
                    {
                        "username": "misuvasish114",
                        "content": "Can be solved in linear time using Manacher\\'s Algorithm\\nhttps://en.wikipedia.org/wiki/Longest_palindromic_substring#Manacher.27s_algorithm"
                    },
                    {
                        "username": "dunionwagner",
                        "content": "I think that a good testcase to test would be a test where it\\'s a complete palindrome, like racecar or tacocat, or bbbb."
                    },
                    {
                        "username": "vishakha_1102",
                        "content": "Can someone please tell me the error in this code? I\\'m not able to get why it is showing runtime error."
                    },
                    {
                        "username": "vishakha_1102",
                        "content": "string subString(string s, string x, int n, int m){\\n        int t[n+1][m+1];\\n        int result=0,r=0,c=0;\\n        string ans=\"\";\\n        for(int i=0;i<n+1;i++){\\n            for(int j=0;j<m+1;j++){\\n                if(i==0 || j==0)\\n                  t[i][j]=0;\\n                if(s[i-1]==x[j-1]){\\n                    t[i][j]=1+t[i-1][j-1];\\n                    if (result<t[i][j]) {\\n                     result = t[i][j];\\n                      r=i;\\n                      c=j;\\n                  }\\n                }\\n                else\\n                  t[i][j]=0;\\n            }\\n        }\\n        while(result>0){\\n           ans.push_back(s[r-1]);\\n           r--;\\n           result--;\\n        }\\n        return ans;\\n\\n    }\\n    string longestPalindrome(string s) {\\n     int n=s.size();\\n     string x =\"\";\\n     for(int i=n-1;i>=0;i--){\\n         x.push_back(s[i]);\\n     }\\n     return subString(s,x,n,n);\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "rahulgupta1597",
                        "content": "This will not work for input s =\"aacabdkacaa\""
                    },
                    {
                        "username": "cheungtriedtocode",
                        "content": "need help ,what can i do to solve TLE ,\\n```\\nclass Solution(object):\\n    def longestPalindrome(self, s):\\n        left = 0\\n        dp=\"\"\\n        \\n        for i in range(len(s)):\\n            left = i +1\\n            cur = \"\"\\n            while left<=len(s):\\n                # print(s[i:left])\\n                cur = s[i:left] if s[i:left]==s[i:left][::-1] else cur \\n                left+=1 \\n            dp = max(dp,cur,key=len)\\n      \\n        return dp \\n```"
                    },
                    {
                        "username": "pktk001",
                        "content": "141th testcase is not visible. I\\'m getting TLE on 141th testcase when I try to solve it with hashing.\\n"
                    }
                ]
            },
            {
                "id": 1813226,
                "content": [
                    {
                        "username": "Meena_leetcode",
                        "content": "for input \"cbbd\", wouldn\\'t the longest palindromic substring be \"bcb\" instead of \"bb\"?"
                    },
                    {
                        "username": "ufve0704terry",
                        "content": "I find out that I have such a big problem.\\nEverytime I AC I must need to have several times debug.\\nBut everytime I finish debug and AC,I don\\'t even know why the program can run...\\nI usually think that the program still have some problem I need to solve but it AC..."
                    },
                    {
                        "username": "Ritik_Gupta1",
                        "content": "Palindromic in String "
                    },
                    {
                        "username": "PythonAnalyst",
                        "content": "I passed all the tests except the last one, the 141st. At the last one, he submits either nothing or an empty line for input and writes \"Time Limit Exceed'. Has anyone encountered a similar problem?"
                    },
                    {
                        "username": "misuvasish114",
                        "content": "Can be solved in linear time using Manacher\\'s Algorithm\\nhttps://en.wikipedia.org/wiki/Longest_palindromic_substring#Manacher.27s_algorithm"
                    },
                    {
                        "username": "dunionwagner",
                        "content": "I think that a good testcase to test would be a test where it\\'s a complete palindrome, like racecar or tacocat, or bbbb."
                    },
                    {
                        "username": "vishakha_1102",
                        "content": "Can someone please tell me the error in this code? I\\'m not able to get why it is showing runtime error."
                    },
                    {
                        "username": "vishakha_1102",
                        "content": "string subString(string s, string x, int n, int m){\\n        int t[n+1][m+1];\\n        int result=0,r=0,c=0;\\n        string ans=\"\";\\n        for(int i=0;i<n+1;i++){\\n            for(int j=0;j<m+1;j++){\\n                if(i==0 || j==0)\\n                  t[i][j]=0;\\n                if(s[i-1]==x[j-1]){\\n                    t[i][j]=1+t[i-1][j-1];\\n                    if (result<t[i][j]) {\\n                     result = t[i][j];\\n                      r=i;\\n                      c=j;\\n                  }\\n                }\\n                else\\n                  t[i][j]=0;\\n            }\\n        }\\n        while(result>0){\\n           ans.push_back(s[r-1]);\\n           r--;\\n           result--;\\n        }\\n        return ans;\\n\\n    }\\n    string longestPalindrome(string s) {\\n     int n=s.size();\\n     string x =\"\";\\n     for(int i=n-1;i>=0;i--){\\n         x.push_back(s[i]);\\n     }\\n     return subString(s,x,n,n);\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "rahulgupta1597",
                        "content": "This will not work for input s =\"aacabdkacaa\""
                    },
                    {
                        "username": "cheungtriedtocode",
                        "content": "need help ,what can i do to solve TLE ,\\n```\\nclass Solution(object):\\n    def longestPalindrome(self, s):\\n        left = 0\\n        dp=\"\"\\n        \\n        for i in range(len(s)):\\n            left = i +1\\n            cur = \"\"\\n            while left<=len(s):\\n                # print(s[i:left])\\n                cur = s[i:left] if s[i:left]==s[i:left][::-1] else cur \\n                left+=1 \\n            dp = max(dp,cur,key=len)\\n      \\n        return dp \\n```"
                    },
                    {
                        "username": "pktk001",
                        "content": "141th testcase is not visible. I\\'m getting TLE on 141th testcase when I try to solve it with hashing.\\n"
                    }
                ]
            },
            {
                "id": 1809884,
                "content": [
                    {
                        "username": "Meena_leetcode",
                        "content": "for input \"cbbd\", wouldn\\'t the longest palindromic substring be \"bcb\" instead of \"bb\"?"
                    },
                    {
                        "username": "ufve0704terry",
                        "content": "I find out that I have such a big problem.\\nEverytime I AC I must need to have several times debug.\\nBut everytime I finish debug and AC,I don\\'t even know why the program can run...\\nI usually think that the program still have some problem I need to solve but it AC..."
                    },
                    {
                        "username": "Ritik_Gupta1",
                        "content": "Palindromic in String "
                    },
                    {
                        "username": "PythonAnalyst",
                        "content": "I passed all the tests except the last one, the 141st. At the last one, he submits either nothing or an empty line for input and writes \"Time Limit Exceed'. Has anyone encountered a similar problem?"
                    },
                    {
                        "username": "misuvasish114",
                        "content": "Can be solved in linear time using Manacher\\'s Algorithm\\nhttps://en.wikipedia.org/wiki/Longest_palindromic_substring#Manacher.27s_algorithm"
                    },
                    {
                        "username": "dunionwagner",
                        "content": "I think that a good testcase to test would be a test where it\\'s a complete palindrome, like racecar or tacocat, or bbbb."
                    },
                    {
                        "username": "vishakha_1102",
                        "content": "Can someone please tell me the error in this code? I\\'m not able to get why it is showing runtime error."
                    },
                    {
                        "username": "vishakha_1102",
                        "content": "string subString(string s, string x, int n, int m){\\n        int t[n+1][m+1];\\n        int result=0,r=0,c=0;\\n        string ans=\"\";\\n        for(int i=0;i<n+1;i++){\\n            for(int j=0;j<m+1;j++){\\n                if(i==0 || j==0)\\n                  t[i][j]=0;\\n                if(s[i-1]==x[j-1]){\\n                    t[i][j]=1+t[i-1][j-1];\\n                    if (result<t[i][j]) {\\n                     result = t[i][j];\\n                      r=i;\\n                      c=j;\\n                  }\\n                }\\n                else\\n                  t[i][j]=0;\\n            }\\n        }\\n        while(result>0){\\n           ans.push_back(s[r-1]);\\n           r--;\\n           result--;\\n        }\\n        return ans;\\n\\n    }\\n    string longestPalindrome(string s) {\\n     int n=s.size();\\n     string x =\"\";\\n     for(int i=n-1;i>=0;i--){\\n         x.push_back(s[i]);\\n     }\\n     return subString(s,x,n,n);\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "rahulgupta1597",
                        "content": "This will not work for input s =\"aacabdkacaa\""
                    },
                    {
                        "username": "cheungtriedtocode",
                        "content": "need help ,what can i do to solve TLE ,\\n```\\nclass Solution(object):\\n    def longestPalindrome(self, s):\\n        left = 0\\n        dp=\"\"\\n        \\n        for i in range(len(s)):\\n            left = i +1\\n            cur = \"\"\\n            while left<=len(s):\\n                # print(s[i:left])\\n                cur = s[i:left] if s[i:left]==s[i:left][::-1] else cur \\n                left+=1 \\n            dp = max(dp,cur,key=len)\\n      \\n        return dp \\n```"
                    },
                    {
                        "username": "pktk001",
                        "content": "141th testcase is not visible. I\\'m getting TLE on 141th testcase when I try to solve it with hashing.\\n"
                    }
                ]
            },
            {
                "id": 1809335,
                "content": [
                    {
                        "username": "Meena_leetcode",
                        "content": "for input \"cbbd\", wouldn\\'t the longest palindromic substring be \"bcb\" instead of \"bb\"?"
                    },
                    {
                        "username": "ufve0704terry",
                        "content": "I find out that I have such a big problem.\\nEverytime I AC I must need to have several times debug.\\nBut everytime I finish debug and AC,I don\\'t even know why the program can run...\\nI usually think that the program still have some problem I need to solve but it AC..."
                    },
                    {
                        "username": "Ritik_Gupta1",
                        "content": "Palindromic in String "
                    },
                    {
                        "username": "PythonAnalyst",
                        "content": "I passed all the tests except the last one, the 141st. At the last one, he submits either nothing or an empty line for input and writes \"Time Limit Exceed'. Has anyone encountered a similar problem?"
                    },
                    {
                        "username": "misuvasish114",
                        "content": "Can be solved in linear time using Manacher\\'s Algorithm\\nhttps://en.wikipedia.org/wiki/Longest_palindromic_substring#Manacher.27s_algorithm"
                    },
                    {
                        "username": "dunionwagner",
                        "content": "I think that a good testcase to test would be a test where it\\'s a complete palindrome, like racecar or tacocat, or bbbb."
                    },
                    {
                        "username": "vishakha_1102",
                        "content": "Can someone please tell me the error in this code? I\\'m not able to get why it is showing runtime error."
                    },
                    {
                        "username": "vishakha_1102",
                        "content": "string subString(string s, string x, int n, int m){\\n        int t[n+1][m+1];\\n        int result=0,r=0,c=0;\\n        string ans=\"\";\\n        for(int i=0;i<n+1;i++){\\n            for(int j=0;j<m+1;j++){\\n                if(i==0 || j==0)\\n                  t[i][j]=0;\\n                if(s[i-1]==x[j-1]){\\n                    t[i][j]=1+t[i-1][j-1];\\n                    if (result<t[i][j]) {\\n                     result = t[i][j];\\n                      r=i;\\n                      c=j;\\n                  }\\n                }\\n                else\\n                  t[i][j]=0;\\n            }\\n        }\\n        while(result>0){\\n           ans.push_back(s[r-1]);\\n           r--;\\n           result--;\\n        }\\n        return ans;\\n\\n    }\\n    string longestPalindrome(string s) {\\n     int n=s.size();\\n     string x =\"\";\\n     for(int i=n-1;i>=0;i--){\\n         x.push_back(s[i]);\\n     }\\n     return subString(s,x,n,n);\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "rahulgupta1597",
                        "content": "This will not work for input s =\"aacabdkacaa\""
                    },
                    {
                        "username": "cheungtriedtocode",
                        "content": "need help ,what can i do to solve TLE ,\\n```\\nclass Solution(object):\\n    def longestPalindrome(self, s):\\n        left = 0\\n        dp=\"\"\\n        \\n        for i in range(len(s)):\\n            left = i +1\\n            cur = \"\"\\n            while left<=len(s):\\n                # print(s[i:left])\\n                cur = s[i:left] if s[i:left]==s[i:left][::-1] else cur \\n                left+=1 \\n            dp = max(dp,cur,key=len)\\n      \\n        return dp \\n```"
                    },
                    {
                        "username": "pktk001",
                        "content": "141th testcase is not visible. I\\'m getting TLE on 141th testcase when I try to solve it with hashing.\\n"
                    }
                ]
            },
            {
                "id": 1809333,
                "content": [
                    {
                        "username": "Meena_leetcode",
                        "content": "for input \"cbbd\", wouldn\\'t the longest palindromic substring be \"bcb\" instead of \"bb\"?"
                    },
                    {
                        "username": "ufve0704terry",
                        "content": "I find out that I have such a big problem.\\nEverytime I AC I must need to have several times debug.\\nBut everytime I finish debug and AC,I don\\'t even know why the program can run...\\nI usually think that the program still have some problem I need to solve but it AC..."
                    },
                    {
                        "username": "Ritik_Gupta1",
                        "content": "Palindromic in String "
                    },
                    {
                        "username": "PythonAnalyst",
                        "content": "I passed all the tests except the last one, the 141st. At the last one, he submits either nothing or an empty line for input and writes \"Time Limit Exceed'. Has anyone encountered a similar problem?"
                    },
                    {
                        "username": "misuvasish114",
                        "content": "Can be solved in linear time using Manacher\\'s Algorithm\\nhttps://en.wikipedia.org/wiki/Longest_palindromic_substring#Manacher.27s_algorithm"
                    },
                    {
                        "username": "dunionwagner",
                        "content": "I think that a good testcase to test would be a test where it\\'s a complete palindrome, like racecar or tacocat, or bbbb."
                    },
                    {
                        "username": "vishakha_1102",
                        "content": "Can someone please tell me the error in this code? I\\'m not able to get why it is showing runtime error."
                    },
                    {
                        "username": "vishakha_1102",
                        "content": "string subString(string s, string x, int n, int m){\\n        int t[n+1][m+1];\\n        int result=0,r=0,c=0;\\n        string ans=\"\";\\n        for(int i=0;i<n+1;i++){\\n            for(int j=0;j<m+1;j++){\\n                if(i==0 || j==0)\\n                  t[i][j]=0;\\n                if(s[i-1]==x[j-1]){\\n                    t[i][j]=1+t[i-1][j-1];\\n                    if (result<t[i][j]) {\\n                     result = t[i][j];\\n                      r=i;\\n                      c=j;\\n                  }\\n                }\\n                else\\n                  t[i][j]=0;\\n            }\\n        }\\n        while(result>0){\\n           ans.push_back(s[r-1]);\\n           r--;\\n           result--;\\n        }\\n        return ans;\\n\\n    }\\n    string longestPalindrome(string s) {\\n     int n=s.size();\\n     string x =\"\";\\n     for(int i=n-1;i>=0;i--){\\n         x.push_back(s[i]);\\n     }\\n     return subString(s,x,n,n);\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "rahulgupta1597",
                        "content": "This will not work for input s =\"aacabdkacaa\""
                    },
                    {
                        "username": "cheungtriedtocode",
                        "content": "need help ,what can i do to solve TLE ,\\n```\\nclass Solution(object):\\n    def longestPalindrome(self, s):\\n        left = 0\\n        dp=\"\"\\n        \\n        for i in range(len(s)):\\n            left = i +1\\n            cur = \"\"\\n            while left<=len(s):\\n                # print(s[i:left])\\n                cur = s[i:left] if s[i:left]==s[i:left][::-1] else cur \\n                left+=1 \\n            dp = max(dp,cur,key=len)\\n      \\n        return dp \\n```"
                    },
                    {
                        "username": "pktk001",
                        "content": "141th testcase is not visible. I\\'m getting TLE on 141th testcase when I try to solve it with hashing.\\n"
                    }
                ]
            },
            {
                "id": 1809326,
                "content": [
                    {
                        "username": "Meena_leetcode",
                        "content": "for input \"cbbd\", wouldn\\'t the longest palindromic substring be \"bcb\" instead of \"bb\"?"
                    },
                    {
                        "username": "ufve0704terry",
                        "content": "I find out that I have such a big problem.\\nEverytime I AC I must need to have several times debug.\\nBut everytime I finish debug and AC,I don\\'t even know why the program can run...\\nI usually think that the program still have some problem I need to solve but it AC..."
                    },
                    {
                        "username": "Ritik_Gupta1",
                        "content": "Palindromic in String "
                    },
                    {
                        "username": "PythonAnalyst",
                        "content": "I passed all the tests except the last one, the 141st. At the last one, he submits either nothing or an empty line for input and writes \"Time Limit Exceed'. Has anyone encountered a similar problem?"
                    },
                    {
                        "username": "misuvasish114",
                        "content": "Can be solved in linear time using Manacher\\'s Algorithm\\nhttps://en.wikipedia.org/wiki/Longest_palindromic_substring#Manacher.27s_algorithm"
                    },
                    {
                        "username": "dunionwagner",
                        "content": "I think that a good testcase to test would be a test where it\\'s a complete palindrome, like racecar or tacocat, or bbbb."
                    },
                    {
                        "username": "vishakha_1102",
                        "content": "Can someone please tell me the error in this code? I\\'m not able to get why it is showing runtime error."
                    },
                    {
                        "username": "vishakha_1102",
                        "content": "string subString(string s, string x, int n, int m){\\n        int t[n+1][m+1];\\n        int result=0,r=0,c=0;\\n        string ans=\"\";\\n        for(int i=0;i<n+1;i++){\\n            for(int j=0;j<m+1;j++){\\n                if(i==0 || j==0)\\n                  t[i][j]=0;\\n                if(s[i-1]==x[j-1]){\\n                    t[i][j]=1+t[i-1][j-1];\\n                    if (result<t[i][j]) {\\n                     result = t[i][j];\\n                      r=i;\\n                      c=j;\\n                  }\\n                }\\n                else\\n                  t[i][j]=0;\\n            }\\n        }\\n        while(result>0){\\n           ans.push_back(s[r-1]);\\n           r--;\\n           result--;\\n        }\\n        return ans;\\n\\n    }\\n    string longestPalindrome(string s) {\\n     int n=s.size();\\n     string x =\"\";\\n     for(int i=n-1;i>=0;i--){\\n         x.push_back(s[i]);\\n     }\\n     return subString(s,x,n,n);\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "rahulgupta1597",
                        "content": "This will not work for input s =\"aacabdkacaa\""
                    },
                    {
                        "username": "cheungtriedtocode",
                        "content": "need help ,what can i do to solve TLE ,\\n```\\nclass Solution(object):\\n    def longestPalindrome(self, s):\\n        left = 0\\n        dp=\"\"\\n        \\n        for i in range(len(s)):\\n            left = i +1\\n            cur = \"\"\\n            while left<=len(s):\\n                # print(s[i:left])\\n                cur = s[i:left] if s[i:left]==s[i:left][::-1] else cur \\n                left+=1 \\n            dp = max(dp,cur,key=len)\\n      \\n        return dp \\n```"
                    },
                    {
                        "username": "pktk001",
                        "content": "141th testcase is not visible. I\\'m getting TLE on 141th testcase when I try to solve it with hashing.\\n"
                    }
                ]
            },
            {
                "id": 1807028,
                "content": [
                    {
                        "username": "Meena_leetcode",
                        "content": "for input \"cbbd\", wouldn\\'t the longest palindromic substring be \"bcb\" instead of \"bb\"?"
                    },
                    {
                        "username": "ufve0704terry",
                        "content": "I find out that I have such a big problem.\\nEverytime I AC I must need to have several times debug.\\nBut everytime I finish debug and AC,I don\\'t even know why the program can run...\\nI usually think that the program still have some problem I need to solve but it AC..."
                    },
                    {
                        "username": "Ritik_Gupta1",
                        "content": "Palindromic in String "
                    },
                    {
                        "username": "PythonAnalyst",
                        "content": "I passed all the tests except the last one, the 141st. At the last one, he submits either nothing or an empty line for input and writes \"Time Limit Exceed'. Has anyone encountered a similar problem?"
                    },
                    {
                        "username": "misuvasish114",
                        "content": "Can be solved in linear time using Manacher\\'s Algorithm\\nhttps://en.wikipedia.org/wiki/Longest_palindromic_substring#Manacher.27s_algorithm"
                    },
                    {
                        "username": "dunionwagner",
                        "content": "I think that a good testcase to test would be a test where it\\'s a complete palindrome, like racecar or tacocat, or bbbb."
                    },
                    {
                        "username": "vishakha_1102",
                        "content": "Can someone please tell me the error in this code? I\\'m not able to get why it is showing runtime error."
                    },
                    {
                        "username": "vishakha_1102",
                        "content": "string subString(string s, string x, int n, int m){\\n        int t[n+1][m+1];\\n        int result=0,r=0,c=0;\\n        string ans=\"\";\\n        for(int i=0;i<n+1;i++){\\n            for(int j=0;j<m+1;j++){\\n                if(i==0 || j==0)\\n                  t[i][j]=0;\\n                if(s[i-1]==x[j-1]){\\n                    t[i][j]=1+t[i-1][j-1];\\n                    if (result<t[i][j]) {\\n                     result = t[i][j];\\n                      r=i;\\n                      c=j;\\n                  }\\n                }\\n                else\\n                  t[i][j]=0;\\n            }\\n        }\\n        while(result>0){\\n           ans.push_back(s[r-1]);\\n           r--;\\n           result--;\\n        }\\n        return ans;\\n\\n    }\\n    string longestPalindrome(string s) {\\n     int n=s.size();\\n     string x =\"\";\\n     for(int i=n-1;i>=0;i--){\\n         x.push_back(s[i]);\\n     }\\n     return subString(s,x,n,n);\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "rahulgupta1597",
                        "content": "This will not work for input s =\"aacabdkacaa\""
                    },
                    {
                        "username": "cheungtriedtocode",
                        "content": "need help ,what can i do to solve TLE ,\\n```\\nclass Solution(object):\\n    def longestPalindrome(self, s):\\n        left = 0\\n        dp=\"\"\\n        \\n        for i in range(len(s)):\\n            left = i +1\\n            cur = \"\"\\n            while left<=len(s):\\n                # print(s[i:left])\\n                cur = s[i:left] if s[i:left]==s[i:left][::-1] else cur \\n                left+=1 \\n            dp = max(dp,cur,key=len)\\n      \\n        return dp \\n```"
                    },
                    {
                        "username": "pktk001",
                        "content": "141th testcase is not visible. I\\'m getting TLE on 141th testcase when I try to solve it with hashing.\\n"
                    }
                ]
            },
            {
                "id": 1798978,
                "content": [
                    {
                        "username": "Sampath3756",
                        "content": "in my code i am able to pass all test cases but time limit exceeds, my approach of the problem is using for of for loop for starting and ending point of the substring, and checking the substring is palindrome or not, if it is palindrome comparing the sizes of the longest and current sub string and replacing the longest string with current sub string, could anyone help me for getting my approach better and pass all test cases in time"
                    },
                    {
                        "username": "steve1302",
                        "content": "for input  \"aacabdkacaa\" test case is expecting \"aca\" which is incorrect output.  \"aaca\" is the correct one. how can we solve this??"
                    },
                    {
                        "username": "AMerrill",
                        "content": "\"*aca*\" is the correct output, as \"*aaca*\" is not a palindrome."
                    },
                    {
                        "username": "jems1123",
                        "content": "Can some one implement LCS with recursion and  return data type should be string"
                    },
                    {
                        "username": "user5248P",
                        "content": "LeetCode needs to improve the test cases here. My brute force solution was good enough"
                    },
                    {
                        "username": "vishal0509",
                        "content": "time limit exceeded :("
                    },
                    {
                        "username": "vishal0509",
                        "content": "i am using o(n^2) "
                    },
                    {
                        "username": "AveryBurke",
                        "content": " [@LeetCode](/LeetCode)\nthe expected answer for test case 46 is incorrect.\nThe test string is \"aacabdkacaa\" and the expected out put is \"aca\". I can obtain the following palindromes of length 9 by deleting substring (i've added spacing to make this easier to see):\n\n\"aaca b acaa\" by deleting the substring 'dk'\n\"aaca k acaa\" by deleting the substring 'bd'\n\"aaca d acaa\" by deleting the substrings 'b' and 'k'\n\nmy solution produces the palindrome \"aacabacaa\" (deleting 'dk') but the solution is rejected on test case 46.  How do I get my solution accepted?  \n"
                    },
                    {
                        "username": "slashtab",
                        "content": "The substring is continuous part of the string. You can not delete some characters in-between. "
                    },
                    {
                        "username": "lakshyag9775",
                        "content": "Please Put it under  **HARD** Tag"
                    },
                    {
                        "username": "CristianM92",
                        "content": "Check Manacher\\u2019s algorithm"
                    },
                    {
                        "username": "aayushnag84",
                        "content": "Can anyone explain why this code is not working?\\n\\n\\n``class Solution \\n{\\n      public String longestPalindrome(String s) \\n    {\\n        recur(s, 0, s.length()-1);\\n        System.out.println(max);\\n        return ans;\\n    }\\n    static int max = 0;\\n    static String ans = \"\";\\n    public static int recur(String s, int i, int j)\\n    {\\n        if(i==j) return 1;\\n        else if(j-i == 1 && s.charAt(i)==s.charAt(j)) return 2;\\n        else if(j-i == 1) return 1;\\n        else\\n        {\\n            if(s.charAt(i) == s.charAt(j)) \\n            {         \\n                System.out.println(s.substring(i,j+1));       \\n                int temp = 2 + recur(s, i+1, j-1);\\n                max = temp>max ? temp: max;\\n                ans = temp>max ? s.substring(i,j+1) : ans;\\n                return temp;\\n            }                \\n            else \\n            {\\n                System.out.println(s.substring(i,j+1)); \\n                int temp = recur(s, i+1, j-1);\\n                max = temp>max ? temp : max;\\n                ans = temp>max ? s.substring(i,j+1) : ans;\\n                return temp;\\n            }\\n        }\\n    }\\n}``"
                    },
                    {
                        "username": "Primus4",
                        "content": "my 131 test cases have passed and code runs excellent in other compilers but here it gives garbage value;\\n "
                    }
                ]
            },
            {
                "id": 1798409,
                "content": [
                    {
                        "username": "Sampath3756",
                        "content": "in my code i am able to pass all test cases but time limit exceeds, my approach of the problem is using for of for loop for starting and ending point of the substring, and checking the substring is palindrome or not, if it is palindrome comparing the sizes of the longest and current sub string and replacing the longest string with current sub string, could anyone help me for getting my approach better and pass all test cases in time"
                    },
                    {
                        "username": "steve1302",
                        "content": "for input  \"aacabdkacaa\" test case is expecting \"aca\" which is incorrect output.  \"aaca\" is the correct one. how can we solve this??"
                    },
                    {
                        "username": "AMerrill",
                        "content": "\"*aca*\" is the correct output, as \"*aaca*\" is not a palindrome."
                    },
                    {
                        "username": "jems1123",
                        "content": "Can some one implement LCS with recursion and  return data type should be string"
                    },
                    {
                        "username": "user5248P",
                        "content": "LeetCode needs to improve the test cases here. My brute force solution was good enough"
                    },
                    {
                        "username": "vishal0509",
                        "content": "time limit exceeded :("
                    },
                    {
                        "username": "vishal0509",
                        "content": "i am using o(n^2) "
                    },
                    {
                        "username": "AveryBurke",
                        "content": " [@LeetCode](/LeetCode)\nthe expected answer for test case 46 is incorrect.\nThe test string is \"aacabdkacaa\" and the expected out put is \"aca\". I can obtain the following palindromes of length 9 by deleting substring (i've added spacing to make this easier to see):\n\n\"aaca b acaa\" by deleting the substring 'dk'\n\"aaca k acaa\" by deleting the substring 'bd'\n\"aaca d acaa\" by deleting the substrings 'b' and 'k'\n\nmy solution produces the palindrome \"aacabacaa\" (deleting 'dk') but the solution is rejected on test case 46.  How do I get my solution accepted?  \n"
                    },
                    {
                        "username": "slashtab",
                        "content": "The substring is continuous part of the string. You can not delete some characters in-between. "
                    },
                    {
                        "username": "lakshyag9775",
                        "content": "Please Put it under  **HARD** Tag"
                    },
                    {
                        "username": "CristianM92",
                        "content": "Check Manacher\\u2019s algorithm"
                    },
                    {
                        "username": "aayushnag84",
                        "content": "Can anyone explain why this code is not working?\\n\\n\\n``class Solution \\n{\\n      public String longestPalindrome(String s) \\n    {\\n        recur(s, 0, s.length()-1);\\n        System.out.println(max);\\n        return ans;\\n    }\\n    static int max = 0;\\n    static String ans = \"\";\\n    public static int recur(String s, int i, int j)\\n    {\\n        if(i==j) return 1;\\n        else if(j-i == 1 && s.charAt(i)==s.charAt(j)) return 2;\\n        else if(j-i == 1) return 1;\\n        else\\n        {\\n            if(s.charAt(i) == s.charAt(j)) \\n            {         \\n                System.out.println(s.substring(i,j+1));       \\n                int temp = 2 + recur(s, i+1, j-1);\\n                max = temp>max ? temp: max;\\n                ans = temp>max ? s.substring(i,j+1) : ans;\\n                return temp;\\n            }                \\n            else \\n            {\\n                System.out.println(s.substring(i,j+1)); \\n                int temp = recur(s, i+1, j-1);\\n                max = temp>max ? temp : max;\\n                ans = temp>max ? s.substring(i,j+1) : ans;\\n                return temp;\\n            }\\n        }\\n    }\\n}``"
                    },
                    {
                        "username": "Primus4",
                        "content": "my 131 test cases have passed and code runs excellent in other compilers but here it gives garbage value;\\n "
                    }
                ]
            },
            {
                "id": 1796077,
                "content": [
                    {
                        "username": "Sampath3756",
                        "content": "in my code i am able to pass all test cases but time limit exceeds, my approach of the problem is using for of for loop for starting and ending point of the substring, and checking the substring is palindrome or not, if it is palindrome comparing the sizes of the longest and current sub string and replacing the longest string with current sub string, could anyone help me for getting my approach better and pass all test cases in time"
                    },
                    {
                        "username": "steve1302",
                        "content": "for input  \"aacabdkacaa\" test case is expecting \"aca\" which is incorrect output.  \"aaca\" is the correct one. how can we solve this??"
                    },
                    {
                        "username": "AMerrill",
                        "content": "\"*aca*\" is the correct output, as \"*aaca*\" is not a palindrome."
                    },
                    {
                        "username": "jems1123",
                        "content": "Can some one implement LCS with recursion and  return data type should be string"
                    },
                    {
                        "username": "user5248P",
                        "content": "LeetCode needs to improve the test cases here. My brute force solution was good enough"
                    },
                    {
                        "username": "vishal0509",
                        "content": "time limit exceeded :("
                    },
                    {
                        "username": "vishal0509",
                        "content": "i am using o(n^2) "
                    },
                    {
                        "username": "AveryBurke",
                        "content": " [@LeetCode](/LeetCode)\nthe expected answer for test case 46 is incorrect.\nThe test string is \"aacabdkacaa\" and the expected out put is \"aca\". I can obtain the following palindromes of length 9 by deleting substring (i've added spacing to make this easier to see):\n\n\"aaca b acaa\" by deleting the substring 'dk'\n\"aaca k acaa\" by deleting the substring 'bd'\n\"aaca d acaa\" by deleting the substrings 'b' and 'k'\n\nmy solution produces the palindrome \"aacabacaa\" (deleting 'dk') but the solution is rejected on test case 46.  How do I get my solution accepted?  \n"
                    },
                    {
                        "username": "slashtab",
                        "content": "The substring is continuous part of the string. You can not delete some characters in-between. "
                    },
                    {
                        "username": "lakshyag9775",
                        "content": "Please Put it under  **HARD** Tag"
                    },
                    {
                        "username": "CristianM92",
                        "content": "Check Manacher\\u2019s algorithm"
                    },
                    {
                        "username": "aayushnag84",
                        "content": "Can anyone explain why this code is not working?\\n\\n\\n``class Solution \\n{\\n      public String longestPalindrome(String s) \\n    {\\n        recur(s, 0, s.length()-1);\\n        System.out.println(max);\\n        return ans;\\n    }\\n    static int max = 0;\\n    static String ans = \"\";\\n    public static int recur(String s, int i, int j)\\n    {\\n        if(i==j) return 1;\\n        else if(j-i == 1 && s.charAt(i)==s.charAt(j)) return 2;\\n        else if(j-i == 1) return 1;\\n        else\\n        {\\n            if(s.charAt(i) == s.charAt(j)) \\n            {         \\n                System.out.println(s.substring(i,j+1));       \\n                int temp = 2 + recur(s, i+1, j-1);\\n                max = temp>max ? temp: max;\\n                ans = temp>max ? s.substring(i,j+1) : ans;\\n                return temp;\\n            }                \\n            else \\n            {\\n                System.out.println(s.substring(i,j+1)); \\n                int temp = recur(s, i+1, j-1);\\n                max = temp>max ? temp : max;\\n                ans = temp>max ? s.substring(i,j+1) : ans;\\n                return temp;\\n            }\\n        }\\n    }\\n}``"
                    },
                    {
                        "username": "Primus4",
                        "content": "my 131 test cases have passed and code runs excellent in other compilers but here it gives garbage value;\\n "
                    }
                ]
            },
            {
                "id": 1795396,
                "content": [
                    {
                        "username": "Sampath3756",
                        "content": "in my code i am able to pass all test cases but time limit exceeds, my approach of the problem is using for of for loop for starting and ending point of the substring, and checking the substring is palindrome or not, if it is palindrome comparing the sizes of the longest and current sub string and replacing the longest string with current sub string, could anyone help me for getting my approach better and pass all test cases in time"
                    },
                    {
                        "username": "steve1302",
                        "content": "for input  \"aacabdkacaa\" test case is expecting \"aca\" which is incorrect output.  \"aaca\" is the correct one. how can we solve this??"
                    },
                    {
                        "username": "AMerrill",
                        "content": "\"*aca*\" is the correct output, as \"*aaca*\" is not a palindrome."
                    },
                    {
                        "username": "jems1123",
                        "content": "Can some one implement LCS with recursion and  return data type should be string"
                    },
                    {
                        "username": "user5248P",
                        "content": "LeetCode needs to improve the test cases here. My brute force solution was good enough"
                    },
                    {
                        "username": "vishal0509",
                        "content": "time limit exceeded :("
                    },
                    {
                        "username": "vishal0509",
                        "content": "i am using o(n^2) "
                    },
                    {
                        "username": "AveryBurke",
                        "content": " [@LeetCode](/LeetCode)\nthe expected answer for test case 46 is incorrect.\nThe test string is \"aacabdkacaa\" and the expected out put is \"aca\". I can obtain the following palindromes of length 9 by deleting substring (i've added spacing to make this easier to see):\n\n\"aaca b acaa\" by deleting the substring 'dk'\n\"aaca k acaa\" by deleting the substring 'bd'\n\"aaca d acaa\" by deleting the substrings 'b' and 'k'\n\nmy solution produces the palindrome \"aacabacaa\" (deleting 'dk') but the solution is rejected on test case 46.  How do I get my solution accepted?  \n"
                    },
                    {
                        "username": "slashtab",
                        "content": "The substring is continuous part of the string. You can not delete some characters in-between. "
                    },
                    {
                        "username": "lakshyag9775",
                        "content": "Please Put it under  **HARD** Tag"
                    },
                    {
                        "username": "CristianM92",
                        "content": "Check Manacher\\u2019s algorithm"
                    },
                    {
                        "username": "aayushnag84",
                        "content": "Can anyone explain why this code is not working?\\n\\n\\n``class Solution \\n{\\n      public String longestPalindrome(String s) \\n    {\\n        recur(s, 0, s.length()-1);\\n        System.out.println(max);\\n        return ans;\\n    }\\n    static int max = 0;\\n    static String ans = \"\";\\n    public static int recur(String s, int i, int j)\\n    {\\n        if(i==j) return 1;\\n        else if(j-i == 1 && s.charAt(i)==s.charAt(j)) return 2;\\n        else if(j-i == 1) return 1;\\n        else\\n        {\\n            if(s.charAt(i) == s.charAt(j)) \\n            {         \\n                System.out.println(s.substring(i,j+1));       \\n                int temp = 2 + recur(s, i+1, j-1);\\n                max = temp>max ? temp: max;\\n                ans = temp>max ? s.substring(i,j+1) : ans;\\n                return temp;\\n            }                \\n            else \\n            {\\n                System.out.println(s.substring(i,j+1)); \\n                int temp = recur(s, i+1, j-1);\\n                max = temp>max ? temp : max;\\n                ans = temp>max ? s.substring(i,j+1) : ans;\\n                return temp;\\n            }\\n        }\\n    }\\n}``"
                    },
                    {
                        "username": "Primus4",
                        "content": "my 131 test cases have passed and code runs excellent in other compilers but here it gives garbage value;\\n "
                    }
                ]
            },
            {
                "id": 1792944,
                "content": [
                    {
                        "username": "Sampath3756",
                        "content": "in my code i am able to pass all test cases but time limit exceeds, my approach of the problem is using for of for loop for starting and ending point of the substring, and checking the substring is palindrome or not, if it is palindrome comparing the sizes of the longest and current sub string and replacing the longest string with current sub string, could anyone help me for getting my approach better and pass all test cases in time"
                    },
                    {
                        "username": "steve1302",
                        "content": "for input  \"aacabdkacaa\" test case is expecting \"aca\" which is incorrect output.  \"aaca\" is the correct one. how can we solve this??"
                    },
                    {
                        "username": "AMerrill",
                        "content": "\"*aca*\" is the correct output, as \"*aaca*\" is not a palindrome."
                    },
                    {
                        "username": "jems1123",
                        "content": "Can some one implement LCS with recursion and  return data type should be string"
                    },
                    {
                        "username": "user5248P",
                        "content": "LeetCode needs to improve the test cases here. My brute force solution was good enough"
                    },
                    {
                        "username": "vishal0509",
                        "content": "time limit exceeded :("
                    },
                    {
                        "username": "vishal0509",
                        "content": "i am using o(n^2) "
                    },
                    {
                        "username": "AveryBurke",
                        "content": " [@LeetCode](/LeetCode)\nthe expected answer for test case 46 is incorrect.\nThe test string is \"aacabdkacaa\" and the expected out put is \"aca\". I can obtain the following palindromes of length 9 by deleting substring (i've added spacing to make this easier to see):\n\n\"aaca b acaa\" by deleting the substring 'dk'\n\"aaca k acaa\" by deleting the substring 'bd'\n\"aaca d acaa\" by deleting the substrings 'b' and 'k'\n\nmy solution produces the palindrome \"aacabacaa\" (deleting 'dk') but the solution is rejected on test case 46.  How do I get my solution accepted?  \n"
                    },
                    {
                        "username": "slashtab",
                        "content": "The substring is continuous part of the string. You can not delete some characters in-between. "
                    },
                    {
                        "username": "lakshyag9775",
                        "content": "Please Put it under  **HARD** Tag"
                    },
                    {
                        "username": "CristianM92",
                        "content": "Check Manacher\\u2019s algorithm"
                    },
                    {
                        "username": "aayushnag84",
                        "content": "Can anyone explain why this code is not working?\\n\\n\\n``class Solution \\n{\\n      public String longestPalindrome(String s) \\n    {\\n        recur(s, 0, s.length()-1);\\n        System.out.println(max);\\n        return ans;\\n    }\\n    static int max = 0;\\n    static String ans = \"\";\\n    public static int recur(String s, int i, int j)\\n    {\\n        if(i==j) return 1;\\n        else if(j-i == 1 && s.charAt(i)==s.charAt(j)) return 2;\\n        else if(j-i == 1) return 1;\\n        else\\n        {\\n            if(s.charAt(i) == s.charAt(j)) \\n            {         \\n                System.out.println(s.substring(i,j+1));       \\n                int temp = 2 + recur(s, i+1, j-1);\\n                max = temp>max ? temp: max;\\n                ans = temp>max ? s.substring(i,j+1) : ans;\\n                return temp;\\n            }                \\n            else \\n            {\\n                System.out.println(s.substring(i,j+1)); \\n                int temp = recur(s, i+1, j-1);\\n                max = temp>max ? temp : max;\\n                ans = temp>max ? s.substring(i,j+1) : ans;\\n                return temp;\\n            }\\n        }\\n    }\\n}``"
                    },
                    {
                        "username": "Primus4",
                        "content": "my 131 test cases have passed and code runs excellent in other compilers but here it gives garbage value;\\n "
                    }
                ]
            },
            {
                "id": 1792517,
                "content": [
                    {
                        "username": "Sampath3756",
                        "content": "in my code i am able to pass all test cases but time limit exceeds, my approach of the problem is using for of for loop for starting and ending point of the substring, and checking the substring is palindrome or not, if it is palindrome comparing the sizes of the longest and current sub string and replacing the longest string with current sub string, could anyone help me for getting my approach better and pass all test cases in time"
                    },
                    {
                        "username": "steve1302",
                        "content": "for input  \"aacabdkacaa\" test case is expecting \"aca\" which is incorrect output.  \"aaca\" is the correct one. how can we solve this??"
                    },
                    {
                        "username": "AMerrill",
                        "content": "\"*aca*\" is the correct output, as \"*aaca*\" is not a palindrome."
                    },
                    {
                        "username": "jems1123",
                        "content": "Can some one implement LCS with recursion and  return data type should be string"
                    },
                    {
                        "username": "user5248P",
                        "content": "LeetCode needs to improve the test cases here. My brute force solution was good enough"
                    },
                    {
                        "username": "vishal0509",
                        "content": "time limit exceeded :("
                    },
                    {
                        "username": "vishal0509",
                        "content": "i am using o(n^2) "
                    },
                    {
                        "username": "AveryBurke",
                        "content": " [@LeetCode](/LeetCode)\nthe expected answer for test case 46 is incorrect.\nThe test string is \"aacabdkacaa\" and the expected out put is \"aca\". I can obtain the following palindromes of length 9 by deleting substring (i've added spacing to make this easier to see):\n\n\"aaca b acaa\" by deleting the substring 'dk'\n\"aaca k acaa\" by deleting the substring 'bd'\n\"aaca d acaa\" by deleting the substrings 'b' and 'k'\n\nmy solution produces the palindrome \"aacabacaa\" (deleting 'dk') but the solution is rejected on test case 46.  How do I get my solution accepted?  \n"
                    },
                    {
                        "username": "slashtab",
                        "content": "The substring is continuous part of the string. You can not delete some characters in-between. "
                    },
                    {
                        "username": "lakshyag9775",
                        "content": "Please Put it under  **HARD** Tag"
                    },
                    {
                        "username": "CristianM92",
                        "content": "Check Manacher\\u2019s algorithm"
                    },
                    {
                        "username": "aayushnag84",
                        "content": "Can anyone explain why this code is not working?\\n\\n\\n``class Solution \\n{\\n      public String longestPalindrome(String s) \\n    {\\n        recur(s, 0, s.length()-1);\\n        System.out.println(max);\\n        return ans;\\n    }\\n    static int max = 0;\\n    static String ans = \"\";\\n    public static int recur(String s, int i, int j)\\n    {\\n        if(i==j) return 1;\\n        else if(j-i == 1 && s.charAt(i)==s.charAt(j)) return 2;\\n        else if(j-i == 1) return 1;\\n        else\\n        {\\n            if(s.charAt(i) == s.charAt(j)) \\n            {         \\n                System.out.println(s.substring(i,j+1));       \\n                int temp = 2 + recur(s, i+1, j-1);\\n                max = temp>max ? temp: max;\\n                ans = temp>max ? s.substring(i,j+1) : ans;\\n                return temp;\\n            }                \\n            else \\n            {\\n                System.out.println(s.substring(i,j+1)); \\n                int temp = recur(s, i+1, j-1);\\n                max = temp>max ? temp : max;\\n                ans = temp>max ? s.substring(i,j+1) : ans;\\n                return temp;\\n            }\\n        }\\n    }\\n}``"
                    },
                    {
                        "username": "Primus4",
                        "content": "my 131 test cases have passed and code runs excellent in other compilers but here it gives garbage value;\\n "
                    }
                ]
            },
            {
                "id": 1791003,
                "content": [
                    {
                        "username": "Sampath3756",
                        "content": "in my code i am able to pass all test cases but time limit exceeds, my approach of the problem is using for of for loop for starting and ending point of the substring, and checking the substring is palindrome or not, if it is palindrome comparing the sizes of the longest and current sub string and replacing the longest string with current sub string, could anyone help me for getting my approach better and pass all test cases in time"
                    },
                    {
                        "username": "steve1302",
                        "content": "for input  \"aacabdkacaa\" test case is expecting \"aca\" which is incorrect output.  \"aaca\" is the correct one. how can we solve this??"
                    },
                    {
                        "username": "AMerrill",
                        "content": "\"*aca*\" is the correct output, as \"*aaca*\" is not a palindrome."
                    },
                    {
                        "username": "jems1123",
                        "content": "Can some one implement LCS with recursion and  return data type should be string"
                    },
                    {
                        "username": "user5248P",
                        "content": "LeetCode needs to improve the test cases here. My brute force solution was good enough"
                    },
                    {
                        "username": "vishal0509",
                        "content": "time limit exceeded :("
                    },
                    {
                        "username": "vishal0509",
                        "content": "i am using o(n^2) "
                    },
                    {
                        "username": "AveryBurke",
                        "content": " [@LeetCode](/LeetCode)\nthe expected answer for test case 46 is incorrect.\nThe test string is \"aacabdkacaa\" and the expected out put is \"aca\". I can obtain the following palindromes of length 9 by deleting substring (i've added spacing to make this easier to see):\n\n\"aaca b acaa\" by deleting the substring 'dk'\n\"aaca k acaa\" by deleting the substring 'bd'\n\"aaca d acaa\" by deleting the substrings 'b' and 'k'\n\nmy solution produces the palindrome \"aacabacaa\" (deleting 'dk') but the solution is rejected on test case 46.  How do I get my solution accepted?  \n"
                    },
                    {
                        "username": "slashtab",
                        "content": "The substring is continuous part of the string. You can not delete some characters in-between. "
                    },
                    {
                        "username": "lakshyag9775",
                        "content": "Please Put it under  **HARD** Tag"
                    },
                    {
                        "username": "CristianM92",
                        "content": "Check Manacher\\u2019s algorithm"
                    },
                    {
                        "username": "aayushnag84",
                        "content": "Can anyone explain why this code is not working?\\n\\n\\n``class Solution \\n{\\n      public String longestPalindrome(String s) \\n    {\\n        recur(s, 0, s.length()-1);\\n        System.out.println(max);\\n        return ans;\\n    }\\n    static int max = 0;\\n    static String ans = \"\";\\n    public static int recur(String s, int i, int j)\\n    {\\n        if(i==j) return 1;\\n        else if(j-i == 1 && s.charAt(i)==s.charAt(j)) return 2;\\n        else if(j-i == 1) return 1;\\n        else\\n        {\\n            if(s.charAt(i) == s.charAt(j)) \\n            {         \\n                System.out.println(s.substring(i,j+1));       \\n                int temp = 2 + recur(s, i+1, j-1);\\n                max = temp>max ? temp: max;\\n                ans = temp>max ? s.substring(i,j+1) : ans;\\n                return temp;\\n            }                \\n            else \\n            {\\n                System.out.println(s.substring(i,j+1)); \\n                int temp = recur(s, i+1, j-1);\\n                max = temp>max ? temp : max;\\n                ans = temp>max ? s.substring(i,j+1) : ans;\\n                return temp;\\n            }\\n        }\\n    }\\n}``"
                    },
                    {
                        "username": "Primus4",
                        "content": "my 131 test cases have passed and code runs excellent in other compilers but here it gives garbage value;\\n "
                    }
                ]
            },
            {
                "id": 1789086,
                "content": [
                    {
                        "username": "Sampath3756",
                        "content": "in my code i am able to pass all test cases but time limit exceeds, my approach of the problem is using for of for loop for starting and ending point of the substring, and checking the substring is palindrome or not, if it is palindrome comparing the sizes of the longest and current sub string and replacing the longest string with current sub string, could anyone help me for getting my approach better and pass all test cases in time"
                    },
                    {
                        "username": "steve1302",
                        "content": "for input  \"aacabdkacaa\" test case is expecting \"aca\" which is incorrect output.  \"aaca\" is the correct one. how can we solve this??"
                    },
                    {
                        "username": "AMerrill",
                        "content": "\"*aca*\" is the correct output, as \"*aaca*\" is not a palindrome."
                    },
                    {
                        "username": "jems1123",
                        "content": "Can some one implement LCS with recursion and  return data type should be string"
                    },
                    {
                        "username": "user5248P",
                        "content": "LeetCode needs to improve the test cases here. My brute force solution was good enough"
                    },
                    {
                        "username": "vishal0509",
                        "content": "time limit exceeded :("
                    },
                    {
                        "username": "vishal0509",
                        "content": "i am using o(n^2) "
                    },
                    {
                        "username": "AveryBurke",
                        "content": " [@LeetCode](/LeetCode)\nthe expected answer for test case 46 is incorrect.\nThe test string is \"aacabdkacaa\" and the expected out put is \"aca\". I can obtain the following palindromes of length 9 by deleting substring (i've added spacing to make this easier to see):\n\n\"aaca b acaa\" by deleting the substring 'dk'\n\"aaca k acaa\" by deleting the substring 'bd'\n\"aaca d acaa\" by deleting the substrings 'b' and 'k'\n\nmy solution produces the palindrome \"aacabacaa\" (deleting 'dk') but the solution is rejected on test case 46.  How do I get my solution accepted?  \n"
                    },
                    {
                        "username": "slashtab",
                        "content": "The substring is continuous part of the string. You can not delete some characters in-between. "
                    },
                    {
                        "username": "lakshyag9775",
                        "content": "Please Put it under  **HARD** Tag"
                    },
                    {
                        "username": "CristianM92",
                        "content": "Check Manacher\\u2019s algorithm"
                    },
                    {
                        "username": "aayushnag84",
                        "content": "Can anyone explain why this code is not working?\\n\\n\\n``class Solution \\n{\\n      public String longestPalindrome(String s) \\n    {\\n        recur(s, 0, s.length()-1);\\n        System.out.println(max);\\n        return ans;\\n    }\\n    static int max = 0;\\n    static String ans = \"\";\\n    public static int recur(String s, int i, int j)\\n    {\\n        if(i==j) return 1;\\n        else if(j-i == 1 && s.charAt(i)==s.charAt(j)) return 2;\\n        else if(j-i == 1) return 1;\\n        else\\n        {\\n            if(s.charAt(i) == s.charAt(j)) \\n            {         \\n                System.out.println(s.substring(i,j+1));       \\n                int temp = 2 + recur(s, i+1, j-1);\\n                max = temp>max ? temp: max;\\n                ans = temp>max ? s.substring(i,j+1) : ans;\\n                return temp;\\n            }                \\n            else \\n            {\\n                System.out.println(s.substring(i,j+1)); \\n                int temp = recur(s, i+1, j-1);\\n                max = temp>max ? temp : max;\\n                ans = temp>max ? s.substring(i,j+1) : ans;\\n                return temp;\\n            }\\n        }\\n    }\\n}``"
                    },
                    {
                        "username": "Primus4",
                        "content": "my 131 test cases have passed and code runs excellent in other compilers but here it gives garbage value;\\n "
                    }
                ]
            },
            {
                "id": 1786279,
                "content": [
                    {
                        "username": "Sampath3756",
                        "content": "in my code i am able to pass all test cases but time limit exceeds, my approach of the problem is using for of for loop for starting and ending point of the substring, and checking the substring is palindrome or not, if it is palindrome comparing the sizes of the longest and current sub string and replacing the longest string with current sub string, could anyone help me for getting my approach better and pass all test cases in time"
                    },
                    {
                        "username": "steve1302",
                        "content": "for input  \"aacabdkacaa\" test case is expecting \"aca\" which is incorrect output.  \"aaca\" is the correct one. how can we solve this??"
                    },
                    {
                        "username": "AMerrill",
                        "content": "\"*aca*\" is the correct output, as \"*aaca*\" is not a palindrome."
                    },
                    {
                        "username": "jems1123",
                        "content": "Can some one implement LCS with recursion and  return data type should be string"
                    },
                    {
                        "username": "user5248P",
                        "content": "LeetCode needs to improve the test cases here. My brute force solution was good enough"
                    },
                    {
                        "username": "vishal0509",
                        "content": "time limit exceeded :("
                    },
                    {
                        "username": "vishal0509",
                        "content": "i am using o(n^2) "
                    },
                    {
                        "username": "AveryBurke",
                        "content": " [@LeetCode](/LeetCode)\nthe expected answer for test case 46 is incorrect.\nThe test string is \"aacabdkacaa\" and the expected out put is \"aca\". I can obtain the following palindromes of length 9 by deleting substring (i've added spacing to make this easier to see):\n\n\"aaca b acaa\" by deleting the substring 'dk'\n\"aaca k acaa\" by deleting the substring 'bd'\n\"aaca d acaa\" by deleting the substrings 'b' and 'k'\n\nmy solution produces the palindrome \"aacabacaa\" (deleting 'dk') but the solution is rejected on test case 46.  How do I get my solution accepted?  \n"
                    },
                    {
                        "username": "slashtab",
                        "content": "The substring is continuous part of the string. You can not delete some characters in-between. "
                    },
                    {
                        "username": "lakshyag9775",
                        "content": "Please Put it under  **HARD** Tag"
                    },
                    {
                        "username": "CristianM92",
                        "content": "Check Manacher\\u2019s algorithm"
                    },
                    {
                        "username": "aayushnag84",
                        "content": "Can anyone explain why this code is not working?\\n\\n\\n``class Solution \\n{\\n      public String longestPalindrome(String s) \\n    {\\n        recur(s, 0, s.length()-1);\\n        System.out.println(max);\\n        return ans;\\n    }\\n    static int max = 0;\\n    static String ans = \"\";\\n    public static int recur(String s, int i, int j)\\n    {\\n        if(i==j) return 1;\\n        else if(j-i == 1 && s.charAt(i)==s.charAt(j)) return 2;\\n        else if(j-i == 1) return 1;\\n        else\\n        {\\n            if(s.charAt(i) == s.charAt(j)) \\n            {         \\n                System.out.println(s.substring(i,j+1));       \\n                int temp = 2 + recur(s, i+1, j-1);\\n                max = temp>max ? temp: max;\\n                ans = temp>max ? s.substring(i,j+1) : ans;\\n                return temp;\\n            }                \\n            else \\n            {\\n                System.out.println(s.substring(i,j+1)); \\n                int temp = recur(s, i+1, j-1);\\n                max = temp>max ? temp : max;\\n                ans = temp>max ? s.substring(i,j+1) : ans;\\n                return temp;\\n            }\\n        }\\n    }\\n}``"
                    },
                    {
                        "username": "Primus4",
                        "content": "my 131 test cases have passed and code runs excellent in other compilers but here it gives garbage value;\\n "
                    }
                ]
            },
            {
                "id": 1785028,
                "content": [
                    {
                        "username": "Sampath3756",
                        "content": "in my code i am able to pass all test cases but time limit exceeds, my approach of the problem is using for of for loop for starting and ending point of the substring, and checking the substring is palindrome or not, if it is palindrome comparing the sizes of the longest and current sub string and replacing the longest string with current sub string, could anyone help me for getting my approach better and pass all test cases in time"
                    },
                    {
                        "username": "steve1302",
                        "content": "for input  \"aacabdkacaa\" test case is expecting \"aca\" which is incorrect output.  \"aaca\" is the correct one. how can we solve this??"
                    },
                    {
                        "username": "AMerrill",
                        "content": "\"*aca*\" is the correct output, as \"*aaca*\" is not a palindrome."
                    },
                    {
                        "username": "jems1123",
                        "content": "Can some one implement LCS with recursion and  return data type should be string"
                    },
                    {
                        "username": "user5248P",
                        "content": "LeetCode needs to improve the test cases here. My brute force solution was good enough"
                    },
                    {
                        "username": "vishal0509",
                        "content": "time limit exceeded :("
                    },
                    {
                        "username": "vishal0509",
                        "content": "i am using o(n^2) "
                    },
                    {
                        "username": "AveryBurke",
                        "content": " [@LeetCode](/LeetCode)\nthe expected answer for test case 46 is incorrect.\nThe test string is \"aacabdkacaa\" and the expected out put is \"aca\". I can obtain the following palindromes of length 9 by deleting substring (i've added spacing to make this easier to see):\n\n\"aaca b acaa\" by deleting the substring 'dk'\n\"aaca k acaa\" by deleting the substring 'bd'\n\"aaca d acaa\" by deleting the substrings 'b' and 'k'\n\nmy solution produces the palindrome \"aacabacaa\" (deleting 'dk') but the solution is rejected on test case 46.  How do I get my solution accepted?  \n"
                    },
                    {
                        "username": "slashtab",
                        "content": "The substring is continuous part of the string. You can not delete some characters in-between. "
                    },
                    {
                        "username": "lakshyag9775",
                        "content": "Please Put it under  **HARD** Tag"
                    },
                    {
                        "username": "CristianM92",
                        "content": "Check Manacher\\u2019s algorithm"
                    },
                    {
                        "username": "aayushnag84",
                        "content": "Can anyone explain why this code is not working?\\n\\n\\n``class Solution \\n{\\n      public String longestPalindrome(String s) \\n    {\\n        recur(s, 0, s.length()-1);\\n        System.out.println(max);\\n        return ans;\\n    }\\n    static int max = 0;\\n    static String ans = \"\";\\n    public static int recur(String s, int i, int j)\\n    {\\n        if(i==j) return 1;\\n        else if(j-i == 1 && s.charAt(i)==s.charAt(j)) return 2;\\n        else if(j-i == 1) return 1;\\n        else\\n        {\\n            if(s.charAt(i) == s.charAt(j)) \\n            {         \\n                System.out.println(s.substring(i,j+1));       \\n                int temp = 2 + recur(s, i+1, j-1);\\n                max = temp>max ? temp: max;\\n                ans = temp>max ? s.substring(i,j+1) : ans;\\n                return temp;\\n            }                \\n            else \\n            {\\n                System.out.println(s.substring(i,j+1)); \\n                int temp = recur(s, i+1, j-1);\\n                max = temp>max ? temp : max;\\n                ans = temp>max ? s.substring(i,j+1) : ans;\\n                return temp;\\n            }\\n        }\\n    }\\n}``"
                    },
                    {
                        "username": "Primus4",
                        "content": "my 131 test cases have passed and code runs excellent in other compilers but here it gives garbage value;\\n "
                    }
                ]
            },
            {
                "id": 1780987,
                "content": [
                    {
                        "username": "kasomaibrahim",
                        "content": "A faster solution with time complexity of O(n) is the Manacher algorithm. It utilizes the idea that if a palindrome has its center at the current position and its right boundary has reached position j, then the palindrome with its center at the current position will have the same length as the palindrome with its center at the symmetrical position of j with respect to the current position, as long as j is within the boundary of the palindrome with center at the current position."
                    },
                    {
                        "username": "Satyarth_Agrahari",
                        "content": "The C++ code provided implements Manacher\\'s algorithm to find the longest palindromic substring in a given input string.\\n\\nThe code starts by defining a function named \"longestPalindrome\" which takes a string as its input and returns a string as its output.\\n\\nThe first step in the function is to preprocess the input string by inserting special characters between each character and also at the beginning and end of the string. This is done by creating a new string \"temp\" and iterating through each character in the input string, adding it to \"temp\" and also adding the special character \"#\" after it. This modified string is then stored in \"s\".\\n\\nNext, the code defines two arrays \"p\" and \"id\" of size n+1, where n is the length of the modified string. The array \"p\" is used to hold the length of the palindrome centered at each character in the modified string and the array \"id\" is used to keep track of the center and right boundary of the current palindrome.\\n\\nThe code then initializes two variables \"mx\" and \"id\" to 0 and assigns the value 0 to all elements of the \"p\" array.\\n\\nThe algorithm then starts iterating through each character in the modified string using a for loop, for each i in s.\\n\\nThe first thing the code does inside the for loop is to check if the current character is within the right boundary of the previous palindrome. If so, it uses the \"mirroring\" technique to calculate the length of the palindrome centered at the current character. It sets the value of \"p[i]\" to the minimum of \"p[(id*2-i)\" and \"mx-i\".\\n\\nOtherwise, the code falls back to the \"expanding around the center\" technique and starts checking the characters on both sides of the current character to find the length of the palindrome centered at the current character.\\n\\nThe code then updates the \"mx\" and \"id\" variables if the current palindrome exceeds the right boundary of the previous palindrome.\\n\\nFinally, the code finds the center and length of the longest palindrome by iterating through the \"p\" array and returning the substring of the original input string using the center and length information.\\n\\nIt\\'s important to note that the above code is just an example and this specific implementation may be different from other ones, but the overall idea and algorithm remains the same."
                    },
                    {
                        "username": "paragtharani24",
                        "content": "can anyone please optimize  below code:\\n\\n/**\\n * @param {string} s\\n * @return {string}\\n */\\nvar longestPalindrome = function(s) {\\n    let longestPalString = \"\"\\n    for(var i=0; i<s.length; i++){\\n        let str = \"\"\\n        for(var j=i; j<s.length; j++){\\n            str = str + s[j]\\n            if(isPalindrome(str)){\\n                if(str.length > longestPalString.length){\\n                    longestPalString = str\\n                }\\n            }\\n        }\\n    }\\n\\n    return longestPalString;\\n};\\n\\nfunction isPalindrome(str){\\n    let left = 0\\n    let right = str.length - 1\\n\\n    while (left < right) {\\n        if (str[left++] !== str[right--]) {\\n            return false\\n        }\\n    }\\n\\n    return true\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Hi, I am getting memory limit exceeds in my code. Can you please help to fix. I know my code taking too much memory, but how I fix this.\\nCan we able to modify it so it doesn\\'t give memory limit exceeds or we are not able to modify it.\\nThanks for any suggestion.\\n\\n  class Solution {\\n    `List<String> outer = new ArrayList<>();\\n    public String longestPalindrome(String s) {\\n        String result = \"\";\\n        helper(s , 0, s.length()- 1, \"\");\\n        for (String man:outer) {\\n            int l = man.length();\\n            if (result.length()<l){\\n                result = man;\\n            }\\n        }\\n        return result;\\n    }\\n    public void helper(String s, int start, int end, String result){\\n        int mid = result.length()/2;\\n        if(start> end){\\n            outer.add(result);\\n            return;\\n        }\\n        if(start == end){\\n            char ch = s.charAt(end);\\n            String left = result.substring(0, mid);\\n            String right = result.substring(mid);\\n            result = left + ch + right;\\n            outer.add(result);\\n            helper(s, start + 1, s.length() -1, \"\");\\n             return;\\n        }\\n        char ch1 = s.charAt(start);\\n        char ch2 = s.charAt(end);\\n        if(ch1 == ch2){\\n\\n            String left = result.substring(0, mid);\\n            String right = result.substring(mid);\\n            result = left + ch1 + ch2 + right;\\n            helper(s, start + 1, end - 1, result);\\n        }\\n        result = \"\";\\n        helper(s, start, end - 1, result);\\n    }\\n}`"
                    },
                    {
                        "username": "hiranmay1000",
                        "content": "Why this is coming? help!!\n\nYour input\n\"aacabdkacaa\"\nOutput\n\"aacabacaa\"\nExpected\n\"aca\""
                    },
                    {
                        "username": "hiranmay1000",
                        "content": "Why this is happening please help !! \\nI have used map for finding the longest palindromic substring\\n\\nYour input : \"aacabdkacaa\"\\nOutput : \"aacabacaa\"\\nExpected : \"aca\""
                    },
                    {
                        "username": "shubha_neema",
                        "content": "Getting wrong answer, even for correct answer. Can anyone tell me why this is happening?\\nInput\\ns =\"babad\"\\nOutput\\n\"aba\"\\nExpected\\n\"bab\""
                    },
                    {
                        "username": "vismay__yerunkar",
                        "content": "Subscribe Hustlers Algorithm\\uD83D\\uDCA6\\uD83D\\uDCA6\\uD83D\\uDCA6\\uD83D\\uDD25\\uD83D\\uDD25 `https://youtu.be/94RdOzbXvHM`  Lets make a stronger problem solving community. subscribe to the channel for amazing dsa content."
                    },
                    {
                        "username": "prasannaprassu80",
                        "content": "What is wrong in my code? 127/141 test cases are passed. if i check the failed test case, by copy and paste them in the test case, that test case is getting passed,. then why it is showing test cases failed?\n\n\ndef longestPalindrome(self, s: str) -> str:\n        length_list= []\n        max_len=0\n        result=\"\"\n        for i in range(len(s)):\n            for j in range(i+1, len(s)+1):\n                substring= s[i:j]\n                rev_substring= substring[::-1]\n                if (substring== rev_substring):\n                    length_list.append(substring)\n        for each in length_list:\n            if len(each)> max_len:\n                max_len= len(each)\n                result= each\n        return (result)\n[leetcode](https://leetcode.com) "
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@prasannaprassu80](/prasannaprassu80)\nTime Limit Exceeded!!!\n\nIt not a error of your code, it's time complexity."
                    },
                    {
                        "username": "zohairhadi",
                        "content": "I thought that I\\'d come up with a good solution but there\\'s a lot of edge cases that my solution doesn\\'t cater to. \\nAny suggestions on what I\\'m missing?\\n\\n`\\n        def longestPalindrome(self, s):\\n\\n\\n        longest = \"\"\\n        temp_longest = \"\"\\n        for i in range(1, len(s)-2):\\n\\n            if s[i-1] == s[i+1]:\\n                count = 2\\n                while (s[i-count] == s[i+count]):\\n                    count += 1\\n                count -= 1\\n                temp_longest = s[i-count: i+count + 1]\\n\\n            elif s[i] == s[i+1]:\\n                count = 1\\n                while (s[i-count] == s[i+1+count]):\\n                    count += 1\\n                count -= 1\\n                temp_longest = s[i-count: i+1+count + 1]\\n\\n            if len(temp_longest) > len(longest):\\n                longest = temp_longest\\n\\n        return longest            \\n`"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@zohairhadi2000](/zohairhadi2000) This code will get in trouble even for simple testcase:\ns= \"bbbbbbbb\"\nWhy?\n\nBecause you didnt define a boundary condition for string that you check on:\n```\nif s[i-1] == s[i+1]:\n            count = 2\n            while (s[i-count] == s[i+count]):\n                count += 1\n            count -= 1\n            temp_longest = s[i-count: i+count + 1]\n```\nWhat if? s[i-count], i-count<0?, i+count>len(s)-1. It returns a \n_IndexError: string index out of range_ right\n\nSo first, check your condition, then run dry test (change some simple case by yourself). \n\nYou can use a slide windows to check, and only check to len(s)-l-1, l=max last found palindromic substring.\n\n```\nclass Solution:\n    def longestPalindrome(self, s: str) -> str:\n        n, l, i, temp, s1 = [len(s), 1, 0, 0, s[::-1]] \n        if s1==s: return s \n        while i+l <= n-1:\n            for j in range(l,n-i+1):\n                if s1[i:i+j] ==s[n-j-i:n-i]: l=j; temp=i\n                if s1[i:i+j] not in s: break\n            if i<=n-l-1:    i+=1; continue \n            else: break \n        if temp==0 and l==1: return s[0]\n        return s[n-l-temp:n-temp]  \n```"
                    }
                ]
            },
            {
                "id": 1777802,
                "content": [
                    {
                        "username": "kasomaibrahim",
                        "content": "A faster solution with time complexity of O(n) is the Manacher algorithm. It utilizes the idea that if a palindrome has its center at the current position and its right boundary has reached position j, then the palindrome with its center at the current position will have the same length as the palindrome with its center at the symmetrical position of j with respect to the current position, as long as j is within the boundary of the palindrome with center at the current position."
                    },
                    {
                        "username": "Satyarth_Agrahari",
                        "content": "The C++ code provided implements Manacher\\'s algorithm to find the longest palindromic substring in a given input string.\\n\\nThe code starts by defining a function named \"longestPalindrome\" which takes a string as its input and returns a string as its output.\\n\\nThe first step in the function is to preprocess the input string by inserting special characters between each character and also at the beginning and end of the string. This is done by creating a new string \"temp\" and iterating through each character in the input string, adding it to \"temp\" and also adding the special character \"#\" after it. This modified string is then stored in \"s\".\\n\\nNext, the code defines two arrays \"p\" and \"id\" of size n+1, where n is the length of the modified string. The array \"p\" is used to hold the length of the palindrome centered at each character in the modified string and the array \"id\" is used to keep track of the center and right boundary of the current palindrome.\\n\\nThe code then initializes two variables \"mx\" and \"id\" to 0 and assigns the value 0 to all elements of the \"p\" array.\\n\\nThe algorithm then starts iterating through each character in the modified string using a for loop, for each i in s.\\n\\nThe first thing the code does inside the for loop is to check if the current character is within the right boundary of the previous palindrome. If so, it uses the \"mirroring\" technique to calculate the length of the palindrome centered at the current character. It sets the value of \"p[i]\" to the minimum of \"p[(id*2-i)\" and \"mx-i\".\\n\\nOtherwise, the code falls back to the \"expanding around the center\" technique and starts checking the characters on both sides of the current character to find the length of the palindrome centered at the current character.\\n\\nThe code then updates the \"mx\" and \"id\" variables if the current palindrome exceeds the right boundary of the previous palindrome.\\n\\nFinally, the code finds the center and length of the longest palindrome by iterating through the \"p\" array and returning the substring of the original input string using the center and length information.\\n\\nIt\\'s important to note that the above code is just an example and this specific implementation may be different from other ones, but the overall idea and algorithm remains the same."
                    },
                    {
                        "username": "paragtharani24",
                        "content": "can anyone please optimize  below code:\\n\\n/**\\n * @param {string} s\\n * @return {string}\\n */\\nvar longestPalindrome = function(s) {\\n    let longestPalString = \"\"\\n    for(var i=0; i<s.length; i++){\\n        let str = \"\"\\n        for(var j=i; j<s.length; j++){\\n            str = str + s[j]\\n            if(isPalindrome(str)){\\n                if(str.length > longestPalString.length){\\n                    longestPalString = str\\n                }\\n            }\\n        }\\n    }\\n\\n    return longestPalString;\\n};\\n\\nfunction isPalindrome(str){\\n    let left = 0\\n    let right = str.length - 1\\n\\n    while (left < right) {\\n        if (str[left++] !== str[right--]) {\\n            return false\\n        }\\n    }\\n\\n    return true\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Hi, I am getting memory limit exceeds in my code. Can you please help to fix. I know my code taking too much memory, but how I fix this.\\nCan we able to modify it so it doesn\\'t give memory limit exceeds or we are not able to modify it.\\nThanks for any suggestion.\\n\\n  class Solution {\\n    `List<String> outer = new ArrayList<>();\\n    public String longestPalindrome(String s) {\\n        String result = \"\";\\n        helper(s , 0, s.length()- 1, \"\");\\n        for (String man:outer) {\\n            int l = man.length();\\n            if (result.length()<l){\\n                result = man;\\n            }\\n        }\\n        return result;\\n    }\\n    public void helper(String s, int start, int end, String result){\\n        int mid = result.length()/2;\\n        if(start> end){\\n            outer.add(result);\\n            return;\\n        }\\n        if(start == end){\\n            char ch = s.charAt(end);\\n            String left = result.substring(0, mid);\\n            String right = result.substring(mid);\\n            result = left + ch + right;\\n            outer.add(result);\\n            helper(s, start + 1, s.length() -1, \"\");\\n             return;\\n        }\\n        char ch1 = s.charAt(start);\\n        char ch2 = s.charAt(end);\\n        if(ch1 == ch2){\\n\\n            String left = result.substring(0, mid);\\n            String right = result.substring(mid);\\n            result = left + ch1 + ch2 + right;\\n            helper(s, start + 1, end - 1, result);\\n        }\\n        result = \"\";\\n        helper(s, start, end - 1, result);\\n    }\\n}`"
                    },
                    {
                        "username": "hiranmay1000",
                        "content": "Why this is coming? help!!\n\nYour input\n\"aacabdkacaa\"\nOutput\n\"aacabacaa\"\nExpected\n\"aca\""
                    },
                    {
                        "username": "hiranmay1000",
                        "content": "Why this is happening please help !! \\nI have used map for finding the longest palindromic substring\\n\\nYour input : \"aacabdkacaa\"\\nOutput : \"aacabacaa\"\\nExpected : \"aca\""
                    },
                    {
                        "username": "shubha_neema",
                        "content": "Getting wrong answer, even for correct answer. Can anyone tell me why this is happening?\\nInput\\ns =\"babad\"\\nOutput\\n\"aba\"\\nExpected\\n\"bab\""
                    },
                    {
                        "username": "vismay__yerunkar",
                        "content": "Subscribe Hustlers Algorithm\\uD83D\\uDCA6\\uD83D\\uDCA6\\uD83D\\uDCA6\\uD83D\\uDD25\\uD83D\\uDD25 `https://youtu.be/94RdOzbXvHM`  Lets make a stronger problem solving community. subscribe to the channel for amazing dsa content."
                    },
                    {
                        "username": "prasannaprassu80",
                        "content": "What is wrong in my code? 127/141 test cases are passed. if i check the failed test case, by copy and paste them in the test case, that test case is getting passed,. then why it is showing test cases failed?\n\n\ndef longestPalindrome(self, s: str) -> str:\n        length_list= []\n        max_len=0\n        result=\"\"\n        for i in range(len(s)):\n            for j in range(i+1, len(s)+1):\n                substring= s[i:j]\n                rev_substring= substring[::-1]\n                if (substring== rev_substring):\n                    length_list.append(substring)\n        for each in length_list:\n            if len(each)> max_len:\n                max_len= len(each)\n                result= each\n        return (result)\n[leetcode](https://leetcode.com) "
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@prasannaprassu80](/prasannaprassu80)\nTime Limit Exceeded!!!\n\nIt not a error of your code, it's time complexity."
                    },
                    {
                        "username": "zohairhadi",
                        "content": "I thought that I\\'d come up with a good solution but there\\'s a lot of edge cases that my solution doesn\\'t cater to. \\nAny suggestions on what I\\'m missing?\\n\\n`\\n        def longestPalindrome(self, s):\\n\\n\\n        longest = \"\"\\n        temp_longest = \"\"\\n        for i in range(1, len(s)-2):\\n\\n            if s[i-1] == s[i+1]:\\n                count = 2\\n                while (s[i-count] == s[i+count]):\\n                    count += 1\\n                count -= 1\\n                temp_longest = s[i-count: i+count + 1]\\n\\n            elif s[i] == s[i+1]:\\n                count = 1\\n                while (s[i-count] == s[i+1+count]):\\n                    count += 1\\n                count -= 1\\n                temp_longest = s[i-count: i+1+count + 1]\\n\\n            if len(temp_longest) > len(longest):\\n                longest = temp_longest\\n\\n        return longest            \\n`"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@zohairhadi2000](/zohairhadi2000) This code will get in trouble even for simple testcase:\ns= \"bbbbbbbb\"\nWhy?\n\nBecause you didnt define a boundary condition for string that you check on:\n```\nif s[i-1] == s[i+1]:\n            count = 2\n            while (s[i-count] == s[i+count]):\n                count += 1\n            count -= 1\n            temp_longest = s[i-count: i+count + 1]\n```\nWhat if? s[i-count], i-count<0?, i+count>len(s)-1. It returns a \n_IndexError: string index out of range_ right\n\nSo first, check your condition, then run dry test (change some simple case by yourself). \n\nYou can use a slide windows to check, and only check to len(s)-l-1, l=max last found palindromic substring.\n\n```\nclass Solution:\n    def longestPalindrome(self, s: str) -> str:\n        n, l, i, temp, s1 = [len(s), 1, 0, 0, s[::-1]] \n        if s1==s: return s \n        while i+l <= n-1:\n            for j in range(l,n-i+1):\n                if s1[i:i+j] ==s[n-j-i:n-i]: l=j; temp=i\n                if s1[i:i+j] not in s: break\n            if i<=n-l-1:    i+=1; continue \n            else: break \n        if temp==0 and l==1: return s[0]\n        return s[n-l-temp:n-temp]  \n```"
                    }
                ]
            },
            {
                "id": 1777520,
                "content": [
                    {
                        "username": "kasomaibrahim",
                        "content": "A faster solution with time complexity of O(n) is the Manacher algorithm. It utilizes the idea that if a palindrome has its center at the current position and its right boundary has reached position j, then the palindrome with its center at the current position will have the same length as the palindrome with its center at the symmetrical position of j with respect to the current position, as long as j is within the boundary of the palindrome with center at the current position."
                    },
                    {
                        "username": "Satyarth_Agrahari",
                        "content": "The C++ code provided implements Manacher\\'s algorithm to find the longest palindromic substring in a given input string.\\n\\nThe code starts by defining a function named \"longestPalindrome\" which takes a string as its input and returns a string as its output.\\n\\nThe first step in the function is to preprocess the input string by inserting special characters between each character and also at the beginning and end of the string. This is done by creating a new string \"temp\" and iterating through each character in the input string, adding it to \"temp\" and also adding the special character \"#\" after it. This modified string is then stored in \"s\".\\n\\nNext, the code defines two arrays \"p\" and \"id\" of size n+1, where n is the length of the modified string. The array \"p\" is used to hold the length of the palindrome centered at each character in the modified string and the array \"id\" is used to keep track of the center and right boundary of the current palindrome.\\n\\nThe code then initializes two variables \"mx\" and \"id\" to 0 and assigns the value 0 to all elements of the \"p\" array.\\n\\nThe algorithm then starts iterating through each character in the modified string using a for loop, for each i in s.\\n\\nThe first thing the code does inside the for loop is to check if the current character is within the right boundary of the previous palindrome. If so, it uses the \"mirroring\" technique to calculate the length of the palindrome centered at the current character. It sets the value of \"p[i]\" to the minimum of \"p[(id*2-i)\" and \"mx-i\".\\n\\nOtherwise, the code falls back to the \"expanding around the center\" technique and starts checking the characters on both sides of the current character to find the length of the palindrome centered at the current character.\\n\\nThe code then updates the \"mx\" and \"id\" variables if the current palindrome exceeds the right boundary of the previous palindrome.\\n\\nFinally, the code finds the center and length of the longest palindrome by iterating through the \"p\" array and returning the substring of the original input string using the center and length information.\\n\\nIt\\'s important to note that the above code is just an example and this specific implementation may be different from other ones, but the overall idea and algorithm remains the same."
                    },
                    {
                        "username": "paragtharani24",
                        "content": "can anyone please optimize  below code:\\n\\n/**\\n * @param {string} s\\n * @return {string}\\n */\\nvar longestPalindrome = function(s) {\\n    let longestPalString = \"\"\\n    for(var i=0; i<s.length; i++){\\n        let str = \"\"\\n        for(var j=i; j<s.length; j++){\\n            str = str + s[j]\\n            if(isPalindrome(str)){\\n                if(str.length > longestPalString.length){\\n                    longestPalString = str\\n                }\\n            }\\n        }\\n    }\\n\\n    return longestPalString;\\n};\\n\\nfunction isPalindrome(str){\\n    let left = 0\\n    let right = str.length - 1\\n\\n    while (left < right) {\\n        if (str[left++] !== str[right--]) {\\n            return false\\n        }\\n    }\\n\\n    return true\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Hi, I am getting memory limit exceeds in my code. Can you please help to fix. I know my code taking too much memory, but how I fix this.\\nCan we able to modify it so it doesn\\'t give memory limit exceeds or we are not able to modify it.\\nThanks for any suggestion.\\n\\n  class Solution {\\n    `List<String> outer = new ArrayList<>();\\n    public String longestPalindrome(String s) {\\n        String result = \"\";\\n        helper(s , 0, s.length()- 1, \"\");\\n        for (String man:outer) {\\n            int l = man.length();\\n            if (result.length()<l){\\n                result = man;\\n            }\\n        }\\n        return result;\\n    }\\n    public void helper(String s, int start, int end, String result){\\n        int mid = result.length()/2;\\n        if(start> end){\\n            outer.add(result);\\n            return;\\n        }\\n        if(start == end){\\n            char ch = s.charAt(end);\\n            String left = result.substring(0, mid);\\n            String right = result.substring(mid);\\n            result = left + ch + right;\\n            outer.add(result);\\n            helper(s, start + 1, s.length() -1, \"\");\\n             return;\\n        }\\n        char ch1 = s.charAt(start);\\n        char ch2 = s.charAt(end);\\n        if(ch1 == ch2){\\n\\n            String left = result.substring(0, mid);\\n            String right = result.substring(mid);\\n            result = left + ch1 + ch2 + right;\\n            helper(s, start + 1, end - 1, result);\\n        }\\n        result = \"\";\\n        helper(s, start, end - 1, result);\\n    }\\n}`"
                    },
                    {
                        "username": "hiranmay1000",
                        "content": "Why this is coming? help!!\n\nYour input\n\"aacabdkacaa\"\nOutput\n\"aacabacaa\"\nExpected\n\"aca\""
                    },
                    {
                        "username": "hiranmay1000",
                        "content": "Why this is happening please help !! \\nI have used map for finding the longest palindromic substring\\n\\nYour input : \"aacabdkacaa\"\\nOutput : \"aacabacaa\"\\nExpected : \"aca\""
                    },
                    {
                        "username": "shubha_neema",
                        "content": "Getting wrong answer, even for correct answer. Can anyone tell me why this is happening?\\nInput\\ns =\"babad\"\\nOutput\\n\"aba\"\\nExpected\\n\"bab\""
                    },
                    {
                        "username": "vismay__yerunkar",
                        "content": "Subscribe Hustlers Algorithm\\uD83D\\uDCA6\\uD83D\\uDCA6\\uD83D\\uDCA6\\uD83D\\uDD25\\uD83D\\uDD25 `https://youtu.be/94RdOzbXvHM`  Lets make a stronger problem solving community. subscribe to the channel for amazing dsa content."
                    },
                    {
                        "username": "prasannaprassu80",
                        "content": "What is wrong in my code? 127/141 test cases are passed. if i check the failed test case, by copy and paste them in the test case, that test case is getting passed,. then why it is showing test cases failed?\n\n\ndef longestPalindrome(self, s: str) -> str:\n        length_list= []\n        max_len=0\n        result=\"\"\n        for i in range(len(s)):\n            for j in range(i+1, len(s)+1):\n                substring= s[i:j]\n                rev_substring= substring[::-1]\n                if (substring== rev_substring):\n                    length_list.append(substring)\n        for each in length_list:\n            if len(each)> max_len:\n                max_len= len(each)\n                result= each\n        return (result)\n[leetcode](https://leetcode.com) "
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@prasannaprassu80](/prasannaprassu80)\nTime Limit Exceeded!!!\n\nIt not a error of your code, it's time complexity."
                    },
                    {
                        "username": "zohairhadi",
                        "content": "I thought that I\\'d come up with a good solution but there\\'s a lot of edge cases that my solution doesn\\'t cater to. \\nAny suggestions on what I\\'m missing?\\n\\n`\\n        def longestPalindrome(self, s):\\n\\n\\n        longest = \"\"\\n        temp_longest = \"\"\\n        for i in range(1, len(s)-2):\\n\\n            if s[i-1] == s[i+1]:\\n                count = 2\\n                while (s[i-count] == s[i+count]):\\n                    count += 1\\n                count -= 1\\n                temp_longest = s[i-count: i+count + 1]\\n\\n            elif s[i] == s[i+1]:\\n                count = 1\\n                while (s[i-count] == s[i+1+count]):\\n                    count += 1\\n                count -= 1\\n                temp_longest = s[i-count: i+1+count + 1]\\n\\n            if len(temp_longest) > len(longest):\\n                longest = temp_longest\\n\\n        return longest            \\n`"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@zohairhadi2000](/zohairhadi2000) This code will get in trouble even for simple testcase:\ns= \"bbbbbbbb\"\nWhy?\n\nBecause you didnt define a boundary condition for string that you check on:\n```\nif s[i-1] == s[i+1]:\n            count = 2\n            while (s[i-count] == s[i+count]):\n                count += 1\n            count -= 1\n            temp_longest = s[i-count: i+count + 1]\n```\nWhat if? s[i-count], i-count<0?, i+count>len(s)-1. It returns a \n_IndexError: string index out of range_ right\n\nSo first, check your condition, then run dry test (change some simple case by yourself). \n\nYou can use a slide windows to check, and only check to len(s)-l-1, l=max last found palindromic substring.\n\n```\nclass Solution:\n    def longestPalindrome(self, s: str) -> str:\n        n, l, i, temp, s1 = [len(s), 1, 0, 0, s[::-1]] \n        if s1==s: return s \n        while i+l <= n-1:\n            for j in range(l,n-i+1):\n                if s1[i:i+j] ==s[n-j-i:n-i]: l=j; temp=i\n                if s1[i:i+j] not in s: break\n            if i<=n-l-1:    i+=1; continue \n            else: break \n        if temp==0 and l==1: return s[0]\n        return s[n-l-temp:n-temp]  \n```"
                    }
                ]
            },
            {
                "id": 1776677,
                "content": [
                    {
                        "username": "kasomaibrahim",
                        "content": "A faster solution with time complexity of O(n) is the Manacher algorithm. It utilizes the idea that if a palindrome has its center at the current position and its right boundary has reached position j, then the palindrome with its center at the current position will have the same length as the palindrome with its center at the symmetrical position of j with respect to the current position, as long as j is within the boundary of the palindrome with center at the current position."
                    },
                    {
                        "username": "Satyarth_Agrahari",
                        "content": "The C++ code provided implements Manacher\\'s algorithm to find the longest palindromic substring in a given input string.\\n\\nThe code starts by defining a function named \"longestPalindrome\" which takes a string as its input and returns a string as its output.\\n\\nThe first step in the function is to preprocess the input string by inserting special characters between each character and also at the beginning and end of the string. This is done by creating a new string \"temp\" and iterating through each character in the input string, adding it to \"temp\" and also adding the special character \"#\" after it. This modified string is then stored in \"s\".\\n\\nNext, the code defines two arrays \"p\" and \"id\" of size n+1, where n is the length of the modified string. The array \"p\" is used to hold the length of the palindrome centered at each character in the modified string and the array \"id\" is used to keep track of the center and right boundary of the current palindrome.\\n\\nThe code then initializes two variables \"mx\" and \"id\" to 0 and assigns the value 0 to all elements of the \"p\" array.\\n\\nThe algorithm then starts iterating through each character in the modified string using a for loop, for each i in s.\\n\\nThe first thing the code does inside the for loop is to check if the current character is within the right boundary of the previous palindrome. If so, it uses the \"mirroring\" technique to calculate the length of the palindrome centered at the current character. It sets the value of \"p[i]\" to the minimum of \"p[(id*2-i)\" and \"mx-i\".\\n\\nOtherwise, the code falls back to the \"expanding around the center\" technique and starts checking the characters on both sides of the current character to find the length of the palindrome centered at the current character.\\n\\nThe code then updates the \"mx\" and \"id\" variables if the current palindrome exceeds the right boundary of the previous palindrome.\\n\\nFinally, the code finds the center and length of the longest palindrome by iterating through the \"p\" array and returning the substring of the original input string using the center and length information.\\n\\nIt\\'s important to note that the above code is just an example and this specific implementation may be different from other ones, but the overall idea and algorithm remains the same."
                    },
                    {
                        "username": "paragtharani24",
                        "content": "can anyone please optimize  below code:\\n\\n/**\\n * @param {string} s\\n * @return {string}\\n */\\nvar longestPalindrome = function(s) {\\n    let longestPalString = \"\"\\n    for(var i=0; i<s.length; i++){\\n        let str = \"\"\\n        for(var j=i; j<s.length; j++){\\n            str = str + s[j]\\n            if(isPalindrome(str)){\\n                if(str.length > longestPalString.length){\\n                    longestPalString = str\\n                }\\n            }\\n        }\\n    }\\n\\n    return longestPalString;\\n};\\n\\nfunction isPalindrome(str){\\n    let left = 0\\n    let right = str.length - 1\\n\\n    while (left < right) {\\n        if (str[left++] !== str[right--]) {\\n            return false\\n        }\\n    }\\n\\n    return true\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Hi, I am getting memory limit exceeds in my code. Can you please help to fix. I know my code taking too much memory, but how I fix this.\\nCan we able to modify it so it doesn\\'t give memory limit exceeds or we are not able to modify it.\\nThanks for any suggestion.\\n\\n  class Solution {\\n    `List<String> outer = new ArrayList<>();\\n    public String longestPalindrome(String s) {\\n        String result = \"\";\\n        helper(s , 0, s.length()- 1, \"\");\\n        for (String man:outer) {\\n            int l = man.length();\\n            if (result.length()<l){\\n                result = man;\\n            }\\n        }\\n        return result;\\n    }\\n    public void helper(String s, int start, int end, String result){\\n        int mid = result.length()/2;\\n        if(start> end){\\n            outer.add(result);\\n            return;\\n        }\\n        if(start == end){\\n            char ch = s.charAt(end);\\n            String left = result.substring(0, mid);\\n            String right = result.substring(mid);\\n            result = left + ch + right;\\n            outer.add(result);\\n            helper(s, start + 1, s.length() -1, \"\");\\n             return;\\n        }\\n        char ch1 = s.charAt(start);\\n        char ch2 = s.charAt(end);\\n        if(ch1 == ch2){\\n\\n            String left = result.substring(0, mid);\\n            String right = result.substring(mid);\\n            result = left + ch1 + ch2 + right;\\n            helper(s, start + 1, end - 1, result);\\n        }\\n        result = \"\";\\n        helper(s, start, end - 1, result);\\n    }\\n}`"
                    },
                    {
                        "username": "hiranmay1000",
                        "content": "Why this is coming? help!!\n\nYour input\n\"aacabdkacaa\"\nOutput\n\"aacabacaa\"\nExpected\n\"aca\""
                    },
                    {
                        "username": "hiranmay1000",
                        "content": "Why this is happening please help !! \\nI have used map for finding the longest palindromic substring\\n\\nYour input : \"aacabdkacaa\"\\nOutput : \"aacabacaa\"\\nExpected : \"aca\""
                    },
                    {
                        "username": "shubha_neema",
                        "content": "Getting wrong answer, even for correct answer. Can anyone tell me why this is happening?\\nInput\\ns =\"babad\"\\nOutput\\n\"aba\"\\nExpected\\n\"bab\""
                    },
                    {
                        "username": "vismay__yerunkar",
                        "content": "Subscribe Hustlers Algorithm\\uD83D\\uDCA6\\uD83D\\uDCA6\\uD83D\\uDCA6\\uD83D\\uDD25\\uD83D\\uDD25 `https://youtu.be/94RdOzbXvHM`  Lets make a stronger problem solving community. subscribe to the channel for amazing dsa content."
                    },
                    {
                        "username": "prasannaprassu80",
                        "content": "What is wrong in my code? 127/141 test cases are passed. if i check the failed test case, by copy and paste them in the test case, that test case is getting passed,. then why it is showing test cases failed?\n\n\ndef longestPalindrome(self, s: str) -> str:\n        length_list= []\n        max_len=0\n        result=\"\"\n        for i in range(len(s)):\n            for j in range(i+1, len(s)+1):\n                substring= s[i:j]\n                rev_substring= substring[::-1]\n                if (substring== rev_substring):\n                    length_list.append(substring)\n        for each in length_list:\n            if len(each)> max_len:\n                max_len= len(each)\n                result= each\n        return (result)\n[leetcode](https://leetcode.com) "
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@prasannaprassu80](/prasannaprassu80)\nTime Limit Exceeded!!!\n\nIt not a error of your code, it's time complexity."
                    },
                    {
                        "username": "zohairhadi",
                        "content": "I thought that I\\'d come up with a good solution but there\\'s a lot of edge cases that my solution doesn\\'t cater to. \\nAny suggestions on what I\\'m missing?\\n\\n`\\n        def longestPalindrome(self, s):\\n\\n\\n        longest = \"\"\\n        temp_longest = \"\"\\n        for i in range(1, len(s)-2):\\n\\n            if s[i-1] == s[i+1]:\\n                count = 2\\n                while (s[i-count] == s[i+count]):\\n                    count += 1\\n                count -= 1\\n                temp_longest = s[i-count: i+count + 1]\\n\\n            elif s[i] == s[i+1]:\\n                count = 1\\n                while (s[i-count] == s[i+1+count]):\\n                    count += 1\\n                count -= 1\\n                temp_longest = s[i-count: i+1+count + 1]\\n\\n            if len(temp_longest) > len(longest):\\n                longest = temp_longest\\n\\n        return longest            \\n`"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@zohairhadi2000](/zohairhadi2000) This code will get in trouble even for simple testcase:\ns= \"bbbbbbbb\"\nWhy?\n\nBecause you didnt define a boundary condition for string that you check on:\n```\nif s[i-1] == s[i+1]:\n            count = 2\n            while (s[i-count] == s[i+count]):\n                count += 1\n            count -= 1\n            temp_longest = s[i-count: i+count + 1]\n```\nWhat if? s[i-count], i-count<0?, i+count>len(s)-1. It returns a \n_IndexError: string index out of range_ right\n\nSo first, check your condition, then run dry test (change some simple case by yourself). \n\nYou can use a slide windows to check, and only check to len(s)-l-1, l=max last found palindromic substring.\n\n```\nclass Solution:\n    def longestPalindrome(self, s: str) -> str:\n        n, l, i, temp, s1 = [len(s), 1, 0, 0, s[::-1]] \n        if s1==s: return s \n        while i+l <= n-1:\n            for j in range(l,n-i+1):\n                if s1[i:i+j] ==s[n-j-i:n-i]: l=j; temp=i\n                if s1[i:i+j] not in s: break\n            if i<=n-l-1:    i+=1; continue \n            else: break \n        if temp==0 and l==1: return s[0]\n        return s[n-l-temp:n-temp]  \n```"
                    }
                ]
            },
            {
                "id": 1775657,
                "content": [
                    {
                        "username": "kasomaibrahim",
                        "content": "A faster solution with time complexity of O(n) is the Manacher algorithm. It utilizes the idea that if a palindrome has its center at the current position and its right boundary has reached position j, then the palindrome with its center at the current position will have the same length as the palindrome with its center at the symmetrical position of j with respect to the current position, as long as j is within the boundary of the palindrome with center at the current position."
                    },
                    {
                        "username": "Satyarth_Agrahari",
                        "content": "The C++ code provided implements Manacher\\'s algorithm to find the longest palindromic substring in a given input string.\\n\\nThe code starts by defining a function named \"longestPalindrome\" which takes a string as its input and returns a string as its output.\\n\\nThe first step in the function is to preprocess the input string by inserting special characters between each character and also at the beginning and end of the string. This is done by creating a new string \"temp\" and iterating through each character in the input string, adding it to \"temp\" and also adding the special character \"#\" after it. This modified string is then stored in \"s\".\\n\\nNext, the code defines two arrays \"p\" and \"id\" of size n+1, where n is the length of the modified string. The array \"p\" is used to hold the length of the palindrome centered at each character in the modified string and the array \"id\" is used to keep track of the center and right boundary of the current palindrome.\\n\\nThe code then initializes two variables \"mx\" and \"id\" to 0 and assigns the value 0 to all elements of the \"p\" array.\\n\\nThe algorithm then starts iterating through each character in the modified string using a for loop, for each i in s.\\n\\nThe first thing the code does inside the for loop is to check if the current character is within the right boundary of the previous palindrome. If so, it uses the \"mirroring\" technique to calculate the length of the palindrome centered at the current character. It sets the value of \"p[i]\" to the minimum of \"p[(id*2-i)\" and \"mx-i\".\\n\\nOtherwise, the code falls back to the \"expanding around the center\" technique and starts checking the characters on both sides of the current character to find the length of the palindrome centered at the current character.\\n\\nThe code then updates the \"mx\" and \"id\" variables if the current palindrome exceeds the right boundary of the previous palindrome.\\n\\nFinally, the code finds the center and length of the longest palindrome by iterating through the \"p\" array and returning the substring of the original input string using the center and length information.\\n\\nIt\\'s important to note that the above code is just an example and this specific implementation may be different from other ones, but the overall idea and algorithm remains the same."
                    },
                    {
                        "username": "paragtharani24",
                        "content": "can anyone please optimize  below code:\\n\\n/**\\n * @param {string} s\\n * @return {string}\\n */\\nvar longestPalindrome = function(s) {\\n    let longestPalString = \"\"\\n    for(var i=0; i<s.length; i++){\\n        let str = \"\"\\n        for(var j=i; j<s.length; j++){\\n            str = str + s[j]\\n            if(isPalindrome(str)){\\n                if(str.length > longestPalString.length){\\n                    longestPalString = str\\n                }\\n            }\\n        }\\n    }\\n\\n    return longestPalString;\\n};\\n\\nfunction isPalindrome(str){\\n    let left = 0\\n    let right = str.length - 1\\n\\n    while (left < right) {\\n        if (str[left++] !== str[right--]) {\\n            return false\\n        }\\n    }\\n\\n    return true\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Hi, I am getting memory limit exceeds in my code. Can you please help to fix. I know my code taking too much memory, but how I fix this.\\nCan we able to modify it so it doesn\\'t give memory limit exceeds or we are not able to modify it.\\nThanks for any suggestion.\\n\\n  class Solution {\\n    `List<String> outer = new ArrayList<>();\\n    public String longestPalindrome(String s) {\\n        String result = \"\";\\n        helper(s , 0, s.length()- 1, \"\");\\n        for (String man:outer) {\\n            int l = man.length();\\n            if (result.length()<l){\\n                result = man;\\n            }\\n        }\\n        return result;\\n    }\\n    public void helper(String s, int start, int end, String result){\\n        int mid = result.length()/2;\\n        if(start> end){\\n            outer.add(result);\\n            return;\\n        }\\n        if(start == end){\\n            char ch = s.charAt(end);\\n            String left = result.substring(0, mid);\\n            String right = result.substring(mid);\\n            result = left + ch + right;\\n            outer.add(result);\\n            helper(s, start + 1, s.length() -1, \"\");\\n             return;\\n        }\\n        char ch1 = s.charAt(start);\\n        char ch2 = s.charAt(end);\\n        if(ch1 == ch2){\\n\\n            String left = result.substring(0, mid);\\n            String right = result.substring(mid);\\n            result = left + ch1 + ch2 + right;\\n            helper(s, start + 1, end - 1, result);\\n        }\\n        result = \"\";\\n        helper(s, start, end - 1, result);\\n    }\\n}`"
                    },
                    {
                        "username": "hiranmay1000",
                        "content": "Why this is coming? help!!\n\nYour input\n\"aacabdkacaa\"\nOutput\n\"aacabacaa\"\nExpected\n\"aca\""
                    },
                    {
                        "username": "hiranmay1000",
                        "content": "Why this is happening please help !! \\nI have used map for finding the longest palindromic substring\\n\\nYour input : \"aacabdkacaa\"\\nOutput : \"aacabacaa\"\\nExpected : \"aca\""
                    },
                    {
                        "username": "shubha_neema",
                        "content": "Getting wrong answer, even for correct answer. Can anyone tell me why this is happening?\\nInput\\ns =\"babad\"\\nOutput\\n\"aba\"\\nExpected\\n\"bab\""
                    },
                    {
                        "username": "vismay__yerunkar",
                        "content": "Subscribe Hustlers Algorithm\\uD83D\\uDCA6\\uD83D\\uDCA6\\uD83D\\uDCA6\\uD83D\\uDD25\\uD83D\\uDD25 `https://youtu.be/94RdOzbXvHM`  Lets make a stronger problem solving community. subscribe to the channel for amazing dsa content."
                    },
                    {
                        "username": "prasannaprassu80",
                        "content": "What is wrong in my code? 127/141 test cases are passed. if i check the failed test case, by copy and paste them in the test case, that test case is getting passed,. then why it is showing test cases failed?\n\n\ndef longestPalindrome(self, s: str) -> str:\n        length_list= []\n        max_len=0\n        result=\"\"\n        for i in range(len(s)):\n            for j in range(i+1, len(s)+1):\n                substring= s[i:j]\n                rev_substring= substring[::-1]\n                if (substring== rev_substring):\n                    length_list.append(substring)\n        for each in length_list:\n            if len(each)> max_len:\n                max_len= len(each)\n                result= each\n        return (result)\n[leetcode](https://leetcode.com) "
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@prasannaprassu80](/prasannaprassu80)\nTime Limit Exceeded!!!\n\nIt not a error of your code, it's time complexity."
                    },
                    {
                        "username": "zohairhadi",
                        "content": "I thought that I\\'d come up with a good solution but there\\'s a lot of edge cases that my solution doesn\\'t cater to. \\nAny suggestions on what I\\'m missing?\\n\\n`\\n        def longestPalindrome(self, s):\\n\\n\\n        longest = \"\"\\n        temp_longest = \"\"\\n        for i in range(1, len(s)-2):\\n\\n            if s[i-1] == s[i+1]:\\n                count = 2\\n                while (s[i-count] == s[i+count]):\\n                    count += 1\\n                count -= 1\\n                temp_longest = s[i-count: i+count + 1]\\n\\n            elif s[i] == s[i+1]:\\n                count = 1\\n                while (s[i-count] == s[i+1+count]):\\n                    count += 1\\n                count -= 1\\n                temp_longest = s[i-count: i+1+count + 1]\\n\\n            if len(temp_longest) > len(longest):\\n                longest = temp_longest\\n\\n        return longest            \\n`"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@zohairhadi2000](/zohairhadi2000) This code will get in trouble even for simple testcase:\ns= \"bbbbbbbb\"\nWhy?\n\nBecause you didnt define a boundary condition for string that you check on:\n```\nif s[i-1] == s[i+1]:\n            count = 2\n            while (s[i-count] == s[i+count]):\n                count += 1\n            count -= 1\n            temp_longest = s[i-count: i+count + 1]\n```\nWhat if? s[i-count], i-count<0?, i+count>len(s)-1. It returns a \n_IndexError: string index out of range_ right\n\nSo first, check your condition, then run dry test (change some simple case by yourself). \n\nYou can use a slide windows to check, and only check to len(s)-l-1, l=max last found palindromic substring.\n\n```\nclass Solution:\n    def longestPalindrome(self, s: str) -> str:\n        n, l, i, temp, s1 = [len(s), 1, 0, 0, s[::-1]] \n        if s1==s: return s \n        while i+l <= n-1:\n            for j in range(l,n-i+1):\n                if s1[i:i+j] ==s[n-j-i:n-i]: l=j; temp=i\n                if s1[i:i+j] not in s: break\n            if i<=n-l-1:    i+=1; continue \n            else: break \n        if temp==0 and l==1: return s[0]\n        return s[n-l-temp:n-temp]  \n```"
                    }
                ]
            },
            {
                "id": 1775653,
                "content": [
                    {
                        "username": "kasomaibrahim",
                        "content": "A faster solution with time complexity of O(n) is the Manacher algorithm. It utilizes the idea that if a palindrome has its center at the current position and its right boundary has reached position j, then the palindrome with its center at the current position will have the same length as the palindrome with its center at the symmetrical position of j with respect to the current position, as long as j is within the boundary of the palindrome with center at the current position."
                    },
                    {
                        "username": "Satyarth_Agrahari",
                        "content": "The C++ code provided implements Manacher\\'s algorithm to find the longest palindromic substring in a given input string.\\n\\nThe code starts by defining a function named \"longestPalindrome\" which takes a string as its input and returns a string as its output.\\n\\nThe first step in the function is to preprocess the input string by inserting special characters between each character and also at the beginning and end of the string. This is done by creating a new string \"temp\" and iterating through each character in the input string, adding it to \"temp\" and also adding the special character \"#\" after it. This modified string is then stored in \"s\".\\n\\nNext, the code defines two arrays \"p\" and \"id\" of size n+1, where n is the length of the modified string. The array \"p\" is used to hold the length of the palindrome centered at each character in the modified string and the array \"id\" is used to keep track of the center and right boundary of the current palindrome.\\n\\nThe code then initializes two variables \"mx\" and \"id\" to 0 and assigns the value 0 to all elements of the \"p\" array.\\n\\nThe algorithm then starts iterating through each character in the modified string using a for loop, for each i in s.\\n\\nThe first thing the code does inside the for loop is to check if the current character is within the right boundary of the previous palindrome. If so, it uses the \"mirroring\" technique to calculate the length of the palindrome centered at the current character. It sets the value of \"p[i]\" to the minimum of \"p[(id*2-i)\" and \"mx-i\".\\n\\nOtherwise, the code falls back to the \"expanding around the center\" technique and starts checking the characters on both sides of the current character to find the length of the palindrome centered at the current character.\\n\\nThe code then updates the \"mx\" and \"id\" variables if the current palindrome exceeds the right boundary of the previous palindrome.\\n\\nFinally, the code finds the center and length of the longest palindrome by iterating through the \"p\" array and returning the substring of the original input string using the center and length information.\\n\\nIt\\'s important to note that the above code is just an example and this specific implementation may be different from other ones, but the overall idea and algorithm remains the same."
                    },
                    {
                        "username": "paragtharani24",
                        "content": "can anyone please optimize  below code:\\n\\n/**\\n * @param {string} s\\n * @return {string}\\n */\\nvar longestPalindrome = function(s) {\\n    let longestPalString = \"\"\\n    for(var i=0; i<s.length; i++){\\n        let str = \"\"\\n        for(var j=i; j<s.length; j++){\\n            str = str + s[j]\\n            if(isPalindrome(str)){\\n                if(str.length > longestPalString.length){\\n                    longestPalString = str\\n                }\\n            }\\n        }\\n    }\\n\\n    return longestPalString;\\n};\\n\\nfunction isPalindrome(str){\\n    let left = 0\\n    let right = str.length - 1\\n\\n    while (left < right) {\\n        if (str[left++] !== str[right--]) {\\n            return false\\n        }\\n    }\\n\\n    return true\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Hi, I am getting memory limit exceeds in my code. Can you please help to fix. I know my code taking too much memory, but how I fix this.\\nCan we able to modify it so it doesn\\'t give memory limit exceeds or we are not able to modify it.\\nThanks for any suggestion.\\n\\n  class Solution {\\n    `List<String> outer = new ArrayList<>();\\n    public String longestPalindrome(String s) {\\n        String result = \"\";\\n        helper(s , 0, s.length()- 1, \"\");\\n        for (String man:outer) {\\n            int l = man.length();\\n            if (result.length()<l){\\n                result = man;\\n            }\\n        }\\n        return result;\\n    }\\n    public void helper(String s, int start, int end, String result){\\n        int mid = result.length()/2;\\n        if(start> end){\\n            outer.add(result);\\n            return;\\n        }\\n        if(start == end){\\n            char ch = s.charAt(end);\\n            String left = result.substring(0, mid);\\n            String right = result.substring(mid);\\n            result = left + ch + right;\\n            outer.add(result);\\n            helper(s, start + 1, s.length() -1, \"\");\\n             return;\\n        }\\n        char ch1 = s.charAt(start);\\n        char ch2 = s.charAt(end);\\n        if(ch1 == ch2){\\n\\n            String left = result.substring(0, mid);\\n            String right = result.substring(mid);\\n            result = left + ch1 + ch2 + right;\\n            helper(s, start + 1, end - 1, result);\\n        }\\n        result = \"\";\\n        helper(s, start, end - 1, result);\\n    }\\n}`"
                    },
                    {
                        "username": "hiranmay1000",
                        "content": "Why this is coming? help!!\n\nYour input\n\"aacabdkacaa\"\nOutput\n\"aacabacaa\"\nExpected\n\"aca\""
                    },
                    {
                        "username": "hiranmay1000",
                        "content": "Why this is happening please help !! \\nI have used map for finding the longest palindromic substring\\n\\nYour input : \"aacabdkacaa\"\\nOutput : \"aacabacaa\"\\nExpected : \"aca\""
                    },
                    {
                        "username": "shubha_neema",
                        "content": "Getting wrong answer, even for correct answer. Can anyone tell me why this is happening?\\nInput\\ns =\"babad\"\\nOutput\\n\"aba\"\\nExpected\\n\"bab\""
                    },
                    {
                        "username": "vismay__yerunkar",
                        "content": "Subscribe Hustlers Algorithm\\uD83D\\uDCA6\\uD83D\\uDCA6\\uD83D\\uDCA6\\uD83D\\uDD25\\uD83D\\uDD25 `https://youtu.be/94RdOzbXvHM`  Lets make a stronger problem solving community. subscribe to the channel for amazing dsa content."
                    },
                    {
                        "username": "prasannaprassu80",
                        "content": "What is wrong in my code? 127/141 test cases are passed. if i check the failed test case, by copy and paste them in the test case, that test case is getting passed,. then why it is showing test cases failed?\n\n\ndef longestPalindrome(self, s: str) -> str:\n        length_list= []\n        max_len=0\n        result=\"\"\n        for i in range(len(s)):\n            for j in range(i+1, len(s)+1):\n                substring= s[i:j]\n                rev_substring= substring[::-1]\n                if (substring== rev_substring):\n                    length_list.append(substring)\n        for each in length_list:\n            if len(each)> max_len:\n                max_len= len(each)\n                result= each\n        return (result)\n[leetcode](https://leetcode.com) "
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@prasannaprassu80](/prasannaprassu80)\nTime Limit Exceeded!!!\n\nIt not a error of your code, it's time complexity."
                    },
                    {
                        "username": "zohairhadi",
                        "content": "I thought that I\\'d come up with a good solution but there\\'s a lot of edge cases that my solution doesn\\'t cater to. \\nAny suggestions on what I\\'m missing?\\n\\n`\\n        def longestPalindrome(self, s):\\n\\n\\n        longest = \"\"\\n        temp_longest = \"\"\\n        for i in range(1, len(s)-2):\\n\\n            if s[i-1] == s[i+1]:\\n                count = 2\\n                while (s[i-count] == s[i+count]):\\n                    count += 1\\n                count -= 1\\n                temp_longest = s[i-count: i+count + 1]\\n\\n            elif s[i] == s[i+1]:\\n                count = 1\\n                while (s[i-count] == s[i+1+count]):\\n                    count += 1\\n                count -= 1\\n                temp_longest = s[i-count: i+1+count + 1]\\n\\n            if len(temp_longest) > len(longest):\\n                longest = temp_longest\\n\\n        return longest            \\n`"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@zohairhadi2000](/zohairhadi2000) This code will get in trouble even for simple testcase:\ns= \"bbbbbbbb\"\nWhy?\n\nBecause you didnt define a boundary condition for string that you check on:\n```\nif s[i-1] == s[i+1]:\n            count = 2\n            while (s[i-count] == s[i+count]):\n                count += 1\n            count -= 1\n            temp_longest = s[i-count: i+count + 1]\n```\nWhat if? s[i-count], i-count<0?, i+count>len(s)-1. It returns a \n_IndexError: string index out of range_ right\n\nSo first, check your condition, then run dry test (change some simple case by yourself). \n\nYou can use a slide windows to check, and only check to len(s)-l-1, l=max last found palindromic substring.\n\n```\nclass Solution:\n    def longestPalindrome(self, s: str) -> str:\n        n, l, i, temp, s1 = [len(s), 1, 0, 0, s[::-1]] \n        if s1==s: return s \n        while i+l <= n-1:\n            for j in range(l,n-i+1):\n                if s1[i:i+j] ==s[n-j-i:n-i]: l=j; temp=i\n                if s1[i:i+j] not in s: break\n            if i<=n-l-1:    i+=1; continue \n            else: break \n        if temp==0 and l==1: return s[0]\n        return s[n-l-temp:n-temp]  \n```"
                    }
                ]
            },
            {
                "id": 1771056,
                "content": [
                    {
                        "username": "kasomaibrahim",
                        "content": "A faster solution with time complexity of O(n) is the Manacher algorithm. It utilizes the idea that if a palindrome has its center at the current position and its right boundary has reached position j, then the palindrome with its center at the current position will have the same length as the palindrome with its center at the symmetrical position of j with respect to the current position, as long as j is within the boundary of the palindrome with center at the current position."
                    },
                    {
                        "username": "Satyarth_Agrahari",
                        "content": "The C++ code provided implements Manacher\\'s algorithm to find the longest palindromic substring in a given input string.\\n\\nThe code starts by defining a function named \"longestPalindrome\" which takes a string as its input and returns a string as its output.\\n\\nThe first step in the function is to preprocess the input string by inserting special characters between each character and also at the beginning and end of the string. This is done by creating a new string \"temp\" and iterating through each character in the input string, adding it to \"temp\" and also adding the special character \"#\" after it. This modified string is then stored in \"s\".\\n\\nNext, the code defines two arrays \"p\" and \"id\" of size n+1, where n is the length of the modified string. The array \"p\" is used to hold the length of the palindrome centered at each character in the modified string and the array \"id\" is used to keep track of the center and right boundary of the current palindrome.\\n\\nThe code then initializes two variables \"mx\" and \"id\" to 0 and assigns the value 0 to all elements of the \"p\" array.\\n\\nThe algorithm then starts iterating through each character in the modified string using a for loop, for each i in s.\\n\\nThe first thing the code does inside the for loop is to check if the current character is within the right boundary of the previous palindrome. If so, it uses the \"mirroring\" technique to calculate the length of the palindrome centered at the current character. It sets the value of \"p[i]\" to the minimum of \"p[(id*2-i)\" and \"mx-i\".\\n\\nOtherwise, the code falls back to the \"expanding around the center\" technique and starts checking the characters on both sides of the current character to find the length of the palindrome centered at the current character.\\n\\nThe code then updates the \"mx\" and \"id\" variables if the current palindrome exceeds the right boundary of the previous palindrome.\\n\\nFinally, the code finds the center and length of the longest palindrome by iterating through the \"p\" array and returning the substring of the original input string using the center and length information.\\n\\nIt\\'s important to note that the above code is just an example and this specific implementation may be different from other ones, but the overall idea and algorithm remains the same."
                    },
                    {
                        "username": "paragtharani24",
                        "content": "can anyone please optimize  below code:\\n\\n/**\\n * @param {string} s\\n * @return {string}\\n */\\nvar longestPalindrome = function(s) {\\n    let longestPalString = \"\"\\n    for(var i=0; i<s.length; i++){\\n        let str = \"\"\\n        for(var j=i; j<s.length; j++){\\n            str = str + s[j]\\n            if(isPalindrome(str)){\\n                if(str.length > longestPalString.length){\\n                    longestPalString = str\\n                }\\n            }\\n        }\\n    }\\n\\n    return longestPalString;\\n};\\n\\nfunction isPalindrome(str){\\n    let left = 0\\n    let right = str.length - 1\\n\\n    while (left < right) {\\n        if (str[left++] !== str[right--]) {\\n            return false\\n        }\\n    }\\n\\n    return true\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Hi, I am getting memory limit exceeds in my code. Can you please help to fix. I know my code taking too much memory, but how I fix this.\\nCan we able to modify it so it doesn\\'t give memory limit exceeds or we are not able to modify it.\\nThanks for any suggestion.\\n\\n  class Solution {\\n    `List<String> outer = new ArrayList<>();\\n    public String longestPalindrome(String s) {\\n        String result = \"\";\\n        helper(s , 0, s.length()- 1, \"\");\\n        for (String man:outer) {\\n            int l = man.length();\\n            if (result.length()<l){\\n                result = man;\\n            }\\n        }\\n        return result;\\n    }\\n    public void helper(String s, int start, int end, String result){\\n        int mid = result.length()/2;\\n        if(start> end){\\n            outer.add(result);\\n            return;\\n        }\\n        if(start == end){\\n            char ch = s.charAt(end);\\n            String left = result.substring(0, mid);\\n            String right = result.substring(mid);\\n            result = left + ch + right;\\n            outer.add(result);\\n            helper(s, start + 1, s.length() -1, \"\");\\n             return;\\n        }\\n        char ch1 = s.charAt(start);\\n        char ch2 = s.charAt(end);\\n        if(ch1 == ch2){\\n\\n            String left = result.substring(0, mid);\\n            String right = result.substring(mid);\\n            result = left + ch1 + ch2 + right;\\n            helper(s, start + 1, end - 1, result);\\n        }\\n        result = \"\";\\n        helper(s, start, end - 1, result);\\n    }\\n}`"
                    },
                    {
                        "username": "hiranmay1000",
                        "content": "Why this is coming? help!!\n\nYour input\n\"aacabdkacaa\"\nOutput\n\"aacabacaa\"\nExpected\n\"aca\""
                    },
                    {
                        "username": "hiranmay1000",
                        "content": "Why this is happening please help !! \\nI have used map for finding the longest palindromic substring\\n\\nYour input : \"aacabdkacaa\"\\nOutput : \"aacabacaa\"\\nExpected : \"aca\""
                    },
                    {
                        "username": "shubha_neema",
                        "content": "Getting wrong answer, even for correct answer. Can anyone tell me why this is happening?\\nInput\\ns =\"babad\"\\nOutput\\n\"aba\"\\nExpected\\n\"bab\""
                    },
                    {
                        "username": "vismay__yerunkar",
                        "content": "Subscribe Hustlers Algorithm\\uD83D\\uDCA6\\uD83D\\uDCA6\\uD83D\\uDCA6\\uD83D\\uDD25\\uD83D\\uDD25 `https://youtu.be/94RdOzbXvHM`  Lets make a stronger problem solving community. subscribe to the channel for amazing dsa content."
                    },
                    {
                        "username": "prasannaprassu80",
                        "content": "What is wrong in my code? 127/141 test cases are passed. if i check the failed test case, by copy and paste them in the test case, that test case is getting passed,. then why it is showing test cases failed?\n\n\ndef longestPalindrome(self, s: str) -> str:\n        length_list= []\n        max_len=0\n        result=\"\"\n        for i in range(len(s)):\n            for j in range(i+1, len(s)+1):\n                substring= s[i:j]\n                rev_substring= substring[::-1]\n                if (substring== rev_substring):\n                    length_list.append(substring)\n        for each in length_list:\n            if len(each)> max_len:\n                max_len= len(each)\n                result= each\n        return (result)\n[leetcode](https://leetcode.com) "
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@prasannaprassu80](/prasannaprassu80)\nTime Limit Exceeded!!!\n\nIt not a error of your code, it's time complexity."
                    },
                    {
                        "username": "zohairhadi",
                        "content": "I thought that I\\'d come up with a good solution but there\\'s a lot of edge cases that my solution doesn\\'t cater to. \\nAny suggestions on what I\\'m missing?\\n\\n`\\n        def longestPalindrome(self, s):\\n\\n\\n        longest = \"\"\\n        temp_longest = \"\"\\n        for i in range(1, len(s)-2):\\n\\n            if s[i-1] == s[i+1]:\\n                count = 2\\n                while (s[i-count] == s[i+count]):\\n                    count += 1\\n                count -= 1\\n                temp_longest = s[i-count: i+count + 1]\\n\\n            elif s[i] == s[i+1]:\\n                count = 1\\n                while (s[i-count] == s[i+1+count]):\\n                    count += 1\\n                count -= 1\\n                temp_longest = s[i-count: i+1+count + 1]\\n\\n            if len(temp_longest) > len(longest):\\n                longest = temp_longest\\n\\n        return longest            \\n`"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@zohairhadi2000](/zohairhadi2000) This code will get in trouble even for simple testcase:\ns= \"bbbbbbbb\"\nWhy?\n\nBecause you didnt define a boundary condition for string that you check on:\n```\nif s[i-1] == s[i+1]:\n            count = 2\n            while (s[i-count] == s[i+count]):\n                count += 1\n            count -= 1\n            temp_longest = s[i-count: i+count + 1]\n```\nWhat if? s[i-count], i-count<0?, i+count>len(s)-1. It returns a \n_IndexError: string index out of range_ right\n\nSo first, check your condition, then run dry test (change some simple case by yourself). \n\nYou can use a slide windows to check, and only check to len(s)-l-1, l=max last found palindromic substring.\n\n```\nclass Solution:\n    def longestPalindrome(self, s: str) -> str:\n        n, l, i, temp, s1 = [len(s), 1, 0, 0, s[::-1]] \n        if s1==s: return s \n        while i+l <= n-1:\n            for j in range(l,n-i+1):\n                if s1[i:i+j] ==s[n-j-i:n-i]: l=j; temp=i\n                if s1[i:i+j] not in s: break\n            if i<=n-l-1:    i+=1; continue \n            else: break \n        if temp==0 and l==1: return s[0]\n        return s[n-l-temp:n-temp]  \n```"
                    }
                ]
            },
            {
                "id": 1766681,
                "content": [
                    {
                        "username": "kasomaibrahim",
                        "content": "A faster solution with time complexity of O(n) is the Manacher algorithm. It utilizes the idea that if a palindrome has its center at the current position and its right boundary has reached position j, then the palindrome with its center at the current position will have the same length as the palindrome with its center at the symmetrical position of j with respect to the current position, as long as j is within the boundary of the palindrome with center at the current position."
                    },
                    {
                        "username": "Satyarth_Agrahari",
                        "content": "The C++ code provided implements Manacher\\'s algorithm to find the longest palindromic substring in a given input string.\\n\\nThe code starts by defining a function named \"longestPalindrome\" which takes a string as its input and returns a string as its output.\\n\\nThe first step in the function is to preprocess the input string by inserting special characters between each character and also at the beginning and end of the string. This is done by creating a new string \"temp\" and iterating through each character in the input string, adding it to \"temp\" and also adding the special character \"#\" after it. This modified string is then stored in \"s\".\\n\\nNext, the code defines two arrays \"p\" and \"id\" of size n+1, where n is the length of the modified string. The array \"p\" is used to hold the length of the palindrome centered at each character in the modified string and the array \"id\" is used to keep track of the center and right boundary of the current palindrome.\\n\\nThe code then initializes two variables \"mx\" and \"id\" to 0 and assigns the value 0 to all elements of the \"p\" array.\\n\\nThe algorithm then starts iterating through each character in the modified string using a for loop, for each i in s.\\n\\nThe first thing the code does inside the for loop is to check if the current character is within the right boundary of the previous palindrome. If so, it uses the \"mirroring\" technique to calculate the length of the palindrome centered at the current character. It sets the value of \"p[i]\" to the minimum of \"p[(id*2-i)\" and \"mx-i\".\\n\\nOtherwise, the code falls back to the \"expanding around the center\" technique and starts checking the characters on both sides of the current character to find the length of the palindrome centered at the current character.\\n\\nThe code then updates the \"mx\" and \"id\" variables if the current palindrome exceeds the right boundary of the previous palindrome.\\n\\nFinally, the code finds the center and length of the longest palindrome by iterating through the \"p\" array and returning the substring of the original input string using the center and length information.\\n\\nIt\\'s important to note that the above code is just an example and this specific implementation may be different from other ones, but the overall idea and algorithm remains the same."
                    },
                    {
                        "username": "paragtharani24",
                        "content": "can anyone please optimize  below code:\\n\\n/**\\n * @param {string} s\\n * @return {string}\\n */\\nvar longestPalindrome = function(s) {\\n    let longestPalString = \"\"\\n    for(var i=0; i<s.length; i++){\\n        let str = \"\"\\n        for(var j=i; j<s.length; j++){\\n            str = str + s[j]\\n            if(isPalindrome(str)){\\n                if(str.length > longestPalString.length){\\n                    longestPalString = str\\n                }\\n            }\\n        }\\n    }\\n\\n    return longestPalString;\\n};\\n\\nfunction isPalindrome(str){\\n    let left = 0\\n    let right = str.length - 1\\n\\n    while (left < right) {\\n        if (str[left++] !== str[right--]) {\\n            return false\\n        }\\n    }\\n\\n    return true\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Hi, I am getting memory limit exceeds in my code. Can you please help to fix. I know my code taking too much memory, but how I fix this.\\nCan we able to modify it so it doesn\\'t give memory limit exceeds or we are not able to modify it.\\nThanks for any suggestion.\\n\\n  class Solution {\\n    `List<String> outer = new ArrayList<>();\\n    public String longestPalindrome(String s) {\\n        String result = \"\";\\n        helper(s , 0, s.length()- 1, \"\");\\n        for (String man:outer) {\\n            int l = man.length();\\n            if (result.length()<l){\\n                result = man;\\n            }\\n        }\\n        return result;\\n    }\\n    public void helper(String s, int start, int end, String result){\\n        int mid = result.length()/2;\\n        if(start> end){\\n            outer.add(result);\\n            return;\\n        }\\n        if(start == end){\\n            char ch = s.charAt(end);\\n            String left = result.substring(0, mid);\\n            String right = result.substring(mid);\\n            result = left + ch + right;\\n            outer.add(result);\\n            helper(s, start + 1, s.length() -1, \"\");\\n             return;\\n        }\\n        char ch1 = s.charAt(start);\\n        char ch2 = s.charAt(end);\\n        if(ch1 == ch2){\\n\\n            String left = result.substring(0, mid);\\n            String right = result.substring(mid);\\n            result = left + ch1 + ch2 + right;\\n            helper(s, start + 1, end - 1, result);\\n        }\\n        result = \"\";\\n        helper(s, start, end - 1, result);\\n    }\\n}`"
                    },
                    {
                        "username": "hiranmay1000",
                        "content": "Why this is coming? help!!\n\nYour input\n\"aacabdkacaa\"\nOutput\n\"aacabacaa\"\nExpected\n\"aca\""
                    },
                    {
                        "username": "hiranmay1000",
                        "content": "Why this is happening please help !! \\nI have used map for finding the longest palindromic substring\\n\\nYour input : \"aacabdkacaa\"\\nOutput : \"aacabacaa\"\\nExpected : \"aca\""
                    },
                    {
                        "username": "shubha_neema",
                        "content": "Getting wrong answer, even for correct answer. Can anyone tell me why this is happening?\\nInput\\ns =\"babad\"\\nOutput\\n\"aba\"\\nExpected\\n\"bab\""
                    },
                    {
                        "username": "vismay__yerunkar",
                        "content": "Subscribe Hustlers Algorithm\\uD83D\\uDCA6\\uD83D\\uDCA6\\uD83D\\uDCA6\\uD83D\\uDD25\\uD83D\\uDD25 `https://youtu.be/94RdOzbXvHM`  Lets make a stronger problem solving community. subscribe to the channel for amazing dsa content."
                    },
                    {
                        "username": "prasannaprassu80",
                        "content": "What is wrong in my code? 127/141 test cases are passed. if i check the failed test case, by copy and paste them in the test case, that test case is getting passed,. then why it is showing test cases failed?\n\n\ndef longestPalindrome(self, s: str) -> str:\n        length_list= []\n        max_len=0\n        result=\"\"\n        for i in range(len(s)):\n            for j in range(i+1, len(s)+1):\n                substring= s[i:j]\n                rev_substring= substring[::-1]\n                if (substring== rev_substring):\n                    length_list.append(substring)\n        for each in length_list:\n            if len(each)> max_len:\n                max_len= len(each)\n                result= each\n        return (result)\n[leetcode](https://leetcode.com) "
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@prasannaprassu80](/prasannaprassu80)\nTime Limit Exceeded!!!\n\nIt not a error of your code, it's time complexity."
                    },
                    {
                        "username": "zohairhadi",
                        "content": "I thought that I\\'d come up with a good solution but there\\'s a lot of edge cases that my solution doesn\\'t cater to. \\nAny suggestions on what I\\'m missing?\\n\\n`\\n        def longestPalindrome(self, s):\\n\\n\\n        longest = \"\"\\n        temp_longest = \"\"\\n        for i in range(1, len(s)-2):\\n\\n            if s[i-1] == s[i+1]:\\n                count = 2\\n                while (s[i-count] == s[i+count]):\\n                    count += 1\\n                count -= 1\\n                temp_longest = s[i-count: i+count + 1]\\n\\n            elif s[i] == s[i+1]:\\n                count = 1\\n                while (s[i-count] == s[i+1+count]):\\n                    count += 1\\n                count -= 1\\n                temp_longest = s[i-count: i+1+count + 1]\\n\\n            if len(temp_longest) > len(longest):\\n                longest = temp_longest\\n\\n        return longest            \\n`"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@zohairhadi2000](/zohairhadi2000) This code will get in trouble even for simple testcase:\ns= \"bbbbbbbb\"\nWhy?\n\nBecause you didnt define a boundary condition for string that you check on:\n```\nif s[i-1] == s[i+1]:\n            count = 2\n            while (s[i-count] == s[i+count]):\n                count += 1\n            count -= 1\n            temp_longest = s[i-count: i+count + 1]\n```\nWhat if? s[i-count], i-count<0?, i+count>len(s)-1. It returns a \n_IndexError: string index out of range_ right\n\nSo first, check your condition, then run dry test (change some simple case by yourself). \n\nYou can use a slide windows to check, and only check to len(s)-l-1, l=max last found palindromic substring.\n\n```\nclass Solution:\n    def longestPalindrome(self, s: str) -> str:\n        n, l, i, temp, s1 = [len(s), 1, 0, 0, s[::-1]] \n        if s1==s: return s \n        while i+l <= n-1:\n            for j in range(l,n-i+1):\n                if s1[i:i+j] ==s[n-j-i:n-i]: l=j; temp=i\n                if s1[i:i+j] not in s: break\n            if i<=n-l-1:    i+=1; continue \n            else: break \n        if temp==0 and l==1: return s[0]\n        return s[n-l-temp:n-temp]  \n```"
                    }
                ]
            },
            {
                "id": 1765850,
                "content": [
                    {
                        "username": "kasomaibrahim",
                        "content": "A faster solution with time complexity of O(n) is the Manacher algorithm. It utilizes the idea that if a palindrome has its center at the current position and its right boundary has reached position j, then the palindrome with its center at the current position will have the same length as the palindrome with its center at the symmetrical position of j with respect to the current position, as long as j is within the boundary of the palindrome with center at the current position."
                    },
                    {
                        "username": "Satyarth_Agrahari",
                        "content": "The C++ code provided implements Manacher\\'s algorithm to find the longest palindromic substring in a given input string.\\n\\nThe code starts by defining a function named \"longestPalindrome\" which takes a string as its input and returns a string as its output.\\n\\nThe first step in the function is to preprocess the input string by inserting special characters between each character and also at the beginning and end of the string. This is done by creating a new string \"temp\" and iterating through each character in the input string, adding it to \"temp\" and also adding the special character \"#\" after it. This modified string is then stored in \"s\".\\n\\nNext, the code defines two arrays \"p\" and \"id\" of size n+1, where n is the length of the modified string. The array \"p\" is used to hold the length of the palindrome centered at each character in the modified string and the array \"id\" is used to keep track of the center and right boundary of the current palindrome.\\n\\nThe code then initializes two variables \"mx\" and \"id\" to 0 and assigns the value 0 to all elements of the \"p\" array.\\n\\nThe algorithm then starts iterating through each character in the modified string using a for loop, for each i in s.\\n\\nThe first thing the code does inside the for loop is to check if the current character is within the right boundary of the previous palindrome. If so, it uses the \"mirroring\" technique to calculate the length of the palindrome centered at the current character. It sets the value of \"p[i]\" to the minimum of \"p[(id*2-i)\" and \"mx-i\".\\n\\nOtherwise, the code falls back to the \"expanding around the center\" technique and starts checking the characters on both sides of the current character to find the length of the palindrome centered at the current character.\\n\\nThe code then updates the \"mx\" and \"id\" variables if the current palindrome exceeds the right boundary of the previous palindrome.\\n\\nFinally, the code finds the center and length of the longest palindrome by iterating through the \"p\" array and returning the substring of the original input string using the center and length information.\\n\\nIt\\'s important to note that the above code is just an example and this specific implementation may be different from other ones, but the overall idea and algorithm remains the same."
                    },
                    {
                        "username": "paragtharani24",
                        "content": "can anyone please optimize  below code:\\n\\n/**\\n * @param {string} s\\n * @return {string}\\n */\\nvar longestPalindrome = function(s) {\\n    let longestPalString = \"\"\\n    for(var i=0; i<s.length; i++){\\n        let str = \"\"\\n        for(var j=i; j<s.length; j++){\\n            str = str + s[j]\\n            if(isPalindrome(str)){\\n                if(str.length > longestPalString.length){\\n                    longestPalString = str\\n                }\\n            }\\n        }\\n    }\\n\\n    return longestPalString;\\n};\\n\\nfunction isPalindrome(str){\\n    let left = 0\\n    let right = str.length - 1\\n\\n    while (left < right) {\\n        if (str[left++] !== str[right--]) {\\n            return false\\n        }\\n    }\\n\\n    return true\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Hi, I am getting memory limit exceeds in my code. Can you please help to fix. I know my code taking too much memory, but how I fix this.\\nCan we able to modify it so it doesn\\'t give memory limit exceeds or we are not able to modify it.\\nThanks for any suggestion.\\n\\n  class Solution {\\n    `List<String> outer = new ArrayList<>();\\n    public String longestPalindrome(String s) {\\n        String result = \"\";\\n        helper(s , 0, s.length()- 1, \"\");\\n        for (String man:outer) {\\n            int l = man.length();\\n            if (result.length()<l){\\n                result = man;\\n            }\\n        }\\n        return result;\\n    }\\n    public void helper(String s, int start, int end, String result){\\n        int mid = result.length()/2;\\n        if(start> end){\\n            outer.add(result);\\n            return;\\n        }\\n        if(start == end){\\n            char ch = s.charAt(end);\\n            String left = result.substring(0, mid);\\n            String right = result.substring(mid);\\n            result = left + ch + right;\\n            outer.add(result);\\n            helper(s, start + 1, s.length() -1, \"\");\\n             return;\\n        }\\n        char ch1 = s.charAt(start);\\n        char ch2 = s.charAt(end);\\n        if(ch1 == ch2){\\n\\n            String left = result.substring(0, mid);\\n            String right = result.substring(mid);\\n            result = left + ch1 + ch2 + right;\\n            helper(s, start + 1, end - 1, result);\\n        }\\n        result = \"\";\\n        helper(s, start, end - 1, result);\\n    }\\n}`"
                    },
                    {
                        "username": "hiranmay1000",
                        "content": "Why this is coming? help!!\n\nYour input\n\"aacabdkacaa\"\nOutput\n\"aacabacaa\"\nExpected\n\"aca\""
                    },
                    {
                        "username": "hiranmay1000",
                        "content": "Why this is happening please help !! \\nI have used map for finding the longest palindromic substring\\n\\nYour input : \"aacabdkacaa\"\\nOutput : \"aacabacaa\"\\nExpected : \"aca\""
                    },
                    {
                        "username": "shubha_neema",
                        "content": "Getting wrong answer, even for correct answer. Can anyone tell me why this is happening?\\nInput\\ns =\"babad\"\\nOutput\\n\"aba\"\\nExpected\\n\"bab\""
                    },
                    {
                        "username": "vismay__yerunkar",
                        "content": "Subscribe Hustlers Algorithm\\uD83D\\uDCA6\\uD83D\\uDCA6\\uD83D\\uDCA6\\uD83D\\uDD25\\uD83D\\uDD25 `https://youtu.be/94RdOzbXvHM`  Lets make a stronger problem solving community. subscribe to the channel for amazing dsa content."
                    },
                    {
                        "username": "prasannaprassu80",
                        "content": "What is wrong in my code? 127/141 test cases are passed. if i check the failed test case, by copy and paste them in the test case, that test case is getting passed,. then why it is showing test cases failed?\n\n\ndef longestPalindrome(self, s: str) -> str:\n        length_list= []\n        max_len=0\n        result=\"\"\n        for i in range(len(s)):\n            for j in range(i+1, len(s)+1):\n                substring= s[i:j]\n                rev_substring= substring[::-1]\n                if (substring== rev_substring):\n                    length_list.append(substring)\n        for each in length_list:\n            if len(each)> max_len:\n                max_len= len(each)\n                result= each\n        return (result)\n[leetcode](https://leetcode.com) "
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@prasannaprassu80](/prasannaprassu80)\nTime Limit Exceeded!!!\n\nIt not a error of your code, it's time complexity."
                    },
                    {
                        "username": "zohairhadi",
                        "content": "I thought that I\\'d come up with a good solution but there\\'s a lot of edge cases that my solution doesn\\'t cater to. \\nAny suggestions on what I\\'m missing?\\n\\n`\\n        def longestPalindrome(self, s):\\n\\n\\n        longest = \"\"\\n        temp_longest = \"\"\\n        for i in range(1, len(s)-2):\\n\\n            if s[i-1] == s[i+1]:\\n                count = 2\\n                while (s[i-count] == s[i+count]):\\n                    count += 1\\n                count -= 1\\n                temp_longest = s[i-count: i+count + 1]\\n\\n            elif s[i] == s[i+1]:\\n                count = 1\\n                while (s[i-count] == s[i+1+count]):\\n                    count += 1\\n                count -= 1\\n                temp_longest = s[i-count: i+1+count + 1]\\n\\n            if len(temp_longest) > len(longest):\\n                longest = temp_longest\\n\\n        return longest            \\n`"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@zohairhadi2000](/zohairhadi2000) This code will get in trouble even for simple testcase:\ns= \"bbbbbbbb\"\nWhy?\n\nBecause you didnt define a boundary condition for string that you check on:\n```\nif s[i-1] == s[i+1]:\n            count = 2\n            while (s[i-count] == s[i+count]):\n                count += 1\n            count -= 1\n            temp_longest = s[i-count: i+count + 1]\n```\nWhat if? s[i-count], i-count<0?, i+count>len(s)-1. It returns a \n_IndexError: string index out of range_ right\n\nSo first, check your condition, then run dry test (change some simple case by yourself). \n\nYou can use a slide windows to check, and only check to len(s)-l-1, l=max last found palindromic substring.\n\n```\nclass Solution:\n    def longestPalindrome(self, s: str) -> str:\n        n, l, i, temp, s1 = [len(s), 1, 0, 0, s[::-1]] \n        if s1==s: return s \n        while i+l <= n-1:\n            for j in range(l,n-i+1):\n                if s1[i:i+j] ==s[n-j-i:n-i]: l=j; temp=i\n                if s1[i:i+j] not in s: break\n            if i<=n-l-1:    i+=1; continue \n            else: break \n        if temp==0 and l==1: return s[0]\n        return s[n-l-temp:n-temp]  \n```"
                    }
                ]
            },
            {
                "id": 1763937,
                "content": [
                    {
                        "username": "kasomaibrahim",
                        "content": "A faster solution with time complexity of O(n) is the Manacher algorithm. It utilizes the idea that if a palindrome has its center at the current position and its right boundary has reached position j, then the palindrome with its center at the current position will have the same length as the palindrome with its center at the symmetrical position of j with respect to the current position, as long as j is within the boundary of the palindrome with center at the current position."
                    },
                    {
                        "username": "Satyarth_Agrahari",
                        "content": "The C++ code provided implements Manacher\\'s algorithm to find the longest palindromic substring in a given input string.\\n\\nThe code starts by defining a function named \"longestPalindrome\" which takes a string as its input and returns a string as its output.\\n\\nThe first step in the function is to preprocess the input string by inserting special characters between each character and also at the beginning and end of the string. This is done by creating a new string \"temp\" and iterating through each character in the input string, adding it to \"temp\" and also adding the special character \"#\" after it. This modified string is then stored in \"s\".\\n\\nNext, the code defines two arrays \"p\" and \"id\" of size n+1, where n is the length of the modified string. The array \"p\" is used to hold the length of the palindrome centered at each character in the modified string and the array \"id\" is used to keep track of the center and right boundary of the current palindrome.\\n\\nThe code then initializes two variables \"mx\" and \"id\" to 0 and assigns the value 0 to all elements of the \"p\" array.\\n\\nThe algorithm then starts iterating through each character in the modified string using a for loop, for each i in s.\\n\\nThe first thing the code does inside the for loop is to check if the current character is within the right boundary of the previous palindrome. If so, it uses the \"mirroring\" technique to calculate the length of the palindrome centered at the current character. It sets the value of \"p[i]\" to the minimum of \"p[(id*2-i)\" and \"mx-i\".\\n\\nOtherwise, the code falls back to the \"expanding around the center\" technique and starts checking the characters on both sides of the current character to find the length of the palindrome centered at the current character.\\n\\nThe code then updates the \"mx\" and \"id\" variables if the current palindrome exceeds the right boundary of the previous palindrome.\\n\\nFinally, the code finds the center and length of the longest palindrome by iterating through the \"p\" array and returning the substring of the original input string using the center and length information.\\n\\nIt\\'s important to note that the above code is just an example and this specific implementation may be different from other ones, but the overall idea and algorithm remains the same."
                    },
                    {
                        "username": "paragtharani24",
                        "content": "can anyone please optimize  below code:\\n\\n/**\\n * @param {string} s\\n * @return {string}\\n */\\nvar longestPalindrome = function(s) {\\n    let longestPalString = \"\"\\n    for(var i=0; i<s.length; i++){\\n        let str = \"\"\\n        for(var j=i; j<s.length; j++){\\n            str = str + s[j]\\n            if(isPalindrome(str)){\\n                if(str.length > longestPalString.length){\\n                    longestPalString = str\\n                }\\n            }\\n        }\\n    }\\n\\n    return longestPalString;\\n};\\n\\nfunction isPalindrome(str){\\n    let left = 0\\n    let right = str.length - 1\\n\\n    while (left < right) {\\n        if (str[left++] !== str[right--]) {\\n            return false\\n        }\\n    }\\n\\n    return true\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "Hi, I am getting memory limit exceeds in my code. Can you please help to fix. I know my code taking too much memory, but how I fix this.\\nCan we able to modify it so it doesn\\'t give memory limit exceeds or we are not able to modify it.\\nThanks for any suggestion.\\n\\n  class Solution {\\n    `List<String> outer = new ArrayList<>();\\n    public String longestPalindrome(String s) {\\n        String result = \"\";\\n        helper(s , 0, s.length()- 1, \"\");\\n        for (String man:outer) {\\n            int l = man.length();\\n            if (result.length()<l){\\n                result = man;\\n            }\\n        }\\n        return result;\\n    }\\n    public void helper(String s, int start, int end, String result){\\n        int mid = result.length()/2;\\n        if(start> end){\\n            outer.add(result);\\n            return;\\n        }\\n        if(start == end){\\n            char ch = s.charAt(end);\\n            String left = result.substring(0, mid);\\n            String right = result.substring(mid);\\n            result = left + ch + right;\\n            outer.add(result);\\n            helper(s, start + 1, s.length() -1, \"\");\\n             return;\\n        }\\n        char ch1 = s.charAt(start);\\n        char ch2 = s.charAt(end);\\n        if(ch1 == ch2){\\n\\n            String left = result.substring(0, mid);\\n            String right = result.substring(mid);\\n            result = left + ch1 + ch2 + right;\\n            helper(s, start + 1, end - 1, result);\\n        }\\n        result = \"\";\\n        helper(s, start, end - 1, result);\\n    }\\n}`"
                    },
                    {
                        "username": "hiranmay1000",
                        "content": "Why this is coming? help!!\n\nYour input\n\"aacabdkacaa\"\nOutput\n\"aacabacaa\"\nExpected\n\"aca\""
                    },
                    {
                        "username": "hiranmay1000",
                        "content": "Why this is happening please help !! \\nI have used map for finding the longest palindromic substring\\n\\nYour input : \"aacabdkacaa\"\\nOutput : \"aacabacaa\"\\nExpected : \"aca\""
                    },
                    {
                        "username": "shubha_neema",
                        "content": "Getting wrong answer, even for correct answer. Can anyone tell me why this is happening?\\nInput\\ns =\"babad\"\\nOutput\\n\"aba\"\\nExpected\\n\"bab\""
                    },
                    {
                        "username": "vismay__yerunkar",
                        "content": "Subscribe Hustlers Algorithm\\uD83D\\uDCA6\\uD83D\\uDCA6\\uD83D\\uDCA6\\uD83D\\uDD25\\uD83D\\uDD25 `https://youtu.be/94RdOzbXvHM`  Lets make a stronger problem solving community. subscribe to the channel for amazing dsa content."
                    },
                    {
                        "username": "prasannaprassu80",
                        "content": "What is wrong in my code? 127/141 test cases are passed. if i check the failed test case, by copy and paste them in the test case, that test case is getting passed,. then why it is showing test cases failed?\n\n\ndef longestPalindrome(self, s: str) -> str:\n        length_list= []\n        max_len=0\n        result=\"\"\n        for i in range(len(s)):\n            for j in range(i+1, len(s)+1):\n                substring= s[i:j]\n                rev_substring= substring[::-1]\n                if (substring== rev_substring):\n                    length_list.append(substring)\n        for each in length_list:\n            if len(each)> max_len:\n                max_len= len(each)\n                result= each\n        return (result)\n[leetcode](https://leetcode.com) "
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@prasannaprassu80](/prasannaprassu80)\nTime Limit Exceeded!!!\n\nIt not a error of your code, it's time complexity."
                    },
                    {
                        "username": "zohairhadi",
                        "content": "I thought that I\\'d come up with a good solution but there\\'s a lot of edge cases that my solution doesn\\'t cater to. \\nAny suggestions on what I\\'m missing?\\n\\n`\\n        def longestPalindrome(self, s):\\n\\n\\n        longest = \"\"\\n        temp_longest = \"\"\\n        for i in range(1, len(s)-2):\\n\\n            if s[i-1] == s[i+1]:\\n                count = 2\\n                while (s[i-count] == s[i+count]):\\n                    count += 1\\n                count -= 1\\n                temp_longest = s[i-count: i+count + 1]\\n\\n            elif s[i] == s[i+1]:\\n                count = 1\\n                while (s[i-count] == s[i+1+count]):\\n                    count += 1\\n                count -= 1\\n                temp_longest = s[i-count: i+1+count + 1]\\n\\n            if len(temp_longest) > len(longest):\\n                longest = temp_longest\\n\\n        return longest            \\n`"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@zohairhadi2000](/zohairhadi2000) This code will get in trouble even for simple testcase:\ns= \"bbbbbbbb\"\nWhy?\n\nBecause you didnt define a boundary condition for string that you check on:\n```\nif s[i-1] == s[i+1]:\n            count = 2\n            while (s[i-count] == s[i+count]):\n                count += 1\n            count -= 1\n            temp_longest = s[i-count: i+count + 1]\n```\nWhat if? s[i-count], i-count<0?, i+count>len(s)-1. It returns a \n_IndexError: string index out of range_ right\n\nSo first, check your condition, then run dry test (change some simple case by yourself). \n\nYou can use a slide windows to check, and only check to len(s)-l-1, l=max last found palindromic substring.\n\n```\nclass Solution:\n    def longestPalindrome(self, s: str) -> str:\n        n, l, i, temp, s1 = [len(s), 1, 0, 0, s[::-1]] \n        if s1==s: return s \n        while i+l <= n-1:\n            for j in range(l,n-i+1):\n                if s1[i:i+j] ==s[n-j-i:n-i]: l=j; temp=i\n                if s1[i:i+j] not in s: break\n            if i<=n-l-1:    i+=1; continue \n            else: break \n        if temp==0 and l==1: return s[0]\n        return s[n-l-temp:n-temp]  \n```"
                    }
                ]
            },
            {
                "id": 1759488,
                "content": [
                    {
                        "username": "amart73",
                        "content": "mmm, isn\\'t \"aacabacaa\" a valid and longer palindrome in \"aacabdkacaa\" than \"aca\", why the wrong answer result?\\n\\nWrong Answer\\nInput\\ns =\\n\"aacabdkacaa\"\\n62 / 141 testcases passed\\nOutput\\n\"aacabacaa\"\\nExpected\\n\"aca\"\\n"
                    },
                    {
                        "username": "Bhawesh12",
                        "content": "Because \"aacabdkacaa\" has d and k in between string whereas your answer has \"aacabacaa\"  as a output. How come you skip the 2 letters in between. They will break the palindromic string and the output must be \"aca\""
                    },
                    {
                        "username": "asingh882",
                        "content": "/**\\n * @param {string} s\\n * @return {string}\\n */\\nvar longestPalindrome = function(s) {\\n    \\n    let longest = \"\";\\n    for(let i = 0; i < s.length; i++) {\\n        for(let j = i + 1; j <= s.length; j++) {\\n            let current = s.slice(i, j);\\n            if(isPalindrome(current) && current.length > longest.length) {\\n                    longest = current;\\n            }\\n        }\\n    }\\n    return longest;\\n};\\n\\nvar isPalindrome = function(s) {\\n    let reversed = s.split(\"\").reverse().join(\\'\\');\\n    return s === reversed;\\n}\\n\\n\"Time Limit Exceeded\" \\nHow this can be fixed?"
                    },
                    {
                        "username": "christianc750",
                        "content": "This fails due to time limits but I\\'m curious if my approach is correct\\n\\n `var longestPalindrome = function(s) {\\n let maxlengthpalindrome = { length: 0, output: \\'\\'};\\n const answer = maxlengthpalindromeInnerScope(s,maxlengthpalindrome);\\n console.log (maxlengthpalindrome);\\n return maxlengthpalindrome.output;\\n\\n};\\n\\nfunction maxlengthpalindromeInnerScope(s,memo) {\\n\\n if (s.length === 0) return \\'\\';\\n if (s.length === 1) {\\n    memo.length = 1;\\n    memo.output = s;\\n    return s;\\n }\\n if (s.length <= memo.length) return memo.output;\\n \\n const pal_length = returnPalindrome(s).length;\\n\\n if (pal_length > 1) {\\n    memo.length = pal_length;\\n    memo.output = s;\\n    return s; \\n }\\n\\n const leftSubStringLP = maxlengthpalindromeInnerScope(s.substring(0,s.length-1), memo);\\n const rightSubStringLP = maxlengthpalindromeInnerScope(s.substring(1,s.length), memo); \\n}`"
                    },
                    {
                        "username": "Yongbi",
                        "content": "No need check all of string, check up to s.length-1- last_found_maxlength."
                    },
                    {
                        "username": "sjorsp",
                        "content": "Funny, I already solved this one by my self, but I thought, would ChatGPT handle this?\\nFirst attempt and it worked without any alterations......"
                    },
                    {
                        "username": "xgz2",
                        "content": "Is it feasible to use a set to maintain the formerly confirmed palindromes rather than the matrix representation described in the solutions? I don\\'t seem to be able to get this to work and am instead getting time limit exceeded for many cases."
                    },
                    {
                        "username": "Maheshzzz",
                        "content": "even though my solution passes 141/141 test cases why it is showing time limit exceeded"
                    },
                    {
                        "username": "ndungu_dedan",
                        "content": "Isn`t the longest palindrome for this input \\n\\'babad\\' => baba"
                    },
                    {
                        "username": "DevPj09",
                        "content": "No. Palindrome are the numbers/words which have same looks even after reversed.\\neg: 151. Even if you reverse it still looks the same\\nbut for the input \\'baba\\' reverse is : \\'abab\\' which is not identical to the initial value."
                    },
                    {
                        "username": "dev3008",
                        "content": "class Solution:\\n    def longestPalindrome(self, s: str) -> str:\\n        for i in range(len(s),-1,-1):\\n            for j in range(0,(len(s)-i)+1):\\n                start=j\\n                end=j+i\\n                if(end<=len(s)):\\n                    temp_sub_string = s[j:end]\\n                    if temp_sub_string == temp_sub_string[::-1]:\\n                        return temp_sub_string\\n                        break\\n\\nI have written this solution based on DP But it is stuck in TLE Error...what can be done to improve this solution ?"
                    },
                    {
                        "username": "zfar-",
                        "content": "Hi , \ni don't understand how can be a palindrome of \"abb\" is \"bb\" ? \nas palindrome \"abb\" - \"bba\" -> resulting in only 'b' to be a palindrome.\n\n Can anyone explain ? "
                    },
                    {
                        "username": "DevPj09",
                        "content": "No. Palindrome are the numbers/words which have same looks even after reversed.\\neg: deed. Even if you reverse it still looks the same\\nbut for the input \\'abb\\' reverse is : \\'bba\\' which is not identical to the initial value.\\n\\nhowever, in case of \\'bb\\' even if you reverse it, it is the same. Hope it answers\\n"
                    },
                    {
                        "username": "johnson0127",
                        "content": "s =\\n\"aacabdkacaa\"\\n\\nwhy output is not \"aacabdkacaa\"\\nExpected  is \"aca\" ?\\n"
                    }
                ]
            },
            {
                "id": 1758513,
                "content": [
                    {
                        "username": "amart73",
                        "content": "mmm, isn\\'t \"aacabacaa\" a valid and longer palindrome in \"aacabdkacaa\" than \"aca\", why the wrong answer result?\\n\\nWrong Answer\\nInput\\ns =\\n\"aacabdkacaa\"\\n62 / 141 testcases passed\\nOutput\\n\"aacabacaa\"\\nExpected\\n\"aca\"\\n"
                    },
                    {
                        "username": "Bhawesh12",
                        "content": "Because \"aacabdkacaa\" has d and k in between string whereas your answer has \"aacabacaa\"  as a output. How come you skip the 2 letters in between. They will break the palindromic string and the output must be \"aca\""
                    },
                    {
                        "username": "asingh882",
                        "content": "/**\\n * @param {string} s\\n * @return {string}\\n */\\nvar longestPalindrome = function(s) {\\n    \\n    let longest = \"\";\\n    for(let i = 0; i < s.length; i++) {\\n        for(let j = i + 1; j <= s.length; j++) {\\n            let current = s.slice(i, j);\\n            if(isPalindrome(current) && current.length > longest.length) {\\n                    longest = current;\\n            }\\n        }\\n    }\\n    return longest;\\n};\\n\\nvar isPalindrome = function(s) {\\n    let reversed = s.split(\"\").reverse().join(\\'\\');\\n    return s === reversed;\\n}\\n\\n\"Time Limit Exceeded\" \\nHow this can be fixed?"
                    },
                    {
                        "username": "christianc750",
                        "content": "This fails due to time limits but I\\'m curious if my approach is correct\\n\\n `var longestPalindrome = function(s) {\\n let maxlengthpalindrome = { length: 0, output: \\'\\'};\\n const answer = maxlengthpalindromeInnerScope(s,maxlengthpalindrome);\\n console.log (maxlengthpalindrome);\\n return maxlengthpalindrome.output;\\n\\n};\\n\\nfunction maxlengthpalindromeInnerScope(s,memo) {\\n\\n if (s.length === 0) return \\'\\';\\n if (s.length === 1) {\\n    memo.length = 1;\\n    memo.output = s;\\n    return s;\\n }\\n if (s.length <= memo.length) return memo.output;\\n \\n const pal_length = returnPalindrome(s).length;\\n\\n if (pal_length > 1) {\\n    memo.length = pal_length;\\n    memo.output = s;\\n    return s; \\n }\\n\\n const leftSubStringLP = maxlengthpalindromeInnerScope(s.substring(0,s.length-1), memo);\\n const rightSubStringLP = maxlengthpalindromeInnerScope(s.substring(1,s.length), memo); \\n}`"
                    },
                    {
                        "username": "Yongbi",
                        "content": "No need check all of string, check up to s.length-1- last_found_maxlength."
                    },
                    {
                        "username": "sjorsp",
                        "content": "Funny, I already solved this one by my self, but I thought, would ChatGPT handle this?\\nFirst attempt and it worked without any alterations......"
                    },
                    {
                        "username": "xgz2",
                        "content": "Is it feasible to use a set to maintain the formerly confirmed palindromes rather than the matrix representation described in the solutions? I don\\'t seem to be able to get this to work and am instead getting time limit exceeded for many cases."
                    },
                    {
                        "username": "Maheshzzz",
                        "content": "even though my solution passes 141/141 test cases why it is showing time limit exceeded"
                    },
                    {
                        "username": "ndungu_dedan",
                        "content": "Isn`t the longest palindrome for this input \\n\\'babad\\' => baba"
                    },
                    {
                        "username": "DevPj09",
                        "content": "No. Palindrome are the numbers/words which have same looks even after reversed.\\neg: 151. Even if you reverse it still looks the same\\nbut for the input \\'baba\\' reverse is : \\'abab\\' which is not identical to the initial value."
                    },
                    {
                        "username": "dev3008",
                        "content": "class Solution:\\n    def longestPalindrome(self, s: str) -> str:\\n        for i in range(len(s),-1,-1):\\n            for j in range(0,(len(s)-i)+1):\\n                start=j\\n                end=j+i\\n                if(end<=len(s)):\\n                    temp_sub_string = s[j:end]\\n                    if temp_sub_string == temp_sub_string[::-1]:\\n                        return temp_sub_string\\n                        break\\n\\nI have written this solution based on DP But it is stuck in TLE Error...what can be done to improve this solution ?"
                    },
                    {
                        "username": "zfar-",
                        "content": "Hi , \ni don't understand how can be a palindrome of \"abb\" is \"bb\" ? \nas palindrome \"abb\" - \"bba\" -> resulting in only 'b' to be a palindrome.\n\n Can anyone explain ? "
                    },
                    {
                        "username": "DevPj09",
                        "content": "No. Palindrome are the numbers/words which have same looks even after reversed.\\neg: deed. Even if you reverse it still looks the same\\nbut for the input \\'abb\\' reverse is : \\'bba\\' which is not identical to the initial value.\\n\\nhowever, in case of \\'bb\\' even if you reverse it, it is the same. Hope it answers\\n"
                    },
                    {
                        "username": "johnson0127",
                        "content": "s =\\n\"aacabdkacaa\"\\n\\nwhy output is not \"aacabdkacaa\"\\nExpected  is \"aca\" ?\\n"
                    }
                ]
            },
            {
                "id": 1757868,
                "content": [
                    {
                        "username": "amart73",
                        "content": "mmm, isn\\'t \"aacabacaa\" a valid and longer palindrome in \"aacabdkacaa\" than \"aca\", why the wrong answer result?\\n\\nWrong Answer\\nInput\\ns =\\n\"aacabdkacaa\"\\n62 / 141 testcases passed\\nOutput\\n\"aacabacaa\"\\nExpected\\n\"aca\"\\n"
                    },
                    {
                        "username": "Bhawesh12",
                        "content": "Because \"aacabdkacaa\" has d and k in between string whereas your answer has \"aacabacaa\"  as a output. How come you skip the 2 letters in between. They will break the palindromic string and the output must be \"aca\""
                    },
                    {
                        "username": "asingh882",
                        "content": "/**\\n * @param {string} s\\n * @return {string}\\n */\\nvar longestPalindrome = function(s) {\\n    \\n    let longest = \"\";\\n    for(let i = 0; i < s.length; i++) {\\n        for(let j = i + 1; j <= s.length; j++) {\\n            let current = s.slice(i, j);\\n            if(isPalindrome(current) && current.length > longest.length) {\\n                    longest = current;\\n            }\\n        }\\n    }\\n    return longest;\\n};\\n\\nvar isPalindrome = function(s) {\\n    let reversed = s.split(\"\").reverse().join(\\'\\');\\n    return s === reversed;\\n}\\n\\n\"Time Limit Exceeded\" \\nHow this can be fixed?"
                    },
                    {
                        "username": "christianc750",
                        "content": "This fails due to time limits but I\\'m curious if my approach is correct\\n\\n `var longestPalindrome = function(s) {\\n let maxlengthpalindrome = { length: 0, output: \\'\\'};\\n const answer = maxlengthpalindromeInnerScope(s,maxlengthpalindrome);\\n console.log (maxlengthpalindrome);\\n return maxlengthpalindrome.output;\\n\\n};\\n\\nfunction maxlengthpalindromeInnerScope(s,memo) {\\n\\n if (s.length === 0) return \\'\\';\\n if (s.length === 1) {\\n    memo.length = 1;\\n    memo.output = s;\\n    return s;\\n }\\n if (s.length <= memo.length) return memo.output;\\n \\n const pal_length = returnPalindrome(s).length;\\n\\n if (pal_length > 1) {\\n    memo.length = pal_length;\\n    memo.output = s;\\n    return s; \\n }\\n\\n const leftSubStringLP = maxlengthpalindromeInnerScope(s.substring(0,s.length-1), memo);\\n const rightSubStringLP = maxlengthpalindromeInnerScope(s.substring(1,s.length), memo); \\n}`"
                    },
                    {
                        "username": "Yongbi",
                        "content": "No need check all of string, check up to s.length-1- last_found_maxlength."
                    },
                    {
                        "username": "sjorsp",
                        "content": "Funny, I already solved this one by my self, but I thought, would ChatGPT handle this?\\nFirst attempt and it worked without any alterations......"
                    },
                    {
                        "username": "xgz2",
                        "content": "Is it feasible to use a set to maintain the formerly confirmed palindromes rather than the matrix representation described in the solutions? I don\\'t seem to be able to get this to work and am instead getting time limit exceeded for many cases."
                    },
                    {
                        "username": "Maheshzzz",
                        "content": "even though my solution passes 141/141 test cases why it is showing time limit exceeded"
                    },
                    {
                        "username": "ndungu_dedan",
                        "content": "Isn`t the longest palindrome for this input \\n\\'babad\\' => baba"
                    },
                    {
                        "username": "DevPj09",
                        "content": "No. Palindrome are the numbers/words which have same looks even after reversed.\\neg: 151. Even if you reverse it still looks the same\\nbut for the input \\'baba\\' reverse is : \\'abab\\' which is not identical to the initial value."
                    },
                    {
                        "username": "dev3008",
                        "content": "class Solution:\\n    def longestPalindrome(self, s: str) -> str:\\n        for i in range(len(s),-1,-1):\\n            for j in range(0,(len(s)-i)+1):\\n                start=j\\n                end=j+i\\n                if(end<=len(s)):\\n                    temp_sub_string = s[j:end]\\n                    if temp_sub_string == temp_sub_string[::-1]:\\n                        return temp_sub_string\\n                        break\\n\\nI have written this solution based on DP But it is stuck in TLE Error...what can be done to improve this solution ?"
                    },
                    {
                        "username": "zfar-",
                        "content": "Hi , \ni don't understand how can be a palindrome of \"abb\" is \"bb\" ? \nas palindrome \"abb\" - \"bba\" -> resulting in only 'b' to be a palindrome.\n\n Can anyone explain ? "
                    },
                    {
                        "username": "DevPj09",
                        "content": "No. Palindrome are the numbers/words which have same looks even after reversed.\\neg: deed. Even if you reverse it still looks the same\\nbut for the input \\'abb\\' reverse is : \\'bba\\' which is not identical to the initial value.\\n\\nhowever, in case of \\'bb\\' even if you reverse it, it is the same. Hope it answers\\n"
                    },
                    {
                        "username": "johnson0127",
                        "content": "s =\\n\"aacabdkacaa\"\\n\\nwhy output is not \"aacabdkacaa\"\\nExpected  is \"aca\" ?\\n"
                    }
                ]
            },
            {
                "id": 1756160,
                "content": [
                    {
                        "username": "amart73",
                        "content": "mmm, isn\\'t \"aacabacaa\" a valid and longer palindrome in \"aacabdkacaa\" than \"aca\", why the wrong answer result?\\n\\nWrong Answer\\nInput\\ns =\\n\"aacabdkacaa\"\\n62 / 141 testcases passed\\nOutput\\n\"aacabacaa\"\\nExpected\\n\"aca\"\\n"
                    },
                    {
                        "username": "Bhawesh12",
                        "content": "Because \"aacabdkacaa\" has d and k in between string whereas your answer has \"aacabacaa\"  as a output. How come you skip the 2 letters in between. They will break the palindromic string and the output must be \"aca\""
                    },
                    {
                        "username": "asingh882",
                        "content": "/**\\n * @param {string} s\\n * @return {string}\\n */\\nvar longestPalindrome = function(s) {\\n    \\n    let longest = \"\";\\n    for(let i = 0; i < s.length; i++) {\\n        for(let j = i + 1; j <= s.length; j++) {\\n            let current = s.slice(i, j);\\n            if(isPalindrome(current) && current.length > longest.length) {\\n                    longest = current;\\n            }\\n        }\\n    }\\n    return longest;\\n};\\n\\nvar isPalindrome = function(s) {\\n    let reversed = s.split(\"\").reverse().join(\\'\\');\\n    return s === reversed;\\n}\\n\\n\"Time Limit Exceeded\" \\nHow this can be fixed?"
                    },
                    {
                        "username": "christianc750",
                        "content": "This fails due to time limits but I\\'m curious if my approach is correct\\n\\n `var longestPalindrome = function(s) {\\n let maxlengthpalindrome = { length: 0, output: \\'\\'};\\n const answer = maxlengthpalindromeInnerScope(s,maxlengthpalindrome);\\n console.log (maxlengthpalindrome);\\n return maxlengthpalindrome.output;\\n\\n};\\n\\nfunction maxlengthpalindromeInnerScope(s,memo) {\\n\\n if (s.length === 0) return \\'\\';\\n if (s.length === 1) {\\n    memo.length = 1;\\n    memo.output = s;\\n    return s;\\n }\\n if (s.length <= memo.length) return memo.output;\\n \\n const pal_length = returnPalindrome(s).length;\\n\\n if (pal_length > 1) {\\n    memo.length = pal_length;\\n    memo.output = s;\\n    return s; \\n }\\n\\n const leftSubStringLP = maxlengthpalindromeInnerScope(s.substring(0,s.length-1), memo);\\n const rightSubStringLP = maxlengthpalindromeInnerScope(s.substring(1,s.length), memo); \\n}`"
                    },
                    {
                        "username": "Yongbi",
                        "content": "No need check all of string, check up to s.length-1- last_found_maxlength."
                    },
                    {
                        "username": "sjorsp",
                        "content": "Funny, I already solved this one by my self, but I thought, would ChatGPT handle this?\\nFirst attempt and it worked without any alterations......"
                    },
                    {
                        "username": "xgz2",
                        "content": "Is it feasible to use a set to maintain the formerly confirmed palindromes rather than the matrix representation described in the solutions? I don\\'t seem to be able to get this to work and am instead getting time limit exceeded for many cases."
                    },
                    {
                        "username": "Maheshzzz",
                        "content": "even though my solution passes 141/141 test cases why it is showing time limit exceeded"
                    },
                    {
                        "username": "ndungu_dedan",
                        "content": "Isn`t the longest palindrome for this input \\n\\'babad\\' => baba"
                    },
                    {
                        "username": "DevPj09",
                        "content": "No. Palindrome are the numbers/words which have same looks even after reversed.\\neg: 151. Even if you reverse it still looks the same\\nbut for the input \\'baba\\' reverse is : \\'abab\\' which is not identical to the initial value."
                    },
                    {
                        "username": "dev3008",
                        "content": "class Solution:\\n    def longestPalindrome(self, s: str) -> str:\\n        for i in range(len(s),-1,-1):\\n            for j in range(0,(len(s)-i)+1):\\n                start=j\\n                end=j+i\\n                if(end<=len(s)):\\n                    temp_sub_string = s[j:end]\\n                    if temp_sub_string == temp_sub_string[::-1]:\\n                        return temp_sub_string\\n                        break\\n\\nI have written this solution based on DP But it is stuck in TLE Error...what can be done to improve this solution ?"
                    },
                    {
                        "username": "zfar-",
                        "content": "Hi , \ni don't understand how can be a palindrome of \"abb\" is \"bb\" ? \nas palindrome \"abb\" - \"bba\" -> resulting in only 'b' to be a palindrome.\n\n Can anyone explain ? "
                    },
                    {
                        "username": "DevPj09",
                        "content": "No. Palindrome are the numbers/words which have same looks even after reversed.\\neg: deed. Even if you reverse it still looks the same\\nbut for the input \\'abb\\' reverse is : \\'bba\\' which is not identical to the initial value.\\n\\nhowever, in case of \\'bb\\' even if you reverse it, it is the same. Hope it answers\\n"
                    },
                    {
                        "username": "johnson0127",
                        "content": "s =\\n\"aacabdkacaa\"\\n\\nwhy output is not \"aacabdkacaa\"\\nExpected  is \"aca\" ?\\n"
                    }
                ]
            },
            {
                "id": 1753546,
                "content": [
                    {
                        "username": "amart73",
                        "content": "mmm, isn\\'t \"aacabacaa\" a valid and longer palindrome in \"aacabdkacaa\" than \"aca\", why the wrong answer result?\\n\\nWrong Answer\\nInput\\ns =\\n\"aacabdkacaa\"\\n62 / 141 testcases passed\\nOutput\\n\"aacabacaa\"\\nExpected\\n\"aca\"\\n"
                    },
                    {
                        "username": "Bhawesh12",
                        "content": "Because \"aacabdkacaa\" has d and k in between string whereas your answer has \"aacabacaa\"  as a output. How come you skip the 2 letters in between. They will break the palindromic string and the output must be \"aca\""
                    },
                    {
                        "username": "asingh882",
                        "content": "/**\\n * @param {string} s\\n * @return {string}\\n */\\nvar longestPalindrome = function(s) {\\n    \\n    let longest = \"\";\\n    for(let i = 0; i < s.length; i++) {\\n        for(let j = i + 1; j <= s.length; j++) {\\n            let current = s.slice(i, j);\\n            if(isPalindrome(current) && current.length > longest.length) {\\n                    longest = current;\\n            }\\n        }\\n    }\\n    return longest;\\n};\\n\\nvar isPalindrome = function(s) {\\n    let reversed = s.split(\"\").reverse().join(\\'\\');\\n    return s === reversed;\\n}\\n\\n\"Time Limit Exceeded\" \\nHow this can be fixed?"
                    },
                    {
                        "username": "christianc750",
                        "content": "This fails due to time limits but I\\'m curious if my approach is correct\\n\\n `var longestPalindrome = function(s) {\\n let maxlengthpalindrome = { length: 0, output: \\'\\'};\\n const answer = maxlengthpalindromeInnerScope(s,maxlengthpalindrome);\\n console.log (maxlengthpalindrome);\\n return maxlengthpalindrome.output;\\n\\n};\\n\\nfunction maxlengthpalindromeInnerScope(s,memo) {\\n\\n if (s.length === 0) return \\'\\';\\n if (s.length === 1) {\\n    memo.length = 1;\\n    memo.output = s;\\n    return s;\\n }\\n if (s.length <= memo.length) return memo.output;\\n \\n const pal_length = returnPalindrome(s).length;\\n\\n if (pal_length > 1) {\\n    memo.length = pal_length;\\n    memo.output = s;\\n    return s; \\n }\\n\\n const leftSubStringLP = maxlengthpalindromeInnerScope(s.substring(0,s.length-1), memo);\\n const rightSubStringLP = maxlengthpalindromeInnerScope(s.substring(1,s.length), memo); \\n}`"
                    },
                    {
                        "username": "Yongbi",
                        "content": "No need check all of string, check up to s.length-1- last_found_maxlength."
                    },
                    {
                        "username": "sjorsp",
                        "content": "Funny, I already solved this one by my self, but I thought, would ChatGPT handle this?\\nFirst attempt and it worked without any alterations......"
                    },
                    {
                        "username": "xgz2",
                        "content": "Is it feasible to use a set to maintain the formerly confirmed palindromes rather than the matrix representation described in the solutions? I don\\'t seem to be able to get this to work and am instead getting time limit exceeded for many cases."
                    },
                    {
                        "username": "Maheshzzz",
                        "content": "even though my solution passes 141/141 test cases why it is showing time limit exceeded"
                    },
                    {
                        "username": "ndungu_dedan",
                        "content": "Isn`t the longest palindrome for this input \\n\\'babad\\' => baba"
                    },
                    {
                        "username": "DevPj09",
                        "content": "No. Palindrome are the numbers/words which have same looks even after reversed.\\neg: 151. Even if you reverse it still looks the same\\nbut for the input \\'baba\\' reverse is : \\'abab\\' which is not identical to the initial value."
                    },
                    {
                        "username": "dev3008",
                        "content": "class Solution:\\n    def longestPalindrome(self, s: str) -> str:\\n        for i in range(len(s),-1,-1):\\n            for j in range(0,(len(s)-i)+1):\\n                start=j\\n                end=j+i\\n                if(end<=len(s)):\\n                    temp_sub_string = s[j:end]\\n                    if temp_sub_string == temp_sub_string[::-1]:\\n                        return temp_sub_string\\n                        break\\n\\nI have written this solution based on DP But it is stuck in TLE Error...what can be done to improve this solution ?"
                    },
                    {
                        "username": "zfar-",
                        "content": "Hi , \ni don't understand how can be a palindrome of \"abb\" is \"bb\" ? \nas palindrome \"abb\" - \"bba\" -> resulting in only 'b' to be a palindrome.\n\n Can anyone explain ? "
                    },
                    {
                        "username": "DevPj09",
                        "content": "No. Palindrome are the numbers/words which have same looks even after reversed.\\neg: deed. Even if you reverse it still looks the same\\nbut for the input \\'abb\\' reverse is : \\'bba\\' which is not identical to the initial value.\\n\\nhowever, in case of \\'bb\\' even if you reverse it, it is the same. Hope it answers\\n"
                    },
                    {
                        "username": "johnson0127",
                        "content": "s =\\n\"aacabdkacaa\"\\n\\nwhy output is not \"aacabdkacaa\"\\nExpected  is \"aca\" ?\\n"
                    }
                ]
            },
            {
                "id": 1750988,
                "content": [
                    {
                        "username": "amart73",
                        "content": "mmm, isn\\'t \"aacabacaa\" a valid and longer palindrome in \"aacabdkacaa\" than \"aca\", why the wrong answer result?\\n\\nWrong Answer\\nInput\\ns =\\n\"aacabdkacaa\"\\n62 / 141 testcases passed\\nOutput\\n\"aacabacaa\"\\nExpected\\n\"aca\"\\n"
                    },
                    {
                        "username": "Bhawesh12",
                        "content": "Because \"aacabdkacaa\" has d and k in between string whereas your answer has \"aacabacaa\"  as a output. How come you skip the 2 letters in between. They will break the palindromic string and the output must be \"aca\""
                    },
                    {
                        "username": "asingh882",
                        "content": "/**\\n * @param {string} s\\n * @return {string}\\n */\\nvar longestPalindrome = function(s) {\\n    \\n    let longest = \"\";\\n    for(let i = 0; i < s.length; i++) {\\n        for(let j = i + 1; j <= s.length; j++) {\\n            let current = s.slice(i, j);\\n            if(isPalindrome(current) && current.length > longest.length) {\\n                    longest = current;\\n            }\\n        }\\n    }\\n    return longest;\\n};\\n\\nvar isPalindrome = function(s) {\\n    let reversed = s.split(\"\").reverse().join(\\'\\');\\n    return s === reversed;\\n}\\n\\n\"Time Limit Exceeded\" \\nHow this can be fixed?"
                    },
                    {
                        "username": "christianc750",
                        "content": "This fails due to time limits but I\\'m curious if my approach is correct\\n\\n `var longestPalindrome = function(s) {\\n let maxlengthpalindrome = { length: 0, output: \\'\\'};\\n const answer = maxlengthpalindromeInnerScope(s,maxlengthpalindrome);\\n console.log (maxlengthpalindrome);\\n return maxlengthpalindrome.output;\\n\\n};\\n\\nfunction maxlengthpalindromeInnerScope(s,memo) {\\n\\n if (s.length === 0) return \\'\\';\\n if (s.length === 1) {\\n    memo.length = 1;\\n    memo.output = s;\\n    return s;\\n }\\n if (s.length <= memo.length) return memo.output;\\n \\n const pal_length = returnPalindrome(s).length;\\n\\n if (pal_length > 1) {\\n    memo.length = pal_length;\\n    memo.output = s;\\n    return s; \\n }\\n\\n const leftSubStringLP = maxlengthpalindromeInnerScope(s.substring(0,s.length-1), memo);\\n const rightSubStringLP = maxlengthpalindromeInnerScope(s.substring(1,s.length), memo); \\n}`"
                    },
                    {
                        "username": "Yongbi",
                        "content": "No need check all of string, check up to s.length-1- last_found_maxlength."
                    },
                    {
                        "username": "sjorsp",
                        "content": "Funny, I already solved this one by my self, but I thought, would ChatGPT handle this?\\nFirst attempt and it worked without any alterations......"
                    },
                    {
                        "username": "xgz2",
                        "content": "Is it feasible to use a set to maintain the formerly confirmed palindromes rather than the matrix representation described in the solutions? I don\\'t seem to be able to get this to work and am instead getting time limit exceeded for many cases."
                    },
                    {
                        "username": "Maheshzzz",
                        "content": "even though my solution passes 141/141 test cases why it is showing time limit exceeded"
                    },
                    {
                        "username": "ndungu_dedan",
                        "content": "Isn`t the longest palindrome for this input \\n\\'babad\\' => baba"
                    },
                    {
                        "username": "DevPj09",
                        "content": "No. Palindrome are the numbers/words which have same looks even after reversed.\\neg: 151. Even if you reverse it still looks the same\\nbut for the input \\'baba\\' reverse is : \\'abab\\' which is not identical to the initial value."
                    },
                    {
                        "username": "dev3008",
                        "content": "class Solution:\\n    def longestPalindrome(self, s: str) -> str:\\n        for i in range(len(s),-1,-1):\\n            for j in range(0,(len(s)-i)+1):\\n                start=j\\n                end=j+i\\n                if(end<=len(s)):\\n                    temp_sub_string = s[j:end]\\n                    if temp_sub_string == temp_sub_string[::-1]:\\n                        return temp_sub_string\\n                        break\\n\\nI have written this solution based on DP But it is stuck in TLE Error...what can be done to improve this solution ?"
                    },
                    {
                        "username": "zfar-",
                        "content": "Hi , \ni don't understand how can be a palindrome of \"abb\" is \"bb\" ? \nas palindrome \"abb\" - \"bba\" -> resulting in only 'b' to be a palindrome.\n\n Can anyone explain ? "
                    },
                    {
                        "username": "DevPj09",
                        "content": "No. Palindrome are the numbers/words which have same looks even after reversed.\\neg: deed. Even if you reverse it still looks the same\\nbut for the input \\'abb\\' reverse is : \\'bba\\' which is not identical to the initial value.\\n\\nhowever, in case of \\'bb\\' even if you reverse it, it is the same. Hope it answers\\n"
                    },
                    {
                        "username": "johnson0127",
                        "content": "s =\\n\"aacabdkacaa\"\\n\\nwhy output is not \"aacabdkacaa\"\\nExpected  is \"aca\" ?\\n"
                    }
                ]
            },
            {
                "id": 1745230,
                "content": [
                    {
                        "username": "amart73",
                        "content": "mmm, isn\\'t \"aacabacaa\" a valid and longer palindrome in \"aacabdkacaa\" than \"aca\", why the wrong answer result?\\n\\nWrong Answer\\nInput\\ns =\\n\"aacabdkacaa\"\\n62 / 141 testcases passed\\nOutput\\n\"aacabacaa\"\\nExpected\\n\"aca\"\\n"
                    },
                    {
                        "username": "Bhawesh12",
                        "content": "Because \"aacabdkacaa\" has d and k in between string whereas your answer has \"aacabacaa\"  as a output. How come you skip the 2 letters in between. They will break the palindromic string and the output must be \"aca\""
                    },
                    {
                        "username": "asingh882",
                        "content": "/**\\n * @param {string} s\\n * @return {string}\\n */\\nvar longestPalindrome = function(s) {\\n    \\n    let longest = \"\";\\n    for(let i = 0; i < s.length; i++) {\\n        for(let j = i + 1; j <= s.length; j++) {\\n            let current = s.slice(i, j);\\n            if(isPalindrome(current) && current.length > longest.length) {\\n                    longest = current;\\n            }\\n        }\\n    }\\n    return longest;\\n};\\n\\nvar isPalindrome = function(s) {\\n    let reversed = s.split(\"\").reverse().join(\\'\\');\\n    return s === reversed;\\n}\\n\\n\"Time Limit Exceeded\" \\nHow this can be fixed?"
                    },
                    {
                        "username": "christianc750",
                        "content": "This fails due to time limits but I\\'m curious if my approach is correct\\n\\n `var longestPalindrome = function(s) {\\n let maxlengthpalindrome = { length: 0, output: \\'\\'};\\n const answer = maxlengthpalindromeInnerScope(s,maxlengthpalindrome);\\n console.log (maxlengthpalindrome);\\n return maxlengthpalindrome.output;\\n\\n};\\n\\nfunction maxlengthpalindromeInnerScope(s,memo) {\\n\\n if (s.length === 0) return \\'\\';\\n if (s.length === 1) {\\n    memo.length = 1;\\n    memo.output = s;\\n    return s;\\n }\\n if (s.length <= memo.length) return memo.output;\\n \\n const pal_length = returnPalindrome(s).length;\\n\\n if (pal_length > 1) {\\n    memo.length = pal_length;\\n    memo.output = s;\\n    return s; \\n }\\n\\n const leftSubStringLP = maxlengthpalindromeInnerScope(s.substring(0,s.length-1), memo);\\n const rightSubStringLP = maxlengthpalindromeInnerScope(s.substring(1,s.length), memo); \\n}`"
                    },
                    {
                        "username": "Yongbi",
                        "content": "No need check all of string, check up to s.length-1- last_found_maxlength."
                    },
                    {
                        "username": "sjorsp",
                        "content": "Funny, I already solved this one by my self, but I thought, would ChatGPT handle this?\\nFirst attempt and it worked without any alterations......"
                    },
                    {
                        "username": "xgz2",
                        "content": "Is it feasible to use a set to maintain the formerly confirmed palindromes rather than the matrix representation described in the solutions? I don\\'t seem to be able to get this to work and am instead getting time limit exceeded for many cases."
                    },
                    {
                        "username": "Maheshzzz",
                        "content": "even though my solution passes 141/141 test cases why it is showing time limit exceeded"
                    },
                    {
                        "username": "ndungu_dedan",
                        "content": "Isn`t the longest palindrome for this input \\n\\'babad\\' => baba"
                    },
                    {
                        "username": "DevPj09",
                        "content": "No. Palindrome are the numbers/words which have same looks even after reversed.\\neg: 151. Even if you reverse it still looks the same\\nbut for the input \\'baba\\' reverse is : \\'abab\\' which is not identical to the initial value."
                    },
                    {
                        "username": "dev3008",
                        "content": "class Solution:\\n    def longestPalindrome(self, s: str) -> str:\\n        for i in range(len(s),-1,-1):\\n            for j in range(0,(len(s)-i)+1):\\n                start=j\\n                end=j+i\\n                if(end<=len(s)):\\n                    temp_sub_string = s[j:end]\\n                    if temp_sub_string == temp_sub_string[::-1]:\\n                        return temp_sub_string\\n                        break\\n\\nI have written this solution based on DP But it is stuck in TLE Error...what can be done to improve this solution ?"
                    },
                    {
                        "username": "zfar-",
                        "content": "Hi , \ni don't understand how can be a palindrome of \"abb\" is \"bb\" ? \nas palindrome \"abb\" - \"bba\" -> resulting in only 'b' to be a palindrome.\n\n Can anyone explain ? "
                    },
                    {
                        "username": "DevPj09",
                        "content": "No. Palindrome are the numbers/words which have same looks even after reversed.\\neg: deed. Even if you reverse it still looks the same\\nbut for the input \\'abb\\' reverse is : \\'bba\\' which is not identical to the initial value.\\n\\nhowever, in case of \\'bb\\' even if you reverse it, it is the same. Hope it answers\\n"
                    },
                    {
                        "username": "johnson0127",
                        "content": "s =\\n\"aacabdkacaa\"\\n\\nwhy output is not \"aacabdkacaa\"\\nExpected  is \"aca\" ?\\n"
                    }
                ]
            },
            {
                "id": 1741850,
                "content": [
                    {
                        "username": "amart73",
                        "content": "mmm, isn\\'t \"aacabacaa\" a valid and longer palindrome in \"aacabdkacaa\" than \"aca\", why the wrong answer result?\\n\\nWrong Answer\\nInput\\ns =\\n\"aacabdkacaa\"\\n62 / 141 testcases passed\\nOutput\\n\"aacabacaa\"\\nExpected\\n\"aca\"\\n"
                    },
                    {
                        "username": "Bhawesh12",
                        "content": "Because \"aacabdkacaa\" has d and k in between string whereas your answer has \"aacabacaa\"  as a output. How come you skip the 2 letters in between. They will break the palindromic string and the output must be \"aca\""
                    },
                    {
                        "username": "asingh882",
                        "content": "/**\\n * @param {string} s\\n * @return {string}\\n */\\nvar longestPalindrome = function(s) {\\n    \\n    let longest = \"\";\\n    for(let i = 0; i < s.length; i++) {\\n        for(let j = i + 1; j <= s.length; j++) {\\n            let current = s.slice(i, j);\\n            if(isPalindrome(current) && current.length > longest.length) {\\n                    longest = current;\\n            }\\n        }\\n    }\\n    return longest;\\n};\\n\\nvar isPalindrome = function(s) {\\n    let reversed = s.split(\"\").reverse().join(\\'\\');\\n    return s === reversed;\\n}\\n\\n\"Time Limit Exceeded\" \\nHow this can be fixed?"
                    },
                    {
                        "username": "christianc750",
                        "content": "This fails due to time limits but I\\'m curious if my approach is correct\\n\\n `var longestPalindrome = function(s) {\\n let maxlengthpalindrome = { length: 0, output: \\'\\'};\\n const answer = maxlengthpalindromeInnerScope(s,maxlengthpalindrome);\\n console.log (maxlengthpalindrome);\\n return maxlengthpalindrome.output;\\n\\n};\\n\\nfunction maxlengthpalindromeInnerScope(s,memo) {\\n\\n if (s.length === 0) return \\'\\';\\n if (s.length === 1) {\\n    memo.length = 1;\\n    memo.output = s;\\n    return s;\\n }\\n if (s.length <= memo.length) return memo.output;\\n \\n const pal_length = returnPalindrome(s).length;\\n\\n if (pal_length > 1) {\\n    memo.length = pal_length;\\n    memo.output = s;\\n    return s; \\n }\\n\\n const leftSubStringLP = maxlengthpalindromeInnerScope(s.substring(0,s.length-1), memo);\\n const rightSubStringLP = maxlengthpalindromeInnerScope(s.substring(1,s.length), memo); \\n}`"
                    },
                    {
                        "username": "Yongbi",
                        "content": "No need check all of string, check up to s.length-1- last_found_maxlength."
                    },
                    {
                        "username": "sjorsp",
                        "content": "Funny, I already solved this one by my self, but I thought, would ChatGPT handle this?\\nFirst attempt and it worked without any alterations......"
                    },
                    {
                        "username": "xgz2",
                        "content": "Is it feasible to use a set to maintain the formerly confirmed palindromes rather than the matrix representation described in the solutions? I don\\'t seem to be able to get this to work and am instead getting time limit exceeded for many cases."
                    },
                    {
                        "username": "Maheshzzz",
                        "content": "even though my solution passes 141/141 test cases why it is showing time limit exceeded"
                    },
                    {
                        "username": "ndungu_dedan",
                        "content": "Isn`t the longest palindrome for this input \\n\\'babad\\' => baba"
                    },
                    {
                        "username": "DevPj09",
                        "content": "No. Palindrome are the numbers/words which have same looks even after reversed.\\neg: 151. Even if you reverse it still looks the same\\nbut for the input \\'baba\\' reverse is : \\'abab\\' which is not identical to the initial value."
                    },
                    {
                        "username": "dev3008",
                        "content": "class Solution:\\n    def longestPalindrome(self, s: str) -> str:\\n        for i in range(len(s),-1,-1):\\n            for j in range(0,(len(s)-i)+1):\\n                start=j\\n                end=j+i\\n                if(end<=len(s)):\\n                    temp_sub_string = s[j:end]\\n                    if temp_sub_string == temp_sub_string[::-1]:\\n                        return temp_sub_string\\n                        break\\n\\nI have written this solution based on DP But it is stuck in TLE Error...what can be done to improve this solution ?"
                    },
                    {
                        "username": "zfar-",
                        "content": "Hi , \ni don't understand how can be a palindrome of \"abb\" is \"bb\" ? \nas palindrome \"abb\" - \"bba\" -> resulting in only 'b' to be a palindrome.\n\n Can anyone explain ? "
                    },
                    {
                        "username": "DevPj09",
                        "content": "No. Palindrome are the numbers/words which have same looks even after reversed.\\neg: deed. Even if you reverse it still looks the same\\nbut for the input \\'abb\\' reverse is : \\'bba\\' which is not identical to the initial value.\\n\\nhowever, in case of \\'bb\\' even if you reverse it, it is the same. Hope it answers\\n"
                    },
                    {
                        "username": "johnson0127",
                        "content": "s =\\n\"aacabdkacaa\"\\n\\nwhy output is not \"aacabdkacaa\"\\nExpected  is \"aca\" ?\\n"
                    }
                ]
            },
            {
                "id": 1737303,
                "content": [
                    {
                        "username": "amart73",
                        "content": "mmm, isn\\'t \"aacabacaa\" a valid and longer palindrome in \"aacabdkacaa\" than \"aca\", why the wrong answer result?\\n\\nWrong Answer\\nInput\\ns =\\n\"aacabdkacaa\"\\n62 / 141 testcases passed\\nOutput\\n\"aacabacaa\"\\nExpected\\n\"aca\"\\n"
                    },
                    {
                        "username": "Bhawesh12",
                        "content": "Because \"aacabdkacaa\" has d and k in between string whereas your answer has \"aacabacaa\"  as a output. How come you skip the 2 letters in between. They will break the palindromic string and the output must be \"aca\""
                    },
                    {
                        "username": "asingh882",
                        "content": "/**\\n * @param {string} s\\n * @return {string}\\n */\\nvar longestPalindrome = function(s) {\\n    \\n    let longest = \"\";\\n    for(let i = 0; i < s.length; i++) {\\n        for(let j = i + 1; j <= s.length; j++) {\\n            let current = s.slice(i, j);\\n            if(isPalindrome(current) && current.length > longest.length) {\\n                    longest = current;\\n            }\\n        }\\n    }\\n    return longest;\\n};\\n\\nvar isPalindrome = function(s) {\\n    let reversed = s.split(\"\").reverse().join(\\'\\');\\n    return s === reversed;\\n}\\n\\n\"Time Limit Exceeded\" \\nHow this can be fixed?"
                    },
                    {
                        "username": "christianc750",
                        "content": "This fails due to time limits but I\\'m curious if my approach is correct\\n\\n `var longestPalindrome = function(s) {\\n let maxlengthpalindrome = { length: 0, output: \\'\\'};\\n const answer = maxlengthpalindromeInnerScope(s,maxlengthpalindrome);\\n console.log (maxlengthpalindrome);\\n return maxlengthpalindrome.output;\\n\\n};\\n\\nfunction maxlengthpalindromeInnerScope(s,memo) {\\n\\n if (s.length === 0) return \\'\\';\\n if (s.length === 1) {\\n    memo.length = 1;\\n    memo.output = s;\\n    return s;\\n }\\n if (s.length <= memo.length) return memo.output;\\n \\n const pal_length = returnPalindrome(s).length;\\n\\n if (pal_length > 1) {\\n    memo.length = pal_length;\\n    memo.output = s;\\n    return s; \\n }\\n\\n const leftSubStringLP = maxlengthpalindromeInnerScope(s.substring(0,s.length-1), memo);\\n const rightSubStringLP = maxlengthpalindromeInnerScope(s.substring(1,s.length), memo); \\n}`"
                    },
                    {
                        "username": "Yongbi",
                        "content": "No need check all of string, check up to s.length-1- last_found_maxlength."
                    },
                    {
                        "username": "sjorsp",
                        "content": "Funny, I already solved this one by my self, but I thought, would ChatGPT handle this?\\nFirst attempt and it worked without any alterations......"
                    },
                    {
                        "username": "xgz2",
                        "content": "Is it feasible to use a set to maintain the formerly confirmed palindromes rather than the matrix representation described in the solutions? I don\\'t seem to be able to get this to work and am instead getting time limit exceeded for many cases."
                    },
                    {
                        "username": "Maheshzzz",
                        "content": "even though my solution passes 141/141 test cases why it is showing time limit exceeded"
                    },
                    {
                        "username": "ndungu_dedan",
                        "content": "Isn`t the longest palindrome for this input \\n\\'babad\\' => baba"
                    },
                    {
                        "username": "DevPj09",
                        "content": "No. Palindrome are the numbers/words which have same looks even after reversed.\\neg: 151. Even if you reverse it still looks the same\\nbut for the input \\'baba\\' reverse is : \\'abab\\' which is not identical to the initial value."
                    },
                    {
                        "username": "dev3008",
                        "content": "class Solution:\\n    def longestPalindrome(self, s: str) -> str:\\n        for i in range(len(s),-1,-1):\\n            for j in range(0,(len(s)-i)+1):\\n                start=j\\n                end=j+i\\n                if(end<=len(s)):\\n                    temp_sub_string = s[j:end]\\n                    if temp_sub_string == temp_sub_string[::-1]:\\n                        return temp_sub_string\\n                        break\\n\\nI have written this solution based on DP But it is stuck in TLE Error...what can be done to improve this solution ?"
                    },
                    {
                        "username": "zfar-",
                        "content": "Hi , \ni don't understand how can be a palindrome of \"abb\" is \"bb\" ? \nas palindrome \"abb\" - \"bba\" -> resulting in only 'b' to be a palindrome.\n\n Can anyone explain ? "
                    },
                    {
                        "username": "DevPj09",
                        "content": "No. Palindrome are the numbers/words which have same looks even after reversed.\\neg: deed. Even if you reverse it still looks the same\\nbut for the input \\'abb\\' reverse is : \\'bba\\' which is not identical to the initial value.\\n\\nhowever, in case of \\'bb\\' even if you reverse it, it is the same. Hope it answers\\n"
                    },
                    {
                        "username": "johnson0127",
                        "content": "s =\\n\"aacabdkacaa\"\\n\\nwhy output is not \"aacabdkacaa\"\\nExpected  is \"aca\" ?\\n"
                    }
                ]
            },
            {
                "id": 1736245,
                "content": [
                    {
                        "username": "amart73",
                        "content": "mmm, isn\\'t \"aacabacaa\" a valid and longer palindrome in \"aacabdkacaa\" than \"aca\", why the wrong answer result?\\n\\nWrong Answer\\nInput\\ns =\\n\"aacabdkacaa\"\\n62 / 141 testcases passed\\nOutput\\n\"aacabacaa\"\\nExpected\\n\"aca\"\\n"
                    },
                    {
                        "username": "Bhawesh12",
                        "content": "Because \"aacabdkacaa\" has d and k in between string whereas your answer has \"aacabacaa\"  as a output. How come you skip the 2 letters in between. They will break the palindromic string and the output must be \"aca\""
                    },
                    {
                        "username": "asingh882",
                        "content": "/**\\n * @param {string} s\\n * @return {string}\\n */\\nvar longestPalindrome = function(s) {\\n    \\n    let longest = \"\";\\n    for(let i = 0; i < s.length; i++) {\\n        for(let j = i + 1; j <= s.length; j++) {\\n            let current = s.slice(i, j);\\n            if(isPalindrome(current) && current.length > longest.length) {\\n                    longest = current;\\n            }\\n        }\\n    }\\n    return longest;\\n};\\n\\nvar isPalindrome = function(s) {\\n    let reversed = s.split(\"\").reverse().join(\\'\\');\\n    return s === reversed;\\n}\\n\\n\"Time Limit Exceeded\" \\nHow this can be fixed?"
                    },
                    {
                        "username": "christianc750",
                        "content": "This fails due to time limits but I\\'m curious if my approach is correct\\n\\n `var longestPalindrome = function(s) {\\n let maxlengthpalindrome = { length: 0, output: \\'\\'};\\n const answer = maxlengthpalindromeInnerScope(s,maxlengthpalindrome);\\n console.log (maxlengthpalindrome);\\n return maxlengthpalindrome.output;\\n\\n};\\n\\nfunction maxlengthpalindromeInnerScope(s,memo) {\\n\\n if (s.length === 0) return \\'\\';\\n if (s.length === 1) {\\n    memo.length = 1;\\n    memo.output = s;\\n    return s;\\n }\\n if (s.length <= memo.length) return memo.output;\\n \\n const pal_length = returnPalindrome(s).length;\\n\\n if (pal_length > 1) {\\n    memo.length = pal_length;\\n    memo.output = s;\\n    return s; \\n }\\n\\n const leftSubStringLP = maxlengthpalindromeInnerScope(s.substring(0,s.length-1), memo);\\n const rightSubStringLP = maxlengthpalindromeInnerScope(s.substring(1,s.length), memo); \\n}`"
                    },
                    {
                        "username": "Yongbi",
                        "content": "No need check all of string, check up to s.length-1- last_found_maxlength."
                    },
                    {
                        "username": "sjorsp",
                        "content": "Funny, I already solved this one by my self, but I thought, would ChatGPT handle this?\\nFirst attempt and it worked without any alterations......"
                    },
                    {
                        "username": "xgz2",
                        "content": "Is it feasible to use a set to maintain the formerly confirmed palindromes rather than the matrix representation described in the solutions? I don\\'t seem to be able to get this to work and am instead getting time limit exceeded for many cases."
                    },
                    {
                        "username": "Maheshzzz",
                        "content": "even though my solution passes 141/141 test cases why it is showing time limit exceeded"
                    },
                    {
                        "username": "ndungu_dedan",
                        "content": "Isn`t the longest palindrome for this input \\n\\'babad\\' => baba"
                    },
                    {
                        "username": "DevPj09",
                        "content": "No. Palindrome are the numbers/words which have same looks even after reversed.\\neg: 151. Even if you reverse it still looks the same\\nbut for the input \\'baba\\' reverse is : \\'abab\\' which is not identical to the initial value."
                    },
                    {
                        "username": "dev3008",
                        "content": "class Solution:\\n    def longestPalindrome(self, s: str) -> str:\\n        for i in range(len(s),-1,-1):\\n            for j in range(0,(len(s)-i)+1):\\n                start=j\\n                end=j+i\\n                if(end<=len(s)):\\n                    temp_sub_string = s[j:end]\\n                    if temp_sub_string == temp_sub_string[::-1]:\\n                        return temp_sub_string\\n                        break\\n\\nI have written this solution based on DP But it is stuck in TLE Error...what can be done to improve this solution ?"
                    },
                    {
                        "username": "zfar-",
                        "content": "Hi , \ni don't understand how can be a palindrome of \"abb\" is \"bb\" ? \nas palindrome \"abb\" - \"bba\" -> resulting in only 'b' to be a palindrome.\n\n Can anyone explain ? "
                    },
                    {
                        "username": "DevPj09",
                        "content": "No. Palindrome are the numbers/words which have same looks even after reversed.\\neg: deed. Even if you reverse it still looks the same\\nbut for the input \\'abb\\' reverse is : \\'bba\\' which is not identical to the initial value.\\n\\nhowever, in case of \\'bb\\' even if you reverse it, it is the same. Hope it answers\\n"
                    },
                    {
                        "username": "johnson0127",
                        "content": "s =\\n\"aacabdkacaa\"\\n\\nwhy output is not \"aacabdkacaa\"\\nExpected  is \"aca\" ?\\n"
                    }
                ]
            },
            {
                "id": 1735713,
                "content": [
                    {
                        "username": "Vinit_Anishkumar_Masrani",
                        "content": "When I submit, I get TLE error for the following test case:\nTime Limit Exceeded\nAnd it shows 141/141 testcases passed\nLast executed Input:\n s =\n\n\nWhat is the expected output for this testcase? And why is my code though passing big strings in testcase fails because of TLE in empty one."
                    },
                    {
                        "username": "DevPj09",
                        "content": "This is a bug. Happened with me too. I changed the browser and it worked. Might be due to network or cache.\\n"
                    },
                    {
                        "username": "TheCScience",
                        "content": "Here is problem solution in Java, Python, C++ and C programming.\\n[https://thecscience.com/leetcode-longest-palindromic-substring-problem-solution.html](https://thecscience.com/leetcode-longest-palindromic-substring-problem-solution.html)"
                    },
                    {
                        "username": "Shekhar_k_s",
                        "content": "My Solution was of O(n2) and final result is Time Limit Exceeded ( TLE ) . LOL \\uD83D\\uDE12\\n `void check(vector<vector<bool>> &v, int start, int end, string s, int &indexStart, int &indexEnd)\\n{\\n    if(s[start]==s[end])\\n    {\\n        if(v[start+1][end-1]==true)\\n        {\\n            v[start][end]=true;\\n            // cout<<start<<\" \"<<end<<endl;\\n            indexStart=start;\\n            indexEnd=end;\\n        }else\\n        {\\n            v[start][end]=false;\\n        }\\n    }\\n    else\\n    v[start][end]=false;\\n}\\n\\n\\n\\nclass Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n        int len=s.length();\\n        int indexStart=0;\\n        int indexEnd=0;\\n        vector<vector<bool>> arr;\\n        for(int i=0;i<len;i++)\\n        {\\n            vector<bool> v(len);\\n            v[i]=true;\\n            arr.push_back(v);\\n        }\\n        for(int i=1;i<len;i++)\\n        {\\n            if(s[i-1]==s[i]){\\n                arr[i-1][i]=true;\\n                indexStart=i-1;\\n                indexEnd=i;\\n            }\\n            else\\n            arr[i-1][i]=false;\\n        }\\n        // cout<<indexStart<<\" \"<<indexEnd<<endl;\\n        int start=0;\\n        int end=2;\\n        while(end-start<=len)\\n        {\\n            while(end<len)\\n            {\\n                check(arr, start, end, s, indexStart, indexEnd);\\n                start++;\\n                end++;\\n            }\\n            int temp=end-start;\\n            temp++;\\n            start=0;\\n            end=temp;\\n        }\\n        string ans;\\n        for(int i=indexStart;i<=indexEnd;i++)\\n        {\\n            ans+=s[i];\\n        }\\n        // cout<<indexStart<<\" \"<<indexEnd<<endl;\\n        return ans;\\n    }\\n};`"
                    },
                    {
                        "username": "joshi248",
                        "content": "What is wrong here please tell\\n ```\\nclass Solution {\\npublic:\\n    bool isPalindrome(string strs){\\n        int n = strs.length();\\n        for(int i=0;i<n/2;++i){\\n            if(strs[i]!=strs[n-i-1]) return false;\\n        }\\n        return true;\\n    }\\n    string check(vector<string> &temp){\\n        string sruti = \"\";\\n        for(auto strs:temp){\\n            if(isPalindrome(strs)){\\n              if(strs.length() > sruti.length()) sruti = strs;\\n            }\\n        }\\n        return sruti;\\n    }\\n    string longestPalindrome(string s) {\\n        \\n        vector<string> temp;\\n        int n = s.length();\\n        if(n==1){\\n            if(isPalindrome(s)){\\n                return s;\\n            }\\n            return \"\";\\n        }\\n        for(int i=0;i<n;++i){\\n            for(int j=1;j<=n-i;++j){\\n                temp.push_back(s.substr(i,j));\\n            }\\n        }\\n        string ans = check(temp);\\n        return ans;\\n\\n\\n    }\\n};\\n```"
                    },
                    {
                        "username": "ayushi_828",
                        "content": "class Solution {\\n   int resultStart;\\n    int resultLength;\\n\\n    public String longestPalindrome(String s) {\\n        int strLength = s.length();\\n        if (strLength < 2) {\\n            return s;\\n        }\\n        for (int start = 0; start < strLength - 1; start++) {\\n            expandRange(s, start, start);\\n            expandRange(s, start, start + 1);\\n        }\\n        return s.substring(resultStart, resultStart + resultLength);\\n    }\\n\\n    private void expandRange(String str, int begin, int end) {\\n       while (begin >= 0 && end < str.length() &&\\n                    str.charAt(begin) == str.charAt(end)) {\\n            begin--;\\n            end++;\\n        }\\n       if (resultLength < end - begin - 1) {\\n            resultStart = begin + 1;\\n            resultLength = end - begin - 1;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sukriti_sinha7",
                        "content": "class Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n        string ans = \"\";\\n        for(int i = 0; i < s.length() ; i ++){\\n            string s1 = extend(s,i,i), s2 = extend(s, i, i+1);\\n\\n            if(s1.length() > ans.length()) ans = s1;\\n            if(s2.length() > ans.length()) ans = s2;\\n        }\\n\\n        return ans;\\n    }\\n\\n    string extend(string s, int left, int right){\\n        while(left >= 0 && right < s.length() && s[left] == s[right]){\\n            left--;\\n            right++;\\n        }\\n        return s.substr(left+1, right - left - 1);\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "utkarshv2619",
                        "content": "//easy solution:\\n\\nclass Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n        string res;\\n        int reslen = 0;\\n        \\n        if(s.size()<=1)\\n            return s; \\n        \\n        for(int i=0;i<s.size()-1;i++)\\n        {\\n            //odd length\\n            int l=i;\\n            int r=i;\\n            while(l>=0 && r<s.size() && s[l]==s[r])\\n            {\\n                if(r-l+1 > reslen  )\\n                {\\n                    res = s.substr(l, r-l+1);\\n                    reslen = r-l+1;\\n                }\\n                l--;\\n                r++;\\n            }\\n            //even length\\n            int L=i;\\n            int R=i+1;\\n            while(L>=0 && R<s.size() && s[L]==s[R])\\n            {\\n                if(R-L+1 > reslen)\\n                {\\n                    res = s.substr(L,R-L+1);\\n                    reslen = R-L+1;\\n                }\\n                L--;\\n                R++;\\n            }\\n        }\\n        return res;\\n    }\\n    \\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "//Easy rules.\n\n Discussion Rules\n1. Please don't post any solutions in this discussion.\n\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\n\n3. If you'd like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "codecat____",
                        "content": "I have \"Time Limit Exceeded\" problem here \nhow can i reduce running time in my code ?\n\ncode is given :\n\n\n\n\n\nclass Solution:\n    def longestPalindrome(self, s: str) -> str:\n        y=[]\n        x=[]\n        for i in range(len(s)):\n            for j in range(i+1,len(s)+1):\n                y.append(s[i:j])\n        for k in y:\n            if k == k[::-1]:\n                x.append(k)\n        w=[]\n        for v in x:\n            w.append(len(v))\n        if len(s)==1:\n            return s\n        for q in x:\n            if len(q)==max(w):\n                return(q)\n  "
                    },
                    {
                        "username": "noob-pika",
                        "content": "Check out the last two solutions in the solutions section of this question. The last one has a time complexity of O(n) but may take a while to understand whereas the second last one has a time complexity of O(n^2) but fairly easy"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@codecat____](/codecat____) Just use 2 pointer and reverse string that\\'s enough. I see that you have 5 loop in your algorithm!! It\\'s kind of too much, right?"
                    },
                    {
                        "username": "itanki3085",
                        "content": "Different result between LeetCode and my computer.\\nI got the result : `load of value 15, which is not a valid value for type \\'bool\\'`, but my code at that line is\\n```cpp\\ndp[from][to] = dp[from+1][to-1] && (s[from]==s[to]);\\n```\\nHow was that possible when I assign a boolean value into a address stores boolean value still get an error?\\nAt least it is not related to compiler. But what is the problem related to?"
                    },
                    {
                        "username": "Khudoyshukur",
                        "content": "Are we allowed to use class only? When I am writing without classes it is giving error: use of undeclared identifier \\'solution\\'. What should i do?"
                    }
                ]
            },
            {
                "id": 1735647,
                "content": [
                    {
                        "username": "Vinit_Anishkumar_Masrani",
                        "content": "When I submit, I get TLE error for the following test case:\nTime Limit Exceeded\nAnd it shows 141/141 testcases passed\nLast executed Input:\n s =\n\n\nWhat is the expected output for this testcase? And why is my code though passing big strings in testcase fails because of TLE in empty one."
                    },
                    {
                        "username": "DevPj09",
                        "content": "This is a bug. Happened with me too. I changed the browser and it worked. Might be due to network or cache.\\n"
                    },
                    {
                        "username": "TheCScience",
                        "content": "Here is problem solution in Java, Python, C++ and C programming.\\n[https://thecscience.com/leetcode-longest-palindromic-substring-problem-solution.html](https://thecscience.com/leetcode-longest-palindromic-substring-problem-solution.html)"
                    },
                    {
                        "username": "Shekhar_k_s",
                        "content": "My Solution was of O(n2) and final result is Time Limit Exceeded ( TLE ) . LOL \\uD83D\\uDE12\\n `void check(vector<vector<bool>> &v, int start, int end, string s, int &indexStart, int &indexEnd)\\n{\\n    if(s[start]==s[end])\\n    {\\n        if(v[start+1][end-1]==true)\\n        {\\n            v[start][end]=true;\\n            // cout<<start<<\" \"<<end<<endl;\\n            indexStart=start;\\n            indexEnd=end;\\n        }else\\n        {\\n            v[start][end]=false;\\n        }\\n    }\\n    else\\n    v[start][end]=false;\\n}\\n\\n\\n\\nclass Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n        int len=s.length();\\n        int indexStart=0;\\n        int indexEnd=0;\\n        vector<vector<bool>> arr;\\n        for(int i=0;i<len;i++)\\n        {\\n            vector<bool> v(len);\\n            v[i]=true;\\n            arr.push_back(v);\\n        }\\n        for(int i=1;i<len;i++)\\n        {\\n            if(s[i-1]==s[i]){\\n                arr[i-1][i]=true;\\n                indexStart=i-1;\\n                indexEnd=i;\\n            }\\n            else\\n            arr[i-1][i]=false;\\n        }\\n        // cout<<indexStart<<\" \"<<indexEnd<<endl;\\n        int start=0;\\n        int end=2;\\n        while(end-start<=len)\\n        {\\n            while(end<len)\\n            {\\n                check(arr, start, end, s, indexStart, indexEnd);\\n                start++;\\n                end++;\\n            }\\n            int temp=end-start;\\n            temp++;\\n            start=0;\\n            end=temp;\\n        }\\n        string ans;\\n        for(int i=indexStart;i<=indexEnd;i++)\\n        {\\n            ans+=s[i];\\n        }\\n        // cout<<indexStart<<\" \"<<indexEnd<<endl;\\n        return ans;\\n    }\\n};`"
                    },
                    {
                        "username": "joshi248",
                        "content": "What is wrong here please tell\\n ```\\nclass Solution {\\npublic:\\n    bool isPalindrome(string strs){\\n        int n = strs.length();\\n        for(int i=0;i<n/2;++i){\\n            if(strs[i]!=strs[n-i-1]) return false;\\n        }\\n        return true;\\n    }\\n    string check(vector<string> &temp){\\n        string sruti = \"\";\\n        for(auto strs:temp){\\n            if(isPalindrome(strs)){\\n              if(strs.length() > sruti.length()) sruti = strs;\\n            }\\n        }\\n        return sruti;\\n    }\\n    string longestPalindrome(string s) {\\n        \\n        vector<string> temp;\\n        int n = s.length();\\n        if(n==1){\\n            if(isPalindrome(s)){\\n                return s;\\n            }\\n            return \"\";\\n        }\\n        for(int i=0;i<n;++i){\\n            for(int j=1;j<=n-i;++j){\\n                temp.push_back(s.substr(i,j));\\n            }\\n        }\\n        string ans = check(temp);\\n        return ans;\\n\\n\\n    }\\n};\\n```"
                    },
                    {
                        "username": "ayushi_828",
                        "content": "class Solution {\\n   int resultStart;\\n    int resultLength;\\n\\n    public String longestPalindrome(String s) {\\n        int strLength = s.length();\\n        if (strLength < 2) {\\n            return s;\\n        }\\n        for (int start = 0; start < strLength - 1; start++) {\\n            expandRange(s, start, start);\\n            expandRange(s, start, start + 1);\\n        }\\n        return s.substring(resultStart, resultStart + resultLength);\\n    }\\n\\n    private void expandRange(String str, int begin, int end) {\\n       while (begin >= 0 && end < str.length() &&\\n                    str.charAt(begin) == str.charAt(end)) {\\n            begin--;\\n            end++;\\n        }\\n       if (resultLength < end - begin - 1) {\\n            resultStart = begin + 1;\\n            resultLength = end - begin - 1;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sukriti_sinha7",
                        "content": "class Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n        string ans = \"\";\\n        for(int i = 0; i < s.length() ; i ++){\\n            string s1 = extend(s,i,i), s2 = extend(s, i, i+1);\\n\\n            if(s1.length() > ans.length()) ans = s1;\\n            if(s2.length() > ans.length()) ans = s2;\\n        }\\n\\n        return ans;\\n    }\\n\\n    string extend(string s, int left, int right){\\n        while(left >= 0 && right < s.length() && s[left] == s[right]){\\n            left--;\\n            right++;\\n        }\\n        return s.substr(left+1, right - left - 1);\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "utkarshv2619",
                        "content": "//easy solution:\\n\\nclass Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n        string res;\\n        int reslen = 0;\\n        \\n        if(s.size()<=1)\\n            return s; \\n        \\n        for(int i=0;i<s.size()-1;i++)\\n        {\\n            //odd length\\n            int l=i;\\n            int r=i;\\n            while(l>=0 && r<s.size() && s[l]==s[r])\\n            {\\n                if(r-l+1 > reslen  )\\n                {\\n                    res = s.substr(l, r-l+1);\\n                    reslen = r-l+1;\\n                }\\n                l--;\\n                r++;\\n            }\\n            //even length\\n            int L=i;\\n            int R=i+1;\\n            while(L>=0 && R<s.size() && s[L]==s[R])\\n            {\\n                if(R-L+1 > reslen)\\n                {\\n                    res = s.substr(L,R-L+1);\\n                    reslen = R-L+1;\\n                }\\n                L--;\\n                R++;\\n            }\\n        }\\n        return res;\\n    }\\n    \\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "//Easy rules.\n\n Discussion Rules\n1. Please don't post any solutions in this discussion.\n\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\n\n3. If you'd like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "codecat____",
                        "content": "I have \"Time Limit Exceeded\" problem here \nhow can i reduce running time in my code ?\n\ncode is given :\n\n\n\n\n\nclass Solution:\n    def longestPalindrome(self, s: str) -> str:\n        y=[]\n        x=[]\n        for i in range(len(s)):\n            for j in range(i+1,len(s)+1):\n                y.append(s[i:j])\n        for k in y:\n            if k == k[::-1]:\n                x.append(k)\n        w=[]\n        for v in x:\n            w.append(len(v))\n        if len(s)==1:\n            return s\n        for q in x:\n            if len(q)==max(w):\n                return(q)\n  "
                    },
                    {
                        "username": "noob-pika",
                        "content": "Check out the last two solutions in the solutions section of this question. The last one has a time complexity of O(n) but may take a while to understand whereas the second last one has a time complexity of O(n^2) but fairly easy"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@codecat____](/codecat____) Just use 2 pointer and reverse string that\\'s enough. I see that you have 5 loop in your algorithm!! It\\'s kind of too much, right?"
                    },
                    {
                        "username": "itanki3085",
                        "content": "Different result between LeetCode and my computer.\\nI got the result : `load of value 15, which is not a valid value for type \\'bool\\'`, but my code at that line is\\n```cpp\\ndp[from][to] = dp[from+1][to-1] && (s[from]==s[to]);\\n```\\nHow was that possible when I assign a boolean value into a address stores boolean value still get an error?\\nAt least it is not related to compiler. But what is the problem related to?"
                    },
                    {
                        "username": "Khudoyshukur",
                        "content": "Are we allowed to use class only? When I am writing without classes it is giving error: use of undeclared identifier \\'solution\\'. What should i do?"
                    }
                ]
            },
            {
                "id": 1734023,
                "content": [
                    {
                        "username": "Vinit_Anishkumar_Masrani",
                        "content": "When I submit, I get TLE error for the following test case:\nTime Limit Exceeded\nAnd it shows 141/141 testcases passed\nLast executed Input:\n s =\n\n\nWhat is the expected output for this testcase? And why is my code though passing big strings in testcase fails because of TLE in empty one."
                    },
                    {
                        "username": "DevPj09",
                        "content": "This is a bug. Happened with me too. I changed the browser and it worked. Might be due to network or cache.\\n"
                    },
                    {
                        "username": "TheCScience",
                        "content": "Here is problem solution in Java, Python, C++ and C programming.\\n[https://thecscience.com/leetcode-longest-palindromic-substring-problem-solution.html](https://thecscience.com/leetcode-longest-palindromic-substring-problem-solution.html)"
                    },
                    {
                        "username": "Shekhar_k_s",
                        "content": "My Solution was of O(n2) and final result is Time Limit Exceeded ( TLE ) . LOL \\uD83D\\uDE12\\n `void check(vector<vector<bool>> &v, int start, int end, string s, int &indexStart, int &indexEnd)\\n{\\n    if(s[start]==s[end])\\n    {\\n        if(v[start+1][end-1]==true)\\n        {\\n            v[start][end]=true;\\n            // cout<<start<<\" \"<<end<<endl;\\n            indexStart=start;\\n            indexEnd=end;\\n        }else\\n        {\\n            v[start][end]=false;\\n        }\\n    }\\n    else\\n    v[start][end]=false;\\n}\\n\\n\\n\\nclass Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n        int len=s.length();\\n        int indexStart=0;\\n        int indexEnd=0;\\n        vector<vector<bool>> arr;\\n        for(int i=0;i<len;i++)\\n        {\\n            vector<bool> v(len);\\n            v[i]=true;\\n            arr.push_back(v);\\n        }\\n        for(int i=1;i<len;i++)\\n        {\\n            if(s[i-1]==s[i]){\\n                arr[i-1][i]=true;\\n                indexStart=i-1;\\n                indexEnd=i;\\n            }\\n            else\\n            arr[i-1][i]=false;\\n        }\\n        // cout<<indexStart<<\" \"<<indexEnd<<endl;\\n        int start=0;\\n        int end=2;\\n        while(end-start<=len)\\n        {\\n            while(end<len)\\n            {\\n                check(arr, start, end, s, indexStart, indexEnd);\\n                start++;\\n                end++;\\n            }\\n            int temp=end-start;\\n            temp++;\\n            start=0;\\n            end=temp;\\n        }\\n        string ans;\\n        for(int i=indexStart;i<=indexEnd;i++)\\n        {\\n            ans+=s[i];\\n        }\\n        // cout<<indexStart<<\" \"<<indexEnd<<endl;\\n        return ans;\\n    }\\n};`"
                    },
                    {
                        "username": "joshi248",
                        "content": "What is wrong here please tell\\n ```\\nclass Solution {\\npublic:\\n    bool isPalindrome(string strs){\\n        int n = strs.length();\\n        for(int i=0;i<n/2;++i){\\n            if(strs[i]!=strs[n-i-1]) return false;\\n        }\\n        return true;\\n    }\\n    string check(vector<string> &temp){\\n        string sruti = \"\";\\n        for(auto strs:temp){\\n            if(isPalindrome(strs)){\\n              if(strs.length() > sruti.length()) sruti = strs;\\n            }\\n        }\\n        return sruti;\\n    }\\n    string longestPalindrome(string s) {\\n        \\n        vector<string> temp;\\n        int n = s.length();\\n        if(n==1){\\n            if(isPalindrome(s)){\\n                return s;\\n            }\\n            return \"\";\\n        }\\n        for(int i=0;i<n;++i){\\n            for(int j=1;j<=n-i;++j){\\n                temp.push_back(s.substr(i,j));\\n            }\\n        }\\n        string ans = check(temp);\\n        return ans;\\n\\n\\n    }\\n};\\n```"
                    },
                    {
                        "username": "ayushi_828",
                        "content": "class Solution {\\n   int resultStart;\\n    int resultLength;\\n\\n    public String longestPalindrome(String s) {\\n        int strLength = s.length();\\n        if (strLength < 2) {\\n            return s;\\n        }\\n        for (int start = 0; start < strLength - 1; start++) {\\n            expandRange(s, start, start);\\n            expandRange(s, start, start + 1);\\n        }\\n        return s.substring(resultStart, resultStart + resultLength);\\n    }\\n\\n    private void expandRange(String str, int begin, int end) {\\n       while (begin >= 0 && end < str.length() &&\\n                    str.charAt(begin) == str.charAt(end)) {\\n            begin--;\\n            end++;\\n        }\\n       if (resultLength < end - begin - 1) {\\n            resultStart = begin + 1;\\n            resultLength = end - begin - 1;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sukriti_sinha7",
                        "content": "class Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n        string ans = \"\";\\n        for(int i = 0; i < s.length() ; i ++){\\n            string s1 = extend(s,i,i), s2 = extend(s, i, i+1);\\n\\n            if(s1.length() > ans.length()) ans = s1;\\n            if(s2.length() > ans.length()) ans = s2;\\n        }\\n\\n        return ans;\\n    }\\n\\n    string extend(string s, int left, int right){\\n        while(left >= 0 && right < s.length() && s[left] == s[right]){\\n            left--;\\n            right++;\\n        }\\n        return s.substr(left+1, right - left - 1);\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "utkarshv2619",
                        "content": "//easy solution:\\n\\nclass Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n        string res;\\n        int reslen = 0;\\n        \\n        if(s.size()<=1)\\n            return s; \\n        \\n        for(int i=0;i<s.size()-1;i++)\\n        {\\n            //odd length\\n            int l=i;\\n            int r=i;\\n            while(l>=0 && r<s.size() && s[l]==s[r])\\n            {\\n                if(r-l+1 > reslen  )\\n                {\\n                    res = s.substr(l, r-l+1);\\n                    reslen = r-l+1;\\n                }\\n                l--;\\n                r++;\\n            }\\n            //even length\\n            int L=i;\\n            int R=i+1;\\n            while(L>=0 && R<s.size() && s[L]==s[R])\\n            {\\n                if(R-L+1 > reslen)\\n                {\\n                    res = s.substr(L,R-L+1);\\n                    reslen = R-L+1;\\n                }\\n                L--;\\n                R++;\\n            }\\n        }\\n        return res;\\n    }\\n    \\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "//Easy rules.\n\n Discussion Rules\n1. Please don't post any solutions in this discussion.\n\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\n\n3. If you'd like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "codecat____",
                        "content": "I have \"Time Limit Exceeded\" problem here \nhow can i reduce running time in my code ?\n\ncode is given :\n\n\n\n\n\nclass Solution:\n    def longestPalindrome(self, s: str) -> str:\n        y=[]\n        x=[]\n        for i in range(len(s)):\n            for j in range(i+1,len(s)+1):\n                y.append(s[i:j])\n        for k in y:\n            if k == k[::-1]:\n                x.append(k)\n        w=[]\n        for v in x:\n            w.append(len(v))\n        if len(s)==1:\n            return s\n        for q in x:\n            if len(q)==max(w):\n                return(q)\n  "
                    },
                    {
                        "username": "noob-pika",
                        "content": "Check out the last two solutions in the solutions section of this question. The last one has a time complexity of O(n) but may take a while to understand whereas the second last one has a time complexity of O(n^2) but fairly easy"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@codecat____](/codecat____) Just use 2 pointer and reverse string that\\'s enough. I see that you have 5 loop in your algorithm!! It\\'s kind of too much, right?"
                    },
                    {
                        "username": "itanki3085",
                        "content": "Different result between LeetCode and my computer.\\nI got the result : `load of value 15, which is not a valid value for type \\'bool\\'`, but my code at that line is\\n```cpp\\ndp[from][to] = dp[from+1][to-1] && (s[from]==s[to]);\\n```\\nHow was that possible when I assign a boolean value into a address stores boolean value still get an error?\\nAt least it is not related to compiler. But what is the problem related to?"
                    },
                    {
                        "username": "Khudoyshukur",
                        "content": "Are we allowed to use class only? When I am writing without classes it is giving error: use of undeclared identifier \\'solution\\'. What should i do?"
                    }
                ]
            },
            {
                "id": 1732901,
                "content": [
                    {
                        "username": "Vinit_Anishkumar_Masrani",
                        "content": "When I submit, I get TLE error for the following test case:\nTime Limit Exceeded\nAnd it shows 141/141 testcases passed\nLast executed Input:\n s =\n\n\nWhat is the expected output for this testcase? And why is my code though passing big strings in testcase fails because of TLE in empty one."
                    },
                    {
                        "username": "DevPj09",
                        "content": "This is a bug. Happened with me too. I changed the browser and it worked. Might be due to network or cache.\\n"
                    },
                    {
                        "username": "TheCScience",
                        "content": "Here is problem solution in Java, Python, C++ and C programming.\\n[https://thecscience.com/leetcode-longest-palindromic-substring-problem-solution.html](https://thecscience.com/leetcode-longest-palindromic-substring-problem-solution.html)"
                    },
                    {
                        "username": "Shekhar_k_s",
                        "content": "My Solution was of O(n2) and final result is Time Limit Exceeded ( TLE ) . LOL \\uD83D\\uDE12\\n `void check(vector<vector<bool>> &v, int start, int end, string s, int &indexStart, int &indexEnd)\\n{\\n    if(s[start]==s[end])\\n    {\\n        if(v[start+1][end-1]==true)\\n        {\\n            v[start][end]=true;\\n            // cout<<start<<\" \"<<end<<endl;\\n            indexStart=start;\\n            indexEnd=end;\\n        }else\\n        {\\n            v[start][end]=false;\\n        }\\n    }\\n    else\\n    v[start][end]=false;\\n}\\n\\n\\n\\nclass Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n        int len=s.length();\\n        int indexStart=0;\\n        int indexEnd=0;\\n        vector<vector<bool>> arr;\\n        for(int i=0;i<len;i++)\\n        {\\n            vector<bool> v(len);\\n            v[i]=true;\\n            arr.push_back(v);\\n        }\\n        for(int i=1;i<len;i++)\\n        {\\n            if(s[i-1]==s[i]){\\n                arr[i-1][i]=true;\\n                indexStart=i-1;\\n                indexEnd=i;\\n            }\\n            else\\n            arr[i-1][i]=false;\\n        }\\n        // cout<<indexStart<<\" \"<<indexEnd<<endl;\\n        int start=0;\\n        int end=2;\\n        while(end-start<=len)\\n        {\\n            while(end<len)\\n            {\\n                check(arr, start, end, s, indexStart, indexEnd);\\n                start++;\\n                end++;\\n            }\\n            int temp=end-start;\\n            temp++;\\n            start=0;\\n            end=temp;\\n        }\\n        string ans;\\n        for(int i=indexStart;i<=indexEnd;i++)\\n        {\\n            ans+=s[i];\\n        }\\n        // cout<<indexStart<<\" \"<<indexEnd<<endl;\\n        return ans;\\n    }\\n};`"
                    },
                    {
                        "username": "joshi248",
                        "content": "What is wrong here please tell\\n ```\\nclass Solution {\\npublic:\\n    bool isPalindrome(string strs){\\n        int n = strs.length();\\n        for(int i=0;i<n/2;++i){\\n            if(strs[i]!=strs[n-i-1]) return false;\\n        }\\n        return true;\\n    }\\n    string check(vector<string> &temp){\\n        string sruti = \"\";\\n        for(auto strs:temp){\\n            if(isPalindrome(strs)){\\n              if(strs.length() > sruti.length()) sruti = strs;\\n            }\\n        }\\n        return sruti;\\n    }\\n    string longestPalindrome(string s) {\\n        \\n        vector<string> temp;\\n        int n = s.length();\\n        if(n==1){\\n            if(isPalindrome(s)){\\n                return s;\\n            }\\n            return \"\";\\n        }\\n        for(int i=0;i<n;++i){\\n            for(int j=1;j<=n-i;++j){\\n                temp.push_back(s.substr(i,j));\\n            }\\n        }\\n        string ans = check(temp);\\n        return ans;\\n\\n\\n    }\\n};\\n```"
                    },
                    {
                        "username": "ayushi_828",
                        "content": "class Solution {\\n   int resultStart;\\n    int resultLength;\\n\\n    public String longestPalindrome(String s) {\\n        int strLength = s.length();\\n        if (strLength < 2) {\\n            return s;\\n        }\\n        for (int start = 0; start < strLength - 1; start++) {\\n            expandRange(s, start, start);\\n            expandRange(s, start, start + 1);\\n        }\\n        return s.substring(resultStart, resultStart + resultLength);\\n    }\\n\\n    private void expandRange(String str, int begin, int end) {\\n       while (begin >= 0 && end < str.length() &&\\n                    str.charAt(begin) == str.charAt(end)) {\\n            begin--;\\n            end++;\\n        }\\n       if (resultLength < end - begin - 1) {\\n            resultStart = begin + 1;\\n            resultLength = end - begin - 1;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sukriti_sinha7",
                        "content": "class Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n        string ans = \"\";\\n        for(int i = 0; i < s.length() ; i ++){\\n            string s1 = extend(s,i,i), s2 = extend(s, i, i+1);\\n\\n            if(s1.length() > ans.length()) ans = s1;\\n            if(s2.length() > ans.length()) ans = s2;\\n        }\\n\\n        return ans;\\n    }\\n\\n    string extend(string s, int left, int right){\\n        while(left >= 0 && right < s.length() && s[left] == s[right]){\\n            left--;\\n            right++;\\n        }\\n        return s.substr(left+1, right - left - 1);\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "utkarshv2619",
                        "content": "//easy solution:\\n\\nclass Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n        string res;\\n        int reslen = 0;\\n        \\n        if(s.size()<=1)\\n            return s; \\n        \\n        for(int i=0;i<s.size()-1;i++)\\n        {\\n            //odd length\\n            int l=i;\\n            int r=i;\\n            while(l>=0 && r<s.size() && s[l]==s[r])\\n            {\\n                if(r-l+1 > reslen  )\\n                {\\n                    res = s.substr(l, r-l+1);\\n                    reslen = r-l+1;\\n                }\\n                l--;\\n                r++;\\n            }\\n            //even length\\n            int L=i;\\n            int R=i+1;\\n            while(L>=0 && R<s.size() && s[L]==s[R])\\n            {\\n                if(R-L+1 > reslen)\\n                {\\n                    res = s.substr(L,R-L+1);\\n                    reslen = R-L+1;\\n                }\\n                L--;\\n                R++;\\n            }\\n        }\\n        return res;\\n    }\\n    \\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "//Easy rules.\n\n Discussion Rules\n1. Please don't post any solutions in this discussion.\n\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\n\n3. If you'd like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "codecat____",
                        "content": "I have \"Time Limit Exceeded\" problem here \nhow can i reduce running time in my code ?\n\ncode is given :\n\n\n\n\n\nclass Solution:\n    def longestPalindrome(self, s: str) -> str:\n        y=[]\n        x=[]\n        for i in range(len(s)):\n            for j in range(i+1,len(s)+1):\n                y.append(s[i:j])\n        for k in y:\n            if k == k[::-1]:\n                x.append(k)\n        w=[]\n        for v in x:\n            w.append(len(v))\n        if len(s)==1:\n            return s\n        for q in x:\n            if len(q)==max(w):\n                return(q)\n  "
                    },
                    {
                        "username": "noob-pika",
                        "content": "Check out the last two solutions in the solutions section of this question. The last one has a time complexity of O(n) but may take a while to understand whereas the second last one has a time complexity of O(n^2) but fairly easy"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@codecat____](/codecat____) Just use 2 pointer and reverse string that\\'s enough. I see that you have 5 loop in your algorithm!! It\\'s kind of too much, right?"
                    },
                    {
                        "username": "itanki3085",
                        "content": "Different result between LeetCode and my computer.\\nI got the result : `load of value 15, which is not a valid value for type \\'bool\\'`, but my code at that line is\\n```cpp\\ndp[from][to] = dp[from+1][to-1] && (s[from]==s[to]);\\n```\\nHow was that possible when I assign a boolean value into a address stores boolean value still get an error?\\nAt least it is not related to compiler. But what is the problem related to?"
                    },
                    {
                        "username": "Khudoyshukur",
                        "content": "Are we allowed to use class only? When I am writing without classes it is giving error: use of undeclared identifier \\'solution\\'. What should i do?"
                    }
                ]
            },
            {
                "id": 1731547,
                "content": [
                    {
                        "username": "Vinit_Anishkumar_Masrani",
                        "content": "When I submit, I get TLE error for the following test case:\nTime Limit Exceeded\nAnd it shows 141/141 testcases passed\nLast executed Input:\n s =\n\n\nWhat is the expected output for this testcase? And why is my code though passing big strings in testcase fails because of TLE in empty one."
                    },
                    {
                        "username": "DevPj09",
                        "content": "This is a bug. Happened with me too. I changed the browser and it worked. Might be due to network or cache.\\n"
                    },
                    {
                        "username": "TheCScience",
                        "content": "Here is problem solution in Java, Python, C++ and C programming.\\n[https://thecscience.com/leetcode-longest-palindromic-substring-problem-solution.html](https://thecscience.com/leetcode-longest-palindromic-substring-problem-solution.html)"
                    },
                    {
                        "username": "Shekhar_k_s",
                        "content": "My Solution was of O(n2) and final result is Time Limit Exceeded ( TLE ) . LOL \\uD83D\\uDE12\\n `void check(vector<vector<bool>> &v, int start, int end, string s, int &indexStart, int &indexEnd)\\n{\\n    if(s[start]==s[end])\\n    {\\n        if(v[start+1][end-1]==true)\\n        {\\n            v[start][end]=true;\\n            // cout<<start<<\" \"<<end<<endl;\\n            indexStart=start;\\n            indexEnd=end;\\n        }else\\n        {\\n            v[start][end]=false;\\n        }\\n    }\\n    else\\n    v[start][end]=false;\\n}\\n\\n\\n\\nclass Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n        int len=s.length();\\n        int indexStart=0;\\n        int indexEnd=0;\\n        vector<vector<bool>> arr;\\n        for(int i=0;i<len;i++)\\n        {\\n            vector<bool> v(len);\\n            v[i]=true;\\n            arr.push_back(v);\\n        }\\n        for(int i=1;i<len;i++)\\n        {\\n            if(s[i-1]==s[i]){\\n                arr[i-1][i]=true;\\n                indexStart=i-1;\\n                indexEnd=i;\\n            }\\n            else\\n            arr[i-1][i]=false;\\n        }\\n        // cout<<indexStart<<\" \"<<indexEnd<<endl;\\n        int start=0;\\n        int end=2;\\n        while(end-start<=len)\\n        {\\n            while(end<len)\\n            {\\n                check(arr, start, end, s, indexStart, indexEnd);\\n                start++;\\n                end++;\\n            }\\n            int temp=end-start;\\n            temp++;\\n            start=0;\\n            end=temp;\\n        }\\n        string ans;\\n        for(int i=indexStart;i<=indexEnd;i++)\\n        {\\n            ans+=s[i];\\n        }\\n        // cout<<indexStart<<\" \"<<indexEnd<<endl;\\n        return ans;\\n    }\\n};`"
                    },
                    {
                        "username": "joshi248",
                        "content": "What is wrong here please tell\\n ```\\nclass Solution {\\npublic:\\n    bool isPalindrome(string strs){\\n        int n = strs.length();\\n        for(int i=0;i<n/2;++i){\\n            if(strs[i]!=strs[n-i-1]) return false;\\n        }\\n        return true;\\n    }\\n    string check(vector<string> &temp){\\n        string sruti = \"\";\\n        for(auto strs:temp){\\n            if(isPalindrome(strs)){\\n              if(strs.length() > sruti.length()) sruti = strs;\\n            }\\n        }\\n        return sruti;\\n    }\\n    string longestPalindrome(string s) {\\n        \\n        vector<string> temp;\\n        int n = s.length();\\n        if(n==1){\\n            if(isPalindrome(s)){\\n                return s;\\n            }\\n            return \"\";\\n        }\\n        for(int i=0;i<n;++i){\\n            for(int j=1;j<=n-i;++j){\\n                temp.push_back(s.substr(i,j));\\n            }\\n        }\\n        string ans = check(temp);\\n        return ans;\\n\\n\\n    }\\n};\\n```"
                    },
                    {
                        "username": "ayushi_828",
                        "content": "class Solution {\\n   int resultStart;\\n    int resultLength;\\n\\n    public String longestPalindrome(String s) {\\n        int strLength = s.length();\\n        if (strLength < 2) {\\n            return s;\\n        }\\n        for (int start = 0; start < strLength - 1; start++) {\\n            expandRange(s, start, start);\\n            expandRange(s, start, start + 1);\\n        }\\n        return s.substring(resultStart, resultStart + resultLength);\\n    }\\n\\n    private void expandRange(String str, int begin, int end) {\\n       while (begin >= 0 && end < str.length() &&\\n                    str.charAt(begin) == str.charAt(end)) {\\n            begin--;\\n            end++;\\n        }\\n       if (resultLength < end - begin - 1) {\\n            resultStart = begin + 1;\\n            resultLength = end - begin - 1;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sukriti_sinha7",
                        "content": "class Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n        string ans = \"\";\\n        for(int i = 0; i < s.length() ; i ++){\\n            string s1 = extend(s,i,i), s2 = extend(s, i, i+1);\\n\\n            if(s1.length() > ans.length()) ans = s1;\\n            if(s2.length() > ans.length()) ans = s2;\\n        }\\n\\n        return ans;\\n    }\\n\\n    string extend(string s, int left, int right){\\n        while(left >= 0 && right < s.length() && s[left] == s[right]){\\n            left--;\\n            right++;\\n        }\\n        return s.substr(left+1, right - left - 1);\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "utkarshv2619",
                        "content": "//easy solution:\\n\\nclass Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n        string res;\\n        int reslen = 0;\\n        \\n        if(s.size()<=1)\\n            return s; \\n        \\n        for(int i=0;i<s.size()-1;i++)\\n        {\\n            //odd length\\n            int l=i;\\n            int r=i;\\n            while(l>=0 && r<s.size() && s[l]==s[r])\\n            {\\n                if(r-l+1 > reslen  )\\n                {\\n                    res = s.substr(l, r-l+1);\\n                    reslen = r-l+1;\\n                }\\n                l--;\\n                r++;\\n            }\\n            //even length\\n            int L=i;\\n            int R=i+1;\\n            while(L>=0 && R<s.size() && s[L]==s[R])\\n            {\\n                if(R-L+1 > reslen)\\n                {\\n                    res = s.substr(L,R-L+1);\\n                    reslen = R-L+1;\\n                }\\n                L--;\\n                R++;\\n            }\\n        }\\n        return res;\\n    }\\n    \\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "//Easy rules.\n\n Discussion Rules\n1. Please don't post any solutions in this discussion.\n\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\n\n3. If you'd like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "codecat____",
                        "content": "I have \"Time Limit Exceeded\" problem here \nhow can i reduce running time in my code ?\n\ncode is given :\n\n\n\n\n\nclass Solution:\n    def longestPalindrome(self, s: str) -> str:\n        y=[]\n        x=[]\n        for i in range(len(s)):\n            for j in range(i+1,len(s)+1):\n                y.append(s[i:j])\n        for k in y:\n            if k == k[::-1]:\n                x.append(k)\n        w=[]\n        for v in x:\n            w.append(len(v))\n        if len(s)==1:\n            return s\n        for q in x:\n            if len(q)==max(w):\n                return(q)\n  "
                    },
                    {
                        "username": "noob-pika",
                        "content": "Check out the last two solutions in the solutions section of this question. The last one has a time complexity of O(n) but may take a while to understand whereas the second last one has a time complexity of O(n^2) but fairly easy"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@codecat____](/codecat____) Just use 2 pointer and reverse string that\\'s enough. I see that you have 5 loop in your algorithm!! It\\'s kind of too much, right?"
                    },
                    {
                        "username": "itanki3085",
                        "content": "Different result between LeetCode and my computer.\\nI got the result : `load of value 15, which is not a valid value for type \\'bool\\'`, but my code at that line is\\n```cpp\\ndp[from][to] = dp[from+1][to-1] && (s[from]==s[to]);\\n```\\nHow was that possible when I assign a boolean value into a address stores boolean value still get an error?\\nAt least it is not related to compiler. But what is the problem related to?"
                    },
                    {
                        "username": "Khudoyshukur",
                        "content": "Are we allowed to use class only? When I am writing without classes it is giving error: use of undeclared identifier \\'solution\\'. What should i do?"
                    }
                ]
            },
            {
                "id": 1731175,
                "content": [
                    {
                        "username": "Vinit_Anishkumar_Masrani",
                        "content": "When I submit, I get TLE error for the following test case:\nTime Limit Exceeded\nAnd it shows 141/141 testcases passed\nLast executed Input:\n s =\n\n\nWhat is the expected output for this testcase? And why is my code though passing big strings in testcase fails because of TLE in empty one."
                    },
                    {
                        "username": "DevPj09",
                        "content": "This is a bug. Happened with me too. I changed the browser and it worked. Might be due to network or cache.\\n"
                    },
                    {
                        "username": "TheCScience",
                        "content": "Here is problem solution in Java, Python, C++ and C programming.\\n[https://thecscience.com/leetcode-longest-palindromic-substring-problem-solution.html](https://thecscience.com/leetcode-longest-palindromic-substring-problem-solution.html)"
                    },
                    {
                        "username": "Shekhar_k_s",
                        "content": "My Solution was of O(n2) and final result is Time Limit Exceeded ( TLE ) . LOL \\uD83D\\uDE12\\n `void check(vector<vector<bool>> &v, int start, int end, string s, int &indexStart, int &indexEnd)\\n{\\n    if(s[start]==s[end])\\n    {\\n        if(v[start+1][end-1]==true)\\n        {\\n            v[start][end]=true;\\n            // cout<<start<<\" \"<<end<<endl;\\n            indexStart=start;\\n            indexEnd=end;\\n        }else\\n        {\\n            v[start][end]=false;\\n        }\\n    }\\n    else\\n    v[start][end]=false;\\n}\\n\\n\\n\\nclass Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n        int len=s.length();\\n        int indexStart=0;\\n        int indexEnd=0;\\n        vector<vector<bool>> arr;\\n        for(int i=0;i<len;i++)\\n        {\\n            vector<bool> v(len);\\n            v[i]=true;\\n            arr.push_back(v);\\n        }\\n        for(int i=1;i<len;i++)\\n        {\\n            if(s[i-1]==s[i]){\\n                arr[i-1][i]=true;\\n                indexStart=i-1;\\n                indexEnd=i;\\n            }\\n            else\\n            arr[i-1][i]=false;\\n        }\\n        // cout<<indexStart<<\" \"<<indexEnd<<endl;\\n        int start=0;\\n        int end=2;\\n        while(end-start<=len)\\n        {\\n            while(end<len)\\n            {\\n                check(arr, start, end, s, indexStart, indexEnd);\\n                start++;\\n                end++;\\n            }\\n            int temp=end-start;\\n            temp++;\\n            start=0;\\n            end=temp;\\n        }\\n        string ans;\\n        for(int i=indexStart;i<=indexEnd;i++)\\n        {\\n            ans+=s[i];\\n        }\\n        // cout<<indexStart<<\" \"<<indexEnd<<endl;\\n        return ans;\\n    }\\n};`"
                    },
                    {
                        "username": "joshi248",
                        "content": "What is wrong here please tell\\n ```\\nclass Solution {\\npublic:\\n    bool isPalindrome(string strs){\\n        int n = strs.length();\\n        for(int i=0;i<n/2;++i){\\n            if(strs[i]!=strs[n-i-1]) return false;\\n        }\\n        return true;\\n    }\\n    string check(vector<string> &temp){\\n        string sruti = \"\";\\n        for(auto strs:temp){\\n            if(isPalindrome(strs)){\\n              if(strs.length() > sruti.length()) sruti = strs;\\n            }\\n        }\\n        return sruti;\\n    }\\n    string longestPalindrome(string s) {\\n        \\n        vector<string> temp;\\n        int n = s.length();\\n        if(n==1){\\n            if(isPalindrome(s)){\\n                return s;\\n            }\\n            return \"\";\\n        }\\n        for(int i=0;i<n;++i){\\n            for(int j=1;j<=n-i;++j){\\n                temp.push_back(s.substr(i,j));\\n            }\\n        }\\n        string ans = check(temp);\\n        return ans;\\n\\n\\n    }\\n};\\n```"
                    },
                    {
                        "username": "ayushi_828",
                        "content": "class Solution {\\n   int resultStart;\\n    int resultLength;\\n\\n    public String longestPalindrome(String s) {\\n        int strLength = s.length();\\n        if (strLength < 2) {\\n            return s;\\n        }\\n        for (int start = 0; start < strLength - 1; start++) {\\n            expandRange(s, start, start);\\n            expandRange(s, start, start + 1);\\n        }\\n        return s.substring(resultStart, resultStart + resultLength);\\n    }\\n\\n    private void expandRange(String str, int begin, int end) {\\n       while (begin >= 0 && end < str.length() &&\\n                    str.charAt(begin) == str.charAt(end)) {\\n            begin--;\\n            end++;\\n        }\\n       if (resultLength < end - begin - 1) {\\n            resultStart = begin + 1;\\n            resultLength = end - begin - 1;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sukriti_sinha7",
                        "content": "class Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n        string ans = \"\";\\n        for(int i = 0; i < s.length() ; i ++){\\n            string s1 = extend(s,i,i), s2 = extend(s, i, i+1);\\n\\n            if(s1.length() > ans.length()) ans = s1;\\n            if(s2.length() > ans.length()) ans = s2;\\n        }\\n\\n        return ans;\\n    }\\n\\n    string extend(string s, int left, int right){\\n        while(left >= 0 && right < s.length() && s[left] == s[right]){\\n            left--;\\n            right++;\\n        }\\n        return s.substr(left+1, right - left - 1);\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "utkarshv2619",
                        "content": "//easy solution:\\n\\nclass Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n        string res;\\n        int reslen = 0;\\n        \\n        if(s.size()<=1)\\n            return s; \\n        \\n        for(int i=0;i<s.size()-1;i++)\\n        {\\n            //odd length\\n            int l=i;\\n            int r=i;\\n            while(l>=0 && r<s.size() && s[l]==s[r])\\n            {\\n                if(r-l+1 > reslen  )\\n                {\\n                    res = s.substr(l, r-l+1);\\n                    reslen = r-l+1;\\n                }\\n                l--;\\n                r++;\\n            }\\n            //even length\\n            int L=i;\\n            int R=i+1;\\n            while(L>=0 && R<s.size() && s[L]==s[R])\\n            {\\n                if(R-L+1 > reslen)\\n                {\\n                    res = s.substr(L,R-L+1);\\n                    reslen = R-L+1;\\n                }\\n                L--;\\n                R++;\\n            }\\n        }\\n        return res;\\n    }\\n    \\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "//Easy rules.\n\n Discussion Rules\n1. Please don't post any solutions in this discussion.\n\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\n\n3. If you'd like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "codecat____",
                        "content": "I have \"Time Limit Exceeded\" problem here \nhow can i reduce running time in my code ?\n\ncode is given :\n\n\n\n\n\nclass Solution:\n    def longestPalindrome(self, s: str) -> str:\n        y=[]\n        x=[]\n        for i in range(len(s)):\n            for j in range(i+1,len(s)+1):\n                y.append(s[i:j])\n        for k in y:\n            if k == k[::-1]:\n                x.append(k)\n        w=[]\n        for v in x:\n            w.append(len(v))\n        if len(s)==1:\n            return s\n        for q in x:\n            if len(q)==max(w):\n                return(q)\n  "
                    },
                    {
                        "username": "noob-pika",
                        "content": "Check out the last two solutions in the solutions section of this question. The last one has a time complexity of O(n) but may take a while to understand whereas the second last one has a time complexity of O(n^2) but fairly easy"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@codecat____](/codecat____) Just use 2 pointer and reverse string that\\'s enough. I see that you have 5 loop in your algorithm!! It\\'s kind of too much, right?"
                    },
                    {
                        "username": "itanki3085",
                        "content": "Different result between LeetCode and my computer.\\nI got the result : `load of value 15, which is not a valid value for type \\'bool\\'`, but my code at that line is\\n```cpp\\ndp[from][to] = dp[from+1][to-1] && (s[from]==s[to]);\\n```\\nHow was that possible when I assign a boolean value into a address stores boolean value still get an error?\\nAt least it is not related to compiler. But what is the problem related to?"
                    },
                    {
                        "username": "Khudoyshukur",
                        "content": "Are we allowed to use class only? When I am writing without classes it is giving error: use of undeclared identifier \\'solution\\'. What should i do?"
                    }
                ]
            },
            {
                "id": 1727086,
                "content": [
                    {
                        "username": "Vinit_Anishkumar_Masrani",
                        "content": "When I submit, I get TLE error for the following test case:\nTime Limit Exceeded\nAnd it shows 141/141 testcases passed\nLast executed Input:\n s =\n\n\nWhat is the expected output for this testcase? And why is my code though passing big strings in testcase fails because of TLE in empty one."
                    },
                    {
                        "username": "DevPj09",
                        "content": "This is a bug. Happened with me too. I changed the browser and it worked. Might be due to network or cache.\\n"
                    },
                    {
                        "username": "TheCScience",
                        "content": "Here is problem solution in Java, Python, C++ and C programming.\\n[https://thecscience.com/leetcode-longest-palindromic-substring-problem-solution.html](https://thecscience.com/leetcode-longest-palindromic-substring-problem-solution.html)"
                    },
                    {
                        "username": "Shekhar_k_s",
                        "content": "My Solution was of O(n2) and final result is Time Limit Exceeded ( TLE ) . LOL \\uD83D\\uDE12\\n `void check(vector<vector<bool>> &v, int start, int end, string s, int &indexStart, int &indexEnd)\\n{\\n    if(s[start]==s[end])\\n    {\\n        if(v[start+1][end-1]==true)\\n        {\\n            v[start][end]=true;\\n            // cout<<start<<\" \"<<end<<endl;\\n            indexStart=start;\\n            indexEnd=end;\\n        }else\\n        {\\n            v[start][end]=false;\\n        }\\n    }\\n    else\\n    v[start][end]=false;\\n}\\n\\n\\n\\nclass Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n        int len=s.length();\\n        int indexStart=0;\\n        int indexEnd=0;\\n        vector<vector<bool>> arr;\\n        for(int i=0;i<len;i++)\\n        {\\n            vector<bool> v(len);\\n            v[i]=true;\\n            arr.push_back(v);\\n        }\\n        for(int i=1;i<len;i++)\\n        {\\n            if(s[i-1]==s[i]){\\n                arr[i-1][i]=true;\\n                indexStart=i-1;\\n                indexEnd=i;\\n            }\\n            else\\n            arr[i-1][i]=false;\\n        }\\n        // cout<<indexStart<<\" \"<<indexEnd<<endl;\\n        int start=0;\\n        int end=2;\\n        while(end-start<=len)\\n        {\\n            while(end<len)\\n            {\\n                check(arr, start, end, s, indexStart, indexEnd);\\n                start++;\\n                end++;\\n            }\\n            int temp=end-start;\\n            temp++;\\n            start=0;\\n            end=temp;\\n        }\\n        string ans;\\n        for(int i=indexStart;i<=indexEnd;i++)\\n        {\\n            ans+=s[i];\\n        }\\n        // cout<<indexStart<<\" \"<<indexEnd<<endl;\\n        return ans;\\n    }\\n};`"
                    },
                    {
                        "username": "joshi248",
                        "content": "What is wrong here please tell\\n ```\\nclass Solution {\\npublic:\\n    bool isPalindrome(string strs){\\n        int n = strs.length();\\n        for(int i=0;i<n/2;++i){\\n            if(strs[i]!=strs[n-i-1]) return false;\\n        }\\n        return true;\\n    }\\n    string check(vector<string> &temp){\\n        string sruti = \"\";\\n        for(auto strs:temp){\\n            if(isPalindrome(strs)){\\n              if(strs.length() > sruti.length()) sruti = strs;\\n            }\\n        }\\n        return sruti;\\n    }\\n    string longestPalindrome(string s) {\\n        \\n        vector<string> temp;\\n        int n = s.length();\\n        if(n==1){\\n            if(isPalindrome(s)){\\n                return s;\\n            }\\n            return \"\";\\n        }\\n        for(int i=0;i<n;++i){\\n            for(int j=1;j<=n-i;++j){\\n                temp.push_back(s.substr(i,j));\\n            }\\n        }\\n        string ans = check(temp);\\n        return ans;\\n\\n\\n    }\\n};\\n```"
                    },
                    {
                        "username": "ayushi_828",
                        "content": "class Solution {\\n   int resultStart;\\n    int resultLength;\\n\\n    public String longestPalindrome(String s) {\\n        int strLength = s.length();\\n        if (strLength < 2) {\\n            return s;\\n        }\\n        for (int start = 0; start < strLength - 1; start++) {\\n            expandRange(s, start, start);\\n            expandRange(s, start, start + 1);\\n        }\\n        return s.substring(resultStart, resultStart + resultLength);\\n    }\\n\\n    private void expandRange(String str, int begin, int end) {\\n       while (begin >= 0 && end < str.length() &&\\n                    str.charAt(begin) == str.charAt(end)) {\\n            begin--;\\n            end++;\\n        }\\n       if (resultLength < end - begin - 1) {\\n            resultStart = begin + 1;\\n            resultLength = end - begin - 1;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sukriti_sinha7",
                        "content": "class Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n        string ans = \"\";\\n        for(int i = 0; i < s.length() ; i ++){\\n            string s1 = extend(s,i,i), s2 = extend(s, i, i+1);\\n\\n            if(s1.length() > ans.length()) ans = s1;\\n            if(s2.length() > ans.length()) ans = s2;\\n        }\\n\\n        return ans;\\n    }\\n\\n    string extend(string s, int left, int right){\\n        while(left >= 0 && right < s.length() && s[left] == s[right]){\\n            left--;\\n            right++;\\n        }\\n        return s.substr(left+1, right - left - 1);\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "utkarshv2619",
                        "content": "//easy solution:\\n\\nclass Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n        string res;\\n        int reslen = 0;\\n        \\n        if(s.size()<=1)\\n            return s; \\n        \\n        for(int i=0;i<s.size()-1;i++)\\n        {\\n            //odd length\\n            int l=i;\\n            int r=i;\\n            while(l>=0 && r<s.size() && s[l]==s[r])\\n            {\\n                if(r-l+1 > reslen  )\\n                {\\n                    res = s.substr(l, r-l+1);\\n                    reslen = r-l+1;\\n                }\\n                l--;\\n                r++;\\n            }\\n            //even length\\n            int L=i;\\n            int R=i+1;\\n            while(L>=0 && R<s.size() && s[L]==s[R])\\n            {\\n                if(R-L+1 > reslen)\\n                {\\n                    res = s.substr(L,R-L+1);\\n                    reslen = R-L+1;\\n                }\\n                L--;\\n                R++;\\n            }\\n        }\\n        return res;\\n    }\\n    \\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "//Easy rules.\n\n Discussion Rules\n1. Please don't post any solutions in this discussion.\n\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\n\n3. If you'd like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "codecat____",
                        "content": "I have \"Time Limit Exceeded\" problem here \nhow can i reduce running time in my code ?\n\ncode is given :\n\n\n\n\n\nclass Solution:\n    def longestPalindrome(self, s: str) -> str:\n        y=[]\n        x=[]\n        for i in range(len(s)):\n            for j in range(i+1,len(s)+1):\n                y.append(s[i:j])\n        for k in y:\n            if k == k[::-1]:\n                x.append(k)\n        w=[]\n        for v in x:\n            w.append(len(v))\n        if len(s)==1:\n            return s\n        for q in x:\n            if len(q)==max(w):\n                return(q)\n  "
                    },
                    {
                        "username": "noob-pika",
                        "content": "Check out the last two solutions in the solutions section of this question. The last one has a time complexity of O(n) but may take a while to understand whereas the second last one has a time complexity of O(n^2) but fairly easy"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@codecat____](/codecat____) Just use 2 pointer and reverse string that\\'s enough. I see that you have 5 loop in your algorithm!! It\\'s kind of too much, right?"
                    },
                    {
                        "username": "itanki3085",
                        "content": "Different result between LeetCode and my computer.\\nI got the result : `load of value 15, which is not a valid value for type \\'bool\\'`, but my code at that line is\\n```cpp\\ndp[from][to] = dp[from+1][to-1] && (s[from]==s[to]);\\n```\\nHow was that possible when I assign a boolean value into a address stores boolean value still get an error?\\nAt least it is not related to compiler. But what is the problem related to?"
                    },
                    {
                        "username": "Khudoyshukur",
                        "content": "Are we allowed to use class only? When I am writing without classes it is giving error: use of undeclared identifier \\'solution\\'. What should i do?"
                    }
                ]
            },
            {
                "id": 1722806,
                "content": [
                    {
                        "username": "Vinit_Anishkumar_Masrani",
                        "content": "When I submit, I get TLE error for the following test case:\nTime Limit Exceeded\nAnd it shows 141/141 testcases passed\nLast executed Input:\n s =\n\n\nWhat is the expected output for this testcase? And why is my code though passing big strings in testcase fails because of TLE in empty one."
                    },
                    {
                        "username": "DevPj09",
                        "content": "This is a bug. Happened with me too. I changed the browser and it worked. Might be due to network or cache.\\n"
                    },
                    {
                        "username": "TheCScience",
                        "content": "Here is problem solution in Java, Python, C++ and C programming.\\n[https://thecscience.com/leetcode-longest-palindromic-substring-problem-solution.html](https://thecscience.com/leetcode-longest-palindromic-substring-problem-solution.html)"
                    },
                    {
                        "username": "Shekhar_k_s",
                        "content": "My Solution was of O(n2) and final result is Time Limit Exceeded ( TLE ) . LOL \\uD83D\\uDE12\\n `void check(vector<vector<bool>> &v, int start, int end, string s, int &indexStart, int &indexEnd)\\n{\\n    if(s[start]==s[end])\\n    {\\n        if(v[start+1][end-1]==true)\\n        {\\n            v[start][end]=true;\\n            // cout<<start<<\" \"<<end<<endl;\\n            indexStart=start;\\n            indexEnd=end;\\n        }else\\n        {\\n            v[start][end]=false;\\n        }\\n    }\\n    else\\n    v[start][end]=false;\\n}\\n\\n\\n\\nclass Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n        int len=s.length();\\n        int indexStart=0;\\n        int indexEnd=0;\\n        vector<vector<bool>> arr;\\n        for(int i=0;i<len;i++)\\n        {\\n            vector<bool> v(len);\\n            v[i]=true;\\n            arr.push_back(v);\\n        }\\n        for(int i=1;i<len;i++)\\n        {\\n            if(s[i-1]==s[i]){\\n                arr[i-1][i]=true;\\n                indexStart=i-1;\\n                indexEnd=i;\\n            }\\n            else\\n            arr[i-1][i]=false;\\n        }\\n        // cout<<indexStart<<\" \"<<indexEnd<<endl;\\n        int start=0;\\n        int end=2;\\n        while(end-start<=len)\\n        {\\n            while(end<len)\\n            {\\n                check(arr, start, end, s, indexStart, indexEnd);\\n                start++;\\n                end++;\\n            }\\n            int temp=end-start;\\n            temp++;\\n            start=0;\\n            end=temp;\\n        }\\n        string ans;\\n        for(int i=indexStart;i<=indexEnd;i++)\\n        {\\n            ans+=s[i];\\n        }\\n        // cout<<indexStart<<\" \"<<indexEnd<<endl;\\n        return ans;\\n    }\\n};`"
                    },
                    {
                        "username": "joshi248",
                        "content": "What is wrong here please tell\\n ```\\nclass Solution {\\npublic:\\n    bool isPalindrome(string strs){\\n        int n = strs.length();\\n        for(int i=0;i<n/2;++i){\\n            if(strs[i]!=strs[n-i-1]) return false;\\n        }\\n        return true;\\n    }\\n    string check(vector<string> &temp){\\n        string sruti = \"\";\\n        for(auto strs:temp){\\n            if(isPalindrome(strs)){\\n              if(strs.length() > sruti.length()) sruti = strs;\\n            }\\n        }\\n        return sruti;\\n    }\\n    string longestPalindrome(string s) {\\n        \\n        vector<string> temp;\\n        int n = s.length();\\n        if(n==1){\\n            if(isPalindrome(s)){\\n                return s;\\n            }\\n            return \"\";\\n        }\\n        for(int i=0;i<n;++i){\\n            for(int j=1;j<=n-i;++j){\\n                temp.push_back(s.substr(i,j));\\n            }\\n        }\\n        string ans = check(temp);\\n        return ans;\\n\\n\\n    }\\n};\\n```"
                    },
                    {
                        "username": "ayushi_828",
                        "content": "class Solution {\\n   int resultStart;\\n    int resultLength;\\n\\n    public String longestPalindrome(String s) {\\n        int strLength = s.length();\\n        if (strLength < 2) {\\n            return s;\\n        }\\n        for (int start = 0; start < strLength - 1; start++) {\\n            expandRange(s, start, start);\\n            expandRange(s, start, start + 1);\\n        }\\n        return s.substring(resultStart, resultStart + resultLength);\\n    }\\n\\n    private void expandRange(String str, int begin, int end) {\\n       while (begin >= 0 && end < str.length() &&\\n                    str.charAt(begin) == str.charAt(end)) {\\n            begin--;\\n            end++;\\n        }\\n       if (resultLength < end - begin - 1) {\\n            resultStart = begin + 1;\\n            resultLength = end - begin - 1;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sukriti_sinha7",
                        "content": "class Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n        string ans = \"\";\\n        for(int i = 0; i < s.length() ; i ++){\\n            string s1 = extend(s,i,i), s2 = extend(s, i, i+1);\\n\\n            if(s1.length() > ans.length()) ans = s1;\\n            if(s2.length() > ans.length()) ans = s2;\\n        }\\n\\n        return ans;\\n    }\\n\\n    string extend(string s, int left, int right){\\n        while(left >= 0 && right < s.length() && s[left] == s[right]){\\n            left--;\\n            right++;\\n        }\\n        return s.substr(left+1, right - left - 1);\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "utkarshv2619",
                        "content": "//easy solution:\\n\\nclass Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n        string res;\\n        int reslen = 0;\\n        \\n        if(s.size()<=1)\\n            return s; \\n        \\n        for(int i=0;i<s.size()-1;i++)\\n        {\\n            //odd length\\n            int l=i;\\n            int r=i;\\n            while(l>=0 && r<s.size() && s[l]==s[r])\\n            {\\n                if(r-l+1 > reslen  )\\n                {\\n                    res = s.substr(l, r-l+1);\\n                    reslen = r-l+1;\\n                }\\n                l--;\\n                r++;\\n            }\\n            //even length\\n            int L=i;\\n            int R=i+1;\\n            while(L>=0 && R<s.size() && s[L]==s[R])\\n            {\\n                if(R-L+1 > reslen)\\n                {\\n                    res = s.substr(L,R-L+1);\\n                    reslen = R-L+1;\\n                }\\n                L--;\\n                R++;\\n            }\\n        }\\n        return res;\\n    }\\n    \\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "//Easy rules.\n\n Discussion Rules\n1. Please don't post any solutions in this discussion.\n\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\n\n3. If you'd like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "codecat____",
                        "content": "I have \"Time Limit Exceeded\" problem here \nhow can i reduce running time in my code ?\n\ncode is given :\n\n\n\n\n\nclass Solution:\n    def longestPalindrome(self, s: str) -> str:\n        y=[]\n        x=[]\n        for i in range(len(s)):\n            for j in range(i+1,len(s)+1):\n                y.append(s[i:j])\n        for k in y:\n            if k == k[::-1]:\n                x.append(k)\n        w=[]\n        for v in x:\n            w.append(len(v))\n        if len(s)==1:\n            return s\n        for q in x:\n            if len(q)==max(w):\n                return(q)\n  "
                    },
                    {
                        "username": "noob-pika",
                        "content": "Check out the last two solutions in the solutions section of this question. The last one has a time complexity of O(n) but may take a while to understand whereas the second last one has a time complexity of O(n^2) but fairly easy"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@codecat____](/codecat____) Just use 2 pointer and reverse string that\\'s enough. I see that you have 5 loop in your algorithm!! It\\'s kind of too much, right?"
                    },
                    {
                        "username": "itanki3085",
                        "content": "Different result between LeetCode and my computer.\\nI got the result : `load of value 15, which is not a valid value for type \\'bool\\'`, but my code at that line is\\n```cpp\\ndp[from][to] = dp[from+1][to-1] && (s[from]==s[to]);\\n```\\nHow was that possible when I assign a boolean value into a address stores boolean value still get an error?\\nAt least it is not related to compiler. But what is the problem related to?"
                    },
                    {
                        "username": "Khudoyshukur",
                        "content": "Are we allowed to use class only? When I am writing without classes it is giving error: use of undeclared identifier \\'solution\\'. What should i do?"
                    }
                ]
            },
            {
                "id": 1722697,
                "content": [
                    {
                        "username": "Vinit_Anishkumar_Masrani",
                        "content": "When I submit, I get TLE error for the following test case:\nTime Limit Exceeded\nAnd it shows 141/141 testcases passed\nLast executed Input:\n s =\n\n\nWhat is the expected output for this testcase? And why is my code though passing big strings in testcase fails because of TLE in empty one."
                    },
                    {
                        "username": "DevPj09",
                        "content": "This is a bug. Happened with me too. I changed the browser and it worked. Might be due to network or cache.\\n"
                    },
                    {
                        "username": "TheCScience",
                        "content": "Here is problem solution in Java, Python, C++ and C programming.\\n[https://thecscience.com/leetcode-longest-palindromic-substring-problem-solution.html](https://thecscience.com/leetcode-longest-palindromic-substring-problem-solution.html)"
                    },
                    {
                        "username": "Shekhar_k_s",
                        "content": "My Solution was of O(n2) and final result is Time Limit Exceeded ( TLE ) . LOL \\uD83D\\uDE12\\n `void check(vector<vector<bool>> &v, int start, int end, string s, int &indexStart, int &indexEnd)\\n{\\n    if(s[start]==s[end])\\n    {\\n        if(v[start+1][end-1]==true)\\n        {\\n            v[start][end]=true;\\n            // cout<<start<<\" \"<<end<<endl;\\n            indexStart=start;\\n            indexEnd=end;\\n        }else\\n        {\\n            v[start][end]=false;\\n        }\\n    }\\n    else\\n    v[start][end]=false;\\n}\\n\\n\\n\\nclass Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n        int len=s.length();\\n        int indexStart=0;\\n        int indexEnd=0;\\n        vector<vector<bool>> arr;\\n        for(int i=0;i<len;i++)\\n        {\\n            vector<bool> v(len);\\n            v[i]=true;\\n            arr.push_back(v);\\n        }\\n        for(int i=1;i<len;i++)\\n        {\\n            if(s[i-1]==s[i]){\\n                arr[i-1][i]=true;\\n                indexStart=i-1;\\n                indexEnd=i;\\n            }\\n            else\\n            arr[i-1][i]=false;\\n        }\\n        // cout<<indexStart<<\" \"<<indexEnd<<endl;\\n        int start=0;\\n        int end=2;\\n        while(end-start<=len)\\n        {\\n            while(end<len)\\n            {\\n                check(arr, start, end, s, indexStart, indexEnd);\\n                start++;\\n                end++;\\n            }\\n            int temp=end-start;\\n            temp++;\\n            start=0;\\n            end=temp;\\n        }\\n        string ans;\\n        for(int i=indexStart;i<=indexEnd;i++)\\n        {\\n            ans+=s[i];\\n        }\\n        // cout<<indexStart<<\" \"<<indexEnd<<endl;\\n        return ans;\\n    }\\n};`"
                    },
                    {
                        "username": "joshi248",
                        "content": "What is wrong here please tell\\n ```\\nclass Solution {\\npublic:\\n    bool isPalindrome(string strs){\\n        int n = strs.length();\\n        for(int i=0;i<n/2;++i){\\n            if(strs[i]!=strs[n-i-1]) return false;\\n        }\\n        return true;\\n    }\\n    string check(vector<string> &temp){\\n        string sruti = \"\";\\n        for(auto strs:temp){\\n            if(isPalindrome(strs)){\\n              if(strs.length() > sruti.length()) sruti = strs;\\n            }\\n        }\\n        return sruti;\\n    }\\n    string longestPalindrome(string s) {\\n        \\n        vector<string> temp;\\n        int n = s.length();\\n        if(n==1){\\n            if(isPalindrome(s)){\\n                return s;\\n            }\\n            return \"\";\\n        }\\n        for(int i=0;i<n;++i){\\n            for(int j=1;j<=n-i;++j){\\n                temp.push_back(s.substr(i,j));\\n            }\\n        }\\n        string ans = check(temp);\\n        return ans;\\n\\n\\n    }\\n};\\n```"
                    },
                    {
                        "username": "ayushi_828",
                        "content": "class Solution {\\n   int resultStart;\\n    int resultLength;\\n\\n    public String longestPalindrome(String s) {\\n        int strLength = s.length();\\n        if (strLength < 2) {\\n            return s;\\n        }\\n        for (int start = 0; start < strLength - 1; start++) {\\n            expandRange(s, start, start);\\n            expandRange(s, start, start + 1);\\n        }\\n        return s.substring(resultStart, resultStart + resultLength);\\n    }\\n\\n    private void expandRange(String str, int begin, int end) {\\n       while (begin >= 0 && end < str.length() &&\\n                    str.charAt(begin) == str.charAt(end)) {\\n            begin--;\\n            end++;\\n        }\\n       if (resultLength < end - begin - 1) {\\n            resultStart = begin + 1;\\n            resultLength = end - begin - 1;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sukriti_sinha7",
                        "content": "class Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n        string ans = \"\";\\n        for(int i = 0; i < s.length() ; i ++){\\n            string s1 = extend(s,i,i), s2 = extend(s, i, i+1);\\n\\n            if(s1.length() > ans.length()) ans = s1;\\n            if(s2.length() > ans.length()) ans = s2;\\n        }\\n\\n        return ans;\\n    }\\n\\n    string extend(string s, int left, int right){\\n        while(left >= 0 && right < s.length() && s[left] == s[right]){\\n            left--;\\n            right++;\\n        }\\n        return s.substr(left+1, right - left - 1);\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "utkarshv2619",
                        "content": "//easy solution:\\n\\nclass Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n        string res;\\n        int reslen = 0;\\n        \\n        if(s.size()<=1)\\n            return s; \\n        \\n        for(int i=0;i<s.size()-1;i++)\\n        {\\n            //odd length\\n            int l=i;\\n            int r=i;\\n            while(l>=0 && r<s.size() && s[l]==s[r])\\n            {\\n                if(r-l+1 > reslen  )\\n                {\\n                    res = s.substr(l, r-l+1);\\n                    reslen = r-l+1;\\n                }\\n                l--;\\n                r++;\\n            }\\n            //even length\\n            int L=i;\\n            int R=i+1;\\n            while(L>=0 && R<s.size() && s[L]==s[R])\\n            {\\n                if(R-L+1 > reslen)\\n                {\\n                    res = s.substr(L,R-L+1);\\n                    reslen = R-L+1;\\n                }\\n                L--;\\n                R++;\\n            }\\n        }\\n        return res;\\n    }\\n    \\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "//Easy rules.\n\n Discussion Rules\n1. Please don't post any solutions in this discussion.\n\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\n\n3. If you'd like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "codecat____",
                        "content": "I have \"Time Limit Exceeded\" problem here \nhow can i reduce running time in my code ?\n\ncode is given :\n\n\n\n\n\nclass Solution:\n    def longestPalindrome(self, s: str) -> str:\n        y=[]\n        x=[]\n        for i in range(len(s)):\n            for j in range(i+1,len(s)+1):\n                y.append(s[i:j])\n        for k in y:\n            if k == k[::-1]:\n                x.append(k)\n        w=[]\n        for v in x:\n            w.append(len(v))\n        if len(s)==1:\n            return s\n        for q in x:\n            if len(q)==max(w):\n                return(q)\n  "
                    },
                    {
                        "username": "noob-pika",
                        "content": "Check out the last two solutions in the solutions section of this question. The last one has a time complexity of O(n) but may take a while to understand whereas the second last one has a time complexity of O(n^2) but fairly easy"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@codecat____](/codecat____) Just use 2 pointer and reverse string that\\'s enough. I see that you have 5 loop in your algorithm!! It\\'s kind of too much, right?"
                    },
                    {
                        "username": "itanki3085",
                        "content": "Different result between LeetCode and my computer.\\nI got the result : `load of value 15, which is not a valid value for type \\'bool\\'`, but my code at that line is\\n```cpp\\ndp[from][to] = dp[from+1][to-1] && (s[from]==s[to]);\\n```\\nHow was that possible when I assign a boolean value into a address stores boolean value still get an error?\\nAt least it is not related to compiler. But what is the problem related to?"
                    },
                    {
                        "username": "Khudoyshukur",
                        "content": "Are we allowed to use class only? When I am writing without classes it is giving error: use of undeclared identifier \\'solution\\'. What should i do?"
                    }
                ]
            },
            {
                "id": 1719480,
                "content": [
                    {
                        "username": "Vinit_Anishkumar_Masrani",
                        "content": "When I submit, I get TLE error for the following test case:\nTime Limit Exceeded\nAnd it shows 141/141 testcases passed\nLast executed Input:\n s =\n\n\nWhat is the expected output for this testcase? And why is my code though passing big strings in testcase fails because of TLE in empty one."
                    },
                    {
                        "username": "DevPj09",
                        "content": "This is a bug. Happened with me too. I changed the browser and it worked. Might be due to network or cache.\\n"
                    },
                    {
                        "username": "TheCScience",
                        "content": "Here is problem solution in Java, Python, C++ and C programming.\\n[https://thecscience.com/leetcode-longest-palindromic-substring-problem-solution.html](https://thecscience.com/leetcode-longest-palindromic-substring-problem-solution.html)"
                    },
                    {
                        "username": "Shekhar_k_s",
                        "content": "My Solution was of O(n2) and final result is Time Limit Exceeded ( TLE ) . LOL \\uD83D\\uDE12\\n `void check(vector<vector<bool>> &v, int start, int end, string s, int &indexStart, int &indexEnd)\\n{\\n    if(s[start]==s[end])\\n    {\\n        if(v[start+1][end-1]==true)\\n        {\\n            v[start][end]=true;\\n            // cout<<start<<\" \"<<end<<endl;\\n            indexStart=start;\\n            indexEnd=end;\\n        }else\\n        {\\n            v[start][end]=false;\\n        }\\n    }\\n    else\\n    v[start][end]=false;\\n}\\n\\n\\n\\nclass Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n        int len=s.length();\\n        int indexStart=0;\\n        int indexEnd=0;\\n        vector<vector<bool>> arr;\\n        for(int i=0;i<len;i++)\\n        {\\n            vector<bool> v(len);\\n            v[i]=true;\\n            arr.push_back(v);\\n        }\\n        for(int i=1;i<len;i++)\\n        {\\n            if(s[i-1]==s[i]){\\n                arr[i-1][i]=true;\\n                indexStart=i-1;\\n                indexEnd=i;\\n            }\\n            else\\n            arr[i-1][i]=false;\\n        }\\n        // cout<<indexStart<<\" \"<<indexEnd<<endl;\\n        int start=0;\\n        int end=2;\\n        while(end-start<=len)\\n        {\\n            while(end<len)\\n            {\\n                check(arr, start, end, s, indexStart, indexEnd);\\n                start++;\\n                end++;\\n            }\\n            int temp=end-start;\\n            temp++;\\n            start=0;\\n            end=temp;\\n        }\\n        string ans;\\n        for(int i=indexStart;i<=indexEnd;i++)\\n        {\\n            ans+=s[i];\\n        }\\n        // cout<<indexStart<<\" \"<<indexEnd<<endl;\\n        return ans;\\n    }\\n};`"
                    },
                    {
                        "username": "joshi248",
                        "content": "What is wrong here please tell\\n ```\\nclass Solution {\\npublic:\\n    bool isPalindrome(string strs){\\n        int n = strs.length();\\n        for(int i=0;i<n/2;++i){\\n            if(strs[i]!=strs[n-i-1]) return false;\\n        }\\n        return true;\\n    }\\n    string check(vector<string> &temp){\\n        string sruti = \"\";\\n        for(auto strs:temp){\\n            if(isPalindrome(strs)){\\n              if(strs.length() > sruti.length()) sruti = strs;\\n            }\\n        }\\n        return sruti;\\n    }\\n    string longestPalindrome(string s) {\\n        \\n        vector<string> temp;\\n        int n = s.length();\\n        if(n==1){\\n            if(isPalindrome(s)){\\n                return s;\\n            }\\n            return \"\";\\n        }\\n        for(int i=0;i<n;++i){\\n            for(int j=1;j<=n-i;++j){\\n                temp.push_back(s.substr(i,j));\\n            }\\n        }\\n        string ans = check(temp);\\n        return ans;\\n\\n\\n    }\\n};\\n```"
                    },
                    {
                        "username": "ayushi_828",
                        "content": "class Solution {\\n   int resultStart;\\n    int resultLength;\\n\\n    public String longestPalindrome(String s) {\\n        int strLength = s.length();\\n        if (strLength < 2) {\\n            return s;\\n        }\\n        for (int start = 0; start < strLength - 1; start++) {\\n            expandRange(s, start, start);\\n            expandRange(s, start, start + 1);\\n        }\\n        return s.substring(resultStart, resultStart + resultLength);\\n    }\\n\\n    private void expandRange(String str, int begin, int end) {\\n       while (begin >= 0 && end < str.length() &&\\n                    str.charAt(begin) == str.charAt(end)) {\\n            begin--;\\n            end++;\\n        }\\n       if (resultLength < end - begin - 1) {\\n            resultStart = begin + 1;\\n            resultLength = end - begin - 1;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "sukriti_sinha7",
                        "content": "class Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n        string ans = \"\";\\n        for(int i = 0; i < s.length() ; i ++){\\n            string s1 = extend(s,i,i), s2 = extend(s, i, i+1);\\n\\n            if(s1.length() > ans.length()) ans = s1;\\n            if(s2.length() > ans.length()) ans = s2;\\n        }\\n\\n        return ans;\\n    }\\n\\n    string extend(string s, int left, int right){\\n        while(left >= 0 && right < s.length() && s[left] == s[right]){\\n            left--;\\n            right++;\\n        }\\n        return s.substr(left+1, right - left - 1);\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "utkarshv2619",
                        "content": "//easy solution:\\n\\nclass Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n        string res;\\n        int reslen = 0;\\n        \\n        if(s.size()<=1)\\n            return s; \\n        \\n        for(int i=0;i<s.size()-1;i++)\\n        {\\n            //odd length\\n            int l=i;\\n            int r=i;\\n            while(l>=0 && r<s.size() && s[l]==s[r])\\n            {\\n                if(r-l+1 > reslen  )\\n                {\\n                    res = s.substr(l, r-l+1);\\n                    reslen = r-l+1;\\n                }\\n                l--;\\n                r++;\\n            }\\n            //even length\\n            int L=i;\\n            int R=i+1;\\n            while(L>=0 && R<s.size() && s[L]==s[R])\\n            {\\n                if(R-L+1 > reslen)\\n                {\\n                    res = s.substr(L,R-L+1);\\n                    reslen = R-L+1;\\n                }\\n                L--;\\n                R++;\\n            }\\n        }\\n        return res;\\n    }\\n    \\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "//Easy rules.\n\n Discussion Rules\n1. Please don't post any solutions in this discussion.\n\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\n\n3. If you'd like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "codecat____",
                        "content": "I have \"Time Limit Exceeded\" problem here \nhow can i reduce running time in my code ?\n\ncode is given :\n\n\n\n\n\nclass Solution:\n    def longestPalindrome(self, s: str) -> str:\n        y=[]\n        x=[]\n        for i in range(len(s)):\n            for j in range(i+1,len(s)+1):\n                y.append(s[i:j])\n        for k in y:\n            if k == k[::-1]:\n                x.append(k)\n        w=[]\n        for v in x:\n            w.append(len(v))\n        if len(s)==1:\n            return s\n        for q in x:\n            if len(q)==max(w):\n                return(q)\n  "
                    },
                    {
                        "username": "noob-pika",
                        "content": "Check out the last two solutions in the solutions section of this question. The last one has a time complexity of O(n) but may take a while to understand whereas the second last one has a time complexity of O(n^2) but fairly easy"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@codecat____](/codecat____) Just use 2 pointer and reverse string that\\'s enough. I see that you have 5 loop in your algorithm!! It\\'s kind of too much, right?"
                    },
                    {
                        "username": "itanki3085",
                        "content": "Different result between LeetCode and my computer.\\nI got the result : `load of value 15, which is not a valid value for type \\'bool\\'`, but my code at that line is\\n```cpp\\ndp[from][to] = dp[from+1][to-1] && (s[from]==s[to]);\\n```\\nHow was that possible when I assign a boolean value into a address stores boolean value still get an error?\\nAt least it is not related to compiler. But what is the problem related to?"
                    },
                    {
                        "username": "Khudoyshukur",
                        "content": "Are we allowed to use class only? When I am writing without classes it is giving error: use of undeclared identifier \\'solution\\'. What should i do?"
                    }
                ]
            },
            {
                "id": 1719446,
                "content": [
                    {
                        "username": "divyaxreddy",
                        "content": "NICK WHITE'S code in C++ not working, can u please help?\n\n \n    string longestPalindrome(string s) {\n        int lenOfString = s.length();\n        int start = 0, end = 0;\n       for(int i = 0; i<lenOfString; i++){\n           int len1 = expandFromMid(s, i, i);\n           int len2 = expandFromMid(s, i, i+1);\n\n           int maxlength = max(len1, len2);\n           //check if maxLength is > old length\n           if(maxlength > (end - start)){\n                start = i - ((maxlength-1)/2);\n                end = i + (maxlength/2);\n           }\n       }\n       return s.substr(start, end+1);\n    }\n\n    int expandFromMid(string& s, int i, int j){\n        if( left > right) return 0;\n        int left = i, right = j;\n        while(left >=0 && right <s.length() && (s[left] == s[right])){\n            left--;\n            right++;\n        }\n\n        return right - left + 1;\n    }\n};`"
                    },
                    {
                        "username": "BaconChef",
                        "content": "[HELP]  \\nHow is \\nInput: s = \"babad\"\\nOutput: \"bab\"\\n\\n\"badab\" or \"abdba\" is both palindromic (the same read forwards and backwards) and a substring. And its obviously longer than \"bab\". For that matter, why isn\\'t \"baab\" accepted?\\n\\nMy definitions:\\nA palindrome is a string that is the same if it\\'s read forward and backward.\\nA substring is a string that rearranges or omits characters of a string."
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@BaconChef](/BaconChef)\nHello, let's see your substring definition? \nGiven:\ns = \"babad\"\n\nSubstring palindromic: any characters \"a\", \"b\", \"d\", and \"bab\", \"aba\".\nBut \"baab\" is not a substring of s!"
                    },
                    {
                        "username": "zuratvaradze999",
                        "content": "swift"
                    },
                    {
                        "username": "Violet-",
                        "content": "Could anybody please explain what does this sentence mean (by an example) in the first solution with Longest common subsequence? \"To rectify this, each time we find a longest common substring candidate, we check if the substring\\u2019s indices are the same as the reversed substring\\u2019s original indices.\""
                    },
                    {
                        "username": "parialxx",
                        "content": "Does anyone understand why do I get this error message in the Longest Palindromic substring problem?\n\n\nAddressSanitizer:DEADLYSIGNAL 31\nERROR: AddressSanitizer: SEGV on unknown address 0x7ffd1cc2ec5f (pc 0x0000003447b6 bp 0x7ffc1cc2eab0 sp 0x7ffc1cc2ea90 T0)\n==31==The signal is caused by a READ memory access.\n    #4 0x7fb759d300b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\nAddressSanitizer can not provide additional info.\n31 ABORTING\n\n\nThis is my code...\n\n`#include <string>\n#include <iostream>\n\nusing namespace std;\n\nclass Solution {\npublic:\n\n    string expandString(string s, unsigned int l, unsigned int r) {\n        while(l >= 0 && r < s.size() && s[l] == s[r]) {\n            l--;\n            r++;\n        }\n        return s.substr(l+1, r-(l+1));\n    }\n\n    string longestPalindrome(string s) {\n        string odd = \"\";\n        string even = \"\";\n        string res = \"\";\n\n        for(unsigned int i = 0; i < s.size(); i++) {\n            even = expandString(s, i, i+1);\n            odd = expandString(s, i, i);\n            \n            if(even.size() > res.size()) {\n                res = even;\n            }\n            if(odd.size() > res.size()) {\n                res = odd;\n            }\n        }\n        return res;\n    }\n\n};`"
                    },
                    {
                        "username": "dnd_Hyani69",
                        "content": "//Simple CPP Soluion//\\n\\nclass Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n       int maxlen=1,start=0;\\n     for(int i=1;i<s.length();i++){//1 se chlao\\n         //that is even substring\\n         int l=i-1;\\n         int r=i;\\n         \\n         while(l >= 0 && r<s.length() && s[l]==s[r]){//l chota ho r bada ho and l==r ho bss\\n             if(r-l+1 > maxlen) {\\n             maxlen=r-l+1;\\n              start=l;\\n             }\\n        l--;\\n        r++;\\n         }\\n      //for odd substring \\n       l=i-1;\\n       r=i+1;\\n     \\n     while(l >=0 && r<s.length() && s[l]==s[r]){\\n         if(r-l+1 > maxlen){\\n         maxlen=r-l+1;\\n         start=l;\\n         }\\n         l--;\\n         r++;\\n     }\\n     }\\n     return s.substr(start, maxlen);\\n    }\\n}; "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Simple rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "meetfarhanali",
                        "content": "The leetcode problems sucks. This is my 2nd problem and i see the description is not right. \\nFor babac the longest palindrom will be \"baba\"=\"abab\". I will switch to HRank problems as they make more sense"
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "\"baba\" is not a palendrome.\n\nA Palendrome is a series of characters that is the same forwards and backwards.\n\n\"baba\" backwards is \"abab\". \"baba\" != \"abab\". Thus, \"baba\" is not a palendrome.\n\nTry an easier problem. 125. Valid Palindrome\nhttps://leetcode.com/problems/valid-palindrome/\n"
                    },
                    {
                        "username": "Navin152",
                        "content": "\\nmy code is not working in java can anyone explain please why this code is not working\\n\\nclass Solution {\\n    public String longestPalindrome(String s) {\\n        int n=s.length();\\n        int low,high;\\n        int st=0;\\n        int len=1;\\n        for(int i=1;i<n;i++){\\n            //Even\\n            low=i;\\n            high=i-1;\\n            while(low>=0 && high <n && s[low] == s[high]){\\n                if(high-low+1>len){\\n                    st=low;\\n                    len = high-low+1;\\n                }\\n                low--;high++;\\n                }\\n         //odd\\n            low=i-1;\\n            high=i+1;\\n            while(low>=0 && high<n &&s.charAt(low)== s.charAt(high)){\\n                {\\n                    if(high-low+1>len){\\n                        st=low;\\n                        len= high-low+1;\\n                        }\\n                     low--;\\n                     high++;\\n}\\n}\\n               return  s.substring(st,len);\\n                }   \\n            } \\n           \\n\\n    \\n        \\n\\n"
                    },
                    {
                        "username": "Rajdip_234",
                        "content": " Hi, in this program first we divide the string one is even length and another is odd length and we pass parameter using one function that is string and middle point value then we check the length in both string . If the difference between end and start is less than length of string then we should update start and end value and return the substring value. then again we pass parameter in function which we will declare as our wish and pass string , i value , j value . taking while loop the put the condition i greater than or equals to zero and j should be less than the length of string and the ith value of string is equals to the jth value of string then i will be decremented and j incremented and finally return the value that is (j-i+1)."
                    },
                    {
                        "username": "allgameaimbotall",
                        "content": "Hi I haven't studied Dynamic Programming till now but learned a littlebit about memoization. I tried to solve this problem with recursion + adding memoization .\n\nCode gives exactly what we want but off-course Time-Limit issues.\n\nJust want to ask where does this approach fail?\n\n`\ndp = {}\ndef longestPalindrome(self, s: str) -> str:\nif self.dp.get(s) != None:\n    return self.dp[s]\n\n#TRACKERS\nlenStr = len(s)\n\n#BASE\nif lenStr == 1:\n    self.dp[s] = s\n    return s\n\nif s == s[::-1]:\n    self.dp[s] = s\n    return s\nelse:\n    lp_inleft = self.longestPalindrome(s[1:])\n    lp_inright = self.longestPalindrome(s[:lenStr-1])\n    ans = max(lp_inleft,lp_inright,key=len)\n    self.dp[s] = ans\n    return ans\n        `\n\n        "
                    }
                ]
            },
            {
                "id": 1718435,
                "content": [
                    {
                        "username": "divyaxreddy",
                        "content": "NICK WHITE'S code in C++ not working, can u please help?\n\n \n    string longestPalindrome(string s) {\n        int lenOfString = s.length();\n        int start = 0, end = 0;\n       for(int i = 0; i<lenOfString; i++){\n           int len1 = expandFromMid(s, i, i);\n           int len2 = expandFromMid(s, i, i+1);\n\n           int maxlength = max(len1, len2);\n           //check if maxLength is > old length\n           if(maxlength > (end - start)){\n                start = i - ((maxlength-1)/2);\n                end = i + (maxlength/2);\n           }\n       }\n       return s.substr(start, end+1);\n    }\n\n    int expandFromMid(string& s, int i, int j){\n        if( left > right) return 0;\n        int left = i, right = j;\n        while(left >=0 && right <s.length() && (s[left] == s[right])){\n            left--;\n            right++;\n        }\n\n        return right - left + 1;\n    }\n};`"
                    },
                    {
                        "username": "BaconChef",
                        "content": "[HELP]  \\nHow is \\nInput: s = \"babad\"\\nOutput: \"bab\"\\n\\n\"badab\" or \"abdba\" is both palindromic (the same read forwards and backwards) and a substring. And its obviously longer than \"bab\". For that matter, why isn\\'t \"baab\" accepted?\\n\\nMy definitions:\\nA palindrome is a string that is the same if it\\'s read forward and backward.\\nA substring is a string that rearranges or omits characters of a string."
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@BaconChef](/BaconChef)\nHello, let's see your substring definition? \nGiven:\ns = \"babad\"\n\nSubstring palindromic: any characters \"a\", \"b\", \"d\", and \"bab\", \"aba\".\nBut \"baab\" is not a substring of s!"
                    },
                    {
                        "username": "zuratvaradze999",
                        "content": "swift"
                    },
                    {
                        "username": "Violet-",
                        "content": "Could anybody please explain what does this sentence mean (by an example) in the first solution with Longest common subsequence? \"To rectify this, each time we find a longest common substring candidate, we check if the substring\\u2019s indices are the same as the reversed substring\\u2019s original indices.\""
                    },
                    {
                        "username": "parialxx",
                        "content": "Does anyone understand why do I get this error message in the Longest Palindromic substring problem?\n\n\nAddressSanitizer:DEADLYSIGNAL 31\nERROR: AddressSanitizer: SEGV on unknown address 0x7ffd1cc2ec5f (pc 0x0000003447b6 bp 0x7ffc1cc2eab0 sp 0x7ffc1cc2ea90 T0)\n==31==The signal is caused by a READ memory access.\n    #4 0x7fb759d300b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\nAddressSanitizer can not provide additional info.\n31 ABORTING\n\n\nThis is my code...\n\n`#include <string>\n#include <iostream>\n\nusing namespace std;\n\nclass Solution {\npublic:\n\n    string expandString(string s, unsigned int l, unsigned int r) {\n        while(l >= 0 && r < s.size() && s[l] == s[r]) {\n            l--;\n            r++;\n        }\n        return s.substr(l+1, r-(l+1));\n    }\n\n    string longestPalindrome(string s) {\n        string odd = \"\";\n        string even = \"\";\n        string res = \"\";\n\n        for(unsigned int i = 0; i < s.size(); i++) {\n            even = expandString(s, i, i+1);\n            odd = expandString(s, i, i);\n            \n            if(even.size() > res.size()) {\n                res = even;\n            }\n            if(odd.size() > res.size()) {\n                res = odd;\n            }\n        }\n        return res;\n    }\n\n};`"
                    },
                    {
                        "username": "dnd_Hyani69",
                        "content": "//Simple CPP Soluion//\\n\\nclass Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n       int maxlen=1,start=0;\\n     for(int i=1;i<s.length();i++){//1 se chlao\\n         //that is even substring\\n         int l=i-1;\\n         int r=i;\\n         \\n         while(l >= 0 && r<s.length() && s[l]==s[r]){//l chota ho r bada ho and l==r ho bss\\n             if(r-l+1 > maxlen) {\\n             maxlen=r-l+1;\\n              start=l;\\n             }\\n        l--;\\n        r++;\\n         }\\n      //for odd substring \\n       l=i-1;\\n       r=i+1;\\n     \\n     while(l >=0 && r<s.length() && s[l]==s[r]){\\n         if(r-l+1 > maxlen){\\n         maxlen=r-l+1;\\n         start=l;\\n         }\\n         l--;\\n         r++;\\n     }\\n     }\\n     return s.substr(start, maxlen);\\n    }\\n}; "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Simple rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "meetfarhanali",
                        "content": "The leetcode problems sucks. This is my 2nd problem and i see the description is not right. \\nFor babac the longest palindrom will be \"baba\"=\"abab\". I will switch to HRank problems as they make more sense"
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "\"baba\" is not a palendrome.\n\nA Palendrome is a series of characters that is the same forwards and backwards.\n\n\"baba\" backwards is \"abab\". \"baba\" != \"abab\". Thus, \"baba\" is not a palendrome.\n\nTry an easier problem. 125. Valid Palindrome\nhttps://leetcode.com/problems/valid-palindrome/\n"
                    },
                    {
                        "username": "Navin152",
                        "content": "\\nmy code is not working in java can anyone explain please why this code is not working\\n\\nclass Solution {\\n    public String longestPalindrome(String s) {\\n        int n=s.length();\\n        int low,high;\\n        int st=0;\\n        int len=1;\\n        for(int i=1;i<n;i++){\\n            //Even\\n            low=i;\\n            high=i-1;\\n            while(low>=0 && high <n && s[low] == s[high]){\\n                if(high-low+1>len){\\n                    st=low;\\n                    len = high-low+1;\\n                }\\n                low--;high++;\\n                }\\n         //odd\\n            low=i-1;\\n            high=i+1;\\n            while(low>=0 && high<n &&s.charAt(low)== s.charAt(high)){\\n                {\\n                    if(high-low+1>len){\\n                        st=low;\\n                        len= high-low+1;\\n                        }\\n                     low--;\\n                     high++;\\n}\\n}\\n               return  s.substring(st,len);\\n                }   \\n            } \\n           \\n\\n    \\n        \\n\\n"
                    },
                    {
                        "username": "Rajdip_234",
                        "content": " Hi, in this program first we divide the string one is even length and another is odd length and we pass parameter using one function that is string and middle point value then we check the length in both string . If the difference between end and start is less than length of string then we should update start and end value and return the substring value. then again we pass parameter in function which we will declare as our wish and pass string , i value , j value . taking while loop the put the condition i greater than or equals to zero and j should be less than the length of string and the ith value of string is equals to the jth value of string then i will be decremented and j incremented and finally return the value that is (j-i+1)."
                    },
                    {
                        "username": "allgameaimbotall",
                        "content": "Hi I haven't studied Dynamic Programming till now but learned a littlebit about memoization. I tried to solve this problem with recursion + adding memoization .\n\nCode gives exactly what we want but off-course Time-Limit issues.\n\nJust want to ask where does this approach fail?\n\n`\ndp = {}\ndef longestPalindrome(self, s: str) -> str:\nif self.dp.get(s) != None:\n    return self.dp[s]\n\n#TRACKERS\nlenStr = len(s)\n\n#BASE\nif lenStr == 1:\n    self.dp[s] = s\n    return s\n\nif s == s[::-1]:\n    self.dp[s] = s\n    return s\nelse:\n    lp_inleft = self.longestPalindrome(s[1:])\n    lp_inright = self.longestPalindrome(s[:lenStr-1])\n    ans = max(lp_inleft,lp_inright,key=len)\n    self.dp[s] = ans\n    return ans\n        `\n\n        "
                    }
                ]
            },
            {
                "id": 1716422,
                "content": [
                    {
                        "username": "divyaxreddy",
                        "content": "NICK WHITE'S code in C++ not working, can u please help?\n\n \n    string longestPalindrome(string s) {\n        int lenOfString = s.length();\n        int start = 0, end = 0;\n       for(int i = 0; i<lenOfString; i++){\n           int len1 = expandFromMid(s, i, i);\n           int len2 = expandFromMid(s, i, i+1);\n\n           int maxlength = max(len1, len2);\n           //check if maxLength is > old length\n           if(maxlength > (end - start)){\n                start = i - ((maxlength-1)/2);\n                end = i + (maxlength/2);\n           }\n       }\n       return s.substr(start, end+1);\n    }\n\n    int expandFromMid(string& s, int i, int j){\n        if( left > right) return 0;\n        int left = i, right = j;\n        while(left >=0 && right <s.length() && (s[left] == s[right])){\n            left--;\n            right++;\n        }\n\n        return right - left + 1;\n    }\n};`"
                    },
                    {
                        "username": "BaconChef",
                        "content": "[HELP]  \\nHow is \\nInput: s = \"babad\"\\nOutput: \"bab\"\\n\\n\"badab\" or \"abdba\" is both palindromic (the same read forwards and backwards) and a substring. And its obviously longer than \"bab\". For that matter, why isn\\'t \"baab\" accepted?\\n\\nMy definitions:\\nA palindrome is a string that is the same if it\\'s read forward and backward.\\nA substring is a string that rearranges or omits characters of a string."
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@BaconChef](/BaconChef)\nHello, let's see your substring definition? \nGiven:\ns = \"babad\"\n\nSubstring palindromic: any characters \"a\", \"b\", \"d\", and \"bab\", \"aba\".\nBut \"baab\" is not a substring of s!"
                    },
                    {
                        "username": "zuratvaradze999",
                        "content": "swift"
                    },
                    {
                        "username": "Violet-",
                        "content": "Could anybody please explain what does this sentence mean (by an example) in the first solution with Longest common subsequence? \"To rectify this, each time we find a longest common substring candidate, we check if the substring\\u2019s indices are the same as the reversed substring\\u2019s original indices.\""
                    },
                    {
                        "username": "parialxx",
                        "content": "Does anyone understand why do I get this error message in the Longest Palindromic substring problem?\n\n\nAddressSanitizer:DEADLYSIGNAL 31\nERROR: AddressSanitizer: SEGV on unknown address 0x7ffd1cc2ec5f (pc 0x0000003447b6 bp 0x7ffc1cc2eab0 sp 0x7ffc1cc2ea90 T0)\n==31==The signal is caused by a READ memory access.\n    #4 0x7fb759d300b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\nAddressSanitizer can not provide additional info.\n31 ABORTING\n\n\nThis is my code...\n\n`#include <string>\n#include <iostream>\n\nusing namespace std;\n\nclass Solution {\npublic:\n\n    string expandString(string s, unsigned int l, unsigned int r) {\n        while(l >= 0 && r < s.size() && s[l] == s[r]) {\n            l--;\n            r++;\n        }\n        return s.substr(l+1, r-(l+1));\n    }\n\n    string longestPalindrome(string s) {\n        string odd = \"\";\n        string even = \"\";\n        string res = \"\";\n\n        for(unsigned int i = 0; i < s.size(); i++) {\n            even = expandString(s, i, i+1);\n            odd = expandString(s, i, i);\n            \n            if(even.size() > res.size()) {\n                res = even;\n            }\n            if(odd.size() > res.size()) {\n                res = odd;\n            }\n        }\n        return res;\n    }\n\n};`"
                    },
                    {
                        "username": "dnd_Hyani69",
                        "content": "//Simple CPP Soluion//\\n\\nclass Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n       int maxlen=1,start=0;\\n     for(int i=1;i<s.length();i++){//1 se chlao\\n         //that is even substring\\n         int l=i-1;\\n         int r=i;\\n         \\n         while(l >= 0 && r<s.length() && s[l]==s[r]){//l chota ho r bada ho and l==r ho bss\\n             if(r-l+1 > maxlen) {\\n             maxlen=r-l+1;\\n              start=l;\\n             }\\n        l--;\\n        r++;\\n         }\\n      //for odd substring \\n       l=i-1;\\n       r=i+1;\\n     \\n     while(l >=0 && r<s.length() && s[l]==s[r]){\\n         if(r-l+1 > maxlen){\\n         maxlen=r-l+1;\\n         start=l;\\n         }\\n         l--;\\n         r++;\\n     }\\n     }\\n     return s.substr(start, maxlen);\\n    }\\n}; "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Simple rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "meetfarhanali",
                        "content": "The leetcode problems sucks. This is my 2nd problem and i see the description is not right. \\nFor babac the longest palindrom will be \"baba\"=\"abab\". I will switch to HRank problems as they make more sense"
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "\"baba\" is not a palendrome.\n\nA Palendrome is a series of characters that is the same forwards and backwards.\n\n\"baba\" backwards is \"abab\". \"baba\" != \"abab\". Thus, \"baba\" is not a palendrome.\n\nTry an easier problem. 125. Valid Palindrome\nhttps://leetcode.com/problems/valid-palindrome/\n"
                    },
                    {
                        "username": "Navin152",
                        "content": "\\nmy code is not working in java can anyone explain please why this code is not working\\n\\nclass Solution {\\n    public String longestPalindrome(String s) {\\n        int n=s.length();\\n        int low,high;\\n        int st=0;\\n        int len=1;\\n        for(int i=1;i<n;i++){\\n            //Even\\n            low=i;\\n            high=i-1;\\n            while(low>=0 && high <n && s[low] == s[high]){\\n                if(high-low+1>len){\\n                    st=low;\\n                    len = high-low+1;\\n                }\\n                low--;high++;\\n                }\\n         //odd\\n            low=i-1;\\n            high=i+1;\\n            while(low>=0 && high<n &&s.charAt(low)== s.charAt(high)){\\n                {\\n                    if(high-low+1>len){\\n                        st=low;\\n                        len= high-low+1;\\n                        }\\n                     low--;\\n                     high++;\\n}\\n}\\n               return  s.substring(st,len);\\n                }   \\n            } \\n           \\n\\n    \\n        \\n\\n"
                    },
                    {
                        "username": "Rajdip_234",
                        "content": " Hi, in this program first we divide the string one is even length and another is odd length and we pass parameter using one function that is string and middle point value then we check the length in both string . If the difference between end and start is less than length of string then we should update start and end value and return the substring value. then again we pass parameter in function which we will declare as our wish and pass string , i value , j value . taking while loop the put the condition i greater than or equals to zero and j should be less than the length of string and the ith value of string is equals to the jth value of string then i will be decremented and j incremented and finally return the value that is (j-i+1)."
                    },
                    {
                        "username": "allgameaimbotall",
                        "content": "Hi I haven't studied Dynamic Programming till now but learned a littlebit about memoization. I tried to solve this problem with recursion + adding memoization .\n\nCode gives exactly what we want but off-course Time-Limit issues.\n\nJust want to ask where does this approach fail?\n\n`\ndp = {}\ndef longestPalindrome(self, s: str) -> str:\nif self.dp.get(s) != None:\n    return self.dp[s]\n\n#TRACKERS\nlenStr = len(s)\n\n#BASE\nif lenStr == 1:\n    self.dp[s] = s\n    return s\n\nif s == s[::-1]:\n    self.dp[s] = s\n    return s\nelse:\n    lp_inleft = self.longestPalindrome(s[1:])\n    lp_inright = self.longestPalindrome(s[:lenStr-1])\n    ans = max(lp_inleft,lp_inright,key=len)\n    self.dp[s] = ans\n    return ans\n        `\n\n        "
                    }
                ]
            },
            {
                "id": 1715631,
                "content": [
                    {
                        "username": "divyaxreddy",
                        "content": "NICK WHITE'S code in C++ not working, can u please help?\n\n \n    string longestPalindrome(string s) {\n        int lenOfString = s.length();\n        int start = 0, end = 0;\n       for(int i = 0; i<lenOfString; i++){\n           int len1 = expandFromMid(s, i, i);\n           int len2 = expandFromMid(s, i, i+1);\n\n           int maxlength = max(len1, len2);\n           //check if maxLength is > old length\n           if(maxlength > (end - start)){\n                start = i - ((maxlength-1)/2);\n                end = i + (maxlength/2);\n           }\n       }\n       return s.substr(start, end+1);\n    }\n\n    int expandFromMid(string& s, int i, int j){\n        if( left > right) return 0;\n        int left = i, right = j;\n        while(left >=0 && right <s.length() && (s[left] == s[right])){\n            left--;\n            right++;\n        }\n\n        return right - left + 1;\n    }\n};`"
                    },
                    {
                        "username": "BaconChef",
                        "content": "[HELP]  \\nHow is \\nInput: s = \"babad\"\\nOutput: \"bab\"\\n\\n\"badab\" or \"abdba\" is both palindromic (the same read forwards and backwards) and a substring. And its obviously longer than \"bab\". For that matter, why isn\\'t \"baab\" accepted?\\n\\nMy definitions:\\nA palindrome is a string that is the same if it\\'s read forward and backward.\\nA substring is a string that rearranges or omits characters of a string."
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@BaconChef](/BaconChef)\nHello, let's see your substring definition? \nGiven:\ns = \"babad\"\n\nSubstring palindromic: any characters \"a\", \"b\", \"d\", and \"bab\", \"aba\".\nBut \"baab\" is not a substring of s!"
                    },
                    {
                        "username": "zuratvaradze999",
                        "content": "swift"
                    },
                    {
                        "username": "Violet-",
                        "content": "Could anybody please explain what does this sentence mean (by an example) in the first solution with Longest common subsequence? \"To rectify this, each time we find a longest common substring candidate, we check if the substring\\u2019s indices are the same as the reversed substring\\u2019s original indices.\""
                    },
                    {
                        "username": "parialxx",
                        "content": "Does anyone understand why do I get this error message in the Longest Palindromic substring problem?\n\n\nAddressSanitizer:DEADLYSIGNAL 31\nERROR: AddressSanitizer: SEGV on unknown address 0x7ffd1cc2ec5f (pc 0x0000003447b6 bp 0x7ffc1cc2eab0 sp 0x7ffc1cc2ea90 T0)\n==31==The signal is caused by a READ memory access.\n    #4 0x7fb759d300b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\nAddressSanitizer can not provide additional info.\n31 ABORTING\n\n\nThis is my code...\n\n`#include <string>\n#include <iostream>\n\nusing namespace std;\n\nclass Solution {\npublic:\n\n    string expandString(string s, unsigned int l, unsigned int r) {\n        while(l >= 0 && r < s.size() && s[l] == s[r]) {\n            l--;\n            r++;\n        }\n        return s.substr(l+1, r-(l+1));\n    }\n\n    string longestPalindrome(string s) {\n        string odd = \"\";\n        string even = \"\";\n        string res = \"\";\n\n        for(unsigned int i = 0; i < s.size(); i++) {\n            even = expandString(s, i, i+1);\n            odd = expandString(s, i, i);\n            \n            if(even.size() > res.size()) {\n                res = even;\n            }\n            if(odd.size() > res.size()) {\n                res = odd;\n            }\n        }\n        return res;\n    }\n\n};`"
                    },
                    {
                        "username": "dnd_Hyani69",
                        "content": "//Simple CPP Soluion//\\n\\nclass Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n       int maxlen=1,start=0;\\n     for(int i=1;i<s.length();i++){//1 se chlao\\n         //that is even substring\\n         int l=i-1;\\n         int r=i;\\n         \\n         while(l >= 0 && r<s.length() && s[l]==s[r]){//l chota ho r bada ho and l==r ho bss\\n             if(r-l+1 > maxlen) {\\n             maxlen=r-l+1;\\n              start=l;\\n             }\\n        l--;\\n        r++;\\n         }\\n      //for odd substring \\n       l=i-1;\\n       r=i+1;\\n     \\n     while(l >=0 && r<s.length() && s[l]==s[r]){\\n         if(r-l+1 > maxlen){\\n         maxlen=r-l+1;\\n         start=l;\\n         }\\n         l--;\\n         r++;\\n     }\\n     }\\n     return s.substr(start, maxlen);\\n    }\\n}; "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Simple rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "meetfarhanali",
                        "content": "The leetcode problems sucks. This is my 2nd problem and i see the description is not right. \\nFor babac the longest palindrom will be \"baba\"=\"abab\". I will switch to HRank problems as they make more sense"
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "\"baba\" is not a palendrome.\n\nA Palendrome is a series of characters that is the same forwards and backwards.\n\n\"baba\" backwards is \"abab\". \"baba\" != \"abab\". Thus, \"baba\" is not a palendrome.\n\nTry an easier problem. 125. Valid Palindrome\nhttps://leetcode.com/problems/valid-palindrome/\n"
                    },
                    {
                        "username": "Navin152",
                        "content": "\\nmy code is not working in java can anyone explain please why this code is not working\\n\\nclass Solution {\\n    public String longestPalindrome(String s) {\\n        int n=s.length();\\n        int low,high;\\n        int st=0;\\n        int len=1;\\n        for(int i=1;i<n;i++){\\n            //Even\\n            low=i;\\n            high=i-1;\\n            while(low>=0 && high <n && s[low] == s[high]){\\n                if(high-low+1>len){\\n                    st=low;\\n                    len = high-low+1;\\n                }\\n                low--;high++;\\n                }\\n         //odd\\n            low=i-1;\\n            high=i+1;\\n            while(low>=0 && high<n &&s.charAt(low)== s.charAt(high)){\\n                {\\n                    if(high-low+1>len){\\n                        st=low;\\n                        len= high-low+1;\\n                        }\\n                     low--;\\n                     high++;\\n}\\n}\\n               return  s.substring(st,len);\\n                }   \\n            } \\n           \\n\\n    \\n        \\n\\n"
                    },
                    {
                        "username": "Rajdip_234",
                        "content": " Hi, in this program first we divide the string one is even length and another is odd length and we pass parameter using one function that is string and middle point value then we check the length in both string . If the difference between end and start is less than length of string then we should update start and end value and return the substring value. then again we pass parameter in function which we will declare as our wish and pass string , i value , j value . taking while loop the put the condition i greater than or equals to zero and j should be less than the length of string and the ith value of string is equals to the jth value of string then i will be decremented and j incremented and finally return the value that is (j-i+1)."
                    },
                    {
                        "username": "allgameaimbotall",
                        "content": "Hi I haven't studied Dynamic Programming till now but learned a littlebit about memoization. I tried to solve this problem with recursion + adding memoization .\n\nCode gives exactly what we want but off-course Time-Limit issues.\n\nJust want to ask where does this approach fail?\n\n`\ndp = {}\ndef longestPalindrome(self, s: str) -> str:\nif self.dp.get(s) != None:\n    return self.dp[s]\n\n#TRACKERS\nlenStr = len(s)\n\n#BASE\nif lenStr == 1:\n    self.dp[s] = s\n    return s\n\nif s == s[::-1]:\n    self.dp[s] = s\n    return s\nelse:\n    lp_inleft = self.longestPalindrome(s[1:])\n    lp_inright = self.longestPalindrome(s[:lenStr-1])\n    ans = max(lp_inleft,lp_inright,key=len)\n    self.dp[s] = ans\n    return ans\n        `\n\n        "
                    }
                ]
            },
            {
                "id": 1714511,
                "content": [
                    {
                        "username": "divyaxreddy",
                        "content": "NICK WHITE'S code in C++ not working, can u please help?\n\n \n    string longestPalindrome(string s) {\n        int lenOfString = s.length();\n        int start = 0, end = 0;\n       for(int i = 0; i<lenOfString; i++){\n           int len1 = expandFromMid(s, i, i);\n           int len2 = expandFromMid(s, i, i+1);\n\n           int maxlength = max(len1, len2);\n           //check if maxLength is > old length\n           if(maxlength > (end - start)){\n                start = i - ((maxlength-1)/2);\n                end = i + (maxlength/2);\n           }\n       }\n       return s.substr(start, end+1);\n    }\n\n    int expandFromMid(string& s, int i, int j){\n        if( left > right) return 0;\n        int left = i, right = j;\n        while(left >=0 && right <s.length() && (s[left] == s[right])){\n            left--;\n            right++;\n        }\n\n        return right - left + 1;\n    }\n};`"
                    },
                    {
                        "username": "BaconChef",
                        "content": "[HELP]  \\nHow is \\nInput: s = \"babad\"\\nOutput: \"bab\"\\n\\n\"badab\" or \"abdba\" is both palindromic (the same read forwards and backwards) and a substring. And its obviously longer than \"bab\". For that matter, why isn\\'t \"baab\" accepted?\\n\\nMy definitions:\\nA palindrome is a string that is the same if it\\'s read forward and backward.\\nA substring is a string that rearranges or omits characters of a string."
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@BaconChef](/BaconChef)\nHello, let's see your substring definition? \nGiven:\ns = \"babad\"\n\nSubstring palindromic: any characters \"a\", \"b\", \"d\", and \"bab\", \"aba\".\nBut \"baab\" is not a substring of s!"
                    },
                    {
                        "username": "zuratvaradze999",
                        "content": "swift"
                    },
                    {
                        "username": "Violet-",
                        "content": "Could anybody please explain what does this sentence mean (by an example) in the first solution with Longest common subsequence? \"To rectify this, each time we find a longest common substring candidate, we check if the substring\\u2019s indices are the same as the reversed substring\\u2019s original indices.\""
                    },
                    {
                        "username": "parialxx",
                        "content": "Does anyone understand why do I get this error message in the Longest Palindromic substring problem?\n\n\nAddressSanitizer:DEADLYSIGNAL 31\nERROR: AddressSanitizer: SEGV on unknown address 0x7ffd1cc2ec5f (pc 0x0000003447b6 bp 0x7ffc1cc2eab0 sp 0x7ffc1cc2ea90 T0)\n==31==The signal is caused by a READ memory access.\n    #4 0x7fb759d300b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\nAddressSanitizer can not provide additional info.\n31 ABORTING\n\n\nThis is my code...\n\n`#include <string>\n#include <iostream>\n\nusing namespace std;\n\nclass Solution {\npublic:\n\n    string expandString(string s, unsigned int l, unsigned int r) {\n        while(l >= 0 && r < s.size() && s[l] == s[r]) {\n            l--;\n            r++;\n        }\n        return s.substr(l+1, r-(l+1));\n    }\n\n    string longestPalindrome(string s) {\n        string odd = \"\";\n        string even = \"\";\n        string res = \"\";\n\n        for(unsigned int i = 0; i < s.size(); i++) {\n            even = expandString(s, i, i+1);\n            odd = expandString(s, i, i);\n            \n            if(even.size() > res.size()) {\n                res = even;\n            }\n            if(odd.size() > res.size()) {\n                res = odd;\n            }\n        }\n        return res;\n    }\n\n};`"
                    },
                    {
                        "username": "dnd_Hyani69",
                        "content": "//Simple CPP Soluion//\\n\\nclass Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n       int maxlen=1,start=0;\\n     for(int i=1;i<s.length();i++){//1 se chlao\\n         //that is even substring\\n         int l=i-1;\\n         int r=i;\\n         \\n         while(l >= 0 && r<s.length() && s[l]==s[r]){//l chota ho r bada ho and l==r ho bss\\n             if(r-l+1 > maxlen) {\\n             maxlen=r-l+1;\\n              start=l;\\n             }\\n        l--;\\n        r++;\\n         }\\n      //for odd substring \\n       l=i-1;\\n       r=i+1;\\n     \\n     while(l >=0 && r<s.length() && s[l]==s[r]){\\n         if(r-l+1 > maxlen){\\n         maxlen=r-l+1;\\n         start=l;\\n         }\\n         l--;\\n         r++;\\n     }\\n     }\\n     return s.substr(start, maxlen);\\n    }\\n}; "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Simple rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "meetfarhanali",
                        "content": "The leetcode problems sucks. This is my 2nd problem and i see the description is not right. \\nFor babac the longest palindrom will be \"baba\"=\"abab\". I will switch to HRank problems as they make more sense"
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "\"baba\" is not a palendrome.\n\nA Palendrome is a series of characters that is the same forwards and backwards.\n\n\"baba\" backwards is \"abab\". \"baba\" != \"abab\". Thus, \"baba\" is not a palendrome.\n\nTry an easier problem. 125. Valid Palindrome\nhttps://leetcode.com/problems/valid-palindrome/\n"
                    },
                    {
                        "username": "Navin152",
                        "content": "\\nmy code is not working in java can anyone explain please why this code is not working\\n\\nclass Solution {\\n    public String longestPalindrome(String s) {\\n        int n=s.length();\\n        int low,high;\\n        int st=0;\\n        int len=1;\\n        for(int i=1;i<n;i++){\\n            //Even\\n            low=i;\\n            high=i-1;\\n            while(low>=0 && high <n && s[low] == s[high]){\\n                if(high-low+1>len){\\n                    st=low;\\n                    len = high-low+1;\\n                }\\n                low--;high++;\\n                }\\n         //odd\\n            low=i-1;\\n            high=i+1;\\n            while(low>=0 && high<n &&s.charAt(low)== s.charAt(high)){\\n                {\\n                    if(high-low+1>len){\\n                        st=low;\\n                        len= high-low+1;\\n                        }\\n                     low--;\\n                     high++;\\n}\\n}\\n               return  s.substring(st,len);\\n                }   \\n            } \\n           \\n\\n    \\n        \\n\\n"
                    },
                    {
                        "username": "Rajdip_234",
                        "content": " Hi, in this program first we divide the string one is even length and another is odd length and we pass parameter using one function that is string and middle point value then we check the length in both string . If the difference between end and start is less than length of string then we should update start and end value and return the substring value. then again we pass parameter in function which we will declare as our wish and pass string , i value , j value . taking while loop the put the condition i greater than or equals to zero and j should be less than the length of string and the ith value of string is equals to the jth value of string then i will be decremented and j incremented and finally return the value that is (j-i+1)."
                    },
                    {
                        "username": "allgameaimbotall",
                        "content": "Hi I haven't studied Dynamic Programming till now but learned a littlebit about memoization. I tried to solve this problem with recursion + adding memoization .\n\nCode gives exactly what we want but off-course Time-Limit issues.\n\nJust want to ask where does this approach fail?\n\n`\ndp = {}\ndef longestPalindrome(self, s: str) -> str:\nif self.dp.get(s) != None:\n    return self.dp[s]\n\n#TRACKERS\nlenStr = len(s)\n\n#BASE\nif lenStr == 1:\n    self.dp[s] = s\n    return s\n\nif s == s[::-1]:\n    self.dp[s] = s\n    return s\nelse:\n    lp_inleft = self.longestPalindrome(s[1:])\n    lp_inright = self.longestPalindrome(s[:lenStr-1])\n    ans = max(lp_inleft,lp_inright,key=len)\n    self.dp[s] = ans\n    return ans\n        `\n\n        "
                    }
                ]
            },
            {
                "id": 1714466,
                "content": [
                    {
                        "username": "divyaxreddy",
                        "content": "NICK WHITE'S code in C++ not working, can u please help?\n\n \n    string longestPalindrome(string s) {\n        int lenOfString = s.length();\n        int start = 0, end = 0;\n       for(int i = 0; i<lenOfString; i++){\n           int len1 = expandFromMid(s, i, i);\n           int len2 = expandFromMid(s, i, i+1);\n\n           int maxlength = max(len1, len2);\n           //check if maxLength is > old length\n           if(maxlength > (end - start)){\n                start = i - ((maxlength-1)/2);\n                end = i + (maxlength/2);\n           }\n       }\n       return s.substr(start, end+1);\n    }\n\n    int expandFromMid(string& s, int i, int j){\n        if( left > right) return 0;\n        int left = i, right = j;\n        while(left >=0 && right <s.length() && (s[left] == s[right])){\n            left--;\n            right++;\n        }\n\n        return right - left + 1;\n    }\n};`"
                    },
                    {
                        "username": "BaconChef",
                        "content": "[HELP]  \\nHow is \\nInput: s = \"babad\"\\nOutput: \"bab\"\\n\\n\"badab\" or \"abdba\" is both palindromic (the same read forwards and backwards) and a substring. And its obviously longer than \"bab\". For that matter, why isn\\'t \"baab\" accepted?\\n\\nMy definitions:\\nA palindrome is a string that is the same if it\\'s read forward and backward.\\nA substring is a string that rearranges or omits characters of a string."
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@BaconChef](/BaconChef)\nHello, let's see your substring definition? \nGiven:\ns = \"babad\"\n\nSubstring palindromic: any characters \"a\", \"b\", \"d\", and \"bab\", \"aba\".\nBut \"baab\" is not a substring of s!"
                    },
                    {
                        "username": "zuratvaradze999",
                        "content": "swift"
                    },
                    {
                        "username": "Violet-",
                        "content": "Could anybody please explain what does this sentence mean (by an example) in the first solution with Longest common subsequence? \"To rectify this, each time we find a longest common substring candidate, we check if the substring\\u2019s indices are the same as the reversed substring\\u2019s original indices.\""
                    },
                    {
                        "username": "parialxx",
                        "content": "Does anyone understand why do I get this error message in the Longest Palindromic substring problem?\n\n\nAddressSanitizer:DEADLYSIGNAL 31\nERROR: AddressSanitizer: SEGV on unknown address 0x7ffd1cc2ec5f (pc 0x0000003447b6 bp 0x7ffc1cc2eab0 sp 0x7ffc1cc2ea90 T0)\n==31==The signal is caused by a READ memory access.\n    #4 0x7fb759d300b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\nAddressSanitizer can not provide additional info.\n31 ABORTING\n\n\nThis is my code...\n\n`#include <string>\n#include <iostream>\n\nusing namespace std;\n\nclass Solution {\npublic:\n\n    string expandString(string s, unsigned int l, unsigned int r) {\n        while(l >= 0 && r < s.size() && s[l] == s[r]) {\n            l--;\n            r++;\n        }\n        return s.substr(l+1, r-(l+1));\n    }\n\n    string longestPalindrome(string s) {\n        string odd = \"\";\n        string even = \"\";\n        string res = \"\";\n\n        for(unsigned int i = 0; i < s.size(); i++) {\n            even = expandString(s, i, i+1);\n            odd = expandString(s, i, i);\n            \n            if(even.size() > res.size()) {\n                res = even;\n            }\n            if(odd.size() > res.size()) {\n                res = odd;\n            }\n        }\n        return res;\n    }\n\n};`"
                    },
                    {
                        "username": "dnd_Hyani69",
                        "content": "//Simple CPP Soluion//\\n\\nclass Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n       int maxlen=1,start=0;\\n     for(int i=1;i<s.length();i++){//1 se chlao\\n         //that is even substring\\n         int l=i-1;\\n         int r=i;\\n         \\n         while(l >= 0 && r<s.length() && s[l]==s[r]){//l chota ho r bada ho and l==r ho bss\\n             if(r-l+1 > maxlen) {\\n             maxlen=r-l+1;\\n              start=l;\\n             }\\n        l--;\\n        r++;\\n         }\\n      //for odd substring \\n       l=i-1;\\n       r=i+1;\\n     \\n     while(l >=0 && r<s.length() && s[l]==s[r]){\\n         if(r-l+1 > maxlen){\\n         maxlen=r-l+1;\\n         start=l;\\n         }\\n         l--;\\n         r++;\\n     }\\n     }\\n     return s.substr(start, maxlen);\\n    }\\n}; "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Simple rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "meetfarhanali",
                        "content": "The leetcode problems sucks. This is my 2nd problem and i see the description is not right. \\nFor babac the longest palindrom will be \"baba\"=\"abab\". I will switch to HRank problems as they make more sense"
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "\"baba\" is not a palendrome.\n\nA Palendrome is a series of characters that is the same forwards and backwards.\n\n\"baba\" backwards is \"abab\". \"baba\" != \"abab\". Thus, \"baba\" is not a palendrome.\n\nTry an easier problem. 125. Valid Palindrome\nhttps://leetcode.com/problems/valid-palindrome/\n"
                    },
                    {
                        "username": "Navin152",
                        "content": "\\nmy code is not working in java can anyone explain please why this code is not working\\n\\nclass Solution {\\n    public String longestPalindrome(String s) {\\n        int n=s.length();\\n        int low,high;\\n        int st=0;\\n        int len=1;\\n        for(int i=1;i<n;i++){\\n            //Even\\n            low=i;\\n            high=i-1;\\n            while(low>=0 && high <n && s[low] == s[high]){\\n                if(high-low+1>len){\\n                    st=low;\\n                    len = high-low+1;\\n                }\\n                low--;high++;\\n                }\\n         //odd\\n            low=i-1;\\n            high=i+1;\\n            while(low>=0 && high<n &&s.charAt(low)== s.charAt(high)){\\n                {\\n                    if(high-low+1>len){\\n                        st=low;\\n                        len= high-low+1;\\n                        }\\n                     low--;\\n                     high++;\\n}\\n}\\n               return  s.substring(st,len);\\n                }   \\n            } \\n           \\n\\n    \\n        \\n\\n"
                    },
                    {
                        "username": "Rajdip_234",
                        "content": " Hi, in this program first we divide the string one is even length and another is odd length and we pass parameter using one function that is string and middle point value then we check the length in both string . If the difference between end and start is less than length of string then we should update start and end value and return the substring value. then again we pass parameter in function which we will declare as our wish and pass string , i value , j value . taking while loop the put the condition i greater than or equals to zero and j should be less than the length of string and the ith value of string is equals to the jth value of string then i will be decremented and j incremented and finally return the value that is (j-i+1)."
                    },
                    {
                        "username": "allgameaimbotall",
                        "content": "Hi I haven't studied Dynamic Programming till now but learned a littlebit about memoization. I tried to solve this problem with recursion + adding memoization .\n\nCode gives exactly what we want but off-course Time-Limit issues.\n\nJust want to ask where does this approach fail?\n\n`\ndp = {}\ndef longestPalindrome(self, s: str) -> str:\nif self.dp.get(s) != None:\n    return self.dp[s]\n\n#TRACKERS\nlenStr = len(s)\n\n#BASE\nif lenStr == 1:\n    self.dp[s] = s\n    return s\n\nif s == s[::-1]:\n    self.dp[s] = s\n    return s\nelse:\n    lp_inleft = self.longestPalindrome(s[1:])\n    lp_inright = self.longestPalindrome(s[:lenStr-1])\n    ans = max(lp_inleft,lp_inright,key=len)\n    self.dp[s] = ans\n    return ans\n        `\n\n        "
                    }
                ]
            },
            {
                "id": 1710267,
                "content": [
                    {
                        "username": "divyaxreddy",
                        "content": "NICK WHITE'S code in C++ not working, can u please help?\n\n \n    string longestPalindrome(string s) {\n        int lenOfString = s.length();\n        int start = 0, end = 0;\n       for(int i = 0; i<lenOfString; i++){\n           int len1 = expandFromMid(s, i, i);\n           int len2 = expandFromMid(s, i, i+1);\n\n           int maxlength = max(len1, len2);\n           //check if maxLength is > old length\n           if(maxlength > (end - start)){\n                start = i - ((maxlength-1)/2);\n                end = i + (maxlength/2);\n           }\n       }\n       return s.substr(start, end+1);\n    }\n\n    int expandFromMid(string& s, int i, int j){\n        if( left > right) return 0;\n        int left = i, right = j;\n        while(left >=0 && right <s.length() && (s[left] == s[right])){\n            left--;\n            right++;\n        }\n\n        return right - left + 1;\n    }\n};`"
                    },
                    {
                        "username": "BaconChef",
                        "content": "[HELP]  \\nHow is \\nInput: s = \"babad\"\\nOutput: \"bab\"\\n\\n\"badab\" or \"abdba\" is both palindromic (the same read forwards and backwards) and a substring. And its obviously longer than \"bab\". For that matter, why isn\\'t \"baab\" accepted?\\n\\nMy definitions:\\nA palindrome is a string that is the same if it\\'s read forward and backward.\\nA substring is a string that rearranges or omits characters of a string."
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@BaconChef](/BaconChef)\nHello, let's see your substring definition? \nGiven:\ns = \"babad\"\n\nSubstring palindromic: any characters \"a\", \"b\", \"d\", and \"bab\", \"aba\".\nBut \"baab\" is not a substring of s!"
                    },
                    {
                        "username": "zuratvaradze999",
                        "content": "swift"
                    },
                    {
                        "username": "Violet-",
                        "content": "Could anybody please explain what does this sentence mean (by an example) in the first solution with Longest common subsequence? \"To rectify this, each time we find a longest common substring candidate, we check if the substring\\u2019s indices are the same as the reversed substring\\u2019s original indices.\""
                    },
                    {
                        "username": "parialxx",
                        "content": "Does anyone understand why do I get this error message in the Longest Palindromic substring problem?\n\n\nAddressSanitizer:DEADLYSIGNAL 31\nERROR: AddressSanitizer: SEGV on unknown address 0x7ffd1cc2ec5f (pc 0x0000003447b6 bp 0x7ffc1cc2eab0 sp 0x7ffc1cc2ea90 T0)\n==31==The signal is caused by a READ memory access.\n    #4 0x7fb759d300b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\nAddressSanitizer can not provide additional info.\n31 ABORTING\n\n\nThis is my code...\n\n`#include <string>\n#include <iostream>\n\nusing namespace std;\n\nclass Solution {\npublic:\n\n    string expandString(string s, unsigned int l, unsigned int r) {\n        while(l >= 0 && r < s.size() && s[l] == s[r]) {\n            l--;\n            r++;\n        }\n        return s.substr(l+1, r-(l+1));\n    }\n\n    string longestPalindrome(string s) {\n        string odd = \"\";\n        string even = \"\";\n        string res = \"\";\n\n        for(unsigned int i = 0; i < s.size(); i++) {\n            even = expandString(s, i, i+1);\n            odd = expandString(s, i, i);\n            \n            if(even.size() > res.size()) {\n                res = even;\n            }\n            if(odd.size() > res.size()) {\n                res = odd;\n            }\n        }\n        return res;\n    }\n\n};`"
                    },
                    {
                        "username": "dnd_Hyani69",
                        "content": "//Simple CPP Soluion//\\n\\nclass Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n       int maxlen=1,start=0;\\n     for(int i=1;i<s.length();i++){//1 se chlao\\n         //that is even substring\\n         int l=i-1;\\n         int r=i;\\n         \\n         while(l >= 0 && r<s.length() && s[l]==s[r]){//l chota ho r bada ho and l==r ho bss\\n             if(r-l+1 > maxlen) {\\n             maxlen=r-l+1;\\n              start=l;\\n             }\\n        l--;\\n        r++;\\n         }\\n      //for odd substring \\n       l=i-1;\\n       r=i+1;\\n     \\n     while(l >=0 && r<s.length() && s[l]==s[r]){\\n         if(r-l+1 > maxlen){\\n         maxlen=r-l+1;\\n         start=l;\\n         }\\n         l--;\\n         r++;\\n     }\\n     }\\n     return s.substr(start, maxlen);\\n    }\\n}; "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Simple rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "meetfarhanali",
                        "content": "The leetcode problems sucks. This is my 2nd problem and i see the description is not right. \\nFor babac the longest palindrom will be \"baba\"=\"abab\". I will switch to HRank problems as they make more sense"
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "\"baba\" is not a palendrome.\n\nA Palendrome is a series of characters that is the same forwards and backwards.\n\n\"baba\" backwards is \"abab\". \"baba\" != \"abab\". Thus, \"baba\" is not a palendrome.\n\nTry an easier problem. 125. Valid Palindrome\nhttps://leetcode.com/problems/valid-palindrome/\n"
                    },
                    {
                        "username": "Navin152",
                        "content": "\\nmy code is not working in java can anyone explain please why this code is not working\\n\\nclass Solution {\\n    public String longestPalindrome(String s) {\\n        int n=s.length();\\n        int low,high;\\n        int st=0;\\n        int len=1;\\n        for(int i=1;i<n;i++){\\n            //Even\\n            low=i;\\n            high=i-1;\\n            while(low>=0 && high <n && s[low] == s[high]){\\n                if(high-low+1>len){\\n                    st=low;\\n                    len = high-low+1;\\n                }\\n                low--;high++;\\n                }\\n         //odd\\n            low=i-1;\\n            high=i+1;\\n            while(low>=0 && high<n &&s.charAt(low)== s.charAt(high)){\\n                {\\n                    if(high-low+1>len){\\n                        st=low;\\n                        len= high-low+1;\\n                        }\\n                     low--;\\n                     high++;\\n}\\n}\\n               return  s.substring(st,len);\\n                }   \\n            } \\n           \\n\\n    \\n        \\n\\n"
                    },
                    {
                        "username": "Rajdip_234",
                        "content": " Hi, in this program first we divide the string one is even length and another is odd length and we pass parameter using one function that is string and middle point value then we check the length in both string . If the difference between end and start is less than length of string then we should update start and end value and return the substring value. then again we pass parameter in function which we will declare as our wish and pass string , i value , j value . taking while loop the put the condition i greater than or equals to zero and j should be less than the length of string and the ith value of string is equals to the jth value of string then i will be decremented and j incremented and finally return the value that is (j-i+1)."
                    },
                    {
                        "username": "allgameaimbotall",
                        "content": "Hi I haven't studied Dynamic Programming till now but learned a littlebit about memoization. I tried to solve this problem with recursion + adding memoization .\n\nCode gives exactly what we want but off-course Time-Limit issues.\n\nJust want to ask where does this approach fail?\n\n`\ndp = {}\ndef longestPalindrome(self, s: str) -> str:\nif self.dp.get(s) != None:\n    return self.dp[s]\n\n#TRACKERS\nlenStr = len(s)\n\n#BASE\nif lenStr == 1:\n    self.dp[s] = s\n    return s\n\nif s == s[::-1]:\n    self.dp[s] = s\n    return s\nelse:\n    lp_inleft = self.longestPalindrome(s[1:])\n    lp_inright = self.longestPalindrome(s[:lenStr-1])\n    ans = max(lp_inleft,lp_inright,key=len)\n    self.dp[s] = ans\n    return ans\n        `\n\n        "
                    }
                ]
            },
            {
                "id": 1708425,
                "content": [
                    {
                        "username": "divyaxreddy",
                        "content": "NICK WHITE'S code in C++ not working, can u please help?\n\n \n    string longestPalindrome(string s) {\n        int lenOfString = s.length();\n        int start = 0, end = 0;\n       for(int i = 0; i<lenOfString; i++){\n           int len1 = expandFromMid(s, i, i);\n           int len2 = expandFromMid(s, i, i+1);\n\n           int maxlength = max(len1, len2);\n           //check if maxLength is > old length\n           if(maxlength > (end - start)){\n                start = i - ((maxlength-1)/2);\n                end = i + (maxlength/2);\n           }\n       }\n       return s.substr(start, end+1);\n    }\n\n    int expandFromMid(string& s, int i, int j){\n        if( left > right) return 0;\n        int left = i, right = j;\n        while(left >=0 && right <s.length() && (s[left] == s[right])){\n            left--;\n            right++;\n        }\n\n        return right - left + 1;\n    }\n};`"
                    },
                    {
                        "username": "BaconChef",
                        "content": "[HELP]  \\nHow is \\nInput: s = \"babad\"\\nOutput: \"bab\"\\n\\n\"badab\" or \"abdba\" is both palindromic (the same read forwards and backwards) and a substring. And its obviously longer than \"bab\". For that matter, why isn\\'t \"baab\" accepted?\\n\\nMy definitions:\\nA palindrome is a string that is the same if it\\'s read forward and backward.\\nA substring is a string that rearranges or omits characters of a string."
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@BaconChef](/BaconChef)\nHello, let's see your substring definition? \nGiven:\ns = \"babad\"\n\nSubstring palindromic: any characters \"a\", \"b\", \"d\", and \"bab\", \"aba\".\nBut \"baab\" is not a substring of s!"
                    },
                    {
                        "username": "zuratvaradze999",
                        "content": "swift"
                    },
                    {
                        "username": "Violet-",
                        "content": "Could anybody please explain what does this sentence mean (by an example) in the first solution with Longest common subsequence? \"To rectify this, each time we find a longest common substring candidate, we check if the substring\\u2019s indices are the same as the reversed substring\\u2019s original indices.\""
                    },
                    {
                        "username": "parialxx",
                        "content": "Does anyone understand why do I get this error message in the Longest Palindromic substring problem?\n\n\nAddressSanitizer:DEADLYSIGNAL 31\nERROR: AddressSanitizer: SEGV on unknown address 0x7ffd1cc2ec5f (pc 0x0000003447b6 bp 0x7ffc1cc2eab0 sp 0x7ffc1cc2ea90 T0)\n==31==The signal is caused by a READ memory access.\n    #4 0x7fb759d300b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\nAddressSanitizer can not provide additional info.\n31 ABORTING\n\n\nThis is my code...\n\n`#include <string>\n#include <iostream>\n\nusing namespace std;\n\nclass Solution {\npublic:\n\n    string expandString(string s, unsigned int l, unsigned int r) {\n        while(l >= 0 && r < s.size() && s[l] == s[r]) {\n            l--;\n            r++;\n        }\n        return s.substr(l+1, r-(l+1));\n    }\n\n    string longestPalindrome(string s) {\n        string odd = \"\";\n        string even = \"\";\n        string res = \"\";\n\n        for(unsigned int i = 0; i < s.size(); i++) {\n            even = expandString(s, i, i+1);\n            odd = expandString(s, i, i);\n            \n            if(even.size() > res.size()) {\n                res = even;\n            }\n            if(odd.size() > res.size()) {\n                res = odd;\n            }\n        }\n        return res;\n    }\n\n};`"
                    },
                    {
                        "username": "dnd_Hyani69",
                        "content": "//Simple CPP Soluion//\\n\\nclass Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n       int maxlen=1,start=0;\\n     for(int i=1;i<s.length();i++){//1 se chlao\\n         //that is even substring\\n         int l=i-1;\\n         int r=i;\\n         \\n         while(l >= 0 && r<s.length() && s[l]==s[r]){//l chota ho r bada ho and l==r ho bss\\n             if(r-l+1 > maxlen) {\\n             maxlen=r-l+1;\\n              start=l;\\n             }\\n        l--;\\n        r++;\\n         }\\n      //for odd substring \\n       l=i-1;\\n       r=i+1;\\n     \\n     while(l >=0 && r<s.length() && s[l]==s[r]){\\n         if(r-l+1 > maxlen){\\n         maxlen=r-l+1;\\n         start=l;\\n         }\\n         l--;\\n         r++;\\n     }\\n     }\\n     return s.substr(start, maxlen);\\n    }\\n}; "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Simple rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "meetfarhanali",
                        "content": "The leetcode problems sucks. This is my 2nd problem and i see the description is not right. \\nFor babac the longest palindrom will be \"baba\"=\"abab\". I will switch to HRank problems as they make more sense"
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "\"baba\" is not a palendrome.\n\nA Palendrome is a series of characters that is the same forwards and backwards.\n\n\"baba\" backwards is \"abab\". \"baba\" != \"abab\". Thus, \"baba\" is not a palendrome.\n\nTry an easier problem. 125. Valid Palindrome\nhttps://leetcode.com/problems/valid-palindrome/\n"
                    },
                    {
                        "username": "Navin152",
                        "content": "\\nmy code is not working in java can anyone explain please why this code is not working\\n\\nclass Solution {\\n    public String longestPalindrome(String s) {\\n        int n=s.length();\\n        int low,high;\\n        int st=0;\\n        int len=1;\\n        for(int i=1;i<n;i++){\\n            //Even\\n            low=i;\\n            high=i-1;\\n            while(low>=0 && high <n && s[low] == s[high]){\\n                if(high-low+1>len){\\n                    st=low;\\n                    len = high-low+1;\\n                }\\n                low--;high++;\\n                }\\n         //odd\\n            low=i-1;\\n            high=i+1;\\n            while(low>=0 && high<n &&s.charAt(low)== s.charAt(high)){\\n                {\\n                    if(high-low+1>len){\\n                        st=low;\\n                        len= high-low+1;\\n                        }\\n                     low--;\\n                     high++;\\n}\\n}\\n               return  s.substring(st,len);\\n                }   \\n            } \\n           \\n\\n    \\n        \\n\\n"
                    },
                    {
                        "username": "Rajdip_234",
                        "content": " Hi, in this program first we divide the string one is even length and another is odd length and we pass parameter using one function that is string and middle point value then we check the length in both string . If the difference between end and start is less than length of string then we should update start and end value and return the substring value. then again we pass parameter in function which we will declare as our wish and pass string , i value , j value . taking while loop the put the condition i greater than or equals to zero and j should be less than the length of string and the ith value of string is equals to the jth value of string then i will be decremented and j incremented and finally return the value that is (j-i+1)."
                    },
                    {
                        "username": "allgameaimbotall",
                        "content": "Hi I haven't studied Dynamic Programming till now but learned a littlebit about memoization. I tried to solve this problem with recursion + adding memoization .\n\nCode gives exactly what we want but off-course Time-Limit issues.\n\nJust want to ask where does this approach fail?\n\n`\ndp = {}\ndef longestPalindrome(self, s: str) -> str:\nif self.dp.get(s) != None:\n    return self.dp[s]\n\n#TRACKERS\nlenStr = len(s)\n\n#BASE\nif lenStr == 1:\n    self.dp[s] = s\n    return s\n\nif s == s[::-1]:\n    self.dp[s] = s\n    return s\nelse:\n    lp_inleft = self.longestPalindrome(s[1:])\n    lp_inright = self.longestPalindrome(s[:lenStr-1])\n    ans = max(lp_inleft,lp_inright,key=len)\n    self.dp[s] = ans\n    return ans\n        `\n\n        "
                    }
                ]
            },
            {
                "id": 1704183,
                "content": [
                    {
                        "username": "divyaxreddy",
                        "content": "NICK WHITE'S code in C++ not working, can u please help?\n\n \n    string longestPalindrome(string s) {\n        int lenOfString = s.length();\n        int start = 0, end = 0;\n       for(int i = 0; i<lenOfString; i++){\n           int len1 = expandFromMid(s, i, i);\n           int len2 = expandFromMid(s, i, i+1);\n\n           int maxlength = max(len1, len2);\n           //check if maxLength is > old length\n           if(maxlength > (end - start)){\n                start = i - ((maxlength-1)/2);\n                end = i + (maxlength/2);\n           }\n       }\n       return s.substr(start, end+1);\n    }\n\n    int expandFromMid(string& s, int i, int j){\n        if( left > right) return 0;\n        int left = i, right = j;\n        while(left >=0 && right <s.length() && (s[left] == s[right])){\n            left--;\n            right++;\n        }\n\n        return right - left + 1;\n    }\n};`"
                    },
                    {
                        "username": "BaconChef",
                        "content": "[HELP]  \\nHow is \\nInput: s = \"babad\"\\nOutput: \"bab\"\\n\\n\"badab\" or \"abdba\" is both palindromic (the same read forwards and backwards) and a substring. And its obviously longer than \"bab\". For that matter, why isn\\'t \"baab\" accepted?\\n\\nMy definitions:\\nA palindrome is a string that is the same if it\\'s read forward and backward.\\nA substring is a string that rearranges or omits characters of a string."
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@BaconChef](/BaconChef)\nHello, let's see your substring definition? \nGiven:\ns = \"babad\"\n\nSubstring palindromic: any characters \"a\", \"b\", \"d\", and \"bab\", \"aba\".\nBut \"baab\" is not a substring of s!"
                    },
                    {
                        "username": "zuratvaradze999",
                        "content": "swift"
                    },
                    {
                        "username": "Violet-",
                        "content": "Could anybody please explain what does this sentence mean (by an example) in the first solution with Longest common subsequence? \"To rectify this, each time we find a longest common substring candidate, we check if the substring\\u2019s indices are the same as the reversed substring\\u2019s original indices.\""
                    },
                    {
                        "username": "parialxx",
                        "content": "Does anyone understand why do I get this error message in the Longest Palindromic substring problem?\n\n\nAddressSanitizer:DEADLYSIGNAL 31\nERROR: AddressSanitizer: SEGV on unknown address 0x7ffd1cc2ec5f (pc 0x0000003447b6 bp 0x7ffc1cc2eab0 sp 0x7ffc1cc2ea90 T0)\n==31==The signal is caused by a READ memory access.\n    #4 0x7fb759d300b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\nAddressSanitizer can not provide additional info.\n31 ABORTING\n\n\nThis is my code...\n\n`#include <string>\n#include <iostream>\n\nusing namespace std;\n\nclass Solution {\npublic:\n\n    string expandString(string s, unsigned int l, unsigned int r) {\n        while(l >= 0 && r < s.size() && s[l] == s[r]) {\n            l--;\n            r++;\n        }\n        return s.substr(l+1, r-(l+1));\n    }\n\n    string longestPalindrome(string s) {\n        string odd = \"\";\n        string even = \"\";\n        string res = \"\";\n\n        for(unsigned int i = 0; i < s.size(); i++) {\n            even = expandString(s, i, i+1);\n            odd = expandString(s, i, i);\n            \n            if(even.size() > res.size()) {\n                res = even;\n            }\n            if(odd.size() > res.size()) {\n                res = odd;\n            }\n        }\n        return res;\n    }\n\n};`"
                    },
                    {
                        "username": "dnd_Hyani69",
                        "content": "//Simple CPP Soluion//\\n\\nclass Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n       int maxlen=1,start=0;\\n     for(int i=1;i<s.length();i++){//1 se chlao\\n         //that is even substring\\n         int l=i-1;\\n         int r=i;\\n         \\n         while(l >= 0 && r<s.length() && s[l]==s[r]){//l chota ho r bada ho and l==r ho bss\\n             if(r-l+1 > maxlen) {\\n             maxlen=r-l+1;\\n              start=l;\\n             }\\n        l--;\\n        r++;\\n         }\\n      //for odd substring \\n       l=i-1;\\n       r=i+1;\\n     \\n     while(l >=0 && r<s.length() && s[l]==s[r]){\\n         if(r-l+1 > maxlen){\\n         maxlen=r-l+1;\\n         start=l;\\n         }\\n         l--;\\n         r++;\\n     }\\n     }\\n     return s.substr(start, maxlen);\\n    }\\n}; "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Simple rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "meetfarhanali",
                        "content": "The leetcode problems sucks. This is my 2nd problem and i see the description is not right. \\nFor babac the longest palindrom will be \"baba\"=\"abab\". I will switch to HRank problems as they make more sense"
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "\"baba\" is not a palendrome.\n\nA Palendrome is a series of characters that is the same forwards and backwards.\n\n\"baba\" backwards is \"abab\". \"baba\" != \"abab\". Thus, \"baba\" is not a palendrome.\n\nTry an easier problem. 125. Valid Palindrome\nhttps://leetcode.com/problems/valid-palindrome/\n"
                    },
                    {
                        "username": "Navin152",
                        "content": "\\nmy code is not working in java can anyone explain please why this code is not working\\n\\nclass Solution {\\n    public String longestPalindrome(String s) {\\n        int n=s.length();\\n        int low,high;\\n        int st=0;\\n        int len=1;\\n        for(int i=1;i<n;i++){\\n            //Even\\n            low=i;\\n            high=i-1;\\n            while(low>=0 && high <n && s[low] == s[high]){\\n                if(high-low+1>len){\\n                    st=low;\\n                    len = high-low+1;\\n                }\\n                low--;high++;\\n                }\\n         //odd\\n            low=i-1;\\n            high=i+1;\\n            while(low>=0 && high<n &&s.charAt(low)== s.charAt(high)){\\n                {\\n                    if(high-low+1>len){\\n                        st=low;\\n                        len= high-low+1;\\n                        }\\n                     low--;\\n                     high++;\\n}\\n}\\n               return  s.substring(st,len);\\n                }   \\n            } \\n           \\n\\n    \\n        \\n\\n"
                    },
                    {
                        "username": "Rajdip_234",
                        "content": " Hi, in this program first we divide the string one is even length and another is odd length and we pass parameter using one function that is string and middle point value then we check the length in both string . If the difference between end and start is less than length of string then we should update start and end value and return the substring value. then again we pass parameter in function which we will declare as our wish and pass string , i value , j value . taking while loop the put the condition i greater than or equals to zero and j should be less than the length of string and the ith value of string is equals to the jth value of string then i will be decremented and j incremented and finally return the value that is (j-i+1)."
                    },
                    {
                        "username": "allgameaimbotall",
                        "content": "Hi I haven't studied Dynamic Programming till now but learned a littlebit about memoization. I tried to solve this problem with recursion + adding memoization .\n\nCode gives exactly what we want but off-course Time-Limit issues.\n\nJust want to ask where does this approach fail?\n\n`\ndp = {}\ndef longestPalindrome(self, s: str) -> str:\nif self.dp.get(s) != None:\n    return self.dp[s]\n\n#TRACKERS\nlenStr = len(s)\n\n#BASE\nif lenStr == 1:\n    self.dp[s] = s\n    return s\n\nif s == s[::-1]:\n    self.dp[s] = s\n    return s\nelse:\n    lp_inleft = self.longestPalindrome(s[1:])\n    lp_inright = self.longestPalindrome(s[:lenStr-1])\n    ans = max(lp_inleft,lp_inright,key=len)\n    self.dp[s] = ans\n    return ans\n        `\n\n        "
                    }
                ]
            },
            {
                "id": 1700817,
                "content": [
                    {
                        "username": "divyaxreddy",
                        "content": "NICK WHITE'S code in C++ not working, can u please help?\n\n \n    string longestPalindrome(string s) {\n        int lenOfString = s.length();\n        int start = 0, end = 0;\n       for(int i = 0; i<lenOfString; i++){\n           int len1 = expandFromMid(s, i, i);\n           int len2 = expandFromMid(s, i, i+1);\n\n           int maxlength = max(len1, len2);\n           //check if maxLength is > old length\n           if(maxlength > (end - start)){\n                start = i - ((maxlength-1)/2);\n                end = i + (maxlength/2);\n           }\n       }\n       return s.substr(start, end+1);\n    }\n\n    int expandFromMid(string& s, int i, int j){\n        if( left > right) return 0;\n        int left = i, right = j;\n        while(left >=0 && right <s.length() && (s[left] == s[right])){\n            left--;\n            right++;\n        }\n\n        return right - left + 1;\n    }\n};`"
                    },
                    {
                        "username": "BaconChef",
                        "content": "[HELP]  \\nHow is \\nInput: s = \"babad\"\\nOutput: \"bab\"\\n\\n\"badab\" or \"abdba\" is both palindromic (the same read forwards and backwards) and a substring. And its obviously longer than \"bab\". For that matter, why isn\\'t \"baab\" accepted?\\n\\nMy definitions:\\nA palindrome is a string that is the same if it\\'s read forward and backward.\\nA substring is a string that rearranges or omits characters of a string."
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@BaconChef](/BaconChef)\nHello, let's see your substring definition? \nGiven:\ns = \"babad\"\n\nSubstring palindromic: any characters \"a\", \"b\", \"d\", and \"bab\", \"aba\".\nBut \"baab\" is not a substring of s!"
                    },
                    {
                        "username": "zuratvaradze999",
                        "content": "swift"
                    },
                    {
                        "username": "Violet-",
                        "content": "Could anybody please explain what does this sentence mean (by an example) in the first solution with Longest common subsequence? \"To rectify this, each time we find a longest common substring candidate, we check if the substring\\u2019s indices are the same as the reversed substring\\u2019s original indices.\""
                    },
                    {
                        "username": "parialxx",
                        "content": "Does anyone understand why do I get this error message in the Longest Palindromic substring problem?\n\n\nAddressSanitizer:DEADLYSIGNAL 31\nERROR: AddressSanitizer: SEGV on unknown address 0x7ffd1cc2ec5f (pc 0x0000003447b6 bp 0x7ffc1cc2eab0 sp 0x7ffc1cc2ea90 T0)\n==31==The signal is caused by a READ memory access.\n    #4 0x7fb759d300b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\nAddressSanitizer can not provide additional info.\n31 ABORTING\n\n\nThis is my code...\n\n`#include <string>\n#include <iostream>\n\nusing namespace std;\n\nclass Solution {\npublic:\n\n    string expandString(string s, unsigned int l, unsigned int r) {\n        while(l >= 0 && r < s.size() && s[l] == s[r]) {\n            l--;\n            r++;\n        }\n        return s.substr(l+1, r-(l+1));\n    }\n\n    string longestPalindrome(string s) {\n        string odd = \"\";\n        string even = \"\";\n        string res = \"\";\n\n        for(unsigned int i = 0; i < s.size(); i++) {\n            even = expandString(s, i, i+1);\n            odd = expandString(s, i, i);\n            \n            if(even.size() > res.size()) {\n                res = even;\n            }\n            if(odd.size() > res.size()) {\n                res = odd;\n            }\n        }\n        return res;\n    }\n\n};`"
                    },
                    {
                        "username": "dnd_Hyani69",
                        "content": "//Simple CPP Soluion//\\n\\nclass Solution {\\npublic:\\n    string longestPalindrome(string s) {\\n       int maxlen=1,start=0;\\n     for(int i=1;i<s.length();i++){//1 se chlao\\n         //that is even substring\\n         int l=i-1;\\n         int r=i;\\n         \\n         while(l >= 0 && r<s.length() && s[l]==s[r]){//l chota ho r bada ho and l==r ho bss\\n             if(r-l+1 > maxlen) {\\n             maxlen=r-l+1;\\n              start=l;\\n             }\\n        l--;\\n        r++;\\n         }\\n      //for odd substring \\n       l=i-1;\\n       r=i+1;\\n     \\n     while(l >=0 && r<s.length() && s[l]==s[r]){\\n         if(r-l+1 > maxlen){\\n         maxlen=r-l+1;\\n         start=l;\\n         }\\n         l--;\\n         r++;\\n     }\\n     }\\n     return s.substr(start, maxlen);\\n    }\\n}; "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Simple rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "meetfarhanali",
                        "content": "The leetcode problems sucks. This is my 2nd problem and i see the description is not right. \\nFor babac the longest palindrom will be \"baba\"=\"abab\". I will switch to HRank problems as they make more sense"
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "\"baba\" is not a palendrome.\n\nA Palendrome is a series of characters that is the same forwards and backwards.\n\n\"baba\" backwards is \"abab\". \"baba\" != \"abab\". Thus, \"baba\" is not a palendrome.\n\nTry an easier problem. 125. Valid Palindrome\nhttps://leetcode.com/problems/valid-palindrome/\n"
                    },
                    {
                        "username": "Navin152",
                        "content": "\\nmy code is not working in java can anyone explain please why this code is not working\\n\\nclass Solution {\\n    public String longestPalindrome(String s) {\\n        int n=s.length();\\n        int low,high;\\n        int st=0;\\n        int len=1;\\n        for(int i=1;i<n;i++){\\n            //Even\\n            low=i;\\n            high=i-1;\\n            while(low>=0 && high <n && s[low] == s[high]){\\n                if(high-low+1>len){\\n                    st=low;\\n                    len = high-low+1;\\n                }\\n                low--;high++;\\n                }\\n         //odd\\n            low=i-1;\\n            high=i+1;\\n            while(low>=0 && high<n &&s.charAt(low)== s.charAt(high)){\\n                {\\n                    if(high-low+1>len){\\n                        st=low;\\n                        len= high-low+1;\\n                        }\\n                     low--;\\n                     high++;\\n}\\n}\\n               return  s.substring(st,len);\\n                }   \\n            } \\n           \\n\\n    \\n        \\n\\n"
                    },
                    {
                        "username": "Rajdip_234",
                        "content": " Hi, in this program first we divide the string one is even length and another is odd length and we pass parameter using one function that is string and middle point value then we check the length in both string . If the difference between end and start is less than length of string then we should update start and end value and return the substring value. then again we pass parameter in function which we will declare as our wish and pass string , i value , j value . taking while loop the put the condition i greater than or equals to zero and j should be less than the length of string and the ith value of string is equals to the jth value of string then i will be decremented and j incremented and finally return the value that is (j-i+1)."
                    },
                    {
                        "username": "allgameaimbotall",
                        "content": "Hi I haven't studied Dynamic Programming till now but learned a littlebit about memoization. I tried to solve this problem with recursion + adding memoization .\n\nCode gives exactly what we want but off-course Time-Limit issues.\n\nJust want to ask where does this approach fail?\n\n`\ndp = {}\ndef longestPalindrome(self, s: str) -> str:\nif self.dp.get(s) != None:\n    return self.dp[s]\n\n#TRACKERS\nlenStr = len(s)\n\n#BASE\nif lenStr == 1:\n    self.dp[s] = s\n    return s\n\nif s == s[::-1]:\n    self.dp[s] = s\n    return s\nelse:\n    lp_inleft = self.longestPalindrome(s[1:])\n    lp_inright = self.longestPalindrome(s[:lenStr-1])\n    ans = max(lp_inleft,lp_inright,key=len)\n    self.dp[s] = ans\n    return ans\n        `\n\n        "
                    }
                ]
            },
            {
                "id": 1697926,
                "content": [
                    {
                        "username": "kiu2022fallMama0africa",
                        "content": " `\\nclass Solution:\\n    def longestPalindrome(self, s: str) -> str:\\n        i = 0\\n        k = len(s) - 1\\n        bool_ = True\\n        while bool_:\\n            if checkforpalindrome(s, i, i + k):\\n                return s[i:i + k + 1]\\n            if i + k + 1 > len(s) - 1:\\n                k -= 1\\n                i = 0\\n            else:\\n                i += 1\\n\\n\\ndef checkforpalindrome(s, l, r):\\n    is_Palindrome = True\\n    while l <= r:\\n        if s[l] == s[r]:\\n            l += 1\\n            r -= 1\\n        else:\\n            is_Palindrome = False\\n            break\\n    return is_Palindrome\\n`\\nwhy does this code not working?\\n\\n\\n\\n"
                    },
                    {
                        "username": "rezahssini",
                        "content": "My code returns \"cabdkac\" for s = \"aacabdkacaa\" but expected is \"aca\", I think my code working correctly, Am I wrong ? "
                    },
                    {
                        "username": "Yongbi",
                        "content": "?? \"cabdkac\" == \"cakdbac\" \\nAre you chatting or are you serious?!"
                    },
                    {
                        "username": "ritiksingla2001",
                        "content": "Java easiest solution (beginner friendly)\\n\\n\\n\\n\\nclass Solution {\\n    public String longestPalindrome(String s) {\\n        String res = \"\";\\n        int n = s.length();\\n        int reslen=0;\\n        for (int i=0;i<n;i++){\\n            // odd length sub strings \\n            int l=i,r=i;\\n            while(l>=0 && r<n && s.charAt(l)== s.charAt(r)){\\n                if ((r-l+1)>reslen){\\n                    res=s.substring(l,r+1);\\n                    reslen=r-l+1;\\n                }\\n                l-=1;\\n                r+=1;\\n            }\\n            // even length sub strings \\n            l=i;\\n            r=i+1;\\n            while(l>=0 && r<n && s.charAt(l)== s.charAt(r)){\\n                if ((r-l+1)>reslen){\\n                    res=s.substring(l,r+1);\\n                    reslen=r-l+1;\\n                }\\n                l-=1;\\n                r+=1;\\n            }\\n\\n        }\\n        return res;\\n    }\\n}\\n"
                    },
                    {
                        "username": "klanjewar037",
                        "content": "How to solve using 2 pointers?\nclass Solution {\npublic:\n    string longestPalindrome(string s) \n    {\n            string ans=\"\";\n            int n=s.size();\n            int low=0,high=n-1;\n            int first=0,last=0,cnt=0;\n            while(low<high)\n            {\n                if(s[low]!=s[high])\n                {\n                   low++;\n                   high--;\n                }\n                else if(s[low]==s[high] && cnt<2)\n                {\n                    first=low;\n                    last=high;\n                    cnt++;\n                    low++;\n                    high--;\n                }\n                else\n                {\n                    low++;\n                    high--;\n                }\n            \n\n            }\n            if(s[first]==s[last])\n            {\n                for(int i=first;i<=last;i++)\n                {\n                    ans+=s[i];\n                }\n                return ans;\n            }\n            return ans;\n\n    }\n};"
                    },
                    {
                        "username": "TalalAhmed",
                        "content": "\n                \n`\n\nTest Case\n`\n\"tscvrnsnnwjzkynzxwcltutcvvhdivtmcvwdiwnbmdyfdvdiseyxyiiurpnhuuufarbwalzysetxbaziuuywugfzzmhoessycogxgujmgvnncwacziyybryxjagesgcmqdryfbofwxhikuauulaqyiztkpgmelnoudvlobdsgharsdkzzuxouezcycsafvpmrzanrixubvojyeuhbcpkuuhkxdvldhdtpkdhpiejshrqpgsoslbkfyraqbmrwiykggdlkgvbvrficmiignctsxeqslhzonlfekxexpvnblrfatvetwasewpglimeqemdgdgmemvdsrzpgacpnrbmomngjpiklqgbbalzxiikacwwzbzapqmatqmexxqhssggsyzpnvvpmzngtljlrhrjbnxgpcjuokgxcbzxqhmitcxlzfehwfiwcmwfliedljghrvrahlcoiescsbupitckjfkrfhhfvdlweeeverrwfkujjdwtcwbbbbwctwdjjukfwrreveeewldvfhhfrkfjkctipubscseioclharvrhgjldeilfwmcwifwhefzlxctimhqxzbcxgkoujcpgxnbjrhrljltgnzmpvvnpzysggsshqxxemqtamqpazbzwwcakiixzlabbgqlkipjgnmombrnpcagpzrsdvmemgdgdmeqemilgpwesawtevtafrlbnvpxexkeflnozhlsqexstcngiimcifrvbvgkldggkyiwrmbqaryfkblsosgpqrhsjeiphdkptdhdlvdxkhuukpcbhueyjovbuxirnazrmpvfascyczeuoxuzzkdsrahgsdbolvduonlemgpktziyqaluuaukihxwfobfyrdqmcgsegajxyrbyyizcawcnnvgmjugxgocysseohmzzfguwyuuizabxtesyzlawbrafuuuhnpruiiyxyesidvdfydmbnwidwvcmtvidhvvctutlcwxznykzjwnnsnrvcst\"\n`\n\nIt gives me error of Time Limit Exceeded kindly if someone helps me to optimize my code TIA"
                    },
                    {
                        "username": "Yongbi",
                        "content": "Using two pointer or slide windows to optimize. Kind regards."
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Java, Python C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-longest-palindromic-substring-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-longest-palindromic-substring-problem-solution.html)"
                    },
                    {
                        "username": "khushal1201",
                        "content": "Any solution with O(n) complexity or lower than O(n^2) complexity?"
                    },
                    {
                        "username": "Yongbi",
                        "content": "Yes of course! "
                    },
                    {
                        "username": "fuyouwl",
                        "content": "738126387612873"
                    },
                    {
                        "username": "showtroylove",
                        "content": "If you want to solve challenging problems don\\'t waste your time here working these problems who help no one and serve no purpose.  Want real world challenges and problems that help real people with realistic problems?  If you\\'re like me an Application Developer (you code in the application stack  / space) and not a Kernel / OS Developer then head over to stackoverflow.com or similar and give those problems a crack of the whip.  Your feedback will be real, measurable, and immortalized in internet history archives to use as references on your resume and all the bloody rest of it. Cheers!"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Amen."
                    },
                    {
                        "username": "__aadi9754",
                        "content": "input string is \"aacabdkacaa\" \\nmy output is correct and it is \"aacabacaa\" it is palindromic and is longest palindromic subsequence\\nbut somehow according to the leetcode\\'s compiler the correct answer should be \"aca\""
                    },
                    {
                        "username": "showtroylove",
                        "content": "Your output is incorrect.  (intput) aacabdkacaa  != aacakdbacaa  (output) Not a palindrome. aca is in fact correct.  Check your code and try again."
                    }
                ]
            },
            {
                "id": 1695412,
                "content": [
                    {
                        "username": "kiu2022fallMama0africa",
                        "content": " `\\nclass Solution:\\n    def longestPalindrome(self, s: str) -> str:\\n        i = 0\\n        k = len(s) - 1\\n        bool_ = True\\n        while bool_:\\n            if checkforpalindrome(s, i, i + k):\\n                return s[i:i + k + 1]\\n            if i + k + 1 > len(s) - 1:\\n                k -= 1\\n                i = 0\\n            else:\\n                i += 1\\n\\n\\ndef checkforpalindrome(s, l, r):\\n    is_Palindrome = True\\n    while l <= r:\\n        if s[l] == s[r]:\\n            l += 1\\n            r -= 1\\n        else:\\n            is_Palindrome = False\\n            break\\n    return is_Palindrome\\n`\\nwhy does this code not working?\\n\\n\\n\\n"
                    },
                    {
                        "username": "rezahssini",
                        "content": "My code returns \"cabdkac\" for s = \"aacabdkacaa\" but expected is \"aca\", I think my code working correctly, Am I wrong ? "
                    },
                    {
                        "username": "Yongbi",
                        "content": "?? \"cabdkac\" == \"cakdbac\" \\nAre you chatting or are you serious?!"
                    },
                    {
                        "username": "ritiksingla2001",
                        "content": "Java easiest solution (beginner friendly)\\n\\n\\n\\n\\nclass Solution {\\n    public String longestPalindrome(String s) {\\n        String res = \"\";\\n        int n = s.length();\\n        int reslen=0;\\n        for (int i=0;i<n;i++){\\n            // odd length sub strings \\n            int l=i,r=i;\\n            while(l>=0 && r<n && s.charAt(l)== s.charAt(r)){\\n                if ((r-l+1)>reslen){\\n                    res=s.substring(l,r+1);\\n                    reslen=r-l+1;\\n                }\\n                l-=1;\\n                r+=1;\\n            }\\n            // even length sub strings \\n            l=i;\\n            r=i+1;\\n            while(l>=0 && r<n && s.charAt(l)== s.charAt(r)){\\n                if ((r-l+1)>reslen){\\n                    res=s.substring(l,r+1);\\n                    reslen=r-l+1;\\n                }\\n                l-=1;\\n                r+=1;\\n            }\\n\\n        }\\n        return res;\\n    }\\n}\\n"
                    },
                    {
                        "username": "klanjewar037",
                        "content": "How to solve using 2 pointers?\nclass Solution {\npublic:\n    string longestPalindrome(string s) \n    {\n            string ans=\"\";\n            int n=s.size();\n            int low=0,high=n-1;\n            int first=0,last=0,cnt=0;\n            while(low<high)\n            {\n                if(s[low]!=s[high])\n                {\n                   low++;\n                   high--;\n                }\n                else if(s[low]==s[high] && cnt<2)\n                {\n                    first=low;\n                    last=high;\n                    cnt++;\n                    low++;\n                    high--;\n                }\n                else\n                {\n                    low++;\n                    high--;\n                }\n            \n\n            }\n            if(s[first]==s[last])\n            {\n                for(int i=first;i<=last;i++)\n                {\n                    ans+=s[i];\n                }\n                return ans;\n            }\n            return ans;\n\n    }\n};"
                    },
                    {
                        "username": "TalalAhmed",
                        "content": "\n                \n`\n\nTest Case\n`\n\"tscvrnsnnwjzkynzxwcltutcvvhdivtmcvwdiwnbmdyfdvdiseyxyiiurpnhuuufarbwalzysetxbaziuuywugfzzmhoessycogxgujmgvnncwacziyybryxjagesgcmqdryfbofwxhikuauulaqyiztkpgmelnoudvlobdsgharsdkzzuxouezcycsafvpmrzanrixubvojyeuhbcpkuuhkxdvldhdtpkdhpiejshrqpgsoslbkfyraqbmrwiykggdlkgvbvrficmiignctsxeqslhzonlfekxexpvnblrfatvetwasewpglimeqemdgdgmemvdsrzpgacpnrbmomngjpiklqgbbalzxiikacwwzbzapqmatqmexxqhssggsyzpnvvpmzngtljlrhrjbnxgpcjuokgxcbzxqhmitcxlzfehwfiwcmwfliedljghrvrahlcoiescsbupitckjfkrfhhfvdlweeeverrwfkujjdwtcwbbbbwctwdjjukfwrreveeewldvfhhfrkfjkctipubscseioclharvrhgjldeilfwmcwifwhefzlxctimhqxzbcxgkoujcpgxnbjrhrljltgnzmpvvnpzysggsshqxxemqtamqpazbzwwcakiixzlabbgqlkipjgnmombrnpcagpzrsdvmemgdgdmeqemilgpwesawtevtafrlbnvpxexkeflnozhlsqexstcngiimcifrvbvgkldggkyiwrmbqaryfkblsosgpqrhsjeiphdkptdhdlvdxkhuukpcbhueyjovbuxirnazrmpvfascyczeuoxuzzkdsrahgsdbolvduonlemgpktziyqaluuaukihxwfobfyrdqmcgsegajxyrbyyizcawcnnvgmjugxgocysseohmzzfguwyuuizabxtesyzlawbrafuuuhnpruiiyxyesidvdfydmbnwidwvcmtvidhvvctutlcwxznykzjwnnsnrvcst\"\n`\n\nIt gives me error of Time Limit Exceeded kindly if someone helps me to optimize my code TIA"
                    },
                    {
                        "username": "Yongbi",
                        "content": "Using two pointer or slide windows to optimize. Kind regards."
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Java, Python C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-longest-palindromic-substring-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-longest-palindromic-substring-problem-solution.html)"
                    },
                    {
                        "username": "khushal1201",
                        "content": "Any solution with O(n) complexity or lower than O(n^2) complexity?"
                    },
                    {
                        "username": "Yongbi",
                        "content": "Yes of course! "
                    },
                    {
                        "username": "fuyouwl",
                        "content": "738126387612873"
                    },
                    {
                        "username": "showtroylove",
                        "content": "If you want to solve challenging problems don\\'t waste your time here working these problems who help no one and serve no purpose.  Want real world challenges and problems that help real people with realistic problems?  If you\\'re like me an Application Developer (you code in the application stack  / space) and not a Kernel / OS Developer then head over to stackoverflow.com or similar and give those problems a crack of the whip.  Your feedback will be real, measurable, and immortalized in internet history archives to use as references on your resume and all the bloody rest of it. Cheers!"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Amen."
                    },
                    {
                        "username": "__aadi9754",
                        "content": "input string is \"aacabdkacaa\" \\nmy output is correct and it is \"aacabacaa\" it is palindromic and is longest palindromic subsequence\\nbut somehow according to the leetcode\\'s compiler the correct answer should be \"aca\""
                    },
                    {
                        "username": "showtroylove",
                        "content": "Your output is incorrect.  (intput) aacabdkacaa  != aacakdbacaa  (output) Not a palindrome. aca is in fact correct.  Check your code and try again."
                    }
                ]
            },
            {
                "id": 1673923,
                "content": [
                    {
                        "username": "kiu2022fallMama0africa",
                        "content": " `\\nclass Solution:\\n    def longestPalindrome(self, s: str) -> str:\\n        i = 0\\n        k = len(s) - 1\\n        bool_ = True\\n        while bool_:\\n            if checkforpalindrome(s, i, i + k):\\n                return s[i:i + k + 1]\\n            if i + k + 1 > len(s) - 1:\\n                k -= 1\\n                i = 0\\n            else:\\n                i += 1\\n\\n\\ndef checkforpalindrome(s, l, r):\\n    is_Palindrome = True\\n    while l <= r:\\n        if s[l] == s[r]:\\n            l += 1\\n            r -= 1\\n        else:\\n            is_Palindrome = False\\n            break\\n    return is_Palindrome\\n`\\nwhy does this code not working?\\n\\n\\n\\n"
                    },
                    {
                        "username": "rezahssini",
                        "content": "My code returns \"cabdkac\" for s = \"aacabdkacaa\" but expected is \"aca\", I think my code working correctly, Am I wrong ? "
                    },
                    {
                        "username": "Yongbi",
                        "content": "?? \"cabdkac\" == \"cakdbac\" \\nAre you chatting or are you serious?!"
                    },
                    {
                        "username": "ritiksingla2001",
                        "content": "Java easiest solution (beginner friendly)\\n\\n\\n\\n\\nclass Solution {\\n    public String longestPalindrome(String s) {\\n        String res = \"\";\\n        int n = s.length();\\n        int reslen=0;\\n        for (int i=0;i<n;i++){\\n            // odd length sub strings \\n            int l=i,r=i;\\n            while(l>=0 && r<n && s.charAt(l)== s.charAt(r)){\\n                if ((r-l+1)>reslen){\\n                    res=s.substring(l,r+1);\\n                    reslen=r-l+1;\\n                }\\n                l-=1;\\n                r+=1;\\n            }\\n            // even length sub strings \\n            l=i;\\n            r=i+1;\\n            while(l>=0 && r<n && s.charAt(l)== s.charAt(r)){\\n                if ((r-l+1)>reslen){\\n                    res=s.substring(l,r+1);\\n                    reslen=r-l+1;\\n                }\\n                l-=1;\\n                r+=1;\\n            }\\n\\n        }\\n        return res;\\n    }\\n}\\n"
                    },
                    {
                        "username": "klanjewar037",
                        "content": "How to solve using 2 pointers?\nclass Solution {\npublic:\n    string longestPalindrome(string s) \n    {\n            string ans=\"\";\n            int n=s.size();\n            int low=0,high=n-1;\n            int first=0,last=0,cnt=0;\n            while(low<high)\n            {\n                if(s[low]!=s[high])\n                {\n                   low++;\n                   high--;\n                }\n                else if(s[low]==s[high] && cnt<2)\n                {\n                    first=low;\n                    last=high;\n                    cnt++;\n                    low++;\n                    high--;\n                }\n                else\n                {\n                    low++;\n                    high--;\n                }\n            \n\n            }\n            if(s[first]==s[last])\n            {\n                for(int i=first;i<=last;i++)\n                {\n                    ans+=s[i];\n                }\n                return ans;\n            }\n            return ans;\n\n    }\n};"
                    },
                    {
                        "username": "TalalAhmed",
                        "content": "\n                \n`\n\nTest Case\n`\n\"tscvrnsnnwjzkynzxwcltutcvvhdivtmcvwdiwnbmdyfdvdiseyxyiiurpnhuuufarbwalzysetxbaziuuywugfzzmhoessycogxgujmgvnncwacziyybryxjagesgcmqdryfbofwxhikuauulaqyiztkpgmelnoudvlobdsgharsdkzzuxouezcycsafvpmrzanrixubvojyeuhbcpkuuhkxdvldhdtpkdhpiejshrqpgsoslbkfyraqbmrwiykggdlkgvbvrficmiignctsxeqslhzonlfekxexpvnblrfatvetwasewpglimeqemdgdgmemvdsrzpgacpnrbmomngjpiklqgbbalzxiikacwwzbzapqmatqmexxqhssggsyzpnvvpmzngtljlrhrjbnxgpcjuokgxcbzxqhmitcxlzfehwfiwcmwfliedljghrvrahlcoiescsbupitckjfkrfhhfvdlweeeverrwfkujjdwtcwbbbbwctwdjjukfwrreveeewldvfhhfrkfjkctipubscseioclharvrhgjldeilfwmcwifwhefzlxctimhqxzbcxgkoujcpgxnbjrhrljltgnzmpvvnpzysggsshqxxemqtamqpazbzwwcakiixzlabbgqlkipjgnmombrnpcagpzrsdvmemgdgdmeqemilgpwesawtevtafrlbnvpxexkeflnozhlsqexstcngiimcifrvbvgkldggkyiwrmbqaryfkblsosgpqrhsjeiphdkptdhdlvdxkhuukpcbhueyjovbuxirnazrmpvfascyczeuoxuzzkdsrahgsdbolvduonlemgpktziyqaluuaukihxwfobfyrdqmcgsegajxyrbyyizcawcnnvgmjugxgocysseohmzzfguwyuuizabxtesyzlawbrafuuuhnpruiiyxyesidvdfydmbnwidwvcmtvidhvvctutlcwxznykzjwnnsnrvcst\"\n`\n\nIt gives me error of Time Limit Exceeded kindly if someone helps me to optimize my code TIA"
                    },
                    {
                        "username": "Yongbi",
                        "content": "Using two pointer or slide windows to optimize. Kind regards."
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Java, Python C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-longest-palindromic-substring-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-longest-palindromic-substring-problem-solution.html)"
                    },
                    {
                        "username": "khushal1201",
                        "content": "Any solution with O(n) complexity or lower than O(n^2) complexity?"
                    },
                    {
                        "username": "Yongbi",
                        "content": "Yes of course! "
                    },
                    {
                        "username": "fuyouwl",
                        "content": "738126387612873"
                    },
                    {
                        "username": "showtroylove",
                        "content": "If you want to solve challenging problems don\\'t waste your time here working these problems who help no one and serve no purpose.  Want real world challenges and problems that help real people with realistic problems?  If you\\'re like me an Application Developer (you code in the application stack  / space) and not a Kernel / OS Developer then head over to stackoverflow.com or similar and give those problems a crack of the whip.  Your feedback will be real, measurable, and immortalized in internet history archives to use as references on your resume and all the bloody rest of it. Cheers!"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Amen."
                    },
                    {
                        "username": "__aadi9754",
                        "content": "input string is \"aacabdkacaa\" \\nmy output is correct and it is \"aacabacaa\" it is palindromic and is longest palindromic subsequence\\nbut somehow according to the leetcode\\'s compiler the correct answer should be \"aca\""
                    },
                    {
                        "username": "showtroylove",
                        "content": "Your output is incorrect.  (intput) aacabdkacaa  != aacakdbacaa  (output) Not a palindrome. aca is in fact correct.  Check your code and try again."
                    }
                ]
            },
            {
                "id": 1673472,
                "content": [
                    {
                        "username": "kiu2022fallMama0africa",
                        "content": " `\\nclass Solution:\\n    def longestPalindrome(self, s: str) -> str:\\n        i = 0\\n        k = len(s) - 1\\n        bool_ = True\\n        while bool_:\\n            if checkforpalindrome(s, i, i + k):\\n                return s[i:i + k + 1]\\n            if i + k + 1 > len(s) - 1:\\n                k -= 1\\n                i = 0\\n            else:\\n                i += 1\\n\\n\\ndef checkforpalindrome(s, l, r):\\n    is_Palindrome = True\\n    while l <= r:\\n        if s[l] == s[r]:\\n            l += 1\\n            r -= 1\\n        else:\\n            is_Palindrome = False\\n            break\\n    return is_Palindrome\\n`\\nwhy does this code not working?\\n\\n\\n\\n"
                    },
                    {
                        "username": "rezahssini",
                        "content": "My code returns \"cabdkac\" for s = \"aacabdkacaa\" but expected is \"aca\", I think my code working correctly, Am I wrong ? "
                    },
                    {
                        "username": "Yongbi",
                        "content": "?? \"cabdkac\" == \"cakdbac\" \\nAre you chatting or are you serious?!"
                    },
                    {
                        "username": "ritiksingla2001",
                        "content": "Java easiest solution (beginner friendly)\\n\\n\\n\\n\\nclass Solution {\\n    public String longestPalindrome(String s) {\\n        String res = \"\";\\n        int n = s.length();\\n        int reslen=0;\\n        for (int i=0;i<n;i++){\\n            // odd length sub strings \\n            int l=i,r=i;\\n            while(l>=0 && r<n && s.charAt(l)== s.charAt(r)){\\n                if ((r-l+1)>reslen){\\n                    res=s.substring(l,r+1);\\n                    reslen=r-l+1;\\n                }\\n                l-=1;\\n                r+=1;\\n            }\\n            // even length sub strings \\n            l=i;\\n            r=i+1;\\n            while(l>=0 && r<n && s.charAt(l)== s.charAt(r)){\\n                if ((r-l+1)>reslen){\\n                    res=s.substring(l,r+1);\\n                    reslen=r-l+1;\\n                }\\n                l-=1;\\n                r+=1;\\n            }\\n\\n        }\\n        return res;\\n    }\\n}\\n"
                    },
                    {
                        "username": "klanjewar037",
                        "content": "How to solve using 2 pointers?\nclass Solution {\npublic:\n    string longestPalindrome(string s) \n    {\n            string ans=\"\";\n            int n=s.size();\n            int low=0,high=n-1;\n            int first=0,last=0,cnt=0;\n            while(low<high)\n            {\n                if(s[low]!=s[high])\n                {\n                   low++;\n                   high--;\n                }\n                else if(s[low]==s[high] && cnt<2)\n                {\n                    first=low;\n                    last=high;\n                    cnt++;\n                    low++;\n                    high--;\n                }\n                else\n                {\n                    low++;\n                    high--;\n                }\n            \n\n            }\n            if(s[first]==s[last])\n            {\n                for(int i=first;i<=last;i++)\n                {\n                    ans+=s[i];\n                }\n                return ans;\n            }\n            return ans;\n\n    }\n};"
                    },
                    {
                        "username": "TalalAhmed",
                        "content": "\n                \n`\n\nTest Case\n`\n\"tscvrnsnnwjzkynzxwcltutcvvhdivtmcvwdiwnbmdyfdvdiseyxyiiurpnhuuufarbwalzysetxbaziuuywugfzzmhoessycogxgujmgvnncwacziyybryxjagesgcmqdryfbofwxhikuauulaqyiztkpgmelnoudvlobdsgharsdkzzuxouezcycsafvpmrzanrixubvojyeuhbcpkuuhkxdvldhdtpkdhpiejshrqpgsoslbkfyraqbmrwiykggdlkgvbvrficmiignctsxeqslhzonlfekxexpvnblrfatvetwasewpglimeqemdgdgmemvdsrzpgacpnrbmomngjpiklqgbbalzxiikacwwzbzapqmatqmexxqhssggsyzpnvvpmzngtljlrhrjbnxgpcjuokgxcbzxqhmitcxlzfehwfiwcmwfliedljghrvrahlcoiescsbupitckjfkrfhhfvdlweeeverrwfkujjdwtcwbbbbwctwdjjukfwrreveeewldvfhhfrkfjkctipubscseioclharvrhgjldeilfwmcwifwhefzlxctimhqxzbcxgkoujcpgxnbjrhrljltgnzmpvvnpzysggsshqxxemqtamqpazbzwwcakiixzlabbgqlkipjgnmombrnpcagpzrsdvmemgdgdmeqemilgpwesawtevtafrlbnvpxexkeflnozhlsqexstcngiimcifrvbvgkldggkyiwrmbqaryfkblsosgpqrhsjeiphdkptdhdlvdxkhuukpcbhueyjovbuxirnazrmpvfascyczeuoxuzzkdsrahgsdbolvduonlemgpktziyqaluuaukihxwfobfyrdqmcgsegajxyrbyyizcawcnnvgmjugxgocysseohmzzfguwyuuizabxtesyzlawbrafuuuhnpruiiyxyesidvdfydmbnwidwvcmtvidhvvctutlcwxznykzjwnnsnrvcst\"\n`\n\nIt gives me error of Time Limit Exceeded kindly if someone helps me to optimize my code TIA"
                    },
                    {
                        "username": "Yongbi",
                        "content": "Using two pointer or slide windows to optimize. Kind regards."
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Java, Python C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-longest-palindromic-substring-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-longest-palindromic-substring-problem-solution.html)"
                    },
                    {
                        "username": "khushal1201",
                        "content": "Any solution with O(n) complexity or lower than O(n^2) complexity?"
                    },
                    {
                        "username": "Yongbi",
                        "content": "Yes of course! "
                    },
                    {
                        "username": "fuyouwl",
                        "content": "738126387612873"
                    },
                    {
                        "username": "showtroylove",
                        "content": "If you want to solve challenging problems don\\'t waste your time here working these problems who help no one and serve no purpose.  Want real world challenges and problems that help real people with realistic problems?  If you\\'re like me an Application Developer (you code in the application stack  / space) and not a Kernel / OS Developer then head over to stackoverflow.com or similar and give those problems a crack of the whip.  Your feedback will be real, measurable, and immortalized in internet history archives to use as references on your resume and all the bloody rest of it. Cheers!"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Amen."
                    },
                    {
                        "username": "__aadi9754",
                        "content": "input string is \"aacabdkacaa\" \\nmy output is correct and it is \"aacabacaa\" it is palindromic and is longest palindromic subsequence\\nbut somehow according to the leetcode\\'s compiler the correct answer should be \"aca\""
                    },
                    {
                        "username": "showtroylove",
                        "content": "Your output is incorrect.  (intput) aacabdkacaa  != aacakdbacaa  (output) Not a palindrome. aca is in fact correct.  Check your code and try again."
                    }
                ]
            },
            {
                "id": 1672036,
                "content": [
                    {
                        "username": "kiu2022fallMama0africa",
                        "content": " `\\nclass Solution:\\n    def longestPalindrome(self, s: str) -> str:\\n        i = 0\\n        k = len(s) - 1\\n        bool_ = True\\n        while bool_:\\n            if checkforpalindrome(s, i, i + k):\\n                return s[i:i + k + 1]\\n            if i + k + 1 > len(s) - 1:\\n                k -= 1\\n                i = 0\\n            else:\\n                i += 1\\n\\n\\ndef checkforpalindrome(s, l, r):\\n    is_Palindrome = True\\n    while l <= r:\\n        if s[l] == s[r]:\\n            l += 1\\n            r -= 1\\n        else:\\n            is_Palindrome = False\\n            break\\n    return is_Palindrome\\n`\\nwhy does this code not working?\\n\\n\\n\\n"
                    },
                    {
                        "username": "rezahssini",
                        "content": "My code returns \"cabdkac\" for s = \"aacabdkacaa\" but expected is \"aca\", I think my code working correctly, Am I wrong ? "
                    },
                    {
                        "username": "Yongbi",
                        "content": "?? \"cabdkac\" == \"cakdbac\" \\nAre you chatting or are you serious?!"
                    },
                    {
                        "username": "ritiksingla2001",
                        "content": "Java easiest solution (beginner friendly)\\n\\n\\n\\n\\nclass Solution {\\n    public String longestPalindrome(String s) {\\n        String res = \"\";\\n        int n = s.length();\\n        int reslen=0;\\n        for (int i=0;i<n;i++){\\n            // odd length sub strings \\n            int l=i,r=i;\\n            while(l>=0 && r<n && s.charAt(l)== s.charAt(r)){\\n                if ((r-l+1)>reslen){\\n                    res=s.substring(l,r+1);\\n                    reslen=r-l+1;\\n                }\\n                l-=1;\\n                r+=1;\\n            }\\n            // even length sub strings \\n            l=i;\\n            r=i+1;\\n            while(l>=0 && r<n && s.charAt(l)== s.charAt(r)){\\n                if ((r-l+1)>reslen){\\n                    res=s.substring(l,r+1);\\n                    reslen=r-l+1;\\n                }\\n                l-=1;\\n                r+=1;\\n            }\\n\\n        }\\n        return res;\\n    }\\n}\\n"
                    },
                    {
                        "username": "klanjewar037",
                        "content": "How to solve using 2 pointers?\nclass Solution {\npublic:\n    string longestPalindrome(string s) \n    {\n            string ans=\"\";\n            int n=s.size();\n            int low=0,high=n-1;\n            int first=0,last=0,cnt=0;\n            while(low<high)\n            {\n                if(s[low]!=s[high])\n                {\n                   low++;\n                   high--;\n                }\n                else if(s[low]==s[high] && cnt<2)\n                {\n                    first=low;\n                    last=high;\n                    cnt++;\n                    low++;\n                    high--;\n                }\n                else\n                {\n                    low++;\n                    high--;\n                }\n            \n\n            }\n            if(s[first]==s[last])\n            {\n                for(int i=first;i<=last;i++)\n                {\n                    ans+=s[i];\n                }\n                return ans;\n            }\n            return ans;\n\n    }\n};"
                    },
                    {
                        "username": "TalalAhmed",
                        "content": "\n                \n`\n\nTest Case\n`\n\"tscvrnsnnwjzkynzxwcltutcvvhdivtmcvwdiwnbmdyfdvdiseyxyiiurpnhuuufarbwalzysetxbaziuuywugfzzmhoessycogxgujmgvnncwacziyybryxjagesgcmqdryfbofwxhikuauulaqyiztkpgmelnoudvlobdsgharsdkzzuxouezcycsafvpmrzanrixubvojyeuhbcpkuuhkxdvldhdtpkdhpiejshrqpgsoslbkfyraqbmrwiykggdlkgvbvrficmiignctsxeqslhzonlfekxexpvnblrfatvetwasewpglimeqemdgdgmemvdsrzpgacpnrbmomngjpiklqgbbalzxiikacwwzbzapqmatqmexxqhssggsyzpnvvpmzngtljlrhrjbnxgpcjuokgxcbzxqhmitcxlzfehwfiwcmwfliedljghrvrahlcoiescsbupitckjfkrfhhfvdlweeeverrwfkujjdwtcwbbbbwctwdjjukfwrreveeewldvfhhfrkfjkctipubscseioclharvrhgjldeilfwmcwifwhefzlxctimhqxzbcxgkoujcpgxnbjrhrljltgnzmpvvnpzysggsshqxxemqtamqpazbzwwcakiixzlabbgqlkipjgnmombrnpcagpzrsdvmemgdgdmeqemilgpwesawtevtafrlbnvpxexkeflnozhlsqexstcngiimcifrvbvgkldggkyiwrmbqaryfkblsosgpqrhsjeiphdkptdhdlvdxkhuukpcbhueyjovbuxirnazrmpvfascyczeuoxuzzkdsrahgsdbolvduonlemgpktziyqaluuaukihxwfobfyrdqmcgsegajxyrbyyizcawcnnvgmjugxgocysseohmzzfguwyuuizabxtesyzlawbrafuuuhnpruiiyxyesidvdfydmbnwidwvcmtvidhvvctutlcwxznykzjwnnsnrvcst\"\n`\n\nIt gives me error of Time Limit Exceeded kindly if someone helps me to optimize my code TIA"
                    },
                    {
                        "username": "Yongbi",
                        "content": "Using two pointer or slide windows to optimize. Kind regards."
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Java, Python C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-longest-palindromic-substring-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-longest-palindromic-substring-problem-solution.html)"
                    },
                    {
                        "username": "khushal1201",
                        "content": "Any solution with O(n) complexity or lower than O(n^2) complexity?"
                    },
                    {
                        "username": "Yongbi",
                        "content": "Yes of course! "
                    },
                    {
                        "username": "fuyouwl",
                        "content": "738126387612873"
                    },
                    {
                        "username": "showtroylove",
                        "content": "If you want to solve challenging problems don\\'t waste your time here working these problems who help no one and serve no purpose.  Want real world challenges and problems that help real people with realistic problems?  If you\\'re like me an Application Developer (you code in the application stack  / space) and not a Kernel / OS Developer then head over to stackoverflow.com or similar and give those problems a crack of the whip.  Your feedback will be real, measurable, and immortalized in internet history archives to use as references on your resume and all the bloody rest of it. Cheers!"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Amen."
                    },
                    {
                        "username": "__aadi9754",
                        "content": "input string is \"aacabdkacaa\" \\nmy output is correct and it is \"aacabacaa\" it is palindromic and is longest palindromic subsequence\\nbut somehow according to the leetcode\\'s compiler the correct answer should be \"aca\""
                    },
                    {
                        "username": "showtroylove",
                        "content": "Your output is incorrect.  (intput) aacabdkacaa  != aacakdbacaa  (output) Not a palindrome. aca is in fact correct.  Check your code and try again."
                    }
                ]
            },
            {
                "id": 1671228,
                "content": [
                    {
                        "username": "kiu2022fallMama0africa",
                        "content": " `\\nclass Solution:\\n    def longestPalindrome(self, s: str) -> str:\\n        i = 0\\n        k = len(s) - 1\\n        bool_ = True\\n        while bool_:\\n            if checkforpalindrome(s, i, i + k):\\n                return s[i:i + k + 1]\\n            if i + k + 1 > len(s) - 1:\\n                k -= 1\\n                i = 0\\n            else:\\n                i += 1\\n\\n\\ndef checkforpalindrome(s, l, r):\\n    is_Palindrome = True\\n    while l <= r:\\n        if s[l] == s[r]:\\n            l += 1\\n            r -= 1\\n        else:\\n            is_Palindrome = False\\n            break\\n    return is_Palindrome\\n`\\nwhy does this code not working?\\n\\n\\n\\n"
                    },
                    {
                        "username": "rezahssini",
                        "content": "My code returns \"cabdkac\" for s = \"aacabdkacaa\" but expected is \"aca\", I think my code working correctly, Am I wrong ? "
                    },
                    {
                        "username": "Yongbi",
                        "content": "?? \"cabdkac\" == \"cakdbac\" \\nAre you chatting or are you serious?!"
                    },
                    {
                        "username": "ritiksingla2001",
                        "content": "Java easiest solution (beginner friendly)\\n\\n\\n\\n\\nclass Solution {\\n    public String longestPalindrome(String s) {\\n        String res = \"\";\\n        int n = s.length();\\n        int reslen=0;\\n        for (int i=0;i<n;i++){\\n            // odd length sub strings \\n            int l=i,r=i;\\n            while(l>=0 && r<n && s.charAt(l)== s.charAt(r)){\\n                if ((r-l+1)>reslen){\\n                    res=s.substring(l,r+1);\\n                    reslen=r-l+1;\\n                }\\n                l-=1;\\n                r+=1;\\n            }\\n            // even length sub strings \\n            l=i;\\n            r=i+1;\\n            while(l>=0 && r<n && s.charAt(l)== s.charAt(r)){\\n                if ((r-l+1)>reslen){\\n                    res=s.substring(l,r+1);\\n                    reslen=r-l+1;\\n                }\\n                l-=1;\\n                r+=1;\\n            }\\n\\n        }\\n        return res;\\n    }\\n}\\n"
                    },
                    {
                        "username": "klanjewar037",
                        "content": "How to solve using 2 pointers?\nclass Solution {\npublic:\n    string longestPalindrome(string s) \n    {\n            string ans=\"\";\n            int n=s.size();\n            int low=0,high=n-1;\n            int first=0,last=0,cnt=0;\n            while(low<high)\n            {\n                if(s[low]!=s[high])\n                {\n                   low++;\n                   high--;\n                }\n                else if(s[low]==s[high] && cnt<2)\n                {\n                    first=low;\n                    last=high;\n                    cnt++;\n                    low++;\n                    high--;\n                }\n                else\n                {\n                    low++;\n                    high--;\n                }\n            \n\n            }\n            if(s[first]==s[last])\n            {\n                for(int i=first;i<=last;i++)\n                {\n                    ans+=s[i];\n                }\n                return ans;\n            }\n            return ans;\n\n    }\n};"
                    },
                    {
                        "username": "TalalAhmed",
                        "content": "\n                \n`\n\nTest Case\n`\n\"tscvrnsnnwjzkynzxwcltutcvvhdivtmcvwdiwnbmdyfdvdiseyxyiiurpnhuuufarbwalzysetxbaziuuywugfzzmhoessycogxgujmgvnncwacziyybryxjagesgcmqdryfbofwxhikuauulaqyiztkpgmelnoudvlobdsgharsdkzzuxouezcycsafvpmrzanrixubvojyeuhbcpkuuhkxdvldhdtpkdhpiejshrqpgsoslbkfyraqbmrwiykggdlkgvbvrficmiignctsxeqslhzonlfekxexpvnblrfatvetwasewpglimeqemdgdgmemvdsrzpgacpnrbmomngjpiklqgbbalzxiikacwwzbzapqmatqmexxqhssggsyzpnvvpmzngtljlrhrjbnxgpcjuokgxcbzxqhmitcxlzfehwfiwcmwfliedljghrvrahlcoiescsbupitckjfkrfhhfvdlweeeverrwfkujjdwtcwbbbbwctwdjjukfwrreveeewldvfhhfrkfjkctipubscseioclharvrhgjldeilfwmcwifwhefzlxctimhqxzbcxgkoujcpgxnbjrhrljltgnzmpvvnpzysggsshqxxemqtamqpazbzwwcakiixzlabbgqlkipjgnmombrnpcagpzrsdvmemgdgdmeqemilgpwesawtevtafrlbnvpxexkeflnozhlsqexstcngiimcifrvbvgkldggkyiwrmbqaryfkblsosgpqrhsjeiphdkptdhdlvdxkhuukpcbhueyjovbuxirnazrmpvfascyczeuoxuzzkdsrahgsdbolvduonlemgpktziyqaluuaukihxwfobfyrdqmcgsegajxyrbyyizcawcnnvgmjugxgocysseohmzzfguwyuuizabxtesyzlawbrafuuuhnpruiiyxyesidvdfydmbnwidwvcmtvidhvvctutlcwxznykzjwnnsnrvcst\"\n`\n\nIt gives me error of Time Limit Exceeded kindly if someone helps me to optimize my code TIA"
                    },
                    {
                        "username": "Yongbi",
                        "content": "Using two pointer or slide windows to optimize. Kind regards."
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Java, Python C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-longest-palindromic-substring-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-longest-palindromic-substring-problem-solution.html)"
                    },
                    {
                        "username": "khushal1201",
                        "content": "Any solution with O(n) complexity or lower than O(n^2) complexity?"
                    },
                    {
                        "username": "Yongbi",
                        "content": "Yes of course! "
                    },
                    {
                        "username": "fuyouwl",
                        "content": "738126387612873"
                    },
                    {
                        "username": "showtroylove",
                        "content": "If you want to solve challenging problems don\\'t waste your time here working these problems who help no one and serve no purpose.  Want real world challenges and problems that help real people with realistic problems?  If you\\'re like me an Application Developer (you code in the application stack  / space) and not a Kernel / OS Developer then head over to stackoverflow.com or similar and give those problems a crack of the whip.  Your feedback will be real, measurable, and immortalized in internet history archives to use as references on your resume and all the bloody rest of it. Cheers!"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Amen."
                    },
                    {
                        "username": "__aadi9754",
                        "content": "input string is \"aacabdkacaa\" \\nmy output is correct and it is \"aacabacaa\" it is palindromic and is longest palindromic subsequence\\nbut somehow according to the leetcode\\'s compiler the correct answer should be \"aca\""
                    },
                    {
                        "username": "showtroylove",
                        "content": "Your output is incorrect.  (intput) aacabdkacaa  != aacakdbacaa  (output) Not a palindrome. aca is in fact correct.  Check your code and try again."
                    }
                ]
            },
            {
                "id": 1661814,
                "content": [
                    {
                        "username": "kiu2022fallMama0africa",
                        "content": " `\\nclass Solution:\\n    def longestPalindrome(self, s: str) -> str:\\n        i = 0\\n        k = len(s) - 1\\n        bool_ = True\\n        while bool_:\\n            if checkforpalindrome(s, i, i + k):\\n                return s[i:i + k + 1]\\n            if i + k + 1 > len(s) - 1:\\n                k -= 1\\n                i = 0\\n            else:\\n                i += 1\\n\\n\\ndef checkforpalindrome(s, l, r):\\n    is_Palindrome = True\\n    while l <= r:\\n        if s[l] == s[r]:\\n            l += 1\\n            r -= 1\\n        else:\\n            is_Palindrome = False\\n            break\\n    return is_Palindrome\\n`\\nwhy does this code not working?\\n\\n\\n\\n"
                    },
                    {
                        "username": "rezahssini",
                        "content": "My code returns \"cabdkac\" for s = \"aacabdkacaa\" but expected is \"aca\", I think my code working correctly, Am I wrong ? "
                    },
                    {
                        "username": "Yongbi",
                        "content": "?? \"cabdkac\" == \"cakdbac\" \\nAre you chatting or are you serious?!"
                    },
                    {
                        "username": "ritiksingla2001",
                        "content": "Java easiest solution (beginner friendly)\\n\\n\\n\\n\\nclass Solution {\\n    public String longestPalindrome(String s) {\\n        String res = \"\";\\n        int n = s.length();\\n        int reslen=0;\\n        for (int i=0;i<n;i++){\\n            // odd length sub strings \\n            int l=i,r=i;\\n            while(l>=0 && r<n && s.charAt(l)== s.charAt(r)){\\n                if ((r-l+1)>reslen){\\n                    res=s.substring(l,r+1);\\n                    reslen=r-l+1;\\n                }\\n                l-=1;\\n                r+=1;\\n            }\\n            // even length sub strings \\n            l=i;\\n            r=i+1;\\n            while(l>=0 && r<n && s.charAt(l)== s.charAt(r)){\\n                if ((r-l+1)>reslen){\\n                    res=s.substring(l,r+1);\\n                    reslen=r-l+1;\\n                }\\n                l-=1;\\n                r+=1;\\n            }\\n\\n        }\\n        return res;\\n    }\\n}\\n"
                    },
                    {
                        "username": "klanjewar037",
                        "content": "How to solve using 2 pointers?\nclass Solution {\npublic:\n    string longestPalindrome(string s) \n    {\n            string ans=\"\";\n            int n=s.size();\n            int low=0,high=n-1;\n            int first=0,last=0,cnt=0;\n            while(low<high)\n            {\n                if(s[low]!=s[high])\n                {\n                   low++;\n                   high--;\n                }\n                else if(s[low]==s[high] && cnt<2)\n                {\n                    first=low;\n                    last=high;\n                    cnt++;\n                    low++;\n                    high--;\n                }\n                else\n                {\n                    low++;\n                    high--;\n                }\n            \n\n            }\n            if(s[first]==s[last])\n            {\n                for(int i=first;i<=last;i++)\n                {\n                    ans+=s[i];\n                }\n                return ans;\n            }\n            return ans;\n\n    }\n};"
                    },
                    {
                        "username": "TalalAhmed",
                        "content": "\n                \n`\n\nTest Case\n`\n\"tscvrnsnnwjzkynzxwcltutcvvhdivtmcvwdiwnbmdyfdvdiseyxyiiurpnhuuufarbwalzysetxbaziuuywugfzzmhoessycogxgujmgvnncwacziyybryxjagesgcmqdryfbofwxhikuauulaqyiztkpgmelnoudvlobdsgharsdkzzuxouezcycsafvpmrzanrixubvojyeuhbcpkuuhkxdvldhdtpkdhpiejshrqpgsoslbkfyraqbmrwiykggdlkgvbvrficmiignctsxeqslhzonlfekxexpvnblrfatvetwasewpglimeqemdgdgmemvdsrzpgacpnrbmomngjpiklqgbbalzxiikacwwzbzapqmatqmexxqhssggsyzpnvvpmzngtljlrhrjbnxgpcjuokgxcbzxqhmitcxlzfehwfiwcmwfliedljghrvrahlcoiescsbupitckjfkrfhhfvdlweeeverrwfkujjdwtcwbbbbwctwdjjukfwrreveeewldvfhhfrkfjkctipubscseioclharvrhgjldeilfwmcwifwhefzlxctimhqxzbcxgkoujcpgxnbjrhrljltgnzmpvvnpzysggsshqxxemqtamqpazbzwwcakiixzlabbgqlkipjgnmombrnpcagpzrsdvmemgdgdmeqemilgpwesawtevtafrlbnvpxexkeflnozhlsqexstcngiimcifrvbvgkldggkyiwrmbqaryfkblsosgpqrhsjeiphdkptdhdlvdxkhuukpcbhueyjovbuxirnazrmpvfascyczeuoxuzzkdsrahgsdbolvduonlemgpktziyqaluuaukihxwfobfyrdqmcgsegajxyrbyyizcawcnnvgmjugxgocysseohmzzfguwyuuizabxtesyzlawbrafuuuhnpruiiyxyesidvdfydmbnwidwvcmtvidhvvctutlcwxznykzjwnnsnrvcst\"\n`\n\nIt gives me error of Time Limit Exceeded kindly if someone helps me to optimize my code TIA"
                    },
                    {
                        "username": "Yongbi",
                        "content": "Using two pointer or slide windows to optimize. Kind regards."
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Java, Python C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-longest-palindromic-substring-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-longest-palindromic-substring-problem-solution.html)"
                    },
                    {
                        "username": "khushal1201",
                        "content": "Any solution with O(n) complexity or lower than O(n^2) complexity?"
                    },
                    {
                        "username": "Yongbi",
                        "content": "Yes of course! "
                    },
                    {
                        "username": "fuyouwl",
                        "content": "738126387612873"
                    },
                    {
                        "username": "showtroylove",
                        "content": "If you want to solve challenging problems don\\'t waste your time here working these problems who help no one and serve no purpose.  Want real world challenges and problems that help real people with realistic problems?  If you\\'re like me an Application Developer (you code in the application stack  / space) and not a Kernel / OS Developer then head over to stackoverflow.com or similar and give those problems a crack of the whip.  Your feedback will be real, measurable, and immortalized in internet history archives to use as references on your resume and all the bloody rest of it. Cheers!"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Amen."
                    },
                    {
                        "username": "__aadi9754",
                        "content": "input string is \"aacabdkacaa\" \\nmy output is correct and it is \"aacabacaa\" it is palindromic and is longest palindromic subsequence\\nbut somehow according to the leetcode\\'s compiler the correct answer should be \"aca\""
                    },
                    {
                        "username": "showtroylove",
                        "content": "Your output is incorrect.  (intput) aacabdkacaa  != aacakdbacaa  (output) Not a palindrome. aca is in fact correct.  Check your code and try again."
                    }
                ]
            },
            {
                "id": 1660740,
                "content": [
                    {
                        "username": "kiu2022fallMama0africa",
                        "content": " `\\nclass Solution:\\n    def longestPalindrome(self, s: str) -> str:\\n        i = 0\\n        k = len(s) - 1\\n        bool_ = True\\n        while bool_:\\n            if checkforpalindrome(s, i, i + k):\\n                return s[i:i + k + 1]\\n            if i + k + 1 > len(s) - 1:\\n                k -= 1\\n                i = 0\\n            else:\\n                i += 1\\n\\n\\ndef checkforpalindrome(s, l, r):\\n    is_Palindrome = True\\n    while l <= r:\\n        if s[l] == s[r]:\\n            l += 1\\n            r -= 1\\n        else:\\n            is_Palindrome = False\\n            break\\n    return is_Palindrome\\n`\\nwhy does this code not working?\\n\\n\\n\\n"
                    },
                    {
                        "username": "rezahssini",
                        "content": "My code returns \"cabdkac\" for s = \"aacabdkacaa\" but expected is \"aca\", I think my code working correctly, Am I wrong ? "
                    },
                    {
                        "username": "Yongbi",
                        "content": "?? \"cabdkac\" == \"cakdbac\" \\nAre you chatting or are you serious?!"
                    },
                    {
                        "username": "ritiksingla2001",
                        "content": "Java easiest solution (beginner friendly)\\n\\n\\n\\n\\nclass Solution {\\n    public String longestPalindrome(String s) {\\n        String res = \"\";\\n        int n = s.length();\\n        int reslen=0;\\n        for (int i=0;i<n;i++){\\n            // odd length sub strings \\n            int l=i,r=i;\\n            while(l>=0 && r<n && s.charAt(l)== s.charAt(r)){\\n                if ((r-l+1)>reslen){\\n                    res=s.substring(l,r+1);\\n                    reslen=r-l+1;\\n                }\\n                l-=1;\\n                r+=1;\\n            }\\n            // even length sub strings \\n            l=i;\\n            r=i+1;\\n            while(l>=0 && r<n && s.charAt(l)== s.charAt(r)){\\n                if ((r-l+1)>reslen){\\n                    res=s.substring(l,r+1);\\n                    reslen=r-l+1;\\n                }\\n                l-=1;\\n                r+=1;\\n            }\\n\\n        }\\n        return res;\\n    }\\n}\\n"
                    },
                    {
                        "username": "klanjewar037",
                        "content": "How to solve using 2 pointers?\nclass Solution {\npublic:\n    string longestPalindrome(string s) \n    {\n            string ans=\"\";\n            int n=s.size();\n            int low=0,high=n-1;\n            int first=0,last=0,cnt=0;\n            while(low<high)\n            {\n                if(s[low]!=s[high])\n                {\n                   low++;\n                   high--;\n                }\n                else if(s[low]==s[high] && cnt<2)\n                {\n                    first=low;\n                    last=high;\n                    cnt++;\n                    low++;\n                    high--;\n                }\n                else\n                {\n                    low++;\n                    high--;\n                }\n            \n\n            }\n            if(s[first]==s[last])\n            {\n                for(int i=first;i<=last;i++)\n                {\n                    ans+=s[i];\n                }\n                return ans;\n            }\n            return ans;\n\n    }\n};"
                    },
                    {
                        "username": "TalalAhmed",
                        "content": "\n                \n`\n\nTest Case\n`\n\"tscvrnsnnwjzkynzxwcltutcvvhdivtmcvwdiwnbmdyfdvdiseyxyiiurpnhuuufarbwalzysetxbaziuuywugfzzmhoessycogxgujmgvnncwacziyybryxjagesgcmqdryfbofwxhikuauulaqyiztkpgmelnoudvlobdsgharsdkzzuxouezcycsafvpmrzanrixubvojyeuhbcpkuuhkxdvldhdtpkdhpiejshrqpgsoslbkfyraqbmrwiykggdlkgvbvrficmiignctsxeqslhzonlfekxexpvnblrfatvetwasewpglimeqemdgdgmemvdsrzpgacpnrbmomngjpiklqgbbalzxiikacwwzbzapqmatqmexxqhssggsyzpnvvpmzngtljlrhrjbnxgpcjuokgxcbzxqhmitcxlzfehwfiwcmwfliedljghrvrahlcoiescsbupitckjfkrfhhfvdlweeeverrwfkujjdwtcwbbbbwctwdjjukfwrreveeewldvfhhfrkfjkctipubscseioclharvrhgjldeilfwmcwifwhefzlxctimhqxzbcxgkoujcpgxnbjrhrljltgnzmpvvnpzysggsshqxxemqtamqpazbzwwcakiixzlabbgqlkipjgnmombrnpcagpzrsdvmemgdgdmeqemilgpwesawtevtafrlbnvpxexkeflnozhlsqexstcngiimcifrvbvgkldggkyiwrmbqaryfkblsosgpqrhsjeiphdkptdhdlvdxkhuukpcbhueyjovbuxirnazrmpvfascyczeuoxuzzkdsrahgsdbolvduonlemgpktziyqaluuaukihxwfobfyrdqmcgsegajxyrbyyizcawcnnvgmjugxgocysseohmzzfguwyuuizabxtesyzlawbrafuuuhnpruiiyxyesidvdfydmbnwidwvcmtvidhvvctutlcwxznykzjwnnsnrvcst\"\n`\n\nIt gives me error of Time Limit Exceeded kindly if someone helps me to optimize my code TIA"
                    },
                    {
                        "username": "Yongbi",
                        "content": "Using two pointer or slide windows to optimize. Kind regards."
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Java, Python C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-longest-palindromic-substring-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-longest-palindromic-substring-problem-solution.html)"
                    },
                    {
                        "username": "khushal1201",
                        "content": "Any solution with O(n) complexity or lower than O(n^2) complexity?"
                    },
                    {
                        "username": "Yongbi",
                        "content": "Yes of course! "
                    },
                    {
                        "username": "fuyouwl",
                        "content": "738126387612873"
                    },
                    {
                        "username": "showtroylove",
                        "content": "If you want to solve challenging problems don\\'t waste your time here working these problems who help no one and serve no purpose.  Want real world challenges and problems that help real people with realistic problems?  If you\\'re like me an Application Developer (you code in the application stack  / space) and not a Kernel / OS Developer then head over to stackoverflow.com or similar and give those problems a crack of the whip.  Your feedback will be real, measurable, and immortalized in internet history archives to use as references on your resume and all the bloody rest of it. Cheers!"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Amen."
                    },
                    {
                        "username": "__aadi9754",
                        "content": "input string is \"aacabdkacaa\" \\nmy output is correct and it is \"aacabacaa\" it is palindromic and is longest palindromic subsequence\\nbut somehow according to the leetcode\\'s compiler the correct answer should be \"aca\""
                    },
                    {
                        "username": "showtroylove",
                        "content": "Your output is incorrect.  (intput) aacabdkacaa  != aacakdbacaa  (output) Not a palindrome. aca is in fact correct.  Check your code and try again."
                    }
                ]
            },
            {
                "id": 1653744,
                "content": [
                    {
                        "username": "kiu2022fallMama0africa",
                        "content": " `\\nclass Solution:\\n    def longestPalindrome(self, s: str) -> str:\\n        i = 0\\n        k = len(s) - 1\\n        bool_ = True\\n        while bool_:\\n            if checkforpalindrome(s, i, i + k):\\n                return s[i:i + k + 1]\\n            if i + k + 1 > len(s) - 1:\\n                k -= 1\\n                i = 0\\n            else:\\n                i += 1\\n\\n\\ndef checkforpalindrome(s, l, r):\\n    is_Palindrome = True\\n    while l <= r:\\n        if s[l] == s[r]:\\n            l += 1\\n            r -= 1\\n        else:\\n            is_Palindrome = False\\n            break\\n    return is_Palindrome\\n`\\nwhy does this code not working?\\n\\n\\n\\n"
                    },
                    {
                        "username": "rezahssini",
                        "content": "My code returns \"cabdkac\" for s = \"aacabdkacaa\" but expected is \"aca\", I think my code working correctly, Am I wrong ? "
                    },
                    {
                        "username": "Yongbi",
                        "content": "?? \"cabdkac\" == \"cakdbac\" \\nAre you chatting or are you serious?!"
                    },
                    {
                        "username": "ritiksingla2001",
                        "content": "Java easiest solution (beginner friendly)\\n\\n\\n\\n\\nclass Solution {\\n    public String longestPalindrome(String s) {\\n        String res = \"\";\\n        int n = s.length();\\n        int reslen=0;\\n        for (int i=0;i<n;i++){\\n            // odd length sub strings \\n            int l=i,r=i;\\n            while(l>=0 && r<n && s.charAt(l)== s.charAt(r)){\\n                if ((r-l+1)>reslen){\\n                    res=s.substring(l,r+1);\\n                    reslen=r-l+1;\\n                }\\n                l-=1;\\n                r+=1;\\n            }\\n            // even length sub strings \\n            l=i;\\n            r=i+1;\\n            while(l>=0 && r<n && s.charAt(l)== s.charAt(r)){\\n                if ((r-l+1)>reslen){\\n                    res=s.substring(l,r+1);\\n                    reslen=r-l+1;\\n                }\\n                l-=1;\\n                r+=1;\\n            }\\n\\n        }\\n        return res;\\n    }\\n}\\n"
                    },
                    {
                        "username": "klanjewar037",
                        "content": "How to solve using 2 pointers?\nclass Solution {\npublic:\n    string longestPalindrome(string s) \n    {\n            string ans=\"\";\n            int n=s.size();\n            int low=0,high=n-1;\n            int first=0,last=0,cnt=0;\n            while(low<high)\n            {\n                if(s[low]!=s[high])\n                {\n                   low++;\n                   high--;\n                }\n                else if(s[low]==s[high] && cnt<2)\n                {\n                    first=low;\n                    last=high;\n                    cnt++;\n                    low++;\n                    high--;\n                }\n                else\n                {\n                    low++;\n                    high--;\n                }\n            \n\n            }\n            if(s[first]==s[last])\n            {\n                for(int i=first;i<=last;i++)\n                {\n                    ans+=s[i];\n                }\n                return ans;\n            }\n            return ans;\n\n    }\n};"
                    },
                    {
                        "username": "TalalAhmed",
                        "content": "\n                \n`\n\nTest Case\n`\n\"tscvrnsnnwjzkynzxwcltutcvvhdivtmcvwdiwnbmdyfdvdiseyxyiiurpnhuuufarbwalzysetxbaziuuywugfzzmhoessycogxgujmgvnncwacziyybryxjagesgcmqdryfbofwxhikuauulaqyiztkpgmelnoudvlobdsgharsdkzzuxouezcycsafvpmrzanrixubvojyeuhbcpkuuhkxdvldhdtpkdhpiejshrqpgsoslbkfyraqbmrwiykggdlkgvbvrficmiignctsxeqslhzonlfekxexpvnblrfatvetwasewpglimeqemdgdgmemvdsrzpgacpnrbmomngjpiklqgbbalzxiikacwwzbzapqmatqmexxqhssggsyzpnvvpmzngtljlrhrjbnxgpcjuokgxcbzxqhmitcxlzfehwfiwcmwfliedljghrvrahlcoiescsbupitckjfkrfhhfvdlweeeverrwfkujjdwtcwbbbbwctwdjjukfwrreveeewldvfhhfrkfjkctipubscseioclharvrhgjldeilfwmcwifwhefzlxctimhqxzbcxgkoujcpgxnbjrhrljltgnzmpvvnpzysggsshqxxemqtamqpazbzwwcakiixzlabbgqlkipjgnmombrnpcagpzrsdvmemgdgdmeqemilgpwesawtevtafrlbnvpxexkeflnozhlsqexstcngiimcifrvbvgkldggkyiwrmbqaryfkblsosgpqrhsjeiphdkptdhdlvdxkhuukpcbhueyjovbuxirnazrmpvfascyczeuoxuzzkdsrahgsdbolvduonlemgpktziyqaluuaukihxwfobfyrdqmcgsegajxyrbyyizcawcnnvgmjugxgocysseohmzzfguwyuuizabxtesyzlawbrafuuuhnpruiiyxyesidvdfydmbnwidwvcmtvidhvvctutlcwxznykzjwnnsnrvcst\"\n`\n\nIt gives me error of Time Limit Exceeded kindly if someone helps me to optimize my code TIA"
                    },
                    {
                        "username": "Yongbi",
                        "content": "Using two pointer or slide windows to optimize. Kind regards."
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Java, Python C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-longest-palindromic-substring-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-longest-palindromic-substring-problem-solution.html)"
                    },
                    {
                        "username": "khushal1201",
                        "content": "Any solution with O(n) complexity or lower than O(n^2) complexity?"
                    },
                    {
                        "username": "Yongbi",
                        "content": "Yes of course! "
                    },
                    {
                        "username": "fuyouwl",
                        "content": "738126387612873"
                    },
                    {
                        "username": "showtroylove",
                        "content": "If you want to solve challenging problems don\\'t waste your time here working these problems who help no one and serve no purpose.  Want real world challenges and problems that help real people with realistic problems?  If you\\'re like me an Application Developer (you code in the application stack  / space) and not a Kernel / OS Developer then head over to stackoverflow.com or similar and give those problems a crack of the whip.  Your feedback will be real, measurable, and immortalized in internet history archives to use as references on your resume and all the bloody rest of it. Cheers!"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Amen."
                    },
                    {
                        "username": "__aadi9754",
                        "content": "input string is \"aacabdkacaa\" \\nmy output is correct and it is \"aacabacaa\" it is palindromic and is longest palindromic subsequence\\nbut somehow according to the leetcode\\'s compiler the correct answer should be \"aca\""
                    },
                    {
                        "username": "showtroylove",
                        "content": "Your output is incorrect.  (intput) aacabdkacaa  != aacakdbacaa  (output) Not a palindrome. aca is in fact correct.  Check your code and try again."
                    }
                ]
            },
            {
                "id": 1643316,
                "content": [
                    {
                        "username": "kiu2022fallMama0africa",
                        "content": " `\\nclass Solution:\\n    def longestPalindrome(self, s: str) -> str:\\n        i = 0\\n        k = len(s) - 1\\n        bool_ = True\\n        while bool_:\\n            if checkforpalindrome(s, i, i + k):\\n                return s[i:i + k + 1]\\n            if i + k + 1 > len(s) - 1:\\n                k -= 1\\n                i = 0\\n            else:\\n                i += 1\\n\\n\\ndef checkforpalindrome(s, l, r):\\n    is_Palindrome = True\\n    while l <= r:\\n        if s[l] == s[r]:\\n            l += 1\\n            r -= 1\\n        else:\\n            is_Palindrome = False\\n            break\\n    return is_Palindrome\\n`\\nwhy does this code not working?\\n\\n\\n\\n"
                    },
                    {
                        "username": "rezahssini",
                        "content": "My code returns \"cabdkac\" for s = \"aacabdkacaa\" but expected is \"aca\", I think my code working correctly, Am I wrong ? "
                    },
                    {
                        "username": "Yongbi",
                        "content": "?? \"cabdkac\" == \"cakdbac\" \\nAre you chatting or are you serious?!"
                    },
                    {
                        "username": "ritiksingla2001",
                        "content": "Java easiest solution (beginner friendly)\\n\\n\\n\\n\\nclass Solution {\\n    public String longestPalindrome(String s) {\\n        String res = \"\";\\n        int n = s.length();\\n        int reslen=0;\\n        for (int i=0;i<n;i++){\\n            // odd length sub strings \\n            int l=i,r=i;\\n            while(l>=0 && r<n && s.charAt(l)== s.charAt(r)){\\n                if ((r-l+1)>reslen){\\n                    res=s.substring(l,r+1);\\n                    reslen=r-l+1;\\n                }\\n                l-=1;\\n                r+=1;\\n            }\\n            // even length sub strings \\n            l=i;\\n            r=i+1;\\n            while(l>=0 && r<n && s.charAt(l)== s.charAt(r)){\\n                if ((r-l+1)>reslen){\\n                    res=s.substring(l,r+1);\\n                    reslen=r-l+1;\\n                }\\n                l-=1;\\n                r+=1;\\n            }\\n\\n        }\\n        return res;\\n    }\\n}\\n"
                    },
                    {
                        "username": "klanjewar037",
                        "content": "How to solve using 2 pointers?\nclass Solution {\npublic:\n    string longestPalindrome(string s) \n    {\n            string ans=\"\";\n            int n=s.size();\n            int low=0,high=n-1;\n            int first=0,last=0,cnt=0;\n            while(low<high)\n            {\n                if(s[low]!=s[high])\n                {\n                   low++;\n                   high--;\n                }\n                else if(s[low]==s[high] && cnt<2)\n                {\n                    first=low;\n                    last=high;\n                    cnt++;\n                    low++;\n                    high--;\n                }\n                else\n                {\n                    low++;\n                    high--;\n                }\n            \n\n            }\n            if(s[first]==s[last])\n            {\n                for(int i=first;i<=last;i++)\n                {\n                    ans+=s[i];\n                }\n                return ans;\n            }\n            return ans;\n\n    }\n};"
                    },
                    {
                        "username": "TalalAhmed",
                        "content": "\n                \n`\n\nTest Case\n`\n\"tscvrnsnnwjzkynzxwcltutcvvhdivtmcvwdiwnbmdyfdvdiseyxyiiurpnhuuufarbwalzysetxbaziuuywugfzzmhoessycogxgujmgvnncwacziyybryxjagesgcmqdryfbofwxhikuauulaqyiztkpgmelnoudvlobdsgharsdkzzuxouezcycsafvpmrzanrixubvojyeuhbcpkuuhkxdvldhdtpkdhpiejshrqpgsoslbkfyraqbmrwiykggdlkgvbvrficmiignctsxeqslhzonlfekxexpvnblrfatvetwasewpglimeqemdgdgmemvdsrzpgacpnrbmomngjpiklqgbbalzxiikacwwzbzapqmatqmexxqhssggsyzpnvvpmzngtljlrhrjbnxgpcjuokgxcbzxqhmitcxlzfehwfiwcmwfliedljghrvrahlcoiescsbupitckjfkrfhhfvdlweeeverrwfkujjdwtcwbbbbwctwdjjukfwrreveeewldvfhhfrkfjkctipubscseioclharvrhgjldeilfwmcwifwhefzlxctimhqxzbcxgkoujcpgxnbjrhrljltgnzmpvvnpzysggsshqxxemqtamqpazbzwwcakiixzlabbgqlkipjgnmombrnpcagpzrsdvmemgdgdmeqemilgpwesawtevtafrlbnvpxexkeflnozhlsqexstcngiimcifrvbvgkldggkyiwrmbqaryfkblsosgpqrhsjeiphdkptdhdlvdxkhuukpcbhueyjovbuxirnazrmpvfascyczeuoxuzzkdsrahgsdbolvduonlemgpktziyqaluuaukihxwfobfyrdqmcgsegajxyrbyyizcawcnnvgmjugxgocysseohmzzfguwyuuizabxtesyzlawbrafuuuhnpruiiyxyesidvdfydmbnwidwvcmtvidhvvctutlcwxznykzjwnnsnrvcst\"\n`\n\nIt gives me error of Time Limit Exceeded kindly if someone helps me to optimize my code TIA"
                    },
                    {
                        "username": "Yongbi",
                        "content": "Using two pointer or slide windows to optimize. Kind regards."
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Java, Python C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-longest-palindromic-substring-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-longest-palindromic-substring-problem-solution.html)"
                    },
                    {
                        "username": "khushal1201",
                        "content": "Any solution with O(n) complexity or lower than O(n^2) complexity?"
                    },
                    {
                        "username": "Yongbi",
                        "content": "Yes of course! "
                    },
                    {
                        "username": "fuyouwl",
                        "content": "738126387612873"
                    },
                    {
                        "username": "showtroylove",
                        "content": "If you want to solve challenging problems don\\'t waste your time here working these problems who help no one and serve no purpose.  Want real world challenges and problems that help real people with realistic problems?  If you\\'re like me an Application Developer (you code in the application stack  / space) and not a Kernel / OS Developer then head over to stackoverflow.com or similar and give those problems a crack of the whip.  Your feedback will be real, measurable, and immortalized in internet history archives to use as references on your resume and all the bloody rest of it. Cheers!"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Amen."
                    },
                    {
                        "username": "__aadi9754",
                        "content": "input string is \"aacabdkacaa\" \\nmy output is correct and it is \"aacabacaa\" it is palindromic and is longest palindromic subsequence\\nbut somehow according to the leetcode\\'s compiler the correct answer should be \"aca\""
                    },
                    {
                        "username": "showtroylove",
                        "content": "Your output is incorrect.  (intput) aacabdkacaa  != aacakdbacaa  (output) Not a palindrome. aca is in fact correct.  Check your code and try again."
                    }
                ]
            }
        ]
    }
]